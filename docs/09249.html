<html>
<head>
<title>7 Git Commands That Saved My Life Atleast Once</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">至少救过我一次命的7个Git命令</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-git-commands-that-saved-my-life-once-or-forty-two-times-c76cc94244de?source=collection_archive---------1-----------------------#2021-08-03">https://betterprogramming.pub/7-git-commands-that-saved-my-life-once-or-forty-two-times-c76cc94244de?source=collection_archive---------1-----------------------#2021-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f483" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">#5 —编辑旧的提交消息</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/876a29472a17f4c11059030a5b02f82b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qsEQYdOSZldTaZw6"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@yancymin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">扬西·敏</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5e9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不知道我花了多少时间试图解决冲突，当他们彼此远离时，用master(或<a class="ae ky" href="https://github.com/github/renaming" rel="noopener ugc nofollow" target="_blank"> main now </a>作为本文中的默认示例)重新调整我的功能分支，或者用我的个人电子邮件而不是专业邮件更新几个提交的作者——说真的，我这样做了很多次。</p><p id="5746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">题目是<a class="ae ky" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> Git </a>的时候我肯定不是专家。其实我用的第一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Version_control" rel="noopener ugc nofollow" target="_blank">版本控制系统</a>是<a class="ae ky" href="https://subversion.apache.org/" rel="noopener ugc nofollow" target="_blank">Subversion(SVN)</a>——9年多前。三年后，我开始使用<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/devops/repos/tfvc/what-is-tfvc?view=azure-devops" rel="noopener ugc nofollow" target="_blank"> TFS / TFVC </a>好吧，不要紧，我们来谈谈Git那个。</p><p id="d0d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我四年前才开始专业使用Git，对终端命令一点都不熟悉。</p><p id="22ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我以前的经验是使用<a class="ae ky" href="https://tortoisesvn.net/" rel="noopener ugc nofollow" target="_blank"> TortoiseSVN </a>用户界面，我只需右键单击一些文件和文件夹并“与基础进行比较”，然后交叉手指让一切按预期工作，所以我对git的第一次尝试是尝试一些友好的用户界面工具，如<a class="ae ky" href="https://www.sourcetreeapp.com/" rel="noopener ugc nofollow" target="_blank">源代码树</a>或<a class="ae ky" href="https://desktop.github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub桌面</a>。</p><p id="6e83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一段时间一切都很顺利，但当第一个大问题出现时，我意识到，我必须搜索的任何关于复杂问题的问题，在终端上用git命令回答的次数比用git UI点击回答的次数多10倍。</p><p id="c0c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，使用UI工具并不妨碍您在情况变糟时使用终端，但在我的情况下，我更喜欢尽快开始使用终端。</p><p id="32eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我写这篇文章是希望你不需要花太多时间去解决这些情况。开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9d22" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.获取或设置用户和电子邮件变量</h1><p id="c09d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">git中的配置变量有三级:<em class="mz">本地</em>、<em class="mz">全局</em>和<em class="mz">系统</em>。第一个(如果已定义)会覆盖第二个，依此类推。通过这种方式，我们可以在计算机中进行全局配置，但如果需要的话，也可以为特定的存储库进行本地配置。</p><p id="fffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:如果你有一个局部变量，它会覆盖全局变量。</p><p id="91e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解为特定存储库配置的电子邮件，请转到存储库文件夹，分别运行每一行:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="d128" class="nf md it nb b gy ng nh l ni nj">git config user.name<br/>git config user.email</span></pre><p id="2640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在git存储库之外尝试这个命令，您可能仍然会得到一些东西，但是它将是您的全局或系统配置。</p><p id="f438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你想知道每个级别配置了什么吗？只需在<code class="fe nk nl nm nb b">config</code>命令后添加具体选项:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="1a99" class="nf md it nb b gy ng nh l ni nj">git config --system user.email<br/>git config --global user.email<br/>git config --local user.email</span></pre><ul class=""><li id="563a" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">最后一个只能在git存储库中工作。</li><li id="a071" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">通过将<code class="fe nk nl nm nb b">email</code>更改为<code class="fe nk nl nm nb b">name</code>，您可以对“名称”配置运行相同的命令。</li></ul><h2 id="24a7" class="nf md it bd me ob oc dn mi od oe dp mm li of og mo lm oh oi mq lq oj ok ms ol bi translated">如何设置这些git配置？</h2><p id="e617" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这基本上是相同的命令，但在末尾添加了值。像这样:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4411" class="nf md it nb b gy ng nh l ni nj">git config user.name "Your Name"<br/>git config user.email your_email@domain.com</span></pre><p id="e5ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在git存储库中运行这些命令，这些值将被设置为本地级别。如果您在git存储库之外，它们将被设置为全局级别。</p><p id="a87e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，但是让我们假设你主要在工作中使用你的计算机。您可以将您的专业电子邮件添加为全局配置。</p><p id="d68e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你想在你的个人git账户里自学一些东西呢？</p><p id="d5d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以设置一个特定的存储库来使用您的个人配置，而不会打乱所有其他文件夹的配置。我可能会做这样的事情:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="a2cc" class="nf md it nb b gy ng nh l ni nj">git config --global user.name "Lucas Tagliani"<br/>git config --global user.email my_professional_email@company.com</span></pre><p id="24a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的个人git存储库文件夹中，我会:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="a7b3" class="nf md it nb b gy ng nh l ni nj">git config user.email my_personal_email@freedomain.com</span></pre><p id="eaa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有更多关于<a class="ae ky" href="https://stackoverflow.com/questions/46941346/how-to-know-the-git-username-and-email-saved-during-configuration/46986131#46986131" rel="noopener ugc nofollow" target="_blank">这个堆栈的信息请参见</a>或<a class="ae ky" href="https://docs.github.com/en/get-started/getting-started-with-git/setting-your-username-in-git" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><h1 id="33ba" class="mc md it bd me mf om mh mi mj on ml mm jz oo ka mo kc op kd mq kf oq kg ms mt bi translated">2.如何更改一个或多个提交的作者(电子邮件)</h1><p id="502d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您只需要修复您上次提交的电子邮件作者，只需:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="36d4" class="nf md it nb b gy ng nh l ni nj">git commit --amend --no-edit --author="New Name&lt;new_email@free.com&gt;"</span></pre><p id="230b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后就可以用标志<code class="fe nk nl nm nb b">--force-with-lease</code>推了:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="bc0f" class="nf md it nb b gy ng nh l ni nj">git push --force-with-lease</span></pre><p id="3914" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您需要修复一个以上的最近提交，建议您遵循<a class="ae ky" href="https://confluence.atlassian.com/bitbucketserverkb/how-do-you-make-changes-on-a-specific-commit-779171729.html" rel="noopener ugc nofollow" target="_blank">这些步骤</a>。</p><p id="0413" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果您需要为几次提交修复它——就像我多次做的那样——并且您不关心您的git历史，您可以使用这个脚本:</p><p id="3f21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，它会为每次更新的提交更改git-sha。这被认为是一种非常糟糕的做法。只有在你知道风险的情况下才这么做。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4291" class="nf md it nb b gy ng nh l ni nj">#!/bin/sh<br/><br/>git filter-branch --env-filter '<br/><br/>OLD_EMAIL="your-old-email@example.com"<br/>CORRECT_NAME="Your Correct Name"<br/>CORRECT_EMAIL="your-correct-email@example.com"<br/><br/>if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]<br/>then<br/>export GIT_COMMITTER_NAME="$CORRECT_NAME"<br/>export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"<br/>fi<br/>if [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]<br/>then<br/>export GIT_AUTHOR_NAME="$CORRECT_NAME"<br/>export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"<br/>fi<br/>' --tag-name-filter cat -- --branches --tags</span></pre><p id="38b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在个人项目中运行过这个脚本几次，但是我从来没有在专业项目中运行过。小心点。如果你要用它，别忘了替换掉<code class="fe nk nl nm nb b">OLD_EMAIL</code>、<code class="fe nk nl nm nb b">CORRECT_NAME</code>和<code class="fe nk nl nm nb b">CORRECT_EMAIL</code>。</p><h1 id="4734" class="mc md it bd me mf om mh mi mj on ml mm jz oo ka mo kc op kd mq kf oq kg ms mt bi translated">3.向最后一次提交添加新的更改</h1><p id="f244" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">想象一下。你刚刚完成了你需要做的改变。你感到自信:git添加，git提交，git推送。然后你意识到某个单元测试中的一个小错误，你不想再创建一个提交来修复这个错误…</p><p id="9c0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没问题！这可能是最简单的一个了！一个简单的<code class="fe nk nl nm nb b">amend</code>就可以了。只需运行:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="fa56" class="nf md it nb b gy ng nh l ni nj">git commit --amend</span></pre><p id="74ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后将打开一个带有最后一条提交消息的文本编辑器。编辑消息，如果你想，保存并退出！完成了！</p><p id="6310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:这将重写上次提交的<code class="fe nk nl nm nb b">git-sha</code>。</p><h1 id="0f90" class="mc md it bd me mf om mh mi mj on ml mm jz oo ka mo kc op kd mq kf oq kg ms mt bi translated">4.从git日志中删除提交</h1><p id="905a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">好了，现在你已经使用git有一段时间了，并且学会了进行小规模的独立提交。它让您在寻找问题时更容易，并且您的git历史看起来也更好。</p><p id="fa42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后你从一个业务涉众那里听说最近的一个实现需要撤销。你可能会想“没问题！”因为你有小而独立的提交，但是你会怎么做呢？</p><p id="4fde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您试图只删除最后一次提交，这很容易，您只需运行:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="a91f" class="nf md it nb b gy ng nh l ni nj">git reset --hard HEAD^</span></pre><p id="4699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是假设您的git日志如下所示:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="a53d" class="nf md it nb b gy ng nh l ni nj">* 97c8db67 fix: commit 3 is correct as well<br/>* 69e04606 feat: commit 2 is correct<br/>* 9f130ee1 fix: commit 1 needs to be removed</span></pre><p id="fb48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要删除<em class="mz"> 9f130ee1 </em> <em class="mz"> git-sha </em>(“需要删除提交1”)，您可以执行交互式rebase:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e4f3" class="nf md it nb b gy ng nh l ni nj">git rebase -i HEAD~3</span></pre><p id="2740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中3是在选择要删除的提交之前要查找的提交数。然后将打开一个文本编辑器，显示以下内容:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="8817" class="nf md it nb b gy ng nh l ni nj">pick 9f130ee1 fix: commit 1 needs to be removed<br/>pick 69e04606 fix: commit 2 is correct<br/>pick 97c8db67 fix: commit 3 is correct as well</span></pre><p id="aed9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们简单地将第一行中的“pick”替换为“drop ”,然后保存文件，就完成了！<em class="mz"> 9f130ee1 </em>提交将会退出！</p><ul class=""><li id="9010" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">请注意，这与<a class="ae ky" href="https://git-scm.com/docs/git-revert" rel="noopener ugc nofollow" target="_blank"> git恢复</a>不同，它将完全删除提交，并将重写git历史记录，如果您已经推送了它，这可能是一个糟糕的做法。</li><li id="c6e7" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">如果删除的提交之后的提交依赖于删除的提交，您可能需要手动解决冲突。</li></ul><h1 id="fbfc" class="mc md it bd me mf om mh mi mj on ml mm jz oo ka mo kc op kd mq kf oq kg ms mt bi translated">5.编辑旧的提交消息</h1><p id="7524" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您刚刚注意到一些提交消息中的一些拼写错误的单词，并且想要修复它们。</p><p id="47f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与上一个技巧非常相似，您可以运行:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9c77" class="nf md it nb b gy ng nh l ni nj">git rebase --interactive HEAD~3</span></pre><p id="b951" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等到文本编辑器打开，用“reword”替换“pick ”,然后保存并退出。</p><p id="9278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<a class="ae ky" href="https://git-scm.com/docs/git-rebase" rel="noopener ugc nofollow" target="_blank"> git rebase </a>可以做很多事情，编辑旧的提交消息就是其中之一。使用<code class="fe nk nl nm nb b">git rebase --interactive</code> <a class="ae ky" href="https://docs.github.com/en/get-started/using-git/using-git-rebase-on-the-command-line" rel="noopener ugc nofollow" target="_blank">在这里</a>寻找更多选项。</p><h1 id="62cf" class="mc md it bd me mf om mh mi mj on ml mm jz oo ka mo kc op kd mq kf oq kg ms mt bi translated">6.如何从缺省分支重新建立基础</h1><p id="aa1f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我将主分支重置为我的<code class="fe nk nl nm nb b">feature-branch</code>时，我从<a class="ae ky" href="https://www.linkedin.com/in/tiago-alves-marek-3b8aaa79/" rel="noopener ugc nofollow" target="_blank"> Tiago Marek </a>那里学到了一个非常快速但有用的技巧:避免著名的合并提交，看起来像<em class="mz">“在我们的git历史上合并分支‘main’…</em>”。</p><p id="44e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不用点击一个非常诱人的按钮<em class="mz"> </em>叫做“更新分支”或者只是使用<code class="fe nk nl nm nb b">git pull origin main</code>，从你的<code class="fe nk nl nm nb b">feature-branch</code>你可以:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0fc9" class="nf md it nb b gy ng nh l ni nj">git pull --rebase origin main</span></pre><p id="b3de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将基本上:</p><ol class=""><li id="95d4" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu or nt nu nv bi translated">撤消本地提交</li><li id="455b" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu or nt nu nv bi translated">从远程获取提交</li><li id="3253" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu or nt nu nv bi translated">添加您的本地提交</li></ol><p id="5671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有任何git冲突，您将被要求在推送之前解决它们。</p><h1 id="2c85" class="mc md it bd me mf om mh mi mj on ml mm jz oo ka mo kc op kd mq kf oq kg ms mt bi translated">7.获取两次提交之间的日志</h1><p id="b259" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我在排除故障时学到的另一个快速技巧(这次是从<a class="ae ky" href="https://www.linkedin.com/in/thayseonofrio/" rel="noopener ugc nofollow" target="_blank"> Thayse Onofrio </a>那里学到的)是如何在两次不同的提交之间获取git日志。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="917c" class="nf md it nb b gy ng nh l ni nj">g<!-- -->it log --oneline 5a984958..49a7891a</span></pre><p id="d04d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于查看应用程序最后部署的版本与以前部署的版本之间的差异非常有用。如果您的情况是这样，您也可以使用Github:</p><p id="3bcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/user/your_repository/compare/5a984958..49a7891a" rel="noopener ugc nofollow" target="_blank">https://github.com/user/your_repository/compare/5a984958..49a7891a </a></p><ul class=""><li id="28e6" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">如果你把“..”在上面的链接上有“…”，你会有一个稍微不同的看法。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="280e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="4412" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些是多次“拯救”我的命令。如果你有任何补充、询问或评论，请告诉我。感谢阅读。</p></div></div>    
</body>
</html>