<html>
<head>
<title>6 Ways to Speed Up Your Vue.js Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加速Vue.js应用程序的6种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-ways-to-speed-up-your-vue-js-application-2673a6f1cde4?source=collection_archive---------1-----------------------#2020-09-02">https://betterprogramming.pub/6-ways-to-speed-up-your-vue-js-application-2673a6f1cde4?source=collection_archive---------1-----------------------#2020-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cde4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一份清单，你可以用它来确保你的Vue应用快如闪电</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/003800f489da67384337c9e3c00e5900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LXRekNtjnINqHeH1dFVqvw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">凯文·巴加特在<a class="ae ku" href="https://unsplash.com/s/photos/website?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7f08" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果你曾经使用过Google的Pagespeed Insights或者Google Lighthouse，那么你会看到这个网页性能评估:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lr"><img src="../Images/5cffe79a4113150019882782a9762643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UzMBfW8YlXv39Mc9vfKt6Q.png"/></div></div></figure><p id="56c3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你会收到一组统计数据，然后对你的网站的速度进行诊断。</p><p id="09d2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">有些诊断非常有用，可以指出一些简单的修复、未使用的文件，以及缓慢或占用大量空间的请求。</p><p id="9eaa" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">其他诊断，如主线程工作和Javascript执行时间确实显示了问题，但它们并不能真正帮助您解决问题。</p><p id="91b4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在本文中，我将详细介绍确保Vue应用程序尽快运行的步骤。通过这些步骤，您将确切地知道要修复什么，而不必猜测任何事情。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="fc5c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">1.仅更新需要的内容</h1><p id="d62b" class="pw-post-body-paragraph kv kw it kx b ky mv ju la lb mw jx ld le mx lg lh li my lk ll lm mz lo lp lq im bi translated">使用VueJS可能遇到的最糟糕的问题之一是过多地渲染相同的元素或元素列表。为了理解为什么或如何发生这种情况，我们必须了解Vue的反应性。</p><p id="a6a0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这个例子来自官方的Vue.js文档，它显示了哪些属性是反应性的，哪些不是。Vue中有许多反应性元素:分配给数据对象的属性、计算属性或依赖于反应性属性的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e9e6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但是普通的JavaScript代码，比如<code class="fe nc nd ne nf b">{{ 'value' }}</code>或<code class="fe nc nd ne nf b">{{ new Date() }}</code>，Vue不会将其作为一个反应性属性进行跟踪。</p><p id="4a56" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">那么反应性和复制渲染有什么关系呢？</p><p id="1837" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">假设您的<code class="fe nc nd ne nf b">data</code>对象中有一个这样的对象数组:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="eceb" class="nk me it nf b gy nl nm l nn no">values: [{id: 1, t: 'a'}, {id: 2, t: 'b'}]</span></pre><p id="8020" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你用<code class="fe nc nd ne nf b">v-for</code>渲染它:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="d787" class="nk me it nf b gy nl nm l nn no">&lt;div v-for="value in values" :key="value.id"&gt;{{ value.t }}&lt;/div&gt;</span></pre><p id="0097" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当一个新元素被添加到列表中时，Vue将重新呈现整个列表。不服气？试着这样写:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="3732" class="nk me it nf b gy nl nm l nn no">&lt;div v-for="value in values" :key="value.id"&gt;<br/>  {{ value.t }}<br/>  {{ new Date() }}<br/>&lt;/div&gt;</span></pre><p id="b89f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">JavaScript <code class="fe nc nd ne nf b">Date</code>对象不是被动的，所以它不会影响渲染。只有当元素必须再次呈现时，才会调用它。在这个例子中，你将会看到，每次从<code class="fe nc nd ne nf b">values</code>中添加或删除一个值，一个新的日期将会出现在所有呈现的元素上。</p><p id="8609" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在一个更优化的页面中你应该期待什么？您应该只期望新的或改变的元素显示一个新的<code class="fe nc nd ne nf b">Date</code>，而其他元素根本不应该被呈现。</p><p id="985a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">那么，<code class="fe nc nd ne nf b">key</code>是做什么的，为什么我们要通过它呢？属性帮助Vue理解哪个元素是哪个。如果数组的顺序改变了，<code class="fe nc nd ne nf b">key</code>会帮助Vue将元素重新排列到位，而不是一个一个地重新排列。</p><p id="a201" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">指定一个<code class="fe nc nd ne nf b">key</code>很重要，但这还不够。为了确保您获得最佳性能，您需要创建<code class="fe nc nd ne nf b">Child</code>组件。没错，解决方案非常简单。你只需要把你的Vue应用分成小的、轻量级的组件。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="a4c0" class="nk me it nf b gy nl nm l nn no">&lt;item :itemValue="value" v-for="item in items" :key="item.id"&gt;&lt;/item&gt;</span></pre><p id="4e34" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">仅当特定项目发生反应性变化时，该项目组件才会更新(例如使用<a class="ae ku" href="https://vuejs.org/v2/api/#Vue-set" rel="noopener ugc nofollow" target="_blank"> Vue.set </a>)</p><p id="1f54" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">使用组件呈现列表的性能提升是巨大的。如果在数组中添加或删除了一个元素，Vue不会再一个接一个地渲染所有的组件。如果数组是排序的，Vue只是依靠提供的<code class="fe nc nd ne nf b">key</code>来打乱元素。</p><p id="bbfd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果组件真的很轻量级，你可以做得更好。您可以传递类似于<code class="fe nc nd ne nf b">:itemText="value.t”</code>的原始属性(字符串或数字),而不是传递类似于<code class="fe nc nd ne nf b">value</code>的完整对象。这样一来，<code class="fe nc nd ne nf b">&lt;item&gt; </code>只有在您传递的原始值发生变化时才会被重新渲染。这意味着即使是被动的变化也会导致更新——但这是不必要的！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ac2a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">2.消除重复渲染</h1><p id="c7c0" class="pw-post-body-paragraph kv kw it kx b ky mv ju la lb mw jx ld le mx lg lh li my lk ll lm mz lo lp lq im bi translated">不必要地多次呈现完整列表或重元素是一个相当狡猾的问题，但这很容易发生。</p><p id="cb38" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">假设您有一个组件，它在数据对象中有一个<code class="fe nc nd ne nf b">entities</code>属性。</p><p id="c23f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果您遵循前面的步骤，那么您可能有一个子组件来呈现每个实体。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="9711" class="nk me it nf b gy nl nm l nn no">&lt;entity :entity="entity" v-for="entity in entities" :key="entity.id" /&gt;</span></pre><p id="9b93" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">实体模板如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c30d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">它输出<code class="fe nc nd ne nf b">entity.value</code>，但也从<code class="fe nc nd ne nf b">vuex</code>状态使用<code class="fe nc nd ne nf b">user</code>。现在假设您有一个<code class="fe nc nd ne nf b">auth</code>函数来刷新用户令牌，或者全局用户属性以任何方式被更改。这将导致整个视图随时更新，即使<code class="fe nc nd ne nf b">user.status</code>保持不变！</p><p id="bfab" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">有几种方法可以处理。一个简单的方法是将<code class="fe nc nd ne nf b">user.status</code>值作为<code class="fe nc nd ne nf b">userStatus</code>道具从父节点传递。如果值不变，Vue不会再次渲染它，因为它不需要。</p><p id="5776" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这里的关键是要意识到渲染的依赖性。任何改变的属性、数据值或计算值都会导致重新渲染。</p><p id="c58d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如何识别重复的渲染？</p><p id="0871" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先下载官方<a class="ae ku" href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=en" rel="noopener ugc nofollow" target="_blank"> Vue.js开发工具</a>！</p><p id="27e8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后使用“性能选项卡”来衡量您的Vue应用程序的性能。按start和stop运行性能检查，最好是在应用程序加载期间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi np"><img src="../Images/b1a15176e8e93832cbf81aa306113d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uRo4r7Rbncqnrx8dbhVCtw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">Vue.js开发工具截图</p></figure><p id="7759" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后转到“组件渲染”选项卡。如果您的页面呈现100个组件，那么您应该会看到100个<code class="fe nc nd ne nf b">created</code>事件。</p><p id="23d7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这里需要注意的是<code class="fe nc nd ne nf b">updated</code>事件。如果更新的事件比创建的事件多，而实际值没有更新，很可能是重复的更改导致了重复的渲染。</p><p id="8fe0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果您的代码多次更改<code class="fe nc nd ne nf b">entities</code>值，而不是批量更新，就会发生这种情况。或者，如果您使用Firestore之类的实时数据库，并且获得了比预期更多的快照，也会发生这种情况。(Firestore可以在每次更新时发送许多快照，尤其是如果您有更新相关文档的Firestore触发器)。</p><p id="d2ce" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这里的解决方案是避免不必要地多次更改实体。对于Firestore快照，您可以使用去抖或节流功能来避免过于频繁地更改<code class="fe nc nd ne nf b">entities</code>属性。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="20a7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">3.优化事件处理</h1><p id="ebb1" class="pw-post-body-paragraph kv kw it kx b ky mv ju la lb mw jx ld le mx lg lh li my lk ll lm mz lo lp lq im bi translated">不是所有的事件都是平等的，因此你必须确保你对每个事件都进行了正确的优化。</p><p id="5e46" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">两个很好的例子是<code class="fe nc nd ne nf b">@mouseover</code>和<code class="fe nc nd ne nf b">window.scroll</code>事件。即使在正常使用的情况下，这两种类型的事件也可能被触发多次。如果您现有的事件处理程序进行高成本的计算，这些计算将每秒运行多次，导致您的应用程序延迟。一种解决方案是使用去抖功能来限制处理这些事件的次数。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f613" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">4.移除或减少慢速组件</h1><p id="608c" class="pw-post-body-paragraph kv kw it kx b ky mv ju la lb mw jx ld le mx lg lh li my lk ll lm mz lo lp lq im bi translated">当您自己创建新组件时，尤其是导入第三方组件时，您需要确保它们运行良好。</p><p id="5af4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">您可以使用Vue.js开发工具的“性能”选项卡来估计您正在使用的每个组件的渲染时间。当添加一个新的组件时，你可以看到与你自己的组件相比渲染花费了多少时间。</p><p id="025e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果新组件比您自己的组件花费更多的时间，那么您可能需要寻找替代组件，删除它，或者尝试减少它的使用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nq"><img src="../Images/f5c943e46e307f4e376c5da5ea021a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SLEt6zuG1eYEhKfq9Fxw4A.png"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="93b1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">5.渲染一次</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nr"><img src="../Images/1c2fa980320cc484cb5789b7ec0d4277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6PL_PU-Dg-UHrIPZutTLfw.png"/></div></div></figure><p id="b988" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是来自Vue.js官方文档。如果你有一些元素，一旦所有的东西都被挂载了，那么你可以使用v-once指令。</p><p id="61b4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">假设您的应用程序中有一部分要求数据在整个会话期间不发生变化。通过使用v-once指令，可以确保这个部分只呈现一次。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="532e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">6.虚拟滚动</h1><p id="bffd" class="pw-post-body-paragraph kv kw it kx b ky mv ju la lb mw jx ld le mx lg lh li my lk ll lm mz lo lp lq im bi translated">这是优化Vue应用性能的最后一步。你曾经在桌面上滚动过脸书吗？(或者Twitter，或者Instagram，或者任何流行的社交媒体应用？)我打赌你有！你可以无休止地滚动，页面不会变慢。但是如果你有一个很大的列表要在你的Vue应用中呈现，你会看到页面越长越慢。</p><p id="85bb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果您决定实现无休止的滚动而不是分页，您可以并且应该使用这两个开源项目中的一个来实现虚拟滚动和呈现巨大的项目列表:</p><ul class=""><li id="088a" class="ns nt it kx b ky kz lb lc le nu li nv lm nw lq nx ny nz oa bi translated"><a class="ae ku" href="https://github.com/tangbc/vue-virtual-scroll-list" rel="noopener ugc nofollow" target="_blank">https://github.com/tangbc/vue-virtual-scroll-list</a></li><li id="35a2" class="ns nt it kx b ky ob lb oc le od li oe lm of lq nx ny nz oa bi translated"><a class="ae ku" href="https://github.com/Akryum/vue-virtual-scroller" rel="noopener ugc nofollow" target="_blank">https://github.com/Akryum/vue-virtual-scroller</a></li></ul><p id="125f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我两种都用过，以我的经验来看,<code class="fe nc nd ne nf b">vue-virtual-scroll-list</code>更好，因为它更容易使用，并且不依赖会破坏UI的绝对位置。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b6cf" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="338b" class="pw-post-body-paragraph kv kw it kx b ky mv ju la lb mw jx ld le mx lg lh li my lk ll lm mz lo lp lq im bi translated">尽管本指南没有考虑所有场景，但这六种方法涵盖了Vue应用程序的许多常见性能问题。</p><p id="953b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">实现出色的前端性能比您可能意识到的更重要。开发者通常拥有比最终使用你的应用的用户更好的电脑。你的用户可能甚至不使用电脑，而是使用速度慢且过时的智能手机。</p><p id="3044" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因此，这取决于我们，开发人员，尽我们所能，提供最佳的用户体验。您可以使用这六种方式作为检查清单，以帮助确保您的Vue应用程序为所有用户顺利运行。</p></div></div>    
</body>
</html>