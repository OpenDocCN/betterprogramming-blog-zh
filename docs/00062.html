<html>
<head>
<title>Observer vs Pub-Sub Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">观察者vs发布-订阅模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/observer-vs-pub-sub-pattern-50d3b27f838c?source=collection_archive---------1-----------------------#2017-10-29">https://betterprogramming.pub/observer-vs-pub-sub-pattern-50d3b27f838c?source=collection_archive---------1-----------------------#2017-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6badb84a0c92aff1187edc4868cf3008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SGZ37XwUtBVt8JhQKGFFaQ.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@officestock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">塞巴斯蒂安·赫尔曼</a>在<a class="ae kf" href="https://unsplash.com/search/photos/interview?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b694" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我曾经在一次采访中被问到:“观察者模式和发布订阅模式的区别是什么？”</p><p id="8e60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我立刻意识到pub-sub的意思是<em class="le">发布者-订阅者</em>，然后我生动地回忆起，从《T8】 <em class="le">头一个设计模式</em>  <em class="le"> s </em>:</p><p id="8fd1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">发布者+订阅者=观察者模式。</p><p id="c783" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“我明白了，我明白了。你骗不了我。”，我想。</p><p id="48a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我带着胜利的微笑回答:“他们是一样的。”</p><p id="ee1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是面试官笑了笑，就像他得到了我，说:“不，他们不是。”我当时就想:“等等，什么？”</p><p id="4372" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我错过了什么？怎么出问题了？</p><p id="72c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我回到家，我决定通过谷歌搜索找到答案。这篇文章是关于我从那个问题中学到的。</p><p id="cdc5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在深入研究区别之前，让我们先讨论一下观察者和发布-订阅模式。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="8bf1" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">观察者设计模式</h1><p id="8382" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我想很多人都会同意我的观点，观察者设计模式是最简单的设计模式之一。我的意思是，不像其他的设计模式，当你第一次读到它的时候，你至少可以“感觉”到它的主要概念是什么。</p><blockquote class="mp mq mr"><p id="45d1" class="kg kh le ki b kj kk kl km kn ko kp kq ms ks kt ku mt kw kx ky mu la lb lc ld im bi translated">观察者模式是一种软件设计模式，其中一个名为<code class="fe mv mw mx my b">subject</code>的对象维护一个名为<code class="fe mv mw mx my b">observers</code>的依赖对象列表，并自动通知它们任何状态变化，通常是通过调用它们的方法之一— <a class="ae kf" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">维基百科定义</a></p></blockquote><p id="285b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们通俗地解释一下。</p><p id="ed9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设你正在寻找一份软件工程师的工作，并且对一家名为<em class="le"> Banana Inc. </em>的公司感兴趣</p><p id="2977" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，你联系了他们的招聘经理，给了他你的联系电话。他向你保证，如果有任何空缺，他们会让你知道。还有其他几个候选人也有兴趣。</p><p id="01f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们会让所有的候选人都知道这个空缺，如果你回复了，他们可能会进行面试。</p><p id="3cbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，这个场景与观察者设计模式有什么关系呢？</p><p id="9e89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，香蕉公司是<code class="fe mv mw mx my b">Subject</code> <strong class="ki iu">，</strong>维护所有<code class="fe mv mw mx my b">Observers</code> <strong class="ki iu"> </strong>(像你一样的候选人)和将<code class="fe mv mw mx my b">notify</code> <strong class="ki iu"> </strong>的某个<code class="fe mv mw mx my b">event</code> <strong class="ki iu"> </strong>【空缺】的观察员。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/4b7b18daefe890f25bd3a934608c0338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s1kclXywIwae86iNa7cKZQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">观察者设计模式</p></figure><p id="e30a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果您需要在软件或应用程序中实现这个场景，您可以遵循这个过程，并说您已经实现了观察者设计模式。</p><p id="6d06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我不打算通过展示任何代码示例来夸大我的文章，因为互联网上有很多可用的示例。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="49d0" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">发布-订阅(发布者-订阅者)设计模式</h1><p id="5bb5" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">是的，观察者模式中的<code class="fe mv mw mx my b">Subject</code>就像是一个<code class="fe mv mw mx my b">Publisher</code><strong class="ki iu"/>和<code class="fe mv mw mx my b">Observer</code> <strong class="ki iu"> </strong>完全可以关联到一个<code class="fe mv mw mx my b">Subscriber</code> <strong class="ki iu">。</strong></p><p id="5e18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是的，<code class="fe mv mw mx my b">Subject</code>通知<code class="fe mv mw mx my b">Observers</code>，就像<code class="fe mv mw mx my b">Publisher</code>通常通知它的订户一样。这就是为什么大多数设计模式书籍或文章使用发布者-订阅者概念来解释观察者设计模式。</p><p id="dc47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是还有另一种流行的模式叫做<em class="le">发布者-订阅者</em>，它在概念上与观察者模式非常相似。</p><p id="120b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(真正的)发布者-订阅者模式和观察者模式的主要区别在于:</p><p id="65e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在发布者-订阅者模式中，被称为<em class="le">发布者</em>的消息发送者不将消息直接发送给被称为<em class="le">订阅者</em> <strong class="ki iu">的特定接收者。</strong></p><p id="ad38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着发布者和订阅者不知道彼此的存在。</p><p id="708c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有第三个组件，叫做<em class="le">代理</em>、<em class="le">消息代理</em>或<em class="le">事件总线</em>，发布者和订阅者都知道。它过滤所有传入的消息并相应地分发它们。</p><p id="a351" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">换句话说，发布-订阅是一种用于在不同系统组件之间传递消息的模式，这些组件不知道彼此的身份。</p><p id="b00d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代理如何过滤所有消息？实际上，邮件过滤有几个过程。最流行的方法是基于主题和基于内容的方法。</p><p id="13f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不会在这条路上走得更远，但是<a class="ae kf" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern#Message_filtering" rel="noopener ugc nofollow" target="_blank">维基百科解释得很好</a>。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/9f74b266e20557011713112ead67ad9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/1*-GHFC93E4ODwNc98IE5_vA.gif"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">发布订阅模式(图片来源:<a class="ae kf" href="https://msdn.microsoft.com/en-us/library/ff649664.aspx" rel="noopener ugc nofollow" target="_blank"> MSDN博客</a>)</p></figure><p id="39af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，简而言之，这两种模式之间的主要区别如下所示:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/a26dc707627d3ad66a602ba818396bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*NcicKEqwUaI8VEc-Ejk6Dg.jpeg"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">图片来源:<a class="ae kf" href="http://developers-club.com/posts/270339/" rel="noopener ugc nofollow" target="_blank">开发者俱乐部</a></p></figure><p id="c324" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有道理？</p><p id="2268" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们总结一下不同之处:</p><ul class=""><li id="960a" class="ng nh it ki b kj kk kn ko kr ni kv nj kz nk ld nl nm nn no bi translated">在观察者模式中，观察者知道<code class="fe mv mw mx my b">Subject</code>。<code class="fe mv mw mx my b">Subject</code>维护着<code class="fe mv mw mx my b">Observers</code>的记录。然而，在发布者-订阅者中，发布者和订阅者不需要相互了解。它们只是在消息队列或代理的帮助下进行通信。</li><li id="e285" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">在发布者-订阅者模式中，组件是松散耦合的，与观察者<strong class="ki iu"> </strong>模式相反。</li><li id="8b89" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">观察者模式大部分是同步实现的<em class="le"/>，即<code class="fe mv mw mx my b">Subject</code>在事件发生时调用其所有观察者的适当方法。发布者-订阅者模式主要是异步实现的<em class="le"/>(使用消息队列)。</li><li id="04ff" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">观察者<strong class="ki iu"> </strong>模式需要在单应用程序地址空间中实现。另一方面，发布者-订阅者模式更像是一种跨应用程序的模式。</li></ul><p id="69c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管这些模式之间存在差异，但有些人可能会说发布者-订阅者模式是观察者模式的变体，因为它们在概念上有相似之处。</p><p id="679e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们不一定是错的；他们很相似，不是吗？</p><p id="d3cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好了，暂时就这些了。希望你能明白。感谢阅读这篇文章。请让我知道是否有任何错误或是否需要任何修改。提前感谢。</p></div></div>    
</body>
</html>