<html>
<head>
<title>Learn Solidity: Events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习可靠性:事件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-solidity-events-2801d6a99a92?source=collection_archive---------1-----------------------#2021-01-13">https://betterprogramming.pub/learn-solidity-events-2801d6a99a92?source=collection_archive---------1-----------------------#2021-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e565" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用事件进行日志记录</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/959f8021333f91a657693bcc5840986d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JsYhZcMXqvr3mvHbY_uCeg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@axville?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">伊曼纽尔</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="1757" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎阅读Learn Solidity系列的另一篇文章，这篇文章旨在向您介绍<a class="ae kv" href="https://ethereum.org/en/" rel="noopener ugc nofollow" target="_blank">以太坊</a>编程。</p><p id="334a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://medium.com/better-programming/build-your-first-dapp-with-web3-js-9a7306d16a61" rel="noopener">上一篇文章</a>中，我们已经看到了如何使用<a class="ae kv" href="https://web3js.readthedocs.io/en/v1.3.0/" rel="noopener ugc nofollow" target="_blank"> web3.js </a>来构建一个dapp。在今天的文章中，我们将看到如何使用web3.js从区块链读取事件。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="e1ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Solidity中的事件就像您在其他语言中使用的日志功能一样，只是日志不是记录到控制台或文件中，而是保存在以太坊区块链中。在以下几节中，我们将看到:</p><ul class=""><li id="4da5" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated">如何声明和触发事件</li><li id="d6bf" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">什么是<code class="fe mn mo mp mq b">logsBloom</code>以及它如何帮助有效搜索区块链</li><li id="e1c4" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">如何解读区块链的一个事件</li><li id="bff0" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">如何订阅活动</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a53d" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">如何声明和触发事件</h1><p id="9a70" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">为了声明事件，您需要使用以下语法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f7db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事件的定义包含事件的名称和触发事件时要保存的参数。</p><p id="52f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦声明了事件，就可以从函数中发出事件，如下所示:</p><pre class="kg kh ki kj gt nq mq nr ns aw nt bi"><span id="988d" class="nu ms iq mq b gy nv nw l nx ny">emit MyEvent(block.timestamp, 'hello');</span></pre><p id="bb00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们构建一个例子来看看这实际上是如何工作的。</p><p id="b483" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的终端中，创建一个新目录并使用<code class="fe mn mo mp mq b">truffle init</code>构建一个新的truffle项目。使用您最喜欢的代码编辑器打开项目，在contracts文件夹中创建一个名为<code class="fe mn mo mp mq b">EventExample.sol</code>的新合同，然后复制粘贴以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3445" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建相应的迁移文件<code class="fe mn mo mp mq b">2_deploy_eventExample.js</code>:</p><pre class="kg kh ki kj gt nq mq nr ns aw nt bi"><span id="6039" class="nu ms iq mq b gy nv nw l nx ny">const EventExample = artifacts.require("EventExample");</span><span id="fb63" class="nu ms iq mq b gy nz nw l nx ny">module.exports = function (deployer) {<br/>   deployer.deploy(EventExample);<br/>};</span></pre><p id="3aad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们使用<code class="fe mn mo mp mq b">truffle migrate</code>来部署契约，但是在迁移之前，不要忘记编辑您的<code class="fe mn mo mp mq b">truffle-config.js</code>文件来配置网络和编译器。</p><p id="d0fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的终端中，使用<code class="fe mn mo mp mq b">truffle console</code>启动松露控制台。<br/>我们将调用<code class="fe mn mo mp mq b">storeData</code>函数并检查创建的事务的日志。让我们从获取已部署契约的实例开始:</p><pre class="kg kh ki kj gt nq mq nr ns aw nt bi"><span id="6ad4" class="nu ms iq mq b gy nv nw l nx ny">let eventExample = await EventExample.deployed()</span></pre><p id="0951" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以使用以下方式调用该函数:</p><pre class="kg kh ki kj gt nq mq nr ns aw nt bi"><span id="63a9" class="nu ms iq mq b gy nv nw l nx ny">let tx = await eventExample.storeData(10)</span></pre><p id="6eb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果打印事务接收日志<code class="fe mn mo mp mq b">tx.receipt.rawLogs</code>的内容，它存储了事务执行期间发生的触发事件的数组，您将得到一个包含一个对象的数组，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/70bd1b58332986be96a28072d43f4388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QOpaJA-IZf353U7U5Ddhgg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">事项登记</p></figure><p id="657e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以看到事件数据以十六进制存储在数据字段下。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="2369" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">logsBloom如何帮助<strong class="ak">高效搜索区块链</strong></h1><p id="1a84" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">为了有效地扫描区块链以查找具有特定数据的事件，您可以在想要用来过滤区块链中记录的事件的事件数据前添加<code class="fe mn mo mp mq b">indexed</code>关键字。</p><pre class="kg kh ki kj gt nq mq nr ns aw nt bi"><span id="570c" class="nu ms iq mq b gy nv nw l nx ny">event DataStored(uint256 data1, uint256 indexed data2)</span></pre><p id="be0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在刚刚构建的示例中尝试一下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e42b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您需要使用<code class="fe mn mo mp mq b">migrate --reset</code>重新部署合同。</p><p id="59dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重复前面相同的步骤，获取已部署契约的实例，并调用<code class="fe mn mo mp mq b">storeData</code>函数:</p><pre class="kg kh ki kj gt nq mq nr ns aw nt bi"><span id="fc58" class="nu ms iq mq b gy nv nw l nx ny">&gt; eventExample = await EventExample.deployed()<br/>&gt; tx = await eventExample.storeData(10, 15)</span></pre><p id="0264" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后考察<code class="fe mn mo mp mq b">tx.receipt.rawLogs</code>。您将看到以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/582483e3da241349aea1c198c178c3e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4_0eiTVQZzWuUnouRlstNQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">事项登记</p></figure><p id="8475" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mn mo mp mq b">data1</code>字段显示在<code class="fe mn mo mp mq b">data</code>下，而索引字段<code class="fe mn mo mp mq b">data2</code>显示在<code class="fe mn mo mp mq b">topics</code>字段下。通常，索引参数放在<code class="fe mn mo mp mq b">topics</code>下，非索引参数放在<code class="fe mn mo mp mq b">data</code>下。</p><p id="1ce3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个主题是事件签名的散列，在<a class="ae kv" href="https://docs.soliditylang.org/en/v0.8.0/abi-spec.html#events" rel="noopener ugc nofollow" target="_blank">可靠性文档</a>中有描述:</p><blockquote class="oc od oe"><p id="7191" class="kw kx of ky b kz la jr lb lc ld ju le og lg lh li oh lk ll lm oi lo lp lq lr ij bi translated"><code class="fe mn mo mp mq b">topics[0]</code> : <code class="fe mn mo mp mq b">keccak(EVENT_NAME+"("+EVENT_ARGS.map(canonical_type_of).join(",")+")")</code> <br/> ( <code class="fe mn mo mp mq b">canonical_type_of</code>是一个简单地返回给定参数的规范类型的函数，例如对于<code class="fe mn mo mp mq b">uint indexed foo</code>，它将返回<code class="fe mn mo mp mq b">uint256</code>)。如果事件被声明为<code class="fe mn mo mp mq b">anonymous</code>，则不产生<code class="fe mn mo mp mq b">topics[0]</code>；</p></blockquote><p id="d271" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>一个事件中最多可以索引三个参数。</p><p id="ee8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个块头包含一个名为<code class="fe mn mo mp mq b">logsBloom</code>的字段，这是由块的事务列表部分中每个事务的收据中包含的可索引信息(日志地址和日志主题)组成的<a class="ae kv" href="https://en.wikipedia.org/wiki/Bloom_filter" rel="noopener ugc nofollow" target="_blank">布隆过滤器</a>。</p><p id="db6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当在整个区块链或其一部分中寻找属于某个地址或包含某个数据的特定事件时，该节点检查块报头并检查每个块的布隆过滤器，以便决定该块是否包含期望的日志。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b122" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">如何从区块链中读取一个事件</h1><p id="135e" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">事件应该从区块链外部使用，这可以从前端或Node.js项目完成。</p><p id="ca0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简化客户端，我将演示如何从节点项目中读取事件。</p><p id="a5e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先在项目中创建一个名为<code class="fe mn mo mp mq b">client</code>的新文件夹，并执行以下命令:</p><pre class="kg kh ki kj gt nq mq nr ns aw nt bi"><span id="2f89" class="nu ms iq mq b gy nv nw l nx ny">&gt; npm init -y<br/>&gt; npm i web3 --save<br/>&gt; touch index.js</span></pre><p id="6604" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mn mo mp mq b">index.js</code>的内容如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="074e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用WebSocket provider代替HTTP provider，因为后者不支持订阅。</p><p id="02e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上有三种方法可以从区块链中读取事件数据:</p><ol class=""><li id="5886" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr oj mf mg mh bi translated">这是我们在之前的<code class="fe mn mo mp mq b">index.js</code>中所做的。如果执行<code class="fe mn mo mp mq b">node index.js</code>，就会得到数据和题目。</li><li id="ae86" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr oj mf mg mh bi translated">订阅活动—如web3文档的本节<a class="ae kv" href="https://web3js.readthedocs.io/en/v1.3.0/web3-eth-contract.html#events" rel="noopener ugc nofollow" target="_blank">中所述，订阅活动有三种方式:</a></li></ol><ul class=""><li id="be58" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated"><code class="fe mn mo mp mq b"><a class="ae kv" href="https://web3js.readthedocs.io/en/v1.3.0/web3-eth-contract.html#once" rel="noopener ugc nofollow" target="_blank">once</a></code>:订阅一个事件，在第一个事件或错误发生后立即退订；只会在单一事件中触发。删除<code class="fe mn mo mp mq b">index.js</code>文件中包含事务执行的代码，替换为:</li></ul><pre class="kg kh ki kj gt nq mq nr ns aw nt bi"><span id="dfb8" class="nu ms iq mq b gy nv nw l nx ny">eventExample.once("DataStored", (error, event) =&gt; {<br/>    if (!error) console.log(event);<br/>});</span></pre><p id="bcdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从您的终端，通过执行<code class="fe mn mo mp mq b">node index.js</code>启动节点项目。你不会看到任何打印出来的东西，因为它还在等待第一个<code class="fe mn mo mp mq b">DataStored</code>事件。打开另一个终端并获取部署的契约实例。然后调用<code class="fe mn mo mp mq b">storeData</code>函数。现在，您将在第一个控制台中看到打印的事件。</p><ul class=""><li id="e684" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated"><code class="fe mn mo mp mq b"><a class="ae kv" href="https://web3js.readthedocs.io/en/v1.3.0/web3-eth-contract.html#contract-events" rel="noopener ugc nofollow" target="_blank">events</a></code>:订阅活动。订阅是这样做的:<code class="fe mn mo mp mq b">myContract.events.MyEvent([options][, callback])</code>。在本例中，我们将观察包含值为5或9的<code class="fe mn mo mp mq b">data2</code>的<code class="fe mn mo mp mq b">DataStored</code>事件。</li></ul><pre class="kg kh ki kj gt nq mq nr ns aw nt bi"><span id="05ea" class="nu ms iq mq b gy nv nw l nx ny">eventExample.events<br/>   .DataStored({ filter: { data2: [5, 9] } })<br/>   .on("data", (event) =&gt; {<br/>       console.log(event);<br/>    });</span></pre><ul class=""><li id="8261" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated"><code class="fe mn mo mp mq b"><a class="ae kv" href="https://web3js.readthedocs.io/en/v1.3.0/web3-eth-contract.html#events-allevents" rel="noopener ugc nofollow" target="_blank">events.allEvents</a></code>:这与events相同，但接收来自此智能合约的所有事件。可选地，过滤器属性可以过滤那些事件。</li></ul><p id="307c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.获取以前的事件——这可以通过调用<code class="fe mn mo mp mq b"><a class="ae kv" href="https://web3js.readthedocs.io/en/v1.3.0/web3-eth-contract.html#getpastevents" rel="noopener ugc nofollow" target="_blank">getPastEvents</a></code>来完成，如下所示:<code class="fe mn mo mp mq b">myContract.getPastEvents(event[, options][, callback])</code>。文档中描述了选项的完整列表。一个重要的选项是<code class="fe mn mo mp mq b">fromBlock</code>,因为如果没有指定，您将只能获得最新块的事件。</p><pre class="kg kh ki kj gt nq mq nr ns aw nt bi"><span id="f0f4" class="nu ms iq mq b gy nv nw l nx ny">eventExample.getPastEvents("DataStored", { fromBlock: 0 }).then((events) =&gt; console.log(events));</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="fcca" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">结论</h1><p id="f9b8" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">作为进一步的阅读，你可以看看<a class="ae kv" href="https://docs.soliditylang.org/en/v0.8.0/contracts.html#events" rel="noopener ugc nofollow" target="_blank">可靠性文档</a>中的事件部分。</p><p id="922e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢这篇文章。如果有，请继续关注即将发布的文章。</p></div></div>    
</body>
</html>