# Python 中的鸭子打字和猴子打补丁是什么？

> 原文：<https://betterprogramming.pub/what-are-duck-typing-and-monkey-patching-in-python-2f8e3d6b864f>

## 我们说 Python 灵活的一个原因是

![](img/74cf5c12790bd63470f4c72aea8e8a6e.png)

照片由[艾哈迈德·扎扬](https://unsplash.com/@zayyerrn?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

这不是一篇关于动物的文章，尽管在一个标题中出现三个动物的名字并不常见。今天我想讨论一下 Python 中的鸭子打字和猴子打补丁。这两个特性对于使 Python 成为一种灵活的通用语言至关重要。

读完这篇文章后，我希望您对 Python 中的 duck 类型化和 monkey 修补是如何工作的有一个直观的想法。我们开始吧！

# 鸭子打字

对于许多程序员来说，duck typing 这个术语并不陌生——尤其是如果你有一些动态编程语言的背景知识。然而，它不是由计算机科学家发明的。我们来看看它的大致定义:

> “如果它长得像鸭子，游起来像鸭子，叫声像鸭子，那么它很可能就是鸭子。”— [维基百科](https://en.wikipedia.org/wiki/Duck_test)

这是一种溯因推理的形式，它意味着我们只根据一个人的外表和行为而不是他们的实际类型来得出我们的身份结论。在编程语言中，duck typing 代表了一种实现模式，它定义了特定对象的行为方式，而不用担心类的类型。这听起来可能太抽象了，但是用一个具体的例子，你会发现一点也不难。

首先，我们将创建一个“真正的”duck 类，作为定义鸭子行为的基准。如下所示，`Duck`类有两个实例方法— `swim()`和`quack()`(这是鸭子的两种行为):

作为`Duck`类的一个实例对象，我们可以验证一只鸭子能够像鸭子一样行动。它会游泳和嘎嘎叫。如下所示，我们首先创建`duck_testing`函数来检查一只假定的鸭子是否会游泳和嘎嘎叫。正如所料，`duck`实例做了它应该做的事情，并通过了 duck 类型测试:

您是否注意到我实际上使用内省函数`isinstance`检查了`duck`实例对象的类型？通过验证假定的 duck 是`Duck`类的一个实例，我们确信它将通过 duck 类型测试。然而，检查感兴趣的对象的类型以期望其行为是乏味的，这正是 duck typing 试图避免的。duck typing 的关键是我们不关心对象的类型。只要它会游泳，会嘎嘎叫(或者其他任何被定义的行为或方法)，我们就认为它是鸭子(或者任何被关注的类型)。

让我们看看 duck typing 如何超越我们一直在谈论的`Duck`类。为了便于对比，我将创建两个自定义类:

如上所示，`ToyDuck`类同时实现了`swim()`和`quack()`方法。因此，根据鸭分型，我们应该期待它通过鸭分型测试。另一方面，`Human`类只有`swim()`方法，因此不会通过 duck 类型测试来获得 duck 的资格。接下来让我们验证我们的预测:

不出所料，一只玩具鸭会游泳，还会嘎嘎叫，而人类只会游泳。`human`实例对象不被认为是一个类似鸭子的对象。值得注意的是，`toy_duck`和`human`对象都不是原始`Duck`类的实例对象。只是支持的行为(即游泳和呱呱)使得`toy_duck`成为一个类似鸭子的对象，并通过了鸭子类型化测试。这是实现鸭子类型的关键。

# 猴子补丁

猴子补丁这个术语有一个非常有趣的名字。根据维基百科的说法，猴子补丁可能与早期的术语“游击补丁”有关，它指的是偷偷摸摸地改变代码。鉴于游击队与大猩猩的同音关系，以及大猩猩与猴子的关系(两者都是灵长类动物)，猴子补丁就产生了。就其在编程世界中的特定概念化而言，它是这样定义的:

> “猴子补丁是程序在本地扩展或修改支持系统软件的一种方式(只影响程序的运行实例)。”— [维基百科](https://en.wikipedia.org/wiki/Monkey_patch)

作为一种动态语言，Python 允许我们通过扩展特定的模块或类在编码中使用猴子补丁，而无需修改它们的原始实现。在本节中，我们希望使`Human`类的实例(如上定义)能够像鸭子一样工作。我知道这很奇怪，但是想想唐老鸭作为一个人。

为了理解 monkey 补丁是如何机械地工作的，让我们后退一步，看看 Python 类是如何工作的。众所周知，Python 是一种面向对象的语言，它通过把一切都当作对象来操作，包括模块和类。为了提供一个概念证明，我们将只对一个定制类应用 monkey 补丁。在深入细节之前，我们先来看一个简化的 Python 类:

它绝对不是一个花哨的类，只有一个类属性和一个实例方法(如果你不了解`self`参数，请查看[这篇文章](https://medium.com/better-programming/unlock-the-4-mysteries-of-self-in-python-d1913fbb8e16))。需要注意的一点是，我们可以访问`Foo`的`__dict__`属性，它列出了这个类的所有属性，包括`attr1`和`bar`。如前所述，Python 类也是对象，这意味着我们甚至可以在运行时动态更新它们的属性。顺便说一下，这正是猴子补丁的意义所在。

正如您在上面的代码片段中看到的，我们直接为类对象设置了一个属性和一个函数。因此，更新后的 class' `__dict__`属性揭示了`attr2`和`bar2`确实是“修补”到原始类的。重要的是，我们可以像对待预定义属性一样访问`attr2`(例如`attr1`)。

既然我们知道了 monkey 补丁如何与泛型类一起工作，让我们用`Human`类来尝试一下。只是友情提示:想要的特性是让一个人体对象嘎嘎叫，这样它就能通过鸭子分型测试。重要的是，我们不会改变原来的类。如下所示，我们定义了一个名为`quack`的函数，并将该函数设置为`Human`类的`quack`属性:

需要注意的一点是，定义的`quack`函数有一个参数，看似不用，但却是必不可少的。因为`quack`函数是一个实例方法，它总会有一个引用实例对象的参数(我们在这个类中使用了`self`，但是你可以随意调用它)。如果你仍然对`self`争论感到困惑，请[查看](https://medium.com/better-programming/unlock-the-4-mysteries-of-self-in-python-d1913fbb8e16)我的[以前的文章](https://medium.com/swlh/declare-your-first-python-class-understand-3-basic-components-15768c8d35b0)。

正如你所看到的，在猴子打补丁之后，`Human`类的实例对象成功地通过了鸭子类型测试。同样，这一步不涉及改变原来的`Human`类的实现。相反，我们在类外“修补”这些特性。这就是这个动态特性的美妙之处。

# 概述

在本文中，我们回顾了 Python 中 duck 类型化和 monkey 修补的工作原理。下面是这两个术语的简要回顾:

*   Duck typing 是一种方法，可以设计一个类，使其具有所需的行为，而无需子类化或实现协议、接口或抽象基类。如果你不知道这些术语也没关系。还是可以用鸭式打字。同样，关键是实现所需行为所需的方法和属性。
*   Monkey patching 是一种扩展机制，它允许我们在不修改原始实现的情况下实现现有模块和类的附加特性。但是，请谨慎使用它，因为修补同一模块/类的代码的不同部分会因为相互影响而导致意外的行为。