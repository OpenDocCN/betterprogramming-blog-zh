<html>
<head>
<title>What You Should Consider Before Submitting That Coding Interview Task</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在提交编码面试任务之前你应该考虑什么</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-you-should-consider-before-submitting-that-coding-interview-task-a655dbb6061e?source=collection_archive---------8-----------------------#2020-03-27">https://betterprogramming.pub/what-you-should-consider-before-submitting-that-coding-interview-task-a655dbb6061e?source=collection_archive---------8-----------------------#2020-03-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="60e9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">面向初级开发人员，但不仅限于此</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3210b97a47c82779683659ed7944655e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-SO7Y2vdv8WFREff"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Tetiana SHYSHKINA 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4e2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管我们同意与否，如今大多数公司都将编码挑战作为招聘过程的一部分。</p><p id="4b84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为这些挑战做准备可能会令人困惑。从我回顾的测试中，我发现候选人经常专注于研究花哨的算法，而忽略了编码挑战中最关键的方面。</p><p id="5510" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在向面试官提交代码之前，这里有一些你需要考虑的建议。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6d0e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">字谜问题</h1><p id="e5ca" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我正在帮助我的朋友，一个初级开发人员，为技术挑战做准备。我们在做一个字谜题。这是一个常见的面试问题，面试官评估候选人对数据结构和算法的了解程度。</p><blockquote class="mz na nb"><p id="dc9b" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated"><a class="ae ky" href="https://web.stanford.edu/class/cs9/sample_probs/Anagrams.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">问题陈述:</strong> </a></p><p id="6dea" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">如果你可以通过重新排列字母将第一个字符串变成第二个字符串，那么这两个字符串就可以说是彼此的变位词。例如，“table”和“bleat”是变位词，“tear”和“rate”也是。你的工作是编写一个函数，接受两个字符串作为输入，并确定它们是否是彼此的变位组合。</p><p id="8447" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated"><strong class="lb iu">约束:</strong></p><p id="be93" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">每个字符串由ASCII[a-z]范围内的字母组成</p></blockquote><p id="64d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过了一段时间，我的朋友想出了下面的解决办法:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="9a6c" class="nl md it nh b gy nm nn l no np">public static boolean areAnagrams(string w1, string w2){</span><span id="4884" class="nl md it nh b gy nq nn l no np">char[] chr1 = w1<!-- -->.toCharArray();<br/>char[] chr2 = w2<!-- -->.toCharArray();</span><span id="18f3" class="nl md it nh b gy nq nn l no np">int[] count = new int[26];</span><span id="be95" class="nl md it nh b gy nq nn l no np">for (char ch : <!-- -->chr1<!-- -->){<br/>    count[ch - 97] = count[ch - 97] + 1;<br/>  }</span><span id="bac3" class="nl md it nh b gy nq nn l no np">for (char ch : <!-- -->chr2<!-- -->){<br/>    count[ch - 97] = count[ch - 97] - 1;<br/>  }</span><span id="bdbc" class="nl md it nh b gy nq nn l no np">for (int n : count) {<br/>    <!-- -->System.out.format("%d%n", n);</span><span id="0488" class="nl md it nh b gy nq nn l no np">if (n != 0){<br/>      return false; <br/>    }<br/>  }</span><span id="91c3" class="nl md it nh b gy nq nn l no np">return true;<br/>}</span></pre><p id="f27b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接下来的部分中，我将使用这个例子来说明我在审查初级开发人员的代码时注意到的一些技巧和常见问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="28a0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">停止使用神奇的数字</h1><p id="4dc7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">看他的代码首先跃入脑海的是那些在代码中重复出现的幻数:<code class="fe nr ns nt nh b">97</code>和<code class="fe nr ns nt nh b">26</code>。</p><p id="3e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幻数被认为是一种糟糕的编程模式，原因如下:</p><ol class=""><li id="b16a" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">除了编写代码的开发人员之外，没有人知道这些神奇的数字是什么，甚至这个开发人员也会随着时间的推移而忘记它。</li><li id="22a3" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">它们增加了出错的机会。如果有人错误地修改了第二个循环中的数字<code class="fe nr ns nt nh b">97</code>会怎么样。该代码似乎依赖于两个循环使用相同的数字这一事实。</li><li id="24b6" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">如果我们决定在将来更新这个函数，我们将不得不查找这些幻数的所有出现并更新它们。</li></ol><p id="7956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据问题陈述，我可以假设<code class="fe nr ns nt nh b">97</code>是字母<code class="fe nr ns nt nh b">a</code>的ASCII十进制代码，而<code class="fe nr ns nt nh b">26</code>是ASCII[a-z]范围内的字母数。</p><p id="5f0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题可以很容易地通过使用常数来解决。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d3b0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在命名变量时要小心</h1><p id="3530" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我朋友的例子中，他称他的变量为<code class="fe nr ns nt nh b">w1</code>和<code class="fe nr ns nt nh b">w2</code>、<code class="fe nr ns nt nh b">ch1</code>和<code class="fe nr ns nt nh b">ch2</code>、<code class="fe nr ns nt nh b">n</code>。</p><p id="2c30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nr ns nt nh b">w1</code>和<code class="fe nr ns nt nh b">w2</code>是输入——要比较的字符串。使用一个更明确的名字会使代码更容易阅读。比如<code class="fe nr ns nt nh b">first</code>和<code class="fe nr ns nt nh b">second</code>，或者<code class="fe nr ns nt nh b">word1</code>和<code class="fe nr ns nt nh b">word2</code>。</p><p id="b00f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nr ns nt nh b">ch1</code>和<code class="fe nr ns nt nh b">ch2</code>似乎是<code class="fe nr ns nt nh b">first</code>和<code class="fe nr ns nt nh b">second</code>输入的字符数组。这些也可以重命名为<code class="fe nr ns nt nh b">first_chars</code>和<code class="fe nr ns nt nh b">second_chars</code>。</p><p id="7c11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe nr ns nt nh b">count</code>应该是一个数组，它将一个索引与字母的出现次数相关联。为什么不改名为可读性更强的，比如<code class="fe nr ns nt nh b">frequencies</code>？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2cb9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">清理您的代码</h1><p id="70a6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在提交您的实现之前，请确保清除所有打印功能和<code class="fe nr ns nt nh b">console.logs</code>。</p><p id="d4f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调试你的代码是极好的，但是你不希望它被提交。它使代码变得混乱，并使审查变得困难。</p><p id="a04e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对问题或输入做出了任何假设，例如，为了缩小范围，最好在注释或自述文件中进行描述。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d763" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">修正的字谜问题</h1><p id="4765" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">考虑到前面的几点，代码看起来有点大，但是更容易阅读，并且所有的上下文都在那里。无论是谁审查它，都不需要挠头去理解它的作用。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="c3bd" class="nl md it nh b gy nm nn l no np">public static boolean areAnagrams(string first, string second){</span><span id="5bee" class="nl md it nh b gy nq nn l no np">int MAX_LETTERS = 26;<br/>int[] frequencies = new int[<!-- -->MAX_LETTERS<!-- -->];<br/>char a = 'a';</span><span id="efc4" class="nl md it nh b gy nq nn l no np">for (int i = 0; i &lt; first.length(); i++){<br/>  char c = first.charAt(i);<br/>  int offset = c - a;<br/>  <!-- -->frequencies<!-- -->[offset]++;<br/>}</span><span id="b0b5" class="nl md it nh b gy nq nn l no np">for (int i = 0; i &lt; second.length(); i++){<br/>  char c = second.charAt(i);<br/>  int offset = c - a;<br/>  <!-- -->frequencies<!-- -->[offset]--;<br/>}</span><span id="8a61" class="nl md it nh b gy nq nn l no np">for (int n : frequencies) {<br/>  if (n != 0){<br/>   return false; <br/>  }<br/>}</span><span id="4779" class="nl md it nh b gy nq nn l no np">return true;<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0fe6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">检查您的代码</h1><p id="d3de" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你设法解决了这个问题，你写了一个有效的算法。现在怎么办？</p><p id="338c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仔细检查您的实现，并尝试看看如何改进它。不可否认，从不同的角度看待你已经实现的东西并不总是容易的。如果你的挑战没有时间限制，休息一下，一小时后再回来。</p><p id="1c66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当看到我朋友的代码时，我想到的一件事是，它可以进一步优化。例如，当两个字符串没有相同数量的字母时，它们永远不会是变位词。</p><p id="e221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在遍历所有迭代之前先进行检查。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="b20e" class="nl md it nh b gy nm nn l no np">public static boolean areAnagrams(string first, string second){</span><span id="f046" class="nl md it nh b gy nq nn l no np">if (<!-- -->first<!-- -->.length() != <!-- -->second<!-- -->.length()) {<br/>  return false;<br/>}</span><span id="75d6" class="nl md it nh b gy nq nn l no np">int MAX_LETTERS = 26;</span><span id="9801" class="nl md it nh b gy nq nn l no np">int[] frequencies = new int[<!-- -->MAX_LETTERS<!-- -->];<br/>char a = 'a';</span><span id="6190" class="nl md it nh b gy nq nn l no np">for (int i = 0; i &lt; first.length(); i++){<br/>  char c = first.charAt(i);<br/>  int offset = c - a;<br/>  <!-- -->frequencies<!-- -->[offset]++;<br/>}</span><span id="bd8f" class="nl md it nh b gy nq nn l no np">for (int i = 0; i &lt; second.length(); i++){<br/>  char c = second.charAt(i);<br/>  int offset = c - a;<br/>  <!-- -->frequencies<!-- -->[offset]--;<br/>}</span><span id="6dc7" class="nl md it nh b gy nq nn l no np">for (int n : frequencies) {<br/>  if (n != 0){<br/>   return false; <br/>  }<br/>}</span><span id="b572" class="nl md it nh b gy nq nn l no np">return true;<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1d26" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不要提交未经测试的代码</h1><p id="91f1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">测试你的代码非常重要。编写一个函数来检查不同的输入，并确保结果符合预期。</p><p id="5e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试还会揭示代码中的盲点。</p><p id="1249" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在回顾我朋友的代码时，我想到一件事，他假设字符串<code class="fe nr ns nt nh b">first</code>和<code class="fe nr ns nt nh b">second</code>都在ASCII[a-z]的范围内。但是，如果用户输入的字符串包含超出该范围的字符，会发生什么情况呢？该函数可能试图访问非法索引并抛出一个<code class="fe nr ns nt nh b">ArrayIndexOutOfBoundsException</code>。</p><p id="005a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们需要一个验证器函数来检查输入，并在输入无效时抛出错误。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c083" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">针对更有经验的开发人员的测试</h1><p id="c1a2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个字谜测试是一个针对初级开发人员的简单例子。对于更有经验的开发人员来说，评审人员还会检查您的实现中关注点的分离。</p><p id="1525" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着你不应该把所有的代码放在一个巨大的函数中。<code class="fe nr ns nt nh b">areAnagrams</code>应该检查两个字符串是否是变位词，并返回一个布尔值，仅此而已。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b7a8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">添加自述文件和安装指南</h1><p id="1c03" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在压缩和提交代码之前，请确保您有一个自述文件，解释评审者如何安装依赖项和使用您的代码。</p><p id="e8ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当审查者想要测试你的代码时，它应该马上工作。他们不应该花时间去弄清楚需要安装哪个版本的依赖项才能工作。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8f99" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">注意你的提交历史</h1><p id="9a32" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你通过GitHub提交代码，请注意提交历史。你的承诺应该遵循你承诺的回购协议的贡献准则。</p><p id="b380" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提交消息应该是不言自明的——我强烈建议遵循<a class="ae ky" href="https://github.com/angular/angular/blob/master/CONTRIBUTING.md#commit" rel="noopener ugc nofollow" target="_blank">角度提交消息惯例</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bae1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">额外收获:你真的需要那个前端框架吗？</h1><p id="2947" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">除非在您的编码任务中明确说明，否则您可能不需要花哨的前端框架。</p><p id="15be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我正在审查一个前端申请人的代码，我需要知道他们能用HTML、CSS和普通JavaScript制作一个简单的网页。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9484" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="cc00" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我审查一个编码任务时，我不一定在乎你写了最快的算法。所以我没有分析我朋友的做法。我们每天编写的代码并没有那么复杂；许多图书馆已经实现了所有奇特的算法。</p><p id="d40c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为评审者关心的是代码的清晰性，良好的编程模式，测试等等。</p></div></div>    
</body>
</html>