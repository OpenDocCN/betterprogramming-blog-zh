<html>
<head>
<title>A Deep Dive Into The Node.js Thread Pool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解Node.js线程池</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-deep-dive-into-the-node-js-thread-pool-a1f32a4f8628?source=collection_archive---------13-----------------------#2022-01-19">https://betterprogramming.pub/a-deep-dive-into-the-node-js-thread-pool-a1f32a4f8628?source=collection_archive---------13-----------------------#2022-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9031" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个真实的调试故事</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/39b4f5c5f56eed0a75deb7bff1352e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QNvw-sqBo_UrA29q3xWNaQ.jpeg"/></div></div></figure><p id="f443" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">几个月前，我发现自己在sprint优先级中有以下问题:</p><p id="1716" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://github.com/PostHog/bigquery-plugin/issues/10" rel="noopener ugc nofollow" target="_blank">“big query在本地/自托管上非常古怪”</a></p><p id="9137" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将上下文保持在最低限度，我们运行一个开源分析平台，您可以自行托管，并且有插件可以帮助您将数据从平台发送到其他工具，BigQuery就是其中之一。</p><p id="120e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，在sprint即将到来的两周前，一个在自己托管的实例上使用BigQuery插件的客户报告说在插件的日志上看到了很多错误，说是执行超时了。</p><p id="ef1f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">插件可以一次运行长达30秒的任务，而BigQuery的插入似乎需要更长时间才能完成。</p><p id="ff94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更糟糕的是，尽管抛出了错误，但似乎有些插入还是成功了，这导致我们在触发重试逻辑时导出副本。</p><p id="fcc7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另外，最重要的是，据报道这发生在本地Postgres支持的部署和自托管ClickHouse支持的实例上，而不是在我们的ClickHouse支持的云实例上。什么？</p><p id="a410" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，回到我的冲刺目标。在阅读了我能找到的所有上下文之后，似乎到目前为止的共识是BigQuery在这里出了问题。</p><p id="56de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我有点怀疑。我一直在开发插件，就在一周前，我在开发另一个插件时遇到了类似的神秘错误。</p><p id="aae9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">起初我对它们不屑一顾，但是当我读到关于BigQuery插件的问题时，我的灯泡亮了。</p><p id="d98b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更深层的东西正在发生。</p><h1 id="3338" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">实用洗牌</h1><p id="605c" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">虽然BigQuery插件似乎不是唯一受影响的，但它可能会让我对正在发生的事情有所了解。</p><p id="9797" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我开始在检查代码的同时运行它，一些事情很快变得清晰:我们经常在第一次插入尝试时抛出错误，但从不在重试时抛出。</p><p id="bf02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里会有什么不同？</p><p id="e77e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">答对了。缓冲器。</p><p id="609f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当谈到异步处理时，我们的插件有几个选项，主要是作业API和缓冲区实用程序。</p><p id="973c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">BigQuery插件在第一次插入尝试时使用缓冲区，但是利用jobs(另一个API)来处理重试。</p><p id="be64" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">考虑到这个问题似乎只在第一次运行时出现，似乎是缓冲区的问题。</p><h1 id="b98e" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">毫无疑问</h1><p id="10bb" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">好吧，缓冲似乎是问题所在，但这需要得到证实。</p><p id="4305" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我设置了一个插件，它同时使用缓冲区和作业来调用同一个异步函数，该函数向一个总是等待5s才响应的端点发出请求，并对两者的性能进行计时。</p><p id="8e4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作业总是在大约相同的时间内执行，但是缓冲时间会有很大不同:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/9d250219e85ad541939e30795219fbf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CVG1yR2jNqC5ipr_.png"/></div></div></figure><p id="e8e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我经历了成千上万次跑步，工作总是很稳定。缓冲时间从5秒到29秒不等，然后超时。</p><p id="e694" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以缓冲是个问题。但是找出原因是我的胡须开始长出来的地方。</p><p id="7a1f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我开始注意到连接重置、套接字挂起和其他各种错误。我知道这个请求只需要5秒，所以还有25秒可以用。这毫无意义，所以我的直觉是，这是一个更低层次的问题。</p><p id="991e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这一点上，我花了几个小时查找Node.js和Piscina(我们的线程池)文档，测试不同的配置选项，但我哪儿也不去。</p><p id="a198" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以最后我决定用一个叫做<a class="ae lq" href="https://github.com/davidmarkclements/0x" rel="noopener ugc nofollow" target="_blank"> 0x </a>的flamegraph工具运行插件服务器。</p><p id="2fc9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有<em class="mp">那个</em>长得像<em class="mp">这个</em>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/964dc2d65f5218aa0ad9958b372f781d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rmYGZsjfHVNitT1r.png"/></div></div></figure><p id="8997" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嗯，<code class="fe mr ms mt mu b">atomicsWaitLoop</code>是什么？</p><p id="5e13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我去了皮辛纳回购公司，得到了答案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><blockquote class="mx my mz"><p id="dc10" class="ku kv mp kw b kx ky ju kz la lb jx lc na le lf lg nb li lj lk nc lm ln lo lp im bi translated">从<a class="ae lq" href="https://github.com/piscinajs/piscina/blob/b6dbbf131c4c5b83495e3fa15222ec1d31fa70ee/src/worker.ts" rel="noopener ugc nofollow" target="_blank"> piscinajs源代码中复制的片段。</a></p></blockquote><blockquote class="nd"><p id="422e" class="ne nf it bd ng nh ni nj nk nl nm lp dk translated">"一般来说，任务不应该在没有等待它们完成之前就产生异步操作."</p></blockquote><p id="b8a3" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">哦。</p><p id="24db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这正是缓冲区的作用！</p><p id="adad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我们做了一些我们的线程池不推荐的事情。可能就是这样。但是我们已经全面完成了！为什么这个错误没有发生在云上，而是发生在自托管的实例上？</p><p id="b46d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实证明，错误<em class="mp">确实</em>发生在云上，但非常罕见。它还与哨兵中的其他合法超时合并在一起，这使得它很难被发现。</p><p id="8a74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但那仍然不是它。<em class="mp">到底发生了什么</em>，我们如何修复它？</p><h1 id="a502" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">永远不要阻塞事件循环</h1><p id="f489" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">JavaScript生态系统中的黄金法则是<a class="ae lq" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/" rel="noopener ugc nofollow" target="_blank">“不要阻塞事件循环”</a>。</p><p id="1856" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事件循环是JavaScript在单线程环境中处理异步操作的方法。</p><p id="5e51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其他人解释的更好，所以我就不在这里赘述了。</p><p id="20ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实证明，为了提高主线程和工作线程之间的通信性能，Piscina默认运行一个(可能是无限的)while循环，该循环在指定的端口上主动为工作线程寻找新任务，而不是等待由侦听新消息触发的回调。</p><p id="41dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果，当Piscina检查新消息时，它阻塞了事件循环，所以其他什么也没做。</p><p id="99a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，假设我们已经为要执行的任务设置了超时，如果一个工作线程阻塞超过30秒，一旦它再次空闲用于其他处理，它就会处理来自我们任务的回调，但此时我们会强制超时。</p><p id="0dc7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，这只发生在<em class="mp">作废的承诺</em>上。明确无效(即不等待)的承诺，以便在“后台”处理，其结果并不重要。如果等待承诺，只要承诺没有完成，任务就不会被标记为完成，因此工作人员不会进入阻塞状态来寻找新的任务。</p><p id="76b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">具体来说，这里有一个示例场景:</p><ol class=""><li id="62e2" class="nt nu it kw b kx ky la lb ld nv lh nw ll nx lp ny nz oa ob bi translated">PostHog接收一个事件</li><li id="8f7c" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">该事件被传递给插件进行处理</li><li id="3334" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">这个插件取消了用事件向BigQuery发送POST请求的承诺</li><li id="53ec" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">工人将任务标记为完成，并继续寻找新的任务</li><li id="3a8b" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">事件循环被阻塞45秒</li><li id="db04" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">一个新的事件进来，一个新的任务被拾起</li><li id="0080" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">当有机会时，事件循环试图处理来自无效承诺的回调</li><li id="f209" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">当它处理来自请求的回调时，我们的包装器强制超时和插件错误(尽管请求已经成功完成)</li><li id="5a2f" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">我们的重试逻辑被触发，事件被导出两次</li></ol><h1 id="6d0b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">当缺少负载是问题时</h1><p id="e828" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">现在，这比我们的云实例对我们的客户端实例影响更大的原因是，Piscina worker只会在寻找新任务时阻塞事件循环。如果它正在处理一个任务，它将能够正常地处理后台回调等。</p><p id="ee42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，虽然在云上我们每分钟处理数十万个事件，每个事件都可能触发多个任务，但我们的一些客户端可能会在30秒内没有工作人员收到任务，从而触发这个问题。</p><p id="fc9f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这很棘手，因为在看到类似超时错误的东西时，您可能会认为您应该扩大<em class="mp">的规模</em>，这是我们面临的导致超时的其他类似问题的解决方案。</p><p id="0e87" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，如果你纵向扩展，我们将向插件服务器添加更多的线程——默认设置是<code class="fe mr ms mt mu b">n(threads) == n(cpus)</code>——如果你横向扩展，我们也将运行更多的工作线程。</p><p id="5035" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，你增加了一个给定的工人必须等待30秒或更长时间来完成一项任务的机会。</p><p id="aae3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的(暂时)答案实际上是缩小<em class="mp">的规模</em>。</p><h1 id="bfe1" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">解决方案</h1><p id="a5ee" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">因此，客户端可以缩小规模来缓解这个问题，但这肯定不是一个好的解决方案。</p><p id="3c72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我们如何解决这个问题呢？</p><p id="317e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嗯，我们本可以做的一件事就是彻底摆脱无效的承诺。然而，它们给我们带来的性能优势是显著的。</p><p id="a48c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们开始头脑风暴的方法，将允许我们保持无效的承诺。</p><p id="2b02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一次尝试非常简单。Piscina提供了一个<code class="fe mr ms mt mu b">useAtomics</code>标志，可以用来禁用阻塞机制，而不是等待表示新消息的信号的较慢方法。</p><p id="dacd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，在对我们的系统进行基准测试后，我发现当<code class="fe mr ms mt mu b">useAtomics</code>被设置为<code class="fe mr ms mt mu b">false</code>时，我们的事件摄取率<a class="ae lq" href="https://github.com/PostHog/plugin-server/issues/487#issuecomment-870509629" rel="noopener ugc nofollow" target="_blank">降低了大约27% </a>。这是不可接受的性能下降，所以我们放弃了这个想法。</p><p id="17a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，在考虑了一些其他的想法后，我们得出了以下结论(注意，我们已经在运行Piscina的<em class="mp">分支</em>):</p><p id="651d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">引入一个设置，表示在退回到较慢的机制之前，工作人员在寻找任务时应该阻塞事件循环的最长时间，默认为5秒。(<a class="ae lq" href="https://github.com/PostHog/piscina/pull/4" rel="noopener ugc nofollow" target="_blank">实现</a>)</p><p id="129e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样做的原因是因为在我们的云实例中，性能是最重要的，大多数时候工作人员会在几分之一秒内获得一个新任务，所以绝对大多数的任务将使用fast机制来完成。</p><p id="6549" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，在处理低容量的自托管实例上，如果工作人员已经花费了例如5秒来获得新任务，则实例上的负载很小，因此性能影响不会成为问题，因为它不太可能导致任务的长期积压。</p><p id="af2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，这就是我们如何保持我们的表现完好无损，没有触及无效的承诺。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="3170" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://github.com/PostHog/plugin-server/issues/487" rel="noopener ugc nofollow" target="_blank"> <em class="mp">这是原始门票</em> </a> <em class="mp">在这里对此进行了解释并讨论了可能性</em>。</p></div></div>    
</body>
</html>