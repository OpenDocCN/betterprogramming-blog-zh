<html>
<head>
<title>Lazy Load Your React Code With Code-Splitting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用代码分割延迟加载React代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lazy-load-react-code-with-code-splitting-ae3727e3c568?source=collection_archive---------10-----------------------#2020-04-16">https://betterprogramming.pub/lazy-load-react-code-with-code-splitting-ae3727e3c568?source=collection_archive---------10-----------------------#2020-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5d13" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以更优雅和高效的方式加载代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/834cf2e1ddbc5534fcb28bd99f20db0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*75_WXqewLOGEWrUh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@photoholgic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">霍尔格链接</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="16dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React是一个用于创建前端视图的库。它有一个庞大的图书馆生态系统与之合作。此外，我们可以用它来增强现有的应用程序。</p><p id="6c38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探讨如何通过拆分代码来加快应用程序的加载速度，以便只加载需要的部分。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3591" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">代码分割</h1><p id="12fa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们需要代码分割，这样产品反应包就不会太大。随着我们的应用变得越来越大，如果我们不把它们分开，只在需要的时候加载，产品包也会变得越来越大，加载时间也会变长。</p><p id="647f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> Create React App </a>内置了代码拆分支持。我们可以使用React的<code class="fe mz na nb nc b">lazy</code>和<code class="fe mz na nb nc b">import</code>函数来实现这一点。</p><p id="10e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以如下使用这些函数:</p><p id="b925" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">Foo.js</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="98ec" class="nh md it nc b gy ni nj l nk nl">import React from "react";</span><span id="e400" class="nh md it nc b gy nm nj l nk nl">export default function Foo() {<br/>  return &lt;div&gt;foo&lt;/div&gt;;<br/>}</span></pre><p id="0449" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d694" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们有了带有<code class="fe mz na nb nc b">Foo</code>组件的<code class="fe mz na nb nc b">Foo.js</code>。</p><p id="339c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在<code class="fe mz na nb nc b">App.js</code>中，我们有<code class="fe mz na nb nc b">App</code>组件，它有<code class="fe mz na nb nc b">Suspense</code>来加载回退。UI有<code class="fe mz na nb nc b">Foo</code>导入载荷。我们需要这个，因为<code class="fe mz na nb nc b">Foo</code>是在运行时加载的。</p><p id="739b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">React.lazy</code>在运行时而不是构建时加载<code class="fe mz na nb nc b">Foo</code>组件。它还将捆绑包中的代码分割成一个单独的文件，这样每个捆绑包文件都更小。</p><p id="631c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果缺少<code class="fe mz na nb nc b">Suspense</code>组件，我们将得到一个错误，告诉我们添加一个回退UI。</p><p id="4d0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在等待组件加载时，<code class="fe mz na nb nc b">fallback</code> prop接受我们想要呈现的任何React元素。我们可以将<code class="fe mz na nb nc b">Suspense</code>放在惰性组件之上的任何地方。</p><p id="7a73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将多个元素包装在一个<code class="fe mz na nb nc b">Suspense</code>元素中也是可行的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e851" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">误差边界</h1><p id="1677" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了在其他模块加载失败时优雅地失败，比如发生网络故障时，我们可以使用错误边界组件。</p><p id="170a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用它们，我们将它们包装在<code class="fe mz na nb nc b">Suspense</code>组件周围，如下所示:</p><p id="b4c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">ErrorBoundary.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="0537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">Foo.js</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="da00" class="nh md it nc b gy ni nj l nk nl">import React from "react";</span><span id="283f" class="nh md it nc b gy nm nj l nk nl">export default function Foo() {<br/>  return &lt;div&gt;foo&lt;/div&gt;;<br/>}</span></pre><p id="aacc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="b25c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们在<code class="fe mz na nb nc b">ErrorBoundary.js</code>中添加了<code class="fe mz na nb nc b">ErrorBoundary</code>组件。</p><p id="db53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在<code class="fe mz na nb nc b">App</code>中，我们将它包装在我们的<code class="fe mz na nb nc b">Suspense</code>组件周围，这让我们可以捕捉加载<code class="fe mz na nb nc b">Foo</code>组件时发生的任何错误。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9ba1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">基于路由的代码分割</h1><p id="d28e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">很多React应用都是单页应用。他们有将URL映射到组件的路径。</p><p id="888a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以根据路线分割代码。例如，我们可以将React路由器路由整合到我们的应用程序中，并根据路由分割代码，如下所示:</p><p id="8f6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">Foo.js</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="0c4c" class="nh md it nc b gy ni nj l nk nl">import React from "react";</span><span id="2225" class="nh md it nc b gy nm nj l nk nl">export default function Foo() {<br/>  return &lt;div&gt;foo&lt;/div&gt;;<br/>}</span></pre><p id="58b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">Bar.js</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b865" class="nh md it nc b gy ni nj l nk nl">import React from "react";</span><span id="90a1" class="nh md it nc b gy nm nj l nk nl">export default function Bar() {<br/>  return &lt;div&gt;bar&lt;/div&gt;;<br/>}</span></pre><p id="f89b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ec33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们在所有组件周围添加了<code class="fe mz na nb nc b">Router</code>组件。</p><p id="5dfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将<code class="fe mz na nb nc b">Route</code>放在<code class="fe mz na nb nc b">Suspense</code>组件中，这样它们就可以被延迟加载。也就是说，只有当我们在浏览器中加载路线时，它们才会加载。</p><p id="c950" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是我们在路线周围需要<code class="fe mz na nb nc b">Suspense</code>组件的原因。我们需要回退用户界面，以便在加载路线时显示它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="24c4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">指定出口</h1><p id="eb0f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">React.lazy</code>仅支持默认导出。如果我们的模块使用命名导出，那么我们必须创建一个中间模块，将它作为默认导出。</p><p id="d6b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以将代码安排如下:</p><p id="138f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">Foo.js</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="e760" class="nh md it nc b gy ni nj l nk nl">import React from "react";</span><span id="76bf" class="nh md it nc b gy nm nj l nk nl">export const Foo = function() {<br/>  return &lt;div&gt;foo&lt;/div&gt;;<br/>};</span></pre><p id="1f0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">FooDefault.js</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="23d4" class="nh md it nc b gy ni nj l nk nl">import { Foo } from "./Foo";</span><span id="9512" class="nh md it nc b gy nm nj l nk nl">export default Foo;</span></pre><p id="9491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="854a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们有将<code class="fe mz na nb nc b">Foo</code>导出为默认导出的<code class="fe mz na nb nc b">FooDefault.js</code>。</p><p id="fc1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们在<code class="fe mz na nb nc b">App.js</code>用<code class="fe mz na nb nc b">React.lazy</code>导入。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cf06" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="9d7e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用Create React App和React可以轻松实现代码拆分。React拥有动态导入组件的<code class="fe mz na nb nc b">lazy</code>方法。</p><p id="cdd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一个后备UI，这样我们就可以在动态导入的组件加载时看到一些东西。</p><p id="2bc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还支持错误边界，当动态导入的组件加载失败时，我们可以使用它来优雅地失败。</p><p id="3efe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React路由器也支持代码分割。<code class="fe mz na nb nc b">React.lazy</code>聪明到可以按路线拆分代码。</p></div></div>    
</body>
</html>