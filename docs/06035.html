<html>
<head>
<title>The Story of Curly Braces in Coding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码中花括号的故事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-curly-story-of-coding-49a348a31cf2?source=collection_archive---------7-----------------------#2020-08-27">https://betterprogramming.pub/the-curly-story-of-coding-49a348a31cf2?source=collection_archive---------7-----------------------#2020-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4928" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它从哪里来，怎么样，会持续吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5be575da8eb58235dd9a1366dae7f1eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6mqtVEKnSqNIFRuK"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Clément H </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7e0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看看我们今天的编程语言，你会发现编程语言中使用了这个奇妙的符号<code class="fe lv lw lx ly b">{</code>和<code class="fe lv lw lx ly b">}</code>。</p><p id="feed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是为了什么？简单，就是告诉编译器(或者解释器)代码块的开始和结束。当然，你可以在一个块中包含多个块。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="02bf" class="md me it ly b gy mf mg l mh mi">// A very simple example from C#<br/>public class MyClass<br/>{<br/>    public void myFunction(bool isToPrint)<br/>    {<br/>        if (isToPrint) <br/>        {<br/>            Console.WriteLine("Hello, world!");<br/>        }<br/>    }<br/>}</span></pre><p id="948d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有没有想过这是怎么发生的？我们应该把它放在哪里？未来的趋势是什么？</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a7f1" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">一直都有吗？</h1><p id="15be" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">不。当计算机第一次被发明的时候，编程语言和我们今天使用的是如此的不同。迈克尔·麦克米兰的一个优秀的媒体博客写下了它的全部历史。</p><div class="no np gp gr nq nr"><a href="https://medium.com/better-programming/a-brief-history-of-the-curly-brace-in-programming-5b3eacdc3f7a" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">编程中花括号的简史</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">我们每天都在使用它们，但是代码中的花括号是从哪里来的呢？</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div><p id="10ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我只是在下面总结一下(感谢迈克尔·麦克米兰</p><h2 id="2c81" class="md me it bd mr og oh dn mv oi oj dp mz li ok ol nb lm om on nd lq oo op nf oq bi translated">在算法58的日子里(1958年)</h2><p id="81c0" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在那个年代，块的概念被带到了编程中，这是编程界的一大进步。它是通过ALGO58语言引入的。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="968c" class="md me it ly b gy mf mg l mh mi">if x &gt; -1 then<br/>     begin<br/>          if x ≠ 0 then<br/>          x := 1/x<br/>     end;</span></pre><p id="5ed4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，它使用了<code class="fe lv lw lx ly b">begin</code>和<code class="fe lv lw lx ly b">end</code>。清晰可见。任何读了它的人都明白，不用想<code class="fe lv lw lx ly b">{</code>和<code class="fe lv lw lx ly b">} </code>是什么。</p><h2 id="fdd5" class="md me it bd mr og oh dn mv oi oj dp mz li ok ol nb lm om on nd lq oo op nf oq bi translated">在C语言之父BPCL的时代(大约10年后)</h2><p id="8562" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated"><code class="fe lv lw lx ly b">begin</code>和<code class="fe lv lw lx ly b">end</code>很好。但是为了使编码更容易和更有效，引入了一个更短的方法，即<code class="fe lv lw lx ly b">$(</code>和<code class="fe lv lw lx ly b">$)</code>。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a072" class="md me it ly b gy mf mg l mh mi">IF A &lt; B<br/>     $( LET T = A<br/>          A := B; B := T<br/>     $)</span></pre><p id="3622" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好，我们不再需要打字了。但这并没有持续太久。</p><h2 id="d2d8" class="md me it bd mr og oh dn mv oi oj dp mz li ok ol nb lm om on nd lq oo op nf oq bi translated">c语言(BPCL之后大约一年)</h2><p id="9a9a" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">B语言的寿命很短，在1968-1969年间被C语言完全取代。发生了一些语法变化，其中之一是将<code class="fe lv lw lx ly b">$(</code>和<code class="fe lv lw lx ly b">$)</code>替换为<code class="fe lv lw lx ly b">{</code>和<code class="fe lv lw lx ly b">}</code>。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a54e" class="md me it ly b gy mf mg l mh mi">if (isToPrint == true) <br/>{<br/>    print("Hello, world!");<br/>}</span></pre><p id="17bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此后，<code class="fe lv lw lx ly b">{</code>和<code class="fe lv lw lx ly b">}</code>被C语言的衍生语言广泛使用，如C++、C#等。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="7740" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">今天天气如何？</h1><p id="1258" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我会说它做得很好。大多数编程语言仍然使用<code class="fe lv lw lx ly b">{</code>和<code class="fe lv lw lx ly b">}</code>来表示一段代码，可能是基本结构如<code class="fe lv lw lx ly b">if-else</code>，或者是函数作用域，或者是类作用域等。这包括C#、C++、Java等语言，也包括新千年引入的语言，如Scala、Kotlin、Swift等。</p><p id="2c25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，对于我们应该把<code class="fe lv lw lx ly b">{</code>的起点放在哪里，编码社区中有很大的意见分歧。Jeremy Bytes解释了三个阵营</p><div class="no np gp gr nq nr"><a href="https://jeremybytes.blogspot.com/2013/04/where-do-curly-braces-belong.html" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">花括号属于哪里？</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">上周末，在我的一次会议上出现了一个问题(干净代码:杀人狂魔也读代码):你把…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">jeremybytes.blogspot.com</p></div></div><div class="oa l"><div class="or l oc od oe oa of ks nr"/></div></div></a></div><h2 id="b145" class="md me it bd mr og oh dn mv oi oj dp mz li ok ol nb lm om on nd lq oo op nf oq bi translated">阵营1:我们应该总是把它放在下一行</h2><p id="e4eb" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">这遵循了<code class="fe lv lw lx ly b">begin</code>和<code class="fe lv lw lx ly b">end</code>时代的惯例。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="79e6" class="md me it ly b gy mf mg l mh mi">public void myFunction(bool isToPrint)<br/>{<br/>    if (isToPrint) <br/>    {<br/>        Console.WriteLine("Hello, world!");<br/>    }<br/>}</span></pre><p id="afe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因很简单，容易辨认，看起来更整洁。即使在打印纸上，也能看得很清楚。C，C++时代，这是著名的风格，现在用C#，这是风格。</p><h2 id="adc7" class="md me it bd mr og oh dn mv oi oj dp mz li ok ol nb lm om on nd lq oo op nf oq bi translated">阵营2:我们应该总是把它放在起跑线的同一条线上</h2><p id="ed96" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">随着编程语言的进步，<code class="fe lv lw lx ly b">{</code>不再需要在下一行。它可以在块开始的同一行，节省一些行空间。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="cb93" class="md me it ly b gy mf mg l mh mi">public void myFunction(bool isToPrint) {<br/>    if (isToPrint) {<br/>        Console.WriteLine("Hello, world!");<br/>    }<br/>}</span></pre><p id="beb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它看起来更紧凑，尽管不如Camp 1整洁。这是在Java时代引入的，并从那时开始流行起来。</p><h2 id="e232" class="md me it bd mr og oh dn mv oi oj dp mz li ok ol nb lm om on nd lq oo op nf oq bi translated">阵营3:要看是结构块还是功能块等。</h2><p id="deb0" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">这是两个阵营1和2的混合，对于函数和类块，它应该在下一行。但如果结构块(如<code class="fe lv lw lx ly b">if-else</code>或<code class="fe lv lw lx ly b">for-loop</code>等)，那么它应该在同一行。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="9d4a" class="md me it ly b gy mf mg l mh mi">public void myFunction(bool isToPrint) <br/>{<br/>    if (isToPrint) {<br/>        Console.WriteLine("Hello, world!");<br/>    }<br/>}</span></pre><p id="fbd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阵营3是最不受欢迎的，因为它不一致。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4693" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">接下来会发生什么？</h1><p id="7444" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在某一点上，阵营1和阵营2之间就谁的做法正确存在激烈的争论。两个阵营似乎都能从逻辑上证明他们的观点。整洁还是紧凑？哪个会赢？</p><h2 id="d620" class="md me it bd mr og oh dn mv oi oj dp mz li ok ol nb lm om on nd lq oo op nf oq bi translated">语言接受方法</h2><p id="d715" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">根据最新的趋势和在线参考，我发现唯一坚持阵营1的语言是C#，正如他们在其<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions" rel="noopener ugc nofollow" target="_blank"> C#编码指南</a>中所述。</p><p id="a0df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">介绍<code class="fe lv lw lx ly b">{</code>和的源语言。<code class="fe lv lw lx ly b">}</code>，也就是<a class="ae ky" href="https://developer.gnome.org/programming-guidelines/stable/c-coding-style.html.en" rel="noopener ugc nofollow" target="_blank"> Gnome C编码标准</a>和<a class="ae ky" href="https://isocpp.org/wiki/faq/coding-standards" rel="noopener ugc nofollow" target="_blank"> C++编码指南</a>，正呈现出一种张贴混乱的混合风格。然而，自Java以来开发的语言都提倡Camp 2风格，例如<a class="ae ky" href="https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html" rel="noopener ugc nofollow" target="_blank"> Java编码指南</a>、<a class="ae ky" href="https://docs.scala-lang.org/tour/basics.html" rel="noopener ugc nofollow" target="_blank"> Scala编码指南</a>、<a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html" rel="noopener ugc nofollow" target="_blank"> Swift编码指南</a>、<a class="ae ky" href="https://kotlinlang.org/docs/tutorials/kotlin-for-py/functions.html" rel="noopener ugc nofollow" target="_blank"> Kotlin编码指南</a>等等(Go、R、Rust、JavaScript、Dart)</p><p id="c577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过观察采用Camp 2方法的新语言，尽管C和C++并没有表现出一致的偏好，但这表明Camp 2可能是向前发展的主要趋势。</p><h2 id="3aa5" class="md me it bd mr og oh dn mv oi oj dp mz li ok ol nb lm om on nd lq oo op nf oq bi translated">该工具提高了可读性</h2><p id="222e" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">虽然许多纯粹主义者仍然坚持认为代码应该写在纯文本编辑器上仍然可读的地方(或打印在纸上)，但不可否认的是，IDE等工具的进步改变了我们编码的方式。</p><p id="fc3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工具使得代码简洁而紧凑。即阵营1和阵营2的两个世界的最好的，例如，仅仅折叠功能或类<code class="fe lv lw lx ly b">{</code> <code class="fe lv lw lx ly b">}</code>的能力使它整洁，并且不再担心找到块的开始和结束在哪里。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/c04b7d80d42995e99d3402d63c508746.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*RKzm06PKJiga6JvS.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="56d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有助于消除远离Camp 2方法的缺点，并进一步提高代码的紧凑性。</p><p id="35a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来2号阵营的明显趋势会更加突出。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0636" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">会持续多久？</h1><p id="18dd" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">尽管在1号或2号营地，<code class="fe lv lw lx ly b">{</code>和<code class="fe lv lw lx ly b">}</code>仍然被很好地保存下来，作为表示街区开始和结束的字符。</p><p id="2c42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有一些迹象表明编程语言开始远离<code class="fe lv lw lx ly b">{</code>和<code class="fe lv lw lx ly b">}</code>的使用。</p><h2 id="763b" class="md me it bd mr og oh dn mv oi oj dp mz li ok ol nb lm om on nd lq oo op nf oq bi translated">不需要在一行中使用<code class="fe lv lw lx ly b">{</code>和【if-else</h2><p id="51c7" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">让我们看一下<a class="ae ky" href="https://developer.gnome.org/programming-guidelines/stable/c-coding-style.html.en" rel="noopener ugc nofollow" target="_blank"> C语言编码指南</a>，它陈述如下:</p><blockquote class="ot ou ov"><p id="202b" class="kz la ow lb b lc ld ju le lf lg jx lh ox lj lk ll oy ln lo lp oz lr ls lt lu im bi translated">大括号不应用于单个语句块</p></blockquote><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="21e4" class="md me it ly b gy mf mg l mh mi">if (condition)<br/>	single_statement ();<br/>else<br/>	another_single_statement (arg1);</span></pre><p id="ab74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再来看Java，它有三进制运算，如下，它代替了一个简单的<code class="fe lv lw lx ly b">if-else</code>:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e21d" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">// Normal</strong><br/>if (booleanCondition) {<br/>    doThisIfTrue();<br/>} else {<br/>    doThisIfFalse();<br/>}</span><span id="db00" class="md me it ly b gy pa mg l mh mi"><strong class="ly iu">// Ternary</strong><br/>booleanCondition? doThisIfTrue() : doThisIfFalse();</span></pre><p id="1135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看Kotlin，它有一个Elvis运算符，可以帮助简化空值检查:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="7b95" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">// Normal</strong><br/>if (myObject != null) {<br/>    myObject.doSomethingWithObject()<br/>} else {<br/>    doSomethingElse()<br/>}</span><span id="c044" class="md me it ly b gy pa mg l mh mi"><strong class="ly iu">// Elvis Expression</strong><br/>myObject?.doSomethingWithObject ?: doSomethingElse()</span></pre><h2 id="9810" class="md me it bd mr og oh dn mv oi oj dp mz li ok ol nb lm om on nd lq oo op nf oq bi translated">函数式编程范式</h2><p id="fd61" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在过去的几十年里，编程范式已经从过程化转向面向对象，再转向函数式编程。</p><div class="no np gp gr nq nr"><a href="https://levelup.gitconnected.com/why-code-evolve-from-procedural-to-object-oriented-to-functional-programming-13a88292307e" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">为什么代码从过程化到面向对象再到函数式编程</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">通过实际的代码示例学习不同风格的编程范式</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oa l"><div class="pb l oc od oe oa of ks nr"/></div></div></a></div><p id="c884" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在函数式编程中，它鼓励人们在工作中使用函数，而不是强制执行任务。一个简单的例子就是<code class="fe lv lw lx ly b">for-loop</code>。(科特林的例子)</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="749c" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">// 1. Imperative approach</strong><br/>for (it in 1..100) {<br/>    <em class="ow">print</em>(i)<br/>}</span><span id="dfb5" class="md me it ly b gy pa mg l mh mi"><strong class="ly iu">// 2. Simple functional approach</strong><br/>(1..100).forEach { it -&gt; print(it) }</span><span id="ed69" class="md me it ly b gy pa mg l mh mi"><strong class="ly iu">// 3. Concise functional approach</strong><br/>(1..100).forEach(::print)</span></pre><p id="7355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你注意到在最后一个例子中，它显示了<code class="fe lv lw lx ly b">{</code>和<code class="fe lv lw lx ly b">}</code>的消失</p><h2 id="89ef" class="md me it bd mr og oh dn mv oi oj dp mz li ok ol nb lm om on nd lq oo op nf oq bi translated">没有卷的语言</h2><p id="a4a7" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">有几种新语言尝试不使用，例如Shell脚本结构代码块，不使用curly。尽管这个函数仍然使用曲线。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4ff7" class="md me it ly b gy mf mg l mh mi">if [ expression ] <br/>then <br/>   statement1<br/>   statement2<br/>else <br/>   statement3 <br/>fi</span></pre><p id="20fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如Python，使用缩进级别来反映代码块的开始和结束。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="45b7" class="md me it ly b gy mf mg l mh mi">def tri_recursion(k):<br/>  if(k &gt; 0):<br/>    result = k + tri_recursion(k - 1)<br/>    print(result)<br/>  else:<br/>    result = 0<br/>  return result</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="91c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，编程社区长期以来一直被<code class="fe lv lw lx ly b">{</code>和<code class="fe lv lw lx ly b">}</code>所困扰，还没有准备好接受一个没有它们的版本。</p><p id="3abd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，我们看到程序员群体的趋势正朝着简洁编码的方向发展。在工具和技术的帮助下，程序员越来越接受不那么冗长的代码。</p><div class="no np gp gr nq nr"><a href="https://medium.com/swlh/the-7-coding-styles-that-are-dated-90eff1408d6e" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">7种过时的编码风格</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">我曾是他们的坚定信徒，但现在我改变了看法</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="pc l oc od oe oa of ks nr"/></div></div></a></div><p id="dc9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一天<code class="fe lv lw lx ly b">{</code>和<code class="fe lv lw lx ly b">}</code>不再被用来定义代码块的可能性可能会成为现实，尽管我认为这需要一段时间。</p></div></div>    
</body>
</html>