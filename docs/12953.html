<html>
<head>
<title>4 Rate Limit Algorithms Every Developer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个开发人员都应该知道的4种速率限制算法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-rate-limit-algorithms-every-developer-should-know-7472cb482f48?source=collection_archive---------1-----------------------#2022-07-14">https://betterprogramming.pub/4-rate-limit-algorithms-every-developer-should-know-7472cb482f48?source=collection_archive---------1-----------------------#2022-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c6ab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实现速率限制的初学者指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/249d22a0287193b2b812f45c62c043da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vG_qX3fdN12moc682JbcgA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://commons.wikimedia.org/wiki/File:Bucket_of_stones.jpg" rel="noopener ugc nofollow" target="_blank">维基共享资源</a>提供</p></figure><p id="52af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你以前处理过后端服务，你可能听说过速率限制这个术语。</p><p id="515d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有这个重要的工具包，客户可以在任何时候向您的服务发出任意多的请求。这导致流量突然激增，从而囤积你的服务器。</p><p id="118e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇博文中，让我们回到基本面，讨论四种常用的限速算法。</p><p id="30de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><h1 id="b328" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">令牌桶</h1><p id="0e86" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">令牌桶是其他四个中最容易实现的一个。</p><p id="eb49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来看看简化的步骤。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/49e22b55017a545d9c1a57906cd74d95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3lp4BzvAg4KfG3Q7k4WUig.png"/></div></div></figure><ul class=""><li id="b59d" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">想象有一个包含<code class="fe nc nd ne nf b">N</code>个令牌的桶</li><li id="6176" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">如果请求到达，我们从桶中取出一个令牌并处理请求</li><li id="5d1a" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">假设没有令牌剩余，我们丢弃并且不处理请求。</li><li id="8954" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">在每个固定的时间间隔，我们将桶中的代币补充回<code class="fe nc nd ne nf b">N</code>号。</li></ul><p id="1db7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用简单的哈希映射来实现该算法。</p><p id="32a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设每个用户每分钟只能触发四个请求。</p><pre class="kj kk kl km gt nl nf nm nn aw no bi"><span id="7f3b" class="np lw it nf b gy nq nr l ns nt">userID = 123<br/>usersBucket[userID] = 4</span></pre><p id="d433" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当收到请求时，我们将<code class="fe nc nd ne nf b">usersBucket[userID]</code>中的计数器减少<code class="fe nc nd ne nf b">1</code>。如果令牌用完了，我们就放弃请求。在每一分钟，我们都将哈希表中的计数器重置回<code class="fe nc nd ne nf b">4</code>。</p><p id="fe5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个棘手的情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/91ba8599fc141c32bd8b69f08a541584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eaLShCqFe9TjVvL48GiktA.png"/></div></div></figure><ul class=""><li id="17cf" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">12:00:59:用户触发了四个请求</li><li id="e7fc" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">12:01:00:我们将令牌重置回<code class="fe nc nd ne nf b">4</code></li><li id="107a" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">12:01:01:用户再次触发四个请求</li></ul><p id="a17f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的场景中，用户在三秒钟内触发了八个请求！</p><p id="5b64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保更顺畅的流量，令牌的再填充速率应该不同于速率限制。</p><p id="c4b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们的速率限制是每分钟四个请求。我们可以每15秒钟充值一个代币，而不是每分钟充值四个代币。这防止了重置边界处的流量突然爆发。</p><h1 id="5121" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">漏桶</h1><p id="2218" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在前面的算法中，虽然我们每15秒补充一个令牌，但用户仍然可以在第14秒触发四个请求，这导致流量突然激增。</p><p id="6ab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">漏桶在确保更平稳的流量分配方面派上了用场。</p><p id="a0a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是简化的步骤:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/834b8cd7cf8103c4f052006b50dbd64e.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*PqKJnOsvSvq8N9jrAG9gEg.png"/></div></figure><ul class=""><li id="0fb3" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">想象有一个桶，桶底有一个洞</li><li id="025a" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">当请求进来时，我们将请求填充到桶中</li><li id="97e1" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">在每一个固定的时间间隔，一个请求从底层“泄漏”出来并得到处理</li></ul><p id="4f96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">漏桶遵循FIFO概念。我们可以使用队列来实现它。</p><p id="75a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个进来的请求不会被转储，而是被排队到一个桶中。在每个固定的时间间隔，首先进入的请求将被出队并处理。</p><p id="d5bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用漏桶，请求可以以不同的速率进入，而服务器以一个恒定且可预测的速率处理它们。</p><p id="e08b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">俗话说，“没有最好的解决方案，只有取舍。”一致的速率意味着漏桶以平均速率处理请求，导致较慢的响应时间。</p><h1 id="a1d3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">固定窗</h1><p id="7599" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">固定窗口与令牌桶非常相似，因此两者都可能经历流量的突然爆发。</p><p id="24fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往，让我们简化步骤。假设我们正在实现每分钟四个请求的速率限制:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/e8053c72b390f8e1c745204f8e2a9e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BJ4At3xkfd_Xt8L8OVXvNQ.png"/></div></div></figure><ul class=""><li id="d3a7" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">时间线根据每个窗口的分钟数进行分割</li><li id="f99e" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">每个窗口包含一个计数器<code class="fe nc nd ne nf b">4</code></li><li id="ea95" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">当请求到达时，我们根据时间戳的下限分配请求</li><li id="c51c" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">如果请求在12:01:45进入，它将被分配到12:01:00的窗口</li><li id="e3d4" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">如果计数器大于<code class="fe nc nd ne nf b">0</code>，我们递减计数器并处理请求</li><li id="8a2b" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">否则，我们放弃请求</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/4c478877f89d00affa72b0a74f895016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CFGddTZBGG3HnOn2aoI48g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">当所有请求都到达窗口边界时，流量突发就会发生</p></figure><p id="1f0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">固定窗口算法的最大缺点如下:</p><ul class=""><li id="ea41" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">这将潜在地导致窗口边界附近的流量突然爆发</li><li id="6edc" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">如果计数器在窗口开始时用完，所有客户端将需要等待很长的重置窗口</li></ul><h1 id="78b5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">推拉窗</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/026a8915a0330eb8470ca02e2ab42bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9wnPvDNf5pXhvXTUCfqpbA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@tara-winstead/" rel="noopener ugc nofollow" target="_blank">塔拉·温斯泰德</a>在<a class="ae ky" href="https://www.pexels.com/photo/a-child-playing-abacus-6692923/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</p></figure><p id="a4e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">滑动窗口算法非常类似于固定窗口算法，除了它解决了上述缺点。</p><p id="e4b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们正在实现每分钟四个请求的速率限制:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/e4883c0a3afb41a8f65d264df7f3ada0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GUMxe0SwVA8TlEEs2BTDig.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">请求5将被处理并添加到阵列中，因为在最后1分钟内只有3个已处理的请求。将弹出请求1。</p></figure><ul class=""><li id="8ee5" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">数组(也称为窗口)用于存储已处理的请求及其时间戳</li><li id="d1fe" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">当一个请求到达时，我们遍历数组并检查在最后一分钟内处理的请求数</li><li id="8026" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">如果在最后一分钟内处理的请求数量少于四个，我们将请求添加到数组中并处理它</li><li id="322d" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated">当我们遍历数组时，我们会弹出在最后一分钟之前处理的请求</li></ul><p id="02d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所知，滑动窗口算法是确保在任何给定时间点严格遵守速率限制的理想选择。</p><p id="3b6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们存储了过去1分钟内的所有请求，并且在每次请求到达时循环遍历数组，因此该算法会消耗更多的内存和CPU。</p><h1 id="a798" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="e0a5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这些算法各有不同的优点和局限性。</p><p id="d703" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在决定您的应用程序将承受的权衡时，了解它们是如何工作的变得至关重要。</p><p id="af89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有所帮助，下次再见！</p><p id="2b91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对这样的文章感兴趣，今天就和我一起报名Medium吧！</p><div class="oa ob gp gr oc od"><a href="https://medium.com/@nganjason007/membership" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">通过我的推荐链接加入Medium—Jason Ngan</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">阅读Jason Ngan(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="on l oo op oq om or ks od"/></div></div></a></div></div></div>    
</body>
</html>