# 如何在 Python 中创建惰性属性以提高性能

> 原文：<https://betterprogramming.pub/how-to-create-lazy-attributes-to-improve-performance-in-python-b369fd72e1b6>

## 它关乎高效的性能

![](img/825db9445833cc33a4ce0e011112b090.png)

罗伯特·尼克森在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

*惰性评估*是一个编程实现范例，它将评估必要的操作推迟到被请求的时候。

通常，当运算开销很大，需要大量处理时间或内存时，惰性求值是首选实现。例如，在 Python 中，涉及惰性求值的最著名的技术之一是生成器。生成器不会为迭代创建整个序列(这会消耗大量内存),而是缓慢地评估当前需求，并在请求时一次生成一个元素。

除了生成器特性，在 Python 世界之外，许多其他面向对象的编程语言，比如 Swift 和 Kotlin，都有与对象相关的惰性求值。具体来说，您可以指定自定义实例对象的特定属性在这些语言中是惰性的，这意味着这些属性在被显式访问之前不会被创建。

但是，据我所知，在 Python 教程中对惰性属性的讨论较少。因此，为了向 Python 学习者提供一个概念证明，我将向您介绍 Python 中的惰性属性。

# 这个问题

在我们开始讨论懒惰属性之前，有些人可能想知道为什么它很重要，或者为什么我们要费心使用懒惰属性。

这里有一个可能的场景:假设我们正在构建一个允许用户与其他用户交互的网站。一个功能是查看一个人的追随者，在一个列表中。当我们点击一个用户时，我们可以在弹出窗口中查看该用户的个人资料。让我们写一些代码来展示一个可能的实现。

问题是

如您所见，当前的实现包括获取列表中所有用户的配置文件数据。获取简档数据的操作可能是昂贵的。它不仅需要访问远程服务器，还需要将数据存储在内存中。

重要的是，显示所需的用户界面并不需要这些简档数据，因为简档数据仅在点击特定用户名时使用。这个用例为我们实现懒惰属性奠定了完美的基础。

# 解决方案 1:使用“@property”

首先，属性与 Python 中的属性不是完全相同的概念。本质上，*属性*是修饰函数。并且通过修饰，常规函数被转换成属性，这些属性可以用作其他属性，比如支持点记法访问。

因此，严格地说，创建属性本身并不是真正创建惰性属性。相反，这只是提供一个接口来简化数据处理的问题。在幕后，还涉及到其他一些过程。在我解释它是如何工作的之前，让我们先看看下面的代码。

惰性属性:“@property”

上面的代码有以下与使用`@property` decorator 实现 lazy 属性相关的变化。

*   我们现在有了一个受保护的属性`_profile_data`，它是在对象的实例化过程中作为`None`创建的，用作以后数据处理的占位符。
*   我们使用`@property`装饰器来装饰`profile_data`函数，这样我们就可以使用点符号来访问`profile_data`的属性。
*   在`profile_data`函数中，我们首先检查`_profile_data`属性是否有数据，只有当它没有数据时(即`None`)，我们才执行重运算。在我们的用例中，如果一个特定的用户从未被点击来显示他们的配置文件，我们将永远不需要获取配置文件数据，这正是惰性评估的目的——它只会在绝对需要时运行昂贵的操作。

评估用“@property”实现的惰性属性

上面的代码用于检查惰性属性的实现是否如预期的那样工作。我们尝试访问属性两次，正如您所看到的，这个昂贵的操作只在属性为`None`时运行了一次。当我们第二次访问该属性时，我们立即获得了获取的值。

# 解决方案 2:使用“__getattr__”特殊方法

在 Python 中，名字前后有双下划线的函数被称为*特殊*或*神奇*方法。有些人也称它们为 *dunder* (即双下划线)方法。一个特殊的方法——`__getattr__`——可以帮助我们实现懒惰属性。

对于自定义类，实例对象将其属性保存在字典中，可以使用特殊方法`__dict__`访问该字典。具体来说，这个字典将属性名存储为它的键，将相应的属性值存储为它的值。值得注意的是，如果字典不包含指定的属性，那么将调用特殊方法`__getattr__`作为后备机制。

这听起来可能令人困惑，但对于真实的代码示例来说并不难，如下所示。

惰性属性:“__getattr__”

上面的代码有以下与使用`__getattr__`特殊方法实现惰性属性相关的变化。

*   更新后的`__init__`方法删除了配置文件数据的属性设置。这是一个必要的改变，因为如果设置了它，即使值为`None`，属性及其值也将存储在对象的`__dict__`属性中。在这种情况下，特殊方法`__getattr__`不会被调用。
*   我们还实现了`__str__`方法，该方法将用于显示对象以供参考(即在`__getattr__`方法中引发的异常中)。
*   在`__getattr__`方法中，我们指定当访问`profile_data`属性时，我们将远程获取数据并使用`setattr`方法设置属性。

惰性属性的测试

运行上面的代码是为了展示特殊方法`__getattr__`是否能够帮助我们实现惰性属性。

当我们第一次尝试获取名为`profile_data`的属性时，调用了`__getattr__`特殊方法并为我们创建了属性`profile_data`。

值得注意的是，当我们试图检索`profile_data`属性时，特殊的`__getattr__`方法没有被第二次调用，因为这个特殊的属性已经在`__dict__`字典中可用。让我们用下面的代码检查一下。

__dict__ '和“__getattr__”

如上所示，`profile_data`属性不在字典中。在我们试图检索它之后，`__getattr__`方法被调用，`profile_data`属性及其值被保存在字典中。

下一次我们访问该属性时，它直接从字典中返回，而不触发`__getattr__`方法。这正是我们想要懒惰评估拥有的行为。

# 荣誉奖:' __getattribute__ '

除了`__getattr__`方法，Python 中还有另一种特殊的方法叫做`__getattribute__`。虽然它们的名称相似，工作原理在某种程度上也相似，但请不要混淆这两种不同的方法。

与当特定属性在实例字典中时不会被调用的`__getattr__`方法不同，`__getattribute__`方法在每次检索属性时都会被调用。

只有当您预期属性会非常频繁地改变并且只有最新的数据是相关的时，这个特性才是有用的。在这些情况下，我们可以通过定义相关的函数来达到效果。

换句话说，我不建议你尝试实现它，因为让它正常工作很棘手(参见[这里](https://stackoverflow.com/questions/3278077/difference-between-getattr-vs-getattribute)的简短讨论)。例如，您可能遇到的一个特殊问题是无限递归循环——`__getattribute__`方法被调用了无数次，会使您的程序崩溃。

# 结论

在本文中，我们重点讨论了在 Python 中实现惰性属性的两种实用方法(外加一种不详细讨论也不推荐的巧妙方法):一种使用`@property`装饰器，另一种使用`__getattr__`特殊方法。

就我个人而言，我更喜欢使用属性装饰器，它更简单易懂。然而，当您需要定义多个惰性属性时，`__getattr__`方法更好，因为它提供了一个集中的地方来管理这些惰性属性。

感谢阅读。