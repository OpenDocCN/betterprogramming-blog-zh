<html>
<head>
<title>Stack vs. Queue — How To, When To, and Why To Use Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆栈与队列——如何、何时以及为什么使用它们</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stack-vs-queue-55d6ea7b2f4f?source=collection_archive---------3-----------------------#2022-01-28">https://betterprogramming.pub/stack-vs-queue-55d6ea7b2f4f?source=collection_archive---------3-----------------------#2022-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a856" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于使用堆栈和队列数据结构您需要知道的一切</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/77fdf29f3aced4e52622a8384ac0732b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zKnDkJpL-4GQ36kzrDiODQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">堆栈和队列图|由作者创建</p></figure><p id="0e28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">线性数据结构对于软件工程来说是必不可少的，它为构建我们日常使用的许多功能提供了基础——比如新闻提要和通知系统。当被赋予构建这些特性的任务时，许多工程师只是求助于数组，而没有考虑两个非常重要的数据结构:堆栈和队列。</p><p id="143e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文深入探讨了堆栈和队列数据结构、它们的用例、权衡和实现。到本文结束时，您将对栈和队列有一个清晰的理解，能够在您自己的工程任务中使用它们。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="15da" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">目录</h1><ol class=""><li id="8564" class="mt mu it la b lb mv le mw lh mx ll my lp mz lt na nb nc nd bi translated">为什么要关心堆栈和队列？</li><li id="4629" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated"><a class="ae ne" href="#639c" rel="noopener ugc nofollow">什么是栈？</a></li><li id="e8da" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated"><a class="ae ne" href="#db40" rel="noopener ugc nofollow">什么是队列？</a></li><li id="2517" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated"><a class="ae ne" href="#8b97" rel="noopener ugc nofollow">堆栈vs队列—用例</a> <br/> a) <a class="ae ne" href="#7ab7" rel="noopener ugc nofollow">堆栈用例</a> <br/> b) <a class="ae ne" href="#8fbe" rel="noopener ugc nofollow">队列用例</a></li><li id="14b5" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated"><a class="ae ne" href="#c1d4" rel="noopener ugc nofollow">如何实现堆栈和队列</a> <br/> a) <a class="ae ne" href="#fa8e" rel="noopener ugc nofollow">如何构建堆栈</a> <br/> b) <a class="ae ne" href="#215d" rel="noopener ugc nofollow">如何构建队列</a></li><li id="4774" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated"><a class="ae ne" href="#7ee9" rel="noopener ugc nofollow">堆栈与队列汇总</a></li></ol></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="2669" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">为什么您应该关心堆栈和队列？</h1><p id="5fc0" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">在深入兔子洞之前，最好理解为什么您可能想考虑堆栈或队列而不是数组。如前所述，堆栈、队列和数组都是线性数据结构——然而，性能最好的操作在这些数据结构之间是不同的。</p><blockquote class="nn no np"><p id="48b5" class="ky kz nq la b lb lc ju ld le lf jx lg nr li lj lk ns lm ln lo nt lq lr ls lt im bi translated">在比较运算性能时，可以使用三种不同的符号——大O、ω和θ。大O更常用，因为它代表最坏的情况。</p></blockquote><p id="1021" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过使用连续内存存储，数组在三种数据结构中执行随机元素访问的速度最快，随机访问的时间复杂度为O(1)。使用数组的缺点是在搜索、插入和删除元素时只能达到O(n)。或者，当使用堆栈或队列进行随机访问时，只能达到O(n ),但是插入和删除的时间复杂度为O(1)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/205c2c016a484ef4ce4f4227192ec6b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f46Om12rE80mkYifa7ZOrQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数组与堆栈与队列时间和空间复杂性表|由作者创建</p></figure><blockquote class="nv"><p id="1b00" class="nw nx it bd ny nz oa ob oc od oe lt dk translated">最终，您应该使用的数据结构取决于给定用例所需的最常见的操作。</p></blockquote><p id="facf" class="pw-post-body-paragraph ky kz it la b lb of ju ld le og jx lg lh oh lj lk ll oi ln lo lp oj lr ls lt im bi translated">既然您已经知道了何时应该避免使用数组，那么让我们来详细了解一下堆栈和队列。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="639c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">什么是堆栈？</h1><p id="a1e9" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">最直观的方法是想象一堆盘子。当添加一个盘子到你的堆栈时，你不会想把它放在中间的某个地方；相反，您将把它添加到堆栈的顶部。类似地，当你从盘子堆里拿走盘子时，你应该先从上面开始，然后往下走。这正是堆栈数据结构的行为方式，换句话说，它以后进先出的方式插入和删除元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/af6212737d9371b9f9552550279edd8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w4JArDLFpRD6FCRzhR2irw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">堆栈图|由作者创建</p></figure><p id="bce0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了实现插入和删除的恒定时间复杂度(O(1))，使用链表构建栈。这是因为当数组上发生插入或删除时，元素会改变它们在内存中的位置；因此它是线性时间复杂度(O(n))。然而这种行为不会出现在链表中，但是我们将在本文的后面对此进行更深入的探讨。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="db40" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">什么是队列？</h1><p id="ef72" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">就像堆栈一样，队列也存在于物理世界中——想象一下人们在收银机前排队。正如第一个排队的人将是第一个被服务的人一样，添加到队列中的第一个元素将是第一个被删除的元素——遵循FIFO原则(先进先出)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/7177fb97cfdb895175d438fe9cb53868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A6LiW5qnDB1cnteRtSZdEw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">队列图|由作者创建</p></figure><p id="0cd3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">队列还使用链表来保证插入和删除元素时的时间复杂度为O(1)。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="8b97" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">堆栈与队列—使用案例</h1><p id="b290" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">由于这两种数据结构中性能最好的操作是插入和删除，唯一不同的因素是它们的LIFO或FIFO行为，所以在队列上使用堆栈的情况和在队列上使用堆栈的情况完全取决于场景是否需要LIFO或FIFO特性。下面是堆栈和队列的应用程序列表。</p><h2 id="7ab7" class="om mc it bd md on oo dn mh op oq dp ml lh or os mn ll ot ou mp lp ov ow mr ox bi translated">堆栈用例</h2><ul class=""><li id="ef8d" class="mt mu it la b lb mv le mw lh mx ll my lp mz lt oy nb nc nd bi translated">堆栈可用于存储为实现撤消功能而触发的操作。</li><li id="1aee" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt oy nb nc nd bi translated">用于导航的“后退”按钮(“下一步”导航也使用堆栈)。</li><li id="440a" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt oy nb nc nd bi translated">按时间顺序排列的新闻提要以后进先出的方式运行，以确保最新的条目位于提要的顶部，因此可以为此使用堆栈。</li></ul><h2 id="8fbe" class="om mc it bd md on oo dn mh op oq dp ml lh or os mn ll ot ou mp lp ov ow mr ox bi translated">队列用例</h2><ul class=""><li id="4370" class="mt mu it la b lb mv le mw lh mx ll my lp mz lt oy nb nc nd bi translated">后端任务管理，以类似队列的方式处理操作，如API调用、数据库写入和发布/订阅消息系统。</li><li id="edba" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt oy nb nc nd bi translated">警报和通知系统倾向于具有FIFO行为，因此可以使用队列来建立这种行为。</li></ul><p id="5496" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">值得注意的是，虽然堆栈和队列都使用链表，但是如果您需要的数据结构的用例不需要链表的所有功能，那么在堆栈和队列上使用链表并不理想。堆栈或队列的最佳实现是强制执行LIFO或FIFO行为的实现，这是因为它是自文档化的，可以保护您的应用程序免受bug的影响。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="c1d4" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">如何实现堆栈和队列</h1><p id="9084" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">如前所述，构建堆栈和队列的最佳方式是使用链表。这是因为链表允许你在插入和删除元素时达到O(1)的时间复杂度。</p><p id="fd59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">链表由包含数据的相邻节点组成，这些节点用指针连接在一起。链表有三种形式:单向链表、双向链表和循环链表；在我们的例子中，我们将使用双向链表。</p><p id="7083" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">双向链表有三个主要组成部分:头(第一个元素)、尾(最后一个元素)和节点(包含数据、指向下一个元素的指针和指向前一个元素的指针)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/c40272cd6a58061ebd67f328d9eb7c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Ad2DZV6C2m6vv0HXmv-NQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">双向链表图|由作者创建</p></figure><p id="fbc8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在堆栈和队列之间一致的组件是节点，让我们看看如何在Python中构建节点:</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="4404" class="om mc it pb b gy pf pg l ph pi"># Creating a node class</span><span id="fd9e" class="om mc it pb b gy pj pg l ph pi">class Node:<br/>  <br/>  def __init__(self, data):<br/>    self.data = data<br/>    self.next = None<br/>    self.prev = None</span></pre><p id="5e67" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，我们的节点包含数据和两个指针，一个指向上一个节点，一个指向下一个节点。</p><p id="543e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦你写好了这些，你就可以继续构建你的栈或者队列了。</p><p id="a1eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">堆栈和队列的主要方法与元素的插入和删除有关。然而，<a class="ae ne" href="https://runestone.academy/ns/books/published//pythonds/BasicDS/TheStackAbstractDataType.html" rel="noopener ugc nofollow" target="_blank">堆栈抽象数据类型</a>和<a class="ae ne" href="https://runestone.academy/ns/books/published//pythonds/BasicDS/TheQueueAbstractDataType.html" rel="noopener ugc nofollow" target="_blank">队列抽象数据类型</a>还包括其他三种方法——我们将把它们构建到我们的堆栈和队列类中:</p><ul class=""><li id="33ba" class="mt mu it la b lb lc le lf lh pk ll pl lp pm lt oy nb nc nd bi translated"><code class="fe pn po pp pb b">peek()</code> —返回堆栈中的第一个项目或队列前面的第一个项目，但不删除它。它不需要参数，也不修改堆栈或队列。</li><li id="25ab" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt oy nb nc nd bi translated"><code class="fe pn po pp pb b">isEmpty()</code> —测试堆栈或队列是否为空。它不需要参数，返回一个布尔值。</li><li id="97b2" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt oy nb nc nd bi translated"><code class="fe pn po pp pb b">size()</code>返回堆栈或队列中的项目数。它不需要参数，返回一个整数。</li></ul><h2 id="fa8e" class="om mc it bd md on oo dn mh op oq dp ml lh or os mn ll ot ou mp lp ov ow mr ox bi translated">如何构建堆栈</h2><p id="2c77" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">虽然双向链表包含了头和尾，但是栈只关心它的头，它被称为栈的<code class="fe pn po pp pb b">top</code>。让我们首先为堆栈的<code class="fe pn po pp pb b">top</code>创建一个实例变量，以及一个<code class="fe pn po pp pb b">size</code>实例变量:</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="5196" class="om mc it pb b gy pf pg l ph pi"># Creating a stack class</span><span id="b376" class="om mc it pb b gy pj pg l ph pi">class Stack:<br/>  def __init__(self):<br/>    self.top = None<br/>    <em class="nq">self</em>.size = 0</span></pre><p id="6d23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Size方法<br/> </strong>接下来是<code class="fe pn po pp pb b">size</code>方法，它简单地返回堆栈的大小:</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="2e50" class="om mc it pb b gy pf pg l ph pi">def getSize(<em class="nq">self</em>):<br/>  <em class="nq">return</em> <em class="nq">self</em>.size</span></pre><p id="20ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> isEmpty方法</strong> <br/>接下来，我们可以实现<code class="fe pn po pp pb b">isEmpty</code>方法——所有需要做的就是测试堆栈是否为空并返回一个布尔值:</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="315b" class="om mc it pb b gy pf pg l ph pi">def isEmpty(<em class="nq">self</em>):<br/>  <em class="nq">return</em> <em class="nq">self</em>.size == 0</span></pre><p id="cb85" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">窥视法</strong> <br/>接下来，我们可以实施<code class="fe pn po pp pb b">peek</code>法，有两件事我们需要做:</p><ol class=""><li id="f013" class="mt mu it la b lb lc le lf lh pk ll pl lp pm lt na nb nc nd bi translated">检查堆栈是否为空，如果为空，则引发异常。</li><li id="7838" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">从栈顶返回数据。</li></ol><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="0958" class="om mc it pb b gy pf pg l ph pi">def peek(<em class="nq">self</em>):<em class="nq"><br/>  if</em> <em class="nq">self</em>.isEmpty(): #1<br/>    <em class="nq">raise</em> Exception("Peeking from an empty stack")<br/>  <em class="nq">return</em> <em class="nq">self</em>.top.data #2</span></pre><p id="36bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以继续我们的主要操作了:<em class="nq">将</em>元素推到<em class="nq">堆栈的顶部</em>并且<em class="nq">将</em>元素从堆栈的顶部弹出。</p><p id="9abf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">推送方法</strong> <br/>从推送操作开始，需要四个步骤:</p><ol class=""><li id="d482" class="mt mu it la b lb lc le lf lh pk ll pl lp pm lt na nb nc nd bi translated">创建一个节点实例，并将其<code class="fe pn po pp pb b">next</code>指针设置为堆栈的原始<code class="fe pn po pp pb b">top</code>节点。</li><li id="3c62" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">如果堆栈中有现有的<code class="fe pn po pp pb b">top</code>，将其<code class="fe pn po pp pb b">prev</code>变量设置为新节点。</li><li id="f733" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">将<code class="fe pn po pp pb b">top</code>实例变量更新到新节点。</li><li id="fe47" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">将堆叠的<code class="fe pn po pp pb b">size</code>增加一个。</li></ol><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="7b0c" class="om mc it pb b gy pf pg l ph pi">def push(self, new_el):<br/>  new_node = Node(new_el) #1 - create node<br/>  new_node.next = self.top #1 - set next pointer</span><span id="57db" class="om mc it pb b gy pj pg l ph pi">if self.top != None:<br/>    self.top.prev = new_node #2</span><span id="cb45" class="om mc it pb b gy pj pg l ph pi">self.top = new_node #3<br/>  <em class="nq">self</em>.size += 1 #4</span></pre><p id="6e24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">弹出方法</strong> <br/>最后是弹出操作，需要六个步骤:</p><ol class=""><li id="b33f" class="mt mu it la b lb lc le lf lh pk ll pl lp pm lt na nb nc nd bi translated">从堆栈的<code class="fe pn po pp pb b">top</code>实例变量中检索第一个节点。</li><li id="8151" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">将第二个节点的<code class="fe pn po pp pb b">prev</code>指针设置为<code class="fe pn po pp pb b">None</code>。</li><li id="350b" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">将<code class="fe pn po pp pb b">top</code>实例变量更新到第二个节点。</li><li id="fa31" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">在要删除的节点上，将<code class="fe pn po pp pb b">next</code>指针设置为<code class="fe pn po pp pb b">None</code>。</li><li id="c6b3" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">将堆栈的<code class="fe pn po pp pb b">size</code>减少一个。</li><li id="c8dc" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">返回要删除的节点的数据。</li></ol><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="30ee" class="om mc it pb b gy pf pg l ph pi">def pop(self):<br/>  if self.top == None:<br/>    print("Stack is empty")<br/>  else:<br/>    del_node = self.top #1<br/>    del_node.next.prev = None #2<br/>    self.top = del_node.next #3<br/>    del_node.next = None #4<br/>    <em class="nq">self</em>.size -= 1 #5</span><span id="4193" class="om mc it pb b gy pj pg l ph pi">return del_node.data #6</span></pre><p id="d016" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">构建好堆栈后，您可以这样使用它:</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="195d" class="om mc it pb b gy pf pg l ph pi">stack = Stack() # create a stack instance</span><span id="6e61" class="om mc it pb b gy pj pg l ph pi">stack.isEmpty() # logs 'True'</span><span id="5b52" class="om mc it pb b gy pj pg l ph pi">stack.push('c')<br/>stack.push('b')<br/>stack.push('a')</span><span id="262e" class="om mc it pb b gy pj pg l ph pi">stack.top.data # logs 'a'<br/>stack.getSize() # logs '3'</span><span id="6070" class="om mc it pb b gy pj pg l ph pi">stack.peek() # logs 'a'<br/>stack.pop() # logs 'a'<br/>stack.top.data # logs 'b'<br/>stack.getSize() # logs '2'<br/>stack.isEmpty() # logs 'False'</span></pre><h1 id="215d" class="mb mc it bd md me pq mg mh mi pr mk ml jz ps ka mn kc pt kd mp kf pu kg mr ms bi translated">如何构建队列</h1><p id="2dfd" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">与堆栈不同，队列与双链表的头和尾组件有关，因为删除和插入发生在队列的两端，称为<code class="fe pn po pp pb b">front</code>(队列的右侧)和<code class="fe pn po pp pb b">rear</code>(队列的左侧)。在这种情况下，队列的<code class="fe pn po pp pb b">front</code>和<code class="fe pn po pp pb b">rear</code>需要一个实例变量，以及一个<code class="fe pn po pp pb b">size</code>实例变量。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="f750" class="om mc it pb b gy pf pg l ph pi"># Creating a queue class</span><span id="763c" class="om mc it pb b gy pj pg l ph pi">class Queue:<br/>  def __init__(self):<br/>    self.front = None<br/>    self.rear = None<br/>    self.size = 0</span></pre><p id="fa3a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Size方法</strong> <br/>接下来是<code class="fe pn po pp pb b">size</code>方法，它简单地返回队列的大小:</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="1943" class="om mc it pb b gy pf pg l ph pi">def getSize(<em class="nq">self</em>):<br/>  <em class="nq">return</em> <em class="nq">self</em>.size</span></pre><p id="41e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">是空方法</strong> <br/>接下来，我们可以实现<code class="fe pn po pp pb b">isEmpty</code>方法——只需要测试队列是否为空并返回一个布尔值:</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="9da3" class="om mc it pb b gy pf pg l ph pi">def isEmpty(<em class="nq">self</em>):<br/>  <em class="nq">return</em> <em class="nq">self</em>.size == 0</span></pre><p id="cec1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Peek方法</strong> <br/>接下来，我们可以实施<code class="fe pn po pp pb b">peek</code>方法，我们需要做两件事:</p><ol class=""><li id="6c9d" class="mt mu it la b lb lc le lf lh pk ll pl lp pm lt na nb nc nd bi translated">进行卫生检查，查看队列是否为空，如果为空，则引发异常。</li><li id="9f40" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">从堆栈的<code class="fe pn po pp pb b">front</code>元素返回数据。</li></ol><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="fe3b" class="om mc it pb b gy pf pg l ph pi">def peek(<em class="nq">self</em>):<em class="nq"><br/>  if</em> <em class="nq">self</em>.isEmpty(): #1<br/>    <em class="nq">raise</em> Exception("Peeking from an empty queue")<br/>  <em class="nq">return</em> <em class="nq">self</em>.top.data #2</span></pre><p id="e849" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以继续我们的主要操作:<em class="nq">将</em>元素插入到队列的<code class="fe pn po pp pb b">rear</code>中，并且<em class="nq">从队列的<code class="fe pn po pp pb b">front</code>中删除</em>元素。</p><p id="f214" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">入队方法</strong> <br/>入队方法从包含五个步骤的入队方法开始:</p><ol class=""><li id="6cec" class="mt mu it la b lb lc le lf lh pk ll pl lp pm lt na nb nc nd bi translated">创建一个节点实例，并将其<code class="fe pn po pp pb b">next</code>指针设置为指向队列的原始<code class="fe pn po pp pb b">rear</code>节点。</li><li id="f2a2" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">如果队列中有一个现有的<code class="fe pn po pp pb b">rear</code>节点，将它的<code class="fe pn po pp pb b">prev</code>变量设置为新节点。</li><li id="91d2" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">如果队列中没有现有的<code class="fe pn po pp pb b">rear</code>节点(即队列为空)，则将<code class="fe pn po pp pb b">front</code>实例变量设置为新节点。</li><li id="6bf9" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">将<code class="fe pn po pp pb b">rear</code>实例变量更新到新节点。</li><li id="b0b0" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">将队列的<code class="fe pn po pp pb b">size</code>加1。</li></ol><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="416f" class="om mc it pb b gy pf pg l ph pi">def enqueue(self, new_el):<br/>  new_node = Node(new_el) #1 - create node<br/>  new_node.next = self.rear #1 - set next pointer</span><span id="5ba0" class="om mc it pb b gy pj pg l ph pi">if self.rear != None:<br/>    self.rear.prev = new_node #2<br/>  else:<br/>    self.front = new_node #3</span><span id="8274" class="om mc it pb b gy pj pg l ph pi">self.rear = new_node #4<br/>  <em class="nq">self</em>.size += 1 <em class="nq">#5</em></span></pre><p id="f901" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">出列方法</strong> <br/>最后一步是构建出列方法，包括六个步骤:</p><ol class=""><li id="a829" class="mt mu it la b lb lc le lf lh pk ll pl lp pm lt na nb nc nd bi translated">从队列的<code class="fe pn po pp pb b">front</code>实例变量中检索前端节点。</li><li id="242b" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">从前面获取前一个节点，并将它的<code class="fe pn po pp pb b">next</code>指针设置为<code class="fe pn po pp pb b">None</code>。</li><li id="b6d0" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">将<code class="fe pn po pp pb b">front</code>实例变量更新到步骤2中提到的节点。</li><li id="9319" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">将<code class="fe pn po pp pb b">prev</code>指针设置为指向正在删除的节点上的<code class="fe pn po pp pb b">None</code>。</li><li id="c769" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">将<code class="fe pn po pp pb b">queue</code>的尺寸减少一个。</li><li id="ee61" class="mt mu it la b lb nf le ng lh nh ll ni lp nj lt na nb nc nd bi translated">返回正在删除的节点的数据。</li></ol><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="58b1" class="om mc it pb b gy pf pg l ph pi">def dequeue(self):<br/>  if self.front == None:<br/>    print("Queue is empty")<br/>  else:<br/>    del_node = self.front #1<br/>    del_node.prev.next = None #2<br/>    self.front = del_node.prev #3<br/>    del_node.prev = None #4<br/>    <em class="nq">self</em>.size -= 1 <em class="nq">#5</em></span><span id="44bd" class="om mc it pb b gy pj pg l ph pi">return del_node.data #6</span></pre><p id="b04b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，您可以像这样使用队列:</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="cbd9" class="om mc it pb b gy pf pg l ph pi">queue = Queue() # create a queue instance</span><span id="7704" class="om mc it pb b gy pj pg l ph pi">queue.isEmpty() # logs 'True'</span><span id="d657" class="om mc it pb b gy pj pg l ph pi">queue.enqueue('c')<br/>queue.enqueue('b')<br/>queue.enqueue('a')</span><span id="af91" class="om mc it pb b gy pj pg l ph pi">queue.front.data # logs 'c'<br/>queue.rear.data # logs 'a'<em class="nq"><br/></em>queue.getSize() <em class="nq"># logs 3</em></span><span id="9bf4" class="om mc it pb b gy pj pg l ph pi">queue.peek() # logs 'c'<br/>queue.dequeue() # logs 'c'<br/>queue.top.data # logs 'b'<br/>queue.rear.data # logs 'a'<br/>queue.getSize() # logs '2'<br/>queue.isEmpty() # logs 'False'</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="7ee9" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">堆栈与队列:摘要</h1><p id="3fc3" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">虽然堆栈和队列都是非原始的线性数据结构，最好使用链表来实现，但关键的区别是它们的LIFO和FIFO的本质。</p><p id="ccc4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于在堆栈和队列中插入和删除元素的方式不同，使用数据结构的应用程序也完全不同。</p><p id="13d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让自己对每一种可用的数据结构有一个深入的了解，这将有助于你构建高性能和高效的应用程序，我希望这篇文章已经帮助你构建了这些知识！</p></div></div>    
</body>
</html>