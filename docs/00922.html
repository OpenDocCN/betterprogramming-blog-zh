<html>
<head>
<title>Creating an Opinionated Go GQL Server — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建自以为是的Go GQL服务器—第3部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-an-opinionated-go-gql-server-part-3-ca9f71980131?source=collection_archive---------7-----------------------#2019-07-28">https://betterprogramming.pub/creating-an-opinionated-go-gql-server-part-3-ca9f71980131?source=collection_archive---------7-----------------------#2019-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/440891927e4fcbc1de578a1987294248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UcRj6PARam6Nha5LvwU3Nw.png"/></div></div></figure><p id="ea91" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这件作品是一个系列的一部分。它不适合初学者，但你可以从第一部分<a class="ae kz" href="https://medium.com/better-programming/creating-an-opinionated-gql-server-part1-8fad071e525f" rel="noopener">开始查看</a></p><div class="la lb gp gr lc ld"><a href="https://medium.com/better-programming/creating-an-opinionated-gql-server-part1-8fad071e525f" rel="noopener follow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd iu gy z fp li fr fs lj fu fw is bi translated">创建自以为是的Go GQL服务器—第1部分</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">项目设置和初始步骤</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">medium.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr jz ld"/></div></div></a></div><p id="ee78" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可以复习一下怎么上到这一部分。</p><p id="693b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">和往常一样，代码在<a class="ae kz" href="https://github.com/cmelgarejo/go-gql-server/tree/tutorial/part-3" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中。</p><p id="5390" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">今天我们将为我们的项目添加一个GORM和一个数据库。我选择的RDBMS是<a class="ae kz" href="https://www.postgresql.org" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>。你可以使用<a class="ae kz" href="https://www.mysql.com/" rel="noopener ugc nofollow" target="_blank"> MySQL </a>，<a class="ae kz" href="https://www.sqlite.org/" rel="noopener ugc nofollow" target="_blank"> SQLite </a>，只要GORM支持，你喜欢哪个就用哪个。</p><p id="30e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你错过了，你也可以看看第二部。在这篇文章中，我会以更快的速度继续，查看代码中的注释以获取更多信息。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="f663" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">将GORM添加到项目</h1><p id="25a8" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">让我们将GORM添加到我们的项目中:</p><p id="dc63" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nc nd ne nf b">$ go get -u github.com/jinzhu/gorm</code></p><p id="1d6a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要移民；让我们加上<a class="ae kz" href="https://gopkg.in/gormigrate.v1" rel="noopener ugc nofollow" target="_blank"> Gormigrate </a>:</p><p id="8ab5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nc nd ne nf b">$ go get gopkg.in/gormigrate.v1</code></p><p id="d641" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我不希望id像<code class="fe nc nd ne nf b">int</code>的那样容易被发现。现在，任何人都可以在<code class="fe nc nd ne nf b">deleteUser(userId: 1)</code>上发送一个突变，这应该会增加另一层复杂性，以减少我们愚蠢的API的攻击面。</p><p id="ae27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">添加来自<code class="fe nc nd ne nf b">gofrs</code>的UUID套餐:</p><p id="85a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nc nd ne nf b">$ go get github.com/gofrs/uuid</code></p><p id="cd79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并且，我们将设置<code class="fe nc nd ne nf b">db</code>模型来使用UUIDs作为主键。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="c2e2" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">潜入戈尔姆</h1><p id="a4e3" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">现在，让我们在我们的项目中设置<code class="fe nc nd ne nf b">GORM</code>，使用下面的指令。</p><p id="6da1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，让我们为所有东西创建一个入口点<code class="fe nc nd ne nf b">db</code>，在这里我们可以初始化和设置数据库连接。</p><p id="ddb1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们把这个代码放在<code class="fe nc nd ne nf b">internal/orm/main.go</code>吧。</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1e36" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能已经注意到了<code class="fe nc nd ne nf b">internal/logger</code>日志包——我们将在奖金部分深入探讨。现在，你甚至可以使用<code class="fe nc nd ne nf b">import "log"</code>包。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="1ca6" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">移民</h1><p id="cb08" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">在<code class="fe nc nd ne nf b">migration.ServiceAutoMigration</code>中调用的迁移服务，我们将在<code class="fe nc nd ne nf b">internal/ocm/migration/main.go</code>中保存:</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="bdc9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们看到几个更依赖于迁移的包:<code class="fe nc nd ne nf b">internal/orm/migration/jobs</code>和<code class="fe nc nd ne nf b">internal/orm/models</code>。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="42cc" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">定义模型</h1><p id="c74b" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">让我们首先设置可以添加到<code class="fe nc nd ne nf b">updateMigration</code>功能中的模型，从而定义<code class="fe nc nd ne nf b">user.go</code>。</p><p id="7f72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是第一，我对我所有的车型都有一个特殊的要求；我希望它们中的一些可以被软删除(而不是从表中删除),而一些则被彻底销毁。当我们使用GORM时，我们可以通过使用<code class="fe nc nd ne nf b">gorm.Model</code> struct来创建struct，或者定义我们自己的struct，我们将这样做。</p><p id="b76a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有一件事。<code class="fe nc nd ne nf b">gorm.Model</code>也使用自动递增的数字id，但是我喜欢把事情复杂化，所以我想使用UUIDs作为主键。</p><p id="d499" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们用基础模型的两个版本创建一个<code class="fe nc nd ne nf b">internal/orm/models/base.go</code>模型文件:一个带有<code class="fe nc nd ne nf b">hard</code>delete；另一个带有<code class="fe nc nd ne nf b">soft</code> delete:</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="61bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，有了这些基本模型，我们可以为我们的服务器定义我们需要的任何其他模型，所以这里是<code class="fe nc nd ne nf b">internal/orm/models/user.go</code>:</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e31f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于我们将通过<code class="fe nc nd ne nf b"><a class="ae kz" href="https://godoc.org/github.com/markbates/goth" rel="noopener ugc nofollow" target="_blank">Goth</a></code>使用外部服务进行身份验证，并将其用于身份验证流，所以现在我们没有密码列。</p><p id="d1a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，我们现在需要用至少一个用户来播种这个表。我们将使用<a class="ae kz" href="https://gopkg.in/gormigrate.v1" rel="noopener ugc nofollow" target="_blank">or migrate</a>pkg并准备一个迁移作业文件。姑且称之:<code class="fe nc nd ne nf b">internal/orm/migrations/jobs/seed_users.go</code>。</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="cba6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经设置好了一切，我们可以修改我们的<code class="fe nc nd ne nf b">cmd/gql-server/main.go</code>。</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="cf0d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有，<code class="fe nc nd ne nf b">pkg/server/main.go</code>:</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="92cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>处理程序也应该接收<code class="fe nc nd ne nf b">ORM</code>实例，因此我们可以使用解析器<code class="fe nc nd ne nf b">internal/handlers/gql.go</code>中的数据库连接:</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1f7b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此时，让我们修改<code class="fe nc nd ne nf b">Resolver</code>结构的<code class="fe nc nd ne nf b">internal/gql/resolvers/main.go</code>以使用<code class="fe nc nd ne nf b">ORM</code>实例:</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9c35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">哦，对了！让我们修改我们的<code class="fe nc nd ne nf b">internal/schemas.graphql</code>来反映数据库模型:</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8ec7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能已经注意到我是如何返回<code class="fe nc nd ne nf b">users</code>查询的。</p><p id="99d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是因为我们可能需要将记录的<code class="fe nc nd ne nf b">count</code>返回到一个网格中，例如，我想在将来进行过滤和搜索，这就是<code class="fe nc nd ne nf b">list</code>的用武之地</p><p id="9b85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">没有单用户查询，这是为什么呢？我要<code class="fe nc nd ne nf b">KISS</code>一直(不是你，别那样看着我！)，这就是为什么我们将使用相同的查询来检索单个特定的记录，或者一组记录。</p><p id="6b14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们用一个选项来修改<code class="fe nc nd ne nf b">scripts/gqlgen.sh</code>，在<code class="fe nc nd ne nf b">internal/gql/resolvers/generated/resolver.go</code>重新生成解析器函数，这样您就可以将任何新的查询或变异解析器复制到它自己的文件中。</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3602" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从<code class="fe nc nd ne nf b">internal/gql/resolvers/generated/resolver.go</code>、有<code class="fe nc nd ne nf b">"not implemented"</code>死机的<code class="fe nc nd ne nf b">func</code>中取出需要的部分，并删除除<code class="fe nc nd ne nf b">package resolvers</code>行之外的所有内容，否则，将会影响<code class="fe nc nd ne nf b">func</code>定义。</p><p id="5be8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，最后，我们可以为用户创建特定的解析器。一个包含所有<code class="fe nc nd ne nf b">internal/gql/resolvers/users.go</code>的新文件:</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1057" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能想知道<code class="fe nc nd ne nf b">tf</code>包是什么。</p><p id="bb52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还记得我在第2部分提到的<code class="fe nc nd ne nf b">transformations</code>文件和文件夹吗？好了，这里是我们需要将GQL输入的<em class="nm">转换为数据库<code class="fe nc nd ne nf b">user</code>结构的地方，以便轻松地将其保存在数据库中，并将其从数据库转换回解析器的GQL返回结构:</em></p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2229" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回到<code class="fe nc nd ne nf b">users.go</code>解析器，我已经将助手<code class="fe nc nd ne nf b">func</code>从解析器中分离出来，以使它们尽可能的最小和最可读。</p><p id="0b21" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下一个<a class="ae kz" href="https://gist.github.com/cmelgarejo/PART4.md" rel="noopener ugc nofollow" target="_blank">部分(4 </a>)中，当我们需要为解析器插入认证和权限时，将解析器传递给助手函数比仅仅传递ORM更有意义。</p><p id="e181" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">嘿，现在我们可以从数据库中查询和变异我们的用户了！</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/6f1fb758468285725a880a855060193e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EU3yDd1J36ZThMxk9SsiGA.png"/></div></div></figure><p id="1530" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数据库中的特定用户:</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/c6047984ace09b9823f20cea85a6d512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B-aBW5OKUQXuIHrlyVZM5g.png"/></div></div></figure><p id="53b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们总是可以创造一个新的:</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/2dedc6016cd40898fd1bcb5a4b9d70c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0OF4A5b9seC_tNipAHcdvw.png"/></div></div></figure><p id="2c12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并更新它:</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/baa344e4bc4de313ae013f4c69f6e662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*on7tkGnbtd6V4JxHFCixZg.png"/></div></div></figure><p id="9756" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好的，正如承诺的那样，让我们通过添加几个包来增强我们的小项目。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="5691" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">奖金部分</h1><h2 id="b644" class="nq ma it bd mb nr ns dn mf nt nu dp mj km nv nw mn kq nx ny mr ku nz oa mv ob bi translated"><strong class="ak">记录器包</strong></h2><p id="f151" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">包含的<code class="fe nc nd ne nf b">import "log"</code>包对我们来说已经足够了，但是我找到了这个结构良好的包，名为<a class="ae kz" href="http://github.com/sirupsen/logrus" rel="noopener ugc nofollow" target="_blank"> logrus </a>，并为它创建了一个包装器，以便在整个项目中使用，我创建了文件<code class="fe nc nd ne nf b">internal/logger/main.go</code>:</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/101c1bf789359261fe7b11e4d50ed343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dph44-4TLgWiTyfBbpBdDA.png"/></div></div></figure><p id="1667" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们有了一个具有良好特性的可扩展日志包。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/101c1bf789359261fe7b11e4d50ed343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dph44-4TLgWiTyfBbpBdDA.png"/></div></div></figure><h2 id="7cdd" class="nq ma it bd mb nr ns dn mf nt nu dp mj km nv nw mn kq nx ny mr ku nz oa mv ob bi translated">使用Realize在更改时添加服务器重装</h2><p id="7dd4" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">如果你对每次修改都要重启服务器感到烦恼…我已经在Node.js中开发了一段时间，我真的很想念<code class="fe nc nd ne nf b"><a class="ae kz" href="https://www.npmjs.com/package/nodemon" rel="noopener ugc nofollow" target="_blank">nodemon</a>.</code></p><p id="7dae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">谢天谢地，我们在Go中有更好的东西:</p><p id="df2c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nc nd ne nf b">$ go get github.com/tockins/realize</code></p><p id="3a9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在此之后，您将拥有<code class="fe nc nd ne nf b">$GOPATH/bin/realize</code>中的<code class="fe nc nd ne nf b">realize</code>可执行文件以供使用。创建一个<code class="fe nc nd ne nf b">.realize.yml</code>文件，或者在项目的根目录下运行<code class="fe nc nd ne nf b">$GOPATH/bin/realize init</code>，以交互方式创建它。</p><p id="de1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我的<code class="fe nc nd ne nf b">.yml</code>文件:</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5c1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这应该足以在我们接下来制作的脚本中运行它。将<code class="fe nc nd ne nf b">scripts/run.sh</code>复制到<code class="fe nc nd ne nf b">scripts/dev-run.sh</code>并修改如下:</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6919" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另外，将<code class="fe nc nd ne nf b">run.sh</code>改为:</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d65d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，现在你可以用<code class="fe nc nd ne nf b">.scripts/dev-run.sh</code>运行我们的项目，并在你每次修改Go文件时重新加载它！整洁，对不对？</p><p id="f5ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，在本系列的最后一部分中，所有的代码都可以在<a class="ae kz" href="https://github.com/cmelgarejo/go-gql-server/tree/tutorial/part-3" rel="noopener ugc nofollow" target="_blank">库中找到，这里是</a>！如果您有问题、批评或意见，请提出来，让我们一起了解更多！</p><p id="5b97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有，现在延续到这里了！</p><div class="la lb gp gr lc ld"><a href="https://medium.com/better-programming/creating-an-opinionated-go-gql-server-part-4-e9d9a7bb442a" rel="noopener follow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd iu gy z fp li fr fs lj fu fw is bi translated">创建自以为是的Go GQL服务器(第4部分)</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">在我们的项目中加入哥特元素</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">medium.com</p></div></div><div class="lm l"><div class="od l lo lp lq lm lr jz ld"/></div></div></a></div></div></div>    
</body>
</html>