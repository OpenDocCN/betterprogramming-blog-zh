<html>
<head>
<title>Kubernetes GraphQL Query in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的Kubernetes GraphQL查询</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kubernetes-graphql-query-in-go-2f88af8f0d67?source=collection_archive---------15-----------------------#2022-06-07">https://betterprogramming.pub/kubernetes-graphql-query-in-go-2f88af8f0d67?source=collection_archive---------15-----------------------#2022-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1c88" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建GraphQL服务器来搜索集群中的Kubernetes资源</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2ffc28e157d88c473c859af2cdac13af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_umWgQ9byP5o7mceC6Q2mg.png"/></div></div></figure><p id="ea45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在共享集群治理中，我们的部分职责是允许用户访问他们的资源，这由RBAC来完成，分配合理的权限，并通过kubectl支持用户的查询。对于后端开发人员来说“没有障碍”,而对于不熟悉命令行操作或kubectl的移动、web和数据开发人员来说却不是这样。</p><p id="f62e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，我们如何为我们的用户突破障碍呢？</p><p id="d658" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们用一个UI可查询接口来实现它，提供查询服务和API，如REST或GraphQL，以确保更容易的访问、更高的平台可见性和更好的用户体验。关于实现，我们用Go实现了一个GraphQL服务。</p><h1 id="41d6" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">为什么选择GraphQL</h1><p id="8080" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">REST和GraphQL是实现前端-后端交互时的两种流行选择。前者多年来一直是互联网标准，后者是一种脸书开源API查询语言，你可以在graphql.org的<a class="ae mn" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank">找到它的基础知识。这两者之间有很多比较，但在这里我只贴一张来自https://graphcms.com/blog/graphql-vs-rest-apis</a><a class="ae mn" href="https://graphcms.com/blog/graphql-vs-rest-apis" rel="noopener ugc nofollow" target="_blank">的照片，它最直观地展示了两者的区别。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/6ac49562e130e04f395cc3b612bad009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*neM86hxycp2veAi7"/></div></div></figure><p id="d9c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，不难得出为什么我们选择GraphQL而不是REST。</p><ul class=""><li id="7535" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated"><strong class="kw iu"> GraphQL更加灵活</strong>。</li></ul><p id="6a42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它的对手休息是刚性的。以<code class="fe my mz na nb b">Pod</code>查询(name，namespace，labels，container_name，maintainer)为例，我们可以发现为什么:REST通常会设计类似<code class="fe my mz na nb b">GET /pod/:name, GET /pod/:namespace</code>的多查询API。在返回的数据需要定制的场景中，只有两种方法，不是所有的信息都需要，而是只需要某些字段。</p><ul class=""><li id="07b1" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated">返回所有字段并用客户端过滤它们，当响应包含几十个字段时，会大大增加网络开销。</li><li id="58c7" class="mp mq it kw b kx nc la nd ld ne lh nf ll ng lp mu mv mw mx bi translated">服务器根据需要定制返回数据，这对后端工作负载来说很重要。</li></ul><p id="ba0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当Kubernetes中有几十种资源类型，每一种都支持至少三个查询，因此要设计数百个REST APIs，更不用说未来的维护了，这是多么令人沮丧啊。</p><p id="0faa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">GraphQL拯救了我们。它没有几十个API，使客户端能够独立选择数据内容，服务器能够准确地返回目标数据。此外，它为客户端提供了一种统一的格式来获取数据，无论数据类型是什么，都是以一种更加严格、可伸缩和可维护的方式。</p><pre class="kj kk kl km gt nh nb ni nj aw nk bi"><span id="5ecf" class="nl lr it nb b gy nm nn l no np">query {<br/>  Pod(namespace: $namespace, name: $name) {<br/>    metadata {<br/>      name<br/>      namespace<br/>      //labels<br/>      //annotations<br/>    }<br/>    status {<br/>      conditions {<br/>        lastTransitionTime<br/>        message<br/>        reason<br/>        status<br/>        type<br/>      }<br/>    }<br/>    spec {<br/>      //spec fields<br/>    }<br/>  }<br/>}</span></pre><ul class=""><li id="44ca" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated"><strong class="kw iu"> GraphQL是我们用户比较熟悉的。</strong></li></ul><p id="3449" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae mn" href="https://backstage.io/" rel="noopener ugc nofollow" target="_blank"> Backstage </a>，一个在很多大公司广泛使用的平台，给了GraphQL很好的支持，很多内部实现都基于GraphQL，使得我们的查询API更容易被用户接受，因为他们对它非常熟悉。</p><h1 id="0d7c" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">在Go中启用GraphQL</h1><p id="bff9" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated"><strong class="kw iu"> Schema </strong> (GraphQL schema语言)是GraphQL的核心，描述了我们要查询的数据模型，其中最基础也是最关键的是抽象和定义对象类型。</p><p id="8f0a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Go中开发GraphQL时，我们使用框架<a class="ae mn" href="https://github.com/graphql-go/graphql" rel="noopener ugc nofollow" target="_blank"> graphql-go </a>，在此基础上我们完成了graphql模式的定义。这四个要素是</p><ul class=""><li id="d2be" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated"><strong class="kw iu">类型模式</strong>，它定义了查询名称、查询使用的参数以及查询返回的字段和类型。</li><li id="845f" class="mp mq it kw b kx nc la nd ld ne lh nf ll ng lp mu mv mw mx bi translated"><strong class="kw iu">解析器</strong>，填充返回消息的回调方法。</li><li id="00a9" class="mp mq it kw b kx nc la nd ld ne lh nf ll ng lp mu mv mw mx bi translated"><strong class="kw iu">订阅方</strong>，返回增量更新的回调方法。</li><li id="ac60" class="mp mq it kw b kx nc la nd ld ne lh nf ll ng lp mu mv mw mx bi translated"><strong class="kw iu">突变</strong>，一种修改数据的方法(本例不赘述)。</li></ul><h2 id="6299" class="nl lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">类型架构</h2><p id="8629" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">定义字段。</p><pre class="kj kk kl km gt nh nb ni nj aw nk bi"><span id="a5b0" class="nl lr it nb b gy nm nn l no np">type Resource {<br/>  name: String!<br/>  labels: [Label!]<br/>  status: Status!<br/>}</span></pre><p id="d336" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe my mz na nb b">Type</code>就像Java中的<code class="fe my mz na nb b">Class</code>和Go中的<code class="fe my mz na nb b">struct</code>一样，由一组字段组成，每个字段都有对应的类型。如示例所示，类型有不同的类别，其中<a class="ae mn" href="https://graphql.org/learn/schema/#scalar-types" rel="noopener ugc nofollow" target="_blank">标量类型</a>是最常见的一种，像示例中的<code class="fe my mz na nb b">String</code>以及下面的许多类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/c75961b5050ed60ad5c7ad0776b932e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZSkyNvGfL0lXaRSa"/></div></div></figure><p id="c3ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">GraphQL还支持定制的标量类型。例子中的<code class="fe my mz na nb b">Label</code>和<code class="fe my mz na nb b">Status</code>属于<code class="fe my mz na nb b">Object Type</code>，这允许我们像定义类图一样定义GraphQL类型，并将它们链接在一起。</p><p id="4866" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe my mz na nb b">[]</code>、<code class="fe my mz na nb b">!</code>、<code class="fe my mz na nb b">[]!</code>为<code class="fe my mz na nb b">Type Modifier</code>，用于标记<code class="fe my mz na nb b">Field</code>为数组或非空，如<code class="fe my mz na nb b">[Label!]</code>表示<code class="fe my mz na nb b">labels</code>是由<code class="fe my mz na nb b">Label</code>类型组成的数组，数组可以为空，但<code class="fe my mz na nb b">Label</code>不可以。</p><p id="0636" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于GraphQL支持的其他<a class="ae mn" href="https://graphql.org/learn/schema/#interfaces" rel="noopener ugc nofollow" target="_blank">接口类型</a>、<a class="ae mn" href="https://graphql.org/learn/schema/#union-types" rel="noopener ugc nofollow" target="_blank">联合类型</a>和<a class="ae mn" href="https://graphql.org/learn/schema/#input-types" rel="noopener ugc nofollow" target="_blank">输入类型</a>，有兴趣可以参考文档中的例子。</p><p id="234b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">而在<code class="fe my mz na nb b">graph-go</code>端，也有一一对应的类型，比如<code class="fe my mz na nb b">graphql.String</code>，默认每个字段都是可空的，如果需要非空，可以用<code class="fe my mz na nb b">graphql.NewNonNull</code>包装类型。</p><h2 id="da8e" class="nl lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">分解器</h2><p id="d8ef" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">下一步是分配或解析字段。</p><p id="96d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe my mz na nb b">Resolver</code>以您定义的任何方式填写退货数据。为了查询Kubernetes集群中的资源，这里使用了client-go。</p><h2 id="a5af" class="nl lr it bd ls nq nr dn lw ns nt dp ma ld nu nv mc lh nw nx me ll ny nz mg oa bi translated">订户</h2><p id="3693" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">通过注册与<code class="fe my mz na nb b">List/Watch</code>非常相似的<code class="fe my mz na nb b">Subscriber</code>，我们可以随后更新GraphQL数据。如果你熟悉Kubernetes的告密者模式，这并不陌生。</p><p id="3c22" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于我们使用Kubernetes查询，<code class="fe my mz na nb b">client-go</code> informer是一个完美的匹配。但是在查询数据库或者像Kafka这样的消息库的时候，肯定有其他的方式来支持这个。</p><p id="6956" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe my mz na nb b">Type Schema</code>、<code class="fe my mz na nb b">Resolver</code>和<code class="fe my mz na nb b">Subscriber</code>之后，可以为Pod查询定义一个简单的GraphQL模式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="83eb" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">搜索集群并构建GraphQL APIs</h1><p id="4d5f" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">现在是关于应用client-go，它被认为是go与Kubernetes集群交互的最佳选择，来实现<code class="fe my mz na nb b">resolver</code>和<code class="fe my mz na nb b">subscriber</code>方法。</p><p id="bc90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至于Pod查询，我们直接使用<code class="fe my mz na nb b">clientset</code> API，将它们与我们上面定义的各种参数结合起来。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="6754" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于订阅者，我们用Informer定制<code class="fe my mz na nb b">Add</code>事件的更新，返回一个通道，用<code class="fe my mz na nb b">graphql-go</code>框架处理来自订阅者的通道更新消息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="2412" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">试验</h1><p id="1f03" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">让我们用Go <code class="fe my mz na nb b">httpserver</code>一步一步地启动GraphQL服务器。</p><ul class=""><li id="cb10" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated">创建<code class="fe my mz na nb b">graphqlHandler</code>。</li></ul><pre class="kj kk kl km gt nh nb ni nj aw nk bi"><span id="0c3e" class="nl lr it nb b gy nm nn l no np">graphqlHandler := handler.New(&amp;handler.Config{<br/>   Schema:     &amp;schema,<br/>   Pretty:     true,<br/>   GraphiQL:   false,<br/>   Playground: true,<br/>})</span></pre><ul class=""><li id="c810" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated">定义<code class="fe my mz na nb b">http handler</code>。</li></ul><pre class="kj kk kl km gt nh nb ni nj aw nk bi"><span id="721b" class="nl lr it nb b gy nm nn l no np">http.Handle("/graphql", graphqlHandler)</span></pre><ul class=""><li id="5a74" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated">启动<code class="fe my mz na nb b">server</code>。</li></ul><pre class="kj kk kl km gt nh nb ni nj aw nk bi"><span id="2627" class="nl lr it nb b gy nm nn l no np">err = http.ListenAndServe(":8080", nil)</span></pre><p id="eabd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在在<a class="ae mn" href="http://localhost:8080/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/graph QL</a>上测试一下。</p><p id="1821" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">投入</p><pre class="kj kk kl km gt nh nb ni nj aw nk bi"><span id="d420" class="nl lr it nb b gy nm nn l no np">query {<br/>  Pod(namespace: "prometheus") {<br/>    name<br/>    status<br/>  }<br/>}</span></pre><p id="8c6e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们得到了</p><pre class="kj kk kl km gt nh nb ni nj aw nk bi"><span id="baf8" class="nl lr it nb b gy nm nn l no np">{<br/>   "data":{<br/>      "Pod":{<br/>         "name":"prometheus-khdf12",<br/>         "status":"Running"<br/>      }<br/>   }<br/>}</span></pre><h1 id="9bf3" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">部署</h1><p id="ca1a" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">将程序封装到docker映像中并部署到集群后，我们现在就可以向用户开放服务了。</p><p id="0ecc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe my mz na nb b">Dockerfile</code>👇</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="907e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">需要注意的是，<a class="ae mn" href="https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity" rel="noopener ugc nofollow" target="_blank"> WorkloadIdentity </a>应该配置为在GKE集群中启用client-go。详见<a class="ae mn" href="https://medium.com/codex/cluster-governance-clean-up-resources-periodically-2a8d4f0966da" rel="noopener">集群治理—定期清理资源</a>。</p><h1 id="e2f7" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">更进一步</h1><p id="623f" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们完成的Kubernetes Pod的GraphQL查询远非完美，我们希望返回完整的Pod信息，而不是简单的<code class="fe my mz na nb b">PodShort</code>。</p><p id="1296" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，手动返回Pod字段还有一些问题。</p><ul class=""><li id="4221" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated">繁琐。可能有几十个字段，层层嵌套。</li><li id="f6e3" class="mp mq it kw b kx nc la nd ld ne lh nf ll ng lp mu mv mw mx bi translated">不便于维护。如果Kubernetes在未来版本中丢弃或添加一些字段，代码更新是不可避免的。</li><li id="0c3d" class="mp mq it kw b kx nc la nd ld ne lh nf ll ng lp mu mv mw mx bi translated">不利于扩张。一个Pod类型需要繁琐的定义，如果在集群中扩展到几十个甚至几百个类型和CRD会怎样？这似乎是一个不可能完成的任务。</li></ul><p id="561b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有没有灵活可扩展的方式？简单的答案是应用client-go来获取集群中的CRD定义，并将其解析到一个<code class="fe my mz na nb b">graph.Fields</code>集合中。详细回答请关注我的下一篇文章。</p><p id="a427" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读！</p><h1 id="5863" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">参考</h1><p id="ca66" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated"><a class="ae mn" href="https://graphcms.com/blog/graphql-vs-rest-apis" rel="noopener ugc nofollow" target="_blank">https://graphcms.com/blog/graphql-vs-rest-apis</a></p><p id="518a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae mn" href="https://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank">https://graphql.org/learn/schema/</a></p></div></div>    
</body>
</html>