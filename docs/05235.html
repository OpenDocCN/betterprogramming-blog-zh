<html>
<head>
<title>How to Write an Async Class Constructor in TypeScript or JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用TypeScript或JavaScript编写异步类构造函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-an-async-class-constructor-in-typescript-javascript-7d7e8325c35e?source=collection_archive---------2-----------------------#2020-06-23">https://betterprogramming.pub/how-to-write-an-async-class-constructor-in-typescript-javascript-7d7e8325c35e?source=collection_archive---------2-----------------------#2020-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2057" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">不使用常见的“init”或“builder”模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/602744d85e07165bc8af468cdd5eb7ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GC9pMcyzrH0f0Kcr2QJBBw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@juliandik?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">朱利安·迪克</a>在<a class="ae kv" href="/s/photos/lisbon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="fa4d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">创建类对象:通常建议的方法</h1><p id="25e8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe mk ml mm mn b">init</code>和<code class="fe mk ml mm mn b">builder</code>是我最常看到的推荐用于创建需要异步进程的类对象的两种方法。</p><h2 id="8dca" class="mo kx iq bd ky mp mq dn lc mr ms dp lg lx mt mu li mb mv mw lk mf mx my lm mz bi translated">实例初始化()</h2><pre class="kg kh ki kj gt na mn nb nc aw nd bi"><span id="645a" class="mo kx iq mn b gy ne nf l ng nh">class MyClass {</span><span id="1ee0" class="mo kx iq mn b gy ni nf l ng nh">  constructor() {<br/>    // set props normally<br/>    // nothing async can go here<br/>  }</span><span id="fc6c" class="mo kx iq mn b gy ni nf l ng nh">  public async init() {<br/>    // do your async steps here<br/>  }<br/>}</span></pre><p id="6291" class="pw-post-body-paragraph lo lp iq lq b lr nj jr lt lu nk ju lw lx nl lz ma mb nm md me mf nn mh mi mj ij bi translated">在<code class="fe mk ml mm mn b">init</code>方法中，您定义了一个<code class="fe mk ml mm mn b">async</code>实例方法，在对象实例化之后，作为附加步骤执行所有的<code class="fe mk ml mm mn b">async</code>设置。</p><pre class="kg kh ki kj gt na mn nb nc aw nd bi"><span id="cded" class="mo kx iq mn b gy ne nf l ng nh">const myClassInstance = new MyClass()</span><span id="702c" class="mo kx iq mn b gy ni nf l ng nh">// need to remember to call this on the instance<br/>await myClassInstance.init()</span></pre><p id="69bc" class="pw-post-body-paragraph lo lp iq lq b lr nj jr lt lu nk ju lw lx nl lz ma mb nm md me mf nn mh mi mj ij bi translated">我对这种方法的问题是，您必须相信创建类的调用者记得在创建类的实例时调用<code class="fe mk ml mm mn b">init()</code>方法。这显然是容易出错的，并且要求调用者有关于类的上下文。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="45d0" class="kw kx iq bd ky kz nv lb lc ld nw lf lg jw nx jx li jz ny ka lk kc nz kd lm ln bi translated">类对象生成器</h1><pre class="kg kh ki kj gt na mn nb nc aw nd bi"><span id="3b08" class="mo kx iq mn b gy ne nf l ng nh">class MyClass {</span><span id="066f" class="mo kx iq mn b gy ni nf l ng nh">  constructor() {<br/>    // set props normally<br/>    // nothing async can go here<br/>  }</span><span id="fba8" class="mo kx iq mn b gy ni nf l ng nh">  public static async build(): Promise&lt;MyClass&gt; {<br/>    // do your async stuff here<br/>    // now instantiate and return a class<br/>    return new MyClass()<br/>  }<br/>}</span></pre><p id="ea60" class="pw-post-body-paragraph lo lp iq lq b lr nj jr lt lu nk ju lw lx nl lz ma mb nm md me mf nn mh mi mj ij bi translated">类对象构建器方法稍微好一点。这种方法在其他语言中也作为一种变通方法使用。它包括在类对象上编写一个静态方法，该方法在同步实例化类对象并返回它之前执行异步处理。</p><pre class="kg kh ki kj gt na mn nb nc aw nd bi"><span id="221d" class="mo kx iq mn b gy ne nf l ng nh">const myClassInstance = await MyClass.build()</span></pre><p id="a11c" class="pw-post-body-paragraph lo lp iq lq b lr nj jr lt lu nk ju lw lx nl lz ma mb nm md me mf nn mh mi mj ij bi translated">与前一种方法相比，我更喜欢这种方法，因为它减轻了调用者记住调用额外的<code class="fe mk ml mm mn b">init()</code>函数的负担。然而，调用者仍然需要有上下文来使用非标准的静态类方法来实例化类，而不是标准的<code class="fe mk ml mm mn b">new MyClass()</code>语法。没有办法使构造函数私有，或者确保避免这种容易犯的错误。编辑:这对于Javascript仍然适用，但是Typescript 2.x <em class="oa">确实为类构造函数方法提供了私有/受保护的decorators，这将强制只有“build”方法可以实例化该类。将这一点添加到使用Typescript而不是Javascript的长长的理由列表中；)</em></p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="0fcf" class="kw kx iq bd ky kz nv lb lc ld nw lf lg jw nx jx li jz ny ka lk kc nz kd lm ln bi translated">功能选项模式</h1><p id="dd3d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我以前写过如何使用functional options模式来干净地构造类:</p><div class="ob oc gp gr od oe"><a href="https://medium.com/swlh/using-a-golang-pattern-to-write-better-typescript-58044b56b26c" rel="noopener follow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">使用Golang模式编写更好的打字稿</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">如何使用函数选项模式来构造更好的类定义</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">medium.com</p></div></div><div class="on l"><div class="oo l op oq or on os kp oe"/></div></div></a></div><p id="2eb5" class="pw-post-body-paragraph lo lp iq lq b lr nj jr lt lu nk ju lw lx nl lz ma mb nm md me mf nn mh mi mj ij bi translated">我意识到，通过使用这种模式来构造类，您已经使构造在创建时需要异步处理的类变得简单了，而不需要任何额外的东西，比如在创建对象后记得调用一个<code class="fe mk ml mm mn b">init()</code>函数。</p><h2 id="5c4e" class="mo kx iq bd ky mp mq dn lc mr ms dp lg lx mt mu li mb mv mw lk mf mx my lm mz bi translated">异步选项构造函数</h2><p id="2aee" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">下面是我以前的<code class="fe mk ml mm mn b">House</code>示例类的扩展，我用来通过函数选项演示构造。如您所见，异步创建所需要的只是创建一个异步选项构造函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ot ou l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">允许类的函数选项构造的类定义</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ot ou l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">施工容易！</p></figure><p id="50e9" class="pw-post-body-paragraph lo lp iq lq b lr nj jr lt lu nk ju lw lx nl lz ma mb nm md me mf nn mh mi mj ij bi translated">采用functional options模式来构造类还有<a class="ae kv" href="https://medium.com/swlh/using-a-golang-pattern-to-write-better-typescript-58044b56b26c" rel="noopener">其他的好处</a>，但是特别地，它允许创建一个可能需要异步过程的类对象。异步函数调用可以直接添加到类实例化步骤中，不需要单独的<code class="fe mk ml mm mn b">init()</code>调用，也不需要修改已经建立的类构造方法。调用者可以使用标准的<code class="fe mk ml mm mn b">new House()</code>语法来实例化类，并使用您建立的静态类构造器模式来构建他们的对象实例，而不需要太多关于类实现的额外上下文。</p><p id="ab33" class="pw-post-body-paragraph lo lp iq lq b lr nj jr lt lu nk ju lw lx nl lz ma mb nm md me mf nn mh mi mj ij bi translated">编码快乐！</p></div></div>    
</body>
</html>