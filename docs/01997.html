<html>
<head>
<title>Using Default Parameters and the Rest Operator in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中使用默认参数和Rest操作符</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-default-parameters-and-the-rest-operator-in-javascript-f714aa24165f?source=collection_archive---------11-----------------------#2019-10-29">https://betterprogramming.pub/using-default-parameters-and-the-rest-operator-in-javascript-f714aa24165f?source=collection_archive---------11-----------------------#2019-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c356" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">防止bug和开发人员错误</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8c58044771ce7d186315fd1dd0d47272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lSOIX36N0NKP1MJ_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3276" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在2015版本的JavaScript中，JavaScript函数现在可以接受函数中的默认参数，并且有rest运算符来捕获数组中的可选参数。</p><p id="ba32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于处理可选参数很方便，这些特性有很多用例。在我们拥有这两个特性之前，我们所拥有的只是带有被调用函数的参数列表的<code class="fe lv lw lx ly b">arguments</code>对象。</p><p id="7065" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止可选参数出现未定义的错误，我们所能做的就是直接检查每个参数，看它们是否被定义，然后直接设置值。</p><p id="cf0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对开发人员来说是痛苦的，因为我们希望函数获得一长串可选参数。使用默认参数时，参数的默认值直接在函数的签名中设置。这消除了许多检查代码的代码行。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="55f9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">默认参数</h1><p id="d11f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">JavaScript的缺省参数很简单。为了在我们的代码中设置它们，我们编写以下代码:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b7e1" class="nh mh it ly b gy ni nj l nk nl">const sum = (a,b=1) =&gt; a+b</span></pre><p id="18af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们将默认的参数值<code class="fe lv lw lx ly b">b</code>设置为<code class="fe lv lw lx ly b">1</code>，所以如果在调用<code class="fe lv lw lx ly b">sum</code>函数时没有传入第二个参数，那么<code class="fe lv lw lx ly b">b</code>会自动设置为<code class="fe lv lw lx ly b">1</code>。</p><p id="8550" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们如下调用<code class="fe lv lw lx ly b">sum</code>,我们将返回<code class="fe lv lw lx ly b">2</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6b2f" class="nh mh it ly b gy ni nj l nk nl">sum(1)</span></pre><p id="ef84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，现在我们不必担心可选参数是<code class="fe lv lw lx ly b">undefined</code>，如果没有为参数设置默认值，这将是另一个结果。这消除了在JavaScript中使参数可选时出现的许多错误来源。</p><p id="c13a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不使用默认参数的另一种方法是检查每个参数是否是<code class="fe lv lw lx ly b">undefined</code>。为此，我们编写了以下代码:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ad14" class="nh mh it ly b gy ni nj l nk nl">const sum = (a,b,c)=&gt;{<br/>  if (typeof b === 'undefined'){<br/>    b = 1;<br/>  }</span><span id="f50b" class="nh mh it ly b gy nm nj l nk nl">  if (typeof c === 'undefined'){<br/>    c = 1;<br/>  }<br/>  return a+b+c;<br/>}</span></pre><p id="466a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们不带参数调用下面的<code class="fe lv lw lx ly b">sum</code>函数，我们得到:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9d60" class="nh mh it ly b gy ni nj l nk nl">const sum = (a,b = 1,c = 1)=&gt; a+b+c;<br/>sum(1) // returns 3<br/>sum(1, 2) // returns 4</span></pre><p id="1833" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，我们用默认参数优雅地处理了丢失的参数。</p><p id="00a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于默认参数，传入<code class="fe lv lw lx ly b">undefined</code>等同于跳过参数。例如，如果我们调用下面的函数并传入<code class="fe lv lw lx ly b">undefined</code>，我们得到:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9845" class="nh mh it ly b gy ni nj l nk nl">const sum = (a,b = 1,c = 1)=&gt; a+b+c;<br/>sum(1,undefined) // returns 3<br/>sum(1,undefined,undefined) // returns 3<br/>sum(1, 2,undefined) // returns 4</span></pre><p id="a692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe lv lw lx ly b">undefined</code>和跳过参数一样。</p><p id="bec8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于传递给函数的其他falsy值来说，情况并非如此。因此，如果我们传入<code class="fe lv lw lx ly b">0</code>、<code class="fe lv lw lx ly b">null</code>、<code class="fe lv lw lx ly b">false</code>或空字符串，它们将被传入，默认的参数值将被覆盖。</p><p id="559f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有下面的代码:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="5165" class="nh mh it ly b gy ni nj l nk nl">const test = (num=1) =&gt; typeof num;<br/>test(undefined);<br/>test(null);<br/>test('');<br/>test(0);<br/>test(false);</span></pre><p id="9140" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到<code class="fe lv lw lx ly b">test(undefined)</code>的<code class="fe lv lw lx ly b">number</code>、<code class="fe lv lw lx ly b">test(null)</code>的<code class="fe lv lw lx ly b">object</code>、<code class="fe lv lw lx ly b">string</code>的<code class="fe lv lw lx ly b">test(string)</code>、<code class="fe lv lw lx ly b">test(0)</code>的<code class="fe lv lw lx ly b">number</code>、<code class="fe lv lw lx ly b">boolean</code>的<code class="fe lv lw lx ly b">test(false)</code>。</p><p id="a3ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着除了<code class="fe lv lw lx ly b">undefined</code>之外的任何东西都被传入，但是请注意，如果我们传入falsy值，然后对它们运行算术运算，falsy值将被转换为<code class="fe lv lw lx ly b">0</code>。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c2c5" class="nh mh it ly b gy ni nj l nk nl">const sum = (a,b = 1,c = 1)=&gt; a+b+c;<br/>sum(1,null)<br/>sum(1,null,false)<br/>sum(1, 2,'')</span></pre><p id="484e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，<code class="fe lv lw lx ly b">sum(1, null)</code>返回<code class="fe lv lw lx ly b">2</code>，因为<code class="fe lv lw lx ly b">b</code>被转换为<code class="fe lv lw lx ly b">0</code>，<code class="fe lv lw lx ly b">c</code>的默认值为<code class="fe lv lw lx ly b">1</code>。</p><p id="f1fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">sum(1)</code>返回<code class="fe lv lw lx ly b">1</code>，因为<code class="fe lv lw lx ly b">b</code>和<code class="fe lv lw lx ly b">c</code>转换为<code class="fe lv lw lx ly b">0</code>。<code class="fe lv lw lx ly b">sum(1, 2,’’)</code>为<code class="fe lv lw lx ly b">3</code>如同<code class="fe lv lw lx ly b">a</code>为<code class="fe lv lw lx ly b">1</code>，传入<code class="fe lv lw lx ly b">b</code>使其成为<code class="fe lv lw lx ly b">2</code>而不是得到<code class="fe lv lw lx ly b">1</code>的默认值，<code class="fe lv lw lx ly b">c</code>为空字符串，转换为<code class="fe lv lw lx ly b">0</code>。</p><p id="8160" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认参数是在调用时计算的，因此，如果没有参数传递给带有默认值的函数参数，则每次调用时都会设置默认参数。</p><p id="4cfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="861a" class="nh mh it ly b gy ni nj l nk nl">const append = (val, arr = [])=&gt;{<br/>  arr.push(val);<br/>  return arr;<br/>}<br/><br/>append(1);<br/>append(2);</span></pre><p id="7f14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">append(1)</code>返回<code class="fe lv lw lx ly b">[1]</code>，而<code class="fe lv lw lx ly b">append(2)</code>返回<code class="fe lv lw lx ly b">[2]</code>，因为我们没有向每个函数调用传递一个数组，所以<code class="fe lv lw lx ly b">arr</code>在每次运行时都被设置为一个空数组。</p><p id="549f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">知道我们可以在默认参数中传递函数返回值也很重要，所以如果我们有一个函数返回一些东西，我们可以在默认参数中调用它并将返回值赋给参数。</p><p id="69c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="5cc4" class="nh mh it ly b gy ni nj l nk nl">const fn = () =&gt; 2<br/>const sum(a, b = fn()) =&gt; a+b;</span></pre><p id="fc83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，如果我们调用<code class="fe lv lw lx ly b">sum(1)</code>，当<code class="fe lv lw lx ly b">fn</code>函数返回<code class="fe lv lw lx ly b">2</code>时，我们得到<code class="fe lv lw lx ly b">3</code>。如果我们想在将值作为参数赋值之前预先处理和组合值，这是非常方便的。</p><p id="a46d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认参数的另一个重要特性是，给定参数左侧的参数可作为默认值分配给该参数，因此我们可以有一个类似于下面函数的函数:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e2f7" class="nh mh it ly b gy ni nj l nk nl">const saySomething = (name, somethingToSay, message = `Hi ${name}. ${somethingToSay}`) =&gt; ({<br/>  name,<br/>  somethingToSay,<br/>  message<br/>});</span></pre><p id="db4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们给<code class="fe lv lw lx ly b">saySomething</code>函数中的<code class="fe lv lw lx ly b">message</code>参数分配了一个表达式。这对于操作数据，然后像我们之前通过赋值函数那样进行赋值是非常有用的。</p><p id="db75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以看到，默认参数依赖于它左侧的参数。这意味着默认参数不必是静态的。</p><p id="d605" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我们用填充了前两个参数的方式来调用它，比如<code class="fe lv lw lx ly b">saySomething(‘Jane’, ‘How are you doing?’)</code>。我们得到:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e049" class="nh mh it ly b gy ni nj l nk nl">{name: "Jane", somethingToSay: "How are you doing?", message: "Hi Jane. How are you doing?"}</span></pre><p id="01ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回的<code class="fe lv lw lx ly b">message</code>是我们定义的模板字符串。</p><p id="b07e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不能调用嵌套在函数中的函数来获取作为默认参数值的返回值。例如，如果我们写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c3c2" class="nh mh it ly b gy ni nj l nk nl">const fn = (a = innerFn())=&gt;{<br/>  const innerFn = () =&gt; { return 'abc'; }<br/>}</span></pre><p id="2e8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将导致抛出一个<code class="fe lv lw lx ly b">ReferenceError</code>，因为当默认参数被定义时，内部函数还没有被定义。</p><p id="4285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以将默认参数值设置在必需参数的左侧。参数仍然从左到右传递给参数，所以如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0c07" class="nh mh it ly b gy ni nj l nk nl">const sum = (a=1,b) =&gt; a+b</span></pre><p id="a46a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有<code class="fe lv lw lx ly b">sum(1)</code>，我们有<code class="fe lv lw lx ly b">NaN</code>返回<code class="fe lv lw lx ly b">1</code>。它被添加到<code class="fe lv lw lx ly b">undefined</code>中，因为我们没有为第二个参数传递任何东西，所以<code class="fe lv lw lx ly b">b</code>是<code class="fe lv lw lx ly b">undefined</code>。</p><p id="c845" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果我们写<code class="fe lv lw lx ly b">sum(1,2)</code>，那么<code class="fe lv lw lx ly b">3</code>被返回，因为我们已经将<code class="fe lv lw lx ly b">a</code>设置为<code class="fe lv lw lx ly b">1</code>并且将<code class="fe lv lw lx ly b">b</code>设置为<code class="fe lv lw lx ly b">2</code>。</p><p id="5c97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以使用析构赋值来设置默认参数值。例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="83f2" class="nh mh it ly b gy ni nj l nk nl">const sum = ([a,b] = [1,2], {c:c} = {c:3}) =&gt; a+b+c;</span></pre><p id="5ec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们毫无争议地称之为<code class="fe lv lw lx ly b">sum</code>。我们得到<code class="fe lv lw lx ly b">6</code>是因为JavaScript提供的析构赋值特性将<code class="fe lv lw lx ly b">a</code>设置为<code class="fe lv lw lx ly b">1</code>、<code class="fe lv lw lx ly b">b</code>设置为<code class="fe lv lw lx ly b">2</code>、<code class="fe lv lw lx ly b">c</code>设置为<code class="fe lv lw lx ly b">3</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6e7f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Rest运算符</h1><p id="642d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">rest操作符是一个JavaScript操作符，我们可以在函数中以数组的形式存储不确定数量的参数。</p><p id="394f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它看起来就像spread操作符，让我们将一个数组的条目或一个对象的键值对列表传播到另一个对象中。</p><p id="16ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有一个函数，它有一个很长的参数列表，我们可以使用rest操作符来缩短函数中的参数列表。</p><p id="2865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">rest运算符与以下语法一起使用:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="87b7" class="nh mh it ly b gy ni nj l nk nl">const fn = (a,b,..restOfTheArgs) =&gt; {...}</span></pre><p id="4fc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<code class="fe lv lw lx ly b">restOfTheArgs</code>是一个数组，包含除前两个参数之外的参数列表。例如，如果我们想要编写一个<code class="fe lv lw lx ly b">sum</code>函数，它将一个不定的数字列表作为参数，并对这些数字求和，我们可以编写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8c93" class="nh mh it ly b gy ni nj l nk nl">const sum = (a,b,...otherNums) =&gt; {<br/>  return a + b + otherNums.reduce((x,y)=&gt;x+y, 0);<br/>}</span></pre><p id="af03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，这对于有参数列表的函数来说非常方便。在此之前，我们必须使用函数中可用的<code class="fe lv lw lx ly b">arguments</code>对象来获取参数列表。</p><p id="32e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这并不理想，因为我们允许他们在参数中传递任何东西。有了rest操作符，我们就拥有了两个世界的精华。我们可以有一些固定的参数，而其余的保持灵活。</p><p id="2b3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得函数比具有固定数量参数的函数更加灵活，同时对于采用不确定数量参数的函数也具有一定的灵活性。</p><p id="a36a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">arguments</code>对象拥有函数的所有参数。此外，它不是一个真正的数组，所以数组函数对他们不可用。它只是一个对象，用索引和键来表示参数的位置。</p><p id="1ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" rel="noopener ugc nofollow" target="_blank">sort</a></code>、<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">map</a></code>、<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank">forEach</a></code>或<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" rel="noopener ugc nofollow" target="_blank">pop</a></code>这样的方法不能在<code class="fe lv lw lx ly b">arguments</code>对象上运行。它还具有其他属性。这给程序员造成了困惑。</p><p id="0b76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用rest操作符转换成数组的参数没有这些问题，因为它是一个真实的数组。</p><p id="faa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要调用我们编写的<code class="fe lv lw lx ly b">sum</code>函数，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="de62" class="nh mh it ly b gy ni nj l nk nl">const result = sum(1,2,3,4,5,6,7,8,9,10);</span></pre><p id="c866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">result</code>将是<code class="fe lv lw lx ly b">55</code>，因为我们把所有的论点总结在一起。<code class="fe lv lw lx ly b">otherNums</code>是除1和2以外的所有数字的数组。</p><p id="f44b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用rest操作符将一个参数列表析构为一个变量列表。这意味着我们可以用spread操作符将参数列表转换成数组，然后将参数数组分解成变量列表。</p><p id="d027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这非常有用，因为我们可以获得rest操作符所操作的数组条目，并将它们转换为命名变量。</p><p id="6120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="cdca" class="nh mh it ly b gy ni nj l nk nl">const sum = (a,b,...[c,d,e])=&gt; a+b+c+d+e;</span></pre><p id="18e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们可以使用rest操作符，但要限制函数接受的参数数量。</p><p id="fc7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们取函数参数<code class="fe lv lw lx ly b">a</code>和<code class="fe lv lw lx ly b">b</code>，也取<code class="fe lv lw lx ly b">c</code>、<code class="fe lv lw lx ly b">d</code>、<code class="fe lv lw lx ly b">e</code>为参数。然而，不使用rest操作符可能会更清楚，因为所有的参数都是固定的，我们可以直接列出参数。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="10fc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="9f3d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我们有了2015版的JavaScript，我们可以用参数做很多方便的事情。</p><p id="a2e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认值和rest操作符对于处理缺失的参数或操作参数非常方便。默认参数让我们为那些在函数调用参数中可能没有传递任何内容的参数设置默认值。</p><p id="1a45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">rest操作符让我们以数组的形式检索参数中列出的部分或全部项目。让我们用数组操作来操纵它们，或者使用析构赋值来将它们分解成单独的变量。</p></div></div>    
</body>
</html>