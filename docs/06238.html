<html>
<head>
<title>10 Storybook Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10个故事书最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-storybooks-best-practices-ad5fec0f145a?source=collection_archive---------0-----------------------#2020-09-12">https://betterprogramming.pub/10-storybooks-best-practices-ad5fec0f145a?source=collection_archive---------0-----------------------#2020-09-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c51d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更好的开发者体验，更好的软件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/88a9a68eae3c8276be5fc9511bfbee08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*L4dlC_VY6Elm3F0LhXDGjw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">10个故事书最佳实践</p></figure><p id="5720" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个关于<a class="ae lq" href="https://storybook.js.org/" rel="noopener ugc nofollow" target="_blank">故事书</a>和约定的帖子。它是基于我多年来使用Storybook的经验和其他开发者的经验。我在这里定义的最佳实践并不是修复和改进每个项目的灵丹妙药。它们是我认为值得尝试的想法和惯例的基线。希望它们能帮助你和你的团队拥有更好的开发者体验，并最终向世界交付更好的软件。</p><p id="7017" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我想你知道什么是故事书，并且对它有一些经验。这里的想法可以应用于任何规模的应用程序，并不特定于任何特定的框架(例如React或Vue)，但我写它们时考虑了大型应用程序、大型团队和多个贡献者。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="a7df" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak"> 1。每个组件一个故事书文件</strong></h1><p id="d1e2" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">故事文件应该包含:</p><ul class=""><li id="5d1a" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">一个<em class="ne">默认</em>故事</li><li id="cd79" class="mv mw it kw b kx nf la ng ld nh lh ni ll nj lp na nb nc nd bi translated">一个<em class="ne">游乐场</em>故事</li><li id="bb71" class="mv mw it kw b kx nf la ng ld nh lh ni ll nj lp na nb nc nd bi translated">和其他反映组件特定状态或API的故事。</li></ul><p id="c7de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认故事显示的组件只定义了其所需的属性。这为每个人创建了一个可视化的基线表示。因此，当人们想到一个特定的组件时，理想情况下，他们会记住默认故事所再现的内容。</p><p id="fe23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">游乐场故事用于帮助组件的消费者尝试不同的道具组合，并观察组件的反应。这可以在故事书版本5和以下版本中使用<a class="ae lq" href="https://www.npmjs.com/package/@storybook/addon-knobs" rel="noopener ugc nofollow" target="_blank">旋钮附件</a>来实现。您为组件的所有道具提供旋钮:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0353" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于故事书的最新版本(版本6)，游乐场的故事可以使用新的<a class="ae lq" href="https://storybook.js.org/docs/react/writing-stories/args" rel="noopener ugc nofollow" target="_blank"> Args特性</a>来编写。它看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4728" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，其他故事应该反映组件的特定状态或API。例如，如果我们有一个按钮组件，它有一个接受值<code class="fe nm nn no np b">primary</code>、<code class="fe nm nn no np b">secondary</code>、<code class="fe nm nn no np b">tertiary</code>或<code class="fe nm nn no np b">error</code>的<code class="fe nm nn no np b">type</code>属性。那么，我们将有四个故事:<code class="fe nm nn no np b">Button/Primary</code>、<code class="fe nm nn no np b">Button/Secondary</code>、<code class="fe nm nn no np b">Button/Tertiary</code>和<code class="fe nm nn no np b">Button /Error</code>。遵循这种模式有几个原因:</p><ul class=""><li id="ec00" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">共享精确定义了您想要引用的状态的组件的链接更容易，这在与QA和设计者交流时很有用。</li><li id="e248" class="mv mw it kw b kx nf la ng ld nh lh ni ll nj lp na nb nc nd bi translated">如果故事书与测试工具相结合，比如快照测试或视觉回归测试，那么每个故事就变成了一个单元测试。如果其中一个失败了，你知道是哪一个。</li><li id="8fa0" class="mv mw it kw b kx nf la ng ld nh lh ni ll nj lp na nb nc nd bi translated">通过使故事清晰，我们避免了隐藏旋钮下的组件状态。</li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="b9e1" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak"> 2。共处一地:故事书文件应该和它的组件呆在一起</strong></h1><p id="26d6" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">出于相同原因而更改的代码应该放在一起。从这个意义上说，给定组件的故事书文件很可能会随着该组件的改变而改变——所以要把它们放在一起。此外，如果组件文件夹被移动到项目中的另一个位置，或者甚至移动到另一个项目，那么将故事书文件一起移动会更容易。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="ddd2" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak"> 3。命名约定</strong></h1><p id="bb55" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">将故事书文件命名为<code class="fe nm nn no np b">[ComponentName].stories.[js|jsx|tsx]</code>。老实说，重要的是你和你的团队就命名约定达成一致，并且每个人都遵守它。就我个人而言，我喜欢在文件名中包含组件的名称，因为这样更容易在代码编辑器中找到。否则，我可能会以五个名为<code class="fe nm nn no np b">index.stories.tsx</code>的文件结束，然后我必须打开每个文件或者执行搜索来找到正确的文件。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="b586" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak"> 4。新组件必须有故事书</strong></h1><p id="c776" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">它有助于创建一个组件库并获得拥有一个组件库的好处。如果你的团队有某种公关清单，故事书可能是在将代码合并到master之前要检查的项目之一。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="0fbd" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak"> 5。更喜欢组件故事格式</strong></h1><p id="d7b7" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated"><a class="ae lq" href="https://storybook.js.org/docs/react/api/csf" rel="noopener ugc nofollow" target="_blank">组件故事格式或CSF </a>是故事书维护者推荐的编写故事的方式。它基本上是在故事文件中使用的一组约定。您不用使用<code class="fe nm nn no np b">storiesOf</code> API，而是编写常规的JavaScript函数并导出它们。Storybook将命名的和默认的导出内容转换为故事。CSF格式的一个很大的优点是代码看起来更干净，更容易阅读。代替故事书样板，你可以关注你的代码实际在做什么</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="6e67" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak"> 6。在构建代码库的同时构建故事</strong></h1><p id="cf5c" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">当你使用Storybook时，你应该清楚你的应用程序是如何组织的。这是我从loc Goyet那里得到的，他发了一篇很棒的帖子<a class="ae lq" href="https://dev.to/loicgoyet/how-i-manage-to-make-my-storybook-project-the-most-efficient-possible-2d8o" rel="noopener ugc nofollow" target="_blank">关于我如何设法让我的故事书项目变得最有效率。他的想法是让故事菜单反映故事在应用程序中的位置:</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/7ba0d476c01274d71601d6e7375f1331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-z14cb27bHIEOBRZcxwKxg.png"/></div></div></figure><p id="8052" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你看到上面Storybook中的菜单是如何与应用程序文件夹结构对齐的吗？</p><p id="cabe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该结构将帮助您:</p><ul class=""><li id="cfb3" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">更轻松地查找故事</li><li id="034b" class="mv mw it kw b kx nf la ng ld nh lh ni ll nj lp na nb nc nd bi translated">理解代码是如何组织的。</li></ul><p id="778a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您的应用程序中使用了协同定位，将相关项目放在一起，文件夹结构会让您了解应用程序的结构。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="218d" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak"> 7。一致的环境</strong></h1><p id="e1f2" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">当<strong class="kw iu"> </strong>我们在Storybook中开发时，我们想要隔离，但很可能我们仍然使用一些与应用程序共享的资源，如图像、数据、CSS、图标、翻译等。这很好，因为我们希望确保我们的组件在应用程序的上下文中使用时行为一致。例如，如果在应用程序中使用了一个本地化库，它可能会在Storybook中以相同的配置重用。另一个例子:如果使用第三方CSS，那么它应该包含在Storybook中，因为我们想知道该CSS是否会与我们的CSS冲突。目的是避免在应用程序中使用组件时出现意外。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c5be" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak"> 8。控制数据</strong></h1><p id="24b4" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">如果您注意到在许多不同的故事中需要相同的数据，那么创建一个mocks文件夹并添加JavaScript文件可能是一个好主意，这些文件导出将创建可重用数据的工厂函数。让我们假设我们有一个显示用户图像、姓名、锚点的虚拟角色组件，并且这个组件被用在多个地方。我们可以有一个名为mocks/user.js的文件，其内容如下:</p><pre class="kj kk kl km gt nv np nw nx aw ny bi"><span id="1f87" class="nz lz it np b gy oa ob l oc od">const getUser = (overrides = {}) =&gt; {<br/>    const defaultValues = {<br/>        username: "Some User",<br/>        anchor: "<a class="ae lq" href="http://twitter.com/someuser" rel="noopener ugc nofollow" target="_blank">@someuser</a>",<br/>        image: "<a class="ae lq" href="https://webapp/static/images/someuser.png" rel="noopener ugc nofollow" target="_blank">https://webapp/static/images/someuser.png</a>"<br/>    };<br/>    return Object.assign(defaultValues, overrides);<br/>};</span><span id="11db" class="nz lz it np b gy oe ob l oc od">export default getUser;</span></pre><p id="921c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">工厂为什么发挥作用？只是为了确保我们每次都得到一个新的对象。如果我们导入一个对象，我们可能会不小心修改它，导致错误的结果。我见过。同样，这里我使用<code class="fe nm nn no np b">Object.assign</code>作为例子，但是你可能需要更复杂的东西来处理数组和对象的合并。Lodash 和<a class="ae lq" href="https://ramdajs.com/docs/#merge" rel="noopener ugc nofollow" target="_blank"> RamdaJS </a>都有这个功能——ramda js太棒了！</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="a7f0" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak"> 9。创建你自己的装饰器和插件(如果有意义的话)</strong></h1><p id="1a30" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated"><a class="ae lq" href="https://storybook.js.org/docs/react/writing-stories/decorators" rel="noopener ugc nofollow" target="_blank">装饰器</a>基本上是包装另一段代码并赋予它额外功能的函数。在Storybook中，装饰器可以应用于单独的故事(称为故事装饰器)，一个组件的所有故事(称为组件装饰器)，或者项目中的所有故事(称为全局装饰器)。基线是这样的:</p><pre class="kj kk kl km gt nv np nw nx aw ny bi"><span id="2052" class="nz lz it np b gy oa ob l oc od">const myDecorator = (Story) =&gt; &lt;div&gt;&lt;Story /&gt;&lt;/div&gt;</span></pre><p id="1162" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在React应用程序中，让提供者包装应用程序或应用程序的一部分是很常见的。例如，如果你需要用一个提供者来包装你的组件，那么装饰器是一个不错的选择。或者，如果您想为某个组件添加一个边距，这样它就不会接触到画布的边界，您可以使用这样的装饰器:</p><pre class="kj kk kl km gt nv np nw nx aw ny bi"><span id="80f8" class="nz lz it np b gy oa ob l oc od">const withMargin = (Story) =&gt; &lt;div style={{ margin: '3em' }}&gt;&lt;Story/&gt;&lt;/div&gt;</span></pre><p id="3908" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">附加组件是故事书的扩展，可以帮助你以各种方式配置和扩展故事书。开发附加组件更复杂，但并不难，而且你有更多的能力和灵活性。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="ebff" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak"> 10。认真对待故事书的使用和维护</strong></h1><p id="d59f" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">故事书对开发UI有很大的帮助，因为它鼓励你关注组件的界面，这将帮助你拥有更通用和精简的组件。通用组件和精益组件非常灵活，可以在不同的环境中使用。最后，如果您有一些灵活的组件，您可能需要更少的组件。组件越少意味着代码越少；更少的代码意味着更少的出错机会；更少的漏洞意味着更快乐的用户和更快乐的开发者。所以，保持故事书运行良好，不要让支离破碎的故事继续存在，当它们变得混乱时，重构和重新安排。</p><p id="6af1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据我的经验，只有当人们拥有所有权时，事情才会得到改善。如果没有一群人负责照看故事书，那么保持故事书的发展和获得使用故事书的好处将会非常困难。每个人都有责任贡献并遵循团队的约定，但是指派某人或一组人作为故事书维护者可能会有所帮助。故事书的维护者可以让其他人负责遵守约定——他们可以在你的团队中改进故事书的使用。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="b994" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="8cdb" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">这些是我在使用Storybook五年后，从比我聪明的其他开发人员的经验中收集的一些想法。我真心希望你学到了新的东西，并且很乐意尝试故事书，或者让故事书对你和你的团队更好。如果你有任何问题或建议让这篇文章更好，请在下面的评论中告诉我。</p><p id="5af9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">谢谢！</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="8a69" class="nz lz it bd ma of og dn me oh oi dp mi ld oj ok mk lh ol om mm ll on oo mo op bi translated">参考</h2><ul class=""><li id="4027" class="mv mw it kw b kx mq la mr ld oq lh or ll os lp na nb nc nd bi translated">【https://storybook.js.org/ T4】</li><li id="9bb0" class="mv mw it kw b kx nf la ng ld nh lh ni ll nj lp na nb nc nd bi translated"><a class="ae lq" href="https://www.learnstorybook.com/" rel="noopener ugc nofollow" target="_blank">https://www.learnstorybook.com/</a></li><li id="1d96" class="mv mw it kw b kx nf la ng ld nh lh ni ll nj lp na nb nc nd bi translated"><a class="ae lq" href="https://dev.to/loicgoyet/how-i-manage-to-make-my-storybook-project-the-most-efficient-possible-2d8o" rel="noopener ugc nofollow" target="_blank">https://dev . to/loic goyet/how-I-manage-make-my-story book-project-the-most-efficient-possible-2d8o</a></li><li id="486b" class="mv mw it kw b kx nf la ng ld nh lh ni ll nj lp na nb nc nd bi translated"><a class="ae lq" href="https://blog.hichroma.com/the-delightful-storybook-workflow-b322b76fd07?gi=48bcfdd9231b" rel="noopener ugc nofollow" target="_blank">https://blog . hich Roma . com/the-pleasant-story book-workflow-b 322 b 76 FD 07？gi=48bcfdd9231b </a></li><li id="8453" class="mv mw it kw b kx nf la ng ld nh lh ni ll nj lp na nb nc nd bi translated"><a class="ae lq" href="https://www.learnstorybook.com/design-systems-for-developers/react/en/distribute/" rel="noopener ugc nofollow" target="_blank">https://www . learn storybook . com/design-systems-for-developers/react/en/distribute/</a></li><li id="c168" class="mv mw it kw b kx nf la ng ld nh lh ni ll nj lp na nb nc nd bi translated"><a class="ae lq" href="https://www.richsoni.com/posts/2019-01-29-storybook-architecture-audit/" rel="noopener ugc nofollow" target="_blank">https://www . rich soni . com/posts/2019-01-29-story book-architecture-audit/</a></li><li id="b3ce" class="mv mw it kw b kx nf la ng ld nh lh ni ll nj lp na nb nc nd bi translated">https://github.com/lauthieb/awesome-storybook<a class="ae lq" href="https://github.com/lauthieb/awesome-storybook" rel="noopener ugc nofollow" target="_blank"/></li></ul></div></div>    
</body>
</html>