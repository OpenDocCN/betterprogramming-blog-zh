<html>
<head>
<title>3 Alternatives for Regular Custom Classes in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中常规自定义类的3种替代方案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-alternatives-for-regular-custom-classes-in-python-2f2bafd66338?source=collection_archive---------14-----------------------#2022-04-04">https://betterprogramming.pub/3-alternatives-for-regular-custom-classes-in-python-2f2bafd66338?source=collection_archive---------14-----------------------#2022-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d586" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在适当的时候使用它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0f85452d2d2d3653ffb6b13e0f6d40f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AHAGpTvBT8NYkrlL"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">无刷</a>上<a class="ae ky" href="https://unsplash.com/@headwayio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">车头时距</a>拍摄</p></figure><p id="3789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在任何项目的大部分时间里，我们都在努力定义各种类来建模我们的数据。因此，构建适当的类是使您的项目健壮和可维护的基本技术。通常，自定义类采用以下形式:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fab3" class="ma mb it lw b gy mc md l me mf">class CustomClass<br/>    # the body of the class<br/>    pass</span></pre><p id="8f2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有几种情况下你想使用不同的东西。在本文中，我将回顾与为您的项目定义类相关的三种选择。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="f38c" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">命名元组</h1><p id="89ff" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我们知道元组是Python中基本的内置数据结构之一。当我们定义一个元组时，我们简单地使用括号将它的项括起来，用逗号分隔，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f64e" class="ma mb it lw b gy mc md l me mf">student_data = ("John", "M")</span></pre><p id="1700" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一种内置类型，元组被设计为通用类型，以便它们可以用于一般用途。然而，这种通用性是有代价的——元组不知道它们保存的是什么数据。对于元组来说，它们不是由我们“定义”的，它们可以按照自己的意愿保存任何项目，没有任何限制。相比之下，自定义类知道它保存什么数据，尤其是属性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/602677550bc434a2031ddeeba29a807b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g1F1s3GCDhXWMJmy-Df5WQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自动完成提示</p></figure><p id="8239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，在PyCharm IDE中，您可以看到<code class="fe nk nl nm lw b">student</code>的属性被自动填充用于代码完成，因为IDE知道<code class="fe nk nl nm lw b">student</code>可以有什么数据。</p><p id="7997" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了提供“普通”类的好处(例如，点符号)，您实际上可以创建一个基于称为命名元组的元组的数据模型:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/1677909ddf23a2ed8e4ef4c488499658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqRlSdayo-epn3UeF48a3g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">命名元组</p></figure><p id="6ae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建一个命名元组，您需要从内置的<code class="fe nk nl nm lw b">collections</code>模块中导入<code class="fe nk nl nm lw b">namedtuple</code>函数。<code class="fe nk nl nm lw b">namedtuple</code>函数可以被称为工厂函数，因为你用它来创建一个新类。具体来说，您以字符串的形式提供类名，以列表的形式提供属性。对于命名元组的实例，它知道这样的实例保存什么数据。</p><blockquote class="nn no np"><p id="b5b5" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><strong class="lb iu">问题</strong>:你什么时候想在常规定制类上使用命名元组？</p><p id="3c56" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><strong class="lb iu">回答</strong>:当数据模型作为数据容器时，可以使用命名元组，因为它们不支持可变性，这意味着你不能改变命名元组实例的属性，不像普通类的实例。值得注意的是，命名元组是元组的一个子类，所以它们的大小很小。如果需要创建许多实例，命名元组可以节省内存。</p></blockquote><p id="fc47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于命名元组的更多信息，请参考我的<a class="ae ky" href="https://medium.com/swlh/empower-a-lightweight-python-data-structure-from-tuples-to-namedtuples-ca4abddd8ef6" rel="noopener">上一篇文章</a>。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="f479" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">列举</h1><p id="38ff" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">枚举是一种技术，它涉及到创建一个类，将同一概念的相关成员保存在一起。例如，北、南、东和西是方向概念的成员。再比如，春、夏、秋、冬是季节概念的成员。</p><p id="c7d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python的标准库中，enum模块提供了创建枚举类的基本功能。我们先来看一些代码:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0d1a" class="ma mb it lw b gy mc md l me mf">from enum import Enum<br/><br/>class Season(Enum):<br/>    SPRING = 1<br/>    SUMMER = 2<br/>    FALL = 3<br/>    WINTER = 4</span></pre><p id="975d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，Season类是Enum的一个子类，它包含四个季节。在这里，我将这四个成员大写，因为它们代表常数。然而，如果你喜欢小写，这是你的选择。每个成员都有两个重要的属性:<code class="fe nk nl nm lw b">name</code>和<code class="fe nk nl nm lw b">value</code>，如下图:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="23e6" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; spring = Season.SPRING<br/>&gt;&gt;&gt; spring.name<br/>'SPRING'<br/>&gt;&gt;&gt; spring.value<br/>1</span></pre><p id="66bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这些值，您可以将它们命名为增量整数。如果要构造枚举成员，它们会很有用。假设您有一个API，并收到一个响应2，作为季节的值。您可以按如下方式创建成员:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5c64" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; fetched_season_value = 2<br/>&gt;&gt;&gt; matched_season = Season(fetched_season_value)<br/>&gt;&gt;&gt; matched_season<br/>&lt;Season.SUMMER: 2&gt;</span></pre><p id="18c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">enumeration类的另一个有用的特性是支持迭代。也就是说，枚举类是可迭代的。例如，您可以通过运行以下命令来创建这些枚举数的列表:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="32dc" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; list(Season)<br/>[&lt;Season.SPRING: 1&gt;, &lt;Season.SUMMER: 2&gt;, &lt;Season.FALL: 3&gt;, &lt;Season.WINTER: 4&gt;]</span></pre><p id="8c7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想知道这四个季节的名字，你也可以用列表理解法:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d293" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; [x.name for x in Season]<br/>['SPRING', 'SUMMER', 'FALL', 'WINTER']</span></pre><blockquote class="nn no np"><p id="63fd" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><strong class="lb iu">问题</strong>:你什么时候想在常规定制类上使用枚举？</p><p id="be49" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><strong class="lb iu">答</strong>:当你有一组成员落在同一个概念里，就要用枚举。尽管您可以创建一个常规类，并使用类属性来保存这些成员，但默认情况下，常规类不支持迭代。此外，它没有本机属性(如名称和值)来操作这些成员。</p></blockquote><p id="eafa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于枚举的更多信息，请参考我的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/take-advantage-of-the-enum-class-to-implement-enumerations-in-python-1b65b530e1d">上一篇文章</a>。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="b5d8" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">数据类别</h1><p id="915e" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">当我说数据类时，我只是说我们正在使用<code class="fe nk nl nm lw b">dataclass</code>装饰器创建一个保存数据的类。与装饰函数的典型装饰器不同，<code class="fe nk nl nm lw b">dataclass</code>装饰器装饰一个类，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="134e" class="ma mb it lw b gy mc md l me mf">from dataclasses import dataclass<br/><br/>@dataclass<br/>class Student:<br/>    name: str<br/>    gender: str</span></pre><p id="1cf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm lw b">dataclass</code>装饰器是<code class="fe nk nl nm lw b">dataclasses</code>模块的一部分。我们简单地把这个装饰器放在我们定义的类上面。在类的主体中，我们指定了类的属性以及它们各自的类型。</p><p id="8382" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">装修看起来很直白。让我们看看这些额外的功能对于<code class="fe nk nl nm lw b">dataclass</code>装饰者来说是什么。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9b87" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; student = Student("John", "M")<br/>&gt;&gt;&gt; student.name<br/>'John'<br/>&gt;&gt;&gt; student.gender<br/>'M'</span></pre><p id="7089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，一个重要的事情是我们没有显式定义<code class="fe nk nl nm lw b">__init__</code>方法，但是修饰后的Student类知道如何构造一个实例！这是因为<code class="fe nk nl nm lw b">dataclass</code>装饰器使用带注释的属性(例如<code class="fe nk nl nm lw b">name: str </code> &amp; <code class="fe nk nl nm lw b">gender: str</code>)在幕后为我们创建了初始化<code class="fe nk nl nm lw b">__init__ </code>方法。</p><p id="487a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe nk nl nm lw b">__init__</code>方法之外，<code class="fe nk nl nm lw b">dataclass</code>装饰器还为我们实现了<code class="fe nk nl nm lw b">__repr__</code>方法，这允许我们检查实例:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0c16" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; repr(student)<br/>"Student(name='John', gender='M')"</span></pre><p id="bfca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，因为如果一个类没有实现<code class="fe nk nl nm lw b">__str__</code>，那么<code class="fe nk nl nm lw b">__repr__</code>就是后备。因此，如果您打印数据类的实例，您将得到相同的字符串输出:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8554" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; print(student)<br/>Student(name='John', gender='M')</span></pre><blockquote class="nn no np"><p id="0a25" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><strong class="lb iu">问题</strong>:你什么时候想使用数据类而不是常规的自定义类？</p><p id="31b5" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><strong class="lb iu">答</strong>:当你想为一个自定义类消除一些样板文件，比如实现__init__和__repr__。如果您想在__init__方法中获得更多定制的行为，dataclass装饰器可能不是您的最佳选择。</p></blockquote><p id="b5a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于枚举的更多信息，请参考我的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/6-things-to-know-to-get-started-with-python-data-classes-c795bf7e0a74">上一篇文章</a>。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="86f2" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结论</h1><p id="e56c" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在本文中，我们回顾了除常规自定义类之外的三种可选方法:命名元组、枚举和数据类。它们各有利弊，您应该根据自己的需要选择合适的数据模型。不要将自己局限于常规的定制类，可能会有更好的内置解决方案适合您。</p><p id="6039" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住不要多此一举！</p></div></div>    
</body>
</html>