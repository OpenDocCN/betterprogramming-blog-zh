<html>
<head>
<title>Getting Started With Operations and OperationQueues in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的操作和操作队列入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-operations-and-operationqueues-in-swift-893c4406eabf?source=collection_archive---------10-----------------------#2019-11-26">https://betterprogramming.pub/getting-started-with-operations-and-operationqueues-in-swift-893c4406eabf?source=collection_archive---------10-----------------------#2019-11-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dfd9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Swift中的并发性和关注点分离</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f71d07d050a961c472a5851e10ed272f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bx0CxcXa4QjjfPU1YdN8ZA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@halgatewood?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">哈尔·盖特伍德</a>在<a class="ae ky" href="https://unsplash.com/s/photos/queue?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="71b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift中的操作是在跟踪进度和依赖关系的同时将职责划分到几个类别的强大方法。它们的正式名称是NSOperations，与<code class="fe lv lw lx ly b">OperationQueue</code>结合使用。</p><p id="ae96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请务必先阅读我关于Swift中的<a class="ae ky" href="https://www.avanderlee.com/swift/concurrent-serial-dispatchqueue/" rel="noopener ugc nofollow" target="_blank">并发性的文章</a>，这样您就知道了队列和分派的基础知识。操作与调度块有很多共同之处，但是有更多的好处。让我们开始吧！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="36db" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Swift中的操作是什么？</h1><p id="dbb7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一个操作通常负责一个同步任务。这是一个抽象类，从来没有直接使用过。您可以利用系统定义的<code class="fe lv lw lx ly b">BlockOperation</code>子类或者创建自己的子类。您可以通过将操作添加到<code class="fe lv lw lx ly b">OperationQueue</code>或手动调用start方法来启动操作。但是，强烈建议将管理状态的全部责任交给<code class="fe lv lw lx ly b">OperationQueue</code>。</p><p id="1ef0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用系统定义的<code class="fe lv lw lx ly b">BlockOperation</code>看起来如下:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0913" class="nh mh it ly b gy ni nj l nk nl">let blockOperation = BlockOperation {<br/>    print("Executing!")<br/>}<br/><br/>let queue = OperationQueue()<br/>queue.addOperation(blockOperation)</span></pre><p id="9084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也可以通过直接在队列中添加块来实现:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e12c" class="nh mh it ly b gy ni nj l nk nl">queue.addOperation {<br/>  print("Executing!")<br/>}</span></pre><p id="6448" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定的任务被添加到<code class="fe lv lw lx ly b">OperationQueue</code>中，它将尽快开始执行。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="793e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建自定义操作</h1><p id="0cf3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您创建了自定义操作的关注点分离。例如，您可以为导入内容创建一个自定义实现，为上传内容创建另一个自定义实现。</p><p id="3547" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码示例显示了用于导入内容的自定义子类:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="42cd" class="nh mh it ly b gy ni nj l nk nl">final class ContentImportOperation: Operation {<br/><br/>    let itemProvider: NSItemProvider<br/><br/>    init(itemProvider: NSItemProvider) {<br/>        self.itemProvider = itemProvider<br/>        super.init()<br/>    }<br/><br/>    override func main() {<br/>        guard !isCancelled else { return }<br/>        print("Importing content..")<br/>        <br/>        // .. import the content using the item provider<br/><br/>    }<br/>}</span></pre><p id="2a49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该类接受一个项提供程序，并在main方法中导入内容。对于同步操作，<code class="fe lv lw lx ly b">main()</code>函数是唯一需要重写的方法。将操作添加到队列中，并设置一个完成块来跟踪完成情况:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="2b1e" class="nh mh it ly b gy ni nj l nk nl">let fileURL = URL(fileURLWithPath: "..")<br/>let contentImportOperation = ContentImportOperation(itemProvider: NSItemProvider(contentsOf: fileURL)!)<br/><br/>contentImportOperation.completionBlock = {<br/>    print("Importing completed!")<br/>}<br/><br/>queue.addOperation(contentImportOperation)<br/><br/>// Prints:<br/>// Importing content..<br/>// Importing completed!</span></pre><p id="f106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将您导入内容的所有逻辑转移到一个单独的类中，您可以在这个类中跟踪进度、完成情况，并且可以轻松地编写测试。</p><h2 id="a193" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated">操作的不同状态</h2><p id="25c8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">根据操作的当前执行状态，操作可以处于几种状态。</p><ul class=""><li id="3028" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">准备好了:准备开始了</li><li id="e7fc" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><strong class="lb iu">正在执行:</strong>任务当前正在运行</li><li id="3f26" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><strong class="lb iu">完成:</strong>流程完成后</li><li id="1735" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><strong class="lb iu">取消:</strong>任务被取消</li></ul><p id="f877" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">知道一个操作只能执行一次是很重要的。每当它处于完成或取消状态时，您就不能再重新启动同一个实例。</p><p id="bce6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在自定义实现中，您需要在执行之前手动检查取消状态，以确保任务取消。要知道，当一个操作同时开始和取消时，可能会发生数据竞争。你可以在我的博客文章“<a class="ae ky" href="https://www.avanderlee.com/swift/thread-sanitizer-data-races/" rel="noopener ugc nofollow" target="_blank"> Thread Sanitizer解释:Swift </a>中的数据竞争”中阅读更多关于数据竞争的内容</p><p id="4c4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦任务完成,<code class="fe lv lw lx ly b">OperationQueue</code>将自动从其队列中删除该任务，这发生在执行或取消之后。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f99c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">利用依赖关系</h1><p id="2bfa" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">使用操作的一个好处是可以使用依赖关系。您可以轻松地在两个实例之间添加依赖关系。例如，要在内容导入后开始上传:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b803" class="nh mh it ly b gy ni nj l nk nl">let fileURL = URL(fileURLWithPath: "..")<br/>let contentImportOperation = ContentImportOperation(itemProvider: NSItemProvider(contentsOf: fileURL)!)<br/>contentImportOperation.completionBlock = {<br/>    print("Importing completed!")<br/>}<br/><br/>let contentUploadOperation = UploadContentOperation()<br/>contentUploadOperation.addDependency(contentImportOperation)<br/>contentUploadOperation.completionBlock = {<br/>    print("Uploading completed!")<br/>}<br/><br/>queue.addOperations([contentImportOperation, contentUploadOperation], waitUntilFinished: true)<br/><br/>// Prints:<br/>// Importing content..<br/>// Uploading content..<br/>// Importing completed!<br/>// Uploading completed!</span></pre><p id="4582" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有在内容导入完成后，上传才会开始。它不考虑取消，这意味着如果导入操作取消，上传仍然会开始。</p><p id="7afa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您必须实现一个检查来查看依赖项是否被取消:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8b26" class="nh mh it ly b gy ni nj l nk nl">final class UploadContentOperation: Operation {<br/>    override func main() {<br/>        guard !dependencies.contains(where: { $0.isCancelled }), !isCancelled else {<br/>            return<br/>        }<br/><br/>        print("Uploading content..")<br/>    }<br/>}</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b1b7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="466f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我希望您对开始在Swift中实施运营感到兴奋。它是一颗隐藏的宝石，允许您分离关注点，添加任务之间的依赖关系，并跟踪完成情况。</p></div></div>    
</body>
</html>