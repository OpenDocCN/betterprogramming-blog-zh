# JavaScript 中的函数式编程:映射、过滤和归约

> 原文：<https://betterprogramming.pub/functional-programming-in-javascript-map-filter-and-reduce-12d9b8bbc56>

## 检查 map()、filter()和 reduce()的不同实现

![](img/7419a045a74a1476b9e23395f612f824.png)

由 [Maria Shanina](https://unsplash.com/@mariashanina?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄。

我被教导以命令的方式编写 JavaScript。这可能是因为在我学习的时候，这是你能做的全部事情。但是随着时间的推移，这种语言已经进化到使各种范例成为可能。

我是函数式编程的超级粉丝。几乎在所有情况下我都更喜欢它。所以我喜欢 JavaScript 包含像`map`、`filter`和`reduce`这样的酷操作——我一直在使用它们。

但是我确实经常想知道我自己将如何编写这些函数。我认为这是一个值得做的练习，因为解构这些抽象意味着我将能够更好地推理它们，并以不同的方式重建它们来解决其他问题。这只会让我成为一个更好的程序员。

所以下面我就这么做了。我还为每一个包含了两个实现(一个是命令式的，一个是功能式的)，希望能引发一场关于哪种范式总体上更好的讨论。

# 地图

![](img/725e588529ef5beb79264a7c096acb53.png)

克里斯·劳顿在 [Unsplash](https://unsplash.com/s/photos/change?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片。

`Map`通过应用一些函数来转换数组中的每个元素，然后返回转换后的值列表。

类似于`[1, 2, 3]`变成`f(x) => x * 2`变成`[2, 4, 6]`。

## 简单溶体

这是可行的，也是可读的，但是由于一些原因，我不喜欢它。首先，我们使用了循环结构。循环结构不是功能性的，它们有笨拙的语法(打字错误集中)，并且它们内部的东西很难测试。这是一个简单的例子，但是想象一个必须做十件事情的循环。很快就失控了。

递归可能是更好的方法。

## *递归求解*

这里，该函数使用 spread 运算符将数组中的第一个元素与其他元素分开。然后，如果它是未定义的，我们就结束了，我们只是返回。如果没有，我们对当前元素应用回调，然后对其余元素调用`map`函数。这个函数将继续调用自己，直到它将回调应用到所有元素，然后它返回所有内容。第 11 行的 spread 操作符很重要，因为我们希望以后得到一个扁平的数组。如果没有它，我们会得到这样的结果:`map [1, 2, 3]`会变成`[2, [4, [6, []]]]`。

在我看来，这样好多了。我能够确切地看到发生了什么，每一步都有明确的名称，我没有笨拙的语法，并且很容易测试(因为我不必进入我不能容易地检查其状态的循环范围)。

# 过滤器

![](img/e5ba10de4e4b9ca9d194aef457774aae.png)

Simone Hutsch 在 [Unsplash](https://unsplash.com/s/photos/filter?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片。

像`map`，`filter`对数组的每个元素应用一个函数。然而，它并不转换这些值，而是通过评估一些布尔条件来确定是否将它们包含在返回的数组中。这被称为一个*谓词*函数。

于是，`[‘Be’, ‘Bed', ‘Ga’]`变成`f(x) => x INCLUDES ‘B’`变成了`[‘Be’, ‘Bed’]`。

## *简单的解决方案*

像`map`一样，这个简单的解决方案使用了一个循环结构，所以它不是我最喜欢的。我们还有多层嵌套，这使得代码难以阅读。

## *递归求解*

这和`map`的大部分是一样的。在第一行，我们将当前元素从其他元素中分离出来。如果我们在列表的末尾，我们就提前返回。

接下来，我们在其他项目上调用`filter`。这将使用 filter 调用填充调用堆栈，每个调用操作数组中的下一个元素，直到我们到达最后一个元素(这时第 5 行开始)。

最后，我们检查谓词是否为该元素返回了`true`。如果是的话，我们把它包含在返回的数组中。如果没有，我们返回其他被过滤的元素。

出于与之前相同的原因，我们需要传播价值观。

# 减少

![](img/79b8d94fca9fe7de826020236ab36dab.png)

Gabriella Clare Marino 在 [Unsplash](https://unsplash.com/s/photos/small?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片。

可能很难理解(也很难解释)，我认为看到组成它的实际代码会比我尝试的更多。但简而言之，它的目的是将数组从一个值“缩减”到另一个值。

于是，`[1, 2, 3]`变成了`f(x, y) => x + y`变成了`6`。`x`是数组中的当前元素，`y`是本次操作的当前缩减值。

## *简单的解决方案*

我们在简单的解决方案中使用了另一个循环。在该代码中，`current`是指当前减少的值。所以，如果我们用下面的参数调用`reduce`:

```
reduce ([1, 2], (element, currentTotal) => currentTotal + element, 0)
```

那么我们最开始的现值就是`0`。然后，在循环的第一次迭代中，我们将第一个元素`1`传递给回调函数。我们也传递当前值，我们刚才说是`0`。所以第一次迭代，我们的回调函数返回`0 + 1`，也就是`1`。按照数组中下一个元素的相同顺序，回调函数接下来将返回`1 + 2`，也就是`3`，我们的`reduce`函数将返回这个值。

希望这是有意义的。同样，我更喜欢功能性更强的方法，所以我在下面列出了它。

## *递归求解*

# 结论

在这个练习之前，我不知道这些函数的结构是多么相似。它们的核心都是简单地遍历一个列表，并对每个元素应用一个函数。知道这一点非常有价值。这意味着，如果我决定需要为列表编写自己的声明性函数——可能还不存在——我可以相对肯定它们会遵循类似的过程。

我希望这种认识能凸显出做这种事情的价值。您可以一遍又一遍地使用这些抽象，但是如果您自己没有实际地重新构建它们，您将永远无法获得额外的上下文或参考框架。不仅如此，这个特定的练习还突出了函数式编程的魔力:也就是说，使用高阶函数和组合可以产生干净简单但仍能执行复杂操作的代码。

因此，你不仅学习了这门语言，还接触到了强大的范例。