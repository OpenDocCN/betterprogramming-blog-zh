<html>
<head>
<title>Unit Testing Test Doubles and Exploring the Mocking Framework in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试测试加倍并探索Kotlin中的模拟框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unit-testing-test-doubles-and-the-mocking-framework-in-kotlin-4378fbb64d6a?source=collection_archive---------11-----------------------#2022-08-16">https://betterprogramming.pub/unit-testing-test-doubles-and-the-mocking-framework-in-kotlin-4378fbb64d6a?source=collection_archive---------11-----------------------#2022-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bff1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这个有用程序的深入指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/20aa24634b5362e1030ec709dd663642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*625uraId9G8GXGO2"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@mari?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mari Helin </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8bdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对单元测试一无所知，可以看看我之前的文章:<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/android-unit-testing-basics-78a04a66124a">Android单元测试基础</a>和<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/android-unit-testing-choosing-naming-convention-and-test-cases-d1a3122ac28a"> Android单元测试——选择命名约定和测试用例</a>。</p><h1 id="eaca" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是测试替身</h1><p id="c9d8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">双测试用于替代外部依赖来初始化被测系统。</p><p id="e6e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:被测系统(<code class="fe mp mq mr ms b">sut</code>)是我们正在测试的类或单元。</p><p id="bbca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在一个单元测试中，当我们测试一个特定的单元(类)时，我们不会对它的外部依赖使用真实的实现；相反，我们使用测试替身，因为真正的实现是缓慢和不可靠的。</p><p id="52f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我们一次只需要测试一个单元(单独测试每个单元)，所以如果出现任何错误，我们确保错误在当前单元中。</p><h1 id="60cd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">测试双精度类型</h1><h2 id="f620" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">骗子</h2><p id="6af4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一个对象，它具有专门为测试目的而创建的轻量级实现。不适合生产代码。例如，CacheData。</p><p id="ee59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个真实的实现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl nf"><img src="../Images/c71c69b504131fe0a2e651c4edf1a26f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*EGe0Q9sepKci7Y2K8jrXkA.png"/></div></figure><p id="a351" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个假的实现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl nf"><img src="../Images/49408d9f7036dfc9cb99ce9c9ddda682.png" data-original-src="https://miro.medium.com/v2/format:webp/1*LUST_FTr4xXMkEFentcC1Q.png"/></div></figure><h1 id="e05d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">烟蒂</h1><p id="0ff9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">生成预定义的输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl nf"><img src="../Images/778ee6fe7ab05c30db7fc70a88652dd8.png" data-original-src="https://miro.medium.com/v2/format:webp/1*r6rgJEASK6CFAmN869ufPg.png"/></div></figure><h1 id="6a8b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">模拟的</h1><p id="0fda" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">验证是否调用了特定的函数。</p><p id="0038" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果是，它被调用了多少次？</p><p id="e313" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用时传递了哪些参数？</p><h1 id="10b4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">测试双打示例</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/c0fe46481d1c336804b340491d5914fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9l5ysFrD9QPSLAndGJSNOg.png"/></div></div></figure><p id="a738" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在没有外部依赖的情况下，我们通过将输入分成组和边界来依赖它，并基于此，我们期待结果。</p><p id="f217" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于外部依赖，我们依赖于这些依赖的结果，所以我们的目标变成了测试<code class="fe mp mq mr ms b">FetchProductUseCase</code> ( <code class="fe mp mq mr ms b">sut</code>)如何与外部依赖交互。</p><p id="1553" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们需要模拟这些依赖关系，以涵盖所有可能的情况，并根据这些情况查看<code class="fe mp mq mr ms b">sut</code>如何与这些依赖关系交互。</p><p id="e038" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将<code class="fe mp mq mr ms b">FetchProductUseCase</code> ( <code class="fe mp mq mr ms b">sut</code>)与其他外部依赖项隔离开来进行测试，因此我们需要模拟这些依赖项，通过用测试替身来替换它们，以适应每个测试用例。</p><p id="1bdc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们需要为<code class="fe mp mq mr ms b">sut</code>所需的每个外部依赖项创建一个<code class="fe mp mq mr ms b">Test Double</code>类。在这种情况下，将会有三个<code class="fe mp mq mr ms b">Test Double</code>类:<code class="fe mp mq mr ms b">ProductService</code>、<code class="fe mp mq mr ms b">ProductCache</code>和<code class="fe mp mq mr ms b">ProductAnalyticManager</code>。</p><p id="c144" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一个例子，让它更清楚。</p><p id="22ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，<code class="fe mp mq mr ms b">setup</code>功能如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f52d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">ProductService</code>类中<code class="fe mp mq mr ms b">getProduct</code>函数的返回类型是<code class="fe mp mq mr ms b">ServiceResult</code>，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="3a0e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">测试案例1</h1><p id="9fa1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们需要使<code class="fe mp mq mr ms b">productService</code>测试双返回<code class="fe mp mq mr ms b">Success</code>中的<code class="fe mp mq mr ms b">getProduct</code>来确定<code class="fe mp mq mr ms b">FetchProductUseCase</code>是否调用<code class="fe mp mq mr ms b">logFailure</code>的<code class="fe mp mq mr ms b">Success</code>状态。在这种情况下，根本不应该调用它。</p><p id="6920" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们的测试用例将包含以下内容:</p><ul class=""><li id="c347" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated">准备测试替身:准备<code class="fe mp mq mr ms b">ProductService</code>的测试替身返回<code class="fe mp mq mr ms b">Success</code></li><li id="044c" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">验证结果:确保<code class="fe mp mq mr ms b">ProductAnalyticManager</code>的TestDouble中的<code class="fe mp mq mr ms b">logFailure</code>根本没有被<code class="fe mp mq mr ms b">sut</code> ( <code class="fe mp mq mr ms b">FetchProductUseCase</code>)调用。</li></ul><p id="6404" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nx">注:以上两点将包含在接下来的测试用例中，不再每次提及。</em></p><h2 id="a014" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">准备测试双打</h2><p id="6966" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为此，我们需要两个<code class="fe mp mq mr ms b">Test Double</code>类。</p><p id="5acb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个是告诉<code class="fe mp mq mr ms b">ProductService</code> Test Double返回<code class="fe mp mq mr ms b">Success</code>,这样我们就可以确保行为符合<code class="fe mp mq mr ms b">Success</code>案例的预期。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f16f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这个Test Double返回数据，所以这是一个存根。</p><p id="8d73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有一个就是保证<code class="fe mp mq mr ms b">AnalyticManager</code>测试双中的<code class="fe mp mq mr ms b">logFailure</code>是否被<code class="fe mp mq mr ms b">sut</code> ( <code class="fe mp mq mr ms b">FetchProductUseCase</code>)调用。在这种情况下，不应该调用<code class="fe mp mq mr ms b">logFailure</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4b46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe mp mq mr ms b">logFailure</code>被调用，那么<code class="fe mp mq mr ms b">failureCounter</code>将增加，这样我们就可以知道它是否被调用。</p><p id="17eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此这是模拟的，因为我们已经验证了是否调用了<code class="fe mp mq mr ms b">logFailure</code>函数。</p><h1 id="8aac" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">验证结果</h1><p id="9f46" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们的测试功能，包括验证结果，将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="24c0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">测试案例2</h1><p id="7923" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们需要使<code class="fe mp mq mr ms b">productService</code>中的<code class="fe mp mq mr ms b">getProduct</code>返回<code class="fe mp mq mr ms b">GeneralError</code>。这将保证<code class="fe mp mq mr ms b">FetchProductUseCase</code>是否调用<code class="fe mp mq mr ms b">logFailure</code>的<code class="fe mp mq mr ms b">GeneralError</code>状态。在这种情况下，<code class="fe mp mq mr ms b">logFailure</code>应该被调用一次。</p><h2 id="42d0" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">准备测试双打</h2><p id="9a1b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为此，我们需要对<code class="fe mp mq mr ms b">ProductService</code>的Test Double进行一些修改。</p><p id="7c39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使<code class="fe mp mq mr ms b">ProductService</code>测试双返回<code class="fe mp mq mr ms b">GeneralError</code>，这样我们可以确保在<code class="fe mp mq mr ms b">GeneralError</code>情况下的行为是预期的。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1bb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不需要改变<code class="fe mp mq mr ms b">ProductAnalyticManager</code>测试Double，因为我们已经准备好确保<code class="fe mp mq mr ms b">ProductAnalyticManager</code>的测试Double中的<code class="fe mp mq mr ms b">logFailure</code>是否被<code class="fe mp mq mr ms b">sut</code> ( <code class="fe mp mq mr ms b">FetchProductUseCase</code>)调用。在这种情况下，<code class="fe mp mq mr ms b">logFailure</code>应该被调用一次。</p><h2 id="06de" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">验证结果</h2><p id="c39f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">所以我们的测试函数如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="859c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">测试案例3</h1><p id="3943" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们需要确保<code class="fe mp mq mr ms b">productService</code>中的<code class="fe mp mq mr ms b">getProduct</code>返回<code class="fe mp mq mr ms b">ServerError</code>，这样我们就可以确定在<code class="fe mp mq mr ms b">ServerError</code>状态下<code class="fe mp mq mr ms b">FetchProductUseCase</code>是否调用<code class="fe mp mq mr ms b">logFailure</code>。在这种情况下，<code class="fe mp mq mr ms b">logFailure</code>应该被调用一次。</p><h2 id="0dd3" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">准备测试双打</h2><p id="9f9b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为此，我们需要对<code class="fe mp mq mr ms b">ProductService</code>的test double进行一些修改。</p><p id="b5d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使<code class="fe mp mq mr ms b">ProductService</code>测试双回路<code class="fe mp mq mr ms b">ServerError</code>如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="de83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，在这里，没有必要改变<code class="fe mp mq mr ms b">ProductAnalyticManager</code>的测试双。</p><h2 id="851f" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">验证结果</h2><p id="dde3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">因此，我们的测试函数如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2b5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的测试案例中，我们查看了模拟和存根示例。对于假的，我们可以以<code class="fe mp mq mr ms b">ProductCache</code>的测试替身为例。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="be52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了不使它太长，你可以从<a class="ae kv" href="https://github.com/haythamayyash/android-unit-testing-course" rel="noopener ugc nofollow" target="_blank">这里</a>通过GitHub找到代码和我如何在测试用例中使用它。还可以看到<code class="fe mp mq mr ms b">FetchProductUseCaseTest</code>文件。</p><h1 id="73b7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">模拟框架</h1><p id="25af" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Mocking框架通过用存根和mocks之类的对象替换它们来促进测试用例的使用。</p><p id="b2cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有多个嘲讽框架，例如，Mockito，Mockk等。如果你理解了上面的基本原理，你会发现所有的框架都很容易。</p><p id="3fec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用Mockito作为例子，因为它是最受欢迎的。</p><p id="f33b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要为测试类添加<code class="fe mp mq mr ms b">@RunWith(MockitoJUnitRunner::class)</code>注释，以使用Mockito注释。</p><p id="0b4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中使用的任何一个test double类，我们可以在字段级用<code class="fe mp mq mr ms b">@Mock</code>注释来注释它，那么这个类就是一个空的Test Double。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f1ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:<code class="fe mp mq mr ms b">@Mock</code>mock ITO框架中的注释并不意味着模拟测试double。它可能是一个模拟或存根。</p><p id="b9a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们以上面的例子为例，用Mockito的结构替换测试替身。</p><h1 id="822b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">测试案例1</h1><p id="d3cb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">不用创建一个<code class="fe mp mq mr ms b">Test Double</code>类来返回<code class="fe mp mq mr ms b">Success</code>，我们可以用下面的代码来实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="d820" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您是Mocking框架的新手，您可能会发现语法很奇怪，但是您会很快习惯它。</p><p id="ccee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如上面的语法所说，当调用<code class="fe mp mq mr ms b">getProduct</code>函数时，那么请返回我们测试用例需要的任何内容。这种情况下，我们需要返回<code class="fe mp mq mr ms b">success</code>。</p><p id="5420" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，上面的代码是一个存根。</p><p id="9689" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，我们的代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="bce2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我们可以使用来自Mockito的verify方法，而不是在<code class="fe mp mq mr ms b">ProductAnalyticManager</code> Test Double中使用计数器。我们可以使用<code class="fe mp mq mr ms b">verifyNoMoreInteractions</code>函数确保特定对象上没有交互。</p><p id="a417" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们的代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="63e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，使用Mockito进行准备和验证非常简单。</p><h1 id="4020" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">测试案例2和3</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6177" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个测试类似于测试用例1，但是不同之处在于我们需要确保<code class="fe mp mq mr ms b">logFailure</code>被调用一次。</p><p id="4d57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像<code class="fe mp mq mr ms b">verify</code>和<code class="fe mp mq mr ms b">verifyNoInteractions</code>这样的验证方法让我们知道函数是否被调用了，以及被调用了多少次。因此该验证为<code class="fe mp mq mr ms b">Mock(Mock Test Double)</code>。</p><p id="fdb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为伪test double是我们的伪实现，所以即使使用Mocking框架，您也可以保持原样，或者像处理模拟Test Double一样处理它。你可以在这里找到完整的例子。</p><p id="f3f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不只有上面提到的功能。Mockito(或其他框架)为我们提供了许多功能和选项，让嘲讽的生活变得更加轻松。</p><p id="10ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有些开发人员使用框架，有些根本不用，还有一些混合使用。这种偏好取决于每个开发人员。</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="e978" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nx">感谢阅读！</em></p><p id="ac01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nx">敬请期待更多。</em></p></div></div>    
</body>
</html>