<html>
<head>
<title>Functional Programming for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的函数式编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-programming-for-beginners-b518007dda81?source=collection_archive---------11-----------------------#2019-06-17">https://betterprogramming.pub/functional-programming-for-beginners-b518007dda81?source=collection_archive---------11-----------------------#2019-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="aa92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">用于过滤数组的无压力编程范例及更多内容</em></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/3b0b705d634e92c3c8f6a15572f7e788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gjo0AK1Jhmde0QZQ8vAiSA.jpeg"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">照片由<a class="ae lf" href="https://unsplash.com/@rimakruciene?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Rima Kruciene </a>在<a class="ae lf" href="https://unsplash.com/@rimakruciene?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c00b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">坦白地说，我很震惊有这么多程序员对<a class="ae lf" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>一无所知。这是编写安全、定义良好的代码的最实用的方法之一，而不需要理解它的基本编程原则。</p><p id="cb63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理解基本原则很重要，但本文只是一个基本介绍。它展示了函数式编程如何提高代码的可读性，然后以附加资源的链接结束。</p><p id="5c2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从用for循环过滤一组住宅开始。</p><pre class="kq kr ks kt gt lg lh li lj aw lk bi"><span id="1ecb" class="ll lm it lh b gy ln lo l lp lq">class Home {<br/>  constructor(<br/>    public type: "Condo" | "House",<br/>    public price: number,<br/>  ) { }<br/>}</span><span id="c570" class="ll lm it lh b gy lr lo l lp lq">const homes = [ <br/>  new Home("Condo", 100), <br/>  new Home("House", 200),<br/>]</span></pre></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="cf8a" class="lz lm it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">使用For循环过滤</h1><p id="5b90" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">下面的代码是大多数初学者如何过滤数组的。</p><pre class="kq kr ks kt gt lg lh li lj aw lk bi"><span id="168a" class="ll lm it lh b gy ln lo l lp lq">function filterCondos(homes: Home[]): Home[] {<br/>  const condos = []<br/>  for (let i = 0; i &lt; homes.length; ++i) {<br/>    const home = homes[i]<br/>    if (home.type === "Condo") {<br/>      condos.push(home)<br/>    }<br/>  }<br/>  return condos<br/>}</span><span id="0a10" class="ll lm it lh b gy lr lo l lp lq">const condos = filterCondos(homes)</span></pre><p id="d640" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数<code class="fe nb nc nd lh b">filterCondos</code>循环遍历并将homes推入一个数组，其中<code class="fe nb nc nd lh b">home.type === “Condo"</code>。</p><p id="ab5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基本上，我不喜欢<code class="fe nb nc nd lh b">filterCondos</code>,因为它对于一个简单的任务来说有很多代码。</p><p id="541b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">检查类型，<code class="fe nb nc nd lh b">home.type === "Condo"</code>是唯一重要的一行代码。那么，为什么<code class="fe nb nc nd lh b">filterCondos</code>如此臃肿？怎样才能减少过剩？</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="312b" class="lz lm it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">使用Array.prototype.filter过滤</h1><p id="08cc" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">函数式编程范式允许代码一目了然。</p><pre class="kq kr ks kt gt lg lh li lj aw lk bi"><span id="2b10" class="ll lm it lh b gy ln lo l lp lq">function byCondo(home: Home): boolean {<br/>  return home.type === "Condo"<br/>}</span><span id="ed53" class="ll lm it lh b gy lr lo l lp lq">const condos = homes.filter(byCondo)</span></pre><p id="37b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数<code class="fe nb nc nd lh b">byCondo</code>检查一个家是否是“公寓”当与<a class="ae lf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank"> Array.prototype.filter </a>一起使用时，我们得到一个数组<code class="fe nb nc nd lh b">condos</code>。</p><p id="1980" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果和使用<code class="fe nb nc nd lh b">filterCondos</code>一样，没有多余的代码。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="ab84" class="lz lm it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">用咖喱函数过滤</h1><p id="8ac5" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">我想按任何类型进行过滤，而不仅仅是“公寓”这可以通过创建一个函数来实现，在这个函数中，类型被传入，新的函数被返回。</p><pre class="kq kr ks kt gt lg lh li lj aw lk bi"><span id="7bce" class="ll lm it lh b gy ln lo l lp lq">const condos = homes.filter(byType("Condo"))<br/>const houses = homes.filter(byType("House"))</span></pre><p id="186b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种技术叫做<a class="ae lf" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank">奉承</a>。如果娃娃是函数，就像一个俄罗斯娃娃——函数返回函数。</p><pre class="kq kr ks kt gt lg lh li lj aw lk bi"><span id="f74e" class="ll lm it lh b gy ln lo l lp lq">function byType(type: "Condo" | "House") {<br/>  return function (home: Home): boolean {<br/>    return home.type === type<br/>  }<br/>}</span></pre><p id="613c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了简单起见，使用像<a class="ae lf" href="https://lodash.com" rel="noopener ugc nofollow" target="_blank"> lodash </a>这样的库来生成curry函数。</p><pre class="kq kr ks kt gt lg lh li lj aw lk bi"><span id="1c01" class="ll lm it lh b gy ln lo l lp lq">import _ from "lodash"</span><span id="b5cf" class="ll lm it lh b gy lr lo l lp lq">function filterByType(type: "Condo" | "House", home: Home) {<br/>  return home.type === type<br/>}</span><span id="090d" class="ll lm it lh b gy lr lo l lp lq">const byType = _.curry(filterByType)</span><span id="ad5c" class="ll lm it lh b gy lr lo l lp lq">const condos = homes.filter(byType("Condo"))<br/>const houses = homes.filter(byType("House"))</span></pre><p id="582b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">表达式<code class="fe nb nc nd lh b">_.curry(filterByType)</code>构建了<code class="fe nb nc nd lh b">byType</code>函数。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="a67c" class="lz lm it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">结论</h1><p id="c50d" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated"><a class="ae lf" href="https://en.wikipedia.org/wiki/Imperative_programming" rel="noopener ugc nofollow" target="_blank">命令式编程</a>，使用for循环，产生不必要的代码，使代码更难阅读。函数式编程是解决方案，因为它关注逻辑——它是<a class="ae lf" href="https://en.wikipedia.org/wiki/Declarative_programming" rel="noopener ugc nofollow" target="_blank">声明式编程</a>范例的一部分。</p><p id="16ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用函数式编程还有很多上面没有讨论的原因。查看下面的附加资源，以获得对函数式编程更完整的理解。</p><ol class=""><li id="d48d" class="ne nf it js b jt ju jx jy kb ng kf nh kj ni kn nj nk nl nm bi translated">Mozilla开发者网络(MDN)上的数组对象API </li><li id="b161" class="ne nf it js b jt nn jx no kb np kf nq kj nr kn nj nk nl nm bi translated"><a class="ae lf" href="https://www.skptricks.com/2018/11/learn-to-chain-map-filter-and-reduce-in-javascript.html" rel="noopener ugc nofollow" target="_blank">Sumit Kumar prad Han<a class="ae lf" href="https://www.blogger.com/profile/13441435149900194825" rel="noopener ugc nofollow" target="_blank">撰写的关于链接</a>的短文</a></li><li id="b61e" class="ne nf it js b jt nn jx no kb np kf nq kj nr kn nj nk nl nm bi translated"><a class="ae lf" href="https://medium.com/poka-techblog/simplify-your-javascript-use-map-reduce-and-filter-bd02c593cc2d" rel="noopener">关于连锁的长文</a>作者<a class="ae lf" href="https://medium.com/@etiennetalbot" rel="noopener">艾蒂安·塔尔博特</a></li><li id="f9ce" class="ne nf it js b jt nn jx no kb np kf nq kj nr kn nj nk nl nm bi translated">FunFunFunction的<a class="ae lf" href="https://www.youtube.com/watch?v=BMUiFMZr7vk&amp;list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84&amp;index=1" rel="noopener ugc nofollow" target="_blank">功能编程播放列表</a></li><li id="958a" class="ne nf it js b jt nn jx no kb np kf nq kj nr kn nj nk nl nm bi translated"><a class="ae lf" href="https://medium.com/@navneet.sahota/why-functional-programming-matters-e13e910a0152" rel="noopener">为什么函数式编程如此重要</a>作者<a class="ae lf" href="https://medium.com/@navneet.sahota" rel="noopener"> Navneet Singh </a></li><li id="e438" class="ne nf it js b jt nn jx no kb np kf nq kj nr kn nj nk nl nm bi translated"><a class="ae lf" href="https://blog.submain.com/csharp-functional-programming" rel="noopener ugc nofollow" target="_blank">c#中的函数式编程</a>Carlos Schults</li></ol></div></div>    
</body>
</html>