<html>
<head>
<title>An Introduction to OpenAPI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenAPI简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-use-cases-of-openapi-which-are-good-to-know-1a041f4ad71e?source=collection_archive---------4-----------------------#2021-12-06">https://betterprogramming.pub/4-use-cases-of-openapi-which-are-good-to-know-1a041f4ad71e?source=collection_archive---------4-----------------------#2021-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ca14" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">OpenAPI的4个使用案例，值得了解</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b14f8e21749dd7cca7708f18bfd0df3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DV177Sut6_--Dofq"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@skraidantisdrambliukas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Gert RDA valasevi it</a>拍摄的照片</p></figure><p id="a139" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将介绍OpenAPI (OA)及其一些更有趣的用例。如果您已经熟悉什么是OA，那么您可以直接跳到本文的用例部分。</p><h2 id="0230" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">什么是OpenAPI？</h2><p id="9cc9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">OpenAPI是一种规范，用于以某种方式记录基于HTTP的API，这种方式允许用户(通常是从事API本身工作的团队之外的用户)理解它所公开的功能并与之交互。</p><p id="5542" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该规范最初由一家名为“Swagger”的名为<a class="ae kv" href="https://smartbear.com/?utm_medium=ppcg&amp;utm_source=aw&amp;utm_term=smartbear&amp;utm_content=518273908799&amp;utm_campaign=SEM_SmartBear:CoreTerm_BR_EMEA_ENG_EXT_Prospecting&amp;awsearchcpc=1&amp;gclid=Cj0KCQiAkZKNBhDiARIsAPsk0Wjjc7MtwLTepzsILVbeGCMM-h1sUv7bvJMZotn317gBfkthROuoW9waAvrkEALw_wcB&amp;gclsrc=aw.ds" rel="noopener ugc nofollow" target="_blank"> SmartBear </a>的公司开发，成为API文档事实上的标准。这导致了linux基金会下的<a class="ae kv" href="https://www.openapis.org/about" rel="noopener ugc nofollow" target="_blank"> OpenAPI倡议</a>的形成，它现在管理该规范，以及将该规范从Swagger重命名为OpenAPI。因此，当你阅读Swagger规范和OpenAPI规范时，它们实际上是相同的——Swagger只是OpenAPI的早期版本(3.x.x版之前)。</p><h2 id="2dcb" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">创建规格</h2><p id="67f1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">OA规范通常采用<code class="fe mq mr ms mt b">YAML</code>文件的形式，尽管也支持<code class="fe mq mr ms mt b">JSON</code>。你可以在<a class="ae kv" href="https://github.com/OAI/OpenAPI-Specification" rel="noopener ugc nofollow" target="_blank">这个库</a>和<a class="ae kv" href="https://github.com/snok/drf-openapi-tester/tree/master/tests/schemas/sample-schemas" rel="noopener ugc nofollow" target="_blank">这里</a>看到规格的例子。</p><p id="3335" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">规范可以是单个文件，也可以是多个带有引用(<code class="fe mq mr ms mt b">$ref</code>)的文件，引用使用路径指向文件或远程资源。如果使用引用，这些引用可以是相对/绝对文件路径，也可以是网络上资源的URI。这使得OA规范非常有弹性，但一开始也有些混乱——我们的大脑还不能很好地适应解析refs，这使得学习曲线有些陡峭。你可以在这里阅读更多关于这个特性的信息<a class="ae kv" href="https://swagger.io/docs/specification/using-ref/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ced9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建OA规范最简单的方法是写下一个. yml文件或一堆这样的文件。尽管这将API规范的编写和维护与开发过程联系在一起，增加了开销。此外，当规范是手工编写时，这不可避免地会导致人为错误和规范与实际API不同步的情况。因此，这是应该尽可能避免的做法，除非有令人信服的理由这样做。</p><p id="f566" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种方法是从代码中生成OpenAPI规范。</p><p id="46e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多较新的后端框架都内置了某种程度的OA spec生成。例如，FastAPI (Python)将规范生成作为其核心功能的一部分，而NestJS (TypeScript)有一个可选的核心扩展<a class="ae kv" href="https://docs.nestjs.com/openapi/introduction" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="f4c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，旧的框架倾向于拥有丰富的生态系统，包括用于生成OpenAPI规范的库。例如参见:Django+DRF的<a class="ae kv" href="https://github.com/tfranzel/drf-spectacular" rel="noopener ugc nofollow" target="_blank">本库</a>(Python)，Spring Boot的<a class="ae kv" href="https://springdoc.org/" rel="noopener ugc nofollow" target="_blank">本库</a>(Java/Kotlin)，Rails的<a class="ae kv" href="https://github.com/rswag/rswag" rel="noopener ugc nofollow" target="_blank">本库</a>(Ruby)，Laravel的<a class="ae kv" href="https://github.com/vyuldashev/laravel-openapi" rel="noopener ugc nofollow" target="_blank">本库</a>(PHP)。</p><h2 id="7481" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">验证规格</h2><p id="0c21" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">OA specs的创建越接近API代码，从所使用的语言中收集的类型信息越多，您就越能相信生成的OA specs反映了正在讨论的API端点。因此，反过来，人工干预越多，你就越不信任这些规范。</p><p id="7a76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，根据实际的API测试规范是一个好主意——特别是如果您必须手工编写规范或者调整生成过程的话。对于一些框架来说，有一个专门的库用于这个目的，例如，参见Django+DRF的<a class="ae kv" href="https://github.com/snok/drf-openapi-tester" rel="noopener ugc nofollow" target="_blank">这个库</a>(我与人合著)，还有更多通用的测试解决方案——参见文章末尾的测试和调试用例了解更多细节。</p><p id="2d73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个选择是验证规范是否写得正确，找出错误或者检查规范的风格。如果你使用一个实体库来为你生成规格，这可能是多余的。另一方面，如果您手工编写规范，或者在生成后修改它们，并提交到您的VCS，那么这种形式的验证是必需的。</p><p id="5dd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，有一个<a class="ae kv" href="https://www.npmjs.com/package/swagger-cli" rel="noopener ugc nofollow" target="_blank">官方CLI工具</a>你可以用NPM/Yarn安装。它的验证信息非常糟糕，难以理解——所以它不是最好的林挺工具。一个更优雅的工具是<a class="ae kv" href="https://github.com/Redocly/openapi-cli" rel="noopener ugc nofollow" target="_blank"> openapi-cli </a>，同样使用Node.js作为主干。除非您有充分的理由使用官方CLI，否则我会推荐您使用该工具。</p><p id="700c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提示:在CI中验证您的规范并使用预提交钩子通常是一个最佳实践。</p><h1 id="a01c" class="mu lt iq bd lu mv mw mx lx my mz na ma jw nb jx md jz nc ka mg kc nd kd mj ne bi translated">用例:文档</h1><p id="c351" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">当然，OA specs的第一个也是最主要的用途是记录API。然而，如果没有消费文档的方式，文档是没有用的。</p><p id="8117" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，有多种工具可以生成用于显示API规范的UI。</p><p id="1a79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个领域最古老的工具是SmartBear的swagger-UI。它免费且简单易用，但在我看来，它的默认用户界面和样式并不怎么样。此外，它缺少下面讨论的其他工具所具有的许多花哨功能(例如高级搜索功能)。如果你不介意有一个相当基本的网站来展示你的规格，这是一个可靠的选择。</p><p id="dacc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个非常流行的叫做<a class="ae kv" href="https://github.com/Redocly/redoc" rel="noopener ugc nofollow" target="_blank"> redoc </a>，它是由维护<code class="fe mq mr ms mt b">openapi-cli</code>项目的同一家公司(从开源项目发展而来)维护的，叫做<a class="ae kv" href="https://redoc.ly/" rel="noopener ugc nofollow" target="_blank"> Redocly </a>。该工具提供了一个开箱即用的漂亮UI——使用CLI，您可以轻松地生成一个生产就绪的React驱动的网站，该网站具有良好的定制和漂亮简洁的外观，您可以在此处看到一个示例<a class="ae kv" href="https://redocly.github.io/redoc/" rel="noopener ugc nofollow" target="_blank"/>。如果你需要大量的品牌或更复杂的功能，你需要付费。</p><p id="1693" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，还有<a class="ae kv" href="https://mrin9.github.io/RapiDoc/" rel="noopener ugc nofollow" target="_blank"> RapiDoc </a>，这是一个开源项目，提供了很多选项。这是一个框架不可知的JS库，所以你可以在任何你喜欢的框架上使用它(比如Vue，React等等)。).您还可以完全控制样式，但也可以使用它的默认设置。这是一个更复杂的选项，需要开发时间，但是它在定制和用户控制方面比其他选项提供了更多。根据您的使用情况，这可能是一个不错的选择。</p><p id="1db2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:上一节提到的许多库和框架至少捆绑了其中一种工具。因此，举例来说，FastAPI提供了一个现成的redoc网站，而DRF壮观则同时提供了Swagger-UI和redoc。因此，您应该提前检查这一点，并做出相应的决定。</p><h1 id="38dd" class="mu lt iq bd lu mv mw mx lx my mz na ma jw nb jx md jz nc ka mg kc nd kd mj ne bi translated">用例:代码生成</h1><p id="3451" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">因为OA规范是机器可读的，并且包含大量关于类型的信息，所以它们的主要用例之一是代码生成。您可以做很多事情——常见的例子是从OA specs生成客户端SDK和服务器存根，创建参考客户端，甚至创建要在应用程序前端使用的客户端脚手架。</p><p id="0362" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有两个非常受欢迎的项目主导着这个领域，这两个项目都采用了有点类似的方法，使用code-gen的模板:</p><p id="b2d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个项目是<a class="ae kv" href="https://github.com/swagger-api/swagger-codegen" rel="noopener ugc nofollow" target="_blank"> Swagger Codegen </a>，同样由SmartBear完成。这个项目在Github上有13K颗星，非常稳定。尽管它的用途有所限制，它所支持的模板范围也是如此。</p><p id="1dfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与10K明星合作的第二个项目是<a class="ae kv" href="https://github.com/OpenAPITools/openapi-generator" rel="noopener ugc nofollow" target="_blank"> OpenAPI-Generator </a>。这个项目提供了广泛的工具——用Java编写——和大量的模板可供选择。它非常强大，拥有其他项目没有的能力，但是不太稳定(阅读，版本之间有突破性的变化)。</p><h1 id="5ac6" class="mu lt iq bd lu mv mw mx lx my mz na ma jw nb jx md jz nc ka mg kc nd kd mj ne bi translated">用例:类型脚本</h1><p id="86ea" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果您的项目包括使用TypeScript开发的前端组件，那么您可以使用OA specs做的最有用的事情之一就是从它们生成TypeScript类型。我在多个项目中这样做过，包括一次我自己写了一个OA到TypeScript的转换器。幸运的是，现在有两个成熟的开源生成器可以为您完成这项工作:<a class="ae kv" href="https://github.com/horiuchi/dtsgenerator" rel="noopener ugc nofollow" target="_blank"> DTSGenerator </a>和<a class="ae kv" href="https://github.com/drwpow/openapi-typescript#readme" rel="noopener ugc nofollow" target="_blank"> openapi-typescript </a>。</p><p id="4720" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的项目有一个开发部署，我建议您执行以下操作:公开一个端点，该端点允许将OA规范作为文件下载。然后创建一个shell脚本，使用<code class="fe mq mr ms mt b">curl</code>或<code class="fe mq mr ms mt b">wget</code>下载规范，将结果传送到这些工具之一。例如，以下脚本以这样的方式使用DTSGenerator:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0698" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，前端开发人员更新API规范变得非常容易——只需要一个简短的shell命令。</p><p id="f61c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，您可以将生成的类型发布为内部NPM包，或者从存储库中安装它们。尽管这将控制从前端转移到了后端，但灵活性稍差。</p><h1 id="03b9" class="mu lt iq bd lu mv mw mx lx my mz na ma jw nb jx md jz nc ka mg kc nd kd mj ne bi translated">用例:测试和调试</h1><p id="8b96" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一种越来越流行的测试API的有趣方法是所谓的“模糊测试”。这是一种基于属性的测试，但针对的是API而不是函数。在模糊测试中，针对一系列随机数据测试给定的API，识别弱点、未处理的错误等。虽然模糊测试的主要目的是识别安全性和代码弱点，但它也是一种确保o a文档准确反映其所代表的API的方法。</p><p id="18b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有些付费服务使用OA规范作为事实的来源，例如，Gitlab在其终极计划中为客户提供了<a class="ae kv" href="https://docs.gitlab.com/ee/user/application_security/api_fuzzing/" rel="noopener ugc nofollow" target="_blank">服务</a>。但是，也有多种开源解决方案。<a class="ae kv" href="https://github.com/apiaryio/dredd" rel="noopener ugc nofollow" target="_blank"> Dredd </a>是一个成熟的多平台项目，可以用于这个目的。在Python世界里，有<a class="ae kv" href="https://github.com/schemathesis/schemathesis" rel="noopener ugc nofollow" target="_blank">模式</a>，它建立在优秀的假设测试库之上，提供模糊测试。</p><h1 id="41cd" class="mu lt iq bd lu mv mw mx lx my mz na ma jw nb jx md jz nc ka mg kc nd kd mj ne bi translated">结论</h1><p id="ab82" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在本文中，我讨论了OpenAPI及其各个方面。以上是一个一般性的介绍，同时也提供了我觉得有趣和有价值的用例。OA生态系统是动态的，并且在不断发展。我建议看看这个网站上的工具列表，以及这个令人敬畏的列表。</p></div></div>    
</body>
</html>