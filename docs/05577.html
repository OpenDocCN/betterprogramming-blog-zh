<html>
<head>
<title>Test-Driven Development With Stripe and Ruby on Rails</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Stripe和Ruby on Rails进行测试驱动开发</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/test-driven-development-with-stripe-and-ruby-on-rails-cfc81e3e261?source=collection_archive---------8-----------------------#2020-07-20">https://betterprogramming.pub/test-driven-development-with-stripe-and-ruby-on-rails-cfc81e3e261?source=collection_archive---------8-----------------------#2020-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b7bd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">测试您的支付集成的实用指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3f69db8d615143a200ac5ab907b3c617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KhuDkpTeacAOIYPKjcN8wg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@joshappel" rel="noopener ugc nofollow" target="_blank">乔希·阿佩尔</a>提供。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="68d8" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">在Stripe Dashboard中为自动测试设置一个单独的子帐户</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/826d6b8153813a7d1d09b601ef6c0e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*sLWdKNAtyxhPGNG008T7ZA.png"/></div></figure><p id="a496" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">对于我的项目，我通常会创建至少三个独立的<a class="ae ky" href="https://stripe.com/" rel="noopener ugc nofollow" target="_blank"> Stripe </a>子账户:一个用于开发(手工测试)，一个用于测试(自动化测试)，一个用于生产。</p><p id="5d15" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">一旦您创建了这些子帐户，将它们的API凭证保存到您的环境中(对于Linux为<code class="fe mv mw mx my b">.bashrc</code>，对于Mac为<code class="fe mv mw mx my b">.bash_profile</code>)。</p><p id="819d" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">我在Rails中设置了我的条带初始化器，如下所示(<code class="fe mv mw mx my b">config/initializers/stripe.rb</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="eff1" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">这样，我就能肯定不同的环境不会互相冲突。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="9625" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">定义测试的前后挂钩</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="df3e" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">在<code class="fe mv mw mx my b">spec/support/clear_stripe.rb</code>中定义的两种方法将在测试套件之间和之后运行，以确保每个测试运行都是独立的，并且在Stripe的末端是一个干净的石板。</p><p id="e531" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">它们将清除Stripe的客户、定价和产品数据，因此请确保它们不会在生产中被调用！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="48d8" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">在有意义的地方模仿条纹</h1><p id="85b5" class="pw-post-body-paragraph lz ma it mb b mc nb ju me mf nc jx mh mi nd mk ml mm ne mo mp mq nf ms mt mu im bi translated">在测试套件中实时请求条带化可以增强您对应用程序的信心，但随着应用程序的增长，这可能会非常耗时。为了避免这种情况，我使用了一种叫做<code class="fe mv mw mx my b">stripe-ruby-mock</code>的<a class="ae ky" href="https://github.com/stripe-ruby-mock/stripe-ruby-mock" rel="noopener ugc nofollow" target="_blank">宝石</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f9a7" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">通过在每次测试之前调用<code class="fe mv mw mx my b">StripeMock.start</code>，我们确保我们的测试套件不会对条带发出实时请求。我选择嘲讽Stripe的<code class="fe mv mw mx my b">Stripe::Customer.create</code>动作，因为它经常被调用，而我在寻找的响应不太可能在Stripe端改变。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7aa2" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">集成测试示例</h1><p id="0734" class="pw-post-body-paragraph lz ma it mb b mc nb ju me mf nc jx mh mi nd mk ml mm ne mo mp mq nf ms mt mu im bi translated">这个集成测试测试了我的应用程序的一部分，它允许用户从<a class="ae ky" href="https://www.twilio.com/" rel="noopener ugc nofollow" target="_blank"> Twilio </a>提供电话号码。测试的目标是确保Stripe可以为用户设置订阅，并尝试在第一个订阅期向他们收费。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="44d1" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">在这里，我们看到我们没有调用<code class="fe mv mw mx my b">stripe-ruby-mock</code>。相反，我们实时请求条带化。像往常一样，在测试套件开始之前，Stripe的数据被清除，我们在系统上初始化一个用户，并在Stripe端初始化一个匹配的客户端记录。</p><p id="fa8e" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">在测试主体中，为客户添加了一个支付源(这个行为在一个单独的测试套件中进行测试),并发出web请求。此后应用程序行为被断言。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ed73" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">验证Webhooks来自条带服务</h1><p id="e712" class="pw-post-body-paragraph lz ma it mb b mc nb ju me mf nc jx mh mi nd mk ml mm ne mo mp mq nf ms mt mu im bi translated">您的应用程序必须包含用于验证到达您的服务器的web请求确实来自Stripe的逻辑。否则，任何人都可以向您的服务发送虚假请求来绕过计费逻辑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5943" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">我编写了上面的模块来验证来自Stripe的请求，并将其插入到我的控制器中的一个<code class="fe mv mw mx my b">before_action</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5bea" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">这个控制器的测试很简单。我们应该在测试中得到一个<code class="fe mv mw mx my b">unauthorized</code>响应，因为请求不是由Stripe签名的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8dfc" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">测试条纹网钩</h1><p id="b750" class="pw-post-body-paragraph lz ma it mb b mc nb ju me mf nc jx mh mi nd mk ml mm ne mo mp mq nf ms mt mu im bi translated">为了使测试更容易，我在我的应用程序中创建了一个模块，并委派了由Stripe事件调用的业务逻辑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5800" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">该模块用于提取Stripe提供的有效负载，并根据事件类型有条件地运行业务逻辑。这样，我可以使用<code class="fe mv mw mx my b">stripe-ruby-mock</code>来生成模拟请求，将这些请求提供给模块，并观察它的行为。测试webhooks的测试套件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a7ba" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">在每个测试中，我们将请求配置参数传递给<code class="fe mv mw mx my b">stripe-ruby-mock</code>，并将gem发出的事件传递给<code class="fe mv mw mx my b">StripeHelper::IncomingWebhook</code>。然后，该模块挂钩到应用程序的模型中，并执行我们可以在之后观察到的某些操作。</p><p id="60c3" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">暂时就这样吧！我希望这激发了您为应用程序的条带集成编写测试。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="63ee" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated"><a class="ae ky" href="https://www.linkedin.com/in/shashike-jayatunge/" rel="noopener ugc nofollow" target="_blank">沙希科</a>是一名来自多伦多的软件工程师，也是<a class="ae ky" href="https://www.restarone.com" rel="noopener ugc nofollow" target="_blank"> Restarone Inc </a>的创始人。当他不开发软件时，他在Medium和YouTube上创作内容，帮助人们过渡到技术领域。</p></div></div>    
</body>
</html>