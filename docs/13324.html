<html>
<head>
<title>Kafka With Python: How To Get Your Projects Up and Running</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的Kafka:如何启动和运行您的项目</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kafka-with-python-how-to-get-your-projects-up-and-running-34bc58c46652?source=collection_archive---------3-----------------------#2022-08-17">https://betterprogramming.pub/kafka-with-python-how-to-get-your-projects-up-and-running-34bc58c46652?source=collection_archive---------3-----------------------#2022-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b17f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Kafka运行流式作业</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d87df2eea68e875f7ac09532b2316182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*14i5ljWBi-SngbTb.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来源:https://www.confluent.io/blog/author/martin-kleppmann/</p></figure><p id="c894" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在本文中，我们将讨论什么是Apache Kafka及其用例。我们还将使用Python和融合云构建一个Kafka消费者的演示示例。</p><p id="b3b6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Apache Kafka是一个开源的流媒体平台。尽管它的代码库是用Java编写的，但一些API允许它使用Python、Scala等。您可以将Kafka视为实时处理传入提交日志并按顺序存储它们的工具。这些日志的用户可以根据自己的需求访问和使用它们。</p><p id="67f9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在本文中，我们将讨论以下几点:</p><ul class=""><li id="b52b" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">卡夫卡应用的基本术语定义</li><li id="83a8" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">卡夫卡用例</li><li id="355d" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">Python中的Kafka消费者示例</li></ul><h1 id="3115" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">卡夫卡应用的基本术语定义</h1><p id="5d38" class="pw-post-body-paragraph kv kw it kx b ky mx ju la lb my jx ld le mz lg lh li na lk ll lm nb lo lp lq im bi translated">在与卡夫卡合作之前，我们需要定义几个关键术语:</p><ul class=""><li id="1f65" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">主题</li><li id="d108" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">消息</li><li id="56d1" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">划分</li><li id="ba4f" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">经纪人</li><li id="e33a" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">生产者</li><li id="488a" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">消费者</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/fee4af79a852b8fbe50ef0a723b14761.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/0*wPNmI7Xbk5czye7x.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">卡夫卡集群，消费者，生产者(来源:【https://kafka.apache.org/081/documentation.html】T2)</p></figure><h2 id="b4ca" class="nd mg it bd mh ne nf dn ml ng nh dp mp le ni nj mr li nk nl mt lm nm nn mv no bi translated">主题</h2><p id="b057" class="pw-post-body-paragraph kv kw it kx b ky mx ju la lb my jx ld le mz lg lh li na lk ll lm nb lo lp lq im bi translated">它是数据的单一实体，也是事件的命名容器。您的应用程序可以包含许多不同的主题。我们也可以把主题想象成持久的、不可变的、只能附加的事件日志。我们还可以设置日志保留期，以便随着时间的推移保留存储空间。</p><h2 id="92c9" class="nd mg it bd mh ne nf dn ml ng nh dp mp le ni nj mr li nk nl mt lm nm nn mv no bi translated">消息</h2><p id="0c14" class="pw-post-body-paragraph kv kw it kx b ky mx ju la lb my jx ld le mz lg lh li na lk ll lm nb lo lp lq im bi translated">消息是主题的内容。它们被表示为(键，值)对。在主题中，键应该是唯一的，并且通常是基本类型。它们可以用作应用程序中某个实体(用户、设备、交易等)的标识符。).值可以由任何类型的对象表示，并且可以复制。一个主题中的消息可以在多个实例中进行划分。</p><h2 id="5455" class="nd mg it bd mh ne nf dn ml ng nh dp mp le ni nj mr li nk nl mt lm nm nn mv no bi translated">划分</h2><p id="5908" class="pw-post-body-paragraph kv kw it kx b ky mx ju la lb my jx ld le mz lg lh li na lk ll lm nb lo lp lq im bi translated">分区是将Kafka集群的多个实例中的单个主题中的日志分开。划分逻辑是根据消息的关键字定义的。如果该项为空，则分区被均匀填充。否则，通过哈希函数运行键，属性分区的数量就是哈希值。具有相同密钥的消息位于相同的分区中。</p><h2 id="ad5f" class="nd mg it bd mh ne nf dn ml ng nh dp mp le ni nj mr li nk nl mt lm nm nn mv no bi translated">经纪人</h2><p id="45a9" class="pw-post-body-paragraph kv kw it kx b ky mx ju la lb my jx ld le mz lg lh li na lk ll lm nb lo lp lq im bi translated">代理是运行Kafka流程的实际机器和实例。每个代理可以托管一组分区，并处理向这些分区写入和读取事件的请求。代理还可以处理彼此之间的分区复制。</p><h2 id="39e3" class="nd mg it bd mh ne nf dn ml ng nh dp mp le ni nj mr li nk nl mt lm nm nn mv no bi translated">生产者</h2><p id="c8a2" class="pw-post-body-paragraph kv kw it kx b ky mx ju la lb my jx ld le mz lg lh li na lk ll lm nb lo lp lq im bi translated">与Kafka交互的应用程序可以在两种模式下运行:生产者或消费者。制片人在卡夫卡的主题上写消息。在编写消息时，他们提供代理的地址、安全配置和消息的内容。</p><h2 id="cb7f" class="nd mg it bd mh ne nf dn ml ng nh dp mp le ni nj mr li nk nl mt lm nm nn mv no bi translated">消费者</h2><p id="1caf" class="pw-post-body-paragraph kv kw it kx b ky mx ju la lb my jx ld le mz lg lh li na lk ll lm nb lo lp lq im bi translated">消费者代表客户端应用程序。他们阅读来自卡夫卡主题的信息。消费者像生产者一样管理连接池和网络协议。对于Kafka来说，许多消费者实例阅读一个主题也是正常的，因为在阅读一个消息后，它不会被破坏，它会被任何其他感兴趣的消费者阅读。</p><h2 id="ca22" class="nd mg it bd mh ne nf dn ml ng nh dp mp le ni nj mr li nk nl mt lm nm nn mv no bi translated">卡夫卡用例</h2><p id="616e" class="pw-post-body-paragraph kv kw it kx b ky mx ju la lb my jx ld le mz lg lh li na lk ll lm nb lo lp lq im bi translated">Kafka过程可以应用于数据科学项目，主要是在我们需要处理数据流和实时进行预测的时候。</p><p id="240d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们以电子商务中的实时推荐为例。我们可以离线训练一个模型，看看用户是否喜欢我们的推荐。用户加载页面的事件可以用Kafka Producer写入我们系统的主题中。然后提取和丰富特征并做出预测，我们可以阅读来自卡夫卡消费者的信息。</p><p id="0d9d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们还可以使用Kafka brokers跨不同的服务发送消息。该系统可以实现为微服务架构，其中一些微服务可以是生产者，而其他微服务可以是消费者。例如，一个人可以在主题上创建新的用户帐户，另一个人可以使用关于帐户的信息并向用户发送电子邮件。</p><h2 id="d090" class="nd mg it bd mh ne nf dn ml ng nh dp mp le ni nj mr li nk nl mt lm nm nn mv no bi translated">Python中的Kafka消费者示例</h2><p id="6fc1" class="pw-post-body-paragraph kv kw it kx b ky mx ju la lb my jx ld le mz lg lh li na lk ll lm nb lo lp lq im bi translated">这里我们将演示一个如何产生和消费消息的小例子。我们将在合流云中建立一个集群，并创建一个卡夫卡主题。然后，我们将使用<code class="fe np nq nr ns b">confluent_kafka</code>库用Python编写一个消费者，并运行它来观察输出消息。</p><p id="bbe7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先，我们需要在<a class="ae ku" href="https://confluent.cloud/" rel="noopener ugc nofollow" target="_blank">融合云</a>上创建一个帐户。然后我们建立了卡夫卡集群。在这里，我们可以选择它运行的服务(AWS、Google Cloud或Azure ),并选择区域和可用性区域。我们将我们的集群命名为<code class="fe np nq nr ns b">cluster_0</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nt"><img src="../Images/229b8163bf9865b71f1d90f7ecb396fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A-7KL5Jl3sDDLal-6c6bfA.png"/></div></div></figure><p id="00d1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当集群启动并运行时，我们可以转到topics选项卡并创建Kafka主题。我们将它命名为<code class="fe np nq nr ns b">topic_0</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi ny"><img src="../Images/f025bb281305bd02638a0a8ff949a7d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sDD689gDr0i5w4icZHntiA.png"/></div></div></figure><p id="7c46" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，我们需要安装Confluent CLI，并通过登录Confluent Cloud帐户连接到我们的集群。命令如下:</p><pre class="kj kk kl km gt nz ns oa ob aw oc bi"><span id="31c5" class="nd mg it ns b gy od oe l of og">brew install --cask confluent-cli<br/>confluent login</span></pre><p id="63c3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">连接完成后，我们可以检查我们的环境ID并选择使用它。</p><pre class="kj kk kl km gt nz ns oa ob aw oc bi"><span id="41f8" class="nd mg it ns b gy od oe l of og">confluent environment list<br/>confluent environment use &lt;env-ID&gt;</span></pre><p id="67f2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因为我们已经创建了Kafka集群，所以我们也应该能够列出它并选择它来使用。</p><pre class="kj kk kl km gt nz ns oa ob aw oc bi"><span id="cdae" class="nd mg it ns b gy od oe l of og">confluent kafka cluster list<br/>confluent kafka cluster use &lt;cluster-ID&gt;</span></pre><p id="ce72" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了与集群通信，我们需要定义API密钥和秘密密钥。</p><pre class="kj kk kl km gt nz ns oa ob aw oc bi"><span id="57a9" class="nd mg it ns b gy od oe l of og">confluent api-key create --resource &lt;cluster-ID&gt;<br/>confluent api-key use &lt;API-Key&gt; --resource &lt;cluster-ID&gt;</span></pre><p id="9a77" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，当与集群的通信建立后，我们应该能够看到创建的主题<code class="fe np nq nr ns b">topic_0</code>。</p><pre class="kj kk kl km gt nz ns oa ob aw oc bi"><span id="d2db" class="nd mg it ns b gy od oe l of og">confluent kafka topic list</span></pre><p id="d4e9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在我们应该用Python来定义消费者。首先，我们创建配置文件，定义Kafka集群运行的服务器、安全协议和凭证。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="0777" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了能够看到引导服务器地址，运行以下命令并复制字段<code class="fe np nq nr ns b">Endpoint SASL_SSL</code>的内容。</p><pre class="kj kk kl km gt nz ns oa ob aw oc bi"><span id="2856" class="nd mg it ns b gy od oe l of og">confluent kafka cluster describe</span></pre><p id="82d5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后我们定义<code class="fe np nq nr ns b">consumer.py</code>来解析配置文件，创建一个<code class="fe np nq nr ns b">Consumer</code>实例，然后从Kafka主题中提取现有的消息并打印它们的内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="69c3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们让<code class="fe np nq nr ns b">Consumer</code>脚本可执行并运行它。</p><pre class="kj kk kl km gt nz ns oa ob aw oc bi"><span id="9e47" class="nd mg it ns b gy od oe l of og">chmod u+x consumer.py<br/>./consumer.py config.ini</span></pre><p id="18d6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">运行<code class="fe np nq nr ns b">Consumer</code>之后，我们需要用数据填充主题。为此，我们在第二个终端中运行了<code class="fe np nq nr ns b">Producer</code>,并编写了以下消息。这里的索引是一个键，<code class="fe np nq nr ns b">:</code>右边的字符串是消息的值。</p><pre class="kj kk kl km gt nz ns oa ob aw oc bi"><span id="143c" class="nd mg it ns b gy od oe l of og">confluent kafka topic produce topic_0 --parse-key</span><span id="cc66" class="nd mg it ns b gy oj oe l of og">1:message 1<br/>2:message 2<br/>3:message 3<br/>4:message 4<br/>5:message 5<br/>6:message 6<br/>7:message 7<br/>8:message 8</span></pre><p id="ad8c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当我们切换回第一个终端时，我们应该看到消息正在被使用和打印。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi ok"><img src="../Images/a5c9f888d53400da595d04887c5501ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rKWaSrgkI3gVxiKNLCVwJA.png"/></div></div></figure><p id="1587" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">卡夫卡的主题所传达的信息被成功地消费了。我们还可以使用融合云UI来可视化这些消息。例如，消息7的偏移量为0，分区为0。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi ol"><img src="../Images/c2d539c5396ccee1f14e201c817b3e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJDMSiP7z3xFOAbykE_phw.png"/></div></div></figure><h1 id="c8b9" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">最后的想法</h1><p id="ae7e" class="pw-post-body-paragraph kv kw it kx b ky mx ju la lb my jx ld le mz lg lh li na lk ll lm nb lo lp lq im bi translated">在本文中，我们看到了Kafka的基本功能和术语，建立了一个融合云集群，并构建了一个Kafka消费者的示例。</p><p id="98f9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在接下来的文章中，我们将把Kafka过程引入机器学习管道。</p><p id="a188" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">感谢您在评论区的反馈！请继续关注。</p><p id="ca0b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">干杯！</p><h1 id="5f49" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">链接</h1><ul class=""><li id="42dd" class="lr ls it kx b ky mx lb my le om li on lm oo lq lw lx ly lz bi translated"><a class="ae ku" href="https://developer.confluent.io/learn-kafka/apache-kafka/events/" rel="noopener ugc nofollow" target="_blank">https://developer . confluent . io/learn-Kafka/Apache-Kafka/events/</a></li><li id="5e31" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><a class="ae ku" href="https://github.com/confluentinc/confluent-kafka-python" rel="noopener ugc nofollow" target="_blank">https://github.com/confluentinc/confluent-kafka-python</a></li><li id="54f2" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><a class="ae ku" href="https://kafka.apache.org/081/documentation.html" rel="noopener ugc nofollow" target="_blank">https://kafka.apache.org/081/documentation.html</a></li></ul><div class="op oq gp gr or os"><a rel="noopener  ugc nofollow" target="_blank" href="/build-production-ready-ml-workflow-with-dvc-and-s3-cdd9c95bf19"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">与DVC和S3一起构建生产就绪的ML工作流</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">DVC:和Git一样，只是数据不同</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">better编程. pub</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ko os"/></div></div></a></div><div class="op oq gp gr or os"><a rel="noopener  ugc nofollow" target="_blank" href="/run-s3-locally-with-minio-for-dvc-machine-learning-pipeline-7fa3d240d3ab"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">使用MinIO在本地运行DVC机器学习管道的S3</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">开始使用对象存储的最便宜和最快的方法。</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">better编程. pub</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg ko os"/></div></div></a></div></div></div>    
</body>
</html>