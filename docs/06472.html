<html>
<head>
<title>Custom Text Selection With ACTION_PROCESS_TEXT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ACTION_PROCESS_TEXT自定义文本选择</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/custom-text-selection-with-action-process-text-9c1cd9b24027?source=collection_archive---------7-----------------------#2020-10-05">https://betterprogramming.pub/custom-text-selection-with-action-process-text-9c1cd9b24027?source=collection_archive---------7-----------------------#2020-10-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7d26" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用意图过滤器的跨应用程序通信</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/991383f679f8d0292542be5aeedd631c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3atbxhhieGV03IMO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@rvignes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Romain Vignes </a>拍摄的照片。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="649b" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">什么是意图过滤器？</h1><p id="2f46" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">要理解<code class="fe mu mv mw mx b">ACTION_PROCESS_TEXT</code>的基础，你应该知道什么是意图过滤器，以及它是如何工作的。所以让我们从头开始。</p><h2 id="c065" class="my lh it bd li mz na dn lm nb nc dp lq mh nd ne ls ml nf ng lu mp nh ni lw nj bi translated">什么是意图？</h2><p id="2de8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">意图是从另一个Android组件触发动作的基本通信块。通常，该功能缩小到三个基本用例:开始一项活动、一项服务或一次广播。</p><p id="48a9" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">Android有两种意图。</p><p id="bd1d" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">显式意图:<strong class="ma iu"> </strong>这种类型的意图用于触发应用程序中的另一个组件，因为我们知道目标类名。</p><pre class="kj kk kl km gt np mx nq nr aw ns bi"><span id="b8ec" class="my lh it mx b gy nt nu l nv nw"><strong class="mx iu">val send </strong>= Intent(<strong class="mx iu">this</strong>@MainActivity, SecondActivity::<strong class="mx iu">class</strong>.java)<br/>startActivity(<strong class="mx iu">send</strong>)</span></pre><p id="14a2" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">隐含意图:<strong class="ma iu"> </strong>这种类型的意图帮助我们导航我们不知道的组件。例如，要在外部浏览器中打开一个URL，我们不知道浏览器应用程序的组件名。</p><pre class="kj kk kl km gt np mx nq nr aw ns bi"><span id="afa3" class="my lh it mx b gy nt nu l nv nw"><strong class="mx iu">val send </strong>= Intent()<br/><strong class="mx iu">send</strong>.action = <strong class="mx iu">Intent</strong>.ACTION_VIEW<br/><strong class="mx iu">send</strong>.data = <strong class="mx iu">Uri</strong>.parse(url)<br/>startActivity(<strong class="mx iu">send</strong>)</span></pre><p id="2814" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">所以这里我们要用<code class="fe mu mv mw mx b">ACTION</code>。它只是一个字符串，指定要执行的一般操作。当你用<code class="fe mu mv mw mx b">ACTION</code>触发一个意图时，支持<code class="fe mu mv mw mx b">ACTIONS</code>的应用将会显示出来(一个典型的用例是共享意图)。</p><h2 id="fd39" class="my lh it bd li mz na dn lm nb nc dp lq mh nd ne ls ml nf ng lu mp nh ni lw nj bi translated">意图过滤器</h2><p id="7640" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">到目前为止，我们已经从发送方的角度看到了一切。接收器呢？接收器应用程序如何支持<code class="fe mu mv mw mx b">ACTIONS</code>？答案是意图过滤器。</p><p id="3946" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">在清单中声明一个Android组件时，我们可以使用一个<code class="fe mu mv mw mx b">intent-filter</code>标签将该组件注册到一个或多个意图过滤器。据<a class="ae ky" href="https://developer.android.com/guide/components/intents-filters" rel="noopener ugc nofollow" target="_blank">安卓开发者</a>:</p><blockquote class="nx ny nz"><p id="1ffd" class="ly lz oa ma b mb nk ju md me nl jx mg ob nm mj mk oc nn mn mo od no mr ms mt im bi translated">每个意图过滤器基于意图的动作、数据和类别指定它接受的意图类型。只有当意图可以通过您的意图过滤器之一时，系统才会向您的应用程序组件传递隐式意图。”</p></blockquote><p id="2752" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">意图-清单文件中的过滤器用法</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ed52" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">为什么需要ACTION_PROCESS_TEXT？</h1><p id="e5c7" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">从Android 6.0 Marshmallow开始，引入了一个新的浮动文本选择工具栏，使复制、粘贴和剪切等选项更贴近所选文本。</p><p id="997e" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">有通用选项固然很好，但是显示工具栏的必要应用也同样重要。例如，当用户选择一些文本时，显示翻译器作为选项之一。</p><p id="a60a" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">显示未内置到系统中的应用程序不是由操作系统决定的。互动应该是双方的。这就是意图过滤器和<code class="fe mu mv mw mx b">ACTION_PROCESS_TEXT</code>的用武之地。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="4c7e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">什么是ACTION_PROCESS_TEXT？</h1><p id="e5bb" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe mu mv mw mx b">ACTION_PROCESS_TEXT</code>只不过是在API级中引入的一个<code class="fe mu mv mw mx b">ACTION</code>字符串。在清单文件中的Android组件上使用这个动作和<code class="fe mu mv mw mx b">intent-filter</code>，将向系统发出信号，表明这个应用程序可以处理选择的文本。</p><p id="0cf1" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">因此，操作系统将在浮动文本选择工具栏中显示相应的应用程序。一旦用户选择了一个应用程序，一个隐含的意图就会被激发，其中<code class="fe mu mv mw mx b">ACTION_PROCESS_TEXT</code>作为<code class="fe mu mv mw mx b">ACTION</code>，所选的文本在附加部分，这样开发者就可以在各自的Android组件中检索它们。</p><p id="6ffe" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">理论说够了。让我们做一些编码。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5a68" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">意图过滤器设置</h1><p id="3abd" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">第一步应该是对您希望在浮动工具栏中显示的Android组件实现意图过滤器。这很简单。我们需要包含<code class="fe mu mv mw mx b">intent-filter</code>标签，并将<code class="fe mu mv mw mx b">ACTION</code>设置为<code class="fe mu mv mw mx b">android.intent.action.PROCESS_TEXT</code>。</p><p id="957c" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">我们还可以设置mime类型，将您的应用程序限制在特定的类别中(例如，仅在选择文本时显示)。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文本处理意图过滤器</p></figure><p id="873c" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">此时，如果您运行应用程序并在设备中的任意位置选择文本，您的应用程序将显示在浮动工具栏中。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5db2" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">获取选定的文本</h1><p id="a427" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">现在我们已经在文本选择工具栏中显示了应用程序，下一步是处理输入数据。这很简单。我们只需要验证传入意图<code class="fe mu mv mw mx b">ACTION</code>是否为<code class="fe mu mv mw mx b">android.intent.action.PROCESS_TEXT</code>:</p><pre class="kj kk kl km gt np mx nq nr aw ns bi"><span id="2389" class="my lh it mx b gy nt nu l nv nw"><strong class="mx iu">if </strong>(intent.<strong class="mx iu">action </strong>!= null &amp;&amp;<br/>        intent.<strong class="mx iu">action</strong>.equals(Intent.<strong class="mx iu">ACTION_PROCESS_TEXT</strong>) ){<br/>    <br/>}</span></pre><p id="7963" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">如果是<code class="fe mu mv mw mx b">true</code>，那么我们需要读取输入数据。默认情况下，读取输入数据的键是<code class="fe mu mv mw mx b">Intent.EXTRA_PROCESS_TEXT</code>。这将返回<code class="fe mu mv mw mx b">CharSequence</code>，我们需要将它转换成一个字符串，然后使用。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文本处理读取输入</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6a6f" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">更新结果</h1><p id="3188" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在某些情况下，我们需要发送回文本(例如，如果您的应用程序就像那些时髦的字体之一，那么您需要将输入数据转换成其各自的样式，并在源文件中替换它)。</p><p id="a199" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">为此，我们首先需要验证源是否可以观察到更新后的结果。为此，我们在intent extras中获得了另一个参数— <code class="fe mu mv mw mx b">EXTRA_PROCESS_TEXT_READONLY</code>。看一看:</p><pre class="kj kk kl km gt np mx nq nr aw ns bi"><span id="b78c" class="my lh it mx b gy nt nu l nv nw">isReadOnly = intent.getBooleanExtra(<br/>                 <strong class="mx iu">Intent</strong>.EXTRA_PROCESS_TEXT_READONLY, <strong class="mx iu">false</strong>)</span></pre><p id="ef86" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">如果这是<code class="fe mu mv mw mx b">true</code>，那么源不能更新文本。如果是假的，那么我们可以通过<code class="fe mu mv mw mx b">setResult</code>发送回处理过的文本。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">发回已处理的文本</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="4fc3" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="c021" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果开发者以正确的方式使用这样的功能(像在<a class="ae ky" href="https://play.google.com/store/apps/details?id=org.wikipedia" rel="noopener ugc nofollow" target="_blank">维基百科</a>和<a class="ae ky" href="https://play.google.com/store/apps/details?id=com.google.android.apps.translate" rel="noopener ugc nofollow" target="_blank">谷歌翻译</a>)，这将提高Android的质量。另一方面，误用它会导致Android体验不佳。</p><p id="1a57" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">不是每个应用程序都需要使用这种类型的跨应用程序通信，所以我建议您只有在Android的操作系统定制为最终用户增加价值的情况下才利用它。</p><p id="fb81" class="pw-post-body-paragraph ly lz it ma b mb nk ju md me nl jx mg mh nm mj mk ml nn mn mo mp no mr ms mt im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读！</p></div></div>    
</body>
</html>