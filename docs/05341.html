<html>
<head>
<title>When Parallelism Beats Concurrency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当并行性战胜并发性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/when-parallelism-beats-concurrency-5f52d7012944?source=collection_archive---------3-----------------------#2020-07-01">https://betterprogramming.pub/when-parallelism-beats-concurrency-5f52d7012944?source=collection_archive---------3-----------------------#2020-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="19b6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这两者不是一回事</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d892b50cd571db5c5e3b4eca3d25d4c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/0*OatbcjcF_2YmF5jl"/></div></figure><p id="9cfa" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我知道，对你们中的许多人来说，这两个概念可能意味着同样的事情，或者也许你会努力解释它们之间的区别。然而，它们实际上是两个非常不同的概念。这对于理解我们现在处理数据的方式非常重要。</p><p id="a4ae" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这两种情况下，我们都试图通过增加致力于特定任务的工人数量来更快地解决问题，但他们分配工作的方式是他们最大的差异所在。</p><p id="dd97" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您将会明白，为什么理解它们的差异对于高效、安全、无误地处理数据如此重要。</p><p id="5ea0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">先从解释这些概念开始吧！</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="52ef" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">介绍</h1><p id="baab" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">首先，让我们简单了解一下我们应该理解的并发性和并行性。</p><h2 id="bf9f" class="mq lu it bd lv mr ms dn lz mt mu dp md kz mv mw mf ld mx my mh lh mz na mj nb bi translated">并发</h2><p id="1028" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">通俗地说，<strong class="ks iu">并发</strong>是这样一种情况，为了解决一个问题，我们以这样一种方式处理它:<strong class="ks iu">一个单一的任务被多个工作者</strong>同时处理；也就是说，让我们想象一个大数组，其中有多个工作线程，每个工作线程处理数组中要处理的下一个元素，直到到达数组的末尾。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/2c7ce1e270f4323a69f629e1645fd71f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Sl5vN81dNDVV-sO0"/></div></div></figure><p id="35c3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当并发发生时，需要一些<strong class="ks iu">同步</strong>，以便访问在所有现有工作者之间共享的资源(在我们的例子中，这是数组)。</p><p id="053c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在某些情况下，这种方法的复杂性和性能开销可能非常大；我们将在本文的后面尝试演示这一点。</p><h2 id="d75e" class="mq lu it bd lv mr ms dn lz mt mu dp md kz mv mw mf ld mx my mh lh mz na mj nb bi translated">平行</h2><p id="2e34" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">另一方面，<strong class="ks iu">并行性</strong>是这样一种情况，为了解决一个问题，我们决定采取一种“<a class="ae nh" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm" rel="noopener ugc nofollow" target="_blank">分而治之</a>”的方法，将问题分成多个小问题。这允许我们<strong class="ks iu">并行解决多个更小的问题</strong>。</p><p id="a5e8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用我们上面展示的同一个例子会是什么样子呢？假设我们有四个并行的工人。并行解决方案如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/9784481d975b310bffc02150783d31d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jhaJQyzXuKfIv99-"/></div></div></figure><p id="f652" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如你所见，差别是实质性的；我们现在有四个可以独立解决的小任务。知道了这一点，我们就可以确认每个工人顺序地处理了<strong class="ks iu">元素！当每个工人完成任务后，我们可以<strong class="ks iu">将他们的结果组合起来，产生一个单一的最终结果</strong>。</strong></p><p id="d2b9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这样做的主要好处是，我们不需要同步工作人员对共享资源的访问；现在，每个工人都有自己独立的工作要处理。</p><p id="36b1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我希望这两者的区别是清楚的，但是还剩下什么呢？我们还有一个案例，相当明显:<strong class="ks iu">顺序处理</strong>。</p><p id="6ff2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在标准的顺序流程中，我们将由一个工人按顺序处理我们的任务。这是更常见的方法，在某些情况下，这可能是最快的方法！</p><p id="cf1c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你需要更好地理解并发和多线程，以及为什么我们用现在的方式做事，我推荐你读一读布莱恩·戈茨 的书<a class="ae nh" href="https://geni.us/ZVVg" rel="noopener ugc nofollow" target="_blank"> <strong class="ks iu">【实践中的Java并发】。</strong></a></p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="c7c7" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">怎么才能解决呢？</h1><p id="7949" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">如果我们在性能方面比较这三种方法，我们几乎可以保证<strong class="ks iu">在大多数情况下，并发方法的性能要差得多</strong>。这是为什么呢？正如我们之前提到的，线程间同步访问共享资源会导致争用，从而影响性能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/88d7bcccf47cd18ac989f3eff4d3208a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BA9Y-Fe3ZQHFIpqR"/></div></div></figure><p id="0e53" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们通过一个例子来理解这种性能影响的原因！</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="d2e4" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">并行方法</h1><p id="c747" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">我们要展示的问题是整数集合中所有元素的相加。在并发方法中，我们将使用几个线程来添加每一对元素，以尝试加快速度；那么它看起来像什么？</p><p id="6056" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，我们将创建一个接口来实现遵循不同方法的解决方案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c244" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">有了它，我们的并发实现将是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6178" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所做的基本上是创建固定数量的线程，其中每个线程每次都将在数组中添加一对元素，直到到达数组的末尾。</p><p id="948f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">你会注意到我们使用了<a class="ae nh" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-frame.html" rel="noopener ugc nofollow" target="_blank"><strong class="ks iu">Java . util . concurrent . atomic</strong></a>包中的两个重要Java类；我们说的是<a class="ae nh" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html" rel="noopener ugc nofollow" target="_blank">原子积分器</a>和<a class="ae nh" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAccumulator.html" rel="noopener ugc nofollow" target="_blank">长累加器</a>。</p><p id="96f5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这两个类非常有助于同步对当前位置和最终结果的访问；但是，它们也会对解决方案的性能产生相当大的影响。我们来看看为什么！</p><h2 id="d7ec" class="mq lu it bd lv mr ms dn lz mt mu dp md kz mv mw mf ld mx my mh lh mz na mj nb bi translated"><strong class="ak">原子变量内部</strong></h2><p id="3ba2" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">首先，为什么我们已经决定使用<a class="ae nh" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html" rel="noopener ugc nofollow" target="_blank"> AtomicInteger </a>来保持我们当前的位置？</p><p id="0fb4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">嗯，<a class="ae nh" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html" rel="noopener ugc nofollow" target="_blank"> AtomicInteger </a>非常适合那些变量将被多线程修改的情况，但更重要的是，<strong class="ks iu">这个变量将被非常频繁地读取</strong>。</p><p id="0330" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu"> AtomicInteger </strong>结合使用了<a class="ae nh" href="https://en.wikipedia.org/wiki/Compare-and-swap" rel="noopener ugc nofollow" target="_blank">比较和交换</a>和<strong class="ks iu">可变</strong>变量。</p><p id="f91f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">“<strong class="ks iu">比较和交换</strong>是对使用“<a class="ae nh" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html" rel="noopener ugc nofollow" target="_blank">同步</a>块的改进；然而，如果一个线程试图设置一个已经改变的值，它的写操作将失败，它将不得不重试。</p><p id="84f7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最重要的是，volatile的使用意味着，在许多情况下，当一个线程访问该变量时，必须从主内存中检索它的值；这是一个相当大的性能影响，因为访问主内存比访问高速缓存级别要昂贵得多。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/68ffe49bd322d77b5f31c4945c5cd790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ca_9TTiaA2FuS05E"/></div></div></figure><p id="5e20" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae nh" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAccumulator.html" rel="noopener ugc nofollow" target="_blank">长累加器</a>呢？这种类型的类在几个线程写入一个变量，但在操作完成之前不会被读取时很有用。它是如何工作的？<a class="ae nh" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAccumulator.html" rel="noopener ugc nofollow" target="_blank"> LongAccumulator </a>巧妙地利用了一种非阻塞方法，允许多个写操作并行写入各个计数器，然后在进程结束时将它们合并。大概是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/1acd431fb563d57f0becbd445d26f600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lBlYB3J_8EYbT2G_"/></div></div></figure><p id="8a6e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所以在理解了我们的解决方案是如何工作的之后，我们可以肯定<strong class="ks iu">这个实现中的主要瓶颈是不同线程之间的数组当前位置的同步</strong>。</p><p id="65e2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在让我们来看看我们的顺序实现！</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="5905" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">顺序方法</h1><p id="ac9a" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">顺序方法非常简单——我们只是使用单线程顺序处理每个元素。让我们看看它是什么样子的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8766" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们使用Java <a class="ae nh" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" rel="noopener ugc nofollow" target="_blank">流</a>遍历元素，并利用<a class="ae nh" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-java.util.function.BinaryOperator-" rel="noopener ugc nofollow" target="_blank"> reduce </a>方法通过添加每一对来组合元素。</p><p id="8464" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们也可以使用标准的Java循环，迭代遍历每个元素，将总和保存在一个变量中。这种方法会有什么问题？主要问题是它不容易并行化；使用并发方法需要一定程度的同步，才能得到有效的结果。</p><p id="8d89" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，我们的顺序解决方案还不错，尽管在添加更多线程可以减少工作时间的情况下，它还可以改进。这就引出了我们的最后一种方法:并行方法。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="a478" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">平行方法</h1><p id="0f84" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">在过去，实现并行方法要困难得多，但是自从JDK 8之后，随着Java流的引入，事情变得简单多了。</p><p id="3abf" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">实际上，由于Java Streams API，我们的并行实现与顺序方法只有一处不同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="de12" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">很简单吧？</p><p id="2a5e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">那么你认为并行执行总是比顺序执行快吗？可能你们大多数人会认为肯定会，但事实是<strong class="ks iu">事情没那么简单！</strong>为什么会这样？</p><p id="8a79" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了能够进行有效的并行处理，我们必须考虑不同的方面；这意味着只有在特定的条件下，并行化我们的代码才能真正提高代码的性能。下面就从这几个方面来看看吧！</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/8f57aff494d8df33bbdde29dc08c5d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*llzJFVmOKmhdpMdb"/></div></div></figure><h1 id="c662" class="lt lu it bd lv lw nk ly lz ma nl mc md jz nm ka mf kc nn kd mh kf no kg mj mk bi translated">并行与顺序</h1><p id="d051" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">正如我们提到的，<strong class="ks iu">并行方法并不总是解决问题的最快方案</strong>。在并行化我们的代码之前，我们必须考虑几个方面:</p><h2 id="15c1" class="mq lu it bd lv mr ms dn lz mt mu dp md kz mv mw mf ld mx my mh lh mz na mj nb bi translated"><strong class="ak">数据是否大到足以有所作为？</strong></h2><p id="daf3" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">在许多情况下，我们必须处理的数据量是如此之小，以至于当数据被分割并分配给线程时，单线程的顺序执行将会完成！</p><h2 id="a00d" class="mq lu it bd lv mr ms dn lz mt mu dp md kz mv mw mf ld mx my mh lh mz na mj nb bi translated"><strong class="ak">信号源容易分裂吗？</strong></h2><p id="2b29" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">如果我们不能容易地以平均的方式分割数据，这可能会导致开销，与顺序执行相比，这将使我们失去运行并行工作器的所有好处。</p><p id="0b55" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">举个例子，如果你的源码是一个<a class="ae nh" href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" rel="noopener ugc nofollow" target="_blank">迭代器</a>，你就不能轻易拆分它；然而，从JDK 8开始，Java引入了<a class="ae nh" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">拆分器</a>来拥有一个可拆分迭代器。</p><h2 id="0dce" class="mq lu it bd lv mr ms dn lz mt mu dp md kz mv mw mf ld mx my mh lh mz na mj nb bi translated"><strong class="ak">能否分割成完全独立、孤立的工作块？</strong></h2><p id="8ad3" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">有时，一个步骤中的每一步都依赖于前一步的结果，这就形成了一种无法打破的相互依赖关系。这些任务<strong class="ks iu">本质上是顺序的，</strong>在这些情况下，并行运行我们的任务是完全没有意义的，因为我们看不到任何好处。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/8fab2ce462af63ba87eadd0ed494dc44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-Wgm1GdGitziIo4p"/></div></div></figure><h2 id="1673" class="mq lu it bd lv mr ms dn lz mt mu dp md kz mv mw mf ld mx my mh lh mz na mj nb bi translated"><strong class="ak">合并结果便宜还是贵？</strong></h2><p id="668a" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">不得不合并整数和不得不合并不同线程生成的多个复杂树是不一样的；那会非常昂贵。我们必须始终考虑这一点，因为在并行化我们的代码时，我们可能会得到意想不到的结果。</p><h2 id="5ca4" class="mq lu it bd lv mr ms dn lz mt mu dp md kz mv mw mf ld mx my mh lh mz na mj nb bi translated"><strong class="ak">我们必须保持处理元素的顺序吗？</strong></h2><p id="931f" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">在我们必须保持接收元素的顺序的情况下，我们的并行化选择将非常有限。</p><p id="f160" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">知道了这一点，我们应该知道Java流在知道数据是无序的时候能够进行优化，正如我们在我的文章“<a class="ae nh" href="https://medium.com/swlh/understanding-java-streams-e0f2df12441f" rel="noopener">理解Java流</a>”中解释的那样，流是如何使用标志进行优化的。</p><p id="6e5b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">利用这一点的一个方法是使用<a class="ae nh" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#unordered--" rel="noopener ugc nofollow" target="_blank"> unordered() </a>来表达我们不关心顺序；这将允许优化许多短路操作，如<a class="ae nh" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#findFirst--" rel="noopener ugc nofollow" target="_blank"> findFirst() </a>、<a class="ae nh" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#findAny--" rel="noopener ugc nofollow" target="_blank"> findAny() </a>或<a class="ae nh" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#limit-long-" rel="noopener ugc nofollow" target="_blank"> limit() </a>。</p><h2 id="b087" class="mq lu it bd lv mr ms dn lz mt mu dp md kz mv mw mf ld mx my mh lh mz na mj nb bi translated"><strong class="ak">缓存未命中</strong></h2><p id="e285" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">我们实现代码的方式可能会对性能产生重大影响；例如，使用基于数组的结构有利于CPU缓存中的分配。当我们访问第一个元素时，我们的硬件会分配一个数组块，因为大多数时候，我们会访问数组中更多的元素。这对性能有非常有利的影响，因为缓存访问比主内存访问快得多。</p><p id="fc81" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在并行执行的情况下，<strong class="ks iu">如果我们不断得到缓存未命中，我们的线程将被阻塞，等待从内存中提供数据</strong>；这意味着我们将失去运行并行线程的部分好处。</p><blockquote class="np nq nr"><p id="955d" class="kq kr ns ks b kt ku ju kv kw kx jx ky nt la lb lc nu le lf lg nv li lj lk ll im bi translated">对于Java流，并行执行几乎是神奇的，但它并不像看起来那么简单！</p></blockquote><p id="fa1d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">好了，这些是你在使用并行执行时必须记住的一些事情！现在让我们看看我们的实现的一些性能结果，看看我们所经历的所有理论实际上是否有意义。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="952e" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">性能比较</h1><p id="15d9" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">在这一节中，我们将展示针对我们的实现的一些基准执行的结果，以检查这是否与我们到目前为止所研究的相匹配。</p><p id="f095" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">JMH已经被用来轻松地创建基准测试；在JMH可用的不同类型的基准测试中，我们选择运行“平均时间”基准测试。</p><p id="17e5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在第一次运行中，我们将选择大小为1，000，000的元素；根据结果，我们将看到下一步该做什么。</p><h2 id="fdbb" class="mq lu it bd lv mr ms dn lz mt mu dp md kz mv mw mf ld mx my mh lh mz na mj nb bi translated">第一个基准:100万个元素</h2><p id="3f7f" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">理解这些测试如何运行的源代码可以在<a class="ae nh" href="https://github.com/theboreddev/parallelism-vs-concurrency" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="7c1a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">基本上，我们已经运行了两次预热基准测试迭代，给JIT编译器足够的时间来进行优化，然后我们在第三次迭代中获得结果。</p><p id="a5e4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">那么，让我们言归正传——结果是什么？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nw"><img src="../Images/20c5f7954ad28362aceca24fee9fdfd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3YsWyoO15Dl_hDCX2ioTXQ.png"/></div></div></figure><p id="d277" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">正如所料，并发方法是迄今为止性能最差的，平均花费了<strong class="ks iu"> 1秒和38毫秒</strong>。另一方面，平行和顺序方法有类似的结果。顺序方法以超过2毫秒的优势胜出！</p><p id="13bc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">正如我们前面提到的，编写高效的并行代码并不容易；我认为原因之一可能是数据不够大。让我们用10，000，000来再次运行我们的基准测试。</p><h2 id="c538" class="mq lu it bd lv mr ms dn lz mt mu dp md kz mv mw mf ld mx my mh lh mz na mj nb bi translated">第二个基准:1000万个元素</h2><p id="6ddd" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">添加10，000，000个元素的结果是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nx"><img src="../Images/dc4e79883f4e3889186692cce6f00803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tcOPcjKuJOALSXNF0IFP6w.png"/></div></div></figure><p id="503a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">在这种情况下，明显的赢家是并行方法！</strong>我们还注意到并发方法的优势已经大大降低。</p><p id="4ee4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，我们必须处理多达10，000，000个元素才能注意到并行处理的显著改进；然而，这只是一个非常简单的例子，可以考虑其他方面，并可以进一步改进。</p><p id="09bc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我说的就是这些！我真的希望你这次学到了一些东西！</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="41f2" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">结论</h1><p id="f9cc" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">我们已经了解到，尽管Java流使得切换我们的代码并行执行变得非常容易，但是事情并不总是那么简单。</p><p id="2140" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当性能是我们的业务需求之一时，最好的做法是总是运行性能测试，但是请<strong class="ks iu">不要陷入过早的优化</strong>。如果让你的代码更快对你的组织没有真正的商业利益，那么不要浪费你的时间和精力。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/5a4655aac7aecee764d55e78745209d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mya5GpAAH2vsQYPf"/></div></div></figure><p id="c440" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">还有一件事很有帮助，那就是很好地理解每一层是如何工作的，从CPU到应用程序源代码的最顶层。了解内部机制及其对性能的影响总是有助于预测性能方面可能出现的问题。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ny"><a href="https://codeburst.io/a-new-concurrency-model-in-java-975d597dd5e4" rel="noopener follow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">一种新的Java并发模型</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">在过去的几年里，我们在并发模型中编写代码的方式发生了很大的变化。在过去…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">codeburst.io</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ko ny"/></div></div></a></div><div class="on oo gp gr op ny"><a href="https://medium.com/swlh/combining-multiple-api-calls-with-completablefuture-1d9d27e03bec" rel="noopener follow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">用CompletableFuture组合多个API调用</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">在我的上一篇文章“新的并发性……”中介绍了Java中的新并发范例之后</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">medium.com</p></div></div><div class="oh l"><div class="oq l oj ok ol oh om ko ny"/></div></div></a></div></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><p id="02c7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">非常感谢您的阅读！</p></div></div>    
</body>
</html>