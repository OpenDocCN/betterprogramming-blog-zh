<html>
<head>
<title>Asynchronous State Management With React-Query</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有反应查询的异步状态管理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/asynchronous-state-management-with-react-query-a9937457ed5e?source=collection_archive---------8-----------------------#2022-04-20">https://betterprogramming.pub/asynchronous-state-management-with-react-query-a9937457ed5e?source=collection_archive---------8-----------------------#2022-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9b0f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将我们的请求包装在<code class="fe kf kg kh ki b">useQuery</code>中并使用缓存键意味着我们根本不需要考虑从网络请求中接收的数据的状态管理</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/074c4ee113776c93f08e9ed821299a97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vD4mY6iEQ34HTcAYyPTlnw.png"/></div></div></figure><p id="6b4f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">花点时间想想您最新的React项目中的共享状态。对于大多数应用程序，这可能包括当前登录的用户。</p><p id="14f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">博客应用可以包括所有可用的博客帖子或由特定作者撰写的所有博客帖子。</p><p id="8f5c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">健身应用可以包括针对所选肌肉群的锻炼列表。</p><p id="f214" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">棒球应用可以包括特定运动员的击球统计。实际上，React应用程序中的共享状态可以是任何东西！</p><p id="5a0e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是所有这些国家有什么共同之处呢？我们通过网络请求访问它们(或者到我们自己的后端，或者到第三方API)。</p><p id="8ec9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看如何使用定制钩子和<a class="ae lr" href="https://react-query.tanstack.com/" rel="noopener ugc nofollow" target="_blank"> react-query </a>来管理这些来自异步网络请求的状态。</p><h1 id="1a23" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">利用useQuery钩子</h1><p id="3a78" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在我们的例子中，我们将大量使用react-query中的<code class="fe kf kg kh ki b">useQuery()</code>钩子。这个钩子有三个参数—</p><ol class=""><li id="d997" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">我们将发出的请求的缓存键</li><li id="850a" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">查询功能</li><li id="3edf" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">一个选项对象。</li></ol><p id="e6cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于我们所有的例子，让我们想象一个健身应用程序，它允许用户按肌肉群搜索锻炼。首先，让我们彻底了解如何使用<code class="fe kf kg kh ki b">useQuery()</code>发出一个网络请求，从我们想象的API中获得所有的反馈练习。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7459" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们已经定义了查询函数<code class="fe kf kg kh ki b">fetchBackExercises()</code>，它向我们假想的端点<code class="fe kf kg kh ki b">/exercises?muscleGroup=back</code>发出请求。</p><p id="dc18" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以想象这个端点将返回一个JSON形式的练习对象列表，可以在我们的react应用程序中使用它来创建一个列出练习的组件。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="940c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">老实说，我觉得这有点乱。我希望我的组件尽可能地具有可读性，其中有大量的JavaScript代码，很难一看就知道发生了什么。让我们稍微重构一下，将所有的查询逻辑放入一个定制的钩子中。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="87ab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这看起来更好！所有关于获取练习的网络请求的逻辑现在都封装在我们的定制<code class="fe kf kg kh ki b">useExercises()</code>钩子中。</p><p id="eaf0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个钩子接受一个参数<code class="fe kf kg kh ki b">muscleGroup</code>，因此它可以在我们的应用程序中的任何地方轻松重用。</p><p id="8583" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe kf kg kh ki b">muscleGroup</code> arg既用在实际网络请求的查询参数中，也用在<code class="fe kf kg kh ki b">useQuery</code>钩子的缓存键中，这将很快变得重要。</p><p id="ac33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这允许我们简化我们的<code class="fe kf kg kh ki b">&lt;ExerciseList /&gt;</code>组件，这样我们所做的就是调用我们的钩子，并映射结果来创建我们的组件列表。</p><h1 id="c678" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">这对状态管理有什么帮助？</h1><p id="0d87" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">到目前为止，我们已经有了一个非常干净的、可重用的钩子和组件，但是这和状态管理有什么关系呢？答案就在react-query的缓存中。</p><p id="bd16" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">记住<code class="fe kf kg kh ki b">useQuery()</code>钩子的第一个参数是一个<em class="nf">缓存键</em>。通过<code class="fe kf kg kh ki b">useQuery()</code>发出的每个网络请求的响应都用那个键保存在缓存中。</p><p id="1f1f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在发出请求之前，react-query将检查缓存。如果缓存中已经存在相同的键，<code class="fe kf kg kh ki b">useQuery()</code>将简单地获取缓存的响应并返回它，而不是浪费资源再次发出相同的请求。</p><p id="f55e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从本质上说，这意味着react-query的缓存成为我们存储来自网络请求的任何状态的数据(对于大多数应用程序来说，这几乎就是一切！).</p><p id="56bf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的<code class="fe kf kg kh ki b">useExercise()</code>钩子的例子中，许多不同的组件可以使用钩子来请求<code class="fe kf kg kh ki b">muscleGroup: 'back'</code>的练习。实际的网络请求只会发出一次，随后每次调用<code class="fe kf kg kh ki b">useExercises('back')</code>都会从react-query缓存中抓取响应。</p><p id="3924" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们要求的任何其他肌肉群也是如此(<code class="fe kf kg kh ki b">useExercises('chest')</code>、<code class="fe kf kg kh ki b">useExercises('biceps')</code>、<code class="fe kf kg kh ki b">useExercises('legs')</code>等)。由于我们将<code class="fe kf kg kh ki b">muscleGroup</code>参数传递到缓存键(<code class="fe kf kg kh ki b">['exercises', muscleGroup]</code>)，每个新的<code class="fe kf kg kh ki b">muscleGroup</code>将触发一个实际的网络请求，但是每个后续请求将使用缓存，就像它只是任何其他状态一样。</p><p id="1e9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么以这种方式管理我们的异步状态有什么好处呢？将我们的请求包装在<code class="fe kf kg kh ki b">useQuery</code>中并使用缓存键意味着我们根本不需要考虑从网络请求中接收的数据的状态管理。</p><p id="a8a4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们不需要担心上下文/提供者，我们<em class="nf">绝对</em>不需要担心任何第三方状态管理库。以这种方式管理异步状态允许我们保持干净、可维护、简单、可读的代码。</p></div></div>    
</body>
</html>