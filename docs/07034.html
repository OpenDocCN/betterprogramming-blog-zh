<html>
<head>
<title>How to Programmatically Create a Preference-Styled Toolbar in macOS Catalyst</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在macOS Catalyst中以编程方式创建偏好样式的工具栏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-programmatically-create-a-preference-styled-toolbar-in-macos-catalyst-d7c370199c49?source=collection_archive---------13-----------------------#2020-11-30">https://betterprogramming.pub/how-to-programmatically-create-a-preference-styled-toolbar-in-macos-catalyst-d7c370199c49?source=collection_archive---------13-----------------------#2020-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="46be" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Catalyst中更好的工具栏样式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/63f8fc1f1734680b7a0d6180d5410f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YvJEzaoQkdDrMVOklK9mQw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片。</p></figure><p id="87c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">大苏尔给Mac带来了大规模的重新设计。它提供了新的图标和新的、更简洁的UI设计，同时保持了macOS的特性。它也为我们的Catalyst开发带来了很大的改进，但是今天我们将讨论工具栏的新偏好样式。</p><p id="02be" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文的目的是创建一个具有这种工具栏风格的首选项控制器。这种风格以前已经存在，但大苏尔采取了不同的方法。它现在有一个更干净的外观和感觉，并且在越来越多的应用程序中使用。本教程假设您已经有了首选项窗口的场景。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="1d83" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">让我们开始编码吧</h1><p id="370c" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">首先，我们需要在窗口中添加一个<code class="fe mv mw mx my b">toolbar</code>。在我们的<code class="fe mv mw mx my b">SettingsViewController</code>中，我们制作了一个名为<code class="fe mv mw mx my b">insertToolbar()</code>的新函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e8b1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们分解一下刚刚编写的代码:</p><ol class=""><li id="a77b" class="nb nc iq kx b ky kz lb lc le nd li ne lm nf lq ng nh ni nj bi translated">我们检查我们是在为Mac还是iOS构建。</li><li id="1034" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated">我们从当前的<code class="fe mv mw mx my b">windowScene</code>创建一个场景对象，如果它存在的话。如果不存在，函数返回。</li><li id="e7fc" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated">我们检查场景中是否有标题栏。</li><li id="d792" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated">我们用<code class="fe mv mw mx my b">mainToolbar</code>标识符创建了一个<code class="fe mv mw mx my b">NSToolbar</code>类型的<code class="fe mv mw mx my b">toolBar</code>对象。我们还将<code class="fe mv mw mx my b">ToolbarIdentifers.general</code>分配给<code class="fe mv mw mx my b">toolBar</code>的<code class="fe mv mw mx my b">selectedItemIdentifier</code>属性。这会给你一个错误，这个错误稍后会被修复。</li><li id="2e06" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated">我们将<code class="fe mv mw mx my b">toolBar</code>样式设置为<code class="fe mv mw mx my b">.preferece</code>，给它我们想要的外观；</li><li id="75ff" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated">我们将刚刚创建的<code class="fe mv mw mx my b">toolBar</code>对象分配给<code class="fe mv mw mx my b">titleBar</code>的工具栏属性。</li></ol><p id="0e72" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将我们的控制器<code class="fe mv mw mx my b">self</code>分配给<code class="fe mv mw mx my b">toolBar</code>的代表。它现在返回一个错误，因为我们的控制器还不符合<code class="fe mv mw mx my b">NSToolbarDelegate</code>。为了解决这个问题，我们创建了一个<code class="fe mv mw mx my b">ViewController</code>的扩展，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3209" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个新的扩展中，我们将实现一些工具栏功能。首先，创建一些标识符常量，而不是每次我们需要寻址一个特定的标识符时都编写一个字符串，这是一个好的做法。这将减少拼写错误的风险。所以在我们刚刚创建的扩展中，我们把这个枚举:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="641f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="np">注意:为了简单起见，我稍后将对SF符号的名称进行硬编码。</em></p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="a6a1" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">标识符离题了</h1><p id="f471" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">为了将所有的常数放在一个地方，可以这样创建一个枚举:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="08b5" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">回到真正的编码</h1><p id="940f" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">我们刚刚创建了项目的标识符。现在我们必须告诉工具栏显示什么以及如何显示。我们从添加<code class="fe mv mw mx my b">public func toolbarAllowedItemIdentifiers(_ toolbar: NSToolbar) -&gt; [NSToolbarItem.Identifier]</code>方法开始，该方法告诉工具栏哪些项目是允许的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e615" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它必须返回一个数组<code class="fe mv mw mx my b">NSToolbarItem.Identifier</code>，该数组由我们提前几步设置的标识符组成。现在，我们需要告诉工具栏哪些是默认项目，哪些是可选项目，以便它们获得我们期望的行为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ee25" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们离终点只有一步之遥。我们需要确定按钮看起来应该是什么样子，以及按下时它必须做什么。<code class="fe mv mw mx my b">public func toolbar(_ toolbar: NSToolbar, itemForItemIdentifier itemIdentifier: NSToolbarItem.Identifier, willBeInsertedIntoToolbar flag: Bool) -&gt; NSToolbarItem?</code>前来救援:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b837" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个方法中，我们告诉工具栏哪些项目属于哪个标识符。底部的三个方法是我们的项目执行的动作。在那里更改控制器的内容。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="68e0" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">构建并运行</h1><p id="8368" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">让我们构建并运行我们的应用程序。恭喜你，你做到了！以下是这项工作的成果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/ad70f47f3335cb646a5d599e9a5c76c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bz6hvoq5JGUB68ic"/></div></div></figure></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="7b21" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated"><strong class="ak">奖金</strong></h1><p id="bf98" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">为了在改变标签页时改变窗口的标题，我们必须改变场景标题，可以这样做:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7f70" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文使用的代码可以在<a class="ae nr" href="https://github.com/gianpispi/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div></div>    
</body>
</html>