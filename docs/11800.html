<html>
<head>
<title>How to Build Countable Classes in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python构建可数类</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-countable-classes-in-python-c3aa5b887c90?source=collection_archive---------10-----------------------#2022-04-18">https://betterprogramming.pub/how-to-build-countable-classes-in-python-c3aa5b887c90?source=collection_archive---------10-----------------------#2022-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f86b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">或者如何让“可散列”的对象在字典中充当键</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6cf8d0f1e23e5d9a29261e16c418d0bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TdECFbTNs7Ly4qyIMzMwdg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Andrea Lightfoot 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="aeab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑这样一种情况，给你一些类型为<code class="fe lv lw lx ly b">Point(x,y)</code>的对象，你想检查其中是否有重复的对象，或者更好的是，获得每个不同点的计数。例如:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8a2c" class="md me it ly b gy mf mg l mh mi">Point(1,2), Point(2,3), Point(1,2) -&gt; {Point(1,2): 2, Point(2,3): 1}</span></pre><p id="01b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过使用一个<code class="fe lv lw lx ly b">dict</code>(代码多一点)、一个<code class="fe lv lw lx ly b">collections.defaultdict </code>(代码少一点)或者一个<code class="fe lv lw lx ly b">collections.Counter</code>(一行程序)来完成。但是无论你选择哪一个，你都会遇到一个问题，Python把具有相同坐标的点当作不同的对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="ad9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使你覆盖了<code class="fe lv lw lx ly b">==</code>操作符(参见'<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-comparable-classes-in-python-a897f9bccf25?sk=e740f80d7836dbc1a43c007245ad79fb">如何构建可比较的类【T18)，<code class="fe lv lw lx ly b">Counter</code>(以及<code class="fe lv lw lx ly b">defaultdict</code>和<code class="fe lv lw lx ly b">dict</code>)也不会将其用于其内部机制。然而，这一次，他们会给出一个提示，告诉我们哪里出了问题:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="5d05" class="ms me it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">哈希能力解释</h1><p id="7fef" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">为了在类似dict的结构(如<code class="fe lv lw lx ly b">dict</code>、<code class="fe lv lw lx ly b">set</code>、<code class="fe lv lw lx ly b">defaultdict</code>、<code class="fe lv lw lx ly b">Counter</code>等)中作为键使用，一个对象具有可比性是不够的。</p><p id="d2fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在内部，这些结构根据应用于对象的散列函数的结果将存储的对象分布在“桶”中。只有当散列发生冲突时，Python才会退回到基于直接比较的线性搜索。默认情况下(就像比较一样)，Python不关心值，甚至不关心字段的存在。用户定义的类被散列的是它在内存中的位置。</p><p id="f028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让Python更好地理解在计算散列时应该考虑什么，您需要定义<code class="fe lv lw lx ly b">__hash__</code>方法。不需要微调实际的散列函数；您可以重用现有结构(如元组)的哈希算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对！__hash__和__eq__都存在</p></figure><p id="0a96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们在这里覆盖了<code class="fe lv lw lx ly b">__hash__</code>和<code class="fe lv lw lx ly b">__eq__</code>方法。如果你只覆盖了<code class="fe lv lw lx ly b">__hash__</code>方法而没有覆盖<code class="fe lv lw lx ly b">__eq__</code>，事情就会被打破。dict中的查找过程(以及存储或编辑)包括两个阶段。</p><p id="3487" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python首先通过散列进行搜索，然后它确保不仅散列是一致的，对象本身也是一致的。除非您也定义了<code class="fe lv lw lx ly b">__eq__</code>方法，否则在第二阶段，它将退回到使用内存位置作为比较的标准:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不对！__eq__丢失</p></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="b879" class="ms me it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">不变性解释</h1><p id="b417" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">如果你需要做的只是数一数这些物体，然后忘记它们，那就足够了。但是如果它发生在动态中(对象可以被创建、删除或修改)，值得注意的是<code class="fe lv lw lx ly b">dict</code>并不跟踪对象中的修改。</p><p id="17d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果某个点的坐标被更改，它不会自动将其移动到另一个存储桶，因此查找将会失败:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="9b48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理修改的正确方法是删除旧值，然后插入修改后的值。为了实施这一策略并保护自己免受这种难以调试的错误，建议将类设为不可变的。</p><p id="5941" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="no">顺便说一句，这是Python中字符串不可变的原因之一:这样它们就可以安全地用作字典中的键，而不用担心桶。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="d337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用父类的<code class="fe lv lw lx ly b">__setattr__</code>并不是实现不变性的唯一方法。另一个技巧是通过一个专用字段将属性锁定在构造函数的末尾(见下文)。还有一种方法是使用标准库中的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.python.org/3/library/dataclasses.html" rel="noopener ugc nofollow" target="_blank">dataclasses</a></code>模块，该模块应该一次性替换所有的“神奇”方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/4dbfcb0aaf0f5250ce81e6e6af5e5100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0TiruD9vwP_6ZkZq312WLQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使类不可变的三种方法</p></figure><p id="7d01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<code class="fe lv lw lx ly b">@dataclass</code>装饰器的好消息是，它将为像<code class="fe lv lw lx ly b">__repr__</code>、<code class="fe lv lw lx ly b">__eq__</code>、<code class="fe lv lw lx ly b">__lt__</code>等一系列方法提供合理的默认设置。免费的。坏消息是，这个缺省值仅在最简单的用例中是合理的，在现实生活中，无论何时您想要任何有价值的东西，您仍然必须覆盖' dunder' (=double underline)方法。因此，它没有从“dunder”方法中解放出来，而是引入了具有非显而易见语义的新方法:如果您认为<code class="fe lv lw lx ly b">__init__</code>和<code class="fe lv lw lx ly b">__new__</code>已经很难看了，您会对<code class="fe lv lw lx ly b">__post_init__</code>怎么看？</p><p id="ab8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，就像比较一样，你可以使用一个已经可数的类作为起点。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="2b89" class="ms me it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">基于现有的可数类构建</h1><p id="27b9" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated"><code class="fe lv lw lx ly b">namedtuple</code>生成的类不仅是可比的，而且是可数的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="1327" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<code class="fe lv lw lx ly b">list</code>继承在这里没有用，因为列表是不可修改的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="708d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的办法是从元组继承:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="d274" class="ms me it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="3b59" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">如果你希望你的类是可数的，或者在类似字典的结构中作为关键字使用，你需要三样东西:</p><ol class=""><li id="e67f" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">覆盖<code class="fe lv lw lx ly b">__hash__</code>方法</li><li id="0cae" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">相应地覆盖<code class="fe lv lw lx ly b">__eq__</code>方法</li><li id="e77d" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">使类不可变</li></ol><p id="aede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这对您来说听起来太低级了，有几个方便的函数可以在最简单的情况下自动完成:</p><ul class=""><li id="a123" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu oe nw nx ny bi translated"><code class="fe lv lw lx ly b">collections.namedtuple</code>函数用命名字段构建一个元组；</li><li id="6b5d" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu oe nw nx ny bi translated">继承<code class="fe lv lw lx ly b">tuple</code>进一步定制；</li><li id="6653" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu oe nw nx ny bi translated">decorator构建了一个预定义了所有必要方法的类。</li></ul><p id="ea7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些方法中的任何一个都足以满足你的类的“哈希能力”,因此，例如，你可以使用熟悉的习语<code class="fe lv lw lx ly b">len(set(items))</code>来计算列表中不同对象的数量。</p></div></div>    
</body>
</html>