<html>
<head>
<title>The Big Car Showroom and the Strategy Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大型汽车展厅与战略设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-big-car-showroom-and-the-strategy-design-pattern-210dbb274dbf?source=collection_archive---------13-----------------------#2022-06-10">https://betterprogramming.pub/the-big-car-showroom-and-the-strategy-design-pattern-210dbb274dbf?source=collection_archive---------13-----------------------#2022-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e737" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">假设我们在一家超市获得了软件开发实习生的职位。我们的任务是为市场开发一个列出所有在售汽车的应用程序。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6d0510c0598a24303e7e46ee4571fda6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bFOZnR-7FdWadpRM"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">出售从针头到汽车等日常用品的大型超市。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kv"><img src="../Images/f6c9b17aa121032a332cdd42c7308e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F1zdw7bsz3u8DbSkkkUGbw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基本方法</p></figure><p id="f2d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们从基础开始，让所有的汽车类型都继承自类<code class="fe ls lt lu lv b">Car</code>。<code class="fe ls lt lu lv b">listManufacturer</code>方法列出了汽车制造商的详细信息和品牌，在我们的例子中，它因子类而异，这就是为什么它是抽象的，而类<code class="fe ls lt lu lv b">Car</code>是一个抽象类。方法run和<code class="fe ls lt lu lv b">carryPassengers</code>是普通的泛型方法，如下所示。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="d409" class="ma mb iq lv b gy mc md l me mf">void run() {<br/>    System.out.println("Run from point A to point B");<br/>}</span><span id="58e3" class="ma mb iq lv b gy mg md l me mf">void carryPassengers() {<br/>    System.out.println("Carry passengers and their luggages");<br/>}</span></pre><p id="c69b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一切看起来都很完美，而“遗产”似乎像拼图中最完美的一块一样解决了我们所有的问题。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="6b00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但仿真车或玩具车不具备<code class="fe ls lt lu lv b">carryPassengers</code>特征，也不应该继承<code class="fe ls lt lu lv b">carryPassengers</code>方法。在这种情况下，实现以下面向对象的设计原则。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="ceaa" class="ma mb iq lv b gy mc md l me mf">Identify aspects of your applications that vary (carryPassengers) and separate them from what remains same. </span></pre><p id="6f68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就继承而言，子类的抽象方法<code class="fe ls lt lu lv b">listManufacturer</code>和run保持不变。而<code class="fe ls lt lu lv b">carryPassengers</code>方法则不然。让我们封装变更，这样就不会影响代码的其余部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mo"><img src="../Images/689332f3a652886c806edb2f266900cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6-2UgrMb4nGFmuKAiE8QVQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">改进的方法</p></figure><p id="4598" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们写了一个接口Carriable，它有抽象方法<code class="fe ls lt lu lv b">carryPassengers</code>。并且只有那些车厢(类)实现了可以实际载客的接口。答对了。我们成功地分离了实现中的不同部分。让我们把重点放在代码维护上。</p><p id="fc63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，<code class="fe ls lt lu lv b">carryPassengers()</code>是在每个可承载类中单独实现的。(截至目前，为了简单起见，我们忽略其他方法。)</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="8018" class="ma mb iq lv b gy mc md l me mf">class TeslaCar extends Car implements Carriable {<br/>   void carryPassengers() {<br/>       System.out.println("Carry passengers and their luggages");<br/>   }<br/>}</span><span id="0fc4" class="ma mb iq lv b gy mg md l me mf">class HondaCar extends Car implements Carriable {<br/>   void carryPassengers() {<br/>       System.out.println("Carry passengers and their luggages");<br/>   }<br/>}</span></pre><p id="1dea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在想象一下，我们需要改变方法<code class="fe ls lt lu lv b">carryPassengers</code>的行为，而<code class="fe ls lt lu lv b">carryPassengers</code>由100行代码组成，有100个类型为<code class="fe ls lt lu lv b">Carriable</code>的类。</p><p id="1e57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要改变方法<code class="fe ls lt lu lv b">carryPassengers</code>的行为，我们需要分别单独接触100个Carriable类型的类。这没有任何作用，但是会在代码中引入错误，使代码维护变得困难。触及Carriable类型的每个子类会导致代码设计不灵活。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/8d17bec614f5f1ce1c33ca11b9cda17d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gn7YAHsTyvSFYhngQDJaNQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最后进场</p></figure><p id="9836" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">Carry</code>和<code class="fe ls lt lu lv b">CarryNot</code>类中已经给出了<code class="fe ls lt lu lv b">Carriable</code>接口的<code class="fe ls lt lu lv b">carryPassengers</code>的具体实现</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="0d83" class="ma mb iq lv b gy mc md l me mf">class Carry implements Carriable {<br/>    public void carryPassengers() {<br/>        System.out.println("Carry passengers and their luggages");<br/>    }<br/>}</span><span id="16af" class="ma mb iq lv b gy mg md l me mf">Class CarryNot implements Carriable {<br/>   public void carryPassengers() {<br/>       System.out.println("Cannot carry passengers and their     luggages");<br/>    }<br/>}</span></pre><p id="b56b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，抽象类<code class="fe ls lt lu lv b">Car</code>具有实例变量Carry，可以查看具体类<code class="fe ls lt lu lv b">Carry</code>或<code class="fe ls lt lu lv b">CarryNot</code>，从而查看封装在Carry和<code class="fe ls lt lu lv b">CarryNot</code>类中的方法<code class="fe ls lt lu lv b">carryPassengers</code>的不同实现。</p><p id="966a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类<code class="fe ls lt lu lv b">Car</code>的每个子类将通过carriable类型的继承实例变量Carriable查看Carry或CarryNot。</p><p id="6ec1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">抽象类Car有方法<code class="fe ls lt lu lv b">setCarriable(Carriable carriable)</code>来决定查看哪种类型的<code class="fe ls lt lu lv b">Carriable</code>，是查看类<code class="fe ls lt lu lv b">Carry</code>还是<code class="fe ls lt lu lv b">CarryNot</code>。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="2f9a" class="ma mb iq lv b gy mc md l me mf">void setCarriable(Carriable carriable) {<br/>    this.carriable = carriable;<br/>}</span></pre><p id="3259" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类<code class="fe ls lt lu lv b">Car</code>的每个子类也将从父抽象类<code class="fe ls lt lu lv b">Car</code>继承<code class="fe ls lt lu lv b">carryPassengers()</code>方法。方法<code class="fe ls lt lu lv b">carryPassengers</code>除了已经设置为carriable的<code class="fe ls lt lu lv b">calls carryPassengers()</code>方法之外什么也不做。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="219b" class="ma mb iq lv b gy mc md l me mf">void carryPassengers() {<br/>    carriable.carryPassengers();<br/>}</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="96d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们需要改变<code class="fe ls lt lu lv b">carry</code>方法的行为，我们只需要接触一个子类<code class="fe ls lt lu lv b">Carry</code>。这种方法比以前的方法灵活得多。</p><p id="9dd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">策略设计模式定义了一系列的算法(在我们的例子中，<code class="fe ls lt lu lv b">carryPassengers</code>的可变代码)封装了每一个算法(在我们的例子中，是类<code class="fe ls lt lu lv b">Carry</code>和<code class="fe ls lt lu lv b">CarryNot</code>)并使它们可以互换(在我们的例子中，Carriable carriable变量可以指向类<code class="fe ls lt lu lv b">Carry</code>和<code class="fe ls lt lu lv b">CarryNot</code>)。它让算法独立于使用它的客户端而变化。(在我们的例子中，我们可以修改<code class="fe ls lt lu lv b">carryPassengers</code>的行为，而不触及<code class="fe ls lt lu lv b">Car</code>类的子类)。</p></div></div>    
</body>
</html>