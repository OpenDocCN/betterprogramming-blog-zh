<html>
<head>
<title>React Declarative-imperative Bridge Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应声明-命令桥模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-declarative-imperative-bridge-pattern-483d8ab63559?source=collection_archive---------9-----------------------#2022-12-05">https://betterprogramming.pub/react-declarative-imperative-bridge-pattern-483d8ab63559?source=collection_archive---------9-----------------------#2022-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="000a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在React应用程序中执行命令式代码的更简单方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/af010681fff0ce34d9dade8bcaa104fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bQhK8TM6X9obeGxF"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@aleksandr_barsukov?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚历山大·巴尔苏科夫</a>在<a class="ae kv" href="https://unsplash.com/s/photos/bridge?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e010" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不管我们在编写React应用程序方面有多好，我们都不能完全避免针对命令式接口进行编码。这是因为UI从根本上来说是必不可少的，浏览器中的API也是如此。</p><p id="a425" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">控制媒体元素是一种常见的情况，但我们也可能处理符合浏览器惯例的第三方库。React的声明式模型与命令式API不太匹配，我们需要在“是什么”和“如何”之间架起一座桥梁。在本文中，我们将讨论这样一种模式。</p><p id="8947" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关注我的人都知道我是普通JavaScript的坚定信徒。我从香草冒险中得到的一个重要教训是，每个解决方案都有一个应该实现的自然位置，偏离这个位置会产生样板文件和复杂性。如果你曾经觉得与基于状态的UI更新相比，使用<code class="fe ls lt lu lv b">useEffect</code>和<code class="fe ls lt lu lv b">useRef</code>以及手动跟踪钩子依赖关系有点不合适，那是因为它确实如此。它不适合那个模型(双关语)，也不属于反应式UI。</p><p id="719f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">声明性-命令性桥模式旨在解决这个问题，并将声明性和命令性世界之间的桥放到一个更自然的地方。我说的自然地点是指一个已经存在一个定义明确的机制来做我们所需要的事情的地方。在声明性-命令性桥接的情况下，自然发生的地方是<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements" rel="noopener ugc nofollow" target="_blank">定制元素</a>中的属性观察机制。</p><p id="fde8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个相对较新的模式，我们只有在2020年左右才能在我们的目标浏览器中实际使用，当时在微软最终放弃其旧的Edge浏览器并切换到基于Chromium的浏览器后，自定义元素规范<a class="ae kv" href="https://caniuse.com/?search=custom%20element" rel="noopener ugc nofollow" target="_blank">在所有浏览器中得到支持</a>。Safari仍然不支持所有的规范(谢谢苹果！)，但这与我们在这里要做的事情没有关系。</p><h1 id="b5d7" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">反应一方</h1><p id="9e68" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated"><em class="lw">(为完整起见，在此插入使用参考和效果的良好ol’示例。)</em></p><p id="fd66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将假设您熟悉使用引用和效果的常用方法。我不会用这种模式的例子来烦你。让我们直入主题吧。</p><p id="c072" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">反应部分与任何状态驱动的反应组件基本相同。</p><p id="8d8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><pre class="kg kh ki kj gt mu lv mv bn mw mx bi"><span id="6007" class="my ly iq lv b be mz na l nb nc">let <br/>  STOPPED = 0, <br/>  PLAYING = 1<br/><br/>let Player = () =&gt; {<br/>  let <br/>    [playbackState, setPlaybackSate] = useState(STOPPED),<br/>    onPlay = () =&gt; setPlaybackState(PLAYING),<br/>    onStop = () =&gt; setPlaybackState(STOPPED)<br/><br/>  return (<br/>    &lt;article&gt;<br/>      &lt;react-audio playback-state={playbackState}&gt;<br/>        &lt;audio src="foo.mp3"&gt;&lt;/audio&gt;<br/>      &lt;/react-audio&gt;<br/>      &lt;button onClick={onPlay} <br/>              aria-pressed={playbackState === PLAYING}&gt;<br/>        Play<br/>      &lt;/button&gt;<br/>      &lt;button onClick={onStop}&gt;<br/>        Stop<br/>      &lt;/button&gt;<br/>    &lt;/article&gt;<br/>  )<br/>}</span></pre><p id="33bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望我不需要解释上面的代码是做什么的，因为这是DIB模式的要点——简单。</p><p id="22d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我要指出一个小细节。<code class="fe ls lt lu lv b">&lt;audio&gt;</code>元素是<code class="fe ls lt lu lv b">&lt;react-audio&gt;</code>定制元素的子元素。这一点非常重要，因为React可以完全控制定制元素的子树。在示例代码中，React指定了源代码，事实上，它创建了<code class="fe ls lt lu lv b">&lt;audio&gt;</code>元素。如果我们想在回放时得到当前时间的通知，我们可以将一个<code class="fe ls lt lu lv b">onTimeUpdate</code>事件处理程序直接附加到<code class="fe ls lt lu lv b">&lt;audio&gt;</code>元素，而不是自定义元素。</p><h1 id="53e5" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">这座桥</h1><p id="04a6" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">让我们看一下实际的声明性命令性桥接发生的自定义元素。我们称这个元素为“桥”元素。</p><pre class="kg kh ki kj gt mu lv mv bn mw mx bi"><span id="8a6e" class="my ly iq lv b be mz na l nb nc">customElements.define('react-audio', class extends HTMLElement {<br/>  static get observedAttributes() { return ['playback-state'] }<br/><br/>  attributeChangedCallback() {<br/>    if (this.getAttribute('playback-state') == STOPPED) {<br/>      this.firstElementChild.pause()<br/>      this.firstElementChild.currentTime = 0<br/>    } else {<br/>      this.firstElementChild.play()<br/>    }<br/>  }<br/>})</span></pre><p id="4228" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自定义元素将<code class="fe ls lt lu lv b">playback-state</code>属性声明为observed。这将导致每次属性改变时调用<code class="fe ls lt lu lv b">attributeChangedCallback()</code>实例方法。</p><p id="738e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">attributeChangedCallbak()</code>中，我们将回放状态的声明性概念转化为在<code class="fe ls lt lu lv b">&lt;audio&gt;</code>元素上执行的命令性动作，这是定制元素的第一个(也是唯一的)子元素。</p><p id="7885" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，随着我们需求的增长，这可能会变得更加复杂。我们可能有多个观察到的属性，我们可能发出事件，等等。说到事件，请注意，由于它的<a class="ae kv" href="https://reactjs.org/docs/events.html" rel="noopener ugc nofollow" target="_blank">合成事件</a>实现，React仅限于少数标准事件。我们不能利用自定义事件。</p><p id="d52b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">&lt;react-audio&gt;</code>元素不需要创建任何子节点，因为这不是它的目的。因为我们正在使用定制元素，所以我们仍然有呈现整个子树的<em class="lw">选项</em>，甚至为此使用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" rel="noopener ugc nofollow" target="_blank">阴影DOM </a>。通过这样做，我们放弃了对React方面的子节点的一些控制，但是为其他一些事情打开了大门(例如，使用不同框架的应用程序之间的代码重用，或者甚至没有框架)。关键是，是在React中还是在custom元素中呈现子树与DIB模式无关，模式也不会强制您这样或那样做。</p><h1 id="6b6e" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">但是，但是…自定义元素没有反应！</h1><p id="8892" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">当然不是。这才是重点！</p><p id="2b7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种模式的全部要点是将命令性的——因此也是非特定于React的——代码移出效果挂钩，移出组件，无论如何它都不太合适。这是你无论如何都需要在某个地方写<em class="lw">的代码，但是把它包装在一个钩子中并不会比一卷卫生纸更“被动”和“状态驱动”。我认为它是嵌入在React组件中的“外来”代码，就像一头游荡到某人后院的野生动物。它正被营救并转移到它的自然栖息地。</em></p><h1 id="0335" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">摘要</h1><p id="d4fd" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">概括地说，DIB模式的工作方式如下:</p><ul class=""><li id="8ad0" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">React做了React做得最好的事情——状态驱动的UI更改——我们只是避免在组件中做任何命令性的代码(效果)</li><li id="6d0f" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">自定义元素的观察属性特性弥补了声明性API和命令性API之间的差距</li><li id="d8e4" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">所有命令式代码都存在于自定义元素中</li><li id="d7ba" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">定制元素可能使用也可能不使用React创建的子树，它与模式无关</li></ul><p id="5ad8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在我的GitHub库<a class="ae kv" href="https://github.com/foxbunny/react-dib-pattern" rel="noopener ugc nofollow" target="_blank">中找到更完整的DIB实现的完整源代码。</a></p></div></div>    
</body>
</html>