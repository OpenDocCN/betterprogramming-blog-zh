# ES2022:关于私有类字段、方法和静态初始化块的完整指南

> 原文：<https://betterprogramming.pub/es2022-a-complete-guide-on-private-static-class-fields-methods-and-static-initialization-blocks-f12943a86b2d>

## 新 ECMAScript 语法介绍

![](img/2787463a3561f6e251b0f6f7a3600f30.png)

照片由[真诚媒体](https://unsplash.com/@sincerelymedia?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

技术委员会 39 ( [TC39](https://tc39.es/process-document/) )是一个致力于 ECMAScript 标准化的 JavaScript 专家小组。完成的提案是已经达到阶段 4 的提案，并且包括在规范的[最新草案](https://tc39.es/ecma262/)中。

让我们来看看 ES2022 对 JavaScript 类的更改，其中包括以下新语法:

*   私有类字段和方法
*   静态公共字段(静态公共方法在 ES2015 中)
*   静态私有字段和方法
*   静态初始化块
*   针对私人领域的人体工程学品牌检查

# 班级

[类](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)是创建对象的模板。它们封装数据以及处理这些数据的方法。ES2015 中正式引入了 JavaScript 类。它们建立在原型的基础上，但是也有一些语法和语义与 ES5 类语义不同。

类可以通过类声明或类表达式来定义。

*   类声明使用关键字`class`和类名定义了一个类。

*   类表达式用表达式定义类，表达式可以是命名的或未命名的类。

下面是一个未命名的类示例，变量名变成了类名(第 5 行):

下面是一个命名类的例子。类名覆盖变量名成为类名(第 5 行)。然而，类名不能用来实例化一个实例(第 14 行)。

类成员位于花括号`{}`内。类成员包括字段和方法。在没有任何`static`修饰符的情况下，它们与对象/实例相关联，被称为实例字段和实例方法。它们在一个类中被`this`引用。“Class”构造函数是实例化对象的特殊方法。默认情况下，所有字段和方法都是公共的。

下面是一个类定义:

第 2 行声明了一个字段`_count`，并将其初始化为 0。

第 5 行将参数值分配给字段`_name`。

我们使用下划线(`_`)来区分带有 get/set 方法的字段名称。ES2015 中引入了 Getters 和 setters。如果我们对一个字段和 get/set 方法使用相同的名称，getter/setter 将递归调用自己，并抛出一个`RangeError: Maximum call stack size exceeded`。

在下面的代码中，`girl`是从类`Person`创建的实例:

第 1 行创建了实例`girl`。

第 2 行直接访问实例字段，并打印出值`Alice`。

第 3 行调用 get 方法，打印出转换后的值`ALICE`。

第 4 行打印出实例细节。

我们可以使用下面的代码使用`in`操作符来检查字段或方法是否存在:

在下面的代码中，实例`girl`可以调用`greet`方法来打印消息并增加计数，如下所示:

# 私有字段和方法

默认情况下，所有字段和方法都是公共的。ES2022 添加了确保封装的私有作用域。私有范围内的字段和方法不能从类外部访问——除非有一些显式的方法来公开它们。

在声明字段和访问字段时，私有字段都用一个散列(`#`)前缀定义。私有字段只能作为字段声明提前声明。如果没有初始化器，字段被设置为`undefined`。类似地，方法可以通过在名字前加前缀`#`来私有化。

对于前面的例子，我们将`_count`和`_name`重命名为`#_count`和`#_name`，使它们成为私有的。同样，`#increaseCount`成为私有方法。我们必须为私有字段添加一个声明，这对于公共字段不是必须的(第 5 行)。

在下面的代码中，实例`girl`只能访问公共 getter(第 4 行)，而不能访问私有字段`#_name`(第 3 行)。

在下面的代码中，`in`操作符将为私有字段和方法返回 false，如下所示:

在下面的代码中，`girl`实例可以调用公共`greet`方法并访问公共 getter，但是不能访问`#_count`(第 5 行)和`#increaseCount`(第 8 行)。

# 私有字段和方法没有继承

JavaScript 没有受保护的范围。私有字段和方法只能从类声明内部访问。它们对子类不可见。

在下面的例子中，`Girl`是`Person`的子类。一个类定义不能访问它的超类的私有方法(第 9 行)。

同样的规则也适用于子类实例。实例`girl`可以访问其超类的公共字段和方法，但不能访问私有字段和方法(第 19 和 22 行)。

# 静态公共字段和方法

在 ES2015 中，引入了静态公共方法。ES2022 增加了剩余的静态字段和方法:

*   静态公共字段
*   静态私有字段
*   静态私有方法

静态字段和方法不用于类的实例。相反，它们是在类本身上调用的。

静态字段通常用于缓存、固定配置或任何其他不需要跨实例复制的数据。静态方法通常是特殊功能的实用函数。

下面的类`Circle`混合了静态和实例字段/方法:

静态字段和方法可以从类本身访问:

实例不能访问静态字段和方法，您将在下面看到:

静态字段只被静态方法调用，比如`pi`和`doublePi`。

如果我们把`message`改成`static`字段呢？`circle.getMessage()`的值会是多少？

会是`undefined`。

这可以通过用类名而不是`this`引用它来解决。

我们从`Circle`创建一个子类。

所有静态字段和方法都继承自超类，如下所示:

实例行为几乎一样，除了`circle`的原型是`Circle`(第 13 行)，构造器是`CircleExtended`(第 14 行)。

# 静态私有字段和方法

ES2022 增加了实例字段和方法以及静态字段和方法的私有范围。私有静态字段和方法也用一个 hash ( `#`)前缀定义。

对于前面的例子，我们通过将`pi`和`doublePi`重命名为`#pi`和`#doublePi`来使它们成为私有的:

调用类的静态方法和实例方法，它似乎工作得很好，如下所示:

我们从`Circle`创建一个子类。

然后，我们不能调用`CircleExtended.area`(第 2 行)和`CircleExtended.perimeter`(第 4 行)，尽管这两个方法在超类中有公共作用域。

我们知道只有定义私有静态字段的类才能访问该字段。在`CircleExtended.area`和`CircleExtended.perimeter`中，`this`是指不能访问私有成员`#pi`和`#doublePi`的子类。为了让它们工作，我们需要修改超类，用类名而不是`this`来引用静态私有字段。

# 静态初始化块

静态初始化块支持比静态字段初始化更灵活的`static`属性初始化。每个类可以有多个静态初始化块。它们和任何交错的静态字段初始值设定项一起按照声明的顺序进行计算。超类的任何静态初始化都是在子类之前首先执行的。

执行代码后，我们看到这些消息按顺序打印出来:

静态块允许我们处理不同的类初始化用例。在下面的例子中，类 D 的静态块可以使用`this`引用访问它自己的静态字段(第 15 行)，使用`super`引用访问它的超类字段(第 14 行)。它还可以包括 try/catch 块(第 16–20 行)。

在下面的示例中，它演示了如何从类外部访问私有字段。`peekMySecret`是一个随机变量，通过一个静态块被授权访问一个静态私有字段。代码如下:

# 针对私人领域的人体工程学品牌检查

我们已经展示了如何使用`in`操作符来检查实例中是否有特定的公共字段或方法。在 ES2022 中，检查已经扩展到私有字段和方法，这被称为私有字段的人体工程学品牌检查。

这是一个[官方示例](https://github.com/tc39/proposal-private-fields-in-in):

我们应该能够调用`C.isC`来检查`c`是否是一个实例。但是，浏览器还不支持该功能。

# 结论

编程语言随着时间的推移而发展，要跟上它们是一个挑战。与此同时，看到它们变得更简洁、更强大也很有趣。

在本文中，我们回顾了 ES2022 对 JavaScript 类在私有/静态类字段/方法、静态初始化块和私有字段的人体工程学品牌检查方面的更改。

感谢阅读。我希望这有所帮助。如果你有兴趣，可以看看[我的其他媒体文章](https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af)。