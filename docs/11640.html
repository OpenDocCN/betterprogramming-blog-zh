<html>
<head>
<title>A Distributed System Interview Question: How to Avoid Read Inconsistency During a Transaction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式系统面试问题:如何避免事务期间的读取不一致</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-distributed-system-interview-question-how-to-avoid-read-inconsistency-during-a-transaction-6ac3b4a8f92a?source=collection_archive---------5-----------------------#2022-04-05">https://betterprogramming.pub/a-distributed-system-interview-question-how-to-avoid-read-inconsistency-during-a-transaction-6ac3b4a8f92a?source=collection_archive---------5-----------------------#2022-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3f78" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在分布式环境中创建快照隔离</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/931bce37ad3f3d5444082bd35cd22042.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*q8d4q9AU7IPHEt6-Z_qydw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">由作者提供</p></figure><p id="4f47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想象一下，当你试图从账户A转100美元到账户B，而两个账户都在同一家银行。启动传输后，刷新屏幕。然而，当你刷新你的屏幕时，你的总余额下降了——那100美元似乎凭空消失了。你看账户A少了100美元。然而，账户B并没有多100美元。然后，你刷新屏幕几次，看到账户B赚了100美元。</p><p id="0f14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您在事务处理过程中遇到的这个问题称为读取偏差。当您在不恰当的时间读取事务时——在写入事务期间和之后——就会发生异常。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/f01a79c82f63883e04254b75b983723d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*orXviq1GzmmqRGzK.png"/></div></figure><p id="eb32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这可能是一个糟糕的用户体验，但如果您在成功的转账交易后刷新页面，这不会导致任何问题。</p><p id="6db9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，在执行数据库备份或分析查询时，读取偏斜会成为一个问题。</p><p id="36a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在数据库备份中，我们需要制作数据库的副本。在备份过程中，可能会收到书面请求。如果发生读取不对称不一致，备份结果可能会不一致。有些数据是旧版本的，有些数据是新版本的。这种不一致的问题可能会随着这种操作而永久存在。</p><p id="bf2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要在分析查询中扫描大型数据库，并定期检查数据损坏。读取偏差会导致搜索和检查不一致，通常可能会产生不一致的结果，并引发有关数据损坏的错误警报。</p><h1 id="cd5b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">解决读取偏差</h1><p id="afba" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">读取偏斜的问题是，一个读取事务在旧数据库版本中读取一次，而在新数据库版本中读取另一次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/92b21a371d70a4ba01f29c0eb7270b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/0*dv7_UxEmrdKZ3_R5.png"/></div></figure><p id="92cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里重要的一点是，读事务需要一致—它不需要是最新的版本。从事务开始到结束都需要保持一致，所以我们需要保持数据版本不变。</p><p id="66ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，如果Bob以数据版本1运行read事务，那么在整个事务中，Bob应该只能读取数据库数据版本1。如果在事务处理过程中，发生了新的写事务，这将更新数据库中的数据。Bob在他交易中将看不到新版本。</p><p id="fb2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们可以让事务从数据库的一致快照中读取—事务将从所有数据中看到其他事务在事务开始时提交到数据库中。</p><p id="a63b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个特性被称为快照隔离，它在很多关系数据库中都有提供，比如PostgreSQL和MySQL。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/9d73351425a8f609b443bdc8ce3ef584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/0*17T2B34FcdmZTWC2.png"/></div></figure><h1 id="f36e" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">实现快照隔离</h1><p id="cc15" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们需要在数据库中保存各种快照版本，以实现快照隔离。每次事务开始时，数据库会给事务提交最新的快照版本。然后，数据库将跟踪每个事务及其对应的快照版本，以保持读取的一致性。</p><p id="d7f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个事务都有一个<code class="fe mp mq mr ms b">transactionId</code>，从数据库中检索<code class="fe mp mq mr ms b">transactionId</code>。因此，<code class="fe mp mq mr ms b">transactionId</code>总是在增加。数据库使用<code class="fe mp mq mr ms b">createdAt</code>和<code class="fe mp mq mr ms b">deletedAt</code>值跟踪写入数据库的每个<code class="fe mp mq mr ms b">transactionId</code>。提交事务后，数据库用事务中的<code class="fe mp mq mr ms b">transactionId</code>为该操作创建了一个标记。数据库进一步制作新事务的快照，并用最新的transactionId标记该快照。当新事务从数据库中读取数据时，数据库会根据以下几条规则检索该事务之前最新提交的事务:</p><ol class=""><li id="cde7" class="mt mu it kw b kx ky la lb ld mv lh mw ll mx lp my mz na nb bi translated">即使提交了后续事务，也不会显示当前尚未提交到数据库的任何transactionId。</li><li id="c4de" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated">任何中止的交易也不会显示。</li><li id="6c9d" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated">数据库不会显示任何晚于(大于)当前<code class="fe mp mq mr ms b">transactionId</code>的<code class="fe mp mq mr ms b">transactionId</code>交易。</li><li id="6be4" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated">数据库将向读取数据库的其他传入事务显示任何其他事务。</li></ol><p id="fbc2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看在Bob的场景中会发生什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/7afa5edfdb24bdf1505666170f5927bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/0*Ou7RnqcI7C2pC3FZ.png"/></div></figure><ol class=""><li id="e6fc" class="mt mu it kw b kx ky la lb ld mv lh mw ll mx lp my mz na nb bi translated">当Bob发起其转账交易时，它启动一个后台进程，从账户A向账户b转账100美元，该交易将首先调用数据库或aid服务来获取增量<code class="fe mp mq mr ms b">transactionId</code>，并发起交易——假设交易是1234。</li><li id="5f63" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated">后续的读事务将需要通过获得增量<code class="fe mp mq mr ms b">transactionId</code>并调用对数据库的读请求来做同样的事情——假设<code class="fe mp mq mr ms b">transactionId</code>是1345。</li><li id="ff0a" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated">当传输尚未完成时，数据库不会向Bob显示由<code class="fe mp mq mr ms b">transactionId</code> 1234(规则编号1)应用的数据。</li><li id="a804" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated">如果在<code class="fe mp mq mr ms b">transactionId</code> 1345之后启动了另一个写入事务，因为该事务具有更大的<code class="fe mp mq mr ms b">transactionId</code>，所以数据库不会将该事务显示给<code class="fe mp mq mr ms b">transactionId</code> 1345(规则编号3)。</li></ol><p id="ab14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在删除过程中，数据库不会立即删除字段中的值，而是会在该字段上标记一个<a class="ae ni" href="https://en.wikipedia.org/wiki/Tombstone_(data_store)#:~:text=A%20tombstone%20is%20a%20deleted,is%20considered%20to%20be%20successful." rel="noopener ugc nofollow" target="_blank">墓碑</a>。不立即删除该值的一个原因是，那些较早的事务可能仍然使用该值。因此，一旦所有事务都使用了提交给它们的事务的值，我们就可以利用垃圾收集来异步检查和删除该值。</p><h1 id="6a79" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">将快照隔离引入分布式环境</h1><p id="9d44" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">到目前为止，我们已经探索了如何解决单节点环境中的读取偏斜—我们假设数据库没有分布在多个集群中。</p><p id="79fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如何在分布式环境中扩展快照隔离？</p><p id="281e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在分布式环境中，很难获得一个全球性的、不断增长的<code class="fe mp mq mr ms b">transactionId</code>。出于一个原因，可能驻留在不同数据库中的每台机器可能都有自己的UUID计数器，我们需要进行一些协调来确保因果关系。如果事务B从事务A中读取值，我们希望确保事务B的<code class="fe mp mq mr ms b">transactionId</code>比事务A的大。我们如何处理复制数据库中的一致快照？</p><p id="8f58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用时钟或一天中的时间作为一个<code class="fe mp mq mr ms b">transactionId</code>来写入数据库吗？时间时钟是不可靠的，因为NTP同步是基于不可靠的网络。因此，一些机器可能会出现时钟偏移，任意向后移动时间。一个节点的时间也可能不同于另一个节点的时间。但是，如果我们可以让时钟足够精确，它可以充当一个<code class="fe mp mq mr ms b">transactionId</code>——时钟上的时间晚了意味着事件产生的时间晚了。我们如何确保时钟对于transactionId足够准确？</p><p id="f4e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当检索每台机器中的时间值时，我们希望它返回一个置信区间，<code class="fe mp mq mr ms b">[Tbegin, Tlast]</code>而不是得到一个值。置信区间表示时钟具有正负范围<code class="fe mp mq mr ms b">Begin</code>和<code class="fe mp mq mr ms b">Tlast</code>的标准偏差。如果有两笔交易，<code class="fe mp mq mr ms b">transactionX</code>，<code class="fe mp mq mr ms b">transactionY</code>进来，<code class="fe mp mq mr ms b">[TbeginX, TlastX]</code>，<code class="fe mp mq mr ms b">[TbeginY, TlastY]</code>，<code class="fe mp mq mr ms b">TlastX &lt; TbeginY</code>。我们可以保证<code class="fe mp mq mr ms b">transactionX</code>早于<code class="fe mp mq mr ms b">tranasctionY</code>。但是，如果值重叠，我们就无法确定顺序。这种方法被<a class="ae ni" href="https://cloud.google.com/spanner/docs/true-time-external-consistency" rel="noopener ugc nofollow" target="_blank"> Google Spanner </a>用来实现其快照隔离。Spanner将故意等待，直到它超过前一个事务的置信区间而不重叠，以提交当前事务。因此，他们需要保持机器上每个时钟的置信时间间隔尽可能小，以避免延迟。谷歌在每个数据中心部署了一个原子钟或GPS服务器，以实现时钟同步。</p><p id="2a81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了确保快照是每个数据库副本的最新快照，我们可以使用<a class="ae ni" href="https://en.wikipedia.org/wiki/Quorum_(distributed_computing)#:~:text=A%20quorum%20is%20the%20minimum,operation%20in%20a%20distributed%20system." rel="noopener ugc nofollow" target="_blank"> quorum </a>策略从所有数据库集群中获取所有最新的事务快照。我们可以使用的另一个策略是确保事务总是路由到同一个数据库实例，以获得一致的快照结果。</p><h1 id="dda0" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">包扎</h1><p id="7cc5" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">当您因为后台发生了另一个写事务而看不到一致的数据库数据读取结果时，就会发生读偏斜。一致快照是解决单节点数据库中读取偏差的一种方法。</p><p id="ae4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一致快照是一种隔离级别，它保证每个事务都将从数据库的一致快照中读取，通常是当前启动的事务之前的最新快照。</p><p id="e3da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实现快照隔离需要单调递增的计数器transactionId来确定将哪个版本返回给事务调用。然而，当处理分布式环境时，这可能是困难的，因为需要协调来产生因果关系。解决这个问题的一个方法是使用一个返回置信区间的时间时钟来创建一个不断增加的<code class="fe mp mq mr ms b">transactionId</code>。</p><p id="891e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，为了确保每个事务获得一致的快照，我们可以使用仲裁策略，总是从大多数节点返回的当前事务中返回最近的快照，或者在事务调用和数据库实例上具有会话关联性。</p><p id="1181" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在分布式系统中，如何确保读取的一致性？你将如何解决创建全球<code class="fe mp mq mr ms b">transactionId</code>的问题？请在下面评论它们！</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="cb44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nq">原载于【https://edward-huang.com】<a class="ae ni" href="https://edward-huang.com/distributed-system/2022/04/03/distributed-system-question-how-to-avoid-read-inconsistency-during-a-transaction/" rel="noopener ugc nofollow" target="_blank"><em class="nq"/></a><em class="nq">。</em></em></p></div></div>    
</body>
</html>