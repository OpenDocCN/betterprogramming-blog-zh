<html>
<head>
<title>CRUD With a Desktop Electron App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有桌面电子应用程序的CRUD</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/crud-with-a-desktop-electron-app-8ef0f121b047?source=collection_archive---------4-----------------------#2020-10-14">https://betterprogramming.pub/crud-with-a-desktop-electron-app-8ef0f121b047?source=collection_archive---------4-----------------------#2020-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e3f7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在我们的电子应用程序中执行操作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f51ebd1dfd74d4aacde7e5ecf2dd502e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XbM9c69xcLwyHxexcY3-qg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://upload.wikimedia.org/wikipedia/commons/thumb/9/91/Electron_Software_Framework_Logo.svg/1200px-Electron_Software_Framework_Logo.svg.png" rel="noopener ugc nofollow" target="_blank">维基媒体</a></p></figure><p id="367c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上周我写了一篇关于<a class="ae ky" href="https://medium.com/better-programming/basic-desktop-application-with-electron-4f91922fb294" rel="noopener">用Electron </a>创建基本桌面应用的文章。今天我们将讨论在我们的应用程序中执行CRUD操作。</p><p id="4ffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅供参考，CRUD是<em class="lv">创建、读取、更新和删除</em>操作的缩写。</p><p id="1218" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们没有真正的API，但我们可以使用<a class="ae ky" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"> JSONPlaceholder </a>假API。所有发送到这个API的请求都将得到一个响应，就像我们在处理一个真实的数据库一样，但是在JSONPlaceholder端不会有任何变化。</p><p id="c5f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从一个HTML文件开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/660878c51861cc979c22ce5b6c60167d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*8ZqstmHU5s5k8tk1431mEA.png"/></div></figure><p id="31f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们可以看到我们正在导入<code class="fe lx ly lz ma b">render.js</code> <strong class="lb iu"> </strong>脚本，并为一些HTML元素分配一些id。请记住这一点，因为我们接下来将使用这些id。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="3752" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">阅读</h1><p id="5319" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们的初始操作将是一个读操作。当我们的应用程序加载时，它通常会向数据库发送一个GET请求来检索数据，这样我们就可以在DOM上呈现一些东西。</p><p id="8b97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这将是文档的初始加载，我们需要告诉浏览器在加载时调用一些函数。我们打算这样做:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/91d143ec97f42a09a8afefc066ed29ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*TdmrLnHjeEB3-K0X7OMavw.png"/></div></figure><p id="17bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到，我们在加载事件中调用了函数<code class="fe lx ly lz ma b">getPosts()</code>。这个函数将执行读取操作。它将向API发送GET请求，然后在DOM上呈现接收到的数据。看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/b33515c7447bfc1a13f5cb8c64775892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*46hgBDFNbz-AxIa7X_RP-Q.png"/></div></div></figure><p id="b83f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我可以为我们超级博客中的每个帖子附加的所有后续操作播种种子(事件侦听器)。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="89ac" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">创造</h1><p id="26fb" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">现在让我们执行创建操作。它将分两个阶段发生。</p><p id="b240" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击后，我们将为新帖子创建一个输入表单:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/16dc6da11a7b419d98a832e20792fcc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OTr_X3p4GX8pmdjs9Rp6gQ.png"/></div></div></figure><p id="e6c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将向API发送一个POST请求:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/fbf5df2b01eb65d275258598801fa359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*ZUufhMWxYaoTG-LyW0nxUw.png"/></div></figure><p id="6b06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当收到来自API的请求时，我们可以重新呈现DOM。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="d28d" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">更新</h1><p id="d077" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">对于更新操作，这有点不同，因为我们必须在数据库中找到特定的记录来更新。但是我们知道我们在谈论一个RESTful API，我们可以通过唯一ID找到特定的记录，这将是我们马上要访问的URL的一部分。</p><p id="248b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在收到来自API的响应后，我们必须更新DOM。</p><p id="0f20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此我们有一个<code class="fe lx ly lz ma b">update</code> <strong class="lb iu"> </strong>函数，我们向它传递两个参数，即所选记录的ID和事件对象。ID将被插入到获取的URL字符串中，事件对象将用于查找和更新所选文章的HTML元素。这是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/871861c64d06b5270207cc6fa0105158.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*qvSgpVQsSdrro_aGFEJSEw.png"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="ab21" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">删除</h1><p id="9ea3" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">删除操作非常简单。与更新操作类似，我们将传递所选文章的ID，并在URL中使用它来命中API中的正确记录。然后我们只需发送一个请求类型<code class="fe lx ly lz ma b">DELETE</code>并重新呈现DOM，而不需要等待响应——因为不会有响应:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/29070d30f983c574244b4f9f7abb4491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*ZKyf_YkoE_HaOYVb0mAAVQ.png"/></div></figure><p id="8d1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是<code class="fe lx ly lz ma b">render.js</code>文件的完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="9445" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结论</h1><p id="a0ec" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">今天，我们学习了如何用我们奇特的电子桌面应用程序进行基本的CRUD操作。接下来，我们将尝试优化渲染和重新渲染DOM的过程，并使数据管道更加有组织。</p><p id="8c6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不断学习，不断成长！</p></div></div>    
</body>
</html>