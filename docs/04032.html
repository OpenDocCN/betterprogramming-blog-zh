<html>
<head>
<title>Complexity: How Much Time and Space Does Your Algorithm Take to Run?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">复杂度:你的算法运行需要多少时间和空间？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/complexity-how-much-time-and-space-does-your-algorithm-take-82598873541f?source=collection_archive---------8-----------------------#2020-03-19">https://betterprogramming.pub/complexity-how-much-time-and-space-does-your-algorithm-take-82598873541f?source=collection_archive---------8-----------------------#2020-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1002" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更好地理解你的算法，这样你就可以改进它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ee1806cfcf14d602d12e0c9f0b8ee5d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ju7K32KaUDDFbfpX3MDScQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我创造的形象。https://www.flaticon.com/的图标</p></figure><p id="1140" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我对这篇文章很兴奋，因为这是我的第一篇。经过多年的推迟，我终于开始这样做了。我希望你喜欢这本书，但更重要是，我希望你也能学到一些东西。</p><p id="0150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章关注的是一个算法使用多少时间和空间。虽然有很多数学可以帮助我们计算这些东西，但我们将专注于一种直观的方式来了解这些测量。</p><p id="bb73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢数学并且想尝试一下，我会在最后贴上链接，但是首先，让我们回忆一下基础知识。</p><blockquote class="lv"><p id="fc50" class="lw lx it bd ly lz ma mb mc md me lu dk translated">“几乎在每一种计算中，过程的各种安排都是可能的。重要是选择能尽量减少计算所需时间的安排—阿达·洛芙莱斯</p></blockquote></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="8ffe" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">回归基础</h1><h2 id="df17" class="ne mn it bd mo nf ng dn ms nh ni dp mw li nj nk my lm nl nm na lq nn no nc np bi translated"><strong class="ak">什么是a <em class="nq">算法</em>？</strong></h2><p id="3d40" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">算法(或方法)是从输入产生可预测输出的有限指令序列。这意味着，如果一个指令序列没有定义的开始和结束，它就不适合被称为算法(引用我的话……)。</p><h2 id="4fd3" class="ne mn it bd mo nf ng dn ms nh ni dp mw li nj nk my lm nl nm na lq nn no nc np bi translated">什么是c <em class="nq">复杂度</em>？</h2><p id="6c2c" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">不，我不是问你的算法是不是很难读，lol。复杂度是算法的<em class="nw">时间</em>或<em class="nw">空间</em>的度量。</p><blockquote class="nx ny nz"><p id="5109" class="kz la nw lb b lc ld ju le lf lg jx lh oa lj lk ll ob ln lo lp oc lr ls lt lu im bi translated">“算法对于计算机程序就像菜谱对于菜肴一样。不同的食谱可以帮助你做一顿特别的饭，但它们并不总是产生相同的效果。</p><p id="5bbe" class="kz la nw lb b lc ld ju le lf lg jx lh oa lj lk ll ob ln lo lp oc lr ls lt lu im bi translated">它们并不总是有相同的步骤和成分，也不需要相同的时间。有些食谱比其他的更快，效果更好。莎拉·奇马</p></blockquote></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="3e31" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">时间复杂度</h1><p id="4af6" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">时间复杂度表示为<em class="nw"> T(n) </em>，是一个方法在输入大小为<em class="nw"> n </em>的情况下运行所需的时间。</p><p id="6ff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一个算法，T(n) 可以有不同的值吗？是的，但是怎么做呢？让我们看一个简单的例子。</p><p id="b999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们需要整理一副牌。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/e080a4c0e83fa3c597237416373cd41c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*vI-5Z_AgYlqJ3GwjTG9zqQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们假想的一副牌——图片来自<a class="ae ky" href="https://www.flaticon.com/" rel="noopener ugc nofollow" target="_blank">https://www.flaticon.com/</a></p></figure><p id="493c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有三个潜在的案例:</p><ol class=""><li id="e2f6" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated">最佳情况-输入需要最少数量的操作。认为:甲板已经排序。</li><li id="6037" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">最坏情况-输入需要最大数量的操作。认为:甲板完全没有排序。</li><li id="7546" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">平均情况-输入需要平均数量的操作。思考:甲板部分排序。</li></ol><p id="37b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，除非另有说明，我们只关心时间复杂度的最坏情况。我们使用<em class="nw"> big-O (big-oh)符号</em>来衡量最坏的情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/6308f1037550bba1261fa7e0930ce9a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jggw-o58Q_hYG1VOgACw9w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">r到L:最好的时间到最坏的时间。<em class="nq">来源:</em><a class="ae ky" href="https://www.bigocheatsheet.com" rel="noopener ugc nofollow" target="_blank"><em class="nq">【https://www.bigocheatsheet.com】</em></a></p></figure><p id="0cbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在实践中理解这一点，让我们看几个例子:</p><h2 id="3ebf" class="ne mn it bd mo nf ng dn ms nh ni dp mw li nj nk my lm nl nm na lq nn no nc np bi translated">1.O(1) —常数时间</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/3a1531895da35ddb476f4541db966dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U0rZl_Ik5YvTTzc4q_cWkQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">恒定时间。思考:赋值和数组索引访问。图像拍摄于<a class="ae ky" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">https://carbon.now.sh/</a></p></figure><h2 id="796b" class="ne mn it bd mo nf ng dn ms nh ni dp mw li nj nk my lm nl nm na lq nn no nc np bi translated">2.O(logn) —对数时间</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/8692c603ad32d46781ec8e7b43fe8a30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WxkmCFr8xAfqjYowivlwgw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对数时间。如果每次迭代后搜索空间减少一半，那么它是对数的。图像制作于<a class="ae ky" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">https://carbon.now.sh/</a></p></figure><h2 id="c4aa" class="ne mn it bd mo nf ng dn ms nh ni dp mw li nj nk my lm nl nm na lq nn no nc np bi translated">3.O(n) —线性时间</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/2af824de1333ea9d90c6b6abfc0f74a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVmSpnYI63dYsujWZ5Y6MA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">线性时间。想想:在最坏的情况下，我们需要访问输入中的所有元素。图像制作于<a class="ae ky" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">https://carbon.now.sh/</a></p></figure><h2 id="5f76" class="ne mn it bd mo nf ng dn ms nh ni dp mw li nj nk my lm nl nm na lq nn no nc np bi translated">4.O(nlogn) —线性时间或对数线性时间</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/58c8de5c7a688cb6c07e46931e6bf79b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*buWqwU6DCHDV_RrvdCbYbw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">线性时间。高效的排序算法在线性时间内运行。谷歌其他例子，有一些相当有趣的。图像制作于<a class="ae ky" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">https://carbon.now.sh/</a></p></figure><h2 id="dd89" class="ne mn it bd mo nf ng dn ms nh ni dp mw li nj nk my lm nl nm na lq nn no nc np bi translated">5.O(n ) —二次时间</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/adb1d265756c423b7bba156b92832a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3u63F54aHEEYdvLavBmsSA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">二次时间。如果我们需要访问输入中的每一个元素，那么它就是二次的。图像制作于<a class="ae ky" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">https://carbon.now.sh/</a></p></figure><h2 id="2ed4" class="ne mn it bd mo nf ng dn ms nh ni dp mw li nj nk my lm nl nm na lq nn no nc np bi translated">6.O(2^n) —指数时间</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/85a483f93de4c132a16d62b5c9462aee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jGF0tgK1JcXk7Bx9AzpOCw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">指数时间。评论解释的很好。这种解释如何延伸到3^n、4^n或5^n(等等)？图像制作于<a class="ae ky" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">https://carbon.now.sh/</a></p></figure><h2 id="2358" class="ne mn it bd mo nf ng dn ms nh ni dp mw li nj nk my lm nl nm na lq nn no nc np bi translated">7.O(n！)—阶乘时间</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/a27f1d728e8ed6d08709d9ecb2809792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*48_Yi67waqMicyY07Io4Rg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阶乘时间。思考:找出一个字符串的所有排列。谷歌其他例子也在这里。有些问题(如一些NP完全问题)有时只能在阶乘时间内解决。图像制作于<a class="ae ky" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">https://carbon.now.sh/</a></p></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="c3e0" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">让我们试一些例子</h1><p id="adb8" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">以下算法的时间复杂度是多少？你同意我的答案吗？</p><h2 id="282c" class="ne mn it bd mo nf ng dn ms nh ni dp mw li nj nk my lm nl nm na lq nn no nc np bi translated">1.遍历多维数组</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/ca4e5424be9bd2ffb78bd64b88ae4adc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ky_PK1RCrdYMe5WYWZ8UgQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这在O(n)中运行，因为我们只访问输入(多维数组= n)中的每个元素一次。在<a class="ae ky" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">https://carbon.now.sh/</a>拍摄的图像</p></figure><h2 id="c407" class="ne mn it bd mo nf ng dn ms nh ni dp mw li nj nk my lm nl nm na lq nn no nc np bi translated">2.Tomcat嵌入式核心getAllDeclaredMethods方法</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/27f640039a33f74908d8b0fbc5104ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l1oV9kNBWeHylKFUTD9hQw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这在O(l*k)中运行，其中l =继承类的总数&amp; k =方法的总数。图像制作于<a class="ae ky" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">https://carbon.now.sh/</a></p></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="f8fb" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">空间复杂性</h1><p id="87ae" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">关于空间复杂性的(可理解的)材料并不多；它不太受欢迎，但同样重要。</p><p id="3cf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">空间复杂度是一种衡量一个算法需要多少计算机内存(RAM)来执行的指标。我们也可以用big-O来表达。</p><p id="d3e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看返回第<em class="nw">n</em>个斐波那契数的两种实现——递归(无记忆)与迭代。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/87f98498e88c68fa1c715149e445ab3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vp2l2_IQ_Al5K0aIS3deqQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">betterFibonacci的空间复杂度是O(1 ),这意味着即使输入增加，空间量也不会改变，而naiveFibonnaci由于递归堆栈需要O(n)空间。在https://carbon.now.sh/<a class="ae ky" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">拍摄的图像</a></p></figure><p id="8e3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这个，回头见！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="bfb2" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated"><strong class="ak">资源与延伸阅读</strong></h1><ul class=""><li id="ca34" class="oe of it lb b lc nr lf ns li pd lm pe lq pf lu pg ok ol om bi translated">《计算机科学精粹:学习解决计算问题的艺术》</li><li id="ef29" class="oe of it lb b lc on lf oo li op lm oq lq or lu pg ok ol om bi translated"><a class="ae ky" href="https://dev.to/sarah_chima/the-big-o-notation-an-introduction-34f7" rel="noopener ugc nofollow" target="_blank">big-O符号介绍</a></li><li id="6634" class="oe of it lb b lc on lf oo li op lm oq lq or lu pg ok ol om bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/3707190/why-does-javas-arrays-sort-method-use-two-different-sorting-algorithms-for-diff" rel="noopener ugc nofollow" target="_blank">为什么Java的数组排序方法对diff使用两种不同的排序算法？</a></li><li id="93c3" class="oe of it lb b lc on lf oo li op lm oq lq or lu pg ok ol om bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Time_complexity#Quasilinear_time" rel="noopener ugc nofollow" target="_blank">准线性时间—维基百科</a></li><li id="9d60" class="oe of it lb b lc on lf oo li op lm oq lq or lu pg ok ol om bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=KXAbAa1mieU" rel="noopener ugc nofollow" target="_blank"> YouTube视频</a>(给你点数学。)</li></ul><p id="6509" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">欢迎在下面给我更多的技术链接，我会把它们添加到帖子里！)</p><p id="9b1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特别大声喊出来:Wladston，你是一个不可思议的传奇！</p></div></div>    
</body>
</html>