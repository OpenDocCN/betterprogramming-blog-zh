<html>
<head>
<title>Getting Started With Test-Driven Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试驱动开发入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-test-driven-development-3621a828657e?source=collection_archive---------8-----------------------#2019-10-18">https://betterprogramming.pub/getting-started-with-test-driven-development-3621a828657e?source=collection_archive---------8-----------------------#2019-10-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2e4e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"># 100日代码的第31天</h2><div class=""/><div class=""><h2 id="ed98" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">学习用TDD构建坚如磐石的解决方案</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e07cb2e0d6c087bb6886dc984ba81549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sjet9qSO4O8fX2-FXvxflw.jpeg"/></div></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="8230" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在我们开始之前——如果你不熟悉测试驱动开发(TDD)或者TDD的三大法则，那么我强烈建议你在开始本教程之前阅读一下。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="3cda" class="mi mj it bd mk ml mm mn mo mp mq mr ms ki mt kj mu kl mv km mw ko mx kp my mz bi translated">实际例子</h1><p id="5fc4" class="pw-post-body-paragraph lf lg it lh b li na kd lk ll nb kg ln lo nc lq lr ls nd lu lv lw ne ly lz ma im bi translated">我们将编写TDD来实现<a class="ae nj" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>中的<code class="fe nf ng nh ni b">primeFactors</code>函数:</p><p id="0df2" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">首先，我们将创建一个名为<code class="fe nf ng nh ni b">PrimeFactorsTest</code>的类。我们将使用<code class="fe nf ng nh ni b">@Test</code>注释来指定一个函数作为测试。您将在IntelliJ 中看到一个绿色箭头，您可以点击它来运行特定的测试功能，而不是运行整个项目。</p><p id="121f" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们将开始编写我们的第一个测试。我们一写<code class="fe nf ng nh ni b">factorsOf(1)</code>就会看到一个编译错误。这就是我们遵循TDD第二定律编写一些产品代码的时候:创建一个函数，但不要在里面写任何东西。如果你这么做了，你就违反了TDD第一定律。</p><p id="1e23" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">现在我们继续，用“is<code class="fe nf ng nh ni b">(emptyList())</code>”<strong class="lh jd"><em class="nk"/></strong>完成我们的<code class="fe nf ng nh ni b">@Test</code>语句，如果我们运行我们的测试，它将失败，因为<code class="fe nf ng nh ni b">factorsOf()</code>函数不返回任何东西。因此，继续让它返回一个空列表。</p><p id="f6d3" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">到目前为止，我们有以下代码:</p><pre class="ks kt ku kv gt nl ni nm nn aw no bi"><span id="900b" class="np mj it ni b gy nq nr l ns nt">package primeFactors<br/><br/>import org.hamcrest.CoreMatchers.`is`<br/>import org.junit.Assert<br/>import org.junit.Test<br/><br/>class PrimeFactorsTest {<br/><br/>    <strong class="ni jd">// Writing first test case</strong><br/>    @Test fun factors() {<br/>        Assert.assertThat(factorsOf(1), `is`(<em class="nk">emptyList</em>()))<br/>    }<br/><br/>    private fun factorsOf(number: Int): List&lt;Int&gt; {<br/>        return <em class="nk">emptyList</em>()<br/>    }<br/>}</span></pre><p id="ce63" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">然后我们添加另一个测试，它失败了。</p><pre class="ks kt ku kv gt nl ni nm nn aw no bi"><span id="4722" class="np mj it ni b gy nq nr l ns nt">package primeFactors<br/><br/>import org.hamcrest.CoreMatchers.`is`<br/>import org.junit.Assert<br/>import org.junit.Test<br/><br/>class PrimeFactorsTest {<br/>    <br/>    // Writing first test case<br/>    @Test fun factors() {<br/>        Assert.assertThat(factorsOf(1), `is`(<em class="nk">emptyList</em>()))<br/>        <strong class="ni jd">// Adding another test - which will fail<br/>        Assert.assertThat(factorsOf(2), `is`(<em class="nk">listOf</em>(2)))</strong><br/>    }<br/><br/>    private fun factorsOf(number: Int): List&lt;Int&gt; {<br/>        return <em class="nk">emptyList</em>()<br/>    }<br/>}</span></pre><p id="49af" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在修改我们的函数之后，我们的测试用例通过了。现在我们写一个<code class="fe nf ng nh ni b">factorOf(3)</code>的测试用例，它仍然通过。不需要修改代码库。</p><pre class="ks kt ku kv gt nl ni nm nn aw no bi"><span id="f064" class="np mj it ni b gy nq nr l ns nt">package primeFactors</span><span id="f16e" class="np mj it ni b gy nu nr l ns nt">import org.hamcrest.CoreMatchers.`is`<br/>import org.junit.Assert<br/>import org.junit.Test</span><span id="5bb2" class="np mj it ni b gy nu nr l ns nt">class PrimeFactorsTest {</span><span id="682f" class="np mj it ni b gy nu nr l ns nt">    @Test<br/>    fun factors() {<br/>        Assert.assertThat(factorsOf(1), `is`(<em class="nk">emptyList</em>()))<br/>        Assert.assertThat(factorsOf(2), `is`(<em class="nk">listOf</em>(2)))<br/>        Assert.assertThat(factorsOf(3), `is`(<em class="nk">listOf</em>(3)))<br/>    }</span><span id="dbb3" class="np mj it ni b gy nu nr l ns nt">    <strong class="ni jd">private fun factorsOf(number: Int): List&lt;Int&gt; {<br/>        val result = <em class="nk">mutableListOf</em>&lt;Int&gt;()<br/>        if (number &gt; 1) {<br/>            result.add(number)<br/>        } <br/>        return result<br/>    }</strong></span><span id="ba2c" class="np mj it ni b gy nu nr l ns nt">}</span></pre><p id="d93b" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如果我们添加了<code class="fe nf ng nh ni b">factorsOf(4)</code>，它就失败了，所以我们回过头来修改代码。</p><pre class="ks kt ku kv gt nl ni nm nn aw no bi"><span id="6679" class="np mj it ni b gy nq nr l ns nt">package primeFactors</span><span id="baf0" class="np mj it ni b gy nu nr l ns nt">import org.hamcrest.CoreMatchers.`is`<br/>import org.junit.Assert<br/>import org.junit.Test</span><span id="f145" class="np mj it ni b gy nu nr l ns nt">class PrimeFactorsTest {</span><span id="9ced" class="np mj it ni b gy nu nr l ns nt">    @Test<br/>    fun factors() {<br/>        Assert.assertThat(factorsOf(1), `is`(<em class="nk">emptyList</em>()))<br/>        Assert.assertThat(factorsOf(2), `is`(<em class="nk">listOf</em>(2)))<br/>        Assert.assertThat(factorsOf(3), `is`(<em class="nk">listOf</em>(3)))<br/>        <strong class="ni jd">Assert.assertThat(factorsOf(4), `is`(<em class="nk">listOf</em>(2, 2)))</strong><br/>    }</span><span id="8d39" class="np mj it ni b gy nu nr l ns nt">    <strong class="ni jd">private fun factorsOf(number: Int): List&lt;Int&gt; {<br/>        var remainder = number<br/>        val result = <em class="nk">mutableListOf</em>&lt;Int&gt;()<br/>        if (remainder &gt; 1) {<br/>            if (remainder % 2 == 0) {<br/>                result.add(2)<br/>                remainder /= 2<br/>            }<br/>            if (remainder &gt; 1) {<br/>                result.add(remainder)<br/>            }<br/>        }<br/>        return result<br/>    }</strong><br/>}</span></pre><p id="eeb7" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">现在，我们的测试将通过<code class="fe nf ng nh ni b">4</code>，如果我们增加更多的测试— <code class="fe nf ng nh ni b"> 5</code>、<code class="fe nf ng nh ni b">6</code>、<code class="fe nf ng nh ni b">7</code>。他们都通过了，直到我们写<code class="fe nf ng nh ni b">8</code>。</p><pre class="ks kt ku kv gt nl ni nm nn aw no bi"><span id="ad8c" class="np mj it ni b gy nq nr l ns nt">Assert.assertThat(factorsOf(1), `is`(<em class="nk">emptyList</em>()))<br/>Assert.assertThat(factorsOf(2), `is`(<em class="nk">listOf</em>(2)))<br/>Assert.assertThat(factorsOf(3), `is`(<em class="nk">listOf</em>(3)))<br/>Assert.assertThat(factorsOf(4), `is`(<em class="nk">listOf</em>(2, 2)))<br/>Assert.assertThat(factorsOf(5), `is`(<em class="nk">listOf</em>(5)))<br/>Assert.assertThat(factorsOf(6), `is`(<em class="nk">listOf</em>(2, 3)))<br/>Assert.assertThat(factorsOf(7), `is`(<em class="nk">listOf</em>(7)))<br/><strong class="ni jd">// They all pass</strong></span><span id="122e" class="np mj it ni b gy nu nr l ns nt"><strong class="ni jd">// Except this one<br/>Assert.assertThat(factorsOf(8), `is`(<em class="nk">listOf</em>(2,2,2)))</strong></span></pre><p id="0915" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">将<code class="fe nf ng nh ni b">factorsOf()</code>函数修改如下后，它将通过。</p><pre class="ks kt ku kv gt nl ni nm nn aw no bi"><span id="f23d" class="np mj it ni b gy nq nr l ns nt">private fun factorsOf(number: Int): List&lt;Int&gt; {<br/>    var remainder = number<br/>    val result = <em class="nk">mutableListOf</em>&lt;Int&gt;()<br/>    if (remainder &gt; 1) {<br/>        <strong class="ni jd">while</strong> (remainder % 2 == 0) {<br/>            result.add(2)<br/>            remainder /= 2<br/>        }<br/>        if (remainder &gt; 1) {<br/>            result.add(remainder)<br/>        }<br/>    }<br/>    return result<br/>}</span></pre><p id="5ab9" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">现在我们来做<code class="fe nf ng nh ni b">9</code>。</p><pre class="ks kt ku kv gt nl ni nm nn aw no bi"><span id="dfb9" class="np mj it ni b gy nq nr l ns nt">Assert.assertThat(factorsOf(9), `is`(<em class="nk">listOf</em>(3, 3))) // Fails</span></pre><p id="c237" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">所以让我们复制。我们将在它通过后立即重构。</p><pre class="ks kt ku kv gt nl ni nm nn aw no bi"><span id="b3a1" class="np mj it ni b gy nq nr l ns nt">private fun factorsOf(number: Int): List&lt;Int&gt; {<br/>    var remainder = number<br/>    val result = <em class="nk">mutableListOf</em>&lt;Int&gt;()<br/>    if (remainder &gt; 1) {<br/>        while (remainder % 2 == 0) {<br/>            result.add(2)<br/>            remainder /= 2<br/>        }<br/>        <strong class="ni jd">while (remainder % 3 == 0) {<br/>            result.add(3)<br/>            remainder /= 3<br/>        } // We know how to optimize the algo further</strong><br/>        if (remainder &gt; 1) {<br/>            result.add(remainder)<br/>        }<br/>    }<br/>    return result<br/>}</span></pre><p id="eb9d" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们优化我们的算法，得到这个:</p><pre class="ks kt ku kv gt nl ni nm nn aw no bi"><span id="7961" class="np mj it ni b gy nq nr l ns nt">private fun factorsOf(number: Int): List&lt;Int&gt; {<br/>    val result = <em class="nk">mutableListOf</em>&lt;Int&gt;()<br/>    var remainder = number<br/>    var divisor = 2<br/>    while (remainder &gt; 1) {<br/>        while (remainder % divisor == 0) {<br/>            result.add(divisor)<br/>            remainder /= divisor<br/>        }<br/>        divisor++<br/>    }<br/>    return result<br/>}</span></pre><p id="2afc" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">那么，我们是如何得到这个算法的呢？只要遵循TDD的三个法则:编写代码通过一个接一个的测试用例。是不是很神奇？</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="8938" class="mi mj it bd mk ml mm mn mo mp mq mr ms ki mt kj mu kl mv km mw ko mx kp my mz bi translated">编写坚如磐石的单元测试的额外技巧</h1><ul class=""><li id="2768" class="nv nw it lh b li na ll nb lo nx ls ny lw nz ma oa ob oc od bi translated"><strong class="lh jd">全面</strong>:涵盖所有场景，包括成功案例、失败案例、边界案例。</li><li id="9e83" class="nv nw it lh b li oe ll of lo og ls oh lw oi ma oa ob oc od bi translated">可重复的:不管你运行多少次，结果都是一样的。</li><li id="c333" class="nv nw it lh b li oe ll of lo og ls oh lw oi ma oa ob oc od bi translated"><strong class="lh jd">专注:</strong>应该专注于测试一件且只有一件事，这样你就可以在测试失败的情况下精确定位你的代码。</li><li id="c7c8" class="nv nw it lh b li oe ll of lo og ls oh lw oi ma oa ob oc od bi translated"><strong class="lh jd">验证行为:</strong>测试应该让您相信系统的行为符合预期。</li><li id="23a0" class="nv nw it lh b li oe ll of lo og ls oh lw oi ma oa ob oc od bi translated"><strong class="lh jd">快速:</strong>最重要的是，测试应该运行并立即给出错误，如果有的话。</li><li id="dd5f" class="nv nw it lh b li oe ll of lo og ls oh lw oi ma oa ob oc od bi translated">简洁:你的测试应该简短，易于阅读和理解，因为它们是极好的文档来源。</li></ul></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><p id="90f4" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">第31天到此为止。31天写了31篇。谢谢你所有的支持，一直激励我粉碎它！</p><p id="774b" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我希望你喜欢阅读这篇文章。你美得令人窒息！</p></div></div>    
</body>
</html>