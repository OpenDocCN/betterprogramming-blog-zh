<html>
<head>
<title>WebGL Enhanced Drag Slider Tutorial With Curtains.js — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebGL增强的Drag Slider Tutorial With curtains . js—第2部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/webgl-enhanced-drag-slider-tutorial-with-curtains-js-part-2-bf32aa5a15c0?source=collection_archive---------6-----------------------#2019-07-18">https://betterprogramming.pub/webgl-enhanced-drag-slider-tutorial-with-curtains-js-part-2-bf32aa5a15c0?source=collection_archive---------6-----------------------#2019-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/4be96d471e3ede5017613e07afbfe95d.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*Z_N7JlI5O4CZyeDJh-2O7A.gif"/></div></figure><p id="3c1f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">本文是教程的第二部分。在<a class="ae ks" href="https://medium.com/swlh/webgl-enhanced-drag-slider-tutorial-with-curtains-js-part-1-17a11431fb94" rel="noopener">的第一部分</a>，我们创建了一个JavaScript拖动滑块。我们现在要写WebGL部分了。</p><p id="8d0d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以下是您将得到的结果:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="fee1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">提醒一下，我们将使用<a class="ae ks" href="https://www.curtainsjs.com/" rel="noopener ugc nofollow" target="_blank">窗帘. js </a>来添加与WebGL相关的所有内容。</p><p id="e496" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://www.curtainsjs.com/?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> curtains.js </a>是一个开源的<a class="ae ks" href="http://vanilla-js.com/" rel="noopener ugc nofollow" target="_blank">香草</a> JavaScript库。它在这里特别有用，因为它的主要目的是用WebGL效果增强DOM元素。</p><p id="3204" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通过几行JavaScript，您将能够创建WebGL纹理平面，绑定到我们的滑块项目的HTML元素，然后对整个场景进行后期处理。</p><p id="1d50" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用drawings . js的优势变得显而易见:</p><ul class=""><li id="0f6a" class="kz la iq jw b jx jy kb kc kf lb kj lc kn ld kr le lf lg lh bi translated">干净和搜索引擎友好的HTML代码。</li><li id="63a1" class="kz la iq jw b jx li kb lj kf lk kj ll kn lm kr le lf lg lh bi translated">你不必担心你的WebGL对象的大小和位置，因为大多数东西(比如调整大小)将由库来处理。</li><li id="7b56" class="kz la iq jw b jx li kb lj kf lk kj ll kn lm kr le lf lg lh bi translated">如果在WebGL初始化期间或在您的着色器中出现错误，滑块仍将工作。</li></ul><p id="e180" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">尽管我们将使用完全注释的代码一步一步地查看这是如何工作的，但是如果您不熟悉这些概念，您可能希望了解更多关于<a class="ae ks" href="https://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html" rel="noopener ugc nofollow" target="_blank"> WebGL </a>和<a class="ae ks" href="https://thebookofshaders.com/" rel="noopener ugc nofollow" target="_blank">着色器</a>的信息。</p><p id="2deb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可能还想看一下<a class="ae ks" href="https://www.curtainsjs.com/documentation.html" rel="noopener ugc nofollow" target="_blank">窗帘. js API文档</a> <strong class="jw ir"> </strong>或者检查一下它的<a class="ae ks" href="https://github.com/martinlaxenaire/curtainsjs" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p><p id="8b6c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们还将使用<a class="ae ks" href="https://animejs.com/" rel="noopener ugc nofollow" target="_blank"> anime.js </a>作为我们动画的补间引擎。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="84d8" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">第1部分— HTML和CSS</h1><p id="da23" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">要实现WebGL，我们必须对HTML和CSS做一些修改。</p><h2 id="0d01" class="mx lv iq bd lw my mz dn ma na nb dp me kf nc nd mi kj ne nf mm kn ng nh mq ni bi translated">超文本标记语言</h2><p id="778a" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">HTML没有太多变化。</p><p id="c0d0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将添加一个<code class="fe nj nk nl nm b">div</code>容器来保存图像标签上的WebGL <code class="fe nj nk nl nm b">canvas</code>和数据采样器属性；它将被用作片段着色器中的纹理采样器名称。</p><p id="83b4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们还将在主体结束标记之前添加我们的库和主JavaScript文件。</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="nn ky l"/></div></figure><h2 id="b6aa" class="mx lv iq bd lw my mz dn ma na nb dp me kf nc nd mi kj ne nf mm kn ng nh mq ni bi translated">半铸钢ˌ钢性铸铁(Cast Semi-Steel)</h2><p id="b956" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">因为我们的图像将在画布中显示为WebGL平面，所以我们必须隐藏原始图像。</p><p id="859a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">每次创建一个平面，我们将添加一个<code class="fe nj nk nl nm b">loaded</code>类到它的父HTML元素中，以动画显示相应标题的不透明度。</p><p id="c95c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们将在WebGL初始化期间捕获错误(或编译着色器时的任何问题),并将一个<code class="fe nj nk nl nm b">no-curtains</code>类添加到文档主体。</p><p id="956b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，我们需要在CSS中处理这种情况，以再次显示我们的原始图像:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="nn ky l"/></div></figure><p id="5311" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">就这样，没什么难的。现在让我们转到WebGL！</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="3ca9" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">第2部分—着色器</h1><p id="b917" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">在我们扩展slider类来添加所有与WebGL相关的JavaScript之前，我们将编写我们的着色器。</p><p id="ed3f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们有两个不同的元素:我们的平面(将使用相同的着色器)和我们的着色器通道。然后，我们必须编写两对着色器。</p><p id="aff3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">着色器将被放在<code class="fe nj nk nl nm b">&lt;script&gt;</code>标签中，就在我们的主体结束标签之前。注意它们的<code class="fe nj nk nl nm b">ID</code>属性——我们稍后将在JavaScript中使用它们。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="b6de" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">飞机</h1><h2 id="964a" class="mx lv iq bd lw my mz dn ma na nb dp me kf nc nd mi kj ne nf mm kn ng nh mq ni bi translated">平面顶点着色器</h2><p id="9bda" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">由于库生成的投影和视图矩阵，平面顶点着色器相对于它们的HTML元素定位我们的平面。</p><p id="8f9f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它还会将新的纹理坐标传递给我们的片段着色器。通过使用<em class="no">纹理矩阵</em> uniform来计算新的纹理坐标，我们确保纹理将始终适合平面，而不会破坏其自然纵横比。</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="nn ky l"/></div></figure><h2 id="2847" class="mx lv iq bd lw my mz dn ma na nb dp me kf nc nd mi kj ne nf mm kn ng nh mq ni bi translated">平面片段着色器</h2><p id="fcbf" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">我们将把我们的纹理映射到我们刚刚传递的纹理坐标，并根据我们的<code class="fe nj nk nl nm b">uOpacity</code>制服，以及从每个像素到左边缘的距离，制作它的不透明度的动画:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="nn ky l"/></div></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="1e40" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">后加工</h1><p id="5f92" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">着色器过程使用<em class="no">帧缓冲对象</em>将整个场景渲染到纹理，应用着色器，然后将该纹理渲染回画布。</p><p id="c1fb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">大多数后期处理效果将发生在我们的片段着色器内部。我们将使用一个位移纹理来增加整体效果的趣味。我们将使用这张黑白图像的RGB值来计算我们将应用于每个像素的位移量。</p><p id="72a1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将重复和偏移这个纹理，使它看起来像是在跟随我们的平面。然后，我们使用一个模式图像来获得无缝效果。</p><p id="6619" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是我们将使用的图像:</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi np"><img src="../Images/6597747a248dfe0b99c4f6843116eda8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YN8M2ubhwBiMxruOmEeAjA.jpeg"/></div></div></figure><p id="7bac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们详细了解这些着色器之前，让我们分解一下着色器中会发生什么:</p><ul class=""><li id="210c" class="kz la iq jw b jx jy kb kc kf lb kj lc kn ld kr le lf lg lh bi translated">在我们的顶点着色器中计算鼠标相对于纹理坐标的位置，并将其作为变量传递给我们的片段着色器。</li><li id="f25a" class="kz la iq jw b jx li kb lj kf lk kj ll kn lm kr le lf lg lh bi translated">基于我们的<code class="fe nj nk nl nm b">uDragEffect</code>制服和鼠标到远边的距离，计算一个从零到一的<code class="fe nj nk nl nm b">spreadFromMouse</code>浮动(就像我们对平面的不透明度所做的那样)。</li><li id="ff88" class="kz la iq jw b jx li kb lj kf lk kj ll kn lm kr le lf lg lh bi translated">基于<code class="fe nj nk nl nm b">spreadFromMouse</code>应用一种鱼眼效果(离鼠标越远，我们得到的扭曲越多)。参见图1。</li><li id="ec9e" class="kz la iq jw b jx li kb lj kf lk kj ll kn lm kr le lf lg lh bi translated">基于我们的置换贴图RGB值和<code class="fe nj nk nl nm b">spreadFromMouse</code>应用置换(离鼠标越远，置换越多)。参见图2。</li><li id="6808" class="kz la iq jw b jx li kb lj kf lk kj ll kn lm kr le lf lg lh bi translated">基于<code class="fe nj nk nl nm b">spreadFromMouse</code>应用灰度和背景色效果。参见图3。</li></ul><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi np"><img src="../Images/b3699023d06d8052b6a7348a76ecbe00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X2lYmCYz_FlUmQQBQN4jqQ.jpeg"/></div></div></figure><h2 id="9ea8" class="mx lv iq bd lw my mz dn ma na nb dp me kf nc nd mi kj ne nf mm kn ng nh mq ni bi translated">后处理顶点着色器</h2><p id="14c5" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">着色器过程不使用投影和模型视图矩阵，因为渲染纹理(表示画布上实际绘制的内容)和画布始终具有相同的大小和位置。</p><p id="3723" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">出于同样的原因，你不需要在渲染纹理坐标上使用纹理矩阵。</p><p id="dc8b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，我们将需要使用我们的位移图像纹理矩阵来计算其精确的纹理坐标:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="nn ky l"/></div></figure><h2 id="55b5" class="mx lv iq bd lw my mz dn ma na nb dp me kf nc nd mi kj ne nf mm kn ng nh mq ni bi translated">后处理片段着色器</h2><p id="31e8" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">在这里你会发现我们上面定义的所有步骤。</p><p id="29cc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有些效果取决于滑块方向；我们将计算两种效果，并根据滑块方向选择正确的效果。</p><p id="d577" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们本可以使用<code class="fe nj nk nl nm b">if</code>和<code class="fe nj nk nl nm b">else</code>语句，但是它们会降低<a class="ae ks" href="https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/glsl_overview.php" rel="noopener ugc nofollow" target="_blank"> GLSL </a>的性能，应该谨慎使用。</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="nn ky l"/></div></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="c061" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">第3部分WebGL</h1><p id="6788" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">让我们回到JavaScript并添加WebGL部分。</p><p id="6f07" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将扩展<code class="fe nj nk nl nm b">Slider</code>类<strong class="jw ir"> </strong>(在继续之前，请务必插入在<a class="ae ks" href="https://medium.com/@martin.laxenaire/webgl-enhanced-drag-slider-tutorial-with-curtains-js-part-1-17a11431fb94" rel="noopener">上一篇文章</a>中看到的<code class="fe nj nk nl nm b">Slider</code>类代码。)并使用几乎相同的代码结构:构造函数、助手、钩子、设置和销毁方法。唯一的区别是，为了清楚起见，我们将在助手和钩子之前编写所有的设置函数。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="3b71" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">初始化</h1><p id="d850" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">让我们从创建一个新的<em class="no">窗帘</em>实例开始。我们需要将包装画布的div的ID作为参数传递。</p><p id="834b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这将无声地添加一个画布，获取我们的WebGL上下文，开始一个<code class="fe nj nk nl nm b">requestAnimationFrame</code>循环，绘制我们的场景，等等。它将返回一个对象，我们稍后将使用它来添加我们的平面和着色器过程。</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="nn ky l"/></div></figure><p id="13d2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如您所见，我们在init函数中调用了<code class="fe nj nk nl nm b">setupPlanes</code>和<code class="fe nj nk nl nm b">setupShaderPass</code>方法。我们现在就要给它们编码。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="aedf" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">添加平面</h1><p id="e318" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">为了添加我们的平面，我们将使用窗帘对象的<code class="fe nj nk nl nm b">addPlane</code>方法。</p><p id="9763" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个方法有两个参数:</p><ul class=""><li id="1c91" class="kz la iq jw b jx jy kb kc kf lb kj lc kn ld kr le lf lg lh bi translated">将绑定到平面的HTML元素。该平面将复制其CSS大小和位置。在窗口大小调整事件中，它将更新到新的大小和尺寸。它还会自动为该元素的所有图像、画布和视频的子元素创建纹理。在我们的例子中，我们只有一个图像。</li><li id="a6aa" class="kz la iq jw b jx li kb lj kf lk kj ll kn lm kr le lf lg lh bi translated">一个参数对象。在这里我们将指定着色器的脚本id和我们的制服。</li></ul><p id="4064" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦创建了平面，我们将把它放入我们的平面数组供以后使用。</p><p id="013c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">平面有一个方便的<code class="fe nj nk nl nm b">onReady</code>事件，一旦创建了所有的初始纹理，就会触发该事件——这就是我们要制作它们的不透明度动画并将<code class="fe nj nk nl nm b">loaded</code>类添加到其父HTML元素的地方。</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="nn ky l"/></div></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="fc3c" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">添加着色器过程</h1><p id="68c1" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">接下来是着色器阶段。</p><p id="e24b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于窗帘对象的<code class="fe nj nk nl nm b">addShaderPass</code>方法，添加一个着色器过程比添加一个平面更容易。</p><p id="eb8e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它不需要绑定到HTML元素，因为它将绑定到我们的画布。它只需要一个参数对象与着色器的脚本id和制服。</p><p id="b22c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦它被添加，我们将使用<code class="fe nj nk nl nm b">loadImage</code>加载位移图像。</p><p id="c3d5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个方法接受图像的HTML元素作为参数，所以我们首先需要创建一个。不需要监听图像的加载事件，库会处理的。</p><p id="ddd9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们将使用着色器的<code class="fe nj nk nl nm b">onRender</code>事件来沿着次轴连续偏移我们的纹理。</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="nn ky l"/></div></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="900b" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">使用钩子</h1><p id="074a" class="pw-post-body-paragraph ju jv iq jw b jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr ij bi translated">我们已经设置了所有的WebGL对象。现在我们需要用我们在<code class="fe nj nk nl nm b">Slider</code>类中声明的钩子将它们绑定到滑块上。我们将用新的方法来覆盖它们。</p><p id="4b10" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当您调整浏览器大小时，我们的平面会自动调整大小。这是因为curtains.js知道窗口大小调整事件何时发生，并且可以处理新大小和位置的计算。</p><p id="9ab9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，当你通过CSS或JavaScript移动你的平面时，库不能知道，我们确实在转换它们的父div。</p><p id="c378" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们需要通过简单调用<code class="fe nj nk nl nm b">updatePosition</code>方法来告诉我们的飞机更新它们的位置。我们将把它放入我们的<code class="fe nj nk nl nm b">onTranslation</code>函数中。</p><p id="fde5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们还需要更新我们的各种助手和钩子处理程序中的着色器传递鼠标位置、拖动效果和滑块方向。</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="nn ky l"/></div></figure><p id="25c2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们快完成了。</p><p id="cc49" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们将添加一种方法来彻底销毁滑块的WebGL部分，并覆盖我们的<code class="fe nj nk nl nm b">Slider</code>类初始销毁方法:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="nn ky l"/></div></figure><p id="e448" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是你令人敬畏的<strong class="jw ir"> WebGL拖动滑块</strong>！</p><p id="aef9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在最后一部分中，我们将看到<strong class="jw ir">如何通过删除所有不必要的布局/回流调用来提高性能</strong>。</p></div></div>    
</body>
</html>