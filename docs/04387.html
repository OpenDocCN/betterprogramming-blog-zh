<html>
<head>
<title>A Conceptual Overview of Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes的概念概述</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kubernetes-core-concepts-overview-cf4d8bede3e1?source=collection_archive---------15-----------------------#2020-04-09">https://betterprogramming.pub/kubernetes-core-concepts-overview-cf4d8bede3e1?source=collection_archive---------15-----------------------#2020-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4139" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">集装箱化的好处</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/205023bc02b8d13ad1facd248be974bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3_xKUdeRP3IQpg_LzjeEQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@herrherrmann?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">塞巴斯蒂安·赫尔曼</a>在<a class="ae kv" href="https://unsplash.com/s/photos/boxes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="a8b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您是否有一些容器化的应用程序需要部署、更新以及根据某些标准进行扩展和缩减？您是否需要一个解决方案来确保服务的连续性，并且SLA接近100%？不要想太多:想想Kubernetes。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/97b5b50cf93772637f148ea23ed82956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*LHHLfa8lCvKM5bkiKbjKMw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:<a class="ae kv" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes文档</a></p></figure><p id="ccbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将解释<a class="ae kv" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>的基本概念。(请注意，在进一步学习之前，您应该对容器有一些基本的了解。)</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="2fa6" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">什么是集装箱化？</h1><p id="4493" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">容器化包括将应用程序与所有相关的配置文件、库以及它在不同计算环境中高效运行所需的依赖项捆绑在一起</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/1af3a30f3f849790f03a9743412aadbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*TIAz5BJHLXoTRXggbAqjuw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">集装箱化概述(图片来源:<a class="ae kv" href="https://medium.com/hackernoon/what-is-containerization-83ae53a709a6" rel="noopener">什么是集装箱化？</a>由沙安雷)</p></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="9602" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">什么是Kubernetes？</h1><p id="f0ee" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">根据<a class="ae kv" href="https://en.wikipedia.org/wiki/Kubernetes" rel="noopener ugc nofollow" target="_blank">维基百科</a>，</p><blockquote class="mx"><p id="f7df" class="my mz iq bd na nb nc nd ne nf ng lr dk translated">Kubernetes(通常风格化为k8s)是一个开源的容器编排系统，用于自动化应用程序部署、扩展和管理</p></blockquote><p id="799e" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">Kubernetes可以在桌面、内部和云中运行。它主要由谷歌创建，现在由云原生计算基金会(CNCF)维护，该基金会定义了如何构建云原生应用。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="20ff" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">Kubernetes架构概述</h1><p id="dcca" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这是库伯内特建筑的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/5a4d767024cc7656b5a0b1bb69335607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6uhBDhkNaniQoubPN51yUA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Kubernetes建筑(图片来源:<a class="ae kv" href="https://geekflare.com/kubernetes-architecture/" rel="noopener ugc nofollow" target="_blank">了解Kubernetes建筑</a></p></figure><ul class=""><li id="836e" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated"><strong class="ky ir"> Master </strong>:主节点通过API服务器管理整个集群，负责给工作节点分配任务。</li><li id="2826" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><strong class="ky ir"> API服务器</strong>:这个组件提供了一组API，可以用来在集群中执行一些动作。可以在集群外部使用<code class="fe ob oc od oe b">kubectl</code>命令或仪表板<strong class="ky ir"> </strong> GUI对其进行访问。</li><li id="97fe" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">调度器(Scheduler):这个组件根据pod规范文件管理pod的选择和执行，我们将在后面看到。</li><li id="2702" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><strong class="ky ir">控制器</strong>:该组件控制节点和副本。</li><li id="539f" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><strong class="ky ir"> etcd </strong>:这个组件存储一个数据字典。这是一个存储所有集群数据的Kubernetes数据库。</li><li id="3988" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><strong class="ky ir"> Kubelet: </strong>工作节点通过API服务器使用Kubelet与主节点通信，并确保pods按照其规范正常运行。</li><li id="0f8c" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><strong class="ky ir"> Kube-proxy </strong>:该组件为用户管理集群外部的网络和端口。</li></ul></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="8fa8" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">什么是Pod？</h1><p id="08f0" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在Kubernetes架构中，Pod是可以在Kubernetes集群中创建和管理的最小可部署计算单元。根据<a class="ae kv" href="https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/" rel="noopener ugc nofollow" target="_blank">文件</a>，</p><blockquote class="mx"><p id="6698" class="my mz iq bd na nb nc nd ne nf ng lr dk translated">Pod是由一个或多个容器(如Docker容器)组成的组，具有共享存储/网络，以及如何运行容器的规范</p></blockquote><p id="4b81" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">也就是说，在Kubernetes集群中，我们的应用程序运行在一个或多个Pods中。一个Pod代表集群中的一个正在运行的进程。一个pod包含:</p><ul class=""><li id="5af9" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated">docker应用程序容器</li><li id="8878" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">存储资源</li><li id="bc70" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">唯一网络IP</li><li id="3f49" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">显示容器应该如何运行的选项</li></ul><p id="793c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在一些罕见的场景中，可以在一个Pod中运行多个容器，但是一个Pod代表一个单一的部署单元，一个Kubernetes中紧密耦合并共享资源的单一应用程序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/ccb5650415c6f2250442844a691ba957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EmNcwPU9Jtgn0eIHAwJVrg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Kubernetes星团内的豆荚概览(图片来源:<a class="ae kv" href="https://asksendai.com/category/algorithm/" rel="noopener ugc nofollow" target="_blank">https://asksendai.com/category/algorithm/</a>)</p></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ea5c" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">创建一个Pod</h1><h2 id="d6a6" class="og mb iq bd mc oh oi dn mg oj ok dp mk lf ol om mm lj on oo mo ln op oq mq or bi translated">使用命令行</h2><p id="ed73" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">下面是一个使用命令行创建Pod的示例。在现实世界中，不推荐使用命令创建Pod。</p><pre class="kg kh ki kj gt os oe ot ou aw ov bi"><span id="078f" class="og mb iq oe b gy ow ox l oy oz">kubectl run mypod --port=8080 --image=pasciano007/sample:1.0 --generator=run-pod/v1</span></pre><h2 id="2548" class="og mb iq bd mc oh oi dn mg oj ok dp mk lf ol om mm lj on oo mo ln op oq mq or bi translated">使用规范文件</h2><p id="7df2" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这是在现实世界中用来创造一个Kubernetes豆荚。让我们看一个简单的规范YAML文件的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Pod规格YAML文件</p></figure><ul class=""><li id="e873" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated"><code class="fe ob oc od oe b">apiVersion</code>:这是API服务器的版本，如架构概述部分所讨论的。</li><li id="bcfd" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><code class="fe ob oc od oe b">kind</code>:这是定义我们想要创建的资源类型的重要键。在这种情况下，它是一个豆荚。</li><li id="3022" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><code class="fe ob oc od oe b">metadata</code>:这增加了一些关于Pod的附加信息，比如Pod的名称。</li><li id="7ce5" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><code class="fe ob oc od oe b">spec</code>:该键定义需要如何创建、管理或控制Pod。</li><li id="c029" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><code class="fe ob oc od oe b">containers</code>:这个键列出了将在Pod中创建的所有容器。</li><li id="b214" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><code class="fe ob oc od oe b">image</code>:定义用于创建容器的图像。</li></ul><p id="aa5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要运行上述Pod规范YAML文件，我们使用以下命令，该命令创建或更新集群中的资源:</p><pre class="kg kh ki kj gt os oe ot ou aw ov bi"><span id="4f90" class="og mb iq oe b gy ow ox l oy oz">kubectl apply -f filename.yml</span></pre><p id="61f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在接下来的小节中，将只使用规范文件来创建资源，因为这是最好的方法，并且可以使用相同的命令来运行所有传入的规范文件。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="700c" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">什么是部署？</h1><p id="bed2" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在Kubernetes中，部署是部署我们服务的最佳方式，因为它具有一些很棒的内置功能，如:</p><ul class=""><li id="d143" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated">轻松部署副本</li><li id="b61f" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">更新窗格</li><li id="3fab" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">回滚到以前的部署版本</li><li id="05b0" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">规模部署</li><li id="a746" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">暂停和恢复部署</li><li id="c357" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">清理不再需要的旧副本</li><li id="eacc" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">还有更多…</li></ul><p id="00f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个使用带有三个副本的部署规范文件部署应用程序的示例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">部署规范YAML文件</p></figure><p id="2ec5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在Pod创建中看到的一些键在这里有相同的含义。</p><ul class=""><li id="6866" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated"><code class="fe ob oc od oe b">kind</code>:和Pods一样，是定义资源类型的重要键。在这种情况下，它是一个部署。</li><li id="0ac1" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><code class="fe ob oc od oe b">replicas</code>:定义将要创建并分布到所有集群节点的pod的数量</li><li id="ab36" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><code class="fe ob oc od oe b">template</code>:定义吊舱规格</li><li id="005a" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><code class="fe ob oc od oe b">matchLabels</code>:选择将由副本管理的pod</li><li id="3fa3" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><code class="fe ob oc od oe b">containerPort</code>:集装箱将暴露的港口</li><li id="8373" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><code class="fe ob oc od oe b">labels</code>:键值对定义了Pod的标签。该标签将被<code class="fe ob oc od oe b">matchLabels</code>用来选择该Pod，并将副本仅应用于带有该标签的Pod。</li></ul></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="403b" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">与Kubernetes服务联网</h1><p id="47f8" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><em class="pc">服务</em>在Kubernetes的世界里有着不同的含义。在Kubernetes中，服务为集群中的一个或多个pod提供网络连接。</p><p id="e5d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建服务时，它有一个唯一的IP地址。然后，Pods可以使用IP地址或服务名称进行通信。</p><p id="024e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kubernetes服务有四种类型:</p><h2 id="6b93" class="og mb iq bd mc oh oi dn mg oj ok dp mk lf ol om mm lj on oo mo ln op oq mq or bi translated"><code class="fe ob oc od oe b">ClusterIP</code></h2><p id="678b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这是公开的默认服务类型，它只允许集群内的通信。</p><p id="7528" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个<code class="fe ob oc od oe b">ClusterIP</code>服务类型规范文件的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">集群IP规范YAML文件</p></figure><ul class=""><li id="5f25" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated"><code class="fe ob oc od oe b">port</code>:定义服务的端口</li><li id="ee8c" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><code class="fe ob oc od oe b">targetPort</code>:定义pod的端口</li></ul><p id="059f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，节点内的pod可以使用服务的IP地址和端口或者使用服务名(web)和端口进行通信。</p><h2 id="8c32" class="og mb iq bd mc oh oi dn mg oj ok dp mk lf ol om mm lj on oo mo ln op oq mq or bi translated">节点端口</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/019b2f39eee963f8dcf8fe71088396ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E5k05KMRqOfLBHBT1MaGjA.png"/></div></div></figure><p id="03df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该服务允许使用节点的IP地址与群集通信。一个<code class="fe ob oc od oe b">ClusterIP</code>服务被自动创建，并且<code class="fe ob oc od oe b">NodePort</code>服务将路由到它。从集群外部，您可以使用<code class="fe ob oc od oe b">NodeIP:NodePort</code> <strong class="ky ir">访问<code class="fe ob oc od oe b">NodePort</code>服务。</strong></p><p id="4283" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个<code class="fe ob oc od oe b">NodePort</code>服务类型规范文件的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">节点端口服务规范YAML文件</p></figure><ul class=""><li id="b410" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated"><code class="fe ob oc od oe b">port</code>:定义集群内部的服务(<code class="fe ob oc od oe b">ClusterIP</code>)</li><li id="c264" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><code class="fe ob oc od oe b">targetPort</code>:定义Pod的端口</li><li id="cd11" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated"><code class="fe ob oc od oe b">nodePort</code>:定义节点的端口</li></ul><p id="42dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事情就是这样运作的。假设我们有一个应用程序部署使用这项服务。例如，当我们键入<code class="fe ob oc od oe b">localhost:3000</code> ( <code class="fe ob oc od oe b">nodePort</code>)时，流量将被路由到端口8080 ( <code class="fe ob oc od oe b">port</code>)上的服务，该服务又将流量路由到端口8080 ( <code class="fe ob oc od oe b">targetPort</code>)上的容器。</p><h2 id="896e" class="og mb iq bd mc oh oi dn mg oj ok dp mk lf ol om mm lj on oo mo ln op oq mq or bi translated">负载平衡器</h2><p id="9046" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">该服务向您的云提供商公开负载平衡器。负载平衡器将流量路由到自动创建的<code class="fe ob oc od oe b">NodePort</code>和<code class="fe ob oc od oe b">ClusterIP</code>。</p><h2 id="78d3" class="og mb iq bd mc oh oi dn mg oj ok dp mk lf ol om mm lj on oo mo ln op oq mq or bi translated">外部名称</h2><p id="5eff" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这种类型将服务映射到<code class="fe ob oc od oe b">externalName</code>字段的内容(例如my.domain.com)。</p><p id="1aa2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解有关不同服务的更多信息，请参考<a class="ae kv" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="74e3" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">使用ConfigMap的应用程序配置</h1><p id="0d19" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">根据官方文件，</p><blockquote class="mx"><p id="c68a" class="my mz iq bd na nb nc nd ne nf ng lr dk translated">"配置映射允许你将配置工件从图像内容中分离出来，以保持容器化的应用程序的可移植性."</p></blockquote><p id="8cc5" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">换句话说，ConfigMap存储代码的配置设置。在ConfigMap中存储连接字符串、环境变量、公共凭证、主机名和URL，这些值由Kubernetes提供给容器。</p><p id="d4a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个配置映射规范文件的例子，它设置了使用<a class="ae kv" href="https://hub.docker.com/_/postgres" rel="noopener ugc nofollow" target="_blank"> Postgres图像</a>所需的Postgres关系数据库环境变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">配置映射规范YAML文件</p></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="dbaa" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="a8bf" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在本文中，我们学习了一些学习Kubernetes时必须知道的概念。在接下来的教程中，我们将在现实世界中使用这些概念。</p><p id="7ed4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在那之前，请保持关注，注意安全。</p></div></div>    
</body>
</html>