<html>
<head>
<title>Demystifying Look-Ahead and Look-Behind in Regex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开正则表达式中前瞻和后视的神秘面纱</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/demystifying-look-ahead-and-look-behind-in-regex-4a604f99fb8c?source=collection_archive---------3-----------------------#2022-04-01">https://betterprogramming.pub/demystifying-look-ahead-and-look-behind-in-regex-4a604f99fb8c?source=collection_archive---------3-----------------------#2022-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="85b3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用易于理解的示例和动画gif简化正则表达式中的前视和后视</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/40c6531f014ab06560d94993de171471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/0*1TILHRsIsXjrnoZh.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片由<a class="ae ku" href="https://xkcd.com/" rel="noopener ugc nofollow" target="_blank">https://xkcd.com/</a></p></figure><p id="bac6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正则表达式(Regex)中的一个概念是look-arounds——它由前视和后视组成，我一直觉得难以理解。</p><p id="e7e3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">虽然网上有大量的文章和教程解释这个概念，但很少有人用容易理解的方式来解释，至少我不满意。许多人使用诸如“消费群体”、“零宽度断言”等术语。，对正在学习这个高级话题的人没有什么帮助。</p><p id="1624" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">此外，在如何解释环视的名称方面缺乏明确性。例如，对于后视，相对于什么是“后面”?我们在“寻找”什么？前瞻也是如此。似乎它们还不够令人困惑，每种类型的环视都有两个子类型——积极的和消极的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/9c157c3d8ed096285080366e00efd701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*tFo7wfLbMvZWGW5M.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片由https://xkcd.com/的<a class="ae ku" href="https://xkcd.com/" rel="noopener ugc nofollow" target="_blank">提供</a></p></figure><p id="9e55" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这篇文章中，我试图一劳永逸地揭开前瞻和后顾概念的神秘面纱。我将避免技术术语，而是用简单的术语解释，并辅以动画gif。</p><p id="334a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="ls">附言:为了更好地浏览gif动画，我建议使用桌面网络浏览器。</em></p><p id="7509" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我的解释将与编程语言无关，尽管我的代码片段将使用Python。希望这篇文章对你有用。我们开始吧！</p><p id="6c4b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="ls">本文展示的代码片段和动画gif可以在这个</em><a class="ae ku" href="https://github.com/zeyalt/My-Articles/tree/master/Python%20Tips/Demystifying%20Look-ahead%20and%20Look-behind%20in%20Regular%20Expressions" rel="noopener ugc nofollow" target="_blank"><em class="ls">GitHub repo</em></a><em class="ls">找到。</em></p><h1 id="82dc" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">1.正则表达式查找入门</h1><p id="34ec" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">在我们深入探讨之前，让我们首先获得一些高层次的直觉，了解环视试图实现什么以及它们是如何工作的。让我们做一个简单的类比。</p><p id="f3c7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">假设你是另一个国家的游客，你想参观当地的博物馆。你在步行，你迷路了。你向路人问路去博物馆。他们告诉你，“一直往前走，一旦你看到你左边的法国咖啡馆，你就会看到博物馆。”你跟着他们的指示走，瞧，你就找到博物馆了！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/a893651acf71e0260bb2acc4b8641b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YBH7CvNHyHx7FgNQ"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">由<a class="ae ku" href="https://unsplash.com/@paramir?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃胡德·纽豪斯</a>在<a class="ae ku" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f045" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这里，你成功地找到了博物馆，因为你得到了一个路标(“法国咖啡馆”)，行走的方向(“直走”)，以及相对于运动方向在哪里找到路标(“在你的左边”)。环视以类似的方式工作——不是走过建筑物，而是“穿行”文本字符串。</p><p id="d8ee" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在look-around中，您正在查找文本字符串的某些部分。要找到它/他们，你需要知道“地标”(也称为<strong class="kx iu">模式</strong>)，以及在哪里找到地标(要么是之前的<strong class="kx iu">，要么是</strong>模式之后的<strong class="kx iu">)。</strong></p><p id="5c7b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">“行走”的方向是固定的，因为文本字符串是从左向右读的，至少在英语中是这样。一旦该模式存在于文本字符串中，就会找到一个与匹配的<strong class="kx iu">。</strong></p><h1 id="d910" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">2.我们的示例文本</h1><p id="6840" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">为了保持有趣，我将引用蜘蛛侠电影中的一段话来解释回望的概念:</p><blockquote class="mv"><p id="c6d5" class="mw mx it bd my mz na nb nc nd ne lq dk translated">“权力越大，责任越大。”</p></blockquote><figure class="ng nh ni nj nk kn gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nf"><img src="../Images/24c1897314a2e8a75cece192aa1f35a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wY9NmaNBJM2pjn2o"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://unsplash.com/@roadtripwithraj?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">公路旅行照片，Raj </a>在<a class="ae ku" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上</p></figure><h1 id="8d7a" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">3.向前看</h1><p id="0659" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">前瞻是一种环视类型，其中模式出现在所需匹配的前面。我们“向前看”以查看某个文本字符串前面是否有特定的模式。如果是，那么该文本字符串是匹配的。</p><h2 id="31d1" class="nl lu it bd lv nm nn dn lz no np dp md le nq nr mf li ns nt mh lm nu nv mj nw bi translated">3.1.积极的前瞻</h2><p id="8d5c" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">在正向预测中，您希望找到一个后面有表达式<code class="fe nx ny nz oa b">B</code>(即模式)的表达式<code class="fe nx ny nz oa b">A</code>。它的语法是<code class="fe nx ny nz oa b">A(?=B)</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ob"><img src="../Images/f91d8316c4335ab5db2e0fc069b0650a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1LR9Wy207F7jkueh4GyHyg.gif"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图1:积极前瞻的定义(作者提供的GIF)</p></figure><p id="c461" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们用示例文本来说明这一点。假设您想要找到任何一个后面带有模式<code class="fe nx ny nz oa b">" great"</code>的完整单词。因为这是我们在本文中的第一个例子，所以让我们把它分解并一步一步地走完…非常准确地说。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oc"><img src="../Images/c81fb95b89ebfa4221ac46b5706c7599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XYM8ipBIogh-Xe8rNkVK0A.gif"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图2:正面前瞻示例(作者提供的GIF)</p></figure><p id="24fa" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">想象你是图2中的动画行走人。您首先站在示例文本的开头。然后，您开始一个字符一个字符地向文本的末尾移动。</p><p id="c35e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当你行走时，你总是向前看寻找“地标”，在这种情况下，那就是模式<code class="fe nx ny nz oa b">" great"</code>。</p><p id="7e4a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">每次你在一个完整的单词后面找到<code class="fe nx ny nz oa b">" great"</code>，这个单词就是一个匹配。</p><p id="5eab" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这种情况下，成功的匹配是<code class="fe nx ny nz oa b">"With"</code>和<code class="fe nx ny nz oa b">"comes"</code>。Python中相应的代码片段如下:</p><pre class="kj kk kl km gt od oa oe of aw og bi"><span id="3055" class="nl lu it oa b gy oh oi l oj ok">&gt;&gt;&gt; import re</span><span id="320f" class="nl lu it oa b gy ol oi l oj ok">&gt;&gt;&gt; text = "With great power comes great responsibility."<br/>&gt;&gt;&gt; pattern = r'\b\w+\b(?= great)'<br/>&gt;&gt;&gt; matches = re.finditer(pattern, text)<br/>&gt;&gt;&gt; for match in matches:<br/>...     print(f'Match: "{match.group()}" =&gt; Span: {match.span()}')</span><span id="e6e6" class="nl lu it oa b gy ol oi l oj ok"><br/>Match: "With" =&gt; Span: (0, 4)<br/>Match: "comes" =&gt; Span: (17, 22)</span></pre><h2 id="5dfb" class="nl lu it bd lv nm nn dn lz no np dp md le nq nr mf li ns nt mh lm nu nv mj nw bi translated">3.2.消极前瞻</h2><p id="1550" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">另一方面，消极的前瞻是当你想找到一个后面没有表达式<code class="fe nx ny nz oa b">B</code>(即模式)的表达式<code class="fe nx ny nz oa b">A</code>时。它的语法是:<code class="fe nx ny nz oa b">A(?!B)</code>。在某种程度上，这与积极的前瞻相反。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi om"><img src="../Images/0d8caf4b48a67d036f2deae6b6be97fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5Zw8Cefb3HICXEE9OB2NEw.gif"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图3:消极前瞻的定义(作者提供的GIF)</p></figure><p id="7217" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，假设您想要查找任何后面没有模式<code class="fe nx ny nz oa b">" great"</code>的完整单词。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi on"><img src="../Images/c29d9a28a327850354e3ba370a8a0508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1qfXtKaElUgpWSLuzqBH2g.gif"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图4:消极前瞻示例(作者提供的GIF)</p></figure><p id="07e8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这一次，您将向前查找任何后面没有模式<code class="fe nx ny nz oa b">" great"</code>的单词。</p><ul class=""><li id="2b33" class="oo op it kx b ky kz lb lc le oq li or lm os lq ot ou ov ow bi translated">第一个单词<code class="fe nx ny nz oa b">"With"</code>，后面有<code class="fe nx ny nz oa b">" great"</code>，所以不匹配。</li><li id="2a99" class="oo op it kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">下一个单词<code class="fe nx ny nz oa b">"great"</code>后面没有<code class="fe nx ny nz oa b">" great"</code>，所以是匹配。</li><li id="b22c" class="oo op it kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">第三个字，<code class="fe nx ny nz oa b">"power"</code>，后面也没有<code class="fe nx ny nz oa b">" great"</code>，所以是匹配。</li><li id="ce9b" class="oo op it kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">这种情况一直持续到字符串的末尾。因此，成功的匹配是<code class="fe nx ny nz oa b">"great"</code>、<code class="fe nx ny nz oa b">"power"</code>、<code class="fe nx ny nz oa b">"great"</code>和<code class="fe nx ny nz oa b">"responsibility"</code>。</li></ul><p id="9a25" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们看看代码:</p><pre class="kj kk kl km gt od oa oe of aw og bi"><span id="b8db" class="nl lu it oa b gy oh oi l oj ok">&gt;&gt;&gt; text = "With great power comes great responsibility."<br/>&gt;&gt;&gt; pattern = r'\b\w+\b(?! great)'<br/>&gt;&gt;&gt; matches = re.finditer(pattern, text)<br/>&gt;&gt;&gt; for match in matches:<br/>...     print(f'Match: "{match.group()}" =&gt; Span: {match.span()}')</span><span id="ef2b" class="nl lu it oa b gy ol oi l oj ok"><br/>Match: "great" =&gt; Span: (5, 10)<br/>Match: "power" =&gt; Span: (11, 16)<br/>Match: "great" =&gt; Span: (23, 28)<br/>Match: "responsibility" =&gt; Span: (29, 43)</span></pre><h1 id="8806" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">4.向后看</h1><p id="3f8c" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">现在让我们把注意力转向后顾。与前瞻不同，后视用于模式出现在所需匹配之前的情况。您正在“向后看”以查看某个文本字符串背后是否有想要的模式。如果是，那么该文本字符串是匹配的。</p><h2 id="d9d2" class="nl lu it bd lv nm nn dn lz no np dp md le nq nr mf li ns nt mh lm nu nv mj nw bi translated">4.1.积极的回顾</h2><p id="f2b3" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">在正面回顾中，您希望找到前面有表达式<code class="fe nx ny nz oa b">B</code>(即模式)的表达式<code class="fe nx ny nz oa b">A</code>。它的语法是<code class="fe nx ny nz oa b">(?&lt;=B)A</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pc"><img src="../Images/6571b1d68b0305c4f41e91de6e05005d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Hyq_QfSgK7dMI2jW2TsMTQ.gif"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图5:正面回顾的定义(作者的动画GIF)</p></figure><p id="8dbe" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们通过示例文本更好地理解这一点。假设您现在想要查找任何前面有模式<code class="fe nx ny nz oa b">"great "</code>的完整单词。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pd"><img src="../Images/1a732bd33cdea38730783ff8f100792a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xvquZSCiO_JsIUp2UGQwPA.gif"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图6:正面回顾示例(作者制作的动画GIF)</p></figure><p id="1b29" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">再一次，您从文本字符串的开头走到结尾。现在的区别是，你走路的时候“转身”是为了“向后看”，而不是只看前方。请注意，图6中的动画人总是把头转来转去！</p><p id="6658" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">您“向后看”以找到任何前面有模式<code class="fe nx ny nz oa b">"great "</code>的单词。</p><ul class=""><li id="b808" class="oo op it kx b ky kz lb lc le oq li or lm os lq ot ou ov ow bi translated">第一个单词<code class="fe nx ny nz oa b">"With"</code>前面没有字符，因此不匹配。</li><li id="fdbb" class="oo op it kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">第二个单词<code class="fe nx ny nz oa b">"great"</code>前面有<code class="fe nx ny nz oa b">"With "</code>，不匹配。</li><li id="c5fa" class="oo op it kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">第三个单词<code class="fe nx ny nz oa b">"power"</code>前面有<code class="fe nx ny nz oa b">"great "</code>并且是匹配的。</li><li id="75bc" class="oo op it kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">最后，成功匹配的是<code class="fe nx ny nz oa b">"power"</code>和<code class="fe nx ny nz oa b">"responsibility"</code>。下面是代码片段:</li></ul><pre class="kj kk kl km gt od oa oe of aw og bi"><span id="c095" class="nl lu it oa b gy oh oi l oj ok">&gt;&gt;&gt; text = "With great power comes great responsibility."<br/>&gt;&gt;&gt; pattern = r'(?&lt;=great )\b\w+\b'<br/>&gt;&gt;&gt; matches = re.finditer(pattern, text)<br/>&gt;&gt;&gt; for match in matches:<br/>...     print(f'Match: "{match.group()}" =&gt; Span: {match.span()}')</span><span id="8001" class="nl lu it oa b gy ol oi l oj ok"><br/>Match: "power" =&gt; Span: (11, 16)<br/>Match: "responsibility" =&gt; Span: (29, 43)</span></pre><h2 id="c794" class="nl lu it bd lv nm nn dn lz no np dp md le nq nr mf li ns nt mh lm nu nv mj nw bi translated">4.2.消极的回顾</h2><p id="8b47" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">最后，在消极回顾中，您感兴趣的是找到一个前面没有表达式<code class="fe nx ny nz oa b">B </code>(即模式)的表达式<code class="fe nx ny nz oa b">A</code>。它的语法是:<code class="fe nx ny nz oa b">(?&lt;!B)A</code>。这与积极的回顾相反。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pd"><img src="../Images/5ab701f63238d5ab76db8cefcd3e613c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DzOpy6KAWsKHeUhRFPHI4g.gif"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图7:负面回顾的定义(作者的动画GIF)</p></figure><p id="b6d4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，假设您想要在我们的示例文本字符串中找到前面没有模式<code class="fe nx ny nz oa b">"great "</code>的任何完整单词。这一次，当您从字符串的开头走到结尾时，您正在“向后看”前面没有<code class="fe nx ny nz oa b">"great "</code>的单词。</p><p id="8d91" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">通过类似的“遍历”过程，您发现成功的匹配是<code class="fe nx ny nz oa b">"With"</code>、<code class="fe nx ny nz oa b">"great"</code>、<code class="fe nx ny nz oa b">"comes"</code>和<code class="fe nx ny nz oa b">"great"</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pe"><img src="../Images/452d9c58b041a62f477f2556adf60d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gIhVTCMPP2MlMOjar_45cw.gif"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图8:负面回顾示例(作者的动画GIF)</p></figure><p id="cca8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">代码如下:</p><pre class="kj kk kl km gt od oa oe of aw og bi"><span id="3445" class="nl lu it oa b gy oh oi l oj ok">&gt;&gt;&gt; text = "With great power comes great responsibility."<br/>&gt;&gt;&gt; pattern = r'(?&lt;!great )\b\w+\b'<br/>&gt;&gt;&gt; matches = re.finditer(pattern, text)<br/>&gt;&gt;&gt; for match in matches:<br/>...     print(f'Match: "{match.group()}" =&gt; Span: {match.span()}')</span><span id="4caa" class="nl lu it oa b gy ol oi l oj ok"><br/>Match: "With" =&gt; Span: (0, 4)<br/>Match: "great" =&gt; Span: (5, 10)<br/>Match: "comes" =&gt; Span: (17, 22)<br/>Match: "great" =&gt; Span: (23, 28)</span></pre><h1 id="1965" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">5.结合前视和后视</h1><p id="3d79" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">您可能会遇到这样的情况:您希望在一个文本字符串中查找在一个模式之后开始、在另一个模式之前结束的匹配项。在这种情况下，您可以将向前看和向后看结合起来。</p><p id="6c5d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">例如，如果您想在示例文本中查找两个“great”单词之间的任何字符，您可以通过以下方式组合一个正面回顾<code class="fe nx ny nz oa b">(?&lt;=great).*</code>和一个正面前瞻<code class="fe nx ny nz oa b">.*(?=great)</code>:</p><pre class="kj kk kl km gt od oa oe of aw og bi"><span id="68d3" class="nl lu it oa b gy oh oi l oj ok">&gt;&gt;&gt; text = "With great power comes great responsibility."<br/>&gt;&gt;&gt; pattern = r'(?&lt;=great).*(?=great)'<br/>&gt;&gt;&gt; matches = re.finditer(pattern, text)<br/>&gt;&gt;&gt; for match in matches:<br/>...     print(f'Match: "{match.group()}" =&gt; Span: {match.span()}')</span><span id="af7f" class="nl lu it oa b gy ol oi l oj ok"><br/>Match: " power comes " =&gt; Span: (10, 23)</span></pre><h1 id="9748" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">6.包装它</h1><p id="eb35" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">我们缩小一点，在你走之前把东西收拾好。我们已经讨论了Regex中四种类型的查找。这里有一个备忘单，总结了它们的定义和语法。请随意保存一份副本以供将来参考。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pf"><img src="../Images/2006a62c73be9947423a4f846e96e21a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PRRHGdN32Mep-3KhLwvKzw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图9:Regex Look-around的备忘单(图片由作者提供)</p></figure><p id="b4a2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">以下是一些需要注意的观察，以进一步巩固你的理解:</p><ul class=""><li id="b989" class="oo op it kx b ky kz lb lc le oq li or lm os lq ot ou ov ow bi translated">两种类型的肯定回看的语法与等号相关联，<code class="fe nx ny nz oa b">=</code></li><li id="a48f" class="oo op it kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">两种否定回望的语法都与一个感叹号<code class="fe nx ny nz oa b">!</code>相关联</li><li id="b37a" class="oo op it kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">前瞻与介词“after”相关联——寻找一个在它之后有特定模式的匹配</li><li id="e1e9" class="oo op it kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">Look-behinds与介词“before”相关联，即寻找前面有特定模式的匹配。</li></ul><h1 id="be9a" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">7.结论</h1><p id="7bb8" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">恭喜你！我希望这篇文章能够帮助您更好地理解Regex中的look-around。如果你仍然难以理解这些概念，不要担心——它们一开始就令人困惑。请随意收藏这篇文章，如果您需要复习，请回到这里。</p><p id="d919" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我的解释也很简单，使用了通俗易懂的语言，但是如果你需要让你的理解更上一层楼，这里有一些资源你应该看看:</p><ul class=""><li id="a1b2" class="oo op it kx b ky kz lb lc le oq li or lm os lq ot ou ov ow bi translated"><a class="ae ku" href="https://www.rexegg.com/regex-lookarounds.html" rel="noopener ugc nofollow" target="_blank">控制前视和后视</a></li><li id="a16a" class="oo op it kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated"><a class="ae ku" href="https://youtu.be/xQoP_rNmPvI" rel="noopener ugc nofollow" target="_blank">Python Regex:look arounds【YouTube】</a></li><li id="9a3e" class="oo op it kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated"><a class="ae ku" href="https://www.regular-expressions.info/lookaround.html" rel="noopener ugc nofollow" target="_blank">前视和后视零长度断言</a></li></ul><p id="a35b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">暂时就这样了。祝您愉快！</p><pre class="kj kk kl km gt od oa oe of aw og bi"><span id="f61d" class="nl lu it oa b gy oh oi l oj ok"><strong class="oa iu">Let's connect!</strong></span><span id="aa20" class="nl lu it oa b gy ol oi l oj ok">Reach out to me via <a class="ae ku" href="https://www.linkedin.com/in/zeyalt/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a> or <a class="ae ku" href="https://twitter.com/zeyalt_" rel="noopener ugc nofollow" target="_blank">Twitter</a>.</span></pre></div></div>    
</body>
</html>