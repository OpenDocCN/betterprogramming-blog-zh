<html>
<head>
<title>How to Make a Dynamic SwiftUI TabView With Badges</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何制作带有徽章的动态SwiftUI标签视图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-make-a-dynamic-tabview-with-badges-7f4fc3b31801?source=collection_archive---------17-----------------------#2022-01-24">https://betterprogramming.pub/how-to-make-a-dynamic-tabview-with-badges-7f4fc3b31801?source=collection_archive---------17-----------------------#2022-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d56f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何将badge(_:)修饰符应用于TabView并动态驱动选项卡项目内容的分步说明</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e5c3648499db39b710f5ca9ac9f756e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*owfo2E1zzC7sdBwd"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="kv">照片由390097发自</em> <a class="ae kw" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank"> <em class="kv"> Pixabay </em> </a></p></figure><p id="b475" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">有许多文章指导开发人员如何使用静态内容应用<code class="fe lt lu lv lw b">badge(_:)</code>修饰符。然而，没有一个演示如何实际使用动态内容的徽章。</p><h1 id="1701" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">徽章修饰词的一般用法</h1><p id="e44d" class="pw-post-body-paragraph kx ky iq kz b la mp jr lc ld mq ju lf lg mr li lj lk ms lm ln lo mt lq lr ls ij bi translated">徽章对于iOS开发者来说并不是一个新概念。然而，随着SwiftUI在2021年WWDC的第三次发布，实现变得更加容易，苹果在该发布中引入了新的徽章API，提供了原生支持。</p><p id="a64b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">SwiftUI的<code class="fe lt lu lv lw b">badge(_:)</code>修饰符有助于向用户传达相关信息，比如未读消息、电子邮件和其他通知。</p><p id="ce3c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">例如，可以使用<code class="fe lt lu lv lw b">badge(_:)</code>修饰符在选项卡项目上显示硬编码的Int:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/34f2422493d3438abca6df83d343c2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*ttn4jtht5yg4LNnu"/></div></figure><p id="e0ba" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">字符串也可以用作参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/d9b73ca7fea6564d1c2b182d1bc58838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/0*hud2CSmtFEu5xJj1"/></div></figure><p id="9e36" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然而，静态内容不适合或不适合用于通知用户重要更改或更新的选项卡项目。</p><h1 id="f85a" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">动态徽章</h1><p id="17db" class="pw-post-body-paragraph kx ky iq kz b la mp jr lc ld mq ju lf lg mr li lj lk ms lm ln lo mt lq lr ls ij bi translated">这就需要实现额外的代码来显示动态通知。为了使选项卡视图项目能够在我们的视图上呈现动态内容，我们将构建一个基本的消息应用程序。我们将通过创建以下内容来公布一条消息被喜欢的次数:</p><h2 id="03a2" class="my ly iq bd lz mz na dn md nb nc dp mh lg nd ne mj lk nf ng ml lo nh ni mn nj bi translated"><strong class="ak"> 1。型号</strong></h2><p id="e031" class="pw-post-body-paragraph kx ky iq kz b la mp jr lc ld mq ju lf lg mr li lj lk ms lm ln lo mt lq lr ls ij bi translated">遵循模型-视图-视图模型(MVVM)设计模式，我们的模型将保存消息数据。模型不包含任何逻辑，因为它仅用于表示视图模型所使用的数据结构。</p><h2 id="701e" class="my ly iq bd lz mz na dn md nb nc dp mh lg nd ne mj lk nf ng ml lo nh ni mn nj bi translated"><strong class="ak"> 2。查看模型</strong></h2><p id="0feb" class="pw-post-body-paragraph kx ky iq kz b la mp jr lc ld mq ju lf lg mr li lj lk ms lm ln lo mt lq lr ls ij bi translated">ViewModel负责模型数据，并将这些数据传递给视图。我们的MessageViewModel将管理消息数据。</p><h2 id="b760" class="my ly iq bd lz mz na dn md nb nc dp mh lg nd ne mj lk nf ng ml lo nh ni mn nj bi translated"><strong class="ak"> 3。状态变量</strong></h2><p id="3aae" class="pw-post-body-paragraph kx ky iq kz b la mp jr lc ld mq ju lf lg mr li lj lk ms lm ln lo mt lq lr ls ij bi translated">状态属性包装器存储属性类型，并根据其值的任何变化重新计算视图。在我们的<code class="fe lt lu lv lw b">MessageTabView</code>结构中，我们创建了一个<code class="fe lt lu lv lw b">likeCountBadge</code>属性来显示点击like按钮的次数。</p><h1 id="8b6f" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">模型</h1><p id="cb8d" class="pw-post-body-paragraph kx ky iq kz b la mp jr lc ld mq ju lf lg mr li lj lk ms lm ln lo mt lq lr ls ij bi translated">首先，让我们定义一个新的Swift类型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="172b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个结构只是保存我们的消息数据，特别是点击like按钮的次数。</p><h1 id="5a00" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">视图模型</h1><p id="60f1" class="pw-post-body-paragraph kx ky iq kz b la mp jr lc ld mq ju lf lg mr li lj lk ms lm ln lo mt lq lr ls ij bi translated">接下来，我们将创建一个<code class="fe lt lu lv lw b">MessageViewModel</code>来管理我们的数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="28b8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们的类符合<code class="fe lt lu lv lw b">ObservableObject</code>协议。该协议确保当任何发布的改变发生时，用户界面被更新。</p><p id="5f7b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们需要<code class="fe lt lu lv lw b">ViewModel</code>来监控并通知我们赞数的变化。因此，我们使用<code class="fe lt lu lv lw b">@Published</code>属性包装器创建了一个<code class="fe lt lu lv lw b">Message(messageText:likeCount:)</code>的实例。当更新和检索<code class="fe lt lu lv lw b">likeCount</code>的值时，这个消息实例分别由<code class="fe lt lu lv lw b">addOneLike()</code>和<code class="fe lt lu lv lw b">fetchLikes()</code>函数调用。</p><p id="9ea3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">可以向代码库添加额外的功能来执行进一步的任务，例如重置<code class="fe lt lu lv lw b">likeCount</code>值、更改消息等。</p><h1 id="c0eb" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">视角</h1><p id="e8df" class="pw-post-body-paragraph kx ky iq kz b la mp jr lc ld mq ju lf lg mr li lj lk ms lm ln lo mt lq lr ls ij bi translated">首先，让我们创建一个视图来显示我们的只读消息和一个按钮。通过创建这个独特的视图结构，我们不仅降低了<code class="fe lt lu lv lw b">MessageTabView</code>(接下来将讨论)的复杂性，而且使为预览窗口重新编译我们的内容和隔离我们的更改的影响变得更加容易。</p><p id="7bc1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这个视图中，每次点击“Like”按钮，这个动作都会触发<code class="fe lt lu lv lw b">addOneLike()</code>功能。我们需要将<code class="fe lt lu lv lw b">MessageViewModel</code>作为<code class="fe lt lu lv lw b">@EnvironmentObject</code>传入，以便访问它的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="041b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在我们已经创建了一个视图来显示我们的消息和按钮，我们可以修改前面给出的<code class="fe lt lu lv lw b">TabView</code>。</p><p id="3e8f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们新改进的<code class="fe lt lu lv lw b">MessageTabView</code>会在每次赞数有变化时更新。</p><p id="2a66" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们将添加我们的<code class="fe lt lu lv lw b">MessageButtonView</code>作为下面的选项卡项目:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="f282" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您会注意到我们为了实现动态徽章而对最初的<code class="fe lt lu lv lw b">TabView</code>做了一些修改。</p><ol class=""><li id="b938" class="nk nl iq kz b la lb ld le lg nm lk nn lo no ls np nq nr ns bi translated"><code class="fe lt lu lv lw b">@State</code>属性包装器——为了跟踪<code class="fe lt lu lv lw b">likeCountBadge</code>的状态，我们使用了<code class="fe lt lu lv lw b">@State</code>属性包装器。每次更新属性时，视图都会相应地更新。</li><li id="e2e9" class="nk nl iq kz b la nt ld nu lg nv lk nw lo nx ls np nq nr ns bi translated"><code class="fe lt lu lv lw b">@EnvironmentObject</code>属性包装器——这个包装器让我们可以访问ViewModel函数，也就是到目前为止记录的点赞数。</li><li id="53a2" class="nk nl iq kz b la nt ld nu lg nv lk nw lo nx ls np nq nr ns bi translated"><code class="fe lt lu lv lw b">onChange(of:perform:)</code> —这个修饰符的作用类似于属性观察器，当属性的状态改变时，它执行代码。这里，我们想在每次点击Like“Like”按钮时更新我们的<code class="fe lt lu lv lw b">likeCountBadge</code>属性。</li></ol><h1 id="314f" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">包扎</h1><p id="0439" class="pw-post-body-paragraph kx ky iq kz b la mp jr lc ld mq ju lf lg mr li lj lk ms lm ln lo mt lq lr ls ij bi translated">现在，您可以通过使用MVVM方法、SwiftUI属性包装器和应用视图修饰符，向您的选项卡栏项目添加动态标记，从而使您的用户保持最新。</p><p id="1d00" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">从我的GitHub库下载完整的源代码:<a class="ae kw" href="https://github.com/codingcartooningcpa/BadgeTutorial" rel="noopener ugc nofollow" target="_blank">https://github.com/codingcartooningcpa/BadgeTutorial</a></p><p id="936e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>