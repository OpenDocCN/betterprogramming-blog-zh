<html>
<head>
<title>Gaudí for iOS: Theming and Dark Mode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS版高迪:主题化和黑暗模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/gaud%C3%AD-for-ios-theming-and-dark-mode-86fe8fe60aeb?source=collection_archive---------9-----------------------#2020-01-10">https://betterprogramming.pub/gaud%C3%AD-for-ios-theming-and-dark-mode-86fe8fe60aeb?source=collection_archive---------9-----------------------#2020-01-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fca9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">iOS的简单主题管理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/24d9f06d6fec76e87cc621a94f710909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qyg4UtjiPSVOnZg7OeGqxw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@davidpisnoy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> David Pisnoy </a>在<a class="ae ky" href="https://unsplash.com/s/photos/paint?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9d33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/gringoireDM/Gaudi" rel="noopener ugc nofollow" target="_blank"> Gaudí </a>是一个为简化在同一个应用中采用多个主题而编写的框架。</p><p id="9eb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几年前，我在一家电子商务公司工作，有多个横幅来支持一个绿地项目。每个横幅都有不同的配色方案、不同的字体和不同的组件样式。</p><p id="c44f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个UI组件都不应该知道横幅的存在，否则添加/删除横幅会导致所有应用程序发生变化，这显然违反了多个坚实的原则。</p><p id="7938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，重塑一个应用程序通常需要很多改变，并且用旧的主题来测试新的主题需要更大的努力。</p><p id="d95e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然您可以轻松地抽象样式，但根据A/B测试的不同，在运行时构建一个重新设计整个应用程序样式的机制并不容易。</p><p id="91a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，我们已经学会了通过采用不同的设计模式、架构和抽象层来保护自己免受这些变化的影响，但当涉及到颜色和主题时，我从未找到一个令人满意的案例研究来帮助我定义一组清晰的API。</p><p id="a067" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我无法找到一个框架，可以帮助我在运行时轻松切换整个应用程序的主题。</p><p id="fbd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高迪就是这么做的！它为颜色、字体和样式提供了一个抽象层，允许你轻松地将它们分组到一个<code class="fe lv lw lx ly b">Theme</code>对象中，并允许你在运行时切换主题。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="17fd" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">语义颜色</h1><p id="9486" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这个框架使用语义颜色名称来更好地适应<a class="ae ky" href="https://developer.apple.com/documentation/xcode/supporting_dark_mode_in_your_interface" rel="noopener ugc nofollow" target="_blank">黑暗模式</a>和同一应用程序中其他可能的主题。</p><p id="1cb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和你的设计师一起把这些做好。就像苹果建议的那样，不要走捷径，不要改变语义颜色的语义。</p><p id="36f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高迪的<code class="fe lv lw lx ly b">SemanticColor</code>枚举提供了一个关于那种颜色实际上是什么的清晰提示:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9cbc" class="nh mh it ly b gy ni nj l nk nl">public enum SemanticColor: CaseIterable {<br/>    case label(LabelColor)<br/>    case fill(FillColor)<br/>    case background(BackgroundColor)<br/>    case groupedBackground(GroupedContentBackgroundColor)<br/>    case separator(SeparatorColor)<br/>}</span></pre><p id="7336" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些<code class="fe lv lw lx ly b">LabelColor</code>、<code class="fe lv lw lx ly b">FillColor</code>、<code class="fe lv lw lx ly b">BackgroundColor</code>、<code class="fe lv lw lx ly b">GroupedContentBackgroundColor</code>中的每一个都有不同的具体语义颜色，如<code class="fe lv lw lx ly b">primary</code>、<code class="fe lv lw lx ly b">secondary</code>、<code class="fe lv lw lx ly b">tertiary</code>等等。</p><p id="690e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要使用<code class="fe lv lw lx ly b">LabelColor</code>作为填充颜色。这将在你的项目中引入熵。请与您的设计师密切合作，遵守本规范。</p><p id="7ee8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在你的代码中，你将以正确的方式使用<code class="fe lv lw lx ly b">SemanticColor</code>时，改变你的应用程序的皮肤就像改变20行代码一样简单。您还可以通过使用新颜色创建一个新的主题对象来A/B测试不同的主题。</p><h2 id="aff7" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated"><strong class="ak">为什么语义颜色</strong></h2><p id="73fa" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">通过阅读<code class="fe lv lw lx ly b">.red</code>，一个人会期望结果是一种红色的阴影，而阅读<code class="fe lv lw lx ly b">primary</code>，没有期望。</p><p id="1abd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个框架旨在简化主题化。如果你使用一个<code class="fe lv lw lx ly b">black</code>颜色的文本，看到<code class="fe lv lw lx ly b">black</code>在黑暗模式主题中被渲染成白色会很奇怪。</p><p id="2378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于这个原因，我决定采纳苹果关于使用语义颜色的建议，不仅支持黑暗模式，还允许不同的主题一起工作，从主题颜色和实际呈现的颜色保持一层语义抽象。</p><h2 id="5165" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated"><strong class="ak">如何使用</strong></h2><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0a45" class="nh mh it ly b gy ni nj l nk nl">label.textColor = .semanticColor(.label(.primary))</span></pre><p id="b266" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行简单的代码将把标签的<code class="fe lv lw lx ly b">textColor</code>设置为当前主题的主要标签语义颜色。如果主题改变，颜色也会改变。</p><p id="a22f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以通过扩展color enum来创建您的自定义语义颜色，让新颜色具有语义意义。例如，如果颜色是一个文本标签，那么你想像这样扩展<code class="fe lv lw lx ly b">LabelColor</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7c58" class="nh mh it ly b gy ni nj l nk nl">public extension LabelColor {<br/>    static var myCustomSemanticColor: LabelColor {<br/>        return .custom(color: .color(fromHex: "#123456"))<br/>    }<br/>}</span></pre><p id="2a80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我强烈建议您采用这种“扩展方法”，因为直接使用enum的<code class="fe lv lw lx ly b">custom</code> case可能很诱人，但将来当您不得不为另一个标签再次重复该颜色，或者为所有标签更改该自定义颜色时，这将会让您吃不消。</p><p id="5f34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你的设计师用一种稍微不同的灰色，或者一种与最初商定的普通调色板不同的颜色让你感到惊讶，和他们谈谈，看看这种额外的颜色是否有必要，如果有必要，那么就扩展一下。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="14e3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">如何创建主题</h1><p id="ba08" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">创建一个主题就像创建一个符合协议<code class="fe lv lw lx ly b">ThemeProtocol</code>的类一样简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="52ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对<code class="fe lv lw lx ly b">ThemeProtocol</code>的唯一要求是从<code class="fe lv lw lx ly b">SemanticColor</code>到<code class="fe lv lw lx ly b">UIColor</code>的映射函数和<code class="fe lv lw lx ly b">FontStyle</code>的等效映射函数。</p><p id="dc51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能永远不会直接使用主题，也可能永远不会使用映射功能，因为Gaudí为<code class="fe lv lw lx ly b">UIColor</code>和<code class="fe lv lw lx ly b">UIFont</code>提供了扩展，可以方便地访问当前活动的主题。</p><p id="3d5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主题也允许使用<code class="fe lv lw lx ly b">UIAppearance</code>到<code class="fe lv lw lx ly b">AppearanceRuleSet</code></p><p id="7cc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">AppearanceRuleSet</code>是通过使用<code class="fe lv lw lx ly b">UIAppearance</code>代理获得的一组外观规则。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="9322" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个<code class="fe lv lw lx ly b">AppearanceRuleSet</code>,定制应用程序的所有导航栏、所有标签栏和标签栏项目的外观。</p><p id="d47c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DSL允许我们通过对<code class="fe lv lw lx ly b">UIAppearance</code>对象的可定制属性使用<code class="fe lv lw lx ly b">KeyPath</code>来创建规则。</p><p id="23c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以用嵌套的<code class="fe lv lw lx ly b">AppearanceRuleSet</code>对它们进行分组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="0ea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">外观规则DSL也支持<code class="fe lv lw lx ly b">if</code>和<code class="fe lv lw lx ly b">else</code>语句。</p><p id="fef0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">外观规则集是可逆的。这意味着您可以在运行时将主题恢复为默认设置。</p><p id="e94d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你的主题不需要全局外观，你可以使用<code class="fe lv lw lx ly b">.empty</code>外观规则集。</p><h2 id="d795" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated">是时候让高迪知道你的主题是当前的了</h2><p id="3ea1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">将您的<code class="fe lv lw lx ly b">Theme</code>分配到您的<code class="fe lv lw lx ly b">AppDelegate</code>中的<code class="fe lv lw lx ly b">ThemeContainer</code>。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8524" class="nh mh it ly b gy ni nj l nk nl">func application(_ application: UIApplication,<br/>                   willFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {<br/>    ThemeContainer.currentTheme = YourTheme()<br/>}</span></pre><p id="366b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Gaudí提供了许多UIKit扩展来轻松访问颜色和字体，并轻松配置标签、按钮和字符串(<code class="fe lv lw lx ly b">NSAttributedString</code>)。例如，要设置标题标签，您可以使用:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c996" class="nh mh it ly b gy ni nj l nk nl">label.applyLabelStyle(.title(.regular), <br/>                      semanticColor: .label(.primary))</span></pre><p id="99b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将改变<code class="fe lv lw lx ly b">UILabel</code>文本的字体(和大小)和颜色。要获得语义颜色的颜色，您也可以使用<code class="fe lv lw lx ly b">UIColor</code>扩展:<code class="fe lv lw lx ly b">UIColor.semanticColor(.fill(.primary))</code></p><p id="b575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:不要跳过这一步非常重要，否则Gaudi将不会应用默认主题，这将导致应用程序在您试图使用任何Gaudi扩展来获取颜色和字体时崩溃。</p><p id="144e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在你的应用生命周期中，尽快将你的默认主题分配给<code class="fe lv lw lx ly b">ThemeContainer</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b9ac" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">改变主题</strong></h1><p id="e4d0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">类似于默认主题的初始化，你可以在代码的任何地方使用<code class="fe lv lw lx ly b">ThemeContainer.currentTheme</code>变量来切换主题。</p><p id="5412" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">ThemeContainer.currentTheme = YourOtherTheme()</code></p><p id="96ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当这种情况发生时，高迪将自动恢复先前的主题<code class="fe lv lw lx ly b">UIAppearance</code>规则，然后应用新的规则，并在所有的<code class="fe lv lw lx ly b">Themed</code>视图控制器上调用<code class="fe lv lw lx ly b">applyTheme</code>。</p><h2 id="8482" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated"><strong class="ak">主题为</strong></h2><p id="c9e0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了让Gaudí在多主题应用程序中正常工作，需要在主题视图控制器中实现<code class="fe lv lw lx ly b">Themed</code>协议。</p><p id="2cef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有这个协议实现，当主题改变时，非主题视图控制器的任何现有实例都不会改变它的外观。</p><p id="dd7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将你所有的外观定制放入所需的<code class="fe lv lw lx ly b">applyTheme</code>功能中。</p><p id="f6f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe lv lw lx ly b">UITableView</code> / <code class="fe lv lw lx ly b">UICollectionView</code>单元格，如果您在各自的数据源方法中定制它们的外观，那么只要您使用Gaudí的颜色和字体，<code class="fe lv lw lx ly b">applyTheme</code>函数中的一个简单的<code class="fe lv lw lx ly b">reloadData</code>就会刷新它们的颜色和字体。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d27e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">用高迪支持黑暗模式</h1><p id="5217" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最后是主菜:黑暗模式。用高迪，支持黑暗模式极其简单。此框架有两种不同的方式支持黑暗模式:</p><ol class=""><li id="ddb8" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">实现两个不同的<code class="fe lv lw lx ly b">Themes</code>并在<code class="fe lv lw lx ly b">userInterfaceStyle</code>特征集合改变时切换它们。</li><li id="fac6" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">实现一个返回动态颜色的独特的<code class="fe lv lw lx ly b">Theme</code>。</li></ol><p id="2c93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在将解释如何实现这两者。</p><h2 id="3f6c" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated">主题窗口</h2><p id="628b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果你决定拥有两个独立的主题，并根据需要在运行时切换它们，高迪提供了一个自定义的<code class="fe lv lw lx ly b">UIWindow</code>来实现这一点。</p><p id="1993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在你的应用中初始化一个<code class="fe lv lw lx ly b">ThemedWindow</code>的实例，把你的亮模式主题和暗模式主题传递给它</p><p id="a151" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高迪将在运行时根据需要在两个主题之间进行切换。不需要额外的代码。简单告诉<code class="fe lv lw lx ly b">Window</code>这两个主题是什么。</p><h2 id="d91e" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated"><strong class="ak">动态颜色</strong></h2><p id="da98" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果你已经决定用一个独特的<code class="fe lv lw lx ly b">Theme</code>来支持亮暗模式，那么你必须在你的<code class="fe lv lw lx ly b">Theme</code> <code class="fe lv lw lx ly b">color(forSemanticColor:)</code>映射函数中返回动态颜色。</p><p id="9b0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个框架为<code class="fe lv lw lx ly b">UIColor</code>提供了方便的初始化器来支持这个用例:</p><p id="fe28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">UIColor(lightColor: ..., darkColor: ...)</code></p><p id="041a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且:</p><p id="a57a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">UIColor(lightColorHex: "#123456", darkColorHex: "#654321")</code></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3c8b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">摘要</h1><p id="cdec" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">总而言之，Gaudí是一个简单而强大的框架，为您的应用程序带来了对颜色、字体、字体样式和大小等主题属性的轻松管理。</p><p id="9acb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它提供了一个DSL来编写易于阅读和可逆的<code class="fe lv lw lx ly b">UIAppearance</code>规则，通过<code class="fe lv lw lx ly b">Themed</code>协议，它给了<code class="fe lv lw lx ly b">UIViewController</code>一个超级权力，每当<code class="fe lv lw lx ly b">ThemeContainer</code>中的活动主题改变时，它就可以变异。</p><p id="3c0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我已经在三个应用程序中使用了Gaudí，其中两个是商业应用程序。与设计师一起工作，在几分钟内尝试新的颜色和字体，感觉棒极了。</p><p id="915c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我建议你试一试。关于高迪与<code class="fe lv lw lx ly b">NSAttributedStrings</code>的能力，我可以告诉你更多，但这将是<a class="ae ky" href="https://medium.com/better-programming/compose-nsattributedstrings-easily-with-gaudi-da57a596c9c0" rel="noopener">未来帖子</a>的主题。</p><p id="74f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在GitHub 上找到高迪<a class="ae ky" href="https://github.com/gringoireDM/Gaudi" rel="noopener ugc nofollow" target="_blank">。可通过</a><a class="ae ky" href="https://cocoapods.org/" rel="noopener ugc nofollow" target="_blank"> CocoaPods </a>和<a class="ae ky" href="https://github.com/apple/swift-package-manager" rel="noopener ugc nofollow" target="_blank"> SwiftPM </a>获得。</p></div></div>    
</body>
</html>