<html>
<head>
<title>Develop a Simple URL Shortener Using Microservices Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用微服务架构开发一个简单的URL缩短器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/microservices-for-beginners-developing-simple-url-shortener-2e6fab5c473e?source=collection_archive---------3-----------------------#2022-03-07">https://betterprogramming.pub/microservices-for-beginners-developing-simple-url-shortener-2e6fab5c473e?source=collection_archive---------3-----------------------#2022-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fa22" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">node . js+MySQL+rabbit MQ+Redis+Docker</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/486e8792c8aa27bfaf5448f4537e30c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*peg1uh0dmdBMdEjh"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Akshar Dave拍摄的照片🌻 on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="870e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">听说过微服务但从未真正了解过？还是没有机会用这种架构开发应用？很可能你从来不需要它。仅仅因为某样东西很受欢迎，很多大公司都在使用它，并不意味着你也应该这样做。</p><p id="f1c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，你应该熟悉这种方法，这样有一天你会发现自己处于一种适合使用它的情况。<br/>在本文中，我们将使用微服务架构创建一个简单的URL缩短器。</p><p id="afe5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的任务是:</p><p id="0553" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您需要创建一个应用程序来缩短URL。TinyURL (http://tinyurl.com/)就是这种应用程序的一个例子。该应用程序将由两个服务组成。第一个服务是管理服务，另一个服务是重定向服务。RabbitMQ/Kafka将用于在服务之间传递消息</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/1cafd4ecbf58624144fa03306ca17ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*-yciqX1QVbJV9twnVYjfHQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">架构图</p></figure><h1 id="d27c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">管理服务:</h1><p id="6549" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">管理服务有一个用于创建和删除URL的RESTful API。您应该创建两条路线:</p><p id="01a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">创作路线</strong></p><ul class=""><li id="d6bf" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">该路由应该创建一个基于真实URL的短URL。</li><li id="32dc" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">短URL必须是唯一的。</li><li id="ffb8" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">短URL哈希标识必须位于URI路径中。例如:<a class="ae kv" href="http://localhost:8080/uAYC3sOddP" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/uayc 3 soddp</a></li></ul><p id="8973" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">请求示例</strong></p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="e9cd" class="nj lu iq nf b gy nk nl l nm nn">{<br/>  "realURL": "https://www.example.com/test"<br/>}</span></pre><p id="6146" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">响应示例</strong></p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="ccc5" class="nj lu iq nf b gy nk nl l nm nn">{<br/>  "id": 3,<br/>  "realURL": "https://www.example.com/test",<br/>  "shortURL": "http://localhost:8080/gfjhgESta"<br/>}</span></pre><p id="fdc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">删除路径:</strong></p><ul class=""><li id="5c1f" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">使用id删除短URL。</li></ul><p id="82bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">管理服务应该将MySQL/PostgreSQL用于持久层。创建或删除短URL后，必须将信息发送到RabbitMQ/Kafka</p><h1 id="4e4d" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">重定向服务</h1><p id="925c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">该服务将根据短URL的哈希部分找到真实的URL，用户将被重定向到真实的URL。重定向通过RabbitMQ/ Kafka接受关于短URL的信息。</p><p id="d248" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在管理服务上创建短URL的情况下，信息将存储在重定向服务上的Redis中，而在删除短URL的情况下，信息将从重定向服务上的Redis中删除。重定向服务有一个RESTful API路由。</p><p id="28ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">重定向路线</strong></p><ul class=""><li id="a110" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">该路由应该为现有的短URL返回302 HTTP代码。</li><li id="1552" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">对于不存在的短URL，路由应该返回404 HTTP代码。</li></ul><h2 id="708b" class="nj lu iq bd lv no np dn lz nq nr dp md lf ns nt mf lj nu nv mh ln nw nx mj ny bi translated">限速器</h2><p id="c695" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">对重定向服务实施速率限制，该服务允许在120秒内对特定URL发出10次重定向请求。</p><p id="8b5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">重定向路线</strong></p><ul class=""><li id="40b0" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">到达阈值后，路由应该返回429 HTTP代码。</li></ul></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="280c" class="lt lu iq bd lv lw og ly lz ma oh mc md jw oi jx mf jz oj ka mh kc ok kd mj mk bi translated">我们开始吧</h1><p id="5eb4" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我假设您已经安装并准备好了Docker。</p><p id="5e14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将创建一个新项目，并在其中创建三个文件夹:<code class="fe ol om on nf b">Management-Service</code>、<code class="fe ol om on nf b">Redirection-Service</code>和<code class="fe ol om on nf b">Database-Service</code>。</p><p id="4788" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要启动MySQL数据库，因此进入数据库服务并使用以下内容创建Dockerfile:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="931a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ol om on nf b">FROM</code>将从<a class="ae kv" href="https://hub.docker.com/_/mysql" rel="noopener ugc nofollow" target="_blank"> DockerHub </a>中提取MySQL 8服务器映像，ENV将设置环境变量。<br/><code class="fe ol om on nf b">COPY</code>将从<code class="fe ol om on nf b">/db-dump</code>里面复制一切<code class="fe ol om on nf b">/docker-entrypoint-initdb.d</code></p><blockquote class="oq or os"><p id="0d04" class="kw kx ot ky b kz la jr lb lc ld ju le ou lg lh li ov lk ll lm ow lo lp lq lr ij bi translated">第一次启动容器时，将创建一个具有指定名称的新数据库，并使用提供的配置变量进行初始化。此外，它将执行在<code class="fe ol om on nf b"><em class="iq">/docker-entrypoint-initdb.d</em></code>中找到的扩展名为<code class="fe ol om on nf b"><em class="iq">.sh</em></code>、<code class="fe ol om on nf b"><em class="iq">.sql</em></code>和<code class="fe ol om on nf b"><em class="iq">.sql.gz</em></code>的文件。</p></blockquote><p id="f28d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ol om on nf b">EXPOSE</code> <strong class="ky ir"> </strong>通知Docker容器在运行时监听指定的网络端口。</p><p id="2bdc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经安装好了MySQL，但是我们还没有数据库。我们只需要一个表来存储URL。让我们在<code class="fe ol om on nf b">db-dump</code>文件夹中创建文件<code class="fe ol om on nf b">setup.sql</code>:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="0ec2" class="nj lu iq nf b gy nk nl l nm nn">CREATE TABLE urls (<br/>  id   INT PRIMARY KEY AUTO_INCREMENT NOT NULL,<br/>  realUrl    VARCHAR(40)                    NULL,<br/>  createdAt TIMESTAMP NULL,<br/>  updatedAt TIMESTAMP NULL<br/>)</span></pre><p id="da53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们在根项目文件夹中创建<code class="fe ol om on nf b">docker-compose.yml</code>文件。在这里，我们将配置所有的服务和容器。然后，用一个简单的命令<code class="fe ol om on nf b">docker-compose up</code>，从您的YAML文件创建并启动所有服务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><ul class=""><li id="6b84" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe ol om on nf b"><strong class="ky ir"><em class="ot">db</em></strong></code> <strong class="ky ir"> <em class="ot"> </em> </strong>代表服务的名称。你想怎么叫都行。</li><li id="e1d8" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><code class="fe ol om on nf b"><strong class="ky ir"><em class="ot">build</em></strong></code> <strong class="ky ir"> <em class="ot"> </em> </strong>会取我们数据库服务的Dockerfile所在文件夹的路径。</li><li id="0f35" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><code class="fe ol om on nf b"><strong class="ky ir"><em class="ot">command</em></strong></code> <strong class="ky ir"> <em class="ot"> </em> </strong>将为正在执行的容器<em class="ot">提供默认值。</em>在本例中，我们使用的是<code class="fe ol om on nf b"><a class="ae kv" href="https://hub.docker.com/_/mysql" rel="noopener ugc nofollow" target="_blank">mysql_native_password</a></code> <a class="ae kv" href="https://hub.docker.com/_/mysql" rel="noopener ugc nofollow" target="_blank"> </a>插件，因此我们可以使用传统的用户名/密码组合登录MySQL，而不是像unix socket、PAM等这样的东西。</li><li id="1590" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><code class="fe ol om on nf b"><strong class="ky ir"><em class="ot">container_name</em></strong></code> <strong class="ky ir"> <em class="ot"> </em> </strong>只是一个我们可以用来代替容器ID的别名。</li><li id="8f0e" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><code class="fe ol om on nf b"><strong class="ky ir"><em class="ot">volumes</em></strong></code> <strong class="ky ir"> <em class="ot"> </em> </strong>是持久保存Docker容器生成和使用的数据的首选机制。每次我们销毁集装箱，我们的数据库内的一切也将被删除。我们希望在本地主机上持久化数据。有3种类型的卷:</li><li id="9dfc" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">绑定装载(主机卷)—主机上的文件或目录被装载到容器中。</li><li id="5c5f" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">命名卷—命名卷完全由Docker管理。您只需指定卷的名称，后跟要保留的文件夹的路径，而不是文件的路径。Docker将在主机上自动创建一个新目录，该目录将包含由path指定的容器目录的内容。在我们的例子中，Docker将创建一个命名的卷<code class="fe ol om on nf b">mysql-data</code>，它将存储来自容器<code class="fe ol om on nf b">/var/lib/mysql</code>的所有内容。卷的内容存在于给定容器的生命周期之外，因此，例如，我们可以对另一个容器使用相同的数据库。</li><li id="82c5" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">匿名卷—几乎与命名卷相同，但很难引用它们，因为它们的名称是一些随机哈希值。</li></ul><p id="fb0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我强烈建议多读一点关于书的内容。</p><p id="4a08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ol om on nf b"><strong class="ky ir">ports</strong></code> <strong class="ky ir"> <em class="ot"> </em> </strong>表示它会将主机的3306端口映射到容器的3306端口，这是一个标准的MySQL端口。</p><h2 id="170b" class="nj lu iq bd lv no np dn lz nq nr dp md lf ns nt mf lj nu nv mh ln nw nx mj ny bi translated">我们可以在终端内部运行<code class="fe ol om on nf b">docker-compose up -d</code></h2><p id="392d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们第一次启动容器时会慢一点，因为Docker需要获取配置的图像。yml文件。<code class="fe ol om on nf b">-d</code>用于分离模式，以便您可以继续使用您的终端。您可以使用<code class="fe ol om on nf b">docker ps</code>检查所有正在运行的Docker容器。</p><p id="dcab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们进入我们的容器。可以用<code class="fe ol om on nf b">docker exec -it mysqldb /bin/bash</code>。<br/><br/><code class="fe ol om on nf b">docker exec</code>命令在运行容器中运行新命令。<br/>我们为<em class="ot">交互</em>指定标志<code class="fe ol om on nf b">-i</code>，这意味着它将保持STDIN打开，即使没有连接，这是我们需要的，如果我们想键入任何命令，<code class="fe ol om on nf b">-t</code>分配一个伪TTY，伪终端，连接用户的“终端”与STDIN和STDOUT。</p><p id="259e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们指定容器的ID/名称和命令来运行<code class="fe ol om on nf b">/bin/bash</code>(用于终端)。您可以通过运行<br/> <code class="fe ol om on nf b">mysql -u root -p</code>，提供密码<code class="fe ol om on nf b">123456</code>和<code class="fe ol om on nf b">SHOW DATABASES;</code>来确保数据库已经创建。你可以用类似于<code class="fe ol om on nf b">INSERT INTO (realUrl) VALUES ('https://google.com')</code>的东西填充数据库。</p><p id="9478" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们第二次运行容器时，它不会执行位于<code class="fe ol om on nf b">docker-entrypoint-initdb.d</code>中的启动脚本，因为它会识别已经创建的数据库(由于这个卷不会被破坏)。<br/>有时您可能想用不同的名称或密码重新创建数据库。为此，我们需要销毁卷<code class="fe ol om on nf b">docker volume rm &lt;volume_name&gt;</code>，以便启动脚本可以再次运行并创建一个新卷。</p><p id="d39f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重要提示:如果您正在对docker文件进行更改，请确保随后使用<code class="fe ol om on nf b">docker-compose build --no-cache</code>,以便反映这些更改。</p><h2 id="5ab3" class="nj lu iq bd lv no np dn lz nq nr dp md lf ns nt mf lj nu nv mh ln nw nx mj ny bi translated">包括RabbitMQ</h2><p id="06ae" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">将<a class="ae kv" href="https://hub.docker.com/_/rabbitmq" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>拉入<code class="fe ol om on nf b">docker-compose.yml</code>档；</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="a3d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ol om on nf b">5672</code>用于RabbitMQ，<code class="fe ol om on nf b">15672</code>用于RabbitMQ web界面。运行<code class="fe ol om on nf b">docker-compose up</code>后，您可以检查<code class="fe ol om on nf b">localhost:15672</code>并使用默认凭证<code class="fe ol om on nf b">username:guest password:guest</code>登录RabbitMQ界面。</p><h2 id="c4ff" class="nj lu iq bd lv no np dn lz nq nr dp md lf ns nt mf lj nu nv mh ln nw nx mj ny bi translated">接下来，我们将创建一个管理服务</h2><p id="5c67" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">将目录更改为<code class="fe ol om on nf b">/Management-Service</code>，创建<code class="fe ol om on nf b">/src</code>文件夹和<code class="fe ol om on nf b">Dockerfile</code>。</p><p id="ba0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将目录更改为<code class="fe ol om on nf b">/src</code>，创建<code class="fe ol om on nf b">package.json</code>并安装这些依赖项<code class="fe ol om on nf b">npm install amqplib body-parser cors dotenv express hashids mysql2 nodemon sequelize</code>。</p><p id="467c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你应该在<code class="fe ol om on nf b">package.json</code>的脚本标签中添加<code class="fe ol om on nf b">"start":"nodemon -L index.js</code>，这样我们就可以使用<code class="fe ol om on nf b">npm start</code>用<code class="fe ol om on nf b">nodemon</code>启动项目。Nodemon是一个工具，通过在检测到目录中的文件更改时自动重新启动节点应用程序，来帮助开发基于node.js的应用程序。现在把这个粘贴到<code class="fe ol om on nf b">Dockerfile</code>里面:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="620c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将提取最新的Node.js映像，将<code class="fe ol om on nf b">package.json</code>复制到容器中，安装依赖项，然后我们将<code class="fe ol om on nf b">/node_modules</code>移到<code class="fe ol om on nf b">/src</code>文件夹之外。</p><p id="2223" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能想知道我们为什么要移动<code class="fe ol om on nf b">node_modules</code>。原因是因为我们希望能够在我们的主机上更改代码，并看到更改立即反映在容器中。</p><p id="d4b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么我们要将mount从<code class="fe ol om on nf b">/src</code>绑定到<code class="fe ol om on nf b">docker-compose.yml</code>内部的<code class="fe ol om on nf b">/nodeapp/src</code>。绑定挂载意味着Docker容器可以访问和引用主机的文件系统。</p><p id="a7ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们通过容器改变<code class="fe ol om on nf b">/src</code>文件夹中的文件，也会影响主机的文件系统。</p><p id="a855" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们不移动<code class="fe ol om on nf b">/node_modules</code>，就会发生这种情况:</p><ol class=""><li id="0e99" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr ox mw mx my bi translated">我们将代码从<code class="fe ol om on nf b">/src</code>复制到容器的<code class="fe ol om on nf b">/src</code>。</li><li id="f5e3" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ox mw mx my bi translated">创建容器运行<code class="fe ol om on nf b">npm install</code>和<code class="fe ol om on nf b">/node_modules</code>依赖关系。</li><li id="7e18" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ox mw mx my bi translated">因为我们将主机的<code class="fe ol om on nf b">/src</code>绑定到容器的<code class="fe ol om on nf b">/src</code>，这将覆盖包括<code class="fe ol om on nf b">/node_modules</code>在内的所有内容。这意味着我们的容器依赖于位于我们主机上的<code class="fe ol om on nf b">/node_modules</code>，命令<code class="fe ol om on nf b">RUN npm install</code>没有太大意义。当有人试图克隆我们的存储库时，他的电脑上不会有<code class="fe ol om on nf b">/node_modules</code>，因为他从未使用过<code class="fe ol om on nf b">npm install</code>，所以它只会复制<code class="fe ol om on nf b">/src</code>而没有依赖关系。</li></ol><p id="efb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要指定<code class="fe ol om on nf b">docker-compose.yml</code>内部管理服务的配置和需要的技术。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="3c14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建<code class="fe ol om on nf b">/services/MQService.js</code>，我们将在这里创建用于连接RabbitMQ和向队列发布消息的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="995b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码是不言自明的，我们提供了连接到RabbitMQ服务器的设置，<code class="fe ol om on nf b">channel.assertQueue(QUEUE)</code>将创建一个名为<code class="fe ol om on nf b">'shortUrl'</code>的队列(如果它还不存在的话)。<br/> <code class="fe ol om on nf b">publishToQueue</code>接受我们想要发送的消息，并输入我们想要的任何字符串。我们将使用它来区分创建和删除URL的消息。</p><p id="d3d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ol om on nf b">/src</code>内创建<code class="fe ol om on nf b">index.js</code>，内容如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="6740" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们正在导入必要的库。<code class="fe ol om on nf b">Express.js</code>用于基本路由和中间件，<code class="fe ol om on nf b">bodyParser</code>用于使用POST请求处理表单数据，<code class="fe ol om on nf b">dotenv</code>用于将环境变量加载到<code class="fe ol om on nf b">process.env</code> (docker-compose.yml将能够传递环境变量)，<code class="fe ol om on nf b">Sequelize</code>是orm，<code class="fe ol om on nf b">cors</code>用于处理CORS请求，<code class="fe ol om on nf b">Hashids</code>用于生成小的唯一散列。我们将有两条路线:<br/> - POST '/' -创建URL <br/> - DELETE '/:id' -删除URL</p><p id="60bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ol om on nf b">createUrl</code>首先在数据库中创建条目，然后我们根据新创建记录的id创建一个散列，我们将Url对象发布到队列中，并将其作为响应返回给用户。</p><p id="04d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们测试我们的路线。使用参数<code class="fe ol om on nf b">realUrl</code>执行POST请求。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="3596" class="nj lu iq nf b gy nk nl l nm nn">POST / HTTP/1.1</span><span id="be76" class="nj lu iq nf b gy oy nl l nm nn">Host: localhost:8081</span><span id="aec1" class="nj lu iq nf b gy oy nl l nm nn">Content-Type: application/x-www-form-urlencoded</span><span id="26cb" class="nj lu iq nf b gy oy nl l nm nn">realUrl=www.google.ba</span></pre><p id="0519" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果请求成功，您将看到在RabbitMQ GUI中创建的<code class="fe ol om on nf b">shortURL</code>队列。转到Queues-&gt;Get messages，您应该会看到您的Url对象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/20d11e9420390dee4571e88f36e45378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xCZD-Au4g-8NQgeQ_6B9zg.png"/></div></div></figure><h1 id="7988" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">重定向服务</h1><p id="e88e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">让我们创建与管理服务相同的结构。<code class="fe ol om on nf b">Dockerfile</code>也要一样。</p><p id="21e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将目录更改为<code class="fe ol om on nf b">/src</code>，创建<code class="fe ol om on nf b">package.json</code>并安装这些依赖关系<code class="fe ol om on nf b">npm i amqplib body-parser cors dotenv express nodemon redis</code>。</p><p id="6cb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">确保在<code class="fe ol om on nf b">package.json</code>内添加<code class="fe ol om on nf b">"start":"nodemon -L index.js</code>。为了能够为这个微服务构建一个容器，让我们在<code class="fe ol om on nf b">docker-compose-yml</code>文件中添加服务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="b1dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如任务描述中所述，我们将不得不在Redis中存储URL，所以这也是我们添加<code class="fe ol om on nf b">redis-store</code>的原因。我们需要使用来自RabbitMQ的消息，所以让我们创建<code class="fe ol om on nf b">MQService.js</code>,但是这一次我们不需要向队列发布任何东西，我们只需要使用来自队列的消息并将它们存储在Redis中。</p><p id="c6ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ol om on nf b">consumeQueue</code>将把消息传递给我们的回调函数，回调函数将在<code class="fe ol om on nf b">index.js</code>中定义。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="ff62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创造一个<code class="fe ol om on nf b">index.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="4836" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们几乎准备好了，但是如果您克隆这个repo并启动容器，其中一个服务将会失败。</p><p id="680e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原因是我们的<code class="fe ol om on nf b">Management-Service</code>和<code class="fe ol om on nf b">Redirection-Service</code>没有等待RabbitMQ/MySQL，所以他们会在这些服务准备好之前尝试连接。</p><p id="4772" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ol om on nf b">docker-compose.yml</code>中，我们有<code class="fe ol om on nf b">depends_on</code>属性，但是它只等待另一个容器启动，而不等待它正在运行的进程启动。要解决这个问题，我们只能重启失败的容器或者直接在JS文件中使用一些解决方案。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="b49b" class="nj lu iq nf b gy nk nl l nm nn"> // Try to connect to rabbitmq until successful<br/> let conn = null;<br/> do {<br/>     try {<br/>         conn = await amqp.connect(rabbitSettings);<br/>     } catch (e) {}<br/> } while (conn === null)</span></pre><p id="8e57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第三种选择是使用一个简单的脚本<a class="ae kv" href="https://docs.docker.com/compose/startup-order/" rel="noopener ugc nofollow" target="_blank">来等待容器准备好。</a></p><p id="0394" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">发送POST请求时，一定要使用JSON或<code class="fe ol om on nf b">form-urlencoded</code>。您可能需要添加额外的中间件来处理表单数据请求体。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="f548" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">源代码可以在这个<a class="ae kv" href="https://github.com/OstojicI/microservices-url-shortener" rel="noopener ugc nofollow" target="_blank"> GitHub仓库</a>中找到。</p></div></div>    
</body>
</html>