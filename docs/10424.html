<html>
<head>
<title>Detect Active Users in Angular Using NestJs and Socket.IO</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NestJs和Socket检测Angular中的活跃用户。超正析象管(Image Orthicon)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/detect-active-users-in-angular-using-nestjs-and-socket-io-1efaf336b267?source=collection_archive---------1-----------------------#2022-01-06">https://betterprogramming.pub/detect-active-users-in-angular-using-nestjs-and-socket-io-1efaf336b267?source=collection_archive---------1-----------------------#2022-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="42f1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">插座之间的比较。IO和信号员</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8cbf365410b70fad853063e47005ff4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lP915nBqbgXyfpP8EZz-4w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·巴克利在<a class="ae ky" href="https://unsplash.com/s/photos/connect?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e05d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几年前，我写过一篇文章“<a class="ae ky" href="https://medium.com/p/fad0b9d56101" rel="noopener">使用SignalR </a>检测Angular应用中的活跃用户”。这并不是很久以前的事，但是技术发展很快。在实时web应用程序的世界里，Socket。木卫一正在崛起。</p><p id="6f18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">信号器和插座。我和她有很多相似之处。两者都是为web客户机和服务器之间的实时双向通信而设计的，并且都使用WebSocket作为默认的传输协议。</p><p id="960b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了相似之处，SignalR也是。Net生态系统和Socket。IO是为NodeJS打造的。但是在实际操作中，Socket又有多大的不同。IO与SignalR相比？有哪些利弊？</p><p id="ca13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了回答这些问题，我使用NestJS和Socket.IO重写了前一篇文章中的示例应用程序。</p><p id="727d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我告诉你这个实验是如何进行的。</p><p id="2c0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">向前跳跃:</em></p><ul class=""><li id="343c" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae ky" href="#6129" rel="noopener ugc nofollow">用NestJs设置一个WebSocket服务器</a></li><li id="b3d1" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#2824" rel="noopener ugc nofollow">配置NestJS网关</a></li><li id="6f2e" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#596f" rel="noopener ugc nofollow">用Socket接收和广播消息。IO </a></li><li id="4675" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#1ad0" rel="noopener ugc nofollow">使用缓存管理器管理用户会话数据</a></li><li id="0804" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#7ae4" rel="noopener ugc nofollow">角度客户端</a></li><li id="2a1a" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#5ebc" rel="noopener ugc nofollow">插座。IO vs信号员</a></li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="d51b" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">概观</h2><p id="56e8" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">下图说明了这个人为示例中使用的技术堆栈。如果你读了我以前的博文，你会发现主要的区别是我们使用了NestJS/Socket。木卫一而不是。网络核心/信号r。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/f31604dd6e24a1e53040a56b70f64d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wmE3mCdxfEKrKkVghcXNvQ.png"/></div></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="6129" class="nq ms it bd mt nr ns nt mw nu nv nw mz jz nx ka nc kc ny kd nf kf nz kg ni oa bi translated">用NestJs设置WebSocket服务器</h1><p id="4241" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">NestJS提供了WebSocket模块，它支持两个WebSocket平台(S <a class="ae ky" href="https://github.com/socketio/socket.io" rel="noopener ugc nofollow" target="_blank"> ocket。</a> IO和<a class="ae ky" href="https://github.com/websockets/ws" rel="noopener ugc nofollow" target="_blank"> ws </a>)开箱即用。在本文中，我们将使用Socket.IO。</p><p id="4326" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建一个新的NestJS应用程序并安装必要的依赖项。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="f155" class="mr ms it oc b gy og oh l oi oj">nest new nest-waiting-room <br/>cd nest-waiting-room<br/>npm i --save @nestjs/websockets @nestjs/platform-socket.io</span></pre><p id="2789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在设置好NestJS应用程序框架之后。我们需要为新的应用程序添加一个网关。</p><h1 id="2824" class="nq ms it bd mt nr ok nt mw nu ol nw mz jz om ka nc kc on kd nf kf oo kg ni oa bi translated">配置NestJS网关</h1><p id="44f6" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><a class="ae ky" href="https://docs.nestjs.com/websockets/gateways" rel="noopener ugc nofollow" target="_blank">网关</a>在NestJS中引入，作为web socket平台的平台无关接口。我们可以用NestJS CLI生成一个网关，如下所示。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="ef31" class="mr ms it oc b gy og oh l oi oj">nest g gateway app</span></pre><p id="addd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成的网关类如下所示:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="07af" class="mr ms it oc b gy og oh l oi oj">@WebSocketGateway() <br/>export class AppGateway implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect {<br/>....<br/>}</span></pre><p id="e887" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这个类是用<code class="fe op oq or oc b">@WebsocketGateway()</code>修饰的，它让我们可以访问web socket功能。</p><p id="7f93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还实现了3个生命周期挂钩:<code class="fe op oq or oc b">OnGatewayInit</code>、<code class="fe op oq or oc b">OnGatewayConnection </code>和<code class="fe op oq or oc b">OnGatewayDisconnect</code>。从它们的名字来看，它们是不言自明的。</p><p id="bf6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了允许angular客户端从不同的域访问网关，需要如下启用cors。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="bc36" class="mr ms it oc b gy og oh l oi oj">@WebSocketGateway({ cors: true })</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="596f" class="nq ms it bd mt nr ns nt mw nu nv nw mz jz nx ka nc kc ny kd nf kf nz kg ni oa bi translated">用套接字接收和广播消息。超正析象管(Image Orthicon)</h1><p id="2b6a" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><code class="fe op oq or oc b">Gateway</code>类的核心是处理传入和传出的事件消息。</p><p id="9a5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了监听传入的消息，我们使用<code class="fe op oq or oc b">@SubscribeMessage</code> decorator。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="5860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要向所有连接的客户端发送一个事件，您需要使用<code class="fe op oq or oc b">WebSocketServer</code>装饰器并使用本地WebSocket实例发出一条消息:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="a269" class="mr ms it oc b gy og oh l oi oj">@WebSocketServer() server;</span><span id="734d" class="mr ms it oc b gy ou oh l oi oj">// Boardcast message to all connected clients<br/>this.server.emit('patientList', activeUsers.map(x=&gt; x.userName));</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="1ad0" class="nq ms it bd mt nr ns nt mw nu nv nw mz jz nx ka nc kc ny kd nf kf nz kg ni oa bi translated">使用缓存管理器管理用户会话数据</h1><p id="f39b" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">与SignalR版本类似，我们使用内存缓存来存储状态。这主要是为了说明。在实际项目中，您可能会考虑将状态持久化到数据库或Redis中，以使其更具可伸缩性。</p><p id="d221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户会话数据由<code class="fe op oq or oc b">UserSessionCache </code>类管理。<code class="fe op oq or oc b">UserSessoinCache </code>类建立在<a class="ae ky" href="https://github.com/BryanDonovan/node-cache-manager" rel="noopener ugc nofollow" target="_blank">缓存管理器</a>之上。它公开了用户会话数据的CRUD操作。</p><p id="cfd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在更新缓存数据时，我们将这个示例应用程序的到期时间设置为60分钟。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="22c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户会话数据被缓存时，我们也更新了<code class="fe op oq or oc b">lastConnectedTime </code>属性。如果比当前时间多60秒，我们认为用户已经断开连接。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="7ae4" class="nq ms it bd mt nr ns nt mw nu nv nw mz jz nx ka nc kc ny kd nf kf nz kg ni oa bi translated">棱角分明的客户</h1><p id="3362" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">使用插座。Angular中的IO客户端，我们需要安装<a class="ae ky" href="https://github.com/rodgc/ngx-socket-io#readme" rel="noopener ugc nofollow" target="_blank"> ngx-socket-io </a>，这是一个在socket上的Angular包装器。IO客户端库。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="1849" class="mr ms it oc b gy og oh l oi oj">npm i @ngx-socket-io --save</span></pre><p id="609e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在App.module.ts中，我们将套接字服务器配置声明如下。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="54c6" class="mr ms it oc b gy og oh l oi oj">const config: SocketIoConfig = { url: 'http://localhost:3000', options: {} };</span></pre><p id="c793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要在<code class="fe op oq or oc b">AppModule</code>中导入<code class="fe op oq or oc b">SocketIoModule </code>。这将在<code class="fe op oq or oc b">AppModule</code>加载时初始化客户端到套接字服务器的连接。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="db2b" class="mr ms it oc b gy og oh l oi oj">imports: [<br/>...,<br/>SocketIoModule.forRoot(config)<br/>]</span></pre><p id="5a13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建一个<code class="fe op oq or oc b">WebScoketService </code>来处理客户端事件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="62f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，<code class="fe op oq or oc b">userPing </code>函数调用<code class="fe op oq or oc b">socket.emit</code>将事件发送到socket服务器。这个函数每秒在<code class="fe op oq or oc b">waitingroom </code>角度组件中被调用一次，这样服务器就会知道用户在页面上是活动的。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="2023" class="mr ms it oc b gy og oh l oi oj">this.interval = setInterval(() =&gt; {<br/>   this.service.userPing(this.userName);<br/>}, 1000);</span></pre><p id="d67d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">候诊室页面也有一个可观察到的<code class="fe op oq or oc b">activeUsers$</code>。它从套接字订阅。IO服务器<code class="fe op oq or oc b">patientList</code>事件，因此连接用户的任何变化都会实时显示。</p><p id="2822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终结果与SignalR版本完全相同！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/df8fbdd1571401fad287319d3c51318a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JSdjudhtRnaoNJVaag_4Lg.png"/></div></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="5ebc" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">插座。IO与信号r</h2><p id="3aea" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">总的来说，我喜欢Socket.IO。它的设置非常简单，并且提供了我需要的所有功能。</p><p id="ba2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与使用SignalR的实现相比，我只需要编写一半的代码就可以获得客户端和服务器端相同的特性。这直接证明了使用Socket.IO时需要的样板代码要少得多。</p><p id="0544" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们在这个简单的例子中只使用了最基本的功能，但是值得强调一下这个套接字。IO提供了许多其他重要的特性。它包括<code class="fe op oq or oc b">Rooms</code>，一个任意的通道，可用于向客户端子集广播事件。它还支持负载平衡和数据流。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="8f42" class="nq ms it bd mt nr ns nt mw nu nv nw mz jz nx ka nc kc ny kd nf kf nz kg ni oa bi translated">摘要</h1><p id="497b" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">插座。IO支持web客户端和服务器之间的双向通信。它在WebSocket上添加了一个很好的抽象，并公开了足够多但不太复杂的API来完成工作。</p><p id="beee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用套接字的另一个主要好处是。IO是活跃和充满活力的NodeJS社区和生态系统。我个人比较喜欢用NestJS/Socket。未来项目的IO，除非项目是基于。Net平台。</p><p id="38a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Angular客户端示例的源代码是<a class="ae ky" href="https://github.com/sunnyy02/ngWebsocket" rel="noopener ugc nofollow" target="_blank">这里是</a>，NestJS示例可以在<a class="ae ky" href="https://github.com/sunnyy02/nestWaitingRoom" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>