<html>
<head>
<title>Liskov Substitution Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利斯科夫替代原理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solid-swift-by-examples-part-three-675672c1ec20?source=collection_archive---------1-----------------------#2019-08-03">https://betterprogramming.pub/solid-swift-by-examples-part-three-675672c1ec20?source=collection_archive---------1-----------------------#2019-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="381d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Swift实例中的坚实原则</h2><div class=""/><div class=""><h2 id="4dca" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">坚固的雨燕</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/da4a77e544389e799ff3941215950c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lGpFVOhVLsBQYhO-"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@kingslayer77?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">菲尔在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上听</a></p></figure><p id="6269" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是我关于<em class="me">坚实</em>原则系列的第三部分。在以前的文章中，我们讨论了什么是坚实的原则，它们试图解决什么，以及什么是SRP(I)和OCP(II)。</p><p id="1d6d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以在这里看到之前的两件作品:</p><div class="mf mg gp gr mh mi"><a href="https://medium.com/@piero9212/solid-swift-by-examples-part-one-35018d53d3e6" rel="noopener follow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">坚固的雨燕</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">完整指南第一部分</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">medium.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw lb mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a href="https://medium.com/@piero9212/solid-swift-by-examples-part-two-82ac3c457e4e" rel="noopener follow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">开闭原理</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">在第一部分，我们描述了什么是坚实的原则和他们试图解决什么，解释了第一…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">medium.com</p></div></div><div class="mr l"><div class="mx l mt mu mv mr mw lb mi"/></div></div></a></div><p id="5687" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这一部分，我们将探讨利斯科夫替换。由Barbara Liskov在1987年的会议主旨中介绍，后来在1994年与Jannette Wing一起发表在一篇论文中。</p><p id="ecf8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">他们最初的定义是:</p><blockquote class="my"><p id="4268" class="mz na it bd nb nc nd ne nf ng nh md dk translated">"使用指向基类的指针或引用的函数必须能够在不知道的情况下使用派生类的对象."</p></blockquote><p id="4f8b" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">然后，随着Robert C . Martin(Bob叔叔)在他的《敏捷软件开发、原则、模式和实践<em class="me"/>一书中出版了《坚实的原则》一书，并在该书的<a class="ae lh" href="https://docs.microsoft.com/en-us/dotnet/csharp/" rel="noopener ugc nofollow" target="_blank"> C# </a>版本<a class="ae lh" href="http://www.amazon.com/Agile-Principles-Patterns-Practices-C/dp/0131857258" rel="noopener ugc nofollow" target="_blank"> <em class="me">敏捷原则、模式和实践【C# </em> </a>中重新出版，该定义被称为利斯科夫替代原则。</p><p id="e1af" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就引出了罗伯特·马丁给出的定义:</p><blockquote class="my"><p id="87de" class="mz na it bd nb nc nd ne nf ng nh md dk translated">"子类型必须可以替换它们的基本类型."</p></blockquote><p id="480a" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">就这么简单——子类应该在不破坏应用程序或功能的情况下替换它的超类，但这要求所有子类的行为都与父类相同。</p><p id="1f86" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了实现这一点，你的子类需要验证另外两点:<em class="me">前置条件</em>和<em class="me">后置条件</em>变化。</p><ul class=""><li id="d14b" class="nn no it lk b ll lm lo lp lr np lv nq lz nr md ns nt nu nv bi translated">不要在输入参数上实现比父类实现的更严格的验证规则。</li><li id="f14e" class="nn no it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated">将至少与父类相同的规则应用于所有输出参数。</li></ul><p id="75ea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有很多关于Liskov替换原则的文章，使用相同的一个<code class="fe ob oc od oe b">Rectangle</code>和一个<code class="fe ob oc od oe b">Square</code>类的例子来展示如果你的<code class="fe ob oc od oe b">Square</code>类扩展了<code class="fe ob oc od oe b">Rectangle</code>类，你将如何破坏设计原则。</p><p id="6599" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我想用一个真实的例子来解释这个概念。</p><p id="8254" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看下面的例子。假设我们必须从一个API或一个数据库中获取用户信息，并且您做出了类似这样的事情:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">从API和数据库获取数据的用户服务</p></figure><p id="5028" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">应用我们在以前的出版物(SRP和OCP)中学到的一些概念，我们做了这个:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">两个特定服务，一个用于API，另一个用于数据库</p></figure><p id="a1df" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">并且，我们有一个<code class="fe ob oc od oe b">UserManager</code>接收一个<code class="fe ob oc od oe b">UserService</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">处理所有用户逻辑的UserManager类</p></figure><p id="5495" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们从数据库中调用<code class="fe ob oc od oe b">UserManager</code>、<code class="fe ob oc od oe b">fetchUser</code>时:</p><pre class="ks kt ku kv gt oh oe oi oj aw ok bi"><span id="cbf8" class="ol om it oe b gy on oo l op oq">let databaseService = DatabaseUserService()</span><span id="f946" class="ol om it oe b gy or oo l op oq">let userManager = UserManager(service: databaseService)</span><span id="6651" class="ol om it oe b gy or oo l op oq">userManager.fetchUser(with: “thebatman”, password: “afflect8”)</span><span id="1ea5" class="ol om it oe b gy or oo l op oq">//PRINTED RESULT <strong class="oe jd">DB REQUEST HERE</strong></span></pre><p id="0e11" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从一个API:</p><pre class="ks kt ku kv gt oh oe oi oj aw ok bi"><span id="7a52" class="ol om it oe b gy on oo l op oq">let apiService = ApiUserService()</span><span id="c05f" class="ol om it oe b gy or oo l op oq">userManager = UserManager(service: apiService)</span><span id="b9ad" class="ol om it oe b gy or oo l op oq">userManager.fetchUser(with: “thebatman”, password: “afflect8”)</span><span id="02dc" class="ol om it oe b gy or oo l op oq">//PRINTED RESULT <strong class="oe jd">API REQUEST HERE</strong></span></pre><p id="6728" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是这怎么可能呢？</p><p id="b337" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ob oc od oe b">UserManager</code>需要一个<code class="fe ob oc od oe b">UserService</code>，而不是一个<code class="fe ob oc od oe b">APIUserService</code>或<code class="fe ob oc od oe b">DatabaseUserService.</code></p><p id="5fb3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是利斯科夫替代原理在起作用。我们用一个子类型替换一个<code class="fe ob oc od oe b">UserService</code>，比如<code class="fe ob oc od oe b">APIUserService.</code></p><p id="35d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在是时候确定我们如何能够<em class="me">打破</em><strong class="lk jd"/>或者我们如何<em class="me">一直在打破</em><strong class="lk jd"/>这个原则了。</p></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h1 id="e79a" class="oz om it bd pa pb pc pd pe pf pg ph pi ki pj kj pk kl pl km pm ko pn kp po pp bi translated">强化前提条件</h1><p id="8018" class="pw-post-body-paragraph li lj it lk b ll pq kd ln lo pr kg lq lr ps lt lu lv pt lx ly lz pu mb mc md im bi translated">假设我们需要更改业务逻辑，并且只有当密码长度大于<code class="fe ob oc od oe b">5</code>时，您才必须请求用户信息:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">APIUserService</p></figure><p id="61f3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个例子中断了LSP，因为这个子类有一个先决条件，即<code class="fe ob oc od oe b">password</code>的长度必须大于<code class="fe ob oc od oe b">5</code>。</p><p id="f9a7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ob oc od oe b">UserManager</code> (client)的客户不期望<code class="fe ob oc od oe b">APIUserService</code>有不同的前提条件，因为对于<strong class="lk jd">所有的</strong>和<code class="fe ob oc od oe b">UserService</code>子类都应该是一样的。</p><p id="1262" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以用不同的方法来解决这个问题，但这里最简单的方法是将验证转移到我们的客户端，并在它的调用中添加一个新参数，以注入密码所需的最小字符长度:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">一个拥有避免破坏原则的验证规则的用户管理器</p></figure></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h1 id="c2cc" class="oz om it bd pa pb pc pd pe pf pg ph pi ki pj kj pk kl pl km pm ko pn kp po pp bi translated">弱化后置条件</h1><p id="a13d" class="pw-post-body-paragraph li lj it lk b ll pq kd ln lo pr kg lq lr ps lt lu lv pt lx ly lz pu mb mc md im bi translated">假设我们有这个<code class="fe ob oc od oe b">User</code>T21和<code class="fe ob oc od oe b">Contact</code>子类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">一个包含名字和姓氏的简单用户类</p></figure><p id="f136" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在客户端向用户展示<code class="fe ob oc od oe b">UserView</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="e286" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们来试试:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">在操场上测试我们的代码</p></figure><p id="db95" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是如果我们在客户端修改<code class="fe ob oc od oe b">firstName</code>参数会发生什么呢？</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">修改输入的用户视图</p></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">在操场上再次测试</p></figure><p id="f080" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过这种方法，我们打破了<code class="fe ob oc od oe b">init</code>上的<code class="fe ob oc od oe b">Contact</code>类的LSP后置条件，将<code class="fe ob oc od oe b">firstName</code>设置为“联系人”</p></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h1 id="c208" class="oz om it bd pa pb pc pd pe pf pg ph pi ki pj kj pk kl pl km pm ko pn kp po pp bi translated">需要特定类型</h1><p id="772f" class="pw-post-body-paragraph li lj it lk b ll pq kd ln lo pr kg lq lr ps lt lu lv pt lx ly lz pu mb mc md im bi translated">假设我们必须获取用户的照片:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">再次是获取用户照片的用户服务</p></figure><p id="5755" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们已经将这个新功能添加到我们的<code class="fe ob oc od oe b">APIUserService</code>中:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">APIUserService实现</p></figure><p id="c23a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，如果这种获取用户照片的方式只通过API支持，而不通过数据库支持呢？</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">数据库用户服务实现</p></figure><p id="fd45" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果一个覆盖方法什么都不做，或者只是抛出一个异常，那么您可能违反了LSP。</p><p id="865f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是打破利斯科夫替代原理的一种常见方式。</p><p id="5e1d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们用构图来解决这个问题:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作文来帮助我们</p></figure></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h1 id="9584" class="oz om it bd pa pb pc pd pe pf pg ph pi ki pj kj pk kl pl km pm ko pn kp po pp bi translated">结论</h1><p id="bb32" class="pw-post-body-paragraph li lj it lk b ll pq kd ln lo pr kg lq lr ps lt lu lv pt lx ly lz pu mb mc md im bi translated">请注意，如果您将<code class="fe ob oc od oe b">UserPhotoService</code>属性更改为使用<code class="fe ob oc od oe b">APIUserService</code>或<code class="fe ob oc od oe b">DatabaseUserService</code>，一切仍将相同，这就是LSP。</p><p id="8f2f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">编译器非常善于允许我们编写符合Liskov替换原则的代码，所以要好好利用它。</p><p id="8c7e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，在处理子类型时，请注意前置条件和后置条件。有时我们会想到一个亚型，但它可能是不同的东西。</p><p id="937c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望你喜欢这篇文章，希望它对你有所帮助。感谢阅读。请在下面的评论中留下您的反馈。</p></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h1 id="06c9" class="oz om it bd pa pb pc pd pe pf pg ph pi ki pj kj pk kl pl km pm ko pn kp po pp bi translated">下一章</h1><div class="mf mg gp gr mh mi"><a href="https://medium.com/@piero9212/interface-segregation-principle-ec31bdb2872" rel="noopener follow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">界面分离原理</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">这是关于坚实原则的出版物的第四部分。在以前的文章中，我们讨论了…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">medium.com</p></div></div><div class="mr l"><div class="pv l mt mu mv mr mw lb mi"/></div></div></a></div></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h1 id="1b37" class="oz om it bd pa pb pc pd pe pf pg ph pi ki pj kj pk kl pl km pm ko pn kp po pp bi translated">参考</h1><div class="mf mg gp gr mh mi"><a href="https://medium.com/swift-india/solid-principles-part-3-liskov-substitution-principle-723e025d0589" rel="noopener follow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">LSP: Liskov替代原理，又称协议设计</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">子类在代替基类使用时应该表现良好</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">medium.com</p></div></div><div class="mr l"><div class="pw l mt mu mv mr mw lb mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a href="https://medium.com/@piyush.dez/solid-principles-in-swift-e9cc84ff5aa2" rel="noopener follow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">Swift坚实的设计原则</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">SOLID代表了面向对象编程的5个原则:单一责任、开放/封闭、Liskov替换…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">medium.com</p></div></div><div class="mr l"><div class="px l mt mu mv mr mw lb mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a href="https://code.tutsplus.com/tutorials/solid-part-3-liskov-substitution-interface-segregation-principles--net-36710" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">固体:第3部分-利斯科夫替代和界面分离原理</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">单一责任(SRP)、开放/封闭(OCP)、利斯科夫替代、界面分离和依赖性…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">code.tutsplus.com</p></div></div><div class="mr l"><div class="py l mt mu mv mr mw lb mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a href="https://stackify.com/solid-design-liskov-substitution-principle/" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">坚实的设计原则解释:利斯科夫替代原则与代码示例</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">所有5个坚实的设计原则被广泛使用，如果你不知道他们的名字，你会很快认识到他们…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">stackify.com</p></div></div><div class="mr l"><div class="pz l mt mu mv mr mw lb mi"/></div></div></a></div><p id="2a1d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://web.archive.org/web/20150905081111/http://www.objectmentor.com/resources/articles/lsp.pdf" rel="noopener ugc nofollow" target="_blank">https://web . archive . org/web/20150905081111/http://www . object mentor . com/resources/articles/LSP . pdf</a></p></div></div>    
</body>
</html>