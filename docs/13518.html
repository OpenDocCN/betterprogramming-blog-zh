<html>
<head>
<title>Extending ‘SwipeToDismiss’ in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Jetpack Compose中扩展“SwipeToDismiss”</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/extending-swipetodismiss-in-jetpack-compose-7ed356df073a?source=collection_archive---------0-----------------------#2022-09-04">https://betterprogramming.pub/extending-swipetodismiss-in-jetpack-compose-7ed356df073a?source=collection_archive---------0-----------------------#2022-09-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2941" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">可定制、有表现力、可发现</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7350b8c74c7587bba648fa0b2d8f339d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IiG6D4wj9zhV6D-X9T--hw.png"/></div></div></figure><p id="bfae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是在项目列表上执行快速操作的常见UI模式。在本文中，我们将讨论如何构建一个丰富的、富有表现力的滑动来消除一个例子。</p><p id="eb27" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Jetpack compose有一个默认的composable来提供这个功能，称为<code class="fe ln lo lp lq b">SwipeToDismiss</code>。这个可组合组件提供了一些定制，但是我们可以改进它，为用户创造更好的体验。</p><p id="e868" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意:本文不是一篇介绍性文章，假设您对<code class="fe ln lo lp lq b">SwipeToDismiss</code> composable和jetpack compose有一定的了解。关于<code class="fe ln lo lp lq b">SwipeToDismiss</code>组件的快速介绍，请参考Pankaj Rai的教程。</p><p id="5248" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是可组合组件成品的外观:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/289fc5280b21416a4659d39ddbcaf6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*Tu63qK4bBUCBuMvi.gif"/></div></figure><p id="cdb6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我们将改进三个方面:</p><ol class=""><li id="5836" class="lt lu iq kt b ku kv kx ky la lv le lw li lx lm ly lz ma mb bi translated">可定制性</li><li id="5366" class="lt lu iq kt b ku mc kx md la me le mf li mg lm ly lz ma mb bi translated">表示</li><li id="c404" class="lt lu iq kt b ku mc kx md la me le mf li mg lm ly lz ma mb bi translated">可发现性</li></ol><h1 id="e9a3" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">1.可定制性</h1><p id="4ddd" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">首先，我们需要扩展默认SwipeDismiss composable的功能，这样我们就可以构建更好的、更加定制化的体验。为此，我们将创建一个config对象来为我们的可组合组件定义不同的选项。</p><pre class="kg kh ki kj gt ne lq nf ng aw nh bi"><span id="b985" class="ni mi iq lq b gy nj nk l nl nm">data class SwipeActionsConfig(  <br/>    val threshold: Float,  <br/>    val icon: ImageVector,  <br/>    val iconTint: Color,  <br/>    val background: Color,  <br/>    val stayDismissed: Boolean,  <br/>    val onDismiss: () -&gt; Unit,  <br/>)</span></pre><p id="856d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可组合组件将接受最多两个配置对象，它们定义了从起点和终点滑动的行为。这些可定制的选项包括:</p><h2 id="64dc" class="ni mi iq bd mj nn no dn mn np nq dp mr la nr ns mt le nt nu mv li nv nw mx nx bi translated">阈值</h2><p id="eee8" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">这是一个介于0和1之间的浮点数，定义了滑动手势在触发动作之前必须移动的距离。默认的可组合组件已经提供了这种功能，但是创建自定义解决方案的原因是为了在状态中公开它。默认的<code class="fe ln lo lp lq b">SwipeToDismiss</code> composable已经允许这个选项，但是我们将手动处理它，以便将其作为一个状态在我们的UI中使用。但是首先，为了避免由于与默认可组合组件不一致而导致的任何错误，我们需要将这个阈值传递给默认可组合组件。</p><pre class="kg kh ki kj gt ne lq nf ng aw nh bi"><span id="256e" class="ni mi iq lq b gy nj nk l nl nm">SwipeToDismiss(  <br/>    ... <br/>    dismissThresholds = {  <br/>        if (it == DismissDirection.StartToEnd)  <br/>            FractionalThreshold(startDismissConfig.threshold)  <br/>        else FractionalThreshold(endDismissConfig.threshold)  <br/>    },<br/>    ...<br/>}</span></pre><p id="c9f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">解决了这个问题，我们现在将创建一个<code class="fe ln lo lp lq b">willDismissDirection</code>状态，我们可以用它来知道用户当前的滑动是否会导致一个动作。</p><pre class="kg kh ki kj gt ne lq nf ng aw nh bi"><span id="0d8c" class="ni mi iq lq b gy nj nk l nl nm">var willDismissDirection: DismissDirection? by remember {  <br/>    mutableStateOf(null)  <br/>}</span></pre><p id="05d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将包含用户将要触发的动作的方向，或者如果用户没有达到阈值，则为<code class="fe ln lo lp lq b">null</code>。</p><pre class="kg kh ki kj gt ne lq nf ng aw nh bi"><span id="66b7" class="ni mi iq lq b gy nj nk l nl nm">LaunchedEffect(key1 = Unit, block = {  <br/>    snapshotFlow { state.offset.value }  <br/>        .collect {  <br/>            willDismissDirection = when {  <br/>                it &gt; width * startActionsConfig.threshold -&gt; DismissDirection.StartToEnd  <br/>                it &lt; -width * endActionsConfig.threshold -&gt; DismissDirection.EndToStart  <br/>                else -&gt; null  <br/>            }  <br/>        }  <br/>})</span></pre><p id="cf5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将允许我们稍后基于滑动的当前位置和状态来改变UI。</p><h2 id="77bc" class="ni mi iq bd mj nn no dn mn np nq dp mr la nr ns mt le nt nu mv li nv nw mx nx bi translated">颜色和图标</h2><p id="1950" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">这个很简单，我们只需要定义每一面的颜色和图标。对于颜色，我们将定义背景色和图标色调。注意:为了简单起见，我选择传入一个矢量图标。但是，通过为图标传入一个composable，可以做得更好。这允许你做更酷的设计，比如动画图标。</p><h2 id="e65c" class="ni mi iq bd mj nn no dn mn np nq dp mr la nr ns mt le nt nu mv li nv nw mx nx bi translated">滞留时间</h2><p id="3cea" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">在不同的场景中，一旦触发了滑动动作，我们会希望列表项一直保持动画效果(例如从当前列表中删除项目)或弹回到其默认状态(例如将项目添加到不同的策划列表)。通过这个选项，我们可以为每个动作定义我们想要的两种行为。为了实现这一点，我们只需要在dismissState中实现<code class="fe ln lo lp lq b">confirmStateChange</code>函数。</p><pre class="kg kh ki kj gt ne lq nf ng aw nh bi"><span id="845b" class="ni mi iq lq b gy nj nk l nl nm">val state = rememberDismissState(  <br/>    confirmStateChange = {  <br/>        // return true for the item to stay dismissed<br/>        // return false for the item to bounce back to its default state<br/>    }  <br/>)</span></pre><h2 id="c57d" class="ni mi iq bd mj nn no dn mn np nq dp mr la nr ns mt le nt nu mv li nv nw mx nx bi translated">翁迪米什</h2><p id="0c46" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">一旦用户刷卡超过阈值，就会调用这个函数。这也是在<code class="fe ln lo lp lq b">confirmStateChange</code>函数中实现的。我们应该首先检查我们的<code class="fe ln lo lp lq b">willDismissDirection</code>状态是否对应于传递给函数的方向。如果是这样，我们调用<code class="fe ln lo lp lq b">onDismiss</code>函数，然后返回<code class="fe ln lo lp lq b">stayDissmised</code>布尔值。</p><pre class="kg kh ki kj gt ne lq nf ng aw nh bi"><span id="d778" class="ni mi iq lq b gy nj nk l nl nm">val state = rememberDismissState(  <br/>    confirmStateChange = {  <br/>        if (willDismissDirection == DismissDirection.StartToEnd  <br/>            &amp;&amp; it == DismissValue.DismissedToEnd  <br/>        ) {  <br/>            startActionsConfig.onDismiss()  <br/>            startActionsConfig.stayDismissed  <br/>        } else if (willDismissDirection == DismissDirection.EndToStart &amp;&amp;  <br/>            it == DismissValue.DismissedToStart  <br/>        ) {  <br/>            endActionsConfig.onDismiss()  <br/>            endActionsConfig.stayDismissed  <br/>        } else {  <br/>            false  <br/>        }  <br/>    }  <br/>)</span></pre><h1 id="b849" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">2.表示</h1><p id="906b" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">我们需要传达的最重要的信息是用户的动作是否会触发一个动作，以及这个动作会是什么。我们可以利用这个机会，创造性地传递这一信息。由于我们之前已经将阈值公开为一种状态，所以我们可以在这里使用<code class="fe ln lo lp lq b">willDismissDirection</code>来显示和提供关于何时触发动作的反馈。</p><h2 id="d115" class="ni mi iq bd mj nn no dn mn np nq dp mr la nr ns mt le nt nu mv li nv nw mx nx bi translated">显示动画</h2><p id="c299" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">为了增加一些视觉效果，我用一个圆形动画反转了图标及其背景的颜色。我使用<code class="fe ln lo lp lq b">AnimatedContent</code> composable并传递动作的方向以及它是否会触发一个动作作为目标状态。</p><pre class="kg kh ki kj gt ne lq nf ng aw nh bi"><span id="5822" class="ni mi iq lq b gy nj nk l nl nm">AnimatedContent(  <br/>    targetState = Pair(state.dismissDirection, willDismissDirection != null),  <br/>    transitionSpec = {...}  <br/>) { (direction, willDismiss) -&gt;<br/> // SwipeToDismiss composable implementation<br/>}</span></pre><h2 id="208c" class="ni mi iq bd mj nn no dn mn np nq dp mr la nr ns mt le nt nu mv li nv nw mx nx bi translated">图标动画</h2><p id="36a4" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">在reveal动画之上，我还为图标添加了一个弹跳动画。为此，我还监听了<code class="fe ln lo lp lq b">AnimatedContent</code> composable中的<code class="fe ln lo lp lq b">willDismiss</code>布尔值，如果为真，我就激活它。</p><pre class="kg kh ki kj gt ne lq nf ng aw nh bi"><span id="1d09" class="ni mi iq lq b gy nj nk l nl nm">LaunchedEffect(key1 = Unit, block = {  <br/>    if (willDismiss) {  <br/>        revealSize.snapTo(0f)  <br/>        launch {  <br/>            revealSize.animateTo(1f, animationSpec = tween(400))  <br/>        }  <br/>        iconSize.snapTo(.8f)  <br/>        iconSize.animateTo(  <br/>            1.45f,  <br/>            spring(  <br/>                dampingRatio = Spring.DampingRatioHighBouncy,  <br/>            )  <br/>        )  <br/>        iconSize.animateTo(  <br/>            1f,  <br/>            spring(  <br/>                dampingRatio = Spring.DampingRatioLowBouncy,  <br/>            )  <br/>        )  <br/>    }  <br/>})</span></pre><h2 id="20d0" class="ni mi iq bd mj nn no dn mn np nq dp mr la nr ns mt le nt nu mv li nv nw mx nx bi translated">触觉反馈</h2><p id="2281" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">这是最容易实现的，但是它为用户提供了很多有用的反馈。我们可以监听<code class="fe ln lo lp lq b">willDismissDirection</code>状态，并在触发动作时振动设备。</p><pre class="kg kh ki kj gt ne lq nf ng aw nh bi"><span id="db67" class="ni mi iq lq b gy nj nk l nl nm">val haptic = LocalHapticFeedback.current  <br/>LaunchedEffect(key1 = willDismissDirection, block = {  <br/>    if (willDismissDirection != null) {  <br/>        haptic.performHapticFeedback(HapticFeedbackType.LongPress)  <br/>    }  <br/>})</span></pre><h1 id="38c8" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">3.可发现性</h1><p id="49c5" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">在精心制作了这个漂亮的交互之后，如果用户从来不知道它的存在，那将是一个遗憾。大多数应用程序都向用户暗示，这种交互是可能的，方法是将列表项动画化一点，并显示下面指示动作的图标。但是我们如何在我们的可组合中做到这一点呢？我们可以在composable中添加另一个参数来确定列表项是否应该作为用户的“教程”。这可以是我们注入到列表中的第一个项目或虚拟项目。如果这是真的，我们定义一个无限运行的动画来提示用户这个列表项可以被滑动。</p><pre class="kg kh ki kj gt ne lq nf ng aw nh bi"><span id="def7" class="ni mi iq lq b gy nj nk l nl nm">var showingTutorial by remember {  <br/>    mutableStateOf(showTutorial)  <br/>}  <br/>  <br/>if (showingTutorial) {  <br/>    val infiniteTransition = rememberInfiniteTransition()  <br/>    val x by infiniteTransition.animateFloat(  <br/>        initialValue = 0f,  <br/>        targetValue = width * (startActionsConfig.threshold) / 2f,  <br/>        animationSpec = infiniteRepeatable(  <br/>            animation = tween(500, easing = FastOutSlowInEasing, delayMillis = 1000),  <br/>            repeatMode = RepeatMode.Reverse  <br/>        )  <br/>    )  <br/>  <br/>    LaunchedEffect(key1 = x, block = {  <br/>        state.performDrag(x - state.offset.value)  <br/>    })  <br/>}</span></pre><p id="1b19" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦用户尝试这个动作，我们就取消动画，这样在用户尝试滑动时就不会出现奇怪的动画行为。我们可以通过将<code class="fe ln lo lp lq b">showingTutorial</code>变量设置为false来做到这一点。</p><pre class="kg kh ki kj gt ne lq nf ng aw nh bi"><span id="c0ed" class="ni mi iq lq b gy nj nk l nl nm">SwipeToDismiss(  <br/>    state = state,  <br/>    modifier = Modifier  <br/>        .pointerInteropFilter {  <br/>            if (it.action == MotionEvent.ACTION_DOWN) {  <br/>                showingTutorial = false  <br/>            }  <br/>            false  <br/>        },<br/>        ...<br/>)</span></pre><p id="0195" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是最终教程动画的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/3b6d142e169fb0a8b5a9b1a3f52c9fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*4uuFgI6LkkXDge7R.gif"/></div></figure><p id="b9ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完整的示例项目可以在Github的<a class="ae lr" href="https://github.com/sinasamaki/SwipeDismiss" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="a73c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读。</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="e103" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="of">最初发表于</em><a class="ae lr" href="https://sinasamaki.com/post/2022-09-04-swipe-dismiss/" rel="noopener ugc nofollow" target="_blank"><em class="of"/></a><em class="of">。</em></p></div></div>    
</body>
</html>