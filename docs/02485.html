<html>
<head>
<title>Introducing the JavaScript Window Object — XML and Console</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript窗口对象简介— XML和控制台</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introducing-the-javascript-window-object-web-components-and-console-ac9ef42d454e?source=collection_archive---------8-----------------------#2019-12-03">https://betterprogramming.pub/introducing-the-javascript-window-object-web-components-and-console-ac9ef42d454e?source=collection_archive---------8-----------------------#2019-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="478f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们来看看如何创建web组件和控制台对象</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5f5af5564c8604d1ac25022a06262b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HY6-Y0ry5hB4jpIC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">保罗·卡莫纳在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="cda3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">window</code>对象是一个全局对象，它具有与当前DOM文档相关的属性，这就是浏览器选项卡中的内容。<code class="fe lv lw lx ly b">window</code>对象的<code class="fe lv lw lx ly b">document</code>属性拥有DOM文档以及相关的节点和方法，我们可以用它们来操作DOM节点并监听每个节点的事件。因为<code class="fe lv lw lx ly b">window</code>对象是全局的，所以它在应用程序的每个部分都是可用的。</p><p id="0ff1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个变量在没有<code class="fe lv lw lx ly b">var</code>、<code class="fe lv lw lx ly b">let</code>或<code class="fe lv lw lx ly b">const</code>关键字的情况下被声明时，它们会被自动附加到<code class="fe lv lw lx ly b">window</code>对象上，使它们在你的web应用程序的每个部分都可用。这仅适用于禁用严格模式的情况。如果它被启用，那么声明没有<code class="fe lv lw lx ly b">var</code>、<code class="fe lv lw lx ly b">let</code>或<code class="fe lv lw lx ly b">const</code>的变量将被停止，因为让我们意外地声明全局变量不是一个好主意。</p><p id="1682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">window</code>对象有许多属性。它们包括构造函数、值属性和方法。有一些方法可以操作当前的浏览器标签，比如打开和关闭新的弹出窗口等。</p><p id="d8ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在选项卡式浏览器中，每个选项卡都有自己的<code class="fe lv lw lx ly b">window</code>对象，因此<code class="fe lv lw lx ly b">window</code>对象总是代表代码运行时当前打开的选项卡的状态。然而，有些属性仍然适用于浏览器的所有选项卡，如<code class="fe lv lw lx ly b">resizeTo</code>方法以及<code class="fe lv lw lx ly b">innerHeight</code>和<code class="fe lv lw lx ly b">innerWidth</code>属性。</p><p id="faad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们不需要直接引用<code class="fe lv lw lx ly b">window</code>对象来调用方法和对象属性。例如，如果我们想使用<code class="fe lv lw lx ly b">window.Image</code>构造函数，我们可以只写<code class="fe lv lw lx ly b">new Image()</code>。</p><p id="5be2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一部分，我们继续看看<code class="fe lv lw lx ly b">window</code>对象中有什么。在第1部分中，我们探索了包含在<code class="fe lv lw lx ly b">window</code>对象中的主要构造函数。在这一部分，我们继续看更多的<code class="fe lv lw lx ly b">window</code>对象的构造函数和<code class="fe lv lw lx ly b">window</code>对象的一些属性。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="346f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">更多构造函数</h1><h2 id="d708" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">XMLSerializer</h2><p id="9bd1" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><code class="fe lv lw lx ly b">XMLSerializer</code>构造函数用<code class="fe lv lw lx ly b">serializeToString</code>方法创建对象来构建一个表示DOM树的XML字符串。构造函数不接受任何参数。<code class="fe lv lw lx ly b">serializeToString</code>方法接收一个DOM树节点，然后返回节点中包含所有DOM树内容的字符串。当节点类型无法序列化时，该方法将抛出一个<code class="fe lv lw lx ly b">TypeError</code>。如果树不能被成功序列化，它将抛出一个<code class="fe lv lw lx ly b">InvalidStateError</code>。如果内容格式不正确，那么将抛出一个<code class="fe lv lw lx ly b">SyntaxError</code>。以下类型的节点可以通过<code class="fe lv lw lx ly b">serializeToString</code>方法序列化:</p><ul class=""><li id="5127" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">DocumentType</code></li><li id="66c6" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">Document</code></li><li id="19e7" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">DocumentFragment</code></li><li id="7deb" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">Element</code></li><li id="dd61" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">Comment</code></li><li id="f731" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">Text</code></li><li id="b0c0" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">ProcessingInstruction</code></li><li id="6f46" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">Attr</code></li></ul><p id="db0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以使用下面代码中的<code class="fe lv lw lx ly b">XMLSerializer</code>对象:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="c972" class="my mh it ly b gy oh oi l oj ok">const serializer = new XMLSerializer();<br/>const doc = document;<br/>const docStr = serializer.serializeToString(doc);<br/>console.log(docStr);</span></pre><p id="d9ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码创建了一个<code class="fe lv lw lx ly b">XMLSerializer</code>实例。然后我们将<code class="fe lv lw lx ly b">document</code>对象传入<code class="fe lv lw lx ly b">serializeToString</code>方法，该方法返回DOM树的字符串。如果运行上面的代码，最后一行的<code class="fe lv lw lx ly b">console.log</code>输出应该类似如下:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="0992" class="my mh it ly b gy oh oi l oj ok">&lt;!DOCTYPE html&gt;&lt;html ae ky" href="http://www.w3.org/1999/xhtml" rel="noopener ugc nofollow" target="_blank"&gt;http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;<br/>  &lt;meta http-equiv="content-type" content="text/html; charset=UTF-8" /&gt;<br/>  &lt;title&gt;&lt;/title&gt;<br/>  &lt;meta http-equiv="content-type" content="text/html; charset=UTF-8" /&gt;<br/>  &lt;meta name="robots" content="noindex, nofollow" /&gt;<br/>  &lt;meta name="googlebot" content="noindex, nofollow" /&gt;<br/>  &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;</span><span id="6919" class="my mh it ly b gy ol oi l oj ok">&lt;script type="text/javascript" src="/js/lib/dummy.js"&gt;&lt;/script&gt;</span><span id="6001" class="my mh it ly b gy ol oi l oj ok">&lt;link rel="stylesheet" type="text/css" href="/css/result-light.css" /&gt;</span><span id="ee88" class="my mh it ly b gy ol oi l oj ok">&lt;style id="compiled-css" type="text/css"&gt;<br/>      <br/>  &lt;/style&gt;</span><span id="80a1" class="my mh it ly b gy ol oi l oj ok">&lt;!-- TODO: Missing CoffeeScript 2 --&gt;</span><span id="9815" class="my mh it ly b gy ol oi l oj ok">&lt;script type="text/javascript"&gt;//&amp;lt;![CDATA[</span><span id="115f" class="my mh it ly b gy ol oi l oj ok">window.onload=function(){<br/>      <br/>const serializer = new XMLSerializer();<br/>const doc = document;<br/>const docStr = serializer.serializeToString(doc);<br/>console.log(docStr);</span><span id="8118" class="my mh it ly b gy ol oi l oj ok">}</span><span id="6c56" class="my mh it ly b gy ol oi l oj ok">//]]&amp;gt;&lt;/script&gt;</span><span id="e925" class="my mh it ly b gy ol oi l oj ok">&lt;/head&gt;<br/>&lt;body&gt;</span><span id="fb01" class="my mh it ly b gy ol oi l oj ok">&lt;script&gt;<br/>    // tell the embed parent frame the height of the content<br/>    if (window.parent &amp;amp;&amp;amp; window.parent.parent){<br/>      window.parent.parent.postMessage(["resultsFrame", {<br/>        height: document.body.getBoundingClientRect().height,<br/>        slug: ""<br/>      }], "*")<br/>    }</span><span id="e22b" class="my mh it ly b gy ol oi l oj ok">// always overwrite window.name, in case users try to set it manually<br/>    window.name = "result"<br/>  &lt;/script&gt;</span><span id="15d8" class="my mh it ly b gy ol oi l oj ok">&lt;/body&gt;&lt;/html&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/607f6ed6019a909625cea59c78a0d4b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BWoJTZ9Y4TjRas0h"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@invent?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">科林·梅纳德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="448e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">性能</h1><p id="2c81" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><code class="fe lv lw lx ly b">window</code>对象有许多属性。它从<code class="fe lv lw lx ly b">EventTarget</code>接口继承属性，并实现来自<code class="fe lv lw lx ly b">WindowOrWorkerGlobalScope</code>和<code class="fe lv lw lx ly b">WindowEventHandlers</code>混合的属性。</p><h2 id="f79c" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">窗户关闭</h2><p id="c1ab" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><code class="fe lv lw lx ly b">closed</code>属性是只读属性，指示引用的浏览器窗口是否关闭。如果车窗关闭，则为<code class="fe lv lw lx ly b">true</code>，否则为<code class="fe lv lw lx ly b">false</code>。例如，如果您运行:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="fd38" class="my mh it ly b gy oh oi l oj ok">console.log(window.closed)</span></pre><p id="cdd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在当前打开的窗口上，它应该记录<code class="fe lv lw lx ly b">false</code>，因为浏览器窗口显然是打开的。</p><h2 id="81fb" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">窗口.控制台</h2><p id="77d4" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><code class="fe lv lw lx ly b">console</code>属性是一个具有许多属性的对象，这些属性对于将信息记录到浏览器的控制台非常有用。它是一个只读对象。<code class="fe lv lw lx ly b">console</code>方法对于调试很有用，不应该用于向最终用户呈现信息。<code class="fe lv lw lx ly b">console</code>对象有以下方法:</p><ul class=""><li id="8cb7" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.assert()</code> —如果第一个参数为<code class="fe lv lw lx ly b">false</code>，则将消息和堆栈跟踪记录到控制台</li><li id="0f7f" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.clear()</code> —清除控制台</li><li id="ea3d" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.count()</code> —记录使用给定标签调用该方法的次数</li><li id="4f55" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.countReset()</code> —重置给定标签的计数器值</li><li id="6d5a" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.debug()</code> —将消息记录到控制台，日志级别为“调试”</li><li id="6822" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.dir()</code> —列出给定JavaScript对象的属性。内容将有三角形来显示子对象的内容。</li><li id="5904" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.dirxml()</code> —如果可能，显示对象的HTML或XML表示</li><li id="854f" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.error()</code> —将错误消息记录到控制台。我们可以使用字符串替换和附加参数来格式化日志消息。</li><li id="233c" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.group()</code> —创建一组控制台消息，按级别缩进。我们可以用<code class="fe lv lw lx ly b">groupEnd()</code>移出一个关卡。</li><li id="8e09" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.groupCollapsed()</code> —创建一组控制台消息，按项目折叠的级别缩进。我们可以用<code class="fe lv lw lx ly b">groupEnd()</code>移出一个关卡。</li><li id="1cf0" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.groupEnd()</code> —退出当前内嵌组</li><li id="4761" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.info()</code> —记录信息性消息。我们可以使用字符串替换和附加参数来格式化日志消息。</li><li id="66d7" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.log()</code> —用于信息的一般记录。我们可以使用字符串替换和附加参数来格式化日志消息。</li><li id="156d" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.table()</code> —以表格格式记录和显示数据</li><li id="4316" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.time()</code> —以参数中指定的名称启动计时器。在给定的页面上可以同时运行10000个计时器。</li><li id="4d57" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.timeEnd()</code> —停止指定的计时器，并以秒为单位记录计时器启动后经过的时间。</li><li id="91dc" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.timeLog()</code> —将指定计时器的值记录到控制台</li><li id="e1a9" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.trace()</code> —记录堆栈跟踪</li><li id="c5c3" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">console.warn()</code> —向控制台记录警告消息。我们可以使用字符串替换和附加参数来格式化日志消息。</li></ul><h2 id="9ce8" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">window.customElements</h2><p id="e373" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><code class="fe lv lw lx ly b">customElements</code>属性是一个只读属性，它返回一个对<code class="fe lv lw lx ly b">CustomElementRegistry</code>对象的引用，该对象可用于注册新的定制元素并获取关于以前注册的定制元素的信息。自定义元素也称为Web组件。</p><p id="4398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Web Components是一个标准，它允许我们创建封装其他HTML元素的自定义元素。我们需要这样做，以便我们可以在不同的地方重用HTML元素组。如果没有它，如果我们想要重用它们，我们必须在不同的地方重复相同的HTML元素组。定义的定制元素存储在<code class="fe lv lw lx ly b">CustomElementRegistry</code>中，这样浏览器就知道定义的定制元素实际上是一个有效的元素。</p><p id="194e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要定义一个定制元素，我们可以使用下面代码中的<code class="fe lv lw lx ly b">customElements</code>属性:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="5648" class="my mh it ly b gy oh oi l oj ok">const customElementRegistry = window.customElements;<br/>customElementRegistry.define('hello-element',<br/>  class extends HTMLElement {<br/>    constructor() {<br/>      super();<br/>      const shadow = this.attachShadow({<br/>        mode: 'open'<br/>      });<br/>      const span = document.createElement('span');<br/>      span.setAttribute('class', 'wrapper');<br/>      span.innerHTML = 'Hello';<br/>      shadow.appendChild(span);<br/>    }<br/>  });</span></pre><p id="239a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在HTML文件中，我们添加:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="41a2" class="my mh it ly b gy oh oi l oj ok">&lt;hello-element&gt;&lt;/hello-element&gt;</span></pre><p id="c8de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们使用了<code class="fe lv lw lx ly b">window.customElements</code>对象的<code class="fe lv lw lx ly b">define</code>方法。在<code class="fe lv lw lx ly b">define</code>方法的第一个参数中，我们传入元素名。然后在第二个元素中，我们传入一个<code class="fe lv lw lx ly b">HTMLElement</code>类，它实际上是JavaScript中的一个对象。在<code class="fe lv lw lx ly b">class</code>的<code class="fe lv lw lx ly b">constructor</code>方法中，我们创建一个<code class="fe lv lw lx ly b">span</code>元素，将<code class="fe lv lw lx ly b">innerHTML</code>设置为<code class="fe lv lw lx ly b">‘Hello'</code>，然后将它附加到影子根，这是Web组件的根。如果我们运行上面的代码，我们应该会看到屏幕上显示单词<em class="on"> Hello </em>。</p><p id="f812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">define</code>方法有三个参数。第一个是<code class="fe lv lw lx ly b">name</code>，它是一个具有定制元素名称的字符串。第二个参数是一个<code class="fe lv lw lx ly b">HTMLElement</code>构造函数，其中，在构造函数类中，我们创建了想要附加到影子根的HTML元素，并显示了创建的元素。第三个参数是可选参数，它控制元素的定义方式。唯一受支持的属性是<code class="fe lv lw lx ly b">extends</code>属性，它是一个字符串，允许我们指定要扩展的内置元素。这对于创建定制元素很有用，定制一个内置元素，如<code class="fe lv lw lx ly b">div</code>、<code class="fe lv lw lx ly b">span</code>或<code class="fe lv lw lx ly b">p</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4fe4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">摘要</h1><p id="0d65" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在这一部分，我们几乎没有触及<code class="fe lv lw lx ly b">window</code>物体的表面。我们只研究了在各种情况下可能会派上用场的几个构造函数。</p><p id="b0d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了一个<code class="fe lv lw lx ly b">XMLSerializer</code>对象，它允许我们使用<code class="fe lv lw lx ly b">serializeToString</code>方法，该方法带有一个实例，该实例允许我们传入一个DOM树节点，并获取一个字符串，其中所有子元素都被转换为一个字符串。</p><p id="abff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们查看了<code class="fe lv lw lx ly b">window</code>对象的一些属性，包括<code class="fe lv lw lx ly b">closed</code>、<code class="fe lv lw lx ly b">console</code>和<code class="fe lv lw lx ly b">customElements</code>属性。属性让我们检查当前的浏览器窗口是否关闭。<code class="fe lv lw lx ly b">console</code>对象让我们以各种方式记录数据，用于调试目的。它有各种方法对日志输出进行分组，获得执行代码的时间，改变日志输出的风格，等等。属性让我们创建新的定制元素，这些元素被浏览器识别为Web组件，Web组件是封装内置HTML元素的实体，这样我们就可以通过在代码中引用它们来重用它们。</p></div></div>    
</body>
</html>