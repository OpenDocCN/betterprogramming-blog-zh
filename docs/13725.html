<html>
<head>
<title>Automate Your Music Collection Using This Python Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用这个Python包自动化你的音乐收藏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/automate-your-music-collection-using-this-python-package-3891754a48dc?source=collection_archive---------9-----------------------#2022-09-20">https://betterprogramming.pub/automate-your-music-collection-using-this-python-package-3891754a48dc?source=collection_archive---------9-----------------------#2022-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="18f8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你不需要一个大的音乐云服务来跟踪你的收听习惯和发现新的音乐</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/795777c7b4aaac87ebce2cd3ddd35695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*OsAJt-7VgJiFGM6No_pieg.png"/></div></figure><p id="5cb0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">近二十年来，我一直是mpd和mopidy的热心用户。</p><p id="3213" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我已经写了一篇关于如何利用mopidy的文章，包括Spotify、Tidal、YouTube、Bandcamp、Plex、TuneIn、SoundCloud等。)、Snapcast(其开箱即用的多房间聆听体验)和Platypush(其自动化挂钩允许您轻松创建if-this-then-than规则来管理您的音乐事件)将您的聆听体验提升到一个新的水平，同时使用开放协议和易于扩展的开源软件。</p><p id="79fb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">有一个特性我在之前的文章中还没有涉及到:你的音乐收藏的自动化。</p><p id="5000" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Spotify、Tidal和其他音乐流媒体服务分别为您提供诸如<em class="ln">探索周刊</em>或<em class="ln">发布雷达</em>播放列表等功能，其中包含您可能喜欢的曲目或您可能感兴趣的新发布曲目。</p><p id="6431" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">问题是这些服务都有很大的取舍:</p><ol class=""><li id="040f" class="lo lp it ks b kt ku kw kx kz lq ld lr lh ls ll lt lu lv lw bi translated">他们的算法是封闭的。你不知道Spotify是如何计算出哪些歌曲应该出现在你的智能播放列表中的。过去几个月，Spotify经常向我推荐我以前听过或跳过的艺术家的歌曲。没有透明的方式告诉算法，“嘿，实际上，我希望你给我更多这种音乐的建议——或者可能只根据我在这个时间范围内听的音乐来计算建议，或者可能更多地权衡这种类型。”</li><li id="3bc4" class="lo lp it ks b kt lx kw ly kz lz ld ma lh mb ll lt lu lv lw bi translated">这些特性与您使用的服务紧密相关。如果您取消订阅Spotify，您也将失去这些智能功能。像Spotify这样的公司使用这种功能作为锁定机制——你可以随时查看，但如果你这样做了，没有人会向你提供他们聪明的建议。</li></ol><p id="2c91" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在过去几个月从Spotify迁移到Tidal后(TL；DR: Spotify在过去十年中多次破坏了他们的开发者体验，他们在没有提供任何替代方案的情况下扼杀了libspotify，这是我的最后一颗钉子)，我觉得很怀念他们的智能混音、发现和新发布的播放列表。</p><p id="1a96" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">但是，另一方面，Tidal花了一些时间来了解我的收听习惯，即使它做到了，它也经常生成比Spotify差一英寸的智能播放列表。我问自己，为什么我的音乐探索体验会与地球上的一项云服务如此紧密地联系在一起。我决定，是时候让我自动生成与服务无关的音乐建议了:这不再是火箭科学，有大量的服务可以让你获得艺术家或类似于某些音乐的歌曲作为输入，没有理由感到被Spotify、谷歌、Tidal或其他云音乐提供商锁定。</p><p id="4626" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在本文中，我们将介绍如何:</p><ol class=""><li id="8a2e" class="lo lp it ks b kt ku kw kx kz lq ld lr lh ls ll lt lu lv lw bi translated">使用Platypush自动跟踪您从任何设备上听到的音乐</li><li id="d6b3" class="lo lp it ks b kt lx kw ly kz lz ld ma lh mb ll lt lu lv lw bi translated">使用最后一个来计算可能与您最近听过的音乐相似的建议曲目。FM API</li><li id="4e7f" class="lo lp it ks b kt lx kw ly kz lz ld ma lh mb ll lt lu lv lw bi translated">生成一个类似于Spotify的<em class="ln">探索周刊</em>播放列表，无需依赖Spotify</li><li id="ac8d" class="lo lp it ks b kt lx kw ly kz lz ld ma lh mb ll lt lu lv lw bi translated">通过订阅RSS订阅源获取最新发布的专辑和单曲</li><li id="7f2b" class="lo lp it ks b kt lx kw ly kz lz ld ma lh mb ll lt lu lv lw bi translated">通过过滤那些你已经听过至少一次的艺术家的作品，生成一个每周播放列表</li></ol><h1 id="0fd6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">佐料</h1><p id="a0bd" class="pw-post-body-paragraph kq kr it ks b kt mu ju kv kw mv jx ky kz mw lb lc ld mx lf lg lh my lj lk ll im bi translated">我们将使用Platypush来处理以下特性:</p><ol class=""><li id="171f" class="lo lp it ks b kt ku kw kx kz lq ld lr lh ls ll lt lu lv lw bi translated">将我们的收听历史存储到本地数据库，或者与类似<a class="ae lm" href="https://last.fm" rel="noopener ugc nofollow" target="_blank"> last.fm </a>的搜索服务同步。</li><li id="bbd1" class="lo lp it ks b kt lx kw ly kz lz ld ma lh mb ll lt lu lv lw bi translated">定期检查我们新收听的曲目，并使用last.fm API检索类似的曲目。</li><li id="541c" class="lo lp it ks b kt lx kw ly kz lz ld ma lh mb ll lt lu lv lw bi translated">基于一个简单的分数生成一个每周发现播放列表，该分数根据在某段时间内收听的曲目的匹配分数对建议进行排序，并增加出现多次的建议的权重。</li><li id="0642" class="lo lp it ks b kt lx kw ly kz lz ld ma lh mb ll lt lu lv lw bi translated">监控newalbumreleases.net RSS频道的新发布，并创建一个每周<em class="ln">发布雷达</em>播放列表，其中包含我们至少听过一次的艺术家的作品。</li></ol><p id="c753" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">本教程需要:</p><ol class=""><li id="da4b" class="lo lp it ks b kt ku kw kx kz lq ld lr lh ls ll lt lu lv lw bi translated">存储您的收听历史和建议的数据库。数据库初始化脚本已经针对Postgres进行了测试，但是只需做很少的修改，就可以轻松适应MySQL或SQLite。</li><li id="799a" class="lo lp it ks b kt lx kw ly kz lz ld ma lh mb ll lt lu lv lw bi translated">机器(RaspberryPi、家庭服务器、VPS、未使用的平板电脑等。)来运行Platypush自动化。</li><li id="7d73" class="lo lp it ks b kt lx kw ly kz lz ld ma lh mb ll lt lu lv lw bi translated">Spotify或Tidal帐户。报告的例子将通过使用<code class="fe mz na nb nc b">music.tidal</code> Platypush插件在Tidal帐户上生成播放列表，但应该很容易通过使用<code class="fe mz na nb nc b">music.spotify</code>插件使它们适应Spotify，甚至通过使用YouTube API适应YouTube，甚至适应本地M3U播放列表。</li></ol><h1 id="3104" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置软件</h1><p id="e8aa" class="pw-post-body-paragraph kq kr it ks b kt mu ju kv kw mv jx ky kz mw lb lc ld mx lf lg lh my lj lk ll im bi translated">首先安装Platypush的<a class="ae lm" href="https://docs.platypush.tech/platypush/plugins/music.tidal.html" rel="noopener ugc nofollow" target="_blank"> Tidal </a>、<a class="ae lm" href="https://docs.platypush.tech/platypush/plugins/rss.html" rel="noopener ugc nofollow" target="_blank"> RSS </a>和<a class="ae lm" href="https://docs.platypush.tech/platypush/plugins/lastfm.html" rel="noopener ugc nofollow" target="_blank"> Last.fm </a>集成:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="e6d1" class="nh md it nc b gy ni nj l nk nl">[sudo] pip install 'platypush[tidal,rss,lastfm]'</span></pre><p id="04d5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你想使用Spotify而不是Tidal，那么只需从额外依赖列表中删除<code class="fe mz na nb nc b">tidal</code>—<a class="ae lm" href="https://docs.platypush.tech/platypush/plugins/music.spotify.html" rel="noopener ugc nofollow" target="_blank">Spotify插件</a>不需要额外的依赖。</p><p id="dcea" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你打算通过mpd/mopidy听音乐，那么你可能也想把<code class="fe mz na nb nc b">mpd</code>包含在额外依赖列表中，这样Platypush就可以通过mpd协议直接监控你的收听活动。</p><p id="2ee5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">接下来让我们在<code class="fe mz na nb nc b">~/.config/platypush/config.yaml</code>下配置一个简单的配置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6c91" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">运行<code class="fe mz na nb nc b">platypush</code>命令启动Platypush。第一次，它应该提示您认证您的用户所需的tidal.com链接。在浏览器中打开它，并授权应用程序。下一次运行应该不再要求您进行身份验证。</p><p id="2a9d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一旦Platypush依赖项就位，我们就开始配置数据库。</p><h1 id="8b07" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据库配置</h1><p id="5315" class="pw-post-body-paragraph kq kr it ks b kt mu ju kv kw mv jx ky kz mw lb lc ld mx lf lg lh my lj lk ll im bi translated">我假设您在某个地方运行了Postgres数据库，但是下面的脚本也可以很容易地适用于其他DBMSs。</p><p id="1499" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下面是数据库初始化脚本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="898d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在数据库上运行脚本——如果一切顺利，那么所有的表都应该成功创建了。</p><h1 id="c629" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">同步您的音乐活动</h1><p id="6a93" class="pw-post-body-paragraph kq kr it ks b kt mu ju kv kw mv jx ky kz mw lb lc ld mx lf lg lh my lj lk ll im bi translated">既然所有的依赖项都已就绪，那么是时候配置逻辑将音乐活动存储到数据库中了。</p><p id="d296" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你的大部分音乐活动都是通过mpd/mopidy发生的，那么将你的活动存储到数据库中就像在<code class="fe mz na nb nc b"><a class="ae lm" href="https://docs.platypush.tech/platypush/events/music.html" rel="noopener ugc nofollow" target="_blank">NewPlayingTrackEvent</a></code> <a class="ae lm" href="https://docs.platypush.tech/platypush/events/music.html" rel="noopener ugc nofollow" target="_blank">事件</a>上创建一个挂钩，在<code class="fe mz na nb nc b">tmp_music</code>上插入任何新播放的曲目一样简单。将以下内容粘贴到一个新的Platypush用户脚本中(例如<code class="fe mz na nb nc b">~/.config/platypush/scripts/music/sync.py</code>):</p><p id="08ff" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">或者，如果你还想同步发生在其他客户端(如Spotify/Tidal应用程序或web view，或通过移动设备)的音乐活动，你可以考虑利用<code class="fe mz na nb nc b">Last.fm</code>。<code class="fe mz na nb nc b">Last.fm</code>(或其开放的替代产品Libre.fm)是一项与大多数音乐播放器兼容的搜索服务。</p><p id="1466" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Spotify和Tidal都支持scrobbleling，Android应用程序可以抓取你手机上的任何音乐活动并进行scrobb。甚至有<a class="ae lm" href="https://chrome.google.com/webstore/detail/web-scrobbler/hhinaapppaileiechjoiifaancjggfjm?hl=en" rel="noopener ugc nofollow" target="_blank">浏览器扩展</a>允许你从任何浏览器标签跟踪任何音乐活动。</p><p id="65be" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，另一种方法可能是将你的mpd/mopidy音乐活动以及你的浏览器内或移动音乐活动发送到<code class="fe mz na nb nc b">last.fm</code> / <code class="fe mz na nb nc b">libre.fm</code>。相应的挂钩应该是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="fe9a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果您选择scrobble方式，那么您可能希望定期将scrobble历史记录同步到本地数据库，例如，通过每30秒运行一次的cron:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="352f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这个cron会将您的搜索历史同步到您的本地数据库，因此我们可以使用本地数据库作为后续步骤的事实来源——无论音乐是从哪里播放的。</p><p id="3a5f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">要测试这种逻辑，只需重启Platypush，从你最喜欢的播放器中播放一些音乐，并检查所有内容是否都被插入到数据库中——即使我们在<code class="fe mz na nb nc b">tmp_music</code>表上插入曲目，收听历史也应该通过我们在初始化时创建的触发器在适当的表上自动标准化。</p><h1 id="614d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更新建议</h1><p id="a4c5" class="pw-post-body-paragraph kq kr it ks b kt mu ju kv kw mv jx ky kz mw lb lc ld mx lf lg lh my lj lk ll im bi translated">现在，在一个数据源中获取您的收听历史的所有管道都已就绪，让我们转到基于您的收听历史重新计算建议的逻辑。</p><p id="2d0b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们将再次使用last.fm API来获取与我们最近听过的歌曲相似的歌曲——我发现<code class="fe mz na nb nc b">last.fm</code>的建议通常比Spotify的建议更相关。</p><p id="3b24" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了简单起见，让我们将数据库表映射到一些SQLAlchemy ORM类，这样接下来的SQL交互就可以显著简化。ORM模型可以保存在<code class="fe mz na nb nc b">~/.config/platypush/music/db.py</code>下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="fd11" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然后在<code class="fe mz na nb nc b">~/.config/platypush/scripts/music/suggestions.py</code>下创建一个新的用户脚本，内容如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3118" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">重启Platypush，让它运行一段时间。cron将分批运行，每批10个项目(可以很容易地定制)，所以您的<code class="fe mz na nb nc b">music_suggestions</code>表应该在几分钟后开始被填充。</p><h1 id="abf6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">正在生成发现播放列表</h1><p id="b196" class="pw-post-body-paragraph kq kr it ks b kt mu ju kv kw mv jx ky kz mw lb lc ld mx lf lg lh my lj lk ll im bi translated">迄今为止，我们已经实现了以下目标:</p><ul class=""><li id="2469" class="lo lp it ks b kt ku kw kx kz lq ld lr lh ls ll no lu lv lw bi translated">我们有一个逻辑将我们的收听历史同步到本地数据库。</li><li id="6c81" class="lo lp it ks b kt lx kw ly kz lz ld ma lh mb ll no lu lv lw bi translated">我们有一种方法可以将last.fm / libre.fm scrobbles同步到同一个数据库。</li><li id="00ec" class="lo lp it ks b kt lx kw ly kz lz ld ma lh mb ll no lu lv lw bi translated">我们有一个cronjob，它定期扫描我们的收听历史，并通过last.fm API获取建议。</li></ul><p id="6328" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，让我们用一个cron将所有这些放在一起，该cron每周(或每天，或以我们喜欢的任何时间间隔)运行，它执行以下操作:</p><ul class=""><li id="b459" class="lo lp it ks b kt ku kw kx kz lq ld lr lh ls ll no lu lv lw bi translated">它检索我们在指定时间段内的收听历史。</li><li id="793e" class="lo lp it ks b kt lx kw ly kz lz ld ma lh mb ll no lu lv lw bi translated">它检索与我们的收听历史相关联的建议曲目。</li><li id="0674" class="lo lp it ks b kt lx kw ly kz lz ld ma lh mb ll no lu lv lw bi translated">它不包括我们已经听过的曲目，或者已经包含在以前的探索播放列表中的曲目。</li><li id="01bf" class="lo lp it ks b kt lx kw ly kz lz ld ma lh mb ll no lu lv lw bi translated">它会生成包含这些曲目的新发现播放列表，并根据简单的分数进行排名:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/f1739b383826c14efbe5c5f613576086.png" data-original-src="https://miro.medium.com/v2/resize:fit:310/format:webp/1*nPHebbRnqdBo64Gx0R2veg.png"/></div></figure><p id="6267" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">其中<code class="fe mz na nb nc b">ρ(i)</code>是第I条建议曲目的排名，<code class="fe mz na nb nc b">L(i)</code>是相似度中第I条曲目的收听曲目集，<code class="fe mz na nb nc b">m(i, j)</code>是last.fm API报告的<code class="fe mz na nb nc b">i</code>和<code class="fe mz na nb nc b">j</code>之间的匹配分数。</p><p id="c269" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们把所有这些放在一个在<code class="fe mz na nb nc b">~/.config/platypush/scripts/music/discovery.py</code>中定义的cron中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="59d3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您可以通过Python解释器测试cronjob，而不必等到下一个星期一:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1d2c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果一切顺利，您应该很快会在您的收藏中看到一个名为Discover Weekly [date]的新播放列表。恭喜你！</p><h1 id="2f9d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">发布雷达播放列表</h1><p id="95b1" class="pw-post-body-paragraph kq kr it ks b kt mu ju kv kw mv jx ky kz mw lb lc ld mx lf lg lh my lj lk ll im bi translated">Spotify和Tidal的另一个伟大功能是能够提供“release radar”播放列表，其中包含我们可能喜欢的艺术家的新专辑。</p><p id="6c84" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">不过，我们现在有一个强大的方法来自己创建这样的播放列表。我们之前配置了Platypush来订阅来自newalbumreleases.net的RSS提要。填充我们的release radar播放列表包括以下步骤:</p><ol class=""><li id="b260" class="lo lp it ks b kt ku kw kx kz lq ld lr lh ls ll lt lu lv lw bi translated">创建一个钩子来响应这个提要上的<code class="fe mz na nb nc b"><a class="ae lm" href="https://docs.platypush.tech/platypush/events/rss.html" rel="noopener ugc nofollow" target="_blank">NewFeedEntryEvent</a></code> <a class="ae lm" href="https://docs.platypush.tech/platypush/events/rss.html" rel="noopener ugc nofollow" target="_blank">事件</a>。</li><li id="0368" class="lo lp it ks b kt lx kw ly kz lz ld ma lh mb ll lt lu lv lw bi translated">钩子将在初始化数据库时创建的<code class="fe mz na nb nc b">new_release</code>表上存储与我们的集合中的艺术家相匹配的新版本。</li><li id="abce" class="lo lp it ks b kt lx kw ly kz lz ld ma lh mb ll lt lu lv lw bi translated">一个cron将每周扫描这个表，在Spotify/Tidal上搜索曲目，并填充我们的播放列表，就像我们为<em class="ln"> Discover Weekly </em>所做的那样。</li></ol><p id="c574" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们将这些部分放在一个新的用户脚本中，例如存储在<code class="fe mz na nb nc b">~/.config/platypush/scripts/music/releases.py</code>下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ac6d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">就像前一个例子一样，通过在Python解释器中简单地运行<code class="fe mz na nb nc b">refresh_release_radar_cron</code>就可以很容易地测试它是否工作。就像discovery播放列表的情况一样，如果你使用Spotify而不是Tidal，事情也会发生——只需用<code class="fe mz na nb nc b">music.spotify</code>替换<code class="fe mz na nb nc b">music.tidal</code>插件引用。</p><p id="2884" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果一切按预期进行，你将在每周一得到一个名为New Releases [date]的新播放列表，里面有你听过的艺术家的新作品。</p><h1 id="fcf5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="e5b3" class="pw-post-body-paragraph kq kr it ks b kt mu ju kv kw mv jx ky kz mw lb lc ld mx lf lg lh my lj lk ll im bi translated">如今，音乐发烧友无需离开他们的音乐应用程序就能发现许多新音乐。然而，主要音乐云提供商提供的智能播放列表通常是隐式锁定的，他们选择应该出现在播放列表中的曲目的方式可能不透明或不可修改。</p><p id="7188" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">阅读完本文后，您应该能够生成您的发现和新发布的播放列表，而不依赖于特定音乐云的建议。这也可能让你更容易更换音乐提供商:即使你放弃Spotify或Tidal，你的音乐建议逻辑也会在你决定去的任何时候跟随你。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="2428" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="ln">原发布于</em><a class="ae lm" href="https://blog.platypush.tech/article/Automate-your-music-collection" rel="noopener ugc nofollow" target="_blank"><em class="ln">https://blog . platypush . tech</em></a><em class="ln">。</em></p></div></div>    
</body>
</html>