<html>
<head>
<title>Compound Component Design Pattern in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的复合组件设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/compound-component-design-pattern-in-react-34b50e32dea0?source=collection_archive---------2-----------------------#2022-01-05">https://betterprogramming.pub/compound-component-design-pattern-in-react-34b50e32dea0?source=collection_archive---------2-----------------------#2022-01-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ee35" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">避免正确训练，并编写具有隐式状态共享的表达性组件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/625f0a22a7592cf01bc026f12ae055b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e4sAc_kvf0VcHJ8g"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@danist07?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Danist Soh </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="a83b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是复合组件？</h1><p id="90b4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">复合组件是一种React模式，它为父组件与其子组件通信提供了一种富有表现力和灵活性的方式，同时以富有表现力的方式分离了逻辑和UI。</p><p id="84b1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在复合组件中，我们不是通过props传递状态，而是将元素作为子元素传递给父元素。</p><p id="4441" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">那么我们实际上在谈论什么:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="6270" class="mu kx iq mq b gy mv mw l mx my">&lt;select name="places" id="places-select"&gt;<br/>    &lt;option value="paris"&gt;Paris&lt;/option&gt;<br/>    &lt;option value="boston"&gt;Boston&lt;/option&gt;<br/>    &lt;option value="london"&gt;London&lt;/option&gt;<br/>&lt;/select&gt;</span></pre><p id="e8ee" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在HTML中，我们可以将选项作为子元素传递给<code class="fe mz na nb mq b">&lt;select&gt;</code>元素。select元素管理状态，我们清楚地看到哪些元素作为选项传递给select。</p><p id="230a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在React中，我们可以做非常类似的事情，将子元素作为元素传递，而父元素管理隐式状态。</p><h1 id="d7ca" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">在React中实现复合组件模式</h1><p id="a00f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们从一个简单的卡组件开始。我想在卡片上呈现链接，如果有很多链接，限制显示的数量，并有一个<code class="fe mz na nb mq b">show more</code> <code class="fe mz na nb mq b">show less</code>切换来扩展或折叠卡片以显示链接。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="bd22" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下面是我的简单组件的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nd l"/></div></figure><p id="dd0d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我的组件接受内容作为道具，并为我的内容对象中的每一项呈现一个<code class="fe mz na nb mq b">&lt;CardItem /&gt;</code>。</p><p id="d015" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">组件以折叠状态开始，这导致它只呈现三个链接(我设置了三个<code class="fe mz na nb mq b">LIMIT</code>)。但是我也有一个切换功能，如果点击<code class="fe mz na nb mq b">show more</code>，折叠状态会改变，所有的链接都会呈现出来——<code class="fe mz na nb mq b">show more</code>变成<code class="fe mz na nb mq b">show less</code>。</p><p id="19bd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">很简单，对吧？但是如果这个组件有多个用例呢？如果我想重用这种切换显示更多/更少的功能，但每次在不同的卡上使用不同的UI，该怎么办？</p><p id="5538" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">以我目前的组件，我不具备这样做所需的灵活性。我的功能与UI相结合。</p><p id="7cba" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果我需要一个与我的<code class="fe mz na nb mq b">&lt;CardItem /&gt;</code>不同的组件用于链接，我将不得不传递一个道具来控制不同的情况，或者如果道具的数量变得太复杂，甚至可能创建一个新的组件。</p><p id="dd0c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这就是我们的复合组件的用武之地:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nd l"/></div></figure><p id="c00d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里我们从一个Card组件开始，管理一个<code class="fe mz na nb mq b">isCollapsed</code>状态，就像我们之前的组件一样，但是现在我们使用上下文API来存储值。</p><p id="d53d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们还使用两个函数来展开和折叠，并把它们放在卡片上下文中。我们的组件接受的唯一道具是<code class="fe mz na nb mq b">children</code>，我们在一个卡片div中呈现我们的上下文提供者中的子元素。</p><p id="6daf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">接下来，我想为我的卡片内容创建一个组件，以及一种方法来控制我用于展开和折叠的元素。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nd l"/></div></figure><p id="a503" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe mz na nb mq b">CardContent</code>映射到其子节点，并控制有多少子节点(在本例中是链接)被渲染。</p><p id="5619" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe mz na nb mq b">Expand</code>和<code class="fe mz na nb mq b">Collapse</code>组件使用来自<code class="fe mz na nb mq b">Card</code>组件内部的<code class="fe mz na nb mq b">expand</code>和<code class="fe mz na nb mq b">collapse</code>函数，以及从<code class="fe mz na nb mq b">CardContext</code>中提取的<code class="fe mz na nb mq b">isCollapsed</code>布尔值。</p><p id="f238" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，两个函数都使用React的<code class="fe mz na nb mq b">cloneElement()</code>方法返回一个元素，该方法将克隆作为子元素传递给组件的任何元素，并使用给定的配置返回它。在这种情况下，一个具有指定功能的<code class="fe mz na nb mq b">onClick</code>。(点击阅读更多关于React的克隆元素<a class="ae kv" href="https://reactjs.org/docs/react-api.html#cloneelement" rel="noopener ugc nofollow" target="_blank">。)</a></p><p id="f4fe" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，我们导出我们的<code class="fe mz na nb mq b">Card</code>组件及其所有组件。</p><p id="3a1d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这种技术非常明确，让组件的用户清楚地看到每个方法在做什么。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nd l"/></div></figure><p id="fe0d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在我们终于可以使用我们的组件了！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nd l"/></div></figure><p id="5c61" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在<code class="fe mz na nb mq b">Card.CardContent</code>、<code class="fe mz na nb mq b">Card.Expand</code>和<code class="fe mz na nb mq b">Card.Collapse</code>中，我们可以将任何元素作为子元素，它们将始终拥有组件的功能。</p><p id="e3a7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这提供了使用此卡的折叠和扩展功能的灵活性，几乎任何组件，它完全解耦！</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="9455" class="kw kx iq bd ky kz nm lb lc ld nn lf lg jw no jx li jz np ka lk kc nq kd lm ln bi translated">结论</h1><p id="41d0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">可重用性是React的关键，了解您手头有哪些工具可以让开发变得更加有趣和容易。</p><p id="8614" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我希望这篇教程能让你对如何使用复合组件以及它们能给项目带来的价值有所了解:)</p><p id="ddd3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请务必在此查看该项目的code sandbox<a class="ae kv" href="https://codesandbox.io/s/compound-component-card-example-ht8xg" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>