<html>
<head>
<title>Our Journey Building Docketeer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们建造码头的旅程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/our-journey-building-docketeer-an-open-source-docker-container-monitoring-and-visualization-tool-fb6c26d8908a?source=collection_archive---------9-----------------------#2020-11-13">https://betterprogramming.pub/our-journey-building-docketeer-an-open-source-docker-container-monitoring-and-visualization-tool-fb6c26d8908a?source=collection_archive---------9-----------------------#2020-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="06bd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个开源的Docker容器监控和可视化工具</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/07b2fc82c62b97ce1c4f4fe12afcdaaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N6w7327rTM6DHEVG"/></div></div></figure><p id="e54e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你点击了这个链接，那么很有可能你关心码头，集装箱，或两者兼而有之。我们不怪你！在dockeeter，我们认为容器太棒了，我们用我们的容器监控工具<a class="ae ln" href="https://github.com/open-source-labs/Docketeer" rel="noopener ugc nofollow" target="_blank">dockeeter</a>构建了一个完整的开源应用程序来改善开发体验。</p><p id="8792" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Docketeer上工作，我们最喜欢的事情之一就是让开发人员能够从他们的容器化应用程序中获得最大的收益。因此，当规划最新版本时，我们决定专注于提供对容器性能更具可操作性的洞察。</p><p id="2022" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">经过深思熟虑，我们同意增加以下功能:</p><ul class=""><li id="11b4" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">能够查看一段时间内的容器指标(现有版本只显示实时指标)。</li><li id="bf3d" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">当容器使用大量CPU和内存(超过80%)或容器停止运行时，自动通知系统向用户发送文本警报。</li><li id="6a5e" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">包括查看最近GitHub历史的能力，以帮助调试哪些代码更改可能是性能下降的根源。</li></ul><p id="13e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们开始之前，我们应该为我们的技术堆栈做好准备。Docketeer由以下部分组成:</p><ul class=""><li id="3d20" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">React(钩子，路由器):前端库</li><li id="db83" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">Redux:状态管理库</li><li id="0ae4" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">电子:桌面应用框架</li><li id="4a2f" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">网络包:Bundler</li><li id="dab7" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">Twilio:短信服务</li><li id="cc69" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">Chart.js:数据可视化</li><li id="c1c1" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">Jest:测试框架</li><li id="b1da" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">酶:测试工具</li><li id="58e2" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">PostgreSQL:关系数据库</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="fb97" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">从命令行提取Docker统计信息并放入Docketeer</h1><p id="a510" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">我们的应用程序依赖于从<code class="fe ng nh ni nj b"><a class="ae ln" href="https://docs.docker.com/engine/reference/commandline/stats/" rel="noopener ugc nofollow" target="_blank">docker stats</a></code>命令的标准输出中提取容器指标，返回运行容器的实时数据流。</p><p id="38f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了从命令行中提取这些信息并使其对Docketeer有用，我们的团队采用了以下方法:</p><ul class=""><li id="46e2" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">利用Node.js的child_process模块将标准输出引入我们的应用程序。</li><li id="178d" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">解析标准输出，并传递给应用程序可视化数据所需的数据结构</li></ul><p id="9798" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在第一个产品发布中，我们的团队编写了一个解析算法来重新格式化输出并更新我们的全局Redux存储。虽然这种方法确实有效，但仍有很大的优化空间。我们最初算法的时间复杂度是次优的，由于这是一个开源项目，我们希望确保其他开发人员能够在代码基础上构建，这意味着使它更加明确。</p><p id="3cfe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">值得注意的是，因为我们实时显示数据，所以我们以高频率从docker stats读取输出，<em class="nk">每5秒</em>！因此，我们的解析算法中的任何低效都可能在整个应用程序中引发问题。</p><p id="235a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们开始寻找简化算法的方法。谢天谢地，我们发现了<code class="fe ng nh ni nj b">--format</code>！</p><p id="9161" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如Docker文档中所述:</p><blockquote class="nl nm nn"><p id="2b95" class="kr ks nk kt b ku kv jr kw kx ky ju kz no lb lc ld np lf lg lh nq lj lk ll lm ij bi translated">格式化选项(<code class="fe ng nh ni nj b">--format</code>)使用Go模板漂亮地打印容器输出。</p></blockquote><p id="a254" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这很棒，因为它允许我们通过制定如下命令来显著减少数据解析的数量:</p><pre class="kg kh ki kj gt nr nj ns nt aw nu bi"><span id="a06d" class="nv mk iq nj b gy nw nx l ny nz">'docker stats --no-stream --format "{{json .}},"'</span></pre><p id="ec73" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://docs.docker.com/config/formatting/" rel="noopener ugc nofollow" target="_blank">命令</a>可能看起来有点混乱，但重要的是它允许我们使用<a class="ae ln" href="https://golang.org/pkg/text/template/" rel="noopener ugc nofollow" target="_blank"> Go模板</a>将Docker stats的输出定制成我们选择的格式。</p><p id="844a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在是测试时间，我们所有的测试都在macOS上通过了，但是在我们团队的Windows机器上没有通过。</p><p id="419d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您想使用类似的策略，需要注意的一点是Windows和Mac shells的执行方式不同，导致我们的字符串在Windows上无法解析。经过一番调查，我们得出了以下结论:</p><pre class="kg kh ki kj gt nr nj ns nt aw nu bi"><span id="cedc" class="nv mk iq nj b gy nw nx l ny nz">'docker stats --no-stream --format \'{"block": "{{.BlockIO}}", "cid": "{{.ID}}", "cpu": "{{.CPUPerc}}", "mp": "{{.MemPerc}}","mul": "{{.MemUsage}}", "name": "{{.Name}}","net": "{{.NetIO}}", "pids": "{{.PIDs}}"},\''</span></pre><p id="6adf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这在Windows和Mac机器上都是完美的——它现在将返回的输出编码为JSON字符串。</p><p id="a0f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，这个新命令允许我们将解析功能减少三分之二，并且由于我们简化的、更明确的代码，使得其他开发人员更容易为产品做出贡献。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="802b" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">决定数据库</h1><p id="5288" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">我们在这次迭代中面临的另一个关键问题是，是使用关系数据库还是非关系数据库来存储我们的数据。</p><p id="c2d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于我们添加的特性依赖于以一致的频率(每<strong class="kt ir"> </strong>五分钟)写入数据库，我们最初的方法是利用非关系数据库。然而，最终我们决定使用SQL，理由如下:</p><ul class=""><li id="2fbb" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">首先，我们的应用程序主要限于处理来自Docker stats的数据，这为它提供了一个固有的结构，并使它非常适合严格的模式实施</li><li id="6b9d" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">其次，我们的产品路线图包括需要关系数据结构的特性，以及利用用户、容器和容器的定制通知设置之间的多对多关系的使用连接表的能力。</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="b938" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated"><strong class="ak">使用容器化数据库</strong></h1><p id="7ab3" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">决定了数据模型之后，我们需要决定是将其存储在云托管的实例中，还是利用Docker容器来托管我们的Docker容器监控服务。</p><p id="90f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用docker compose为我们的用户创建无缝体验的能力被证明不仅有趣，而且对我们的用例有益。因此，我们的用户不需要手动设置数据库实例来使用Docketeer。在第一次启动时，应用程序建立一个docker网络，从Postgres创建一个容器(从Docker Hub中提取，如果还没有在它们的图像列表中)，创建数据库容器并构建必要的表和模式。所有这些操作都是即时完成的，无需用户进行任何配置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/fe423143803916b08d7d62749121403c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hzL0YIb1VxtEBcQ0WsajBg.png"/></div></div></figure><p id="b884" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用容器化的<code class="fe ng nh ni nj b">Postgres</code>实例还具有性能优势，因为查询不需要通过主机外部的网络进行读写。</p><p id="ecd2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦我们同意使用<code class="fe ng nh ni nj b">Postgres</code>容器，我们必须考虑另一个问题:持久化数据。默认情况下，一旦容器被停止或删除，它的数据就不再持久，这对于我们的用例来说显然是一个问题。为了解决这个问题，我们利用了Docker <a class="ae ln" href="https://docs.docker.com/storage/bind-mounts/" rel="noopener ugc nofollow" target="_blank">绑定挂载</a>，它允许我们跨容器实例持久化数据。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="d861" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">使用Chart.js显示指标</h1><p id="98b2" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">现在我们有了需要可视化的数据。</p><p id="ac0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如前所述，我们的发布路线图包括的功能使我们的用户能够:1:可视化容器数据随时间的变化(不仅仅是实时的)和2:在4、12或24小时内进行比较。</p><p id="af22" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在之前的版本中，我们的团队使用流行的Chart.js库在饼图和条形图中显示实时信息。因此，在规划附加功能时，必须决定是否将它用于我们的新功能，或者我们是否应该使用一个新的库。</p><p id="a7ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该团队研究了两者的优缺点，并确定尽管Chart.js不是最健壮的动态渲染解决方案，并且可能会带来一些挑战，但与切换到另一个库(如D3.js)相比，这些折衷是可以接受的。支持继续使用Chart.js的最有说服力的理由是，这意味着我们不必在React和D3之间平衡对DOM的控制。我们还必须考虑到使用这两种方法所需的时间。Chart.js最终赢得了投票。</p><p id="987a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最终，我们的决定得到了回报，我们的图形以最少的代码实时动态呈现。该团队同意，将来可以决定使用功能更丰富的图表库。考虑到这一点，图表组件是以模块化格式构建的，以使转换尽可能简单明了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/8d5871fa60a7bac64d00d29dfca2ae05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OHkwxkb0cuoyec32"/></div></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="9c36" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">通知和可操作的见解</h1><p id="1bc7" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">因为期望我们的用户一直关注Docketeer是不现实的，所以我们的团队认为包含一个自动通知系统来提醒用户糟糕的容器性能或失败是至关重要的。</p><p id="91f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为不同的容器设置通知规则允许用户自动执行监控过程，并在出现问题时(例如，CPU或内存超过80%或容器已停止)获得及时通知。为了解决这个问题，我们为SMS通知部署了Twilio，这样用户可以轻松地将负责的团队成员添加到通知列表中。</p><p id="86e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好的监控工具不仅可以帮助您了解什么时候出现了问题，还可以围绕触发事件提供可操作的见解。考虑到这一点，Docketeer还允许用户在GitHub项目存储库中查看他们的团队成员所做的最新提交。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="1686" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">电子的进程间通信</h1><p id="c6aa" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">令人惊讶的是，我们更有趣的挑战之一最终不是与容器相关的问题。虽然electron使得用JavaScript构建桌面应用程序成为一个相对高效的过程，但它在构建我们的应用程序的后端时导致了一些严重的问题。</p><p id="3f6f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">困境是Docketeer需要一个后端REST API从外部云服务提供商请求数据，并将数据发送到我们的前端。最初的策略是实现一个节点JS服务器，它利用RESTful端点在云服务提供商和我们的前端之间进行通信。虽然这个解决方案肯定会工作，但服务器的唯一目的是托管Twilio API，这让我们的团队质疑我们是否过度工程化了这个解决方案。</p><p id="0cce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">经过一些研究，我们确定了一个使用电子的进程间通信(IPC)的替代策略。简单来说，Electron允许开发者使用两个并发线程:一个IPC主进程和一个IPC渲染器进程。GUI出现在主进程中，然后启动显示web应用程序的渲染器进程。</p><p id="5fcb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实现IPC相当简单，并且还有一个额外的好处，就是减少了300行代码。为了将Twilio与我们的前端连接起来，我们只需从Electron导入ipcRenderer模块，这为我们提供了一个向ipcMain发送数据的通道。来自Electron的ipcMain模块运行在主进程上，监听来自ipcRender的通信。因为有了这个渠道，我们能够在electronic中处理后端逻辑，而不必部署Node.js/Express.js服务器。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="b08d" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated"><strong class="ak">结束</strong></h1><p id="cb4a" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">我们真的很喜欢这个最后的发布周期，并且很兴奋地看到社区把这个项目带到了哪里！我们也希望您能够从我们一路走来获得的一些很酷的见解中学习！</p><p id="95bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文由以下作者合著:</p><ul class=""><li id="63f4" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">里奇·爱德华兹<a class="ae ln" href="https://github.com/richie-edwards" rel="noopener ugc nofollow" target="_blank"> @GitHub </a> <a class="ae ln" href="https://www.linkedin.com/in/richieedwards/" rel="noopener ugc nofollow" target="_blank"> @LinkedIn </a></li><li id="5ff8" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">米特什·帕特尔<a class="ae ln" href="https://github.com/mit1812" rel="noopener ugc nofollow" target="_blank"> @GitHub </a> <a class="ae ln" href="https://www.linkedin.com/in/mitesh-patel-8702728b/" rel="noopener ugc nofollow" target="_blank"> @LinkedIn </a></li><li id="788c" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">马特·琼斯<a class="ae ln" href="https://github.com/mc-jones" rel="noopener ugc nofollow" target="_blank">@ GitHub</a>T6】@ LinkedIn</li><li id="0cf6" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">柴李<a class="ae ln" href="https://github.com/seachai" rel="noopener ugc nofollow" target="_blank">@ GitHub</a><a class="ae ln" href="https://www.linkedin.com/in/chai-lee-5a064649/" rel="noopener ugc nofollow" target="_blank">@ LinkedIn</a></li><li id="4cf2" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">安东·阿卜杜哈米多夫<a class="ae ln" href="https://github.com/abdukhamidov-anton" rel="noopener ugc nofollow" target="_blank">@ GitHub</a><a class="ae ln" href="https://www.linkedin.com/in/anton-abdukhamidov-1163733b/" rel="noopener ugc nofollow" target="_blank">@ LinkedIn</a></li></ul></div></div>    
</body>
</html>