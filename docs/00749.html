<html>
<head>
<title>Synchronizing Async Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">同步异步代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/synchronizing-async-code-with-dispatchgroup-dispatchsemaphore-de814e485e82?source=collection_archive---------7-----------------------#2019-07-09">https://betterprogramming.pub/synchronizing-async-code-with-dispatchgroup-dispatchsemaphore-de814e485e82?source=collection_archive---------7-----------------------#2019-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5d33" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用DispatchGroup和DispatchSemaphore</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/974b5b4a38a43f409084aa30e80aa967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gSRcL5lAyFe09FWfuK8dmg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@jetcityninja?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> oakie </a>在<a class="ae ky" href="https://unsplash.com/search/photos/synchronized?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2d52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您需要执行多个网络调用，并且需要等待它们完成来聚合结果。</p><p id="e8bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为最简单的解决方案是使用<code class="fe lv lw lx ly b"><strong class="lb iu">DispatchGroup</strong></code> <strong class="lb iu"> </strong>(如果执行顺序不重要)或<code class="fe lv lw lx ly b"><strong class="lb iu">DispatchSemaphore</strong></code>。</p><p id="2551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将通过使用一个将结合两个异步调用的函数，然后使用一个包含异步调用的循环来演示这个问题及其解决方案。</p><p id="8dcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个命令行项目。</p><p id="592e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个函数，在预定义的延迟后将Int转换为String。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="ef71" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">第一个没有循环的场景</h1><p id="f906" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">创建一个将结合两个异步调用的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="170b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行它时，输出将是空的，因为在执行<code class="fe lv lw lx ly b">fetchData</code>完成处理程序之前<code class="fe lv lw lx ly b">completionHandler</code>被调用。</p><p id="75e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一种解决方案(不坚持执行顺序)是使用<code class="fe lv lw lx ly b">DispatchGroup</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="089d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在运行这个函数，输出将是“10”，因为第二个<code class="fe lv lw lx ly b">fetchData</code>比第一个<code class="fe lv lw lx ly b">fetchData</code>花费的时间少。这可能是我们想要的(当我们不关心执行的顺序时)，但是我们可能想要在第一个完成之后调用第二个<code class="fe lv lw lx ly b">fetchData</code>。</p><p id="e2f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此场景的解决方案是使用<code class="fe lv lw lx ly b">DispatchSemaphore</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="bcc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们调用这个函数时，无论任何一个<code class="fe lv lw lx ly b">fetchData</code>函数需要多长时间完成，输出都将是“01”。</p><p id="1ad9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是要记住，我们不能在主线程上使用信号量，因为它会永远阻塞它。</p><p id="2c15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，如果我们不关心顺序，我们可以将semaphore.wait()放在completionHandler之前。这与使用DispatchGroup时的工作方式相同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这将使用DispatchGroup返回类似“10”的解决方案。</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="f322" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated"><strong class="ak">使用循环的第二个场景</strong></h1><p id="e9f6" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">调用循环中的<code class="fe lv lw lx ly b">fetchData</code>函数，经过随机延迟时间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="8376" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们执行这段代码，输出将是:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="8485" class="nj mj it ly b gy nk nl l nm nn">text:</span></pre><p id="a5ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为<code class="fe lv lw lx ly b">print(“text:”, text)</code>是在任何<code class="fe lv lw lx ly b">fetchData</code>调用返回回调之前被调用的。</p><p id="da16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们添加同步:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="9c11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在输出将是随机的，例如:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="5a89" class="nj mj it ly b gy nk nl l nm nn"><strong class="ly iu">1 - 6 - 16 - 15 - 13 - 0 - 10 - 14 - 9 - 7 - 17 - 19 - 3 - 8 - 18 - 4 - 11 - 2 - 12 - 5 -</strong></span></pre><p id="b37b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因是循环内的所有<code class="fe lv lw lx ly b">fetchData</code>函数将被同时调用，在所有回调完成并发送<code class="fe lv lw lx ly b">group.leave()</code>后，<code class="fe lv lw lx ly b">group.notify()</code>将被执行。</p><p id="bfe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，添加<code class="fe lv lw lx ly b">DispatchSemaphore</code>来序列化循环内部的执行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="cbc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，每个<code class="fe lv lw lx ly b">fetchData</code>函数将在执行前等待上一个函数完成，结果是:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="4460" class="nj mj it ly b gy nk nl l nm nn"><strong class="ly iu">0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 11 - 12 - 13 - 14 - 15 - 16 - 17 - 18 - 19 -</strong></span></pre><p id="a6b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">概括一下，我们有两个同步异步函数的工具，如果我们只想等待它们全部完成，我们可以使用<code class="fe lv lw lx ly b">DispatchGroup</code>，如果我们想让它们按照我们使用<code class="fe lv lw lx ly b">DispatchSemahpore</code>的顺序完成和执行。</p><p id="1381" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！</p></div></div>    
</body>
</html>