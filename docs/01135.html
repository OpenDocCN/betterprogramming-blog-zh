<html>
<head>
<title>An Example of a Scalable iOS Project, Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个可伸缩iOS项目的例子，第2部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-example-of-a-scalable-ios-project-part-2-5c703d41f585?source=collection_archive---------18-----------------------#2019-08-16">https://betterprogramming.pub/an-example-of-a-scalable-ios-project-part-2-5c703d41f585?source=collection_archive---------18-----------------------#2019-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/1dad5035d1bcf8ee66ae08e442fc02fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uRkVa-Kaz6Ds1pQme8HKUQ.jpeg"/></div></div></figure><h2 id="9980" class="jc jd je bd b dl jf jg jh ji jj jk dk jl translated" aria-label="kicker paragraph">可扩展iOS应用架构的组成部分</h2><div class=""/><div class=""><h2 id="7ddd" class="pw-subtitle-paragraph kk jn je bd b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dk translated">演示项目(DAP)场景说明</h2></div><p id="f566" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在我的文章《<a class="ae ly" href="https://medium.com/@sven.korset/the-perfect-ios-app-architecture-24259417843f" rel="noopener">完美的iOS app架构</a>》中，我介绍了自己的架构，解释了<em class="lz">场景的概念。</em>在“<a class="ae ly" href="https://medium.com/@sven.korset/an-example-of-a-scalable-ios-project-dce56a256106" rel="noopener">一个可扩展iOS项目的例子</a>的第1部分中，我描述了项目的总体结构。你可能希望在详细描述场景是如何实现的之前，先看看这个。🧐</p><p id="9688" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><a class="ae ly" href="https://github.com/indieSoftware/DemoArchitecture" rel="noopener ugc nofollow" target="_blank"> DemoApp项目</a> (DAP)的存在只是为了提出某些方面和常见问题的具体解决方案。在我看来，如果代码尽可能的精简，只使用尽可能少的样板代码来简化问题及其解决方案，那就更容易理解了。</p><p id="1efe" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">以“有用”的应用程序结束的教程会使代码膨胀，并使找到特定的“A-ha<em class="lz">”</em>时刻变得更加困难。这就是为什么我试图压缩那些时刻，减少DAP中的开销。希望我成功了。😅</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="0463" class="mh mi je bd mj mk ml mm mn mo mp mq mr kt ms ku mt kw mu kx mv kz mw la mx my bi translated">场景0</h1><p id="73a0" class="pw-post-body-paragraph lc ld je le b lf mz ko lh li na kr lk ll nb ln lo lp nc lr ls lt nd lv lw lx im bi translated">首先，当你启动应用程序时，你会进入<em class="lz">场景0 </em>。这只是一个带有相应标签的闪屏。</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/ec3b745dd81e501d53318254c5a6c974.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*jeJNHW0vfztTvLsDg0inSA.png"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">场景0</p></figure><p id="d495" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="lz">场景0 </em>是最简单的场景，展示了一个场景的结构组成，包括<em class="lz">依赖注入</em>。从研究这个场景开始，对建筑结构有一个很好的概述。</p><p id="bd21" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在<em class="lz">场景0 </em>中，展示了如何在应用启动时最好地更新任何<em class="lz">内部设置</em>。对于新的应用程序版本，经常会发生一些内部变化，然后必须更新，例如数据库或核心数据模式或一些内部设置。</p><p id="fe10" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="lz">逻辑</em>不仅要在后台管理更新，还要通过<em class="lz">演示者</em>在<em class="lz">视图</em>中启动一个渐变动画，并在自动进入<em class="lz">场景1 </em>之前暂停。这个时间可能很棘手，这里提供了一个可能的解决方案。</p><p id="28b5" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">让我们深入研究代码！🤠</p><p id="91af" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">首先，业务逻辑由<em class="lz">场景0VC </em>中的<code class="fe nn no np nq b">viewDidAppear</code>触发。</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">Scene0VC.swift</p></figure><p id="8f8f" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="lz">逻辑</em>负责调用<code class="fe nn no np nq b">updateSettings</code>方法，确保满足闪屏的最小显示时间，然后当前场景随着<em class="lz">场景1 </em>导航的启动而消失。</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">Scene0Logic.swift</p></figure><p id="52db" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">为了计时，使用了一个<em class="lz">调度组</em>，但是，当然，也有解决这个问题的其他可能性。</p><p id="6284" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">更有趣的可能是第18行和第29行，在那里<code class="fe nn no np nq b">testFlags</code>开始发挥作用。这些标志来自<em class="lz"> Config.plist </em>文件，而<code class="fe nn no np nq b">noSplash</code>条目显示了如何为测试目的更改逻辑，例如，当运行UI测试时，您通常不希望等待几秒钟闪屏消失。因此，只需用这样的配置运行您的UI测试来节省一些时间。</p><p id="969d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="lz">演示器</em>直接实现。简单地隐藏飞溅，并在完成时通知<em class="lz">逻辑</em>。所以<em class="lz">逻辑</em>只启动隐藏进程，但进程本身由<em class="lz">呈现者</em>管理。</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">Scene0Presenter.swift</p></figure><p id="0d7d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="lz">导航仪</em>也很简单。它创建<em class="lz">导航控制器</em>和下一个<em class="lz">场景1 </em>并呈现它们。然而，创建<em class="lz">场景1VC </em>是通过<code class="fe nn no np nq b">dependencies</code>访问的<em class="lz">工厂</em>完成的。</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">Scene0Navigator.swift</p></figure><p id="c638" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这就是这个特定用例的全部内容。😊</p><p id="e997" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="lz">交互器</em>什么也不做，因为这个场景不需要将任何用户交互映射到业务逻辑用例。</p><p id="a05b" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">该视图非常简单，只需设置一个<code class="fe nn no np nq b">titleLabel</code>并在屏幕上居中。然而，值得一提的是，标签是以编程方式创建的，约束也是如此。为了方便创建约束，使用了第三方库“<a class="ae ly" href="https://github.com/Rightpoint/Anchorage" rel="noopener ugc nofollow" target="_blank"> Anchorage </a>”。这是一个整洁的小图书馆，我强烈推荐。</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">Scene0View.swift</p></figure><p id="97e3" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">编程方式更好的原因可以在我的文章“<a class="ae ly" href="https://medium.com/@sven.korset/decoupling-display-and-logic-in-ios-4de5a334ffbd" rel="noopener">iOS中的显示和逻辑解耦</a>”中读到。然而，在这个例子中，你已经可以看到<code class="fe nn no np nq b">let</code>可以用于<code class="fe nn no np nq b">titleLabel</code>而不是典型的<em class="lz">插座</em> <code class="fe nn no np nq b">var</code>，这导致了更正确的接口。标签样式和设置可以在一个地方完成，此外还可以使用常量。顺便说一下，正如您所看到的，您可以查看整个视图，因为它是简单快捷的，而不是神秘的XML。😉</p><p id="cd1e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">场景设置在<em class="lz">视图控制器</em>中。所以，我们来仔细看看<em class="lz"> Scene0VC </em>。</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">Scene0VC.swift</p></figure><p id="ebb6" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">第14行的<em class="lz"> VC </em>的<code class="fe nn no np nq b">init</code>方法需要注入依赖项。经典依赖注入。😄</p><p id="0293" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">第一个参数是一个<code class="fe nn no np nq b">SetupModel.Scene0</code>，它是一个场景特定的参数。在这种情况下，它是一个空结构，但其他场景(如<em class="lz">场景2 </em>)可能需要一些值才能正常运行。</p><p id="13c2" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">第二个参数是一个<code class="fe nn no np nq b">Act1DCInterface</code>。这是一个依赖关系容器，保存对所有依赖关系的引用，比如<em class="lz">导航器</em>稍后使用的<em class="lz">内部设置</em>或<em class="lz">工厂</em>。</p><p id="c1cf" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在<code class="fe nn no np nq b">init</code>方法中创建了<em class="lz">导航器</em>实例。同样，任何依赖项都会被立即注入。</p><p id="5863" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">对于<em class="lz">逻辑</em>来说也是如此，但是这一次用自己的依赖容器包装了其他场景组件。</p><p id="e33f" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在<em class="lz"> VC </em>对<code class="fe nn no np nq b">super.init()</code>的调用之后，其他组件可以接收对<em class="lz"> ViewController </em>的引用。这是通过属性注入实现的。</p><p id="143a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当<em class="lz">视图</em>通过第30行的<code class="fe nn no np nq b">loadView</code>被加载时，<code class="fe nn no np nq b">Scene0View</code>被创建和分配。演示者也获得了对视图的引用，并且创建了<code class="fe nn no np nq b">Interactor</code>。</p><p id="14b7" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这就是幕后的全部魔力。其他场景的工作方式类似。你已经看出模式了吗？😁</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="d6e8" class="mh mi je bd mj mk ml mm mn mo mp mq mr kt ms ku mt kw mu kx mv kz mw la mx my bi translated">场景1</h1><p id="144a" class="pw-post-body-paragraph lc ld je le b lf mz ko lh li na kr lk ll nb ln lo lp nc lr ls lt nd lv lw lx im bi translated">大多数应用程序使用<em class="lz">表格视图</em>或<em class="lz">集合视图</em>并发送任何服务器请求。这就是为什么这个应该在<em class="lz">场景1 </em>中作为例子展示。</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/9ec2c130cb4b8c46c3ca046078bd9f07.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*NTgvS9srN--30mGVzKld4A.png"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">场景1</p></figure><p id="3fa4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在这里，用户可以搜索特定的单词，并通过谷歌的自动补全功能接收建议。</p><p id="5901" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果用户按下蓝色加号图标，建议将被带入文本字段，这将触发新的搜索。另一方面，如果用户选择一个条目，应用程序将导航到<em class="lz">场景2 </em>。</p><p id="0ea9" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">服务器请求由相应的<em class="lz"> ServerWorker </em>执行，它位于嵌入式框架中，并作为依赖项注入。</p><p id="a8bf" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在这个场景中，展示了<em class="lz">显示</em>和<em class="lz">逻辑</em>通过<em class="lz">交互器</em>和<em class="lz">演示器</em>的交互，以及通过<em class="lz">导航器</em>的转换和与<em class="lz">工作器</em>的通信。所以，这实际上整体上展示了一个完整的场景。</p><p id="6316" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="lz"> VC </em>、<em class="lz">导航器</em>和<em class="lz">视图</em>不言自明。相比<em class="lz">场景0 </em>没有太大区别。是的，一个<em class="lz">表格视图</em>是在<em class="lz">视图</em>中创建的，它的<em class="lz">表格控制器</em>是在<em class="lz"> VC </em>中创建的，但这真的很简单。😪</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">Scene1VC.swift</p></figure><p id="420a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="lz">逻辑</em>有更多的用例。因此，有更多的方法可供调用，但这也没什么特别的。<em class="lz"> LogicState </em>可能比较有意思。</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">Scene1LogicState.swift</p></figure><p id="e53b" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">它是一个简单的结构，保存一些值，从而为场景的<em class="lz">逻辑</em>保存状态。它在<em class="lz">场景1逻辑</em>的<code class="fe nn no np nq b">init</code>期间被初始化，然后用例读取并操作这些值。</p><p id="0334" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="lz">逻辑</em>本身不需要任何进一步的属性来保持状态逻辑。这可以在这个结构中完成。此外，如果需要，您可以通过简单地序列化结构来快速持久化逻辑的状态。数据和逻辑现在更加分离。</p><p id="2e0d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="lz">呈现器</em>除了在视图上显示数据之外，没有做更多的事情。</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">Scene1Presenter.swift</p></figure><p id="e297" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在<code class="fe nn no np nq b">suggestionList(suggestions:)</code>方法的第一种情况下，<code class="fe nn no np nq b">tableController</code>需要被告知更新它的视图。因此，<em class="lz">工作台控制器</em>作为<em class="lz">演示者</em>工作。它负责更新它的视图，在本例中是一个<em class="lz">表视图</em>。另一方面，<em class="lz">表格控制器</em>也作为<em class="lz">交互器</em>工作，因为它将用户动作映射到<em class="lz">逻辑</em>的方法。然而，它的责任是明确的:只负责<em class="lz">表视图</em>而不是其他。</p><p id="fd14" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">让我们回到<em class="lz">呈现器</em>，它在<code class="fe nn no np nq b">serverError</code>方法中呈现一个警告。你可以在“<a class="ae ly" href="https://medium.com/@sven.korset/decoupling-display-and-logic-in-ios-4de5a334ffbd" rel="noopener">iOS</a>中解耦显示和逻辑”中读到为什么可以在这里做。</p><p id="b81b" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">最后一个方法，<code class="fe nn no np nq b">searchText</code>，也是不言自明的。只需更新输入字段文本。</p><p id="9d6d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">现在到了<em class="lz">互动者</em>！🤠</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">Scene1Interactor.swift</p></figure><p id="62ac" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">哎呀，Rx！😱</p><p id="832a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">是的，这里用的是<em class="lz"> RxSwift </em>和<em class="lz"> RxCocoa </em>。当然，您可以编写自己的绑定，比如注册操作，然后调用适当的逻辑方法。然而，Rx使它更简单，并给你更多的权力。至少大部分时间是这样。你知道，权力和责任等等。😅</p><p id="4c2a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我不想进入任何Rx的细节。我不是Rx pro。我认为代码被很好地注释了，足以理解每个调用做了什么。</p><p id="3c83" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">本质上，第一个块将搜索输入字段中的任何文本更改映射到逻辑的<code class="fe nn no np nq b">searchForText</code>方法，第二个块将任何<code class="fe nn no np nq b">tableView</code>滚动事件映射到逻辑的<code class="fe nn no np nq b">dismissKeyboard</code>指令。我打赌你能猜到这些逻辑方法是做什么的。😊</p><p id="3d2f" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">好了，这场戏就到这里。请随意深入研究<em class="lz"> TableController </em>的代码以及如何设置单元格。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="c9a6" class="mh mi je bd mj mk ml mm mn mo mp mq mr kt ms ku mt kw mu kx mv kz mw la mx my bi translated">场景2</h1><p id="01c4" class="pw-post-body-paragraph lc ld je le b lf mz ko lh li na kr lk ll nb ln lo lp nc lr ls lt nd lv lw lx im bi translated">场景2 是一个典型的细节图，有一些额外的东西。</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/3b1472cb8368481134a7935a4d2fa429.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*W03d-A90_eXI9WWkcXuTQg.png"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">场景2</p></figure><p id="6cc8" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果用户在<em class="lz">场景1 </em>中选择了一个条目，那么这个条目应该被传递给<em class="lz">场景2 </em>。向场景传递参数通常相当常见。</p><p id="2000" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如何将值传递回先前的<em class="lz">场景1 </em>也与<em class="lz">场景2 </em>一起显示。此处汇总了所有<em class="lz">场景2 </em>实例中的设备旋转次数。因此，该数字总是被传递给<em class="lz">场景2 </em>，被修改后再返回给<em class="lz">场景1 </em>。</p><p id="53d4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">通常的过渡可以通过<em class="lz">导航栏</em>中的<em class="lz">后退</em>按钮完成，也可以通过<em class="lz">视图</em>中的<em class="lz">复位</em>按钮手动完成。</p><p id="737c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">开关的作用是防止旋转设备时视图旋转。还有一个来自子控制器的嵌入式视图。那是黄色区域。</p><p id="6821" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">为了更好地理解，最好直接在代码中检查各个方面。🧐</p><p id="1801" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">先从<em class="lz"> VC </em>说起。</p><p id="02b4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">设置与其他场景中的相同。对于具体的<em class="lz"> UIKit </em>事件，<em class="lz"> VC </em>要向<em class="lz">逻辑</em>报告，比如当<code class="fe nn no np nq b">viewWillTransition(to:, with:)</code>在<em class="lz"> VC </em>上被调用时，通过<code class="fe nn no np nq b">displayRotated</code>方法通知<em class="lz">逻辑</em>。</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">Scene2VC.swift</p></figure><p id="b83e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">对于<code class="fe nn no np nq b">viewWillDisappear</code>来说也是如此，其中<em class="lz">逻辑</em>应该更新父场景，因为该场景即将移回之前的场景。</p><p id="1e90" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">另一方面，计算属性<code class="fe nn no np nq b">shouldAutorotate</code>需要返回一个状态。<em class="lz"> VC </em>不应保持任何状态。那是<em class="lz">逻辑</em>的责任。然而，<em class="lz"> VC </em>也不应该只调用<em class="lz">逻辑</em>上的方法来获取一个值并在这里传播它。因此，<em class="lz"> VC </em>可以直接访问<em class="lz">逻辑</em>的<code class="fe nn no np nq b">state</code>结构，定义为:</p><p id="e13c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><code class="fe nn no np nq b">private(set) var state = Scene2Model.LogicState()</code></p><p id="1ca2" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这并不理想，但它比通过方法查询所有值更简单，而且这并不是一个真正的问题，因为<code class="fe nn no np nq b">state</code>属性是只读的，不是<em class="lz">逻辑</em>接口的一部分。因此，除了<em class="lz"> VC </em>之外，没有其他组件可以访问它，因为它保存了对<em class="lz">逻辑</em>本身的引用，而不是对<em class="lz">逻辑接口</em>的引用。😬</p><p id="36de" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">说到<em class="lz">逻辑</em>，它还是只操纵一些状态值，调用一些<em class="lz"> Presenter </em>和<em class="lz"> Navigator </em>方法。一种更接近的方法是<code class="fe nn no np nq b">updateParentScene</code>，它用数据更新父场景。</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">Scene2Logic.swift</p></figure><p id="b058" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这就是如何将值传递回前一个场景。逻辑对之前的场景一无所知。它只知道它必须调用一个带有一些<code class="fe nn no np nq b">Scene2Result</code>值的<code class="fe nn no np nq b">callback</code>方法。</p><p id="342e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">回调方法来自<code class="fe nn no np nq b">setupModel</code>，它是一个<code class="fe nn no np nq b">Scene2</code>类型的结构。那么这看起来像什么？</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">Scene2Setup.swift</p></figure><p id="cd96" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">该结构提供了<em class="lz">场景2 </em>所需的值。<code class="fe nn no np nq b">headline</code>和<code class="fe nn no np nq b">numberOfRotations</code>是该场景要传递和呈现的值。然而，还有一个<code class="fe nn no np nq b">callback</code>属性，它指向一个闭包，然后调用这个闭包来传回类型<code class="fe nn no np nq b">Scene2Result</code>的值。</p><p id="b823" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><code class="fe nn no np nq b">Scene2Result</code>是一个简单的结构，它只保存要返回的<code class="fe nn no np nq b">numberOfRotations</code>,但也可以更复杂。因此，初始化<em class="lz">场景2 </em>的参数之一是一个闭包，用于将值返回到前一个场景。</p><p id="6f33" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这是在<em class="lz">场景1逻辑</em>中准备的。</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">Scene1Logic.swift</p></figure><p id="b34b" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这里，<em class="lz">场景1 </em>的<em class="lz">逻辑</em>将值和回调闭包传递给<em class="lz">场景2 </em>。然后闭包只更新<em class="lz">逻辑</em>的状态，但这本质上就是如何来回传递任何值。😄</p><p id="562b" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">最后，让我们看看嵌入式视图控制器。</p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">Scene2Presenter.swift</p></figure><p id="1b16" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这是<em class="lz">场景中<code class="fe nn no np nq b">updateView(model:)</code>方法的摘录。当没有已经添加的子控制器时，一个新的<em class="lz"> UIViewController </em>被创建并作为子控制器添加到场景的<em class="lz"> ViewController </em>中，并且它的视图被嵌入到场景的<em class="lz">视图</em>中。</em></p><figure class="nf ng nh ni gt iv"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">Scene2View.swift</p></figure><p id="d7e9" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">场景视图负责操纵视图层次。这就是这个<code class="fe nn no np nq b">addEmbeddedView</code>方法出现在视图中的原因。它只添加子视图并锚定它。</p><p id="228f" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">但是，等一下，为什么是<em class="lz">演示者</em>创建<em class="lz"> UIViewController </em>而不是<em class="lz">工厂</em>？🤨</p><p id="d76d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">说得好！我已经在我的文章“<a class="ae ly" href="https://medium.com/@sven.korset/decoupling-display-and-logic-in-ios-4de5a334ffbd" rel="noopener">iOS</a>中的解耦显示和逻辑”中解释了这样做的原因。当然，您可以自由地使用<em class="lz">工厂</em>来创建这种依赖关系。那肯定会更干净。</p><p id="5298" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">然而，<em class="lz">演示者</em>将不会进行单元测试，而是UI测试。它将不会脱离其他组件进行测试。您不需要模仿这个<em class="lz"> UIViewController </em>依赖项。这同样适用于<em class="lz">表示器</em>可能需要的任何格式化程序或任何其他依赖项。您很少会注入与这些实例不同的内容。那为什么还要注射呢？只是为了打针？🤔</p><p id="b6f3" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">像所有的事情一样，这是一种交换。利益是否证明了工作的正当性？当然，我们想要干净的代码，但是我们也想要可维护的代码，更少的代码意味着更少的维护。</p><p id="f8e9" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在这种特殊情况下，我认为我们不需要扩展<em class="lz">工厂</em>，可以将这些依赖项直接放入<em class="lz">表示器</em>中。然而，这总是要根据情况来权衡，将来我可能会改变主意。</p><p id="4395" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">所以，不要把它当成不可否认的教条。</p><blockquote class="nt"><p id="36fa" class="nu nv je bd nw nx ny nz oa ob oc lx dk translated">不要认为任何事情都是不可否认的。时间可以改变一切，甚至是教条和最佳实践！</p></blockquote><p id="bed5" class="pw-post-body-paragraph lc ld je le b lf od ko lh li oe kr lk ll of ln lo lp og lr ls lt oh lv lw lx im bi translated">就这样，一切都说完了。😄</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="d898" class="mh mi je bd mj mk ml mm mn mo mp mq mr kt ms ku mt kw mu kx mv kz mw la mx my bi translated">结论</h1><p id="5e97" class="pw-post-body-paragraph lc ld je le b lf mz ko lh li na kr lk ll nb ln lo lp nc lr ls lt nd lv lw lx im bi translated">DAP应该以压缩的形式表示常见的应用程序。</p><p id="134a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">也许这看起来不多，但是根据帕累托原则，20%的努力足以解决80%的问题。在我看来，这些是一个典型的应用程序面临的最常见的问题，应该涵盖上述80%。</p><p id="9b2c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">然而，那当然只是骨架。剩下的就是你作为开发者的创造性任务了。😁</p><p id="927f" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">顺便说一句，这只是“<a class="ae ly" href="https://medium.com/@sven.korset/pieces-of-a-scalable-ios-app-architecture-7c182f9dcd2c" rel="noopener">可扩展的iOS应用架构</a>”系列文章中的一篇。也许你想读更多我不可否认的智慧？😂</p></div></div>    
</body>
</html>