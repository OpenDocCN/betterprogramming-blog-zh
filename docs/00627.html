<html>
<head>
<title>Multithreaded Ruby — Synchronization, Race Conditions and Deadlocks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多线程Ruby——同步、竞争条件和死锁</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/multithreaded-ruby-synchronization-race-conditions-and-deadlocks-f1f1a7cddcea?source=collection_archive---------4-----------------------#2019-06-20">https://betterprogramming.pub/multithreaded-ruby-synchronization-race-conditions-and-deadlocks-f1f1a7cddcea?source=collection_archive---------4-----------------------#2019-06-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1fb7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">线程编程很难。神秘的、非确定性的bug等问题会困扰你。对此我们能做些什么？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/634449079600bedbf795fa94d415ca59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t8o69aldwX8d9b1Mf_lErQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@yipvick?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">叶维克</a>在<a class="ae ky" href="https://unsplash.com/search/photos/fibers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8451" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> T </span>即使在MRI Ruby上，hreads也会导致竞争条件和死锁，这会使您的服务崩溃，并且由于它们的不确定性而难以识别。所以，让我们来看看多线程同步和随之而来的弊端。</p><p id="1f2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将主要讨论并发编程的原子性问题，但首先让我们来看看在谈论并发编程时经常提到的一些弊端。</p><h1 id="4fad" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">什么是死锁？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/8457ac9df823f1bfb935e55842a99279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jfl3BPDob_C51XvInHzGoQ.jpeg"/></div></div></figure><p id="8444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果资源受到同步机制的保护，当两个或多个线程试图访问同一个共享资源时，就会发生死锁。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="629b" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">为什么首先要保护资源？</h1><p id="7b33" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Race_condition" rel="noopener ugc nofollow" target="_blank">两个字，竞况。如果我们使用线程是因为我们想尽可能地利用我们的CPU内核，我们需要让线程以某种方式协同工作。它们可能需要相互通信，或者如上面的例子所示，它们可能需要改变共享对象的状态。然后我们需要确保我们不会丢失数据。</a></p><p id="b75a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时候，GIL可以拯救我们，这样我们就不必同步对共享资源的访问。这是GIL拯救我们的一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="fb3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这并不总是正确的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6ee5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码会根据你的运气产生不同的输出——记住这是不确定的。当我第一次在IRB控制台中运行代码时，我只收到了一次“<em class="ne">正在开门</em>”的消息，但尝试了几次后，我收到消息的频率更高了——一次甚至四次。<br/>这清楚地表明，默认情况下，GIL不会使您的Ruby代码线程安全。</p><h2 id="6c9c" class="nf mf it bd mg ng nh dn mk ni nj dp mo li nk nl mq lm nm nn ms lq no np mu nq bi translated">其他Ruby实现中的同步问题</h2><p id="627c" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><strong class="lb iu"> <em class="ne"> JRuby <br/> </em> </strong>使用JRuby我们会更快地陷入这种同步错误。JRuby没有GIL，所以共享资源的每一个改变都可以在不同的线程中同时完成，这是我们经常遇到的问题。</p><p id="401b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ne">松露红宝石<br/> </em> </strong>松露红宝石正在试验一些特别的东西。他们想实现一个<a class="ae ky" href="http://ssw.jku.at/General/Staff/Daloze/thread-safe-objects.pdf" rel="noopener ugc nofollow" target="_blank">自动同步</a>。这里重要的一点是，如果服务使用线程，这将只在<em class="ne">完成</em>，因此单线程性能保持较高。因此，TruffleRuby将使我们免于手动同步。</p><h2 id="e706" class="nf mf it bd mg ng nh dn mk ni nj dp mo li nk nl mq lm nm nn ms lq no np mu nq bi translated">死锁只会发生在内存共享的多线程mmodel中吗？</h2><p id="abdc" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">最近，围绕以不同方式实现并发性的新语言出现了相当多的讨论。Elixir、Go、Closure、Kotlin和带有Akka框架的Scala只是这次出现的几颗宝石。虽然没有线程并发会更容易，但是不同的方法并不能解决所有问题。<a class="ae ky" href="https://medium.com/@elizarov/deadlocks-in-non-hierarchical-csp-e5910d137cc" rel="noopener">这里的</a>是一篇博客文章，描述了基于<a class="ae ky" href="https://en.wikipedia.org/wiki/Communicating_sequential_processes" rel="noopener ugc nofollow" target="_blank"> CSP </a>的并发方法中的死锁。</p><h1 id="227c" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">如何避免死锁</h1><p id="1b64" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><em class="ne">免责声明</em>:这里介绍的策略并不完整。我只是提出一些我发现在某些情况下可行的可能性。</p><h2 id="4133" class="nf mf it bd mg ng nh dn mk ni nj dp mo li nk nl mq lm nm nn ms lq no np mu nq bi translated">避免同步的需要</h2><p id="c01f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">因为死锁很难调试，所以一个解决方案是设计您的服务，使您不必在线程阶段改变状态。在Ruby中实现这一点的一种方法是使用<a class="ae ky" href="http://ruby-doc.org/core-2.6.3/Thread.html#class-Thread-label-Thread+variables+and+scope" rel="noopener ugc nofollow" target="_blank">线程局部变量</a>。在线程局部变量的帮助下，你可以在一个变量中保存一些状态。加入所有线程后，您就可以访问并处理它们了。</p><p id="40b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个伪示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7d63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ne">这是否意味着线程局部变量将是我们的救星！？</em> </strong></p><p id="96f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不，他们不会。首先，有时等待处理直到每个线程都完成是不可行的，甚至是不可能的。你必须意识到线程局部变量是全局可变状态的一种形式。如果您的线程不使用许多对象/方法调用，并且您从不在线程块之外访问该变量，则可以管理与此相关的危险。但是如果你在设计你的应用程序的时候用很多方法来改变线程状态，这将很快变得非常危险。</p><h2 id="21d9" class="nf mf it bd mg ng nh dn mk ni nj dp mo li nk nl mq lm nm nn ms lq no np mu nq bi translated">普通Ruby中可用的同步策略</h2><p id="a65a" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Mutual_exclusion" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="ne">互斥</em></strong></a><strong class="lb iu"><em class="ne"><br/></em></strong>互斥——互斥的简称——可以控制对资源的访问。下面是带有互斥锁的门锁的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f57e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，无论我们多频繁地从各种线程调用我们的类来打开门，它都只会被打开一次。</p><p id="b085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">互斥锁不是免费的。您必须非常小心，确保不会造成死锁或饥饿——如第一个示例所示。</p><p id="b592" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是使用<strong class="lb iu"> <em class="ne">互斥</em> </strong>类，你可以实现一些更复杂的锁机制，比如<a class="ae ky" href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">读者-作者-锁</strong> </a>和其他同步方法。值得一提的是，这些方法中的许多仍然容易出现死锁、饥饿或其他与并发编程相关的问题。</p><h1 id="a76c" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">结论</h1><p id="1449" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">多线程程序很难——有太多的事情要处理！但是，如果我们想从CPU中挤出最后一点性能，我们需要了解选项以及与它们相关的风险。</p><p id="3abc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，对于我们Ruby开发者来说，未来看起来很光明！TruffleRuby看起来很有前途，对于CRuby来说，现在有太多的开发进入并发领域，很难保持最新。对于每个感兴趣的人，我强烈推荐他们看看GitHub镜像和那里的拉请求。</p><p id="139f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[1]虽然现在，在Ruby中使用线程进行CPU绑定的操作是没有用的，但是使用线程进行IO绑定的操作是很有意义的。关于解释，请看<a class="ae ky" href="https://medium.com/swlh/scalable-ruby-concurrency-and-parallelism-explained-68b09a7aeb53" rel="noopener">这篇文章</a>。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="04d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ne">不是中等会员？</em> <a class="ae ky" href="https://grnt-grdwhl.medium.com/membership" rel="noopener"> <em class="ne">在这里报名</em> </a> <em class="ne">并支持我的写作过程！</em></p></div></div>    
</body>
</html>