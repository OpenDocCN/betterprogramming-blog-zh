# 以编程方式触发 SwiftUI 操作

> 原文：<https://betterprogramming.pub/programmatically-trigger-swiftui-actions-be2dcb8acf0d>

## SwiftUI 2.0 中触发代码的不同方式

![](img/137503208cea5ff940a38930b6b29bad.png)

美国宇航局在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片。

今天的文章讨论了触发代码的不同方式，包括 SwiftUI 2.0 中新的`onChange`操作符。

我相信你已经知道如何让 SwiftUI 自我刷新了。您只需对 SwiftUI `@State`变量进行更改。但是，如何在视图内部甚至外部触发这种变化呢？让我们探索我们的选择。

# 案情摘要

我希望有一个符号，它是一种在两种状态之间循环的计时器，一个符号切换器，看起来像这样:

![](img/a9a394dd27cd2d724db191892a436c4d.png)

一个半黑半白的翻转圈。

我在这里使用了两个新的 SF 符号。现在，最简单的解决方案是有一个布尔状态，根据它的值显示两个符号中的一个。下一节将展示如何编写代码。

# 选项 1

它工作并由一个计时器启动/保持，尽管因为计时器本质上与视图相关联，我们对它没有真正的控制。如果不删除视图，或者像我们在这里做的那样，给它添加一个手势，就没有办法打开或关闭它。

虽然这在很多情况下可能已经足够了，但是我们可能还需要更多。想象一下，我们希望在我们的视图中有一些我们可以打开或关闭的动画——在我们的代码中有一种懒惰的动画视图。

# 选项 2

下面是使用`onAppear` / `onDisappear`视图修饰符和 id 视图修饰符(类似于`setNeedsDisplay`)的相同代码的第二个例子。我们将这些视图修改器与 SwiftUI 的`@Binding`一起使用，让我们能够打开和关闭事物:

# 选项 3

SwiftUI 2.0 还有第三个选项。我们现在可以直接查看视图中 bool 的值，并在它发生变化时采取措施。但是等等，要小心。这在某些方面相当微妙:

这是可行的，但是让我们把它分解一下，这样我们可以更好地理解这里发生了什么。修改代码，当 switcher 的值改变时使`onChange`翻转，注释掉`if switcher`语句。所以，做出你在这里看到的改变。它将会编译——switcher 毕竟是 swift ui`@State`——并且您将能够翻转这些值:

但它会坏掉的。仔细看看代码就明白为什么第二个版本不行了。尽管我们正在更改 SwiftUI `@State`变量，但它并不直接链接到视图。

现在选项 1-3 都很好，但是它们都与视图紧密相关。还有别的办法吗？

# 选项 4

也许我们需要更独立地控制视图的状态，而不需要使用 SwiftUI `@Binding`。SwiftUI `@Bindings`的挑战在于，当您调用依赖于它们的方法时，您需要将它们作为参数包含进来。我相信你可以想象事情失去控制。为了管理具有松散绑定的视图，我们可以使用 SwiftUI `@Published`和 SwiftUI `@Observerable`对象。使用这个选项，我们的代码将如下所示。注意，我们必须在这里引入一个类:

它也很好用。事实上，我们可以对 SwiftUI `@Environmental`对象使用相同的技术。我不会在这里展示这些代码，因为它们几乎完全相同。此外，环境对象的目标是与所有视图共享数据，这在这里几乎是不可能的。

# 选项 5

我们有第五个选项，尽管我们需要包含 Combine 框架来使它变得生动。利用这一点，我们可以使这两个视图——一个调用原理，一个显示翻转圆——的耦合更加松散:

这是用您的视图打开和关闭事物的一种极好的方式，并且它可以扩展到您的非 SwiftUI 代码。

感谢您的阅读。希望你觉得有用。

保持冷静和编码。