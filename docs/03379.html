<html>
<head>
<title>ARCore and Sceneform in Android — Performing Gestures and Collisions on Transformable Nodes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中的ARCore和Sceneform在可变换的节点上执行手势和碰撞</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/arcore-and-sceneform-in-android-performing-gestures-and-collisions-on-transformable-nodes-c66a474f7905?source=collection_archive---------5-----------------------#2020-02-06">https://betterprogramming.pub/arcore-and-sceneform-in-android-performing-gestures-and-collisions-on-transformable-nodes-c66a474f7905?source=collection_archive---------5-----------------------#2020-02-06</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="783c" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">使用Sceneform在Android上轻松构建AR应用</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/9348a25be3e239d2eab03235c7d67d88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QuxSM3QZG9V02WhN"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">Bram Van Oost 在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d578" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在这个新的十年之交，如果有一个领域有可能彻底改变我们与智能手机的交互方式，那就是增强现实(AR眼镜:你在读这个吗？).谷歌一直在推进自己的平台ARCore，该平台使开发者能够在Android、iOS、Unity等平台上创建AR体验。</p><h1 id="9d7a" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">简史</h1><p id="be6a" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">ARCore做了很多事情。从运动跟踪到环境理解和光线估计，它已经涵盖了大部分的基础。然而，尽管它是在2017年推出的，但直到最近，当增加了增强人脸、共享相机和AR元素等新功能并开始显示ARCore的真正潜力时，它才获得了很多关注或进展。</p><p id="b32f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">ARCore的采用花了一些时间的原因之一是因为它最初依赖于OpenGL的3D图形。ARCore发布时，3D内容导入和查看在Java(或Kotlin)中是不可能的，这迫使开发人员使用OpenGL(陡峭的学习曲线会让任何人做噩梦)或Unity，这是与Android组件集成时的一个痛苦。谷歌必须对此采取措施。</p><p id="1ea8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">他们在2018年推出了Sceneform，剩下的就是历史了。</p><h1 id="1460" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">scene form:Android开发者的救生艇</h1><p id="b259" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">Sceneform是一个3D框架，允许我们通过使用高级图形API来呈现3D模型。它附带了一个插件，可以让你直接从Android Studio导入、预览和构建3D资产。Sceneform与ARCore紧密集成，使Java和Kotlin开发人员可以轻松构建高质量的Android AR应用。</p><p id="b665" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Sceneform SDK代表您处理以下事情:</p><ul class=""><li id="7dca" class="mq mr ir kz b la lb ld le lg ms lk mt lo mu ls mv mw mx my bi translated">ARCore的设备兼容性检查</li><li id="8fe0" class="mq mr ir kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated">摄像机权限</li><li id="6aa4" class="mq mr ir kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated">创建ARCore会话</li></ul><p id="a08e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">既然我们已经很好地了解了Sceneform为我们做了什么，那么让我们来定义本文的目标。</p><h1 id="5b20" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">我们的目标</h1><ul class=""><li id="5440" class="mq mr ir kz b la ml ld mm lg ne lk nf lo ng ls mv mw mx my bi translated">介绍ARCore和Sceneform的一些关键术语和构建模块。</li><li id="1cce" class="mq mr ir kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated">使用Kotlin设置平面检测和点击测试以在Android AR应用程序中添加多个节点。</li><li id="8f56" class="mq mr ir kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated">处理可变换节点上的手势和碰撞。</li></ul></div><div class="ab cl nh ni hv nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ik il im in io"><h1 id="26e3" class="lt lu ir bd lv lw no ly lz ma np mc md jx nq jy mf ka nr kb mh kd ns ke mj mk bi translated">关键术语</h1><p id="5dee" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">Sceneform是一个基于节点的图形，可以做很多事情。从处理平面检测并允许我们在场景中设置节点(可以是零个或多个节点)，到执行点击测试，等等。</p><p id="f98c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">点击测试是一种从屏幕转换2D坐标的方法，用户在屏幕上点击他们在AR场景中的3D投影。想象一下，一束光线从屏幕上的点击点发出，穿过手机的摄像头视图。这条假想光线与AR场景的平面表面的第一个交点为我们提供了世界位置。然后我们可以在这个世界位置上设置我们的节点。</p><p id="a5e5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在上一节中，我们讨论了术语节点、可转换节点等等。让我们在这里定义它们:</p><ul class=""><li id="29a0" class="mq mr ir kz b la lb ld le lg ms lk mt lo mu ls mv mw mx my bi translated"><strong class="kz is">场景</strong>——我们的3D对象被渲染的地方。它有一个树状的数据结构。</li><li id="1908" class="mq mr ir kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated"><strong class="kz is">节点</strong> —一个包含所有需要在屏幕上呈现的信息的对象。它可以包含一个<code class="fe nt nu nv nw b">renderable</code>属性，我们可以在上面设置我们的3D资产和材质形状。此外，它由一个<code class="fe nt nu nv nw b">collisionShape</code>组成，有助于检测碰撞。节点可以有零个或多个子节点和一个父节点。</li><li id="9d77" class="mq mr ir kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated"><strong class="kz is">可渲染</strong> —可从资产文件(OBJ、FBX、glTF)创建的3D模型，如此处<a class="ae kw" href="https://heartbeat.fritz.ai/build-you-first-android-ar-app-with-arcore-and-sceneform-in-5-minutes-af02dc56efd6" rel="noopener ugc nofollow" target="_blank">所示</a>或使用<code class="fe nt nu nv nw b">MaterialFactory</code>或<code class="fe nt nu nv nw b">ShapeFactory</code>创建具有纹理的基本形状，如立方体、球体和圆柱体</li><li id="375e" class="mq mr ir kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated"><strong class="kz is">锚节点</strong> —这些类型的节点被分配到ar世界空间中的特定位置。通常，这是检测到平面后放置的第一个节点。</li><li id="0b78" class="mq mr ir kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated"><strong class="kz is">可变形节点</strong>——顾名思义，可以变形。它们能够通过对用户手势做出反应，在AR场景中进行缩放、平移和旋转。</li><li id="d662" class="mq mr ir kz b la mz ld na lg nb lk nc lo nd ls mv mw mx my bi translated"><strong class="kz is">姿态</strong> —提供节点在场景中的位置和方向。我们还可以确定相机的姿态，并找到相机和场景中锚节点之间的距离。</li></ul><p id="5c1f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">一旦您将<code class="fe nt nu nv nw b">ArFragment</code>添加到您的活动布局中，它就为设置<code class="fe nt nu nv nw b">ARCore</code>会话和<code class="fe nt nu nv nw b">ArSceneView</code>做好了基础工作，一旦检查到设备通过了ARCore兼容性测试。</p><p id="73d4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe nt nu nv nw b">setOnTapArPlaneListener</code>设置在<code class="fe nt nu nv nw b">ArFragment</code>中，用于在检测到的平面上发生任何点击事件时监听变化。通过使用从监听器返回的<code class="fe nt nu nv nw b">HitResult</code>，我们可以将锚点添加到我们将设置节点的平面上。</p><h2 id="6367" class="nx lu ir bd lv ny nz dn lz oa ob dp md lg oc od mf lk oe of mh lo og oh mj oi bi translated">材料工厂和形状工厂</h2><p id="e385" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">下面的代码演示如何创建一个带有形状的可呈现的，并将其放在节点上:</p><pre class="kh ki kj kk gu oj nw ok ol aw om bi"><span id="3aed" class="nx lu ir nw b gz on oo l op oq">MaterialFactory.makeOpaqueWithColor(this, Color(android.graphics.Color.<em class="or">YELLOW</em>))<br/>        .thenAccept <strong class="nw is">{ </strong>material <strong class="nw is">-&gt;<br/>            </strong>val vector3 = Vector3(0.05f, 0.05f, 0.05f)<br/>            cubeRenderable = ShapeFactory.makeCube(vector3, Vector3.zero(), material)<br/><br/><br/>            cubeRenderable!!.<em class="or">isShadowCaster </em>= false<br/>            cubeRenderable!!.<em class="or">isShadowReceiver </em>= false<br/><br/>        <strong class="nw is">}</strong></span></pre><p id="fea8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe nt nu nv nw b">MaterialFactory</code>让我们定义材质类型——金属色、颜色、不透明度等等——并将其放在<code class="fe nt nu nv nw b">ShapeFactory</code>实例上。<code class="fe nt nu nv nw b">ShapeFactory</code>类允许我们定义形状的大小。设置球体(带半径)和圆柱体(带半径和高度)的功能有:</p><pre class="kh ki kj kk gu oj nw ok ol aw om bi"><span id="e344" class="nx lu ir nw b gz on oo l op oq">ShapeFactory.makeCylinder(0.1f,0.3f,Vector3.zero(), material)</span><span id="a75f" class="nx lu ir nw b gz os oo l op oq">ShapeFactory.makeSphere(0.1f, Vector3.zero(), material)</span></pre><p id="7963" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">下面是将一个带有可渲染集的节点放在<code class="fe nt nu nv nw b">ArSceneView</code>上时的样子。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ot"><img src="../Images/814c9b448c5bbbd75f3fd2de8de6109a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G8_5Jm5v05sFmtGsUojEOw.jpeg"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">你看到的点是平面上可以放置锚点的特征点。</p></figure><p id="0c5f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当用户选择节点或者以编程方式使用<code class="fe nt nu nv nw b">select()</code>方法时，节点周围的圆圈就会显示出来。</p><p id="dba1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">以下代码片段展示了如何将我们在上面创建的可呈现对象添加到平面上的可转换节点:</p><pre class="kh ki kj kk gu oj nw ok ol aw om bi"><span id="673f" class="nx lu ir nw b gz on oo l op oq">arFragment!!.setOnTapArPlaneListener {<strong class="nw is"> </strong>hitResult, plane, motionEvent -&gt; </span><span id="69ea" class="nx lu ir nw b gz os oo l op oq">val anchor = hitResult.createAnchor()<br/>val anchorNode = AnchorNode(anchor)<br/>anchorNode.setParent(arFragment!!.<em class="or">arSceneView</em>.<em class="or">scene</em>)</span><span id="405b" class="nx lu ir nw b gz os oo l op oq">val node = TransformableNode(arFragment!!.<em class="or">transformationSystem</em>)<br/>node.<em class="or">renderable </em>= cubeRenderable<br/>node.setParent(anchorNode)<br/><br/>arFragment!!.<em class="or">arSceneView</em>.<em class="or">scene</em>.addChild(anchorNode)<br/>node.select()</span><span id="4172" class="nx lu ir nw b gz os oo l op oq">}</span></pre><p id="6240" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">因此，在一个平面上点击，我们可以添加一个可变换的节点，它可以在该平面的边界内移动。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj ou"><img src="../Images/e9ec2c6b4971d5a568d0dd77768c666a.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/1*Bf5uuyJkoRPPJFFc6xoP6g.gif"/></div></figure><p id="5136" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在我们已经很好地了解了Sceneform的不同组件，让我们构建一个基于ARCore的Android应用程序，它可以检测冲突并计算两个可转换节点之间的距离。</p><h1 id="3fc4" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">入门指南</h1><p id="c8d4" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">首先，在Kotlin中创建新的Android Studio项目。请确保ARCore和Sceneform的最低Android API级别为27，并在应用的<code class="fe nt nu nv nw b">build.gradle</code>文件中添加以下依赖项:</p><pre class="kh ki kj kk gu oj nw ok ol aw om bi"><span id="97f0" class="nx lu ir nw b gz on oo l op oq">implementation 'com.google.ar.sceneform.ux:sceneform-ux:1.14.0'</span></pre><h1 id="f150" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">设置ArFragment</h1><p id="c0eb" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">接下来，让我们给<code class="fe nt nu nv nw b">activity_main.xml</code>布局文件添加一个<code class="fe nt nu nv nw b">ArFragment</code>，如下所示:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="ov ow l"/></div></figure><p id="db5c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们还添加了一个<code class="fe nt nu nv nw b">TextView</code>来显示节点之间的距离。</p><h1 id="a7b9" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">检查OpenGL兼容性</h1><p id="b146" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">现在回到<code class="fe nt nu nv nw b">MainActivity.kt</code>类，在链接布局之前，我们将检查OpenGL版本是否是3.0或更高版本:</p><pre class="kh ki kj kk gu oj nw ok ol aw om bi"><span id="cee5" class="nx lu ir nw b gz on oo l op oq">override fun onCreate(savedInstanceState: Bundle?) {<br/>    super.onCreate(savedInstanceState)<br/><br/>    if (!checkIsSupportedDeviceOrFinish(this)) {<br/>        Toast.makeText(<em class="or">applicationContext</em>, "Device not supported", Toast.<em class="or">LENGTH_LONG</em>).show()<br/>    }</span><span id="dda9" class="nx lu ir nw b gz os oo l op oq">    setContentView(R.layout.<em class="or">activity_main</em>) <br/>}</span><span id="85b7" class="nx lu ir nw b gz os oo l op oq"><br/>fun checkIsSupportedDeviceOrFinish(activity: Activity): Boolean {<br/><br/>    val openGlVersionString = (Objects.requireNonNull(activity.getSystemService(Context.<em class="or">ACTIVITY_SERVICE</em>)) as ActivityManager)<br/>        .<em class="or">deviceConfigurationInfo<br/>        </em>.<em class="or">glEsVersion<br/>    </em>if (java.lang.Double.parseDouble(openGlVersionString) &lt; MIN_OPENGL_VERSION) {<br/>        Toast.makeText(activity, "Sceneform requires OpenGL ES 3.0 or later", Toast.<em class="or">LENGTH_LONG</em>)<br/>            .show()<br/>        activity.finish()<br/>        return false<br/>    }<br/>    return true<br/>}</span></pre><h1 id="13ce" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">在平面上添加多个节点</h1><p id="0954" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">现在，让我们修改<code class="fe nt nu nv nw b">setOnTapArPlaneListener</code>方法来容纳两个可转换的节点。在下面来自<code class="fe nt nu nv nw b">MainActivity.kt</code>类的代码中，我们已经初始化了两个3D渲染模型——其中一个在碰撞过程中修改可变形材料。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="ov ow l"/></div></figure><p id="3eab" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">注意我们在<code class="fe nt nu nv nw b">Activity</code>类中设置的<code class="fe nt nu nv nw b">Scene.OnUpdateListener</code>接口<code class="fe nt nu nv nw b">onUpdate(frameTime: FrameTime)</code>。这将在场景更新之前每帧调用一次回调方法。我们可以在这个函数中处理任何事件。属性将为我们提供当前帧的时间信息，从而允许我们利用它来周期性地添加一些自定义的场景。</p><p id="e6fd" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在下一节中，我们将检测两个节点上的冲突事件</p><h1 id="f535" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">使用OverlapTest检测碰撞</h1><p id="923f" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">Sceneform处理冲突的方式略有不同(它称之为重叠)。目前，它没有一个事件处理器来告诉你碰撞何时开始，何时结束。</p><p id="4bd1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">通过调用<code class="fe nt nu nv nw b">overlapTest()</code>函数并传递节点，您可以确定它是否与场景中的任何节点重叠。或者，您可以使用<code class="fe nt nu nv nw b">overlapTestAll()</code>函数来获取重叠节点的列表。</p><p id="b74e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">以下代码处理碰撞并相应地更改节点的可渲染材质:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="ov ow l"/></div></figure><p id="06c7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">为了简单起见，我们只在两个可变换节点放置在平面上时检测重叠。</p><h1 id="b988" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">计算两个节点之间的距离</h1><p id="94c8" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">要连续计算两个可变换节点之间的距离，请在<code class="fe nt nu nv nw b">onUpdate</code>回调函数中添加以下代码:</p><pre class="kh ki kj kk gu oj nw ok ol aw om bi"><span id="f391" class="nx lu ir nw b gz on oo l op oq">val positionA = nodeA!!.<em class="or">worldPosition<br/></em>val positionB = nodeB!!.<em class="or">worldPosition<br/><br/></em>val dx = positionA.x - positionB.x<br/>val dy = positionA.y - positionB.y<br/>val dz = positionA.z - positionB.z<br/><br/>val distanceMeters = Math.sqrt((dx * dx + dy * dy + dz * dz).toDouble()).toFloat()<br/><br/>val distanceFormatted = String.<em class="or">format</em>("%.2f", distanceMeters)<br/><br/>tvDistance!!.<em class="or">text </em>= "Distance between nodes: $distanceFormatted metres"</span></pre><p id="51ec" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">最后，设置好一切后，在ARCore兼容设备上运行上述应用程序，我们得到了以下结果:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="ox ow l"/></div></figure><h1 id="f7cd" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">结论</h1><p id="76b3" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">ARCore with Sceneform最近取得了一些不错的进展。随着最新更新发布有趣的功能，如增强人脸、UI元素、在AR运行时加载元素、共享相机等，谷歌正在缓慢而稳步地追赶其竞争对手。ARCore的跨平台支持也给了它比其他公司更大的优势。</p><p id="a9f2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">新的深度API的发布应该只会帮助开发者构建更具沉浸感的AR场景和体验。</p><p id="7446" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这篇文章的完整源代码可以在<a class="ae kw" href="https://github.com/anupamchugh/ARCoreSceneformCollisions" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。这一次到此为止。感谢阅读。</p></div></div>    
</body>
</html>