<html>
<head>
<title>Implement Core HealthKit Functions Using Combine Publishers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用联合发行商实现核心HealthKit功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-core-healthkit-functions-using-combine-publishers-a142924d2573?source=collection_archive---------6-----------------------#2021-04-14">https://betterprogramming.pub/implement-core-healthkit-functions-using-combine-publishers-a142924d2573?source=collection_archive---------6-----------------------#2021-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="267f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们为HealthKit创建发布者</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/04c3f082c72f3cb16b4335ad46bb3a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RLJ0PWZNmGI1TAaxRCk_Qg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">林赛·亨伍德在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="7255" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank"> Combine </a>是一个用于编写异步代码的强大框架。它提供了像发布者和操作者这样的构件，允许程序员编写复杂的数据管道、网络调用等等。<a class="ae kv" href="https://developer.apple.com/documentation/healthkit" rel="noopener ugc nofollow" target="_blank"> HealthKit </a>是苹果提供的另一个框架，它管理健康相关数据的读写。iOS和watchOS上都有。</p><p id="211a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将探讨如何使用Combine来实现一些HealthKit基本功能——即请求访问以读取用户数据并查询该数据。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1370" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">请求授权</strong></h1><p id="f7e2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">请求授权是一个重要的步骤，我们需要在查询任何健康数据之前进行。用户可以随时通过健康应用或设置更改权限，而我们的应用不会收到这些更改的通知。</p><p id="e943" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了完成这个任务，我们将一组<code class="fe mw mx my mz b">HKSampleType</code>传递给实例方法<code class="fe mw mx my mz b">requestAuthorization(toShare:read:completion:)</code>。我们可以指定我们想读或写的不同类型。</p><p id="f368" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">受<a class="ae kv" href="https://www.apple.com/newsroom/2021/03/apple-womens-health-study-releases-preliminary-data-to-help-destigmatize-menstrual-symptoms/" rel="noopener ugc nofollow" target="_blank">最新苹果女性健康研究更新</a>的启发，我们将在HealthKit中查询症状数据。特别是腹部绞痛(研究参与者最常记录的症状)。您可以查看可用的<a class="ae kv" href="https://developer.apple.com/documentation/healthkit/data_types/symptom_type_identifiers" rel="noopener ugc nofollow" target="_blank">症状类型列表</a>(有一大堆)。下面是请求授权方法的一个简单实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2130" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一种很好的简单的请求访问的方法，但是让我们看看Combine如何通过一个<code class="fe mw mx my mz b">Future</code>帮助我们做得更好。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0722" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">请求期货授权</strong></h1><p id="9e23" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">根据<a class="ae kv" href="https://developer.apple.com/documentation/combine/future" rel="noopener ugc nofollow" target="_blank">官方文档</a>，a <code class="fe mw mx my mz b">Future</code>是“最终产生单一值，然后完成或失败<em class="nc">的发布者。”</em>它非常适合包装一次性授权请求。因为它是一个发布者，我们将能够使用Combine操作符来应用我们想要的任何转换。</p><p id="adb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">Futures</code>也非常适合将命令式编写的代码转换成声明式代码。要初始化一个，我们必须向它提供一个承诺。在Combine中，承诺只是需要一个<code class="fe mw mx my mz b">Result</code>的普通闭包。以下示例使用<code class="fe mw mx my mz b">Future</code>请求授权:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="66aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看<code class="fe mw mx my mz b">authorizationPublisher()</code>方法的签名。它返回一个<code class="fe mw mx my mz b">Future&lt;Bool, Error&gt;</code>。注意，它不需要任何完成处理程序。在函数内部，我们用闭包初始化了一个<code class="fe mw mx my mz b">Future</code>。在这个闭包中，我们将执行请求授权的异步任务。不同之处在于，我们称之为履行承诺，而不是称之为完成。如果出现任何错误，我们调用结果为<code class="fe mw mx my mz b">.failure(error!)</code>的承诺。如果没有，我们调用promise，并将<code class="fe mw mx my mz b">authSuccess</code>布尔传递给它。</p><p id="0af9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您运行这段代码，您会注意到<code class="fe mw mx my mz b">Future</code>一创建就执行了。这就是他们的工作方式，不像其他联合出版商。在某些场景中，我们可能希望随时初始化我们的发布者，并且只在订阅时触发授权流。我们可以通过将<code class="fe mw mx my mz b">Future</code>包装在<code class="fe mw mx my mz b">Deferred</code>发布器中来实现这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b921" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，<code class="fe mw mx my mz b">Future</code>闭包的执行将被推迟，直到它接收到一个订阅者，允许我们调用<code class="fe mw mx my mz b">authorizationPublisher()</code>方法并传递我们的发布者，而无需触发HealthKit授权流。<code class="fe mw mx my mz b">Deferred</code>还将保证对同一个publisher实例的每个新订阅将导致闭包再次执行。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b56e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">检查保健包是否可用</strong></h1><p id="28fc" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">到目前为止，这个授权请求实现还没有考虑受支持的设备系列。我前面提到过，HealthKit只在iOS和watchOS上可用。要检查当前设备是否受HealthKit支持，我们只需调用<code class="fe mw mx my mz b">isHealthDataAvailable()</code>。如果不是，我们将使用自定义<code class="fe mw mx my mz b">HealthDataError</code>枚举的<code class="fe mw mx my mz b">unavailableOnDevice</code>用例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="6eaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要注意的是，当<code class="fe mw mx my mz b">authSuccess</code>为<code class="fe mw mx my mz b">true</code>时，并不一定意味着用户已经被授权访问。这意味着我们成功地请求了它。为了保护用户隐私，如果用户拒绝了请求，HealthKit不会通知我们。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b807" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">查询症状数据</strong></h1><p id="2b85" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">相同的Combine-ish方法可以应用于编写HealthKit查询。这正是Combine大放异彩的时候，它允许我们将HealthKit样本类型转换为我们的应用程序所使用的模型。如果你想深入了解如何实现查询的细节，苹果公司有一本<a class="ae kv" href="https://developer.apple.com/documentation/healthkit/reading_data_from_healthkit" rel="noopener ugc nofollow" target="_blank">很棒的指南</a>。TL；DR版本是我们将使用一种最简单的访问健康数据的方式<code class="fe mw mx my mz b">HKSampleQuery</code>。</p><p id="3c3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用一个<code class="fe mw mx my mz b">PassthroughSubject</code>，一个内置的发布器，它为我们提供了一种通过调用<code class="fe mw mx my mz b">.send(_:)</code>将值注入到流中的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8bf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个<code class="fe mw mx my mz b">PassthroughSubject</code>将不存储任何值。它只会将它们发送给订阅者(不像<code class="fe mw mx my mz b">CurrentValueSubject</code>，它会存储最近发布的值)。</p><p id="4c59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">Subjects</code>是另一个将命令式代码集成到声明式API的工具。我们还可以为HealthKit查询定义一个定制的发布者，但是这需要更多的样板文件来完成大致相同的行为。<code class="fe mw mx my mz b">Subjects</code>和<code class="fe mw mx my mz b">Futures</code>在大多数情况下会起作用，但是如果需要更多的灵活性，那么定制发行商可能值得一试。</p><p id="e3b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以将两个发布者结合起来，构建一个数据管道，异步请求授权，查询HealthKit，并将查询到的示例映射到我们的定制模型类型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8a33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">.flatMap</code>操作符将使用查询主题替换发出的认证布尔值，并将它们展平，这样我们就不会以嵌套发布者结束。</p><p id="15a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nc">免责声明:我使用</em> <code class="fe mw mx my mz b"><em class="nc">.assertNoFailure()</em></code> <em class="nc">表示这个发布者永远不会失败，因此将其错误类型改为</em> <code class="fe mw mx my mz b"><em class="nc">Never</em></code> <em class="nc">。在实际场景中，我们应该在断言没有失败之前捕捉错误并正确处理它们。</em></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="409c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">批量查询健康工具包</strong></h1><p id="7c3f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我之前提到的女性健康研究更新报道了一系列其他症状，如腹胀、疲劳、痤疮和头痛。让我们将它们添加到我们的示例中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b583" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">HealthKit中没有“批处理查询”类型，但是我们可以使用我们之前编写的扩展和一些组合操作符来实现该行为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="a63c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一些新的代码:</p><ol class=""><li id="4e3d" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">迭代<code class="fe mw mx my mz b">symptomTypes</code>数组，为每个症状创建一个<code class="fe mw mx my mz b">subject</code>。</li><li id="a08c" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><code class="fe mw mx my mz b">CompactMap</code>样品到<code class="fe mw mx my mz b">Symptom</code>型号。</li></ol><p id="d139" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果类型是一个发布者数组:<code class="fe mw mx my mz b">[AnyPublisher&lt;[Symptom], Error&gt;]</code>。不完全是我们想要的。与一系列发行商合作意味着订阅每一个发行商，处理多个订阅，等等。幸运的是，Combine拥有合并出版商的强大工具。我们来看看其中的几个:<code class="fe mw mx my mz b">Publisher.Merge</code>和<code class="fe mw mx my mz b">reduce</code>。</p><p id="162b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">Merge</code>是一个发行商，它可以将一个、两个、三个或<em class="nc">多个</em>发行商合并成一个。我们将使用后面的变体<code class="fe mw mx my mz b">MergeMany</code>，并扩展<code class="fe mw mx my mz b">Sequence</code>协议，将它的元素合并到一个发布者中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="23e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这些，我们将不再需要与一系列出版商打交道。然而,“批量查询”的幻想破灭了，因为这个发布者将在每个查询返回时发出值。这就是<code class="fe mw mx my mz b">reduce</code>操作符发挥作用的地方。它的工作方式类似于<code class="fe mw mx my mz b">Sequence</code>reduce——我们提供一个初始值和一个闭包来组合后续值。由于我们的目标是“一批”症状，初始值将是一个空数组，我们将把每个发出的数组加在一起:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c1ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几行代码中包含了很多内容，所以让我们一步一步来看:</p><ol class=""><li id="265f" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">再次重复<code class="fe mw mx my mz b">symptomTypes</code>并为每个症状创建一个主题。这一步的结果类型是一个发布者数组。</li><li id="ff3c" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">将发布服务器的数组合并成一个发布服务器。</li><li id="e546" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">使用<code class="fe mw mx my mz b">reduce</code>收集流的元素，并发布一个包含所有元素的数组。</li><li id="316e" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">清除此发行者的类型以获得更清晰的签名。</li></ol><p id="55ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！发布者将发出一个包含所有被查询症状的数组。对于这个例子，我已经简化了管道，所有的样本都被转换成一个单一的<code class="fe mw mx my mz b">Symptom</code>类型。但是，您可以使用相同的方法来组合多个查询，并将它们映射到不同的模型类型。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9dd5" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">何去何从</strong></h1><p id="2ba5" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">概括地说，我们使用<code class="fe mw mx my mz b">Futures</code>来编写授权请求流。然后，使用<code class="fe mw mx my mz b">subjects</code>，我们为HealthKit示例创建了一个发布者。我们看到了如何用<code class="fe mw mx my mz b">MergeMany</code>组合多个发布者，以及如何用像<code class="fe mw mx my mz b">flatMap</code>和<code class="fe mw mx my mz b">reduce</code>这样的操作符扩展它们的行为。</p><p id="0a6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些简单但富有表现力的代码可以完成日常任务。请求授权和异步读取和转换数据对于许多类型的应用程序来说都是常见的，无论它们是否使用HealthKit。试着找出可以从声明性中获益的命令式API，尝试一下，然后告诉我！</p><p id="af86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0889" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">资源</strong></h1><ol class=""><li id="7360" class="nd ne iq ky b kz mr lc ms lf nr lj ns ln nt lr ni nj nk nl bi translated"><a class="ae kv" href="https://www.apple.com/newsroom/2021/03/apple-womens-health-study-releases-preliminary-data-to-help-destigmatize-menstrual-symptoms/" rel="noopener ugc nofollow" target="_blank">女性健康研究更新</a></li><li id="ae78" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="https://developer.apple.com/documentation/healthkit/hkhealthstore/1614152-requestauthorization" rel="noopener ugc nofollow" target="_blank">请求授权文件</a></li><li id="f07b" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="https://www.donnywals.com/using-promises-and-futures-in-combine/" rel="noopener ugc nofollow" target="_blank">唐尼·沃尔斯的《伟大的未来》一文</a></li><li id="88e4" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="https://developer.apple.com/documentation/healthkit/reading_data_from_healthkit" rel="noopener ugc nofollow" target="_blank">苹果从HealthKit读取数据的指南</a></li><li id="5e39" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="https://developer.apple.com/videos/play/wwdc2020/10664/?time=400" rel="noopener ugc nofollow" target="_blank">health kit入门— WWDC20 </a></li></ol></div></div>    
</body>
</html>