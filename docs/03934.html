<html>
<head>
<title>JavaScript Clean Code: Concurrency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript干净代码:并发性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-clean-code-concurrency-d5314cd856b2?source=collection_archive---------3-----------------------#2020-03-13">https://betterprogramming.pub/javascript-clean-code-concurrency-d5314cd856b2?source=collection_archive---------3-----------------------#2020-03-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="49d7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何编写干净的异步代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d5acbbdecd9ab9d43a6592b34bb4abe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Sa2ufwPKCMaE_UWM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jeshoots?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JESHOOTS.COM</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e9a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并发是大多数现代程序的重要组成部分。为了在JavaScript中实现这一点，我们必须使用非阻塞的异步代码。</p><p id="0a1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究如何以一种简洁、易于阅读和修改的方式编写异步代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fc2d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用承诺代替回电</h1><p id="23be" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">承诺从ES6开始就是一个标准对象，所以以前的异步回调应该全部被承诺取代。</p><p id="3842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有任何顺序代码，使用回调是一件非常痛苦的事情，因为我们必须在多个层次上嵌套它们。</p><p id="45fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们想要运行多个没有承诺的<code class="fe mz na nb nc b">setTimeout</code>回调，那么我们必须如下嵌套它们:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d8da" class="nh md it nc b gy ni nj l nk nl">setTimeout(() =&gt; {<br/>  console.log('foo');<br/>  setTimeout(() =&gt; {<br/>    console.log('bar');<br/>    setTimeout(() =&gt; {<br/>      console.log('baz');<br/>    }, 200)<br/>  }, 200)<br/>}, 200)</span></pre><p id="76df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，我们只有三个回调，嵌套已经很难看了。我们必须把它清理干净，这样看起来更舒服，也更容易理解。</p><p id="d050" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过以下承诺做到这一点:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="7af2" class="nh md it nc b gy ni nj l nk nl">const timeOutPromise = (str) =&gt; {<br/>  return new Promise(resolve =&gt; {<br/>    setTimeout(() =&gt; {<br/>      resolve(str);<br/>    }, 200)<br/>  })<br/>}<br/>timeOutPromise('foo')<br/>  .then((val) =&gt; {<br/>    console.log(val);<br/>    return timeOutPromise('bar');<br/>  })<br/>  .then((val) =&gt; {<br/>    console.log(val);<br/>    return timeOutPromise('baz');<br/>  })<br/>  .then((val) =&gt; {<br/>    console.log(val);<br/>  })</span></pre><p id="a3c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，对于承诺，我们可以用传入回调的<code class="fe mz na nb nc b">then</code>方法将它们链接起来。除了在<code class="fe mz na nb nc b">timeoutPromise</code>函数中，我们不需要嵌套回调，并且它只是两层嵌套，而不是三层或更多层。</p><p id="36f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在传递给<code class="fe mz na nb nc b">then</code>方法的回调参数中获得了一个承诺的解析值。</p><p id="ce72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了捕捉错误，我们可以使用带有回调函数的<code class="fe mz na nb nc b">catch</code>方法，如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b03b" class="nh md it nc b gy ni nj l nk nl">const timeOutPromise = (str) =&gt; {<br/>  return new Promise(resolve =&gt; {<br/>    setTimeout(() =&gt; {<br/>      resolve(str);<br/>    }, 200)<br/>  })<br/>}<br/>timeOutPromise('foo')<br/>  .then((val) =&gt; {<br/>    console.log(val);<br/>    return timeOutPromise('bar');<br/>  })<br/>  .then((val) =&gt; {<br/>    console.log(val);<br/>    return timeOutPromise('baz');<br/>  })<br/>  .then((val) =&gt; {<br/>    console.log(val);<br/>  })<br/>  .catch((err) =&gt; console.error(err))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/51b4e12d1ff43be0517ceb7dbc0f3f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lGD8IJbd-EMfbvjx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@tranmautritam?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tran Mau Tri Tam </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6486" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Async/Await是链接承诺的更干净的语法</h1><p id="28fb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">ES2017引入了<code class="fe mz na nb nc b">async</code>和<code class="fe mz na nb nc b">await</code>语法，这是一种更干净的链接承诺的方式。</p><p id="70dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将上面的内容改写为:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="21f5" class="nh md it nc b gy ni nj l nk nl">const timeOutPromise = (str) =&gt; {<br/>  return new Promise(resolve =&gt; {<br/>    setTimeout(() =&gt; {<br/>      resolve(str);<br/>    }, 200)<br/>  })<br/>}</span><span id="6068" class="nh md it nc b gy nn nj l nk nl">(async () =&gt; {<br/>  let val;<br/>  val = await timeOutPromise('foo');<br/>  console.log(val);<br/>  val = await timeOutPromise('bar');<br/>  console.log(val);<br/>  val = await timeOutPromise('baz');<br/>  console.log(val);<br/>})();</span></pre><p id="1ed0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它与以下内容完全相同:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="57c7" class="nh md it nc b gy ni nj l nk nl">const timeOutPromise = (str) =&gt; {<br/>  return new Promise(resolve =&gt; {<br/>    setTimeout(() =&gt; {<br/>      resolve(str);<br/>    }, 200)<br/>  })<br/>}</span><span id="0608" class="nh md it nc b gy nn nj l nk nl">timeOutPromise('foo')<br/>  .then((val) =&gt; {<br/>    console.log(val);<br/>    return timeOutPromise('bar');<br/>  })<br/>  .then((val) =&gt; {<br/>    console.log(val);<br/>    return timeOutPromise('baz');<br/>  })<br/>  .then((val) =&gt; {<br/>    console.log(val);<br/>  })</span></pre><p id="b120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个不同之处是解析后的值通过赋值操作符被赋值给<code class="fe mz na nb nc b">val</code>。只要我们在承诺之前有<code class="fe mz na nb nc b">await</code>，这个任务就有效。</p><p id="16dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了处理被拒绝的承诺，我们可以像处理同步代码一样使用<code class="fe mz na nb nc b">try...catch</code>子句:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="77f5" class="nh md it nc b gy ni nj l nk nl">const timeOutPromise = (str) =&gt; {<br/>  return new Promise(resolve =&gt; {<br/>    setTimeout(() =&gt; {<br/>      resolve(str);<br/>    }, 200)<br/>  })<br/>}</span><span id="43e5" class="nh md it nc b gy nn nj l nk nl">(async () =&gt; {<br/>  try {<br/>    let val;<br/>    val = await timeOutPromise('foo');<br/>    console.log(val);<br/>    val = await timeOutPromise('bar');<br/>    console.log(val);<br/>    val = await timeOutPromise('baz');<br/>    console.log(val);<br/>  } catch (err) {<br/>    console.error(err);<br/>  }<br/>})();</span></pre><p id="2072" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">async</code>函数只返回承诺，所以不能作为通用函数使用。它们是承诺的语法糖，而不是它的替代品。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="10ed" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="bbda" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要编写异步代码，承诺是必经之路。它们允许我们将多个链接在一起，而不需要嵌套回调。</p><p id="8b35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果异步代码没有作为承诺返回，我们应该将它们转换成承诺。为了链接它们，我们可以使用<code class="fe mz na nb nc b">then</code>方法。</p><p id="3d19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了从被拒绝的承诺中发现错误，我们可以使用<code class="fe mz na nb nc b">catch</code>方法。</p><p id="d5d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">async</code>和<code class="fe mz na nb nc b">await</code>是承诺的句法糖。它们是一样的，但是<code class="fe mz na nb nc b">async</code>和<code class="fe mz na nb nc b">await</code>更短。</p><p id="72ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe mz na nb nc b">try...catch</code>通过<code class="fe mz na nb nc b">async</code>和<code class="fe mz na nb nc b">await</code>从被拒绝的承诺中捕捉错误。</p></div></div>    
</body>
</html>