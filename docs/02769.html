<html>
<head>
<title>Threading in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中的线程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/threading-in-android-129b8688436a?source=collection_archive---------1-----------------------#2019-12-29">https://betterprogramming.pub/threading-in-android-129b8688436a?source=collection_archive---------1-----------------------#2019-12-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="664d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Android线程的详细演练</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f7df63f0f125ddc39cf829cab964d55c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7iV-yPgXRvTLXcn22aV4Wg.png"/></div></div></figure><h1 id="76cb" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="48e2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">每个Android开发人员都需要在应用程序中处理线程。默认情况下，线程做三件事:启动、做一些工作和终止。</p><p id="2927" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">它适合于小块工作，但不适合于长任务，在长任务中线程继续执行任务。</p><p id="9cb6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当一个线程在完成一些工作后死亡，我们需要在线程上运行某种循环来保持它的活力。但是我们应该能够在需要的时候终止它们。</p><p id="09d5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">此外，我们可能需要一种队列，循环可以从中提取工作进行处理。此外，我们可能需要一些其他的线程来创建工作包，并将它们推入队列以供执行。</p><p id="787d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">做所有这些事情并维护它们的状态会产生很多不确定性。然而，Android提供了一组类来做这些事情。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="cc4f" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">Android线程类</h1><p id="dd14" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">当一个应用程序启动时，Android会创建自己的Linux进程。除了这个系统之外，它还为应用程序创建了一个执行线程，称为<em class="mz">主线程</em>或<em class="mz"> UI线程</em>。主线程只是一个处理程序线程。主线程负责处理来自整个应用程序的事件，比如与生命周期信息相关的回调或来自输入事件的回调。它还可以处理来自其他应用程序的事件。</p><p id="444b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">任何需要运行的代码块都被推入工作队列，然后由主线程提供服务。由于主线程要做这么多的工作，最好把更长的工作交给其他线程，这样就不会打扰UI线程的渲染工作。重要的是避免使用主线程来执行任何可能导致它被阻塞从而导致ANRs(应用程序不响应)的操作。</p><p id="53fe" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">网络操作或数据库调用或某些组件的加载是当它们在主线程上执行时可能导致主线程阻塞的一些例子。它们是同步执行的，这意味着在任务完成之前，UI将保持完全无响应。为了避免这种情况，它们通常在单独的线程中执行，这样可以避免在执行任务时阻塞UI。这意味着它们是从UI异步执行的。</p><p id="6f0b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">Android提供了许多创建和管理线程的方法，并且有许多第三方库使得线程管理更加容易。每个线程类都有特定的用途；然而，选择一个适合我们需求的是非常重要的。</p><p id="58b4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">可用的不同线程类别有:</p><p id="6b74" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> AsyncTask: </strong>帮助完成UI线程的工作</p><p id="3222" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> HandlerThread: </strong>回调线程</p><p id="da93" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">运行大量并行工作</p><p id="59c9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> IntentService: </strong>帮助从UI线程中获取意图</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="89b3" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">异步任务</h1><p id="6b3e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">AsyncTask支持正确、轻松地使用UI线程。此类允许您在不使用线程或处理程序的情况下，在UI线程上执行后台操作和发布结果。</p><p id="3060" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">AsyncTask被设计为围绕<code class="fe na nb nc nd b"><a class="ae ne" href="https://developer.android.com/reference/java/lang/Thread.html" rel="noopener ugc nofollow" target="_blank">Thread</a></code>和<code class="fe na nb nc nd b"><a class="ae ne" href="https://developer.android.com/reference/android/os/Handler.html" rel="noopener ugc nofollow" target="_blank">Handler</a></code>的助手类，并不构成通用线程框架。理想情况下，异步任务应该用于短时间的操作(最多几秒钟)。)如果你需要长时间保持线程运行，强烈推荐你使用<code class="fe na nb nc nd b">java.util.concurrent</code>包提供的各种API，比如<code class="fe na nb nc nd b"><a class="ae ne" href="https://developer.android.com/reference/java/util/concurrent/Executor.html" rel="noopener ugc nofollow" target="_blank">Executor</a></code>、<code class="fe na nb nc nd b"><a class="ae ne" href="https://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html" rel="noopener ugc nofollow" target="_blank">ThreadPoolExecutor</a></code>和<code class="fe na nb nc nd b"><a class="ae ne" href="https://developer.android.com/reference/java/util/concurrent/FutureTask.html" rel="noopener ugc nofollow" target="_blank">FutureTask</a></code>。</p><p id="1144" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">执行异步任务时，该任务会经历四个步骤:</p><p id="6438" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">1.<code class="fe na nb nc nd b">onPreExecute()</code>:任务执行前在UI线程上调用。这一步通常用于在任务开始之前做一些事情——例如，简单地在用户界面中显示一个进度对话框。</p><p id="2c7d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">2.<code class="fe na nb nc nd b">doInBackground(Params…)</code>:在<code class="fe na nb nc nd b">onPreExecute()</code>执行完毕后，在后台线程上调用。此步骤用于执行可能需要很长时间的后台计算。异步任务的参数被传递到这个步骤。这个步骤必须返回计算结果，并将结果发送给<code class="fe na nb nc nd b">onPostExecute()</code>。这一步也可以使用<code class="fe na nb nc nd b">publishProgress(..)</code>来发布一个或多个进度单元。</p><p id="7d69" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">3.<code class="fe na nb nc nd b">onProgressUpdate(Progress…)</code>:调用<code class="fe na nb nc nd b">publishProgress(..)</code>后在UI线程上调用。此方法用于在后台计算仍在执行时，在用户界面中显示任何形式的进度。例如，它可以用来制作进度条动画或在文本字段中显示日志。</p><p id="fad1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">4.<code class="fe na nb nc nd b">onPostExecute(Result)</code>:后台计算完成后，在UI线程上调用。背景计算的结果作为参数传递给该步骤。</p><p id="d87e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">可以通过调用<code class="fe na nb nc nd b">cancel(boolean…)</code>随时取消任务。我们需要通过检查任务是被取消还是正在运行来做到这一点。</p><h2 id="a23d" class="nf kv it bd kw ng nh dn la ni nj dp le lv nk nl lg lz nm nn li md no np lk nq bi translated">履行</h2><pre class="kj kk kl km gt nr nd ns nt aw nu bi"><span id="8932" class="nf kv it nd b gy nv nw l nx ny">private class AsyncTaskRunner extends AsyncTask&lt;String, String, String&gt; {</span><span id="cb3a" class="nf kv it nd b gy nz nw l nx ny">@Override  protected void onPreExecute() {<br/>  progressDialog.show();<br/> }</span><span id="fb65" class="nf kv it nd b gy nz nw l nx ny">@Override  protected String doInBackground(String... params) {          . doSomething();<br/>  publishProgress("Sleeping..."); // Calls onProgressUpdate()<br/>  return resp;<br/> }</span><span id="bd87" class="nf kv it nd b gy nz nw l nx ny">@Override   protected void onPostExecute(String result) {<br/>  // execution of result of Long time consuming operation            . progressDialog.dismiss();<br/>  updateUIWithResult() ;<br/> }</span><span id="e214" class="nf kv it nd b gy nz nw l nx ny">@Override  protected void onProgressUpdate(String... text) {<br/> updateProgressUI();<br/> }</span><span id="25e6" class="nf kv it nd b gy nz nw l nx ny">}</span></pre><h2 id="b717" class="nf kv it bd kw ng nh dn la ni nj dp le lv nk nl lg lz nm nn li md no np lk nq bi translated">何时使用AsyncTask</h2><p id="4b9e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">AsyncTask是快速结束需要频繁UI更新的<strong class="lo iu"> </strong>短期工作的完美解决方案。</p><p id="d060" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然而，如果您需要您的延迟任务在活动/片段的生命周期之外运行，那么异步任务是不够的。值得注意的是，即使像屏幕旋转这样简单的事情也会导致活动被破坏。</p><h2 id="5ada" class="nf kv it bd kw ng nh dn la ni nj dp le lv nk nl lg lz nm nn li md no np lk nq bi translated">执行顺序</h2><p id="8dd5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">默认情况下，所有创建的AsyncTasks将共享同一个线程，并从单个消息队列中按顺序执行。同步执行会影响单个任务。</p><p id="ade8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果我们想让任务并行执行，我们可以使用<code class="fe na nb nc nd b">THREAD_POOL_EXECUTOR</code>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="deb9" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">手柄线程</h1><p id="432c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">处理线程是普通Java线程类的子类。处理程序线程是一个长期运行的线程，它从队列中获取工作并对其进行操作。它是其他Android原语的组合，即:</p><p id="b26f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><a class="ae ne" href="https://developer.android.com/reference/android/os/Looper.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iu"> Looper </strong> </a> <strong class="lo iu"> : </strong>保持线程活动并持有消息队列</p><p id="3fbc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><a class="ae ne" href="https://developer.android.com/reference/android/os/MessageQueue.html" rel="noopener ugc nofollow" target="_blank"><strong class="lo iu">message queue</strong></a><strong class="lo iu">:</strong>类，保存一个循环将要发送的消息列表</p><p id="90ee" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><a class="ae ne" href="https://developer.android.com/reference/android/os/Handler.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iu">处理程序</strong> </a> <strong class="lo iu"> : </strong>允许我们发送和处理与一个线程的MessageQueue相关的消息对象</p><p id="a9b6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这意味着我们可以让它在后台运行，然后一个接一个地向它提供越来越多的工作包，直到我们退出它。handler线程在您的活动的生命周期之外运行，因此需要对它们进行适当的清理，否则就会出现线程泄漏。</p><p id="29b4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">创建处理程序线程有两种主要方法。</p><ol class=""><li id="11a8" class="oa ob it lo b lp mi ls mj lv oc lz od md oe mh of og oh oi bi translated">创建一个新的处理器线程，并获得活套。现在，通过分配创建的处理程序线程的looper来创建一个新的处理程序，并在这个处理程序上提交您的任务。</li><li id="0cb3" class="oa ob it lo b lp oj ls ok lv ol lz om md on mh of og oh oi bi translated">通过创建<code class="fe na nb nc nd b">CustomHandlerThread</code>类来扩展处理程序线程。然后，创建一个处理程序来处理该任务。如果您知道想要执行的任务，并且只需要传入参数，那么您会采用这种方法。例如，创建一个定制的<code class="fe na nb nc nd b">HandlerThread</code>类来下载图像或执行网络任务。</li></ol><pre class="kj kk kl km gt nr nd ns nt aw nu bi"><span id="1472" class="nf kv it nd b gy nv nw l nx ny">HandlerThread handlerThread = new HandlerThread("TesHandlerThread");<br/>handlerThread.start();<br/>Looper looper = handlerThread.getLooper();<br/>Handler handler = new Handler(looper);<br/>handler.post(new Runnable(){…});</span></pre><p id="22b6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当我们创建一个处理程序线程时，不要忘记设置它的优先级，因为CPU只能并行处理少量线程，所以设置优先级可以帮助系统知道在其他线程争夺注意力时调度这项工作的正确方法。</p><p id="2bff" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">注意:</strong>当你完成后台线程或者活动的<code class="fe na nb nc nd b">onDestroy()</code>方法时，调用<code class="fe na nb nc nd b">handlerThread.quit()</code>。</p><p id="139c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们可以通过使用本地广播或者通过用主循环创建一个处理程序来发布对UI线程的更新。</p><pre class="kj kk kl km gt nr nd ns nt aw nu bi"><span id="2dac" class="nf kv it nd b gy nv nw l nx ny">Handler mainHandler = new Handler(context.getMainLooper()); <br/> <br/>mainHandler.post(myRunnable);</span></pre><p id="c674" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">何时使用处理程序线程</strong></p><p id="8029" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对于不需要UI更新的长期运行的后台工作，处理程序线程是完美的解决方案。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="8303" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">ThreadPoolExecutor</h1><h2 id="c15d" class="nf kv it bd kw ng nh dn la ni nj dp le lv nk nl lg lz nm nn li md no np lk nq bi translated">什么是线程池？</h2><p id="22d1" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">线程池基本上是一个等待分配任务的线程池。分配给这些线程的任务将并行运行。当任务并行执行时，我们可能希望确保代码是线程安全的。线程池主要解决两个问题:</p><ul class=""><li id="2f8c" class="oa ob it lo b lp mi ls mj lv oc lz od md oe mh oo og oh oi bi translated">由于减少了每个任务的开销，提高了执行大量异步任务时的性能</li><li id="154c" class="oa ob it lo b lp oj ls ok lv ol lz om md on mh oo og oh oi bi translated">一种在执行一组任务时绑定和管理资源(包括线程)的方法</li></ul><p id="5f18" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们考虑一个例子:如果我们有40BMP要解码，其中每个位图需要4ms来解码，如果我们在单线程上完成，则需要超过160ms来解码所有位图。</p><p id="3b47" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然而，如果我们用10个线程来做，每个线程解码4个位图。因此，解码这40个位图所需的时间仅为16ms。</p><p id="1475" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里的问题是如何将工作传递给每个线程，如何调度该工作，以及如何管理这些线程。这是一个非常大的问题。这就是<code class="fe na nb nc nd b">ThreadPoolExecutor</code>出场的地方。</p><h2 id="88ed" class="nf kv it bd kw ng nh dn la ni nj dp le lv nk nl lg lz nm nn li md no np lk nq bi translated">什么是ThreadPoolExecutor？</h2><p id="9f3d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">A <code class="fe na nb nc nd b">ThreadPoolExecutor</code> <strong class="lo iu"> </strong>是扩展<strong class="lo iu"/><a class="ae ne" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/AbstractExecutorService.html" rel="noopener ugc nofollow" target="_blank">abstract executorservice</a>的类。负责所有的线程。</p><ul class=""><li id="4e6c" class="oa ob it lo b lp mi ls mj lv oc lz od md oe mh oo og oh oi bi translated">它将任务分配给线程</li><li id="d516" class="oa ob it lo b lp oj ls ok lv ol lz om md on mh oo og oh oi bi translated">这让他们活着</li><li id="f8f0" class="oa ob it lo b lp oj ls ok lv ol lz om md on mh oo og oh oi bi translated">它终止线程</li></ul><p id="137a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">它的工作方式是将要运行的任务保存在一个工作队列中。每当线程池中的一个线程空闲或可用时，就从工作队列中向该线程分配一个任务。</p><p id="8fd6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">可运行的</strong></p><p id="da55" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">它是一个由类实现的接口，该类的实例由线程执行。简单来说:就是可以执行的命令或者任务。它经常用于在不同的线程中运行代码。</p><pre class="kj kk kl km gt nr nd ns nt aw nu bi"><span id="1a24" class="nf kv it nd b gy nv nw l nx ny">Runnable mRunnable = new Runnable() {<br/>    @Override<br/>    public void run() {<br/>        // Do some work<br/>    }<br/>};</span></pre><p id="5ea3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">执行者</strong></p><p id="0237" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一个<code class="fe na nb nc nd b">Executor</code>是一个用来将任务提交和任务执行分离的接口。是执行<code class="fe na nb nc nd b">Runnable</code>的对象。</p><pre class="kj kk kl km gt nr nd ns nt aw nu bi"><span id="7e52" class="nf kv it nd b gy nv nw l nx ny">Executor mExecutor = Executors.newSingleThreadExecutor(); mExecutor.execute(mRunnable);</span></pre><p id="d530" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">执行服务</strong></p><p id="4d26" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">管理异步任务的<code class="fe na nb nc nd b">Executor</code>。</p><pre class="kj kk kl km gt nr nd ns nt aw nu bi"><span id="9af2" class="nf kv it nd b gy nv nw l nx ny">ExecutorService mExecutorService = Executors.newFixedThreadPool(10); mExecutorService.execute(mRunnable);</span></pre><p id="96b8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> ThreadPoolExecutor </strong></p><p id="d91e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">将任务分配给线程池的<code class="fe na nb nc nd b">ExecutorService</code>。</p><p id="fb8c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">更多的线程并不总是好的，因为CPU只能并行执行一定数量的线程。一旦超过这个数字，CPU就必须进行一些昂贵的计算来决定哪个线程应该根据优先级被分配。</p><p id="38b2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在创建<code class="fe na nb nc nd b">ThreadPoolExecutor</code>、<strong class="lo iu">T22的实例时，我们可以指定初始线程数和最大线程数。随着线程池中工作负载的变化，它将扩展活动线程的数量以与之匹配。</strong></p><p id="443b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">通常建议根据可用内核的数量来分配线程。这可以通过以下方式实现:</p><pre class="kj kk kl km gt nr nd ns nt aw nu bi"><span id="c2c2" class="nf kv it nd b gy nv nw l nx ny">int NUMBER_OF_CORES = Runtime.getRuntime().availableProcessors();</span></pre><p id="d61e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">注意:</strong>这并不一定会返回设备上物理核心的实际数量。这可能是CPU可能会停用一些核心，以节省电池等。</p><pre class="kj kk kl km gt nr nd ns nt aw nu bi"><span id="53b5" class="nf kv it nd b gy nv nw l nx ny">ThreadPoolExecutor(<br/>   int corePoolSize,    // Initial pool size<br/>   int maximumPoolSize, // Max pool size<br/>   long keepAliveTime,  // Time idle thread waits before terminating<br/>   TimeUnit unit        // Sets the Time Unit for keepAliveTime<br/>   BlockingQueue&lt;Runnable&gt; workQueue)  // Work Queue</span></pre><p id="f071" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这些参数是什么？</p><ol class=""><li id="c4e1" class="oa ob it lo b lp mi ls mj lv oc lz od md oe mh of og oh oi bi translated"><code class="fe na nb nc nd b">corePoolSize</code>:保留在池中的最小线程数。最初，池中没有线程。但是随着任务被添加到队列中，新的线程被创建。如果少于<code class="fe na nb nc nd b">corePoolSize </code>个线程正在运行，<code class="fe na nb nc nd b">Executor</code>总是倾向于添加一个新线程，而不是排队。</li><li id="0ee2" class="oa ob it lo b lp oj ls ok lv ol lz om md on mh of og oh oi bi translated"><code class="fe na nb nc nd b">maximumPoolSize</code>:池中允许的最大线程数。如果这超过了<code class="fe na nb nc nd b">corePoolSize</code>并且当前线程数是&gt; = <code class="fe na nb nc nd b">corePoolSize</code>，那么只有当队列满时才会创建新的工作线程。</li><li id="c5fd" class="oa ob it lo b lp oj ls ok lv ol lz om md on mh of og oh oi bi translated"><code class="fe na nb nc nd b">keepAliveTime</code>:当线程数大于内核数时，非内核线程(多余空闲线程)将等待一个新任务，如果在该参数定义的时间内没有获得新任务，它们将终止。</li><li id="b44a" class="oa ob it lo b lp oj ls ok lv ol lz om md on mh of og oh oi bi translated"><code class="fe na nb nc nd b">unit</code>:时间单位<code class="fe na nb nc nd b">keepAliveTime</code>。</li><li id="5b64" class="oa ob it lo b lp oj ls ok lv ol lz om md on mh of og oh oi bi translated"><code class="fe na nb nc nd b">workQueue</code>:任务队列，仅保存可运行的任务。它必须是一个阻塞队列。</li></ol><h2 id="62bf" class="nf kv it bd kw ng nh dn la ni nj dp le lv nk nl lg lz nm nn li md no np lk nq bi translated">何时使用ThreadPoolExecutor</h2><p id="ed98" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe na nb nc nd b">ThreadPoolExecutor</code> <strong class="lo iu"> </strong>是一个强大的任务执行框架，当需要并行执行大量任务时，我们可以使用它——因为它支持队列中的任务添加、任务取消和任务优先化。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="7e37" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">IntentService</h1><p id="f5b8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe na nb nc nd b">IntentService</code>是从<code class="fe na nb nc nd b">Service</code>继承的子类。要了解<code class="fe na nb nc nd b">IntentService</code>，我们需要了解<code class="fe na nb nc nd b">Service</code>。</p><p id="2852" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe na nb nc nd b">Service</code>是Android编程中非常重要的组件。有时，我们可能在应用程序关闭后还要执行一项任务。这是<code class="fe na nb nc nd b">Service</code>会更有帮助的场景。<code class="fe na nb nc nd b">Service</code>可以被<code class="fe na nb nc nd b">startService ()</code> / <code class="fe na nb nc nd b">stopService ()</code>调用和取消，长期在后台运行。也可以通过调用其中的<code class="fe na nb nc nd b">stopSelf()</code>来取消。</p><p id="6187" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们看看一些有助于执行操作的重写方法</p><p id="330e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe na nb nc nd b">onCreate()</code>:只调用一次，直到停止。</p><p id="5179" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe na nb nc nd b">onStartCommand()</code>:该函数第一次在<code class="fe na nb nc nd b">onCreate ()</code>之后被调用，但从第二次开始，当任何组件有意图地调用<code class="fe na nb nc nd b">startService()</code>时，该函数将被直接调用。</p><p id="1ae6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe na nb nc nd b">onDestroy()</code>:停止服务时调用。</p><p id="a16a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">正常的服务流程是:</p><pre class="kj kk kl km gt nr nd ns nt aw nu bi"><span id="a1bf" class="nf kv it nd b gy nv nw l nx ny">onCreate() -&gt; onStartCommand() -&gt; onDestroy()</span></pre><p id="304d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">回到<code class="fe na nb nc nd b">IntentService</code>，<code class="fe na nb nc nd b">Service</code>的启动方式与普通<code class="fe na nb nc nd b">Service</code>相同(从主线程调用<code class="fe na nb nc nd b">startService()</code>)。它在<code class="fe na nb nc nd b">onHandleIntent()</code>中处理每个意图，而不是<code class="fe na nb nc nd b">onStartCommand()</code>。它使用一个工作线程，并在工作耗尽时自行停止。要使用它，我们需要扩展<code class="fe na nb nc nd b">IntentService</code>并实现<code class="fe na nb nc nd b">onHandleIntent()</code>。</p><p id="1a2e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">注意:</strong> <code class="fe na nb nc nd b">IntentService</code>运行在单个工作线程上，<code class="fe na nb nc nd b">Service</code>运行在主线程上。一次只会处理一个请求。</p><p id="0547" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe na nb nc nd b">IntentService</code>受制于Android 8.0 (API等级26)强加的所有<a class="ae ne" href="https://developer.android.com/preview/features/background.html" rel="noopener ugc nofollow" target="_blank">后台执行限制</a>。在大多数情况下，你最好使用<code class="fe na nb nc nd b"><a class="ae ne" href="https://developer.android.com/reference/android/support/v4/app/JobIntentService.html" rel="noopener ugc nofollow" target="_blank">JobIntentService</a></code>，它在Android 8.0或更高版本上运行时使用作业而不是服务。</p><h2 id="2b62" class="nf kv it bd kw ng nh dn la ni nj dp le lv nk nl lg lz nm nn li md no np lk nq bi translated">何时使用IntentService</h2><p id="db44" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe na nb nc nd b">IntentService</code>按需处理异步请求。如果您不要求您的服务同时处理多个请求，这是最好的选择。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="829d" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">结论</h1><p id="86f2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">目前就这些。希望你从这篇文章中学到了一些东西。我将为上面指定的每个组件编写单独的部分。感谢阅读。</p><h2 id="b24d" class="nf kv it bd kw ng nh dn la ni nj dp le lv nk nl lg lz nm nn li md no np lk nq bi translated">参考</h2><p id="1439" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><a class="ae ne" href="https://developer.android.com/reference/android/app/IntentService" rel="noopener ugc nofollow" target="_blank">“intent service</a>”—Android开发者文档</p><p id="a8c2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><a class="ae ne" href="https://www.youtube.com/watch?v=0Z5MZ0jL2BM" rel="noopener ugc nofollow" target="_blank">“了解Android线程</a>”—Android性能模式第五季，Ep。2</p></div></div>    
</body>
</html>