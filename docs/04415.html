<html>
<head>
<title>The Evolution of Adapters in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中适配器的演变</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/evolution-of-adapters-in-android-2e2ff58c0f98?source=collection_archive---------5-----------------------#2020-04-12">https://betterprogramming.pub/evolution-of-adapters-in-android-2e2ff58c0f98?source=collection_archive---------5-----------------------#2020-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7125" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">回顾一下我们在过去十年中取得的进步</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/34047aad7835a68df05548b686903f97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jSV9UI4fdOdboiEu"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@emilep?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">émile Perron</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="518a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">概观</h1><p id="77d5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你从事Android开发已经有一段时间了，你可能需要在职业生涯的不同阶段实现一个视图列表。</p><p id="d6ee" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，您可能使用了<code class="fe ms mt mu mv b">ListView </code>和<code class="fe ms mt mu mv b">GridView </code>在一个网格结构中垂直和水平地显示项目列表。然后是<code class="fe ms mt mu mv b">Recyclerview</code>，它带来了对现有模式的许多增强和像<code class="fe ms mt mu mv b">viewtypes</code>这样的新实现——这是Android适配器的革命性改进。最近<code class="fe ms mt mu mv b">ListAdapter</code>出现了，主要集中于增强性能以提供流畅的体验，即使列表上有数千个项目。</p><p id="b228" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">知道我们今天用什么很重要。同样重要的是要知道<em class="mw">为什么</em>我们会使用我们今天使用的东西。所以我们来看看Android中适配器的历史。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="0b70" class="kz la it bd lb lc ne le lf lg nf li lj jz ng ka ll kc nh kd ln kf ni kg lp lq bi translated">基本适配器</h1><p id="ddc2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是Android中适配器的开始。在基本适配器中，我们没有像现代Android开发中那样的<code class="fe ms mt mu mv b">viewtypes </code>或<code class="fe ms mt mu mv b">itemdecorator </code>。让我们来看一个简单的基本适配器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="fa25" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里，<code class="fe ms mt mu mv b">getView</code>是完全负责创建和膨胀每个视图的函数。我们必须手动检查视图是否已经创建，然后使用布局中的视图，这是目前最好的方法。据我所知，要扩展不同的视图类型，我们需要在相同的布局中设计所有的视图，并且我们必须根据类型切换可见性。这是一个很大的工作量，而且视图不会被适当地回收。这些事情限制了Android开发者创建像我们这些天在Instagram和Twitter上看到的那些花哨的列表。</p><p id="2a34" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另一个主要缺点是我们必须使用网格适配器来显示网格中的视图。就我个人而言，我在2015年末职业生涯开始时会使用<code class="fe ms mt mu mv b">BaseAdapter </code>和<code class="fe ms mt mu mv b">GridAdapter </code>一段时间——相信我，它们很烂！</p><p id="1c59" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这并不是说它们的性能很差，而是我们必须一直做每一点点工作，即使这样也会出现OOM(内存不足)异常之类的问题。那是一场噩梦。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="db52" class="kz la it bd lb lc ne le lf lg nf li lj jz ng ka ll kc nh kd ln kf ni kg lp lq bi translated">RecyclerView适配器</h1><p id="ce7f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">带着悲惨的<code class="fe ms mt mu mv b">baseAdapter</code>前进了几个月，有一天我认识了奇迹般的<code class="fe ms mt mu mv b">recyclerviewAdapter</code>。这对我来说是一个游戏规则的改变。它不仅解决了<code class="fe ms mt mu mv b">baseAdapter</code>中的问题，还为新的可能性打开了大门，如<code class="fe ms mt mu mv b">viewTypes</code>、<code class="fe ms mt mu mv b">itemdecorators</code>，将垂直、水平和网格列表与<code class="fe ms mt mu mv b">layoutmanager</code>相结合，等等。</p><p id="eeaf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们来看一个简单的<code class="fe ms mt mu mv b">recyclerview </code>适配器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="df6f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这个<code class="fe ms mt mu mv b">recyclerview</code>适配器中，我们有两个不同的功能:<code class="fe ms mt mu mv b">onCreateViewHolder </code>和<code class="fe ms mt mu mv b">onBindViewHolder</code>。这些方法只创建视图一次，并在需要时展开视图。这提高了性能，因为<code class="fe ms mt mu mv b">recyclerview</code>只在必要时创建和使用视图。如果列表中有100个条目，它不会加载所有条目，而是只加载当前可以显示给用户的视图数量。在滚动时，<code class="fe ms mt mu mv b">recyclerview</code>适配器只将用户可见的视图存储在内存中，这使得它更加高效和直观。</p><h2 id="35a7" class="nl la it bd lb nm nn dn lf no np dp lj ma nq nr ll me ns nt ln mi nu nv lp nw bi translated">视图类型</h2><p id="904c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">除了上述优点，<code class="fe ms mt mu mv b">recyclerview</code>也为新的实现打开了大门，通过<code class="fe ms mt mu mv b">viewTypes</code>，在同一个适配器中构建嵌套列表和不同的布局。</p><p id="1a14" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在上面的适配器中，我们在该方法中实现了如下所示的<code class="fe ms mt mu mv b">getItemViewType()</code>函数和代码。这是区分要展开的视图的<code class="fe ms mt mu mv b">viewType</code>逻辑。</p><pre class="kj kk kl km gt nx mv ny nz aw oa bi"><span id="4705" class="nl la it mv b gy ob oc l od oe">@Override<br/>public int <strong class="mv iu">getItemViewType</strong>(int position) {<br/>    if (employees.get(position).isEmail) {<br/>        return TYPE_EMAIL;<br/><br/>    } else {<br/>        return TYPE_CALL;<br/>    }<br/>}</span></pre><p id="11ec" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们这里经过的<code class="fe ms mt mu mv b">viewType</code>在<code class="fe ms mt mu mv b">onCreateViewHolder</code>里有。通过使用它，我们可以放大不同的视图。</p><h2 id="7003" class="nl la it bd lb nm nn dn lf no np dp lj ma nq nr ll me ns nt ln mi nu nv lp nw bi translated">支持网格和列表</h2><p id="5d2c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在recycler-view中有一个新的概念叫做布局管理器，它允许我们在没有任何复杂性的情况下集成网格和列表。</p><ul class=""><li id="4e08" class="of og it lt b lu mn lx mo ma oh me oi mi oj mm ok ol om on bi translated"><code class="fe ms mt mu mv b">LinearLayoutManager</code>:支持垂直和水平列表。</li><li id="6e55" class="of og it lt b lu oo lx op ma oq me or mi os mm ok ol om on bi translated"><code class="fe ms mt mu mv b">StaggeredLayoutManager</code>:支持交错列表，就像我们在Pinterest应用中看到的那样。</li><li id="ee12" class="of og it lt b lu oo lx op ma oq me or mi os mm ok ol om on bi translated"><code class="fe ms mt mu mv b">GridLayoutManager</code>:支持像图库一样的显示网格。</li></ul><p id="ea51" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">看看用布局管理器改变列表结构有多快:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="1639" class="nl la it bd lb nm nn dn lf no np dp lj ma nq nr ll me ns nt ln mi nu nv lp nw bi translated">动画片</h2><p id="681d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">列表中的动画是<code class="fe ms mt mu mv b">RecyclerView</code>附带的另一个很酷的特性。除了<code class="fe ms mt mu mv b">notifyDataSetChanged</code>之外，任何一个<code class="fe ms mt mu mv b">notify</code>功能被触发，<code class="fe ms mt mu mv b">RecyclerView</code>都会进行相应的动画。这包括<code class="fe ms mt mu mv b">notifyItemChanged</code>、<code class="fe ms mt mu mv b">notifyItemInserted</code>、<code class="fe ms mt mu mv b">notifyItemMoved</code>和<code class="fe ms mt mu mv b">notifyItemRemoved</code>。</p><h2 id="1a68" class="nl la it bd lb nm nn dn lf no np dp lj ma nq nr ll me ns nt ln mi nu nv lp nw bi translated">取景器模式</h2><p id="883d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe ms mt mu mv b">ViewHolder</code>模式用于加速列表的渲染，使其流畅运行。在每次呈现列表项时使用<code class="fe ms mt mu mv b">findViewById</code>是很昂贵的——它必须深入到你的布局层次结构中，并且实例化对象。由于列表在滚动过程中会频繁地重绘其项目，这样的开销可能会影响性能。</p><p id="698a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">RecyclerView</code>毫无疑问是Android中革命性的小工具，但一切都有下一步。对于<code class="fe ms mt mu mv b">RecyclerView</code>也是如此，下一步称为<code class="fe ms mt mu mv b">ListAdapter</code>。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="2c30" class="kz la it bd lb lc ne le lf lg nf li lj jz ng ka ll kc nh kd ln kf ni kg lp lq bi translated">列表适配器</h1><p id="9ca5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe ms mt mu mv b">RecyclerView</code>适配器不是<code class="fe ms mt mu mv b">BaseAdapter</code>的扩展。另一方面，<code class="fe ms mt mu mv b">ListAdapter</code>是<code class="fe ms mt mu mv b">RecyclerView</code>适配器的下一代(它扩展了<code class="fe ms mt mu mv b">recyclerview-adapter</code>)。<code class="fe ms mt mu mv b">ListAdapter</code>主要致力于提高性能——即使是海量数据，如无止境的Instagram和Twitter feeds自动播放视频。</p><p id="50a6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用<code class="fe ms mt mu mv b">RecyclerView</code>时，如果添加或删除了任何新项目，或者现有项目发生了任何变化，适配器本身负责验证列表。有了<code class="fe ms mt mu mv b">ListAdapter</code>，这项工作现在由<code class="fe ms mt mu mv b"><a class="ae ky" href="https://developer.android.com/reference/android/support/v7/recyclerview/extensions/AsyncListDiffer.html" rel="noopener ugc nofollow" target="_blank">AsyncListDiffer,</a></code>来完成，它是一个助手，通过后台线程上的<code class="fe ms mt mu mv b"><a class="ae ky" href="https://developer.android.com/reference/android/support/v7/util/DiffUtil" rel="noopener ugc nofollow" target="_blank">DiffUtil</a></code>来计算两个列表之间的差异。看看它的基本用法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="8efc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它有两个主要功能:</p><h2 id="fd48" class="nl la it bd lb nm nn dn lf no np dp lj ma nq nr ll me ns nt ln mi nu nv lp nw bi translated">areItemsTheSame</h2><p id="4140" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">该函数决定是放大当前视图还是创建一个新视图。如上所示，我们需要像比较id一样比较主键值，它对于列表中的每一项都是唯一的。</p><h2 id="59b6" class="nl la it bd lb nm nn dn lf no np dp lj ma nq nr ll me ns nt ln mi nu nv lp nw bi translated">内容相同</h2><p id="5a20" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">仅当此函数返回true时，列表适配器才刷新视图。这是因为我们可能在项目中有许多不影响UI的变量，所以这些变量的变化不应该影响UI。为了有效地工作，我们需要比较我们在UI中使用的条目变量。</p><p id="c4d2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通过这种方式，我们可以控制何时在列表中呈现新项目，以及何时更新项目中的数据。太酷了，对吧！</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="d06c" class="kz la it bd lb lc ne le lf lg nf li lj jz ng ka ll kc nh kd ln kf ni kg lp lq bi translated">奖金</h1><p id="fbca" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要了解更多关于如何使用最新的列表适配器在Kotlin中创建反应式和异构适配器的信息，请阅读本文。</p><p id="2db7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">感谢阅读。</p></div></div>    
</body>
</html>