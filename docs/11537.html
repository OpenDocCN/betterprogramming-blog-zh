<html>
<head>
<title>Adding Gestures To Your SwiftUI Rubik Cube App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向SwiftUI Rubik Cube应用程序添加手势</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/adding-gestures-to-your-swiftui-rubik-cube-app-12ed853ce0aa?source=collection_archive---------19-----------------------#2022-03-28">https://betterprogramming.pub/adding-gestures-to-your-swiftui-rubik-cube-app-12ed853ce0aa?source=collection_archive---------19-----------------------#2022-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1678" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建魔方系列的第3部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f5315e1df4a68ceb5e8806f58201a091.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*d9xZNE04v6cyxUstXg12nw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个魔方，你的魔方真实地映射到每个面上，在这个项目中变得越来越模糊…图片由作者提供</p></figure><p id="1502" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一个挑战——我的目标是尝试引入一种更自然的方法，使用手势而不是按钮来解魔方，就像我在上一篇文章中结束的那样。我花了一个多星期才适应的长途旅行。<br/>我想我体会到了托马斯·爱迪生(他发现了一千种不做电灯泡的方法)试图把事情做好的感觉，他提出了四种几乎行得通但行不通的解决方案。</p><h1 id="d178" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">挑战和解决方案</h1><h2 id="dd01" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">阻力</h2><p id="e1e8" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">因为我想在SwiftUI中使用SceneView，所以第一个挑战是让<code class="fe nd ne nf ng b">CameraOrbit</code>工作。</p><p id="9134" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我最初使用一个带有一些共享属性的singleton来启动和运行它。但是在这样做的时候，我发现自己看到了来自控制台的一连串警告。</p><p id="1b22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于访问视图上未安装的<code class="fe nd ne nf ng b">StateObjects</code>的警告。我需要的是推而不是拉。</p><p id="1a10" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我用一个订阅解决了这个问题，这个订阅通过一个使用Combine框架的方法发送值来移动相机的轨道。我用这三条线做了一个设置。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="68bc" class="mm lv it ng b gy nl nm l nn no">let passDrag = PassthroughSubject&lt;(CGPoint,CGSize),Never&gt;()<br/>var sub2: AnyCancellable!</span><span id="b1a5" class="mm lv it ng b gy np nm l nn no">sub2 = passDrag.sink(receiveValue: { (translation ) in<br/>  self.setCamera(translation: translation)<br/>})</span></pre><p id="9ed4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更改摄像机位置视图本身的实际代码如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="4f4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我试着旋转立方体本身，因为我觉得数学可能会简单一点。但是它有一个不幸的副作用，破坏了我在本系列第二部分中概述的解决方案，在我这样做之后，节点位置的匹配失败了。</p><p id="30e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我还需要向应用程序发出信号，表明我没有旋转立方体，而是要求它旋转其中的元素——这是由lockView变量指示的状态。我使用一个已发布的对象或通过订阅再次尝试，最终发现后者更好。发布的对象有点太慢了。</p><h2 id="7759" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">热门歌曲</h2><p id="3381" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">我偶然发现的这个解决方案。问题是，由于我没有在我的<code class="fe nd ne nf ng b">Scene</code>中使用触摸事件，我需要利用一种方法通过拖拽获得位置。为了解决这个问题，我使用了一个singleton来存储点击。然后，我设置了一个计时器来定期检查事件队列——这是我的目标——阻止应用程序让界面上的事件超载。</p><h2 id="cbee" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">动作</h2><p id="d0d4" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">让手势自然地工作是这个项目最具挑战性的方面——当然，我有使用阴影节点来制作运动动画的解决方案——但是我还需要更多。几天过去了，我才意识到我在尝试一件不可能的事情。你看——你在每个角落有六个动作，但只有三个面。最初，我尝试使用拖动方向；但是因为你可以向任何方向移动立方体的轴，这是一个昂贵的(浪费时间)错误。我试着标记立方体来追踪你击中了哪个，但是它也没有通过轴测试。</p><p id="5108" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我试着研究欧拉角视角。尽管如此，这是一个不直观的解决方案，也是一个次等的解决方案——有后效——给人的印象是只有一半的时间在工作。</p><p id="fae2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我想这是第四天——当我想到如果我让用户拖动一个盒子的两边，我可以决定他们希望盒子向哪个方向移动时，我几乎准备好承认失败了。我早在几天前就应该想到一个显而易见的解决方案。</p><p id="e345" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我遇到的唯一问题是几何指数，手册页会告诉你你击打的哪一侧似乎不太可靠。幸运的是，我在SO上找到了这个替代方案[和我的阴影解决方案一样，只有在不旋转使用它的节点时才有效]。</p><p id="4c55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我开始工作了——我需要做的就是查看命中数组中的第一个和最后一个条目，以检查立方体中的哪些盒子是您开始拖动的，然后结束拖动的——然后我平移两边，我必须移动正确的盒子集合。<br/>通过拖动多个面来确定我需要旋转哪个节点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="3654" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我开始工作了——我需要做的就是查看命中数组中的第一个和最后一个条目，以检查立方体中的哪些盒子是您开始拖动的，然后结束拖动的——然后我平移两边，我必须移动正确的盒子集合。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9f26caa99271932f3253f4f265b28e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*A4t6lmwJLKCw4gc4ddQZew.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用在多个面上拖动来测试我需要在哪个节点上旋转</p></figure><h2 id="1932" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">最后一招</h2><p id="d9b7" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">但是等等——这里有一个我没有提到的技巧——一个对SceneKit有效的技巧，但是我知道我会对SwiftUI失败。当然，这是一个可怕的轴问题，事实上，当你开始在立方体内旋转盒子时，你碰到的边缘的读数停止工作——当然，这就是为什么魔方如此难以解决。</p><p id="5711" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">诀窍是创建另一个阴影立方体，它比我第一次击中的略大，一个我没有移动任何东西的立方体——也就是说，我可以确定如果我击中红色的脸，它上面的那个将是白色的脸。当然，在引擎盖下，我会使用这些信息来移动可见的立方体。所以以一种迂回的方式，同样的事情来解决轴的问题，找出我需要在哪个节点上旋转。</p><p id="66cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就把我带到了这篇文章的结尾，实际上是魔方系列，至少现在是这样。如果你还没有读完第1和第2部分，你应该回去读一下<a class="ae ns" rel="noopener ugc nofollow" target="_blank" href="/build-a-rubik-cube-using-sceneview-and-swiftui-dea9e622ef43">这里</a>和<a class="ae ns" rel="noopener ugc nofollow" target="_blank" href="/adding-realistic-movement-to-your-rubik-cube-da287dfaf69b">这里</a>。</p><h2 id="052e" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">表面</h2><p id="39b8" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">在立方体的表面上使用你的只是一个合适的乐趣，虽然非常费时。为了做到这一点，我给每个盒子一套自己的材料，将我的六张照片切成9x9的小块，并分别映射到每个盒子上。这是一个问题，我相信我可以编码一个真正的解决方案；我的映射是用试错法完成的。</p><p id="0b78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无论如何，现在足够的魔方，保持密切合作；我的下一个任务是建立一个基于SceneKit的外星人象棋游戏，使用我从这个网站下载的这些优秀的Giger风格的模型。这个是女王。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/15b9f4ff0ea09f6d7fe95eb540d2f62a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*U0ESFuvFlmSp_N7Qt2KTYQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个国际象棋模型，从cgtrader下载，由<a class="ae ns" href="http://2@gmail.com" rel="noopener ugc nofollow" target="_blank"> themerces </a>设计</p></figure><p id="7a7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个国际象棋模型，从cgtrader下载，由<a class="ae ns" href="http://2@gmail.com/" rel="noopener ugc nofollow" target="_blank"> themerces </a>设计</p></div></div>    
</body>
</html>