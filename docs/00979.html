<html>
<head>
<title>Open-Closed Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开闭原理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solid-swift-by-examples-part-two-82ac3c457e4e?source=collection_archive---------6-----------------------#2019-08-02">https://betterprogramming.pub/solid-swift-by-examples-part-two-82ac3c457e4e?source=collection_archive---------6-----------------------#2019-08-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f71c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Swift实例中的坚实原则</h2><div class=""/><div class=""><h2 id="4dca" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">坚固的雨燕</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/b935d60ff4ccbe47114d0b1f9baf4c99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p34gTpjQgdXj_bha"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">芬恩·哈克肖在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="45e1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在第一部分中，我们描述了什么是可靠原则以及它们试图解决什么，解释了第一个原则，<em class="me">单一责任</em>。</p><div class="mf mg gp gr mh mi"><a href="https://medium.com/better-programming/solid-swift-by-examples-part-one-35018d53d3e6" rel="noopener follow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">稳固和单一责任原则</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">坚固的雨燕</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">medium.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw lb mi"/></div></div></a></div><p id="5687" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这一部分，我们将探讨以下原则:</p><p id="c81f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">开闭原理是由Bertrand Meyer在1988年定义的。他说:</p><blockquote class="mx"><p id="e347" class="my mz it bd na nb nc nd ne nf ng md dk translated">"软件实体应该对扩展开放，但对修改关闭."</p></blockquote><p id="9034" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">这个概念应该扩展并应用于任何其他模块、类或函数。这并不像听起来那么简单。</p><p id="38e9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为开发人员，我们总是有新的需求，其中一些需要更改或扩展现有的功能和业务逻辑，因此我们需要找到一种方法，在添加或更改代码时保持代码的良好状态。</p><p id="f8c6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，每当我们需要修改现有代码时，开闭原则就会发挥作用。</p><p id="aa38" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Bertrand Meyer提议使用继承来实现这个原则，但是Robert C. Martin和其他人重新定义了它，使用多态形式。</p><p id="713d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我更喜欢使用现代的方法，包括组合、接口(协议)、依赖注入和设计模式(作为装饰者)。</p><p id="9bc7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看下面的例子:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">一个简单的投资管理器类</p></figure><p id="46b4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们有一个投资计算器在生产与以前的代码，遵循以前的做法(单一责任)。我们将投资回报抽象成一个名为<code class="fe no np nq nr b">InvestmentManager</code>的类。</p><p id="df6f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，我们需要增加一种新的投资。我们必须改变<code class="fe no np nq nr b">InvestmentManager</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">高级投资实施</p></figure><p id="b2d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这段代码已经开始有味道了。如果我们有一种新的投资方式，我们会一遍又一遍地改变<code class="fe no np nq nr b">InvestmentManager</code>。</p><p id="55bf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们违反了开闭原则，因为它不是封闭的，不能修改，也不能扩展。每次出现新的投资类型，我们都必须修改这个类。我们必须避免这种情况。</p><p id="0aaf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了解决这个问题，我们将从一个接口(协议)<code class="fe no np nq nr b">Investment</code>继承，并且我们将使用<em class="me">装饰模式</em>添加一个新的投资类(我们也可以用继承来处理这个问题)。</p><p id="d22e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每个新的投资都将实现这个协议，<code class="fe no np nq nr b">InvestmentManager</code>将依靠这个抽象遵循开闭原则。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由协议驱动的投资和高级投资</p></figure><p id="5878" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们已经对<code class="fe no np nq nr b">InvestmentManager</code>进行了修改，允许它在修改时关闭，在扩展时打开。</p><p id="f090" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们需要增加一个新的<code class="fe no np nq nr b">Investment</code> <code class="fe no np nq nr b">Class</code>，那么<code class="fe no np nq nr b">InvestmentManager</code>就不需要改变，因为它通过<code class="fe no np nq nr b">Investment</code>接口开放扩展。</p><p id="5fba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个有趣的事情是<code class="fe no np nq nr b">AdvancedInvestment</code>。通过使用装饰模式，我们可以使用来自<code class="fe no np nq nr b">GeneralInvestment</code>的基本属性和实现<code class="fe no np nq nr b">Investment</code>协议来处理一种新的投资方式。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="f134" class="nz oa it bd ob oc od oe of og oh oi oj ki ok kj ol kl om km on ko oo kp op oq bi translated">结论</h1><p id="ca5f" class="pw-post-body-paragraph li lj it lk b ll or kd ln lo os kg lq lr ot lt lu lv ou lx ly lz ov mb mc md im bi translated">我们使用了开闭原则，使我们的代码更容易维护和扩展。有时候，当我们写代码时，我们看不到创建抽象的需要，但是我们可能会需要它。</p><p id="6ed9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望你喜欢这篇文章，它对你有帮助。感谢阅读。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="ef26" class="nz oa it bd ob oc od oe of og oh oi oj ki ok kj ol kl om km on ko oo kp op oq bi translated">下一章</h1><div class="mf mg gp gr mh mi"><a href="https://medium.com/@piero9212/solid-swift-by-examples-part-three-675672c1ec20" rel="noopener follow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">利斯科夫替代原理</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">这是关于坚实原理的出版物的第三部分。在以前的文章中，我们讨论了什么是固体…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">medium.com</p></div></div><div class="mr l"><div class="ow l mt mu mv mr mw lb mi"/></div></div></a></div><h1 id="ea3d" class="nz oa it bd ob oc ox oe of og oy oi oj ki oz kj ol kl pa km on ko pb kp op oq bi translated">参考</h1><div class="mf mg gp gr mh mi"><a href="https://cactussoft.biz/blog/2018/01/16/ios-best-practices-s-o-l-i-d/" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">iOS最佳实践。第四部分:神盾局</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">作为第3部分:架构的延续，我们来谈谈S.O.L.I.D .原则以及如何在Swift中应用它们…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">cactussoft.biz</p></div></div><div class="mr l"><div class="pc l mt mu mv mr mw lb mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a href="https://codeburst.io/understanding-solid-principles-open-closed-principle-e2b588b6491f" rel="noopener follow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">理解固体原理:开放封闭原理</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">这是理解坚实原理系列的第三部分，我们将探讨什么是开闭原理和…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">codeburst.io</p></div></div><div class="mr l"><div class="pd l mt mu mv mr mw lb mi"/></div></div></a></div><ul class=""><li id="0301" class="pe pf it lk b ll lm lo lp lr pg lv ph lz pi md pj pk pl pm bi translated"><a class="ae lh" href="https://web.archive.org/web/20150905081105/http://www.objectmentor.com/resources/articles/ocp.pdf" rel="noopener ugc nofollow" target="_blank">https://web . archive . org/web/20150905081105/http://www . object mentor . com/resources/articles/OCP . pdf</a></li></ul></div></div>    
</body>
</html>