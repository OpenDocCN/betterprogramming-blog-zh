<html>
<head>
<title>What Is DevSecOps?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是DevSecOps？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-devsecops-44447d6727e8?source=collection_archive---------14-----------------------#2021-01-11">https://betterprogramming.pub/what-is-devsecops-44447d6727e8?source=collection_archive---------14-----------------------#2021-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0b90" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">DevSecOps概述以及如何使其自动化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ef8a89e0bff79056317eb799f75c5301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mocLTLSOfpsJtNaa"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">萨曼莎·甘乃迪在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="29b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着敏捷产品开发模型的扩散，各个层次的行业专家都开始意识到增量发布的价值。然而，也有一种期望，即每个发布周期都将维护和提高所交付产品的可靠性和安全性。</p><p id="c421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为开发人员或工程师，您面临的挑战是在不减慢开发速度或推迟发布日期的情况下实现安全性最佳实践。本文将说明在开发生命周期中包含安全实践的几种方法，以防止以后出现严重问题，并且不会降低您的速度。</p><p id="8a5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将使用<a class="ae ky" href="https://www.heroku.com/flow" rel="noopener ugc nofollow" target="_blank"> Heroku流程</a>作为一个示例流程来展示如何将这些安全实践(或DevSecOps)集成到您的CI/CD实践中，尽管这些实践可以用于几乎任何常见的场景。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7840" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是DevSecOps？</h1><p id="75cd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">DevSecOps是在产品开发过程的早期集成安全最佳实践的理念。使用DevSecOps，安全性不会被视为一个孤立的过程或单独的特性，而是开发生命周期中不可或缺的一部分。自动化有助于您尽早发现并修复安全问题，最好是在将应用程序代码合并到代码存储库的主要分支之前。</p><p id="2e45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DevSecOps实践的一些例子包括扫描安全漏洞的存储库、早期威胁建模、安全设计评审、静态代码分析和代码评审。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9c90" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">进入Heroku流程</h1><p id="7f4b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Heroku Flow 为基于Heroku的应用提供全面的CI/CD解决方案。它在一个视图中无缝地将多个服务(Heroku pipelines、review apps、<a class="ae ky" href="https://www.heroku.com/continuous-integration" rel="noopener ugc nofollow" target="_blank"> Heroku CI </a>和GitHub集成)联系在一起，使工程师能够更好地了解每个代码发布，从拉取请求到生产下线。</p><p id="6696" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了直观起见，请查看从最初提交到生产 <em class="mz">的这个<a class="ae ky" href="https://www.heroku.com/html/continuous-delivery/cd-animation.html" rel="noopener ugc nofollow" target="_blank"> Heroku流程工作流。</a></em></p><p id="d105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上图所示，当创建拉请求时，自动化测试将在<a class="ae ky" href="https://www.heroku.com/continuous-integration" rel="noopener ugc nofollow" target="_blank"> Heroku CI </a>中运行。Heroku CI是Heroku的云持续集成工具；它可以自动检测语言并运行默认命令(如<code class="fe na nb nc nd b">npm test</code>)，也可以通过<code class="fe na nb nc nd b">app.json</code>文件进行配置。CI结果可以在GitHub和Heroku界面中的pull请求细节中找到。</p><p id="69cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一个成功的CI构建，使用<a class="ae ky" href="https://devcenter.heroku.com/articles/github-integration-review-apps" rel="noopener ugc nofollow" target="_blank">评审应用</a>创建一个新的应用评审，并将其部署到一个新的临时Heroku环境中。GitHub pull request视图中提供了新的环境链接，允许工程师轻松地检查CI结果或立即运行任何手动测试。</p><p id="7acd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在合并拉取请求后，应用程序的新审查在使用<a class="ae ky" href="https://devcenter.heroku.com/articles/pipelines" rel="noopener ugc nofollow" target="_blank"> Heroku管道</a>的预生产环境中可用。然后评审就可以提升到生产了。</p><p id="c947" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，虽然Heroku Flow的一些部分包含在免费帐户中(即pipelines和review apps)，但一些功能需要付费(Heroku CI)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="41bc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何用Heroku流自动化DevSecOps</h1><p id="454b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">作为一个与GitHub集成的全面的CI/CD解决方案，Heroku Flow提供了几种方法来自动化您的DevSecOps实践。下面我们来探讨三个常见的例子:</p><ul class=""><li id="78dc" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">安全升级具有安全漏洞的依赖项</li><li id="f9b2" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">尽早发现安全漏洞</li><li id="fc97" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">防止未经授权的组件或库</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0525" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">安全升级具有安全漏洞的依赖项</h1><p id="6746" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可能已经知道应该升级具有已知漏洞的依赖项。识别和更新这些依赖关系可能非常耗时。幸运的是，您可以自动完成大部分工作。</p><p id="881f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GitHub提供了一个依赖漏洞扫描器，也称为<a class="ae ky" href="https://docs.github.com/en/free-pro-team@latest/github/administering-a-repository/configuration-options-for-dependency-updates" rel="noopener ugc nofollow" target="_blank">dependent bot</a>，可以在GitHub的安全设置中针对每个存储库启用<a class="ae ky" href="https://github.com/features/security" rel="noopener ugc nofollow" target="_blank">。默认情况下，当识别出存在已知漏洞的依赖项时，它会向GitHub接口添加警告。</a></p><p id="5a1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这是一个有用的特性，但它仍然需要您检查警告并手动创建拉请求来升级受影响的依赖项并创建一个修复版本。幸运的是，Dependabot中有一个测试功能，可以自动创建pull请求来修复已知的漏洞。</p><p id="1162" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要启用此功能，只需将一个<code class="fe na nb nc nd b">.github/dependabot.yml</code> <em class="mz"> </em>文件添加到您的存储库中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="187b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Dependabot将使用建议的修复创建pull请求，将GitHub <a class="ae ky" href="https://docs.github.com/en/free-pro-team@latest/github/creating-cloning-and-archiving-repositories/about-code-owners#codeowners-syntax" rel="noopener ugc nofollow" target="_blank">代码所有者</a>添加为默认审查者。<a class="ae ky" href="https://docs.github.com/en/free-pro-team@latest/github/administering-a-repository/configuration-options-for-dependency-updates" rel="noopener ugc nofollow" target="_blank">dependent bot文档</a>涵盖了所有可用选项。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/531482b003d007ce013982c813672576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bIqLGcl_yhkdCQTK"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Dependabot创建的用于解决已知漏洞的请求</p></figure><p id="7f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然pull请求会升级受影响的库版本，但是验证应用程序在升级后是否会像预期的那样工作仍然很重要。</p><p id="6c0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Dependabot发出的pull请求将运行CI测试，并将被部署到一个新的Heroku环境中。这两个版本都可以从GitHub界面访问。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/788ec226543acde897d92e9af1fb32f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K9d_VKZ3iqAomteQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nw">从GitHub中的拉请求视图进行检查</em></p></figure><p id="0be3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">合并拉请求后，管道将运行CI测试，并将其部署到预生产环境中。然后才能推广生产。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/671c99cb6f28b980e8d11a769d0bcde9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hJ7YyRRsGiHMY0XS"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nw"> Heroku管道视图</em></p></figure><p id="d6a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置Dependabot和Heroku Flow将使解决库和依赖关系中的安全漏洞所需的大部分手工工作自动化。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f70e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">尽早发现安全漏洞</h1><p id="afa3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">自然，捕捉安全漏洞的理想时间是在部署到生产环境之前。许多不同的工具可以运行静态代码分析，并在将代码合并到主分支之前识别出有问题的代码。</p><p id="57b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们考虑一个简单的Node.js应用程序。开发人员通常使用<a class="ae ky" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESlint </a>来实施一致的编码风格并捕捉常见问题。启用<a class="ae ky" href="https://github.com/nodesecurity/eslint-plugin-security#readme" rel="noopener ugc nofollow" target="_blank"> ESlint-plugin-security </a>还将识别常见的安全漏洞:</p><h2 id="bd3e" class="ny md it bd me nz oa dn mi ob oc dp mm li od oe mo lm of og mq lq oh oi ms oj bi translated">。eslintrc</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="e19d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保ESlint在CI期间执行，<code class="fe na nb nc nd b">app.json</code>文件是可编辑的，并指向存储库中的一个文件。</p><h2 id="2369" class="ny md it bd me nz oa dn mi ob oc dp mm li od oe mo lm of og mq lq oh oi ms oj bi translated">app.json</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="342b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个自定义脚本文件中，您可以运行任何需要的命令。</p><h2 id="3540" class="ny md it bd me nz oa dn mi ob oc dp mm li od oe mo lm of og mq lq oh oi ms oj bi translated">ci.sh</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="9155" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果lint失败，构建将被标记为不成功，部署将不会继续。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/13ce1546df7913dc927431ab128869d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tKTVbxP6OwN9zyM5"/></div></div></figure><p id="a797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然ESlint-plugin-security是特定于JavaScript的，但大多数成熟的语言都有静态代码分析工具，比如针对Ruby的流行的<a class="ae ky" href="https://brakemanscanner.org/" rel="noopener ugc nofollow" target="_blank"> Brakeman </a>或针对Java的<a class="ae ky" href="https://find-sec-bugs.github.io/" rel="noopener ugc nofollow" target="_blank"> Find-Sec-Bugs </a>。</p><p id="2400" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然本文中的CI片段是在bash脚本中显示的，但是Heroku CI支持多种语言。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c175" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">防止未经授权的组件或库</h1><p id="a8bf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一些组织非常重视控制应用程序部署的复杂性，并对所有应用程序实施集中控制。例如，这些控件可能会阻止使用Redis附加组件或特定的JavaScript库。</p><p id="f286" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用程序的所有Heroku组件都在<code class="fe na nb nc nd b"><a class="ae ky" href="https://devcenter.heroku.com/articles/app-json-schema" rel="noopener ugc nofollow" target="_blank">app.json</a></code>文件中定义为代码。这为部署前检查提供了可能性。基础架构工程师可以创建一个集中的脚本来防止部署特定组件，并确保所有应用程序都通过相同的检查。</p><p id="8304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们考虑下面显示的集中式脚本<code class="fe na nb nc nd b">infrastructure-checks.sh</code>。它目前可以在一个公共的git存储库mygithubaccount/infra structure-scripts中获得。对于本教程，假设您的目标是阻止所有Heroku附加组件部署。</p><h2 id="d381" class="ny md it bd me nz oa dn mi ob oc dp mm li od oe mo lm of og mq lq oh oi ms oj bi translated">基础设施-scripts.sh</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="e65c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在基础结构脚本中，您可以添加任意数量的检查来排除特定的附加组件，检查环境变量，防止创建某些实例类型，甚至检查不应该使用的特定库。简而言之，您可以做任何必要的事情来维护所有环境的一致性。</p><p id="83ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个Heroku应用程序，CI可以配置为从中央存储库<em class="mz"> : </em>下载并执行<code class="fe na nb nc nd b">infrastructure-scripts.sh</code></p><h2 id="6391" class="ny md it bd me nz oa dn mi ob oc dp mm li od oe mo lm of og mq lq oh oi ms oj bi translated">app.json</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="640a" class="ny md it bd me nz oa dn mi ob oc dp mm li od oe mo lm of og mq lq oh oi ms oj bi translated">ci.sh</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="a2ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">中央基础设施存储库也可以是私有的，但是在下载脚本文件时需要进行身份验证。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7f17" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="515e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">希望您现在已经看到了一些使用Heroku Flow实现安全控制作为CI/CD管道的一部分的实际例子。您应该也能够在其他CI/CD解决方案中实现类似的控件，但是这些可能没有与GitHub和Heroku紧密集成。</p><p id="063a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">越来越多的组织意识到，安全不应该是事后的想法，而是持续改进过程的一部分。以最小干扰的方式将安全控制和修复实现为代码将帮助您可靠和安全地交付代码，而不会降低交付速度。它还可以确保客户或最终用户在很大程度上免受潜在安全漏洞的影响。</p><p id="e1fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为DevSecOps的一部分，自动化还意味着捕获安全漏洞不是一个被动的过程，扫描器和审计过程可以在实时系统中找到安全漏洞，而是一种主动的方法。</p></div></div>    
</body>
</html>