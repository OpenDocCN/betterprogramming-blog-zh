<html>
<head>
<title>How To Write Human-Readable Tests in Kotlin With Kotest and MockK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Kotest和MockK在Kotlin中编写人类可读的测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-human-readable-tests-in-kotlin-with-kotest-and-mockk-1b614da32148?source=collection_archive---------4-----------------------#2021-06-24">https://betterprogramming.pub/how-to-write-human-readable-tests-in-kotlin-with-kotest-and-mockk-1b614da32148?source=collection_archive---------4-----------------------#2021-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0ed9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Kotlin编写测试的完整工具箱，易于理解和维护</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c07db5db06f9ad9ade41338c4e7878c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6oJvre4424laIpcNHUvAtw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/@thisisengineering?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> ThisIsEngineering </a>从<a class="ae kv" href="https://www.pexels.com/photo/female-software-engineer-coding-on-computer-3861972/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄。</p></figure><p id="1ce9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">十有八九，每个使用过Java的人都知道Mockito和Hamcrest。这些框架通过隔离依赖组件和编写断言，在测试代码时帮助很大，但是在可读性方面它们没有给我们带来很多好处。</p><p id="e5d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我想讨论为什么在<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/why-i-switched-from-java-to-kotlin-and-never-looked-back-8c061209ea8">我离开Java去Kotlin </a>后，我决定改用Kotest和MockK。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="80de" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">我们来自哪里</h1><p id="892e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们看看使用Mockito和Hamcrest的常规简单单元测试是什么样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="912f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个片段中使用了什么:</p><ul class=""><li id="a703" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated">为两个相互依赖的服务创建模拟的初始化方法。</li><li id="bc54" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">为方法分配模拟响应。</li><li id="6457" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">创建一个捕获器来验证传递的参数。</li><li id="a101" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">关于方法调用次数的断言。</li></ul><p id="9da4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的代码通常不像我们习惯的那样“从左到右”(反之亦然)可读。即使我们经常接触这种语法，认知负荷仍然更高。我们应该永远记住，单元测试最重要的一个方面是<em class="nm">易于阅读</em>和<em class="nm">理解</em>。这意味着，为了知道发生了什么而减少的每一点努力都是值得整合的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/7b2961e2c00fb0ad1896098993383f44.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*1jf8pNqDUsXYxZY2y84jQg.png"/></div></figure><p id="eb42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们把我们例子中的<code class="fe no np nq nr b">verify</code>断言写成一个句子，我们会发现与实际代码相比有一些混淆。是的，我们可以换一种更合适的说法，但是我将必须满足的条件(<code class="fe no np nq nr b">verify</code>和<code class="fe no np nq nr b">times</code> =我们的方法应该被调用一次)和目标(<code class="fe no np nq nr b">services.add</code>)分开。</p><p id="ef5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看哈姆克雷斯特的<code class="fe no np nq nr b">assertThat</code>断言，我们已经可以看到一些改进，但它仍然不是完美的。</p><p id="0cb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们深入研究一下MockK和Kotest，了解我们如何进一步改进这一点。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5329" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">嘲笑嘲笑</h1><p id="cf17" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><a class="ae kv" href="https://mockk.io" rel="noopener ugc nofollow" target="_blank">mock</a>提供了我们所知道的使用Mockito的所有特性，但是具有更好的可读性和Kotlin兼容性。</p><h2 id="bc45" class="ns ma iq bd mb nt nu dn mf nv nw dp mj lf nx ny ml lj nz oa mn ln ob oc mp od bi translated">嘲弄的</h2><p id="4f7f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当创建模拟对象来隔离测试中的系统时，从语法角度来看，与Mockito没有太大的区别。有趣且与众不同的部分是我们如何用<code class="fe no np nq nr b">every</code>定义我们的存根响应。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1b64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认的模拟要求您为所有接收的调用指定响应。如果有一个调用，但没有存根响应，测试将会失败(例如，在这个例子中，调用除了<code class="fe no np nq nr b">add</code>之外的任何其他方法都会导致测试失败)。如果您想明确忽略这些，您可以创建一个宽松的模拟。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/e99e99e3dcb0b2c10406e5a8c9d603b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*KIq3pztb0k8Mqnx89uflAg.png"/></div></figure><p id="e122" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从方法存根的可读性来看，我们看到了它的伟大之处。</p><h2 id="e70e" class="ns ma iq bd mb nt nu dn mf nv nw dp mj lf nx ny ml lj nz oa mn ln ob oc mp od bi translated">发现</h2><p id="6dd0" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">与间谍合作同样容易。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6bd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe no np nq nr b">verify</code>现在看起来也干净了很多。类和方法被绑定在一起，预期调用的次数就在断言关键字本身的旁边。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/d71504540d998268c69be47599e76d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*sce7b8eJ8EpOTRoldJ3SdQ.png"/></div></div></figure><p id="b022" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对我来说，MockK的语法少了很多“噪音”，更容易掌握。</p><h2 id="608b" class="ns ma iq bd mb nt nu dn mf nv nw dp mj lf nx ny ml lj nz oa mn ln ob oc mp od bi translated">占领</h2><p id="3d68" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">通过<code class="fe no np nq nr b">CapuringSlot</code>或<code class="fe no np nq nr b">MutableList</code>通过捕获来验证传递的参数。第一个选项是为了更容易匹配单个呼叫。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="2edf" class="ns ma iq bd mb nt nu dn mf nv nw dp mj lf nx ny ml lj nz oa mn ln ob oc mp od bi translated">弹簧架</h2><p id="e84d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">作为一名Kotlin开发人员，您很可能也在使用Spring Boot，并且想知道MockK与它的兼容性。springmock提供了与Spring Boot集成测试的兼容性。</p><p id="da1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它提供了与基于Mockito的Spring Boot模拟beans相同的功能。刚开始用<code class="fe no np nq nr b">@MockkBean</code>和<code class="fe no np nq nr b">@SpykBean</code>。</p><p id="9520" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nm">注意:这是一个不完整的MockK特性集列表。关于</em><a class="ae kv" href="https://mockk.io/" rel="noopener ugc nofollow" target="_blank"><em class="nm">mock . io</em></a><em class="nm">还有更多值得探索。还有，</em> <a class="og oh ep" href="https://medium.com/u/1f9f77b4b3d1?source=post_page-----1b614da32148--------------------------------" rel="noopener" target="_blank"> <em class="nm">奥列彭科</em> </a> <em class="nm">写了</em> <a class="ae kv" href="https://blog.kotlin-academy.com/mocking-is-not-rocket-science-basics-ae55d0aadf2b" rel="noopener ugc nofollow" target="_blank"> <em class="nm">一个很棒的关于莫克的特性的综合系列</em> </a> <em class="nm">。</em></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="2412" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">断言的Kotest</h1><p id="ea03" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Kotest使我们能够以简单明了的方式编写断言。</p><h2 id="69b3" class="ns ma iq bd mb nt nu dn mf nv nw dp mj lf nx ny ml lj nz oa mn ln ob oc mp od bi translated">火柴人</h2><p id="b028" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Kotest带来了一个很大的核心匹配器列表，其语法类似于JavaScript的Jest。匹配器既可以用作扩展，也可以用作inflix函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d9ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">扩展函数具有您喜欢的IDE的自动完成特性的优势。我仍然喜欢使用inflix风格，因为它严格区分了实际值和期望值。</p><h2 id="b991" class="ns ma iq bd mb nt nu dn mf nv nw dp mj lf nx ny ml lj nz oa mn ln ob oc mp od bi translated">例外</h2><p id="20e5" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">可以使用<code class="fe no np nq nr b">shouldThrow</code>来检查异常及其验证。您可以只验证是否抛出了异常，也可以对捕获的异常进行额外的检查。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="943c" class="ns ma iq bd mb nt nu dn mf nv nw dp mj lf nx ny ml lj nz oa mn ln ob oc mp od bi translated">线索</h2><p id="43ca" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">为了在处理失败的测试时不沮丧，立即知道是什么导致了错误也是非常重要的。Kotest通过引入<code class="fe no np nq nr b">withClue</code>对此有所帮助，它使您能够向断言添加更多的细节，或者避免由于空值而导致的混淆的断言消息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8410" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kotest不仅是一个断言库，也是一个属性测试库。此外，它还提供了许多本文中没有描述的特性。我强烈推荐在<a class="ae kv" href="https://kotest.io/docs/quickstart" rel="noopener ugc nofollow" target="_blank"> kotest.io </a>上浏览它的文档。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d82f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">把所有的放在一起</h1><p id="c81b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们更新我们最初的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f4b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这看起来已经好多了，尽管这只是一个非常简单的例子。对于具有复杂得多的存根设置和断言的测试，使用MockK和Kotest对理解您很久以前编写的测试或其他人编写的测试的速度有更大的影响。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7968" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">关键要点</h1><p id="c888" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">测试被设计成定期中断，所以你知道你可能已经引起了意想不到的副作用——这就是为什么你会经常阅读它们。使用MockK和Kotest，您可以获得用Kotlin编写可读性很好的测试所需的完整工具。</p><p id="2b49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一如既往，不要只听我的意见。今天就亲自尝试一下吧。</p><p id="ac42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>