# 在 Swift 中控制数据的 3 个属性包装器

> 原文：<https://betterprogramming.pub/3-property-wrappers-to-control-your-data-in-swift-84bcbb22c5be>

## 定义如何使用属性包装操作数据

![](img/bdb34593af8c04f4bec825fa9d0ae659.png)

像糖果一样包装它们——图片来自 [pixabay](https://pixabay.com/photos/pug-dog-pet-animal-puppy-cute-801826/) 的 [StockSnap](https://pixabay.com/users/stocksnap-894430/)

在本文中，我们将探索三种属性包装器来为我们的属性实施策略。通过使用它们，我们可以确保这些属性只在应该的时候使用。

第一个属性包装器将确保封装的值可以过期，并且在给定时间过去后不可访问。在第二个例子中，我们将创建一个确保一个值只能更新一次的方法。

该值的每次后续更新都将失败。最终的属性包装器确保包装的值只在预定义的步骤内更改。

对于这些包装器中的每一个，我们将看一些用例的例子，以及如何在我们的项目中实现和使用它们。

注意:如果你不知道什么是属性包装器以及如何使用它们，你可以阅读我上一篇关于它们的文章。

我们开始吧！

# 可补偿值

属性可以在定义的秒数内保存一个值。时间过后，该属性的值将为零。

## **用例**

*   用户可以使用演示功能 20 分钟。通过用这个包装器包装一个启用该功能的布尔标志，可以确保用户在时间结束后不能继续使用该功能。
*   在游戏中，玩家解锁了一个奖励等级，但是他们只有一个小时的时间来玩。该属性包装将在给定时间后禁用该级别。
*   登录令牌的有效期为一小时。通过包装，过期后就无法使用了。

## **实施**

实现一个属性包装，当值过期时返回 nil

`//1` —我们创建了一个名为`Expirable`的新结构，并为其添加了注释`@propertyWrapper`。这个结构有一个泛型参数`Value`，它将是包装属性的类型。

`//2` —为了检查封装的值是否过期，我们需要该值、它应该有效的秒数以及它的创建日期。

在这个例子中，这些值分别被称为`value`、`countdown`和`start`，它们被传递到初始化器中。

注意:由于某种原因，私有属性`countdown`和`start`在`wrappedValue`的 getter 中会有错误的值，`countdown`将总是 0，`start`将是 2001 年 1 月 1 日。

为了防止这种情况发生，我们使用另一个属性包装器将它们存储在`UserDefaults`中。你可以在这篇文章中阅读这个是如何工作的[。](https://medium.com/better-programming/creating-a-history-with-property-wrappers-in-swift-5-1-4c0202060a7f)

`//3` —每个属性包装器需要一个名为`wrappedValue`的计算属性，带有一个 getter 和一个 setter。在这种情况下，我们将只返回没有过期的值，否则将返回`nil`。

`//4` —为了检查值是否过期，我们使用另一个计算属性。这里，我们首先解开`countdown`和`start`，最后检查经过了多长时间。

由于`timeIntervalSinceNow`返回一个过去日期的负数，我们需要将它乘以-1。

让我们创建一个如何在您的应用程序中使用该属性包装器的示例:

在应用程序中使用属性 wrapper @Expirable。

`//1` —我们可以用`@Expirable`注释任何属性，并传入该值有效的秒数。

`//2` —当我们用一个计时器每秒打印包装属性的值时，我们可以看到它将在三秒内具有初始值。一旦过了这段时间，该值将为零。

# 恰好更新一次值

属性的值只能更改一次。完成后，将忽略以下所有更改。

## **用例**

*   首次启动应用程序时，您会显示一个教程。然后存储一个布尔标志，以记住用户已经看过了教程。
*   你的用户可以通过应用内购买移除广告。一旦用户这样做了，你就再也不会显示广告了。

## **实施**

实现只更新一次值的属性包装。

`//1` —就像在第一个例子中一样，我们创建一个用`@propertyWrapper`注释的新结构。但是因为我们需要比较新旧值，它将只包装符合协议`Equatable`的类型。

`//2` —当初始化这个属性包装器时，我们将给定值存储为初始值和当前值。这让我们可以很容易地检查计算属性`wrappedValue`中的值是否已经改变。

`//3` —最后，我们实现`wrappedValue`。每次要设置新值时，我们首先检查`currentValue`是否与`initialValue`相同。如果不是这样，这个值已经被改变了一次，因此，我们不会再更新它。

下面，您可以看到如何使用此属性包装的示例:

在应用程序中使用属性 wrapper @UpdatableOnce。

`//1` —这一次，我们可以只将包装器添加到等价的属性中。

`//2` —我们可以像设置任何其他属性一样设置值，它会改变它的值。

但是一旦我们做了这件事，下次就不能改变了。相反，该值将保持不变。

# 仅使用定义的步骤更新值

属性值只能按预定义的步骤增加。

## **用例**

*   玩家可以在游戏中收集不同价值的硬币。一枚硬币增加玩家的信用 1，另一枚增加 3，最后一枚增加 5。这个属性包装器确保没有其他数字可以添加到信用。
*   您的用户需要执行特定次数的给定任务。这个应用程序用一个计数器记录这个数字。通过确保该计数器只能增加 1，您可以确保用户确实做了他们需要做的事情。

## **实施**

实现只在预定义步骤中更新值的属性包装。

`//1` —当创建结构`Steppable`时，我们需要将泛型参数`Value`约束到实现`AdditiveArithmetric`的所有类型。这意味着它只能包装支持加法和减法的类型。

`//2` — `Steppable`使用两个私有属性，它包装的值和可接受的更改。两者都在初始化器中设置。

`//3` —每当包装值更新时，我们检查旧值和新值之间的差异是否允许。如果是这种情况，我们更新该值。

注意:我们有多种选择来处理不允许新值的情况。

例如，我们可以简单地返回而不做任何更改，或者向控制台打印一条消息，但是在这个例子中，我们使用`preconditionFailure`来显式地捕捉错误的更改并停止应用程序。

使用这个属性包装器非常简单:

在应用程序中使用属性 wrapper @ Steppable。

`//1` —当使用这个属性包装器时，我们需要用一个包含可接受更改的数组来初始化它。在这种情况下，我们希望允许我们的值改变 1、3 和 5。

`//2` —当增加这些值中的一个时，它会按预期更新。

`//3` —但是当我们用任何其他值改变它时，它将保持不变。

`//4` —此外，在分配新值时，需要遵循以下准则。

# 结论

正如我们在本文中看到的，属性包装器对于如何使用属性来说是非常强大的。

不用创建实现如何处理更改的逻辑的类，所有这些代码都可以在一个地方封装为属性包装器，这增加了可重用性并减少了代码重复。

我希望您能和我一样发现属性包装器的神奇之处！请随意在您的项目中使用这些包装器并进行试验。