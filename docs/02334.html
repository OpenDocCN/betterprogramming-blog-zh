<html>
<head>
<title>Centralize Your Docker Logging With Syslog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Syslog集中您的Docker日志记录</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/docker-centralized-logging-with-syslog-97b9c147bd30?source=collection_archive---------0-----------------------#2019-11-24">https://betterprogramming.pub/docker-centralized-logging-with-syslog-97b9c147bd30?source=collection_archive---------0-----------------------#2019-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="10a4" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">集中记录</h2><div class=""/><div class=""><h2 id="254d" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解我们的系统及其成功或失败的最佳方式是通过大量的日志记录</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/73e0138dc0967c73892e5bf16618aa9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V64LGVt9nOqvbmZk"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="cb24" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated"><strong class="ak">背景</strong></h1><p id="98b5" class="pw-post-body-paragraph mh mi it mj b mk ml kd mm mn mo kg mp mq mr ms mt mu mv mw mx my mz na nb nc im bi translated">在我最近几年参与的一个项目中，我的任务是将一个集中式日志记录系统与我们使用的应用程序堆栈集成在一起(遵循微服务架构)。我想到的第一个想法是构建一个ELK (Elasticsearch，Logstash，Kibana)堆栈来完成这项任务。然而，事实证明，由于项目资源的限制，这不是一个选项。</p><p id="2c9a" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">因此，我调查了所有可以帮助我实现这个特性而又不与我们的局限性相冲突的选项和想法。我最终提出了以下想法:</p><ul class=""><li id="c4ac" class="ni nj it mj b mk nd mn ne mq nk mu nl my nm nc nn no np nq bi translated">直接收集Docker日志。</li><li id="132f" class="ni nj it mj b mk nr mn ns mq nt mu nu my nv nc nn no np nq bi translated">使用系统日志收集日志。</li></ul><p id="60e7" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">正如我已经说过的，第一个想法是建立一个ELK栈来收集日志。然而，由于该项目的预算和资源限制，这不是一个选项。</p><p id="6e92" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">另一个想法是将日志转发到托管服务，如<a class="ae lh" href="https://logz.io/" rel="noopener ugc nofollow" target="_blank"> logz.io </a>。这一选择也是不可能的，因为生产服务器没有互联网接入，再加上同样的预算限制。</p><p id="e4d2" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">第三个想法是设置一个<code class="fe nw nx ny nz b">Logrotate</code>脚本，它执行以下操作来生成日志文件:</p><ul class=""><li id="130f" class="ni nj it mj b mk nd mn ne mq nk mu nl my nm nc nn no np nq bi translated">从<code class="fe nw nx ny nz b">/var/lib/docker/containers/*</code>收集Docker日志。</li><li id="1dbd" class="ni nj it mj b mk nr mn ns mq nt mu nu my nv nc nn no np nq bi translated">用容器名而不是id来重命名文件。</li><li id="e003" class="ni nj it mj b mk nr mn ns mq nt mu nu my nv nc nn no np nq bi translated">压缩日志文件。</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="1332" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">这个想法的第二步是建立一个Cron作业，将日志文件复制到一个中央服务器，在那里可以加载和检查日志。</p><p id="faf3" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">这个想法有很多缺点，更像是重新发明轮子。最大的缺点之一是，如果进行新的部署和替换容器，日志将会丢失。</p><p id="e74e" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">这就是为什么我开始寻找一种替代解决方案，帮助我们将日志从服务器收集到一个集中的服务器，而不会丢失日志。幸运的是，Docker支持多个日志驱动程序(完整列表见<a class="ae lh" href="https://docs.docker.com/config/containers/logging/configure/" rel="noopener ugc nofollow" target="_blank"/>)。其中一个日志驱动程序是Syslog，它默认安装在Linux系统上(不需要安装额外的软件)。出于这个原因，我决定用Syslog实现一个集中式日志系统。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="db7d" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated"><strong class="ak">实施</strong></h1><p id="38df" class="pw-post-body-paragraph mh mi it mj b mk ml kd mm mn mo kg mp mq mr ms mt mu mv mw mx my mz na nb nc im bi translated">仅为了简单起见，我们假设托管微服务的基础架构由以下节点组成:</p><ul class=""><li id="d0b8" class="ni nj it mj b mk nd mn ne mq nk mu nl my nm nc nn no np nq bi translated">托管服务的双节点Docker集群。</li><li id="6b92" class="ni nj it mj b mk nr mn ns mq nt mu nu my nv nc nn no np nq bi translated">一个节点用于存储日志。</li></ul><h2 id="f004" class="oc lq it bd lr od oe dn lv of og dp lz mq oh oi mb mu oj ok md my ol om mf iz bi translated">日志服务器配置</h2><p id="6ab3" class="pw-post-body-paragraph mh mi it mj b mk ml kd mm mn mo kg mp mq mr ms mt mu mv mw mx my mz na nb nc im bi translated">为了配置日志服务器并准备好从Docker主机收集日志，我必须执行以下步骤:</p><ul class=""><li id="c154" class="ni nj it mj b mk nd mn ne mq nk mu nl my nm nc nn no np nq bi translated">确保安装了Syslog，或者使用以下命令安装它:</li></ul><pre class="ks kt ku kv gt on nz oo op aw oq bi"><span id="9ba1" class="oc lq it nz b gy or os l ot ou">$&gt; yum update -y<br/>$&gt; sudo yum install rsyslog rsyslog-doc</span></pre><ul class=""><li id="81ab" class="ni nj it mj b mk nd mn ne mq nk mu nl my nm nc nn no np nq bi translated">列出正确的TCP端口。系统日志配置文件<code class="fe nw nx ny nz b">/etc/rsyslog.conf</code>中必须有下面一行:</li></ul><pre class="ks kt ku kv gt on nz oo op aw oq bi"><span id="5d95" class="oc lq it nz b gy or os l ot ou">$ModLoad imtcp $InputTCPServerRun 514</span></pre><ul class=""><li id="e6ae" class="ni nj it mj b mk nd mn ne mq nk mu nl my nm nc nn no np nq bi translated">更新系统日志和<code class="fe nw nx ny nz b">journald</code>的日志速率限制配置。下面的配置应该添加到<code class="fe nw nx ny nz b">/etc/rsyslog.conf</code>文件中，以避免日志消息过多时日志丢失。更多信息见<a class="ae lh" href="https://www.rsyslog.com/doc/v8-stable/configuration/modules/imjournal.html" rel="noopener ugc nofollow" target="_blank">系统日志文件</a>。</li></ul><pre class="ks kt ku kv gt on nz oo op aw oq bi"><span id="a529" class="oc lq it nz b gy or os l ot ou">$imjournalRatelimitInterval 0<br/>$imjournalRatelimitBurst 0</span></pre><ul class=""><li id="57a1" class="ni nj it mj b mk nd mn ne mq nk mu nl my nm nc nn no np nq bi translated">另外，需要在<code class="fe nw nx ny nz b">journald</code>配置文件<code class="fe nw nx ny nz b">/etc/systemd/journald.conf</code>中将速率限制配置设置为<code class="fe nw nx ny nz b">0</code>。</li></ul><pre class="ks kt ku kv gt on nz oo op aw oq bi"><span id="1f48" class="oc lq it nz b gy or os l ot ou">RateLimitInterval=0</span></pre><p id="d7a9" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">默认情况下，Syslog会将所有日志存储在<code class="fe nw nx ny nz b">/var/log/messages</code>中。但是，我们希望根据容器名称来分离日志，以便于调查。要配置Syslog服务器将不同容器中的日志分离到不同的文件中，我们需要执行以下步骤:</p><ul class=""><li id="6d18" class="ni nj it mj b mk nd mn ne mq nk mu nl my nm nc nn no np nq bi translated">决定并创建保存所有日志的文件夹。</li></ul><pre class="ks kt ku kv gt on nz oo op aw oq bi"><span id="db50" class="oc lq it nz b gy or os l ot ou">$&gt; <!-- -->mkdir /var/log/dockerlfs</span></pre><ul class=""><li id="be05" class="ni nj it mj b mk nd mn ne mq nk mu nl my nm nc nn no np nq bi translated">收集Docker守护进程的日志，并将其保存到磁盘。下面的Syslog配置规则(存储在<code class="fe nw nx ny nz b">/etc/rsyslog.d/docker_daemon.conf</code>中)将Syslog保存所有属于从<code class="fe nw nx ny nz b">docker</code>启动到<code class="fe nw nx ny nz b">/var/log/dockerlfs/daemon.log</code>的程序的日志。</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><ul class=""><li id="535d" class="ni nj it mj b mk nd mn ne mq nk mu nl my nm nc nn no np nq bi translated">收集Docker容器日志，并将其保存到单独的日志文件中。下面的系统日志配置规则将根据容器名称，为每个正在运行的容器将日志保存到单独的文件中。规则应该存储在<code class="fe nw nx ny nz b">/etc/rsyslog.d/docker_container.con</code>中。该规则依赖Docker主机用<code class="fe nw nx ny nz b">container_name</code>标记所有日志。</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="db55" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">下一步是设置一个<code class="fe nw nx ny nz b">Logrotate</code> <strong class="mj jd"> </strong>规则来循环日志，避免服务器上的大日志文件。旧日志可以由系统管理员存档。下面的规则将每天轮换服务器上的日志，或者如果文件大小超过20MB。它还将只保留每个容器的最后30个日志文件。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="f485" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">作为服务器配置的最后一步，我们需要重启服务以确保我们的配置被加载。</p><pre class="ks kt ku kv gt on nz oo op aw oq bi"><span id="caa0" class="oc lq it nz b gy or os l ot ou">$&gt; <!-- -->systemctl restart rsyslog<br/>$&gt; <!-- -->systemctl restart systemd-journald</span></pre></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="f530" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated">配置Docker主机</h1><p id="4782" class="pw-post-body-paragraph mh mi it mj b mk ml kd mm mn mo kg mp mq mr ms mt mu mv mw mx my mz na nb nc im bi translated">现在我们已经完成了Syslog服务器的配置，我们可以继续并开始配置Docker主机，以将日志从服务器转发到Syslog服务器。</p><p id="4e82" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">需要做的第一件事是重新配置Docker守护进程，使用<code class="fe nw nx ny nz b">syslog</code>日志驱动程序代替<code class="fe nw nx ny nz b">journald</code>，并用容器名标记日志。为了实现这个目标，我们需要修改位于<code class="fe nw nx ny nz b">/etc/docker</code>下的Docker守护进程配置文件。<code class="fe nw nx ny nz b">daemon.json</code>应包括以下内容:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="3950" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">变量<code class="fe nw nx ny nz b">SYSLOG_SERVER_IP</code>应该替换为系统日志服务器IP。变量<code class="fe nw nx ny nz b">ENV_NAME</code>应该替换为环境名称(测试、试运行或生产)。使用上面的配置，Docker会将日志直接转发到Syslog服务器。如果系统日志服务器关闭或者没有有效的连接，我们可能会丢失一些上面配置的日志。</p><p id="2006" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">为了改进我们的日志记录系统并避免丢失日志，我们将进行以下更改:</p><ul class=""><li id="89c5" class="ni nj it mj b mk nd mn ne mq nk mu nl my nm nc nn no np nq bi translated">将日志从Docker转发到本地服务器。</li><li id="df72" class="ni nj it mj b mk nr mn ns mq nt mu nu my nv nc nn no np nq bi translated">配置本地系统日志，将日志转发到集中式日志服务器。</li></ul><p id="61db" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">要将日志从Docker转发到本地Syslog服务器，我们只需从<code class="fe nw nx ny nz b">/etc/docker/daemon.json</code>中删除下面一行，或者用<code class="fe nw nx ny nz b">127.0.0.1</code>替换<code class="fe nw nx ny nz b">SYSLOG_SERVER_IP</code>:</p><pre class="ks kt ku kv gt on nz oo op aw oq bi"><span id="9d78" class="oc lq it nz b gy or os l ot ou">"syslog-address": "tcp://${SYSLOG_SERVER_IP}:514",</span></pre><p id="6fa6" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">一旦我们完成了Docker配置，我们需要重启Docker守护进程。</p><pre class="ks kt ku kv gt on nz oo op aw oq bi"><span id="3ade" class="oc lq it nz b gy or os l ot ou">$&gt; <!-- -->systemctl restart docker</span></pre><p id="8a09" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">下一步是更新Docker节点上的Syslog配置，以便能够在本地存储Docker日志，并将它们转发到中央服务器。</p><p id="027d" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated"><strong class="mj jd">系统日志和日志配置</strong></p><p id="1fc1" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">我们需要文件<code class="fe nw nx ny nz b">/etc/systemd/journald.conf</code>中<code class="fe nw nx ny nz b">journald</code>的以下配置项:<code class="fe nw nx ny nz b">RateLimitInterval=0</code>。</p><p id="9a6e" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">我们需要文件<code class="fe nw nx ny nz b">/etc/rsyslog.conf</code>中Syslog的以下配置项:</p><pre class="ks kt ku kv gt on nz oo op aw oq bi"><span id="07b4" class="oc lq it nz b gy or os l ot ou">$ActionQueueFileName fwdRule1<br/>$ActionQueueSaveOnShutdown on<br/>$ActionQueueType LinkedList<br/>$ActionResumeRetryCount -1</span><span id="c466" class="oc lq it nz b gy ov os l ot ou">$imjournalRatelimitInterval 0<br/>$imjournalRatelimitBurst 0</span></pre><ul class=""><li id="6619" class="ni nj it mj b mk nd mn ne mq nk mu nl my nm nc nn no np nq bi translated"><code class="fe nw nx ny nz b">ActionQueueFileName</code> : <em class="ow"> </em>为假脱机文件添加<em class="ow"> </em>唯一名称前缀。</li><li id="611b" class="ni nj it mj b mk nr mn ns mq nt mu nu my nv nc nn no np nq bi translated"><code class="fe nw nx ny nz b">ActionQueueSaveOnShutdown</code> : <em class="ow"> </em>关机时将消息保存到磁盘。</li><li id="073d" class="ni nj it mj b mk nr mn ns mq nt mu nu my nv nc nn no np nq bi translated"><code class="fe nw nx ny nz b">ActionQueueType</code>:异步运行。</li><li id="09e9" class="ni nj it mj b mk nr mn ns mq nt mu nu my nv nc nn no np nq bi translated"><code class="fe nw nx ny nz b">ActionResumeRetryCount</code>:<em class="ow">I</em>n如果主机关闭，则限制重试次数。</li></ul><p id="8fc5" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">使用上面的配置，Syslog将继续尝试向中央服务器发送日志，直到日志被目标服务器捕获。然而，到目前为止，我们还没有在Docker主机上配置本地Syslog服务器来将日志转发到任何其他服务器。因此，从Docker收集的所有日志都将保存在默认文件<code class="fe nw nx ny nz b">/var/log/messages</code>中。</p><p id="8b67" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">将日志从Syslog转发到另一台服务器非常简单。您只需要在<code class="fe nw nx ny nz b">/etc/rsyslog.conf</code>文件的末尾添加以下规则，并用有效的日志服务器IP替换<code class="fe nw nx ny nz b">SYSLOG_SERVER_IP</code>。这个规则主要检查所有的日志，并根据标签和程序名过滤它们。如果消息标签包含名为<code class="fe nw nx ny nz b">container_name</code>或<code class="fe nw nx ny nz b">programname</code>的标签，则从<code class="fe nw nx ny nz b">docker</code>开始。然后将日志转发给<code class="fe nw nx ny nz b">SYSLOG_SERVER_IP</code>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="cd81" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">我们可以通过在Docker服务器上本地保存日志的副本来改进上面的规则。通过下面的更改，我们的系统日志规则会将日志发送到远程系统日志服务器，并且会在运行Docker的各个服务器上本地保存一份日志文件的副本。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="4b69" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">因为我们现在在Docker服务器上有了日志文件的副本，所以添加<code class="fe nw nx ny nz b">Logrotate</code>规则来轮换这些文件是有意义的。我们可以使用用于服务器节点的相同规则。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="6ca1" class="pw-post-body-paragraph mh mi it mj b mk nd kd mm mn ne kg mp mq nf ms mt mu ng mw mx my nh na nb nc im bi translated">最后，Syslog和<code class="fe nw nx ny nz b">journald</code>都需要重启才能获得新的配置。</p><pre class="ks kt ku kv gt on nz oo op aw oq bi"><span id="0e81" class="oc lq it nz b gy or os l ot ou">$&gt; systemctl restart rsyslog<br/>$&gt; systemctl restart systemd-journald</span></pre></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="380d" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated">结论</h1><p id="edfe" class="pw-post-body-paragraph mh mi it mj b mk ml kd mm mn mo kg mp mq mr ms mt mu mv mw mx my mz na nb nc im bi translated">集中式日志记录系统和堆栈可以通过许多不同的方法和工具来实现。Syslog就是其中一种方法——当运行环境存在一些限制，并且缺乏管理和运行ELK等更复杂堆栈的经验时，它尤其有用。</p><div class="ox oy gp gr oz pa"><a href="https://levelup.gitconnected.com/centralize-your-docker-logging-with-fluentd-a2b7e0a379ce" rel="noopener  ugc nofollow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd jd gy z fp pf fr fs pg fu fw jc bi translated">使用FluentD集中您的Docker日志记录</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">使用FluentD开始将容器日志传送到集中的日志服务器</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pj l"><div class="pk l pl pm pn pj po lb pa"/></div></div></a></div></div></div>    
</body>
</html>