<html>
<head>
<title>Processing Images Fast With Native Code in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Android中的原生代码快速处理图像</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/processing-images-fast-with-native-code-in-android-db8b21001fa9?source=collection_archive---------3-----------------------#2022-01-01">https://betterprogramming.pub/processing-images-fast-with-native-code-in-android-db8b21001fa9?source=collection_archive---------3-----------------------#2022-01-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4f9f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解本机代码如何更好地提升应用的性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/07f60d68f7f5cef9147d955bb4fc3557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VBi1Wg5mcBivyc8S"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼尔·罗梅罗在Unsplash<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><p id="22c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">性能是大多数软件产品的一个特性，但是很少有程序比其他程序对性能更敏感。我开发了一款安卓相机应用，我的团队非常重视性能。</p><blockquote class="lv lw lx"><p id="1ea8" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><em class="it">【谷歌发现】有10个结果的页面生成耗时0.4秒。有30个结果的页面用了0.9秒。半秒钟的延迟导致20%的流量下降。半秒的延迟扼杀了用户满意度。</em></p></blockquote><p id="307e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不需要向我的经理或你夸大<code class="fe mc md me mf b">performance</code>的重要性，但是我看到了这个片段，它强化了<strong class="lb iu">性能是一个特性</strong>构造——了解事实很好。</p><p id="6244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在编写应用程序来处理用相机捕获的大图像或设备上的现有图像，您需要格外小心。如今，手机上的相机很容易配备高分辨率传感器。现在在Android设备上很容易找到1300万像素、2400万像素、4800万像素甚至108万像素的相机。</p><p id="4f46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来看一张1300万的图片。它有1300万像素。如果你想在图像上做一个简单的计算，比如说增加图像的曝光度，也就是说增加每个像素的曝光度</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="f070" class="mk ml it mf b gy mm mn l mo mp">image(x, y) = std::clamp(alpha * image(x, y) + beta, 0, 255);</span></pre><p id="3bf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你需要做1300万次。</p><p id="c79e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今的智能手机也配备了多核、支持SIMD的CPU，因此有一些方法可以比串行的1300万次迭代更快，但与此同时，我们想要运行的算法类型通常比我刚才所说的复杂得多。</p><p id="8c26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我的经验，用本机代码处理这些复杂的图像处理操作更容易也更好，特别是为了保持它的高性能。</p><p id="7823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一篇非常基础的文章，演示了如何在Android中用原生代码进行图像处理。我还将通过一个例子来说明，对于相同的问题陈述，一个非常简单且未优化的C++代码的性能非常接近于相当优化的Java代码。如果你正在寻找“在Android中使用Java原生接口或JNI的快速图像处理”——我相信你来对了地方，这篇文章同样会帮助你。</p><h1 id="30a1" class="mq ml it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">问题陈述示例:YUV到RGB转换</h1><p id="7ee3" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">问题陈述是将具有一个平面<code class="fe mc md me mf b">Y</code>通道和两个半平面子采样<code class="fe mc md me mf b">UV</code>通道的名为<a class="ae ky" href="https://developer.android.com/reference/android/graphics/ImageFormat#YUV_420_888" rel="noopener ugc nofollow" target="_blank"> YUV_420_888 </a>的特定格式的8MP (3264x2448)图像转换为Android中的<a class="ae ky" href="https://developer.android.com/reference/android/graphics/Bitmap" rel="noopener ugc nofollow" target="_blank">位图</a>通常支持的<a class="ae ky" href="https://developer.android.com/reference/android/graphics/Bitmap.Config#ARGB_8888" rel="noopener ugc nofollow" target="_blank"> ARGB_8888 </a>格式。你可以在维基百科上阅读更多关于<a class="ae ky" href="https://en.wikipedia.org/wiki/YUV" rel="noopener ugc nofollow" target="_blank"> YUV格式的内容。此外，下面的文章对问题陈述有更好的描述。</a></p><p id="c196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我之所以选择这个作为问题陈述，是因为<code class="fe mc md me mf b">YUV_420_888</code>是Android相机API支持的最常见的输出格式之一，图像通常在Android中作为<code class="fe mc md me mf b">Bitmap</code>使用——因此这是一个需要解决的相当常见的问题陈述。</p><p id="2d5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我一直在试验不同框架或技术的性能，以了解Android中图像处理的性能，并以此作为问题陈述。下面是一些我测试过的使用其他技术的例子:</p><ul class=""><li id="56ad" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><a class="ae ky" href="https://blog.minhazav.dev/how-to-use-renderscript-to-convert-YUV_420_888-yuv-image-to-bitmap/" rel="noopener ugc nofollow" target="_blank">如何使用RenderScript将YUV_420_888 YUV图像转换为位图</a></li><li id="fa2f" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><a class="ae ky" href="https://blog.minhazav.dev/faster-image-processing-in-android-java-using-multi-threading/" rel="noopener ugc nofollow" target="_blank">使用多线程技术加快Android Java中的图像处理速度</a></li></ul><p id="7c09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我计划写一篇完整的系列文章，解释不同方法的性能。以下是迄今为止公布的方法的数量:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/d37c9d73b2b2369f53c4bc48273752d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*A2AQrqEUcsNBVT1v40ja4g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ob">表1:在Pixel 4a设备</em>上将 <code class="fe mc md me mf b"><em class="ob">8MP (3264x2448)</em></code> <em class="ob"> YUV图像转换为位图的性能延迟。</em></p></figure><h1 id="367d" class="mq ml it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">使用本机代码进行图像处理</h1><p id="9f0a" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">如果我们直接在本机空间中操作，基本的框架程序将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="488a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数获取某个像素的<code class="fe mc md me mf b">y</code>、<code class="fe mc md me mf b">u</code>和<code class="fe mc md me mf b">v</code>通道值，并返回相应的<code class="fe mc md me mf b">RGBA_8888</code>值。</p><p id="3d46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，Android程序是用Java或Kotlin语言编写的，但Android工具链附带了一个名为Android NDK的<a class="ae ky" href="https://developer.android.com/ndk" rel="noopener ugc nofollow" target="_blank">本地开发工具包，让你使用C和C++等语言实现应用程序的各个部分。Android文档描述NDK在两种情况下有用:</a></p><blockquote class="lv lw lx"><p id="129e" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">充分利用设备的额外性能来实现低延迟或运行计算密集型应用，如游戏或物理模拟。</p><p id="88a7" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">重用您自己或其他开发人员的C或C++库。</p></blockquote><p id="6a35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接下来的几节中，我将尝试简要解释如何使用本机代码集成将<a class="ae ky" href="https://developer.android.com/reference/android/graphics/ImageFormat#YUV_420_888" rel="noopener ugc nofollow" target="_blank"> YUV_420_888 </a>格式的Java <a class="ae ky" href="https://developer.android.com/reference/android/media/Image" rel="noopener ugc nofollow" target="_blank">图像</a>转换为Java对象<a class="ae ky" href="https://developer.android.com/reference/android/graphics/Bitmap" rel="noopener ugc nofollow" target="_blank">位图</a>。</p><p id="7357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以基本上我们必须填写这个Java函数框架:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="13e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我深入之前，我想给你介绍一下JNI。</p><h1 id="359b" class="mq ml it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">JNI</h1><p id="9b15" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">JNI代表Java本地接口。它定义了从Java或Kotlin代码编译的字节码与用C或C++编写的本机代码交互的方式。顾名思义，它帮助我们将Java代码与本地代码连接起来。</p><p id="996f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你最终更多地与JNI合作，我推荐你阅读安卓在JNI的提示——<a class="ae ky" href="https://developer.android.com/training/articles/perf-jni" rel="noopener ugc nofollow" target="_blank">JNI提示</a>。</p><h1 id="f8ab" class="mq ml it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">NDK和JNI入门</h1><p id="acf9" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">为了避免重复，我建议你看看下面的文章，并尝试安装你的第一个基于JNI的Android应用。这些文章还将帮助您建立编译Android应用程序以及NDK和本机代码所需的工具链。</p><ul class=""><li id="d5fc" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><a class="ae ky" href="https://developer.android.com/ndk/samples/sample_hellojni" rel="noopener ugc nofollow" target="_blank">样本:hello-jni </a></li><li id="8b4e" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><a class="ae ky" href="https://www.journaldev.com/28972/android-jni-application-ndk" rel="noopener ugc nofollow" target="_blank">使用NDK的安卓JNI应用</a></li></ul><p id="d7ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这些文章不够清楚，请在评论中告诉我。如果您已经成功创建并运行了您的JNI应用程序，或者已经了解这些结构，请继续下一部分。</p><h1 id="7a10" class="mq ml it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">YUV到位图转换的本机代码</h1><p id="2dfe" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在<code class="fe mc md me mf b">app/src/main/cpp</code>中创建一个库和源文件<code class="fe mc md me mf b">yuv2rgb.h/cc</code>。</p><h2 id="a76b" class="mk ml it bd mr oe of dn mv og oh dp mz li oi oj nb lm ok ol nd lq om on nf oo bi translated">头文件</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="1cd6" class="mk ml it bd mr oe of dn mv og oh dp mz li oi oj nb lm ok ol nd lq om on nf oo bi translated">源文件</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="b8e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理想情况下，您还应该为此编写一个单元测试，但是这超出了本文的范围。你可以在Android文档中阅读更多关于<a class="ae ky" href="https://source.android.com/compatibility/tests/development/native" rel="noopener ugc nofollow" target="_blank">添加原生测试的内容。</a></p><p id="5b3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将编写一个JNI层，将它与我们开始时使用的Java框架连接起来。</p><h1 id="7c18" class="mq ml it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">Java + JNI集成</h1><p id="a5d4" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">现在，您需要一个JNI文件来将Java库连接到本地库。让我们在<code class="fe mc md me mf b">app/src/main/cpp</code>里加上<code class="fe mc md me mf b">yuv2rgb-jni.cc</code>。</p><p id="540a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，让我们假设我们的Java框架函数在包<code class="fe mc md me mf b">com.example.myproject</code>中，在一个名为<code class="fe mc md me mf b">YuvConvertor</code>的静态类下，你的JNI文件应该是这样的。</p><blockquote class="lv lw lx"><p id="26dc" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">重要提示</em> </strong> <em class="it">:包名、类名和本机方法名在这里很重要，因为它们被运行时用来调用正确的本机函数。请参见下面JNI代码中的方法名，以获得更多上下文信息。</em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="e2a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，从Java库中调用它</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="59d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意的一些要点是:</p><ul class=""><li id="fb23" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">使用NDK API，我们可以直接访问本机代码中<a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html" rel="noopener ugc nofollow" target="_blank">字节缓冲区</a>的内容，如果处理不当，这既非常有用又非常危险。</li><li id="6438" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">在这种情况下，可以直接使用用于位图的<a class="ae ky" href="https://developer.android.com/ndk/reference/group/bitmap" rel="noopener ugc nofollow" target="_blank">NDK API</a>，这有助于减少额外的内存分配，我们可以直接从本机代码更新位图的内存。</li></ul><p id="3c74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，您就有了调用JNI的Java代码，它检索指向本机格式的输入和输出数据的指针，并将其传递给本机库进行处理。原生库是相当常见的C++代码，也可以在Android之外使用。</p><p id="1885" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的make文件(在这种情况下应该在<code class="fe mc md me mf b">app/src/main/cpp/CMakeLists.txt</code>中)应该正确配置，以支持使用Android APK构建本机代码。对于这个例子，它至少应该有这些定义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="0833" class="mq ml it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">表演</h1><p id="5da6" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在考虑性能时，请记住这是一种相当简单的C++代码形式，它没有明确利用可以在Android设备上运行的多线程或SIMD指令集。最好的情况是，部分代码被编译器优化了(例如，主for循环可以自动矢量化)。代码是用<code class="fe mc md me mf b">-O3</code>优化标志编译的。</p><p id="8cb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一幅<code class="fe mc md me mf b">8MP</code>图像(3264x2448 ),该代码在同一参考设备上大约需要<code class="fe mc md me mf b">76.4ms</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/0454bc8cf4a623dfa56cfec51010bf88.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*3ok2ouP9Y5hnJdUVkEM1zg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ob">表2:在Pixel 4a设备</em>上将 <code class="fe mc md me mf b"><em class="ob">8MP (3264x2448)</em></code> <em class="ob"> YUV图像转换为位图的性能延迟。</em></p></figure><p id="0631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在这里看到，这个版本的本机代码的性能比经过高度优化的多线程Java代码慢1.4倍，这不是一个坏消息。starter Java代码使用了<code class="fe mc md me mf b">353 ms</code>来运行相同的算法(尽管它可能有复杂的原因<code class="fe mc md me mf b">ByteBuffer</code>不提供直接数组访问- <a class="ae ky" href="https://blog.minhazav.dev/faster-image-processing-in-android-java-using-multi-threading/#java-bytebuffer-vs-native-byte" rel="noopener ugc nofollow" target="_blank">阅读更多信息</a>)。要了解更多关于编写更优化的本机代码或利用编译器的语言结构的信息，我推荐阅读本文— <a class="ae ky" href="https://blog.minhazav.dev/guide-compiler-to-auto-vectorise/" rel="noopener ugc nofollow" target="_blank">指导C++编译器自动向量化代码</a></p><h1 id="5536" class="mq ml it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">结束语</h1><p id="461e" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我要重申，本机代码对于在Android上运行计算密集型算法非常有用。并且大多数图像处理算法通常属于这一类别，这可能是因为需要处理大量像素，因此需要大量迭代。</p><p id="d6e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在同一个系列的实验中，通过利用多线程、NEON API(SIMD)和一些汇编代码，我能够将延迟降低到<code class="fe mc md me mf b">12.1 ms</code>，这是这个系列的赢家(剧透警告)。然而，编写和维护都相当复杂，基于<code class="fe mc md me mf b">Halide</code>的解决方案对于相同的问题陈述需要大约<code class="fe mc md me mf b">28ms</code>的时间，在性能、维护和编写的便利性方面，这甚至是完美的解决方案。</p><p id="bb8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将在我的下一组文章中写这两个问题，感谢您的阅读。敬请期待！！</p></div><div class="ab cl op oq hx or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="2207" class="mk ml it mf b gy mm mn l mo mp"><strong class="mf iu">Want to Connect With the Author?</strong></span><span id="1e59" class="mk ml it mf b gy ow mn l mo mp">This article was originally published at <a class="ae ky" href="https://blog.minhazav.dev/processing-images-fast-with-native-code-in-android/" rel="noopener ugc nofollow" target="_blank">https://blog.minhazav.dev</a>. </span></pre></div></div>    
</body>
</html>