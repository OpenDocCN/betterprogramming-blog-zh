<html>
<head>
<title>Rundown of the Most Important React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最重要的反应挂钩的概述</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rundown-of-the-most-important-react-hooks-5c9ec4cac5a2?source=collection_archive---------0-----------------------#2019-08-20">https://betterprogramming.pub/rundown-of-the-most-important-react-hooks-5c9ec4cac5a2?source=collection_archive---------0-----------------------#2019-08-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ad5f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">比较功能组件和基于类的组件的速度和性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/282a7f692502b4b65c3c334f8a95d907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNHZyHCVieQQSoPP51b4cQ.jpeg"/></div></div></figure><p id="c170" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">钩子解决了React中各种各样看似不相关的问题，这些问题是我们五年来编写和维护成千上万个组件时遇到的。</p><p id="e4a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无论您是在学习React、日常使用它，还是更喜欢使用具有相似组件模型的不同库，您都可能会认识到其中的一些问题。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="9b89" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak">反应钩的先决条件</strong></h1><p id="59c0" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">钩子是React 16.8的新增功能。在此版本之前，它不可用。关于React的一点知识就足够理解React钩子了。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="9f3c" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">为什么反应钩</h1><p id="79f9" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">我们经常不得不维护一些组件，这些组件开始时很简单，但后来却变成了一堆难以管理的有状态逻辑和副作用。</p><p id="2d0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每种生命周期方法通常都包含一些不相关的逻辑。例如，组件可能在<code class="fe mu mv mw mx b">componentDidMount</code>和<code class="fe mu mv mw mx b">componentDidUpdate</code>中执行数据提取。</p><p id="1d62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，同一个<code class="fe mu mv mw mx b">componentDidMount</code>方法也可能包含一些建立事件监听器的不相关逻辑，清理在<code class="fe mu mv mw mx b">componentWillUnmount</code>中执行。</p><p id="5a7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一起改变的相互相关的代码被分开，但是完全不相关的代码最终被组合在一个方法中。这使得引入错误和不一致变得太容易了。</p><p id="ac5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在许多情况下，不可能将这些组件分解成更小的组件，因为有状态逻辑无处不在。测试它们也很困难。这是许多人喜欢将React与单独的状态管理库结合起来的原因之一。</p><p id="9e24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这通常会引入太多的抽象，需要您在不同的文件之间跳转，并且使得重用组件更加困难。</p><p id="8ade" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了解决这个问题，Hooks允许您将一个组件拆分成更小的功能，这是基于哪些部分是相关的(比如设置订阅或获取数据)，而不是基于生命周期方法强制拆分。</p><p id="0694" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您也可以选择用一个reducer来管理组件的本地状态，使其更具可预测性。</p><h2 id="2211" class="my ly it bd lz mz na dn md nb nc dp mh ld nd ne mj lh nf ng ml ll nh ni mn nj bi translated"><strong class="ak">钩子快如闪电</strong></h2><p id="6b23" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">钩子非常快，因为如果你创建两个组件，一个是使用钩子管理状态的功能组件，另一个是基于类的组件。</p><p id="1d33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将在这两个组件中制作一个基本计数器，以比较它们的速度和性能。第一个是基于类的组件，它只是执行一个计数器逻辑。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/2655f114f13c5f3d7ef35f510a5769a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rqg4EjgRBbcRQxpTMIZUow.png"/></div></div></figure><p id="bc8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用Chrome开发工具中的审计检查了这个基于类的组件的性能，结果是95%。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/5559dfb0d7a8557eb57d5e2cc36f0040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4IUgOjhmjQr70gUw92lyHQ.png"/></div></div><p class="nl nm gj gh gi nn no bd b be z dk translated">参考此处的代码<a class="ae np" href="https://codesandbox.io/s/basic-of-hooks-i7v3d" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="2f23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在功能组件中使用钩子将性能提高到98% <strong class="kw iu"> </strong>，比基于类的组件高3%。</p><p id="4929" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用计数器的简单逻辑，它显示了3%的差异。而且，如果组件中的逻辑很大，性能差异会更大。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="b517" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">反应钩</h1><p id="3ed8" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">React钩子有很多，包括<code class="fe mu mv mw mx b">useState</code>、<code class="fe mu mv mw mx b">useEffect</code>、<code class="fe mu mv mw mx b">useContext</code>、<code class="fe mu mv mw mx b">useReducer</code>、<code class="fe mu mv mw mx b">useMemo</code>、<code class="fe mu mv mw mx b">useCallback</code>、<code class="fe mu mv mw mx b">useRef</code>、<code class="fe mu mv mw mx b">useImperativeHandle</code>、<code class="fe mu mv mw mx b">useLayoutEffect</code>、<code class="fe mu mv mw mx b">useDebugValue</code>，你可以创建自己的定制钩子。</p><p id="c2ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将浏览其中的一些，并将它们与没有挂钩的基于类的组件进行比较。</p><h2 id="a7cb" class="my ly it bd lz mz na dn md nb nc dp mh ld nd ne mj lh nf ng ml ll nh ni mn nj bi translated"><strong class="ak">使用状态挂钩</strong></h2><p id="2451" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">我们已经在上面的计数器逻辑中看到了一个<code class="fe mu mv mw mx b">useState</code>钩子的基本例子。</p><p id="297d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">useState</code>钩子返回一个数组，其中第一个元素是状态名，第二个元素是修改状态值的函数。在<code class="fe mu mv mw mx b">useState</code>中，我们传递状态的初始值。</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="a7e2" class="my ly it mx b gy nu nv l nw nx">const [count , setCount] = useState(0)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/5559dfb0d7a8557eb57d5e2cc36f0040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4IUgOjhmjQr70gUw92lyHQ.png"/></div></div><p class="nl nm gj gh gi nn no bd b be z dk translated">参见此处的代码<a class="ae np" href="https://codesandbox.io/s/basic-of-hooks-i7v3d" rel="noopener ugc nofollow" target="_blank">和</a></p></figure><p id="4fd6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是React钩子管理状态以存储值的方式，类似于基于类的组件。</p><p id="fbce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">功能组件的代码比基于类的组件要小得多。基于类的组件可以执行相同的逻辑，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/2655f114f13c5f3d7ef35f510a5769a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rqg4EjgRBbcRQxpTMIZUow.png"/></div></div></figure><p id="98c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以看到，与基于类的组件相比，React挂钩将代码减少到简单计数器逻辑的一半。</p><h2 id="0f68" class="my ly it bd lz mz na dn md nb nc dp mh ld nd ne mj lh nf ng ml ll nh ni mn nj bi translated">使用效果挂钩</h2><p id="81cc" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated"><code class="fe mu mv mw mx b">useEffect</code>钩子用于处理功能组件中的生命周期方法。</p><p id="e9bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你熟悉React类的生命周期方法，你可以把<code class="fe mu mv mw mx b">useEffect</code>钩子看作是初学者的<code class="fe mu mv mw mx b">componentDidMount</code>、<code class="fe mu mv mw mx b">componentDidUpdate</code>、<code class="fe mu mv mw mx b">componentWillUnmount</code>和<code class="fe mu mv mw mx b">getDerivedStateFromProps</code>的组合。</p><p id="fe52" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它有助于将逻辑写在一个地方。但是Dan Abramov已经多次重复说<code class="fe mu mv mw mx b">useEffect</code>不应该作为这些生命周期方法<strong class="kw iu"> </strong> <em class="ny">的替代而被引入，只能是</em> <strong class="kw iu">。</strong></p><p id="bbbe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你把<code class="fe mu mv mw mx b">useEffect</code>和那个心智模型一起使用，你以后会很困惑。相反，他建议将<code class="fe mu mv mw mx b">useEffect</code>视为一个当依赖数组中的值发生变化时运行副作用的地方。</p><p id="f0d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">useEffect</code>是一个回调函数，我们可以给第二个元素一个依赖数组，它可以包含任何东西，比如变量、道具、状态等等。，我们必须在上面运行<code class="fe mu mv mw mx b">componentDidUpdate</code>。</p><p id="77d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React组件中有两种常见的副作用——不需要清理的副作用和需要清理的副作用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/ab091d8842c9280f6fd386cc9e7b2f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A_jM5ORYizV0X4-GBCkc-A.png"/></div></div></figure><p id="ab94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个使用基于类的组件使用<code class="fe mu mv mw mx b">componentDidMount</code>和<code class="fe mu mv mw mx b">componentDidUpdate</code>的基本例子，基于计数值改变页面的标题。这是先前计数逻辑的扩展。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/f05f8fc00a490610f2747b44c6fe28fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zpqs3c2zpr_UWhu8Eu7y1A.png"/></div></div></figure><p id="7350" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是我们如何用钩子执行相同的逻辑。它将代码长度减少了将近一半，同时也提高了效率。</p><p id="7606" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们有不止一个状态，并且我们必须只在特定的状态改变时使用<code class="fe mu mv mw mx b">useEffect</code>钩子时，依赖数组就出现了。</p><p id="7a0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下面的例子中，我们有两个状态计数和名称，只有当我们的计数值改变时，我们才需要更新文档标题。这就是为什么一个依赖数组只包含<code class="fe mu mv mw mx b">count</code> <strong class="kw iu">。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/0c8eef4a6b0f0982eede2986764af50a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5wcLVfIb0kmb6w19EEEc3g.png"/></div></div><p class="nl nm gj gh gi nn no bd b be z dk translated">此处完成代码<a class="ae np" href="https://codesandbox.io/s/useeffect-in-hooks-e9e4e" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="fde4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">前面，我们看了如何表达不需要任何清理的副作用。然而，有些影响确实如此。</p><p id="3654" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，我们可能想要设置对外部数据源的订阅。在这种情况下，清理是很重要的，这样我们就不会引入内存泄漏！</p><p id="2702" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于像<code class="fe mu mv mw mx b">componentWillUnmount</code><em class="ny"/>这样的清理函数，每个效果都可能返回一个在它之后清理的函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/8efbf6af6d541e8b5dd1fc9c9675cd1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RqK_6Zmq1MUecIYHOfdpCg.png"/></div></div></figure><p id="7764" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">参考这个例子，它使用<code class="fe mu mv mw mx b">useState</code>和<code class="fe mu mv mw mx b">useEffect</code>钩子以HH:MM:SS格式计算第二天的剩余时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="nl nm gj gh gi nn no bd b be z dk translated"><a class="ae np" href="https://codesandbox.io/s/timer-71ivn" rel="noopener ugc nofollow" target="_blank">代码链接</a></p></figure><h2 id="14f7" class="my ly it bd lz mz na dn md nb nc dp mh ld nd ne mj lh nf ng ml ll nh ni mn nj bi translated">使用上下文挂钩</h2><p id="8919" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">接受一个上下文对象(从<code class="fe mu mv mw mx b">React.createContext</code>返回的值)并返回该上下文的当前上下文值。</p><p id="233e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当前上下文值由树中调用组件上方最近的<code class="fe mu mv mw mx b">&lt;MyContext.Provider&gt;</code>的<code class="fe mu mv mw mx b">value</code>属性决定。</p><pre class="kj kk kl km gt nq mx nr ns aw nt bi"><span id="1bbb" class="my ly it mx b gy nu nv l nw nx">const value = useContext(MyContext)</span></pre><p id="11b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当组件上方最近的<code class="fe mu mv mw mx b">&lt;MyContext.Provider&gt;</code>更新时，这个钩子将触发一个重新渲染，将最新的上下文<code class="fe mu mv mw mx b">value</code>传递给那个<code class="fe mu mv mw mx b">MyContext</code>提供者。</p><p id="8264" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你熟悉钩子之前的上下文API，<code class="fe mu mv mw mx b">useContext(MyContext)</code>相当于类中的<code class="fe mu mv mw mx b">static contextType = MyContext</code>，或者相当于<code class="fe mu mv mw mx b">&lt;MyContext.Consumer&gt;</code>。</p><p id="79a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">useContext(MyContext)</code>仅让您<em class="ny">阅读</em>上下文并订阅其更改。您仍然需要树中的一个上面的<code class="fe mu mv mw mx b">&lt;MyContext.Provider&gt;</code>来<em class="ny">提供</em>这个上下文的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/77101621493306cc0dc4f1cb1123bf88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5qSSWexVySP4iWmBwBiUg.png"/></div></div><p class="nl nm gj gh gi nn no bd b be z dk translated"><a class="ae np" href="https://codesandbox.io/s/usecontext-hook-09gjc" rel="noopener ugc nofollow" target="_blank">如需完整代码，请参考此链接</a></p></figure><h2 id="71dd" class="my ly it bd lz mz na dn md nb nc dp mh ld nd ne mj lh nf ng ml ll nh ni mn nj bi translated">useReducer挂钩</h2><p id="a26d" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated"><code class="fe mu mv mw mx b">useState</code>的替代方案。接受类型为<code class="fe mu mv mw mx b">(state, action) =&gt; newState</code>的缩减器，并返回与<code class="fe mu mv mw mx b">dispatch</code>方法配对的当前状态。(如果你熟悉Redux，你已经知道这是如何工作的。)</p><p id="393c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您有涉及多个子值的复杂状态逻辑或者下一个状态依赖于前一个状态时，<code class="fe mu mv mw mx b">useReducer</code>通常比<code class="fe mu mv mw mx b">useState</code>更好。</p><p id="7f88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">useReducer</code>还允许您优化触发深度更新的组件的性能，因为您可以向下传递<em class="ny">调度</em>而不是回调。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/48bc32f7e7bf1905b207317eaeb98462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vS4l4NRmhbDFKW14YimC9w.png"/></div></div><p class="nl nm gj gh gi nn no bd b be z dk translated">此处完成代码<a class="ae np" href="https://codesandbox.io/s/usereducer-hooks-err6b" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="8778" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有两种不同的方式来初始化<code class="fe mu mv mw mx b">useReducer</code>状态。您可以根据使用情况选择其中之一。最简单的方法是将初始状态作为第二个参数传递，下一个参数由lazily传递。</p><h2 id="9c8a" class="my ly it bd lz mz na dn md nb nc dp mh ld nd ne mj lh nf ng ml ll nh ni mn nj bi translated"><strong class="ak"> u </strong> seMemo挂钩</h2><p id="d5f3" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">如果您需要缓存被调用函数的结果，那么<code class="fe mu mv mw mx b">useMemo</code>就会出现。这有助于性能优化。</p><p id="68b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">useMemo</code>是一个钩子，当其中一个依赖关系改变时，它将重新计算缓存的值。这种优化避免了每次渲染时的昂贵计算。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/f66ad7959027594df31708dc0ad59807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O5Viqopaz0eC7Iw30QEk6A.png"/></div></div><p class="nl nm gj gh gi nn no bd b be z dk translated">在此完成代码<a class="ae np" href="https://codesandbox.io/s/usememo-hook-jl8jf" rel="noopener ugc nofollow" target="_blank">和</a></p></figure><p id="5f22" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的例子中，由于<code class="fe mu mv mw mx b">useMemo</code>，只有当<code class="fe mu mv mw mx b">counterOne</code>递增时<code class="fe mu mv mw mx b">isEven</code>操作才会发生。</p><p id="748f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果<code class="fe mu mv mw mx b">useMemo</code>不存在，即使<code class="fe mu mv mw mx b">counterTwo</code>被改变也会发生，并且当我们在<code class="fe mu mv mw mx b">isEven</code>功能中添加一个繁重的操作时，它会降低效率。</p><p id="f6f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将来，React可能会选择“忘记”一些以前记忆的值，并在下次渲染时重新计算它们，例如，为屏幕外组件释放内存。</p><p id="82c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编写您的代码，使其在没有<code class="fe mu mv mw mx b">useMemo</code>的情况下仍然可以工作，然后添加它以优化性能。</p><p id="55ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你需要缓存一个函数，<code class="fe mu mv mw mx b">useCallback</code>就出现了。它还用于性能优化。</p><h2 id="6dd1" class="my ly it bd lz mz na dn md nb nc dp mh ld nd ne mj lh nf ng ml ll nh ni mn nj bi translated"><strong class="ak">定制挂钩</strong></h2><p id="2524" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">构建自己的钩子可以让您将组件逻辑提取到可重用的函数中。</p><p id="4c48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">自定义钩子是一个JavaScript函数，它的名字以<code class="fe mu mv mw mx b">use</code>开头，可以调用其他钩子。要全面了解定制挂钩，请参考此<a class="ae np" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="8ecc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望你喜欢读我的第一篇文章。</p></div></div>    
</body>
</html>