<html>
<head>
<title>How to Implement Mock With Spectator With Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用笑话实现观众的嘲笑</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-i-learned-about-mocking-with-spectator-tests-e36ecf2a426c?source=collection_archive---------9-----------------------#2022-04-11">https://betterprogramming.pub/what-i-learned-about-mocking-with-spectator-tests-e36ecf2a426c?source=collection_archive---------9-----------------------#2022-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df0a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我从旁观者测试中学到了什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3a2ae43c1fff5c72a7b824c55e523fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*psAjSrWlIdEqTUbfgSgMoQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@flowforfrank?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">费伦茨·阿尔马西</a>在<a class="ae ky" href="https://unsplash.com/s/photos/javascript-code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="516a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在我之前的<a class="ae ky" href="https://javascript.plainenglish.io/how-to-use-spectator-to-test-your-angular-components-a125c95cf24b" rel="noopener ugc nofollow" target="_blank">博客文章</a>中提到,《旁观者》目前是我Angular应用程序的首选测试工具。在过去的几周里，我学到了一些关于使用旁观者嘲讽的东西，希望对你有用。</p><p id="6174" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我使用的是带有玩笑意味的旁观者。</p><h1 id="2ed6" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">删除未使用的提供程序</h1><p id="4947" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在我的<code class="fe mt mu mv mw b">createServiceFactory</code>或<code class="fe mt mu mv mw b">createComponentFactory</code>中，我已经声明我的依赖项将被自动嘲笑，但我仍然保留了带有<code class="fe mt mu mv mw b">useValue: {}</code>的提供者。在下面的例子中，我的<code class="fe mt mu mv mw b">UserApiService</code>已经被自动嘲讽了。在这种情况下，不再需要在带有<code class="fe mt mu mv mw b">useValue: {}</code>的提供者中声明<code class="fe mt mu mv mw b">UserApiService</code>:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="fe20" class="nb lx it mw b gy nc nd l ne nf">let spectator: SpectatorService&lt;UserService&gt;;<br/>  const createService = createServiceFactory({<br/>    service: UserService,<br/>    providers: [<br/>      { provide: UserApiService, useValue: {}}, // TODO: Remove, we don't need it.<br/>    ],<br/>    mocks: [UserApiService], // Automatically mock<br/>  });<br/><br/>  beforeEach(() =&gt; (spectator = createService()));</span></pre><p id="53a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不需要供应商中的<code class="fe mt mu mv mw b">UserApiService</code>:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="7e95" class="nb lx it mw b gy nc nd l ne nf">let spectator: SpectatorService&lt;UserService&gt;;<br/>  const createService = createServiceFactory({<br/>    service: UserService,<br/>    mocks: [UserApiService],<br/>  });<br/><br/>  beforeEach(() =&gt; (spectator = createService()));</span></pre><p id="5455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe mt mu mv mw b">UserApiService</code>保留在提供者中没有任何副作用。不过，不用的话最好去掉。</p><h1 id="69be" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">Andre return()vs mock return value()</h1><p id="5667" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">自从我开始使用旁观者以来，我一直专门使用<code class="fe mt mu mv mw b">andReturn()</code>来模拟测试用例中的方法。最近才知道Jest的<code class="fe mt mu mv mw b">mockReturnValue()</code>。其工作方式与<code class="fe mt mu mv mw b">andReturn()</code>相同。我注意到的主要区别是<code class="fe mt mu mv mw b">andReturn()</code>对其返回类型并不严格。</p><p id="7c5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定一个返回类型<code class="fe mt mu mv mw b">Observable&lt;User&gt;</code>的方法。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="8c47" class="nb lx it mw b gy nc nd l ne nf">class UserService {<br/>  getUser(): Observable&lt;User&gt; {<br/>    // code here..    <br/>  }<br/>}</span></pre><p id="c4a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<code class="fe mt mu mv mw b">User</code>为:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="bbcd" class="nb lx it mw b gy nc nd l ne nf">interface User {<br/>  firstName: string;<br/>  lastName: string;<br/>}</span></pre><p id="dc8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mt mu mv mw b">mockReturnValue</code>，如果我没有使用预期的返回类型进行模拟，我将得到一个错误:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="77e2" class="nb lx it mw b gy nc nd l ne nf">const userUservice = spectator.inject(UserService);<br/>userService.getUser.mockReturnValue(of('user mock'));</span></pre><p id="e393" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="1736" class="nb lx it mw b gy nc nd l ne nf">error TS2345: Argument of type 'Observable&lt;string&gt;' <br/>is not assignable to parameter of type 'Observable&lt;User&gt;'.</span></pre><p id="7844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">mockReturnValue()</code>只接受方法声明的返回类型:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="9aad" class="nb lx it mw b gy nc nd l ne nf">const userUservice = spectator.inject(UserService);<br/>userService.getUser.mockReturnValue(of({firstName: 'First', lastName: 'Last'} as User));</span></pre><p id="df79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mt mu mv mw b">andReturn()</code>，我可以使用不同的类型:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="ac93" class="nb lx it mw b gy nc nd l ne nf">const userUservice = spectator.inject(UserService);<br/>userService.getUser.andReturn(of('user mock')); // I can mock with a string type!</span></pre><h1 id="33df" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">通过直接赋值进行模拟</h1><p id="0bba" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果我关心mock的返回值，我已经在测试用例中使用了<code class="fe mt mu mv mw b">andReturn()</code>(不久将使用<code class="fe mt mu mv mw b">mockReturnValue()</code>)。当我在寻找一个测试中出现的模拟时，我发现更容易发现。</p><p id="4c90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在一些测试案例中，我只对断言一个被模仿的方法的<code class="fe mt mu mv mw b">toHaveBeenCalled()</code>感兴趣。在这种情况下，我通常会将<code class="fe mt mu mv mw b">jest.fn()</code>赋给我想要断言的方法。这仅在属性或方法是<em class="lv">而不是</em>只读时才有效。</p><p id="ea63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我在组件中使用<code class="fe mt mu mv mw b">UserService</code>。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="c678" class="nb lx it mw b gy nc nd l ne nf">constructor(private userService: UserService) {}</span></pre><p id="a394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可以通过直接分配模拟函数在测试中模拟它的<code class="fe mt mu mv mw b">getUser()</code>方法调用。然后用<code class="fe mt mu mv mw b">toHaveBeenCalled()</code>断言:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="9612" class="nb lx it mw b gy nc nd l ne nf">spectator.component['userService'].getUser = jest.fn();<br/>//.. some code here<br/>expect(spectator.component['userService'].getUser).toHaveBeenCalled();</span></pre><h1 id="aed4" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">模拟只读属性</h1><p id="b956" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果我想模仿的方法是只读的怎么办？</p><p id="95e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我有一个助手:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="b60f" class="nb lx it mw b gy nc nd l ne nf">export class UserService {<br/>  //.. some code<br/>  get canAccess$(): Observable&lt;boolean&gt; {<br/>    // .. implementaion<br/>  }<br/>}</span></pre><p id="9bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我有一个组件使用了上面的getter <code class="fe mt mu mv mw b">UserService.canAccess$</code>。当我试图用<code class="fe mt mu mv mw b">andReturn()</code>模仿getter时:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="f3e6" class="nb lx it mw b gy nc nd l ne nf">const userService = spectator.inject(UserService);<br/>userService.canAccess$.andReturnvalue(of(false));</span></pre><p id="2ee5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我得到以下错误:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="8d42" class="nb lx it mw b gy nc nd l ne nf">TS2339: Property 'andReturn' does not exist on type 'Observable '.</span></pre><p id="cdd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我也不能直接分配mock，因为这里的<code class="fe mt mu mv mw b">canAccess$</code>是只读的:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="c35f" class="nb lx it mw b gy nc nd l ne nf">spectator.component['userService'].canAccess$ = of(false);</span><span id="cbf3" class="nb lx it mw b gy ng nd l ne nf">Cannot assign to 'canAccess$' because it is a read-only property.</span></pre><p id="46e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种方法可以解决这个问题。</p><h2 id="5f8c" class="nb lx it bd ly nh ni dn mc nj nk dp mg li nl nm mi lm nn no mk lq np nq mm nr bi translated">使用Object.defineProperty()</h2><p id="f901" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我之前使用了<code class="fe mt mu mv mw b">Object.defineProperty</code>来修改服务对象的属性:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="e882" class="nb lx it mw b gy nc nd l ne nf">Object.defineProperty(spectator.component['userService'], 'canAccess$', { value: of(true) });</span></pre><p id="57d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这奏效了。我认为一定有一种方法可以通过使用旁观者而不是直接修改服务对象来实现这一点，见下一节。</p><h2 id="5c18" class="nb lx it bd ly nh ni dn mc nj nk dp mg li nl nm mi lm nn no mk lq np nq mm nr bi translated">在测试用例中设置useValue</h2><p id="f624" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我是在浏览《观察家》自述文件中的<a class="ae ky" href="https://github.com/ngneat/spectator#mocking-constructor-dependencies" rel="noopener ugc nofollow" target="_blank">例子</a>时发现这种方法的。</p><p id="1f70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可以通过设置<code class="fe mt mu mv mw b">useValue</code>在我的<code class="fe mt mu mv mw b">createComponentFactory</code>调用中为<code class="fe mt mu mv mw b">canAccess$</code>声明一个默认的模拟。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="850c" class="nb lx it mw b gy nc nd l ne nf">const createComponent = createComponentFactory({<br/>  component: MyComponent,<br/>  //...typeOrOptions here<br/>  providers: [<br/>    { provide: UserService, useValue: { canAccess$: of(true) } }<br/>  ],<br/>});</span></pre><p id="3334" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">套件中的所有测试都将使用这个默认值<code class="fe mt mu mv mw b">canAccess$</code>，除非我在一个测试或另一个测试套件中覆盖它。为了覆盖默认的模拟，我可以在测试用例中用<code class="fe mt mu mv mw b">useValue</code>指定提供者。在这个例子中，我将返回值改为<code class="fe mt mu mv mw b">of(false)</code>。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="117e" class="nb lx it mw b gy nc nd l ne nf">const provider = {<br/>  provide: UserService,<br/>  useValue: { canAccess: of(false) },<br/>};</span></pre><p id="c288" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后使用我刚刚声明的带有模拟覆盖的提供者调用<code class="fe mt mu mv mw b">createComponent()</code>。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="3b64" class="nb lx it mw b gy nc nd l ne nf">spectator = createComponent({<br/>  providers: [provider],<br/>});</span></pre><p id="e3b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可以在单独的测试用例中覆盖默认的模拟。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="61f5" class="nb lx it mw b gy nc nd l ne nf">it('should prevent access...', () =&gt; {<br/>  const provider = {<br/>    provide: UserService,<br/>    useValue: { canAccess$: of(false) },<br/>  };<br/>  spectator = createComponent({<br/>    providers: [provider],<br/>  });<br/>  //.. code here<br/>});</span></pre><p id="6d83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，如果我想在测试套件中使用它，我可以在<code class="fe mt mu mv mw b">beforeEach()</code>中声明覆盖:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="db16" class="nb lx it mw b gy nc nd l ne nf">describe('Prevent access', () =&gt; {<br/>  beforeEach(() =&gt; {<br/>    const provider = {<br/>      provide: UserService,<br/>      useValue: { canAccess$: of(false) },<br/>    };<br/>    spectator = createComponent({<br/>      providers: [provider],<br/>    });<br/>    //.. code here<br/>  });<br/>  it('should prevent access...', () =&gt; {<br/>    // .. code here<br/>  });<br/>  // .. more tests<br/>});</span></pre><p id="c80c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这个故事，你可能也会喜欢我关于旁观者测试和Angular的其他故事:</p><div class="ns nt gp gr nu nv"><a href="https://javascript.plainenglish.io/how-to-use-spectator-to-test-your-angular-components-a125c95cf24b" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">如何使用旁观者来测试你的角组件</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">使用示例应用程序的操作指南。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ks nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/unsubscribing-multiple-observables-in-angular-46c9c4833ffc"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">如何在Angular中自动退订多个可观测量</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">让我们使用异步管道和RxJS操作符的力量</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">better编程. pub</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj ks nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://blog.ardy.me/membership" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">通过我的推荐链接加入媒体</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">阅读Ardy Gallego Dedase(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">blog.ardy.me</p></div></div><div class="oe l"><div class="ol l og oh oi oe oj ks nv"/></div></div></a></div></div></div>    
</body>
</html>