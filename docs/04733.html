<html>
<head>
<title>A Guide to Reference Counting in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python引用计数指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-guide-to-reference-counting-in-python-27334fc2e3c1?source=collection_archive---------14-----------------------#2020-05-04">https://betterprogramming.pub/a-guide-to-reference-counting-in-python-27334fc2e3c1?source=collection_archive---------14-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4743" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">内存中的Python</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6b26c960431213bd87c90ce9a865a5d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m4nqSoQZeIMS0SuQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@steve_j?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯蒂夫·约翰森</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a514" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将讨论Python中的引用计数。为了便于说明，我将使用list对象，它是可变的。我希望你会喜欢它。注意，我不会深入C实现的细节。</p><p id="ab58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">页（page的缩写）s:在您的硬件上，代码片段的输出可能会有所不同。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bbb7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">变量是内存引用</h1><p id="7d8c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Python中的变量是内存引用。说<code class="fe mz na nb nc b">x=[1, 2]</code>会怎么样？<code class="fe mz na nb nc b">[1, 2]</code>是对象。回想一下，在Python中，一切都是对象。<code class="fe mz na nb nc b">[1, 2]</code>将在记忆中被创造。<code class="fe mz na nb nc b">x</code>是<code class="fe mz na nb nc b">[1, 2]</code>对象的内存引用。</p><p id="fb5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关注下面的例子——您可以找到<code class="fe mz na nb nc b">x</code>引用的内存地址。请注意，您可以只使用<code class="fe mz na nb nc b">id(x)</code>，它会给您以十进制为基础，而<code class="fe mz na nb nc b">hex</code>函数会将其转换为十六进制。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/f0cca651fc6a928cf9e2f4839f287e59.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*vqC63P3gWwMZ6qPio9HyYA.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eebe" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">引用计数</h1><p id="0dcd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止，我们已经在内存中创建了一个列表对象和对该对象的引用。<code class="fe mz na nb nc b">y=[1,2]</code>和<code class="fe mz na nb nc b">y=x</code>有什么区别？</p><p id="ac97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你说<code class="fe mz na nb nc b">y=[1,2]</code>时，它会在内存中创建一个新的列表对象，而<code class="fe mz na nb nc b">y</code>会引用它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/9998b8c96df3324a4363130e533faef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*Gibu9KphGF98TLyJknbhYw.png"/></div></figure><p id="0727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而当你说<code class="fe mz na nb nc b">y=x</code>时，你基本上是告诉Python你希望<code class="fe mz na nb nc b">y</code>变量引用<code class="fe mz na nb nc b">x</code>变量所引用的内容。因为变量是内存引用。</p><p id="6956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以确认<code class="fe mz na nb nc b">x</code>和<code class="fe mz na nb nc b">y</code>引用同一个对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/39871871d9b065357ce68b1653829283.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*5x8TQwLeQdlp2hTaVFBsDg.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="15e4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">引用计数的数量</h1><p id="8275" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止还不错——我们学到了很多。现在，有多少变量引用了一个对象？</p><h2 id="8262" class="ni md it bd me nj nk dn mi nl nm dp mm li nn no mo lm np nq mq lq nr ns ms nt bi translated"><strong class="ak">错误使用</strong></h2><p id="9dbe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我看到有些人使用<code class="fe mz na nb nc b">sys.getrefcount(var)</code>却不知道传递<code class="fe mz na nb nc b">var</code>给对象多加一个引用。让我们看看下面的例子。</p><p id="a801" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看这个。在我们期待<code class="fe mz na nb nc b">2</code> ( <code class="fe mz na nb nc b">x</code>和<code class="fe mz na nb nc b">y</code>)的同时输出<code class="fe mz na nb nc b">3</code>。这是因为将<code class="fe mz na nb nc b">x</code>传递给<code class="fe mz na nb nc b">getrefcount</code>函数增加了一个引用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="0487" class="ni md it bd me nj nk dn mi nl nm dp mm li nn no mo lm np nq mq lq nr ns ms nt bi translated"><strong class="ak">最好用</strong></h2><p id="3a9f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可以使用内置的ctypes模块找到您期望的结果。你必须将<code class="fe mz na nb nc b">x</code>的id传递给<code class="fe mz na nb nc b">from_address</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0c0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么会这样？因为<strong class="lb iu">在错误的用法</strong>中，你传递的是变量，而<strong class="lb iu">在更好的用法中，</strong>传递的是变量的id，这意味着你传递的只是一个基数为10的数字，而不是变量。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bbbc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">当物体消失时</h1><p id="71eb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当没有变量引用一个对象时会发生什么？该对象将从内存中删除，因为没有任何对象引用该对象。请注意，这里有一个例外。如果有循环引用，<code class="fe mz na nb nc b">garbage collector</code>就会来打。我不会进入这里的垃圾收集器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="144b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么我使用可变对象</h1><p id="7617" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于不可变对象，由于性能原因，结果可能与您预期的不同。我可能会讨论未来科学背后的东西。</p><p id="3352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查下面例子，看看输出是如何变化的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4df5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="9ac3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止，我们讨论的所有内容都适用于CPython。我希望你喜欢它。</p></div></div>    
</body>
</html>