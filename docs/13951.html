<html>
<head>
<title>How to Create a Transition That Fades Between Colors in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在SwiftUI中创建颜色渐变的过渡</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-transition-that-fades-between-colors-in-swiftui-6d6e275b7d62?source=collection_archive---------6-----------------------#2022-10-18">https://betterprogramming.pub/how-to-create-a-transition-that-fades-between-colors-in-swiftui-6d6e275b7d62?source=collection_archive---------6-----------------------#2022-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b316" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">享受这一步一步的指南来创建这个有趣的项目</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2736d84a4fad5703e4256aa05b12671a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TvGuPPDDc5MNUXQ-qgsAQQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@zalfaimani?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Zalfa Imani </a>在<a class="ae kv" href="https://unsplash.com/s/photos/gallery?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="9968" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢当图像过渡时使用平均颜色背景的应用程序的外观。这项漂亮的技术可以通过计算给定图像的平均颜色来实现。此示例是使用Unsplash中的图像创建的，以创建所需的效果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/18f4c0dac1488a3c9c0339adb85b3db3.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/1*mxt86QJl0LpjfY2wjOwV1g.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图库应用程序</p></figure><p id="97d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">项目的最终版本可以在<a class="ae kv" href="https://github.com/scottandrew/FadingScollerDemo.git" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><h1 id="0294" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">创建Xcode项目</h1><ol class=""><li id="447e" class="ml mm iq ky b kz mn lc mo lf mp lj mq ln mr lr ms mt mu mv bi translated">创建一个新的SwifUI项目</li><li id="5864" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">将<code class="fe nb nc nd ne b">ContentView</code>重命名为<code class="fe nb nc nd ne b">GalleryView</code>。</li><li id="d6ff" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">将<code class="fe nb nc nd ne b">ContentView_Previews</code>更名为<code class="fe nb nc nd ne b">GalleryView_Previews</code>。</li><li id="9328" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">添加来自<a class="ae kv" href="https://github.com/siteline/SwiftUI-Introspect.git" rel="noopener ugc nofollow" target="_blank">https://github.com/siteline/SwiftUI-Introspect.git</a>的SwiftUI-Introspect包</li><li id="be2f" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">将图像添加到项目资源中。示例项目中的图像名为<code class="fe nb nc nd ne b">Image 1, Image 2, Image 3, </code>和<code class="fe nb nc nd ne b"> Image 4</code>。</li></ol><p id="8e7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SwiftUI-Introspect库将用于访问位于<code class="fe nb nc nd ne b">Scrollview</code>之后的<code class="fe nb nc nd ne b">UIScrollView</code>，因此可以将<code class="fe nb nc nd ne b">isPagingEnabled</code>标志设置为<code class="fe nb nc nd ne b">true</code>。</p><h1 id="c1e2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">平均色码</h1><p id="be59" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">平均色码不是原创。这是来自<a class="ae kv" href="https://christianselig.com/2021/04/efficient-average-color/" rel="noopener ugc nofollow" target="_blank">https://christianselig.com/2021/04/efficient-average-color/</a>的代码。这段代码快速高效。作者对他为什么创建这个代码有一个很好的解释。</p><p id="77d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码在一个<code class="fe nb nc nd ne b">UIImage</code>类别中，这个类别允许直接在图像上调用它。例如:<code class="fe nb nc nd ne b">image.findAverageColor()</code></p><h1 id="71f4" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">创建ImageEntry模型</h1><p id="44dc" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">需要创建一个<code class="fe nb nc nd ne b">ImageEntry.swift</code>文件。该文件将包含一个小结构来保存一个<code class="fe nb nc nd ne b">UIImage</code>、一个UUID和平均颜色。采用图像名称的简单构造函数将完成所有工作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="50ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">做出的一个设计决策是将数据保存为<code class="fe nb nc nd ne b">UIKit</code>对象。这使得代码不必在SwiftUI和UIKit之间来回切换，直到有必要的时候。</p><h1 id="96ee" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">开始构建画廊视图</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><ol class=""><li id="d7d7" class="ml mm iq ky b kz la lc ld lf nk lj nl ln nm lr ms mt mu mv bi translated">创建一个显示在图库中的<code class="fe nb nc nd ne b">ImageEntry</code>项目数组。</li><li id="f802" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">将<code class="fe nb nc nd ne b">ScrollView</code>包裹在<code class="fe nb nc nd ne b">GeometryReader.</code>内<code class="fe nb nc nd ne b">GeometryReader</code>将用于设置图像尺寸。稍后还需要视图的宽度来计算背景颜色。</li><li id="6a74" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">将<code class="fe nb nc nd ne b">ScrollView</code>设为水平，使其左右滚动。</li><li id="16d1" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">在<code class="fe nb nc nd ne b">LazyHStack</code>中布局图像。</li><li id="2c23" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">从当前<code class="fe nb nc nd ne b">ImageEntry</code>中的<code class="fe nb nc nd ne b">UIImage</code>创建<code class="fe nb nc nd ne b">Image</code>。</li><li id="b10d" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">使<code class="fe nb nc nd ne b">Image</code>适合屏幕，缩进24个带圆角的单元。</li><li id="9032" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">使<code class="fe nb nc nd ne b">ScrollView</code>分页。</li><li id="8818" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">让<code class="fe nb nc nd ne b">GeometryView</code>忽略屏幕的安全区域，这样整个屏幕用于布局。当添加彩色背景时，这一点很重要。</li></ol><p id="a824" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在已经创建了一个没有背景的基本图库。画廊可以滚动，图像适合屏幕，保持其长宽比。</p><h1 id="2840" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">跟踪滚动视图的位置</h1><p id="1d4e" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">转换需要知道<code class="fe nb nc nd ne b">ScrollView</code>的偏移量。首先，必须创建自定义视图首选项来存储视图的偏移。</p><p id="2a83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个<code class="fe nb nc nd ne b">ScrollViewOffsetPreferenceKey.swift</code>文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8190" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进入<code class="fe nb nc nd ne b">reduce</code>时<code class="fe nb nc nd ne b">value</code>已经设定。为0的<code class="fe nb nc nd ne b">nextValue</code>需要加到<code class="fe nb nc nd ne b">value</code>上。这将导致密钥发送更新消息。</p><h1 id="f1d0" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">跟踪滚动视图偏移量</h1><p id="ceee" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">为了跟踪<code class="fe nb nc nd ne b">ScrollView</code>的偏移，需要向<code class="fe nb nc nd ne b">ScrollView</code>添加一个空视图。当偏移量改变时，它需要通知用户界面。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><ol class=""><li id="caf2" class="ml mm iq ky b kz la lc ld lf nk lj nl ln nm lr ms mt mu mv bi translated">添加一个名为scroll的坐标空间，以跟踪相对于滚动视图的位置。(第20行)</li><li id="a7c5" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">将<code class="fe nb nc nd ne b">LazyHStack</code>包裹在<code class="fe nb nc nd ne b">ZStack</code>中，这样视图可以在<code class="fe nb nc nd ne b">ScrollView</code>中分层。(第二行)</li><li id="3f14" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">在<code class="fe nb nc nd ne b">LazyHStack</code>的下面，增加了一个<code class="fe nb nc nd ne b">GeometryReader</code>，它有一个清晰的彩色视图。(第3-6行)</li><li id="95c8" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">每次重绘时，获取清晰视图相对于滚动(<code class="fe nb nc nd ne b">ScrollView</code>)坐标空间的位置，并将其存储在清晰视图的<code class="fe nb nc nd ne b">ScrollViewPreferenceKey</code>中。(第5-6行)</li><li id="1fa5" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">当在<code class="fe nb nc nd ne b">ScrollViewPreferenceKey</code>上设置值时，调用<code class="fe nb nc nd ne b">onPreferenceChange</code>修改器。该值是透明颜色视图的最新偏移量。(第24–26行)</li></ol><p id="23ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当应用程序运行时，滚动视图的偏移量可以随着图库的滑动而在调试控制台中改变。</p><h1 id="79ec" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">为什么会这样？</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/1707af6a2959c967d1950f636442e1ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lrKh6FgfAEGN1KOqa_LhWw.png"/></div></div></figure><p id="4414" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在滚动视图中，在<code class="fe nb nc nd ne b">0,0</code>创建了一个清晰的视图。当用户向左滑动时，框架将改变并变为负值。清晰视图的框架相对于滚动视图的框架。由于清晰视图位于滚动视图的原点，偏移将与<code class="fe nb nc nd ne b">UIScrollView.contentOffset</code>的结果匹配，但为负值。</p><h1 id="cbb4" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">颜色的延伸</h1><p id="df6f" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">从设计的角度来看，告诉一种颜色在它自己和另一种颜色之间进行插值是有意义的。因此，代码被放入<code class="fe nb nc nd ne b">UIColor</code>的扩展中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><ol class=""><li id="d235" class="ml mm iq ky b kz la lc ld lf nk lj nl ln nm lr ms mt mu mv bi translated"><code class="fe nb nc nd ne b">getComponents</code>是从<code class="fe nb nc nd ne b">UIColor</code>中获取颜色分量的辅助函数。代码支持RGBA或带有alpha的白色值。</li><li id="8c2f" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><code class="fe nb nc nd ne b">interpolate</code>函数返回源(自身)和目标颜色之间的颜色。</li></ol><p id="a59f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">计算采用源颜色的剩余值，并将其添加到下一页的颜色量中。例如，如果源颜色为<code class="fe nb nc nd ne b">red component = 1.0</code>，目标颜色为<code class="fe nb nc nd ne b">red component = 0.5</code>，滚动25%到下一页。计算如下:</p><pre class="kg kh ki kj gt no ne np nq aw nr bi"><span id="50ee" class="ns lu iq ne b gy nt nu l nv nw">newRed = (1.0–0.25) * 1.0 + 0.25 * 0.5</span><span id="5de3" class="ns lu iq ne b gy nx nu l nv nw">newRed = 0.76 * 1.0 + 0.25 * 0.5</span><span id="478d" class="ns lu iq ne b gy nx nu l nv nw">newRed = 0.76 + 0.125</span><span id="d140" class="ns lu iq ne b gy nx nu l nv nw">newRed = 0.885</span></pre><h1 id="7062" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">后台计算器</h1><p id="4615" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">后台计算器是奇迹发生的地方。它需要两件事才能起作用:</p><ol class=""><li id="965d" class="ml mm iq ky b kz la lc ld lf nk lj nl ln nm lr ms mt mu mv bi translated">视图的宽度。这是应用程序中的屏幕。</li><li id="183a" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">平均颜色阵列与图像的顺序相同。</li></ol><p id="4988" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">计算器将是一个可观察的对象，发布计算的背景颜色。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><ol class=""><li id="ec7b" class="ml mm iq ky b kz la lc ld lf nk lj nl ln nm lr ms mt mu mv bi translated"><code class="fe nb nc nd ne b">color</code>保存上次计算的背景色的发布者</li><li id="57b8" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><code class="fe nb nc nd ne b">width</code>我们视图的宽度，用于页码计算</li><li id="e6d0" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><code class="fe nb nc nd ne b">colors</code>平均颜色列表</li><li id="708f" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">当<code class="fe nb nc nd ne b">colors</code>被设置时，<code class="fe nb nc nd ne b">color</code>发布者被设置为<code class="fe nb nc nd ne b">colors</code>数组中的第一种颜色</li><li id="a89a" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><code class="fe nb nc nd ne b">calculateBackground(position:)</code>获取偏移量并计算当前背景颜色</li></ol><h1 id="198e" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">仔细看看<code class="fe nb nc nd ne b">calculateBackground(position:)</code></h1><p id="e21c" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">大多数神奇的事情都发生在<code class="fe nb nc nd ne b">calculateBackground(position:)</code>函数中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><ol class=""><li id="97af" class="ml mm iq ky b kz la lc ld lf nk lj nl ln nm lr ms mt mu mv bi translated"><code class="fe nb nc nd ne b">fractionalPage</code>将当前页面与页面之间的分数偏移。例如，0.5表示第0页和第1页之间的中点。</li><li id="412f" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><code class="fe nb nc nd ne b">page</code>从<code class="fe nb nc nd ne b">fractionalPage</code>双精度值创建一个整数。这将作为当前页面颜色的索引。</li><li id="f580" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><code class="fe nb nc nd ne b">fromColor</code>是当前页面的背景色。</li><li id="ad31" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">如果<code class="fe nb nc nd ne b">fractionalPage</code>在第一页和最后一页之间，计算新的背景颜色。如果没有，返回当前页面的颜色。例如，如果<code class="fe nb nc nd ne b">fractionalPage</code>为1.5，并且有两个页面，则在索引2处没有页面。这意味着不需要计算；背景将是当前页面的背景，即1。</li></ol><p id="eccd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要计算页面之间的颜色:</p><ol class=""><li id="fed4" class="ml mm iq ky b kz la lc ld lf nk lj nl ln nm lr ms mt mu mv bi translated">计算下一页</li><li id="24b5" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">得到页面之间的百分比，是<code class="fe nb nc nd ne b">fractionalPage</code>的小数部分。</li><li id="636b" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">调用<code class="fe nb nc nd ne b">interpolate</code>获取当前页面和下一页面之间的颜色。</li></ol><h1 id="dbd1" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">把所有的放在一起</h1><p id="8ef4" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">为了将这些放在一起，需要将三样东西添加到<code class="fe nb nc nd ne b">GalleryView</code>文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><ol class=""><li id="437a" class="ml mm iq ky b kz la lc ld lf nk lj nl ln nm lr ms mt mu mv bi translated">添加一个有状态的对象来保存<code class="fe nb nc nd ne b">BackgroundCalculator</code>的实例。随着计算器发布的颜色更新，视图将重新绘制。(第9行)</li><li id="75c9" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">将<code class="fe nb nc nd ne b">ScrollView</code>包裹在<code class="fe nb nc nd ne b">ZStack</code>中(第13行)</li><li id="bb05" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">在<code class="fe nb nc nd ne b">ScrollView</code>后面增加一个<code class="fe nb nc nd ne b">Rectangle</code>，其前景色是<code class="fe nb nc nd ne b">BackgroundCalculator</code>的计算色。(第14行)</li><li id="7dde" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">当<code class="fe nb nc nd ne b">ScrollViewOffsetPrefrenceKey</code>的值改变时，根据<code class="fe nb nc nd ne b">ScrollView</code>的当前位置计算新的背景颜色。新位置需要乘以-1。(第39行)</li><li id="e188" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">当<code class="fe nb nc nd ne b">GalleryView</code>出现时，需要将<code class="fe nb nc nd ne b">GalleryView</code>的宽度和平均颜色列表传递给<code class="fe nb nc nd ne b">BackgroundCalculator</code>。(第43–44行)</li></ol><p id="cad4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时运行项目将在图像后面显示一个彩色背景，在颜色之间平滑过渡。</p><h1 id="ee7f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="e1da" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">我喜欢这种转变。我认为它赋予了观点间无聊的转换以个性。我希望你也喜欢这个，并在你的应用中找到它的用处。完成的项目可以在<a class="ae kv" href="https://github.com/scottandrew/FadingScollerDemo.git" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="1b73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢这篇文章，请留下评论。</p></div></div>    
</body>
</html>