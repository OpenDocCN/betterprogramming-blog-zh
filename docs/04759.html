<html>
<head>
<title>The Complete Data Mining Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完整的数据挖掘管道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-complete-data-mining-pipeline-1f661e30d94f?source=collection_archive---------13-----------------------#2020-05-06">https://betterprogramming.pub/the-complete-data-mining-pipeline-1f661e30d94f?source=collection_archive---------13-----------------------#2020-05-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ff0b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从用Selenium抓取Twitter到用PostgreSQL存储数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/611a591909251e7d68717e54f19c9b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dl5tRRpbURUImJuo"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@cadop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马修·施瓦茨</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e4d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，我一直在思考情绪分析改善我们生活的潜力。我决定建立一个情绪分析模型，根据人们在社交媒体上的帖子来评估他们的心理健康状况。</p><p id="6b5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个想法以前肯定有人做过，但我想把它作为一个练习来做。我认为这是一个有用的模型，可以用在我未来的项目中。和任何其他机器学习项目一样，我首先需要的是数据。很多很多数据。</p><p id="a41f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">社交媒体每天都充斥着新帖子，但挑战在于如何获取所有这些数据。当然，你可以手动登录你喜欢的社交媒体，开始手动提取，在这个过程中投入大量时间。或者你可以<em class="ls">自动化</em>这个过程，利用这段时间做一些更有用的事情。永远不要低估懒惰的力量！</p><p id="cb90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我将带您了解如何通过使用<code class="fe lt lu lv lw b">Selenium</code>从互联网中提取数据并将其存储在数据库中，例如<code class="fe lt lu lv lw b">PostgreSQL</code>，来收集所有数据。本教程的各个部分是独立有用的:网页抓取部分可以独立于数据库使用。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="710f" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">创建虚拟环境</h1><p id="affa" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">如果您已经有了创建虚拟环境的方法，请跳过这一部分。我们将使用<code class="fe lt lu lv lw b">virtualenv</code>，但是如果您愿意，也可以随意使用<code class="fe lt lu lv lw b">anaconda</code> <strong class="ky ir"> </strong>。虚拟环境允许我们管理不同于Python项目的其他库。安装在虚拟环境中的库在其他任何地方都不可用，为了使用，它还必须安装在外部。</p><p id="acaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们确保安装了最新版本的<code class="fe lt lu lv lw b">pip</code>。运行以下命令:</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="9462" class="nf mf iq lw b gy ng nh l ni nj">$ <strong class="lw ir">python3 -m pip install --user -U pip<br/></strong>Collecting pip<br/>[...]<br/>Succesfully installed pip-20.0.2</span></pre><p id="6f82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们用下面的命令安装<code class="fe lt lu lv lw b">virtualenv</code>:</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="500d" class="nf mf iq lw b gy ng nh l ni nj">$ <strong class="lw ir">python3 -m pip install --user -U virtualenv<br/></strong>Collecting virtualenv<br/>[...]<br/>Succesfully installed virtualenv</span></pre><p id="6a7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前往您计划遵循本教程的文件夹，运行下一个命令来创建一个虚拟环境<strong class="ky ir"> </strong>，比如说，<code class="fe lt lu lv lw b">venv</code>:</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="b9a4" class="nf mf iq lw b gy ng nh l ni nj">$ <strong class="lw ir">virtualenv -p python3 venv</strong><br/>Running virtualenv with interpreter /usr/local/bin/python3<br/>[...]<br/>Installing setuptools, pip, wheel... done.</span></pre><p id="7f25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次计划使用环境时，都必须使用以下命令激活它:</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="976c" class="nf mf iq lw b gy ng nh l ni nj">$ <strong class="lw ir">source venv/bin/activate<br/></strong>(venv)$</span></pre><p id="47ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要停用:</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="619a" class="nf mf iq lw b gy ng nh l ni nj">(venv)$ <strong class="lw ir">deactivate</strong><br/>$</span></pre><p id="5235" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们已经建立并运行了虚拟环境，让我们开始讨论web抓取。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="2f2e" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">用硒刮网</h1><p id="82e1" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">对于本教程，我决定从我的twitter feed获取数据:发布推文的用户身份、发布日期、赞数、转发和回复次数以及推文本身的内容。Twitter有一个API，可以用来提取相同的信息，但不是任何人都可以使用它，因为它必须由Twitter授予您。并非互联网上的所有网站都有API，因此selenium将永远是一个强大的工具。</p><p id="d587" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是什么是<code class="fe lt lu lv lw b">selenium</code>？<code class="fe lt lu lv lw b">Selenium</code>自动化浏览器，就这么简单。我们可以使用<code class="fe lt lu lv lw b">selenium</code>来模仿我们并自动完成这项任务，而不必手动登录Twitter并浏览你订阅的所有推文。可以使用其他库，比如<code class="fe lt lu lv lw b">BeautifulSoup</code>，但是如果你需要模拟一个用户，你需要<code class="fe lt lu lv lw b">Selenium</code>。</p><p id="dcb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们继续之前，我们必须用下面的命令安装<code class="fe lt lu lv lw b">Selenium</code>库:</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="ae42" class="nf mf iq lw b gy ng nh l ni nj">(venv)$ <strong class="lw ir">pip install selenium<br/></strong>Collecting selenium<br/>[...]<br/>Succesfully installed selenium-3.141.0</span></pre><h2 id="a578" class="nf mf iq bd mg nk nl dn mk nm nn dp mo lf no np mq lj nq nr ms ln ns nt mu nu bi translated">安装ChromeDriver</h2><p id="0259" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">我们已经安装了selenium，但是我们需要为它配置selenium web驱动程序。我打算用谷歌Chrome，但selenium和Firefox一样好用。首先，我们需要找出我们使用的是哪个版本的Chrome。在您的搜索栏中键入以下内容:</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="25f2" class="nf mf iq lw b gy ng nh l ni nj">chrome://settings/help</span></pre><p id="1877" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该会看到您的Chrome版本:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/51c72296b19cb36c91a98344e45ae9d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HUB84LDLCwUa-vVXnnGvQw.png"/></div></div></figure><p id="c979" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们从<a class="ae kv" href="https://chromedriver.chromium.org/downloads" rel="noopener ugc nofollow" target="_blank">这里</a>下载相应的<code class="fe lt lu lv lw b">ChromeDriver</code>版本。因为我有版本81并且使用Linux，我将下载Linux的版本81。解压文件并存储在你喜欢的地方，最好是你的项目文件夹。或者，在Linux中，我建议将它存储在<code class="fe lt lu lv lw b">/usr/local/bin</code>中，你可以在解压文件后使用下面的命令:</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="309b" class="nf mf iq lw b gy ng nh l ni nj"><strong class="lw ir">$ mv ~/Downloads/chromedriver /usr/local/bin</strong></span></pre><h2 id="4249" class="nf mf iq bd mg nk nl dn mk nm nn dp mo lf no np mq lj nq nr ms ln ns nt mu nu bi translated">抓取Twitter</h2><p id="4bcb" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">在您的项目中，创建一个名为<code class="fe lt lu lv lw b">main.py</code>的Python文件，并添加这两个导入:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="3fa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们要创建一个名为<code class="fe lt lu lv lw b">TBot</code>的类，它包含了我们将要使用的所有逻辑和方法。首先，让我们创建构造函数来确保我们的<code class="fe lt lu lv lw b">selenium</code>安装是正确的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="09a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构造函数实例化了一个Chrome驱动程序，它本质上是一个Chrome选项卡，我们可以通过selenium来控制它。</p><p id="59b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用<code class="fe lt lu lv lw b">.get("<a class="ae kv" href="https://twitter.com/login" rel="noopener ugc nofollow" target="_blank">https://instagram.com</a>")</code>我们告诉我们的司机去Twitter的登录页面。我们添加了一个无限循环来无限期地停留在这个页面上。</p><p id="ce07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，通过在类外部键入<code class="fe lt lu lv lw b">TBot()</code>来创建一个新的<code class="fe lt lu lv lw b">TBot</code>实例，并使用以下命令执行该文件:</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="843f" class="nf mf iq lw b gy ng nh l ni nj">(venv)$ python main.py</span></pre><p id="fefa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应该会打开一个新的浏览器，显示Twitter的登录页面。</p><h2 id="73c5" class="nf mf iq bd mg nk nl dn mk nm nn dp mo lf no np mq lj nq nr ms ln ns nt mu nu bi translated">登录</h2><p id="6350" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">现在我们需要找到一种给定用户登录的方法。Selenium通过在网页中找到一个元素并与之交互来运行。</p><p id="02fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在web页面中定位元素有三种主要方式:通过ID、类或xpath。如果您不熟悉xpath或HTML的概念，我建议您阅读下面这篇由W3Schools<a class="ae kv" href="https://www.w3schools.com/xml/xpath_intro.asp" rel="noopener ugc nofollow" target="_blank">撰写的关于XPath的文章。但是对于本教程，您只需要知道xpath，顾名思义，是到一个元素的路径，在本例中，是Twitter的HTML代码。</a></p><p id="6a53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了登录，我们需要用户名和密码字段的ID或xpath <strong class="ky ir"> </strong>。一旦我们有了它们，我们可以告诉<code class="fe lt lu lv lw b">selenium</code>用相应的值填充每个字段。在之前打开的Twitter页面上点击右键，选择“检查”，或者按<strong class="ky ir"> Ctrl + Shift + I </strong>。你现在看到的是Twitter首页的HTML源代码！选择左上角HTML代码正上方的光标，并单击用户名字段。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/57a68f7dd7b1759959cdb6bf3617a04d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*fvdy51ISA_aCiqCNf1xyjA.png"/></div></figure><p id="dc2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将显示与您单击的元素相对应的HTML代码的确切部分。遗憾的是，我们看到无论是用户字段还是密码字段的HTML代码都没有ID <strong class="ky ir"> </strong>，所以我们必须通过xpath来定位这些元素。要获得任何HTML元素的xpath，只需右键单击它的HTML代码，然后<strong class="ky ir"> Copy &gt; Copy full XPath </strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/d5239d788c1b4c1d1d73ddc1aa109bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3q0QFJp9qPV8QHrUdcXFdA.png"/></div></div></figure><p id="28ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们知道了如何获得xpaths，让我们写一些代码吧！我们将创建一个登录函数，它接收两个参数，用户名和密码，找到它们各自的html输入字段并写入其中。为此，我们使用<code class="fe lt lu lv lw b">find_element_by_xpath()</code>来获取我们想要的web元素，并使用<code class="fe lt lu lv lw b">send_keys()</code>在其中写入一些文本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="78b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的代码应该是优雅的，完整的xpaths当然不是优雅的。出于这个原因，我选择制作一些更精细的xpaths来寻找<code class="fe lt lu lv lw b">username_input</code>、<code class="fe lt lu lv lw b">pswd_input</code>和<code class="fe lt lu lv lw b">login</code>。您可以使用您从浏览器中复制的xpaths它们会工作得很好——但是不要害怕使用我的xpaths并尝试理解它们是如何工作的！</p><p id="dfe4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过分析xpath to <code class="fe lt lu lv lw b">username_input</code>来了解它们是做什么的。首先，<code class="fe lt lu lv lw b">//</code>选择文档中符合以下描述的任意元素。在这种情况下，我们寻找一个<code class="fe lt lu lv lw b">input</code>元素，它的属性<code class="fe lt lu lv lw b">name</code>等于<code class="fe lt lu lv lw b">session[username_or_email]</code>。本质上，它实现了与我们可以从页面中复制的完整xpath相同的东西，但是这种方式看起来更好。</p><p id="97b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，在方法的开始有一个<code class="fe lt lu lv lw b">sleep()</code>函数。这将在我们指定的时间内暂停scraper的执行。这是非常有用的，因为在我们试图访问它们的任何元素之前，我们给了页面加载的时间。</p><p id="286b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您尝试访问页面的现有元素，并得到如下错误，请考虑增加等待页面的时间:</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="21d2" class="nf mf iq lw b gy ng nh l ni nj">selenium.common.exceptions.NoSuchElementException: Message: no such element: Unable to locate element:[...]</span></pre><p id="ce5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">增加您希望等待页面的时间，可以让页面在我们执行操作之前有机会完全加载。</p><p id="3761" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们在<code class="fe lt lu lv lw b">TBot</code>中有了<code class="fe lt lu lv lw b">__login</code>函数，让我们从构造函数中调用它。它应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="f9d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我强烈建议您将用户名和密码存储在另一个Python文件中。这样，您可以将您的用户名和密码导入到<code class="fe lt lu lv lw b">main.py</code>函数中，并在不显示其实际值的情况下使用它们。让我们看看它是否有效——用下面的命令运行您的<code class="fe lt lu lv lw b">main.py</code>,您应该会自动进入您的Twitter主页:</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="d4f8" class="nf mf iq lw b gy ng nh l ni nj">(venv)$ <strong class="lw ir">python main.py</strong></span></pre><h2 id="0cff" class="nf mf iq bd mg nk nl dn mk nm nn dp mo lf no np mq lj nq nr ms ln ns nt mu nu bi translated">提取我们迫切需要的数据</h2><p id="d801" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">现在到了有趣的部分，从我们的Twitter feed中提取所有相关信息。首先，我们需要制定一个如何进行的计划。慢慢来，检查页面的HTML，想出实现目标的最佳方法。</p><p id="57af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据我的经验，可能所有的tweets都有相同的HTML结构(在这种情况下是正确的——永远相信你的经验)。这允许我们编写代码从一条推文中获取信息，并在整个twitter feed中重用它。我们开始吧！</p><p id="8fb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe lt lu lv lw b">TBot</code>类内部创建以下方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="942e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意我们是如何将<code class="fe lt lu lv lw b">find_elements_by_xpath</code>的输出存储在<code class="fe lt lu lv lw b">tweets</code>中的，这意味着我们已经设法在一个xpath下捕获了所有的tweets。现在，我们遍历每条推文，提取其个人信息。反过来，每条tweet拥有相同的内部HTML结构，因此我们可以使用相同的函数来提取信息。</p><p id="791f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这种方法，我们不能只是复制和粘贴从浏览器中复制的xpath，因为每个tweet都有自己的xpath。我们需要能够概括我们在文档中定位tweets的方法，因此需要创建我们自己的xpath。</p><p id="22ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我对这个解决方案不是很满意。对于评论、转发和赞，它不获取实际的数字，只获取表示它的字符串。例如，1.9K是一个字符串，而1900是一个实际数字，我们可以这样计算。为了解决这个问题，我创建了以下方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0a87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该方法检查<code class="fe lt lu lv lw b">data</code>是否包含代表千位的<code class="fe lt lu lv lw b">K</code>或代表百万位的<code class="fe lt lu lv lw b">M</code>，然后删除它，将<code class="fe lt lu lv lw b">data</code>转换为十进制数，并将其乘以各自的数量。因为看到有人得到1900.0的转发不太好，所以最后把<code class="fe lt lu lv lw b">data</code>变成了整数。</p><p id="d25c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe lt lu lv lw b">__scrap_tweets</code>中实现这个方法相当简单，我们只需要为评论、转发和喜欢的值调用它，并捕获输出值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="a2cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，剩下要做的就是从构造函数中调用方法，现在应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="25f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们检查一下它是否与<code class="fe lt lu lv lw b">(venv)$ python main.py</code>一起工作。现在，您应该可以看到您的整个Twitter feed，后面跟有这条漂亮的错误消息:</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="38c5" class="nf mf iq lw b gy ng nh l ni nj">selenium.common.exceptions.StaleElementReferenceException: Message: stale element reference: element is not attached to the page document</span></pre><p id="edf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你碰巧避免了这个错误，你仍然应该仔细听。当我们将Twitter feed中的所有推文加载到<code class="fe lt lu lv lw b">tweets</code>中时，最后一条推文实际上并没有显示在页面上。因此，当我们试图访问他们的数据时，Python会感到困惑并停止执行。为了避免这个问题，我们需要在每次出错时向下滚动，这样新的tweets就会加载到页面中。让我们创建一个滚动方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="bd89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要将<code class="fe lt lu lv lw b">__scrap_tweets</code>中的代码包装在<code class="fe lt lu lv lw b">try/except</code>中，并调用<code class="fe lt lu lv lw b">except</code>部分中的<code class="fe lt lu lv lw b">__scroll</code>方法。它应该看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="20f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，当我们可以无限向下滚动时，我们不想只从初始提要中获取数据。我们将在<code class="fe lt lu lv lw b">TBot</code>构造函数的无限循环中定期调用<code class="fe lt lu lv lw b">__scrap_tweets</code>，结果如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="4c33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你运行<code class="fe lt lu lv lw b">(venv)$ <strong class="ky ir">python main.py</strong></code> <strong class="ky ir"> </strong>时，你的终端应该会被来自你的feed的无休止的tweets淹没。</p><p id="dd5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们不想将它们存储在终端的输出日志中，不是吗？我们希望将它们存储在某个我们需要时可以提取的地方:数据库中。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="f23c" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">在PostgreSQL中存储数据</h1><p id="e8fa" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">在数据库中存储数据非常有用。以我们刚刚构建的Twitter scraper为例，它使我们能够多次运行它，并将所有数据存储在完全相同的位置。更好的是，我们可以同时运行Twitter bot的几个实例(使用不同的帐户)，并将所有这些推文存储在我们的数据库中。此外，下载CSV格式的数据库内容非常容易，这对于机器学习来说是非常好的。但是首先，我们需要一个数据库。</p><h2 id="1625" class="nf mf iq bd mg nk nl dn mk nm nn dp mo lf no np mq lj nq nr ms ln ns nt mu nu bi translated">设置PostgreSQL</h2><p id="cc81" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">虽然你当然可以在你的本地机器上做这个，但是我推荐你在Heroku上自由地创建它。</p><ul class=""><li id="59ef" class="oa ob iq ky b kz la lc ld lf oc lj od ln oe lr of og oh oi bi translated">如果您还没有帐户，请前往<a class="ae kv" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank">https://www.heroku.com/</a>创建一个帐户。</li><li id="7318" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated">在Heroku的仪表盘上，点击“新建”并选择“创建新应用”命名您的应用程序，然后单击“创建应用程序”</li><li id="a26b" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated">在应用的“概述”页面上，单击“配置加载项”按钮。在页面的“附件”部分，输入并选择“Heroku Postgres”</li><li id="a4e2" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated">选择“Hobby Dev-Free”计划，该计划将为您提供一个支持多达10，000行数据的免费PostgreSQL数据库。</li><li id="7bdb" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated">点击“供应”</li><li id="9377" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated">现在点击“Heroku Postgres”进入你的数据库概述页面。在那里，点击设置&gt;查看凭证。这是您登录数据库所需的信息。您可以通过<a class="ae kv" href="https://adminer.cs50.net/" rel="noopener ugc nofollow" target="_blank"> Adminer </a>或<a class="ae kv" href="https://www.jetbrains.com/es-es/datagrip/" rel="noopener ugc nofollow" target="_blank"> DataGrip </a>填写所有需要的凭证。</li></ul><p id="e611" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要在我们的计算机上安装一些库，这样我们就可以用Python连接到我们的数据库。我们首先需要的是<code class="fe lt lu lv lw b">libpq-dev</code>包，在Linux上可以用下面的命令安装它:</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="1904" class="nf mf iq lw b gy ng nh l ni nj">$ sudo apt-get install libpq-dev</span></pre><p id="e2a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你是Windows，你必须在本地安装<code class="fe lt lu lv lw b"><a class="ae kv" href="https://www.postgresql.org/download/" rel="noopener ugc nofollow" target="_blank">PostgreSQL</a></code>。一旦解决了这个问题，让我们安装我们需要的Python库:<code class="fe lt lu lv lw b">SQLAlchemy</code>和<code class="fe lt lu lv lw b">psycopg2</code>:</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="f7b2" class="nf mf iq lw b gy ng nh l ni nj">(venv)$ <strong class="lw ir">pip install sqlalchemy</strong><br/>Collecting sqlalchemy<br/>[...]<br/>Succesfully installed sqlalchemy-1.3.16</span><span id="fdd2" class="nf mf iq lw b gy oo nh l ni nj">(venv)$ <strong class="lw ir">pip install psycopg2<br/></strong>Collecting psycopg2<br/>[...]<br/>Succesfully installed psycopg2-2.8.5</span></pre><h2 id="ed6f" class="nf mf iq bd mg nk nl dn mk nm nn dp mo lf no np mq lj nq nr ms ln ns nt mu nu bi translated">对象关系映射</h2><p id="2fb2" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">对象关系映射(ORM)是将面向对象编程语言中的类与数据库中的关系或表相关联的能力。这意味着我们不必通过SQL创建我们的tweets数据库表，我们可以用Python来做。我们不打算使用任何SQL，因为多亏了<code class="fe lt lu lv lw b">sqlalchemy</code> <strong class="ky ir">，我们想要的一切都可以通过Python来完成。</strong></p><p id="4662" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先创建一个名为<code class="fe lt lu lv lw b">bd.py</code>的文件，它将负责所有与数据库相关的事情。让我们添加我们需要的所有导入:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0fc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们用下面几行建立与数据库的连接:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="e3d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中<code class="fe lt lu lv lw b">"YOUR URI"</code>应该是在Heroku的数据库凭证中找到的。</p><p id="1578" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要创建一个对象来关联数据库中的一个表。幸运的是，我们可以创建这个对象，<code class="fe lt lu lv lw b">sqlalchemy</code>将创建与之相关的相应的表。</p><p id="e7a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们想存储tweets，所以让我们用它们来命名我们的对象。类<code class="fe lt lu lv lw b">Tweet</code>必须包含我们希望存储在数据库中的所有字段，并且必须以特定的方式声明:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="12d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们的类<code class="fe lt lu lv lw b">Tweet</code>是从我们之前定义的<code class="fe lt lu lv lw b">Base</code>扩展而来的。我们必须将<code class="fe lt lu lv lw b">__tablename__</code>设置为我们希望数据库中的表拥有的名称。然后，我们必须指定我们希望表拥有的所有列(属性)以及它们的数据类型(<code class="fe lt lu lv lw b">String</code>、<code class="fe lt lu lv lw b">Integer</code>)。</p><p id="d79b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经定义了我们的类<code class="fe lt lu lv lw b">Tweet</code>，让我们在数据库中创建它对应的表。在<code class="fe lt lu lv lw b">db.py</code>的末尾增加以下几行:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="f364" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，表<code class="fe lt lu lv lw b">tweets</code>只会在我们运行<code class="fe lt lu lv lw b">db.py</code>时创建，而不是在我们导入这个文件时创建。让我们运行<code class="fe lt lu lv lw b">db.py</code>来创建我们的<code class="fe lt lu lv lw b">tweets</code>表:</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="6a8f" class="nf mf iq lw b gy ng nh l ni nj">(venv)$ <strong class="lw ir">python db.py<br/></strong>[...]<br/>CREATE TABLE tweets (<br/>    id SERIAL NOT NULL, <br/>    username VARCHAR, <br/>    date VARCHAR, <br/>    likes INTEGER, <br/>    retweets INTEGER, <br/>    comments INTEGER, <br/>    text VARCHAR, <br/>    PRIMARY KEY (id)<br/>)<br/>[...]<br/>Process finished with exit code 0</span></pre><p id="9da8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您在终端上看到这个输出，那么一切正常。这是在我们的数据库上运行的SQL代码，用于基于<code class="fe lt lu lv lw b">Tweet</code>类创建我们想要的表。</p><p id="977d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要一个方法将我们的<code class="fe lt lu lv lw b">Tweet</code>对象添加到我们的数据库中。姑且称之为<code class="fe lt lu lv lw b">add</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="a66b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该方法首先创建一个会话，然后添加调用该方法的对象(<code class="fe lt lu lv lw b">self</code>)并提交操作。它通过关闭会话来结束，以避免任何问题。</p><p id="7add" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！剩下唯一要做的就是从<code class="fe lt lu lv lw b">main.py</code>调用这个函数——更准确地说，是从<code class="fe lt lu lv lw b">TBot</code>的方法<code class="fe lt lu lv lw b">__scrap_tweets</code>中调用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="db8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们用两行代码替换了前面的代码，一行用于创建带有相应属性的<code class="fe lt lu lv lw b">Tweet</code>对象，另一行用于调用它的<code class="fe lt lu lv lw b">add</code>方法。让我们试一试，看看它是否有效。再一次，运行<code class="fe lt lu lv lw b">(venv)$ <strong class="ky ir">python main.py</strong></code> <strong class="ky ir"> </strong>并转到<a class="ae kv" href="https://adminer.cs50.net/" rel="noopener ugc nofollow" target="_blank"> Adminer </a>，或任何你用来可视化你的数据的服务，并检查你的推文确实被存储在那里。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="6693" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">最后的想法</h1><p id="3f66" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated"><code class="fe lt lu lv lw b">Selenium</code>和带<code class="fe lt lu lv lw b">SQLAlchemy</code>的<code class="fe lt lu lv lw b"> ORM</code>是强大的工具，可以节省你大量的时间，极大地促进数据挖掘过程。我希望这篇教程可以作为这两项漂亮技术的起点。</p><p id="8637" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一如既往，如果需要，请随时联系我。本教程中的所有代码都可以在GitHub中免费获得。</p><div class="op oq gp gr or os"><a href="https://github.com/PaburoTC/TwitterScrapper" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">PaburoTC/TwitterScrapper</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">在GitHub上创建一个帐户，为PaburoTC/TwitterScrapper的开发做出贡献。</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">github.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg kp os"/></div></div></a></div><p id="fd42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快乐数据挖掘！</p><p id="8ca8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谢谢你</p></div></div>    
</body>
</html>