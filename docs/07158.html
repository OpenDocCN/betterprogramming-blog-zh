<html>
<head>
<title>The Power of Promise.all() in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中Promise.all()的力量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-of-promise-all-in-javascript-84a4da1751f0?source=collection_archive---------10-----------------------#2020-12-11">https://betterprogramming.pub/the-power-of-promise-all-in-javascript-84a4da1751f0?source=collection_archive---------10-----------------------#2020-12-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="550c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过激动人心的使用案例了解有前途的功能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ad35b34a27eb5a3072601be2d2c824f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AOq_JohnhXG1Z1sFR2JPeA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@belart84?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Artem Beliaikin </a>在<a class="ae kv" href="https://unsplash.com/s/photos/lock-bridge?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="50ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文不是关于承诺、<code class="fe ls lt lu lv b">async/await</code>或者Javascript的单线程特性。这是关于<code class="fe ls lt lu lv b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank">Promise.all()</a></code>功能，以及如何将你独立运行的功能或任务组合在一起，形成一个美丽的结果。</p><p id="58d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常情况下，一个例子或用例将被证明是有用的。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="0582" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">用例:发布到多个社交媒体网络</h1><p id="948e" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们的应用程序<a class="ae kv" href="https://www.ayrshare.com" rel="noopener ugc nofollow" target="_blank"> Ayrshare </a>的主要目的是提供一个跨多个社交媒体网络发布的API，如Twitter、Instagram、脸书和LinkedIn。</p><p id="9733" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用户将使用文章文本、图像和发送文章的网络列表进行API调用(RESTful或通过客户端包)。API以结果数组的形式返回每个网络的成功或错误结果。</p><p id="638d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这背后是复杂的。</p><p id="33b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个网络都有自己的授权、工作流程和安全要求。例如，如果您在帖子上附加了一张图片，Twitter会要求您首先上传图片，等待图片处理完成，然后在新的更新状态调用中将返回的媒体ID发送给Twitter。时间各不相同，有些网络可能会出错，有些则不会，而且新的网络一直在增加。但从最终用户的角度来看，他们发送了帖子，结果会立即返回。</p><p id="c863" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个视觉(<a class="ae kv" href="https://www.ayrshare.com/our-firebase-tech-stack/" rel="noopener ugc nofollow" target="_blank"> Firebase技术堆栈概述</a>):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/7e3d95cc3d79d4536cd865d3fa9a6841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D0PThMYY0KGba792Vt0jbw.png"/></div></div></figure><p id="d55a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望并行运行所有网络帖子，并收集结果返回给调用者。随着网络数量的增加，我们最好不要超过最长的网络。</p><p id="4067" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们面临的问题是，如果每个网络函数调用都是异步的，那么每个函数将在不同的时间完成，我们将无法在一个响应中返回结果。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="53cb" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">Promise.all()来救援</h1><p id="8c54" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">如果你有类似的问题，<code class="fe ls lt lu lv b">Promise.all()</code>就是你的解决方案。</p><blockquote class="nb"><p id="b356" class="nc nd iq bd ne nf ng nh ni nj nk lr dk translated">Promise.all()方法将承诺的iterable作为输入，并返回一个解析为输入承诺结果数组的single— <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="e104" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">换句话说，如果您调用几个异步函数，您可以等到它们都解析并在数组中捕获它们的输出。</p><p id="105d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一个简单的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d335" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">printSquare</code>迭代整数和平方的数组。调用<code class="fe ls lt lu lv b">getSquare</code>返回一个承诺，因为我们通过添加关键字<code class="fe ls lt lu lv b">async</code>使它成为一个异步函数。从技术上讲，我们不需要异步，因为<code class="fe ls lt lu lv b">Math.pow</code>函数是同步的。</p><p id="131b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">promiseArray</code>是一系列等待解决的承诺。当我们打印出<code class="fe ls lt lu lv b">promiseArray</code>时:</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="550e" class="nw me iq lv b gy nx ny l nz oa">[ <br/>  Promise { 1 }, <br/>  Promise { 4 }, <br/>  Promise { 9 }, <br/>  Promise { 16 }, <br/>  Promise { 25 } <br/>]</span></pre><p id="9ca5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很接近，但是那些“承诺”是什么？如上所述，数组是由等待解决的承诺组成的。使用<code class="fe ls lt lu lv b">Promise.all()</code>可以轻松解决这些问题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="64d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果是:</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="b4ca" class="nw me iq lv b gy nx ny l nz oa">[ 1, 4, 9, 16, 25 ]</span></pre><p id="08b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完美！此外，结果的顺序保持不变。</p><p id="971e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们需要对<code class="fe ls lt lu lv b">Promise.all()</code>执行<code class="fe ls lt lu lv b">await</code>，因为它返回了一个需要解决的承诺。</p><p id="2d43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于那些好奇的人来说，这里有一个真实的例子，艾尔莎的代码发布到所有的网络:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="0546" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">最后的想法</h1><p id="0823" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">通常，<code class="fe ls lt lu lv b">Promise.all()</code>被认为是并行运行的，但事实并非如此。</p><p id="45cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“并行”意味着你在多个线程上同时做许多事情。然而，JavaScript是单线程的，只有一个调用堆栈和一个内存堆。它是一种<a class="ae kv" href="https://theflyingmantis.medium.com/javascript-single-threaded-non-blocking-asynchronous-concurrent-language-ffae97c57bef" rel="noopener">异步</a>，非阻塞语言。这意味着JavaScript不是并行运行的，而是一次只运行一个函数/承诺。如果单个线程必须等待某个东西，比如HTTP调用的返回，它将继续执行另一个函数，直到返回完成。</p><p id="159a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的承诺数组中，每个承诺将一次处理一个，但是如果处理需要等待，JavaScript将在每个承诺之间切换。虽然<code class="fe ls lt lu lv b">Promise.all()</code>中的承诺解析顺序会因阻塞而异，但最终结果将是一个有序结果数组。</p></div></div>    
</body>
</html>