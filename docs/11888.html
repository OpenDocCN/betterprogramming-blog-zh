<html>
<head>
<title>Moving SwiftUI Views and Models Into Separate Swift Packages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将SwiftUI视图和模型转移到单独的Swift包中</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/moving-swiftui-views-and-models-into-separate-swift-packages-4319acdd8827?source=collection_archive---------5-----------------------#2022-04-25">https://betterprogramming.pub/moving-swiftui-views-and-models-into-separate-swift-packages-4319acdd8827?source=collection_archive---------5-----------------------#2022-04-25</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="d6b6" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">编写模块化代码</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/4c5b15c220bb463e8234264f5838e538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XyGYwC1mfoxgXecl8rUk9g.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片由<a class="ae kz" href="https://pixabay.com/users/mediamodifier-1567646/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5766346" rel="noopener ugc nofollow" target="_blank"> Mediamodifier </a>从<a class="ae kz" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5766346" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>获得</p></figure><p id="8667" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Swift包是将我们的代码分成可以跨多个项目使用的模块的好方法。</p><p id="b9dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是在SwiftUI中使用它们的简单指南，但是任何Swift代码都可以这样分发。</p><h1 id="b3f9" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">创建MyViews包</h1><p id="8132" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">打开Xcode并点击<em class="mt">文件&gt;新建&gt;包… </em>或者按Command、Control、Shift和n。为这个项目创建一个新文件夹很有用，当你决定要将文件放在哪里时，你可以使用<em class="mt">新建文件夹</em>按钮来完成。我把我的新文件夹命名为<code class="fe mu mv mw mx b">PackagesExample</code>，但是名字并不重要。调用您的包<code class="fe mu mv mw mx b">MyViews</code>并确保它没有被添加到任何项目或工作区中。</p><p id="9231" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您的包中的<em class="mt"> Sources </em>文件夹将为每个目标拥有单独的文件夹。</p><p id="cba1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">创建两个包含Swift文件的新文件夹，如下所示:</p><ul class=""><li id="2965" class="my mz iu lc b ld le lg lh lj na ln nb lr nc lv nd ne nf ng bi translated"><code class="fe mu mv mw mx b">MyViews/Sources/MyViews/MyViews.swift</code></li><li id="5010" class="my mz iu lc b ld nh lg ni lj nj ln nk lr nl lv nd ne nf ng bi translated"><code class="fe mu mv mw mx b">MyViews/Sources/HelloButton/HelloButton.swift</code></li></ul><p id="84fe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">打开<code class="fe mu mv mw mx b">HelloButton.swift</code>，加上这个:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="0475" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是一个简单的按钮，在其初始化器中采取行动，就像普通的SwiftUI <code class="fe mu mv mw mx b">Button</code>一样。注意，所有东西都被声明为公共的，因为我们希望能够在包模块之外引用这些东西。</p><p id="b6bb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们要写<code class="fe mu mv mw mx b">MyViews</code>，看起来非常相似:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="1d72" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可能想知道为什么我在两个地方添加了完全相同的代码。</p><p id="7c6d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">原因是为了证明您在Swift套餐方面确实有两种选择。</p><p id="eb48" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它可以仅用于<code class="fe mu mv mw mx b">import HelloButton</code>，或用于<code class="fe mu mv mw mx b">import MyViews</code>并通过<code class="fe mu mv mw mx b">MyViews.HelloButton</code>引用。</p><p id="2bc5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通常，我会决定我们希望用哪种方式构建包。要么我想要一个内部有类似于<code class="fe mu mv mw mx b">HelloButton</code>的类型的主目标，要么我想要为所有东西创建一个单独的目标。这两种方法都有好处。</p><p id="8c1c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有了一个大模块，我可以一次导入许多东西，但也许我不想用一个import语句访问所有东西。</p><p id="e18a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们需要在<code class="fe mu mv mw mx b">Package.swift</code>文件中指定所有的目标和依赖项，这个文件应该是在您创建包时创建的。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><h1 id="2fe4" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">创建MyModels包</h1><p id="b5c4" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">现在我们将为我们的视图模型创建一个包，我们将做同样的事情。</p><p id="d9d7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">可能只有<code class="fe mu mv mw mx b">import ContentViewModel</code>或<code class="fe mu mv mw mx b">import</code>和<code class="fe mu mv mw mx b">MyModels</code>被<code class="fe mu mv mw mx b">MyModels.ContentViewModel</code>引用。</p><p id="de20" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">打开Xcode点击<em class="mt">文件&gt;新建&gt;包……</em>或者按<em class="mt">命令、控制、Shift和N </em>。调用您的包<code class="fe mu mv mw mx b">MyModels</code>并确保它没有被添加到任何项目或工作区中。</p><p id="1eeb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您的包中的<em class="mt"> Sources </em>文件夹将为每个目标创建单独的文件夹。</p><p id="0f23" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">创建两个包含Swift文件的新文件夹，如下所示:</p><ul class=""><li id="906f" class="my mz iu lc b ld le lg lh lj na ln nb lr nc lv nd ne nf ng bi translated"><code class="fe mu mv mw mx b">MyModels/Sources/MyModels/MyModels.swift</code></li><li id="5b47" class="my mz iu lc b ld nh lg ni lj nj ln nk lr nl lv nd ne nf ng bi translated"><code class="fe mu mv mw mx b">MyModels/Sources/ContentViewModel/ContentViewModel.swift</code></li></ul><p id="15e2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">打开<code class="fe mu mv mw mx b">ContentViewModel.swift</code>并添加以下内容:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="3add" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是相当简单的代码，带有一个迭代计算按下<code class="fe mu mv mw mx b">HelloButton</code>的次数的函数。</p><p id="4145" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe mu mv mw mx b">MyModels.swift</code>不出所料是这样的:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="ac52" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样，我们需要在<code class="fe mu mv mw mx b">Package.swift</code>文件中指定所有的目标和依赖项，这个文件应该是在您创建包时创建的。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><h1 id="6384" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">将这一切结合在一起</h1><p id="f427" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">那么我们将如何使用这些包呢？在同一个根文件夹中创建一个新的app项目，作为两个名为anywhere you want的包。我把我的叫做<code class="fe mu mv mw mx b">PackagesExample</code>，和我的根文件夹一样，但是名字不重要。接下来，您需要添加您创建的包，方法是转到<em class="mt">文件&gt;添加包… </em>并点击窗口底部的<em class="mt">添加本地… </em>按钮。</p><p id="17dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">添加<code class="fe mu mv mw mx b">MyViews</code>和<code class="fe mu mv mw mx b">MyModels</code>包并不会将它们完全添加到您的项目中。</p><p id="f4a7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我发现在将包模块添加到目标的框架、库和general选项卡上的嵌入内容之前，我无法导入包模块:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj no"><img src="../Images/bae6bde0a8bb4cc5d3b684945deaa6b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8-2kAn0yrn4kQR4u.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图像由罗布·斯特金拍摄</p></figure><p id="462b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们终于可以在<code class="fe mu mv mw mx b">ContentView.swift</code>中整合UI了:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="3df0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是一个简单的<code class="fe mu mv mw mx b">VStack</code>,每个<code class="fe mu mv mw mx b">HelloButton</code>下面有一个<code class="fe mu mv mw mx b">Text</code>,显示它被点击或点击的次数。</p><p id="4753" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了让事情变得有趣，我用两种方法创建了按钮，一种是传递对函数的直接引用，另一种是传递一个尾随闭包，在这个闭包中我调用了函数。</p><p id="55f4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">两种方式都适用于任一按钮，因为它们的代码是相同的。</p><p id="6877" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我已经包含了<code class="fe mu mv mw mx b">ContentViewModel</code>和<code class="fe mu mv mw mx b">MyModel.ContentViewModel</code>，但是实际上您可能已经决定了在您的包中是包含通用模块还是更具体的模块。</p><p id="ccac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您不想为您的包使用远程存储库，您可以就此打住！</p><h1 id="0736" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">创建和发布GitHub库</h1><p id="50f9" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">使本地包远程化的最简单的方法是为它们创建GitHub存储库。</p><p id="f5f0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你是使用GitHub CLI的人，你可能已经知道如何做到这一点，但我将使用GitHub桌面应用<a class="ae kz" href="https://desktop.github.com/" rel="noopener ugc nofollow" target="_blank">因为我非常喜欢图形用户界面。</a></p><p id="e1f7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当GitHub桌面安装并打开后，按command + O并浏览到<code class="fe mu mv mw mx b">MyViews</code>或<code class="fe mu mv mw mx b">MyModels</code>包。您可能会得到消息“这个目录似乎不是一个Git存储库。是否要在这里创建一个存储库？”</p><p id="617b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">点击链接<em class="mt">创建一个存储库</em>，如果需要，将git ignore改为Swift，保留所有其他字段的默认值。</p><p id="ea19" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您没有得到那个消息，那么继续添加存储库。</p><p id="31bf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">作为创建存储库的一部分，GitHub Desktop已经用代码的当前状态创建了一个初始提交。如果您在此之后进行了任何更改，您需要在此处提交它们。如果您对包的当前状态满意，单击右边的<em class="mt">发布库</em>按钮。</p><p id="9426" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在GitHub 按钮上应该有一个<em class="mt">视图，靠近<em class="mt">发布库</em>按钮的位置。点击这个，你会被带到GitHub网站。</em></p><p id="874d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">复制URL并返回到<code class="fe mu mv mw mx b">PackagesExample</code>，或者任何你称之为你的应用程序项目的地方。</p><h1 id="1de2" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">用远程包替换本地包</h1><p id="19d5" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">在文件检查器中右键单击或按住control键单击您刚刚上传的包，并选择<em class="mt">删除</em>，但选择<em class="mt">移除引用</em>而不是<em class="mt">移至回收站</em>！</p><p id="5907" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在您的Swift包的本地版本已被移除，转到<em class="mt">文件&gt;添加包… </em>，并将您从包的GitHub复制的URL粘贴到右上角的搜索框中。如果一切顺利，您应该能够添加包，并且项目应该仍然可以构建，因为它有正确的模块。</p><p id="1200" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对另一个包重复我们到目前为止所做的一切，这样您的项目中就有两个远程包，而没有本地包。</p><h1 id="03f4" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">有什么区别吗？</h1><p id="bbf4" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">您可能会注意到，程序包相关性列表中的文件是不可编辑的。这是因为它们的版本现在由GitHub库控制，这提供了包的主要优势之一。</p><p id="6e97" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果不能编辑这些包，我们可以确保不修改不属于特定项目的代码。</p><p id="ea4f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是因为这些是我们的包，我们希望能够偶尔编辑它们。Xcode仍然可以打开一个包，但这不会给我们完整的故事，因为我们的视图和模型是分开的。</p><p id="dc94" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">到目前为止，如果我想编辑一个远程包，最简单的方法就是进入<em class="mt">文件&gt;添加包… </em>，点击<em class="mt">添加本地… </em>，然后像我最初创建它们时一样添加它们。</p><p id="01f3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">据苹果公司称，本地包总是覆盖远程包。这意味着，无论远程存储库发生什么变化，都将始终使用本地存在的模块版本。</p><p id="9588" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这意味着远程存储库也不会改变以匹配本地存储库，因此您仍然需要使用GitHub Desktop(或者您通常使用的源代码控制)提交和推送您的更改。</p><p id="6443" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当您不再对本地包进行更改时，再次选择<em class="mt">移除引用</em>。</p><p id="6485" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这将确保您回到使用远程存在的版本，允许您检查您提交的内容是否被成功推送。</p></div></div>    
</body>
</html>