<html>
<head>
<title>Setting Up Mocks for React Development, Storybook, and Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为React开发、故事书和测试设置模拟</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/setting-up-mocks-for-react-development-storybook-and-testing-8f5cedb66257?source=collection_archive---------6-----------------------#2021-09-14">https://betterprogramming.pub/setting-up-mocks-for-react-development-storybook-and-testing-8f5cedb66257?source=collection_archive---------6-----------------------#2021-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ef8a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">fetch-mock JavaScript库简介</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/34f3c9c82aacafb8d88e8d24bf0cb5b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oHRgW5m9GKxFs5is"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6fee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">web应用程序是运行在web服务器上的软件，用户可以通过web浏览器访问它。用户界面(UI)提供了一个执行一系列操作的环境，例如查看购物清单或者在购物车中添加或删除商品。</p><p id="7bd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于UI是一个触觉和视觉组件，业务逻辑由后端支持。对于UI来说，使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/fetch" rel="noopener ugc nofollow" target="_blank">fetch</a></code>、<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank">axios</a></code>或<a class="ae ky" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>等进行异步调用是很典型的。</p><p id="ef1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在UI开发期间，后端可能暂时不可用。模仿API来与API并行工作将是一个很好的方法。</p><p id="5618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/wheresrhys/fetch-mock" rel="noopener ugc nofollow" target="_blank">fetch-mock</a></code>是一种模仿用<code class="fe lv lw lx ly b">fetch</code>发出的HTTP请求的流行方式。我们发现使用mock进行UI开发、故事书和测试是有效的。</p><p id="3b57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">fetch-mock</code>支持大多数JavaScript环境，包括<a class="ae ky" href="https://levelup.gitconnected.com/think-and-write-javascript-with-nodejs-88ce9e728eb8" rel="noopener ugc nofollow" target="_blank"> Node.js </a>，web workers，service workers，以及任何支持<code class="fe lv lw lx ly b">fetch</code>的浏览器。在本文中，我们以React为例，探索它模拟CRUD操作的能力。</p><h1 id="c4e3" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">CRUD操作的HTTP方法</h1><p id="2cd4" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">CRUD是实现RESTful服务所必需的四种操作的缩写:创建、读取、更新和删除。<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/whats-new-in-http-3-10c2455a4f8c"> HTTP </a>支持多种CRUD操作方法。这些是常用的方法:</p><ul class=""><li id="b00c" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">GET:这是一个读取操作，用于检索资源的表示。比如:<code class="fe lv lw lx ly b">GET http://myserver.com/v2/users</code>。如果操作成功，GET返回一个XML或JSON形式的表示，状态代码为200 (OK)。在出错的情况下，它会返回一个错误代码，比如401(未授权)、403(禁止)等。</li><li id="a0d6" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">POST:它通常是用于创建新资源的创建操作。比如:<code class="fe lv lw lx ly b">POST http://myserver.com/v2/user</code>。如果操作成功，POST返回创建内容，状态码为201(已创建)。在出错的情况下，它会返回一个错误代码，如409(冲突)、500(内部服务器错误)等。</li><li id="3765" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">PUT:它通常是用于更新资源的更新操作。例如:<code class="fe lv lw lx ly b">PUT http://myserver.com/v2/user</code>。如果操作成功，PUT将返回状态代码为200 (OK)的更新内容，或者状态代码为204 (No Content)的无内容。在出错的情况下，它会返回一个错误代码，比如405(不允许使用方法)、501(未实现)等。建议让PUT请求幂等。</li><li id="7ca3" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">删除:这是用于删除资源的删除操作。比如:<code class="fe lv lw lx ly b">DELETE http://myserver.com/v2/user/:userId</code>。如果操作成功，DELETE将返回状态代码为200 (OK)的已删除内容，或者返回状态代码为204 (No Content)的无内容。在出错的情况下，它会返回一个错误代码，比如404(未找到)、410(已消失)等。</li></ul><h1 id="1779" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">建立反应工作环境</h1><p id="d203" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">安装<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/upgrade-create-react-app-based-projects-to-version-4-cra-4-d7962aee11a6"> Create React App </a>:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="7130" class="no ma it ly b gy np nq l nr ns">npx create-react-app react-mock<br/>cd react-mock</span></pre><p id="ea17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行以下命令:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="0c76" class="no ma it ly b gy np nq l nr ns">npm install --save-dev fetch-mock</span></pre><p id="fc95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">fetch-mock</code>作为<code class="fe lv lw lx ly b">package.json</code>中的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/package-jsons-dependencies-in-depth-a1f0637a3129"> devDependencies </a>安装:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="c79e" class="no ma it ly b gy np nq l nr ns">"devDependencies": {<br/>  "fetch-mock": "^9.11.0"<br/>}</span></pre><p id="2be7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们修改<code class="fe lv lw lx ly b">src/App.js</code>如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3f3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码在端点<code class="fe lv lw lx ly b">/v2/users</code>(第6–11行)获取一个用户列表，并在浏览器上显示它(第13行)。</p><p id="b58f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以工作，除了端点还在构建中。</p><h1 id="157e" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">模拟CRUD操作</h1><p id="aa0b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如果端点不可用，我们可以模拟GET方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="fdf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2号线进口<code class="fe lv lw lx ly b">fetchMock</code>。</p><p id="5a96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第5–7行定义了模拟函数<code class="fe lv lw lx ly b">callMocks</code>。它模仿端点<code class="fe lv lw lx ly b">/v2/users</code>的GET方法，以响应第4行定义的名称列表。这个模拟响应是一个数组引用，<code class="fe lv lw lx ly b">serverNameList</code>。</p><p id="3278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第12–14行调用模拟函数<code class="fe lv lw lx ly b">callMocks</code>。</p><p id="3670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了mock，我们可以在没有实际API的情况下实现和调优UI。</p><p id="83a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是用户界面输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/2f89919467aa0b2814f9e7666118398d.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/format:webp/1*ePTYpx0bUWKpNM3xae6yPw.png"/></div></figure><p id="20ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们嘲笑了GET方法。其他方法，比如POST和DELETE，也可以被模仿。</p><p id="3943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于UI，我们添加了两个功能:</p><ul class=""><li id="a24f" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">删除名单上的最后一个。它在端点<code class="fe lv lw lx ly b">/v2/user/:userId</code>调用DELETE方法。</li><li id="15ca" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">在随机索引处添加新名称。它在端点<code class="fe lv lw lx ly b">/v2/user</code>用主体<code class="fe lv lw lx ly b">body: {id: number; name: string}</code>调用POST方法。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/274b255d35cb7740bdb5b41ff0799d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*4lI4HxK-d7pkmKagUmQHHA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8dce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是模拟这两个额外端点的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ebd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第9–15行模拟端点<code class="fe lv lw lx ly b">/v2/user</code>的POST方法，用指定的<code class="fe lv lw lx ly b">name</code>和插入索引(<code class="fe lv lw lx ly b">id</code>)创建一个用户。模拟响应是一个返回已处理值的函数。</p><p id="d71e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第16–20行模拟端点<code class="fe lv lw lx ly b">/v2/user/:id</code>的DELETE方法，用指定的索引(<code class="fe lv lw lx ly b">id</code>)删除一个名称。<code class="fe lv lw lx ly b">:id</code>是特定资源的路径。第16行使用<code class="fe lv lw lx ly b">express:</code>表示URL匹配器会将<code class="fe lv lw lx ly b">:id</code>视为快速样式匹配。模拟响应是一个返回已处理值的函数。</p><p id="a01d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模仿可以被链接，但是重要的是把更具体的URL匹配器放在前面，因为它一匹配第一个URL匹配器就退出。</p><p id="eb5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">message</code>在第25行定义。如果有成功的操作，更新<code class="fe lv lw lx ly b">message</code>，这触发重新提取(第36行)。</p><p id="2284" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第41–54行定义了删除UI。这是一个删除名单上最后一个的按钮。通过<code class="fe lv lw lx ly b">onClick</code>触发<code class="fe lv lw lx ly b">DELETE /v2/user/:userId</code>的操作。</p><p id="2d26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第56–79行定义了创建UI。它是新名称的输入字段，也是在服务器列表上创建新用户的按钮。它使用<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/lodash-create-react-apps-built-in-library-for-debounce-and-throttle-with-hooks-3418087f44d8"> Lodash </a>的函数<code class="fe lv lw lx ly b">capitalize</code>(第70行)来大写输入。通过<code class="fe lv lw lx ly b">onClick</code>，它触发<code class="fe lv lw lx ly b">POST /v2/user/</code>的操作，带有一个主体(第68-71行)。</p><p id="cd58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第80行显示最近的<code class="fe lv lw lx ly b">message</code>。</p><p id="2037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击删除按钮后的界面如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/08d330c4b512967c9696dc95394c10fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*x6jnnhUdvrHFaQZilyMdLw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2260" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是添加名称后的UI:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/7497c77471b15658091c3b31cc8c70ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*hN30HMDHFUcehOnats1Ieg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="b282" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">模拟错误处理</h1><p id="f15d" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们可以模仿异步调用，这很酷。但是如果服务器操作出现错误怎么办？</p><p id="4354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当模拟响应被定义为函数时，我们可以根据需要抛出异常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6528" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果新名称已经存在，第13–15行抛出一个异常。</p><p id="06f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第24行为所有未处理的情况添加了一个glob URL匹配器。我们把它放在这里是为了展示如何在URL中使用通配符。对于未处理的URL，有一个内置函数，<code class="fe lv lw lx ly b">catch</code>。24线相当于<code class="fe lv lw lx ly b">.catch(e =&gt; ({ throws: `Unhandled call at ${e}.` }))</code>。</p><p id="ea70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有另一种方法来处理未处理的调用。<code class="fe lv lw lx ly b">fetchMock.config</code>是一种静态配置。<code class="fe lv lw lx ly b">fallbackToNetwork</code>是选项之一。默认情况下，它被设置为<code class="fe lv lw lx ly b">'always'</code>，所有的呼叫都通过网络，有效地禁用fetch-mock。</p><p id="24ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以设置<code class="fe lv lw lx ly b">fetchMock.config.fallbackToNetwork = false</code>，然后一个不匹配的调用<code class="fe lv lw lx ly b">POST /v2/unknown</code>将抛出一个错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码定义了<code class="fe lv lw lx ly b">fetchMock.config</code>中的选项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="adb0" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">故事书和测试的抓取模拟</h1><p id="bde8" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们已经展示了如何在开发过程中使用fetch-mock来模拟异步调用。也可以用在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/an-in-depth-look-at-storybook-6-8c44cd6895ee">故事书</a>里。关键是在呈现组件之前调用模拟。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="be64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果为具有不同模仿的多个故事调用函数<code class="fe lv lw lx ly b">callMocks</code>，它应该在链接模仿之前调用<code class="fe lv lw lx ly b">restore()</code>。使用<code class="fe lv lw lx ly b">restore</code>(是<code class="fe lv lw lx ly b">reset</code>的别名)，所有东西都重置为其未清除状态，并且为其先前调用记录的所有数据都被清除。</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="c304" class="no ma it ly b gy np nq l nr ns">fetchMock.restore().get(...).get(...).get(...).post(...)...</span></pre><p id="1ae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/facebook/jest" rel="noopener ugc nofollow" target="_blank"> Jest </a>是一个JavaScript <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-achieve-100-test-coverage-for-react-functional-components-fbde1e40631c">测试框架</a>来确保任何JavaScript代码库的正确性。我们可以使用<code class="fe lv lw lx ly b">jest.fn()</code>来模仿<code class="fe lv lw lx ly b">fetch</code>调用，这与<code class="fe lv lw lx ly b">fetch-mock</code>的想法类似。通过重用<code class="fe lv lw lx ly b">callMocks</code>，我们可能不需要模拟每个异步调用。</p><p id="0f4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">fetch-mock</code>有一个Jest的包装器，<code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.npmjs.com/package/jest-fetch-mock" rel="noopener ugc nofollow" target="_blank">jest-fetch-mock</a></code>。它提供与<code class="fe lv lw lx ly b">jest.fn()</code>相似的功能。</p><h1 id="4e1c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="d261" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们在项目中使用了<code class="fe lv lw lx ly b">fetch-mock</code>。在一个真实的项目中，一些API正在构建中，这种情况时有发生。只要定义了接口，我们就可以模拟它们同时处理UI特性。<code class="fe lv lw lx ly b">fallbackToNetwork</code>默认设置为<code class="fe lv lw lx ly b">'always'</code>。它允许我们混合使用现有的API和一些模拟。</p><p id="3963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些模拟可以在故事书中重复使用。它允许我们用异步调用为组件构建故事。</p><p id="3421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些模拟也可以在测试用例中重用。它可能不会取代所有的笑话模仿，但一些基本的情况下，没有太多额外的努力涵盖很好。</p><p id="cc02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毕竟<code class="fe lv lw lx ly b">fetch-mock</code>是一个项目中有用的帮手。</p><p id="dc06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。如果你有兴趣，可以看看<a class="ae ky" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener">我的其他媒体文章</a>。</p></div></div>    
</body>
</html>