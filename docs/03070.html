<html>
<head>
<title>Breaking Down a Complex Regex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分解复杂的正则表达式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/breaking-down-a-complex-regex-73b6c795a2be?source=collection_archive---------7-----------------------#2020-01-18">https://betterprogramming.pub/breaking-down-a-complex-regex-73b6c795a2be?source=collection_archive---------7-----------------------#2020-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="51ea" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提升你的正则表达式技能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/09434b55847ad566aa0d9a1af46fff64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X4e5j_LwuYjRR00jj5SUTg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="85d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在学习创建Pig Latinizer的多种方法时，我努力理解复杂的regex(正则表达式)如何在一个<code class="fe lu lv lw lx b">.split</code>方法中发挥其魔力。</p><p id="8860" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更具体地说，我对一行简单的代码感到惊讶和困惑(通过<a class="ae ly" href="https://aubreeabril.wordpress.com/2018/08/23/pig-latinizer-using-regex/" rel="noopener ugc nofollow" target="_blank">这位了不起的程序员</a>):</p><pre class="kj kk kl km gt lz lx ma mb aw mc bi"><span id="131c" class="md me it lx b gy mf mg l mh mi">"forest".split(/([aeiou].*)/)<br/># =&gt; ["f", "orest"]</span></pre><p id="f293" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种拆分方法的目标是将一个单词分成两个字符串的数组，以单词的第一个元音字母作为分隔符。如上所示，第一个字符串包含第一个元音前的所有字符，第二个字符串包含第一个元音后的所有字符(包括元音本身)。</p><p id="8e68" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了消除split/regex组合的复杂性，我决定“拆分”regex——一次一个正则表达式。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="008f" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">Regex 1: /[aeiou]/</h1><p id="77bd" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated"><code class="fe lu lv lw lx b">[]</code>是一个字符类，允许我们在字符串中找到任何匹配的字符。字符类中的字符充当分隔符。当找到匹配时，字符串中的字符被分割/拆分。</p><p id="36ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们可以看到单词<code class="fe lu lv lw lx b">forest</code>被<code class="fe lu lv lw lx b">o</code>和<code class="fe lu lv lw lx b">e</code>分开，返回一个分开的字符串数组:</p><pre class="kj kk kl km gt lz lx ma mb aw mc bi"><span id="b9fc" class="md me it lx b gy mf mg l mh mi">"forest".split(/[aeiou]/)<br/># dividers =&gt;  ("o")("e")<br/># returns =&gt; ["f", "r", "st"]</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3b4f" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">Regex 1 + 2: /[aeiou]。/</h1><p id="ac4d" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated"><code class="fe lu lv lw lx b">.</code>匹配字符类中任何字符之前或之后的任何一个字符。</p><p id="7bc8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在字符串<code class="fe lu lv lw lx b">forest</code>里面，<code class="fe lu lv lw lx b">o</code>和<code class="fe lu lv lw lx b">r</code>匹配我们的角色类，<code class="fe lu lv lw lx b">[aeiou]</code>。然后<code class="fe lu lv lw lx b">.</code>找到匹配字符后面的单个字符，使<code class="fe lu lv lw lx b">or</code>和<code class="fe lu lv lw lx b">es</code>成为分隔符:</p><pre class="kj kk kl km gt lz lx ma mb aw mc bi"><span id="00e2" class="md me it lx b gy mf mg l mh mi">"forest".split(/[aeiou]./)<br/># dividers =&gt; ("or")("es")<br/># returns =&gt; ["f", "", "t"]</span></pre><p id="ed8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是等等，为什么返回的数组里有空字符串？</p><p id="1aa3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为<code class="fe lu lv lw lx b">.split</code>方法将一个字符串分成子字符串，这里我们有两个并排的分隔符。换句话说，分隔符之间没有字符。分隔符之间的空白部分作为空子字符串返回。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a876" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">Regex 1 + 2 + 3: /[aeiou]。*/</h1><p id="e4ae" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">点(<code class="fe lu lv lw lx b">.</code>)表示“任何单个字符”，而星号(<code class="fe lu lv lw lx b">*</code>)表示“零或更多次”</p><p id="2d0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们基本上是在说:</p><ol class=""><li id="988b" class="nm nn it la b lb lc le lf lh no ll np lp nq lt nr ns nt nu bi translated">在单词<code class="fe lu lv lw lx b">forest</code>中查找任何匹配的字符。</li><li id="3e63" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">抓取单个字符，后跟匹配的字符。</li><li id="0ef3" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">匹配零次或多次出现的(1)和(2)</li></ol><p id="6e2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换句话说，<code class="fe lu lv lw lx b">[aeiou]</code>找到<code class="fe lu lv lw lx b">o</code>作为第一个匹配的字符，<code class="fe lu lv lw lx b">.</code>抓取<code class="fe lu lv lw lx b">or</code>，然后<code class="fe lu lv lw lx b">*</code>抓取后面所有的字符，使<code class="fe lu lv lw lx b">orest</code>成为唯一的除法器。</p><p id="e044" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们只剩下<code class="fe lu lv lw lx b">f</code>的结果了:</p><pre class="kj kk kl km gt lz lx ma mb aw mc bi"><span id="1160" class="md me it lx b gy mf mg l mh mi">"forest".split(/[aeiou].*/)<br/># divider =&gt;    ("orest")<br/># returns =&gt; ["f"]</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d5ea" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">Regex (1 + 2 + 3): /([aeiou]。*)/</h1><p id="291f" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">您可能还记得，我们实现这个方法是为了将一个单词分成两部分，并按照单词的第一个元音来划分。</p><p id="57bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">常规模式返回第一部分。</p><p id="e106" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二部分呢？</p><p id="0784" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是括号(或“子表达式”)出现的地方。它匹配<code class="fe lu lv lw lx b">/[aeiou].*/</code>常规模式的内容，该模式包含我们想要的结果的第二部分，并将该内容推送到结果上。</p><p id="3460" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们返回的数组包含这两部分。瞧啊。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="83b8" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">最后的想法</h1><p id="9f2c" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">我分解这个正则表达式的初衷是为了理解正则模式的不同部分是如何组合在一起的，但是后来我遇到了一些意想不到的结果，比如空字符串。</p><p id="c077" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这让我更深入地研究regex和<code class="fe lu lv lw lx b">split</code>方法之间的关系。我发现<a class="ae ly" href="https://spin.atomicobject.com/2007/11/01/ruby-string-split/" rel="noopener ugc nofollow" target="_blank">是一篇有用的文章</a>，它通过一些很酷的例子解释了那些奇怪的行为。</p><p id="d9d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">《原子对象》的作者扎克·丹尼斯也挖出了我困惑的根源:</p><blockquote class="oc od oe"><p id="50af" class="ky kz of la b lb lc ju ld le lf jx lg og li lj lk oh lm ln lo oi lq lr ls lt im bi translated">“当你开始超越简短的时候，你会发现String#split有一些奇怪的行为，它总是带有正则表达式分隔符。”</p></blockquote><p id="7171" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很高兴知道我不是一个人。</p></div></div>    
</body>
</html>