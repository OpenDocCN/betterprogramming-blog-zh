<html>
<head>
<title>How To Log Guzzle Requests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何记录大量的请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-log-guzzle-requests-fbc16c99a8fd?source=collection_archive---------8-----------------------#2022-09-01">https://betterprogramming.pub/how-to-log-guzzle-requests-fbc16c99a8fd?source=collection_archive---------8-----------------------#2022-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7c9c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">更新中间件的简单方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1c9653d5c783560083c0d5c0908a5bc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WJCtL6GS4oenfvbQ44Se2g.jpeg"/></div></div></figure><p id="ecd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当您构建API消费者时，您应该记录您的API请求和响应。否则，会让人觉得你在盲目工作。</p><p id="c96a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将解释如何配置一个Guzzle中间件来记录对文件的请求。这对于调试和历史记录非常有用。</p><p id="bd31" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样做的方法是用我们的日志中间件传递一个新的<code class="fe ln lo lp lq b">HandlerStack</code>到我们的<code class="fe ln lo lp lq b">Client</code>实例中。</p><p id="38b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建新的<code class="fe ln lo lp lq b">Guzzle</code>实例的语法如下:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="5f4a" class="lv lw iq lq b gy lx ly l lz ma">$client = new \GuzzleHttp\Client([<br/>    'base_uri' =&gt; "<a class="ae mb" href="http://www.example.com/api" rel="noopener ugc nofollow" target="_blank">http://www.example.com/api</a>",<br/>    'handler' =&gt; $handlerStack,<br/>    ]),<br/>]);</span></pre><p id="51f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">$handlerStack</code>将最终持有处理日志记录的中间件。</p><h1 id="0520" class="mc lw iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">设置日志文件</h1><p id="7888" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">在设置中间件之前，我需要实例化处理将日志消息写入文件的东西。我将使用Monolog包来处理这个问题。这很容易达到我想要的标准，在我的默认<code class="fe ln lo lp lq b">laravel.log</code>旁边有一个每日日志文件。</p><p id="701a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我的<code class="fe ln lo lp lq b">AppServiceProvider</code>中，我将设置一个助手函数来创建记录器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="7a2d" class="mc lw iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">设置中间件</h1><p id="e2ba" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">Guzzle的日志中间件需要一个日志记录器(我刚刚在上面创建的)和一个控制记录内容的<code class="fe ln lo lp lq b">MessageFormatter</code>实例。</p><p id="0171" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将设置一个助手函数来创建中间件:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="430a" class="lv lw iq lq b gy lx ly l lz ma">private function createGuzzleLoggingMiddleware(string $messageFormat)<br/>{<br/>    return \GuzzleHttp\Middleware::log(<br/>        $this-&gt;getLogger(),<br/>        new \GuzzleHttp\MessageFormatter($messageFormat)<br/>    );<br/>}</span></pre><p id="2f9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">$messageFormat</code>是一个字符串，它“使用变量替代请求、响应和其他事务数据来格式化日志消息。”可能的替代物<a class="ae mb" href="https://github.com/guzzle/guzzle/blob/master/src/MessageFormatter.php#L12" rel="noopener ugc nofollow" target="_blank">可以在这里看到</a>——但是我想出了一些方便的替代物:</p><p id="8432" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">记录请求:{ method } { uri } HTTP/{ version } { req _ body }<br/>记录响应:响应:{code} — {res_body}</p><h1 id="4315" class="mc lw iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">创建句柄堆栈</h1><p id="318b" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">既然我已经有了一种方法来轻松地创建Guzzle日志中间件的实例，我可以创建一个新的<code class="fe ln lo lp lq b">HandlerStack</code>来将中间件推送到:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="282f" class="lv lw iq lq b gy lx ly l lz ma">$handlerStack = \GuzzleHttp\HandlerStack::create();</span><span id="84f8" class="lv lw iq lq b gy na ly l lz ma">$handlerStack-&gt;push(<br/>    $this-&gt;createGuzzleLoggingMiddleware($messageFormat)<br/>);</span></pre><h1 id="5a25" class="mc lw iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">分别记录请求和响应</h1><p id="9fa3" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">我决定将请求和响应记录在两个独立的日志条目中。似乎实现这一点的唯一方法是将多个日志中间件推到风口浪尖，所以我设置了一个helper函数来创建一个<code class="fe ln lo lp lq b">HandlerStack</code>,其中包含我想要记录的一组消息格式字符串中所有需要的日志中间件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="a081" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们做到了！现在，向我们的Guzzle客户端添加多个记录器就像下面的代码一样简单:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="9a7f" class="lv lw iq lq b gy lx ly l lz ma">$client = new Client([<br/>    'base_uri' =&gt; "<a class="ae mb" href="http://example.com" rel="noopener ugc nofollow" target="_blank">http://example.com</a>",<br/>    'handler' =&gt; $this-&gt;createLoggingHandlerStack([<br/>        '{method} {uri} HTTP/{version} {req_body}',<br/>        'RESPONSE: {code} - {res_body}',<br/>    ]),<br/>]);</span></pre><h1 id="a35a" class="mc lw iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">关于处理大吃大喝反应的简短说明</h1><p id="c2cf" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">在设置了日志记录器之后，我意识到我不能再访问响应体了——原来这是我的错误。</p><p id="870a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之前，我使用以下代码行访问响应内容:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="638c" class="lv lw iq lq b gy lx ly l lz ma">$this-&gt;client-&gt;get($endpoint)-&gt;getBody()-&gt;getContents();</span></pre><p id="d140" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是结果是，这得到了“作为字符串的主体的剩余内容”——并且由于中间件已经访问了主体来记录它，所以没有任何剩余的内容要检索。</p><p id="87f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">访问响应内容的正确方法是将主体转换为字符串:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="1b64" class="lv lw iq lq b gy lx ly l lz ma">(string) $this-&gt;client-&gt;get($endpoint)-&gt;getBody();</span></pre></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><pre class="lr lq ls lt aw lu bi"><span id="bd34" class="lv lw iq lq b gy ni nj nk nl nm ly l lz ma"><strong class="lq ir">Want to Connect?</strong></span><span id="7695" class="lv lw iq lq b gy na ly l lz ma"><a class="ae mb" href="https://twitter.com/MichaelStivala" rel="noopener ugc nofollow" target="_blank">Follow me on Twitter</a> as I continue to document what I learn on my software-building journey.</span></pre></div></div>    
</body>
</html>