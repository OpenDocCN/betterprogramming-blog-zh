<html>
<head>
<title>React 18 Has Been Released. Implement Mini-React in 400 Lines of Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 18已经发布。用400行代码实现迷你反应</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-18-has-been-released-implement-mini-react-in-400-lines-of-code-837559761758?source=collection_archive---------3-----------------------#2022-04-11">https://betterprogramming.pub/react-18-has-been-released-implement-mini-react-in-400-lines-of-code-837559761758?source=collection_archive---------3-----------------------#2022-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3289" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React 18中实现异步可中断更新的最小模型！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/06330be99b9f4fd6bdae17d3b8507604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KV-0dqQsViRGqXUYOML94g.png"/></div></div></figure><p id="9ef3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React v18已经发布，给我们带来了很多特性，但是最重要的特性是一个异步可中断更新，很多新的上层API都是依靠它创建的。可以说是React v18的底层引擎。</p><p id="2b9f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文将使用大约400行代码带您实现一个可以异步更新和可中断的迷你React。一个简单的运行截图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ln"><img src="../Images/45e0d2341edb05a2317524d554af4531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Lai2E1hG14smn02GOEDvuQ.gif"/></div></div></figure><p id="1205" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我用了React官网提供的<a class="ae lo" href="https://reactjs.org/tutorial/tutorial.html#what-are-we-building" rel="noopener ugc nofollow" target="_blank">井字游戏教程示例</a>，可以看到效果很完美。另外，目前支持函数组件和类组件，可能满足你80%的需求！我也把它放在了<a class="ae lo" href="https://github.com/islizeqiang/mini-react" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上，你也可以在本地克隆，跟着我的文章一步一步调试。</p><p id="5275" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我在看了很多React的源代码后创建的，它在整体逻辑和函数命名上与React基本相同，如果你对React的内部感兴趣，这篇文章是给你的！</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="5798" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">JSX和创造元素</h1><p id="2be3" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">相信你对JSX的反应并不陌生。我们用JSX来描述DOM，它们最终会被babel转换成React提供的API。例如下面的代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/97dedc6ef8671e78ad3eaba18cc3ede5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XoekqpARAW_Nt6PsSiseew.png"/></div></div></figure><p id="f58b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您也可以在StackBlitz上亲自尝试(在终端中输入<code class="fe mu mv mw mx b">node transform-JSX.js</code>):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="5134" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你也可以在编译后的字符串中添加更多的元素来查看最终的结果，我在这里直接给出React.createElement提供的选项:</p><ol class=""><li id="a6f6" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">类型:表示当前节点的类型，比如上图中的<code class="fe mu mv mw mx b">div</code>。</li><li id="958b" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">config:表示当前元素节点上的属性，比如上图中的<code class="fe mu mv mw mx b">{id: "test"}</code>。</li><li id="6271" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">children:子元素，可以是多个简单文本，也可以是React.createElement创建的子节点。</li></ol><p id="13a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后根据这个需求实现一个自己的<code class="fe mu mv mw mx b">React.createElement</code>，就像下面的代码，我们定义一个自定义的数据结构。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no mz l"/></div></figure><h1 id="2f99" class="lw lx iq bd ly lz np mb mc md nq mf mg jw nr jx mi jz ns ka mk kc nt kd mm mn bi translated">提供；给予</h1><p id="eea3" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">然后，我们可以基于上面创建的数据结构实现一个简化版本的渲染函数，将JSX渲染到真实的DOM。</p><p id="4f75" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面的代码演示将使用CodeSandbox，拖动左栏查看代码，点击上方菜单按钮查看目录结构。您也可以直接编辑以查看显示的结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu mz l"/></div></figure><p id="91d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以你可以看到它的工作，但现在它只渲染一次，不能与我们互动。</p><p id="03b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外，请注意，我们在这里使用<code class="fe mu mv mw mx b">react-scripts@3.4.4</code>来帮助转换JSX，API在以后的版本中有所改变，但是在最后仍然调用<code class="fe mu mv mw mx b">React.createElement</code>。官博这里是<a class="ae lo" href="https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html#whats-different-in-the-new-transform" rel="noopener ugc nofollow" target="_blank">这里是</a>。我提供的<a class="ae lo" href="https://github.com/islizeqiang/mini-react/blob/master/vite.config.ts" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>使用了<code class="fe mu mv mw mx b">Vite</code>而不是<code class="fe mu mv mw mx b">react-scripts</code>。</p><p id="6295" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来是React的核心——纤程架构和并发模式，从React 17开始提出，主要是为了解决完整的元素树一旦递归，就无法<strong class="kt ir">终止</strong>的问题，这可能会导致主线程被长时间阻塞，那些高优先级的任务(比如用户输入或者动画的任务等等。)不能及时处理。</p><p id="2ead" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以在React源代码中，工作被分解成小单元。<strong class="kt ir">浏览器一旦空闲，就会处理这些小的工作单元，然后将结果映射到真正的DOM，直到全部处理完毕。</strong></p><p id="00bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mu mv mw mx b">requestIdleCallback</code>是一个实验性的API，在浏览器空闲时执行回调。接下来，我们将使用这个API来简单地实现这个特性。我会在最后给出React目前使用的<a class="ae lo" href="https://github.com/facebook/react/tree/main/packages/scheduler" rel="noopener ugc nofollow" target="_blank">调度器包</a>的模拟实现。</p><p id="be13" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在开始写下一段代码之前，我想再介绍一下工作单元之间的联系。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/e4ab746da096e66d29e995ae05dfbc5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*LkXFsSMU8Q82MD9T39bfzA.png"/></div></figure><p id="651c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就像上图一样，我们将创建每个纤维节点之间的连接，就像一个链表，它们是</p><ol class=""><li id="3894" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">child:父节点指向第一个子元素的指针。</li><li id="43e5" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">return/parent:所有子元素都有一个指向父元素的指针。</li><li id="b50d" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">sibling:从第一个子元素开始，指向下一个兄弟元素。</li></ol><p id="e3a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以现在你可以愉快地编码了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu mz l"/></div></figure><p id="671e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管添加了这么多代码，我们只是重构了<code class="fe mu mv mw mx b">render</code>逻辑。重构后的调用顺序是<code class="fe mu mv mw mx b"><strong class="kt ir">workLoop</strong></code><strong class="kt ir">-&gt;-</strong>-<code class="fe mu mv mw mx b"><strong class="kt ir">performUnitOfWork</strong></code>-&gt;--<code class="fe mu mv mw mx b"><strong class="kt ir">reconcileChildren</strong></code>。接下来，我来总结一下各个功能的作用:</p><ol class=""><li id="b45e" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated"><code class="fe mu mv mw mx b">workLoop</code>:连续调用<code class="fe mu mv mw mx b">requestIdleCallback</code>获得空闲时间。如果它当前是空闲的，并且有单元任务要执行，那么执行每个单元任务。</li><li id="f8f1" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated"><code class="fe mu mv mw mx b">performUnitOfWork</code>:执行的具体单位任务。这就是链表思想的体现。具体来说，一次只处理一个纤程节点，返回下一个要处理的节点。</li><li id="1fee" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated"><code class="fe mu mv mw mx b">reconcileChildren</code>:调和当前纤程节点，实际上是虚拟DOM的比较，记录要做的更改。你可以看到我们直接在每个纤程节点上修改和保存，因为现在只是对JavaScript对象的修改，并没有触及真正的DOM。</li><li id="b640" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">最后一步是<code class="fe mu mv mw mx b"><strong class="kt ir">commitRoot</strong></code>。如果当前需要更新(根据<code class="fe mu mv mw mx b">wipRoot</code>)并且没有下一个单元任务要处理(根据<code class="fe mu mv mw mx b">!nextUnitOfWork</code>)，这意味着虚拟变化需要被映射到真实DOM。<code class="fe mu mv mw mx b">commitRoot</code>是根据纤程节点的变化修改真实的DOM。</li></ol><p id="5cca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到目前为止，我们已经实现了光纤架构，是时候见证它的威力了。</p><p id="59a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们想给组件添加状态，所以让我们实现一个<code class="fe mu mv mw mx b">useState</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu mz l"/></div></figure><p id="c323" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mu mv mw mx b">useState</code>巧妙的保留了钩子在纤程节点上的状态，并通过队列修改状态。从这里我们也可以知道为什么<code class="fe mu mv mw mx b">React-hooks</code>要求每次调用的顺序不能改变。</p><p id="e055" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除此之外，我们还实现了一个<code class="fe mu mv mw mx b">Component</code>，它在这里被简单地转换为一个render方法，并添加了一点它的唯一标识。</p><h1 id="e9ff" class="lw lx iq bd ly lz np mb mc md nq mf mg jw nr jx mi jz ns ka mk kc nt kd mm mn bi translated">模拟请求回调</h1><p id="bb50" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">现在我们几乎实现了所有的功能，下面我来解释一下React目前采用的<a class="ae lo" href="https://github.com/facebook/react/tree/main/packages/scheduler" rel="noopener ugc nofollow" target="_blank">调度器包</a>，它其实是一个比requestIdleCallback更复杂的调度逻辑，包括更新任务的优先级等等。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no mz l"/></div></figure><p id="d4da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以上是我参考的<a class="ae lo" href="https://github.com/facebook/react/blob/main/packages/scheduler/src/forks/Scheduler.js" rel="noopener ugc nofollow" target="_blank">调度器</a>实现mock requestIdleCallback，它结合了<code class="fe mu mv mw mx b">requestAnimationFrame</code>和<code class="fe mu mv mw mx b">MessageChannel</code>。这里使用<code class="fe mu mv mw mx b">MessageChannel</code>的目的是使用宏任务处理每一轮单位任务。</p><p id="d5e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么为什么要使用宏任务呢？</p><p id="c2fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了放弃主线程，浏览器可以在这个空闲期间更新DOM或者接收事件。因为浏览器更新DOM是一个<strong class="kt ir">单独的任务</strong>，而此时不会执行JavaScript，因为主线程一次只能运行一个特性，要么执行JS，要么处理DOM计算样式，要么接收输入事件等。</p><p id="6cf6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">为什么不用微任务？</strong></p><p id="a395" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为每一轮宏任务中都包含了微任务，所以在所有微任务执行完毕之前，也就是当前宏任务没有完成的时候，不能放弃主线程。</p><p id="fecb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">那么为什么不用</strong> <code class="fe mu mv mw mx b"><strong class="kt ir">setTimeout</strong></code> <strong class="kt ir">？</strong></p><p id="3683" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为如果<code class="fe mu mv mw mx b">setTimeout</code>被嵌套调用5次以上，就会认为该函数被阻塞，浏览器会将最小时间设置为4ms，所以不够精确。</p><h1 id="c740" class="lw lx iq bd ly lz np mb mc md nq mf mg jw nr jx mi jz ns ka mk kc nt kd mm mn bi translated">最终版</h1><p id="3e5c" class="pw-post-body-paragraph kr ks iq kt b ku mo jr kw kx mp ju kz la mq lc ld le mr lg lh li ms lk ll lm ij bi translated">下面是最终版本，可以看到React的核心思想在去掉注释后，用不到400行代码实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu mz l"/></div></figure><p id="62b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我还在Github资源库中添加了Mini-React的<a class="ae lo" href="https://github.com/islizeqiang/mini-react/blob/master/src/mini-react.ts" rel="noopener ugc nofollow" target="_blank"> TypeScript版本</a>，如果你有兴趣可以去看看，非常欢迎投稿。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="5ad9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nw">感谢阅读。如果你喜欢这样的故事，想支持我，请考虑成为</em> <a class="ae lo" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="nw">中会员</em> </a> <em class="nw">。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae lo" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="nw">我的链接</em> </a> <em class="nw">报名，我会得到一点佣金。</em></p><p id="d5b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你的支持对我来说很重要——谢谢。</p></div></div>    
</body>
</html>