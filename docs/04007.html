<html>
<head>
<title>How to Build a Node.js API Cache With Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Redis构建Node.js API缓存</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-node-js-api-cache-with-redis-ac0aa54dee48?source=collection_archive---------7-----------------------#2020-03-18">https://betterprogramming.pub/how-to-build-a-node-js-api-cache-with-redis-ac0aa54dee48?source=collection_archive---------7-----------------------#2020-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="409e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">API调用是必不可少的，但也很昂贵。对于Redis和Node，我们可以通过构建API缓存来优化它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7f10946b5970f786d5380f2766ce6302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wW-ppOtlUUhyIwGSo0XJgw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="9a3f" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">什么是API缓存，我们为什么要使用它？</h1><p id="3300" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">我想大家应该已经知道什么是缓存了。它(主要)临时存储在不久的将来会再次需要的数据(例如，为了节省计算能力或网络使用)。</p><p id="1986" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">API是一个应用程序编程接口，可以向其发送请求以获取数据。</p><p id="8929" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">那么我们如何将这两种技术结合起来使用呢？</p><p id="51b6" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">让我们直接参考我们自己将要实现的例子:在我们的web应用程序中，用户输入数据，然后数据被发送到我们的服务器。在我们的服务器上，我们自己不处理发送的数据(一个数字)。我们只评估它。</p><p id="acba" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">因此，我们的服务器将从客户端接收到的数据发送到一个API，在我们的代码示例中，该API执行一个计算(将值加倍)，然后将结果发送回我们的服务器。当然，服务器会将结果返回给用户。</p><p id="35b3" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">到目前为止，没有问题，对不对？但是如果几个用户在很短的时间内发送同一个号码呢？由于我们的API只将数字乘以2，这意味着如果同一个数字被传输几次，将会一次又一次地返回相同的结果——只是一次又一次地需要请求。</p><p id="8480" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">这就成了一个问题，因为它耗费了不必要的容量。API通常不能免费使用，你需要为大量的请求付费。</p><p id="4579" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">此外，API请求需要一定的时间，这取决于位置和容量，这对用户体验是不利的。</p><p id="80c5" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">这就是Redis的用武之地。Redis是一个非常非常快速的内存中数据结构存储，因此它非常适合小型和不复杂数据的易失性存储以及非常快速的检索。</p><p id="206a" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">如果想了解Node.js中Redis的更多信息，可以阅读我以前的一篇文章:</p><div class="mz na gp gr nb nc"><a href="https://medium.com/javascript-in-plain-english/getting-started-with-redis-and-how-to-use-it-in-node-js-8d4f1a3f7369" rel="noopener follow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">Node.js &amp; Redis。高性能缓存</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">该指南面向所有希望开始使用Redis或希望能够在Node.js中使用它的人</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">medium.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq ks nc"/></div></div></a></div></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="456c" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">这是我们的做法</h1><ol class=""><li id="3bed" class="nr ns it lz b ma mb md me mg nt mk nu mo nv ms nw nx ny nz bi translated">客户端向我们的服务器发送一个号码。</li><li id="22ec" class="nr ns it lz b ma oa md ob mg oc mk od mo oe ms nw nx ny nz bi translated">如果客户机发送给我们服务器的数字已经作为一个键存储在我们的缓存中(原则上类似于一个ID，因为每个结果只能有一个原始数字)，那么使用这个键，我们加载最初由API生成的结果，并将结果直接发送给客户机——没有任何不必要的API请求。</li><li id="7c69" class="nr ns it lz b ma oa md ob mg oc mk od mo oe ms nw nx ny nz bi translated">如果来自客户端的数字还没有作为一个键存储在我们的缓存中，我们就在请求中将它发送给API。</li><li id="91ae" class="nr ns it lz b ma oa md ob mg oc mk od mo oe ms nw nx ny nz bi translated">在这种情况下，客户端直接从API接收结果，但是我们也将密钥(来自用户的数字)和来自API的结果存储在缓存中。</li></ol><p id="97ba" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">这样，我们避免了不必要的API请求。如果一个值还没有被缓存，那么任何事情都有第一次。第二次，可以从缓存中读取。</p><p id="fdc1" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">为了证明这一点——因为在现实世界的例子中应该是这样——我们设置了一个缓存条目，在60秒后自动删除。在现实世界的项目中，我们应该这样做，以便从长远来看始终保证API的新鲜结果。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="641e" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">让我们实际一点</h1><h2 id="91d9" class="of lg it bd lh og oh dn ll oi oj dp lp mg ok ol lr mk om on lt mo oo op lv oq bi translated">在你的机器上安装Redis</h2><p id="32ba" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">Linux:</p><ul class=""><li id="e192" class="nr ns it lz b ma mt md mu mg or mk os mo ot ms ou nx ny nz bi translated"><a class="ae my" href="https://redis.io/topics/quickstart" rel="noopener ugc nofollow" target="_blank">https://redis.io/topics/quickstart</a></li><li id="4b27" class="nr ns it lz b ma oa md ob mg oc mk od mo oe ms ou nx ny nz bi translated">sudo服务redis启动或<em class="ov"> </em> sudo服务redis-服务器启动</li></ul><p id="7a75" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">macOS:</p><ul class=""><li id="3e6f" class="nr ns it lz b ma mt md mu mg or mk os mo ot ms ou nx ny nz bi translated">安装brew。如果您还没有安装，<a class="ae my" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">https://brew.sh/</a>。</li><li id="7a91" class="nr ns it lz b ma oa md ob mg oc mk od mo oe ms ou nx ny nz bi translated">brew安装redis</li><li id="bac7" class="nr ns it lz b ma oa md ob mg oc mk od mo oe ms ou nx ny nz bi translated">brew服务启动redis</li></ul><p id="3cd2" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">窗口:</p><ul class=""><li id="4ad4" class="nr ns it lz b ma mt md mu mg or mk os mo ot ms ou nx ny nz bi translated">使用Windows的Linux子系统。然后就像在Linux上一样安装它。</li></ul><h2 id="4b69" class="of lg it bd lh og oh dn ll oi oj dp lp mg ok ol lr mk om on lt mo oo op lv oq bi translated">检查Redis是否在工作</h2><p id="6119" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">一旦您已经启动了Redis服务，您应该能够通过<code class="fe ow ox oy oz b">redis-cli</code>与它通信。试做<code class="fe ow ox oy oz b">redis-cli ping</code> <em class="ov"> <br/> </em>而Redis应该用<em class="ov"> </em> <code class="fe ow ox oy oz b">PONG</code>来回答。这意味着Redis正在工作。</p><h2 id="e311" class="of lg it bd lh og oh dn ll oi oj dp lp mg ok ol lr mk om on lt mo oo op lv oq bi translated">Node.js中的Redis入门</h2><p id="23d1" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">首先，我们需要在Node.js项目中安装Redis:</p><pre class="kj kk kl km gt pa oz pb pc aw pd bi"><span id="265b" class="of lg it oz b gy pe pf l pg ph">npm install redis</span></pre><p id="0869" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">然后我们可以在代码中导入它，并连接到运行在我们机器上的<code class="fe ow ox oy oz b">Redis</code>实例。<code class="fe ow ox oy oz b">createClient</code>的参数将是我们机器上实例的地址(这就是为什么我们使用localhost ),端口6379是Redis的默认端口。</p><pre class="kj kk kl km gt pa oz pb pc aw pd bi"><span id="8b7d" class="of lg it oz b gy pe pf l pg ph">const redis = require(‘redis’)<br/>const client = redis.createClient(‘redis://localhost:6379’)</span></pre><h2 id="bd01" class="of lg it bd lh og oh dn ll oi oj dp lp mg ok ol lr mk om on lt mo oo op lv oq bi translated">让我们安装其余的软件包</h2><pre class="kj kk kl km gt pa oz pb pc aw pd bi"><span id="c7fe" class="of lg it oz b gy pe pf l pg ph">npm install axios body-parser cors express redis</span></pre><h2 id="49de" class="of lg it bd lh og oh dn ll oi oj dp lp mg ok ol lr mk om on lt mo oo op lv oq bi translated">最后，一些代码</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi pj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">server.js</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="8709" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">解释最重要的部分</h1><p id="21f4" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">如果我们在浏览器中调用服务器的起始页(即客户端页面)，我们通过<code class="fe ow ox oy oz b">/</code>路径(代码中的第13行)来完成。在此之上，我们得到一个表单，我们可以在其中输入一个数字，当提交时该数字被发送到服务器。</p><p id="1566" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">该号码作为POST <strong class="lz iu"> </strong>请求发送到服务器，由于<code class="fe ow ox oy oz b">body-parser</code>，服务器可以从第72行开始处理它。</p><p id="e305" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">使用Redis的<code class="fe ow ox oy oz b">client.exists</code>函数，我们可以检查一个键(作为第一个参数(<code class="fe ow ox oy oz b">number</code>)是否存储了相应的值。Redis查询的结果作为<code class="fe ow ox oy oz b">result</code>变量返回，或者是<code class="fe ow ox oy oz b">true</code>或者是<code class="fe ow ox oy oz b">false</code>。</p><p id="8dd7" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">如果客户端已经为我们的号码(<code class="fe ow ox oy oz b">result = true</code>)存储了一个结果，我们调用<code class="fe ow ox oy oz b">getResultFromCache</code>函数。如果没有，我们调用<code class="fe ow ox oy oz b">getResultFromAPI</code>来查询API。</p><p id="760d" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated"><code class="fe ow ox oy oz b">getResultFromCache</code>执行Redis的<code class="fe ow ox oy oz b">client.get</code>函数，从一个键中读取相应的存储值。现在我们为客户端执行一个到结果页面的重定向，在这里我们将结果和提示作为<code class="fe ow ox oy oz b">URL</code>参数传递，提示它是从缓存中读取的。</p><p id="17b9" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">然而，如果我们检查数字及其结果是否已经被缓存，结果是<code class="fe ow ox oy oz b">false</code>，我们运行<code class="fe ow ox oy oz b">getResultFromAPI</code>并执行一个API请求。然后，我们向客户端提供API请求的结果，并使用<code class="fe ow ox oy oz b">client.set</code>将密钥和API相乘的结果存储在Redis缓存中。<br/>通过<code class="fe ow ox oy oz b">client.expire</code>，我们还设置了60秒后自动删除条目。</p><p id="e232" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">在结果页面的第86行，如果生成了客户端，这里我们只给出从API缓存的两个主要函数传递的<code class="fe ow ox oy oz b">URL</code>参数。出于验证目的，我们通过结果计算回原始值。</p><h2 id="18bb" class="of lg it bd lh og oh dn ll oi oj dp lp mg ok ol lr mk om on lt mo oo op lv oq bi translated">没那么壮观:我们的API服务器</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pi pj l"/></div></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="a76e" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">让整个系统正常工作，并对其进行基准测试</h1><p id="fbdd" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">基本上，我们的整个项目只包括<code class="fe ow ox oy oz b">server.js</code>和<code class="fe ow ox oy oz b">api.js</code>。你应该两者兼得。它们共享<code class="fe ow ox oy oz b">node_modules</code>没有任何问题，所以在您按照上面的解释安装了依赖项之后，您可以同时运行两个服务器。在<a class="ae my" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080/ </a>可以找到起始页。</p><p id="3ff4" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">你可能已经注意到了，我用<code class="fe ow ox oy oz b">Date.now</code>节省了两个主要函数的时间。此外，API在<code class="fe ow ox oy oz b">getResultFromAPI</code>中读取并从<br/> <code class="fe ow ox oy oz b">getResultFromCache </code>中的缓存读取的过程开始。</p><p id="0760" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">在流程结束时，只需用成功执行后的当前时间减去存储的开始时间，就可以得到整个流程的持续时间。</p><p id="8730" class="pw-post-body-paragraph lx ly it lz b ma mt ju mc md mu jx mf mg mv mi mj mk mw mm mn mo mx mq mr ms im bi translated">为了获得最清晰、最真实的时间基准测试结果，您可以在不同的设备上运行两台服务器(例如，Raspberry Pi)。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="c86f" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">结论</h1><p id="c666" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">感谢阅读。欢迎对代码和文章本身留下反馈。因为我只有19岁，希望我还有很多东西要学。</p></div></div>    
</body>
</html>