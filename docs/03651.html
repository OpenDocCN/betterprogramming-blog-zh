<html>
<head>
<title>The Best of Future JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">未来最好的JavaScript</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-best-of-future-javascript-885be92bb685?source=collection_archive---------25-----------------------#2020-02-24">https://betterprogramming.pub/the-best-of-future-javascript-885be92bb685?source=collection_archive---------25-----------------------#2020-02-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1084" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Do表达式、可选链接和nullish合并运算符。让我们来看看每一个</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/76c929df22bed9cb238df8b878636922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oa03D5j9k5yqUkXpg83fVg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">布鲁诺·伯格尔在<a class="ae kv" href="https://unsplash.com/s/photos/road?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ae0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">📕看看我的新书</strong> <a class="ae kv" href="https://www.amazon.com/Clean-Code-Principles-Patterns-Practitioners-ebook/dp/B0BSDJKYQJ/ref=sr_1_1?crid=8M0CMV4CP6UQ&amp;keywords=clean+code+principles&amp;qid=1674980636&amp;sprefix=clean+code+principle%2Caps%2C175&amp;sr=8-1" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">干净代码原则和模式:软件从业者手册</strong> </a>！</p><p id="002c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是未来JavaScript中我最喜欢的部分。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d0d0" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">做表情</h1><p id="f225" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mw mx my mz b">do { .. }</code>表达式执行一个块(块内有一条或多条语句)，块内最终的语句完成值成为<code class="fe mw mx my mz b">do</code>表达式的完成值。你看这里的<a class="ae kv" href="https://github.com/tc39/proposal-do-expressions" rel="noopener ugc nofollow" target="_blank">规格</a>。</p><p id="5901" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了<code class="fe mw mx my mz b">do</code>表达式，你就可以摆脱烦人的<code class="fe mw mx my mz b">let</code>变量，并且能够随心所欲地使用<code class="fe mw mx my mz b">const</code> <em class="na"> </em>。</p><p id="9cee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在我的一个附带项目中搜索了<code class="fe mw mx my mz b">let</code> <em class="na"> </em>，其中包含大量代码，大多数找到的事件都遵循逻辑，我声明了一个变量，并将其值设置为基于哪个条件评估为真的值之一:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="124f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是在初始设置后，我不会改变<code class="fe mw mx my mz b">opacity</code>或<code class="fe mw mx my mz b">color</code> <em class="na"> </em>的值。它们基本上是常量，但我不得不用<code class="fe mw mx my mz b">let</code>来声明它们。</p><p id="d86b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mw mx my mz b">do</code>表达式，我可以如下重写上面的代码，并用<code class="fe mw mx my mz b">const</code>替换<code class="fe mw mx my mz b">let</code> <em class="na"> </em>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8946" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">可选的链接和无效合并运算符</h1><p id="f115" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们都写过成百上千次类似的表达方式:</p><pre class="kg kh ki kj gt nd mz ne nf aw ng bi"><span id="db10" class="nh ma iq mz b gy ni nj l nk nl">const creditCardType = creditCardTypes &amp;&amp; creditCardTypes[0] &amp;&amp; creditCardTypes[0].type ? creditCardTypes[0].type : ‘Visa’;</span></pre><p id="acf3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它很长，我希望它能写得更短。它可以！</p><p id="aa91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢两个新的实验性JavaScript特性:<a class="ae kv" href="https://github.com/tc39/proposal-optional-chaining" rel="noopener ugc nofollow" target="_blank">可选链接</a>和<a class="ae kv" href="https://github.com/tc39/proposal-nullish-coalescing" rel="noopener ugc nofollow" target="_blank"> nullish合并操作符</a>。利用这两个新的实验特性，我可以将上面的语句写成如下:</p><pre class="kg kh ki kj gt nd mz ne nf aw ng bi"><span id="b07b" class="nh ma iq mz b gy ni nj l nk nl">const creditCardType = creditCardTypes?.[0]?.type ?? ‘Visa’;</span></pre><p id="d2c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">??</code>操作符是<code class="fe mw mx my mz b">||</code>操作符的绝佳替代品。<code class="fe mw mx my mz b">||</code>操作符检查真值，而<code class="fe mw mx my mz b">??</code>操作符检查空值:<code class="fe mw mx my mz b">undefined</code>和<code class="fe mw mx my mz b">null</code>。</p><p id="f4ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe mw mx my mz b">??</code>运算符左侧的表达式计算结果为undefined或null，则返回其右侧的表达式。使用<code class="fe mw mx my mz b">||</code>操作符可能会导致细微的错误，例如在计算数值时。</p><p id="0d73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当使用<code class="fe mw mx my mz b">||</code>操作符时，数值零计算为一个假值，可能会产生意外的结果，但是当使用<code class="fe mw mx my mz b">??</code>操作符时应该可以正常工作。</p><p id="2933" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个潜在错误的例子:</p><pre class="kg kh ki kj gt nd mz ne nf aw ng bi"><span id="84d4" class="nh ma iq mz b gy ni nj l nk nl">const minValue = suppliedMinValue || -100;</span></pre><p id="ba64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你提供一个min时会发生什么。值为零？您得到的是-100的<code class="fe mw mx my mz b">minValue</code>，而不是零，这可能是意料之外的。使用<code class="fe mw mx my mz b">??</code>，我们可以解决这个问题:</p><pre class="kg kh ki kj gt nd mz ne nf aw ng bi"><span id="1018" class="nh ma iq mz b gy ni nj l nk nl">const minValue = suppliedMinValue ?? -100;</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7bd0" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">好消息！</h1><p id="bdd1" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">你可以使用<a class="ae kv" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>插件获得这些新的实验特性:</p><ul class=""><li id="396d" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated"><a class="ae kv" href="https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining" rel="noopener ugc nofollow" target="_blank">巴别塔可选链接插件</a>。</li><li id="753c" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">Babel nullish合并运算符插件。</li></ul><p id="5426" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果使用TypeScript，它支持可选链接和nullish合并操作符，但不支持<code class="fe mw mx my mz b">do</code>表达式。</p><p id="f787" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似地，如果您使用<a class="ae kv" href="https://flow.org/" rel="noopener ugc nofollow" target="_blank">流</a>静态类型检查器，您可以通过在<code class="fe mw mx my mz b"><a class="ae kv" href="https://flow.org/en/docs/config/options/" rel="noopener ugc nofollow" target="_blank">.flowconfig</a></code>中启用它们来使用可选的链接和nullish合并操作符。</p><p id="7f56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">📕看看我的新书</strong> <a class="ae kv" href="https://www.amazon.com/Clean-Code-Principles-Patterns-Practitioners-ebook/dp/B0BSDJKYQJ/ref=sr_1_1?crid=8M0CMV4CP6UQ&amp;keywords=clean+code+principles&amp;qid=1674980636&amp;sprefix=clean+code+principle%2Caps%2C175&amp;sr=8-1" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">干净代码原则和模式:软件从业者手册</strong> </a>！</p></div></div>    
</body>
</html>