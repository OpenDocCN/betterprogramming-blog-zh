<html>
<head>
<title>Beginning Python Programming — Part 15</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python编程入门—第15部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/beginning-python-programming-part-15-ae96dd8b9c95?source=collection_archive---------6-----------------------#2019-07-01">https://betterprogramming.pub/beginning-python-programming-part-15-ae96dd8b9c95?source=collection_archive---------6-----------------------#2019-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a5f1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">多重处理简介</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b99d7b47d887c180e95939abd0554f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IyqUsB_yVwFp07kD"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@briankost?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Brian Kostiuk拍摄— @BriKost </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="ba21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一篇文章中，我们讨论了多线程。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/beginning-python-programming-part-14-208b9fa2f0a1" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Python编程入门—第14部分</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">多线程简介</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="5d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们将介绍Python提供的另一个名为<code class="fe mn mo mp mq b">multiprocessing</code>的库。像<code class="fe mn mo mp mq b">threading</code>，<code class="fe mn mo mp mq b">multiprocessing</code>允许我们并发运行代码；然而，这段代码运行在多个处理器上。先说一个定义。</p><ul class=""><li id="e0a8" class="mr ms it lb b lc ld lf lg li mt lm mu lq mv lu mw mx my mz bi translated">全局解释器锁(GIL)——用于确保当<em class="na">锁定</em>时，Python字节码每次只在一个线程上运行。如果<em class="na">释放</em>，则允许使用多个内核进行处理。</li></ul><p id="47de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们已经能够避开这种复杂性，因为我们只处理单核计算。GIL对于确保并发访问的安全性至关重要；通俗地说，多个任务同时运行不会出问题。</p><p id="940a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前面的例子中，我们最终同时在控制台上打印了两行。通过确保一次只有一个进程可以写入控制台，GIL可以用来清理这种情况。</p><p id="3e01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然GIL可以保护我们，但它限制了我们使用多个内核进行并行处理，从而导致性能问题。这并不意味着“永远不要使用多重处理”，它只是意味着当我们确切地知道我们希望我们的代码如何执行时，我们应该只使用多重处理。</p><h1 id="818f" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">多重处理</h1><p id="ed32" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated"><code class="fe mn mo mp mq b">multiprocessing</code>最适合在我们执行基于CPU的计算时使用。CPU计算可能是比特币挖掘(缓慢的方式)或为一些极端的例子创建彩虹表。一些更实际的例子是照片和视频编辑、音乐创作或创建哈希表(数据挖掘的东西)。</p><p id="eee1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子，你会从上一篇文章中认出来，只是稍微做了些修改，以适应多处理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a01c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不用导入<code class="fe mn mo mp mq b">threading</code>和<code class="fe mn mo mp mq b">concurrent.futures</code>，我们只需要导入<code class="fe mn mo mp mq b">multiprocessing</code>。接下来改变的是我用了<code class="fe mn mo mp mq b">multiprocessing.current_process().pid</code>而不是<code class="fe mn mo mp mq b">threading.active_count().name[-3:]</code>。这将获得从我们的主进程派生出来的进程的进程ID，并将其报告回控制台，这样，如果我们以后需要终止它，我们就知道在哪里可以找到我们的进程。我们的<code class="fe mn mo mp mq b">task</code>函数中的其他内容都是一样的。</p><p id="fa5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mn mo mp mq b">main</code>中，我们改变了我们的执行程序，它曾经是<code class="fe mn mo mp mq b">ThreadPoolExecutor</code>的一个实例，但是我们把它改成了<code class="fe mn mo mp mq b">multiprocessing.Pool()</code>。这里，我们指定只使用一个进程。如果我将它留空，它将使用<code class="fe mn mo mp mq b">os.cpu_count()</code>返回我的机器中可用的CPU总数。</p><p id="48c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像线程一样，我使用<code class="fe mn mo mp mq b">map</code>将每个<code class="fe mn mo mp mq b">number</code>映射到它自己的<code class="fe mn mo mp mq b">task</code>。如果我的任务多于进程，它们会排队等待前一个任务完成。最后我加了<code class="fe mn mo mp mq b">executor.close()</code>，因为我有一个失控的进程。<code class="fe mn mo mp mq b">close()</code>清理池并确保其正确停止。</p><p id="108b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mn mo mp mq b">if __name__ == “__main__"</code>中，我们删除了线<code class="fe mn mo mp mq b">current_threads = threading.active_count()</code>。我们没有用多处理的等价行来替换它，这将是<code class="fe mn mo mp mq b">current_children = multiprocessing.active_children()</code>，因为我们的执行器将阻塞主线程，直到它完成。我们可以使用一个更真实的<code class="fe mn mo mp mq b">apply_async</code>调用(类似于<code class="fe mn mo mp mq b">start</code>)来运行它，但是出于我们的目的，我们在这里不需要它。</p><p id="25ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还继续使用<code class="fe mn mo mp mq b">time</code>来检查我们的执行运行时间，就像我们之前做的那样。</p><p id="d0f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是测试多个流程的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/97b21a3dbe4b1ea5cfae3a5cee61ac4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WNzSYFurh3AHmheEhly_5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">所用进程总数的运行时间(秒)。</p></figure><p id="e6ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里获得了比线程更好的运行时间。情况并不总是这样，所以在决定之前一定要进行自己的测试。我们的时间是3.05秒。之前，我们用50个线程达到了3.09。这意味着多重处理知道如何利用多线程。</p><p id="d095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像线程一样，当我们使用两个进程时，我们看到了最显著的跳跃。我们还看到其他明显的下降，直到我们达到4核。在4个和7个过程之间，我们看不到太大的区别；然而，在8个进程中，我们看到了另一个明显的下降。这种差异的缺乏可能是因为我的电脑在做其他事情(咳咳，写这篇文章)，这些事情已经通过Chrome、Safari、PyCharm(为了代码质量)和Mail耗尽了CPU时间，更不用说所有在后台运行的东西了。</p><p id="37ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我添加了10个和16个进程来展示当您使用的进程多于CPU时会发生什么。我们看到这个数字回升，而不是改善。</p><p id="d918" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能希望添加一些类似这样的代码，以防止在您可能不知道有多少CPU的系统上放置代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6945" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道还有其他方法可以做到这一点，使用<code class="fe mn mo mp mq b">elif</code>或三元运算符，但这很简单，而且很有效。<code class="fe mn mo mp mq b">os.cpu_count()</code>可能很贵，这就是我把它存储在变量中的原因。这样，我就不会在每次需要进行比较或赋值时要求Python查找CPU计数。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="5872" class="nb nc it bd nd ne oi ng nh ni oj nk nl jz ok ka nn kc ol kd np kf om kg nr ns bi translated">锁</h1><p id="dfcb" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">因为我们有机会让两个不同的进程同时打印到控制台，所以我们可能希望在程序中包含锁。</p><p id="7ffa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将使用上面的同一个例子来展示锁是如何工作的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8cc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">Lock</code>做的是<em class="na">获得</em>一个控制台进程的锁。当锁处于活动状态时，任何其他进程都不能使用它。A <code class="fe mn mo mp mq b">Lock</code>是在编辑文件时使用的，我相信你已经看到警告，<em class="na">某用户</em>打开了<em class="na">某文件</em>，请让他们关闭或稍后再试。这和我们在这里讨论的锁是一样的。Lock防止其他任何人访问控制台，直到进程<em class="na">释放</em>控制台上的锁。</p><p id="be68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">锁确实会增加我们的运行时间，但不会增加太多。在这个例子中，我的运行时间从0.87秒增加到了1.01秒。为了数据输出更加安全，我将花费大约0.2秒。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/e3206cffef087379dddd1fe13ab3cbd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rix8pbqgN70gpKmR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@hero?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Herson Rodriguez </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="8421" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">共享</h1><p id="8183" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">有时我们需要在进程间共享数据。有几种方法可以做到这一点，但并不那么简单。当我第一次开始使用多处理时，我看到了许多新的错误消息，它们看起来很神秘，因为我不熟悉套接字编程。虽然这超出了本教程的范围，但我会尽量保持简单，以便您可以在进程之间共享数据。这取决于你自己去学习先进的东西。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2d88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有一个来自上一篇线程文章的修改过的例子。我们从几个直接导入开始:<code class="fe mn mo mp mq b">Process</code>、<code class="fe mn mo mp mq b">Queue</code>和<code class="fe mn mo mp mq b">current_process</code>。</p><p id="933f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我稍微修改了一下我们的<code class="fe mn mo mp mq b">count</code>函数。在进入细节之前，我想介绍一下多处理队列。队列也存在于<a class="ae ky" href="https://docs.python.org/3/library/threading.html" rel="noopener ugc nofollow" target="_blank">线程</a>库中；然而，没有一种简单的方法来共享值，因为进程运行在不同的内存空间中。这就是队列发挥作用的地方。您可以将队列附加到流程，以便将值从一个流程传输到另一个流程。</p><p id="09a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将值插入到队列中，我们使用了<code class="fe mn mo mp mq b">queue.put(item)</code>。为了检索值，我们使用<code class="fe mn mo mp mq b">queue.get()</code>。队列的工作方式是先进先出，也就是FIFO，这意味着你进入队列的第一个项目就是你第一次调用T7时得到的。</p><p id="37ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的例子。<code class="fe mn mo mp mq b">count</code>先前要求的四个参数。因为<code class="fe mn mo mp mq b">current_process().name</code>返回“进程-1”、“进程-2”等。，我们可以忽略传递当前进程计数。其他一切都是一样的，直到我们在队列中得到这个结果。</p><p id="5c6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们程序的第一步是创建一个<code class="fe mn mo mp mq b">queue</code>，我们可以用它在进程间共享数据。接下来，我们创建空列表来保存我们的<code class="fe mn mo mp mq b">results</code>和<code class="fe mn mo mp mq b">processes</code>。最后，我们创建一个变量来保存我们希望在使用<code class="fe mn mo mp mq b">process_count</code>进行计算时使用的进程数量。我们这样做是为了，如果我们需要升级或删除一些流程，我们可以在一个地方完成所有这些工作，以便将来轻松地进行更新。</p><p id="3fd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们更新了如何通过传递<code class="fe mn mo mp mq b">queue</code>而不是<code class="fe mn mo mp mq b">results</code>列表来创建新流程。在第二个循环中启动每个进程仍然和以前一样。在第三个循环中，我们做了一些改变。在使用<code class="fe mn mo mp mq b">process.join()</code>之前，我们需要从<code class="fe mn mo mp mq b">queue</code>中获取每个值，并将其存储在<code class="fe mn mo mp mq b">results</code>列表中。</p><p id="6d08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们使用<code class="fe mn mo mp mq b">queue.close()</code>来确保我们自己清理干净，然后我们通过打印出<code class="fe mn mo mp mq b">results</code>列表中第一个元素的长度来结束。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/d0381a801f7734694ae2cbc6f4d70533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uOrtko0hym8BBbNx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯·巴巴利斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="db8f" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">异步方法的差异</h1><p id="8548" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">既然我们已经介绍了可用的不同异步选项，让我们看看最重要的方面:何时使用它们。</p><h2 id="e5ce" class="op nc it bd nd oq or dn nh os ot dp nl li ou ov nn lm ow ox np lq oy oz nr pa bi translated">穿线</h2><ul class=""><li id="a230" class="mr ms it lb b lc nt lf nu li pb lm pc lq pd lu mw mx my mz bi translated">数据可以很容易地在线程之间共享。</li><li id="bd0d" class="mr ms it lb b lc pe lf pf li pg lm ph lq pi lu mw mx my mz bi translated">当您受到I/O(例如，磁盘读/写)的限制但有许多连接时，最好使用它。</li><li id="29a5" class="mr ms it lb b lc pe lf pf li pg lm ph lq pi lu mw mx my mz bi translated">仅使用一个CPU内核。</li></ul><h2 id="e7ed" class="op nc it bd nd oq or dn nh os ot dp nl li ou ov nn lm ow ox np lq oy oz nr pa bi translated">多重处理</h2><ul class=""><li id="6b47" class="mr ms it lb b lc nt lf nu li pb lm pc lq pd lu mw mx my mz bi translated">使用多个CPU内核。</li><li id="610f" class="mr ms it lb b lc pe lf pf li pg lm ph lq pi lu mw mx my mz bi translated">能够一次写入许多磁盘。</li><li id="a432" class="mr ms it lb b lc pe lf pf li pg lm ph lq pi lu mw mx my mz bi translated">当您需要非常快速地执行许多计算时，这是最佳选择。</li><li id="2714" class="mr ms it lb b lc pe lf pf li pg lm ph lq pi lu mw mx my mz bi translated">除非特别说明，否则在附加内核中只使用一个线程。(如果你没有一个好的设计计划，代码会很快变得混乱)</li><li id="5cec" class="mr ms it lb b lc pe lf pf li pg lm ph lq pi lu mw mx my mz bi translated">在进程之间共享数据是困难的。</li></ul><h2 id="f100" class="op nc it bd nd oq or dn nh os ot dp nl li ou ov nn lm ow ox np lq oy oz nr pa bi translated">阿辛西奥</h2><ul class=""><li id="6240" class="mr ms it lb b lc nt lf nu li pb lm pc lq pd lu mw mx my mz bi translated">依赖于线程，但是线程将任务委托给系统来执行工作，并从委托的任务中获得结果。</li><li id="988e" class="mr ms it lb b lc pe lf pf li pg lm ph lq pi lu mw mx my mz bi translated">当与多处理搭配使用时，您可以通过将多线程委托给系统来有效地使用所有内核。</li><li id="e1eb" class="mr ms it lb b lc pe lf pf li pg lm ph lq pi lu mw mx my mz bi translated">最适合I/O较慢但需要多个连接的情况(例如，web服务器或web crawler)。</li><li id="3468" class="mr ms it lb b lc pe lf pf li pg lm ph lq pi lu mw mx my mz bi translated">不适合基于CPU的任务，因为它依赖于线程。</li></ul><h1 id="d7bc" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">摘要</h1><p id="1c97" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">今天我们学习了多重处理，以及如何用它来快速执行计算。我们做了更多的数据科学研究，发现当我们在示例中从线程切换到多处理时，处理时间大大减少，这是一项基于CPU的任务。</p><p id="c49a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还研究了如何在进程间共享数据。虽然这看起来很简单，因为例子就在那里，但我第一次尝试使用多处理时，花了一段时间才弄清楚。随着您编写更多的多处理代码，这将变得更加容易。所以继续练习。</p><p id="ef6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们总结了编写异步代码的所有不同方法，并查看了一些提示来帮助我们记住哪种工具适合这项工作。</p><h2 id="8467" class="op nc it bd nd oq or dn nh os ot dp nl li ou ov nn lm ow ox np lq oy oz nr pa bi translated">建议阅读和查看</h2><p id="9428" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">Python文档中的多重处理。</p><div class="lv lw gp gr lx ly"><a href="https://docs.python.org/3.7/library/multiprocessing.html" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">多处理—基于进程的并行性— Python 3.7.4rc1文档</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">该模块还引入了在模块中没有类似物的API。这方面的一个主要例子是…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">docs.python.org</p></div></div></div></a></div><p id="68e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自Python wiki的全局解释器锁。</p><div class="lv lw gp gr lx ly"><a href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">global interpreter lock-Python Wiki</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">在CPython中，全局解释器锁或GIL是一个互斥体，它保护对Python对象的访问，防止多个…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">wiki.python.org</p></div></div></div></a></div><p id="30df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Raymond Hettinger，并发主题演讲— PyBay 2017</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pj nz l"/></div></figure><h1 id="ddc2" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">下一步是什么？</h1><p id="aec0" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">在那之后，我们的话题越来越少了。我们已经讨论了Python教程中的大部分内容和一些没有包括的内容。我已经决定我不想涉及标准库。当你写代码的时候，这是很自然的事情，如果我写了，会让你超负荷。</p><p id="accf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们确实需要涵盖所有编程语言的一个关键方面。测试！</p><p id="ec46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，你可以不写测试就写一个程序，它会工作的(看这里前面的例子)。到目前为止，测试是您为应用程序所做的最重要的事情。</p><p id="2169" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是让我们面对现实吧，即使你的应用被设计成做一些<em class="na">惊人的</em> <em class="na">事情</em>，如果它不能做<em class="na">任何事情</em>，那它就完全没用了。所以现在还不要发布你的应用。测试一下。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/beginning-python-programming-part-16-5703d8f0fad3" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Python编程入门—第16部分</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">让我们来谈谈测试驱动开发</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="pk l mj mk ml mh mm ks ly"/></div></div></a></div></div></div>    
</body>
</html>