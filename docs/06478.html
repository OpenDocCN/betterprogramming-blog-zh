<html>
<head>
<title>Routing in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中的路由</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/routing-in-swiftui-1dc87b7a47c7?source=collection_archive---------0-----------------------#2020-10-06">https://betterprogramming.pub/routing-in-swiftui-1dc87b7a47c7?source=collection_archive---------0-----------------------#2020-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="edc3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">SwiftUI中路由的2种解决方案</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0cb18e0b9816903ff89dbb159aeec85e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YK3JS-OPwkZl7T68"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Javier Allegue Barros<a class="ae kv" href="https://unsplash.com/@soymeraki?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在</a><a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="d1ce" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">目的</h1><ul class=""><li id="fe68" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">将导航逻辑与视图层分离。它允许你在不修改视图的情况下改变导航。</li><li id="98e1" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">通过使导航更加灵活来简化任务的实现，如深度链接</li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="3a42" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated">SwiftUI特定信息</h1><p id="8613" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">SwiftUI的声明性质使得将导航从视图层中分离出来很有挑战性。推送导航需要在视图中插入一个<code class="fe nk nl nm nn b">NavigationLink</code>。模态表示需要在视图代码中的某个地方添加<code class="fe nk nl nm nn b">.sheet</code>修饰符。您必须为<code class="fe nk nl nm nn b">NavigationLink</code>和<code class="fe nk nl nm nn b">.sheet</code>提供目的地视图。同样，一般来说，您将使用<code class="fe nk nl nm nn b">@state</code>属性来触发导航。</p><p id="9bce" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">这与UIKit不同。例如，要在UIKit中有模式地呈现一个视图，在当前视图控制器上调用<code class="fe nk nl nm nn b">present</code> <strong class="lq ir"> <em class="nt"> </em> </strong>并传递一个目的视图控制器来显示就足够了。这可以在呈现视图控制器之外轻松完成。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="e073" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated">解决方法</h1><p id="d347" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">我们将考虑两种不同的解决方案来将导航从视图层中分离出来。两者都使用本地SwiftUI导航方法<code class="fe nk nl nm nn b">NavigationLink</code>和<code class="fe nk nl nm nn b">.sheet</code>修饰符。但是提供目的地视图和导航状态将被转移到路由器。</p><ol class=""><li id="bb92" class="lo lp iq lq b lr no lt np lv nu lx nv lz nw mb nx md me mf bi translated"><strong class="lq ir">具有触发视图的路由器:</strong>路由器将返回所有可能导航路线的触发子视图，以将它们插入到呈现视图中。这样的子视图代码片段将包含一个<code class="fe nk nl nm nn b">NavigationLink</code>或<code class="fe nk nl nm nn b">.sheet</code>修饰符，以及一个指定的目的视图，并将使用一个<code class="fe nk nl nm nn b">@state</code>属性，通过绑定存储在路由器中。这样，呈现的视图将不再依赖于导航代码和目的地，而只依赖于路由器协议。</li><li id="a8aa" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb nx md me mf bi translated"><strong class="lq ir">带有类型擦除修饰符的路由器:</strong>一个正在呈现的视图将被配置为带有通用修饰符，用于呈现任何其他视图。被路由器初始化后，这些修改器将通过绑定跟踪存储在路由器中的导航状态，并在路由器改变该状态时执行导航。路由器还将具有所有可能的导航功能。这些函数将改变状态并触发导航。</li></ol><h2 id="67a9" class="ny kx iq bd ky nz oa dn lc ob oc dp lg lv od oe li lx of og lk lz oh oi lm oj bi translated">用法示例</h2><p id="b84e" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">为了更容易理解，让我们在一个简单示例的上下文中考虑这两种解决方案。</p><p id="b972" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">该项目将由两个简单的视图组成:一个带有单个按钮的呈现视图和一个当用户点击按钮时应该导航到的呈现视图。呈现的视图将显示从呈现视图传递的文本。点击该文本将会关闭显示的视图。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="372c" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated">1.带触发视图的路由器</h1><h2 id="e4c8" class="ny kx iq bd ky nz oa dn lc ob oc dp lg lv od oe li lx of og lk lz oh oi lm oj bi translated">呈现视图</h2><p id="c722" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">呈现视图由知道如何导航到呈现视图的路由器初始化。路由器提供了一个触发器视图，插入该视图后，可以响应用户交互来执行所需的导航。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="f940" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">使用<code class="fe nk nl nm nn b">PresentingRouterProtocol</code>代替实际的路由器类允许我们很容易地改变导航逻辑，并用模拟路由器初始化<code class="fe nk nl nm nn b">PresentingView</code>进行测试。</p><p id="963c" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">我们应该用<code class="fe nk nl nm nn b">@StateObject</code>(iOS 14可用)包装路由器属性。这是因为导航状态驻留在路由器中，并且视图应该在状态改变时更新。此外，与<code class="fe nk nl nm nn b">@ObservedObject</code>，<strong class="lq ir"> <em class="nt"> </em> </strong>相反，该包装器<strong class="lq ir"> <em class="nt"> </em> </strong>避免了每次更新所有者视图时重新创建路由器。这对于我们实现基于<code class="fe nk nl nm nn b">NavigationLink</code>的推送导航至关重要。</p><h2 id="c371" class="ny kx iq bd ky nz oa dn lc ob oc dp lg lv od oe li lx of og lk lz oh oi lm oj bi translated">路由器协议</h2><p id="3ce0" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">有两个协议。第一个视图由可以导航到其他视图的路由器使用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="46f4" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated"><code class="fe nk nl nm nn b">NavigationState</code> <strong class="lq ir"> <em class="nt"> </em> </strong>将被实现为子类中的一个结构。它将包含所有可能的导航路线的状态变量。<code class="fe nk nl nm nn b">binding</code> <strong class="lq ir"> <em class="nt"> </em> </strong>是一个方便的<strong class="lq ir"> <em class="nt"> </em> </strong>函数，用于获取已有状态变量的绑定。</p><p id="16e9" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">另一个协议用于视图的路由器，这些视图以模态方式呈现或在导航视图上推送。它能让我们回到过去。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="62d3" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">通常，路由器会同时符合<code class="fe nk nl nm nn b">PresentingRouter</code>和<code class="fe nk nl nm nn b">PresentedRouter</code>协议。</p><h2 id="c7e5" class="ny kx iq bd ky nz oa dn lc ob oc dp lg lv od oe li lx of og lk lz oh oi lm oj bi translated">路由器实施</h2><p id="4f8c" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">符合<code class="fe nk nl nm nn b">PresentingRouterProtocol</code>的路由器应该能够导航到详细视图。所以它的<code class="fe nk nl nm nn b">navigationState</code>应该包含这个路由的变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="6d5b" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated"><code class="fe nk nl nm nn b">presentDetails</code> <strong class="lq ir"> <em class="nt"> </em> </strong>函数使用来自<code class="fe nk nl nm nn b">NavigatingRouter</code>协议扩展的<code class="fe nk nl nm nn b">binding</code>函数来提供对相应状态变量的访问，包括目的地视图的路由器和返回的触发视图。目的地路由器将使用此绑定来删除。触发器视图将使用该绑定来触发导航。</p><h2 id="ebdf" class="ny kx iq bd ky nz oa dn lc ob oc dp lg lv od oe li lx of og lk lz oh oi lm oj bi translated">触发视图</h2><p id="44a4" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">路由器返回执行实际导航的触发视图，以响应用户操作。我们将只回顾两种最有用的触发视图，尽管可能有更多的触发视图。两者都接受一个内容视图，并将其转换成一个可以导航到指定目标视图的结果按钮。</p><p id="7ccf" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">第一个是上面例子中使用的<code class="fe nk nl nm nn b">SheetButton</code> <strong class="lq ir"> <em class="nt">，</em> </strong>。它用SwiftUI <code class="fe nk nl nm nn b">.sheet</code>修饰符实现了模态导航。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="14c3" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">第二个是<code class="fe nk nl nm nn b">NavigationButton</code>。它提供用内部的<code class="fe nk nl nm nn b">NavigationLink</code>实现的推送导航。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="fb05" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">我们使用<code class="fe nk nl nm nn b">NavigationLink</code> <strong class="lq ir"> <em class="nt"> </em> </strong>初始化器<strong class="lq ir"> <em class="nt"> </em> </strong>与<strong class="lq ir"><em class="nt"/></strong><code class="fe nk nl nm nn b">isActive</code><strong class="lq ir"><em class="nt"/></strong>绑定在这里因为我们要在路由器中保持导航状态。</p><p id="ab21" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">在<code class="fe nk nl nm nn b">SheetButton</code>和<code class="fe nk nl nm nn b">NavigationButton</code>中拥有相同的初始化参数使得将导航类型从模态呈现改为推送导航变得容易——反之亦然。</p><h2 id="5796" class="ny kx iq bd ky nz oa dn lc ob oc dp lg lv od oe li lx of og lk lz oh oi lm oj bi translated">BasePresentedRouter类</h2><p id="55b5" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">取消功能是很常见的。因此，我们还将介绍一个简单的基本路由器类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="daaf" class="ny kx iq bd ky nz oa dn lc ob oc dp lg lv od oe li lx of og lk lz oh oi lm oj bi translated">呈现的视图</h2><p id="9e8b" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">细节视图只能显示，不执行任何其他类型的导航。正因为如此，我们将使用基本的<code class="fe nk nl nm nn b">BasePresentedRouter</code> <strong class="lq ir"> <em class="nt"> </em> </strong>路由器，这里不进行子类化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="3dab" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">我们可以在<code class="fe nk nl nm nn b">PresentedView</code>中声明没有<strong class="lq ir"> <em class="nt"> </em> </strong>包装器的<strong class="lq ir"> <em class="nt"> </em> </strong> <code class="fe nk nl nm nn b">router</code>属性，因为我们只使用它来解除，所以视图不需要监听路由器的状态变化。</p><p id="9501" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">当用户点击文本时，我们隐藏视图。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="6506" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated">2.具有类型擦除修饰符的路由器</h1><p id="3c1c" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">这个解决方案中的导航以不同的方式实现——使用修饰符。我称它们为<em class="nt">类型删除</em>，因为它们不依赖于特定的目的地视图。添加一次后，他们可以导航到任何视图。</p><h2 id="2ed0" class="ny kx iq bd ky nz oa dn lc ob oc dp lg lv od oe li lx of og lk lz oh oi lm oj bi translated">呈现视图</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="e1a1" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">为了允许将任何视图推到导航视图上，我们应该添加一个<code class="fe nk nl nm nn b">.navigation</code>修饰符，并将路由器作为单个参数传递。类似地，为了能够呈现一个表，我们使用了一个<code class="fe nk nl nm nn b">.sheet</code>修饰符。我们可以将它添加到<code class="fe nk nl nm nn b">body</code>的任何子视图中。是一个自定义的<code class="fe nk nl nm nn b">.sheet</code> <strong class="lq ir"> <em class="nt"> </em> </strong>修饰符，以路由器为参数。</p><p id="9107" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">通过按钮的操作调用路由器的<code class="fe nk nl nm nn b">presentDetails</code>功能，呈现视图导航到呈现视图。</p><h2 id="0835" class="ny kx iq bd ky nz oa dn lc ob oc dp lg lv od oe li lx of og lk lz oh oi lm oj bi translated">路由器实施</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="860c" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">基类<code class="fe nk nl nm nn b">Router</code>实现了<code class="fe nk nl nm nn b">ObservableObject</code>协议，它的状态用<code class="fe nk nl nm nn b">@Published</code>包装，以允许状态变化传播到视图并更新导航。</p><p id="ea0e" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated"><code class="fe nk nl nm nn b">navigating</code>变量将推送导航驱动到<code class="fe nk nl nm nn b">NavigationView</code>上。它的值应该是目标视图。</p><p id="3777" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated"><code class="fe nk nl nm nn b">presentingSheet</code>是驾驶单演示。它的值也应该是目标视图。</p><p id="f4b1" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated"><code class="fe nk nl nm nn b">isPresented</code>是一个绑定到状态变量的布尔值，它驱动导航到当前视图。它应该从呈现路由器传递。</p><p id="7421" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">相应地，通过将目的地视图设置为<code class="fe nk nl nm nn b">navigation</code>或<code class="fe nk nl nm nn b">presentingSheet</code>状态属性，可以触发推送或模式导航。下面是路由器子类的一个方便界面。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="784d" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">正如您在上面看到的，路由器应该通过绑定到驱动所有者视图表示的<code class="fe nk nl nm nn b">Bool</code>属性来初始化。我们可以通过以下接口从呈现路由器获得它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="aec1" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated"><code class="fe nk nl nm nn b">boolBinding</code>这是一个私有函数，通过关键路径访问状态来实现。下面是路由器的私有扩展，其中也包含用于<code class="fe nk nl nm nn b">.navigation</code>和<code class="fe nk nl nm nn b">.sheet</code>修饰符的<code class="fe nk nl nm nn b">binding</code> <strong class="lq ir"> <em class="nt"> </em> </strong>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="0ab8" class="ny kx iq bd ky nz oa dn lc ob oc dp lg lv od oe li lx of og lk lz oh oi lm oj bi translated">。导航和。纸张修改器</h2><p id="05a5" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated"><code class="fe nk nl nm nn b">.navigation</code><code class="fe nk nl nm nn b">.sheet</code><strong class="lq ir"><em class="nt"/></strong>实际上是添加到<code class="fe nk nl nm nn b">View</code>扩展中的函数。他们以一个路由器为参数，将生成的视图修改器与路由器中对应的导航状态绑定:<code class="fe nk nl nm nn b">navigation</code> <strong class="lq ir"> <em class="nt"> </em> </strong>和<strong class="lq ir"><em class="nt"/></strong><code class="fe nk nl nm nn b">presentingSheet</code><strong class="lq ir"><em class="nt"/></strong>变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="1af9" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated"><code class="fe nk nl nm nn b">NavigationModifier</code> <strong class="lq ir"> <em class="nt"> </em> </strong>在<code class="fe nk nl nm nn b">NavigationLink</code> <strong class="lq ir"> <em class="nt"> </em> </strong>内部实现，使用提供的绑定触发展现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="f3de" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated"><code class="fe nk nl nm nn b">SheetModifier</code> <strong class="lq ir"> <em class="nt"> </em> </strong>是用SwiftUI <code class="fe nk nl nm nn b">.sheet</code> <strong class="lq ir"> <em class="nt"> </em> </strong>修改器以非常相似的方式实现的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="c29d" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated"><strong class="lq ir">细分路由器</strong></p><p id="628b" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">基本<code class="fe nk nl nm nn b">Router</code>类的上述实现允许它的子类非常简单。我们只需要为可用的导航选项添加功能。</p><p id="47b6" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">在我们的例子中，它将是一个单独的<code class="fe nk nl nm nn b">presentDetails</code>函数。为了执行导航，我们需要创建一个目的地视图，用相应的路由器初始化它，并使用基类的一个便利方法(<code class="fe nk nl nm nn b">navigateTo</code>或<code class="fe nk nl nm nn b">presentSheet</code>)来触发所需类型的导航。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="0c86" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">然后，当我们想要呈现<code class="fe nk nl nm nn b">PresentedView</code>时，我们可以从任何视点代码调用它。在我们的例子中是按钮的动作闭包。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="b944" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">如果我们想从推送导航切换到模态，我们唯一需要做的就是将<code class="fe nk nl nm nn b">navigateTo</code> <strong class="lq ir"> <em class="nt"> </em> </strong>调用替换为<code class="fe nk nl nm nn b">presentSheet</code>。</p><h2 id="133a" class="ny kx iq bd ky nz oa dn lc ob oc dp lg lv od oe li lx of og lk lz oh oi lm oj bi translated">呈现的视图</h2><p id="5dab" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">与第一个解决方案相同。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="022c" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated">深层链接</h1><p id="7d4d" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">这两种解决方案在路由器内部都有导航状态。这使我们能够通过简单地改变路由器的状态来执行导航和实现深度链接。但是，第一种解决方案需要添加适当的触发器视图，以允许可能的深层链接路由。第二种解决方案对目标视图使用类型擦除。所以只需要一般的<code class="fe nk nl nm nn b">.navigation</code>和<code class="fe nk nl nm nn b">.sheet</code>修改器。</p><h1 id="cdab" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">比较</h1><p id="23ef" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">这两种解决方案都将导航逻辑从视图层中分离出来。两者都将导航状态存储在路由器中。两者都需要一些代码来插入到视图中进行导航。该代码在内部使用了<code class="fe nk nl nm nn b">NavigationLink</code>或<code class="fe nk nl nm nn b">.sheet</code>修饰符。</p><p id="6c55" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">在这两种解决方案中，将导航类型从模态导航更改为推送导航是微不足道的，反之亦然。</p><p id="e705" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">在第一种解决方案中，导航是通过路由器返回的触发器视图来执行的。并且在第二种解决方案中使用通用类型擦除修饰符。在第一个解决方案中，我们需要通过插入相应的触发子视图来预配置一个包含所有可能路径的视图。在第二种解决方案中，添加新路线不需要更改视图，因为<strong class="lq ir"> <em class="nt"> </em> </strong> <code class="fe nk nl nm nn b">.navigation</code>和<code class="fe nk nl nm nn b">.sheet</code>修改器支持任何目的地视图。</p><p id="0b92" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">例如，假设某个视图可以导航到三个不同视图，将它们推到一个导航堆栈上。在这种情况下，我们需要在第一个解决方案中插入三个触发视图，在第二个解决方案中只插入一个<code class="fe nk nl nm nn b">.navigation</code>修改器。这种差异使得第二种解决方案中的导航更加灵活。</p><p id="d922" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">子类化在第二个解决方案中更简单，因为有存储所有导航状态的基本路由器超类。</p><p id="6745" class="pw-post-body-paragraph mx my iq lq b lr no jr mz lt np ju na lv nq nc nd lx nr nf ng lz ns ni nj mb ij bi translated">第二种解决方案的一个缺点是基类需要存储所有三个导航状态变量:<code class="fe nk nl nm nn b">navigating</code>、<code class="fe nk nl nm nn b">presentingSheet</code>和<code class="fe nk nl nm nn b">isPresented</code>，即使它们并不都是特定子类必须使用的。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="0b23" class="kw kx iq bd ky kz ms lb lc ld mt lf lg jw mu jx li jz mv ka lk kc mw kd lm ln bi translated">资源</h1><p id="bcd0" class="pw-post-body-paragraph mx my iq lq b lr ls jr mz lt lu ju na lv nb nc nd lx ne nf ng lz nh ni nj mb ij bi translated">您可以在我的GitHub资源库中找到本文中使用的源代码:</p><ul class=""><li id="06f1" class="lo lp iq lq b lr no lt np lv nu lx nv lz nw mb mc md me mf bi translated"><a class="ae kv" href="https://github.com/ihorvovk/Routing-in-SwiftUI-with-trigger-views" rel="noopener ugc nofollow" target="_blank">带触发视图的路由</a></li><li id="5504" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="https://github.com/ihorvovk/Routing-in-SwiftUI-with-type-erased-modifiers" rel="noopener ugc nofollow" target="_blank">使用类型删除修饰符的路由</a></li></ul></div></div>    
</body>
</html>