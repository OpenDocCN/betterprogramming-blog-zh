<html>
<head>
<title>What Are Template Literal Types in TypeScript 4.1?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4.1中的模板文字类型是什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typescript-new-release-19f1238c6a68?source=collection_archive---------4-----------------------#2020-12-03">https://betterprogramming.pub/typescript-new-release-19f1238c6a68?source=collection_archive---------4-----------------------#2020-12-03</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="f469" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://rakiabensassi.medium.com/list/software-engineering-7a179a23ebfd" rel="noopener">网络开发</a></h2><div class=""/><div class=""><h2 id="6355" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated"><strong class="ak">递归条件类型，React的JSX工厂，以及新TypeScript版本中的更多特性</strong></h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/6e38be99ec345ca248f594fe4358b8a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fzrx2nLUkboLRkKb"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">科尔顿·迪安·马歇尔在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="1feb" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我已经使用TypeScript很多年了，发现它非常容易理解——特别是作为一个有Java背景的人。但是在阅读了关于TypeScript 4.1(该语言的最新重大更新)的新闻后，我惊讶于我所不知道的东西。</p><p id="dd26" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我不认为我的无知是个例外。在利用新闻作为更深入了解类型系统实际工作方式的机会后，我想与您分享新版本中令人兴奋的功能和变化，其中包含对关键字的解释和大量非神秘化的示例。</p><p id="b609" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你确信你已经牢固掌握了所有的语言基础，并且渴望学习高级功能，那么让我们开始吧。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="8c03" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">新的语言功能</h1><h2 id="5ab8" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">模板文字类型</h2><p id="95eb" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">在ES6中引入的模板文字允许您在处理字符串时使用反斜线而不是单引号或双引号:</p><pre class="kt ku kv kw gu nu nv nw nx aw ny bi"><span id="1da2" class="ne mn iu nv b gz nz oa l ob oc">const message = `text`;</span></pre><p id="cf47" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">正如<a class="ae li" href="https://flaviocopes.com/javascript-template-literals/" rel="noopener ugc nofollow" target="_blank"> Flavio Copes </a>所指出的，它们提供了许多用引号构建的普通字符串所没有的特性:</p><ul class=""><li id="58ae" class="od oe iu ll b lm ln lp lq ls of lw og ma oh me oi oj ok ol bi translated">它们提供了很好的语法来定义多行字符串。</li><li id="c686" class="od oe iu ll b lm om lp on ls oo lw op ma oq me oi oj ok ol bi translated">它们提供了一种在字符串中插入变量和表达式的简单方法。</li><li id="67de" class="od oe iu ll b lm om lp on ls oo lw op ma oq me oi oj ok ol bi translated">它们允许你用模板标签创建DSL(领域特定语言)。</li></ul><p id="8484" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">模板文字类型与JavaScript中的<a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank">模板文字字符串</a>具有相同的语法，除了它用在类型位置:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">TypeScript 4.1模板文本字符串类型</p></figure><p id="93cb" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当与具体的文字类型一起使用时，通过连接内容会产生一个新的字符串文字类型。</p><h2 id="5ebe" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">映射类型中的键重新映射</h2><p id="ee80" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">映射类型可以基于任意键创建新的对象类型。字符串可以在映射类型中用作属性名:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">TypeScript映射类型</p></figure><p id="bac2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果您希望能够创建新的键或过滤掉键，TypeScript 4.1允许您用一个新的<code class="fe ot ou ov nv b">as</code>子句重新映射映射类型中的键:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">打字稿<a class="ae li" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types" rel="noopener ugc nofollow" target="_blank">重映射键</a></p></figure><p id="691f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">新的<code class="fe ot ou ov nv b">as</code>子句允许您利用模板文字类型等特性，轻松地基于旧的属性名称创建新的属性名称。可以通过生成<code class="fe ot ou ov nv b">never</code>来过滤键，这样在某些情况下就不必使用额外的<code class="fe ot ou ov nv b">Omit</code>辅助类型:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">TypeScript通过as子句利用模板文字类型(<a class="ae li" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types" rel="noopener ugc nofollow" target="_blank"> source </a>)</p></figure></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="dde6" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">JSX工厂</h1><p id="7b86" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">JSX代表JavaScript XML。它允许你用JavaScript编写HTML元素并把它们放在DOM中，而不需要任何<code class="fe ot ou ov nv b">createElement()</code>和/或<code class="fe ot ou ov nv b">appendChild()</code>方法。这里有一个例子:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">反应JSX工厂功能</p></figure><p id="a93c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">TypeScript 4.1通过<code class="fe ot ou ov nv b">jsx</code>编译器选项的两个新选项支持React 17的<code class="fe ot ou ov nv b">jsx</code>和<code class="fe ot ou ov nv b">jsxs</code>工厂函数:</p><ul class=""><li id="695e" class="od oe iu ll b lm ln lp lq ls of lw og ma oh me oi oj ok ol bi translated"><code class="fe ot ou ov nv b">react-jsx</code></li><li id="c51f" class="od oe iu ll b lm om lp on ls oo lw op ma oq me oi oj ok ol bi translated"><code class="fe ot ou ov nv b">react-jsxdev</code></li></ul><blockquote class="ow"><p id="fc9b" class="ox oy iu bd oz pa pb pc pd pe pf me dk translated">这些选项分别用于生产编译和开发编译。通常，一方的选择可以延伸到另一方。”— <a class="ae li" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html" rel="noopener ugc nofollow" target="_blank">打字稿发行说明</a></p></blockquote><p id="2317" class="pw-post-body-paragraph lj lk iu ll b lm pg ke lo lp ph kh lr ls pi lu lv lw pj ly lz ma pk mc md me in bi translated">以下是TypeScript文档中关于生产和开发配置的两个示例:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">tsconfig.json: <a class="ae li" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html" rel="noopener ugc nofollow" target="_blank">生产构建的TypeScript配置示例</a></p></figure><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">tsconfig.dev.json: <a class="ae li" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html" rel="noopener ugc nofollow" target="_blank">开发构建的TypeScript配置示例</a></p></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pl"><img src="../Images/8bc150680f90d648c723c4d33ea90548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*Zr-oxARXGZ1tUXSLDbHoiw.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">TypeScript 4.1支持React ( <a class="ae li" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">图片来源</a>)等JSX环境中丰富的类型检查</p></figure></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="f7c2" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">递归条件类型</h1><p id="62b2" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">当前版本的另一个新特性是递归条件类型。通过允许条件类型在其分支内引用自身，它们提供了更灵活的条件类型处理。这个特性使得编写递归类型别名变得更加容易。下面是一个使用<code class="fe ot ou ov nv b">Awaited</code>解开深层嵌套承诺的例子:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">打字稿<code class="fe ot ou ov nv b">Awaited</code></p></figure><p id="41f5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">但是，应该注意的是，TypeScript需要更多的时间来对递归类型进行类型检查。微软警告说，应该负责任地谨慎使用它们。</p><h2 id="9cb2" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">检查索引访问</h2><p id="e6d7" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">TypeScript中的索引签名允许你访问任意命名的属性，如下面的<code class="fe ot ou ov nv b">Options</code>接口所示。在这里，我们看到没有名字<code class="fe ot ou ov nv b">path</code>或名字<code class="fe ot ou ov nv b">permissions</code>的被访问属性应该具有类型<code class="fe ot ou ov nv b">string | number</code>:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">类型脚本检查索引访问(示例<a class="ae li" href="https://gist.github.com/rakia/4a844b0b8931ef2f813e7ec36bd55704" rel="noopener ugc nofollow" target="_blank">源</a></p></figure><p id="8db7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">一个新的标志，<code class="fe ot ou ov nv b">--noUncheckedIndexedAccess</code>，提供了一个节点，其中每个属性访问(如<code class="fe ot ou ov nv b">opts.path</code>)或索引访问(如<code class="fe ot ou ov nv b">opts["blabla"]</code>)都被认为是潜在未定义的。这意味着，如果您需要访问一个类似于上一个示例中的<code class="fe ot ou ov nv b">opts.path</code>的属性，您必须检查它是否存在，或者使用一个非空断言操作符(后缀<code class="fe ot ou ov nv b">!</code>字符):</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">打字稿<code class="fe ot ou ov nv b">--noUncheckedIndexedAccess</code>(示例<a class="ae li" href="https://gist.github.com/rakia/4a844b0b8931ef2f813e7ec36bd55704" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></figure><p id="e999" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe ot ou ov nv b">--noUncheckedIndexedAccess</code>标志对于捕捉大量错误是有用的，但是对于大量代码来说可能是嘈杂的。这就是为什么它不会被<code class="fe ot ou ov nv b">--strict</code>标志自动使能。</p><h2 id="8b37" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">没有<code class="fe ot ou ov nv b">baseUrl</code>的路径</h2><p id="ae0d" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">在TypeScript 4.1之前，为了能够在<code class="fe ot ou ov nv b">tsconfig.json</code>文件中使用<code class="fe ot ou ov nv b">paths</code>，您必须声明<code class="fe ot ou ov nv b">baseUrl</code>参数。在新版本中，可以指定不带<code class="fe ot ou ov nv b">baseUrl</code>的<code class="fe ot ou ov nv b">paths</code>选项。这解决了自动导入中路径不佳的问题。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">tsconfig.json中的TypeScript路径和baseUrl</p></figure><h2 id="fa8c" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated"><code class="fe ot ou ov nv b">checkJs</code>现在暗指<code class="fe ot ou ov nv b">allowJs</code></h2><p id="24e0" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">如果您有一个JavaScript项目，您使用<code class="fe ot ou ov nv b">checkJs</code>选项来报告。js文件，您还应该声明<code class="fe ot ou ov nv b">allowJs</code>来允许编译JavaScript文件。在TypeScript 4.1中，情况不再如此。<code class="fe ot ou ov nv b">checkJs</code>现在默认暗示<code class="fe ot ou ov nv b">allowJs</code>:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">在tsconfig.json中键入checkjs和allowjs</p></figure><h2 id="e45a" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">JSDoc <code class="fe ot ou ov nv b">@see </code>标签的编辑器支持</h2><p id="ce1a" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">当在编辑器中使用TypeScript时，现在对JSDoc标签<code class="fe ot ou ov nv b"><a class="ae li" href="http://twitter.com/see" rel="noopener ugc nofollow" target="_blank">@see</a></code>有了更好的支持。这应该会提高TypeScript 4.1的可用性:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">TypeScript @see(示例<a class="ae li" href="https://gist.github.com/rakia/4a844b0b8931ef2f813e7ec36bd55704" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></figure></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="271a" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">重大变化</h1><h2 id="5138" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated"><code class="fe ot ou ov nv b">lib.d.ts</code>变化</h2><p id="789e" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated"><code class="fe ot ou ov nv b"><a class="ae li" href="https://basarat.gitbook.io/typescript/type-system/lib.d.ts#:~:text=This%20file%20contains%20the%20ambient,context%20of%20a%20TypeScript%20project." rel="noopener ugc nofollow" target="_blank">lib.d.ts</a></code>是每次安装TypeScript时提供的文件。它包含JavaScript运行时和DOM中各种常见JavaScript结构的环境声明，使您可以轻松地开始编写类型检查的JavaScript代码。</p><p id="473a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">该文件自动包含在TypeScript项目的编译上下文中。您可以通过指定<code class="fe ot ou ov nv b">--noLib</code>编译器命令行标志或<code class="fe ot ou ov nv b">tsconfig.json</code>中的<code class="fe ot ou ov nv b">"noLib": true</code>来排除它。</p><p id="e0ee" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在TypeScript 4.1中，由于DOM类型是如何自动生成的，<code class="fe ot ou ov nv b">lib.d.ts</code>可能有一组更改的API。例如<code class="fe ot ou ov nv b">Reflect.enumerate</code>已被删除，因为它已从ES2016中删除。</p><h2 id="c5a4" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated"><code class="fe ot ou ov nv b">abstract</code>成员不能被标记<code class="fe ot ou ov nv b">async</code></h2><p id="8f3c" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">另一个突破性的变化是，标记为<code class="fe ot ou ov nv b">abstract</code>的成员不能再标记为<code class="fe ot ou ov nv b">async</code>。所以要修复你的代码，你必须删除关键字<code class="fe ot ou ov nv b">async</code>:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">TypeScript抽象类</p></figure><h2 id="0b70" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated"><code class="fe ot ou ov nv b">any</code> / <code class="fe ot ou ov nv b">unknown</code>在虚假位置繁殖</h2><p id="8b00" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">在TypeScript 4.1之前，对于类似于<code class="fe ot ou ov nv b">foo &amp;&amp; somethingElse</code>的表达式，<code class="fe ot ou ov nv b">foo</code>的类型是<code class="fe ot ou ov nv b">any</code>或<code class="fe ot ou ov nv b">unknown</code>。整个表达式的类型是<code class="fe ot ou ov nv b">somethingElse</code>的类型，在下面的例子中是<code class="fe ot ou ov nv b">{ someProp: string }</code>:</p><pre class="kt ku kv kw gu nu nv nw nx aw ny bi"><span id="bff3" class="ne mn iu nv b gz nz oa l ob oc">declare let foo: unknown;<br/>declare let somethingElse: { someProp: string };</span><span id="cdf5" class="ne mn iu nv b gz pn oa l ob oc">let x = foo &amp;&amp; somethingElse;</span></pre><p id="8611" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在TypeScript 4.1中，<code class="fe ot ou ov nv b">any</code>和<code class="fe ot ou ov nv b">unknown</code>向外传播，而不是右侧的类型。通常，解决这种变化的适当方法是从<code class="fe ot ou ov nv b">foo &amp;&amp; someExpression</code>切换到<code class="fe ot ou ov nv b">!!foo &amp;&amp; someExpression</code>。</p><p id="a480" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><em class="pm">注意:双惊叹号(</em> <code class="fe ot ou ov nv b"><em class="pm">!!</em></code> <em class="pm">)是将变量转换为布尔值(真或假)的一种简便方法。</em></p><h2 id="c3c3" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">在p <code class="fe ot ou ov nv b">romise</code>中<code class="fe ot ou ov nv b">resolve</code>的参数不再是可选的</h2><p id="8218" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated"><code class="fe ot ou ov nv b">resolve</code>参数在<code class="fe ot ou ov nv b">Promise</code>中不再可选:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">promise中的打字稿解析</p></figure><p id="d650" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">上一个示例可能会引发如下错误:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">TypeScript解析错误</p></figure><p id="59c7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">作为一个解决方案，在promises中必须给<code class="fe ot ou ov nv b">resolve</code>至少一个值，否则在确实需要不带参数调用<code class="fe ot ou ov nv b">resolve()</code>的情况下，您必须用显式的<code class="fe ot ou ov nv b">void</code>泛型类型参数来声明<code class="fe ot ou ov nv b">Promise</code>:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">带有void泛型参数的TypeScript promise</p></figure><h2 id="c80c" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">条件差价创建可选属性</h2><p id="44f2" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">在JavaScript中，对象扩展<code class="fe ot ou ov nv b">{ ...files }</code>不会对falsy值进行操作。这意味着如果是<code class="fe ot ou ov nv b">null</code>或<code class="fe ot ou ov nv b">undefined</code>，将跳过<code class="fe ot ou ov nv b">files</code>。</p><p id="c3f4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在以下使用条件展开的示例中，如果定义了<code class="fe ot ou ov nv b">file</code>，则<code class="fe ot ou ov nv b">file.owner</code>的属性将被展开。否则，没有属性会传播到返回的对象中:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div></figure><p id="ad0c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在TypeScript 4.1之前，<code class="fe ot ou ov nv b">getOwner</code>返回了基于每个跨页的联合类型:</p><pre class="kt ku kv kw gu nu nv nw nx aw ny bi"><span id="11b7" class="ne mn iu nv b gz nz oa l ob oc">{ x: number } | { x: number, name: string, age: number, location: string }</span></pre><ul class=""><li id="1c83" class="od oe iu ll b lm ln lp lq ls of lw og ma oh me oi oj ok ol bi translated">如果定义了<code class="fe ot ou ov nv b">file</code>，则所有来自<code class="fe ot ou ov nv b">Person</code>(<code class="fe ot ou ov nv b">owner</code>的类型)的属性。</li><li id="0ce8" class="od oe iu ll b lm om lp on ls oo lw op ma oq me oi oj ok ol bi translated">否则，它们都不会在结果中定义。</li></ul><p id="037e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然而，事实证明这最终是极其昂贵的，并且通常不是有益的——在单个对象中有数百个分布，并且每个分布潜在地增加了数百或数千个属性。为了提高性能，在TypeScript 4.1中，返回的类型有时使用全可选属性:</p><pre class="kt ku kv kw gu nu nv nw nx aw ny bi"><span id="08ef" class="ne mn iu nv b gz nz oa l ob oc">{<br/>    x:         number;<br/>    name?:     string;<br/>    age?:      number;<br/>    location?: string;<br/>}</span></pre><h2 id="b60e" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">不匹配的参数不再相关</h2><p id="e638" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">彼此不对应的参数先前在TypeScript中通过将它们与类型<code class="fe ot ou ov nv b">any</code>相关联而彼此相关。</p><p id="b74e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在下面的重载示例中(为同一个函数提供多个函数类型)，<code class="fe ot ou ov nv b">pickCard</code>函数将根据用户传入的内容返回两个不同的东西。如果用户传入一个代表卡片组的对象，该函数将选取卡片。如果用户选择卡片，他们将得到他们选择的卡片:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="or os l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">JavaScript重载(示例<a class="ae li" href="https://www.typescriptlang.org/docs/handbook/functions.html" rel="noopener ugc nofollow" target="_blank">源</a></p></figure><p id="3767" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在TypeScript 4.1中，某些可赋值性情况会失败，某些重载解析情况会失败。作为一种变通方法，您最好使用类型断言来避免错误。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="5ca6" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">最后的想法</h1><p id="d7e4" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">TypeScript通过在运行代码之前捕捉错误并提供修复来节省时间。通过更深入地理解它，您可以了解如何改进您的TypeScript应用程序结构并解决复杂的情况。希望本文能帮助您探索类型系统，并让您的编程之旅更加精彩。</p><p id="8dd1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">可以通过<a class="ae li" href="https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild" rel="noopener ugc nofollow" target="_blank"> NuGet </a>或NPM访问TypeScript 4.1</p><pre class="kt ku kv kw gu nu nv nw nx aw ny bi"><span id="19b8" class="ne mn iu nv b gz nz oa l ob oc">npm install typescript</span></pre></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><p id="d4c1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">🧠💡我为一群聪明、好奇的人写关于工程、技术和领导力的文章。<a class="ae li" href="https://rakiabensassi.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll je">加入我的免费电子邮件简讯独家访问</strong> </a> <strong class="ll je"> </strong>或注册媒体<a class="ae li" href="https://rakiabensassi.medium.com/membership" rel="noopener">这里</a>。</p><p id="b5f1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><em class="pm">你可以在Udemy上查看我的</em> <strong class="ll je"> <em class="pm">视频课程</em></strong><em class="pm">:</em><a class="ae li" href="https://www.udemy.com/course/identify-and-fix-javascript-memory-leaks/" rel="noopener ugc nofollow" target="_blank"><em class="pm">如何识别、诊断、修复Web Apps中的内存泄漏</em> </a> <em class="pm">。</em></p></div></div>    
</body>
</html>