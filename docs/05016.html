<html>
<head>
<title>50 Python Interview Questions and Answers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">50 Python面试问答</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/50-python-interview-questions-and-answers-f8e80d031bd3?source=collection_archive---------3-----------------------#2020-06-01">https://betterprogramming.pub/50-python-interview-questions-and-answers-f8e80d031bd3?source=collection_archive---------3-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="acc5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">测试你对Python的理解和你的编码技能，并在下一次工作面试中胜出</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/419787ae25a35b7291a74dfe9281a0e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*W-pLGmOoANd01uD62YE_Qw.png"/></div></figure><p id="b14a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">本文将涵盖Python编程语言的面试问题。虽然这个列表并不详尽，但它应该会让你对你可能遇到的问题类型有一个很好的了解。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="e6e1" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">Python面试问题—特定于语言</h1><h2 id="315c" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题1:链表和元组有什么区别？</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/66106eb11ff9739923e76c2cc419d563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X_bN2OUKvdOMn3llD2bVgA.png"/></div></div></figure><h2 id="4437" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">何时使用它们</strong></h2><p id="3604" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">只要用户知道元组中插入了什么，就应该使用元组<strong class="ks iu">。假设一所大学将学生的信息存储在一个数据结构中——为了使这些信息保持不变，应该将其存储在一个元组中。</strong></p><p id="cf49" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">由于<strong class="ks iu">列表</strong>为用户提供了更容易的可访问性，所以只要需要存储相似类型的对象，就应该使用它们。例如，如果一家杂货店需要在一个区域存储所有的乳制品，它应该使用一个列表。</p><h2 id="ea59" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题2:如何将列表转换成元组？</h2><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="b6a0" class="ml lu it ni b gy nm nn l no np">my_list = [50, "Twenty", 110, "Fifty", "Ten", 20, 10, 80, "Eighty"]</span><span id="ea7f" class="ml lu it ni b gy nq nn l no np">my_tuple = (my_list[0], my_list[len(my_list) - 1], len(my_list))<br/>print(my_tuple)</span></pre><p id="b337" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">输出:<code class="fe nr ns nt ni b">50, ‘Eighty’, 9</code></p><p id="57b1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们所要做的就是创建一个包含三个元素的元组。元组的第一个元素是列表的第一个元素，可以使用<code class="fe nr ns nt ni b">my_list[0]</code>找到。</p><p id="5309" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">元组的第二个元素是列表中的最后一个元素。<code class="fe nr ns nt ni b">my_list[len(my_list) - 1]</code>会给我们这种元素。我们也可以使用<code class="fe nr ns nt ni b">pop()</code>方法，但是那样会改变列表。</p><h2 id="8869" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题3:数组和列表有什么区别？</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nu"><img src="../Images/8980475e6ed263db593a55f559e4645f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xhEuoWpY9NymIpxxAfeVhw.png"/></div></div></figure><h2 id="1756" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题4:如何将一个列表转换成一个数组？</h2><p id="2789" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">在编程时，有时您需要将现有的列表转换为数组，以便对它们执行某些操作(数组支持以列表不支持的方式对它们执行数学运算)。</p><p id="9e8f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里我们将使用<code class="fe nr ns nt ni b">numpy.array()</code>。numpy库的这个函数将一个列表作为参数，并返回一个包含列表中所有元素的数组。请参见下面的示例:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="f7b5" class="ml lu it ni b gy nm nn l no np">import numpy as np<br/>my_list = [2,4,6,8,10]<br/>my_array = np.array(my_list)<br/># printing my_array<br/>print my_array<br/># printing the type of my_array<br/>print type(my_array)</span></pre><p id="6827" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">输出:<code class="fe nr ns nt ni b">[ 2 4 6 8 10]</code></p><h2 id="e37a" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题Python中内存是如何管理的？</h2><ul class=""><li id="b17a" class="nv nw it ks b kt nc kw nd kz nx ld ny lh nz ll oa ob oc od bi translated">内存管理由Python私有堆空间处理。所有Python对象和数据结构都位于私有堆中。程序员无权访问这个私有堆。Python解释器负责这个。</li><li id="8c77" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">Python对象的堆空间是由Python的内存管理器分配的。核心API为程序员提供了一些编程工具。</li><li id="864d" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">Python还有一个内置的垃圾收集器，它可以回收所有未使用的内存，这样就可以将这些内存用于堆空间。</li></ul><h2 id="96c8" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题Python中如何实现多线程？</h2><ul class=""><li id="50c4" class="nv nw it ks b kt nc kw nd kz nx ld ny lh nz ll oa ob oc od bi translated">Python有一个多线程包，但是如果你想要多线程来加速你的代码，那么使用它通常不是一个好主意。</li><li id="cac6" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">Python有一个称为全局解释器锁(GIL)的构造。GIL确保任何时候只有一个线程可以执行。一个线程获取GIL，做一点工作，然后将GIL传递给下一个线程。</li><li id="007b" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">这发生得非常快。看起来您的线程是并行执行的，但是它们实际上是轮流使用同一个CPU内核。</li><li id="57e3" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">所有这些GIL传递增加了执行的开销。这意味着如果你想让你的代码运行得更快，那么使用线程包通常不是一个好主意。</li></ul><h2 id="0497" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题7:什么是猴子打补丁？</h2><p id="e422" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">在Python中，术语monkey patch指的是运行时对类或模块的动态修改。</p><h2 id="a59e" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题8:什么是lambda函数？举例说明什么时候有用，什么时候没用。</h2><p id="72a7" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">lambda函数是一个小型匿名函数，它返回一个对象。lambda返回的对象通常被赋给一个变量，或者被用作其他更大函数的一部分。</p><p id="b7a5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用lambda关键字定义lambda函数，而不是使用传统的<code class="fe nr ns nt ni b">def</code>关键字来创建函数。lambda的结构如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oj"><img src="../Images/ef6cc6f9538b406922358bb278ecb7be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1Yfk_CU9sdmw8GHs.png"/></div></div></figure><h2 id="4e50" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">兰姆达斯的目的</strong></h2><p id="ff10" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">lambda比完整的函数更具可读性，因为它可以内嵌编写。所以当函数表达式很小时，使用lambdas是一个很好的做法。</p><p id="2477" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">lambda函数的美妙之处在于它们返回函数对象。这使得它们在用于像<code class="fe nr ns nt ni b">map</code>或<code class="fe nr ns nt ni b">filter</code>这样需要函数对象作为参数的函数时非常有用。</p><p id="5f53" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当表达式超过一行时，Lambdas没有用。</p><h2 id="f5b4" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题9:什么是酸洗和拆线？</h2><p id="aad9" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">Pickle模块接受任何Python对象，并将其转换为字符串表示形式，然后使用dump函数将其转储到一个文件中。这个过程称为pickling，而从存储的字符串表示中检索原始Python对象的过程称为unpickling。</p><h2 id="4cfe" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题10:NumPy数组比(嵌套)Python列表有什么优势？</h2><ul class=""><li id="4315" class="nv nw it ks b kt nc kw nd kz nx ld ny lh nz ll oa ob oc od bi translated">Python的列表是高效的通用容器。它们支持(相当)有效的插入、删除、追加和连接，Python的列表理解使它们易于构造和操作。</li><li id="7c01" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">它们有一定的局限性。它们不支持像元素加法和乘法这样的“矢量化”操作，并且它们可以包含不同类型的对象这一事实意味着Python必须存储每个元素的类型信息，并且在对每个元素进行操作时必须执行类型调度代码。</li><li id="0a1c" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated"><code class="fe nr ns nt ni b">NumPy</code>不仅更高效，也更方便。你可以免费获得大量的向量和矩阵运算，这有时可以避免不必要的工作。它们也能有效地实现。</li><li id="8db9" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated"><code class="fe nr ns nt ni b">NumPy</code>数组速度更快，内置了很多功能——FFT、卷积、快速搜索、基本统计、线性代数、直方图等。</li></ul><h2 id="c092" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题11:用例子解释Python中的继承</h2><p id="02db" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">继承允许一个类获得另一个类的所有成员(比如属性和方法)。继承提供了代码的可重用性，使得创建和维护应用程序变得更加容易。我们从其中继承的类被称为超类，被继承的类被称为派生类/子类。</p><p id="4eaa" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Python支持不同类型的继承:</p><ul class=""><li id="19a3" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll oa ob oc od bi translated">单一继承——派生类获得单一超类的成员。</li><li id="4875" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">多级继承—派生类d1继承自基类base1，d2继承自base2。</li><li id="fed9" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">分层继承——从一个基类可以继承任意数量的子类。</li><li id="4fde" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">多重继承—派生类从多个基类继承。</li></ul><h2 id="e682" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题12:Python中的多态性是什么？</h2><p id="3aa1" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">多态性意味着采取多种形式的能力。例如，如果父类有一个名为ABC的方法，那么子类也可以有一个同名的方法，它有自己的参数和变量。Python允许多态性。</p><h2 id="d86a" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题13:解释<code class="fe nr ns nt ni b">range()</code>和<code class="fe nr ns nt ni b">xrange()</code>的区别</h2><p id="f325" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">在很大程度上，<code class="fe nr ns nt ni b">xrange</code>和<code class="fe nr ns nt ni b">range</code>具有完全相同的功能。它们都会生成一个整数列表供您使用。唯一的区别是<code class="fe nr ns nt ni b">range</code>返回一个Python列表对象，而<code class="fe nr ns nt ni b">xrange</code>返回一个<code class="fe nr ns nt ni b">xrange</code>对象。</p><p id="7255" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这意味着<code class="fe nr ns nt ni b">xrange</code>并不像range那样在运行时生成静态列表。它用一种叫做让步的特殊技术创造出你需要的价值。这种技术用于一种称为发生器的对象。</p><h2 id="d8ee" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题14:解释Flask和Django的区别</h2><p id="3614" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">Django是一个Python web框架，它提供了一个开源的高级框架，“鼓励快速开发和干净、实用的设计。”它快速、安全且可扩展。Django提供了强大的社区支持和详细的文档。</p><p id="69ea" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">该框架是一个包容性的包，在创建应用程序时，您可以获得管理面板、数据库界面和目录结构。此外，它包括许多特性，因此您不必添加单独的库和依赖项。它提供的特性包括用户认证、模板引擎、路由、数据库模式迁移等等。</p><p id="e195" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Django框架非常灵活，您可以在其中与大型公司的MVP一起工作。从某种角度来看，使用Django的一些最大的公司是Instagram、Dropbox、Pinterest和Spotify。</p><p id="dc7d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Flask被认为是一个微框架，是一个极简的web框架。它不是“包含电池的”，这意味着它缺少像Django这样的全栈框架所提供的许多特性和功能，比如web模板引擎、帐户授权和身份验证。</p><p id="ce7e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Flask是极简和轻量级的，这意味着您可以在编码时添加所需的扩展和库，而无需框架自动提供。Flask背后的理念是，它只提供构建应用程序所需的组件，这样你就有了灵活性和控制力。换句话说，就是不固执己见。它提供的一些特性包括build-int dev服务器、Restful请求调度、HTTP请求处理等等。</p><h2 id="023e" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题15:python path是什么？</h2><p id="4dfc" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">它是一个环境变量，在导入模块时使用。每当导入一个模块时，还会查找<code class="fe nr ns nt ni b">PYTHONPATH</code>来检查在不同的目录中是否存在导入的模块。解释器用它来决定加载哪个模块。</p><h2 id="d697" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题16:什么是PEP 8？</h2><p id="6c95" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">PEP代表Python增强提案。它是一组规定如何格式化Python代码以获得最大可读性的规则。</p><h2 id="3922" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题17:什么是Python decorators？</h2><p id="0578" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">装饰器是Python中的一种设计模式，它允许用户向现有对象添加新功能，而无需修改其结构。装饰器通常在你想要装饰的函数定义之前被调用。</p><h2 id="1adb" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题18:什么是init？</h2><p id="42b4" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated"><code class="fe nr ns nt ni b">__init__</code>是Python中的方法或构造函数。当创建类的新对象/实例时，会自动调用此方法来分配内存。所有的类都有<code class="fe nr ns nt ni b">__init__</code>方法。</p><h2 id="0e24" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题19:什么是三元运算符？</h2><p id="4e7c" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">三元运算符是用Python编写条件语句的一种方式。顾名思义，这个Python操作符由三个操作数组成。</p><p id="577b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="on">注意:三元运算符可以被认为是if-else语句的一个简化的单行版本，用于测试条件。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oj"><img src="../Images/0061006ae7a1958a5f1bd7275906156e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kk6C6eRDd24WvVcc.png"/></div></div></figure><h2 id="9eca" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">语法</strong></h2><p id="32fb" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">三元运算符中的三个操作数包括:</p><ul class=""><li id="bffb" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll oa ob oc od bi translated">条件:计算结果为true或false的布尔表达式。</li><li id="b1bc" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated"><code class="fe nr ns nt ni b">true_val</code>:表达式求值为真时要赋值的值。</li><li id="639e" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated"><code class="fe nr ns nt ni b">false_val</code>:如果表达式的计算结果为假，则为其赋值。</li></ul><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="c169" class="ml lu it ni b gy nm nn l no np">var = true_val if condition else false_val</span></pre><p id="80d0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nr ns nt ni b">=</code>(赋值)操作符左侧的变量<code class="fe nr ns nt ni b">var</code>将被赋值:</p><ul class=""><li id="0b55" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll oa ob oc od bi translated"><code class="fe nr ns nt ni b">value1</code>如果<code class="fe nr ns nt ni b">booleanExpression</code>评估为<code class="fe nr ns nt ni b">true</code>。</li><li id="48d5" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated"><code class="fe nr ns nt ni b">value2</code>如果<code class="fe nr ns nt ni b">booleanExpression</code>评估为<code class="fe nr ns nt ni b">false</code>。</li></ul><h2 id="40d3" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">示例</strong></h2><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="d587" class="ml lu it ni b gy nm nn l no np"># USING TERNARY OPERATOR<br/>to_check = 6<br/>msg = "Even" if to_check%2 == 0 else "Odd"<br/>print(msg) </span><span id="c50d" class="ml lu it ni b gy nq nn l no np"># USING USUAL IF-ELSE<br/>msg = ""<br/>if(to_check%2 == 0):<br/>  msg = "Even"<br/>else:<br/>  msg = "Odd"<br/>print(msg)</span></pre><p id="0f8b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong> <br/>偶数<br/>偶数</p><h2 id="01a8" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">解释</strong></h2><p id="3cb2" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">上面的代码使用三元运算符来判断一个数是奇数还是偶数。</p><ul class=""><li id="305f" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll oa ob oc od bi translated">如果条件(to_check % 2 == 0)为<code class="fe nr ns nt ni b">true</code>，则<code class="fe nr ns nt ni b">msg</code>将被分配为“偶数”。</li><li id="ecec" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">如果条件(to_check % 2 == 0)为<code class="fe nr ns nt ni b">false</code>，则<code class="fe nr ns nt ni b">msg</code>将被指定为“奇数”。</li></ul><h2 id="c50c" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题20:Python中的全局和局部变量是什么？</h2><p id="0eac" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated"><strong class="ks iu">全局变量:</strong>声明在函数外部或全局空间中的变量称为全局变量。程序中的任何函数都可以访问这些变量。</p><p id="b2c4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">局部变量:</strong>任何在函数内部声明的变量都称为局部变量。这个变量存在于局部空间，而不存在于全局空间。</p><h2 id="24f2" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题21:Python中的<code class="fe nr ns nt ni b">@property</code>是什么？</h2><p id="9f6a" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated"><code class="fe nr ns nt ni b">@property</code>是一名室内装潢师。在Python中，decorators使用户能够以同样的方式使用类(不管对其属性或方法做了什么更改)。装饰器允许像访问属性一样访问函数。</p><h2 id="52cd" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题22:try/except在Python中是如何使用的？</h2><p id="b026" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">异常是程序执行时发生的错误。当这个错误发生时，程序将停止并生成一个异常，然后处理这个异常以防止程序崩溃。</p><p id="1705" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">程序产生的异常在<code class="fe nr ns nt ni b">try</code>块中被捕获，并在<code class="fe nr ns nt ni b">except</code>块中被处理。</p><ul class=""><li id="776b" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll oa ob oc od bi translated"><code class="fe nr ns nt ni b">Try</code>:让您测试代码块的错误。</li><li id="ef78" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated"><code class="fe nr ns nt ni b">Except</code>:让您处理错误。</li></ul><h2 id="9378" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题23:解释Python 2和Python 3的区别</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oo"><img src="../Images/389609042c8a0e3240f092cfc2c6296c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QfKs68GkKqYLPytsvZLgwg.png"/></div></div></figure><p id="da83" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Python 2在软件领域根深蒂固，几个软件之间的相互依赖使得这种转变几乎不可能。</p><h2 id="2ccc" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题24:Python中的join方法是什么？</h2><p id="b799" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">Python中的<code class="fe nr ns nt ni b">join</code>方法获取可迭代数据结构的元素，并使用特定的字符串连接器值将它们连接在一起。</p><h2 id="7484" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak"/><code class="fe nr ns nt ni b"><strong class="ak">join</strong></code><strong class="ak">如何工作？</strong></h2><p id="2f9a" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">Python中的join方法是一个string方法，它连接string iterable结构的元素，string iterable结构也包含字符串或字符(数组、列表等。)通过使用特定的字符串作为连接器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oj"><img src="../Images/c0a72581f0f9651c4f5d52a7eb04a3a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bp0Lyy1XROk2XYJy.png"/></div></div></figure><h2 id="353f" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">示例:使用空字符串连接元素</strong></h2><p id="95de" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">这将使用每个元素之间的空字符串来连接数组中的元素。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="e3db" class="ml lu it ni b gy nm nn l no np">array = ['H','E','L','L','O']<br/>connector = ""<br/>joined_string = connector.join(array)<br/>print(joined_string)</span></pre><p id="f3de" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong> <br/>您好</p><h2 id="1cbc" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题25:什么是词典理解？</h2><p id="6540" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">字典理解是用Python创建字典的一种方式。它通过合并两组数据来创建一个字典，这两组数据要么是列表，要么是数组。</p><p id="d747" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">两个列表/数组之一的数据将作为字典的键，而第二个列表/数组的数据将作为值。每个键充当每个值的唯一标识符，因此两个列表/数组的大小应该相同。</p><p id="8753" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里我们来看看简单的合并。简单合并是没有任何限制地合并或组合两个列表。换句话说，这是无条件的合并。</p><p id="ba4a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一般语法如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oj"><img src="../Images/56f7373fc86a09201eda39e576b01ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*E7p7sqob7TdVk_4o.png"/></div></div></figure><h2 id="b9f1" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">例子</strong></h2><p id="a61f" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">以下示例运行于学院的数据库，并使用简单的合并。想象一下，一个大学数据库存储了大量数据，例如，学生的地址、成绩、班级、费用、卷号等等。现在，我们需要唯一地标识每个学生，并创建一个只存储所有学生的新字典。我们的决定仅仅取决于两个问题:</p><ul class=""><li id="1181" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll oa ob oc od bi translated">关键应该是什么？</li><li id="27a0" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">价值应该是多少？</li></ul><p id="7b31" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里我们将选择roll numbers作为键，names作为值，因为roll numbers是惟一的，名称可以重复。因此，亚历克斯的滚动编号是122，所以元组看起来像122:亚历克斯。一旦你尝试下面附加的代码，这将得到更好的解释。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="8544" class="ml lu it ni b gy nm nn l no np">rollNumbers =[122,233,353,456]<br/>names = ['alex','bob','can', 'don'] <br/>NewDictionary={ i:j for (i,j) in zip (rollNumbers,names)}<br/>print(NewDictionary)</span></pre><p id="fb5b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong> <br/> <code class="fe nr ns nt ni b">{456: ‘don’, 233: ‘bob’, 122: ‘alex’, 353: ‘can’}</code></p><h2 id="c464" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题26:如何用Python做深度拷贝？</h2><p id="c93c" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">深层拷贝是指克隆对象。当我们使用<code class="fe nr ns nt ni b">=</code>操作符时，我们不是在克隆对象——相反，我们引用我们的变量到同一个对象(也称为浅层拷贝)。</p><p id="8983" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这意味着更改一个变量的值会影响另一个变量的值，因为它们引用(或指向)同一个对象。浅拷贝和深拷贝之间的这种差异只适用于包含其他对象的对象，如类的列表和实例。</p><h2 id="0e01" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">方法</strong></h2><p id="35f0" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">为了对一个对象进行深层复制(或克隆)，我们在Python中导入了内置的<code class="fe nr ns nt ni b">copy</code>模块。这个模块有<code class="fe nr ns nt ni b">deepcopy()</code>方法，它简化了我们的任务。</p><h2 id="000a" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">语法</strong></h2><p id="04ac" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">该函数将我们想要克隆的对象作为唯一的参数，并返回克隆对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oj"><img src="../Images/c27404ade1481adf63e3081d936b3966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6flj0hDWM-z_8U7-.png"/></div></div></figure><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="ff9b" class="ml lu it ni b gy nm nn l no np">import copy</span><span id="9b13" class="ml lu it ni b gy nq nn l no np"># Using '=' operator<br/>x = [1, 2, 3]<br/>y = x<br/>x[0] = 5    # value of 'y' also changes as it is the SAME object<br/>x[1] = 15<br/>print "Shallow copy: ", y</span><span id="2317" class="ml lu it ni b gy nq nn l no np"># Using copy.deepcopy()<br/>a = [10, 20, 30]<br/>b = copy.deepcopy(a)<br/>a[1] = 70   # value of 'b' does NOT change because it is ANOTHER object<br/>print "Deep copy: ", b</span></pre><p id="a631" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong> <br/>浅层复制:<code class="fe nr ns nt ni b">[5, 15, 3]</code> <br/>深层复制:<code class="fe nr ns nt ni b">[10, 20, 30]</code></p><h2 id="5746" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题27:如何检查一个键是否存在于Python字典中？</h2><p id="8cfe" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">在提取该键的值之前，检查字典中是否存在该键是一种安全的做法。为此，Python提供了两个内置函数:</p><ul class=""><li id="b1f8" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll oa ob oc od bi translated"><code class="fe nr ns nt ni b">has_key()</code></li></ul><p id="b67c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果字典中有给定的键，那么<code class="fe nr ns nt ni b">has_key</code>方法返回true，否则返回false。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="4e25" class="ml lu it ni b gy nm nn l no np">Fruits = {'a': "Apple", 'b':"Banana", 'c':"Carrot"}<br/>key_to_lookup = 'a'<br/>if Fruits.has_key(key_to_lookup):<br/>  print "Key exists"<br/>else:<br/>  print "Key does not exist"</span></pre><p id="9369" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong>键存在</p><ul class=""><li id="6a52" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll oa ob oc od bi translated"><code class="fe nr ns nt ni b">if-in</code>声明</li></ul><p id="f376" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这种方法使用<code class="fe nr ns nt ni b">if-in</code>语句来检查字典中是否存在给定的键。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="9e44" class="ml lu it ni b gy nm nn l no np">Fruits = {'a': "Apple", 'b':"Banana", 'c':"Carrot"}<br/>key_to_lookup = 'a'<br/>if key_to_lookup in Fruits:<br/>  print "Key exists"<br/>else:<br/>  print "Key does not exist"</span></pre><p id="dc76" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong>键存在</p><h2 id="43bf" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题28:你如何在Python中实现记忆化？</h2><p id="5e74" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">考虑一下这段计算开销很大的代码:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="0fce" class="ml lu it ni b gy nm nn l no np"># Fibonacci Numbers<br/>def fib(num):<br/>    if num == 0:<br/>        return 0<br/>    elif num == 1:<br/>        return 1<br/>    return fib(num - 1) + fib(n - 2)</span></pre><p id="abda" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">记忆化可以通过Python decorators来实现。下面是完整的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="708b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong> <br/> <code class="fe nr ns nt ni b">4.9035000301955733e-05</code> <br/> <code class="fe nr ns nt ni b">1.374000021314714e-06</code> <br/> <code class="fe nr ns nt ni b">1.2790005712304264e-06</code></p><h2 id="de02" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题29:你如何用Python对字典进行排序？</h2><p id="95e3" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">我们可以通过键或值对这种类型的数据进行排序，这是通过使用<code class="fe nr ns nt ni b">sorted()</code>函数来完成的。</p><p id="e62a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，我们需要知道如何从字典中检索数据并传递给这个函数。从字典中获取数据有两种基本方法:</p><p id="fbe4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nr ns nt ni b">Dictionary.keys()</code>:只返回任意顺序的键。<br/> <code class="fe nr ns nt ni b">Dictionary.values()</code>:返回数值列表。<br/> <code class="fe nr ns nt ni b">Dictionary.items()</code>:以键值对列表的形式返回所有数据。</p><h2 id="6a48" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><code class="fe nr ns nt ni b">Sorted()</code>语法</h2><p id="df80" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">此方法采用一个强制参数和两个可选参数:</p><ul class=""><li id="26c6" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll oa ob oc od bi translated">Data(必填):要排序的数据。我们将传递使用上述方法之一检索的数据。</li><li id="2e2a" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">Key(可选):一个函数(或标准)，我们希望基于它对列表进行排序。例如，标准可以是根据字符串的长度或任何其他任意函数对字符串进行排序。该函数应用于列表的每个元素，并对结果数据进行排序。将其留空将根据原始值对列表进行排序。</li><li id="5fcc" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">Reverse(可选):将第三个参数设置为true将按降序对列表进行排序。让这个空的按升序排序。</li></ul><p id="24f0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nr ns nt ni b"><strong class="ks iu">keys()</strong></code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="4ff4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nr ns nt ni b"><strong class="ks iu">values()</strong></code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="be8e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nr ns nt ni b"><strong class="ks iu">items()</strong></code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><h2 id="0a87" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题30:你将如何以及何时使用<code class="fe nr ns nt ni b">any() </code>和<code class="fe nr ns nt ni b">all()</code>？</h2><p id="ecfb" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated"><code class="fe nr ns nt ni b">any()</code>是一个函数，接受一个iterable(比如列表、元组、集合等。)并返回<code class="fe nr ns nt ni b">True</code>，如果任何一个元素评估为<code class="fe nr ns nt ni b">True</code>，但是如果所有元素评估为<code class="fe nr ns nt ni b">False</code>，它返回<code class="fe nr ns nt ni b">False</code>。</p><p id="18f2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">向<code class="fe nr ns nt ni b">any()</code>传递一个iterable来检查是否有任何元素是<code class="fe nr ns nt ni b">True</code>可以这样做:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="e281" class="ml lu it ni b gy nm nn l no np">one_truth = [True, False, False]<br/>three_lies = [0, '', None]</span><span id="4496" class="ml lu it ni b gy nq nn l no np">print(any(one_truth))</span><span id="1925" class="ml lu it ni b gy nq nn l no np">print(any(three_lies))</span></pre><p id="e64f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong> <br/> <code class="fe nr ns nt ni b">True</code> <br/> <code class="fe nr ns nt ni b">False</code></p><p id="6f4d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第一个print语句打印<code class="fe nr ns nt ni b">True</code>，因为<code class="fe nr ns nt ni b">one_truth</code>中的一个元素是<code class="fe nr ns nt ni b">True</code>。</p><p id="6abf" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">另一方面，第二个print语句打印<code class="fe nr ns nt ni b">False</code>，因为没有一个元素是<code class="fe nr ns nt ni b">True</code>；即所有元素都是<code class="fe nr ns nt ni b">False</code>。</p><p id="895a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="on">当需要检查一长串</em> <code class="fe nr ns nt ni b"><em class="on">or</em></code> <em class="on">条件时使用</em> <code class="fe nr ns nt ni b"><em class="on">any()</em></code> <em class="on">。</em></p><h2 id="3484" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">什么是</strong> <code class="fe nr ns nt ni b"><strong class="ak">all()</strong></code> <strong class="ak">？</strong></h2><p id="ed63" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated"><code class="fe nr ns nt ni b">all()</code>是另一个Python函数，它接受一个iterable，如果所有元素的计算结果都是<code class="fe nr ns nt ni b">True</code>，则返回<code class="fe nr ns nt ni b">True</code>，否则返回<code class="fe nr ns nt ni b">False</code>。</p><p id="985c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">与<code class="fe nr ns nt ni b">any()</code>类似，<code class="fe nr ns nt ni b">all()</code>接受一个列表、元组、集合或任何可迭代的对象，如下所示:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="44b3" class="ml lu it ni b gy nm nn l no np">all_true = [True, 1, 'a', object()]<br/>one_true = [True, False, False, 0]<br/>all_false = [None, '', False, 0]</span><span id="e711" class="ml lu it ni b gy nq nn l no np">print(all(all_true))<br/>print(all(one_true))<br/>print(all(all_false))</span></pre><p id="a1f5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong><br/><code class="fe nr ns nt ni b">True </code><br/><code class="fe nr ns nt ni b">False</code><br/><code class="fe nr ns nt ni b">False</code></p><p id="c8ea" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第一个函数调用返回了<code class="fe nr ns nt ni b">True</code>，因为<code class="fe nr ns nt ni b">all_true</code>中充满了真值。将<code class="fe nr ns nt ni b">one_true</code>传递给<code class="fe nr ns nt ni b">all()</code>返回了<code class="fe nr ns nt ni b">False</code>，因为列表包含一个或多个falsy值。最后，将<code class="fe nr ns nt ni b">all_false</code>传递给<code class="fe nr ns nt ni b">all()</code>会返回<code class="fe nr ns nt ni b">False</code>，因为它也包含一个或多个falsy值。</p><p id="4b92" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="on">需要检查一长串</em> <code class="fe nr ns nt ni b"><em class="on">and</em></code> <em class="on">条件时使用</em> <code class="fe nr ns nt ni b"><em class="on">all()</em></code> <em class="on">。</em></p><h2 id="91ab" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题31:什么是Python Docstring？</h2><p id="1bed" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">Python文档字符串提供了一种将文档与以下内容相关联的合适方式:</p><ul class=""><li id="fd72" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll oa ob oc od bi translated">Python模块</li><li id="c434" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">Python函数</li><li id="21e8" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">Python类</li></ul><p id="257f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是书面代码的指定文档。与传统的代码注释不同，篡改应该描述一个函数做什么，而不是它如何工作。</p><p id="e29a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">可以使用以下方法访问docstring</p><ul class=""><li id="9d14" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll oa ob oc od bi translated">对象的<code class="fe nr ns nt ni b">__doc__</code>方法。</li><li id="e0d3" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated"><code class="fe nr ns nt ni b">help</code>功能。</li></ul><h2 id="45a0" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">例子</strong></h2><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="d48f" class="ml lu it ni b gy nm nn l no np">def Examplefunc(str): #function that outputs the str parameter<br/>  print "The value is", str <br/>  #no return statement needed in this function</span><span id="e9fc" class="ml lu it ni b gy nq nn l no np">def Multiply(x,y): #function that computes the product of x and y <br/>  return x*y #returning the product of x and y</span><span id="557f" class="ml lu it ni b gy nq nn l no np">#Calling the functions<br/>Examplefunc(9) #9 passed as the parameter)<br/>answer = Multiply(4,2) #4 and 2 passed as the parameters<br/>print "The product of x and y is:",answer</span></pre><p id="ae4a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong> <br/>值为<code class="fe nr ns nt ni b">9</code>。<br/>x和y的乘积是<code class="fe nr ns nt ni b">8</code>。</p><h2 id="d9e5" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">解释</strong></h2><p id="03af" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">函数<code class="fe nr ns nt ni b">Examplefunc</code>将变量<code class="fe nr ns nt ni b">str</code>作为参数，并打印该值。因为它只打印值，所以不需要返回命令。</p><p id="1bcb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">函数<code class="fe nr ns nt ni b">Multiply</code>将两个参数<code class="fe nr ns nt ni b">x</code>和<code class="fe nr ns nt ni b">y</code>作为参数。然后它计算乘积，并使用<code class="fe nr ns nt ni b">return</code>语句返回答案。</p><h2 id="d1e3" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题33:解释Python中生成器和迭代器的区别。</h2><p id="10f0" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">Python中的迭代器充当对象的容器，因此可以对它们进行迭代。生成器有助于创建自定义迭代器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oj"><img src="../Images/9eb0065cf204c98bcbbe81027267d0b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FDXMTsYAiaKzCrca.png"/></div></div></figure><p id="3fec" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">除了明显的句法差异，还有一些其他值得注意的差异。</p><p id="3e33" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nr ns nt ni b">GeneratorIteratorImplemented</code>正在使用一个函数。它是使用一个类实现的。它使用了<code class="fe nr ns nt ni b">yield</code>关键字。使用会产生简洁的代码。使用会导致代码相对不太简洁。存储<code class="fe nr ns nt ni b">yield </code>语句之前的所有局部变量。不使用局部变量。</p><h2 id="17bc" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">迭代器的实现</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="46f9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong><br/>T13】</p><h2 id="d914" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">发电机的实现</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="b29b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong> <br/> <code class="fe nr ns nt ni b">0<br/>1<br/>2<br/>3<br/>4<br/>5</code></p><h2 id="6270" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题34:Python中的<code class="fe nr ns nt ni b">defaultdict</code>是什么？</h2><p id="6460" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">Python字典<code class="fe nr ns nt ni b">dict</code>包含单词和含义，以及任何数据类型的键值对。<code class="fe nr ns nt ni b">defaultdict</code>是内置<code class="fe nr ns nt ni b">dict</code>类的另一个细分。</p><h2 id="cf89" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak"/><code class="fe nr ns nt ni b"><strong class="ak">defaultdict</strong></code><strong class="ak">有何不同？</strong></h2><p id="dd97" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated"><code class="fe nr ns nt ni b">defaultdict</code>是<code class="fe nr ns nt ni b">dict</code>类的一个细分。它的重要性在于，它允许根据所创建的字典类型为每个新键赋予一个默认值。</p><p id="681e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一个<code class="fe nr ns nt ni b">defaultdict</code>可以通过给出它的声明来创建，一个参数可以有三个值:<code class="fe nr ns nt ni b">list</code>、<code class="fe nr ns nt ni b">set</code>或<code class="fe nr ns nt ni b">int</code>。根据指定的数据类型创建字典。当添加或访问<code class="fe nr ns nt ni b">defaultdict</code>中不存在的任何键时，它被赋予一个默认值，而不是给出一个<code class="fe nr ns nt ni b">KeyError</code>。</p><h2 id="111c" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">示例</strong></h2><p id="44d5" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">下面的代码片段显示了一个简单的字典，当访问一个不存在于<code class="fe nr ns nt ni b">dict</code>中的键时，它给出一个错误:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="0d91" class="ml lu it ni b gy nm nn l no np">dict_demo = dict()<br/>print(dict_demo[3])</span></pre><p id="0033" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们来介绍一个<code class="fe nr ns nt ni b">defaultdict</code>，看看会发生什么。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="6e98" class="ml lu it ni b gy nm nn l no np">from collections import defaultdict</span><span id="2ebc" class="ml lu it ni b gy nq nn l no np">defaultdict_demo = defaultdict(int)<br/>print(defaultdict_demo[3])</span></pre><p id="f1d0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong> <code class="fe nr ns nt ni b">0</code></p><p id="a154" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这种情况下，我们将<code class="fe nr ns nt ni b">int</code>作为数据类型传递给了<code class="fe nr ns nt ni b">defaultdict</code>。因此，任何不存在于<code class="fe nr ns nt ni b">defaultdict_demo</code>中的键都将被赋予一个值<code class="fe nr ns nt ni b">0</code>，除非为其定义了一个值。</p><p id="bc8a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="on">注意:也可以将</em> <code class="fe nr ns nt ni b"><em class="on">set</em></code> <em class="on">或</em> <code class="fe nr ns nt ni b"><em class="on">list</em></code> <em class="on">作为参数</em></p><h2 id="da01" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题35:什么是Python模块？</h2><p id="9acd" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">Python模块是一个Python文件，包含一组要在应用程序中使用的函数和变量。变量可以是任何类型——数组、字典、对象等。</p><p id="e35a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">模块可以是内置的，也可以是用户定义的。</p><h2 id="e396" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">Python中模块的好处</strong></h2><p id="b989" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">在Python中创建和使用模块有几个好处:</p><ul class=""><li id="692a" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll oa ob oc od bi translated">结构化代码:通过分组到一个Python文件中进行逻辑组织，这使得开发更容易，更不容易出错，代码更容易理解和使用。</li><li id="9ae3" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">可重用性:在单个模块中定义的功能可以很容易地被应用程序的其他部分重用。这消除了创建重复代码的需要。</li></ul></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="ec7b" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">Python面试问题—编码</h1><p id="00a0" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">在这一节中，我们将看看与列表、链表、图、树、多线程/并发性等相关的常见编码面试问题。</p><h2 id="9078" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题36:在Python中反转一个字符串</h2><p id="5131" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">让我们使用切片方法反转字符串<code class="fe nr ns nt ni b">Python</code>。要反转一个字符串，我们只需创建一个片段，从字符串的长度开始，到索引<code class="fe nr ns nt ni b">0</code>结束。</p><p id="d1b3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">要使用切片反转字符串，请编写以下代码:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="a7a4" class="ml lu it ni b gy nm nn l no np">stringname[stringlength::-1] # method 1</span></pre><p id="43ed" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">要在不指定字符串长度的情况下反转字符串，请编写:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="f7d4" class="ml lu it ni b gy nm nn l no np">stringname[::-1] # method2</span></pre><p id="ce37" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">slice语句的意思是从字符串<code class="fe nr ns nt ni b">length</code>开始，到位置<code class="fe nr ns nt ni b">0</code>结束，并以<code class="fe nr ns nt ni b">-1</code>为步长移动(或后退一步)。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="d7d3" class="ml lu it ni b gy nm nn l no np">str="Python" # initial string<br/>stringlength=len(str) # calculate length of the list<br/>slicedString=str[stringlength::-1] # slicing <br/>print (slicedString) # print the reversed string</span></pre><p id="cc5f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong>T3】</p><p id="3fd5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这只是Python中反转字符串的一种方法。另外两个值得注意的方法是<code class="fe nr ns nt ni b">Loop</code>和<code class="fe nr ns nt ni b">Use Join</code>。</p><h2 id="f289" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题37:检查一个Python字符串是否包含另一个字符串</h2><p id="a43a" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">有几种方法可以做到这一点。在本文中，我们将看看<code class="fe nr ns nt ni b">find</code>方法。</p><p id="aaea" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nr ns nt ni b">find</code>方法检查字符串是否包含子串。如果是，该方法返回字符串中子串的起始索引，否则返回<code class="fe nr ns nt ni b">-1</code>。</p><p id="f1de" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一般语法如下:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="e5ea" class="ml lu it ni b gy nm nn l no np">string.find(substring)</span><span id="3417" class="ml lu it ni b gy nq nn l no np">a_string="Python Programming" <br/>substring1="Programming" <br/>substring2="Language" <br/>print("Check if "+a_string+" contains "+substring1+":")<br/>print(a_string.find(substring1)) <br/>print("Check if "+a_string+" contains "+substring2+":")<br/>print(a_string.find(substring2))</span></pre><p id="867e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong> <br/>检查<code class="fe nr ns nt ni b">Python Programming</code>是否包含<code class="fe nr ns nt ni b">Programming</code> : <code class="fe nr ns nt ni b">7</code> <br/>检查<code class="fe nr ns nt ni b">Python Programming</code>是否包含<code class="fe nr ns nt ni b">Language</code> : <code class="fe nr ns nt ni b">-1</code></p><p id="22e6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">检查一个字符串是否包含另一个字符串的另外两个值得注意的方法是使用<code class="fe nr ns nt ni b">in</code>操作符或使用<code class="fe nr ns nt ni b">count</code>方法。</p><h2 id="5ae2" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题38:用Python实现广度优先搜索(BFS)</h2><p id="281a" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">考虑下面代码中实现的图形:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oj"><img src="../Images/ba9c6d90314ab8c75886ba5e8296f200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IDEDPalRkl8w-6vM.png"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="1980" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong> <code class="fe nr ns nt ni b">A B C D E F</code></p><h2 id="d88d" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">解释</strong></h2><p id="d7bc" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated"><strong class="ks iu">第3–10行:</strong>图示的图形使用邻接表表示。在Python中实现这一点的一个简单方法是使用字典数据结构，其中每个顶点都存储有其相邻节点的列表。</p><p id="7eda" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">第12行:</strong> <code class="fe nr ns nt ni b">visited</code>是用于跟踪被访问节点的列表。</p><p id="f45a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">第13行:</strong> <code class="fe nr ns nt ni b">queue</code>是用于跟踪当前队列中的节点的列表。</p><p id="c155" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">第29行:</strong><code class="fe nr ns nt ni b">bfs</code>函数的参数是<code class="fe nr ns nt ni b">visited</code>列表，字典形式的<code class="fe nr ns nt ni b">graph</code>，起始节点<code class="fe nr ns nt ni b">A</code>。</p><p id="1a2b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">第15–26行:</strong> <code class="fe nr ns nt ni b">bfs</code>遵循上述算法:</p><ol class=""><li id="a5d5" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll or ob oc od bi translated">它检查起始节点并将其添加到<code class="fe nr ns nt ni b">visited</code>列表和<code class="fe nr ns nt ni b">queue</code>中。</li><li id="4872" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll or ob oc od bi translated">然后，当队列包含元素时，它继续从队列中取出节点，将该节点的邻居(如果它们未被访问)附加到队列中，并将它们标记为已访问。</li><li id="126c" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll or ob oc od bi translated">这一直持续到队列为空。</li></ol><h2 id="ead2" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">时间复杂度</strong></h2><p id="abbf" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">因为访问了所有的节点和顶点，所以图中BFS的时间复杂度是O(V + E)，其中V是顶点的数量，E是边的数量。</p><h2 id="4f68" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题39:在Python中实现深度优先搜索(DFS)</h2><p id="c84f" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">考虑这个图形，用下面的代码实现:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oj"><img src="../Images/2fa481e5410c166990e4e98b80acf587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*imtyQMN2J51tcN4V.png"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="c2fd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong>T0】</p><h2 id="0680" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">解释</strong></h2><p id="0b78" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated"><strong class="ks iu">第2–9行:</strong>图示的图形是用邻接表表示的——在Python中，一种简单的方法是使用字典数据结构。每个顶点都存储有其相邻节点的列表。</p><p id="63ac" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">第11行:</strong> <code class="fe nr ns nt ni b">visited</code>是用来跟踪被访问节点的集合。</p><p id="bef7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">第21行:</strong><code class="fe nr ns nt ni b">dfs</code>函数被调用，并通过<code class="fe nr ns nt ni b">visited</code>集合、<code class="fe nr ns nt ni b">graph</code>字典和<code class="fe nr ns nt ni b">A</code>传递，T5是起始节点。</p><p id="a78d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">第13–18行:</strong> <code class="fe nr ns nt ni b">dfs</code>遵循上述算法:</p><ol class=""><li id="eec6" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll or ob oc od bi translated">它首先检查当前节点是否未被访问——如果是，它被追加到<code class="fe nr ns nt ni b">visited</code>集合中。</li><li id="aa98" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll or ob oc od bi translated">然后对于当前节点的每个邻居，再次调用<code class="fe nr ns nt ni b">dfs</code>函数。</li><li id="9847" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll or ob oc od bi translated">当所有节点都被访问时，调用基本情况。该函数随后返回。</li></ol><h2 id="8421" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">时间复杂度</strong></h2><p id="774a" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">由于所有的节点和顶点都被访问，图的DFS的平均时间复杂度是O(V + E)，其中V是顶点的数目，E是边的数目。对于树上的DFS，时间复杂度是O(V)，其中V是节点的数量。</p><h2 id="e5cf" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题40:在Python中实现通配符</h2><p id="de45" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">在Python中，可以使用<code class="fe nr ns nt ni b">regex</code>(正则表达式)库实现通配符。</p><p id="b54c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">点<code class="fe nr ns nt ni b">.</code>字符用于代替问号<code class="fe nr ns nt ni b">?</code>符号。因此，要搜索与颜色模式匹配的所有单词，代码应该如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="e3e0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong> <code class="fe nr ns nt ni b">color</code></p><h2 id="e66f" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题41:在Python中实现合并排序</h2><p id="463f" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">以下是Python中合并排序的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="f249" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong> <code class="fe nr ns nt ni b">[17, 20, 26, 31, 44, 54, 55, 77, 93]</code></p><h2 id="0be6" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">解释</strong></h2><p id="ac8a" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">这是实现合并排序的递归方法。采取的步骤如下:</p><ol class=""><li id="dd2c" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll or ob oc od bi translated">列表在每次递归调用中被分成<code class="fe nr ns nt ni b">left</code>和<code class="fe nr ns nt ni b">right</code>，直到获得两个相邻的元素。</li><li id="dd7d" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll or ob oc od bi translated">分类过程开始。在每次调用中，<code class="fe nr ns nt ni b">i</code>和<code class="fe nr ns nt ni b">j</code>迭代器遍历两半。<code class="fe nr ns nt ni b">k</code>迭代器遍历整个列表，并一路修改。</li><li id="83bb" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll or ob oc od bi translated">如果<code class="fe nr ns nt ni b">i</code>处的值小于<code class="fe nr ns nt ni b">j</code>处的值，则将<code class="fe nr ns nt ni b">left[i]</code>分配给<code class="fe nr ns nt ni b">myList[k]</code>槽，并且<code class="fe nr ns nt ni b">i</code>递增。如果不是，则选择<code class="fe nr ns nt ni b">right[j]</code>。</li><li id="0e88" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll or ob oc od bi translated">这样，通过<code class="fe nr ns nt ni b">k</code>分配的值都被排序。</li><li id="b78b" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll or ob oc od bi translated">在这个循环结束时，其中的一半可能没有被完全遍历，如果是这样，它的值就被简单地分配给列表中剩余的槽。</li></ol><h2 id="a479" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">时间复杂度</strong></h2><p id="8a18" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">该算法在O(n.logn)中工作。这是因为列表被分成log(n)个调用，合并过程在每个调用中花费线性时间。</p><h2 id="e0b3" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题42:用Python实现Dijkstra的算法</h2><p id="8410" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated"><strong class="ks iu">基本算法:</strong></p><ol class=""><li id="9244" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll or ob oc od bi translated">从每个未访问的顶点中，选择距离最小的顶点并访问它。</li><li id="3eb7" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll or ob oc od bi translated">更新所访问顶点的每个相邻顶点的距离，这些顶点的当前距离大于其总和以及它们之间的边的权重。</li><li id="c84c" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll or ob oc od bi translated">重复直到所有的顶点都被访问。</li></ol><p id="3e2b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">实施:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="deee" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出</strong><br/>a到源顶点a的最短距离是:<code class="fe nr ns nt ni b">0</code><br/>b到源顶点a的最短距离是:<code class="fe nr ns nt ni b">3</code><br/>c到源顶点a的最短距离是:<code class="fe nr ns nt ni b">3.5</code><br/>d到源顶点a的最短距离是:<code class="fe nr ns nt ni b">4.5</code></p><h2 id="28cc" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题43:合并两个排序列表</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="cb81" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong> <code class="fe nr ns nt ni b">[-2, -1, 0, 4, 5, 6, 7]</code></p><p id="286f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是解决这个问题比较直观的方法。</p><ul class=""><li id="484e" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll oa ob oc od bi translated">首先创建一个新的空列表。这个列表将被两个列表中的所有元素按排序顺序填充并返回。</li><li id="f6b9" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">然后将三个变量初始化为零，以存储每个列表的当前索引。</li><li id="5538" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">然后比较两个给定列表中当前索引处的元素，将较小的元素附加到新列表中，并将该列表的索引增加1。</li><li id="c23f" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">重复直到到达其中一个列表的末尾，并将另一个列表追加到合并列表中。</li></ul><h2 id="fe31" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">时间复杂度</strong></h2><p id="9c6b" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">该算法的时间复杂度为O(n+m)O(n+m ),其中nn和mm是列表的长度。这是因为两个列表都至少被迭代了一次。</p><p id="9abb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">注意，这个问题也可以通过就地合并来解决。</p><h2 id="c05a" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题44:找出两个加起来等于k的数字</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="cf2d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong> <br/> <code class="fe nr ns nt ni b">None<br/>[1,4]</code></p><p id="fc73" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">你可以通过首先对列表进行排序来解决这个问题。然后，对于列表中的每个元素，使用二分搜索法查找该元素与预期总和之间的差异。换句话说，如果预期的总和是<code class="fe nr ns nt ni b">k</code>，排序列表的第一个元素是<code class="fe nr ns nt ni b">a0</code>，我们将为<code class="fe nr ns nt ni b">a0</code>做一个二分搜索法。重复搜索，直到找到一个。您可以按照自己喜欢的方式递归或迭代地实现<code class="fe nr ns nt ni b">binarySearch()</code>函数。</p><h2 id="9789" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">时间复杂度</strong></h2><p id="909d" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">因为大多数基于比较的最优排序函数都取O(nlogn)，所以让我们假设Python <code class="fe nr ns nt ni b">.sort()</code>函数取相同的值。此外，由于二分搜索法查找单个元素需要O(logn)时间，因此所有n个元素的二分搜索法将需要O(nlogn)时间。</p><h2 id="7268" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题45:找到列表中第一个不重复的整数</h2><p id="bb53" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">在这里，您可以使用Python字典来记录重复次数。</p><p id="5609" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">样本输入:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="418c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong> <code class="fe nr ns nt ni b">2</code></p><p id="ee4b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nr ns nt ni b">counts</code>字典中的键是给定列表的元素，值是每个元素在列表中出现的次数。我们返回列表中最多出现一次的元素，在第23行。我们需要维护元组值中每个键的更新顺序。</p><h2 id="bf6f" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">时间复杂度</strong></h2><p id="aeca" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">由于该列表只迭代两次，并且用线性时间复杂度初始化<code class="fe nr ns nt ni b">counts</code>字典，因此该解决方案的时间复杂度是线性的，即O(n)。</p><h2 id="4623" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题46:求链表的中间值</h2><p id="ae00" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">这个问题的代码解决方案涉及多个<code class="fe nr ns nt ni b">.py</code>文件要查看运行中的代码，请前往<a class="ae os" href="https://www.educative.io/blog/python-interview-questions#q46" rel="noopener ugc nofollow" target="_blank">原始帖子</a>。</p><p id="650b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里你可以使用两个指针同时工作:</p><ul class=""><li id="3a2a" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll oa ob oc od bi translated">快速指针一次移动两步，直到列表结束。</li><li id="671c" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">慢速指针一次移动一步。</li><li id="71cb" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">当快指针到达终点时，慢指针将在中间。</li></ul><p id="4870" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">有了这个算法，你可以使这个过程更快，因为计算长度和遍历到中间是并行发生的。</p><h2 id="6202" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">时间复杂度</strong></h2><p id="f663" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">你以两倍的速度遍历链表，所以肯定会更快。但是，瓶颈复杂度仍然是O(n)。</p><h1 id="abee" class="lt lu it bd lv lw ot ly lz ma ou mc md jz ov ka mf kc ow kd mh kf ox kg mj mk bi translated">问题47:反转队列的前“k”个元素</h1><p id="86d7" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">这个问题的代码解决方案涉及多个<code class="fe nr ns nt ni b">.py</code>文件。要查看代码解决方案，请访问<a class="ae os" href="https://www.educative.io/blog/python-interview-questions#q47" rel="noopener ugc nofollow" target="_blank">原始帖子</a>。</p><h2 id="0467" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">解说</strong></h2><ol class=""><li id="1904" class="nv nw it ks b kt nc kw nd kz nx ld ny lh nz ll or ob oc od bi translated">检查无效输入，即队列是否为空，是否<code class="fe nr ns nt ni b">k</code>大于队列，以及<strong class="ks iu">行2 </strong>上的<code class="fe nr ns nt ni b">k</code>是否为负。如果输入有效，开始创建一个<code class="fe nr ns nt ni b">Stack</code>。可用的堆栈函数有:</li></ol><ul class=""><li id="6eb0" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll oa ob oc od bi translated"><strong class="ks iu">建造者:</strong> <code class="fe nr ns nt ni b">myStack()</code>。</li><li id="19a9" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated"><strong class="ks iu">推送元素:</strong> <code class="fe nr ns nt ni b">push(int)</code>将元素添加到堆栈中。</li><li id="c47a" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated"><strong class="ks iu">弹出元素:</strong> <code class="fe nr ns nt ni b">pop()</code>从堆栈中移除或弹出顶层元素。</li><li id="c601" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated"><strong class="ks iu">检查是否为空:</strong> <code class="fe nr ns nt ni b">isEmpty()</code>堆栈为空则返回true，否则返回false。</li><li id="edb7" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated"><strong class="ks iu"> Return back: </strong> <code class="fe nr ns nt ni b">back()</code>返回已经添加到末尾的元素，而不将其从堆栈中移除。</li><li id="66f4" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated"><strong class="ks iu"> Return front: </strong> <code class="fe nr ns nt ni b">front()</code>返回顶部元素(已添加到开头)，但不将其从堆栈中移除。</li></ul><p id="c21d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">2.我们的函数<code class="fe nr ns nt ni b">reverseK(queue, k)</code>将queue作为输入参数。<code class="fe nr ns nt ni b">k</code>代表我们要反转的元素个数。可用的队列函数有:</p><ul class=""><li id="3eed" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll oa ob oc od bi translated"><strong class="ks iu">入队:</strong> <code class="fe nr ns nt ni b">enqueue(int)</code>。</li><li id="d284" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated"><strong class="ks iu">出列:</strong> <code class="fe nr ns nt ni b">dequeue()</code>。</li><li id="1192" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated"><strong class="ks iu">构造函数:</strong> <code class="fe nr ns nt ni b">myQueue(size)</code> size应该是指定队列大小的整数。</li><li id="36a3" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated"><strong class="ks iu">检查是否为空:</strong>T15】。</li><li id="40dd" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated"><strong class="ks iu">检查尺寸:</strong> <code class="fe nr ns nt ni b">size()</code>。</li></ul><p id="de71" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">3.转到实际的逻辑——将第一个<code class="fe nr ns nt ni b">k</code>元素从队列的前面出列，并将其放入我们之前在第8行使用<code class="fe nr ns nt ni b">stack.push(queue.dequeue())</code>创建的堆栈中。</p><p id="ad2d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">4.一旦所有的<code class="fe nr ns nt ni b">k</code>值都被压入堆栈，就开始弹出它们，并按顺序将它们放入队列的后面。我们将在第12行中使用<code class="fe nr ns nt ni b">queue.enqueue(stack.pop())</code>来实现这一点。在这一步的最后，我们将留下一个空栈，而<code class="fe nr ns nt ni b">k</code>反转的元素将被追加到队列的后面。</p><p id="902c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">5.我们将这些反转的元素移到队列的前面。为此，我们在第16行中使用了<code class="fe nr ns nt ni b">queue.enqueue(queue.dequeue())</code>。每个元素首先从后面出列。</p><h2 id="9f78" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题48:求二叉查找树的高度</h2><p id="075e" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">这里你可以使用递归来找到左右子树的高度。这个问题的代码解决方案涉及多个<code class="fe nr ns nt ni b">.py</code>文件。要查看代码解决方案，请访问<a class="ae os" href="https://www.educative.io/blog/python-interview-questions#q48" rel="noopener ugc nofollow" target="_blank">原始帖子</a>。</p><h2 id="1ce5" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">解说</strong></h2><p id="ccf6" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">这里，如果给定的节点是<code class="fe nr ns nt ni b">None</code>，我们返回-1。然后，我们调用左右子树上的<code class="fe nr ns nt ni b">findHeight()</code>函数，并返回具有较大值加1的那个。如果给定节点是<code class="fe nr ns nt ni b">None</code>，我们将不会返回<code class="fe nr ns nt ni b">0</code>，因为叶节点的高度是<code class="fe nr ns nt ni b">0</code>。</p><h2 id="673c" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">时间复杂度</strong></h2><p id="49de" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">代码的时间复杂度是O(n)O(n ),因为必须遍历整个树的所有节点。</p><h2 id="9cb4" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题49:将最大堆转换为最小堆</h2><p id="88b3" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">这里我们将<code class="fe nr ns nt ni b">minHeapify</code>所有父节点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="a662" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">输出:</strong> <code class="fe nr ns nt ni b">[-2, 1, 5, 9, 4, 6, 7]</code></p><h2 id="74f1" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">解释</strong></h2><p id="6dcf" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">请记住，我们可以将给定的<code class="fe nr ns nt ni b">maxHeap</code>视为一个常规的元素列表，并对其重新排序，以便它准确地表示一个<code class="fe nr ns nt ni b">minHeap</code>——这正是我们在这个解决方案中所做的。<code class="fe nr ns nt ni b">convertMax()</code>函数通过调用每个节点上的<code class="fe nr ns nt ni b">minHeapify()</code>函数，从最低的父节点恢复所有节点上的堆属性。</p><h2 id="b634" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">时间复杂度</strong></h2><p id="f16c" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">为堆中一半的节点调用<code class="fe nr ns nt ni b">minHeapify()</code>函数。<code class="fe nr ns nt ni b">minHeapify()</code>函数花费O(log(n))时间，并且它在n/2个节点上被调用，所以这个解决方案花费O(nlog(n))时间。</p><h2 id="8818" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated">问题50:检测链表中的循环</h2><p id="9854" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">这个问题的代码解决方案涉及多个<code class="fe nr ns nt ni b">.py</code>文件。要查看代码解决方案，请访问<a class="ae os" href="https://www.educative.io/blog/python-interview-questions#q50" rel="noopener ugc nofollow" target="_blank">的原始帖子</a>。</p><h2 id="de7f" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">解说</strong></h2><p id="fd4e" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">遍历整个链表，并将每个访问过的节点添加到一个<code class="fe nr ns nt ni b">visited_nodes</code>集合中。在每个节点，我们检查它是否被访问过。原则上，如果重新访问一个节点，则存在一个循环！</p><h2 id="ca44" class="ml lu it bd lv mm mn dn lz mo mp dp md kz mq mr mf ld ms mt mh lh mu mv mj mw bi translated"><strong class="ak">时间复杂度</strong></h2><p id="aaa2" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">我们迭代列表一次。平均而言，在集合中查找需要O(1)时间。因此，该算法的平均运行时间为O(n)。然而，在最坏的情况下，查找可以增加到O(n)，这将导致算法在O(n)中工作。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="7b4e" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">现在不要停！</h1><p id="5322" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">你的学习和准备才刚刚开始。通过练习Python面试中最常见的问题，将你的自信提升到一个全新的水平。最好的准备方式是研究编码面试的总体模式。目标不仅仅是记住这些问题，而是理解驱动它们的潜在模式。这样，你就有能力解决任何出现在你面前的问题。一些主要模式是:</p><ul class=""><li id="467f" class="nv nw it ks b kt ku kw kx kz ok ld ol lh om ll oa ob oc od bi translated">推拉窗</li><li id="d3f0" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">两点</li><li id="18c5" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">快速和慢速指针</li><li id="96b4" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">合并间隔</li><li id="9f7b" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">循环排序</li><li id="353c" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">广度优先搜索树</li><li id="2970" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">链表的就地反转</li><li id="addb" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">两堆</li><li id="f7e2" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">按位异或</li><li id="0978" class="nv nw it ks b kt oe kw of kz og ld oh lh oi ll oa ob oc od bi translated">k路合并</li></ul></div></div>    
</body>
</html>