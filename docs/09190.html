<html>
<head>
<title>How To Decode Dynamic JSON in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Swift中解码动态JSON</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-decode-dynamic-json-in-swift-5ca5f923aed1?source=collection_archive---------3-----------------------#2021-07-26">https://betterprogramming.pub/how-to-decode-dynamic-json-in-swift-5ca5f923aed1?source=collection_archive---------3-----------------------#2021-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3412" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">处理可以动态变化的服务器响应</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a38b1f12ffa8e7f46d25d26f8e9370c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mC4TH0PZTyZzGpS-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@floriankrumm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Florian Krumm </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="464e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现代应用程序必须与后端通信。他们可能出于几个原因使用它:</p><ul class=""><li id="36f5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">对用户进行身份验证。</li><li id="f189" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">来备份他们的数据。</li><li id="430d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">下载数据显示给用户。</li><li id="a9c1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">和许多其他用例。</li></ul><p id="05f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大多数交互中，来自后端的数据都是定义良好的。有一个具有固定数量属性的模型，每个属性都有一个明确定义的类型。客户机和服务器同意这种模型:对于每个请求，都有一个对应的响应和一个精确的契约。</p><p id="72bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在其他应用程序中，根据一天中的时间或用户的地理位置，相同的请求可能会返回不同的数据。一个典型的例子是社交网络的feed。当我们请求新帖子时，我们会根据一天中的时间、地理位置和其他用户的帖子得到不同的结果。</p><p id="8487" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解码这些响应不是立即的，我们可能会尝试以次优的方式实现解码。我们来看看怎么做才合适。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="1327" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">问题是</h1><p id="4a8c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">假设我们想要检索一个社交网络的提要。应用程序和后端使用JSON内容进行通信。这是对呼叫的可能响应:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ea16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe np nq nr ns b">content</code>属性包含三个不共享相同结构的对象:一个对象的类型是<code class="fe np nq nr ns b">text</code>，另一个是<code class="fe np nq nr ns b">picture</code>，还有一个<code class="fe np nq nr ns b">video</code>。有一些通用字段(如<code class="fe np nq nr ns b">id</code>和<code class="fe np nq nr ns b">author</code>)，但有些字段是特定类型的(如<code class="fe np nq nr ns b">text</code>的<code class="fe np nq nr ns b">text</code>、<code class="fe np nq nr ns b">picture</code>的<code class="fe np nq nr ns b">caption</code>或<code class="fe np nq nr ns b">video</code>的<code class="fe np nq nr ns b">duration</code>)。</p><p id="828d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何正确地建模它们？正如在计算机科学中经常发生的那样，我们有几种选择，每一种都有其优点和缺点。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2a16" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">班级</h1><p id="53af" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">第一种方法是使用类层次结构来编码这些信息。我们从包含所有共享信息的父类<code class="fe np nq nr ns b">Post</code>开始。然后，我们为每种类型实现不同的子类，扩展基类并添加特定于类型的信息。</p><p id="beba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法有几个问题:</p><ol class=""><li id="ba44" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nt mb mc md bi translated">我们不能利用<code class="fe np nq nr ns b">inits</code>的自动合成，结果我们写了很多不必要的代码。</li><li id="1115" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nt mb mc md bi translated">我们不能利用<code class="fe np nq nr ns b">Codable</code>协议的自动合成。子类将要求超类显式实现它(见下面的错误)。</li><li id="1d9e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nt mb mc md bi translated">解码时，我们仍然需要实现一些自定义机制来确定在解码过程中需要实例化哪个具体的子类。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/a7146cf2ffc4c4c89ca3b3b805c2bcb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6JfryBFp22DTr5LtvVbjYQ.png"/></div></div></figure><p id="7727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于它的长度，我不会提供这个解决方案的代码，但您可以尝试自己实现它。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2c55" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结构体</h1><p id="e17e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">第二种方法是使用带有可选字段的单个<code class="fe np nq nr ns b">struct</code>。这种方法是可行的，并且克服了类方法的一些缺点:</p><ol class=""><li id="a74d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nt mb mc md bi translated">我们有一个自动合成的<code class="fe np nq nr ns b">init</code>。</li><li id="8d8a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nt mb mc md bi translated">我们有一个自动合成的<code class="fe np nq nr ns b">Codable</code>实现。</li><li id="c586" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nt mb mc md bi translated">在与后端通信时，我们不必费心去理解内容的类型。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a0fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们需要使用它时，我们可以简单地创建一个解码器，为日期设置适当的解码策略，并对其进行解码。然后，我们可以访问单个post类型的<code class="fe np nq nr ns b">decoded.content</code>数组<code class="fe np nq nr ns b">switch</code>，并对其执行某种操作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d89b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法也不完美:</p><ol class=""><li id="7c92" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nt mb mc md bi translated">每个内容都有几个<code class="fe np nq nr ns b">nil</code>属性。</li><li id="e9fb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nt mb mc md bi translated">我们可以对没有意义的类型使用属性。比如一个<code class="fe np nq nr ns b">text</code>有一个<code class="fe np nq nr ns b">duration</code>是什么意思？</li><li id="187b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nt mb mc md bi translated">它呈现重复。<code class="fe np nq nr ns b">text</code>有一个名为<code class="fe np nq nr ns b">text</code>的<code class="fe np nq nr ns b">String</code>属性，<code class="fe np nq nr ns b">picture</code>有一个名为<code class="fe np nq nr ns b">caption</code>的<code class="fe np nq nr ns b">String</code>属性。我们两个都需要，因为服务器为不同类型的帖子发送不同的密钥，但是我们可以使用两个中的一个。</li><li id="5a79" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nt mb mc md bi translated">很难扩展。添加新类型时，我们可能需要添加额外的<code class="fe np nq nr ns b">nil</code>字段。模型中的属性数量可能会急剧增加。</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="fb9a" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">列举型别</h1><p id="9cef" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">最后一种方法两全其美。它最大限度地减少了重复，并确保所有必填字段都被正确填充。它移除了所有的<code class="fe np nq nr ns b">nil</code>属性，给了我们一个易于阅读和扩展的模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="cd72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，尽管这是最好的模型之一，它仍然需要我们做一些工作。编译器在抱怨，因为Swift不能自动合成这样的枚举(<a class="ae ky" href="https://github.com/apple/swift-evolution/blob/main/proposals/0295-codable-synthesis-for-enums-with-associated-values.md" rel="noopener ugc nofollow" target="_blank">除非在Swift 5.5 </a>之前):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/dabb5b1b4ac8f0fad784932b4aa44a66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PLxepnE-06UJuwLmbfFD7A.png"/></div></div></figure><p id="3098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要自己实现<code class="fe np nq nr ns b">Decodable</code>和<code class="fe np nq nr ns b">Encodable</code>协议。一旦我们理解了它们，它们的实现就容易了。它甚至可以自动化。我们将分三步实施协议:</p><ul class=""><li id="56d4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">添加所需的支持类型。</li><li id="da49" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">实现<code class="fe np nq nr ns b">encode(to:)</code>功能。</li><li id="fa6e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">执行<code class="fe np nq nr ns b">init(from:)</code>功能。</li></ul><p id="70a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们将看到编码和解码的实际操作。</p><h2 id="ba9e" class="nw mr it bd ms nx ny dn mw nz oa dp na li ob oc nc lm od oe ne lq of og ng oh bi translated">添加配套<code class="fe np nq nr ns b">types</code></h2><p id="5465" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">第一步是正确编码<code class="fe np nq nr ns b">Post</code>枚举。我们必须对三位信息进行编码:</p><ul class=""><li id="7c7c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">由枚举事例本身编码的类型属性</li><li id="d83b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一些常见数据</li><li id="cc9e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一些特定类型的数据</li></ul><p id="3563" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了对<code class="fe np nq nr ns b">type</code>进行编码，我们首先需要创建一个<code class="fe np nq nr ns b">CodingKeys</code>枚举，在这里我们将定义它的case。</p><p id="fb60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要一个<code class="fe np nq nr ns b">Types</code>枚举来描述我们知道的没有数据的帖子类型。这种类型允许您安全地编码和解码<code class="fe np nq nr ns b">type</code>属性的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="fec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以添加几个计算变量来轻松访问共享信息和类型。</p><h2 id="72af" class="nw mr it bd ms nx ny dn mw nz oa dp na li ob oc nc lm od oe ne lq of og ng oh bi translated">实现可编码</h2><p id="94a9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">一旦我们有了编码密钥，我们就可以实现<code class="fe np nq nr ns b">Encodable</code>协议。我们需要将所有信息一点一点地添加到编码器中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="1e47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们创建了一个特殊的容器，它使用一个<code class="fe np nq nr ns b">type</code>键。这让我们可以对JSON的<code class="fe np nq nr ns b">"type"</code>属性进行编码。</p><p id="05da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们利用<code class="fe np nq nr ns b">encode(to:)</code>方法的数据结构的综合实现，向编码器添加更多信息。说到<code class="fe np nq nr ns b">commonData</code>，不管帖子的类型如何，我们都可以对其进行编码。对于特定类型的数据，我们简单地<code class="fe np nq nr ns b">switch</code>所有的选择。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8d71" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">实现可解码</h1><p id="78b6" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">最后，我们需要实现双重协议:<code class="fe np nq nr ns b">Decodable</code>。</p><p id="b3e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe np nq nr ns b">init(from:)</code>功能与<code class="fe np nq nr ns b">encode(to:)</code>的结构相同。首先，我们从一个使用正确枚举的容器开始解码<code class="fe np nq nr ns b">type</code>。然后，我们从类型中独立地提取出<code class="fe np nq nr ns b">commonData</code>。最后，我们切换类型来初始化来自解码器的适当的post-specific数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="1352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，同样对于解码部分，我们是如何利用自动合成的初始化器<code class="fe np nq nr ns b">CommonData</code>、<code class="fe np nq nr ns b">TextData</code>、<code class="fe np nq nr ns b">PictureData</code>和<code class="fe np nq nr ns b">VideoData</code>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="5661" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">使用</h1><p id="4e1e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">为了编码和解码我们的enum，我们遵循通常的过程:我们创建<code class="fe np nq nr ns b">JSONEncoder</code>和<code class="fe np nq nr ns b">JSONDecoder</code>，并且我们使用通常的<code class="fe np nq nr ns b">encode()</code>和<code class="fe np nq nr ns b">decode()</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d395" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一次转储的(部分)输出如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/a0d70b75baf1e2643d77fb313fa6fd87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KuuuSSjNfZE5p1wKPG-kGA.png"/></div></div></figure><p id="7059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到解码工作正常。</p><p id="adb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将编码转换成人类可读的文本后，其输出如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/6b8e49dee87a0bf381083d3237680951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NPpGjMNTeQsylk_NkYsPDg.png"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f77d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="74cf" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在今天的文章中，我们探讨了如何对数据建模，这些数据的模式可以在有限的选项集之间变化。更一般地说，我们看到了如何在Swift中对异构的项目集合建模，以及如何安全地对它们进行编码和解码。</p><p id="cfb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该解决方案也是高度可扩展的:如果您需要支持额外的情况，只需用适当的数据将其添加到enum中，编译器会告诉您如何实现其余部分。如果需要向现有类型添加一些数据，可以在不影响其他数据的情况下更新相关的结构。</p></div></div>    
</body>
</html>