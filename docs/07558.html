<html>
<head>
<title>An Introduction to Programming in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust编程入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-introduction-to-programming-in-rust-76181db9665c?source=collection_archive---------4-----------------------#2021-01-27">https://betterprogramming.pub/an-introduction-to-programming-in-rust-76181db9665c?source=collection_archive---------4-----------------------#2021-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2d1d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从零开始学铁锈</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/53dca3c08cacfa1b0043953703ce8b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q0NG-5bebPGfhpYzP5r26A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="014e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Rust 是一种新兴的编程语言，在操作系统和编译器等低级系统中获得了空前的普及。</p><p id="7b7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，在2020年，Rust连续第五年在Stack Overflow开发者调查中被选为最受欢迎的编程语言。许多开发人员坚持认为，Rust将很快超过C和C++，因为Rust的借用检查器和对内存管理和隐式与显式类型等长期问题的解决方案。</p><p id="6866" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天，无论您的经验水平如何，我们都将帮助您开始使用Rust。我们将探索Rust与其他语言的不同之处，了解它的主要组件，并帮助您编写您的第一个Rust程序！</p><p id="39b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">以下是我们今天要讲的内容:</strong></p><ul class=""><li id="8457" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">什么是铁锈？</li><li id="233a" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">铁锈世界你好</li><li id="62c7" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">Rust语法基础</li><li id="3a0b" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">中间锈:所有权和结构</li><li id="6179" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">铁锈生成系统:货物</li><li id="a92c" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">接下来要学习的高级概念</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/ca9346b1f2b8a817d1272c19a8dd31c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*DpHhae2-f2sJgQ1EMzXGnA.png"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="2a94" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">什么是铁锈？</h1><p id="acc7" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">Rust是一种多范例、静态类型的开源编程语言，用于构建操作系统、编译器和其他硬件到软件工具。它是由Mozilla Research的Graydon Hoare在2010年开发的。</p><p id="d984" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Rust针对性能和安全性进行了优化，尤其是优先考虑安全并发。这种语言与C或C++非常相似，但是使用借用检查器来验证引用的安全性。</p><p id="e5a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Rust是嵌入式和裸机开发的理想系统编程语言。Rust最常见的一些应用是低级系统，如操作内核或微控制器应用。Rust拥有强大的并发编程支持，能够防止数据竞争，这让它有别于其他低级语言。</p><h2 id="55c5" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">为什么要学Rust？</h2><p id="c754" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">Rust编程语言是低级系统编程的理想选择，因为它拥有独特的内存分配系统，致力于优化和安全的并发性。虽然它在大公司中还不常见，但它仍然是评价最高的语言之一。</p><p id="5a69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Rust在不断改进，对低级系统的需求也在不断增加，所以Rust很有可能成为未来操作系统的语言。在这个早期阶段成为一名Rust开发人员将有助于你获得这些受欢迎的角色，这些角色将提供无与伦比的工作保障和高薪。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="dbf7" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">铁锈世界你好</h1><p id="b7d5" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">了解Rust的最好方法是进行一些实践。我们将介绍如何用Rust编写你的第一个<code class="fe oa ob oc od b">hello-world</code>程序。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="c67f" class="no ms it od b gy oi oj l ok ol">fn main() {</span><span id="9e9e" class="no ms it od b gy om oj l ok ol">    println!("Hello World!");</span><span id="1df0" class="no ms it od b gy om oj l ok ol">}</span></pre><p id="2916" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来分解这段代码。</p><p id="d9da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b"><strong class="la iu">fn</strong></code></p><p id="b860" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b">fn</code>是<em class="on">功能</em>的简称。在Rust(和大多数其他编程语言)中，函数的意思是“告诉我一些信息，我会做一些事情，然后给你一个答案。”</p><p id="43a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b"><strong class="la iu">main</strong></code></p><p id="723a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">主函数是程序开始的地方。</p><p id="768d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b"><strong class="la iu">()</strong></code></p><p id="a432" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些括号是该函数的参数列表。它现在是空的，意味着没有参数。先别担心这个。稍后我们会看到很多有参数的函数。</p><p id="83f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b"><strong class="la iu">{ }</strong></code></p><p id="ab14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些被称为花括号或括号。它们定义了我们代码体的开始和结束。身体会说主要功能做什么。</p><p id="7685" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b"><strong class="la iu">println!</strong></code></p><p id="b5e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个宏，和函数很像。意思是“打印并添加新的一行”现在，你可以把<code class="fe oa ob oc od b">println</code>看作一个函数。不同的是以感叹号(<code class="fe oa ob oc od b">!</code>)结尾。</p><p id="8736" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b"><strong class="la iu">("Hello, world!")</strong></code></p><p id="92f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是宏调用的参数列表。我们说“用这些参数调用这个叫做<code class="fe oa ob oc od b">println</code>的宏。”这就像main函数有一个参数表一样，只是<code class="fe oa ob oc od b">println</code>宏有一个参数。稍后我们会看到更多关于函数和参数的内容。</p><p id="fb82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b"><strong class="la iu">"Hello, world!"</strong></code></p><p id="5e7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一根绳子。字符串是放在一起的一串字母(或字符)。我们将它们放在双引号(<code class="fe oa ob oc od b">"</code>)内，将它们标记为字符串。然后我们可以将它们传递给像<code class="fe oa ob oc od b">println!</code>这样的宏和其他我们稍后会用到的函数。</p><p id="6d30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b"><strong class="la iu">;</strong></code></p><p id="f3e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是分号。它标志着英语中一个像句号一样的单个语句的结束。你可以把语句想象成计算机采取特定行动的指令。大多数情况下，一条语句只是一行代码。在这种情况下，它调用宏。还有其他类型的陈述，我们很快就会看到。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="4a4c" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">Rust语法基础</h1><p id="ccff" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">现在让我们来看看Rust程序的一些基本部分以及如何实现它们。</p><h2 id="1d5a" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">变量和可变性</h2><p id="5731" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">变量是被保存和标记以备后用的数据点。变量声明的格式是:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="176c" class="no ms it od b gy oi oj l ok ol">let [variable_name] = [value];</span></pre><p id="f1f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">变量名应该是描述该值含义的描述性内容，例如:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="54b9" class="no ms it od b gy oi oj l ok ol">let my_name = "Ryan";</span></pre><p id="f8e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们创建了一个名为<code class="fe oa ob oc od b">my_name</code>的变量，并将其值设置为<code class="fe oa ob oc od b">"Ryan"</code>。</p><p id="5e7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">提示</strong>:在命名变量时，总是以小写字母开头，以大写字母标记新单词的开始。</p><p id="6e67" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Rust中，变量在默认情况下是不可变的，这意味着一旦变量的值被设置，就不能被改变。</p><p id="5d09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，此代码将在编译期间给出一个错误:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="3545" class="no ms it od b gy oi oj l ok ol">fn main() {</span><span id="cadc" class="no ms it od b gy om oj l ok ol">    let x = 5;</span><span id="8074" class="no ms it od b gy om oj l ok ol">    println!("The value of x is: {}", x);</span><span id="bee3" class="no ms it od b gy om oj l ok ol">    x = 6;</span><span id="b79e" class="no ms it od b gy om oj l ok ol">    println!("The value of x is: {}", x);</span><span id="1e78" class="no ms it od b gy om oj l ok ol">}</span></pre><p id="6d0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">错误来自第4行，我们试图在那里设置<code class="fe oa ob oc od b">x = 6</code>。因为我们已经在第2行设置了<code class="fe oa ob oc od b">x</code>的值，所以我们不能更改该值。</p><p id="f226" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">起初，这似乎是一个令人沮丧的品质；但是，它有助于实施最小化可变数据的最佳实践。如果两个或多个函数引用同一个变量，可变数据通常会导致错误。</p><p id="0ee6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想象一下，我们有依赖于一个值为T3的变量的T2和改变这个变量的T4。<code class="fe oa ob oc od b">functionA</code>必破！</p><p id="bdcc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦你开始添加几十个变量和函数，很容易看到你是如何意外地改变一个值的。众所周知，这类问题很难调试，所以Rust选择完全避免它们。</p><p id="d7f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要覆盖这个缺省值并创建一个<em class="on">可变</em>(可变)变量，将变量声明为:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="c33f" class="no ms it od b gy oi oj l ok ol">let mut x = 5;</span></pre><p id="cd20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可变变量最常用作迭代器变量或<code class="fe oa ob oc od b">while</code>循环结构中的变量。</p><h2 id="6819" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">数据类型</h2><p id="f156" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">到目前为止，我们已经看到可以用短语(称为<em class="on">字符串</em>)和整数来设置变量值。这些变量是不同的<em class="on">数据类型</em>，一个描述它持有什么形式的值以及它能做什么样的操作的标签。</p><p id="655a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Rust有一个类型推断特性，允许编译器“推断”你的变量应该是什么数据类型，即使你没有明确地声明它。这使得你可以节省时间来为显而易见的类型编写变量声明，比如<code class="fe oa ob oc od b">my_name</code>字符串。</p><p id="e54a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以选择使用变量名和值之间的<code class="fe oa ob oc od b">: &amp;[type]</code>来显式键入变量。</p><p id="4c8c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，我们可以将我们的<code class="fe oa ob oc od b">my_name</code>声明重写为:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="6a42" class="no ms it od b gy oi oj l ok ol">let my_name = "Ryan"; //implicitly typed</span><span id="5800" class="no ms it od b gy om oj l ok ol">let my_name: &amp;str = "Ryan"; //explicitly typed</span></pre><p id="4c5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">显式类型化允许您确保以某种方式对变量进行类型化，并在变量类型可能不明确时避免错误。Rust将尽可能做出最好的猜测，但这可能会导致一些意想不到的行为。</p><p id="5985" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们有一个变量<code class="fe oa ob oc od b">answer</code>记录用户在表单上的回答。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="06a3" class="no ms it od b gy oi oj l ok ol">let answer = "true";</span></pre><p id="b34d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Rust会隐式地将这个变量输入为字符串，因为它在引号内。然而，我们可能希望这个变量是一个布尔值，它是一个介于<code class="fe oa ob oc od b">true</code>和<code class="fe oa ob oc od b">false</code>之间的二元选项。</p><p id="1b84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了避免其他开发人员的困惑，并确保发现语法错误，我们应该将声明改为:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="fd80" class="no ms it od b gy oi oj l ok ol">let answer: bool = true;</span></pre><p id="f998" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">铁锈的基本类型有:</p><ul class=""><li id="ba5b" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><strong class="la iu">整数</strong>:整数</li><li id="4f81" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu">浮点数</strong>:带小数位的数字</li><li id="a21f" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu">布尔</strong>:二进制<code class="fe oa ob oc od b">true</code>或<code class="fe oa ob oc od b">false</code></li><li id="d280" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu">字符串</strong>:用引号括起来的字符集合</li><li id="5145" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu"> Char </strong>:表示特定字符的Unicode标量值</li><li id="9196" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu"> Never </strong>:没有值的类型，用<code class="fe oa ob oc od b">!</code>标记</li></ul><h2 id="23eb" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">功能</h2><p id="9963" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">函数是捆绑在一个简写名称下的相关Rust代码的集合，并从程序的其他地方调用。</p><p id="ace3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，我们只使用了基本的<code class="fe oa ob oc od b">main()</code>函数。Rust还允许我们创建自己的附加功能，这是大多数程序必不可少的功能。功能通常代表一个可重复的任务，如<code class="fe oa ob oc od b">addUser</code>或<code class="fe oa ob oc od b">changeUsername</code>。然后，只要您想执行相同的行为，就可以重用这些函数。</p><p id="377f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b">main</code>之外的函数都必须有唯一的名称和返回输出。他们还可以选择传递参数<em class="on">和</em>，这些参数是在函数中使用的一个或多个输入。</p><p id="8f0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是声明函数的格式:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="ec22" class="no ms it od b gy oi oj l ok ol">fn [functionName]([parameterIdentifier]: [parameterType]) {</span><span id="90ac" class="no ms it od b gy om oj l ok ol">    [functionBody]</span><span id="6c6f" class="no ms it od b gy om oj l ok ol">}</span></pre><p id="6053" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b"><strong class="la iu">fn</strong></code></p><p id="0b28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这告诉Rust下面的代码是一个函数声明</p><p id="efb2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b"><strong class="la iu">[functionName]</strong></code></p><p id="9a74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们放置函数标识符的地方。每当我们想调用函数时，我们都会用到这个标识符。</p><p id="93ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b"><strong class="la iu">()</strong></code></p><p id="dc29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们会在这些括号中填入我们希望函数访问的任何参数。在这种情况下，我们不需要传递任何参数，因此可以将此留空。</p><p id="b857" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b"><strong class="la iu">[parameterIdentifier]</strong></code></p><p id="9467" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们将为传递的值指定一个名称。这个名称作为变量名引用函数体中任何地方的参数。</p><p id="cbf4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b"><strong class="la iu">[parameterType]</strong></code></p><p id="b461" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您必须在参数后提供显式类型。Rust禁止参数的隐式类型化，以避免混淆。</p><p id="3c39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b"><strong class="la iu">{}</strong></code></p><p id="f996" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些大括号标记了代码块的开始和结束。每当调用函数标识符时，就会执行之间的代码。</p><p id="8280" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b"><strong class="la iu">[functionBody]</strong></code></p><p id="e85f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是函数代码的占位符。最佳实践是避免包含任何与完成函数任务不直接相关的代码。</p><p id="bbe3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们将添加一些代码。让我们把我们的<code class="fe oa ob oc od b">hello-world</code>改造成一个叫做<code class="fe oa ob oc od b">say_hello()</code>的函数。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="a8d8" class="no ms it od b gy oi oj l ok ol">fn say_hello() {</span><span id="9dba" class="no ms it od b gy om oj l ok ol">    println!("Hello, world!");</span><span id="632a" class="no ms it od b gy om oj l ok ol">}</span></pre><p id="79d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">提示</strong>:您总能通过<code class="fe oa ob oc od b">()</code>识别出一个函数调用。即使没有参数，您仍然必须包含空白的参数字段，以表明它是一个函数。</p><p id="362b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦函数完成，我们就可以从程序的其他部分调用它。因为节目在<code class="fe oa ob oc od b">main()</code>开始，我们从那里给<code class="fe oa ob oc od b">say_hello()</code>打电话。</p><p id="d30c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是整个程序的样子:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="2c0a" class="no ms it od b gy oi oj l ok ol">fn say_hello() {</span><span id="2207" class="no ms it od b gy om oj l ok ol">    println!("Hello, world!");</span><span id="fcd2" class="no ms it od b gy om oj l ok ol">}</span><span id="bacb" class="no ms it od b gy om oj l ok ol">fn main() {</span><span id="a3ea" class="no ms it od b gy om oj l ok ol">    say_hello();</span><span id="99a8" class="no ms it od b gy om oj l ok ol">}</span></pre><h2 id="01f4" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">评论</h2><p id="9bc6" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">注释是你添加信息的一种方式，让其他程序员一眼就能明白你的程序是如何布局的。这些对于描述代码段的目的也很有帮助，这样你就可以很快地记住你以后要完成的任务。写好的评论对你和他人都有帮助。</p><p id="d2df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Rust中写评论有两种方式。首先是用两个正斜杠<code class="fe oa ob oc od b">//</code>。那么直到行尾的所有内容都会被编译器忽略。例如:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="27d1" class="no ms it od b gy oi oj l ok ol">fn main() {</span><span id="b64c" class="no ms it od b gy om oj l ok ol">    // This line is entirely ignored</span><span id="2bbf" class="no ms it od b gy om oj l ok ol">    println!("Hello, world!"); // This printed a message</span><span id="803d" class="no ms it od b gy om oj l ok ol">    // All done, bye!</span><span id="2e19" class="no ms it od b gy om oj l ok ol">}</span></pre><p id="5f05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一种方法是使用一对<code class="fe oa ob oc od b">/*</code>和<code class="fe oa ob oc od b">*/</code>。这种注释的优点是，它允许您将注释放在一行代码的中间，并且便于编写多行注释。不利的一面是，对于许多常见的情况，你必须键入更多的字符，而不仅仅是<code class="fe oa ob oc od b">//</code>。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="7d90" class="no ms it od b gy oi oj l ok ol">fn main(/* hey, I can do this! */) {</span><span id="09ba" class="no ms it od b gy om oj l ok ol">    /* first comment  */</span><span id="8054" class="no ms it od b gy om oj l ok ol">    println!("Hello, world!" /* second comment */);</span><span id="2a4d" class="no ms it od b gy om oj l ok ol">    /* All done, bye!</span><span id="5ddc" class="no ms it od b gy om oj l ok ol">       third comment</span><span id="aed9" class="no ms it od b gy om oj l ok ol">     */</span><span id="804c" class="no ms it od b gy om oj l ok ol">}</span></pre><p id="50e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">提示</strong>:你也可以使用注释来“注释掉”那些你不想执行但以后可能会添加进去的代码段。</p><h2 id="4bd6" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">条件语句</h2><p id="f182" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">条件语句是一种创建仅当一组条件为真时才发生的行为的方法。这是一个很好的方法，可以让适应性函数处理不同的程序情况，而不需要第二个函数。</p><p id="558f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有条件语句都有一个检查变量、一个目标值和一个条件操作符，如<code class="fe oa ob oc od b">==</code>、<code class="fe oa ob oc od b">&lt;</code>或<code class="fe oa ob oc od b">&gt;</code>，它们定义了两者之间的关系。变量相对于目标值的状态返回一个布尔语句:如果变量满足目标值，则返回<code class="fe oa ob oc od b">true</code>，否则返回<code class="fe oa ob oc od b">false</code>。</p><p id="7f34" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，假设我们想要创建一个函数，为任何还没有帐户的用户创建一个帐户。然后他们会登录。</p><p id="fabc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个<code class="fe oa ob oc od b">if</code>条件语句的例子。我们实际上是在说“如果<code class="fe oa ob oc od b">hasAccount</code>为假，我们将创建一个帐户。不管他们是否有现有帐户，我们都会让用户登录他们的帐户。”</p><p id="3eef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b">if</code>语句的格式是:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="f6e1" class="no ms it od b gy oi oj l ok ol">if [variable] [conditionOperator] [targetValue] {</span><span id="88a7" class="no ms it od b gy om oj l ok ol">        [code body]</span><span id="042d" class="no ms it od b gy om oj l ok ol">    }</span></pre><p id="b642" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">三大条件语句是<code class="fe oa ob oc od b">if</code>、<code class="fe oa ob oc od b">if else</code>和<code class="fe oa ob oc od b">while</code>:</p><ul class=""><li id="dfed" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><code class="fe oa ob oc od b">if</code>:“如果条件为真，则执行，否则跳过。”</li><li id="8538" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><code class="fe oa ob oc od b">if else</code>:“如果条件为真，执行代码体A，否则执行代码体b。”</li></ul><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="a527" class="no ms it od b gy oi oj l ok ol">fn main() {</span><span id="52e3" class="no ms it od b gy om oj l ok ol">    let is_hot = false;</span><span id="da4b" class="no ms it od b gy om oj l ok ol">    if is_hot {</span><span id="964a" class="no ms it od b gy om oj l ok ol">        println!("It's hot!");</span><span id="36ed" class="no ms it od b gy om oj l ok ol">    } else {</span><span id="3ed4" class="no ms it od b gy om oj l ok ol">        println!("It's not hot!");</span><span id="296b" class="no ms it od b gy om oj l ok ol">    }</span><span id="5867" class="no ms it od b gy om oj l ok ol">}</span></pre><ul class=""><li id="776a" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><code class="fe oa ob oc od b">while</code>:“条件为真时重复执行代码体，条件为假时继续执行。”</li></ul><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="907d" class="no ms it od b gy oi oj l ok ol">while is_raining() {</span><span id="6958" class="no ms it od b gy om oj l ok ol">    println!("Hey, it's raining!");</span><span id="ac35" class="no ms it od b gy om oj l ok ol">}</span></pre><p id="35ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">提示</strong> : <code class="fe oa ob oc od b">while</code>循环要求被检查的变量是可变的。如果变量永远不变，循环将无限继续。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="95a0" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">中间锈:所有权和结构</h1><h2 id="f73d" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">所有权</h2><p id="b48d" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">所有权是Rust的核心特征，也是它如此受欢迎的部分原因。</p><p id="521b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有编程语言都必须有一个释放未使用内存的系统。一些语言，如Java、JavaScript或Python，有自动垃圾收集器，可以自动移除未使用的引用。像C或C++这样的低级语言要求开发人员在需要的时候手动分配和释放内存。</p><p id="56d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">手动分配有很多问题，很难使用。任何分配时间过长的内存都会浪费内存，过早释放内存会导致错误，分配相同的内存两次会导致错误。</p><p id="4c41" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Rust使用一个所有权系统，通过编译器在编译时强制执行的一组规则来管理内存，从而将自己与所有这些语言区分开来。</p><p id="43a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">所有权的规则是:</strong></p><ul class=""><li id="8fd8" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">Rust中的每个值都有一个变量，称为它的所有者。</li><li id="c8de" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">一次只能有一个所有者。</li><li id="7918" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">当所有者超出范围时，该值将被丢弃。</li></ul><p id="bcce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们探索所有权如何与功能一起工作。声明的变量在使用时被分配。如果将它们作为参数传递给另一个函数，分配将被移动或复制到另一个所有者那里使用。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="edec" class="no ms it od b gy oi oj l ok ol">fn main() {</span><span id="c7f8" class="no ms it od b gy om oj l ok ol">     let x = 5; //x has ownership of 5</span><span id="cb7b" class="no ms it od b gy om oj l ok ol">     function(x);</span><span id="de18" class="no ms it od b gy om oj l ok ol">}</span><span id="1ad5" class="no ms it od b gy om oj l ok ol"> fn function (number : i32)   { //number gains ownership of 5</span><span id="ab50" class="no ms it od b gy om oj l ok ol">        let s = "memory";  //scope of s begins, s is valid starting here</span><span id="62c6" class="no ms it od b gy om oj l ok ol">        // do stuff with s</span><span id="886d" class="no ms it od b gy om oj l ok ol">    }                                  // this scope is now over, and s is no</span><span id="1cfe" class="no ms it od b gy om oj l ok ol">                                       // longer valid</span></pre><p id="fb00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里的关键要点是如何区别对待<code class="fe oa ob oc od b">s</code>和<code class="fe oa ob oc od b">x</code>。<code class="fe oa ob oc od b">x</code>最初拥有值<code class="fe oa ob oc od b">5</code>的所有权，但是一旦它离开<code class="fe oa ob oc od b">main()</code>函数的范围，就必须将所有权传递给参数<code class="fe oa ob oc od b">number</code>。将其用作参数允许内存分配<code class="fe oa ob oc od b">5</code>的范围超出原始函数。</p><p id="5cd8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，<code class="fe oa ob oc od b">s</code>不用作参数，因此仅在程序在<code class="fe oa ob oc od b">function()</code>内时保持分配。一旦<code class="fe oa ob oc od b">function()</code>结束，就不再需要<code class="fe oa ob oc od b">s</code>的值，可以将其释放以释放内存。</p><h2 id="91c4" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">结构</h2><p id="e65d" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">Rust的另一个高级工具是结构，叫做<em class="on">结构</em>。这些是您可以创建来表示对象类型的自定义数据类型。创建结构时，您定义了一组字段，此类型的所有结构都必须为这些字段提供值。</p><p id="d631" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以将这些看作类似于Java和Python等语言中的类。</p><p id="6354" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结构声明的语法是:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="2dd6" class="no ms it od b gy oi oj l ok ol">struct [identifier] {</span><span id="a539" class="no ms it od b gy om oj l ok ol">    [fieldName]: [fieldType],</span><span id="f467" class="no ms it od b gy om oj l ok ol">   [secondFieldName]: [secondFieldType],</span><span id="ec60" class="no ms it od b gy om oj l ok ol">}</span></pre><ul class=""><li id="a06e" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><code class="fe oa ob oc od b">struct</code>告诉Rust下面的声明将定义一个struct数据类型。</li><li id="2cfb" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><code class="fe oa ob oc od b">[identifier]</code>是传递参数时使用的数据类型的名称，比如分别将<code class="fe oa ob oc od b">string</code>或<code class="fe oa ob oc od b">i32</code>传递给字符串和整数类型。</li><li id="7207" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><code class="fe oa ob oc od b">{}</code>这些花括号标记了该结构所需变量的开始和结束。</li><li id="5e9b" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><code class="fe oa ob oc od b">[fieldName]</code>是命名该结构的所有实例必须具有的第一个变量的地方。结构中的变量被称为<em class="on">字段</em>。</li><li id="279c" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><code class="fe oa ob oc od b">[fieldType]</code>是明确定义变量的数据类型以避免混淆的地方。</li></ul><p id="d66a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，您可以创建包含字符串变量<code class="fe oa ob oc od b">brand</code>和整数变量<code class="fe oa ob oc od b">year</code>的<code class="fe oa ob oc od b">struct Car</code>。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="fb9b" class="no ms it od b gy oi oj l ok ol">struct Car{</span><span id="9b61" class="no ms it od b gy om oj l ok ol">    brand: String,</span><span id="3da4" class="no ms it od b gy om oj l ok ol">    year: u16,</span><span id="255f" class="no ms it od b gy om oj l ok ol">};</span></pre><p id="eab6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个<code class="fe oa ob oc od b">Car</code>类型的实例在创建时都必须为这些字段提供一个值。我们将创建一个<code class="fe oa ob oc od b">Car</code>的实例，用<code class="fe oa ob oc od b">brand</code>和<code class="fe oa ob oc od b">year</code>的值来表示一辆汽车。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="6e4e" class="no ms it od b gy oi oj l ok ol">let my_car = Car {</span><span id="dc68" class="no ms it od b gy om oj l ok ol">    brand: String:: from ("BMW"), //explicit type to String</span><span id="8f3c" class="no ms it od b gy om oj l ok ol">    year: 2009,</span><span id="de9c" class="no ms it od b gy om oj l ok ol">};</span></pre><p id="43f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就像我们用原始类型定义变量一样，我们用一个标识符定义一个<code class="fe oa ob oc od b">Car</code>变量，以便以后引用。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="7d3e" class="no ms it od b gy oi oj l ok ol">let [variableIdentifier] = [dataType] {</span><span id="e8ed" class="no ms it od b gy om oj l ok ol">//fields</span><span id="2b7a" class="no ms it od b gy om oj l ok ol">}</span></pre><p id="3010" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从那里，我们可以用语法<code class="fe oa ob oc od b">[variableIdentifier].[field]</code>使用这些字段的值。Rust将这种说法解释为“变量[标识符]的[字段]值是多少？”。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="2828" class="no ms it od b gy oi oj l ok ol">println!(</span><span id="e8d7" class="no ms it od b gy om oj l ok ol">        "My car is a {} from {}",</span><span id="71fa" class="no ms it od b gy om oj l ok ol">        my_car.brand, my_car.year</span><span id="0bf1" class="no ms it od b gy om oj l ok ol">    );</span><span id="7580" class="no ms it od b gy om oj l ok ol">}</span></pre><p id="7982" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是我们的结构看起来的样子:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="b14a" class="no ms it od b gy oi oj l ok ol">fn main () {</span><span id="b1ec" class="no ms it od b gy om oj l ok ol">struct Car{</span><span id="07c4" class="no ms it od b gy om oj l ok ol">    brand: String,</span><span id="fd2b" class="no ms it od b gy om oj l ok ol">    year: u16,</span><span id="dfc1" class="no ms it od b gy om oj l ok ol">};</span><span id="1846" class="no ms it od b gy om oj l ok ol">let my_car = Car {</span><span id="516a" class="no ms it od b gy om oj l ok ol">        brand: String:: from ("BMW"),</span><span id="df28" class="no ms it od b gy om oj l ok ol">    year: 2009,</span><span id="2f9b" class="no ms it od b gy om oj l ok ol">};</span><span id="f96f" class="no ms it od b gy om oj l ok ol">println!(</span><span id="b6a8" class="no ms it od b gy om oj l ok ol">        "My car is a {} from {}",</span><span id="05a0" class="no ms it od b gy om oj l ok ol">        my_car.brand, my_car.year</span><span id="6f0e" class="no ms it od b gy om oj l ok ol">    );</span><span id="bce4" class="no ms it od b gy om oj l ok ol">}</span></pre><p id="43d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总的来说，结构是一种很好的方式，可以将所有与对象类型相关的信息存储在一起，以便在程序中实现和引用。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="1f4a" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">铁锈生成系统:货物</h1><p id="1681" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated"><a class="ae lu" href="https://doc.rust-lang.org/cargo/" rel="noopener ugc nofollow" target="_blank"> Cargo </a>是Rust的构建系统和包管理器。通过列出项目需要的库(称为<em class="on">依赖</em>)来组织Rust项目是一个必不可少的工具。它会自动下载任何缺少的依赖项，并从源代码中构建Rust程序。</p><p id="ac89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，我们处理的程序足够简单，不需要依赖关系。一旦你开始制作更复杂的程序，你将需要Cargo来访问标准库之外的工具的功能。Cargo也有助于将项目上传到GitHub文件夹，因为它们将所有的部分和依赖项保存在一起。</p><p id="2c3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你从官方网站下载了Rust，Cargo会自动与编译器(<code class="fe oa ob oc od b">rustc</code>)和文档生成器(<code class="fe oa ob oc od b">rustdoc</code>)一起安装，作为Rust工具链的一部分。您可以通过在命令行中输入以下命令来验证是否安装了Cargo:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="4982" class="no ms it od b gy oi oj l ok ol">$ cargo --version</span></pre><p id="a652" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要创建Cargo项目，请在您的操作系统CLI中运行以下命令:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="1e4d" class="no ms it od b gy oi oj l ok ol">$ cargo new hello_cargo</span><span id="4d43" class="no ms it od b gy om oj l ok ol">$ cd hello_cargo</span></pre><p id="9e33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一个命令创建一个名为<code class="fe oa ob oc od b">hello_cargo</code>的新目录。第二个选项选择新目录。</p><p id="2f3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这会生成一个名为<code class="fe oa ob oc od b">Cargo.toml</code>的清单，其中包含Cargo编译您的包所需的所有元数据，以及一个负责编译您的项目的<code class="fe oa ob oc od b">main.rs</code>文件。</p><p id="6e23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要查看这些内容，请输入:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="6390" class="no ms it od b gy oi oj l ok ol">$ tree</span></pre><p id="5a37" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您也可以导航到您的目录位置来打开<code class="fe oa ob oc od b">Cargo.toml</code>文件。在中，您会发现一组关于该项目的信息，如下所示:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="1069" class="no ms it od b gy oi oj l ok ol">[package]</span><span id="b88d" class="no ms it od b gy om oj l ok ol">name = "hello_cargo"</span><span id="e6be" class="no ms it od b gy om oj l ok ol">version = "1.43.0"</span><span id="39ef" class="no ms it od b gy om oj l ok ol">authors = ["Your Name &lt;you@example.com&gt;"]</span><span id="d55d" class="no ms it od b gy om oj l ok ol">edition = "2020"</span><span id="3297" class="no ms it od b gy om oj l ok ol">[dependencies]</span></pre><p id="631f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">任何依赖关系都将列在<code class="fe oa ob oc od b">dependencies</code>类别下。</p><p id="ce1d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦您的项目完成，您就可以输入命令<code class="fe oa ob oc od b">$ cargo run</code>来编译和运行项目。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="3590" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">接下来要学习的高级概念</h1><p id="d4cc" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">虽然这些组件中有许多看起来很小，但每一个都让你离成为防锈大师更近了一步！Rust每年都变得越来越流行，这意味着现在是获取技能来创建未来的低级系统的时候了。</p><p id="036c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="on">快乐学习！</em></p></div></div>    
</body>
</html>