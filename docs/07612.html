<html>
<head>
<title>Implementing Websocket With Go and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go和React实现Websocket</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-websocket-with-go-and-react-b3ee976770ab?source=collection_archive---------1-----------------------#2021-02-02">https://betterprogramming.pub/implementing-websocket-with-go-and-react-b3ee976770ab?source=collection_archive---------1-----------------------#2021-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e4d4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在你的网络应用中实现实时交流的简单教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/285f5588150a8eff6d908444d330b5bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2D_eQSQV1GU0E0K8X1Pckg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mansonyms?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">曼森·伊姆</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄，经作者修改</p></figure><p id="73a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将带你了解如何使用Go和React实现WebSocket。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1f74" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">属国</h1><p id="9631" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">所需的依赖关系如下:</p><ul class=""><li id="dcc2" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><a class="ae ky" href="https://github.com/labstack/echo" rel="noopener ugc nofollow" target="_blank">回音</a></li><li id="2a5b" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" href="https://github.com/gorilla/websocket" rel="noopener ugc nofollow" target="_blank">大猩猩/网络插座</a></li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b4fe" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置API服务器</h1><p id="0eb3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我们将使用<a class="ae ky" href="https://github.com/labstack/echo" rel="noopener ugc nofollow" target="_blank"> echo </a>包制作一个API服务器。</p><p id="48f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将以下代码添加到<code class="fe nn no np nq b">main.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9745" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它会在<a class="ae ky" href="http://localhost:8080:" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>响应<code class="fe nn no np nq b">Hello, World!</code>，像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/7c411645cca193f7d5d64314f2a8cb6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*maL6zRQ-qjbI5ES1xh7Z0Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">http://localhost:8080</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="761f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置WebSocket</h1><p id="f00a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">默认情况下，Go有一个WebSocket的包，但目前，它缺少一些功能，正如他们<a class="ae ky" href="https://pkg.go.dev/golang.org/x/net/websocket" rel="noopener ugc nofollow" target="_blank">所说的</a>:</p><blockquote class="nu nv nw"><p id="be6c" class="kz la nx lb b lc ld ju le lf lg jx lh ny lj lk ll nz ln lo lp oa lr ls lt lu im bi translated">“这个包目前缺少一些在替代的和更积极维护的WebSocket包中发现的功能:</p><p id="3dcc" class="kz la nx lb b lc ld ju le lf lg jx lh ny lj lk ll nz ln lo lp oa lr ls lt lu im bi translated"><a class="ae ky" href="https://godoc.org/github.com/gorilla/websocket" rel="noopener ugc nofollow" target="_blank">https://godoc.org/github.com/gorilla/websocket</a>T20】https://godoc.org/nhooyr.io/websocketT21】</p></blockquote><p id="3747" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们将使用<a class="ae ky" href="https://github.com/gorilla" rel="noopener ugc nofollow" target="_blank">gorilla</a>/<a class="ae ky" href="https://github.com/gorilla/websocket" rel="noopener ugc nofollow" target="_blank">WebSocket</a>包建立一个web socket——这是一个广泛用于Go的web socket实现。</p><p id="9538" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现WebSocket的步骤如下:</p><ul class=""><li id="2e9a" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">为WebSocket创建端点</li><li id="b279" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">升级传入的HTTP连接</li><li id="1efa" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">听一个连接</li></ul><h2 id="895a" class="ob md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">为WebSocket创建端点</h2><p id="79f8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们要做的第一件事是为Websocket创建一个端点。</p><p id="c605" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们给<code class="fe nn no np nq b">main.go</code>添加一个WebSocket端点，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="0696" class="ob md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">升级传入的HTTP连接</h2><p id="5bde" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来，我们将升级传入的HTTP连接。</p><p id="02fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要创建一个结构:<code class="fe nn no np nq b">websocket.Upgrader</code>。此代码的结构包含WebSocket连接的信息，如下所示:</p><pre class="kj kk kl km gt on nq oo op aw oq bi"><span id="b589" class="ob md it nq b gy or os l ot ou">var upgrader = websocket.Upgrader{}</span><span id="369a" class="ob md it nq b gy ov os l ot ou">func main() {}</span></pre><p id="d8d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这段代码，升级处理程序中的HTTP连接:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="94f1" class="ob md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">听一个连接</h2><p id="ab40" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来，我们将创建一个函数来侦听通过客户端发送的任何WebSocket连接。</p><p id="e58f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们将期待来自客户端应用程序的JSON数据，所以让我们创建一个名为<code class="fe nn no np nq b">Message</code>的结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e5b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并在处理程序中添加一些代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5d5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义<code class="fe nn no np nq b">for</code>循环，它将监听客户端应用程序发送的任何消息。</p><p id="6fe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">读取JSON数据后，它会通过<code class="fe nn no np nq b">ws.WriteJSON(message)</code>将消息发送给客户端。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0d8a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置客户端应用程序</h1><p id="a865" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们已经为WebSocket设置了一个端点，我们将创建一个客户端应用程序来发送到WebSocket端点。</p><p id="e641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了快速启动，我们将如下使用<code class="fe nn no np nq b">create-react-app</code>:</p><pre class="kj kk kl km gt on nq oo op aw oq bi"><span id="fa20" class="ob md it nq b gy or os l ot ou">npx create-react-app websocket-app --template typescript</span></pre><p id="4950" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装后，通过运行以下命令运行开发服务器:</p><pre class="kj kk kl km gt on nq oo op aw oq bi"><span id="0ffb" class="ob md it nq b gy or os l ot ou">yarn start</span></pre><p id="ac90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到欢迎页面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/11f03cdc0637aa6392275166a71420e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ah_vBvaBHQ4Hw24w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">欢迎页面</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f323" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">连接到WebSocket端点</h1><p id="8914" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了连接到我们的WebSocket端点，我们将在<code class="fe nn no np nq b">ws://127.0.0.1:8080/ws</code>上创建一个WebSocket API连接实例，并尝试通过该连接发送消息。</p><p id="5361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对<code class="fe nn no np nq b">src/App.tsx</code>做一些修改，比如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="922f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装后，App组件将使用<code class="fe nn no np nq b">socket.onopen</code>事件启动一个监听器，其中WebSocket将升级连接。</p><p id="58fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和<code class="fe nn no np nq b">socket.messsage</code>事件监听来自服务器的消息。</p><p id="30a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经准备好测试它了，访问<a class="ae ky" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>，让我们在字段中输入一些值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/f0246e3906bf7d69c560713560d2933a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*forbiiUX9O3xzPtz8f1pqw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试电路</p></figure><p id="60a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到连接正在成功工作。</p><p id="48a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果多个客户端同时发送一条消息呢？会在其他标签页同步吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/4f58d846f8f321c35e8930accae8a7ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*u-PtT_95fPzfij_fr6A8Vg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试连接2</p></figure><p id="1947" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是否定的:因为每个客户端都有各自的连接。在<code class="fe nn no np nq b">main.go</code>中，我们仅向一个具有关联连接的客户端发送消息。</p><p id="273d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们想要实现跨应用程序的实时连接，而无需重新加载。</p><p id="2a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要实现一个可以处理多个客户端并向它们发送消息的实现。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8d43" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">处理多个客户端的实现</h1><p id="57b0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我们将创建<code class="fe nn no np nq b">hub.go</code>，它保存客户端信息并向它们发送消息。我们将使用以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d2ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并对<code class="fe nn no np nq b">main.go</code>做一些修改，像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c020" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">hub</code>结构存储一个客户端，并通过通道发送消息。当通道收到消息时，它将写回所有客户端。</p><p id="1e94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经实现了一个侦听器，它将向所有选项卡发送消息。</p><p id="f37e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们测试一下是否一切正常。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/12d81fade6dbd3382ae8362017632f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*34bpnL3FF_CAKqfsLWE1mg.gif"/></div></div></figure><p id="4d95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，只要右边的选项卡发送一条消息，左边的选项卡就会显示相同的消息。</p><p id="33e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在已经实现了实时交流。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c522" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="02cf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经介绍了如何使用Go和React实现WebSocket连接。WebSocket已经存在了一段时间，现在大多数现代浏览器都支持它，根据<a class="ae ky" href="https://caniuse.com/?search=websocket" rel="noopener ugc nofollow" target="_blank">我可以使用</a>吗？</p><p id="84c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，GraphQL通过<a class="ae ky" href="https://www.howtographql.com/react-apollo/8-subscriptions/" rel="noopener ugc nofollow" target="_blank">订阅</a>利用WebSocket协议，这是一个观察从Graphql服务器发出的事件的操作。</p><p id="fc80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当谈到全双工通信时，WebSocket比以前的方式(如HTTP轮询和SSE)更加可靠和高效。此外，有了我们上面看到的优秀库，您可以轻松地将WebSocket引入到您的应用程序中。</p></div></div>    
</body>
</html>