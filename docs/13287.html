<html>
<head>
<title>ViewModel To View in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">要在Jetpack撰写中查看的视图模型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/viewmodel-to-view-in-jetpack-compose-7c7183b54fb5?source=collection_archive---------3-----------------------#2022-08-15">https://betterprogramming.pub/viewmodel-to-view-in-jetpack-compose-7c7183b54fb5?source=collection_archive---------3-----------------------#2022-08-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="78e5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何在Jetpack Compose中将ViewModel应用于MVVM架构视图</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8d7492f9b1db8e569f35e367d9d68570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4MXWQdes-V1utKWO"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">斯蒂芬·弗兰克在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2f9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在下面找到以前关于Jetpack Compose的教程:</p><ul class=""><li id="4dd0" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/a-glimse-into-jetpack-compose-by-building-an-app-a7869723d4e8">通过构建应用程序一瞥Jetpack Compose</a></li><li id="7515" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/layouting-in-jetpack-compose-8c16e687bfe5">在Jetpack组合中布局</a></li><li id="dff1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/navigation-routes-in-jetpack-compose-ce2e0337ed28">在Jetpack中导航构成</a></li><li id="d3d7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/mvvm-in-jetpack-compose-part-4-fe757a1a1b84">在Jetpack Compose中开始使用MVVM</a></li></ul><p id="f4a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将学习在Jetpack Compose中从<code class="fe mg mh mi mj b">ViewModel</code>部分到<code class="fe mg mh mi mj b">View </code>部分的实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="6ae0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从我的上一篇文章中，我们学习了如何通过创建<code class="fe mg mh mi mj b">ViewModel</code>和<code class="fe mg mh mi mj b">Model</code>部分在我们的应用程序中实现MVVM。让我们想想如何将<code class="fe mg mh mi mj b">ViewModel</code>连接到<code class="fe mg mh mi mj b">View</code>部分。</p><blockquote class="mm mn mo"><p id="ba01" class="kw kx mp ky b kz la jr lb lc ld ju le mq lg lh li mr lk ll lm ms lo lp lq lr ij bi translated">我们建议屏幕级组件使用<code class="fe mg mh mi mj b">ViewModel</code>实例来提供对业务逻辑的访问，并成为其UI状态的真实来源。您不应该将<code class="fe mg mh mi mj b">ViewModel</code>实例传递给其他组件。</p></blockquote><p id="c32f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用规则，我们必须将<code class="fe mg mh mi mj b">ViewModel</code>传递给一个屏幕级的可组合组件。通常，屏幕级可组合组件由活动或片段组成。因此，这就是我们在应用程序中实现<code class="fe mg mh mi mj b">ViewModel</code>到<code class="fe mg mh mi mj b">View</code>的方式。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/695945101c3b9c9007a4d2b75a4b5b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y8vIqq5zTHWK88dNvvizZQ.png"/></div></div></figure><p id="85a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上图来看，每个片段都有自己的<code class="fe mg mh mi mj b">ViewModel</code>。打开<code class="fe mg mh mi mj b">HomeFragment.kt</code>和<code class="fe mg mh mi mj b">DetailFragment.kt</code>，按照以下代码操作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu ml l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu ml l"/></div></figure><p id="480d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在<code class="fe mg mh mi mj b">HomeFragment.kt</code>可以访问<code class="fe mg mh mi mj b">HomeViewModel.kt</code>并且<code class="fe mg mh mi mj b">DetailFragment.kt</code>可以访问<code class="fe mg mh mi mj b">DetailViewModel.kt</code>，它们都使用来自Jetpack Compose API的<code class="fe mg mh mi mj b">viewmodel()</code>。</p><p id="04b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将在<code class="fe mg mh mi mj b">HomeFragment.kt</code>中开始处理<code class="fe mg mh mi mj b">HomeViewModel.kt</code>。<code class="fe mg mh mi mj b">HomeFragment.kt</code>有<code class="fe mg mh mi mj b">HomeScreen.kt</code>显示由<code class="fe mg mh mi mj b">Games.kt</code>列表组成的<code class="fe mg mh mi mj b">PagingList</code>，</p><p id="d438" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mg mh mi mj b">HomeFragment.kt</code>，按照下面的代码操作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu ml l"/></div></figure><p id="76a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在<code class="fe mg mh mi mj b">HomeScreen.kt</code>有了由<code class="fe mg mh mi mj b">HomeViewModel.kt</code>正在检索的<code class="fe mg mh mi mj b">Games.kt</code>列表组成的<code class="fe mg mh mi mj b">PagingList</code>。</p><p id="3565" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mg mh mi mj b">HomeScreen.kt</code>，复制下面的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu ml l"/></div></figure><p id="f877" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码有几点我们需要知道:</p><ul class=""><li id="cf84" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe mg mh mi mj b">gamesList</code>是使用分页Jetpack组合API的<code class="fe mg mh mi mj b">LazyPagingItems</code>的一部分。</li><li id="2796" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果<code class="fe mg mh mi mj b">gamesList</code>是<code class="fe mg mh mi mj b">null</code>，这意味着它没有数据供我们显示，所以我们将在那里停止这个过程。如果不是<code class="fe mg mh mi mj b">null</code>，那么我们将继续该过程。</li><li id="b310" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe mg mh mi mj b">PagingList</code> <code class="fe mg mh mi mj b">Games.kt</code>会因为<code class="fe mg mh mi mj b">Paging</code>特性而继续添加数据。自然地，<code class="fe mg mh mi mj b">PagingList</code>的价值<code class="fe mg mh mi mj b">itemCount</code>会继续增加。</li><li id="be73" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">每个<code class="fe mg mh mi mj b">PagingList</code>都会在<code class="fe mg mh mi mj b">ProductCard.kt</code>列表中显示给我们。但是我们需要将细节解析成<code class="fe mg mh mi mj b">ProductCard.kt</code>。由于<code class="fe mg mh mi mj b">ProductCard.kt</code>是一个可组合的函数，除了<code class="fe mg mh mi mj b">HomeScreen.kt</code>之外，它还可以在其他类中使用，并且内容可能不局限于<code class="fe mg mh mi mj b">Games.kt</code>的<code class="fe mg mh mi mj b">PagingList</code>，我们必须通过给出<code class="fe mg mh mi mj b">ProductCard.kt</code>的一般参数来解析细节。</li><li id="86e1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe mg mh mi mj b">gamesList</code>有<code class="fe mg mh mi mj b">CombinedLoadStates</code>，每个状态包含<code class="fe mg mh mi mj b">LoadState</code>，如<code class="fe mg mh mi mj b">loading</code>和<code class="fe mg mh mi mj b">error</code>。如果<code class="fe mg mh mi mj b">gamesList</code>处于<code class="fe mg mh mi mj b">loading</code>状态，我们只需向用户显示加载视图，如果<code class="fe mg mh mi mj b">gamesList</code>处于<code class="fe mg mh mi mj b">error</code>状态，则显示错误视图。如果<code class="fe mg mh mi mj b">gamesList</code>不在<code class="fe mg mh mi mj b">loading</code>状态，也不在<code class="fe mg mh mi mj b">error</code>状态，我们将显示<code class="fe mg mh mi mj b">ProductCard.kt</code>列表。</li><li id="c82a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe mg mh mi mj b">ProductCard.kt</code>在<code class="fe mg mh mi mj b">onClickProduct</code>中具有特征，在<code class="fe mg mh mi mj b">Games.kt</code>中正确的<code class="fe mg mh mi mj b">Id</code>将被解析为<code class="fe mg mh mi mj b">DetailFragment.kt</code>的参数。</li></ul><p id="fceb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在在<code class="fe mg mh mi mj b">ProductCard.kt</code>中，遵循下面的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu ml l"/></div></figure><p id="eeab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们只解析<code class="fe mg mh mi mj b">ProductCard.kt</code>需要什么。<code class="fe mg mh mi mj b">ProductCard.kt</code>可以在<code class="fe mg mh mi mj b">HomeScreen.kt</code>之外的任何地方使用，因为它接受<code class="fe mg mh mi mj b">name</code>、<code class="fe mg mh mi mj b">imageUrl</code>、<code class="fe mg mh mi mj b">releaseData</code>和<code class="fe mg mh mi mj b">onClickProduct</code>。这些是通用参数，可用于除<code class="fe mg mh mi mj b">Games.kt</code>之外的任何列表。我们将按计划将该参数应用于<code class="fe mg mh mi mj b">ProductCard.kt</code>。</p><p id="5012" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到<code class="fe mg mh mi mj b">HomeScreen.kt</code>。我们将看看这一部分:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu ml l"/></div></figure><p id="a9cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所述，<code class="fe mg mh mi mj b">gamesList</code>具有包含<code class="fe mg mh mi mj b">loading</code>状态和<code class="fe mg mh mi mj b">error</code>状态的<code class="fe mg mh mi mj b">CombinedLoadStates</code>。<code class="fe mg mh mi mj b">CombinedLoadStates</code>也有三种主要状态:<code class="fe mg mh mi mj b">Append</code>、<code class="fe mg mh mi mj b">Prepend</code>和<code class="fe mg mh mi mj b">Refresh</code>。</p><ul class=""><li id="09d9" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe mg mh mi mj b">Append</code>:滚动到屏幕底部执行的<code class="fe mg mh mi mj b">CombinedLoadStates</code>的一部分。通常，这包括将内容滚动到底部，因为内容会不断添加到屏幕底部。</li><li id="7084" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe mg mh mi mj b">Prepend</code>:滚动到屏幕上方执行的<code class="fe mg mh mi mj b">CombinedLoadStates</code>的一部分。通常，这包括向上滚动页面以刷新页面，从而用新内容替换内容。</li><li id="25e8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe mg mh mi mj b">Refresh</code>:由<code class="fe mg mh mi mj b">append</code>、<code class="fe mg mh mi mj b">prepend</code>或手动刷新执行的<code class="fe mg mh mi mj b">CombinedLoadStates</code>的一部分。手动意味着让最终用户执行刷新页面的操作，例如按下刷新按钮来刷新页面，以便用新内容替换内容。</li></ul><p id="8bad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，如果API响应返回一个错误，我们只想让<code class="fe mg mh mi mj b">Append</code>和<code class="fe mg mh mi mj b">Refresh</code>状态用于滚动页面行为和刷新按钮行为。</p><p id="b4e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要向最终用户展示当API响应返回加载或错误时会发生什么。为此，我们将创建一个用于加载和出错的可组合函数。</p><p id="702b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建<code class="fe mg mh mi mj b">LoadingCircular.kt</code>。当API响应返回loading时，这个可组合函数将用于向最终用户显示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu ml l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/b51b044f467ff2882d98c3d86bb8bc8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*N1D1jFz5W8XYM0-awM04Lw.gif"/></div></div></figure><p id="f299" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建<code class="fe mg mh mi mj b">ErrorButton.kt</code>。这个可组合的函数将用于在API响应返回错误时向最终用户显示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu ml l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/f5b876afe6777b4c9d6308bee98e2619.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*P-iaasA9H7GQ0Qnh77WPcw.png"/></div></figure><p id="accc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有一个用于加载和错误行为的可组合函数。让我们将其应用于<code class="fe mg mh mi mj b">refresh</code>和<code class="fe mg mh mi mj b">append</code>状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu ml l"/></div></figure><p id="b4e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当API返回加载时，每个状态都配有<code class="fe mg mh mi mj b">LoadingCircular.kt</code>，当API返回错误时配有<code class="fe mg mh mi mj b">ErrorButton.kt</code>。当我们点击错误按钮时，将调用来自<code class="fe mg mh mi mj b">LazyPagingItems.kt</code>的重试功能，因为该代码位于<code class="fe mg mh mi mj b">LazyVerticalGrid.kt</code>T25中。</p><p id="566a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe mg mh mi mj b">HomeFragment.kt</code>应该有这样的行为。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/3f78a54a3bbb88f90750ef3055d02263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/1*lEjEA3zSYcA-A2J-fCklvw.gif"/></div></figure><p id="f207" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将重点放在<code class="fe mg mh mi mj b">DetailFragment.kt</code>上。我们想在<code class="fe mg mh mi mj b">Games.kt</code>中显示我们根据<code class="fe mg mh mi mj b">Id</code>选择的详细游戏。复制下面的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu ml l"/></div></figure><p id="edf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mg mh mi mj b">DetailViewModel.kt</code>的帮助下，我们可以调用<code class="fe mg mh mi mj b">getDetailGames</code>来检索<code class="fe mg mh mi mj b">Games.kt</code>的细节——基于<code class="fe mg mh mi mj b">Games.kt</code>中的<code class="fe mg mh mi mj b">Id</code>——并根据来自API的响应向最终用户显示可组合的功能。</p><p id="8c22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果API返回成功,<code class="fe mg mh mi mj b">Games.kt</code>的细节将被解析为<code class="fe mg mh mi mj b">DetailScreen.kt</code>。打开<code class="fe mg mh mi mj b">DetailScreen.kt</code>。复制下面的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu ml l"/></div></figure><p id="2e33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将根据下面的代码给出一些信息:</p><ul class=""><li id="f8e2" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">如果从响应API解析出的<code class="fe mg mh mi mj b">DetailScreen.kt</code>的<code class="fe mg mh mi mj b">games</code>为空，我们将不执行<code class="fe mg mh mi mj b">DetailScreen.kt</code>。</li><li id="eae4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们将定义名为<code class="fe mg mh mi mj b">name</code>、<code class="fe mg mh mi mj b">imageUrl</code>、<code class="fe mg mh mi mj b">releaseDate</code>、<code class="fe mg mh mi mj b">description</code>、<code class="fe mg mh mi mj b">listImageCarousel</code>的变量，并将它们分配给各自的可组合函数。</li><li id="bbcc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们将把<code class="fe mg mh mi mj b">backgroundImage</code>和<code class="fe mg mh mi mj b">backgroundImageAdditional</code>添加到一个列表中，该列表将被解析为<code class="fe mg mh mi mj b">ProductImageCarousel.kt</code></li><li id="064f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">由于<code class="fe mg mh mi mj b">Games.kt</code>中的描述将包含HTML格式，如<code class="fe mg mh mi mj b">&lt;b&gt;</code>、<code class="fe mg mh mi mj b">&lt;u&gt;</code>。我们将使用<code class="fe mg mh mi mj b">HtmlCompact</code>将HTML格式转换成具有粗体、下划线或无样式的文本。</li></ul><p id="57f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们只需调整<code class="fe mg mh mi mj b">ProductHeader.kt</code>和<code class="fe mg mh mi mj b">ProductCarousel.kt</code>。</p><p id="066d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mg mh mi mj b">ProductHeader.kt</code>并遵循以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu ml l"/></div></figure><p id="2b78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将<code class="fe mg mh mi mj b">ProductHeader.kt</code>作为一个可组合的函数，可以在除<code class="fe mg mh mi mj b">DetailScreen.kt</code>之外的任何地方使用。这就是为什么参数名应该尽可能通用的原因。我们解析<code class="fe mg mh mi mj b">name</code>、<code class="fe mg mh mi mj b">imageUrl</code>和<code class="fe mg mh mi mj b">releaseDate</code>，并在各自的可组合函数中解析它们。</p><p id="1f1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mg mh mi mj b">ProductImageCarousel.kt</code>。遵循以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu ml l"/></div></figure><p id="9166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将利用<code class="fe mg mh mi mj b">listImage</code>中的所有字符串显示在<code class="fe mg mh mi mj b">ProductImageCarousel.kt</code>上的图像列表中。注意，如果URL是错误的或无效的，图像将在<code class="fe mg mh mi mj b">drawable resource</code>中显示<code class="fe mg mh mi mj b">ic_launcher_foreground</code>。</p><p id="6245" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们的应用程序中应该有这样的行为。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/bc952be5f12ea4d9a1516c7ddf3bc9e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*CT5oaxNHmj8JI30GFji9Ag.gif"/></div></figure><h1 id="87cd" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">结论</h1><p id="fc1c" class="pw-post-body-paragraph kw kx iq ky b kz nq jr lb lc nr ju le lf ns lh li lj nt ll lm ln nu lp lq lr ij bi translated">我们已经学习了很多关于用MVVM架构实现Jetpack Compose中的<code class="fe mg mh mi mj b">ViewModel Section</code>到<code class="fe mg mh mi mj b">View</code>部分。</p><p id="9542" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章的所有代码可以在<a class="ae kv" href="https://github.com/SkyairOnline/Jetpack-Compose" rel="noopener ugc nofollow" target="_blank">这里</a>查看。</p><p id="6008" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一篇文章中，我将讲述如何在我们的应用程序中使用注入。</p><p id="de17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里看到我的下一篇文章</p><div class="nv nw gp gr nx ny"><a rel="noopener  ugc nofollow" target="_blank" href="/dependencies-injection-jetpack-compose-using-hilt-bd4f76ac6c22"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">依赖注入Jetpack组成使用手柄</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">创建松散耦合的干净代码的技巧</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">better编程. pub</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kp ny"/></div></div></a></div></div></div>    
</body>
</html>