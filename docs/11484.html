<html>
<head>
<title>5 More Python One-liners You Should Use</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您应该使用的另外5个Python一行程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-more-python-one-liners-you-should-use-475d0a0a3e22?source=collection_archive---------3-----------------------#2022-03-24">https://betterprogramming.pub/5-more-python-one-liners-you-should-use-475d0a0a3e22?source=collection_archive---------3-----------------------#2022-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9e01" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解决问题。节省时间。快走</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/594971b4ed44c0f3c3915b3ccc6e8cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wafYMZu7Ve4erwK2DHWPAg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卢克·彼得斯在<a class="ae ky" href="https://unsplash.com/s/photos/developer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="bca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">欢迎回到另一个版本:</p><p id="2fd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“看看这段简短的代码能做多少有趣的事情！”</p><p id="7403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一期中，我们将探索Python代码中一些非常酷的部分。这些简短的一行程序解决了广泛的问题，如果你已经设法将自己编程到一个角落，它们可以让你摆脱困境。</p><p id="e02c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中一些例子来自Python标准库，而另一些来自第三方库。下次你需要快速解决问题，想节省时间或者只是想让一些东西看起来更简洁，试试这些。</p><h1 id="0bd7" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">1.用lambdas映射列表</h1><p id="f091" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们的第一个例子是最有用的，但也颇有争议。这个一行程序允许您遍历列表的内容，然后对列表中的单个元素执行操作。该列表可以很容易地就地修改，创建一个修改过的版本，并把你从经典的<code class="fe mt mu mv mw b">for</code>或<code class="fe mt mu mv mw b">while</code>循环中拯救出来。</p><p id="eba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个映射字符串列表并将短语“<em class="lv">_后缀</em>”添加到每个字符串末尾的示例:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="8266" class="nb lx it mw b gy nc nd l ne nf">original_list = ['one', 'two', 'three']</span><span id="8948" class="nb lx it mw b gy ng nd l ne nf">new_list = list(map(lambda x: str(x) + '_suffix', original_list))</span></pre><p id="d9f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行之后，我们的<code class="fe mt mu mv mw b">new_list</code>变量应该包含以下内容:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="f9f9" class="nb lx it mw b gy nc nd l ne nf">['one_suffix', 'two_suffix', 'three_suffix']</span></pre><p id="9515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种紧凑方法有争议的原因是，对于较大的lambda表达式，它可能比传统的多行循环可读性差得多。lambda函数可能会变得混乱，您可能会开始混淆代码中的意图。将它用于复杂的列表操作是不明智的，但是像这样的快速变化可以极大地清理事物。</p><h1 id="4e12" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">2.检查字符串是否包含在字符串列表中</h1><p id="d41c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这是一段我已经重复了无数次的代码。能够知道某个内容是否包含在列表的任何项目中非常有用。这可以很容易地用于定位版本号或在名称列表中查找名称。</p><p id="1f9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试试名字的例子。假设我们有以下全名列表:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="d9b2" class="nb lx it mw b gy nc nd l ne nf">name_list = ['Kathy Bates', 'George Clooney', 'Will Smith']</span></pre><p id="3b34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们假设我们想要确定任何名为“George”的人是否在我们的列表中:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="63bc" class="nb lx it mw b gy nc nd l ne nf">any('George' in name for name in name_list)</span></pre><p id="4a56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">又短又甜。使用带有简单的<code class="fe mt mu mv mw b">in</code>检查的<code class="fe mt mu mv mw b">any</code>允许我们快速确定是否有任何元素包含名称“乔治”。</p><p id="d22a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，如果您运行这段代码，您会得到以下结果:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="49e2" class="nb lx it mw b gy nc nd l ne nf">True</span></pre><p id="fe20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们知道乔治·克鲁尼藏在哪里了。</p><h1 id="191d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">3.选择性破坏分配</h1><p id="9d7d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当你在处理析构赋值的时候，列表中有其他你不需要赋值的元素是很棘手的。这些元素通常出现在列表的末尾，但有时也会出现在列表的开头或中间。这带来了一个恼人的问题，即在析构赋值时必须删除一些变量。</p><p id="6bc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，在给变量赋值时，有一种简单的方法可以去掉不用的变量。我们拿下面的数据来说:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="5a1b" class="nb lx it mw b gy nc nd l ne nf">person = ['bob', 'smith', 39, 'professor']</span></pre><p id="0f3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些数据中，我们有一个人的信息。我们有名字、姓氏、年龄和职业。假设我们想把这个分解成单个变量，但是我们并不关心Bob的姓或者他的年龄(Bob是永恒的):</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="1acc" class="nb lx it mw b gy nc nd l ne nf">first_name, *_, profession = person</span></pre><p id="6abc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用神奇的<code class="fe mt mu mv mw b">*_</code>语法，我们可以省略一行中的几个元素，只保留剩下的一个。如果我们打印出每个变量，我们可以看到我们现在有适当的数据:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="5ac6" class="nb lx it mw b gy nc nd l ne nf">print(first_name)<br/>&gt;&gt;&gt; bob</span><span id="7089" class="nb lx it mw b gy ng nd l ne nf">print(profession)<br/>&gt;&gt;&gt; professor</span></pre><p id="892e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想简单地省略一个元素而不是许多元素，我们可以使用<code class="fe mt mu mv mw b">_</code>。这将在我们使用列表中的下一个位置元素时跳过它。</p><h1 id="1e0a" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">4.仅从列表中获取唯一的项目</h1><p id="77d9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这是一个非常常见的编程任务。无论您是从数据库中获取数据，还是清理一些用户提供的信息，删除重复项都是一项非常常见的日常工作。</p><p id="2a03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您有一个数字列表，并且希望确保它不包含任何重复的数字:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="940a" class="nb lx it mw b gy nc nd l ne nf">my_numbers = [1, 2, 3, 4, 4, 5, 6, 6, 7, 8]</span></pre><p id="34ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使列表具有唯一性的最简单、最干净的方法是将其转换成一个<code class="fe mt mu mv mw b">set</code>。默认情况下，A <code class="fe mt mu mv mw b">set</code>不允许重复值，所以你的列表通过简单的转换就会自动变得唯一。别担心，您可以在以下时间后将其转换回列表:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="006d" class="nb lx it mw b gy nc nd l ne nf">unique_list = list(set(my_numbers))</span></pre><p id="4ead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们打印出我们的<code class="fe mt mu mv mw b">unique_list</code>变量，我们将只看到唯一的值:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="881c" class="nb lx it mw b gy nc nd l ne nf">print(unique_list)<br/>&gt;&gt;&gt; [1, 2, 3, 4, 5, 6, 7, 8]</span></pre><h1 id="f326" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">5.使用pyforest动态导入库</h1><p id="df21" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您是否曾经编写了一个冗长的脚本，或者处理了一个大型复杂的数据集，并以大量的import语句而告终？在你的文件顶部附近，看起来像是<code class="fe mt mu mv mw b">import import import</code>的海洋。就像他们把电影的演职员表放在开头一样。带我去看精彩的部分吧。</p><p id="4a5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在一个进口城市游泳，那么你可能想知道如何减少声明的总数。一种方法可能是把你的文件分割得更细一些，使它们更加模块化。这是一种选择，但有时分解会导致不必要的重复，甚至增加复杂性。有时候，把所有内容都放在一个地方是很好的(也可能更具可读性)。</p><p id="8f16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方法是使用<code class="fe mt mu mv mw b">pyforest</code>模块。这是一个第三方模块，允许您编写单行导入语句，并让它动态导入许多其他样板模块。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="e864" class="nb lx it mw b gy nc nd l ne nf">import pyforest</span></pre><p id="8114" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是拉进一辆装满模块的自动倾卸卡车所需要的一切。最棒的是，你并没有真的把他们拉进来… <em class="lv">而不是</em>。<code class="fe mt mu mv mw b">pyforest</code>模块只会在你引用它的时候导入一些东西。因此，如果您想引用<code class="fe mt mu mv mw b">os</code>模块(以及许多其他模块)，您所要做的就是导入<code class="fe mt mu mv mw b">pyforest</code>,然后在import语句之后以任何形式使用<code class="fe mt mu mv mw b">os</code>。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="761b" class="nb lx it mw b gy nc nd l ne nf">import pyforest</span><span id="993f" class="nb lx it mw b gy ng nd l ne nf">os.getpid()</span></pre><p id="3324" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您运行上面的代码，您将看到一个成功的运行和当前Python实例的进程ID。</p><p id="1f4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个模块对于减少混乱、动态加载模块和减少代码的总启动时间非常有用。</p><p id="2188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看官方<code class="fe mt mu mv mw b">pyforest</code> GitHub获取更多信息:</p><div class="nh ni gp gr nj nk"><a href="https://github.com/8080labs/pyforest" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">GitHub-8080 labs/py forest:py forest-感受自动化导入的幸福</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">一遍又一遍地写同样的导入是你力所不及的。让pyforest替你做这件事。有了pyforest你…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ks nk"/></div></div></a></div></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="599c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！如果你喜欢这篇文章，请看看我下面的其他Python帖子:</p><ul class=""><li id="bf40" class="og oh it lb b lc ld lf lg li oi lm oj lq ok lu ol om on oo bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/handy-python-snippets-for-cleaner-code-a1e2c5d39a0d"> <em class="lv">便于清理代码的Python片段</em> </a></li><li id="4865" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/obscure-python-syntax-you-should-try-831dbc96777e"> <em class="lv"> 5种晦涩难懂的Python语法你应该试试</em> </a></li></ul></div></div>    
</body>
</html>