# 理解 JavaScript 中 Currying 的实用指南

> 原文：<https://betterprogramming.pub/understanding-currying-in-javascript-8e7f76e08904>

## 奉承会让人困惑。我们来分解一下

![](img/a4193eec4eeeded19e6778646cec9e32.png)

我听说我们在谈论咖喱！😋——图片由 [Dragne Marius](https://unsplash.com/@marius_dragne?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

你是一个听说过“咖喱”这个词的程序员。也许你已经使用了部分应用，并假设它们是同一个东西。他们不是。

读完这本理解和启发的指南后，你也会加入那些知道区别的精英程序员群体。

# 准确的 Currying 资源

抛开所有的笑话和乐趣，我创建了这篇信息性文章，作为对所有关于 JavaScript 欺骗的可怕资源的回应。当我在谷歌上搜索“JavaScript curry”时，我震惊地看到结果顶部有这么多错误信息，即来自[这篇文章](https://blog.bitsrc.io/understanding-currying-in-javascript-ceb2188c339)和[这篇文章](https://medium.com/@kbrainwave/currying-in-javascript-ce6da2d324fe)。

值得庆幸的是，从 [javascript.info](https://javascript.info/currying-partials) 、 [Eric Elliot](https://medium.com/javascript-scene/curry-and-function-composition-2c208d774983) 和 [Adam Bene](https://blog.benestudio.co/currying-in-javascript-es6-540d2ad09400) 那里获得了一些有用的信息，然而除了 javascript.info 之外，即使是这些有用的资源也无法提供一个可靠的、通用的 curry 函数。

正是由于这种可怕的认识，我觉得我有责任向程序员传播这种困境的知识和意识，并提供一篇理智、准确和有用的文章。

# 条款

也就是说，在我们开始学习如何使用 currying 之前，理解一些术语是至关重要的:

## **一级功能**

如果函数可以存储在变量中，并像常规对象一样对待，比如被其他函数传入和返回，那么就说一种语言支持一级函数。

## **高阶函数**

一种对其他函数进行操作的函数，要么接受一个函数作为输入，要么返回一个函数作为输出，或者两者都接受。

如果一种语言没有对一级函数的支持，更高阶的函数就不能存在于那种语言中。

## **关闭**

> “一种在具有一级函数的语言中实现词汇范围[名称绑定](https://en.wikipedia.org/wiki/Name_binding)的技术”——[维基百科](https://en.wikipedia.org/wiki/Closure_(computer_programming))

这意味着函数保留了对定义时在作用域内的变量的访问权，即使在没有这些变量的作用域内调用该函数。

## **部分应用**

> "将一个函数的多个变元固定下来，产生另一个更小变元的函数的过程."— [维基百科](https://en.wikipedia.org/wiki/Partial_application)

## **阿谀奉承**

> 将带有多个参数的函数的计算转换为带有单个参数的函数序列的计算— [维基百科](https://en.wikipedia.org/wiki/Currying)

## **Arity**

函数接受的参数数量。

# 部分应用

部分函数应用是一种预定义一些参数的方法，这些参数将在任何后续参数之前首先应用。

一位好心的作者在[的这篇维基百科](https://en.wikipedia.org/wiki/Partial_application)文章中写道:

> "如果您确定了函数的前几个参数，您将得到一个包含其余参数的函数."

在 JavaScript 中，将参数部分应用于不同函数的函数示例如下所示:

注意，这个例子并不完全符合部分应用的定义——从技术上讲，它返回的是一个[变量函数](https://en.wikipedia.org/wiki/Variadic_function)，而不是一个更小 arity 的函数。

在这个代码示例中，函数`partiallyApply`接受一个函数`func`和一些预定义的参数(`argsToApply`)作为输入，并返回一个包装了`func`的新函数。

神奇的事情就发生在这个包装函数中。当我们创建匿名包装函数时，一个*闭包*被创建，它保留了对`argsToApply`变量的访问。

这意味着即使包装函数被返回并且`argsToApply`不再在作用域内，包装函数仍然保留对`argsToApply`的访问。

以下是一些部分应用的功能:

正如我们所看到的，在`concat5`的例子中，我们能够预定义五个参数中的三个，然后用剩下的两个调用函数，即使这些预定义的参数不再在作用域中。

这在某种程度上与 currying 有关，我们现在将探讨这一点。

# Currying

虽然与局部应用相关，但是*与*不是同一个*。*curry 函数就是取一个函数，将其转化为一系列函数，每个函数取一个自变量。

这里有一个例子来说明:

这里发生了一些有趣的事情:

1.  `curry`函数将一个函数作为参数，并返回一个新函数。
2.  返回的函数返回一个函数，以此类推(这是函数的序列)。如果您要检查每个 curried 函数调用的返回值，您会看到除了最后一个返回值之外，它们都是函数，这就引出了这个问题:
3.  函数序列确切地知道最后一个参数是什么时候提供的，它不是返回一个新函数，而是返回最终结果。

正如我们所看到的，currying 与部分应用程序的区别在于，与部分应用程序的单个函数相比，currying 返回一系列函数，这些函数知道何时结束并返回最终结果。这是因为 currying 关心函数的 *arity* 。

如果我们还记得本文顶部术语的定义， *arity* 是函数接受的参数个数。`curry`函数能够检测所需数量的参数何时被传入，并相应地采取行动。

在 JavaScript 中，我们可以用`Function.prototype.length`方法获得 arity，如下所示:

即使默认参数和 rest 参数接受额外的参数，它们也不计入函数的长度。

注意，默认参数和 rest 参数不计入函数的`length`。在 currying 的上下文中，这是有意义的。如果参数是可选的，我们如何知道何时返回最终值而不是另一个函数？

理解`argsAfterDefault`有一个为 0 的`length`也很重要，即使在默认参数之后有两个“常规”参数。当 JavaScript 计算一个函数的`length`时，它只关心在任何默认或 rest 参数之前的参数*。*

有了这些信息，我们现在对我们想要的`curry`函数的行为有了更多的了解。它应该只在传入了`length`个参数后返回最终值——一次一个。

但是如果我们想一次传递多个呢？或者什么都不通过？

考虑这个例子:

我们想要两个 curry 函数的哪个实现？

`currySingleArgs`严格遵循阿谀奉承的定义，但`curryMultipleArgs`灵活得多。这实际上取决于您的具体情况需要什么，所以让我们继续深入研究这两个问题。

# 玩弄多种论点

我们来分析一下这两个库里功能的实现，从`curryMultipleArgs`开始:

这可能看起来有点复杂，但是一旦我们把它分解，它就变得简单了。让我们来看看返回的函数:

这是我们传入函数的简化版本。

这里需要注意的是，像部分应用程序一样，这个内部(或“包装”)函数创建了一个*闭包*，它仍然可以访问最初传入的函数来获取它的`length`并最终调用它，即使在函数超出范围之后。

该功能有两个主要部分:

1.  如果传入了适当数量的参数，就用这些参数调用原始函数。
2.  否则，返回一个接受更多参数的匿名函数。

第一部分更容易理解。如果我们处理我们的函数，然后用正确数量的参数立即调用处理过的函数(`curry`)，那么原始函数(`func`)将使用这些参数执行。

第二部分是有趣的地方。让我们分析一下返回的匿名函数:

这个函数表达式用括号括起来，在语法上是合法的。

这是一个接受任意数量参数的函数，类似于`curried`函数，当使用这些参数调用时，调用`curried`函数。

同样，与部分应用程序示例和`curried`一样，需要注意的是这个匿名函数创建了一个闭包，它保留了对重要引用的访问，即传递给`curried` ( `args1`)和`curried`本身的参数。

现在，这还有点不清楚，但是当我们一步一步地，了解程序是如何执行的时候，这就更有意义了。

为此，我创建了一个修改版的`curryMultipleArgs`，它在每次执行函数序列中的一个函数时记录`args1`和`args2`的值:

当匿名函数被执行时，它也会立即调用 curried。

这个解决方案的工作方式是以迂回的方式递归调用`curried`，使用一个接受更多参数的匿名函数。

如果这不是 100%有意义，不要担心。这很好，也在意料之中。奉承是一个具有挑战性的话题，有很多东西需要你去思考。

# 玩弄一个论点

让我们来分析一下`currySingleArgs`的实现:

这比另一个实现稍微复杂一点，因为需要对外部数组进行变异，以便只强制使用单个参数。

这个实现跟踪所有的参数，不是通过传入数组并与每个函数调用连接，而是通过首先初始化一个数组来保存所有的参数，然后在每次调用`intermediate`时向该数组推送一个新的参数。

该算法有两个主要步骤:

1.  在函数序列中的第一次函数调用时(当调用`curried`时)，初始化参数数组并立即用传入的参数调用`intermediate`。
2.  如果最终传入了正确数量的参数，则调用`func`。如果还没有传入正确数量的参数，返回`intermediate`接受另一个参数。

让我们从第二步开始，采用由内向外的方法来剖析这个函数:

作为逻辑的核心，这出奇的简单。

这张快照中没有太多内容。该函数接受一个参数`arg`，并立即将其推送到`args`数组。

之后，如果`args`的长度等于`func`的长度，这只有在最后一个参数被传入时才成立，我们用参数调用`func`并返回结果。

否则，我们返回`intermediate`，允许程序继续链接函数调用。

第二步没有太多的内容，让我们仔细看看第一步。这可能有点令人困惑，但一旦我们将其分解，我们就可以开始理解到底发生了什么:

值得注意的是，参数数组是在我们调用函数序列中的第一个函数时初始化的，而不是在我们调用函数时初始化的。

以这个简单的 curry 解决方案为例，它在函数被 curry 化时初始化参数数组:

这是非常不可取的行为。

为了避免这种行为，我们需要在开始调用 curried 函数后初始化`args`。

一种方法是将整个事情包装在一个函数中，我们将其命名为`curried`，然后在初始化`args`后立即调用`intermediate`。

这样，`intermediate`的任何后续调用仍然能够访问`args`数组，但是`curried`函数的任何新调用都将拥有自己的`args`副本。

让`intermediate`函数向`args`添加另一个参数的唯一方法是让`curried`或另一个`intermediate`返回它，这迫使我们链接我们的函数调用，而不依赖于状态:

正是我们想要的行为。

如您所见，这就是让函数正常运行的全部内容。

这里发生了很多事情，但是当我们分解并分析解决方案时，它开始变得有意义。在发生的许多事情中，最需要理解的是:

1.  通过在函数签名中只接受一个参数，我们一次只处理一个参数。
2.  这个参数，无论是否存在，都被放入我们的`args`数组中。这是当具有正确数量的参数时将应用于`func`的数组。
3.  `args`仅在我们开始调用 curried 函数后初始化，而不是在此之前。这给了我们简单、可预测的行为。我们通过生活和大量使用闭包来实现这个目标。

# TL；速度三角形定位法(dead reckoning)

JavaScript 中的通用 curry 函数有两种实现方式，一种是一次只能接受一个参数，另一种是一次可以接受任意数量的参数:

一般柯里函数的两种实现。

这是一次性的文章/指南。我希望你喜欢它，并发现它是有益的和有趣的。