<html>
<head>
<title>How To Perform Python Web Scraping in 12 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在12分钟内完成Python网页抓取</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-perform-python-web-scraping-in-12-minutes-bec3bb336015?source=collection_archive---------12-----------------------#2021-03-16">https://betterprogramming.pub/how-to-perform-python-web-scraping-in-12-minutes-bec3bb336015?source=collection_archive---------12-----------------------#2021-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2ef1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个简短的教程，介绍如何在没有HTML或XPath知识的情况下使用AutoScraper Python库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f9f3072466b65f0f78daa47bfaa555c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rSAFKYRJdDMWaLx6NIEzJg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">米格尔·a·阿穆蒂奥在<a class="ae ky" href="/s/photos/search?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="1054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Web抓取对于数据工程师、数据科学家等等来说是一个非常有用的工具。虽然有许多公开可用的数据集和API可以用作您的项目或业务的输入，但在web上也有大量免费可用的信息，您可以使用web抓取来收集。</p><p id="a76c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当谈到web抓取的实践时，有许多跨不同语言的不同工具和方法可供您使用。很多网页抓取库需要你对网站如何工作有一些了解。您可能还需要花一些时间来学习使用某个特定的库。例如，Python中漂亮的Soup库能够从HTML文件中提取数据，因此被广泛用于web抓取上下文。然而，要使用这个库，您需要对HTML有所了解，并花一些时间熟悉特定于模块的方法。</p><p id="2a4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我并不是说学习HTML和网站的一般工作方式不好。然而，如果你并不真正感兴趣，只是想使用网站作为数据来源，那么使用像<a class="ae ky" href="https://github.com/alirezamika/autoscraper" rel="noopener ugc nofollow" target="_blank"> AutoScraper </a>这样的库可能会更好！自动web抓取有付费的解决方案，但是如果你有Python知识，你可以利用这个轻量级的web抓取库从web页面抓取内容，而不需要知道任何HTML术语。相反，您需要的只是复制和粘贴文本的能力(或多或少)。</p><p id="68f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我想通过一个简短的实践演示向您展示AutoScraper可以做什么，演示您如何在没有任何先验知识的情况下使用它来开始web抓取。我们将通过几个例子来了解仅使用AutoScraper就能获得著名的<a class="ae ky" href="http://quotes.toscrape.com/" rel="noopener ugc nofollow" target="_blank">报价相关数据</a>(只需十分钟的时间)。</p><p id="82e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想跟着做，确保你已经安装了AutoScraper提供)。此外，为了更好地在我们浏览示例时检查进度，我使用了<code class="fe lv lw lx ly b">pprint</code>模块(data pretty printer)并在Jupyter笔记本上浏览示例。导入这两个库然后我们开始吧！</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="92d8" class="md me it ly b gy mf mg l mh mi">from autoscraper import AutoScraper<br/>from pprint import pprint</span></pre><p id="7738" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">提醒:您应该确保检查哪种数据(如果有的话)可以从特定来源获得。一个好的做法是检查</em> <code class="fe lv lw lx ly b"><em class="mj">robots.txt</em></code> <em class="mj">文件，看看站点是否主动允许抓取。如果你看到</em> <code class="fe lv lw lx ly b"><em class="mj">robots.txt</em></code> <em class="mj">禁止某些用户代理(比如你用来抓取网页的代理)访问网站，你最好去找另一个数据源。你还应该检查你要抓取的网站的条款和条件页面(通常链接在网站的页脚)，看看它是否允许自动数据收集/抓取。负责任的刮！</em></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="da8a" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">从网页中获取一个元素</h1><p id="5d20" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">首先，让我们试着从网页中获取一个东西。一些有用的东西是简短的传记/描述，对于那些想了解更多作者信息的人来说。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/875552e63b46b5c563e6bcd3e3d65e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGPYlWcVeKxYipT2a-JbcQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="http://quotes.toscrape.com/author/Andre-Gide/" rel="noopener ugc nofollow" target="_blank">行情刮</a></p></figure><p id="6b79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是复制粘贴部分的用武之地。每个作者的个人资料页面看起来都很相似，所以为了让我们的AutoScraper获取我们传递给它的每个个人资料URL的描述，我们需要首先在一个站点上训练它。这样做看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4518" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们为想要抓取的页面设置一个URL(在本例中，它是个人资料页面)。不同作者的URL中不同的部分是作者的名字，所以要访问J.K .罗琳的个人资料页面，你需要将<code class="fe lv lw lx ly b">desired_author</code>设置为<code class="fe lv lw lx ly b">J-K-Rowling</code>。最好在一开始就这样做，而不是为你想看的每个新作者重写URL。</p><p id="8589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使AutoScraper在许多不同的站点上工作，我们首先必须用我们想要收集的数据在一个样本站点上“训练”它。在这种情况下，我们需要“描述”数据，即上图中框内的所有文本。训练数据必须以列表的形式出现，即使你只取一个元素，所以我们需要做的是复制并粘贴描述，并将其分配给<code class="fe lv lw lx ly b">profile_training_data</code>。</p><p id="d240" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们创建一个新的<code class="fe lv lw lx ly b">AutoScraper</code>类实例并运行<code class="fe lv lw lx ly b">build</code>方法，提供<code class="fe lv lw lx ly b">profile_url</code>(我们想要抓取的页面)并将<code class="fe lv lw lx ly b">profile_training_data</code>传递给<code class="fe lv lw lx ly b">wanted_list</code>(我们想要收集的数据)。这个新定义的<code class="fe lv lw lx ly b">AutoScraper</code>将学习如何获取你想要的训练数据。它还会记住如何为你传递给它的类似网站这样做。</p><p id="af6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在其他链接上测试scraper，让我们运行以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/d909a1e2c3e9b2bf9f9051a19b13ca3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fiXy4wl3JSff6Bgv1WxHDg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">笔记本结果—作者简介</p></figure><p id="a0f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们上面所做的是抓取三位新作者的简介:阿尔伯特·爱因斯坦、J.K .罗琳和苏珊·科林斯。我们所做的就是将三位作者的名字分配给一个列表，然后遍历该列表，并使用经过训练的<code class="fe lv lw lx ly b">profile_scraper</code>来获取这三位作者的简介。对于存储，我们定义了一个字典来存储所有结果，其中键是作者姓名，值是作者描述。当然，您可以自由地以不同的方式存储它们，或者建立自己的管道将这些结果转移到数据库(sqlite3、MongoDB等)中。)取决于您的使用情况。</p><p id="055b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获取数据，我们使用了来自<code class="fe lv lw lx ly b">AutoScraper</code>类的<code class="fe lv lw lx ly b">get_result_exact</code>方法，该方法返回来自与<code class="fe lv lw lx ly b">profile_scraper</code>从训练数据中学习到的规则相匹配的站点的结果列表。稍后，我们将看到另一种在抓取数据时允许模糊匹配的方法。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="0546" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">从一个页面获取多个元素</h1><p id="9b51" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">现在我们已经介绍了基础知识，让我们尝试另一个简单的例子，我们只是用AutoScraper从一个网页中抓取多个东西。假设我们想从每个作者的个人资料页面中获取他们的出生日期和出生地。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/2b8644a8cb1ed627f3b908c544397ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b2qUvv1vorBI7QwK8Sa6Xw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="http://quotes.toscrape.com/author/Suzanne-Collins/" rel="noopener ugc nofollow" target="_blank">行情刮</a></p></figure><p id="93eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码看起来和以前差不多，只是这一次，我们将多个值的列表传递到训练数据中。这样做应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9555" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以在三个新作者身上测试新的刮刀。同样，代码看起来和上次差不多，但是我们要给<code class="fe lv lw lx ly b">get_result_exact</code>方法传递一个额外的参数。这样做会看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/40fe64186d166c8ced5a79d5e1054dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S-f7tn-_LAcHCwGihLAWkA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">笔记本结果—使用“分组”作为别名</p></figure><p id="204c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过设置<code class="fe lv lw lx ly b">grouped=True</code>，我们可以看到每一项的<code class="fe lv lw lx ly b">rule_id</code>。这个<code class="fe lv lw lx ly b">rule_id</code>可以认为是返回数据的类别标签。因为我们之前向<code class="fe lv lw lx ly b">wanted_list</code>传递了多个值，所以我们需要<code class="fe lv lw lx ly b">grouped=True</code>来确保我们能够识别返回的结果。从<code class="fe lv lw lx ly b">get_result_exact</code>返回的结果将是一个条目字典，以<code class="fe lv lw lx ly b">rule_id</code>为键，以找到的数据点列表为值。</p><p id="fe9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过不同的组来识别元数据项，这很好，但是您会看到我们为每个规则取了任意的名称。我们可以通过在传递训练数据时为规则添加一个别名来解决这个问题。我们不是将一个列表传递给<code class="fe lv lw lx ly b">build</code>方法，而是将一个值字典传递给<code class="fe lv lw lx ly b">wanted_dict</code>参数。这个字典应该将键作为别名(要收集的数据的类别标签或名称)，然后将值作为要收集的数据(前面的<code class="fe lv lw lx ly b">wanted_list</code>中的内容)。重新训练<code class="fe lv lw lx ly b">metadata_scraper</code>会是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3faa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以在多个作者身上运行AutoScraper，使用与之前相同的格式，但是有一处修改。我们没有将<code class="fe lv lw lx ly b">grouped=True</code>传递给<code class="fe lv lw lx ly b">get_result_exact</code>方法，而是传递了<code class="fe lv lw lx ly b">group_by_alias=True</code>。这意味着该方法将返回一个字典，其中前面定义的别名作为键，匹配数据的列表作为值。执行此操作的代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/5e486932d2f14bd0fcf3a24049b10e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-AhHChjnalc6jwJk2xJ2g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">记录单结果—按命名别名分组</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="3b44" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">抓取精确的结果与从网页抓取相似的结果</h1><p id="a068" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">到目前为止，我们只使用了<code class="fe lv lw lx ly b">get_result_exact</code>方法来收集数据。AutoScraper库还提供了<code class="fe lv lw lx ly b">get_result_similar</code>方法，如果您想从与您的训练数据格式不完全相同的网页中获得额外的结果，该方法会有所帮助。</p><p id="113c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试这一点，让我们试着从主要报价抓取页面的顶部标签:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/76f5551d273d65a1b4f190f9e17fe2bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ACpHYXfnaoJLsn23mVLxQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="http://quotes.toscrape.com/" rel="noopener ugc nofollow" target="_blank">行情刮</a></p></figure><p id="b2f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们需要复制并粘贴在页面右侧列表中找到的前十个标签，并将它们分配到我们的培训数据列表中。和以前一样，我们将使用<code class="fe lv lw lx ly b">wanted_dict</code>，这样我们可以为AutoScraper将要学习的<code class="fe lv lw lx ly b">rule_id</code>分配一个别名。训练这个顶级标记刮刀将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3569" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经训练了<code class="fe lv lw lx ly b">tags_scraper</code>，让我们看看在我们用来训练自动抓取器的同一个站点上调用<code class="fe lv lw lx ly b">get_result_exact</code>会发生什么:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a99d" class="md me it ly b gy mf mg l mh mi">tags_scraper.get_result_exact(tag_url)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/68d002a8e97f5c3289093a18baaa947b.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*acnxbqR2zAIDT5I6zWvhqA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">笔记本结果—获取结果精确</p></figure><p id="ebb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，代码正确地返回了您可以在主页上看到的顶部标签。然而，页面上的每个可见帖子都有标签，这可能是另一个有趣的数据集。为了获取这些数据，我们可以执行以下操作:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a531" class="md me it ly b gy mf mg l mh mi">tags_scraper.get_result_similar(tag_url, grouped=True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/f9dca544c7722162c6be5b858ad54fab.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*-fSrI7J8Um3Rh_4M-eaxYw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">笔记本结果-获取结果相似</p></figure><p id="4a8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面，我们使用了<code class="fe lv lw lx ly b">get_result_similar</code>方法来获得页面上所有标签的列表，尽管我们在训练数据中没有包括页面上的post标签。根据您的使用情况，此方法可能有助于获取更多超出用于训练AutoScraper的确切数据范围的数据。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="0391" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">定制自动刮刀</h1><p id="a05f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">注意，你也可以看看你的刮刀在训练时学到的所有规则，而不必从中获得结果。为此，我们来看看我们已经训练过的<code class="fe lv lw lx ly b">tags_scraper</code>的<code class="fe lv lw lx ly b">stack_list</code>:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f860" class="md me it ly b gy mf mg l mh mi">existing_rules = [rule["stack_id"] for rule in tags_scraper.stack_list]<br/>pprint(existing_rules)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/5914b8707b5cc4cd317c6c51934a4f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*GvGKpdA444qTQ9flGWRsRw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">笔记本结果—堆栈列表名称(自动抓取学习规则)</p></figure><p id="fbce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面，我们只是通过使用一些列表理解来找到<code class="fe lv lw lx ly b">tags_scraper</code>已经学习的规则的名称，并将它们全部放在一个列表中。输出显示scraper已经学习了许多规则，但是如果您查看来自<code class="fe lv lw lx ly b">tags_scraper.get_result_similar</code>的输出，您会看到每个规则包含相同的数据。您可以使用<code class="fe lv lw lx ly b">remove_rules</code>或<code class="fe lv lw lx ly b">keep_rules</code>方法编辑刮刀，使其仅包含您需要的规则。您所需要做的就是为相应的方法传递一个您想要删除的规则或者您想要保留的规则的列表。</p><p id="63fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，因为我们只想从页面中获取顶部的标签，所以让我们编辑掉返回具有多个值的结果的规则。如果您滚动查看来自<code class="fe lv lw lx ly b">tags_scraper</code>的早期输出，您会发现顶部的标签只出现在具有单值列表的规则中。我们可以用另一个列表理解片段巧妙地实现这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2a33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，为了检查我们是否已经删除了除了一个规则之外的所有规则，让我们运行我们之前使用的相同的列表理解片段来查看当前存在于<code class="fe lv lw lx ly b">tags_scraper</code>中的所有规则:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8a54" class="md me it ly b gy mf mg l mh mi">edited_existing_rules = [rule["stack_id"] for rule in tags_scraper.stack_list]<br/>pprint(edited_existing_rules)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/867c1a7a2aead68dca73e0f894184d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*ebdKZdH6mKfEuINXKq1dkw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">笔记本结果—堆栈列表名称(编辑后自动抓取学习的规则)</p></figure><p id="d693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧啊。我们已经编辑了<code class="fe lv lw lx ly b">tags_scraper</code>，现在只有我们想要的规则列表。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="4391" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">使经过训练的刮刀可重复使用</h1><p id="d488" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在完成训练自动铲运机的工作后，有一种方法来储存训练过的铲运机以备将来使用是有意义的。这样做比每次你需要运行铲运机时都要重新训练要有效得多。</p><p id="7c06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">save</code>方法将把规则(我们知道保存在分配给我们初始化的AutoScraper的<code class="fe lv lw lx ly b">stack_list</code>中)序列化为JSON，并将它们保存到您指定的文件路径中。然后，当您想要再次使用保存的scraper时，您可以使用<code class="fe lv lw lx ly b">load</code>方法替换您调用它的<code class="fe lv lw lx ly b">AutoScraper</code>类的实例的现有<code class="fe lv lw lx ly b">stack_list</code>。这可以像这样简单地完成:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d053" class="md me it ly b gy mf mg l mh mi"># saving the tags_scraper we trained before<br/>tags_scraper.save("tags_scraper_trained")</span><span id="d96c" class="md me it ly b gy nz mg l mh mi"># fresh session might look like<br/>tags_scraper_trained = AutoScraper()<br/>tags_scraper_trained.load("tags_scraper_trained")</span></pre><p id="1e63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以像前面使用<code class="fe lv lw lx ly b">get_result_exact</code>或<code class="fe lv lw lx ly b">get_result_similar</code>方法一样使用<code class="fe lv lw lx ly b">tags_scraper_trained</code>实例。一旦你在探索阶段完成了训练和定制你的scraper的工作，保存<code class="fe lv lw lx ly b">AutoScraper</code>实例可能是很好的第一步。然后，当您准备好定期抓取数据时，您可以在代码的最开始调用<code class="fe lv lw lx ly b">load</code>方法来使用保存的AutoScraper。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="2f56" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="d2b9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">仅此而已！</p><p id="ba44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您是在寻找一种无需API即可获取数据的方法的数据工程师，还是希望为机器学习项目收集自己的数据而不是使用现有数据集的数据科学家，Web抓取都是一种添加到您的工具包中的有用实践。</p><p id="beb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是网络抓取的新手，或者对学习HTML或XPath之类的东西不太感兴趣，AutoScraper可能是你可以依赖的工具。自动化工具确实有其局限性，所以根据您需要定制web抓取操作的程度，您可能会发现您需要学习使用其他更实用的库。</p><p id="079e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，我希望这篇关于AutoScraper库的简短介绍对您有所帮助。祝你的(负责任的)数据收集之旅好运！</p></div></div>    
</body>
</html>