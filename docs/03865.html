<html>
<head>
<title>Understanding the useEffect Dependency Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解useEffect依赖项数组</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-the-useeffect-dependency-array-2913da504c44?source=collection_archive---------0-----------------------#2020-03-10">https://betterprogramming.pub/understanding-the-useeffect-dependency-array-2913da504c44?source=collection_archive---------0-----------------------#2020-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="114a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入反应</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8f2e5fd949c72cd235117935105e41ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6TrOhlcJNL7V0CqnICw2HQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@travelnow_or_crylater?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> travelnow.or.crylater </a>在<a class="ae ky" href="https://unsplash.com/s/photos/understand?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="1131" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍</h1><p id="961a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">最近写了一篇关于<a class="ae ky" href="https://medium.com/better-programming/redux-vs-context-vs-state-4202be6d3e54" rel="noopener"> <em class="mu">上下文vs状态vs Redux</em></a>的文章。目标是尝试给开发者一些关于每个选择的优点和缺点，并希望帮助你对你计划使用的工具做出更好的选择。</p><p id="7370" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在我发布之后，有几个人问我关于使用<a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>移植到钩子的问题。一些开发人员在使用<code class="fe na nb nc nd b">mapDispatchToProps</code>和<code class="fe na nb nc nd b">connect</code> <a class="ae ky" href="https://github.com/reduxjs/react-redux" rel="noopener ugc nofollow" target="_blank"> React Redux </a> HOC时遇到了<code class="fe na nb nc nd b">useEffect</code>在每个渲染上运行的问题。</p><p id="74c7" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这些都是很好的问题！思考了一会儿之后，让我们来分析一下为什么你会看到这个，希望能帮助你理解为什么会发生这种情况。</p><p id="3879" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">因此，本文首先解释背景，然后解决这个问题的步骤是:</p><ol class=""><li id="1a04" class="ne nf it ma b mb mv me mw mh ng ml nh mp ni mt nj nk nl nm bi translated">什么是<code class="fe na nb nc nd b">useEffect</code>钩？</li><li id="96d4" class="ne nf it ma b mb nn me no mh np ml nq mp nr mt nj nk nl nm bi translated">什么是依赖数组？</li><li id="5bde" class="ne nf it ma b mb nn me no mh np ml nq mp nr mt nj nk nl nm bi translated">函数在依赖数组中工作吗？</li><li id="c593" class="ne nf it ma b mb nn me no mh np ml nq mp nr mt nj nk nl nm bi translated">我们能用<code class="fe na nb nc nd b">useEffect</code>搭配<code class="fe na nb nc nd b">mapStateToDispatch</code>吗？</li></ol><h2 id="5b2e" class="ns lh it bd li nt nu dn lm nv nw dp lq mh nx ny ls ml nz oa lu mp ob oc lw od bi translated">但是useDispatch呢？</h2><p id="3d0e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在我们跳进去之前，我应该马上回答；React Redux提供了一个<code class="fe na nb nc nd b">useDispatch</code>钩子。</p><p id="2053" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这个挂钩允许我们像以前的<code class="fe na nb nc nd b">connect</code> HOC一样进行调度，我强烈推荐将来使用它。</p><p id="0f37" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在本文的后面，我们将讨论它如何与<code class="fe na nb nc nd b">useEffect</code>一起工作的一些细节，但是这里关注的是围绕一个更“遗留的”(如果我们可以称之为遗留的)系统的工作，这个系统仍然在使用<code class="fe na nb nc nd b">connect</code>。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="56c3" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">什么是useEffect？</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="5faf" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">最简单地说，<code class="fe na nb nc nd b">useEffect</code>是一个钩子，允许你在功能组件中执行副作用。更详细地说，这些效果仅在组件渲染后执行，因此不会阻止渲染本身。</p><p id="9fd9" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">通常，这类似于获取组件需要的一些数据的请求。如果我们不处理副作用，React组件将如何呈现？我们的副作用会阻碍用户界面吗？</p><h2 id="9a2b" class="ns lh it bd li nt nu dn lm nv nw dp lq mh nx ny ls ml nz oa lu mp ob oc lw od bi translated">阻止用户界面</h2><p id="1509" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">您在代码中直接遇到的第一个问题是，您可以非常容易地阻止UI的呈现。您无法通过请求阻止它。<a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank">反应</a>会阻止你得到那个选项。</p><p id="3cdd" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">例如，第一眼看上去，您可能决定等到数据返回后再进行渲染。如果尝试使用异步函数，React将出错。</p><p id="8a73" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><strong class="ma iu">注意:</strong>React中即将出现可中断组件！这将通过<a class="ae ky" href="https://reactjs.org/docs/concurrent-mode-intro.html" rel="noopener ugc nofollow" target="_blank">并发模式</a>实现，我强烈推荐阅读更多相关内容。也许我即将发表的一篇文章可以探索代码！</p><p id="ff79" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我很好奇是否有任何方法可以让React等待我的请求，但我做不到。我甚至使用了一个令人恶心的<code class="fe na nb nc nd b">sleep</code>方法，JavaScript会在跳回解析一个承诺之前正确地完成这个函数。我只是觉得这很棒。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="fce4" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">但是上面的例子确实说明了阻塞UI。请注意，当单个组件被阻塞时，它将停止页面的呈现，等待它完成。</p><p id="f2c3" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">像这样冻结UI就是为什么我们不想阻止任何类型的渲染的副作用，并且应该有足够的理由尝试找到一些方法来隔离该功能，直到初始渲染之后。尽管如此，我们还是来看看阻塞以外的例子</p><p id="028a" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">假设我们没有屏蔽UI，我们仍然使用承诺。我们的代码可能看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="64e9" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这里有几个问题，让我们一次看一个。</p><h2 id="4dc5" class="ns lh it bd li nt nu dn lm nv nw dp lq mh nx ny ls ml nz oa lu mp ob oc lw od bi translated">无限重渲染</h2><p id="54a4" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">上面代码的明显问题是，这将创建一个无休止的重新渲染循环。这也可能发生在<code class="fe na nb nc nd b">useEffect</code>中，但是有更多的规则来确保这种事情不会发生。</p><p id="6beb" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果我们尝试观察状态中的数据，比如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="f12b" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果我们这样做，看起来会好很多。我的意思是，网页存在，这总是一个进步。当我们试图对这个组件进行推理时，这种方法的问题变得更加明显。然后，从那里开始，随着复杂性的增加。</p><p id="7f3b" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">所以让我们问问自己，这里的数据是什么？对于功能本身来说，它永远不是“现在”它总是上一次渲染的数据。</p><h2 id="b0f6" class="ns lh it bd li nt nu dn lm nv nw dp lq mh nx ny ls ml nz oa lu mp ob oc lw od bi translated">组件推理</h2><p id="80c4" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在上面的例子中，组件推理不是一个大问题。我们只想要这个数据一次，不担心加载等问题。</p><p id="0f70" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">但是，如果用户可以传入URL，这意味着当它有数据时，实际上需要调用它，但只有来自指定URL的数据。该数据来自上一次渲染，而不是本次渲染。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7571" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">现在，当然，<code class="fe na nb nc nd b">useEffect</code>效果是在渲染之后执行的，所以你可以说它在逻辑上和我们之前的没有什么不同。</p><p id="4bf3" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">但是我认为，通过在<code class="fe na nb nc nd b">useEffect</code>中放置一些东西，你明确地告诉下一个看到这段代码的开发者，它在逻辑上不在这个组件的流程中。</p><p id="6bfd" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">它不是用来自上而下阅读的。这个函数可以被认为是在这个组件的其余部分执行之后。然而，当某个东西与一个功能组件内联时，则假设数据现在对该组件可用。</p><p id="b603" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">现在，如果花一点时间收集我们想要的数据会怎么样？长时间运行的代码执行可能会阻止UI的呈现，但是为了简单起见，我将使用一个超时来假装这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://codesandbox.io/s/delayed-fetch-without-effect-876qw" rel="noopener ugc nofollow" target="_blank">自己试试吧！</a></p></figure><p id="55bd" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果您呈现它，您可能会注意到组件更新了几次，并且查询其事实的次数不可预知。这是因为我们现在需要记住渲染中的一些边缘情况。</p><p id="a470" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果有人在没有任何数据的时候更新了这个，但是我们已经在收集数据了，会发生什么呢？如果请求获取，但是我们的组件更新并请求另一个，会发生什么？</p><p id="958d" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">想象一下，在这段时间内，我们也有可以更新元素的交互，这似乎并不牵强。越来越难推理出我们组件的确切状态，以及在给定时间内发生了什么。</p><p id="4194" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这并不是说这些事情是不可能的。但是肯定有更好的方法，这就引出了最后一点。</p><h2 id="8763" class="ns lh it bd li nt nu dn lm nv nw dp lq mh nx ny ls ml nz oa lu mp ob oc lw od bi translated">功能纯度</h2><p id="0bdd" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果你在“函数式”编程的世界中工作过，你的函数中的这些效果是不被允许的。您希望确保组件具有<a class="ae ky" href="https://en.wikipedia.org/wiki/Referential_transparency" rel="noopener ugc nofollow" target="_blank">引用透明性</a>。副作用会带走你的功能的纯粹性。</p><p id="b662" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我认为函数式编程是您应该掌握的一项重要资产，但是我今天不想深入探讨它。看待这个问题最简单的方法是问问自己，假设您将一组特定的输入传递给组件，您能期待相同的输出吗？</p><p id="bb09" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我们代码中的每个副作用都会降低这种可能性。现在，在你试图从你的系统中完全消除所有副作用之前，请记住用户输入本身就是一个副作用，使用<code class="fe na nb nc nd b">useEffect</code>仍然是一个副作用。</p><p id="52d4" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">相反，我们的目标应该是管理、隔离和控制。如果我们想将测试从内部隔离到一个组件或系统，像这样处理输入在将来的测试中也很方便。</p><p id="c2b1" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">为了保持这个函数更加纯粹，我们将使用依赖数组。稍后我们将深入研究依赖数组，但是现在让我们看看它是什么样子的。</p><p id="3cd7" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">使用<code class="fe na nb nc nd b">useEffect</code>钩子的美妙之处还在于将它与React团队发布的<a class="ae ky" href="https://www.npmjs.com/package/eslint-plugin-react-hooks" rel="noopener ugc nofollow" target="_blank"> ESLint规则</a>配对，这将让您知道数组中建议的依赖关系，并有助于尽可能保持该函数的纯净。</p><h2 id="ebe8" class="ns lh it bd li nt nu dn lm nv nw dp lq mh nx ny ls ml nz oa lu mp ob oc lw od bi translated">作为一个使用效果，这个例子看起来像什么？</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://codesandbox.io/s/fetchexampleone-pf1il" rel="noopener ugc nofollow" target="_blank">自己试试！</a></p></figure><p id="16cc" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><strong class="ma iu">注意:</strong>在上面的例子中，<code class="fe na nb nc nd b">fetch</code>也应该是<code class="fe na nb nc nd b">useEffect</code>的依赖数组的一部分。在我们研究这个例子的时候，我不想添加太多的噪音，但是我们将在文章的后面回到为什么它需要在那里。</p><p id="5efa" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">看看<code class="fe na nb nc nd b"><a class="ae ky" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">useEffect</a></code>，它看起来和我们之前的例子没有太大的不同。您会注意到，如果您将超时添加回代码示例，它现在也将正确工作。</p><p id="1c52" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我们稍后会解释为什么会这样，但是请注意，我们实际上只添加了两个新的部分，一个是<code class="fe na nb nc nd b">useEffect</code>调用，另一个是<code class="fe na nb nc nd b">[id, setData]</code>依赖数组。</p><p id="5251" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">正如我前面提到的，我发现随着我对钩子越来越熟悉，看到一个<code class="fe na nb nc nd b">useEffect</code>告诉我这段代码不会影响组件，直到初始渲染之后。</p><p id="9c72" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">它允许我快速找到代码中的“副作用”,减少了运行组件的认知负荷，增加了可读性。</p><p id="87df" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果这是一个我们在其他组件中经常看到的请求，我们甚至可以将它分解成自己的自定义钩子，这对于可读性更有帮助:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="b9c4" class="ns lh it bd li nt nu dn lm nv nw dp lq mh nx ny ls ml nz oa lu mp ob oc lw od bi translated">所以，我应该在副作用上使用useEffect钩子？</h2><p id="23a5" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">唷，是的。你应该。这是一个很长的列表，说明了为什么不应该将它与组件内联，但是我希望这些例子能够帮助您理解为什么要构建它。</p><p id="546b" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><code class="fe na nb nc nd b">useEffect</code>允许您:</p><ul class=""><li id="8048" class="ne nf it ma b mb mv me mw mh ng ml nh mp ni mt og nk nl nm bi translated">而不是阻止用户界面。</li><li id="f3f4" class="ne nf it ma b mb nn me no mh np ml nq mp nr mt og nk nl nm bi translated">创建一个可视化的“代码块”,这是一个可见的效果。</li><li id="7a6d" class="ne nf it ma b mb nn me no mh np ml nq mp nr mt og nk nl nm bi translated">保持你的函数的纯净(或者，它试图保持纯净)。</li><li id="1112" class="ne nf it ma b mb nn me no mh np ml nq mp nr mt og nk nl nm bi translated">增加代码的可读性</li><li id="a994" class="ne nf it ma b mb nn me no mh np ml nq mp nr mt og nk nl nm bi translated">需要时可以方便地提取自定义钩子，以便我们可以在其他组件之间共享。</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="76d1" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">它是如何与类组件联系在一起的？</h1><p id="d236" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">对于React的长期开发人员来说，当我开始讨论钩子时，经常出现的第一个问题是:“什么是生命周期方法钩子？”</p><p id="7863" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">或者在给他们看<code class="fe na nb nc nd b">useEffect</code>的时候会被问到:“这是我的<code class="fe na nb nc nd b">componentDidMount</code>发生的地方吗？”我对回答这些问题非常谨慎。</p><p id="48e8" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">本质上，人们想要的是一种将类组件1:1地逻辑映射到功能组件的方法，但是我不太愿意用这种方式把它绑在一起。你必须摆脱功能组件和<a class="ae ky" href="https://reactjs.org/docs/components-and-props.html" rel="noopener ugc nofollow" target="_blank">类组件</a>之间1:1映射的思维。</p><p id="db2b" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">尝试以一种新的方式重新想象一个功能组件，最关键的是这个功能可以并且应该在任何时候都可以被调用。</p><p id="720a" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">有些东西不仅仅叫做“在山上”。相反，应该用一个依赖数组来调用它们，比如父级的状态。并且只有当依赖关系改变时，才应该再次调用它。</p><p id="8d10" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">依赖数组在<code class="fe na nb nc nd b">useEffect</code>之外也能工作，<code class="fe na nb nc nd b">useCallback</code>和<code class="fe na nb nc nd b">useMemo</code>是其他很好的例子。</p><p id="070d" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我们希望记忆一个函数或返回值，并且只有在依赖数组中的特定数据发生变化时才调用/重新初始化这些东西。但是，这应该可以随时调用。</p><p id="1e6a" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><strong class="ma iu">注:</strong>如果你想看这方面更深入的描述，我强烈推荐看看丹·阿布拉莫夫的<a class="ae ky" href="https://overreacted.io/a-complete-guide-to-useeffect/" rel="noopener ugc nofollow" target="_blank">分解</a> <code class="fe na nb nc nd b"><a class="ae ky" href="https://overreacted.io/a-complete-guide-to-useeffect/" rel="noopener ugc nofollow" target="_blank">useEffect</a></code>。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="423f" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">什么是依赖数组？</h1><p id="805f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">因此，我已经多次抛出了“依赖数组”，我们最好将其分解并理解它的作用。依赖数组是<code class="fe na nb nc nd b">useEffect</code>函数中的第二个可选参数。</p><p id="f54c" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">顾名思义，这是一个依赖关系数组，当从以前的渲染中改变时，将调用第一个参数中定义的效果函数。我们先来看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="1919" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">那么，这种效应到底在做什么呢？每次这个组件被更新时，它都会调用这个<code class="fe na nb nc nd b">useEffect</code>。也许这就是我们想要的，这是可以接受的。</p><p id="a315" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">但通常情况下，你可能只是因为其他原因才希望这种效果发生。也许只有当数据改变时，或者也许当用户第一次看到组件时。</p><p id="be06" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在上面的例子中，我们似乎只希望这个效果在<code class="fe na nb nc nd b">id</code>中的值改变时运行。为了做到这一点，我们通过将<code class="fe na nb nc nd b">id</code>放入依赖数组来告诉效果“仅在<code class="fe na nb nc nd b">id</code>改变时运行”。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="e014" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">现在这个效果只在<code class="fe na nb nc nd b">id</code>与之前更新不同时执行。我上面提到也许你只希望它在用户“第一次看到组件”时运行，但是我之前也提到不要把它想成<code class="fe na nb nc nd b">componentDidMount</code>……我不是自相矛盾吗？</p><p id="cebf" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">不完全是，因为当我们谈论“第一次看到”时，我们实际上是从用户的角度来谈论它。他们的体验不一定需要像我们一直期望的那样符合代码。</p><p id="50c5" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">很可能，如果我们为一个页面加载数据，目的是在用户登陆该页面时获取数据。所以，如果你想这样做，你可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="84d5" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这只会在第一次被调用时获取数据。这是有道理的，对吗？我们给了这个效果一个依赖数组。所以我们的效果认为:“嘿，只有当这个数组中的值改变时，才回忆这个效果”。但是没有值，所以它永远不会更新。</p><p id="c810" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">但是我警告你不要使用这种风格来构建你的效果。React团队也是如此。</p><p id="46c1" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">它会导致令人困惑的、难以发现的错误。相反，让我们考虑一下这个组件。我们传入一个URL，它定义了我们在哪里进行这个获取。如果我们像这样把URL放在数组中会发生什么？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="69dc" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">有三种结果。</p><ol class=""><li id="b537" class="ne nf it ma b mb mv me mw mh ng ml nh mp ni mt nj nk nl nm bi translated">该URL永远不会改变，效果应该只运行一次。</li><li id="dee8" class="ne nf it ma b mb nn me no mh np ml nq mp nr mt nj nk nl nm bi translated">该URL正在更改，但您只希望它在第一时间进行查询。</li><li id="a15d" class="ne nf it ma b mb nn me no mh np ml nq mp nr mt nj nk nl nm bi translated">该URL不断变化，您希望它每次都进行查询。</li></ol><p id="f34f" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">对于数字1和3，无论你想走哪条路，第二个解决方案都适合你。</p><p id="1b9b" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">对于第一点，如果URL在第一次进入道具后没有改变，那么它已经正常工作了。URL是依赖关系，并且这种依赖关系不会改变。</p><p id="839b" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果由于某种原因，它确实发生了变化，您将会更快地看到错误，而将一个空数组传递给依赖数组将会对您“隐藏”这个错误。</p><p id="3b88" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">对于第三点，这就是构建依赖数组的目的。每次URL改变时，效果都会重新运行，您不需要设置任何复杂的逻辑来将它绑定到组件，就像我们在本文开始时必须做的那样。</p><p id="846a" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">所以，唯一真正的问题是第二点。但是当你停下来想一想，你在这个例子中构造组件的方式似乎有一个更重要的问题。</p><p id="9bd3" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">您希望数据进入，但是这些数据只是组件的一个实例的代表。如果有人稍后拍摄组件的快照，并将这些输入传递给新的组件，您将不会得到相同的输出。</p><p id="8056" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我们的例子没有我们想要的组件的引用透明性。我们应该期望给定一组输入，我们总是得到相同的输出。</p><p id="feda" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我们的目标应该是这些组件在任何时候都是可调用的。所以，我强烈建议你，如果你达到了第二个结果，重新考虑你的部分。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="d9a6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">函数在依赖数组中工作吗？</h1><p id="2a2a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">是啊！它们的工作方式与依赖数组中的值的工作方式相同，但是它们被绑定到该函数的引用上。每当那个函数的引用改变时，我们都要重新运行那个效果。</p><p id="1161" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在上面的例子中，我们作弊了，因为我们从未真正定义过<code class="fe na nb nc nd b">fetchData</code>是什么。让我们看一个没有组件的函数的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="db1f" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这行得通，对吧？嗯，是的，但可能不是以我们想要的方式，因为这将再次调用我们对组件的每次更新的影响。每次更新<code class="fe na nb nc nd b">ExampleComponent</code>时，我们都要重新初始化<code class="fe na nb nc nd b">fetchData</code>函数。</p><p id="ce36" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><strong class="ma iu">注意</strong>:同样，我们不想将我们的心智模型绑定到类组件中，很多人已经习惯了类组件中的实例变量/方法。</p><p id="d837" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在功能组件的情况下，我们没有贯穿更新的“以前的值”。如果再次调用一个函数，所有这些值都会被重新创建，包括函数。</p><p id="c976" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">你对上面这个问题的第一个想法可能是:“那么，为什么还要在依赖数组中有这个函数呢？如果我删除它，它工作正常。”</p><p id="00b7" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">是的，在这种情况下，它会像你预期的那样工作，但是如果你使用React的<a class="ae ky" href="https://www.npmjs.com/package/eslint-plugin-react-hooks" rel="noopener ugc nofollow" target="_blank"> ESLint作为钩子</a>(我强烈建议你这样做)，你会注意到它不是这样的。</p><p id="f781" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这是因为同样的原因，我们上面谈到了第一次渲染时的<em class="mu">和我们的<code class="fe na nb nc nd b">url</code>道具。这可能会给我们带来想要的结果，但是它也可能隐藏了一个不想要的bug。</em></p><p id="4199" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在上面的例子中，我们实际上只希望使用一个函数，但是你可以将一个函数作为道具传递给你的组件。并且该功能可以是几种不同的可能功能之一。</p><p id="fd75" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">就像<code class="fe na nb nc nd b">url</code>道具一样，我们希望确保如果我们收到一个新函数，我们会再次调用effect。</p><p id="6c61" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">因此，随着推理的方式，我们如何才能解决我们的ESLint问题，并保持我们的效果尽可能纯净。有三种方法，每一种解决不同的用例。</p><h2 id="a9c1" class="ns lh it bd li nt nu dn lm nv nw dp lq mh nx ny ls ml nz oa lu mp ob oc lw od bi translated">方法1。将函数移动到效果中</h2><p id="772b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">用例:这个<code class="fe na nb nc nd b">fetchData</code>调用只在这个本地<code class="fe na nb nc nd b">useEffect</code>中使用。</p><p id="ac0a" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果你计划只在这个<code class="fe na nb nc nd b">useEffect</code>中使用这个函数，最直接和推荐的解决方案是将函数直接移到效果闭包中。</p><p id="09ab" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这适用于我们之前讨论的所有内容，它确保了我们的效果函数本身尽可能的纯净和透明。它将逻辑封装在一个区域中，并且让开发人员知道这个功能只是一个副作用。</p><p id="2c75" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">那看起来像什么？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="3cca" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">由于<code class="fe na nb nc nd b">fetchData</code>函数现在是我们效果的一部分，它不再是我们效果的依赖项，我们可以简单地将它从依赖数组中移除。</p><h2 id="50f5" class="ns lh it bd li nt nu dn lm nv nw dp lq mh nx ny ls ml nz oa lu mp ob oc lw od bi translated">方法2。用useCallback记忆函数</h2><p id="d9e8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">用例:这个函数在多个本地钩子中使用，或者将要在一个子组件中传递。</p><p id="eebc" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><code class="fe na nb nc nd b">useCallback</code>是一种新的反应手段。它允许我们记忆一个函数，以便在组件的后续更新中，该函数保持其引用相等，因此不会触发效果。</p><p id="76f5" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><code class="fe na nb nc nd b">useCallbacks</code>使用与<code class="fe na nb nc nd b">useEffect</code>相同的依赖数组，因此如果它所依赖的值或函数改变，它将被重新初始化。为了理解这是如何工作的，我认为跳到引用和值相等是有用的。</p><p id="de9a" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><strong class="ma iu">引用相等与值相等</strong></p><p id="58c8" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">出于我们的目的，我们正在寻找两种类型的等式，值和引用(也称为<em class="mu">复合值</em>)。</p><p id="e848" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">值相等稍微好理解一点。值相等是变量的实际“值”的比较，例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="624d" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在上例中，<code class="fe na nb nc nd b">A === C</code>，而<code class="fe na nb nc nd b">B</code>也不等于。但是如果我们现在改变<code class="fe na nb nc nd b">A</code>，那么<code class="fe na nb nc nd b">A</code>和<code class="fe na nb nc nd b">C</code>的值将不再相等。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="f5ee" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">现在，不仅这些值不再相等，而且它们指向内存中的两个不同点。我们知道这一点，因为当我们改变A时，C并不随之改变。</p><p id="3f86" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果它们共享内存中的同一个位置，两个值将同时更新。这就是为什么这些是价值上的平等，而不是指称上的平等。让我们来看看我们的记忆是什么样子的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/94ee15bbbab090ed8a667e8a1e821fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VDj0_n9JjQb9jTwofms0oQ.gif"/></div></div></figure><p id="0f21" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">对于原始值，如字符串或整数，我们只能通过值进行比较，我们没有办法存储另一个变量的引用。即使我们这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="9d70" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">尽管我们将变量<code class="fe na nb nc nd b">B</code>指向我们的<code class="fe na nb nc nd b">A</code>变量，但我们并没有得到内存中的位置，我们仍然只是得到了变量值的一个副本。</p><p id="f148" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">许多其他语言确实有能力存储变量的“引用”,通常称为指针。这在C/C++语言中可能最为人所知。</p><p id="b304" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">另一方面，我们可以比较引用值和复合值，比如对象、函数和数组。</p><p id="5e0f" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><strong class="ma iu">注意:</strong>技术上来说函数和数组也是JavaScript中的对象。</p><p id="23ee" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">为了回到使用<code class="fe na nb nc nd b">useEffect</code>依赖数组中的函数，让我们看看函数的引用相等性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="d86f" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">函数A和B都指向内存中的同一个点。现在，如果有人要给A重新赋值，它会把A移动到内存中的一个新位置，就像上面一样，B仍然会指向原来的位置。</p><p id="c86d" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">另一方面，如果A持有一个对象，我们改变了这个对象，B也会得到这些更新。让我们用图表来看看上面的代码示例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/294c5440ce923e3a0d90830fe1718964.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kb3ok78-qxZkgn02L2mkQg.png"/></div></div></figure><h2 id="a3a6" class="ns lh it bd li nt nu dn lm nv nw dp lq mh nx ny ls ml nz oa lu mp ob oc lw od bi translated">回到我们的记忆函数</h2><p id="0ba8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">因此，知道我们可以为给定的函数在内存中存储对某个点的引用，我们可以将该引用传递到一个<code class="fe na nb nc nd b">useEffect</code>的依赖数组中。</p><p id="9a5b" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果组件被重新渲染，而那个函数没有指向内存中的同一个点(即使是同一个函数和参数)，那么<code class="fe na nb nc nd b">useEffect</code>会被再次调用，因为它把它看作一个新函数。</p><p id="7d73" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果我们可以记住函数引用，这意味着我们可以阻止<code class="fe na nb nc nd b">useEffect</code>重新运行，除非它真的改变了。让我们看看那是什么样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://codesandbox.io/s/testing-usecallback-flow-yhcxy" rel="noopener ugc nofollow" target="_blank">自己试试！</a></p></figure><p id="fb76" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果您只打算使用一次函数，我建议像上面那样移动逻辑，但是当您需要将函数传递给多个<code class="fe na nb nc nd b">useEffects</code>时，这种模式很方便。</p><p id="41d5" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">当将功能传递给子组件时，您会发现<code class="fe na nb nc nd b">useCallback</code>更加方便。如果我们不使用这种模式，子组件将重新呈现每次更新，即使它已被记忆。这是因为该函数永远不会具有与先前渲染相同的引用相等性。</p><p id="ef6c" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">更重要的是，如果这个子组件有任何依赖于这个函数的钩子，它们每次都会被调用。因此，用<code class="fe na nb nc nd b">useCallback</code>构建传递给子组件的函数总是一个好的选择。</p><p id="ab97" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><strong class="ma iu">注意:</strong>这并不意味着你应该用<code class="fe na nb nc nd b">useCallback</code>构建每一个函数。只有当它被传递给子组件时才是至关重要的。记忆本地函数调用通常会给代码增加不必要的开销和复杂性。</p><p id="ba66" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">因此，我们知道如果我们在一个依赖数组中使用我们的函数，我们应该通过将它包装在一个<code class="fe na nb nc nd b">useEffect</code>中来记忆它们。如果我们不这样做，每次组件更新后效果都会重新运行。</p><p id="f0bd" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">那么，为什么在最初的<code class="fe na nb nc nd b">useEffect</code>例子中，我现在用<code class="fe na nb nc nd b">setData</code>函数做了呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="aaf0" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">那是因为在<code class="fe na nb nc nd b">useState</code>钩子中返回的函数已经被你记住了。<code class="fe na nb nc nd b">useReducer</code>也是如此。这为开发人员在创建钩子的过程中建立了一个基本的设计原则。</p><p id="56ae" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果你从钩子返回一个函数，很可能你希望这个函数被记忆，这样开发者就可以使用它们，而不需要额外的处理开销。</p><h2 id="8530" class="ns lh it bd li nt nu dn lm nv nw dp lq mh nx ny ls ml nz oa lu mp ob oc lw od bi translated">浏览一个例子</h2><p id="561c" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我帮助一个朋友浏览了一个代码示例，以更好地理解记忆化函数和非记忆化函数的工作原理，方法是先看一个代码示例，然后画一个图表。</p><p id="5f61" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我认为没有我同时口头讨论它，它会显得有点乱，所以我想清理它，也许动画它，但在那之前，我会把它贴在这里，以防它对某人有帮助。</p><p id="4d3d" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">代码示例可以在<a class="ae ky" href="https://codesandbox.io/s/useeffectwithandwithoutcallback-t3gff" rel="noopener ugc nofollow" target="_blank"> CodeSandbox </a>中找到。下面的代码是我们将要经历的；<code class="fe na nb nc nd b">memoized</code>函数使用我们上面描述的<code class="fe na nb nc nd b">useCallback</code>方法，而<code class="fe na nb nc nd b">notMemoized</code>函数将在每次更新时重新初始化。</p><p id="8b27" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">然后，这两个函数被同一个组件(不同的实例)使用，这个示例有两个呈现，以说明在更新期间发生了什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/564d36518475fb63aa0bbd7646a45766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*okqDs5eSo6LskgX7v2rgXg.gif"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/33b9dbbce1dc86ed6b34a9f5b7808ffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vbgwKmhsWaVERnilqvAAg.jpeg"/></div></div></figure><h2 id="e214" class="ns lh it bd li nt nu dn lm nv nw dp lq mh nx ny ls ml nz oa lu mp ob oc lw od bi translated">方法三。请导入该函数</h2><p id="e0d7" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们可以为我们的<code class="fe na nb nc nd b">fetchData</code>函数使用的最后一种样式实际上是将它移到组件本身之外。</p><p id="b7c5" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这是一种不像前两种那样经常被谈论的风格，但是，根据它的作用，它可能是我最喜欢的风格。这种风格确实需要你在模块中使用ESM <code class="fe na nb nc nd b">import</code>风格，而不是CJS风格。</p><p id="8475" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><strong class="ma iu">注意:</strong>不要说太多细节，这是因为导入语句会给我们一个不能变异的函数实例，而带有CJS的导出模块可以变异。</p><p id="854a" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这也是ESM可以静态分析的原因。如果你真的想了解更多，在be <a class="ae ky" href="https://medium.com/better-programming/reducing-js-bundle-size-58dc39c10f9c" rel="noopener">减少JS包大小</a>系列中，模块被频繁提及。</p><p id="37bd" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在上面的例子中，可能是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="f066" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">因为模块不能变异，我们不必在依赖数组中指定函数，因为它不可能改变。现在，您仍然可以将函数放在依赖数组中，但即使是ESLint也不会强迫您这样做。</p><p id="3cb3" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">那么，为什么这样更好呢？只是为了避免把函数放在依赖数组里？</p><p id="9bb0" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我经常将我的函数拆分成这样的utils函数的最大原因是为了增加它的可测试性。有时我会在我的<code class="fe na nb nc nd b">useEffect</code>中有一些复杂的逻辑，我想单独测试。</p><p id="6c55" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">现在，有很多方法可以测试钩子，但是做起来更有挑战性。我还发现将这些代码块分割成命名的函数增加了我的代码的可读性，所以这样做通常更有帮助，并且将它移动到一个新的模块给我带来了更好的免费测试。</p><p id="6ac8" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">最后，当我们这样做的时候，当我们对那个组件进行集成测试的时候，它也使得模拟那个效应的副作用变得更加容易。</p><p id="5b78" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在这个例子中，我们已经分离了实际的异步“获取”副作用。我们可以模仿<code class="fe na nb nc nd b">fetchData</code>方法，取而代之的是，调用<code class="fe na nb nc nd b">setData</code>参数来填充我们想要测试的数据。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7384" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">可以在依赖数组中使用连接调度函数吗？</h1><p id="f968" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">那么现在，所有这些背景信息都清楚了，我们终于可以回答手头的原始问题了吗？如果我们用一个<code class="fe na nb nc nd b">mapDispatchToProps</code>和我们的<code class="fe na nb nc nd b">useEffect</code>，它还能工作吗？它会重新渲染还是我们必须把每个道具都包在一个<code class="fe na nb nc nd b">useCallback</code>里？</p><p id="d4f9" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">不，你不需要对<code class="fe na nb nc nd b">mapDispatchToProps</code>做任何事情，它会像我们期望的那样开箱即用，就像<code class="fe na nb nc nd b">useDispatch</code>一样。甚至过去的版本。但这是为什么呢？</p><p id="99f8" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">React Redux已经在旧代码和最近发布的新<code class="fe na nb nc nd b">useDispatch</code>钩子中记忆了它们的功能。他们遵循了我们上面谈到的设计原则，并确保您在取回它们时不必记忆。</p><p id="1b17" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">但是对于前面的<code class="fe na nb nc nd b">mapDispatchToProps</code>代码来说，这样做也有显著的性能优势。如果React Redux库不处理这一点，用户就必须在每次组件更新时处理这种引用相等的差异。</p><p id="a5e8" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">但是，为什么有些用户在使用旧的<code class="fe na nb nc nd b">mapDispatchToProps</code>示例时会遇到问题呢？</p><p id="6d1a" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">嗯，这个问题花了我一点时间来找出确切的原因，但它归结为<code class="fe na nb nc nd b">ownProps</code>。<code class="fe na nb nc nd b">ownProps</code>是可选地传递给<code class="fe na nb nc nd b">mapDispatchToProps</code>函数调用的第二个参数，是来自父组件的道具。</p><p id="f45c" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">关于这个问题的更多细节，请点击查看<a class="ae ky" href="https://spin.atomicobject.com/2018/04/02/redux-rerendering/" rel="noopener ugc nofollow" target="_blank">更多信息。</a></p><p id="16d8" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">所以，在这个例子中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://codesandbox.io/s/connect-with-mutliple-rerenders-9r00m" rel="noopener ugc nofollow" target="_blank">自己试试吧！</a></p></figure><p id="e863" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果我们查看作为<code class="fe na nb nc nd b">mapDispatchToProps</code>一部分的<code class="fe na nb nc nd b">ownProps</code>参数，我们会看到一个看起来像这样的对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="bf51" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">现在，我们上面的例子完全是虚构的，因为实际上什么也没有发生。</p><p id="9641" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">尽管如此，只要我们有一个属性被传入到<code class="fe na nb nc nd b">Container</code>组件中，并且我们在<code class="fe na nb nc nd b">mapDispatchToProps</code>中有一个<code class="fe na nb nc nd b">ownProps</code>参数，这个函数在每次更新时都会失去它的引用相等性。</p><p id="0faa" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这是有意义的，因为这个对象在每次渲染时都是一个新的对象。我们必须添加额外的逻辑来处理等式检查，以确定对象中的数据是否相同。</p><p id="3de4" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">对我来说，从一个<code class="fe na nb nc nd b">useCallback</code>的角度考虑这个问题更容易。如果<code class="fe na nb nc nd b">useCallback</code>是我们组件的一部分，我们实际上会触发类似的问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="77da" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">传递整个prop对象不是您通常构造一个<code class="fe na nb nc nd b">useCallback</code>的方式，而不是您正在寻找的单个值。但是它有一个类似的问题，您跟踪的是在更新时构造的整个对象，而不是所需的值。</p><p id="8217" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">与通过比较内存引用或像对象、数组或函数那样的深度比较相比，确保字符串和整数等值的相等总是更容易。</p><p id="5691" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">所以，我认为在<code class="fe na nb nc nd b">useCallback</code>中解决这个问题更难，因为这是一种更不自然的构建代码的方式，这也是当你对钩子越来越熟悉的时候，它变得如此伟大的原因。通常，这种代码风格会引导您采用一种不太容易出错的格式。</p><p id="fd7b" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">在上述情况下，我仍然建议您尽可能使用<code class="fe na nb nc nd b">useDispatch</code>来避免这类问题，但是如果您不能这样做，请记住，通过使用<code class="fe na nb nc nd b">ownProps</code>，您可能会使您的代码性能更差，更容易出错。</p><p id="ea0b" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果您想继续使用<code class="fe na nb nc nd b">mapDispatchToProps</code>，更好的方法是通过函数传递所需的值，然后通过<code class="fe na nb nc nd b">ownProps</code>进行捕获。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="289f" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="c915" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我希望您发现今天的演练很有价值，并且对什么是<code class="fe na nb nc nd b">useEffect</code>有更好的理解，最重要的是，依赖数组是如何工作的。这些知识跨多个钩子工作，并且是构建功能组件的心智模型的基础。</p><p id="a23e" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我希望您带走的最重要的部分是对这些值和引用需要在功能组件中如何处理的更好的理解。</p><p id="0fae" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">目标是让你的组件总是可渲染的，并且尽可能的具有引用完整性。</p><p id="b7b5" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我在接触钩子和函数组件的人身上看到的最常见的问题之一是对依赖关系和函数引用的误解，这导致了大量的重渲染或不良副作用。</p><p id="2bae" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我知道很多人对钩子整体上有点担心，特别是转向新的React Redux钩子，但是我个人发现它们使我的代码更可读，并且一旦你更熟悉了，就不容易出错。</p><p id="aa5d" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我强烈推荐React团队发布的ESLint插件，因为当你更习惯这种风格时，它们会帮助你做出正确的选择。</p><p id="4168" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我正试图在我的文章中引入更多的可视化图表，并希望它们越来越生动。我绝不是一个插画师，但以我个人的经验，我经常发现视觉队列比大的文章更容易记忆。</p><p id="4b2b" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我也想过用视频解释/编码来补充这些文章以获得更好的指导，所以让我知道你是否对此感兴趣！</p><p id="baf4" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果您有任何其他想法来帮助使这些信息更丰富或您想听到的主题，请留下评论。</p><p id="cf15" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">干杯！</p></div></div>    
</body>
</html>