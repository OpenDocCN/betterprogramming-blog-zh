<html>
<head>
<title>My Cheatsheet for the “yq” Tool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的“yq”工具的备忘单</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/my-yq-cheatsheet-34f2b672ee58?source=collection_archive---------0-----------------------#2022-08-03">https://betterprogramming.pub/my-yq-cheatsheet-34f2b672ee58?source=collection_archive---------0-----------------------#2022-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ba88" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用yq解析Kubernetes YAML</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/af51b4204c471ef1bf5aa9909af56cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L-0XyS2_dkJhX43lG2oNzw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按作者</p></figure><p id="3473" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">yq 是一个以YAML数据处理和高亮显示为主的工具。其目前的4.x版本在3.x的基础上进行了巨大的升级，使我们能够更高效地查询和操作YAML。</p><p id="ad93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然关于<code class="fe lv lw lx ly b">jq</code>能起到类似于<code class="fe lv lw lx ly b">yq</code>的作用的争论从未停止过，但我仍然相信<code class="fe lv lw lx ly b">yq</code>在处理Kubernetes资源方面是仅次于kubectl的最强有力的工具，尤其是在操作YAML文件方面，是不可替代的。</p><p id="e283" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么我抱着这样的信念？从下面关于<code class="fe lv lw lx ly b">yq</code>处理的查询、更新和删除的演示和最佳实践中，你会得到答案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h1 id="8b2c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">基本信息</h1><p id="3006" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">本文中我们所指的<code class="fe lv lw lx ly b">yq</code>工具是<a class="ae lu" href="https://github.com/mikefarah/yq" rel="noopener ugc nofollow" target="_blank"> mikefarah/yq </a>，而不是<a class="ae lu" href="https://github.com/kislyuk/yq" rel="noopener ugc nofollow" target="_blank"> kislyuk/yq </a>。mikefarah/yq 拥有强大的操作符并提供更广泛的支持，而kislyuk/yq 只能支持YAML读取。</p><p id="4657" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">yq</code>在最新的4.x版本中做了巨大的改变，抛弃了那些类似<code class="fe lv lw lx ly b">r, d</code>的子命令，取而代之的是用<code class="fe lv lw lx ly b">yq eval</code>触发所有操作。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="42d5" class="nc mc it ly b gy nd ne l nf ng">yq eval [expression] [yaml_file1]… [flags]</span></pre><p id="3c2b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">query</code>、<code class="fe lv lw lx ly b">update</code>、<code class="fe lv lw lx ly b">delete</code>等操作在<code class="fe lv lw lx ly b">expression</code>和可以使用的运算符上有所不同。并且由于<code class="fe lv lw lx ly b">eval</code>是默认命令，所以<code class="fe lv lw lx ly b">yq e '.metadata.name' a.yaml</code>和<code class="fe lv lw lx ly b">yq '.metadata.name' a.yaml</code>如果没有声明是一样的。</p><p id="d176" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">yq</code>以类似于树解析的方式解析YAML文件，将YAML文件分成不同的节点类型，这些节点类型相互嵌套。</p><p id="4e78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这三种节点类型是</p><ul class=""><li id="30da" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated"><strong class="la iu">标量</strong>，常用节点，如<code class="fe lv lw lx ly b">.metadata.name</code>，其值可以是<code class="fe lv lw lx ly b">string</code>、<code class="fe lv lw lx ly b">int</code>、<code class="fe lv lw lx ly b">boolean</code>等。</li><li id="5152" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><strong class="la iu">数组</strong>，数组节点，比如<code class="fe lv lw lx ly b">.spec.containers</code>和<code class="fe lv lw lx ly b">.spec.volumes</code>都是数组。以<code class="fe lv lw lx ly b">-</code>开头的每一项的值通常是KV结构的YAML，或者是一个单独的字符串，比如容器中的ENV设置。</li><li id="56dc" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><strong class="la iu">映射</strong>、<code class="fe lv lw lx ly b">.metadata.labels</code>、<code class="fe lv lw lx ly b">.metadata.annotations</code>都是典型的映射结构。</li></ul><h1 id="3ae6" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak">查询</strong></h1><p id="d3fe" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">查询主要是遍历YAML，或者换句话说，用<code class="fe lv lw lx ly b">.(dot)</code>操作符搜索YAML文件中的键和值。</p><h2 id="38c3" class="nc mc it bd md nv nw dn mh nx ny dp ml lh nz oa mn ll ob oc mp lp od oe mr of bi translated">按字段查询</h2><p id="8f6d" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">通过<code class="fe lv lw lx ly b">.key1.key2.xxx</code>的表达式，我们可以得到YAML支持的所有数据格式，比如常见的<code class="fe lv lw lx ly b">string</code>、<code class="fe lv lw lx ly b">array</code>、<code class="fe lv lw lx ly b">map</code>、<code class="fe lv lw lx ly b">object</code>等。下面列出了一些合理的<code class="fe lv lw lx ly b">yq</code>命令。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="9e98" class="nc mc it ly b gy nd ne l nf ng">$ yq e '.metadata.name' pod.yaml<br/>test-pod<br/>$ yq e '.metadata.labels' pod.yaml <em class="og"># return labels map<br/></em>l1: v1<br/>app.name: test-pod<br/>$ yq e '.metadata pod.yaml <em class="og"># return whole metadata field​<br/></em>name: test-pod<br/>labels:<br/>l1: v1<br/>app.name: test-pod<br/>annotations:<br/>com.team.owner: abc</span></pre><p id="e65c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，我们用双引号标记密钥，以忽略特殊字符引起的问题，如<code class="fe lv lw lx ly b">app.name</code>。</p><h2 id="deff" class="nc mc it bd md nv nw dn mh nx ny dp ml lh nz oa mn ll ob oc mp lp od oe mr of bi translated"><strong class="ak">数组/映射扩展查询</strong></h2><p id="32d9" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">与只有一个值的字符串不同，在YAML中，数组可以有多个表达式。在YAML，用一个简单的键就可以得到完全相同的结果，通过一些特殊的处理，可以得到更多精度更高的结果。</p><ul class=""><li id="f764" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated">钥匙后面有一个<code class="fe lv lw lx ly b">[]</code>，可以取下返回地图的钥匙或<code class="fe lv lw lx ly b">—</code>。</li></ul><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="4a31" class="nc mc it ly b gy nd ne l nf ng">$ yq e '.metadata.labels[]' pod.yaml<br/>v1<br/>test-pod<br/>$ yq e '.spec.containers[]' pod.yaml<br/>name: c1<br/>image: nginx<br/>volumeMounts:<br/>  - name: html<br/>mountPath: /usr/share/nginx/html<br/>name: c2<br/>image: debian</span></pre><ul class=""><li id="888d" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated">使用collect ( <code class="fe lv lw lx ly b">[key/index]</code>)，可以从映射或数组中获取一个或多个键或索引值，如果索引或键不存在，则返回null。</li></ul><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="357e" class="nc mc it ly b gy nd ne l nf ng">$ yq e '.metadata.labels["l1"]' pod.yaml<br/>v1<br/><em class="og"># Get multiple keys<br/></em>$ yq e '.metadata.labels["l1", "app", "app.name"]' pod.yaml<br/>v1<br/>null<br/>test-pod<br/><br/>$ yq e '.spec.containers[1]' pod.yaml<br/>name: c2<br/>image: debian<br/>volumeMounts:<br/>- name: html<br/>mountPath: /html<br/>command: ["/bin/sh", "-c"]<br/>args:<br/>- while true; do date &gt;&gt; /html/index.html; sleep 1; done</span></pre><p id="80d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们需要搜索一个以上的键或索引时，可以选择<code class="fe lv lw lx ly b">pick</code>操作符来获取map/array中键和索引的相应值。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="62be" class="nc mc it ly b gy nd ne l nf ng">$ yq e '.metadata.labels | pick(["com.team.owner", "l1", "app.name"])' pod.yaml<br/>l1: v1<br/>app.name: test-pod</span></pre><p id="1253" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">with_entries</code>操作符可以处理地图，让我们得到地图的键/值，然后进行后续处理。与<code class="fe lv lw lx ly b">select</code>操作符配合使用，可以实现非常强大的过滤查询。</p><h2 id="9339" class="nc mc it bd md nv nw dn mh nx ny dp ml lh nz oa mn ll ob oc mp lp od oe mr of bi translated">条件查询</h2><p id="9376" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated"><code class="fe lv lw lx ly b">yq</code>支持两种常用的查询运算符<code class="fe lv lw lx ly b">select</code>和<code class="fe lv lw lx ly b">contains</code>，通常与<code class="fe lv lw lx ly b">.key</code>查询结合使用。</p><ul class=""><li id="bc80" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated"><code class="fe lv lw lx ly b">has(key)</code>，如果该键存在，则返回true。</li><li id="2eb3" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe lv lw lx ly b">contains(obj)</code>，返回真/假。<code class="fe lv lw lx ly b">obj</code>可以是简单的字符串(查询任何匹配的键和值)、KV组合、数组、对象等。</li><li id="ef60" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe lv lw lx ly b">select(.=="some pattern here")</code>。<code class="fe lv lw lx ly b">.</code>指当前字段，如果存在，则返回；否则，返回<code class="fe lv lw lx ly b">null</code>。<code class="fe lv lw lx ly b">select</code>可以和比较运算符(<code class="fe lv lw lx ly b">&gt;</code>、<code class="fe lv lw lx ly b">&lt;</code>、<code class="fe lv lw lx ly b">==</code>等)，或者布尔运算符(and、or、not等)一起使用。)，也支持通配符(<code class="fe lv lw lx ly b">*</code>)。</li></ul><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="f95b" class="nc mc it ly b gy nd ne l nf ng">$ yq '.metadata.labels | has("l1")' pod.yaml<br/>true<br/>$ yq '.metadata.labels | contains({"l1":"v1"})' pod.yaml<br/>true<br/><em class="og"># combine select and has<br/></em>$ yq '.metadata.labels | select(. | has("l1")) ' pod.yaml<br/>l1: v1<br/>app.name: test-pod<br/>$ yq '.metadata.name | select(. == "test")' pod.yaml <em class="og"># no match<br/># wildcard match<br/></em>yq '.spec.containers[] | select(.name == "*1" )' pod.yaml<br/>name: c1<br/>image: nginx<br/>volumeMounts:<br/>- name: html<br/>mountPath: /usr/share/nginx/html<br/><em class="og"># select, with_entries and not，search for labels don't match<br/></em>yq '.metadata.labels | with_entries(select(.key == "l1" |not))' pod.yaml<br/>app.name: test-pod</span></pre><p id="cb3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于更复杂的场景，比如匹配正则方程，<code class="fe lv lw lx ly b">select</code>总是和字符串操作符结合在一起，比如<code class="fe lv lw lx ly b">test</code>、<code class="fe lv lw lx ly b">match</code>、<code class="fe lv lw lx ly b">capture</code>等。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="34a0" class="nc mc it ly b gy nd ne l nf ng"># test regular<br/>yq '.spec.containers[] | select(.image | test("nginx|debian"))' pod.yaml # return all containers</span><span id="2614" class="nc mc it ly b gy oh ne l nf ng"># capture<br/>yq '.spec.containers[] | select(.command | .[] | capture("/bin/sh"))' pod.yaml</span></pre><h2 id="7230" class="nc mc it bd md nv nw dn mh nx ny dp ml lh nz oa mn ll ob oc mp lp od oe mr of bi translated"><strong class="ak">导线和变量</strong></h2><p id="360b" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">当表达式变得复杂时，我们使用<code class="fe lv lw lx ly b">pipe(|)</code>来逐层解析<code class="fe lv lw lx ly b">yq</code>表达式。但是有两个问题需要回答。</p><ul class=""><li id="2f56" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated">如何读取前一层的信息？</li><li id="a610" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">如何比较不同图层之间的内容？例如验证<code class="fe lv lw lx ly b">volumeMounts</code>与<code class="fe lv lw lx ly b">spec.volumes</code>在容器中是否一致。</li></ul><p id="2438" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">yq</code>提供的运算符就是答案。</p><ul class=""><li id="b44e" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated"><code class="fe lv lw lx ly b">parent</code>，可以返回上一层的节点内容。</li><li id="91eb" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe lv lw lx ly b">variable</code>，定义后续管道中使用的变量。</li></ul><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="519e" class="nc mc it ly b gy nd ne l nf ng">yq '.spec.volumes[] | .name |  parent' pod.yaml<br/>name: html<br/>emptyDir: {}<br/><br/><em class="og"># find all volumeMounts match the volumes<br/></em>yq '.spec | .volumes[].name as $volumeName | .containers[] | select(.volumeMounts[] | .name == $volumeName)' pod.yaml</span></pre><h2 id="f129" class="nc mc it bd md nv nw dn mh nx ny dp ml lh nz oa mn ll ob oc mp lp od oe mr of bi translated">复杂流操作符</h2><p id="e7de" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated"><code class="fe lv lw lx ly b">yq</code>表达式还支持一组运算符(<code class="fe lv lw lx ly b">map</code>、<code class="fe lv lw lx ly b">flattern</code>、<code class="fe lv lw lx ly b">groupby</code>、<code class="fe lv lw lx ly b">union</code>、<code class="fe lv lw lx ly b">reduce</code>等)。)进行管内处理，类似于函数式编程。<code class="fe lv lw lx ly b">map</code>、<code class="fe lv lw lx ly b">flattern</code>、<code class="fe lv lw lx ly b">groupby</code>都是针对数组节点处理的，其中<code class="fe lv lw lx ly b">flattern</code>和<code class="fe lv lw lx ly b">groupby</code>很少使用，很难想象会在Kubernetes相关的YAML中使用。因此，我建议了解他们扮演什么角色，只在需要的时候检查他们的文档。</p><p id="5f9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而，<code class="fe lv lw lx ly b">map</code>是你应该掌握的运算符。它与<code class="fe lv lw lx ly b">string</code>操作符或<code class="fe lv lw lx ly b">math</code>操作符结合起来处理数组中的项，或者添加组合字符串。例如，将容器中的名称修改为大写。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="035c" class="nc mc it ly b gy nd ne l nf ng">yq e '.spec.containers | map(.name | upcase) ' pod.yaml</span></pre><p id="46d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了像<code class="fe lv lw lx ly b">map</code>或者<code class="fe lv lw lx ly b">groupby</code>这样的操作符，还有另外一组流操作符，我喜欢称之为“<strong class="la iu"> end-function操作符”</strong>，它们总是结束表达式管道。</p><p id="96b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个“端函数运算符”的表格</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h1 id="d5f1" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">更新</h1><p id="a584" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">查询、搜索和过滤现有文件可以满足我们的大部分需求。但是，如果我们需要更新或创建一个YAML呢？放松点，因为<code class="fe lv lw lx ly b">yq</code>已经准备好了。</p><p id="991b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，让我们看一组相关的标志。</p><ul class=""><li id="6b4d" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated"><code class="fe lv lw lx ly b">-i/–inplace</code>。默认情况下，结果被发送到标准输出，可以使用<code class="fe lv lw lx ly b">-i</code>对当前文件进行修改。而我们需要文件重定向操作符(<code class="fe lv lw lx ly b">&gt;</code>)来输出到一个新文件。</li><li id="70e3" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe lv lw lx ly b">-o/–output-format</code>。该输出格式默认为YAML，但也支持<code class="fe lv lw lx ly b">json/j</code>、<code class="fe lv lw lx ly b">xml/x</code>和<code class="fe lv lw lx ly b">props/p</code>。</li><li id="6058" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe lv lw lx ly b">-I/–indent</code>，YAML的缩进。默认值为2，这也是YAML规范的标准。</li><li id="00d6" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe lv lw lx ly b">–from-file</code>，从文件中读取表达式。</li></ul><h2 id="00b8" class="nc mc it bd md nv nw dn mh nx ny dp ml lh nz oa mn ll ob oc mp lp od oe mr of bi translated"><strong class="ak">更新/添加密钥</strong></h2><p id="b693" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated"><code class="fe lv lw lx ly b">yq</code>支持通常模式的YAML更新<code class="fe lv lw lx ly b">yq e -i '.key1 | .key2 … = new_value' file</code>。<strong class="la iu">如果要更新的字段不存在，则</strong> <code class="fe lv lw lx ly b"><strong class="la iu">update</strong></code> <strong class="la iu">操作变为</strong> <code class="fe lv lw lx ly b"><strong class="la iu">add</strong></code> <strong class="la iu">。</strong>除了最常见的<code class="fe lv lw lx ly b">=</code>运算符，<code class="fe lv lw lx ly b">yq</code>还支持其他运算符，包括<code class="fe lv lw lx ly b">|= </code>。</p><p id="2968" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它们在大多数情况下具有相同的效果，除了<code class="fe lv lw lx ly b">|=</code>可以基于旧值进行更新。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="0515" class="nc mc it ly b gy nd ne l nf ng"># add suffix to pod’s name using |= operator<br/>yq '.metadata.name |= . + "abc" | .metadata.name' pod.yaml<br/>test-podabc</span></pre><p id="e4dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，我们会在末尾添加新字段。但是在<code class="fe lv lw lx ly b">index:0</code>处添加也是可行的，比如在<code class="fe lv lw lx ly b">.spec</code>处添加<code class="fe lv lw lx ly b">nodeName</code>字段。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="189a" class="nc mc it ly b gy nd ne l nf ng">yq  '.spec = {"nodeName":"master"} + .spec ' pod.yaml</span></pre><p id="09ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于向数组和地图添加新内容，我们可以使用<code class="fe lv lw lx ly b">+</code>或<code class="fe lv lw lx ly b">+=</code>操作符，比如在<code class="fe lv lw lx ly b">.matadata.labels</code>中的起始位置添加一个新标签。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="9643" class="nc mc it ly b gy nd ne l nf ng">yq '.metadata.labels |= {"pos-1":"val-1"} + . ' pod.yaml<br/>pos-1: val-1<br/>l1: v1<br/>app.name: test-pod</span></pre><p id="3e15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同时，可以使用一组字符串运算符(<code class="fe lv lw lx ly b">sub/replace</code>、<code class="fe lv lw lx ly b">split</code>、<code class="fe lv lw lx ly b">join</code>、<code class="fe lv lw lx ly b">upcase</code>、<code class="fe lv lw lx ly b">downcase</code>等)进行更新。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h2 id="23ff" class="nc mc it bd md nv nw dn mh nx ny dp ml lh nz oa mn ll ob oc mp lp od oe mr of bi translated">从ENV读取变量更新</h2><p id="0a12" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">这是一个非常常见的操作，因为我们使用各种bash/kubectl命令来获取用于更新<code class="fe lv lw lx ly b">yq</code>中的字段的有用信息。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="c96a" class="nc mc it ly b gy nd ne l nf ng">USER="slaise"; yq '.metadata.name |= strenv(USER) + "-" + . | .metadata.name' pod.yaml</span><span id="d39b" class="nc mc it ly b gy oh ne l nf ng">slaise-test-pod</span></pre><h2 id="3816" class="nc mc it bd md nv nw dn mh nx ny dp ml lh nz oa mn ll ob oc mp lp od oe mr of bi translated"><strong class="ak">评论更新</strong></h2><p id="bf39" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">comment运算符允许您通过以下三种方式更新注释。</p><ul class=""><li id="fc68" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated"><code class="fe lv lw lx ly b">line_comment</code>更新某些行中的注释。</li><li id="5470" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe lv lw lx ly b">head_comment</code>在YAML文件的开头添加一个注释，后跟一个空行。</li><li id="4143" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe lv lw lx ly b">foot_comment</code>在YAML文件的末尾添加注释，上面有一个空行。</li></ul><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="7567" class="nc mc it ly b gy nd ne l nf ng">yq '.metadata.annotations["com.team.owner"] line_comment="owner squad"' pod.yaml<br/>yq '. head_comment="Pod example start"'  pod.yaml<br/>yq '. foot_comment="Pod example end"' pod.yaml</span></pre><h2 id="9b14" class="nc mc it bd md nv nw dn mh nx ny dp ml lh nz oa mn ll ob oc mp lp od oe mr of bi translated"><strong class="ak">合并</strong></h2><p id="5cf9" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">Merge在<code class="fe lv lw lx ly b">yq</code>中有双重含义:简单的是数学中的数字乘法，用来更新数值。复杂的是对象的合并——不同YAML节点的合并操作。后者在集群管理中非常有用，比如用户忘记设置pod中的<code class="fe lv lw lx ly b">volumeMounts</code>字段，我们可以通过读取<code class="fe lv lw lx ly b">volumes</code>值自动给容器加一，这样可以避免YAML检查后返回错误给用户，加快迭代速度。请参见下面的命令。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="5362" class="nc mc it ly b gy nd ne l nf ng">yq e '.spec.volumes as $volumes | .spec.containers[] | select(.name == "c2") | . * {"volumeMounts": {"name":$volumes[0].name}}' pod.yaml</span></pre><p id="d89a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这同样适用于在CI/CD中添加公共配置，例如与安全相关的<code class="fe lv lw lx ly b">securityContext</code>，或者与资源使用相关的请求和限制。</p><h2 id="a0ca" class="nc mc it bd md nv nw dn mh nx ny dp ml lh nz oa mn ll ob oc mp lp od oe mr of bi translated"><strong class="ak">一次更新多个密钥</strong></h2><p id="de5c" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">也可以使用<code class="fe lv lw lx ly b">yq</code>和<code class="fe lv lw lx ly b">with</code>操作器一次更新密钥。让我们看一个向pod添加<code class="fe lv lw lx ly b">serviceAccount</code>和<code class="fe lv lw lx ly b">restartPolicy</code>的例子。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="0d61" class="nc mc it ly b gy nd ne l nf ng">yq 'with(.spec; .serviceAccount="test-sa" | .restartPolicy=false)' pod.yaml</span></pre><p id="6ee0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并且<code class="fe lv lw lx ly b">with</code>还可以一次更新所有数组项，例如，将<code class="fe lv lw lx ly b">imagePullPolicy</code>添加到pod中的两个容器中。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="7730" class="nc mc it ly b gy nd ne l nf ng">yq 'with(.spec.containers[]; .imagePullPolicy="Never")' pod.yaml</span></pre><h1 id="3db0" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">删除</h1><p id="422a" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">虽然删除可以单独使用，但它通常与查询和条件查询结合使用。支持删除的操作符有<code class="fe lv lw lx ly b">substract</code>和<code class="fe lv lw lx ly b">del</code>。</p><ul class=""><li id="b2ed" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated"><code class="fe lv lw lx ly b">del</code>是最常用的<code class="fe lv lw lx ly b">delete</code>运算符，用于删除匹配的键。</li><li id="4a42" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe lv lw lx ly b">substract</code>是一个数学减法运算符，但也可用于从数组中删除项目。</li></ul><h2 id="6972" class="nc mc it bd md nv nw dn mh nx ny dp ml lh nz oa mn ll ob oc mp lp od oe mr of bi translated">删除字段</h2><p id="390c" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">如果知道字段路径，可以直接删除，比如删除<code class="fe lv lw lx ly b">.spec</code>中的<code class="fe lv lw lx ly b">nodeName</code>。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="613b" class="nc mc it ly b gy nd ne l nf ng">yq -i 'del(.spec.nodeName)' pod.yaml</span></pre><p id="fcc0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，我们可以在<code class="fe lv lw lx ly b">select/match/has</code>之后执行<code class="fe lv lw lx ly b">delete</code>。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="d73f" class="nc mc it ly b gy nd ne l nf ng"># only deletes the labels when select matches<br/>yq 'del(select(.metadata.name == "test-pod") | .metadata.labels)' pod.yaml</span></pre><h2 id="dfff" class="nc mc it bd md nv nw dn mh nx ny dp ml lh nz oa mn ll ob oc mp lp od oe mr of bi translated"><strong class="ak">删除数组项</strong></h2><p id="be67" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">删除Pod中的nginx容器。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="6311" class="nc mc it ly b gy nd ne l nf ng">yq '.spec.containers - [{"image":"nginx", "name":"c1", "volumeMounts":[{"name":"html","mountPath":"/usr/share/nginx/html"}]}]' pod.yaml</span></pre><p id="90f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，您需要声明整个数组项的内容。太复杂了吧？而<code class="fe lv lw lx ly b">select + del</code>可以让事情变得更简单。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="a6b2" class="nc mc it ly b gy nd ne l nf ng">yq 'del(.spec.containers[] | select(.image == "nginx"))' pod.yaml</span></pre><h1 id="e796" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">输出</h1><p id="e861" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">有一些标志可用于增强输出。</p><ul class=""><li id="eb6f" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated"><code class="fe lv lw lx ly b">-C</code>强制颜色输出。</li><li id="2041" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe lv lw lx ly b">-in</code>将输出缩进设置为n个空格。</li><li id="6a1b" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe lv lw lx ly b">-P</code>用于漂亮的印刷。</li><li id="8a35" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe lv lw lx ly b">-v</code>支持更详细的详细输出，可用于调试。</li></ul><p id="d7f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认输出到stdout并在<code class="fe lv lw lx ly b">pretty print</code>打印。但是<code class="fe lv lw lx ly b">style</code>操作符可以将打印样式转换成其他5种格式，双份、单份、标签、文字和折叠。下面的例子输出一个JSON样式的字符串。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/05ce289d0e894ca0628736c738ce44ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*orIku3vmKQsqg6RKEZCrPQ.png"/></div></div></figure><h1 id="4a13" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak">练习</strong></h1><p id="dc7b" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">点击“保存”按钮，我们现在已经将上述所有知识包裹在脑海中，抓住了<code class="fe lv lw lx ly b">yq</code>命令的精髓，即遍历YAML文件，结合过滤操作符，实现最终的查询、更新、删除。</p><p id="a944" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们通过一个删除相关YAML文件的例子来实践它。</p><p id="6027" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有一个Github存储库，用gitops管理成千上万的YAML文件。您被要求删除一些部署，它们分别属于一些被放弃的团队。所有这些部署都以<code class="fe lv lw lx ly b">teamname + customize_name </code>格式命名。</p><p id="02e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好，我们一步一步往下说。</p><ul class=""><li id="2523" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated">定义一个包含这些团队名称的数组。</li><li id="22fc" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">查询部署的YAML，并查找包含这些名称的部署。</li><li id="7ba8" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">删除和修改原始文件。</li></ul><p id="ee2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后<code class="fe lv lw lx ly b">yq</code>命令如下。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="b036" class="nc mc it ly b gy nd ne l nf ng">yq -i '["team1*", "team2*", "team3*"] as $names | select(.kind == "Deployment" and $names | contains(.metadata.name)) | del(.)' *.yaml</span></pre><p id="3dca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果任务是删除不包含某些名称的部署，那么<code class="fe lv lw lx ly b">not</code>操作符可以完成。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="83c8" class="nc mc it ly b gy nd ne l nf ng">yq -i '["team1*", "team2*", "team3*"] as $names | select(.kind == "Deployment" and $names | contains(.metadata.name) | not) | del(.)' *.yaml</span></pre><h1 id="05d5" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结束了</h1><p id="f13d" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated"><code class="fe lv lw lx ly b">yq</code>命令作为集群治理的有效工具，可以解放我们的双手，将我们从枯燥的复制粘贴中解放出来。它是用Go编写的，这增加了我研究它的实现的兴趣。稍后，我还将尝试添加一些功能来满足自己的需求。</p><p id="091f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p></div></div>    
</body>
</html>