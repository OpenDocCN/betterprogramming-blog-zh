<html>
<head>
<title>Typewriter Effect in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中的打字机效果</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typewriter-effect-in-swiftui-ba81db10b570?source=collection_archive---------2-----------------------#2022-11-13">https://betterprogramming.pub/typewriter-effect-in-swiftui-ba81db10b570?source=collection_archive---------2-----------------------#2022-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2bfb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">给文本添加延迟并产生动画</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c5ec3207c0de9f22b35bd6b54c2c848f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zNndVVt9dWCDYZBB"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·温克勒在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="5bb5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">先决条件</h1><ul class=""><li id="7367" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">安装了Xcode 13+的Mac</li><li id="b07a" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">Swift编程的经验不是必须的，但可以让你的生活更轻松</li></ul><h1 id="ce1c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">创建新项目</h1><p id="9cbf" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">打开Xcode并创建一个新的应用程序项目。如果你是Xcode和应用程序开发的新手，你可以遵循我在其他文章中的详细步骤，比如“<a class="ae kv" href="https://ix76y.medium.com/creating-a-image-card-in-swift-ui-beginner-tutorial-2881b4420ea3" rel="noopener">在SwiftUI </a>中创建图像卡”。本文还包含了一小段关于Xcode接口的内容，以帮助您入门。</p><h1 id="4679" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">创建用户界面</h1><p id="e0a5" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">这个例子的UI将非常简单地向您展示这个概念。我们将有一个文本，在开始时将是空的，直到我们单击它下面的按钮，这将触发类型写入器效果并写入“Hello，World！”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/5bc7f079d6a8b1fc861dd7facc83d568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*61HCuAULUAo2CK9IjJCnWA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带有文本和按钮的用户界面</p></figure><p id="a60b" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nb mq mr lx nc mt mu lz nd mw mx mb ij bi translated">当您创建一个新视图或直接在<code class="fe ne nf ng nh b">ContentView</code>中工作时，您应该已经在视图的主体中有一个文本:</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="f2bb" class="nm kx iq nh b be nn no l np nq">var body: some View {<br/>  Text("Hello, World!")<br/>}</span></pre><p id="d158" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nb mq mr lx nc mt mu lz nd mw mx mb ij bi translated">按下⌘并点击文本，这将打开行动菜单，我们可以选择嵌入垂直堆栈内的文本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/77c019f7fe4551ff910d84bcfa6be4b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*esM9-XOfU-nWDmiZosk4Rw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在VStack中嵌入文本的操作菜单</p></figure><p id="cb0e" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nb mq mr lx nc mt mu lz nd mw mx mb ij bi translated">接下来，打开视图库(单击右上角的小+图标)并拖动<code class="fe ne nf ng nh b">VStack</code>中文本下方的按钮。你的身体现在应该看起来像这样:</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="2622" class="nm kx iq nh b be nn no l np nq">var body: some View {<br/>  VStack {<br/>    Text("Hello, World!")<br/>    Button("Button") {<br/>      Action<br/>    }<br/>  }<br/>}</span></pre><p id="6402" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nb mq mr lx nc mt mu lz nd mw mx mb ij bi translated">让我们将按钮的文本从“Button”改为“Type ”,并在两个元素之间增加一点间距。您可以通过点击<code class="fe ne nf ng nh b">VStack</code>来改变它的间距，然后在属性检查器中改变间距。对于这个，我选择值16。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/f629f6f9f6f6d33c946e502177346a73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*490u6QeBK-pZbJlVTYlk9g.png"/></div></figure><p id="6e2a" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nb mq mr lx nc mt mu lz nd mw mx mb ij bi translated">对于按钮的动作，我们将编写一个处理打字机效果的小函数。现在我们称之为<code class="fe ne nf ng nh b">typeWriter()</code>。这是我们的UI代码最终的样子:</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="4997" class="nm kx iq nh b be nn no l np nq">var body: some View {<br/>  VStack(spacing: 16.0) {<br/>    Text("Hello, World!")<br/>    Button("Type") {<br/>      typeWriter()<br/>    }<br/>  }<br/>}</span></pre><p id="5232" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nb mq mr lx nc mt mu lz nd mw mx mb ij bi translated">Xcode现在会抱怨函数<code class="fe ne nf ng nh b">typeWriter()</code>没有定义。所以让我们写我们的打字机逻辑吧！</p><h1 id="db90" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">打字机</h1><p id="a254" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">首先，我们需要保存代码的函数的主要构造。一旦我们在body view的右括号后面加上这个，Xcode应该已经停止抱怨<code class="fe ne nf ng nh b">typeWriter()</code>没有被定义。</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="6fee" class="nm kx iq nh b be nn no l np nq">func typeWriter() {<br/>    // some code here<br/>}</span></pre><p id="4246" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nb mq mr lx nc mt mu lz nd mw mx mb ij bi translated">在写任何代码之前，我们应该考虑我们想要实现的实际逻辑。一般来说，我们需要一个函数:</p><ol class=""><li id="cb01" class="lo lp iq lq b lr mz lt na lv nt lx nu lz nv mb nw md me mf bi translated">在x位置写一个字母</li><li id="c30e" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb nw md me mf bi translated">等待y时间</li><li id="42af" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb nw md me mf bi translated">从x + 1开始</li></ol><p id="7c8c" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nb mq mr lx nc mt mu lz nd mw mx mb ij bi translated">为此，我们需要两个变量。一个用来保存最终文本，另一个用来写每个字母:</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="465c" class="nm kx iq nh b be nn no l np nq">// This will be empty at the start and we will add each letter to it<br/>@State var text: String = ""<br/>// This is the final text that we want to show<br/>let finalText: String = "Hello, World!"</span></pre><p id="1172" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nb mq mr lx nc mt mu lz nd mw mx mb ij bi translated">我们将<code class="fe ne nf ng nh b">text</code>声明为可变字符串，因为它会改变。另外，我们在开头加一个<code class="fe ne nf ng nh b">@State</code>。这意味着如果文本发生变化，它将自动更新所有连接到该变量的UI元素。<code class="fe ne nf ng nh b">finalText</code>被声明为<code class="fe ne nf ng nh b">let</code>，因为我们不会改变它，它也是一个字符串。</p><p id="ef90" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nb mq mr lx nc mt mu lz nd mw mx mb ij bi translated">要将文本变量绑定到我们的文本视图，我们可以将它传递给视图:</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="dbdc" class="nm kx iq nh b be nn no l np nq">@State var text: String = ""<br/>let finalText: String = "Hello, World!"<br/><br/>var body: some View {<br/>  VStack(spacing: 16.0) {<br/>    Text(text)<br/>    Button("Type") {<br/>      typeWriter()<br/>    }<br/><br/>  }<br/>}</span></pre><p id="af22" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nb mq mr lx nc mt mu lz nd mw mx mb ij bi translated">现在回到我们实际上的<code class="fe ne nf ng nh b">TypeWriter()</code>功能。我们知道我们需要一个循环，从我们的<code class="fe ne nf ng nh b">finalText</code>开始遍历每个字符。一般来说，编写重复函数有两种方式:递归和迭代。</p><h2 id="05a4" class="nx kx iq bd ky ny nz dn lc oa ob dp lg lv oc od li lx oe of lk lz og oh lm oi bi translated">递归与迭代函数</h2><p id="7451" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">迭代函数使用类似while或for循环的循环。另一方面，递归函数调用自己，不使用任何循环。递归函数通常需要较少的代码，但可能更难理解。在这种情况下，我们将以递归方式编写代码，但是两个函数都可以使用。</p><p id="6ca3" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nb mq mr lx nc mt mu lz nd mw mx mb ij bi translated">我们希望在特定的位置打印字符，所以让我们将该位置作为参数传递给我们的函数，并检查该位置是否小于我们的<code class="fe ne nf ng nh b">finalText</code>长度:</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="230c" class="nm kx iq nh b be nn no l np nq">// passing the position as an argument with a default value of 0 for the first value<br/>func typeWriter(at position: Int = 0) {<br/>  if position &lt; finalText.count {<br/>    // write the letter at position "position" to "text"<br/>  }<br/>}</span></pre><p id="129d" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nb mq mr lx nc mt mu lz nd mw mx mb ij bi translated">接下来，我们想获取那个位置的字母，并将其附加到我们的<em class="oj">文本</em>变量中。</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="db06" class="nm kx iq nh b be nn no l np nq">func typeWriter(at position: Int = 0) {<br/>  if position &lt; finalText.count {<br/>    // get the character from finalText and append it to text<br/>    text.append(finalText[position])<br/>    // call this function again with the character at the next position<br/>    typeWriter(at: position + 1)<br/>  }<br/>}</span></pre><h2 id="05b0" class="nx kx iq bd ky ny nz dn lc oa ob dp lg lv oc od li lx oe of lk lz og oh lm oi bi translated">Unicode编码</h2><p id="b452" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">唯一缺少的似乎是时间延迟，但是Xcode可能会抱怨上面的代码片段。问题是<code class="fe ne nf ng nh b">finalText[position]</code>。原因在于Swift的原生字符串类型是由Unicode标量值构建的。简而言之，我们在这里得到的错误是由一个或多个不同的Unicode值产生同一个人类可读的字符这一事实引起的。如果您想了解更多相关信息，请查看Swift官方文档<a class="ae kv" href="https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html#ID293" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="28c2" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nb mq mr lx nc mt mu lz nd mw mx mb ij bi translated">幸运的是，我们可以非常容易地解决这个问题，只需告诉Swift我们希望如何解释带扩展名的字符串订阅，这是我们在特定位置获取字符的捷径:</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="8d4e" class="nm kx iq nh b be nn no l np nq">extension String {<br/>    subscript(offset: Int) -&gt; Character {<br/>        self[index(startIndex, offsetBy: offset)]<br/>    }<br/>}</span></pre><h2 id="4ede" class="nx kx iq bd ky ny nz dn lc oa ob dp lg lv oc od li lx oe of lk lz og oh lm oi bi translated">时间延误</h2><p id="f7c6" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">现在，我们的代码不再抛出任何错误，让我们最后在延迟部分工作，这将产生实际的打字机效果。</p><p id="2db7" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nb mq mr lx nc mt mu lz nd mw mx mb ij bi translated">Swift为我们提供了一种非常简单、简洁的方式，可以在不阻塞UI的情况下延时运行代码。这一点很重要，因为我们不希望在输入文本时用户界面冻结。</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="7f68" class="nm kx iq nh b be nn no l np nq">func typeWriter(at position: Int = 0) {<br/>  if position &lt; finalText.count {<br/>    // Run the code inside the DispatchQueue after 0.2s<br/>    DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {<br/>      text.append(finalText[position])<br/>      typeWriter(at: position + 1)<br/>    }<br/>  }<br/>}</span></pre><p id="b666" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nb mq mr lx nc mt mu lz nd mw mx mb ij bi translated">如果你想让它更快或更慢，只需将0.2更改为更小或更大的值。是时候试试我们的代码了:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/c6163ce11ff096d09662e732882ff4ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/1*lLSs4GsLzVulwJljtElR3g.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">打字者效应。</p></figure><h2 id="00e1" class="nx kx iq bd ky ny nz dn lc oa ob dp lg lv oc od li lx oe of lk lz og oh lm oi bi translated">最后润色</h2><p id="4112" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">代码运行良好，但是您可能会注意到，如果您再次按下按钮，它将再次追加相同的文本，类似于“Hello，World！你好，世界！”。我们可以很容易地进行调整，但是添加一个简单的if语句来检查位置是否为零，在这种情况下，文本将再次设置为空字符串。</p><h1 id="8d40" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">最终代码</h1><p id="b2cf" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">这样，我们最终的代码应该是这样的。</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="36a2" class="nm kx iq nh b be nn no l np nq">struct TypeWriterView: View {<br/>    @State var text: String = ""<br/>    let finalText: String = "Hello, World!"<br/>    <br/>    var body: some View {<br/>        VStack(spacing: 16.0) {<br/>            Text(text)<br/>            Button("Type") {<br/>                typeWriter()<br/>            }<br/>        }<br/>    }<br/>    <br/>    <br/>    func typeWriter(at position: Int = 0) {<br/>        if position == 0 {<br/>            text = ""<br/>        }<br/>        if position &lt; finalText.count {<br/>            DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {<br/>                text.append(finalText[position])<br/>                typeWriter(at: position + 1)<br/>            }<br/>        }<br/>    }<br/>}<br/><br/><br/>struct TypeWriterView_Previews: PreviewProvider {<br/>    static var previews: some View {<br/>        TypeWriterView()<br/>    }<br/>}<br/><br/>extension String {<br/>    subscript(offset: Int) -&gt; Character {<br/>        self[index(startIndex, offsetBy: offset)]<br/>    }<br/>}</span></pre></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><p id="fba6" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nb mq mr lx nc mt mu lz nd mw mx mb ij bi translated">我希望这个教程是有帮助的！如果你有任何问题，让我知道。感谢阅读。</p></div></div>    
</body>
</html>