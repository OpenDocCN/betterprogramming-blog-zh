<html>
<head>
<title>How To Get Open Street Map Data Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Python获取开放的街道地图数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-get-open-street-and-map-data-using-python-2b777bf5af14?source=collection_archive---------2-----------------------#2019-12-07">https://betterprogramming.pub/how-to-get-open-street-and-map-data-using-python-2b777bf5af14?source=collection_archive---------2-----------------------#2019-12-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8de2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当你的应用需要了解我们周围的世界时</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1f235a893bac0e217e0625fe157cc73a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FxpXvED0m4zK1jUSqwsYUw.png"/></div></div></figure><p id="fc8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您是否曾经参与过一个项目，需要一些真实世界的地理位置数据，例如，有多少条高速公路穿过这个特定的城市，或者在这个特定的地方有多少家餐馆？</p><p id="3c38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">OpenStreetMap是一个很棒的开源世界地图，它可以让我们对这些和类似的问题有所了解。这个数据集中隐藏了很多数据，充满了有用的标签和地理信息。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="9493" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">OpenStreetData模型</h1><p id="98c2" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">让我们看看OSM是如何构成的。</p><p id="0ef7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在OSM数据模型中，我们有三个基本组件，分别是<a class="ae lq" href="https://wiki.openstreetmap.org/wiki/Node" rel="noopener ugc nofollow" target="_blank">节点</a>、<a class="ae lq" href="https://wiki.openstreetmap.org/wiki/Way" rel="noopener ugc nofollow" target="_blank">方式</a>和<a class="ae lq" href="https://wiki.openstreetmap.org/wiki/Relation" rel="noopener ugc nofollow" target="_blank">关系</a>，它们都有一个ID。许多元素都带有<a class="ae lq" href="https://wiki.openstreetmap.org/wiki/Tags" rel="noopener ugc nofollow" target="_blank">标签</a>，这些标签描述了表示为键值对的特定特性。</p><p id="f08f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简单来说，<em class="mv">节点</em>是地图上的点(在纬度和经度上)，就像下一张有据可查的德里印度门的图片。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/5b41f9079385dabac1087f4f4496fc4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M1iF3pVr7n2oD9CghSMynQ.png"/></div></div></figure><p id="d5d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一种方式是节点的有序列表，它可以对应于一条街道或一所房子的轮廓。这里有一个印度NH 24的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/fe5e6e4d8a95a477a2f3cde730736607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dl3BClgeAZfiHAUYJVeFIg.png"/></div></div></figure><p id="d539" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后一个数据元素是一个<em class="mv">关系</em>，它也是一个有序列表，包含节点、路径甚至其他关系。</p><p id="eaa1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它用于建模对象之间的逻辑或地理关系。例如，这可以用于大型结构，如印度议会，它包含多个多边形来描述建筑。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/7d23c2957b339bb0e73f9a4cdaae0ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UDDVSXRyQQaTe8kbYPurWw.png"/></div></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="c27f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">使用天桥API</h1><p id="739b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">现在我们来看看如何从OSM加载数据。<a class="ae lq" href="https://wiki.openstreetmap.org/wiki/Overpass_API" rel="noopener ugc nofollow" target="_blank">天桥API </a>使用定制的<a class="ae lq" href="https://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL" rel="noopener ugc nofollow" target="_blank">查询语言</a>来定义查询。</p><p id="d7dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这需要一些时间来适应，但幸运的是有<a class="ae lq" href="https://github.com/tyrasd" rel="noopener ugc nofollow" target="_blank">马丁·雷弗</a>的<a class="ae lq" href="http://overpass-turbo.eu/" rel="noopener ugc nofollow" target="_blank">天桥涡轮</a>，它可以直接在浏览器中交互式地评估我们的查询。</p><p id="928b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您想要查询咖啡馆的节点，那么您的查询如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="25f8" class="ne lz it na b gy nf ng l nh ni">node["amenity"="cafe"]({{bbox}}); out;</span></pre><p id="2783" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中查询源代码中的每条语句都以分号结束。该查询首先指定我们想要查询的组件，在本例中是一个节点。</p><p id="ad58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在查询中应用了一个按标签过滤的方法，寻找所有键值对为<code class="fe nj nk nl na b">"amenity"="cafe"</code>的节点。在<a class="ae lq" href="https://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL#By_tag_.28has-kv.29" rel="noopener ugc nofollow" target="_blank">文档</a>中可以找到不同的标签过滤选项。</p><p id="d503" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有各种各样的标签可供选择，其中一个常见的关键字是<a class="ae lq" href="https://wiki.openstreetmap.org/wiki/Key:amenity" rel="noopener ugc nofollow" target="_blank"> amenity </a>，它涵盖了各种社区设施，如咖啡馆、餐厅，或者只是一张长椅。为了对OSM其他可能的标签有一个大概的了解，看看<a class="ae lq" href="https://wiki.openstreetmap.org/wiki/Map_Features" rel="noopener ugc nofollow" target="_blank"> OSM地图功能</a>或<a class="ae lq" href="https://taginfo.openstreetmap.org/" rel="noopener ugc nofollow" target="_blank"> taginfo </a>。</p><p id="8f2e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个过滤器是边界框过滤器，其中<code class="fe nj nk nl na b">{{bbox}}</code>对应于边界框，我们希望在该边界框中进行搜索，并且仅在天桥Turbo中工作。</p><p id="55b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">否则，您可以通过纬度和经度中的<code class="fe nj nk nl na b">(south, west, north, east)</code>指定一个边界框，如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="928f" class="ne lz it na b gy nf ng l nh ni">node["amenity"="pub"]<br/>  (53.2987342,-6.3870259,53.4105416,-6.1148829); <br/>out;</span></pre><p id="72e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以试试天桥涡轮。正如我们之前在OSM数据模型中看到的，也有可能拥有相同属性的方法和关系。</p><p id="d81a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们也可以通过使用一个<a class="ae lq" href="https://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL#Union" rel="noopener ugc nofollow" target="_blank"> union </a> block语句来获得这些信息，该语句收集一对括号内的语句序列的所有输出，如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3815" class="ne lz it na b gy nf ng l nh ni">( node["amenity"="cafe"]({{bbox}});<br/>  way["amenity"="cafe"]({{bbox}});<br/>  relation["amenity"="cafe"]({{bbox}});<br/>);<br/>out;</span></pre><p id="d6e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一种过滤查询的方法是通过元素id 过滤<a class="ae lq" href="https://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL#By_element_id" rel="noopener ugc nofollow" target="_blank">。下面是查询<code class="fe nj nk nl na b">node(1); out;</code>的例子，它给出了经度接近于零的世界</a>的<a class="ae lq" href="https://www.openstreetmap.org/node/1" rel="noopener ugc nofollow" target="_blank">本初子午线。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/382a360041b973ee032d6790c2c2ffaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EqpqG_63WTSM5soL.png"/></div></div></figure><p id="2fb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一种过滤查询的方式是按地区来过滤<a class="ae lq" href="https://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL#By_area_.28area.29" rel="noopener ugc nofollow" target="_blank">，可以指定为<code class="fe nj nk nl na b">area["ISO3166-1"="GB"][admin_level=2];</code>，这样我们就得到了英国的地区。</a></p><p id="60e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在可以使用它作为查询的过滤器，方法是将<code class="fe nj nk nl na b">(area)</code>添加到语句中，如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="78eb" class="ne lz it na b gy nf ng l nh ni">area["ISO3166-1"="GB"][admin_level=2];<br/>node["place"="city"](area);<br/>out;</span></pre><p id="e3ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该查询返回英国的所有城市。也可以使用关系或方式作为区域。在这种情况下，区域ID需要从一个现有的OSM路径中派生出来，方法是将<code class="fe nj nk nl na b">2400000000</code>添加到它的OSM ID中，或者在有关系的情况下，添加<code class="fe nj nk nl na b">3600000000</code>。</p><p id="6b96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，并不是所有的路/关系都有一个区域对应物(即那些标有<code class="fe nj nk nl na b">area=no</code>的路/关系，以及大多数没有定义<code class="fe nj nk nl na b">name=*</code>的多多边形将不属于区域)。</p><p id="85f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们将<a class="ae lq" href="https://www.openstreetmap.org/relation/62149" rel="noopener ugc nofollow" target="_blank">英国</a>的关系应用到前面的例子中，我们将得到:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8c4e" class="ne lz it na b gy nf ng l nh ni">area(3600062149);<br/>node["place"="city"](area);<br/>out;</span></pre><p id="955d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们可以指定查询数据的输出，这是由<a class="ae lq" href="https://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL#Print_.28out.29" rel="noopener ugc nofollow" target="_blank"> out action </a>配置的。到目前为止，我们将输出指定为<code class="fe nj nk nl na b">out;</code>，但是可以添加各种附加值。</p><p id="57dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一组值可以控制输出信息的详细程度或详细程度，如<a class="ae lq" href="https://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL#Print_.28out.29" rel="noopener ugc nofollow" target="_blank">文档</a>中描述的<code class="fe nj nk nl na b">ids</code>、<code class="fe nj nk nl na b">skel</code>、<code class="fe nj nk nl na b">body</code>(默认值)、<code class="fe nj nk nl na b">tags</code>、<code class="fe nj nk nl na b">meta</code>和<code class="fe nj nk nl na b">count</code>。</p><p id="1167" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们可以为地理编码信息添加修饰符。<code class="fe nj nk nl na b">geom</code>为每个对象添加完整的几何图形。当返回没有关联坐标的关系或路径，并且您想要获得它们的节点和路径的坐标时，这很重要。</p><p id="44ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，查询<code class="fe nj nk nl na b">rel["ISO3166-1"="GB"][admin_level=2]; out geom;</code>不会返回任何坐标。值<code class="fe nj nk nl na b">bb</code>仅将边界框添加到每个路径和关系，而<code class="fe nj nk nl na b">center</code>仅添加同一边界框的中心。</p><p id="5e18" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">排序顺序可通过<code class="fe nj nk nl na b">asc</code>和<code class="fe nj nk nl na b">qt</code>进行配置，分别按对象ID或四块索引排序，后者明显更快。最后，通过添加一个整数值，您可以设置要返回的最大元素数。</p><p id="1731" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结合目前所学，最终可以查询到德国所有Biergarten的位置。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3c34" class="ne lz it na b gy nf ng l nh ni">area["ISO3166-1"="DE"][admin_level=2];</span><span id="ef9b" class="ne lz it na b gy nn ng l nh ni">( node["amenity"="biergarten"](area);<br/>  way["amenity"="biergarten"](area);<br/>  rel["amenity"="biergarten"](area);<br/>);<br/>out center;</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4376" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">使用Python访问</h1><p id="abd4" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">要用Python访问over float API，使用<a class="ae lq" href="https://github.com/DinoTools/python-overpy" rel="noopener ugc nofollow" target="_blank">over pay</a>包作为包装器。在这里，您可以看到我们如何用overpy包来翻译前面的示例:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c39b" class="ne lz it na b gy nf ng l nh ni">import overpy</span><span id="cd95" class="ne lz it na b gy nn ng l nh ni">api = overpy.Overpass()<br/>r = api.query("""<br/>area["ISO3166-1"="DE"][admin_level=2];<br/>(node["amenity"="biergarten"](area);<br/> way["amenity"="biergarten"](area);<br/> rel["amenity"="biergarten"](area);<br/>);<br/>out center;<br/>""")</span><span id="9919" class="ne lz it na b gy nn ng l nh ni">coords  = []<br/>coords += [(float(node.lon), float(node.lat)) <br/>           for node in r.nodes]<br/>coords += [(float(way.center_lon), float(way.center_lat)) <br/>           for way in r.ways]<br/>coords += [(float(rel.center_lon), float(rel.center_lat)) <br/>           for rel in r.relations]</span></pre><p id="c322" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">overpy的一个优点是它从响应中检测内容类型(即XML、JSON)。更多信息请看他们的<a class="ae lq" href="https://python-overpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div></div>    
</body>
</html>