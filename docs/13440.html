<html>
<head>
<title>How To Implement Your Own Libc</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何实现自己的Libc</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-your-own-libc-tk-cce1c8e84e80?source=collection_archive---------4-----------------------#2022-08-26">https://betterprogramming.pub/implementing-your-own-libc-tk-cce1c8e84e80?source=collection_archive---------4-----------------------#2022-08-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="467f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们的操作系统不支持libc，所以让我们努力吧！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/db8eb6cf6e541c7c02225bf7ad5ad423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R3tg9sNfAIknX_P8yVT2gg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">让我们一起深入OS开发吧！</p></figure><p id="680e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我撰写的关于创建自己的操作系统的系列文章的第二部分。你可以跟随GitHub上的<a class="ae lu" href="https://github.com/azyklus/sys3" rel="noopener ugc nofollow" target="_blank">库</a>(或者<a class="ae lu" href="https://git.sr.ht/~azyklus/sys3" rel="noopener ugc nofollow" target="_blank"> Sourcehut </a>)。</p><p id="6534" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们离开时，我们已经设置了一个基本的shell，当我们启动系统时，它会向我们打招呼。除了编写的汇编代码和C语言的一些零碎内容，如VGA颜色代码和低级打印，没有什么别的东西。在这篇文章中，我们将扩展我们的shell程序并实现一些关键的libc功能。</p><p id="350c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们需要创建一些文件来保存我们的代码。您可以随意称呼它们，但是我创建了一个基本的源代码树，如下所示:</p><ul class=""><li id="f077" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">/(根目录)</li><li id="ae27" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">/main —包含入口点和我们的shell程序。</li><li id="53d1" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">/lib —包含在整个应用程序中使用的“库”。</li><li id="b50c" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">/lib/boot —包含我们的引导加载程序。</li><li id="cfb7" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">/lib/libc —包含我们的libc实现。</li><li id="8995" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">/lib/link —包含我们的链接器脚本。</li></ul><p id="fbbf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mj">注意:这种布局可能不是您最喜欢的，但是您可以根据自己的喜好设置您的源代码树。这有助于我保持条理。</em></p><p id="2e25" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您需要创建至少两个头文件来包含<code class="fe mk ml mm mn b">MemCpy</code>、<code class="fe mk ml mm mn b">MemSet</code>、<code class="fe mk ml mm mn b">MemCmp</code>、<code class="fe mk ml mm mn b">MemMove</code>、<code class="fe mk ml mm mn b">strlen</code>、<code class="fe mk ml mm mn b">abort</code>和<code class="fe mk ml mm mn b">PutChar</code>的定义。这些是一些基本函数，使我们能够进一步扩展我们的内核。我们将从<code class="fe mk ml mm mn b">mem</code>函数开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">定义一个头文件来包含我们的mem函数。</p></figure><p id="d47e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们将在它们自己的文件中实现这些函数。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">非常基本的内存实用函数实现。</p></figure><p id="6da8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在有了一些基本的内存操作工具，但是我们需要一个适当的“打印”实现和它的一些化身。为了实现这一点，我想稍微偏离libc实现，创建一个类似软件UART(通用异步收发器)的东西。</p><p id="129f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们将创建一个名为“Uart”的结构，并给它一个字段:内存基址。稍后我们将向这个结构中添加更多内容，但是现在，我们将用一个字段写出它，并在旁边添加两个函数。看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一种基本的通用异步收发器系统。</p></figure><p id="5646" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们实现这些函数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">UART功能已实现。</p></figure><p id="a666" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的<code class="fe mk ml mm mn b">UartInit</code>函数创建了一个指向<code class="fe mk ml mm mn b">Uart</code>结构实例的指针。这个指针将被传递给其他相关的函数— <code class="fe mk ml mm mn b">Read</code>和<code class="fe mk ml mm mn b">Write</code>。</p><p id="5676" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的<code class="fe mk ml mm mn b">Read</code>函数中，我们有两个参数:<code class="fe mk ml mm mn b">Uart</code>指针和一个整数偏移量。将焦点转移到函数体，我们可以看到，我们声明了一个指向可变的无符号8位整数的指针，并将其设置为结构中的基址。我们在这里使用“volatile ”,这样编译器就不会优化掉我们的代码。最后，我们解引用并返回可变指针和偏移量的组合值。</p><p id="027f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要将我们的值写入UART，我们需要一个指向<code class="fe mk ml mm mn b">Uart</code>的指针和一个偏移量，很像<code class="fe mk ml mm mn b">Read</code>，但是我们也需要一个无符号的8位整数值来写入。我们以和以前一样的方式使用“volatile ”,将我们的值赋给指针和偏移量的组合。</p><p id="91af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们有了一个非常基本的内存映射IO设置，我们可以回到我们的<code class="fe mk ml mm mn b">stdio</code>头。稍后我们将重写我们的shell函数来使用我们的UART定义。现在，让我们写出我们的<code class="fe mk ml mm mn b">Print</code>和<code class="fe mk ml mm mn b">Printf</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">让我们定义我们的打印功能！</p></figure><p id="9150" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的include guard之后，我们从一个我还没有谈到的叫做<code class="fe mk ml mm mn b">sys/cdefs.h</code>的头球切入。这是我创建的一个文件，用来存放我的一些个人#定义和类型别名等等。这并不重要，因为除了它自己的include guard之外，该文件中目前只有一个定义，所以我们将在以后的文章中再次讨论它。</p><p id="6fe4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们用下面的代码实现我们的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="edfb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有很多东西需要解开，所以我们将从<code class="fe mk ml mm mn b">PutChar</code>函数开始。这需要一个整数来表示一个“字符代码”,然后将其转换成一个<code class="fe mk ml mm mn b">char</code>,然后将其提供给<code class="fe mk ml mm mn b">UartWrite</code>函数，该函数随后执行一个易失性写操作。现在，这个函数自己初始化UART，但是我们以后会改变它。</p><p id="224a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">静态的<code class="fe mk ml mm mn b">Print</code>函数接受一个字符数组并简单地循环，直到它放入通过<code class="fe mk ml mm mn b">PutChar</code>函数提供的每个字符，尽管<code class="fe mk ml mm mn b">Printf</code>必然会变得更加复杂。</p><p id="154b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们试图完成一些基本的格式化，所以我们必须发挥创造力:我们需要检查一些常用的特殊格式化字符。</p><p id="22ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们必须确保我们没有写任何东西，所以我们检查我们的<code class="fe mk ml mm mn b">EOF</code>条件，然后我们继续检查我们是否遇到了“格式表达式”这些以符号<code class="fe mk ml mm mn b">%</code>开始，后面的字符表示我们将要进行的格式化类型:<code class="fe mk ml mm mn b">%s</code>表示字符串格式化，<code class="fe mk ml mm mn b">%c</code>表示字符格式化。另一次，我们将实现整数、浮点数和其他数据类型的格式化。</p><p id="5996" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们还有一个功能要实现:<code class="fe mk ml mm mn b">abort</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Abort在出错时暂停程序！</p></figure><p id="f95d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们的系统遇到不可恢复的错误时，这个函数被调用。理想情况下，我们永远不会到达这一点，但是如果到达这一点，我们需要能够执行系统的快速停止。</p><p id="2dda" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经有了一些基本的libc功能，我们可以像上次一样编译我们的程序了，我们可以打字了！我们还没有像Bash或ZSH那样的“外壳”,但我们将在下一期中实现更合适的东西，敬请期待！</p><h1 id="40a1" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">资源</h1><p id="31ca" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">作为免责声明，部分代码是从其他来源借用或翻译而来的:</p><ul class=""><li id="d55c" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><a class="ae lu" href="https://wiki.osdev.org/Main_Page" rel="noopener ugc nofollow" target="_blank"> OSDev Wiki </a></li><li id="96ba" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://redox-os.org/docs/" rel="noopener ugc nofollow" target="_blank"> RedoxOS文档</a></li><li id="f70a" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://osblog.stephenmarz.com/index.html" rel="noopener ugc nofollow" target="_blank">斯蒂芬·马兹博客</a></li></ul><p id="190c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的git仓库:</p><ul class=""><li id="4f2a" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><a class="ae lu" href="https://github.com/azyklus/sys3" rel="noopener ugc nofollow" target="_blank"> GitHub </a></li><li id="ef8c" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://git.sr.ht/~azyklus/sys3" rel="noopener ugc nofollow" target="_blank"> Sourcehut </a></li></ul><p id="c021" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">故事到此为止:</p><ul class=""><li id="537d" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/how-to-create-your-own-operating-system-bfd2545d2e6d">第一章</a></li></ul><p id="6092" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">再次，我非常感谢你阅读我的故事，我期待着我们下次见面！❤</p></div></div>    
</body>
</html>