<html>
<head>
<title>How to Clean Your Sockets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何清洁你的插座</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-i-cleaned-my-sockets-108503649bb3?source=collection_archive---------4-----------------------#2019-05-14">https://betterprogramming.pub/how-i-cleaned-my-sockets-108503649bb3?source=collection_archive---------4-----------------------#2019-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="baba" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用路由和控制器清理和简化您在<a class="ae kf" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> socket.io </a>中的套接字</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/56b7abfaffa5fe1a1bcb9761e9cafa0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jKJqDrvWTkTEChAJ.jpg"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">物理网络套接字</p></figure><p id="d49d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于那些认为这将是清洁物理插座以插入东西的人来说，我很抱歉地告诉你们事实并非如此。相反，我将告诉你我如何清理我用<a class="ae kf" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> socket.io </a>编写的套接字，这是一个非常流行的库，用于开发客户机和服务器之间的实时套接字连接。在我们冒险探究我做了什么之前，让我们看看路由通常是如何用<a class="ae kf" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> express </a>编写的，这是另一个用于编写强大http服务器的流行框架。</p><h1 id="a9bd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">路线和控制器</h1><p id="433b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果您是一名web开发人员，您可能非常喜欢MVC架构，以及我们如何掌握它在web应用程序开发中的使用。对于那些不熟悉的人来说，<strong class="ky ir"> MVC </strong>代表模型-视图-控制器，而<strong class="ky ir">架构</strong>在本文中指的是我们的应用程序的结构。</p><ul class=""><li id="5fb1" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><strong class="ky ir">模型</strong> —应用程序的一部分，处理应用程序特定数据的管理(长期和短期)。</li><li id="49c3" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><strong class="ky ir">视图</strong> —用户与之交互的应用程序的一部分，可以看到，允许用户导航并与我们的服务交互。</li><li id="f5fe" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><strong class="ky ir">控制器</strong>—<strong class="ky ir">视图</strong>作为中间人与<strong class="ky ir">模型通信的应用程序部分，</strong>调解用户和我们的数据库之间的交互。</li></ul><p id="4306" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，这个系统描述了三个不同的类别，我们可以将我们的代码分类。但是，我们可以进一步分解控制器，对每个组件进行更细粒度的定义。</p><p id="8363" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">控制器故障</strong></p><ul class=""><li id="2b2a" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><strong class="ky ir">控制器</strong>——控制器的一部分，实际处理我们的应用程序的逻辑。</li><li id="7527" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><strong class="ky ir">路线</strong>——控制器的一部分，将我们的逻辑映射到用户试图与之交互的路线。</li></ul><p id="5f4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当仅仅作为想法呈现时，这其中的许多是高度抽象的，所以让我们看一下我的应用程序的一部分来演示这种分解:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">我们的控制器</p></figure><p id="3076" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们设置了路由器，将我们的<strong class="ky ir">路由</strong>映射到我们的<strong class="ky ir">控制器</strong>。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">我们的路线</p></figure><p id="9b0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前面的两段代码中，我们有两个控制器，用于处理来自服务器的50条消息和一条消息的检索。</p><p id="8ae3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，这种粒度级别允许我们创建更加模块化的应用程序，并真正将组件的功能隔离到它们应该做的事情上。然而，我的代码库的其他部分没有利用这种类型的约定，而这种约定正是我一直缺少的。</p><h1 id="2f83" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">套接字和套接字处理程序</h1><p id="d9a8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在深入研究我的代码之前，先回顾一下，<strong class="ky ir"> socket.io </strong>是一个提供网络套接字的库，这些套接字允许我们在客户机和服务器之间建立实时连接。现在让我们以我最初的socket实现为例，尝试找出可以改进的地方。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">我最初的套接字实现</p></figure><p id="9a2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了代码中的大分组和所有控制台日志之外，您还能在这部分代码中发现什么问题？如果我们遵循我们之前定义的控制器分解范例——我们应该是<strong class="ky ir"/>,因为作为程序员我们努力保持一致性——我们不会在这段代码中明确地将套接字作为<strong class="ky ir">路由</strong>和<strong class="ky ir">控制器</strong>来处理。</p><p id="0253" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们孤立地看一下其中一个插座:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">断开功能</p></figure><p id="3f57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有这个名为<em class="nf"> socket </em>的socket对象，我们告诉它在发生<em class="nf"> disconnect </em>事件时<em class="nf">，我们希望它执行我们指定的代码。这几乎<strong class="ky ir">完全</strong>像我们的express控制器是如何定义和工作的。</em></p><p id="eb8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们为socket对象提供了一个<em class="nf">端点</em>，它将被<em class="nf">映射</em> <strong class="ky ir"> <em class="nf"> </em> </strong>到一个函数，当客户端试图与之交互时，该函数将会起作用。考虑到所有这些，我们如何在保持简单性的同时，真正地分解我们的套接字以提高可读性呢？</p><p id="1226" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">让我们为我们应该如何做创造一些步骤</strong>:</p><ol class=""><li id="dea3" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr ng mv mw mx bi translated">创建另一个文件来存放我们的“控件/控制器”</li><li id="b916" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr ng mv mw mx bi translated">将<strong class="ky ir">路线</strong>和<strong class="ky ir">控制器</strong>分解成各自的部件。</li><li id="63d9" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr ng mv mw mx bi translated">…利润…</li><li id="e065" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr ng mv mw mx bi translated">当我们绘制路线时，巧妙地传递每个控制器将需要的任何依赖关系。</li></ol><p id="a52a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些步骤看起来像什么？好吧，让我们看看！</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8aca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，我们现在得到了两个新文件，这两个文件由它们所关注的内容分开。这不仅使我们具有更好的可读性，而且现在处理路线的函数只允许访问它们已经通过我们定义路线的地方传递的数据，这使我们能够对我们的应用程序进行更全面的控制，并更好地理解每个单独的组件应该做什么。</p><h1 id="16c0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">包扎</h1><p id="1173" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">虽然我们生活在一个总是试图尽可能向前推进的世界，但有时我们最好后退一步，评估我们过去的步骤，以学习和改进我们未来的步骤。我最初对这些套接字的实现非常草率，但是如果我没有回头来看它们，我就永远不会有机会改进我的代码，并发现一种新的方式来思考我为未来的实现编写套接字的方式。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="6f6e" class="ls lt iq bd lu lv no lx ly lz np mb mc jw nq jx me jz nr ka mg kc ns kd mi mj bi translated">资源</h1><ul class=""><li id="dc5f" class="mp mq iq ky b kz mk lc ml lf nt lj nu ln nv lr mu mv mw mx bi translated"><a class="ae kf" href="https://github.com/C3NZ/xenochat" rel="noopener ugc nofollow" target="_blank">这一块的所有代码都可以在这里找到</a></li></ul></div></div>    
</body>
</html>