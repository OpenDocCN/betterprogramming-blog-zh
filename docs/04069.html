<html>
<head>
<title>Locate: A Recursive Search Tool Written in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Locate:一个用Rust编写的递归搜索工具</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/locate-a-recursive-search-tool-6e497d0134ba?source=collection_archive---------6-----------------------#2020-03-21">https://betterprogramming.pub/locate-a-recursive-search-tool-6e497d0134ba?source=collection_archive---------6-----------------------#2020-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4f55" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个用Rust编写的工具，可以递归搜索文件夹中的所有文件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8268ea37cf419de9687c64a64e592a36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*reGtKHqzabV5aC5JinMqxQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Evgeni Tcherkasski 在<a class="ae ky" href="https://unsplash.com/s/photos/search?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有多少次你在文件中寻找某个字符串或函数的起源？</p><p id="af24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Locate是用<a class="ae ky" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> Rust </a>编写的工具，它递归地遍历每个文件，并给出文件中查询字符串的确切位置。</p><p id="439c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的速度快得惊人，因为它是用Rust编写的，而且它可以递归地遍历目录。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7733" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">动机</h1><p id="4738" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我想学习Rust，我认为学习一门新语言的最好方法是创建一个项目。</p><p id="b67f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我一直使用VS代码中的search函数来查找函数的起源或者函数被使用的地方。如果处理大型项目，有时很难准确定位使用函数的所有点。当然，人们可以通过导入来追溯函数的起源，但是拥有一个工具有时会很方便。</p><p id="7d4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:由于这是我在Rust中的第一个项目，有可能我做了一些不应该做的事情。</p><p id="301a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6084" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建新的包</h1><p id="231f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了开始一个新的包，我们做<code class="fe mz na nb nc b">cargo new</code>，因为这是一个二进制程序:</p><p id="abb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">cargo new locate --bin</code></p><p id="46bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建一个文件夹结构:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="ddef" class="nh md it nc b gy ni nj l nk nl">. <br/>├── Cargo.toml <br/>└── src <br/>    └── main.rs <br/>1 directory, 2 files</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4c4d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们需要的包裹</h1><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d544" class="nh md it nc b gy ni nj l nk nl">fstream = "0.1.2"<br/>walkdir = "2.3.1"<br/>argparse = "0.2.2"<br/>colored = "1.9"</span></pre><ul class=""><li id="bf55" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><code class="fe mz na nb nc b"><strong class="lb iu">fstream</strong></code> <strong class="lb iu"> </strong>将用于读取文件。</li><li id="da63" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe mz na nb nc b"><strong class="lb iu">walkdir</strong></code> <strong class="lb iu"> </strong>将用于迭代所有文件夹和文件。</li><li id="3d80" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe mz na nb nc b"><strong class="lb iu">argparse</strong></code> <strong class="lb iu"> </strong>是一个简单的参数解析器，用来解析参数。</li><li id="0f10" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe mz na nb nc b"><strong class="lb iu">colored</strong></code>将用于给终端输出着色。</li></ul><p id="d28c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这些添加到您的<code class="fe mz na nb nc b">cargo.toml</code>中。</p><p id="a4e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们的<code class="fe mz na nb nc b">cargo.toml</code>看起来会像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5a7f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">密码</h1><h2 id="b5f3" class="nh md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">主代码</h2><p id="0186" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们的基本工作流程如下。首先，我们将从用户处获取<code class="fe mz na nb nc b">path</code>和<code class="fe mz na nb nc b">query</code>。然后，我们需要一个函数来遍历路径中的所有文件夹，并检查查询字符串是否存在于任何文件中。如果是这样，文件的路径将被传递给另一个函数，查询字符串的确切位置将位于该函数中。</p><p id="b32d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遍历目录很容易，因为我们将使用<code class="fe mz na nb nc b">walkdir</code>来完成。</p><h2 id="6b97" class="nh md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">c的代码<code class="fe mz na nb nc b">hecking dir</code></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="2951" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在给定的路径上创建一个新的<code class="fe mz na nb nc b">Walkdir</code>，并应用一个过滤器来消除权限错误。</p><p id="14b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们检查<code class="fe mz na nb nc b">iter</code>是否是一个文件。然后我们使用<code class="fe mz na nb nc b">fstrem</code>来检查查询字符串是否在文件中。</p><p id="ca48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们得到包含查询的文件，它就被传递给另一个函数，该函数定位准确的行号。</p><h2 id="1a5c" class="nh md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">检查文件的代码</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="e6b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单:我们逐行读取整个文件。由于它返回一个字符串向量，我们可以很容易地遍历每一行并检查查询字符串是否存在。</p><p id="279a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果存在，我们就简单地打印它。有打印格式(如<code class="fe mz na nb nc b">.green()</code>、<code class="fe mz na nb nc b">.bold()</code>等)。)这是在我们之前进口的<code class="fe mz na nb nc b">colored</code>板条箱的帮助下完成的。</p><p id="f3be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已。我们有两个部分的代码，读取文件和找到文件。</p><p id="9106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩下的工作是从命令行解析参数。库参数解析器的灵感来自Python中的<code class="fe mz na nb nc b">argparse</code>。</p><h2 id="9eff" class="nh md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">参数分析器的代码</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="df93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这部分也很简单。我们正在创建两个可变变量(Rust中的变量在默认情况下是不可变的)。然后我们将创建一个新的argpaser对象，设置它的描述，并创建我们的选项。最棒的是，它使用我们对每个选项的描述自动生成帮助消息。</p><p id="b9b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成了。我们试试吧！</p><p id="6670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型<code class="fe mz na nb nc b">cargo build</code>。您会发现在<code class="fe mz na nb nc b">target/debug</code>中创建了一个二进制文件。您可以直接通过<code class="fe mz na nb nc b">cargo run</code>或者使用您刚刚创建的二进制文件来运行它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="356e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">演示</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/6653c737135af2d6fa9b9dc199657408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/0*hhYe1dxYAIEZ-ZOi.gif"/></div></figure><p id="664b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://github.com/pr4k/locate/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>找到完整的源代码。</p><p id="6c01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有，如果你不想做这一切，可以直接用:<code class="fe mz na nb nc b">cargo install locate</code>安装。或者可以在<a class="ae ky" href="https://crates.io/crates/locate" rel="noopener ugc nofollow" target="_blank"> cargo@locate </a>查看。</p><p id="0b78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。编码快乐！</p></div></div>    
</body>
</html>