<html>
<head>
<title>Docker Tips: Rollout and Rollback In Docker Swarm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker提示:Docker Swarm中的展示和回滚</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rollout-and-rollback-in-docker-swarm-7f19e2fe2cd1?source=collection_archive---------0-----------------------#2018-10-01">https://betterprogramming.pub/rollout-and-rollback-in-docker-swarm-7f19e2fe2cd1?source=collection_archive---------0-----------------------#2018-10-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/784733fee7c1d8a985008ab17d88c3fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n5XmJULvspW-xJmC8vJjUw.png"/></div></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="81c7" class="ki kj it bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="b042" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">得益于几个选项，<a class="ae me" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank"> Docker Swarm </a>使得对正在运行的服务执行滚动更新变得非常容易。</p><h2 id="5371" class="mf kj it bd kk mg mh dn ko mi mj dp ks lr mk ml kw lv mm mn la lz mo mp le mq bi translated">创造一个蜂群</h2><p id="93f9" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面的命令是将Docker守护进程转移到Swarm模式所需要的唯一东西。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="ad61" class="mf kj it mw b gy na nb l nc nd">$ docker swarm init</span></pre><p id="d111" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">注意:如果你有几个私有IP，你需要使用其中的一个，并用它来喂养<code class="fe nj nk nl mw b">--advertise-addr</code>。上面的命令将会是:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="2d3e" class="mf kj it mw b gy na nb l nc nd">$ docker swarm init --advertise-addr MY_IP</span></pre><p id="eb93" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">一旦创建了群，我们可以添加额外的节点，但这在本文中没有用——单节点群完全可以。</p><p id="9723" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">免责声明:不要通过在生产中运行单节点群集。</p><h2 id="d593" class="mf kj it bd kk mg mh dn ko mi mj dp ks lr mk ml kw lv mm mn la lz mo mp le mq bi translated">部署服务</h2><p id="25d0" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在Swarm上，服务可以手动部署，也可以通过堆栈文件部署。让我们使用第一个选项，并基于<code class="fe nj nk nl mw b">instavote/vote</code>映像创建一个服务。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/a2554ff187bb94b4114e7714c845211c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oFzdt3QNwlKhIzGKV2Sklg.gif"/></div></div></figure><p id="0527" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">上面运行的命令如下所示。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="4991" class="mf kj it mw b gy na nb l nc nd">$ docker service create \ <br/>--name vote \<br/>--replicas 4 \<br/>--publish 5000:80 \<br/>instavote/vote </span></pre><p id="c155" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">它为服务指定了4个副本。在幕后，这意味着投票服务的四个任务(一个任务运行一个容器)现在在Swarm上运行。当在端口5000上向投票服务发送一个请求时，这个请求会针对四个任务中的一个进行负载平衡(默认情况下以循环方式)。</p><p id="b4a3" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">下面的屏幕截图展示了投票服务的两个连续调用——每个调用由不同的容器处理。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/7e76460bca9927a9227d4776b4cc5c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u3c32Xdl5ctXRrDRG9AuPQ.png"/></div></div></figure><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/b53d421cbb000241063e3cf2f2e16f03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zSaCYQ0_oapU1Mx4K4vEkg.png"/></div></div></figure><p id="cd56" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">注意:这个服务只是提供了<a class="ae me" href="https://github.com/dockersamples/example-voting-app" rel="noopener ugc nofollow" target="_blank">投票App </a>的前端，并不允许我们投票，不过下面我们会看到的举例说明滚动更新就可以了。</p><h2 id="1b7a" class="mf kj it bd kk mg mh dn ko mi mj dp ks lr mk ml kw lv mm mn la lz mo mp le mq bi translated">滚动更新</h2><p id="de30" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我们现在需要更新服务，用<code class="fe nj nk nl mw b">instavote/vote:indent</code>的图片改变原始图片。更新服务非常简单:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="12b9" class="mf kj it mw b gy na nb l nc nd">$ docker service update \<br/>--image instavote/vote:indent \<br/>vote </span></pre><p id="f075" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">让我们看看现场直播:</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/f90cafc1800e52e428524f0f2f37317b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*G-C5kHv9WwiOhFkSVUanoQ.gif"/></div></div></figure><p id="79dd" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">从上面的视频中，我们注意到为了更新服务，任务是按顺序更新的。每一个都经历以下状态:</p><ul class=""><li id="d1e1" class="no np it li b lj ne ln nf lr nq lv nr lz ns md nt nu nv nw bi translated">准备的</li><li id="197a" class="no np it li b lj nx ln ny lr nz lv oa lz ob md nt nu nv nw bi translated">准备好的</li><li id="72b1" class="no np it li b lj nx ln ny lr nz lv oa lz ob md nt nu nv nw bi translated">开始</li><li id="9691" class="no np it li b lj nx ln ny lr nz lv oa lz ob md nt nu nv nw bi translated">运转</li></ul><p id="fcb7" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">一旦一个任务被更新，那么就轮到下一个了，以此类推。这是默认行为。当向服务发送请求时，我们现在可以在制表符和空格之间投票。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/7261d6f23125d87e76a997b281234868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*16vBpPxPE5Y3XA-yGdoBiw.png"/></div></div></figure><p id="dfc9" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">使用服务配置中的以下选项，我们可以自定义完成更新的方式:</p><ul class=""><li id="928a" class="no np it li b lj ne ln nf lr nq lv nr lz ns md nt nu nv nw bi translated"><code class="fe nj nk nl mw b">--update-parallelis</code>:同时更新的任务数。</li><li id="a97f" class="no np it li b lj nx ln ny lr nz lv oa lz ob md nt nu nv nw bi translated"><code class="fe nj nk nl mw b">--update-delay</code>:更新下一批任务前等待的时间。</li></ul><p id="f76a" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">注意:<a class="ae me" href="https://docs.docker.com/engine/reference/commandline/service_create/" rel="noopener ugc nofollow" target="_blank">文档</a>提供了可用于服务创建/更新的所有选项的列表。</p><p id="52e2" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">让我们再次更新服务，指定我们希望任务两个两个地进行，并且每一批都应该在前一批完成10秒后更新。以下命令允许我们这样做:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="e99b" class="mf kj it mw b gy na nb l nc nd">$ docker service update \<br/>--update-parallelism 2 \<br/>--update-delay 10s \<br/>vote</span></pre><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/369d0656b63eafc965a5340df9de0d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pqnFWxYMa8MqmEhT_iDrIg.gif"/></div></div></figure><p id="20b9" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">我们可以看到任务在这个过程中没有停止；它们保持在<code class="fe nj nk nl mw b">running</code>状态，因为只有服务参数被更新。这里不需要重新开始。</p><p id="2cb7" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">如果我们现在用新的映像更新服务，滚动更新将有所不同。让我们用<code class="fe nj nk nl mw b">instavote/vote:movies</code>来更新服务:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c296" class="mf kj it mw b gy na nb l nc nd">$ docker service update \<br/>--image instavote/vote:movies \<br/>vote</span></pre><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/86478983567443677d2b1320b24919a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xCwDwmAftT3fXUjZf0-aBQ.gif"/></div></div></figure><p id="2b5f" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">正如所料，更新了两个任务。十秒钟后，另外两个完成了。我们现在可以选择科幻电影。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/78acb4dc70f3533a74299b2621580bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y_gMyIi2LUOg9pRH6FA_fw.png"/></div></div></figure><h2 id="7501" class="mf kj it bd kk mg mh dn ko mi mj dp ks lr mk ml kw lv mm mn la lz mo mp le mq bi translated">服务检查</h2><p id="c8fc" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们检查服务，我们可以看到<code class="fe nj nk nl mw b">Spec</code>和<code class="fe nj nk nl mw b">PreviousSpec</code>键。而<code class="fe nj nk nl mw b">Spec</code>键指的是服务的当前规范(带有<code class="fe nj nk nl mw b">movies</code>图像标签的那个)，而<code class="fe nj nk nl mw b">PreviousSpec</code>指的是带有<code class="fe nj nk nl mw b">indent</code>标签的图像。Swarm跟踪服务历史中的两个层次。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="e38b" class="mf kj it bd kk mg mh dn ko mi mj dp ks lr mk ml kw lv mm mn la lz mo mp le mq bi translated">反转</h2><p id="a512" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为Swarm知道投票服务以前的规范，所以可以用下面的命令回滚到这个规范:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="231c" class="mf kj it mw b gy na nb l nc nd">$ docker service rollback vote</span></pre><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/66bf6137f6df0a900eb71ba298c03353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nfuchiDPfhGm-p8wmJM8Sw.gif"/></div></div></figure><p id="6583" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">正如我们所看到的，任务一个接一个地回滚。由于我们没有提供额外的配置来指定回滚应该如何完成，所以它使用默认行为(一个任务接一个任务地更新，并且每次更新之间没有延迟)。至于滚动更新的配置，我们可以在服务定义中使用以下选项来指定我们希望完成回滚的方式:</p><ul class=""><li id="f678" class="no np it li b lj ne ln nf lr nq lv nr lz ns md nt nu nv nw bi translated"><code class="fe nj nk nl mw b">--rollback-parallelism</code></li><li id="02a8" class="no np it li b lj nx ln ny lr nz lv oa lz ob md nt nu nv nw bi translated"><code class="fe nj nk nl mw b">--rollback-delay</code></li></ul><p id="9492" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">注意:<a class="ae me" href="https://docs.docker.com/engine/reference/commandline/service_create/" rel="noopener ugc nofollow" target="_blank">文档</a>提供了可用于服务创建/更新的所有选项的列表。</p><p id="abbd" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">回滚后，映像<code class="fe nj nk nl mw b">instavote/vote:indent </code>再次被服务使用。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/4e1501fbb366465d22fd834f215353d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Lx61ndjiXmvNOBNk9jdhg.png"/></div></div></figure><h2 id="9664" class="mf kj it bd kk mg mh dn ko mi mj dp ks lr mk ml kw lv mm mn la lz mo mp le mq bi translated">关于自动回滚</h2><p id="2279" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，我们已经执行了服务的手动回滚。但是，如果我们希望在新版本很糟糕的情况下自动回滚，该怎么办呢？让我们考虑另一个例子。</p><p id="06da" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated"><code class="fe nj nk nl mw b">lucj/whoami:1.0</code>和<code class="fe nj nk nl mw b">lucj/whoami:2.0</code>是简单API的两个版本，它们只返回容器的主机名，该容器处理在<code class="fe nj nk nl mw b">/whoami </code>端点上接收到的HTTP GET请求。标签为1.0的图像运行良好，标签为2.0的图像有问题。用于构建这些图像的docker文件如下:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="20ad" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">这里需要注意的重要一点是<code class="fe nj nk nl mw b">HEALTHCHECK</code>指令的存在。它用于验证服务的良好状态。基本上，它从容器中定期检查<strong class="li iu">端点是否响应。Swarm使用这个<code class="fe nj nk nl mw b">HEALTHCHECK</code>的结果来执行我们可以在服务级别配置的附加动作。</strong></p><p id="5058" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">让我们使用标签为1.0的图像来创建服务。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="ac75" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">我们指定了<code class="fe nj nk nl mw b">--update-failure-action</code>标志并赋予它<code class="fe nj nk nl mw b">rollback</code>值，这样不成功的更新将自动触发回滚。此外，<code class="fe nj nk nl mw b">--update-delay</code>和<code class="fe nj nk nl mw b">--update-monitor</code>用于为<code class="fe nj nk nl mw b">HEALTHCHECK</code>提供额外的定时。</p><p id="1a2b" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">让我们用有缺陷的<code class="fe nj nk nl mw b">lucj/whoami:2.0</code>映像来更新服务。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/0fab16ca32e08ad4fab3beb9f5dd6236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YUem9lfzWJxdRC27IZc4FQ.gif"/></div></div></figure><p id="83a8" class="pw-post-body-paragraph lg lh it li b lj ne ll lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">因为第一个任务无法更新(运行状况检查失败)，所以会自动执行回滚。在这个过程中，第二个任务没有受到影响，确保了服务仍然可用。如果我们只指定了一个副本，服务将在更新过程中关闭，显然这是我们想要避免的。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="81d5" class="ki kj it bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">摘要</h1><p id="768d" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望这篇文章对说明Docker Swarm的滚动更新功能有用。在定义服务时，指定更新配置选项被认为是最佳实践，以便最大限度地减少停机时间。</p></div></div>    
</body>
</html>