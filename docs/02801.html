<html>
<head>
<title>3 Reasons to Avoid Using ImmutableJS With Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免在Redux中使用ImmutableJS的3个原因</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-reasons-to-avoid-using-immutablejs-with-redux-b0109d0123e8?source=collection_archive---------8-----------------------#2020-01-02">https://betterprogramming.pub/3-reasons-to-avoid-using-immutablejs-with-redux-b0109d0123e8?source=collection_archive---------8-----------------------#2020-01-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ea84" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一旦进去了，你就再也拿不出来了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/17177e0dc3beeaf0a8c0c7a6ff4d5b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*zHkA6yZI9JhQ2YlBu8oEjg.png"/></div></figure><p id="a5ba" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">没有不可变的数据，Redux就无法工作，因此有意义的是<a class="ae lm" href="https://github.com/immutable-js/immutable-js" rel="noopener ugc nofollow" target="_blank">不可变的js库</a>——它有助于确保不变性——在Redux中使用得如此频繁。但是在一些大规模React-Redux应用程序中使用ImmutableJS之后，很明显使用这个库是有代价的，而且一旦使用，就很难退出。</p><p id="0b60" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">避免在Redux中使用ImmutableJS的三个原因是:</p><ol class=""><li id="8f78" class="ln lo it ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated">它会渗入到哑元件中，使它们变得不纯并且难以使用</li><li id="baa1" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated">它会扼杀Redux性能</li><li id="a2ed" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated">它允许应用程序状态变得复杂和深度嵌套</li></ol><p id="bbe0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在深入这些之前，先简要介绍一下什么是不变性，为什么它在Redux中如此重要，以及不变性JS提供了什么。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="a9a9" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">不变性和冗余</h1><p id="01d7" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">Redux通过检查与组件相关的应用程序状态是否发生变化来决定组件是否应该重新呈现。</p><p id="d03c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当应用程序的状态是一个不可变的对象时——这意味着一旦创建就不能再更改，或者<em class="nf">发生了变化— </em> Redux可以非常快速和容易地进行这种检查。</p><p id="c784" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是因为当对象是不可变的时，更新它们的唯一方法是用期望的改变创建一个新对象。新对象在内存中有新的引用，所以只需要一个简单的比较。对于组件关心的每个状态位(在<code class="fe ng nh ni nj b">mapStateToProps</code>中定义)，Redux可以做以下事情，不管这个状态位有多复杂:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="243e" class="no mj it nj b gy np nq l nr ns">previousBitOfState !== newBitOfState ? updateComponent() : null</span></pre></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="e7ad" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">ImmutableJS提供了什么？</h1><p id="43b4" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">ImmutableJS提供了一系列不可变的数据结构和更新它们的APIs它们看起来与普通的JavaScript非常相似。</p><p id="4ce4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">例如，对象可以被处理为:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="e5b4" class="no mj it nj b gy np nq l nr ns">const myImmutableMap = Immutable.fromJS({ a: 1, b: 2 })</span><span id="c9f7" class="no mj it nj b gy nt nq l nr ns">myImmutbableMap.set('b', 3)</span></pre><p id="6eed" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">和数组表示为:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="b56e" class="no mj it nj b gy np nq l nr ns">const myImmutableList = Immutable.fromJS([1, 2, 3])</span><span id="997a" class="no mj it nj b gy nt nq l nr ns">myImmutableList.push(4)</span></pre><p id="1871" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这确保了<code class="fe ng nh ni nj b">myImmutableMap</code>和<code class="fe ng nh ni nj b">myImmutableList</code>永远不会变异，然后在必要时可以使用<code class="fe ng nh ni nj b">toJS()</code>函数将它们转换回普通的JavaScript对象/数组。</p><p id="1b12" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">ImmutableJS还在幕后进行了大量性能优化，以使不可变更新快速高效。例如，不变量JS <code class="fe ng nh ni nj b">List</code>的<code class="fe ng nh ni nj b">push</code>和<code class="fe ng nh ni nj b">pop</code>方法的时间复杂度为O(1 ),即使它们产生了一个新的<code class="fe ng nh ni nj b">List</code>。</p><p id="b156" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">要向数组中添加一个元素，您必须创建一个包含所有其他元素的数组副本，这通常是一个O(n)操作。</p><p id="af71" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">简而言之，ImmutableJS是如何使用Redux的:</p><ol class=""><li id="8c3a" class="ln lo it ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated">使用<code class="fe ng nh ni nj b">Immutable.fromJS()</code>将整个Redux存储初始化为ImmutableJS数据结构。</li><li id="a3cb" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated">使用ImmutableJS APIs更新您在reducers中的状态— <code class="fe ng nh ni nj b">push()</code>、<code class="fe ng nh ni nj b">set()</code>、<code class="fe ng nh ni nj b">setIn([])</code>、<code class="fe ng nh ni nj b">merge()</code>等。</li><li id="908b" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated">确信您的状态在更新过程中没有发生变化。</li><li id="47a2" class="ln lo it ks b kt lw kw lx kz ly ld lz lh ma ll ls lt lu lv bi translated">理想情况下，在将ImmutableJS状态作为道具传递给组件之前，将它们转换成普通的JavaScript。</li></ol><p id="fa8c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这听起来很简单，但是随着应用程序在代码行和开发人员数量上的增长，很多事情可能会出错。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="519f" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">原因1:它泄漏到哑组件中，使它们变得不纯并且难以使用</h1><p id="4b45" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">Redux文档清楚地表明，哑组件——例如，那些由Redux连接的容器包装的组件——不应该接收props作为ImmutableJS对象:</p><blockquote class="nu nv nw"><p id="eaa6" class="kq kr nf ks b kt ku ju kv kw kx jx ky nx la lb lc ny le lf lg nz li lj lk ll im bi translated">你的哑元应该是纯净的；也就是说，给定相同的输入，它们应该产生相同的输出，并且没有外部依赖性。如果将这样的组件传递给一个不可变的。JS对象作为道具，你使它依赖于不可变的。JS来提取道具的值并操纵它。</p></blockquote><p id="d74b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">还会出现许多其他更明显的问题——尤其是当哑组件同时接收普通JavaScript和ImmutableJS属性时。当这种情况发生时，开发人员必须时刻意识到他们正在处理的是哪种类型的道具，当试图析构一个ImmutableJS对象时，通常会发现困难的方法:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="c92b" class="no mj it nj b gy np nq l nr ns">const immutableMap = Immutable.fromJS({ a: 1, b: 2 })<br/>const { a, b } = immutableMap</span><span id="e624" class="no mj it nj b gy nt nq l nr ns">console.log(a) // undefined<br/>console.log(b) // undefined</span></pre><p id="1f51" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">由于这种不确定性，一些简单的事情变得复杂了——不是不可能的复杂，而是不必要的复杂:</p><h2 id="4424" class="no mj it bd mk oa ob dn mo oc od dp ms kz oe of mu ld og oh mw lh oi oj my ok bi translated">1.定义组件的<code class="fe ng nh ni nj b">propTypes</code>和<code class="fe ng nh ni nj b">defaultProps</code></h2><p id="a692" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">期待<code class="fe ng nh ni nj b">propTypes.object</code>还是<code class="fe ng nh ni nj b">propTypes.instanceOf(Immutable.Map)</code>？如果是后者，不要忘记将ImmutableJS库导入到组件文件中。</p><h2 id="0c31" class="no mj it bd mk oa ob dn mo oc od dp ms kz oe of mu ld og oh mw lh oi oj my ok bi translated">2.组件测试的模拟道具</h2><p id="921a" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">又是同一个问题:期待一个模拟道具是<code class="fe ng nh ni nj b">Immutable.fromJS({...})</code>还是仅仅是一个普通的<code class="fe ng nh ni nj b">{...}</code>？</p><h2 id="4999" class="no mj it bd mk oa ob dn mo oc od dp ms kz oe of mu ld og oh mw lh oi oj my ok bi translated">3.编写、使用和重用实用函数</h2><p id="b5b9" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">一个函数需要一个数组或者不变量列表作为参数吗？它返回什么？为什么有两个函数看起来如此相似？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div><p class="on oo gj gh gi op oq bd b be z dk translated">忽略了这些可以写得更简洁的事实…</p></figure><p id="949f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了避免这种不确定性，同时遵守上面引用的Redux文档，在传递给组件之前，所有的props都必须转换成普通的JavaScript。这很容易实现——但不是很优雅。</p><p id="35a5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一个天真的方法是在所有道具通过之前使用<code class="fe ng nh ni nj b">toJS()</code>,但这是一个坏主意，这将在下面的原因2中讨论。高阶组件(HoC)可以用来更有效地进行转换，但这需要包装每个已经包装的连接组件，从而产生<code class="fe ng nh ni nj b">connect(toJS(MyComponent))</code>，其中<code class="fe ng nh ni nj b">toJS()</code>是一个相当令人生畏的HoC，看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="068c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">有一个带有-immutable-props-to-js 的npm包<a class="ae lm" href="https://www.npmjs.com/package/with-immutable-props-to-js" rel="noopener ugc nofollow" target="_blank">提供了这种特设功能，但是隐藏如此复杂的代码并不会使它更易于使用。</a></p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="f042" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">理由二:它能扼杀Redux性能</h1><p id="5d3d" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">ImmutableJS本身针对性能进行了巧妙的优化，但是如果不正确地与Redux一起使用——特别是在<code class="fe ng nh ni nj b">mapStateToProps</code>中——它可能会恶化整个应用程序的性能。我以前曾<a class="ae lm" href="https://medium.com/front-end-weekly/a-redux-performance-obsession-mapping-state-to-props-11b6bbae1766" rel="noopener">写过这个问题</a>但没有明确指出不变量，尽管它可能是所有问题中最糟糕的一个。</p><p id="83ee" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当使用<code class="fe ng nh ni nj b">toJS()</code>或<code class="fe ng nh ni nj b">toArray()</code>将ImmutableJS对象转换成普通JavaScript时，问题就出现了。</p><p id="aaa2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这些操作不仅在大型对象上运行<a class="ae lm" href="https://www.grzegorowski.com/immutable-js-tojs-vs-toarray" rel="noopener ugc nofollow" target="_blank">开销很大</a>，而且每次都会创建一个新对象。回想一下浅层相等检查，这意味着当Redux比较连续的<code class="fe ng nh ni nj b">mapStateToProps</code>函数的结果时，它们看起来总是不同的——这导致Redux连接组件的重新呈现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div><p class="on oo gj gh gi op oq bd b be z dk translated"><NumbersComponent/>将比要求更频繁地重新呈现—每次调用mapStateToProps时</p></figure><p id="f342" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">不幸的是，避免在<code class="fe ng nh ni nj b">mapStateToProps</code>中使用<code class="fe ng nh ni nj b">toJS()</code>的选项可能很困难，如原因1中所讨论的:要么将所有道具保留为ImmutableJS对象，要么屈从于另一个npm包和/或另一个更高阶的组件。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="aaae" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">原因3:它允许应用程序状态变得复杂和深度嵌套</h1><p id="443b" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">很少考虑应用程序状态的形状，对于小型应用程序来说，这可能很好。但是随着应用程序的增长，状态会变得难以管理——通常是当它变得嵌套很深的时候。</p><p id="c655" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">嵌套状态更有可能存储重复数据，当数据可以更新时，这尤其成问题，因为更新必须在所有重复数据之间保持一致。这是为什么经常推荐使用<a class="ae lm" href="https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape/" rel="noopener ugc nofollow" target="_blank">标准化状态的主要原因之一</a>。此外，在确保不变性的同时更新深度嵌套的数据通常非常困难:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="2e92" class="no mj it nj b gy np nq l nr ns">const newImmutableState = {<br/>  ...immutableState,<br/>  deeply: {<br/>    ...deeply,<br/>    nested: {<br/>      ...nested,<br/>      data: 'new data'<br/>    }<br/>  }<br/>}</span></pre><p id="2ee5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是ImmutableJS出手相救的地方之一:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="3d07" class="no mj it nj b gy np nq l nr ns">immutableState.setIn(['deeply', 'nested', 'data'], 'new data')</span></pre><p id="e385" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">但是从愤世嫉俗的角度来看，这种语法可能有点太方便了。当更新状态如此容易时，无论有多复杂或嵌套，开发人员都不会质疑它。这使得没有动力去优化状态形状，因此这可能带来的潜在好处(对于开发人员和应用程序性能)将永远不会实现。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="7d43" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">摘要</h1><p id="9de3" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">ImmutableJS有助于确保应用程序的状态保持不变，这是Redux正常工作所必需的。</p><p id="5793" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然而，使用这个库是有代价的:它会很快遍布你的代码库。甚至进入不关心不可变数据的地方。如果使用不当，它会影响性能。它可能隐藏了有效管理国家的一些细微差别。而且往往看起来甚至不像JavaScript。</p><p id="d448" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你开始一个新的Redux应用程序，在单向跳转到ImmutableJS之前考虑这些成本，并且知道有替代的解决方案——我已经<a class="ae lm" href="https://medium.com/better-programming/try-these-instead-of-using-immutable-js-with-redux-f5bc3bd30190" rel="noopener">在后续文章</a>中写了这些。</p></div></div>    
</body>
</html>