<html>
<head>
<title>Don’t Depend on State From Callback Handlers in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中不依赖于回调处理程序的状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dont-depend-on-state-from-callback-handlers-in-react-167241a876ff?source=collection_archive---------22-----------------------#2020-04-20">https://betterprogramming.pub/dont-depend-on-state-from-callback-handlers-in-react-167241a876ff?source=collection_archive---------22-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5e89" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">把渲染阶段想象成小而孤立的世界</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eda822505ebcef17179707ecf0831a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TCfHR6TTkeyaDHMnxP3iWw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@emilep?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">émile Perron</a>在<a class="ae ky" href="https://unsplash.com/s/photos/web?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0dce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是一名React开发人员，你可能会同意我的观点，使用state很容易成为你一天中最大的痛苦。</p><p id="1240" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这里有一个技巧可以帮助你避免引入无声但灾难性的错误:<em class="lv">避免闭包引用回调处理程序的状态值</em>。</p><p id="9069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果做得好，在回调处理程序中处理状态应该没有问题。但是，如果你在某一点上犯了错误，引入了难以调试的无声错误，那么后果就开始吞噬你一天中你希望可以收回的时间。</p><p id="1eef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，我们要看看代码中的一个问题，它将向我们展示当我们使用状态时一个常见的有问题的场景。前面的代码示例将显示一个组件<code class="fe lw lx ly lz b">App</code>。它将声明一个<code class="fe lw lx ly lz b">collapsed</code>状态(默认为<code class="fe lw lx ly lz b">true</code>)并呈现一个<code class="fe lw lx ly lz b">AppContent</code>组件，该组件呈现输入元素:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="133a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户输入一些东西时，它会从props中调用它的<code class="fe lw lx ly lz b">onChange</code>处理程序，该程序被定向到<code class="fe lw lx ly lz b">App</code>。它接收<code class="fe lw lx ly lz b">callback</code>参数，并将其<code class="fe lw lx ly lz b">collapsed</code>状态设置为<code class="fe lw lx ly lz b">false</code>，这样其子节点就可以展开来显示它们的内容。然后执行在<code class="fe lw lx ly lz b">handleOnChange</code>(T10)中结束，传入<code class="fe lw lx ly lz b">collapsed</code>和一个随机的<code class="fe lw lx ly lz b">person</code>变量(是的，我知道是随机的),只有当 <code class="fe lw lx ly lz b">collapsed</code>为<code class="fe lw lx ly lz b">false</code>时，这个变量才会填充数据<em class="lv">。</em></p><p id="53c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码实际上运行良好，没有意外的控制台错误，生活是美好的。</p><p id="8f61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，在这段代码中有一个主要的问题。事实上，我们被抛出没有控制台错误，我们的代码没有被打破，使它成为一个危险的错误！</p><p id="05a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在<code class="fe lw lx ly lz b">handleOnChange</code>中添加一些<code class="fe lw lx ly lz b">console.log</code>，看看我们会得到什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/6ea5a9c7f6362d3cb13a49be86b9ccad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2OLMY50x0FovF7mV.jpg"/></div></div></figure><p id="ef1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等，为什么<code class="fe lw lx ly lz b">person</code> <code class="fe lw lx ly lz b">null</code>和<code class="fe lw lx ly lz b">collapsed</code> <code class="fe lw lx ly lz b">true</code>？我们已经将<code class="fe lw lx ly lz b">collapsed</code>的状态值设置为<code class="fe lw lx ly lz b">false</code>，我们知道这是有效的JavaScript代码，因为运行时能够顺利运行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="c205" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你理解JavaScript中的执行上下文，这是没有意义的，因为封装对<code class="fe lw lx ly lz b">setCollapsed</code>的调用的函数在向其本地<code class="fe lw lx ly lz b">onChange</code>函数发送调用之前已经完成了<em class="lv">！</em></p><p id="b18d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，实际上还是对的。JavaScript现在没有做错什么。这实际上是R <em class="lv"> eact </em>在做它的事情。</p><p id="6830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于渲染过程的完整解释，你可以去看看他们的<a class="ae ky" href="https://reactjs.org/docs" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="5f3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但简而言之，每当react进入一个新的<em class="lv">渲染</em>阶段时，它会对该渲染阶段所呈现的<em class="lv">所有内容拍摄一个<em class="lv"/>。在这个阶段，react本质上创建了一个React元素树，它表示在那个时间点</em>的树<em class="lv">。</em></p><p id="7ef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据定义，对<code class="fe lw lx ly lz b">setCollapsed</code> <em class="lv">的调用会导致</em>重新渲染，但是这个渲染阶段是在未来的某个时间点！这就是为什么<code class="fe lw lx ly lz b">collapsed</code>仍然是<code class="fe lw lx ly lz b">true</code>而<code class="fe lw lx ly lz b">person</code>是<code class="fe lw lx ly lz b">null</code>的原因，因为那个时间点的执行<em class="lv">是特定于那个渲染</em>的，有点像拥有他们自己生活的小世界。</p><p id="fa53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是JavaScript的执行上下文的概念:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/434b00d5361fd94551636dafd59288b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9z1WZPXeXPyV1m_r.jpg"/></div></div></figure><p id="80df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，这是react的渲染阶段(你可以认为React有自己的执行上下文):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/0a750ee65f53c6771ee946ce60b9d04d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQh4-PZLtwwLZrf-iO3ftQ.jpeg"/></div></div></figure><p id="5903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说完这些，我们再来看看我们对<code class="fe lw lx ly lz b">setCollapsed</code>的调用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/cce7c763ffbc12c4a5927d6a2d67cfac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/0*oeHaEgM-EED2b6Q0.jpg"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/20bb46ab3db25f26a6b4de9bcf855025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/0*oldnY3PDf_QIFXnX.jpg"/></div></figure><p id="77a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这都发生在同一个渲染阶段，所以这就是为什么<em class="lv">折叠的</em>仍然是<code class="fe lw lx ly lz b">true</code>并且<code class="fe lw lx ly lz b">person</code>被作为<code class="fe lw lx ly lz b">null</code>传递。当整个组件重新呈现时，下一个呈现阶段的值将代表上一个阶段的值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/27bb9d3dd0cefd660440adbf00d0237b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_N8aID4h8SI9KTsYAx73MQ.jpeg"/></div></div></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="a02f" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">结论</h1><p id="bf11" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">这篇文章到此结束！我希望你觉得这很有价值。以后多找找。</p></div></div>    
</body>
</html>