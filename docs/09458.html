<html>
<head>
<title>Secure Your Kubernetes Cluster With Seccomp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Seccomp保护您的Kubernetes集群</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/secure-your-kubernetes-cluster-with-seccomp-9403ecf831b2?source=collection_archive---------2-----------------------#2021-08-27">https://betterprogramming.pub/secure-your-kubernetes-cluster-with-seccomp-9403ecf831b2?source=collection_archive---------2-----------------------#2021-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e54a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在容器的系统调用中应用最小特权原则的实践指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ec645bb79b60c0cc67008c14bf96b0db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cWqlV_okB1RU8cyz"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mattartz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马特·阿特兹</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="15f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes已经在那里存在了一段时间，从那以后，它在技术爱好者和严肃的企业中非常受欢迎。虽然它试图改善我们部署和运行应用程序的方式，这本身就是一个巨大的飞跃，但它是一项相对较新的技术，正在逐步走向成熟。Kubernetes一直特别关注安全性，我们有多种方法可以解决这个问题。一种这样的方法是使用Seccomp。</p><p id="5004" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Seccomp代表安全计算，是从2.6.12版开始的标准Linux内核特性。它允许您使用syscall过滤器来限制特定进程的权限，只允许它进行系统调用。</p><p id="ae42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们想要减少容器的攻击面时，这是特别有用的。例如，如果一个容器只呈现静态网页，那么它就不需要拥有对文件系统的写访问权。同样，大多数容器不需要访问诸如重新启动或更改系统配置之类的命令。</p><p id="b6c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将多个功能整理到Seccomp配置文件中，并将该配置文件应用到您的流程中。像Docker这样的容器运行时默认使用这个特性，并提供适用于它运行的每个容器的<code class="fe lv lw lx ly b">RuntimeDefault</code> seccomp策略。然而，当我们运行Kubernetes时，它用不限制任何系统调用的<code class="fe lv lw lx ly b">Unconfined</code>替换了默认的seccomp配置文件。</p><p id="b1cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这是一个网络罪犯可以利用的安全漏洞。因此，Kubernetes允许我们从1.19版开始使用Seccomp。Kubernetes 1.22版上的一些alpha特性使我们能够在Kubernetes集群的所有工作负载上默认应用sec comp策略，我们也将在本教程中探讨这些特性。</p><h1 id="a9cb" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">先决条件</h1><p id="3f2f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在这个练习中，您需要一台安装了Docker CE和KinD的Linux机器。您还需要分叉<a class="ae ky" href="https://github.com/bharatmicrosystems/seccomp-k8s" rel="noopener ugc nofollow" target="_blank">这个</a>存储库并将&amp; cd克隆到其中。</p><h1 id="c24a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">引导没有默认Seccomp配置文件的Kubernetes集群</h1><p id="ad5b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">由于默认的Seccomp策略是一个alpha特性，仅在Kubernetes v1.22及更高版本中可用，所以我们没有默认启用它。您可以通过在kubelet CLI中提供<code class="fe lv lw lx ly b">feature-gates=SeccompDefault=true</code>和<code class="fe lv lw lx ly b">seccomp-default</code>标志或者在kubelet配置文件中设置它们来启用该特性。</p><p id="b5f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们首先使用不带标志的KinD引导一个Kubernetes集群。</p><p id="fd03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将使用下面的<code class="fe lv lw lx ly b">kind-config.yaml</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c9ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们使用配置文件创建一个KinD集群:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/a229417f2eb8dbc0a67bd492b8a12c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vz3VXpTT4l3fJUhav6rV1w.gif"/></div></div></figure><p id="6fed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经创建了一个Docker映像，列出了所有被阻塞的系统调用。因此，我们将使用该图像创建一个pod，它将告诉我们哪个seccomp配置文件应用于我们的工作负载。让我们现在就开始吧:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/62f7479a0579e94f2a0c296efc59dfb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*O3UqBTKNCSN3YD7VJIBI1A.gif"/></div></div></figure><p id="7098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，Seccomp对于该群集是禁用的。那是因为我们没有设置正确的标志。</p><p id="2d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们继续创建一个设置了标志的集群。</p><h1 id="5c16" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">使用默认Seccomp配置文件引导Kubernetes集群</h1><p id="8e91" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">现在，让我们创建以下类型的配置文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2c08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个yaml文件中，我们有几个不同的部分。我们包含了一个<code class="fe lv lw lx ly b">featureFlags</code>部分，其中<code class="fe lv lw lx ly b">SeccompDefault</code>被设置为<code class="fe lv lw lx ly b">true</code>。这将在该集群中启用<code class="fe lv lw lx ly b">SeccompDefault</code>配置文件。我们还需要显式地将标志应用于特定的节点，所以我们添加了<code class="fe lv lw lx ly b">kubeadmConfigPatches</code>，在两个节点上将<code class="fe lv lw lx ly b">kubeletExtraArgs </code> — <code class="fe lv lw lx ly b"> seccomp-default</code>设置为<code class="fe lv lw lx ly b">true</code>，将<code class="fe lv lw lx ly b">feature-gates</code>设置为<code class="fe lv lw lx ly b">SeccompDefault=true</code>。这也意味着我们可以在特定的节点上应用这个特性，并根据我们的需要使用<code class="fe lv lw lx ly b">nodeAffinity</code>在节点上调度pod。</p><p id="f4fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们删除旧群集，并使用所需的配置创建一个新群集:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/bc8182826a2161ef74b83281ae78f023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EE5vfMNxetvE8HcqPSMweQ.gif"/></div></div></figure><p id="5071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们看到的，这一次，Seccomp被设置为过滤。这意味着Seccomp默认应用于所有容器。</p><p id="304e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认设置是不错的开始，但是它们可能不足以满足您的安全需求。要解决这个问题，您还可以实现自定义的Seccomp配置文件。让我们在下一节看看这些。</p><h1 id="1c31" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">实施自定义Seccomp配置文件</h1><p id="f1c0" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">要实现自定义的seccomp配置文件，您必须创建一些配置文件。我们将创建三个概要文件供我们使用— <code class="fe lv lw lx ly b"> audit.json</code>、<code class="fe lv lw lx ly b">violation.json</code>和<code class="fe lv lw lx ly b">fine-grained.json</code>。</p><p id="6350" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们先来看<code class="fe lv lw lx ly b">audit.json</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6df0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这包含一个简单的设置为<code class="fe lv lw lx ly b">SCMP_ACT_LOG</code>的<code class="fe lv lw lx ly b">defaultAction</code>属性。这意味着它将审核对Syslog文件的所有系统调用。当我们在创建一个细粒度的概要文件之前理解什么样的系统调用是应用程序所必需的时，这个策略是有益的。</p><p id="4ca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们看看violation.json文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ccc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该文件包含设置为<code class="fe lv lw lx ly b">SCMP_ACT_ERRNO</code>的<code class="fe lv lw lx ly b">defaultAction</code>属性。它将拒绝所有的系统调用，因此，虽然它适合于演示目的，但在实际场景中它不会工作。</p><p id="a7ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在系统调用上实现最小特权原则的整个思想是通过使用细粒度的策略，该策略包含我们的应用程序需要的系统调用并阻塞其余的系统调用。那么，让我们看看下面的<code class="fe lv lw lx ly b">file-grained.json</code>政策文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="668c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该文件包含一个设置为<code class="fe lv lw lx ly b">SCMP_ACT_ERRNO</code>的<code class="fe lv lw lx ly b">defaultAction</code>，这意味着它将默认拒绝所有呼叫。然后我们定义需要允许的<code class="fe lv lw lx ly b">syscalls</code>，并将动作设置为<code class="fe lv lw lx ly b">SCMP_ACT_ALLOW</code>。这意味着该配置文件将阻止除允许列表中的系统调用之外的所有系统调用。</p><p id="5a94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，事不宜迟，让我们创建一个新的集群并测试它。</p><h1 id="9ff2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">使用自定义Seccomp配置文件引导Kubernetes集群</h1><p id="3a6e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">为此，我们将创建以下类型的配置文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="50c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个文件与上一个非常相似，除了它包含一个<code class="fe lv lw lx ly b">extraMounts</code>部分，该部分将<code class="fe lv lw lx ly b">profiles</code>目录挂载到每个Kubernetes节点上的<code class="fe lv lw lx ly b">/var/lib/kubelet/seccomp/profiles</code>。这将允许我们在我们的吊舱中使用这些配置文件。</p><p id="11d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们删除旧集群并创建一个新集群:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/90398d0a525f9f970969105eb6a00792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0E49ttkSG3tVjEZVKmUl7g.gif"/></div></div></figure><p id="ced2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，随着集群的创建，让我们一次使用一个概要文件。让我们创建一个使用审计配置文件的pod。</p><h2 id="65d7" class="na ma it bd mb nb nc dn mf nd ne dp mj li nf ng ml lm nh ni mn lq nj nk mp nl bi translated">审计模式</h2><p id="b75f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们将为此创建以下<code class="fe lv lw lx ly b">audit-mode.yaml</code> pod清单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们部署了<code class="fe lv lw lx ly b">nginx</code>映像并使用了<code class="fe lv lw lx ly b">localhostProfile</code> — <code class="fe lv lw lx ly b">profiles/audit.json</code>。</p><p id="8ffb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们应用这个yaml，看看我们得到了什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/64acd724c4907642b85f01194a21e528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Y_YRtAwyzG1m1rvma7YkOA.gif"/></div></div></figure><p id="e9e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到pod正在运行，现在我们可以测试pod了。</p><p id="a75d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将执行以下操作:</p><ul class=""><li id="e724" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">将pod公开为一个<code class="fe lv lw lx ly b">NodePort</code>服务。</li><li id="ba2a" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">获取服务的<code class="fe lv lw lx ly b">NodePort</code>。</li><li id="4be3" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">获取其中一个KinD节点的docker容器id。</li><li id="d354" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">使用<code class="fe lv lw lx ly b">localhost:&lt;NodePort&gt;</code>上的<code class="fe lv lw lx ly b">curl</code>点击服务。</li><li id="f83e" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">在一个重复的终端中结束本地主机中的<code class="fe lv lw lx ly b">/var/log/syslog</code>文件。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/b80a0dfefdfa16ffdb57745627a963da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*My31UX3vKABun1sqgL2CQA.gif"/></div></div></figure><p id="001f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，当我们进行调用时，我们会在Syslog中看到许多审核事件。这就是审计模式的作用。让我们看看如果使用违规模式会发生什么。</p><h2 id="521a" class="na ma it bd mb nb nc dn mf nd ne dp mj li nf ng ml lm nh ni mn lq nj nk mp nl bi translated">违规模式</h2><p id="9769" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">这次我们将使用以下<code class="fe lv lw lx ly b">violation-mode.yaml</code> pod清单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它与<code class="fe lv lw lx ly b">audit-mode.yaml</code>非常相似，但这里我们使用的是<code class="fe lv lw lx ly b">localhostProfile</code> — <code class="fe lv lw lx ly b">profiles/violation.json</code>。</p><p id="0a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们应用yaml，看看我们会得到什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/83c4cdd6889483158be1c0447e684510.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/1*5Wq95k2UgnAKzP7ls1UYWQ.gif"/></div></figure><p id="bb3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而这一次，吊舱在<code class="fe lv lw lx ly b">CrashLoopBackoff</code>。同样，这是因为容器无法启动，因为我们已经限制了所有的系统调用。现在，让我们来看一个细粒度的策略。</p><h2 id="f04e" class="na ma it bd mb nb nc dn mf nd ne dp mj li nf ng ml lm nh ni mn lq nj nk mp nl bi translated">自定义模式</h2><p id="978b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在这种模式下，我们将允许NGINX需要运行的所有系统调用，但我们将有目的地限制其中一个，以便我们可以测试它。为此，我们使用下面的<code class="fe lv lw lx ly b">custom-mode.yaml</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4437" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个yaml用的是<code class="fe lv lw lx ly b">localhostProfile</code> — <code class="fe lv lw lx ly b"> profiles/fine-grained.json</code>。所以让我们应用它，看看我们得到了什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/ffdeb1717cef88d90f85ef2ebf062745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RuFaFNWjnsNQeHuq6QeUNw.gif"/></div></div></figure><p id="e334" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这导致了一个错误。当我们查看日志时，它不能统计一个共享对象，因为不允许该操作。这是因为我们还没有明确提供该策略。</p><h1 id="08d3" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="5843" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">Kubernetes允许Seccomp进入产品是一个受欢迎的变化，从安全角度来看非常有帮助。我们只是在等待这个特性从alpha到beta，最后到GA。如果您想在生产中使用这个特性，因为这个特性是在alpha中，请小心操作，一次滚动一个节点，以确保不会破坏任何东西。</p><p id="016b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望你喜欢这篇文章！</p></div></div>    
</body>
</html>