<html>
<head>
<title>A Step-by-Step Guide to Tuning a Model on Google Cloud’s Vertex AI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在谷歌云的顶点人工智能上调整模型的一步一步的指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-step-by-step-guide-to-tune-a-model-on-google-clouds-vertex-ai-afd2e72af595?source=collection_archive---------3-----------------------#2021-06-10">https://betterprogramming.pub/a-step-by-step-guide-to-tune-a-model-on-google-clouds-vertex-ai-afd2e72af595?source=collection_archive---------3-----------------------#2021-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a5aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">调整模型超参数，并在托管张量板上可视化度量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/7f24184c590a836fd8c2242d7b8f420d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*aeXlwnOS3DvVHiMVgBZbpQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">顶点AI(来源:<a class="ae ku" href="https://cloud.google.com/vertex-ai" rel="noopener ugc nofollow" target="_blank">谷歌云</a>)</p></figure><h1 id="5a9e" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">顶点AI教程系列</h1><ol class=""><li id="9145" class="ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/a-step-by-step-guide-to-train-a-model-on-google-clouds-vertex-ai-47faafae1330">在谷歌云的顶点人工智能上训练模型的逐步指南</a></li><li id="3437" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated">在Google Cloud的Vertex AI上调优模型的分步指南(本文)</li><li id="053e" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-operationalize-a-model-on-google-clouds-vertex-ai-53298b530703">如何在谷歌云的顶点人工智能上操作一个模型</a></li><li id="8e7c" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-automl-on-google-clouds-vertex-ai-27f8778239ea">如何在Google Cloud的Vertex AI上使用AutoML</a></li><li id="fe06" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-bigquery-ml-on-google-clouds-vertex-ai-23b1ca0b635">如何在Google Cloud的Vertex AI上使用big query ML</a></li><li id="02a5" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-pipeline-on-google-clouds-vertex-ai-863b429c811f">如何在Google Cloud的Vertex AI上使用Pipeline</a></li></ol><h1 id="44c3" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">B <strong class="ak">背景</strong></h1><p id="beb3" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">在之前的<a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/a-step-by-step-guide-to-train-a-model-on-google-clouds-vertex-ai-47faafae1330">文章</a>(本系列的第一篇)中，我们通过一步一步的说明，在谷歌云最新的集成机器学习平台<a class="ae ku" href="https://cloud.google.com/vertex-ai" rel="noopener ugc nofollow" target="_blank"> Vertex AI </a>上训练了第一个模型。我们正在解决的问题是针对<a class="ae ku" href="https://www.tensorflow.org/datasets/catalog/cifar10" rel="noopener ugc nofollow" target="_blank"> CIFAR10 </a>数据集的图像分类任务，该数据集包含10个类别的60，000张32x32图像。</p><p id="ff1c" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">在本文中，我们将在此基础上改进模型性能，并探索Vertex AI上的两个非常酷的工具:<a class="ae ku" href="https://cloud.google.com/vertex-ai/docs/training/hyperparameter-tuning-overview" rel="noopener ugc nofollow" target="_blank"> Hypertune </a>和<a class="ae ku" href="https://cloud.google.com/vertex-ai/docs/experiments" rel="noopener ugc nofollow" target="_blank"> Experiments </a>。</p><h1 id="7f86" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">O <strong class="ak">优化理念</strong></h1><p id="da08" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">前一篇文章中的一个观察结果是，更多时期的训练产生了更好的结果。在本地训练五个纪元时，我们得到了60%的评估准确率。用顶点AI上的15个历元，我们获得了66%的评价准确率。请注意，通常最好使用精度和召回率作为性能指标。但是我们正在处理一个完美平衡的数据集。因此，为了简单起见，我们将坚持准确性。</p><p id="f271" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">最简单也是最蛮力的想法就是多历练。我们将epoch参数设置为50，并启动了一个训练作业(参考上一篇文章了解如何操作)。不幸的是，结果令人失望。评估准确率为64%，低于15个时期训练的结果。同时，训练准确率高达93%。显然，该模型过度拟合了训练数据。所以我们需要某种正则化来推广这个模型。</p><p id="4a05" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">有许多正则化技术可用。最简单的可能是<a class="ae ku" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Dropout" rel="noopener ugc nofollow" target="_blank"> Dropout </a>，它随机关闭每个训练批次的一些神经元，试图迫使模型学习更强大的功能。我们将使用辍学来改进我们的模型。</p><h1 id="c0c8" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">超调谐</h1><p id="964f" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">现在我们已经决定使用Dropout，接下来的问题是辍学率，这是模型在每个训练批次中将关闭的神经元的百分比。辍学率是一个超参数。许多其他配置也是超参数，例如学习速率、特定层中神经元的数量、层数、激活函数等。出于演示的目的，让我们关注辍学率。为了简单起见，我们只在展平层后添加一个丢弃层。有关实现的详细信息，请参见以下代码片段。该模型与我们在上一篇文章中使用的模型相同。这里唯一添加的元素是Dropout层。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">超调谐码</p></figure><p id="bcfb" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">如你所见，辍学率被设计成一个我们可以传递给培训工作的论据。我们的目标是找到产生最高验证准确性的最佳退出率。显然，您可以通过启动多个培训工作来手动改变辍学率，使其符合您的最佳猜测。但是，当你可以依靠自动化时，为什么要做一些重复和无聊的事情呢？</p><p id="5925" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">Hypertune是来救援的。它就是这样做的——它从我们指定的范围启动多个具有各种超参数值(在我们的例子中是辍学率)的训练任务。Hypertune监控我们需要公开的模型性能指标，并在允许的空间中搜索以最大化指标。Hypertune支持典型的搜索算法，默认为<a class="ae ku" href="https://en.wikipedia.org/wiki/Bayesian_optimization" rel="noopener ugc nofollow" target="_blank">贝叶斯超参数优化</a>。</p><p id="6042" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">回到代码，我们已经参数化了辍学率。现在我们需要更新模型来公开度量。我们使用的衡量标准是验证准确性，在每个时期结束时根据验证数据集进行计算。我们将使用自定义Tensorflow回调来实现指标报告，该回调调用<a class="ae ku" href="https://github.com/GoogleCloudPlatform/cloudml-hypertune" rel="noopener ugc nofollow" target="_blank"> Hypertune </a> Python库来报告指标。Hypertune库本质上只是将一些结构化格式的指标转储到主机上的一个临时文件夹中，Hypertune服务将获取这些数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">超调度量代码</p></figure><p id="7c61" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">注意，我们故意忽略了检查点部分，这样我们就不需要为不同的调优试验安排不同的Google云存储文件夹。如果我们不幸获得了主机抢占权，那就这样吧。只是从头开始那个特殊的训练试验需要多一点时间。</p><p id="eac1" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">现在我们准备启动超参数调优工作。与上一篇文章类似，我们将使用<code class="fe ne nf ng nh b">gcloud</code>命令行工具。</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="3425" class="nm kw it nh b gy nn no l np nq">gcloud beta ai hp-tuning-jobs create \<br/>--display-name=e2e-tutorial-hpt --region=us-central1 \<br/>--config=hpt.yaml --max-trial-count=10 \<br/>--parallel-trial-count=2</span></pre><p id="08e4" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">命令参数都是不言自明的。肉在配置文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">超调配置</p></figure><p id="f459" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated"><code class="fe ne nf ng nh b">trialJobSepc</code>下的<code class="fe ne nf ng nh b">workerPoolSpec</code>与我们在上一篇文章中用于启动培训作业的配置相同。这里新添加的字段是<code class="fe ne nf ng nh b">studySpec</code>，它包含目标指标和相关超参数的搜索空间。</p><p id="1574" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated"><code class="fe ne nf ng nh b">hp-tuning-jobs create</code>命令将返回一个作业ID，我们可以用它来查询超参数调优状态。</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="4257" class="nm kw it nh b gy nn no l np nq">gcloud beta ai hp-tuning-jobs describe JOB_ID --region=us-central1</span></pre><p id="3b02" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">我们也可以访问UI上的调优工作。进入顶点AI -&gt;训练-&gt;超参数调优，点击调优作业查看详情。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/80220a594dc619ece3dec3558f0fd113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NdngSErL_fVyFLxqk4qH3g.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">超调结果</p></figure><p id="c6f5" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">看起来它已经完成了，0.45的退出率产生了最高的验证准确性。</p><h1 id="5f61" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">Exp <strong class="ak"> eriment(托管Tensorboard) </strong></h1><p id="4fdb" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">我们可以从超参数调优工作中获得最高验证准确性的模型，然后就到此为止。但是我们想尝试实验功能。因此，我们将用最佳辍学率对模型进行最后一次训练，并连接实验工具(managed Tensorboard)来可视化实时模型训练。</p><p id="8a57" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">要使用Experiment，我们首先应该创建一个Tensorboard实例。</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="d96e" class="nm kw it nh b gy nn no l np nq">gcloud beta ai tensorboards create \<br/>--display-name=e2e-tutorial-viz --region=us-central1</span></pre><p id="848a" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">我们可以看到一个Tensorboard实例是通过UI创建的:Vertex AI-&gt; Experiments-&gt; tensor board Instances。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nw"><img src="../Images/e80b8a3585eb4eafd9d2724a8541b58b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bargMobltdNYhUbsDIT58A.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">Tensorboard实例</p></figure><p id="8271" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">接下来，我们将在模型训练中添加一个Tensorboard回调，以便它导出Tensorboard可视化所需的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">Tensorboard度量代码</p></figure><p id="c51e" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">这里涉及到一个<code class="fe ne nf ng nh b">AIP_TENSORBOARD_LOG_DIR</code>环境变量，我们将在后面解释。</p><p id="d608" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">在启动培训工作之前还有一件事:我们需要创建一个服务帐户，并为Tensorboard可视化配置其权限。你可以按照这个<a class="ae ku" href="https://cloud.google.com/vertex-ai/docs/experiments/tensorboard-training#create_a_service_account_with_required_permissions" rel="noopener ugc nofollow" target="_blank">链接</a>来设置。我知道我在第一篇文章中说过，我会尽量让文章保持独立。但是这种权限设置是非常机械的，指令都在一个地方，所以我觉得没有必要复制它们。</p><p id="ecdf" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">现在我们可以开始培训工作了。这次我们不使用<code class="fe ne nf ng nh b">gcloud</code>命令，而是直接发送一个curl请求，这就是<code class="fe ne nf ng nh b">gcloud</code>命令的功能。这是因为在<code class="fe ne nf ng nh b">gcloud</code>命令中似乎有一个参数解析错误，阻止了为Tensorboard可视化创建训练作业。</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="6785" class="nm kw it nh b gy nn no l np nq">curl -H "Authorization: Bearer $(gcloud auth print-access-token)" \<br/>-H "Content-Type: application/json" \<br/>-X POST -d @request.json \<br/>https://us-central1-aiplatform.googleapis.com/v1beta1/projects/PROJECT_NAME/locations/us-central1/customJobs</span></pre><p id="9234" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">这里的核心内容在<code class="fe ne nf ng nh b">request.json</code>文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">张量板请求</p></figure><p id="97ce" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">有几点需要注意:首先，<code class="fe ne nf ng nh b">GCS_PATH_FOR_PYTHON_CODE</code>是我们的Python包发行版所在的地方。关于我们如何在Google云存储中打包和存储训练代码，请参考第一篇文章。其次，<code class="fe ne nf ng nh b">GCS_PATH_FOR_TENSORBOARD_LOG</code>是Tensorboard日志的Google云存储位置。训练主机将前面提到的<code class="fe ne nf ng nh b">AIP_TENSORBOARD_LOG_DIR</code>环境变量设置为<code class="fe ne nf ng nh b">GCS_PATH_FOR_TENSORBOARD_LOG</code>的值，这样就可以在我们的训练代码中访问它。第三，<code class="fe ne nf ng nh b">SERVICE_ACCOUNT_FROM_THE_PERMISSION_STEP</code>是您按照前面提到的权限设置创建的服务帐户。最后，<code class="fe ne nf ng nh b">FULL_RESOURCE_NAME_OF_TENSORBOARD</code>是Tensorboard实例的完整资源名，我们可以通过以下命令获得:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="42ab" class="nm kw it nh b gy nn no l np nq">gcloud beta ai tensorboards list --region=us-central1</span></pre><p id="0b51" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">现在我们都准备好了。只需等待训练作业开始，然后导航到UI:Vertex AI-&gt; Experiments-&gt; Experiments并单击Open Tensorboard按钮，这将在一个新选项卡上打开我们训练作业的Tensorboard可视化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nx"><img src="../Images/58a02f276d52116a7db3f04dc2af8210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BovauMZawh-k-KEocuvpQw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">张量板输入</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi ny"><img src="../Images/625b42a503144d527e2b4ab751a0fb37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TI1Gjq8ruRzj0g_qY1vHdA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">张量板可视化</p></figure><h1 id="bfd9" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated"><strong class="ak"> Wra </strong> p Up</h1><p id="f110" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">最后，让我们在测试数据集上评估模型(代码在第一篇文章中)。评估准确率为74%。从最初的60%开始，我们已经走了很长一段路。显然，仍有改进的余地。但这次旅程很好地为我们展示了Vertex AI在训练定制模型方面的能力。我们将在此稍作休息，并在本系列的下一集继续讨论。</p></div></div>    
</body>
</html>