<html>
<head>
<title>Visualizing the Rates of Change in a Codebase Over Time With git-log(1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用git-log可视化代码库随时间的变化率(1)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/visualizing-rates-of-change-in-testbase-vs-codebase-over-time-with-git-log-1-118e0c37d455?source=collection_archive---------8-----------------------#2020-05-22">https://betterprogramming.pub/visualizing-rates-of-change-in-testbase-vs-codebase-over-time-with-git-log-1-118e0c37d455?source=collection_archive---------8-----------------------#2020-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3a6e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">查看您的代码和测试覆盖率在您的代码库的生命周期中是如何变化的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f6097c25c8962175fb566fff7d0fb876.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y1lhnbGLmGph-1fDjp29Uw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片:<a class="ae kv" href="https://unsplash.com/@jeremybishop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰里米·毕晓普</a></p></figure><p id="3784" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我最近提出的关于哪些度量在软件质量保证中有用的建议的反应，我感到很惊讶:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我认为更多的人知道如何查看他们的测试代码相对于他们的应用程序代码的变化率</p></figure><p id="a349" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我很惊讶，这么多人看到上面的推文，马上问怎么在第一时间进行测量。</p><p id="a774" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道<a class="ae kv" href="https://medium.com/better-programming/measuring-the-cadence-of-commits-in-git-history-ed58590a3b0e" rel="noopener">测量Git </a>中的变化率不是通才软件工程师通常执行的活动。但是我已经假设在专业软件测试社区中有比表面上存在的更高的熟悉程度。这尤其有趣，因为许多人对这一指标感兴趣，并直觉地被它所吸引——他们只是不知道如何得到它。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="b401" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">用<code class="fe mt mu mv mw b">git-log(1)</code>比较两个目录的变化率</h1><p id="43c9" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">通常，软件应用程序的源代码是这样布局的，单个顶级目录包含所有应用程序代码(<em class="nc">代码库</em>)，另一个顶级目录包含所有自动化测试代码和脚手架(<em class="nc">测试库</em>)。(如果你的项目不是这样设计的，请继续读下去，我会告诉你如何解决这个问题。如果你不耐烦的话，也可以直接滚动到文章的底部。)</p><p id="277c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，想象一个Git存储库，其中所有的代码库都在目录<code class="fe mt mu mv mw b">app/</code>中，测试库在目录<code class="fe mt mu mv mw b">test/</code>中。</p><p id="b178" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，Git回购看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/7e1c747c7d92cd93098407330d3fa269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ccmzrlkPlCWBl2n9szzS3A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Git repo的布局使得代码库和测试库位于不同的顶级目录中</p></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="6b4e" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">将git-log(1)输出转换为时间序列</h1><p id="138f" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">这里首先要知道的是<code class="fe mt mu mv mw b">git-log(1)</code>可以将文件系统路径作为参数。因此，您将从命令<code class="fe mt mu mv mw b">git log app</code>和命令<code class="fe mt mu mv mw b">git log test</code>获得不同的输出(如果是在Git repo根中发出的，如上图截图所示)。</p><p id="01db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，<code class="fe mt mu mv mw b">git-log(1)</code>的默认输出不是<a class="ae kv" href="https://www.investopedia.com/terms/t/timeseries.asp" rel="noopener ugc nofollow" target="_blank">时间序列</a>。</p><p id="d783" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个将<code class="fe mt mu mv mw b">git-log(1)</code>的输出转换成时间序列的脚本。该脚本将为<code class="fe mt mu mv mw b">app</code>目录生成一个时间序列，并为<code class="fe mt mu mv mw b">test</code>目录生成另一个时间序列:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne lt l"/></div></figure><p id="a0a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，输出如下所示:</p><pre class="kg kh ki kj gt nf mw ng nh aw ni bi"><span id="bac9" class="nj mc iq mw b gy nk nl l nm nn">app/<br/>      1 2020-02-27<br/>      1 2020-03-03<br/>      2 2020-03-06<br/>      3 2020-03-11<br/>test/<br/>      1 2020-01-13<br/>      1 2020-02-12<br/>      1 2020-02-25<br/>      1 2020-03-05</span></pre><p id="1c8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似于<code class="fe mt mu mv mw b">3 2020–03–11</code>的一行表示在2020年3月3日，一整天有三个提交到这个存储库。</p><p id="00de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以向下阅读列表的左侧，查看在初始提交之后的每一天进行了多少次提交，一直到Git存储库的<a class="ae kv" href="https://web.archive.org/web/20200429004214/https://help.github.com/en/github/administering-a-repository/setting-the-default-branch" rel="noopener ugc nofollow" target="_blank">默认分支</a>的<a class="ae kv" href="https://stackoverflow.com/questions/2304087/what-is-head-in-git" rel="noopener ugc nofollow" target="_blank">当前</a> <code class="fe mt mu mv mw b"><a class="ae kv" href="https://stackoverflow.com/questions/2304087/what-is-head-in-git" rel="noopener ugc nofollow" target="_blank">HEAD</a></code>的提交日期。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="f1f0" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">从时间序列中进行推断</h1><p id="fdea" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">从上面的数据可以立即推断出的一件事是代码库和测试库在不同的日子提交。源代码中存在这种模式在实际项目中是一种<em class="nc">高信号观察</em> <strong class="ky ir"> </strong>，因为理想情况下，应用程序代码及其支持测试代码应该随着功能的增加和修改而一起改变。</p><p id="72c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的shell脚本被配置为只查看最近三周的数据。在<a class="ae kv" href="https://codeascraft.com/2011/04/20/divide-and-concur/" rel="noopener ugc nofollow" target="_blank">十年的持续集成实践中，</a>我发现3周/21天是一个足够宽的时间窗口，在这个时间窗口中可以观察到Git历史中的趋势，而不会引入大量来自旧的和不相关的源代码更改的噪音。</p><p id="3704" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过编辑上面的shell脚本的第8行来将时间窗口从三周更改为您想要的任何时间。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="560c" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">比较两个任意文件集的更改率</h1><p id="4f0b" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">在本文的开头，我承认并不是每个人的项目都被安排在codebase和testbase顶级目录结构中。</p><p id="f08b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，无论代码库和测试库是如何布局的，您都可以通过使用<code class="fe mt mu mv mw b"><a class="ae kv" href="https://en.wikipedia.org/wiki/Find_(Unix)" rel="noopener ugc nofollow" target="_blank">find(1)</a></code>过滤您的源代码树来可视化两个不同文件集的Git历史——都是<em class="nc">文件集</em>。这是因为<code class="fe mt mu mv mw b">git-log(1)</code>可以接受多个路径作为参数。</p><p id="072f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以只需要使用<code class="fe mt mu mv mw b">find(1)</code>来创建两个路径集合:一个用于代码库，一个用于测试库。</p><p id="b7c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果您的测试文件与代码文件并排存储，那么您可以使用<code class="fe mt mu mv mw b">find(1)</code>提取测试文件的路径，如下面的shell脚本所示。在这个例子中，我假设所有的测试文件名都以<code class="fe mt mu mv mw b">Test.php</code>结尾，所以所有的测试文件都以类似<code class="fe mt mu mv mw b">exampleTest.php</code>的名字命名。</p><p id="02c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是如何找到所有以<code class="fe mt mu mv mw b">Test.php</code>结尾的文件，而不管该文件在Git存储库的文件系统中的位置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne lt l"/></div></figure><p id="b437" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将产生类似于上面显示的输出，除了在这种情况下只显示测试库的历史:</p><pre class="kg kh ki kj gt nf mw ng nh aw ni bi"><span id="117c" class="nj mc iq mw b gy nk nl l nm nn">      1 2020-01-13<br/>      3 2020-02-12<br/>      1 2020-02-25<br/>      1 2020-03-05</span></pre><p id="ce60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和以前一样，这个时间序列表示在过去三周内提交给所有<code class="fe mt mu mv mw b">Test.php</code>文件的<strong class="ky ir"> </strong>的总数。通过将<a class="ae kv" href="https://gist.github.com/textarcana/02e4b689ba7a1774a135ba13674d847e#file-find_files_for_git_log-sh-L4" rel="noopener ugc nofollow" target="_blank">行4 </a>上的<code class="fe mt mu mv mw b">--since</code>参数更改为三周前以外的某个日期，您可以将时间窗口更改为您想要的任意值<a class="ae kv" href="https://git-scm.com/docs/git-log#Documentation/git-log.txt---sinceltdategt" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="6b9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们把代码库的历史打印出来，这样就可以和测试库的历史进行比较。</p><p id="0b0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您的所有应用程序文件都有一个通用的扩展名，比如说<code class="fe mt mu mv mw b">.php</code>，那么您可以使用<code class="fe mt mu mv mw b">find(1)</code>收集所有代码库文件(所有可能被测试的文件)的路径，如下所示:</p><pre class="kg kh ki kj gt nf mw ng nh aw ni bi"><span id="6aa6" class="nj mc iq mw b gy nk nl l nm nn">find . -name "*.php" -not -name "*Test.php"</span></pre><p id="ab19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将打印出以<code class="fe mt mu mv mw b">.php</code>结尾的所有文件的列表，除了以<code class="fe mt mu mv mw b">Test.php</code>结尾的文件，这些文件将从列表中省略。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne lt l"/></div></figure><p id="f20b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与我们用来查看testbase文件的脚本一样，该脚本将生成一个时间序列，显示对代码库文件进行提交的日期，如下所示:</p><pre class="kg kh ki kj gt nf mw ng nh aw ni bi"><span id="760f" class="nj mc iq mw b gy nk nl l nm nn">      1 2020-01-13<br/>      1 2020-02-12<br/>      1 2020-02-25<br/>      1 2020-03-05</span></pre><p id="b4ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论您的代码库是如何布局的，您都可以使用<code class="fe mt mu mv mw b">find(1)</code>来收集您的代码库和测试库文件的路径，这样您就可以将这些路径传递到<code class="fe mt mu mv mw b">git-log(1)</code>中并比较这两个历史！</p></div></div>    
</body>
</html>