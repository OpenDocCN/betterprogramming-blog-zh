<html>
<head>
<title>Persist Filtering Logic With Swift Combine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过快速组合保持过滤逻辑</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/persist-filtering-logics-with-swift-combine-6c3594be77cc?source=collection_archive---------5-----------------------#2020-01-12">https://betterprogramming.pub/persist-filtering-logics-with-swift-combine-6c3594be77cc?source=collection_archive---------5-----------------------#2020-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="39b2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数据驱动联合收割机</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/c56dabf7c2495f791a11f86d38e2c324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*VRAcUdNgdsBhrdJWhClutg.png"/></div></figure><p id="6ad0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在<a class="ae lm" href="https://medium.com/@kevinminority/persist-business-logic-with-swift-combine-519efb3a7e37" rel="noopener">上一集</a>中，我们成功地模拟了一个值流，并为每个值附加了一个简单的操作符(<code class="fe ln lo lp lq b">delay</code>)。</p><p id="3f70" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在本文中，我们将研究更多的操作符，将它们命名为<code class="fe ln lo lp lq b">Codeable</code>，并最终在运行时将它们翻译成Combine publisher。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="3512" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">运算符的类型</h1><p id="77d2" class="pw-post-body-paragraph kq kr it ks b kt mq ju kv kw mr jx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated">在我们开始对操作符建模之前，我们需要了解有多少种操作符。</p><p id="0622" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">ReactiveX网站将其大致分为10种类型:创建、转换、过滤、合并、错误处理、实用、条件、数学/聚合、背压、可连接-可观察和运算符-转换可观察。如果您感兴趣，ReactiveX对每种类型和操作符都有很好的解释。</p><p id="b051" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">注:</strong>如果不熟悉RxSwift，RxSwift中的<a class="ae lm" href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md" rel="noopener ugc nofollow" target="_blank">可观察</a>相当于Combine中的<a class="ae lm" href="https://developer.apple.com/documentation/combine/publisher" rel="noopener ugc nofollow" target="_blank">发布者</a>。</p><p id="60e4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在前一篇文章中，我们提到了<code class="fe ln lo lp lq b">delay</code>操作符，它属于<code class="fe ln lo lp lq b">utility</code>类型。今天我们将重点关注在<code class="fe ln lo lp lq b">filtering</code>类型中保持两个操作符。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="2fc8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">过滤运算符</h1><p id="3291" class="pw-post-body-paragraph kq kr it ks b kt mq ju kv kw mr jx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated">这种类型的操作符根据给定的条件，删除所有或部分(或不删除)向下游发送的流项目。</p><h2 id="7e4c" class="mv lz it bd ma mw mx dn me my mz dp mi kz na nb mk ld nc nd mm lh ne nf mo ng bi translated">下降优先</h2><p id="2b3f" class="pw-post-body-paragraph kq kr it ks b kt mq ju kv kw mr jx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated"><code class="fe ln lo lp lq b">dropFirst</code>停止顶部<em class="nh"> n </em>项目的发射。考虑到简单性，我们可以将它添加到我们的<code class="fe ln lo lp lq b">Operator</code>枚举中。</p><pre class="kj kk kl km gt ni lq nj nk aw nl bi"><span id="ee9f" class="mv lz it lq b gy nm nn l no np"><strong class="lq iu">enum</strong> Operator {<br/>  <strong class="lq iu">case</strong> delay(seconds: Double)<br/>  <strong class="lq iu">case</strong> <strong class="lq iu">dropFirst</strong>(count: Int)<br/>}</span></pre><p id="3a94" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们也可以很容易地将这个enum case转换成Publisher。</p><pre class="kj kk kl km gt ni lq nj nk aw nl bi"><span id="779a" class="mv lz it lq b gy nm nn l no np"><strong class="lq iu">extension</strong> Operator {<strong class="lq iu">func</strong> applyPublisher&lt;T&gt;(<strong class="lq iu">_</strong> publisher: AnyPublisher&lt;T, Never&gt;) -&gt; AnyPublisher&lt;T, Never&gt; {<strong class="lq iu">  <br/>switch</strong> <strong class="lq iu">self</strong> {<br/><strong class="lq iu">    case</strong> .dropFirst(<strong class="lq iu">let</strong> count):<br/>        return publisher.dropFirst(count).eraseToAnyPublisher()<br/>    //skip the rest of cases<br/>  }}}</span></pre><p id="16c4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，<code class="fe ln lo lp lq b">dropFirst</code>操作符可以被持久化并显示在操作符列表中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/9b803ea2fa0b30b84bc6accdd411d80b.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/1*n-XPwpIC2WS52VlFIortwQ.gif"/></div></figure><p id="1149" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">持久化<code class="fe ln lo lp lq b">dropFirst</code>似乎类似于and <code class="fe ln lo lp lq b">delay</code>操作符。或许，过滤与实用操作符并没有太大的不同。在我们下结论之前，让我们再尝试一个操作符。</p><h2 id="4b6a" class="mv lz it bd ma mw mx dn me my mz dp mi kz na nb mk ld nc nd mm lh ne nf mo ng bi translated">过滤器</h2><p id="551f" class="pw-post-body-paragraph kq kr it ks b kt mq ju kv kw mr jx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated">与<code class="fe ln lo lp lq b">dropFirst</code>有非常基本的过滤标准不同，<code class="fe ln lo lp lq b">filter</code> <em class="nh"> </em>运算符<em class="nh"> </em>采用闭包而不是原语类型。现在，这是一个挑战。我们如何保持和分发一个闭包？</p><div class="nr ns gp gr nt nu"><a href="https://developer.apple.com/documentation/combine/publisher/3204709-filter" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">过滤器(_:)</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">重新发布与提供的闭包匹配的所有元素。</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">developer.apple.com</p></div></div></div></a></div><p id="acc3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们仔细看看<code class="fe ln lo lp lq b">filter</code>方法。</p><pre class="kj kk kl km gt ni lq nj nk aw nl bi"><span id="61e2" class="mv lz it lq b gy nm nn l no np">func filter(_ isIncluded: @escaping (Self.Output) -&gt; <a class="ae lm" href="https://developer.apple.com/documentation/swift/bool" rel="noopener ugc nofollow" target="_blank">Bool</a>) -&gt; <a class="ae lm" href="https://developer.apple.com/documentation/combine/publishers" rel="noopener ugc nofollow" target="_blank">Publishers</a>.<a class="ae lm" href="https://developer.apple.com/documentation/combine/publishers/filter" rel="noopener ugc nofollow" target="_blank">Filter</a>&lt;Self&gt;</span></pre><p id="dca0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">它的闭包<code class="fe ln lo lp lq b">isIncluded</code>采用泛型类型并返回一个布尔值。</p><p id="69d4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Foundation中有没有表示逻辑条件并返回布尔值的东西？想起什么了吗？</p><h2 id="cd50" class="mv lz it bd ma mw mx dn me my mz dp mi kz na nb mk ld nc nd mm lh ne nf mo ng bi translated">用NSPredicate筛选</h2><p id="b32d" class="pw-post-body-paragraph kq kr it ks b kt mq ju kv kw mr jx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated">答案是<code class="fe ln lo lp lq b"><a class="ae lm" href="https://developer.apple.com/documentation/foundation/nspredicate" rel="noopener ugc nofollow" target="_blank">NSPredicate</a></code>。如果我们可以将过滤条件作为字符串格式的表达式持久化，我们可以简单地传递流值并使用<code class="fe ln lo lp lq b">NSPredicate</code>来评估结果。</p><p id="d451" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们继续将<code class="fe ln lo lp lq b">filter</code>添加到枚举中。</p><pre class="kj kk kl km gt ni lq nj nk aw nl bi"><span id="e0eb" class="mv lz it lq b gy nm nn l no np"><strong class="lq iu">enum</strong> Operator {<br/>  <strong class="lq iu">case</strong> delay(seconds: Double)<br/>  <strong class="lq iu">case</strong> dropFirst(count: Int)<br/>  <strong class="lq iu">case</strong> <strong class="lq iu">filter</strong>(expression: String)<br/>}</span></pre><p id="dd6a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里我们需要的只是过滤像<code class="fe ln lo lp lq b">%d !=3</code>或<code class="fe ln lo lp lq b">%@ != “D”</code>这样的表达式；因此，<code class="fe ln lo lp lq b">expression</code>是我们的关联类型。同样，我们需要能够将<code class="fe ln lo lp lq b">filter</code>枚举移动到Publisher中。</p><pre class="kj kk kl km gt ni lq nj nk aw nl bi"><span id="8ce3" class="mv lz it lq b gy nm nn l no np"><strong class="lq iu">extension</strong> Operator {<br/><strong class="lq iu">func</strong> applyPublisher&lt;T&gt;(<strong class="lq iu">_</strong> publisher: AnyPublisher&lt;T, Never&gt;) -&gt; AnyPublisher&lt;T, Never&gt; {<strong class="lq iu">  <br/>  switch</strong> <strong class="lq iu">self</strong> {<br/><strong class="lq iu">    case</strong> .filter(<strong class="lq iu">let</strong> expression):<br/>    return publisher.filter { value <strong class="lq iu">in<br/>                </strong>NSPredicate(format: expression, <br/>                            argumentArray: [value])<br/>                 .evaluate(with: <strong class="lq iu">nil</strong>) }.eraseToAnyPublisher()<br/>        <br/>        //skip the rest of cases<br/>  }}}</span></pre><p id="599f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">按照计划，我们将表达式和从Publisher向上游发送的值一起发送到<code class="fe ln lo lp lq b">NSPredicate</code>。</p><p id="62a1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">注意<code class="fe ln lo lp lq b">NSPredicate</code>接受一个参数数组。因此，经过一些修改，即使值是元组格式，它也应该可以工作，这在反应式场景中非常常见。我们将在以后讨论组合运算符时讨论这个问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/42790206f7ddda095a12a9c42d3997c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/1*RWqlrVkqCfO36v3Noc8riA.gif"/></div></figure><p id="038a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如您所见，过滤器流被添加到这个持久化的操作符数组中，并被转换为Publisher，以便从上游值中过滤出数字<code class="fe ln lo lp lq b">3</code>。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="82e7" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">下一集:持久化——转换操作符、映射和扫描</h1><p id="fe19" class="pw-post-body-paragraph kq kr it ks b kt mq ju kv kw mr jx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated">在演示GIF中，您可能会发现操作符列表相当空。在接下来的几周里，我们将用不同类型的运算符来填充它们:转换运算符、<code class="fe ln lo lp lq b">map</code>、<em class="nh">、</em>和<code class="fe ln lo lp lq b">scan</code>。</p><p id="b555" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">你可以在combine-playground文件夹下的这个<a class="ae lm" href="https://github.com/kevinjohnason/combine-magic-swiftui" rel="noopener ugc nofollow" target="_blank">combine-magic-swi fui repo</a>中找到源代码。</p></div></div>    
</body>
</html>