<html>
<head>
<title>An Introduction to Asynchronous Programming in Python 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3中异步编程的介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-intro-to-asynchronous-programming-in-python-3-7cfa9173234?source=collection_archive---------4-----------------------#2022-02-02">https://betterprogramming.pub/an-intro-to-asynchronous-programming-in-python-3-7cfa9173234?source=collection_archive---------4-----------------------#2022-02-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a50d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">运行异步Python代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9608cd83b8214c847d360844ea335256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*23KtUDuCv_mOboccUiZGtg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片来源于<a class="ae kv" href="https://pixabay.com/users/boskampi-3788146/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1873831)" rel="noopener ugc nofollow" target="_blank">来自Pixabay </a>的Boskampi)</p></figure><p id="d1a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python被认为是最容易学习的语言之一。另一方面，Python处理异步代码的方法可能相当混乱。本文将介绍异步Python代码的关键概念和示例，以使其更易于理解。</p><p id="196d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">特别是，您应该带走以下内容:</p><ol class=""><li id="f3a5" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">异步编程的核心词汇</li><li id="b414" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">当异步方法有意义时</li><li id="2adb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">Python 3中异步代码的基础</li><li id="3739" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">进一步调查的有用资源</li></ol><p id="e68e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始吧！</p><h1 id="498b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">什么是异步编程？</h1><p id="2933" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">异步程序在不阻塞主进程的情况下并行执行操作<em class="nd">。这听起来有点拗口，但它的全部意思是:异步代码是一种确保你的程序在可以做其他工作的时候不会不必要地花费时间等待的方法。</em></p><p id="29ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你以前读过任何关于异步编程的东西，你可能已经听过国际象棋的例子很多次了(一个国际象棋大师一次进行一场比赛，而不是一次进行所有的比赛)。虽然这是经典的有助于说明这个概念，烹饪食物提供了一个更相关的隐喻，你应该记住一些更辛辣的细节。</p><h2 id="015a" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">同步烹饪</h2><p id="3c1a" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">你多久做一次这样的早餐？</p><p id="daac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一步:煮鸡蛋(或者烤面包，给我们的素食朋友)</p><p id="274f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二步:煮培根(燕麦片)</p><p id="3e4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第三步:吃冷鸡蛋/烤面包和热培根/燕麦片</p><p id="495f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望答案是“绝对不会”在进入下一道菜之前，一次做一道菜可能会产生一些非常恶心的食物(这是完全没有效率的)。这就是我们所说的:<code class="fe nq nr ns nt b">synchronous cooking.</code>如果你有经常这样做的朋友，立即帮助他们。</p><h2 id="dcab" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">异步烹饪</h2><p id="c8f1" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">做一顿像样的饭时，很少想一次只准备一道菜。相反，如果你在做燕麦片和烤面包，你可以放上咖啡，然后开始烧水，取出燕麦片和面包。当水烧开时，你开始做燕麦片，在燕麦片做好的几分钟前，把面包片放进烤面包机。</p><p id="39a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当一切都准备好了，你就有希望在同一时间准备好热咖啡、烤面包和燕麦片。这就是我们所说的:<code class="fe nq nr ns nt b">asynchronous cooking</code>。</p><p id="bc5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，同时烹饪所有食物并不会减少每道菜的烹饪时间。你仍然需要让烤面包变成金棕色，咖啡渗滤出来，燕麦片必须……做燕麦片做好的时候做的任何事情。异步制作吐司和同步制作花费的时间是一样的。</p><p id="0b5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，<em class="nd">任务并没有浪费时间等待每一项完成，而是作为烹饪过程的各个阶段</em>来执行。这意味着多项任务会尽快开始，您的宝贵时间会得到有效利用。</p><h2 id="39be" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">考虑</h2><p id="6bec" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">异步方法的另一个重要特征是<em class="nd">顺序不如我们继续其他任务</em>重要。例如，如果我们正在煮一顿有三道菜的饭，第一道菜在第二道菜之前，第三道菜在第三道菜之前。在这种情况下，我们可能需要同步烹饪这些菜肴。</p><p id="dfd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使异步方法是正确的，知道何时继续新的任务对于使它有用也是非常重要的。例如，在沸水的情况下，我们可以在打开炉子、拿出面包、拿出锅等等之间来回切换，但是，这真的能给我们带来任何价值吗？</p><p id="5214" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当没有什么可等待的时候，我们会在任务之间跳跃。在沸水中需要很长时间的东西是水需要在炉子上加热的部分。异步将水烧开<em class="nd">甚至可能效率更低</em>，因为我们必须在任务之间来回移动(这被称为<em class="nd">执行开销</em>，例如，从炉子走到食品室拿面包，然后当锅离炉子更近时从食品室走到储锅室)。</p><p id="7c27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，异步并不适合每个用例，也不会神奇地让您现有的同步代码更快。它的设计也不简单，需要对顺序比效率更重要的地方进行大量的预先考虑。</p><p id="81a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">抛开这个扩展的隐喻，让我们看看异步python代码实际上是什么样子的！</p><h1 id="6722" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">Python 3中异步逻辑的秘诀</h1><p id="79fe" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">关于用Python编写异步程序的各种方法，你可能会在网上看到很多材料(例如回调、生成器等),为了全面了解，我推荐这个<a class="ae kv" href="https://realpython.com/async-io-python/" rel="noopener ugc nofollow" target="_blank">演练</a>，但是Python中的现代异步代码通常使用<code class="fe nq nr ns nt b">async</code>和<code class="fe nq nr ns nt b">await</code>。</p><h2 id="39ed" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">水槽和重物？</h2><p id="ee75" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><code class="fe nq nr ns nt b">async</code>和<code class="fe nq nr ns nt b">await</code>是Python 3中用于编写异步程序的关键词。<code class="fe nq nr ns nt b">async/await</code>语法如下:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="d360" class="ne mh iq nt b gy ny nz l oa ob">async def get_stuff_async() -&gt; Dict:<br/>    results = await some_long_operation()<br/>    return results["key"]</span></pre><p id="3874" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这与同步版本没什么不同:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="b121" class="ne mh iq nt b gy ny nz l oa ob">def get_stuff_sync() -&gt; Dict:<br/>    results = some_long_operation()<br/>    return results["key"]</span></pre><p id="51af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">唯一的文本差异是<code class="fe nq nr ns nt b">async</code>和<code class="fe nq nr ns nt b">await</code>的存在。那么<code class="fe nq nr ns nt b">async</code>和<code class="fe nq nr ns nt b">await</code>实际上是做什么的呢？</p><p id="be8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns nt b">async</code>只是声明我们的函数是异步操作。<code class="fe nq nr ns nt b">await</code>告诉Python这个操作可以暂停，直到<code class="fe nq nr ns nt b">some_long_operation</code>完成。</p><p id="979f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个调用的功能差异是这样的:</p><ol class=""><li id="0970" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">在<code class="fe nq nr ns nt b">get_stuff_sync</code>中，我们调用<code class="fe nq nr ns nt b">some_long_operation</code>，等待该调用返回<code class="fe nq nr ns nt b">results</code>，然后返回结果的重要子集。当我们等待<code class="fe nq nr ns nt b">results</code>时，不能执行其他操作，因为这是一个<em class="nd">阻塞</em>调用。</li><li id="d57b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在<code class="fe nq nr ns nt b">get_stuff_async</code>中，我们<em class="nd">调度</em> <code class="fe nq nr ns nt b">some_long_operation</code>，然后<em class="nd">让出控制权</em>回到主线程。一旦<code class="fe nq nr ns nt b">some_long_operation</code>返回<code class="fe nq nr ns nt b">results</code>，则<code class="fe nq nr ns nt b">get_stuff_async</code>继续执行，并返回<code class="fe nq nr ns nt b">results</code>的重要子集。当我们等待<code class="fe nq nr ns nt b">results</code>时，主进程可以自由执行其他操作，因为这是一个<em class="nd">非阻塞</em>调用。</li></ol><p id="0bc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个抽象的例子，但是您可能已经看到了这种异步方法的一些优点(和缺点)。<code class="fe nq nr ns nt b">get_stuff_async</code>的实现给了我们一个更有效的方法来使用我们的资源，而<code class="fe nq nr ns nt b">get_stuff_sync</code>提供了更多关于排序的确定性和更简单的实现。</p><p id="1c6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，使用异步函数和方法比这个例子稍微复杂一些。</p><h1 id="ca0e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">运行异步Python代码</h1><p id="a9df" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在前一个例子中，我们看到了一些重要的新词汇:</p><ul class=""><li id="1c85" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr oc ly lz ma bi translated">日程安排</li><li id="8209" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oc ly lz ma bi translated">产量</li><li id="696f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oc ly lz ma bi translated">阻塞</li><li id="e03d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oc ly lz ma bi translated">无阻塞</li><li id="d540" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oc ly lz ma bi translated">主流中泓线</li></ul><p id="fdac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当学习如何在Python中运行异步代码时，所有这些都可以更容易地解释。</p><p id="7dfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在同步程序中，我们可以这样做:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="9453" class="ne mh iq nt b gy ny nz l oa ob">if __name__ == "__main__":<br/>    results = get_stuff_sync()<br/>    print(results)  </span><span id="4688" class="ne mh iq nt b gy od nz l oa ob"># <strong class="nt ir"><em class="nd">returns</em></strong> “The Emperor’s Wayfinder is in the Imperial Vault”</span></pre><p id="c18f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们会把结果打印到控制台上。</p><p id="f5db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您用我们的异步代码这样做，您会得到完全不同的消息:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="8b18" class="ne mh iq nt b gy ny nz l oa ob">if __name__ == "__main__":<br/>    results = get_stuff_async()<br/>    print(results)</span><span id="323b" class="ne mh iq nt b gy od nz l oa ob"># <strong class="nt ir"><em class="nd">returns</em></strong> &lt;coroutine object get_stuff_async at 0x7f80372b9c40&gt;<br/># <strong class="nt ir"><em class="nd">bonus!!</em></strong> RuntimeWarning: coroutine 'get_stuff_async' was never awaited</span></pre><p id="0d00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这告诉我们的是<code class="fe nq nr ns nt b">get_stuff_async</code>返回一个<code class="fe nq nr ns nt b">coroutine</code>对象，而不是我们的重要结果。它也提示我们为什么:我们从来没有等待函数本身。</p><p id="8e80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，我们只需要把<code class="fe nq nr ns nt b">await</code>放在函数调用的前面，对吗？可惜，事情没这么简单。<code class="fe nq nr ns nt b">await</code>只能在<code class="fe nq nr ns nt b">async</code>函数或方法内部使用。我们需要使用<code class="fe nq nr ns nt b">asyncio</code> <em class="nd">在<em class="nd">事件循环</em>上调度我们的逻辑，而不是顶级的‘await’。</em></p><h2 id="c842" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">事件循环</h2><p id="9ebc" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">Python中异步操作的核心是事件循环。称之为“事件循环”给了它某种程度的庄严感，对吗？事实是，事件循环在各种程序中都有使用，它们并不特别或神奇。</p><p id="fa3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以任何web服务器为例:它等待请求，然后当它接收到请求时，它将该请求视为一个事件，并将该事件与一个响应相匹配(例如，转到本文的URL，媒体后端说“新事件:浏览器请求了<code class="fe nq nr ns nt b">super-genius-article</code>，我们应该返回<code class="fe nq nr ns nt b">super-genius-article.html</code>”)。这是一个事件循环。</p><p id="d02e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“The”事件循环指的是Python内置的事件循环，它允许我们调度异步任务(它也适用于多线程和子流程)。您真正需要知道的是，它将您安排的任务与事件相匹配，这样它就知道流程何时完成。</p><p id="cbb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使用它，我们消耗标准库<code class="fe nq nr ns nt b">asyncio</code>模块，就像这样:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="591a" class="ne mh iq nt b gy ny nz l oa ob">import asyncio</span><span id="d079" class="ne mh iq nt b gy od nz l oa ob">if __name__ == "__main__":</span><span id="f20d" class="ne mh iq nt b gy od nz l oa ob">    # asyncio.run is like top-level `await`<br/>    results = asyncio.run(get_stuff_async())<br/>    print(results)</span><span id="6ba7" class="ne mh iq nt b gy od nz l oa ob"># <strong class="nt ir"><em class="nd">returns</em></strong> “The Emperor’s Wayfinder is in the Imperial Vault”</span></pre><p id="706e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在大多数情况下，这就是你从事件循环中所需要的。在一些高级用例中，您可能希望在编写低级库或服务器代码时直接访问事件循环，但这对于现在来说已经足够了。</p><p id="09b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们的小样本脚本如下所示:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="f662" class="ne mh iq nt b gy ny nz l oa ob">import asyncio</span><span id="6771" class="ne mh iq nt b gy od nz l oa ob">async def some_long_operation():<br/>    return {"key": "The Emperor's Wayfinder is in the Imperial Vault"}</span><span id="2608" class="ne mh iq nt b gy od nz l oa ob">async def get_stuff_async():<br/>    results = await some_long_operation()<br/>    return results["key"]</span><span id="001e" class="ne mh iq nt b gy od nz l oa ob">if __name__ == "__main__":<br/>    results = asyncio.run(get_stuff_async())<br/>    print(results)</span></pre><p id="e059" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这肯定是可行的，但是这种逻辑并不要求异步行为，甚至没有从异步行为中获益，所以让我们看一个更健壮的例子，在这个例子中，异步实际上是有益的。</p><h1 id="7503" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">网络请求的异步性</h1><p id="0d63" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">向web上的不同位置发送数据或从web上的不同位置接收数据是异步编程的一个用例。等待来自一个缓慢的远程API的响应并不有趣。在等待其他数据的同时执行其他重要的操作有助于提高程序的效率。现在让我们写一个例子。</p><h2 id="c9e6" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">快速、慢速的服务器</h2><p id="33a0" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">为了说明这个例子，我们将自己编写缓慢的远程API:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="c133" class="ne mh iq nt b gy ny nz l oa ob">import time<br/>import uvicorn<br/>from fastapi import FastAPI</span><span id="eef4" class="ne mh iq nt b gy od nz l oa ob">app = FastAPI()  # the irony, amirite?</span><span id="5275" class="ne mh iq nt b gy od nz l oa ob"><br/>@app.get("/{sleep}")<br/>def slow(sleep: int):<br/>    time.sleep(sleep)<br/>    return {"time_elapsed": sleep}</span><span id="5e69" class="ne mh iq nt b gy od nz l oa ob"><br/>if __name__ == "__main__":<br/>    uvicorn.run(app)  # uvicorn is a server built with uvloop, an asynchronous event loop!</span></pre><p id="5602" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个简单的服务器，有一个端点接受路径参数<code class="fe nq nr ns nt b">sleep</code>，休眠一段时间，然后在JSON响应中返回这个数字。(想了解更多关于编写高质量API的知识？新文章即将发布！)</p><p id="c622" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不用说，这将让我们模拟一些我们可能正在等待的缓慢操作。</p><h2 id="f202" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">快速异步脚本</h2><p id="ea3c" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">现在，对于客户端代码，我们将选择一些随机数，并等待一些随机的时间:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="d098" class="ne mh iq nt b gy ny nz l oa ob">import asyncio<br/>import aiohttp</span><span id="ce37" class="ne mh iq nt b gy od nz l oa ob">from datetime import datetime<br/>from random import randrange</span><span id="8f9e" class="ne mh iq nt b gy od nz l oa ob"><br/>async def get_time(session: aiohttp.ClientSession, url: str):<br/>    async with session.get(url) as resp:  # async context manager!<br/>        result = await resp.json()<br/>        print(result)<br/>        return result["time_elapsed"]</span><span id="da52" class="ne mh iq nt b gy od nz l oa ob"><br/>async def main(base_url: str):<br/>    session = aiohttp.ClientSession(base_url)<br/>    # select 10 random numbers between 0, 10<br/>    numbers = [randrange(0, 10) for i in range(10)]<br/>    # await responses from each request<br/>    await asyncio.gather(*[<br/>        get_time(session, url)<br/>        for url in [f"/{i}" for i in numbers]<br/>    ])<br/>    await session.close()</span><span id="2328" class="ne mh iq nt b gy od nz l oa ob">if __name__ == "__main__":<br/>    start_time = datetime.now()    <br/>    asyncio.run(main("http://localhost:8000"))<br/>    print(start_time - datetime.now())</span></pre><p id="4230" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行这个脚本，我们得到如下输出:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="e30b" class="ne mh iq nt b gy ny nz l oa ob">[7, 2, 6, 4, 0, 9, 4, 2, 5, 5]  # times we requested the API to wait<br/>{'time_elapsed': 0}  # API response JSON for waiting X seconds<br/>{'time_elapsed': 2}<br/>{'time_elapsed': 2}<br/>{'time_elapsed': 4}<br/>{'time_elapsed': 4}<br/>{'time_elapsed': 5}<br/>{'time_elapsed': 5}<br/>{'time_elapsed': 6}<br/>{'time_elapsed': 7}<br/>{'time_elapsed': 9}<br/>0:00:09.020562       # time it took the program to run</span></pre><h2 id="9eae" class="ne mh iq bd mi nf ng dn mm nh ni dp mq lf nj nk ms lj nl nm mu ln nn no mw np bi translated">一个不太快的同步脚本</h2><p id="963d" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">客户端代码的同步版本使用相同的可重复性请求时间，如下所示:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="e67d" class="ne mh iq nt b gy ny nz l oa ob">import requests<br/>from datetime import datetime<br/></span><span id="566b" class="ne mh iq nt b gy od nz l oa ob">def get_time(url: str):<br/>    resp = requests.get(url)<br/>    result = resp.json()<br/>    print(result)<br/>    return result["time_elapsed"]<br/></span><span id="a2ed" class="ne mh iq nt b gy od nz l oa ob">def main(base_url: str):<br/>    numbers = [7, 2, 6, 4, 0, 9, 4, 2, 5, 5]<br/>    print(numbers)</span><span id="3a0a" class="ne mh iq nt b gy od nz l oa ob">    for num in numbers:<br/>        get_time(base_url + f"/{num}")<br/></span><span id="c1c2" class="ne mh iq nt b gy od nz l oa ob">if __name__ == "__main__":<br/>    start_time = datetime.now()<br/>    main("http://localhost:8000")<br/>    print(datetime.now() - start_time)</span></pre><p id="ffc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="d045" class="ne mh iq nt b gy ny nz l oa ob"># returns:</span><span id="da9b" class="ne mh iq nt b gy od nz l oa ob">[7, 2, 6, 4, 0, 9, 4, 2, 5, 5]  # same numbers<br/>{'time_elapsed': 7}<br/>{'time_elapsed': 2}<br/>{'time_elapsed': 6}<br/>{'time_elapsed': 4}<br/>{'time_elapsed': 0}<br/>{'time_elapsed': 9}<br/>{'time_elapsed': 4}<br/>{'time_elapsed': 2}<br/>{'time_elapsed': 5}<br/>{'time_elapsed': 5}<br/>0:00:44.099638      # 5x slower</span></pre><h1 id="8b3f" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">观察</h1><p id="3060" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">您可能会立即注意到，数字列表没有排序，但是当我们运行异步客户端代码时，远程API的输出是排序的。这是因为我们在接收结果的同时输出结果，等待时间长的自然比等待时间短的返回得晚。</p><p id="a377" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二，当我们的最长等待时间<em class="nd">是</em> 9秒时，我们在9秒多一点的时间内打了10个电话。<em class="nd">同步</em>执行时间是我们从API请求的所有时间的总和，所以是44秒(或者慢5倍),因为它在继续下一个调用之前等待每个调用完成。<em class="nd">异步</em>执行时间相当于<em class="nd">我们请求的最长等待时间</em>(在这个客户端代码中<em class="nd">最长9秒</em>)，因此效率显著提高。</p><p id="8878" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管async和sync调用都请求API等待相同的时间(44秒)，但是通过使用异步编程，我们可以获得更快的整体程序。</p><p id="d793" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，您会注意到这些客户端代码样本使用了一些有趣的东西，来自<code class="fe nq nr ns nt b">asyncio</code>和<code class="fe nq nr ns nt b">aiohttp</code>:</p><ol class=""><li id="cd30" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">异步上下文管理器(<code class="fe nq nr ns nt b">async with</code>语法)的使用方式与常规的<code class="fe nq nr ns nt b">with</code>语句相同，但是在异步代码中</li><li id="57f1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nq nr ns nt b">aiohttp.ClientSession</code>对象是一个用于编写客户端异步网络请求的API在<code class="fe nq nr ns nt b">aiohttp</code>的<a class="ae kv" href="https://docs.aiohttp.org/en/stable/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>中查看关于它的更多信息</li><li id="0e69" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nq nr ns nt b">asyncio.gather</code>调用是执行一组异步函数并将其结果作为列表返回的一种非常方便的方式——当您需要来自多个地方的数据，但不想等待任何单个请求时，您可以想象使用它来进行有用的API调用</li></ol><h1 id="cef9" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="4b79" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">希望本文为您提供了一些在Python中使用异步编程的弹药。它远非全面，因为它涉及到并行编程范例，所以有大量的知识需要学习，但这只是一个开始。</p><p id="43ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前进过程中需要记住的关键事项:</p><ol class=""><li id="2284" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">异步并不总是一蹴而就的——在许多用例中，同步执行将比异步编程更简单、更快，因为并不是每个程序都必须等待数据返回</li><li id="cb4c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用异步需要设计——考虑程序的顺序以及何时需要哪些数据，而同步代码倾向于想当然地认为数据就在那里，每次调用都会立即返回</li><li id="e7a0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">虽然有许多方法可以编写异步代码，但是您几乎总是希望使用<code class="fe nq nr ns nt b">async/await</code>——如果您不确定是否需要其他方法，那么您希望使用<code class="fe nq nr ns nt b">async/await</code>语法</li></ol><p id="dcb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">暂时就这样吧！晚安，祝您的异步编程之旅好运。</p><h1 id="1d3b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">资源</h1><p id="50a0" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这并不是促成这篇文章的所有因素的总和，但不管怎样，它们都是值得一看的好东西。</p><ol class=""><li id="2bbc" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">https://docs.python.org/3/library/asyncio.html</li><li id="c415" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">https://uvloop.readthedocs.io/<a class="ae kv" href="https://uvloop.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"/></li><li id="31bc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">FastAPI:【https://fastapi.tiangolo.com/ T4】</li><li id="5b66" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">令人敬畏的Asyncio:<a class="ae kv" href="https://github.com/timofurrer/awesome-asyncio" rel="noopener ugc nofollow" target="_blank">https://github.com/timofurrer/awesome-asyncio</a></li></ol></div></div>    
</body>
</html>