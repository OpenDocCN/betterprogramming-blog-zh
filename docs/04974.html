<html>
<head>
<title>How to Build Containers in a Kubernetes Cluster With Kaniko</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Kaniko在Kubernetes集群中构建容器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-containers-in-a-kubernetes-cluster-with-kaniko-2d01cd3242a7?source=collection_archive---------2-----------------------#2020-05-27">https://betterprogramming.pub/how-to-build-containers-in-a-kubernetes-cluster-with-kaniko-2d01cd3242a7?source=collection_archive---------2-----------------------#2020-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6b1d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在K8s中自动构建容器，无需Docker守护进程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fbe6c0d081c4bd86e9c4a8ebd77bbdfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l85zI6ot5txddTGeDq7BiA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://commons.wikimedia.org/wiki/File:Kubernetes-Engine-Logo.svg" rel="noopener ugc nofollow" target="_blank">维基共享</a></p></figure><p id="f2bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传统上，组织在Kubernetes集群之外构建Docker映像。然而，随着越来越多的公司采用Kubernetes，并且对虚拟机的需求日益减少，在Kubernetes集群中运行您的持续集成构建是有意义的。</p><p id="7b6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在容器中构建Docker映像是一个安全挑战，因为容器需要访问worker节点文件系统来连接Docker守护进程。</p><p id="13e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还需要在特权模式下运行容器。不推荐这种做法，因为它会将您的节点暴露给众多的安全威胁。大多数组织依赖持久的外部卷来存储数据，在任何情况下，容器都不应该直接访问节点文件系统。</p><p id="4304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在特权模式下运行容器是一个糟糕的想法，因为它提供了对主机的容器根访问。这给了网络犯罪分子破坏您的系统的机会，可能危及整个工作节点，而不仅仅是容器。</p><p id="6f5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谷歌通过提供一个名为<a class="ae ky" href="https://github.com/GoogleContainerTools/kaniko" rel="noopener ugc nofollow" target="_blank"> Kaniko </a>的工具解决了这个问题。Kaniko帮助您在不访问Docker守护进程的情况下在容器中构建容器映像。这样，您可以在容器内执行构建作业，而无需授予对主机文件系统的任何访问权限。</p><p id="a8bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您只需要创建一个构建清单作为Kubernetes批处理作业，并使用您选择的任何CI工具将它应用到集群。该作业负责构建您的映像并将其上传到指定的容器注册中心。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="79ce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Kaniko如何工作</h1><p id="be01" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">卡尼科:</p><ul class=""><li id="d81c" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">读取指定的<code class="fe ni nj nk nl b">Dockerfile</code>。</li><li id="5892" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">将基本映像(在<code class="fe ni nj nk nl b">FROM</code>指令中指定)提取到容器文件系统中。</li><li id="c304" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">单独运行<code class="fe ni nj nk nl b">Dockerfile</code>中的每个命令。</li><li id="cb16" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">每次运行后，拍摄用户空间文件系统的快照。</li><li id="3bbb" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">每次运行时将快照层附加到基础层。</li></ul><p id="615a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，Kaniko不依赖于Docker守护进程。</p><p id="bf32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看它是如何工作的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9834" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件</h1><p id="d2e9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">确保您具备以下条件:</p><ul class=""><li id="0e19" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">正在运行的Kubernetes集群，具有创建、列出、更新和删除作业、服务、pod和机密的权限。</li><li id="b3cd" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">用于存储<code class="fe ni nj nk nl b">Dockerfile</code>和Kubernetes清单的GitHub帐户。</li><li id="7b7a" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated">用于托管容器映像的Docker Hub帐户。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a7b9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建容器注册表机密</h1><p id="6484" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从设置一个容器注册表秘密开始。要推送构建的映像，需要向容器注册中心进行认证。</p><p id="d0dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将需要以下内容:</p><ul class=""><li id="b9d0" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe ni nj nk nl b">docker-server</code>—Docker注册服务器，您需要在其中托管您的图像。如果您使用Docker Hub，请使用<code class="fe ni nj nk nl b"><a class="ae ky" href="https://index.docker.io/v1/" rel="noopener ugc nofollow" target="_blank">https://index.docker.io/v1/</a></code>。</li><li id="fcdd" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated"><code class="fe ni nj nk nl b">docker-username</code>—Docker注册用户名。</li><li id="e70b" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated"><code class="fe ni nj nk nl b">docker-password</code>—Docker注册表密码。</li><li id="5458" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated"><code class="fe ni nj nk nl b">docker-email</code>—Docker注册表上配置的电子邮件。</li></ul><p id="2c7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行以下命令，替换上述值:</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="6018" class="nv md it nl b gy nw nx l ny nz">$ kubectl create secret docker-registry regcred --docker-server=&lt;docker-server&gt; --docker-username=&lt;username&gt; --docker-password=&lt;password&gt; --docker-email=&lt;email&gt;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="134c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">GitHub知识库</h1><p id="f676" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于动手练习叉<a class="ae ky" href="https://github.com/bharatmicrosystems/kubernetes-kaniko" rel="noopener ugc nofollow" target="_blank">这个库</a>到你的GitHub账户。克隆分叉的GitHub库并将<code class="fe ni nj nk nl b">cd</code>放入其中。</p><p id="3f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们正在构建一个<a class="ae ky" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> NGINX </a>容器，所以让我们从<code class="fe ni nj nk nl b">nginx:v3</code>标签开始。运行以下命令，将占位符替换为适合您环境的值:</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="aa64" class="nv md it nl b gy nw nx l ny nz">$ export GHUSER="&lt;YOUR_GITHUB_USER&gt;"<br/>$ export GHREPO="&lt;YOUR_GITHUB_REPO&gt;"<br/>$ export DOCKERREPO="&lt;YOUR_DOCKER_REPOSITORY&gt;"</span><span id="d8de" class="nv md it nl b gy oa nx l ny nz">#Substitute placeholders in build.yaml<br/>$ sed -i "s/GHUSER/${GHUSER}/g" build.yaml<br/>$ sed -i "s/GHREPO/${GHREPO}/g" build.yaml<br/>$ sed -i "s/&lt;repo&gt;/${DOCKERREPO}/g" build.yaml<br/>$ sed -i "s/&lt;tag&gt;/nginx:v3/g" build.yaml</span><span id="b5c0" class="nv md it nl b gy oa nx l ny nz">#Substitute placeholders in Dockerfile<br/>$ sed -i "s/v_x/3/g" Dockerfile</span><span id="c79d" class="nv md it nl b gy oa nx l ny nz">#Substitute placeholders in the Kubernetes deployment file<br/>$ sed -i "s/&lt;repo&gt;/${DOCKERREPO}/g" workloads/nginx-deployment.yaml<br/>$ sed -i "s/&lt;tag&gt;/nginx:v3/g" workloads/nginx-deployment.yaml</span></pre><p id="75d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来看看换人后的<code class="fe ni nj nk nl b">Dockerfile</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="15c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">Dockerfile</code>包含两个步骤。它向<code class="fe ni nj nk nl b">nginx</code>声明基础映像，并向<code class="fe ni nj nk nl b">/usr/share/nginx/html/index.html</code>写入<code class="fe ni nj nk nl b">This is version 3</code>。当我们到达NGINX端点时，我们应该得到一个响应。</p><p id="e812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看替换后的<code class="fe ni nj nk nl b">build.yaml</code>是什么样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您可能注意到的，这是一个带有单独容器的简单的Kubernetes工作。清单使用<code class="fe ni nj nk nl b">gcr.io/kaniko-project/executor:latest</code>映像创建一个容器，并使用以下参数运行它:</p><ul class=""><li id="ce65" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe ni nj nk nl b">docker-file</code>—Docker文件的路径，相对于上下文。</li><li id="a226" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated"><code class="fe ni nj nk nl b">context </code>—Docker上下文。在这种情况下，我们已经指明了我们的GitHub存储库</li><li id="4e7f" class="mz na it lb b lc nm lf nn li no lm np lq nq lu ne nf ng nh bi translated"><code class="fe ni nj nk nl b">destination</code> —推送已构建映像的Docker存储库。</li></ul><p id="c6f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它还在<code class="fe ni nj nk nl b">/kaniko/.docker</code>上挂载一个docker config JSON文件，以通过docker存储库进行身份验证。我们在上一节中对此进行了定义。</p><p id="2859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那<code class="fe ni nj nk nl b">nginx-deployment.yaml</code>文件呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3a53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个经典的NGINX部署，它部署了我们使用Kaniko构建的<code class="fe ni nj nk nl b">nginx:v3</code>映像。</p><p id="9f2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你注意到注释，它有<code class="fe ni nj nk nl b">fluxcd.io/automated: "true"</code>。这意味着如果我们使用<a class="ae ky" href="https://fluxcd.io" rel="noopener ugc nofollow" target="_blank"> Flux CD </a>来部署这个清单，当它在Docker存储库中可用时，Flux CD会用新版本的NGINX映像自动更新它。</p><p id="5928" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们有一个NGINX服务，将NGINX pods暴露给外部负载平衡器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="91d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将更改推送到您的远程GitHub存储库。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f411" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用Kaniko构建容器映像</h1><p id="3711" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通过应用<code class="fe ni nj nk nl b">build.yaml</code>清单构建映像:</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="9788" class="nv md it nl b gy nw nx l ny nz">$ kubectl apply -f build.yaml<br/>job/kaniko created<br/>$ kubectl get pod<br/>NAME           READY   STATUS    RESTARTS   AGE<br/>kaniko-jztr6   1/1     Running   0          68s</span></pre><p id="61f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">pod运行后，打印日志:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="643e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，Kaniko已经构建了<code class="fe ni nj nk nl b">nginx:v3</code>，它应该会出现在你的Docker注册表中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="807b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">安装Flux CD</h1><p id="7514" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如前所述，我们使用Flux CD将工作负载部署到我们的Kubernetes集群。<a class="ae ky" href="https://fluxcd.io/" rel="noopener ugc nofollow" target="_blank"> Flux CD </a>是一款持续交付工具，正在迅速流行起来。Weaveworks最初开发了这个项目，然后将它开源给了云计算原生计算基金会。</p><p id="df5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Flux CD通过定期轮询库来同步源代码库中存储的Kubernetes清单和Kubernetes集群。</p><p id="a421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，Flux CD还允许您轮询容器注册中心，并使用最新的映像更新Git存储库上的Kubernetes清单，如果您想自动升级工作负载的话。</p><p id="5259" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照我的文章<a class="ae ky" href="https://medium.com/better-programming/how-to-continuously-deliver-kubernetes-applications-with-flux-cd-502e4fb8ccfe" rel="noopener">如何使用Flux CD连续交付Kubernetes应用程序</a>中的说明，在您的Kubernetes集群中安装和配置Flux CD。请确保在遵循该指南时不要更改<code class="fe ni nj nk nl b">GHUSER</code>和<code class="fe ni nj nk nl b">GHREPO</code>变量。目标是将你的GitHub库与Flux CD同步。</p><p id="6fe2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦您在Kubernetes集群上设置了Flux CD，您就可以通过运行以下命令将其与GitHub存储库同步:</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="6bab" class="nv md it nl b gy nw nx l ny nz">$ fluxctl sync --k8s-fwd-ns flux<br/>Synchronizing with ssh://<a class="ae ky" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>/bharatmicrosystems/kubernetes-kaniko-nginx<br/>Revision of master to apply is 3a33f0a<br/>Waiting for 3a33f0a to be applied ...<br/>Done.</span></pre><p id="21db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们列出<code class="fe ni nj nk nl b">web</code>名称空间内的所有资源，看看Flux是否部署了NGINX。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="b232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<code class="fe ni nj nk nl b">nginx-service</code>获取外部IP并触发端点:</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="34fd" class="nv md it nl b gy nw nx l ny nz">$ curl 35.193.173.129<br/>This is version 3</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2329" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更新NGINX版本</h1><p id="30c6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们尝试一些不同的东西。正如我在上一节所描述的，Flux CD会自动检测NGINX的新版本，并用最新版本更新<code class="fe ni nj nk nl b">nginx-deployment.yaml</code>清单文件。如果我们构建一个新版本的NGINX，并将其推送到容器注册中心，会发生什么？让我们找出答案。</p><h2 id="3730" class="nv md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">更新清单</h2><p id="3ff6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们需要更新docker文件和构建清单以反映新版本。</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="d196" class="nv md it nl b gy nw nx l ny nz"># Update docker file with the new version<br/>$ sed -i 's/3/4/g' Dockerfile</span><span id="5738" class="nv md it nl b gy oa nx l ny nz"># Update the build.yaml with the new version<br/>$ sed -i 's/nginx:v3/nginx:v4/g' build.yaml</span></pre><p id="4414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再次应用构建清单:</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="cfca" class="nv md it nl b gy nw nx l ny nz">$ kubectl apply -f build.yaml<br/>job/kaniko created<br/>$ kubectl get pod<br/>NAME           READY   STATUS    RESTARTS   AGE<br/>kaniko-qs9qz   1/1     Running   0          68s</span></pre><p id="a0ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在pod运行后列出日志:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="f4f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kaniko应该构建映像并将其推送到Docker存储库:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/313dc4871bca9b3484d41137dd89b0b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*msVo3_Cjhi0_vCSOKEYmlg.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9257" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">通量CD同步</h1><p id="d7b0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">等待五分钟，让Flux将您的GitHub存储库与集群同步。</p><p id="b066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该看到Flux CD已经用新的<code class="fe ni nj nk nl b">nginx-deployment.yaml</code>清单更新了您的GitHub库:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/2fc54e03e91f05f663b32aaa533b6f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0zj9MwaqU1Ma09_ba_p3bQ.png"/></div></div></figure><p id="ff72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看一下<code class="fe ni nj nk nl b">nginx-deployment.yaml</code>文件，你会看到Kaniko已经将图像更新为<code class="fe ni nj nk nl b">nginx:v4</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="0739" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们列出来自<code class="fe ni nj nk nl b">web</code>名称空间的所有资源:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="a08f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到<code class="fe ni nj nk nl b">nginx-deployment</code>豆荚是最近的。</p><p id="3e87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次卷曲NGINX服务:</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="a714" class="nv md it nl b gy nw nx l ny nz">$ curl 35.193.173.129<br/>This is version 4</span></pre><p id="d76f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜你！你现在得到的是<code class="fe ni nj nk nl b">version 4</code>而不是<code class="fe ni nj nk nl b">version 3</code>。这表明Flux CD在检测到容器注册表中的更改时会自动更新配置。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5f97" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="9ab5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">感谢阅读！我希望你喜欢这篇文章。</p><p id="dbd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与Flux CD一起，Kaniko可以成为现有选项的一个令人信服的CI/CD替代方案，并为您提供额外的优势，特别是如果您希望利用Kubernetes和云的无限扩展能力。</p></div></div>    
</body>
</html>