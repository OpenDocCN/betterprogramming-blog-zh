# 为什么我仍然“口齿不清”(你也应该这样)

> 原文：<https://betterprogramming.pub/why-i-still-lisp-and-you-should-too-18a2ae36bd8>

## 这种过时的语言可能不会被很多人使用。但它仍然是我代码库的一部分。

![](img/59e099af59580067cb30689f2da7dee5.png)

在公共领域提供徽标

作为 Scheme/Common Lisp/rack 的长期用户(和积极支持者),我有时会被问到为什么坚持使用它们。幸运的是，我总是领导我自己的工程组织，所以我从来没有向管理层证明过。但是还有一个更重要的支持者——我自己的工程同事——他们从来没有享受过使用这些语言的乐趣。虽然他们从来不会问理由，但他们确实会出于求知欲而问，有时也是出于好奇，为什么我对 Python 或 Scala 中的下一个很酷的特性不感兴趣，或者不管他们本月的风格是什么。

虽然实际使用的 Lisp 风格对我来说有所不同(Scheme、Common Lisp、Racket、Lisp-for-Erlang)，但核心始终保持不变:一种基于 s 表达式、动态类型、主要是函数式的、基于值调用λ演算的语言。

我十几岁的时候就在 ZX Spectrum+上开始了严肃的 BASIC 编程，尽管我以前也曾涉足过(手写)Fortran 程序。这对我来说是一个决定性的时期，因为它真正定义了我的职业道路。很快，我就将这门语言推向了极限，并试图编写远远超出这门语言及其实现的有限能力的程序。我在一段时间内使用了 Pascal(DOS 环境下的 Turbo Pascal)，这很有趣，直到我在 Unix 上发现了 C(Santa Cruz Operation Xenix！).这让我获得了计算机科学学士学位，但它总是让我希望我的程序有更多的表现力。

这是我发现函数式编程的时候(谢谢 IISc！)在米兰达(丑陋的哈斯克尔非常美丽的妈妈)中，它让我看到了我想要在我的节目中拥有美丽的一面。我对编程语言的表现力的概念开始有了很大的飞跃。我对程序应该是什么样子的概念现在开始包含简洁、优雅和可读性。

Miranda 不是一种特别快的语言，所以执行速度是一个问题。Miranda 也是一种带有标准 ML 风格类型推理的静态类型语言。一开始，我迷恋于类型系统。然而，随着时间的推移，我开始鄙视它。虽然它帮助我在编译时捕捉到了一些东西，但大部分都是碍事的(稍后会详细介绍)。

大约一年后，我在印第安纳大学和 Dan Friedman(以小 Lisper /小阴谋家出名)一起学习编程语言。这是我对 Scheme 和 Lisp 世界的介绍。我终于知道我找到了表达我的节目的完美媒介。在过去的 25 年里，这一点没有改变。

在这篇文章中，我试图解释和探索，为什么会这样。难道我只是一只不肯改弦更张的老恐龙？我是否对新思想过于傲慢和轻蔑？或者我只是厌倦了？答案，我认为，以上都不是。我找到了完美，但还没有任何东西打破它。

让我们稍微分解一下。我把这几段话说回来:

> 一种基于 s 表达式、动态类型、主要功能性、按值调用的λ演算语言

我将开始解释这一点——反向解释。

# 基于λ-微积分的语言

所有程序中的基本实体是一个*函数*。功能有一种意向性，它构成了软件设计过程的基础。你总是在思考信息是如何作用的，它是如何转换的，以及它是如何产生的。我还没有找到一个比λ演算更好的基础框架来捕捉这种内在的意向性(“如何”)。

“T4”这个词可能会让你迷惑。数学有两种思考函数的方法。首先，作为一组有序对:(*输入，输出*)。虽然这种表示法是证明函数定理的好方法，但在编码时却毫无用处。这也被称为功能的*扩展*视图。

考虑函数的第二种方式是作为一个转换规则。例如，将输入乘以自身得到输出(这给了我们平方函数，方便地被每种编程语言缩写为 *sqr* )。这是函数的*内涵*视图，λ演算很好地捕捉到了这一点，并提供了简单的规则来帮助我们证明关于函数的定理，而无需求助于外延。

*现在等一下*，我敢肯定你在想。我从来没有证明过我的函数。我敢打赌，事实上，你有。而且你要一直这样做。你总是说服自己，你的职能是做正确的事情。你的可能不是一个正式的证明(这可能会导致一些错误)，但对代码的推理是软件开发人员一直在做的事情。他们在脑海中回放代码，看看它是如何运行的。

基于λ演算的语言使得*真正*容易在你的头脑中“回放代码”。λ-演算的简单规则意味着你头脑中要记住的东西更少，代码也更容易阅读和理解。

当然，编程语言是实用的工具，所以为了适应更广泛的目的，核心的简单性必须得到增强。这就是为什么我喜欢 Scheme(以及我目前最喜欢的 Scheme 风格——球拍——CS，为那些关心这类事情的人准备的)。它添加到核心λ-演算中的是使其可用的最低限度。甚至添加的内容也遵循λ演算所支持的基本原则，所以没什么好惊讶的。

当然，这确实意味着*递归*是一种生活方式。如果你是那些递归从来没有意义的人之一，或者如果你仍然相信“递归是低效的”，那么是时候重新审视它了。Scheme(和球拍)尽可能有效地将递归实现为循环。不仅如此，方案标准*要求* it。

这个被称为*尾调用优化* ( *或 TCO* )的特性已经存在了几十年。没有一种现代语言支持我们的编程语言，这是对我们编程语言现状的可悲评论。这对于 JVM 来说尤其是一个问题，因为新的语言已经出现，试图将 JVM 作为运行时架构。JVM 不支持它，因此构建在 JVM 之上的语言不得不千方百计提供某种有时适用的 TCO 的表象。所以，我总是对任何针对 JVM 的函数式语言持怀疑态度。这也是我没有成为 Clojure 粉丝的原因。

这是第一个原因。scheme/rack 是一种基于λ演算的编程语言的明智实现。你可能已经注意到了，我没有用*功能性*语言来描述 Scheme 这个词。这是因为尽管它主要是功能性的，但它并没有完全偏向非可变性。尽管 Scheme 不鼓励使用突变，但它认识到，在真正的情况下，可能会使用突变，并且它允许在没有辅助设备的情况下使用突变。我不会在这里与纯粹主义者争论为什么或为什么这不是一个好主意，但它与我将在本文后面谈到的一些东西有关。

# 按值调用

那些知道λ-演算细节的人可能已经认识到我为什么选择做这样的区分。记住我的历史:我是在 Miranda 上开始使用函数式语言的，它是一种懒惰的函数式语言(Haskell 也是)。这意味着表达式只有在需要它们的值时才会被评估。最初的λ-演算也是这样定义的。这意味着函数的参数是在使用时计算的，而不是在调用函数时计算的。

这种区别是微妙的，它确实有一些有趣的数学特性，但它对在你的大脑中“回放代码”有着深远的影响。有很多例子会让你大吃一惊(即使对于有经验的程序员来说)，但是有一个例子你可能比其他人更感兴趣。

作为一名程序员，在你的职业生涯中最难处理的错误之一是那些在屏幕上打印一些东西就能让错误消失的错误。在惰性函数式语言中，打印某些东西会强制对表达式求值，而在错误的情况下，可能不会对表达式求值。因此，打印值作为调试工具变得可疑，因为它严重地改变了程序的行为。我不知道你怎么想，但对我来说，印刷是一种工具，有人必须从我冰冷、麻木的手指中撬开它。

语言中到处使用的懒惰求值还有其他微妙之处，这使它对我来说不是一个吸引人的选择。我从来不想去猜测某个表达式什么时候被求值。要么评价，要么不评价。不要让我猜测什么时候，特别是当它在某个图书馆深处将要发生(或不发生)的时候。

通过值调用在如何证明关于程序的形式定理方面有一些暗示，但是谢天谢地存在一种叫做通过值调用λ演算的野兽，如果必要的话我们可以依赖它。

Scheme 通过使用 *thunks* 和突变，允许你有*显式*惰性求值，这些可以方便地抽象出来，以便你在需要时调用。这就引出了下一点。

# 主要是功能性的

函数式编程很棒。在头脑中回放功能代码很简单:代码易于阅读，没有突变让人放心。除非这还不够。

我不支持随意的突变，但我支持明智地使用突变。就像上面的懒惰评估的例子一样，我可以完全支持使用变异来实现功能特性。突变存在于所有软件的外围。对于一些抽象来说，最具表现力的事情可能是将突变引入一个漂亮的小抽象。例如，消息传递总线是一个充满突变的抽象，但是它可以有非常优雅的、纯粹功能性的代码段，而不必携带虚假的状态变量或像单子这样的辅助设备。

像任何工具一样，非变异代码走极端可能是有害的。一种能让我明智地使用变异以更优雅的方式实现大量代码的语言，总是能战胜一种在任何情况下都强制使用(通常是好的)结构的语言。

因此，Scheme 对无突变的固有偏见，但它对突变的“如果你必须使用它”的态度(或者被称为*副作用*)，使它成为我更有效的工具。

我在上面提到了单子，所以稍微谈一谈它们是个好主意，因为它们是获得效果的纯功能方式。写了一篇关于它们的博士论文，我想我对它们有一些了解。我喜欢尤金尼奥·莫吉最初的单子概念的优雅和纯粹的美。从计算产生的价值中分离出一个计算，然后将该计算具体化为一种类型的想法在任何意义上都是*高明的*。这是从数学上理解编程语言语义的一个很好的方法。

作为一个编程工具，我对此喜忧参半。这是一种复杂的隔离效果的方法，然后将它们贯穿到整个程序中，这时你可以轻松地创建简单的抽象，使程序的其余部分更容易处理。正如一位杰出的类型理论家(他将保持匿名)曾经说过的，“单子只在每隔一周的星期二有用。”

单子是一种辅助工具，它被强加到函数式语言中，以提供一个围绕副作用的函数式栅栏。问题是栅栏是“传染性”的，所有接触栅栏的东西现在也必须被围起来，如此等等，直到你到达操场的尽头。因此，与其面对副作用并在抽象中优雅地处理它，不如现在给你一个复杂的抽象，让你不得不随身携带。最重要的是，他们也写得不好。

我不是说单子完全没用。它们在某些情况下确实工作得很好(“每隔一个星期二”)，当它们工作的时候我也确实使用它们。但是当它们是处理计算的唯一机制时，它们严重削弱了编程语言的表达能力。

这就把我们带到了下一个，也许是我持有的最有争议的观点。

# 动态类型化

当今世界一直在谈论类型化语言。TypeScript 被认为是顽固的 JavaScript 世界的救世主。Python 和 JavaScript 因缺乏静态类型而受到谴责。在大型编程项目中，类型被认为是文档和通信的基本要素。工程经理们拜倒在类型推理的石榴裙下，以免平庸的软件工程师写出质量低劣的代码。

有两种类型的静态类型。“旧式”静态类型在 C、C++、Java、Fortran 中使用，编译器使用这些类型来生成更高效的代码。这里的类型检查器非常严格，但是不要假装提供基本类型检查之外的任何保证。他们至少是可以理解的*。*

*还有一种新的静态类型，其根源是 Hindley-Milner 类型系统，它带来了一种新的野兽:类型推理。这给你一种错觉，不是所有的类型都需要声明。如果你遵守规则，你会得到旧式静态类型的好处，但也有一些很酷的新事物，如多态性。这种观点也可以理解。*

*但是在过去的几十年里，它有了新的含义:静态类型是编译时错误检查的一种形式，因此它将帮助您生成质量更好的代码。这就好像静态类型是一个神奇的定理证明器，它将验证程序的一些深层属性。这就是我调用 *bullsh*t.* 的地方。我从来没有一个静态类型检查器(不管它有多复杂)帮我防止任何明显错误(无论如何都应该在测试中被发现)之外的错误。*

*然而，静态类型检查器所做的就是妨碍我。一直都是。没有失败。作为一名程序员，我脑子里一直带着*不变量*(这是一个关于我程序中事物的属性的有趣名字)。那些不变量中只有*一个*是它的类型。当你第一次遇到它的时候，拥有一个可以验证不变量的工具是一件很酷的事情(就像我对米兰达做的那样)。*

*但这是一个*愚蠢的*工具。它只能做这么多。所以，你现在有了关于如何满足这个工具的人为规则。我知道完全可以做的事情(并且可以证明或者甚至正式证明我的用例)突然就不行了。所以现在我必须重新设计我的程序来满足有限工具的需求。大多数人对这种权衡非常满意，他们慢慢地改变他们对软件的看法，以适应其局限性。*

*在旧的印度电影中，审查委员会不允许在银幕上接吻。所以浪漫的场景总是会被剪成花朵互相碰撞，或者一对鸟儿一起飞走，或者诸如此类的傻事。这就是静态类型跳棋的感觉。我们得到了承诺我们言论自由权利的美丽语言，但随后我们却被监管言论的审查委员会扇了一巴掌。我们最终不得不用隐喻和象征来表达我们的意思，而这只是一点点的好处。*

*一个*伟大的*工具会做的，是允许我在编译时声明并证明*我所有的*不变量。这当然是最终无法解决的。因此，如果在蹩脚的工具(静态类型检查器)和无工具之间进行选择，我总是倾向于无工具，因为我更喜欢在我的程序上没有任何人为的约束。因此有了动态类型。*

*所有程序(静态类型或其他)都必须处理运行时异常。写得好的程序会遇到较少的问题，写得不好的程序会遇到较多的问题。静态类型检查器将一些人从写得不好的阵营转移到写得比较好的阵营。提高(并保证)软件质量的是*严格的测试*。要交付高质量的软件，没有其他的解决方案。你是否使用静态类型对你的软件质量只有很小的影响。当你拥有由深思熟虑的程序员编写的设计良好的程序时，这种影响甚至会消失。*

*换句话说，静态类型是没有意义的。它也许有一些文献价值，但它不能代替其他不变量的文献。例如，你的不变量可能是，你期望一个单调递增的数组，其平均值为某某，标准差为某某。任何静态类型检查能让你做的最好的事情就是`array[float]`。其余的不变量必须用描述函数的文字来表达。那么，为什么要让自己遭受`array[float]`的痛苦呢？*

*动态类型允许我在程序中表达我想表达的东西，而不会妨碍我。根据程序的需要，我可以将我的不变量指定为显式检查或文档。*

*但是，像其他事情一样，有时您需要静态地了解类型。例如，我经常处理图像，知道它们是`array[byte]`很有帮助，我有预烤的操作，可以神奇地快速处理它们。scheme/Lisp/rack 都提供了在你需要的时候做这件事的方法。在 Scheme 中，它是依赖于实现的，但是 Racket 附带了一个`Typed Racket`变体，可以与动态类型的变体混合使用。Common Lisp 允许在特定的上下文中声明类型，主要是为了让编译器在可能的情况下实现优化。*

*所以，再一次，Scheme/Lisp/rack 在我需要的时候给我类型*的好处*，但是不要处处强加约束。真是两全其美。*

# *基于 s 表达式*

*最后，我们来了解我使用 Lisp 的最重要的原因之一。对于那些以前从未听说过术语 s-expression 的人来说，它代表了 Lisp 及其后代中一种特殊的语法选择。所有的语法形式不是*原子*就是*列表*。原子是像名称(符号)、数字、字符串和布尔这样的东西。列表看起来像“(…)”，其中列表的内容也是列表或原子，有一个空列表“()”是完全可以的。就是这样。*

*没有中缀操作，没有运算符优先级，没有结合性，没有虚假分隔符，没有悬挂的 else，什么都没有。所有的函数应用都是前缀，所以不用说“(a + b)”，而是说“(+ a b)”，这进一步让你可以灵活地说“(+ a b c)”。“+”只是一个函数的名字，如果你愿意，你可以重新定义它。*

*有一些“关键词”指导一个给定的列表以某种方式进行评估，但是评估的规则是有层次的和定义良好的。换句话说，s 表达式实际上是你的程序的基于树的表示。*

*这种简单的语法经常让新手感到困惑。这可能会让许多程序员失去兴趣，他们很不幸没有接触到这种编写程序方式的美妙之处。*

*这种形式的句法的最大优点是一种极简主义——你不需要虚假的句法结构来传达概念。概念完全由函数名或使用的语法关键字来传达。这会产生异常紧凑的代码。在字符数量方面并不总是紧凑的，但在阅读代码时需要记住的概念数量方面是紧凑的。*

*这还不到一半。如果你的程序是树，你可以写程序来操作这些树。口齿不清者(以及阴谋家和诈骗犯)称这些东西为*宏*，或*句法扩展*。换句话说，你可以*扩展你的语言的语法来引入新的抽象。**

*有无数代 Lispers 编写的很酷的语法扩展，包括对象系统、语言嵌入、专用语言等等。我用它来开发语法特性，这些特性允许我使用 Scheme 来构建从传感器网络到数字信号处理，再到电子商务定价策略的东西。世界上还没有一种语言能够接近支持这种级别的语法扩展。这是我(和许多其他口齿不清的人)不可或缺的东西。*

# *结论*

*那就归结为。*

> *一种基于 s 表达式、动态类型、主要功能性、按值调用的λ演算语言*

*这就是为什么我现在还在用 Scheme/rack/Lisp，而且可能会用一辈子。我使用其他语言吗？当然——很多。他们中没有一个比得上这些。尤其是新的。发明新语言似乎是每一代信息不灵通的新一代软件工程师都要经历的一项练习，因为旧语言比他们做梦都想得出来的任何东西都要好*(我向您展示 Ruby，尽管它名义上源于 Lisp，但它回避了一个问题:*为什么不直接使用 Lisp 本身*)。**

**像所有偏见一样，我的也有缺点。大约 15 年前，所有第三方 SDK 都是完全用 C/C++编写的，可以很容易地与 Lisp 互操作。Java 的出现对它造成了阻碍，因为 JVM 不能很好地与 Scheme/Lisp/rack 互操作。这使得在不做大量工作的情况下将第三方库集成到我的程序中变得越来越困难。**

**另一个缺点是，随着 API 在互联网上的兴起，大多数供应商都以互联网的通用语言(Java、Ruby、Python、JavaScript，以及最近的 Go 和 Rust)发布库，但从不以 Scheme/Lisp/rack 发布，除非它是社区贡献，并且同样很少以 C/C++发布。这经常让我不得不自己构建一个 API 层，这当然是不太实际的。球拍(这是我目前最喜欢的)，有一个非常活跃的社区，确实有助于大事情的发生，但它通常有点落后于时代，当谈到最新和最伟大的事情时，我经常被甩在后面。这可能是我将来采用 Clojure 的主要原因，但还有待观察。**

**当然，这还没有吓住我。如果有什么不同的话，它让我更加意识到 Lisp 社区必须把它的话传播得更远更广，并带来新一代的 Lisp 来巩固快速变化环境中的生态系统。**

**最后，还有性能问题。首先，让我们消除常见的误解:Lisp 是*而不是*解释型语言。它是*而不是*慢，所有的实现都有很多很多的杠杆来调整*大多数*程序的性能。在某些情况下，程序可能需要更快的语言的帮助，如 *C* 和 *C++* ，因为它们更接近硬件，但随着硬件的更快，甚至这种差异也变得无关紧要。这些语言是生产质量代码的完美选择，并且可能比大多数其他选择更稳定，因为它们已经投入了几十年的工作。**

**我承认，学习 Scheme/Lisp/rack 比学习 Python 要难一点点(但比学习 Java/JavaScript 容易多了)。然而，如果你这样做了，你会成为一个更好的程序员，你会慢慢欣赏这些语言的美丽，以至于没有其他语言能满足你。**