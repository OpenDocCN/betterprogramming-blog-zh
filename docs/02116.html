<html>
<head>
<title>Querying MongoDB Like an SQL DB Using Aggregation Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用聚合管道像查询SQL DB一样查询MongoDB</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/querying-mongodb-like-an-sql-db-using-aggregation-pipeline-9b7e1dc780b7?source=collection_archive---------1-----------------------#2019-11-07">https://betterprogramming.pub/querying-mongodb-like-an-sql-db-using-aggregation-pipeline-9b7e1dc780b7?source=collection_archive---------1-----------------------#2019-11-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a7c2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">要像老板一样在MongoDB中使用SQL SELECT、GROUP、JOIN、LIMIT和OFFSET查询，您只需要知道</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e16c18c67694c0f192c62a48da2fc364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0ENdi1HI8KErSzFP"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">斯蒂芬·道森在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="7501" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">什么是聚合？</h1><p id="3633" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">聚合操作处理数据记录并返回计算结果。聚合操作将多个文档中的值组合在一起，并可以对分组的数据执行各种操作以返回单个结果。</p><p id="bae2" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">在<code class="fe mw mx my mz b">db.collection.aggregate</code>方法和<code class="fe mw mx my mz b"><a class="ae kv" href="https://docs.mongodb.com/manual/reference/method/db.aggregate/#db.aggregate" rel="noopener ugc nofollow" target="_blank">db.aggregate</a></code>方法中，<a class="ae kv" href="https://docs.mongodb.com/manual/core/aggregation-pipeline/" rel="noopener ugc nofollow" target="_blank">流水线</a>阶段出现在一个数组中。文档按顺序通过各个阶段。我们将经历一些阶段来实现类似关系数据库的结果。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="53e4" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">$match(在哪里)</h1><p id="7523" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">过滤文档，只将符合指定条件的文档传递到下一个管道阶段。</p><p id="eecd" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">它有以下原型:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="116c" class="ne le iq mz b gy nf ng l nh ni">{ $match: { &lt;query&gt; } }</span></pre><p id="0dc8" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">它相当于SQL查询中的WHERE。让我们举个例子把事情说清楚。这个例子使用了一个名为<code class="fe mw mx my mz b">articles</code>的集合，包含以下文档:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="877e" class="ne le iq mz b gy nf ng l nh ni">{ "_id" : ObjectId("512bc95fe835e68f199c8686"), "author" : "dave", "score" : 80, "views" : 100 }<br/>{ "_id" : ObjectId("512bc962e835e68f199c8687"), "author" : "dave", "score" : 85, "views" : 521 }<br/>{ "_id" : ObjectId("55f5a192d4bede9ac365b257"), "author" : "ahn", "score" : 60, "views" : 1000 }<br/>{ "_id" : ObjectId("55f5a192d4bede9ac365b258"), "author" : "li", "score" : 55, "views" : 5000 }<br/>{ "_id" : ObjectId("55f5a1d3d4bede9ac365b259"), "author" : "annT", "score" : 60, "views" : 50 }<br/>{ "_id" : ObjectId("55f5a1d3d4bede9ac365b25a"), "author" : "li", "score" : 94, "views" : 999 }<br/>{ "_id" : ObjectId("55f5a1d3d4bede9ac365b25b"), "author" : "ty", "score" : 95, "views" : 1000 }</span></pre><p id="8657" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">平等匹配。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="b4ce" class="ne le iq mz b gy nf ng l nh ni">db.articles.aggregate(<br/>    [ { $match : { author : "dave" } } ]<br/>);</span><span id="d4a8" class="ne le iq mz b gy nj ng l nh ni">// Result<br/>{ "_id" : ObjectId("512bc95fe835e68f199c8686"), "author" : "dave", "score" : 80, "views" : 100 }<br/>{ "_id" : ObjectId("512bc962e835e68f199c8687"), "author" : "dave", "score" : 85, "views" : 521 }</span></pre><p id="bd43" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">在<code class="fe mw mx my mz b">$match</code>中我们可以有多个约束，比如<code class="fe mw mx my mz b">$or</code>、<code class="fe mw mx my mz b">$and</code>等。根据我们的要求，虽然它也有一些限制。你可以在<a class="ae kv" href="https://docs.mongodb.com/manual/reference/operator/aggregation/match/" rel="noopener ugc nofollow" target="_blank"> Mongo文档</a>中读到。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="4440" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">$skip(偏移)</h1><p id="370d" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">跳过传递到该阶段的指定数量的<a class="ae kv" href="https://docs.mongodb.com/manual/reference/glossary/#term-document" rel="noopener ugc nofollow" target="_blank">文档</a>，并将剩余的文档传递到<a class="ae kv" href="https://docs.mongodb.com/manual/reference/glossary/#term-pipeline" rel="noopener ugc nofollow" target="_blank">管道</a>中的下一阶段。它有以下原型:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="e9ca" class="ne le iq mz b gy nf ng l nh ni">{ $skip: &lt;positive integer&gt; }</span></pre><p id="8ddd" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">在上面的例子中，我们能够匹配与<code class="fe mw mx my mz b">dave</code>相关的记录。如果我们想从头开始跳过几个结果，我们可以将查询写成:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="6815" class="ne le iq mz b gy nf ng l nh ni">db.articles.aggregate([ <br/>    { $match : { author : "dave" } },<br/>    { $skip: 1 } <br/>]);</span><span id="c8d2" class="ne le iq mz b gy nj ng l nh ni">// We are skipping 1 result and we should get just this</span><span id="44aa" class="ne le iq mz b gy nj ng l nh ni">{ "_id" : ObjectId("5dc1d22f24a8e913bfcf4f60"), "author" : "dave", "score" : 85, "views" : 521 }</span></pre><p id="82f5" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我们通常使用<code class="fe mw mx my mz b">$skip</code>和<code class="fe mw mx my mz b">$limit</code>对数据进行分页，让我们将更多的记录插入到我们的集合中，并在下一节中看看<code class="fe mw mx my mz b">$skip</code>和<code class="fe mw mx my mz b">$limit</code>如何协同工作。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="7c43" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">美元限额(限额)</h1><p id="e2ae" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">限制传递到<a class="ae kv" href="https://docs.mongodb.com/manual/reference/glossary/#term-pipeline" rel="noopener ugc nofollow" target="_blank">管道</a>中下一个阶段的文档数量。它有以下原型:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="8fb3" class="ne le iq mz b gy nf ng l nh ni">{ $limit: &lt;positive integer&gt; }</span></pre><p id="0d07" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我们已经为<code class="fe mw mx my mz b">dave</code>添加了新的记录，让我们用一个简单的<code class="fe mw mx my mz b">$match</code>看看这些系列看起来怎么样:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="a8f7" class="ne le iq mz b gy nf ng l nh ni">db.articles.aggregate(<br/>    [ { $match : { author : "dave" } } ]<br/>);</span><span id="766d" class="ne le iq mz b gy nj ng l nh ni">{ "_id" : ObjectId("5dc1d22124a8e913bfcf4f5f"), "author" : "dave", "score" : 80, "views" : 100 }<br/>{ "_id" : ObjectId("5dc1d22f24a8e913bfcf4f60"), "author" : "dave", "score" : 85, "views" : 521 }<br/>{ "_id" : ObjectId("5dc1d53924a8e913bfcf4f65"), "author" : "dave", "score" : 185, "views" : 1521 }<br/>{ "_id" : ObjectId("5dc1d54f24a8e913bfcf4f66"), "author" : "dave", "score" : 15, "views" : 21 }</span></pre><p id="746c" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">在示例集合中，我们有四个匹配的记录。假设您被要求对结果进行分页，以便一次显示两个结果，您会怎么做？让我们看看。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="70b9" class="ne le iq mz b gy nf ng l nh ni">db.articles.aggregate([ <br/>    { $match : { author : "dave" } },<br/>    { $skip: 0},<br/>    { $limit: 2}<br/>]);</span><span id="41f8" class="ne le iq mz b gy nj ng l nh ni">// We are not skipping any records and but limiting the records to 2</span><span id="141a" class="ne le iq mz b gy nj ng l nh ni">{ "_id" : ObjectId("5dc1d22124a8e913bfcf4f5f"), "author" : "dave", "score" : 80, "views" : 100 }<br/>{ "_id" : ObjectId("5dc1d22f24a8e913bfcf4f60"), "author" : "dave", "score" : 85, "views" : 521 }</span><span id="6f4a" class="ne le iq mz b gy nj ng l nh ni">// We got the first two results, to get the next two results just update the $skip</span><span id="786d" class="ne le iq mz b gy nj ng l nh ni">db.articles.aggregate([ <br/>    { $match : { author : "dave" } },<br/>    { $skip: 2},<br/>    { $limit: 2}<br/>]);</span><span id="a4bb" class="ne le iq mz b gy nj ng l nh ni">// This should give two records after skipping the first two.</span><span id="d68e" class="ne le iq mz b gy nj ng l nh ni">{ "_id" : ObjectId("5dc1d53924a8e913bfcf4f65"), "author" : "dave", "score" : 185, "views" : 1521 }<br/>{ "_id" : ObjectId("5dc1d54f24a8e913bfcf4f66"), "author" : "dave", "score" : 15, "views" : 21 }</span></pre><p id="0e9b" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">到目前为止，我们做得很好，但是假设您的经理走到您面前，让您按视图对结果进行排序。你要怎么办？我们为此准备了<code class="fe mw mx my mz b">$sort</code>。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="d606" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">$sort(排序依据)</h1><p id="8a03" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">对所有输入文档进行排序，并按排序后的顺序将它们返回到管道。它有以下原型:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="bbd0" class="ne le iq mz b gy nf ng l nh ni">{ $sort: { &lt;field1&gt;: &lt;sort order&gt;, &lt;field2&gt;: &lt;sort order&gt; ... } }</span></pre><p id="c2c4" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">让我们使用管道中的<code class="fe mw mx my mz b">$sort</code>阶段。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="3da6" class="ne le iq mz b gy nf ng l nh ni">1 to specify ascending order<br/>-1 to specify descending order</span><span id="5b66" class="ne le iq mz b gy nj ng l nh ni">db.articles.aggregate([ <br/>    { $match : { author : "dave" } },<br/>    { $sort: { views: 1}}<br/>]);</span><span id="4d7f" class="ne le iq mz b gy nj ng l nh ni">// Result</span><span id="22ab" class="ne le iq mz b gy nj ng l nh ni">{ "_id" : ObjectId("5dc1d54f24a8e913bfcf4f66"), "author" : "dave", "score" : 15, "views" : 21 }<br/>{ "_id" : ObjectId("5dc1d22124a8e913bfcf4f5f"), "author" : "dave", "score" : 80, "views" : 100 }<br/>{ "_id" : ObjectId("5dc1d22f24a8e913bfcf4f60"), "author" : "dave", "score" : 85, "views" : 521 }<br/>{ "_id" : ObjectId("5dc1d53924a8e913bfcf4f65"), "author" : "dave", "score" : 185, "views" : 1521 }</span><span id="402d" class="ne le iq mz b gy nj ng l nh ni">Voilà ! The results are sorted now.</span></pre><p id="4027" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">尽可能早地将<code class="fe mw mx my mz b">$match</code>放在聚合<a class="ae kv" href="https://docs.mongodb.com/manual/reference/glossary/#term-pipeline" rel="noopener ugc nofollow" target="_blank">管道</a>中。因为<code class="fe mw mx my mz b">$match</code>限制了聚合管道中的文档总数，所以更早的<code class="fe mw mx my mz b">$match</code>操作可以最小化管道中的处理量。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="43af" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">$组</h1><p id="f320" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">根据指定的<code class="fe mw mx my mz b">_id</code>表达式对输入文档进行分组，并为每个不同的分组输出一个文档。</p><p id="7ccf" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">每个输出文档的<code class="fe mw mx my mz b">_id</code>字段包含唯一的分组依据值。输出文档还可以包含计算字段，这些字段包含一个<a class="ae kv" href="https://docs.mongodb.com/manual/reference/operator/aggregation/group/#accumulators-group" rel="noopener ugc nofollow" target="_blank">累加器表达式</a>的值。它有以下原型:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="2c77" class="ne le iq mz b gy nf ng l nh ni">{<br/>  $group:<br/>    {<br/>      _id: &lt;expression&gt;, // Group By Expression<br/>      &lt;field1&gt;: { &lt;accumulator1&gt; : &lt;expression1&gt; },<br/>      ...<br/>    }<br/>}</span></pre><p id="8a1b" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">假设我们想按作者对文章进行分组，换句话说，按每个作者的文章数量进行分组，我们可以利用管道中的分组阶段。所以，让我们来看看现场直播:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="b8d6" class="ne le iq mz b gy nf ng l nh ni">db.articles.aggregate([ <br/>    { $group : { _id: "$author", count: { $sum: 1 }}},<br/>    { $sort: { count: 1 }}<br/>]);</span><span id="4fb2" class="ne le iq mz b gy nj ng l nh ni">// We have grouped the articles by author ann getting the count and sorting it by count</span><span id="5691" class="ne le iq mz b gy nj ng l nh ni">{ "_id" : "annT", "count" : 1 }<br/>{ "_id" : "ahn", "count" : 1 }<br/>{ "_id" : "li", "count" : 2 }<br/>{ "_id" : "dave", "count" : 4 }</span><span id="71fb" class="ne le iq mz b gy nj ng l nh ni">// We can have more constraints like if we want only the results whose count is greater than 1, then we can add a $match stage in the pipeline after $group</span><span id="9690" class="ne le iq mz b gy nj ng l nh ni">db.articles.aggregate([ <br/>    { $group : { _id: "$author", count: { $sum: 1 }}},<br/>    { $sort: { count: 1 }},<br/>    { $match: { count : { $gt: 1 }}}<br/>]);</span><span id="9c6a" class="ne le iq mz b gy nj ng l nh ni">{ "_id" : "li", "count" : 2 }<br/>{ "_id" : "dave", "count" : 4 }</span></pre><p id="0849" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">让我们把这一组提高一个档次。假设我们想按数组结构中存储的值进行分组。我们有个东西叫<code class="fe mw mx my mz b">$unwind</code>。让我们看看它是如何工作的。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="7b93" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">$展开</h1><p id="c46b" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">从输入文档中解构一个数组字段，为每个元素输出一个文档。每个输出文档都是输入文档，其中数组字段的值被元素替换。</p><p id="a71c" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">可以将数组字段路径传递给<code class="fe mw mx my mz b">$unwind</code>。使用此语法时，如果字段值为null、缺失或空数组，<code class="fe mw mx my mz b">$unwind</code>不会输出文档。它有以下原型:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="f011" class="ne le iq mz b gy nf ng l nh ni">{ $unwind: &lt;field path&gt; }</span></pre><p id="a3e1" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">让我们用下面的命令获取一个新集合<code class="fe mw mx my mz b">inventory</code>和一个新记录:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="a00c" class="ne le iq mz b gy nf ng l nh ni">db.inventory.insertOne({ "_id" : 1, "item" : "ABC1", sizes: [ "S", "M", "L"] })</span></pre><p id="4e9d" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这就是MongoDB的美妙之处，您可以创建一个新的集合，每个文档都与输入文档相同，除了<code class="fe mw mx my mz b">sizes</code>字段的值现在保存了来自原始<code class="fe mw mx my mz b">sizes</code>数组的值。在没有任何设置的情况下向其添加记录。</p><p id="5de0" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">让我们按尺寸来看这个。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="f5b5" class="ne le iq mz b gy nf ng l nh ni">db.inventory.aggregate( [ { $unwind : "$sizes" } ] )</span><span id="9dc6" class="ne le iq mz b gy nj ng l nh ni">// Result<br/>{ "_id" : 1, "item" : "ABC1", "sizes" : "S" }<br/>{ "_id" : 1, "item" : "ABC1", "sizes" : "M" }<br/>{ "_id" : 1, "item" : "ABC1", "sizes" : "L" }</span></pre><p id="fa7d" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">除了<code class="fe mw mx my mz b">sizes</code>字段的值之外，每个文档都与输入文档相同，该字段现在保存来自原始<code class="fe mw mx my mz b">sizes</code>数组的值。</p><p id="b06c" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">让我们取一个新的集合<code class="fe mw mx my mz b">inventory2</code>并按大小做一个分组，使用这个命令插入更多的记录:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="8395" class="ne le iq mz b gy nf ng l nh ni">db.inventory2.insertMany([<br/>  { "_id" : 1, "item" : "ABC", price: NumberDecimal("80"), "sizes": [ "S", "M", "L"] },<br/>  { "_id" : 2, "item" : "EFG", price: NumberDecimal("120"), "sizes" : [ ] },<br/>  { "_id" : 3, "item" : "IJK", price: NumberDecimal("160"), "sizes": "M" },<br/>  { "_id" : 4, "item" : "LMN" , price: NumberDecimal("10") },<br/>  { "_id" : 5, "item" : "XYZ", price: NumberDecimal("5.75"), "sizes" : null }<br/>])</span></pre><p id="92f1" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">如果我们展开它，我们会得到这样的结果:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="b3f4" class="ne le iq mz b gy nf ng l nh ni">db.inventory2.aggregate( [ { $unwind: "$sizes" } ] )</span><span id="3cdb" class="ne le iq mz b gy nj ng l nh ni">// Results</span><span id="d5fe" class="ne le iq mz b gy nj ng l nh ni">{ "_id" : 1, "item" : "ABC", "price" : NumberDecimal("80"), "sizes" : "S" }<br/>{ "_id" : 1, "item" : "ABC", "price" : NumberDecimal("80"), "sizes" : "M" }<br/>{ "_id" : 1, "item" : "ABC", "price" : NumberDecimal("80"), "sizes" : "L" }<br/>{ "_id" : 3, "item" : "IJK", "price" : NumberDecimal("160"), "sizes" : "M" }</span><span id="e5bc" class="ne le iq mz b gy nj ng l nh ni">// Notice it ignores the null and undefined values</span><span id="b462" class="ne le iq mz b gy nj ng l nh ni">db.articles.aggregate([ <br/>    { $unwind: { path: "$sizes" } },<br/>    { $group: { _id: "$sizes", count: { $sum: 1 }}}<br/>]);</span><span id="96da" class="ne le iq mz b gy nj ng l nh ni">// Results</span><span id="30a4" class="ne le iq mz b gy nj ng l nh ni">{ "_id" : "M", "count" : 2 }<br/>{ "_id" : "L", "count" : 1 }<br/>{ "_id" : "S", "count" : 1 }</span></pre><p id="aa4c" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我们可以对此应用不同的阶段，如<code class="fe mw mx my mz b">$match</code>、<code class="fe mw mx my mz b">$sort</code>、<code class="fe mw mx my mz b">$skip</code>、<code class="fe mw mx my mz b">$limit</code>等。才能得到想要的结果。</p><p id="72e6" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">现在，让我们继续讨论SQL连接，在MongoDB中我们有<code class="fe mw mx my mz b">$lookup</code>来实现连接。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="015d" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">$lookup</h1><p id="3e65" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated"><em class="nk">3.2版本新增。</em></p><p id="380e" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">对<em class="nk"> same </em>数据库中的非共享集合执行左外连接，以从“连接”集合中过滤文档进行处理。</p><p id="5cf1" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">对于每个输入文档，<code class="fe mw mx my mz b">$lookup</code>阶段添加一个新的数组字段，其元素是来自“joined”集合的匹配文档。<code class="fe mw mx my mz b">$lookup</code>阶段将这些整形后的文档传递到下一阶段。</p><p id="5f05" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">可以有不同的连接条件，但我们将研究最基本的条件，即相等匹配。</p><h2 id="a618" class="ne le iq bd lf nl nm dn lj nn no dp ln me np nq lp mi nr ns lr mm nt nu lt nv bi translated">平等匹配</h2><p id="15d5" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">在两个集合之间执行不相关的子查询，并允许除单个相等匹配之外的其他连接条件。<code class="fe mw mx my mz b"><a class="ae kv" href="https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/#pipe._S_lookup" rel="noopener ugc nofollow" target="_blank">$lookup</a></code>阶段具有以下语法:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="7bcb" class="ne le iq mz b gy nf ng l nh ni">{<br/>   $lookup:<br/>     {<br/>       from: &lt;collection to join&gt;,<br/>       let: { &lt;var_1&gt;: &lt;expression&gt;, …, &lt;var_n&gt;: &lt;expression&gt; },<br/>       pipeline: [ &lt;pipeline to execute on the collection to join&gt; ],<br/>       as: &lt;output array field&gt;<br/>     }<br/>}</span><span id="73cf" class="ne le iq mz b gy nj ng l nh ni"><strong class="mz ir">from: </strong>Specifies the collection in the <em class="nk">same</em> database to perform the join with.</span><span id="f7a5" class="ne le iq mz b gy nj ng l nh ni"><strong class="mz ir">let: </strong>Optional. Specifies variables to use in the <!-- -->pipeline<!-- --> field stages. Use the variable expressions to access the fields from the documents input to the $lookup stage.</span><span id="d284" class="ne le iq mz b gy nj ng l nh ni"><strong class="mz ir">pipeline: </strong>Specifies the pipeline to run on the joined collection. The <!-- -->pipeline<!-- --> determines the resulting documents from the joined collection. To return all documents, specify an empty pipeline <!-- -->[].</span><span id="a6ac" class="ne le iq mz b gy nj ng l nh ni"><strong class="mz ir">as</strong>: Specifies the name of the new array field to add to the input documents. The new array field contains the matching documents from the <!-- -->from<!-- --> collection. If the specified name already exists in the input document, the existing field is <em class="nk">overwritten</em>.</span></pre><p id="9928" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">让我们看一些例子来更好地理解术语:</p><h2 id="395e" class="ne le iq bd lf nl nm dn lj nn no dp ln me np nq lp mi nr ns lr mm nt nu lt nv bi translated">使用$lookup执行单个等式连接</h2><p id="8b2a" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">使用以下文档创建集合<code class="fe mw mx my mz b">orders</code>:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="1a66" class="ne le iq mz b gy nf ng l nh ni">db.orders.insert([<br/>   { "_id" : 1, "item" : "almonds", "price" : 12, "quantity" : 2 },<br/>   { "_id" : 2, "item" : "pecans", "price" : 20, "quantity" : 1 },<br/>   { "_id" : 3  }<br/>])</span></pre><p id="1b5f" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">使用以下文档创建另一个集合<code class="fe mw mx my mz b">inventory</code>:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="969b" class="ne le iq mz b gy nf ng l nh ni">db.inventory.insert([<br/>   { "_id" : 1, "sku" : "almonds", description: "product 1", "instock" : 120 },<br/>   { "_id" : 2, "sku" : "bread", description: "product 2", "instock" : 80 },<br/>   { "_id" : 3, "sku" : "cashews", description: "product 3", "instock" : 60 },<br/>   { "_id" : 4, "sku" : "pecans", description: "product 4", "instock" : 70 },<br/>   { "_id" : 5, "sku": null, description: "Incomplete" },<br/>   { "_id" : 6 }<br/>])</span></pre><p id="eb67" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">下面对<code class="fe mw mx my mz b">orders</code>集合的聚合操作使用来自<code class="fe mw mx my mz b">orders</code>集合的字段<code class="fe mw mx my mz b">item</code>和来自<code class="fe mw mx my mz b">inventory</code>集合的字段<code class="fe mw mx my mz b">sku</code>将来自<code class="fe mw mx my mz b">orders</code>的文档与来自<code class="fe mw mx my mz b">inventory</code>集合的文档连接起来:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="12fb" class="ne le iq mz b gy nf ng l nh ni">db.orders.aggregate([<br/>   {<br/>     $lookup:<br/>       {<br/>         from: "inventory",<br/>         localField: "item",<br/>         foreignField: "sku",<br/>         as: "inventory_docs"<br/>       }<br/>  }<br/>]);</span></pre><p id="303d" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">该操作返回以下文档:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="4c4e" class="ne le iq mz b gy nf ng l nh ni">{<br/>   "_id" : 1,<br/>   "item" : "almonds",<br/>   "price" : 12,<br/>   "quantity" : 2,<br/>   "inventory_docs" : [<br/>      { "_id" : 1, "sku" : "almonds", "description" : "product 1", "instock" : 120 }<br/>   ]<br/>}<br/>{<br/>   "_id" : 2,<br/>   "item" : "pecans",<br/>   "price" : 20,<br/>   "quantity" : 1,<br/>   "inventory_docs" : [<br/>      { "_id" : 4, "sku" : "pecans", "description" : "product 4", "instock" : 70 }<br/>   ]<br/>}<br/>{<br/>   "_id" : 3,<br/>   "inventory_docs" : [<br/>      { "_id" : 5, "sku" : null, "description" : "Incomplete" },<br/>      { "_id" : 6 }<br/>   ]<br/>}</span></pre></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="514e" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">结论</h1><p id="651d" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">这只是在MongoDB中使用类似SQL的查询的基本概述。</p><p id="e9bd" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">使用许多其他可用的<a class="ae kv" href="https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/" rel="noopener ugc nofollow" target="_blank">阶段</a>可以做更多的事情。掌握它的最好方法是练习不同的场景，并在项目中使用它们。希望这能有所帮助。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="6f46" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">资源</h1><p id="3ace" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated"><a class="ae kv" href="https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/" rel="noopener ugc nofollow" target="_blank"> MongoDB文档</a></p></div></div>    
</body>
</html>