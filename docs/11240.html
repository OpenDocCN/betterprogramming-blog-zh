<html>
<head>
<title>6 JavaScript Do’s and Don’t</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6 JavaScript应该做和不应该做的事情</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-javascript-dos-and-don-t-e020a4228dfa?source=collection_archive---------8-----------------------#2022-03-01">https://betterprogramming.pub/6-javascript-dos-and-don-t-e020a4228dfa?source=collection_archive---------8-----------------------#2022-03-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bfe8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">优化和拥有可读一致代码的技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/21eac4bf4057bb3a95986d9c0a8a5b19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5KyZV2i-fXMv8RRLUrPRVg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者捕获</p></figure><p id="27c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JavaScript语言自诞生以来经历了快速的发展。有如此多的新特性、变化和新框架，很难跟踪好的实践。</p><p id="be6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将检查一些最适合在JavaScript中使用的通用经验法则。这些精选的技巧将帮助我们写出更好的代码。它们非常适合初学者和有经验的JavaScript开发人员。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="7caf" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">1.每行声明一个变量</h1><p id="0e3d" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在JavaScript中，每行可以声明多个变量。不过，这是我不愿意做的事情。通过每行声明一个变量，代码将变得更容易阅读和理解。</p><p id="9e0a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看一些代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="5a07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一行程序可能看起来有点酷，但是不切实际。这使得代码更难阅读。这种技术也可能导致不希望的结果。</p><p id="64e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的例子中，即使看起来<code class="fe na nb nc nd b">x</code>、<code class="fe na nb nc nd b">y</code>和<code class="fe na nb nc nd b">z</code>是常量变量，但事实并非如此。只有<code class="fe na nb nc nd b">x</code>是常量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="963d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像所有的规则一样，有时也有例外。使用<code class="fe na nb nc nd b">ES6</code>析构特性时，你可以每行声明多个变量。</p><p id="38af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1b36" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，这是最好的解决方案。每行声明一个变量会显得重复。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="6b59" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">2.了解浏览器优化</h1><p id="06e4" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">因为JavaScript没有被编译，所以引擎可以进行优化的唯一方式就是在运行时。他们将得出结论，并找出在旅途中执行优化的方法。</p><p id="3dde" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些优化是隐藏的，有时很难理解。每个供应商都有自己的优化实现。比如在Chrome的<code class="fe na nb nc nd b">v8</code>上，那个优化引擎叫做<code class="fe na nb nc nd b">TurboFan</code>。通过理解其内部的一些基础知识，我们可以产生一个更有效的代码。</p><p id="bdf3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们选择完全忽略引擎，我们可能会产生一些性能损失的代码。我们的应用程序执行速度会变慢，这会损害用户的体验。</p><p id="ddbf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看几个我们可能从中受益的快速成功案例:</p><h2 id="300c" class="ne mc it bd md nf ng dn mh nh ni dp ml lh nj nk mn ll nl nm mp lp nn no mr np bi translated">原型</h2><p id="05bb" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">JavaScript引擎知道原型突变很少见。对象原型通常是可预测的和稳定的。这就是引擎试图在原型对象的早期执行一些优化的原因。</p><p id="406e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，这也有不好的一面。当改变一个原型对象时，引擎必须重新计算所有的优化。这使得这种变异对性能产生不利影响，可能会降低我们的代码速度。它甚至可能会降低一些与原型交互的代码的速度。</p><p id="b9b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个虚拟的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="869a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你真的需要做类似上述场景的事情，只需使用对象属性。这些不会导致原型及其优化被重新计算。</p><p id="7dcf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们修正前面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9171" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在下面的MDN文章<a class="ae nq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/The_performance_hazards_of_prototype_mutation" rel="noopener ugc nofollow" target="_blank">中找到关于这个主题的更多信息。</a></p><h2 id="4546" class="ne mc it bd md nf ng dn mh nh ni dp ml lh nj nk mn ll nl nm mp lp nn no mr np bi translated">类型专门化</h2><p id="b984" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">由于JavaScript使用了一种编译方法，这意味着它必须在执行任何函数之前进行大量的检查。它严重依赖优化来提高性能。</p><p id="f7f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">优化是如何发生的？当一个函数被频繁调用时，它会变热。引擎存储其编译版本。当函数变得更热时，它将被发送到优化编译器。那里有很多优化策略。</p><p id="d440" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中一个优化就是类型规范。该函数将为类型和参数的每个组合创建一个存根。这意味着，如果我们的函数是单态的(具有相同的参数和类型)，它将只需要一个存根。如果它是多态的，那么每个参数和类型组合都需要一个存根。</p><p id="2b60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，通过尝试保持相同的参数和类型，我们的方法将更加有效和高性能。</p><p id="dcfb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="7c9b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们用不同的参数调用这个方法，它不会执行得那么快。</p><p id="fa9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看上面这个函数的一个不好的用法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2a78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像TypeScript这样的工具可以帮助我们尽可能高效地保持我们的方法。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="9a3b" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">3.早点回来</h1><p id="5317" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我们已经习惯了这种模式，几乎没有质疑过它。但是，通过经验，你可能会意识到，一个充满了<code class="fe na nb nc nd b">if</code>和<code class="fe na nb nc nd b">else</code>的代码是:</p><ul class=""><li id="5c05" class="nr ns it la b lb lc le lf lh nt ll nu lp nv lt nw nx ny nz bi translated">无能的</li><li id="f361" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">难以阅读</li><li id="f57d" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">难以维护</li></ul><p id="e8a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们如何改进我们的代码库？只是通过拥抱<strong class="la iu"> <em class="of">回归早期模式</em> </strong>。</p><p id="ad6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“提前返回”是一种模式，建议尽早返回结果，而不是使用<code class="fe na nb nc nd b">else</code>语句。</p><p id="e1c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们实现经典的<code class="fe na nb nc nd b">FizzBuzz</code>功能。</p><p id="2c11" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的代码可能是一个解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="e22d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果我们应用提前返回模式，上面的代码可以简化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2d5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们的代码库可以变成:</p><ul class=""><li id="b1f3" class="nr ns it la b lb lc le lf lh nt ll nu lp nv lt nw nx ny nz bi translated">更加做作</li><li id="5545" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">可读性更强</li><li id="1af8" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">更有效率</li></ul></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="f67c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">4.拥抱函数式编程</h1><p id="8194" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">JavaScript语言是多范例的。我们可以在面向对象编程和函数式编程风格之间进行选择。添加了<code class="fe na nb nc nd b">ES6</code>类后，前者变得更加容易访问。最近添加的<code class="fe na nb nc nd b">private fields</code>增加了JS社区长期要求的特性。</p><p id="eb57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，对于JavaScript原型继承行为来说，这只是一种简单的语法。这会导致挣扎、困惑和沮丧。</p><p id="4be2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我看来，函数式编程方法导致代码更加模块化和易于测试。</p><p id="ef26" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看看React团队是如何通过摒弃类方法来简化开发过程的。即使你没有在React中编写代码，你也能体会到巨大的不同。</p><p id="23d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个使用React类的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="aeda" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们使用新的函数方法重写相同的组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="6c4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们在仪式上花费更少的代码，这使得它不那么令人分心，更容易跟随。</p><p id="3517" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">函数式编程有更多的好处。它让我们避免了许多变异实体带来的问题。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="6f91" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">5.总是使用三重等式</h1><p id="0d05" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">双重相等<code class="fe na nb nc nd b">==</code>是一个比较运算符，它转换操作数以匹配相同的类型。</p><p id="7547" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它使用类型强制来比较值。例如，当比较<code class="fe na nb nc nd b">number</code>和<code class="fe na nb nc nd b">string</code>时，引擎会将<code class="fe na nb nc nd b">string</code>转换为<code class="fe na nb nc nd b">number</code>，然后进行比较。</p><p id="aa42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe na nb nc nd b">==</code>操作符检查值的相等性，而不是类型。</p><p id="ad42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一些例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ad05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这可能会导致一些有趣的等式，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/3a4000862b9a4feb73832fba36cc0a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ioM9fQxsSEI55sTLKmWsw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae nq" href="https://dorey.github.io/" rel="noopener ugc nofollow" target="_blank">https://dorey.github.io/</a>的平等表</p></figure><p id="67d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了防止不必要的行为，最好检查类型和值。这可以通过使用严格相等运算符<code class="fe na nb nc nd b">===</code>来实现。</p><p id="d76e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">严格相等将首先比较值类型。如果它们不相等，它将返回false。只有当它们匹配时，它才会检查它的值。</p><p id="2618" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="of"> ⚠️有其特殊性，即</em> <code class="fe na nb nc nd b"><em class="of">NaN</em></code> <em class="of">的值永远不会严格相等。为此，我们可以使用</em> <code class="fe na nb nc nd b"><em class="of">isNan</em></code> <em class="of">运算符。</em></p><p id="92cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看操作人员的工作情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="f5be" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">6.等待承诺</h1><p id="dbc3" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在JavaScript出现之前，用JavaScript处理异步操作是很乏味的。都是通过复试完成的。这就导致了俗称的<code class="fe na nb nc nd b">callback hell</code>。代码很难阅读和维护。Promise帮助我们写出了更好的代码，但它远非完美，它可能会导致<code class="fe na nb nc nd b">promise hell</code>。</p><p id="c4b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe na nb nc nd b">aysnc/await</code>功能作为<code class="fe na nb nc nd b">ES7</code>规格的一部分发布。它简化了我们在JavaScript中处理承诺的方式。我们现在可以用更同步的方式编写代码。引擎会帮我们做所有的重活。<code class="fe na nb nc nd b">ES12</code>中<code class="fe na nb nc nd b">top level await</code>的发布增加了该功能缺失的最后一块。</p><p id="ec7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如今，我们想要使用承诺而不是<code class="fe na nb nc nd b">async/await</code>的场景并不多。使用<code class="fe na nb nc nd b">async/await</code>确实增加了代码的可读性和可维护性。</p><p id="f16e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="efda" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们用<code class="fe na nb nc nd b">async/await</code>重写代码，它确实变得更容易阅读:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="20c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe na nb nc nd b">async/await</code>与新的Promise APIs如<code class="fe na nb nc nd b">Promise.all</code>、<code class="fe na nb nc nd b">Promise.any</code>、<code class="fe na nb nc nd b">Promise.allSettled</code>、…</p><p id="1080" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个带有最新<code class="fe na nb nc nd b">ES12</code> Promise特性和<code class="fe na nb nc nd b">async/await</code>的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="da0c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">最后一个音符</h1><p id="55f0" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">所以当谈到用JavaScript编码时，这些是我的选择。当然，还有很多技巧，但这是我最喜欢的六个。使用<code class="fe na nb nc nd b">Strict</code>的重要性紧随其后。幸运的是，我们不必太担心它，因为已经有工具为我们执行了。</p><p id="19b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">必须使用<code class="fe na nb nc nd b">ESLint</code>。它将使开发周期自动化，并帮助我们编写更好的代码。这将加速代码审查过程。尽早获得快速反馈总是受欢迎的。</p><p id="ad8b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您是否发现缺少任何提示？让我知道哪些是你最喜欢的。</p><div class="oh oi gp gr oj ok"><a rel="noopener  ugc nofollow" target="_blank" href="/7-tips-to-write-efficient-and-performant-javascript-code-bccbdb9662ae"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">编写高效高性能JavaScript代码的7个技巧</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">提升您的JavaScript应用程序的性能</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">better编程. pub</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div></div></div>    
</body>
</html>