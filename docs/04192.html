<html>
<head>
<title>5 Things Novice React Developers Do Wrong</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">新手反应开发者做错的5件事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-things-novice-react-developers-do-wrong-9d97bd6dae95?source=collection_archive---------2-----------------------#2020-03-29">https://betterprogramming.pub/5-things-novice-react-developers-do-wrong-9d97bd6dae95?source=collection_archive---------2-----------------------#2020-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fb79" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">不要做什么，如果做了该如何改正</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/28ddc348f9d7f32536e4030c45f80858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*amMAm9xs8uXZw_1c"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@valeriydmi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Valeriy Khan </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7ea5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章是为完全是React新手的开发人员和React新手开发人员准备的。我们开始吧！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="cd58" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak"> 1。忘记大写反应组件</strong></h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="f494" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑这段代码。它为父组件创建了一个简单的带有标题的<code class="fe mt mu mv mw b">div</code>。里面有一个子组件，由带有一些文本的<code class="fe mt mu mv mw b">div</code>组成。你认为代码运行时会出现什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/0a01f2e34d22e7ddeda68bdd85d7d773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*RiqUftwRUO2G2EpN_cINIg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">预期与实际</p></figure><p id="46fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mt mu mv mw b">childComponent</code>未被渲染。它去哪里了？代码编译成功。终端也没有错误。</p><p id="0cf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再看一下子组件的代码。请注意组件的名称。你注意到什么不同了吗？</p><p id="50a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在浏览器上打开控制台。(<code class="fe mt mu mv mw b">CTRL + SHIFT + C</code>Windows上|<code class="fe mt mu mv mw b">Command + Option + C</code>Mac上|右键- &gt;鼠标上的“检查”。)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/1eaf3d5b1da6c8a9511aff86edc38534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IVfdq4Q8qELsVyW63wIK5g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">浏览器控制台警告不正确的大小写</p></figure><p id="b49b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实证明，React将小写组件视为DOM标记。如果你是React新手，你可能已经错过了React文档中的这个小细节。</p><p id="80aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果不知道这一点，即使他们的代码编译没有错误，初学者也常常会困惑于哪里出错了。</p><p id="8dde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决方法很简单。大写你的组件。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7b54" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">2.错误调用收到的道具</h1><p id="2756" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">为了访问由父组件传入的属性，子组件必须确保它们调用正确的属性名。</p><p id="196f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也可以使用另一个变量名将Props传递给子组件。考虑以下代码片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="3db6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这段代码可以编译并运行而不会出错，但是在<code class="fe mt mu mv mw b">ChildComponent</code>中不会显示任何文本。</p><pre class="kg kh ki kj gt ne mw nf ng aw nh bi"><span id="692c" class="ni ma iq mw b gy nj nk l nl nm">&lt;ChildComponent mainText={randomString} /&gt;</span></pre><p id="4767" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仔细看看这行代码。在<code class="fe mt mu mv mw b">ParentComponent</code>内部声明的变量<code class="fe mt mu mv mw b">randomString</code>被作为一个名为<code class="fe mt mu mv mw b">mainText</code>的道具传入<code class="fe mt mu mv mw b">ChildComponent</code>。</p><p id="2b1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，<code class="fe mt mu mv mw b">ChildComponent</code>正试图从它收到的道具中访问<code class="fe mt mu mv mw b">randomString</code>。由于它只收到了作为道具的<code class="fe mt mu mv mw b">mainText</code>，这将导致<code class="fe mt mu mv mw b">undefined</code>被分配给在<code class="fe mt mu mv mw b">ChildComponent</code>中声明的<code class="fe mt mu mv mw b">randomString</code>。因此，在它的<code class="fe mt mu mv mw b">&lt;p&gt;</code>标签中不会呈现任何内容。</p><p id="c5e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记下哪些属性被传递到组件中，并相应地访问它们。这将为您在调试过程中省去一些不必要的麻烦。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="55c1" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">3.传递不正确类型的道具</h1><p id="9d94" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">如果接收到的属性不是预期的类型，依赖于这些接收到的属性的组件可能表现不同。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="009c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑这个<code class="fe mt mu mv mw b">ChildComponent</code>接收两个道具:<code class="fe mt mu mv mw b">showIntro</code>和<code class="fe mt mu mv mw b">showBody</code>。它显示“你好！”和“发现错误！”<em class="nn"> </em>仅当<code class="fe mt mu mv mw b">showIntro</code>和<code class="fe mt mu mv mw b">showBody</code>分别设置为真时。</p><p id="98ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mt mu mv mw b">ChildComponent</code>期望两个布尔值作为道具传递。如果在父组件中做类似这样的事情会发生什么？</p><pre class="kg kh ki kj gt ne mw nf ng aw nh bi"><span id="0198" class="ni ma iq mw b gy nj nk l nl nm">&lt;ChildComponent showIntro='false' showBody='false' /&gt;</span><span id="65b1" class="ni ma iq mw b gy no nk l nl nm">&lt;ChildComponent showIntro={'false'} showBody={'false'} /&gt;</span><span id="1f0e" class="ni ma iq mw b gy no nk l nl nm">&lt;ChildComponent showIntro={false} showBody={false} /&gt;</span></pre><p id="cf50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">引号和花括号的不同用法被用来传递道具。然而，他们的行为不会是一样的。看看这个:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/bd466abf952fb5a77a695f8ed4ac06e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*TCgVBEiasi9JAaoOV3VquQ.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">实际的</p></figure><p id="a427" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为前两个<code class="fe mt mu mv mw b">ChildComponent</code>而不是最后一个<code class="fe mt mu mv mw b">ChildComponent</code>渲染两个<code class="fe mt mu mv mw b">&lt;p&gt;</code>标签。</p><p id="3586" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将<code class="fe mt mu mv mw b">'false'</code>和<code class="fe mt mu mv mw b">{'false'}</code>作为道具传入会导致<code class="fe mt mu mv mw b">showIntro</code>和<code class="fe mt mu mv mw b">showBody</code>被无意地赋值为一个<em class="nn">字符串</em>，其值为<code class="fe mt mu mv mw b">false</code>，而不是<em class="nn">布尔值</em> <code class="fe mt mu mv mw b">false</code>。</p><p id="1c5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mt mu mv mw b">showIntro</code>和<code class="fe mt mu mv mw b">showBody</code>在前两个<code class="fe mt mu mv mw b">ChildComponent</code>都被评估为<code class="fe mt mu mv mw b">true</code>。</p><p id="1e5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是由于<code class="fe mt mu mv mw b">&amp;&amp;</code>操作符的隐式类型强制。当<code class="fe mt mu mv mw b">&amp;&amp;</code>操作员勾选<code class="fe mt mu mv mw b">showIntro</code>或<code class="fe mt mu mv mw b">showBody</code>(都是字符串)时，两个字符串都会被强制到<code class="fe mt mu mv mw b">true</code>。</p><p id="467d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一个<code class="fe mt mu mv mw b">ChildComponent</code>收到了<em class="nn">布尔</em> <strong class="ky ir"> </strong> <code class="fe mt mu mv mw b">false</code>，因此它正确地呈现了nothing。</p><pre class="kg kh ki kj gt ne mw nf ng aw nh bi"><span id="23d2" class="ni ma iq mw b gy nj nk l nl nm">console.log(`showIntro type: ${typeof showIntro}`);<br/>console.log(`showIntro evaluated to: ${showIntro &amp;&amp; true}`);</span><span id="097a" class="ni ma iq mw b gy no nk l nl nm">console.log(`showBody type: ${typeof showBody}`);<br/>console.log(`showBody evaluated to: ${showBody &amp;&amp; true}`);</span></pre><p id="002a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了证实这一点，让我们运行<code class="fe mt mu mv mw b">console.log()</code>来检查我们的道具在每个<code class="fe mt mu mv mw b">ChildComponent</code>中被评估到什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/58437fbbd0d353ba9cd9a98df8b28003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*vss4wYAciyydwdt5xYsXEg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">通过console.log()检查道具的类型和评估</p></figure><p id="725f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如这里所演示的，初学者在将道具传递给其他组件时能够区分使用引号和花括号之间的区别是至关重要的。</p><p id="0af0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用引号传入字符串文字。</p><pre class="kg kh ki kj gt ne mw nf ng aw nh bi"><span id="a803" class="ni ma iq mw b gy nj nk l nl nm">&lt;MyComponent data='Hello World!'/&gt; // passing in a String</span></pre><p id="8e41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">花括号用于传入JavaScript表达式。</p><pre class="kg kh ki kj gt ne mw nf ng aw nh bi"><span id="6524" class="ni ma iq mw b gy nj nk l nl nm">&lt;MyComponent data={2468} /&gt; // passing in a Number<br/>&lt;MyComponent data={true} /&gt; // passing in a Boolean</span></pre><p id="3d07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还应该注意React文档中的一些内容:</p><blockquote class="nr"><p id="db27" class="ns nt iq bd nu nv nw nx ny nz oa lr dk translated">“在属性中嵌入JavaScript表达式时，不要用引号括起来。您应该使用引号(对于字符串值)或花括号(对于表达式)，但不能在同一个属性中同时使用两者。</p></blockquote></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a809" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">4.在render()内调用setState()</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/8b67ccb1343435cc932ec89a3d3e5a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NZ9spo__oZJXCwiVSjMMIg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">无限循环错误消息</p></figure><p id="1d2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管您的组件中没有<code class="fe mt mu mv mw b">componentWillUpdate()</code>或<code class="fe mt mu mv mw b">componentWillUpdate()</code>，您可能还是会遇到这个错误。不要担心，当您在您的<code class="fe mt mu mv mw b">render()</code>函数中调用<code class="fe mt mu mv mw b">setState()</code>时，也会出现这个错误。</p><p id="22ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么会这样？每次调用<code class="fe mt mu mv mw b">setState()</code>，React都会通过调用<code class="fe mt mu mv mw b">render()</code>重新渲染。你的<code class="fe mt mu mv mw b">render()</code>函数里面有什么？<code class="fe mt mu mv mw b">setState()</code>。你知道这是怎么回事吗？无限循环。</p><p id="a76b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只需将您的<code class="fe mt mu mv mw b">setState()</code>调用移出您的<code class="fe mt mu mv mw b">render()</code>函数。</p><p id="88e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您必须在组件挂载之后初始化您的状态(也许您正在从API端点获取数据)，那么在<code class="fe mt mu mv mw b">componentDidMount()</code>内部完成。</p><p id="cdae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果可以在组件挂载之前初始化状态，也可以使用构造函数来完成。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="33dd" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">5.setState()的异步特性</h1><p id="8406" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">调试时，使用<code class="fe mt mu mv mw b">console.log()</code>打印数值是一种常见的方法。然而，当代码异步运行时，这并不能很好地工作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="3fed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你以前试过这样做吗？坏消息— <code class="fe mt mu mv mw b">setState()</code>调用是异步的。不能保证给定的代码会按顺序执行。它可能会导致如下输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/058629cf89de095d26aa2f077e64db84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJljheGz6VjwwjyF-6zAqQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在setState()前后调用console.log(state)</p></figure><p id="40ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在执行<code class="fe mt mu mv mw b">setState()</code>之前执行的两个<code class="fe mt mu mv mw b">console.log()</code>调用。因此，它打印两次前一状态的值。</p><p id="e685" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您希望在调用<code class="fe mt mu mv mw b">setState()</code>之前和之后检查状态的值，请在<code class="fe mt mu mv mw b">setState()</code>中传递一个回调作为第二个参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="62ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回调将在<code class="fe mt mu mv mw b">setState()</code>完成后执行，因此为您的<code class="fe mt mu mv mw b">console.log()</code>提供同步行为。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/868218a25c591daaac573a489d29932e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8n1lNRbNSyX0_oOhrWZXxA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">为同步行为向setState()传入回调</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c93c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="3025" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我希望你今天能学到一些新东西。此外，欢迎所有关于我如何更好地说明/解释某一点的建设性反馈！</p><p id="35b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p><p id="b608" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我第一次尝试写技术文章，如果你发现我可能犯的任何错误，请告诉我！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="afa3" class="ni ma iq bd mb oe of dn mf og oh dp mj lf oi oj ml lj ok ol mn ln om on mp oo bi translated">在Medium上阅读更多来自杰里米和其他人的故事</h2><p id="84c2" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">考虑<a class="ae kv" href="https://medium.com/@jeremyinelysium/membership" rel="noopener">成为媒体用户</a>。你的会员费直接支持了我和这个平台的其他很多作家。您可以完全访问媒体上的所有报道，并且可以随时取消。</p></div></div>    
</body>
</html>