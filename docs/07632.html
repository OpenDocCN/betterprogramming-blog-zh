<html>
<head>
<title>An Introduction to RxSwift + MVVM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxSwift + MVVM简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-introduction-to-rxswift-mvvm-3a2868d3b2c5?source=collection_archive---------3-----------------------#2021-02-03">https://betterprogramming.pub/an-introduction-to-rxswift-mvvm-3a2868d3b2c5?source=collection_archive---------3-----------------------#2021-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="638c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在你的iOS应用中应用<em class="kf"> RxSwift- </em>增强版<em class="kf"> MVVM </em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/104bde529097f57af9c610caea41d6c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ME-wmnBqlODBsUa0oPbwRw.jpeg"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">由<a class="ae kw" href="https://unsplash.com/@joel_rohland" rel="noopener ugc nofollow" target="_blank">乔尔·罗兰</a>在<a class="ae kw" href="https://unsplash.com/s/photos/practical?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="73f1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">作为对反应式编程感兴趣的人，本文的目的是向您介绍<a class="ae kw" href="https://github.com/ReactiveX/RxSwift" rel="noopener ugc nofollow" target="_blank"> RxSwift框架</a>，并让您以最快的方式应用它。</p><p id="6661" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我在互联网上发现了许多关于RxSwift的不同而精彩的文章。然而，我发现有几本书要么太理论化，要么方法太先进，甚至有点过时。与命令式编程风格相比，反应式编程有一个相对陡峭的学习曲线。这就是为什么我将省去任何大理石图和深奥的理论，并尽快开始应用RxSwift框架。</p><p id="3a6f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我希望这篇文章能为你提供一些指导，让你选择自己想进一步探索的道路。</p><p id="dbfc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们将涉及的主题:</p><ul class=""><li id="e9d0" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated"><em class="mc">MVVM</em>版本</li><li id="d3e0" class="lt lu iq kz b la md ld me lg mf lk mg lo mh ls ly lz ma mb bi translated">RxSwift增强版MVVM版和RxSwift基础版</li><li id="01b3" class="lt lu iq kz b la md ld me lg mf lk mg lo mh ls ly lz ma mb bi translated">RxSwift最佳实践</li><li id="5ea1" class="lt lu iq kz b la md ld me lg mf lk mg lo mh ls ly lz ma mb bi translated">直流</li></ul></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="2099" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">概观</h1><p id="fbf7" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">作为本文的一部分，我们将为我们的公司创建两个不同的登录。不要太花哨。有两个输入字段和一个登录密码。在我们有一些输入之后，登录按钮被激活。</p><p id="49aa" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">第一种方法将遵循“经典的”MVVM方法。第二个登录屏幕将建立在第一种方法的基础上，并使用被动方法。</p><p id="27fb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">GitHub上提供了完整的项目代码:</p><div class="nm nn gp gr no np"><a href="https://github.com/kmpnz/PracticalRxSwift" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">kmpnz/PracticalRxSwift</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">实用RxSwift简介。通过在GitHub上创建帐户，为kmpnz/PracticalRxSwift开发做出贡献。</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od kq np"/></div></div></a></div></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="bb48" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">MVVM版本</h1><p id="e4a0" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">MVVM是模型-视图-视图模型软件架构模式的缩写。它促进了UI和业务/后端逻辑的分离。MVVM版本的代码严重依赖回调闭包。该协议给出了一个很好的概述:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oe"><img src="../Images/5049e25cc3509b74bf29d06327cecc90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hSG31hds9Kcg5RAmLjkoyA.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><a class="ae kw" href="https://carbon.now.sh/?bg=rgba%28171%2C+184%2C+195%2C+1%29&amp;t=one-dark&amp;wt=none&amp;l=auto&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=protocol%2520LoginViewModelType%253A%2520ViewModelType%2520%257B%250A%2520%2520%2520%2520var%2520username%253A%2520String%2520%257B%2520get%2520set%2520%257D%250A%250A%2520%2520%2520%2520var%2520password%253A%2520String%2520%257B%2520get%2520set%2520%257D%250A%250A%2520%2520%2520%2520var%2520isLoginAllowed%253A%2520Bool%2520%257B%2520get%2520%257D%250A%250A%2520%2520%2520%2520typealias%2520LoginCallbackType%2520%253D%2520%28Bool%29%2520-%253E%2520Void%250A%250A%2520%2520%2520%2520var%2520canLoginCallback%253A%2520%28LoginCallbackType%29%253F%2520%257B%2520get%2520set%2520%257D%250A%250A%2520%2520%2520%2520func%2520attemptLogin%28%29%2520-%253E%2520Result%253CBool%252C%2520LoginError%253E%250A%257D" rel="noopener ugc nofollow" target="_blank"> LoginViewModel协议</a></p></figure><p id="a659" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在纯MVVM方法中，我们覆盖用户名和密码属性的' T0 '方法。这些属性的每次更新都会更新内部登录的允许状态，并且这个状态会被传递到<code class="fe of og oh oi b">canLoginCallback</code>回调中。<code class="fe of og oh oi b">LoginViewController</code>声明自己是回调的处理程序，并更新登录按钮的状态。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oj"><img src="../Images/c0f4f4da67b8fcb74740beda4d59927c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OwjQiWx7q2nMs6ZmrlCP0Q.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><a class="ae kw" href="https://carbon.now.sh/?bg=rgba%28171%2C+184%2C+195%2C+1%29&amp;t=one-dark&amp;wt=none&amp;l=auto&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=func%2520bindViewModel%28%29%2520%257B%250A%2520%2520%2520%2520usernameTextField.addTarget%28self%252C%2520action%253A%2520%2523selector%28usernameTextFieldDidChange%29%252C%2520for%253A%2520.editingChanged%29%250A%2520%2520%2520%2520passwordTextField.addTarget%28self%252C%2520action%253A%2520%2523selector%28passworldTextFieldDidChange%29%252C%2520for%253A%2520.editingChanged%29%250A%2520%2520%2520%2520confirmButton.addTarget%28self%252C%2520action%253A%2520%2523selector%28confirmButtonAction%29%252C%2520for%253A%2520.touchUpInside%29%250A%250A%2520%2520%2520%2520viewModel.canLoginCallback%2520%253D%2520%257B%2520%255Bweak%2520self%255D%2520%28isValid%29%2520in%250A%2520%2520%2520%2520%2520%2520%2520%2520self%253F.confirmButton.isEnabled%2520%253D%2520isValid%250A%2520%2520%2520%2520%257D%250A%257D" rel="noopener ugc nofollow" target="_blank">在LoginViewController中查看绑定方法</a></p></figure><p id="7ee8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们看看RxSwift版本将如何处理这个问题。但首先，让我们快速进入RxSwift理论。我们会尽量简短。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="2038" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">(非常)简短的RxSwift介绍</h1><h2 id="32dd" class="ok mq iq bd mr ol om dn mv on oo dp mz lg op oq nb lk or os nd lo ot ou nf ov bi translated">可观察量</h2><p id="d29d" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated"><code class="fe of og oh oi b">Observable</code>是反应式编程的核心。<code class="fe of og oh oi b">Observable</code>代表一个序列——一系列事件。</p><h2 id="1c4f" class="ok mq iq bd mr ol om dn mv on oo dp mz lg op oq nb lk or os nd lo ot ou nf ov bi translated">观察者</h2><p id="9ade" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">一个<code class="fe of og oh oi b">Observer</code>可以订阅<code class="fe of og oh oi b">Observable</code>序列，以便在新事件到来时接收任何更新。每个序列要么正常完成，要么被某个错误事件终止。最重要的一点是它可以异步接收数据。</p><h2 id="cfa4" class="ok mq iq bd mr ol om dn mv on oo dp mz lg op oq nb lk or os nd lo ot ou nf ov bi translated">特征</h2><p id="888e" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">Rx trait是一个带有附加功能的包装<code class="fe of og oh oi b">Observable</code>，帮助我们更快地做事。它们种类繁多，你可以在<a class="ae kw" href="https://github.com/ReactiveX/RxSwift/blob/main/Documentation/Traits.md" rel="noopener ugc nofollow" target="_blank">官方特征文档</a>中找到大量关于它们的作用和区别的文档。</p><p id="f7dc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于本文，我们将只使用<code class="fe of og oh oi b">Driver</code>特征。<code class="fe of og oh oi b">Driver</code>是<code class="fe of og oh oi b">RxCocoa</code>模块的一部分，正如文档所述:</p><blockquote class="ow"><p id="df90" class="ox oy iq bd oz pa pb pc pd pe pf ls dk translated">"它的目的是提供一种直观的方式在UI层编写反应式代码."</p></blockquote><p id="89bb" class="pw-post-body-paragraph kx ky iq kz b la pg jr lc ld ph ju lf lg pi li lj lk pj lm ln lo pk lq lr ls ij bi translated">主要优点是它不会出错，并且观察发生在主调度程序上。</p><p id="6fd9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">RxSwift是一个引人注目、势不可挡的框架。当你手里拿着锤子的时候，所有的东西看起来都像钉子。我的建议是从小处着手。对于大多数情况来说,<code class="fe of og oh oi b">Driver</code>特质和<code class="fe of og oh oi b">Observable</code>已经足够了，尤其是如果你刚刚开始。这是我从伊恩·基恩的文章中借用的一个想法。它首先定义了一套好的规则。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="573b" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">rx-增强型MVVM版本</h1><p id="b228" class="pw-post-body-paragraph kx ky iq kz b la nh jr lc ld ni ju lf lg nj li lj lk nk lm ln lo nl lq lr ls ij bi translated">纯MVVM和Rx增强版的主要区别在于绑定处理。我们移除了闭包，用RxSwift绑定替换了它们。如前所述，可观测量和观察序列是反应式编程的主要思想。这就是框架的闪光点。例如，与闭包方法相比，反应式<code class="fe of og oh oi b">RXLoginViewModel</code>可以减少到以前的一半大小(大约20行vs . Swift代码的大约40行)。</p><p id="8a5f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe of og oh oi b">Driver</code>和<code class="fe of og oh oi b">Observable</code>足以涵盖我们需要的功能。</p><p id="eadd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您可能想知道这些<code class="fe of og oh oi b">Input</code>和<code class="fe of og oh oi b">Output</code>结构是什么。这是我从这个<a class="ae kw" href="https://github.com/kickstarter/ios-oss" rel="noopener ugc nofollow" target="_blank"> Kickstarter项目</a>借鉴来的一个想法。在GitHub 上有更详细的解释<a class="ae kw" href="https://github.com/kickstarter/native-docs/blob/master/vm-structure.md" rel="noopener ugc nofollow" target="_blank">。作为结构状态的名称，这两个结构定义了该视图模型的预期输入和预期输出。传入的内容由<code class="fe of og oh oi b">Input</code>结构决定，并用<code class="fe of og oh oi b">Observable</code>类型表示。<code class="fe of og oh oi b">Output</code>结构定义了输出的内容。注意<code class="fe of og oh oi b">Output</code>只使用<code class="fe of og oh oi b">Driver</code>类型。特性让我们在主线程上安全地观察它。</a></p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oe"><img src="../Images/66231f161bbfa2340ec27e465d8d08fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gRU3pzSI07NIq1_wsIMzIQ.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><a class="ae kw" href="https://carbon.now.sh/?bg=rgba%28171%2C+184%2C+195%2C+1%29&amp;t=one-dark&amp;wt=none&amp;l=markdown&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=false&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=%2560%2560%2560bash%250AInputs%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520Outputs%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%252B-------------%252B%250A%252B--------%253E%2520%257C%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%257C%2520%2520%252B-------%253E%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%257C%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%257C%250A%252B--------%253E%2520%257C%2520%2520View%2520Model%2520%257C%2520%2520%252B-------%253E%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%257C%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%257C%250A%252B--------%253E%2520%257C%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%257C%2520%2520%252B-------%253E%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%252B-------------%252B%250A%250A%2560%2560%2560" rel="noopener ugc nofollow" target="_blank">单向输入输出流</a></p></figure><p id="ff79" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">清晰的单向流提供了更多的清晰度，建立了更好的结构，并使命名更容易。在我们的示例中，我们有两个文本字段作为输入，一个布尔标志(启用或禁用登录按钮)作为输出。<code class="fe of og oh oi b">configure</code>函数处理这里的逻辑，并返回具有所有<code class="fe of og oh oi b">Driver</code>特征的输出结构。视图控制器驱动按钮启用状态。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oe"><img src="../Images/6f6fcf84ccd307b5fb5793982b157449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-bf_ZpMXoNsw2xR5DHq1Hg.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><a class="ae kw" href="https://carbon.now.sh/?bg=rgba%28171%2C+184%2C+195%2C+1%29&amp;t=one-dark&amp;wt=none&amp;l=swift&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=false&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=func%2520bindViewModel%28%29%2520%257B%250A%2520%2520%2520%2520let%2520outputs%2520%253D%2520viewModel.configure%28input%253A%2520RXLoginViewModel.Input%28username%253A%2520usernameTextField.rx.text.orEmpty.asObservable%28%29%252C%2520password%253A%2520passwordTextField.rx.text.orEmpty.asObservable%28%29%29%29%250A%250A%2520%2520%2520%2520outputs.isLoginAllowed.drive%28confirmButton.rx.isEnabled%29.disposed%28by%253A%2520disposeBag%29%250A%2520%2520%250A%2520%2520%2520%252F%252F%2520...%250A%257D" rel="noopener ugc nofollow" target="_blank">Rx-增强型bindViewModel </a></p></figure><p id="8142" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">请注意，<code class="fe of og oh oi b">RXLoginViewModel</code>没有从视图控制器中初始化。视图控制器在初始化阶段接收视图模型。我读过许多文章，它们举例说明了相反的方法，让视图控制器初始化视图模型。在我看来，这种方法增加了测试视图模型的难度。</p><p id="6212" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">相反，我们反转控件并向控制器提供视图模型。这种模式通常被称为依赖注入。它简化了测试并松散地耦合了对象。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="31df" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">资源</h1><ul class=""><li id="2644" class="lt lu iq kz b la nh ld ni lg pn lk po lo pp ls ly lz ma mb bi translated">本文代码:<a class="ae kw" href="https://github.com/kmpnz/PracticalRxSwift" rel="noopener ugc nofollow" target="_blank">https://github.com/kmpnz/PracticalRxSwift</a></li><li id="2cf7" class="lt lu iq kz b la md ld me lg mf lk mg lo mh ls ly lz ma mb bi translated"><a class="ae kw" href="https://medium.com/better-programming/surviving-rxswift-d6bfe562fb22" rel="noopener">幸存的RxSwift </a>文章作者<a class="pl pm ep" href="https://medium.com/u/5dd26134f1db?source=post_page-----3a2868d3b2c5--------------------------------" rel="noopener" target="_blank">伊恩·基恩</a></li><li id="1310" class="lt lu iq kz b la md ld me lg mf lk mg lo mh ls ly lz ma mb bi translated">Dimitris Kalaitzidis 对<a class="ae kw" href="https://medium.com/@dimitriskalaitzidis/rxswift-subjects-a2c9ff32a185" rel="noopener"> RxSwift主题</a>的深入探究</li><li id="c652" class="lt lu iq kz b la md ld me lg mf lk mg lo mh ls ly lz ma mb bi translated">Kickstarter的<a class="ae kw" href="https://github.com/kickstarter/native-docs/blob/master/vm-structure.md" rel="noopener ugc nofollow" target="_blank">视图模型结构指南</a></li></ul></div></div>    
</body>
</html>