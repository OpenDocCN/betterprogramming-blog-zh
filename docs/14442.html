<html>
<head>
<title>Redis vs. KeyDB — My Performance Test and Conclusions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis vs. KeyDB —我的性能测试和结论</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/redis-vs-keydb-my-performance-test-and-conclusions-519a658ded6e?source=collection_archive---------1-----------------------#2022-12-15">https://betterprogramming.pub/redis-vs-keydb-my-performance-test-and-conclusions-519a658ded6e?source=collection_archive---------1-----------------------#2022-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9fcb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">KeyDB比Redis快吗？</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/3b2f63f467fc92237d4cee57be892e87.png" data-original-src="https://miro.medium.com/v2/format:webp/1*IzhozU0vkUIpIypphJF7YQ.png"/></div></figure><p id="d706" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">KeyDB是Redis的一个分支。KeyDB项目声称Redis实现方法是不正确的，在性能方面可以更好。</p><p id="d421" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">与只运行一个线程的Redis方法相比，KeyDB可以运行多个线程。</p><p id="30ca" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae lm" href="https://docs.keydb.dev" rel="noopener ugc nofollow" target="_blank"> KeyDB网站</a>声称它比Redis快。我做了一些快速测试来检查缓存服务器的性能(这意味着我测试了GET / SET之类的命令)，在这篇文章中，我将分享我的结果。</p><h1 id="f239" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">我考的怎么样？</h1><p id="da7a" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">对于我的测试，我使用Docker运行Redis和KeyDb。我用4个vCPUs配置了我的Docker引擎，以利用KeyDB多线程的优势:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/8d87b40d56785bd37a2b09a4e63419ea.png" data-original-src="https://miro.medium.com/v2/format:webp/1*jDOZmGgXGsBBQGCVuMRm2Q.png"/></div></figure><p id="c463" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我还增加了操作系统的限制，以允许测试有大量的并发连接:</p><pre class="ki kj kk kl gt mk ml mm mn aw mo bi"><span id="d28b" class="mp lo it ml b gy mq mr l ms mt">&gt; ulimit -a<br/>-t: cpu time (seconds)              unlimited<br/>-f: file size (blocks)              unlimited<br/>-d: data seg size (kbytes)          unlimited<br/>-s: stack size (kbytes)             8192<br/>-c: core file size (blocks)         0<br/>-v: address space (kbytes)          unlimited<br/>-l: locked-in-memory size (kbytes)  unlimited<br/>-u: processes                       11136<br/>-n: file descriptors                256</span></pre><h1 id="cb36" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">测试条件</h1><p id="0a64" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">我用这些参数做了一个测试:</p><ul class=""><li id="53d1" class="mu mv it ks b kt ku kw kx kz mw ld mx lh my ll mz na nb nc bi translated">查询总数:50.000</li><li id="c306" class="mu mv it ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated">测试的命令:GET / SET</li><li id="0dc5" class="mu mv it ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated">并发客户端:500</li><li id="563c" class="mu mv it ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated">我执行了5次相同的测试。</li></ul><h1 id="93e1" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">KeyDB结果</h1><p id="a2f1" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated"><code class="fe ni nj nk ml b">KeyDB Version: 6.3.1</code></p><h2 id="4589" class="mp lo it bd lp nl nm dn lt nn no dp lx kz np nq lz ld nr ns mb lh nt nu md nv bi translated">4线程服务器</h2><pre class="ki kj kk kl gt mk ml mm mn aw mo bi"><span id="7258" class="mp lo it ml b gy mq mr l ms mt">&gt; docker run -p 6777:6379 eqalpha/keydb keydb-server --server-threads 4</span></pre><p id="55db" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">执行测试:</p><pre class="ki kj kk kl gt mk ml mm mn aw mo bi"><span id="229e" class="mp lo it ml b gy mq mr l ms mt">&gt; redis-benchmark -p 6777 -t get,set -q -n 50000 -c 500<br/>SET: 23775.56 requests per second, p50=14.559 msec<br/>GET: 22758.31 requests per second, p50=13.439 msec<br/><br/>&gt; redis-benchmark -p 6777 -t get,set -q -n 50000 -c 500<br/>SET: 18903.59 requests per second, p50=16.247 msec<br/>GET: 22872.83 requests per second, p50=13.359 msec<br/><br/>&gt; redis-benchmark -p 6777 -t get,set -q -n 50000 -c 500<br/>SET: 23430.18 requests per second, p50=14.583 msec<br/>GET: 20729.69 requests per second, p50=14.687 msec<br/><br/>&gt; redis-benchmark -p 6777 -t get,set -q -n 50000 -c 500<br/>SET: 17325.02 requests per second, p50=19.263 msec<br/>GET: 19723.87 requests per second, p50=16.591 msec<br/><br/>&gt; redis-benchmark -p 6777 -t get,set -q -n 50000 -c 500<br/>SET: 25706.94 requests per second, p50=13.191 msec<br/>GET: 19817.68 requests per second, p50=14.839 msec</span></pre><p id="addb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">总结一下:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/4d836e2d864ffc82224fdf3ab137485f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*cx7s0WSh7MWdJJJ1OYpJGQ.png"/></div></figure><h2 id="dcbb" class="mp lo it bd lp nl nm dn lt nn no dp lx kz np nq lz ld nr ns mb lh nt nu md nv bi translated">双线程服务器</h2><pre class="ki kj kk kl gt mk ml mm mn aw mo bi"><span id="016f" class="mp lo it ml b gy mq mr l ms mt">&gt; docker run -p 6777:6379 eqalpha/keydb keydb-server --server-threads 2</span></pre><p id="1bd1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">执行测试:</p><pre class="ki kj kk kl gt mk ml mm mn aw mo bi"><span id="ba09" class="mp lo it ml b gy mq mr l ms mt">&gt; redis-benchmark -p 6777 -t get,set -q -n 50000 -c 500<br/>SET: 31605.56 requests per second, p50=11.095 msec<br/>GET: 33692.72 requests per second, p50=10.815 msec<br/><br/>&gt; redis-benchmark -p 6777 -t get,set -q -n 50000 -c 500<br/>SET: 30395.14 requests per second, p50=12.271 msec<br/>GET: 32959.79 requests per second, p50=13.639 msec<br/><br/>&gt; redis-benchmark -p 6777 -t get,set -q -n 50000 -c 500<br/>SET: 29691.21 requests per second, p50=13.087 msec<br/>GET: 32467.53 requests per second, p50=13.159 msec<br/><br/>&gt; redis-benchmark -p 6777 -t get,set -q -n 50000 -c 500<br/>SET: 28216.71 requests per second, p50=14.295 msec<br/>GET: 30693.68 requests per second, p50=14.103 msec<br/><br/>&gt; redis-benchmark -p 6777 -t get,set -q -n 50000 -c 500<br/>SET: 31486.14 requests per second, p50=12.543 msec<br/>GET: 35087.72 requests per second, p50=12.543 msec</span></pre><p id="528a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">总结一下:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/c9b62e4e72c2551cd565fd9df102830b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Usy0Wmg7xkwMBUtqWca4FQ.png"/></div></figure><h2 id="772c" class="mp lo it bd lp nl nm dn lt nn no dp lx kz np nq lz ld nr ns mb lh nt nu md nv bi translated">单线程服务器</h2><p id="224d" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">我只用一个线程做了测试，但是结果和用两个线程一样。</p><h1 id="a87a" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">Redis结果</h1><p id="d326" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated"><code class="fe ni nj nk ml b">Redis Version: 7.0.2</code></p><p id="39cc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">执行服务器:</p><pre class="ki kj kk kl gt mk ml mm mn aw mo bi"><span id="d671" class="mp lo it ml b gy mq mr l ms mt">&gt; docker run -p 6379:6379 redis</span></pre><p id="22dc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">执行测试:</p><pre class="ki kj kk kl gt mk ml mm mn aw mo bi"><span id="babe" class="mp lo it ml b gy mq mr l ms mt">&gt; redis-benchmark -p 6379 -t get,set -q -n 50000 -c 500<br/>SET: 37622.27 requests per second, p50=12.527 msec<br/>GET: 28392.96 requests per second, p50=12.919 msec<br/><br/>&gt; redis-benchmark -p 6379 -t get,set -q -n 50000 -c 500<br/>SET: 27442.37 requests per second, p50=13.439 msec<br/>GET: 31446.54 requests per second, p50=15.527 msec<br/><br/>&gt; redis-benchmark -p 6379 -t get,set -q -n 50000 -c 500<br/>SET: 27808.68 requests per second, p50=13.751 msec<br/>GET: 35335.69 requests per second, p50=13.391 msec<br/><br/>&gt; redis-benchmark -p 6379 -t get,set -q -n 50000 -c 500<br/>SET: 30156.82 requests per second, p50=14.631 msec<br/>GET: 37009.62 requests per second, p50=12.711 msec<br/><br/>&gt; redis-benchmark -p 6379 -t get,set -q -n 50000 -c 500<br/>SET: 33068.79 requests per second, p50=13.359 msec<br/>GET: 40225.26 requests per second, p50=10.999 msec</span></pre><p id="8c6d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">总结一下:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/03d1c24c86bd9a69a9ee3c0005da3621.png" data-original-src="https://miro.medium.com/v2/format:webp/1*H6PAqfwqs9uo3Mz1siZoxA.png"/></div></figure><h1 id="c2ff" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">结论</h1><p id="5f92" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">好的。结果很奇怪:</p><ol class=""><li id="5a61" class="mu mv it ks b kt ku kw kx kz mw ld mx lh my ll nw na nb nc bi translated">KeyDB说它们比Redis更快，因为它们可以以多线程的方式运行，但在测试中，结果显示当线程数为10比1时，它运行得更快…就像Redis一样。</li><li id="e2a3" class="mu mv it ks b kt nd kw ne kz nf ld ng lh nh ll nw na nb nc bi translated">这意味着KeyDB需要更多的资源来达到与Redis相同的性能。</li><li id="0b54" class="mu mv it ks b kt nd kw ne kz nf ld ng lh nh ll nw na nb nc bi translated">KeyDB线程需要统计你的硬件资源；否则，Redis。</li></ol><p id="54cd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们还必须记住，KeyDB有一个Redis没有(至少在他们的开源版本中没有)的特性，比如:</p><p id="3b03" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="nx">“</em>开启闪光”功能。该功能使用SSD磁盘作为RAM的扩展，在性能非常相似的情况下花费更少的RAM。</p><ul class=""><li id="f360" class="mu mv it ks b kt ku kw kx kz mw ld mx lh my ll mz na nb nc bi translated">闪存上的redis:<a class="ae lm" href="https://redis.com/redis-enterprise/technology/redis-on-flash/" rel="noopener ugc nofollow" target="_blank">https://redis . com/redis-enterprise/technology/redis-on-flash/</a></li><li id="f384" class="mu mv it ks b kt nd kw ne kz nf ld ng lh nh ll mz na nb nc bi translated">闪存上的KeyDb:<a class="ae lm" href="https://docs.keydb.dev/docs/flash/" rel="noopener ugc nofollow" target="_blank">https://docs.keydb.dev/docs/flash/</a></li></ul><blockquote class="ny nz oa"><p id="9cd2" class="kq kr nx ks b kt ku ju kv kw kx jx ky ob la lb lc oc le lf lg od li lj lk ll im bi translated">我试图在Flash 特性上运行带有<em class="it">的KeyDB服务器，但是我做不到。它给了我一个错误:“尚不支持FLASH”。</em></p></blockquote></div></div>    
</body>
</html>