<html>
<head>
<title>How Code Comments Are Obsoleting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码注释是如何过时的</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-code-comments-are-obsoleting-333d5ca256d0?source=collection_archive---------4-----------------------#2021-11-29">https://betterprogramming.pub/how-code-comments-are-obsoleting-333d5ca256d0?source=collection_archive---------4-----------------------#2021-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="624d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">除了代码注释，还有更多方法可以让代码变得可理解</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cec6472f90deb39743229535af0c7b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YR7c6ToPznFi4REa"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Daria Nepriakhina 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c6be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一次，我有机会与总部的高级软件主管进行一对一的面谈。他问我有什么可以改进的地方。</p><p id="7180" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">远程工作，我想从代码中得到更多的上下文，而不需要从总部给工程师发电子邮件。作为一个天真的初级工程师，我告诉高级软件主管，我们可以通过对代码进行更多更好的评论来改进。</p><p id="1aa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他礼貌地对我说，“也许，最好的评论是代码本身。”</p><p id="1faf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在那个时候，我不同意。现在回想起来，这开始变得有意义了。</p><p id="5ab0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们看看我们在代码中注释的最初原因，也许这将帮助我们更好地解释为什么它现在不那么流行了</p><h1 id="fcf8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">注释是解密和划分代码</h1><p id="b977" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们看看早期的编程语言。</p><p id="37dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">ASM代码:</strong>操作符固定为3-4个字母，变量固定为几个字符。有了评论，就很难解密它的意思了。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1de1" class="mx lw it mt b gy my mz l na nb">forlp   i, 0, 3<br/>forlp   j, 0, 3<br/>mov     bx, i           <strong class="mt iu">;Compute address of a[i][j] using</strong><br/>shl     bx, 2           <strong class="mt iu">; row major ordering (i*4 + j)*2.</strong><br/>add     bx, j<br/>add     bx, bx<br/>lea     bx, a[bx]<br/>push    bx             <strong class="mt iu"> ;Push address of a[i][j] onto stack.</strong></span></pre><blockquote class="nc nd ne"><p id="3f2a" class="kz la nf lb b lc ld ju le lf lg jx lh ng lj lk ll nh ln lo lp ni lr ls lt lu im bi translated">来源于<a class="ae ky" href="http://www.sourceformat.com/standard/asm-coding-standard-assembly-6.htm" rel="noopener ugc nofollow" target="_blank">汇编语言风格指南—注释</a></p></blockquote><p id="6e41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">Cobol代码:</strong>需要分成不同的分部。它使用注释来使划分更加清晰:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5f88" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu">**********************************************<br/>**  P R O C  D I V I S I O N               ***     **********************************************<br/> </strong> Procedure Division.<br/>  000-Main-Logic.<br/>     Perform 100-Say-Hello.<br/>     Perform 200-Get-Date.<br/>     Perform 300-Say-Goodbye.<br/>     Stop Run.<br/> <strong class="mt iu"> **<br/>  ** Setup initial values and say we are starting.<br/>  **<br/> </strong> 100-Say-Hello.<br/>     Move 80 to Stringlen.<br/>     Move 02 to Dest-output.<br/>     Move Start-Msg to Str.<br/>     CALL "CEEMOUT" Using Msg   Dest-output Feedback.</span></pre><blockquote class="nc nd ne"><p id="0f43" class="kz la nf lb b lc ld ju le lf lg jx lh ng lj lk ll nh ln lo lp ni lr ls lt lu im bi translated">来源于<a class="ae ky" href="https://www.ibm.com/docs/en/zos/2.1.0?topic=routines-sample-cobol-program" rel="noopener ugc nofollow" target="_blank"> IBM COBOL代码示例</a></p></blockquote><p id="49b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">GW-Basic代码:</strong>这里，我们使用行号来帮助程序的流程。没有将有意义的上下文组合在一起的函数作用域。需要注释来帮助更好地理解它。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3ef8" class="mx lw it mt b gy my mz l na nb">10 REM Calculate the area of given radious repeatedly<br/>20 READ R<br/>30 PRINT "R ="; R;<br/>40 A = 3.14*R^2<br/>50 PRINT "AREA ="; A<br/>60 GOTO 10:   REM repeat the process again until no data<br/>70 DATA 5, 7, 12</span></pre><blockquote class="nc nd ne"><p id="9483" class="kz la nf lb b lc ld ju le lf lg jx lh ng lj lk ll nh ln lo lp ni lr ls lt lu im bi translated">来源于<a class="ae ky" href="https://hwiegman.home.xs4all.nl/gw-man/GOTO.html" rel="noopener ugc nofollow" target="_blank"> GW基本GOTO语句</a></p></blockquote><p id="c348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述语言确实限制了开发者清楚地表达他们的意图。因此，注释需要通过解释代码的用途和它们的结构来说明。</p><p id="451c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今的语言更富于表现力。如今代码本身可读性更好了，我们可以更好地对它们进行组织和命名，取代了注释的需要。</p><h1 id="a66f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">注释是为了提供可追溯性或上下文</h1><p id="3445" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当我第一次成为一名软件工程师时，我在下面看到了一些关于每个课程的评论。原因是“<em class="nf">注释提供了从需求到代码修改的可追溯性</em></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="23ed" class="mx lw it mt b gy my mz l na nb"><em class="nf">// *****************************************************************</em><br/><em class="nf">// * Logger helper                                                 *</em><br/><em class="nf">// *                                                               *</em><br/><em class="nf">// * 2005-03-01 First Version, Anders Abel                         *</em><br/><em class="nf">// * 2007-08-17 Added Console Output, Anders Abel                  *</em><br/><em class="nf">// * 2009-12-15 Removed file output, John Doe                       *</em><br/><em class="nf">// *                                                               *</em><br/><em class="nf">// * Usage: Call Logger.Write() with string to be logged.          *</em><br/><em class="nf">// *****************************************************************</em><br/><strong class="mt iu">public</strong> <strong class="mt iu">static</strong> <strong class="mt iu">class</strong> Logger</span></pre><blockquote class="nc nd ne"><p id="19df" class="kz la nf lb b lc ld ju le lf lg jx lh ng lj lk ll nh ln lo lp ni lr ls lt lu im bi translated">来源于<a class="ae ky" href="https://coding.abel.nu/2012/07/comments-are-not-version-control/" rel="noopener ugc nofollow" target="_blank">的注释不受版本控制</a></p></blockquote><p id="a6f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它确实提供了一个很好的类如何变化的历史，但是我不确定我是否需要在每次读类的时候都看到它。</p><p id="59c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今，所有代码都存储在版本控制中(例如Git)。所有这些信息都已经存储在源代码版本控制工具中。我们不需要代码中的重复数据。</p><blockquote class="nc nd ne"><p id="e252" class="kz la nf lb b lc ld ju le lf lg jx lh ng lj lk ll nh ln lo lp ni lr ls lt lu im bi translated">更多讨论<a class="ae ky" href="https://stackoverflow.com/questions/648972/configuration-management-history-in-code-comments" rel="noopener ugc nofollow" target="_blank">在这个堆栈中</a></p></blockquote><p id="bb29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了显示历史更改之外，源代码版本控制还允许一次提供所有文件中代码更改的更好的上下文，如下图所示的示例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/2b042a10a050bfaba3f19c6010b2f6af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kgbyYY29CaSFPrwFr_e0hw.png"/></div></div></figure><blockquote class="nc nd ne"><p id="2d9b" class="kz la nf lb b lc ld ju le lf lg jx lh ng lj lk ll nh ln lo lp ni lr ls lt lu im bi translated">每当我发现一行有问题的代码时，我通常会执行git-fall来查找Git注释，这样我就可以看到整个上下文以及整个过程中文件的变化，而不是希望在代码行上方或函数中找到注释。</p></blockquote><p id="953e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">版本源代码管理注释是及时和相关的。它不仅仅涵盖文件中的代码部分。它不仅取代了一些传统的评论，而且更好。</p><p id="83c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在让代码显示“如何”的同时，陈述“为什么”是一个更好的地方，因为许多人提倡代码注释的目的。</p><p id="d74f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，也许这样说没有错，<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/7-unconventional-pieces-of-coding-advice-17f0cfc0220f">更喜欢Git注释而不是代码注释</a>。它提供了更好的可追溯性和时间精确的上下文，进一步减少了注释的需要。</p><blockquote class="nc nd ne"><p id="5cb2" class="kz la nf lb b lc ld ju le lf lg jx lh ng lj lk ll nh ln lo lp ni lr ls lt lu im bi translated">Git评论很棒。尽可能多的在那里注释，因为它及时链接到所有相关的变更代码。我喜欢丹尼尔·卢(Daniel Lew)的说法:“我从来没有后悔在提交消息(commit message)中写了太多(T10)</p><p id="fa3a" class="kz la nf lb b lc ld ju le lf lg jx lh ng lj lk ll nh ln lo lp ni lr ls lt lu im bi translated">注意:这里的Git comment指的是commit comment，以及制作PR时的comment。</p></blockquote><h1 id="5a77" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">新的编程语言更具表现力</h1><p id="5623" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现代语言现在有能力让一个命名，并把代码和有意义的名字组合成函数、类等。</p><p id="dd1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面给出了一些例子。</p><h2 id="9304" class="mx lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">更好的变量命名</h2><p id="ff0c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">不要这样做:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="033d" class="mx lw it mt b gy my mz l na nb"># convert to cents<br/>a = x * 100</span><span id="3155" class="mx lw it mt b gy nx mz l na nb"># avg cents per customer <br/>avg = a / n</span></pre><p id="7abc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以更好地命名变量并去掉注释:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="c71a" class="mx lw it mt b gy my mz l na nb">total_cents = total * 100<br/>average_per_customer = total_cents / customer_count</span></pre><h2 id="7d61" class="mx lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">具有有意义名称的代码分组</h2><p id="29f8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设代码具有如下各种注释，每个部分都有注释:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="fe60" class="mx lw it mt b gy my mz l na nb">// This function will generate something from the parameters, <br/>function myFunction(parameters) {<br/>    // It will do some things to get started.</span><span id="57aa" class="mx lw it mt b gy nx mz l na nb">    // It will do more with the stuff.</span><span id="fce1" class="mx lw it mt b gy nx mz l na nb">    // It will end doing things with the stuff.<br/>}</span></pre><p id="cdda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的方法可能是正确命名函数，并将代码提取到函数中:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d1cc" class="mx lw it mt b gy my mz l na nb">function generateSomething(parameters) {<br/>  var someThing = initializedWithSomething;    <br/>  doSomethingWith(someThing);<br/>  doMoreWith(someThing);<br/>  endDoingThingsWith(someThing);<br/>  return someThing;<br/>}</span></pre><p id="a379" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个真实的Kotlin代码示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="79ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不太难读。但是我们仍然可以通过将代码中有意义的部分组合成有意义的函数名来提高可读性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="af3d" class="mx lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">引入了更好的代码语法</h2><p id="7440" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如今阅读代码变得更加顺畅。例如，下面给出了一种遍历数组中各项的方法:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7b9d" class="mx lw it mt b gy my mz l na nb">for (int i = 0; i &lt; array.size; i++) {<br/>    println(array[i])<br/>}</span></pre><p id="eda1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，代码甚至可以更有意义:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="f3be" class="mx lw it mt b gy my mz l na nb">for (item in array) { println(item) }<br/>// or<br/>array.forEach { println(it) }</span></pre><p id="afb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个很好的真实科特林代码的例子是:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a597" class="mx lw it mt b gy my mz l na nb"><em class="nf">for (</em><strong class="mt iu"><em class="nf">everyday in this year 2017</em></strong><em class="nf">) {<br/>     // do some with everyday<br/>}</em></span></pre><div class="oa ob gp gr oc od"><a href="https://medium.com/mobile-app-development-publication/iterate-through-everyday-in-this-year-in-kotlin-5b0a828ef23" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">科特林这一年每天都在迭代</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">下面的‘2017年的每一天’不是伪代码，而是真正的Kotlin代码！！如此自然不是吗？</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="on l oo op oq om or ks od"/></div></div></a></div><p id="e3b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift语言中参数标签功能的另一个示例如下:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="6a68" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu">func</strong> setAge(person: String, age: Int) {<br/>    print("\(person) is now \(value)")<br/>}</span></pre><p id="7670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个人在使用它时，我们现在可以清楚地理解第一个参数是<code class="fe os ot ou mt b">name</code>，而第二个参数是<code class="fe os ot ou mt b">age</code>，而不仅仅是一个<code class="fe os ot ou mt b">String</code>和一个<code class="fe os ot ou mt b">Integer</code>。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="4353" class="mx lw it mt b gy my mz l na nb">setAge(<strong class="mt iu">person</strong>: "Jason", <strong class="mt iu">age</strong>: 10)</span></pre><p id="a8e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者更好:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8eaf" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu">func</strong> setAge(<strong class="mt iu">for</strong> person: String, <strong class="mt iu">toAge</strong> age: Int) {<br/>    print("\(person) is now \(value)")<br/>}</span></pre><p id="ba5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在能把它设置得更像英语，听起来更像评论本身吗？方法如下:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0a88" class="mx lw it mt b gy my mz l na nb">setAge(<strong class="mt iu">for</strong>: "Jason", <strong class="mt iu">toAge</strong>: 10)</span></pre><p id="7e1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上只是几个例子。我相信你可以从新语言的各种不同改进中想出更多的例子，这些改进有助于使今天的代码比它们的前辈更具可读性。</p><blockquote class="nc nd ne"><p id="b0fc" class="kz la nf lb b lc ld ju le lf lg jx lh ng lj lk ll nh ln lo lp ni lr ls lt lu im bi translated">更多例子在<a class="ae ky" href="https://www.swiftbysundell.com/articles/writing-self-documenting-swift-code/" rel="noopener ugc nofollow" target="_blank"> Swift —编写自文档代码</a>。</p></blockquote><h2 id="9306" class="mx lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">仅用于替换注释的功能</h2><p id="7ef3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了做一个好的测试，我们使用注释来排列它们。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="4f5b" class="mx lw it mt b gy my mz l na nb">public void myTest() {<br/>    <strong class="mt iu">// Arrange</strong><br/>    <strong class="mt iu">// Act</strong><br/>    <strong class="mt iu">// Assert</strong><br/>}</span></pre><p id="431c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们可以用本地函数进行模板化的<a class="ae ky" href="http://dontcodetired.com/blog/post/Using-Local-Functions-to-Replace-Comments" rel="noopener ugc nofollow" target="_blank">测试，这将保证它的实现。</a></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a8c4" class="mx lw it mt b gy my mz l na nb">public void myTest() {<br/><strong class="mt iu">    Arrange();<br/>    Act();<br/>    AssertResults();</strong><br/><br/>    void Arrange()       { throw new NotImplementedException(); }<br/>    void Act()           { throw new NotImplementedException(); }<br/>    void AssertResults() { throw new NotImplementedException(); }<br/>}</span></pre><p id="3f24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Swift中，可以使用测试断言来避免注释。请参考下面的示例，并附上注释:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="19cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以改成下面。当测试失败时，注释会显示出来。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="391f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">通过更少的低级手动代码工艺优化来降低复杂性</h1><h2 id="dc1f" class="mx lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">代码管理和优化的改进</h2><p id="061b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当我学习C语言时，我记得我必须自己分配和释放内存。我们必须手动跟踪内存分配计数，否则我们将面临内存泄漏的风险。</p><p id="33c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种低级代码管理增加了编码的复杂性，因此很难避免注释。</p><p id="0a16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于现代语言，如基于JVM的语言(如Java)，内存释放是自动完成的。这大大简化了编码的方式。</p><p id="8342" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，不再需要低级代码优化，例如:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1a9d" class="mx lw it mt b gy my mz l na nb">// Using shift 1 as divide 2 for faster processing<br/>int dividedValue = originalValue &gt;&gt; 1;</span></pre><p id="99ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是随着更好的代码编译优化，<a class="ae ky" href="https://stackoverflow.com/a/4072724/3286489" rel="noopener ugc nofollow" target="_blank">下面的代码这些天也会执行相同的</a>。不需要评论。干净简单。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="4549" class="mx lw it mt b gy my mz l na nb">int dividedValue = originalValue / 2;</span></pre><h2 id="284d" class="mx lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">如今的编码水平更高了</h2><p id="11c7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你学过C或C++，学习如何管理指针是有效管理数据结构的关键。我们用它来遍历数据并管理它们。水平低，复杂。感谢<a class="ae ky" href="https://www.geeksforgeeks.org/the-c-standard-template-library-stl/" rel="noopener ugc nofollow" target="_blank">标准模板库</a>简化了其中一些。还是很复杂。</p><p id="f4a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着更高级编程语言的出现，大量库的出现，以及函数式反应式编程的引入，许多软件开发都在更高级别上完成。</p><p id="4eae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，Kotlin语言提供了数百个集合函数，人们可以使用这些函数更容易地操作数据。</p><div class="oa ob gp gr oc od"><a href="https://medium.com/mobile-app-development-publication/kotlin-collection-functions-cheat-sheet-975371a96c4b" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">Kotlin集合函数备忘单</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">使学习和查找相关收藏功能变得更加容易</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="ov l oo op oq om or ks od"/></div></div></a></div><blockquote class="nc nd ne"><p id="a93f" class="kz la nf lb b lc ld ju le lf lg jx lh ng lj lk ll nh ln lo lp ni lr ls lt lu im bi translated">而集合函数的整洁部分，<a class="ae ky" href="https://proandroiddev.com/kotlin-collections-appended-to-by-and-with-205d9540208" rel="noopener ugc nofollow" target="_blank">当函数追加了【to】、【by】或【with】</a>时，它才使其函数有意义。从而使函数名更加不言自明。</p></blockquote><p id="3ac8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不需要编写逻辑的详细算法类型，注释的需求也变得更少。</p><h1 id="bfa3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">上述方法的组合…</h1><p id="54c9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有时，我们可以将上述方法结合起来。</p><p id="1387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个<a class="ae ky" href="https://softwareengineering.stackexchange.com/a/26828/373333" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>中，有人陈述了下面的代码:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a779" class="mx lw it mt b gy my mz l na nb">response.contentType="text/html"<br/>render '{"success":true}'</span></pre><p id="ea2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然很清楚，但可以做得更好:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="f375" class="mx lw it mt b gy my mz l na nb">// must be text/html so the browser renders the response <br/>// within the invisible iframe, where ExtJS can access it<br/>response.contentType="text/html"</span><span id="1db2" class="mx lw it mt b gy nx mz l na nb">// ExtJS expects that, otherwise it will call the failure <br/>// handler instead of the succss handler<br/>render '{"success":true}'</span></pre><p id="8581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想我们可以进一步改变它。</p><h2 id="245d" class="mx lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">1.将细节注释移动到Git注释</h2><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="58bc" class="mx lw it mt b gy my mz l na nb">response.contentType="text/html"<br/>render '{"success":true}'</span></pre><p id="400a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Git注释中，放入下面的。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ae19" class="mx lw it mt b gy my mz l na nb">The response.contentType must be text/html so the browser renders the response within the invisible iframe, where ExtJS can access it</span><span id="cfef" class="mx lw it mt b gy nx mz l na nb">ExtJS expects that the render is success and true, otherwise it will call the failure handler instead of the succss handler</span></pre><h2 id="5ab3" class="mx lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">2.为设置创建一个本地函数</h2><p id="9ecd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">使用一个函数名来更清楚地描述这一点。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="6f12" class="mx lw it mt b gy my mz l na nb">def essentialDoNotRemoveSetting() {<br/>    <!-- -->response.contentType="text/html"<br/>    render '{"success":true}'<br/>}</span></pre><blockquote class="nc nd ne"><p id="3286" class="kz la nf lb b lc ld ju le lf lg jx lh ng lj lk ll nh ln lo lp ni lr ls lt lu im bi translated">如果我的groovy函数语法不正确，我很抱歉，我只是想说明使用函数来提供一些意义。</p></blockquote><p id="6aa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们在代码中没有注释，但是仍然保留了所有的上下文，包括函数名和git注释。</p></div><div class="ab cl ow ox hx oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="im in io ip iq"><h1 id="6f11" class="lv lw it bd lx ly pd ma mb mc pe me mf jz pf ka mh kc pg kd mj kf ph kg ml mm bi translated">代码注释还没有过时……也许永远不会过时</h1><p id="619b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">已经展示了上面所有的例子，我仍然不能否认，在我们拥有一种不需要注释特性的编程语言之前，还有很长的路要走。</p><p id="3054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对代码注释的需求已经显著减少，但它仍然是不时出现的必要之恶。它仍然是需要的，因为…</p><ol class=""><li id="0488" class="pi pj it lb b lc ld lf lg li pk lm pl lq pm lu pn po pp pq bi translated">一些需要的仪式，如文案声明等。或者甚至需要完成一些基本的高级文档，例如JavaDoc。或者作为教程讲解帮助学生作为学习指导。</li><li id="e053" class="pi pj it lb b lc pr lf ps li pt lm pu lq pv lu pn po pp pq bi translated">这种语言还不能让人很好地表达意图。例如ASM、COBOL等。这甚至适用于较新的语言，因为没有一种语言可以声称自己是完全表达的。</li><li id="4caa" class="pi pj it lb b lc pr lf ps li pt lm pu lq pv lu pn po pp pq bi translated">超级复杂的代码算法，需要绑定到一些核心库的一些底层实现，或者一些数学或学术研究工作。那些需要解释很多为什么的代码。理想情况下，这样的实现值得链接到更完整的文档，清晰地解释它们(用图表)，而不是把它们都作为代码注释(这将非常冗长)。</li><li id="c4c0" class="pi pj it lb b lc pr lf ps li pt lm pu lq pv lu pn po pp pq bi translated">一些立即引人注目的注意细节。也就是说，写评论总是令人惊讶，会使人更加关注那篇文章。(这就是为什么我们应该显著减少代码中的建议，这样任何代码注释的存在都会立即引起注意)。一些例子:黑客攻击、库错误解决方法、待办事项或代码更详细解释的参考链接(例如，代码是从哪里复制的)</li><li id="87d6" class="pi pj it lb b lc pr lf ps li pt lm pu lq pv lu pn po pp pq bi translated">嗯，……有时由于交付的时间压力，对“不太理想”的代码进行评论可能有助于加快交付。业务优先第一。</li></ol><p id="3231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在完美的世界里，代码不需要任何注释。代码应该是真理的唯一来源。手动维护与代码相关的东西，而没有与代码相关的时间戳，可能有一天会伤害到我们。</p><blockquote class="nc nd ne"><p id="bf16" class="kz la nf lb b lc ld ju le lf lg jx lh ng lj lk ll nh ln lo lp ni lr ls lt lu im bi translated">对代码进行注释就像一个重复的代码，总是需要手动维护两者之间的一致性。改变其中一个而不改变另一个可能会引起混乱。三思而后行。</p></blockquote><p id="2587" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，我们今天生活在一个不完美的世界。因此代码注释仍然是允许的(但希望不要被接受)。每当我们需要写一个的时候，我们应该思考罗伯特·c·马丁下面说的话。</p><blockquote class="pw"><p id="d2ff" class="px py it bd pz qa qb qc qd qe qf lu dk translated">“每次写评论都要做鬼脸，感受自己表达能力的失败。”罗伯特·马丁</p></blockquote></div><div class="ab cl ow ox hx oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="im in io ip iq"><h1 id="b19c" class="lv lw it bd lx ly pd ma mb mc pe me mf jz pf ka mh kc pg kd mj kf ph kg ml mm bi translated">参考</h1><ol class=""><li id="b268" class="pi pj it lb b lc mn lf mo li qg lm qh lq qi lu pn po pp pq bi translated">评论历史:【http://www.gavilan.edu/csis/languages/comments.html T2】</li><li id="966c" class="pi pj it lb b lc pr lf ps li pt lm pu lq pv lu pn po pp pq bi translated">评论是码闻:【https://softwareengineering.stackexchange.com/questions/1】T4</li><li id="7a5e" class="pi pj it lb b lc pr lf ps li pt lm pu lq pv lu pn po pp pq bi translated">评论就是道歉:<a class="ae ky" href="http://butunclebob.com/ArticleS.TimOttinger.ApologizeIncode" rel="noopener ugc nofollow" target="_blank">http://butunclebob.com/ArticleS.TimOttinger.ApologizeIncode</a></li><li id="1a6b" class="pi pj it lb b lc pr lf ps li pt lm pu lq pv lu pn po pp pq bi translated">XP —需要评论:<a class="ae ky" href="http://wiki.c2.com/?ToNeedComments" rel="noopener ugc nofollow" target="_blank">http://wiki.c2.com/?ToNeedComments</a></li></ol></div></div>    
</body>
</html>