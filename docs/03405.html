<html>
<head>
<title>Build a Tool-Agnostic CI/CD Flow With GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用GitHub动作构建一个与工具无关的CI/CD流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-tool-agnostic-ci-cd-flow-with-github-actions-3d4f4a6238de?source=collection_archive---------12-----------------------#2020-02-07">https://betterprogramming.pub/build-a-tool-agnostic-ci-cd-flow-with-github-actions-3d4f4a6238de?source=collection_archive---------12-----------------------#2020-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4b39" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何利用一个简单的GitHub动作工作流而不牺牲不可知的工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/9212dab547a96dec21b3b25734a0a006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*JoqB-LkqAYk1SK6C.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片由<a class="ae ku" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>提供</p></figure><p id="234d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">不可知工具是一个聪明的概念，即您应该能够在各种环境中运行您的代码。有了许多可用的持续集成和持续开发(CI/CD)应用程序，不可知工具给了开发人员一个很大的优势:可移植性。</p><p id="f200" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当然，让你的CI/CD在任何地方都能工作<em class="lr"/>是一项艰巨的任务。仅针对GitHub库的流行CI应用程序就使用了多种配置语言，包括<a class="ae ku" href="https://groovy-lang.org/syntax.html" rel="noopener ugc nofollow" target="_blank"> Groovy </a>、<a class="ae ku" href="https://yaml.org/" rel="noopener ugc nofollow" target="_blank"> YAML </a>、<a class="ae ku" href="https://github.com/toml-lang/toml" rel="noopener ugc nofollow" target="_blank"> TOML </a>、<a class="ae ku" href="https://json.org/" rel="noopener ugc nofollow" target="_blank"> JSON </a>等等……当然，所有语言都有不同的语法。将工作流从一个工具移植到另一个工具不仅仅是一杯咖啡的过程。</p><p id="fa11" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><a class="ae ku" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub Actions </a>的引入有可能为组合添加另一个工具——或者，对于正确的设置，极大地简化CI/CD工作流。</p><p id="85fd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我之前用几个捆绑在一起的应用程序完成了我的CD流。我使用AWS Lambda来按计划触发站点构建。我让Netlify构建推送触发器，运行图像优化，然后将我的站点推送到公共页面存储库。我在公共存储库中使用Travis CI来测试HTML。所有这些都与GitHub Pages协同工作，GitHub Pages实际上是网站的宿主。</p><p id="532d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我现在使用GitHub Actions来完成所有相同的任务，使用一个<a class="ae ku" href="https://medium.com/better-programming/create-a-portable-makefile-for-continuous-delivery-with-hugo-and-github-pages-98aa44fe059b" rel="noopener">可移植的Makefile </a>构建指令，没有任何其他CI/CD应用程序。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="a557" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">欣赏贝壳</h1><p id="1415" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">大多数CI/CD工具有什么共同点？它们在shell环境中运行您的工作流指令！这太棒了，因为这意味着大多数CI/CD工具可以做你在终端中可以做的任何事情……而且你几乎可以在终端中做任何事情。</p><p id="e21b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">特别是对于一个包含用例来说，比如用一个像Hugo这样的生成器来构建我的静态站点，在shell中运行它是显而易见的。要告诉魔盒做什么，我们只需要写指令。</p><p id="c616" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">虽然shell脚本肯定是最容易移植的选择，但是我使用仍然非常容易移植的Make来编写我的过程指令。这为我提供了一些优于简单shell脚本的优势，比如变量和<a class="ae ku" href="https://en.wikipedia.org/wiki/Make_(software)#Macros" rel="noopener ugc nofollow" target="_blank">宏</a>的使用，以及<a class="ae ku" href="https://en.wikipedia.org/wiki/Makefile#Rules" rel="noopener ugc nofollow" target="_blank">规则</a>的模块化。</p><p id="592a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在我的上一篇文章中，我已经了解了Makefile的本质。让我们看看如何让GitHub Actions运行它。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="2f93" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">使用带有GitHub操作的Makefile</h1><p id="9f88" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">就可移植性而言，我的神奇Makefile就存储在存储库根目录中。因为Makefile包含在代码中，所以我可以在任何可以克隆存储库的系统上本地运行它，只要我设置了环境变量。使用GitHub Actions作为我的CI/CD工具就像让Make go工作起来一样简单。</p><p id="859d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我发现<a class="ae ku" href="https://help.github.com/en/articles/workflow-syntax-for-github-actions" rel="noopener ugc nofollow" target="_blank"> GitHub Actions工作流语法指南</a>非常简单，尽管在选项上也很冗长。下面是运行Makefile的必要设置。</p><p id="5104" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">位于<code class="fe mw mx my mz b">.github/workflow.yml</code>的工作流文件包含以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="305e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我将解释使这个工作的组件。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="1b3f" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">触发工作流</h1><p id="c2a4" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">动作支持一个工作流的多个<a class="ae ku" href="https://help.github.com/en/articles/events-that-trigger-workflows" rel="noopener ugc nofollow" target="_blank">触发器。使用<code class="fe mw mx my mz b">on</code>语法，我为自己定义了两个触发器:一个</a><a class="ae ku" href="https://help.github.com/en/articles/workflow-syntax-for-github-actions#onpushpull_requestbranchestags" rel="noopener ugc nofollow" target="_blank">仅将事件</a>推送到<code class="fe mw mx my mz b">master</code>分支，一个<a class="ae ku" href="https://help.github.com/en/articles/events-that-trigger-workflows#scheduled-events-schedule" rel="noopener ugc nofollow" target="_blank">调度的</a> <code class="fe mw mx my mz b">cron</code>作业。</p><p id="8738" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">一旦<code class="fe mw mx my mz b">workflow.yml</code>文件在您的存储库中，您的任何一个触发器都将导致运行Makefile的操作。要了解最后一次跑步的情况，你也可以<a class="ae ku" href="https://help.github.com/en/articles/configuring-a-workflow#adding-a-workflow-status-badge-to-your-repository" rel="noopener ugc nofollow" target="_blank">在自述文件中添加一个有趣的徽章</a>。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="ffcf" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">一件讨厌的事</h1><p id="3eac" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">因为Makefile在每次推送到<code class="fe mw mx my mz b">master</code>时都会运行，所以当站点构建没有变化时，我有时会出错。当Git通过<a class="ae ku" href="https://victoria.dev/blog/a-portable-makefile-for-continuous-delivery-with-hugo-and-github-pages/" rel="noopener ugc nofollow" target="_blank"> my Makefile </a>尝试提交到Pages存储库时，没有检测到任何更改，并且提交会令人恼火地失败:</p><pre class="kj kk kl km gt nc mz nd ne aw nf bi"><span id="7d81" class="ng ma it mz b gy nh ni l nj nk">nothing to commit, working tree clean<br/>On branch master<br/>Your branch is up to date with 'origin/master'.<br/>nothing to commit, working tree clean<br/>Makefile:62: recipe for target 'deploy' failed<br/>make: *** [deploy] Error 1<br/>##[error]Process completed with exit code 2.</span></pre><p id="59c6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我遇到了一些建议使用<code class="fe mw mx my mz b">diff</code>来检查是否应该提交的解决方案，但是由于<a class="ae ku" href="https://github.com/benmatselby/hugo-deploy-gh-pages/issues/4" rel="noopener ugc nofollow" target="_blank">原因</a>这可能不起作用。作为一种变通方法，我简单地将<a class="ae ku" href="https://gohugo.io/functions/format/#use-local-and-utc" rel="noopener ugc nofollow" target="_blank">当前UTC时间</a>添加到我的索引页面，这样每个构建都将包含一个要提交的变更。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="eec5" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">环境和变量</h1><p id="739d" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">您可以使用<code class="fe mw mx my mz b">runs-on</code>语法为您的工作流定义运行的<a class="ae ku" href="https://help.github.com/en/articles/virtual-environments-for-github-actions#supported-virtual-environments-and-hardware-resources" rel="noopener ugc nofollow" target="_blank">虚拟环境</a>。显而易见的最佳选择是Ubuntu。使用<code class="fe mw mx my mz b">ubuntu-latest</code>可以让我得到最新的版本，不管当你读这篇文章的时候发生了什么。</p><p id="c085" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">GitHub为工作流设置了一些默认的环境变量。带有<code class="fe mw mx my mz b">fetch-depth: 1</code>的<code class="fe mw mx my mz b"><a class="ae ku" href="https://github.com/actions/checkout" rel="noopener ugc nofollow" target="_blank">actions/checkout</a></code> <a class="ae ku" href="https://github.com/actions/checkout" rel="noopener ugc nofollow" target="_blank">动作</a>在<code class="fe mw mx my mz b">GITHUB_WORKSPACE</code>变量中创建了您的库的最近提交的副本。这允许工作流在<code class="fe mw mx my mz b">GITHUB_WORKSPACE/Makefile</code>访问Makefile。如果不使用checkout操作，将找不到Makefile，并且我会得到如下所示的错误:</p><pre class="kj kk kl km gt nc mz nd ne aw nf bi"><span id="77d4" class="ng ma it mz b gy nh ni l nj nk">make: *** No rule to make target 'all'. Stop.<br/>Running Makefile<br/>##[error]Process completed with exit code 2.</span></pre><p id="d40b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">而有一个<a class="ae ku" href="https://help.github.com/en/articles/virtual-environments-for-github-actions#github_token-secret" rel="noopener ugc nofollow" target="_blank">默认</a> <code class="fe mw mx my mz b"><a class="ae ku" href="https://help.github.com/en/articles/virtual-environments-for-github-actions#github_token-secret" rel="noopener ugc nofollow" target="_blank">GITHUB_TOKEN</a></code> <a class="ae ku" href="https://help.github.com/en/articles/virtual-environments-for-github-actions#github_token-secret" rel="noopener ugc nofollow" target="_blank">秘密</a>，这个不是我用过的那个。默认情况下，仅在本地范围内使用当前存储库。为了能够推送到我单独的GitHub Pages存储库，我创建了一个作用于<code class="fe mw mx my mz b">public_repo</code>的<a class="ae ku" href="https://github.com/settings/tokens" rel="noopener ugc nofollow" target="_blank">个人访问令牌</a>，并将其作为<code class="fe mw mx my mz b">secrets.TOKEN</code>加密变量传入。有关详细步骤，请参见<a class="ae ku" href="https://help.github.com/en/articles/virtual-environments-for-github-actions#creating-and-using-secrets-encrypted-variables" rel="noopener ugc nofollow" target="_blank">创建和使用机密</a>。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="64c9" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">便携式工具</h1><p id="c5a7" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">使用一个简单的Makefile来定义我的CI/CD过程的好处是它是完全可移植的。我可以在任何我可以访问环境的地方运行Makefile，包括大多数CI/CD应用程序、虚拟实例，当然还有我的本地机器。</p><p id="883a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我喜欢GitHub动作的原因之一是让我的Makefile运行起来非常简单。我认为语法做得很好，容易阅读，并且在找到你正在寻找的选项时很直观。对于已经在使用GitHub页面的人来说，Actions提供了相当无缝的CD体验。如果这种情况有所改变，我可以在其他地方运行我的Makefile。</p><p id="47a8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">感谢阅读！</p></div></div>    
</body>
</html>