<html>
<head>
<title>Next.js vs. Remix: Analyzing Key Aspects and Differences</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js vs. Remix:分析关键方面和差异</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/next-js-vs-remix-analyzing-key-aspects-and-differences-8674beaba695?source=collection_archive---------4-----------------------#2022-01-31">https://betterprogramming.pub/next-js-vs-remix-analyzing-key-aspects-and-differences-8674beaba695?source=collection_archive---------4-----------------------#2022-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6068" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过比较Remix和Next.js的最新版本，知道哪一个适合你</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d55cbc37c8c6ce78d29bd53b7a9e9a73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rqOaaFKrhxIi2w-CqUeiRg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="300b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">React基于网络的生态系统看起来一天比一天好。2021年底，Next.js推出了它的great 12版本。它包含了许多功能和优化。然而，过了一会儿，我们看到了Remix是如何推出其最新版本的。Remix团队改变了策略，决定免费开源。</p><p id="fff7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么2022年开始一个项目的时候，我们应该挑哪一个呢？这是一个很难做出的选择，并且对您的web应用程序有很大的影响。每个框架都有自己的观点，并将决定你如何思考和构建你的组件。</p><p id="34b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我们将分析什么是每一个的关键方面，最后，你将能够决定这些是否适合你。有些方面可能是交易的破坏者或决定性因素。这完全取决于您的使用案例和个人偏好。</p><p id="0f83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个选择的悖论中，只要知道这两个都是很好的框架，并且它们中的任何一个都不会出错，就可以放心了。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="aa84" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">建筑和哲学</h1><p id="8e7b" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">Next.js框架构建在NodeJs之上。它与React生态系统紧密相连，几乎是React生态系统的延伸。它试图尽早接受它的最新功能。Vercel团队与React团队紧密合作，以实现这一目标。它们主要提供构建在React组件之上的抽象，比如:<code class="fe my mz na nb b">next/dynamic</code>、<code class="fe my mz na nb b">next/head</code>、<code class="fe my mz na nb b">next/link</code>、…</p><p id="c033" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">他们的最新版本已经支持:</p><ul class=""><li id="22d2" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><strong class="la iu"> React服务器端组件</strong>:无状态组件，呈现在服务器上，流式传输到客户端。</li><li id="8f1e" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><strong class="la iu"> HTML服务器端流</strong>:逐步将HTML传送到浏览器。</li></ul><p id="a511" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以在配置文件中启用这两种功能:</p><pre class="kj kk kl km gt nq nb nr ns aw nt bi"><span id="4de1" class="nu mc it nb b gy nv nw l nx ny"><em class="nz">// next.config.js</em><br/>module.exports = {<br/>  experimental: {<br/>    <strong class="nb iu">concurrentFeatures</strong>:<strong class="nb iu"> </strong>true<strong class="nb iu">,<br/>    serverComponents</strong>:<strong class="nb iu"> </strong>true<strong class="nb iu">,</strong><br/>  },<br/>}</span></pre><p id="9216" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">混音版的方法明显不同。他们更加脱离React生态系统，更热衷于等待稳定的React特性。它建立在<code class="fe my mz na nb b">Web Fetch Api</code>(而不是节点)之上，这使得应用程序可以在任何地方运行。它关注于尽可能多地利用服务器。这有两个好处:加载数据时更快的带宽和提供渐进增强体验的能力。</p><p id="108c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个显著的不同是，Remix试图尽可能多地依赖浏览器的原生Web标准功能。那是什么意思？即使禁用了JavaScript，他们的页面也能100%正常运行。当JavaScript可用时，整个体验得到了增强。</p><p id="3514" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">他们的内置表单功能就是一个明显的例子。他们依赖于基本的<code class="fe my mz na nb b">Form</code>浏览器功能。表单动作总是在服务器上发布和执行。这是验证/重定向/数据库逻辑发生的地方。</p><p id="4079" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当JavaScript可用时，一个<code class="fe my mz na nb b">xhr</code>请求将会发生，否则，一个传统的<code class="fe my mz na nb b">HTTP Post</code>将会出现。</p><p id="13a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们唯一需要做的就是在根页面中导出一个<code class="fe my mz na nb b">action</code>函数，并使用它们内置的表单API抽象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="d01d" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak">数据加载</strong></h1><h2 id="85f9" class="nu mc it bd md oc od dn mh oe of dp ml lh og oh mn ll oi oj mp lp ok ol mr om bi translated">Next.js</h2><p id="f621" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在Next.js中，您可以精确地配置如何从web应用程序加载数据。您可以选择在运行时或构建时只在服务器和客户端加载数据。</p><p id="9b8a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Next.js加载API的摘要:</p><ul class=""><li id="236d" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated">运行时服务器端+客户端:<code class="fe my mz na nb b">getInitialProps</code>。</li><li id="0852" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">仅在构建时服务器端:<code class="fe my mz na nb b">getStaticProps</code>。</li><li id="1723" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">仅在运行时的服务器端<code class="fe my mz na nb b">getServerSideProps</code>或<code class="fe my mz na nb b">React Server Components</code>。</li><li id="340f" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">客户端</li></ul><p id="4445" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么有这么多种方法？这使得开发者处于主动地位。Next.js框架的主要目标是SEO，并声称在服务器上加载所有内容可能会损害应用程序的性能。</p><p id="348b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个框架包括了流行的特性静态的。它有一些进一步的改进。如果您需要那些SSG页面定期更新，您可以在<code class="fe my mz na nb b">getStaticProps</code>方法中使用<code class="fe my mz na nb b">stale-while-revalidate</code>策略。这将创造出一个具有增量的静态的网。你需要一个支持这个功能的CDN。</p><p id="77e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">ISR的实际例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="0674" class="nu mc it bd md oc od dn mh oe of dp ml lh og oh mn ll oi oj mp lp ok ol mr om bi translated">再搅拌</h2><p id="4d20" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">混音版本则完全不同。从他们的角度来看，数据应该总是首先加载到服务器端。因为它是基于<code class="fe my mz na nb b">fetch API</code>的，我们可以通过使用Cloud Flare Workers之类的服务在边缘执行代码。</p><p id="b0a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是怎么回事？在每个根页面上，我们可以定义一个将在服务器中执行的命名函数<code class="fe my mz na nb b">loader</code>，然后通过服务器和客户机中的react hook API获得数据。与此行为等价的Next.js是<code class="fe my mz na nb b">getInitialProps/getServerSideProps</code>。在Next.js实现中，您可能会面临大量的道具训练。</p><p id="d78b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看一个混音的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="c78f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着页面布局可以完全在服务器中处理，并并行发送到客户机。一旦全部下载完毕，用户将不会体验到任何加载微调。唯一需要注意的是在同一台服务器上获取数据的时间代价。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/f7338c0dd3938a1b3dc7591e1631b455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tlxHASm1cYOn2dVJ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">remix.run的标题</p></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="a4d2" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">按指定路线发送</h1><p id="7015" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">谈到路由，两个框架有一些相似之处。它们依赖于基于文件系统的路由系统。它正在成为SSR框架的标准。它使路由页面可预测，并允许一些优化。</p><p id="d11d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它们支持嵌套路由和动态路由段。在Next.js中，路线必须放在<code class="fe my mz na nb b">pages</code>目录中。</p><ul class=""><li id="7f9b" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><code class="fe my mz na nb b">pages/index.js</code> → <code class="fe my mz na nb b">/</code></li><li id="4fde" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe my mz na nb b">pages/blog/index.js</code> → <code class="fe my mz na nb b">/blog</code></li><li id="dac4" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe my mz na nb b">pages/blog/first-post.js</code> → <code class="fe my mz na nb b">/blog/first-post</code></li><li id="be58" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe my mz na nb b">pages/[username]/settings.js</code> → <code class="fe my mz na nb b">/:username/settings</code> ( <code class="fe my mz na nb b">/foo/settings</code>)</li></ul><p id="3984" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Remix中，这些需要放在<code class="fe my mz na nb b">app/routes</code>目录中:</p><ul class=""><li id="4eec" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><code class="fe my mz na nb b">app/routes/blog.js</code> → <code class="fe my mz na nb b">/blog</code></li><li id="2000" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe my mz na nb b">app/routes/blog/first-post.js</code> → <code class="fe my mz na nb b">/blog/first-post</code></li><li id="8b11" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe my mz na nb b">app/routes/invoices/$id/activity.js</code> → <code class="fe my mz na nb b">/invoices/123/activity</code></li></ul><p id="73ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">他们的引擎不同。Remix框架构建在React路由器之上，该路由器在GitHub中有<code class="fe my mz na nb b">45k starts</code>。Remix允许你创建嵌套布局。它通过使用React路由器v6的<code class="fe my mz na nb b">Outlet</code>特性来实现。您可以以简洁的方式创建组合页面，并通过缓存和数据加载节省时间。</p><p id="2328" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以选择退出嵌套布局URL行为。怎么会？只是通过使用<code class="fe my mz na nb b">.</code>符号而不是创建文件夹。它会将每个<code class="fe my mz na nb b">.</code>与URL中的一个<code class="fe my mz na nb b">/</code>进行交换。非嵌套布局是Next.js呈现其路线的方式。</p><pre class="kj kk kl km gt nq nb nr ns aw nt bi"><span id="aff3" class="nu mc it nb b gy nv nw l nx ny">// <strong class="nb iu">nested layout:</strong> it will render blog.js + new.js<br/>app/routes/blog/new.js → /blog/new</span><span id="7ebc" class="nu mc it nb b gy oo nw l nx ny">// <strong class="nb iu">unnested layout:</strong> will just render blog.new.js<br/>app/routes/blog.new.js → /blog/new</span></pre><p id="a194" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我看来，Remix在这方面占了上风，Next.js必须迎头赶上。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="12e6" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">附加功能</h1><p id="6fb7" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">Next.js提供了大量的特性。他们最近推出了<code class="fe my mz na nb b">Next.js Live</code>。它支持实时协作，这可能会极大地提高团队的生产力。</p><p id="e8ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">他们还推出了中间件功能。它使开发人员能够根据配置编写代码。它将JavaScript带到了边缘，离用户更近，从而使页面更快。它结合了缓存的优点和动态执行的能力。中间件逻辑可以通过页面解耦功能(如来自组件的授权)来确定范围。</p><p id="c621" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Next.js框架支持将任何React页面转换成AMP页面。如果你想创建一个新闻网页，这是很有用的。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="1df5" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">包裹</h1><p id="a5a6" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我们已经看到了Next.js和Remix的对比。它们都有令人惊叹的特性，提供了出色的体验，并且有一个很棒的社区。他们都以闪电般的Rust和Go编译器提供了出色的开发体验。</p><p id="98bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是…在做出任何决定之前，请注意Next.js附带了一定级别的供应商锁定。要运行它的最大峰值和所有特性，您需要使用Vercel平台。在另一个供应商那里释放其全部潜力可能太费时间了。</p><p id="9647" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有些情况下选择Next.js是显而易见的:当你有静态站点或者需要使用AMP。当你需要一个没有JavaScript的响应网站时，你应该使用Remix。</p><p id="fe41" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除此之外，就涉及到个人喜好了。目前，我倾向于混音，因为我喜欢它的简单和路由。然而，在未来，我们将能够使用像React服务器组件这样的功能。</p><p id="353a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。如果你喜欢你所读的，也可以看看这些相关的文章:</p><div class="op oq gp gr or os"><a rel="noopener  ugc nofollow" target="_blank" href="/6-killer-features-from-remix-3d7e01b0789e"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">混音版的6个黑仔特色</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">改变游戏规则的全栈JavaScript框架的主要亮点</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">better编程. pub</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a rel="noopener  ugc nofollow" target="_blank" href="/5-new-killer-features-of-next-js-12-dfd1d766b539"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">Next.js 12的5个新黑仔功能</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">改变游戏规则的版本的主要亮点</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">better编程. pub</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg ks os"/></div></div></a></div></div></div>    
</body>
</html>