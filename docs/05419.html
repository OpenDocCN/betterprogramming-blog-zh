<html>
<head>
<title>Headless UI Components: A Journey With High Order Components, Render Props, and Custom Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无头UI组件:高阶组件、渲染道具和定制钩子之旅</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/headless-ui-components-a-journey-with-high-order-components-render-props-and-custom-hooks-811c9677b4cf?source=collection_archive---------5-----------------------#2020-07-07">https://betterprogramming.pub/headless-ui-components-a-journey-with-high-order-components-render-props-and-custom-hooks-811c9677b4cf?source=collection_archive---------5-----------------------#2020-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b898" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">没有UI但具有UI功能的无头UI组件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/99e9bd63cc49c2291ffc243c712c78ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p4Oc_Ryp4W-4Vhxiqky2bg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sickhews?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">韦斯·希克斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/future?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="67ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经介绍了<a class="ae ky" href="https://medium.com/better-programming/an-introduction-to-react-table-6ebd34d8059e" rel="noopener">React-Table</a>——一个定制钩子，用于构建一个可扩展的表，而不需要实际的UI组件。这种类型的组件被称为无头UI组件，它将组件的逻辑和行为与其可视化表示分离开来。</p><p id="cea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无头UI组件经历了与高阶组件、渲染道具和定制挂钩的漫长旅程。这些概念将在本文中解释。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="86ed" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">高阶组件</h1><p id="52c3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们有一个组件可以打印出一个简单的UI:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/a8d791bae44d82f57bffd69cf467119d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*Mpxz4NVncjRKW0m5q_hyoA.png"/></div></figure><p id="f859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于本文，源代码在<code class="fe na nb nc nd b"><a class="ae ky" href="https://codepen.io/" rel="noopener ugc nofollow" target="_blank">CodePen</a></code>中得到验证:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3f3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想把文本变成蓝色。这可以通过将样式添加到第一行或将样式传递到第三行来完成。然而，我们希望这种风格转换逻辑也可以被其他组件重用。</p><p id="1162" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高阶元件(HOC)是完成这一任务的好选择。它是一个接受一个组件并返回一个新组件的函数，带有额外的逻辑和行为。它通常定义如下:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="3576" class="nk md it nd b gy nl nm l nn no">const EnhancedComponent = higherOrderComponent(WrappedComponent);</span></pre><p id="10cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们在下面的代码中创建一个特设:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9c98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个特设被命名为<code class="fe na nb nc nd b">withColor</code>(第1-8行)。它取<code class="fe na nb nc nd b">props</code>，如果定义了的话，就提取出<code class="fe na nb nc nd b">color</code>。否则，它使用<code class="fe na nb nc nd b">red</code>作为默认颜色(第2行)。<code class="fe na nb nc nd b">rest</code>道具被传递给原始组件(第5行)。重要的是使用组合，而不是改变原始组件。</p><p id="447a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个HOC用一个<code class="fe na nb nc nd b">div</code>包装原始组件，样式为<code class="fe na nb nc nd b">color</code>(第4行)，在第14行定义为<code class="fe na nb nc nd b">blue</code>。</p><p id="e6db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们看到蓝色的文字:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/7ad63d702e63b53a432f4682950fd43a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*A_Y8kvTN1R9Pkkpj1D0ftA.png"/></div></figure><p id="606b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会问为什么我们在<code class="fe na nb nc nd b">App</code>之外创建<code class="fe na nb nc nd b">TransformedComponent</code>，而不是在渲染中直接改变原始组件，如下所示:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="7e17" class="nk md it nd b gy nl nm l nn no">const App = () =&gt; {<br/>  const TransformedComponent = withColor(BaseComponent);<br/>  return &lt;TransformedComponent value={1} color="blue"/&gt;;<br/>}</span></pre><p id="1e16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React的diffing算法(也称为协调)使用组件引用来确定是应该更新现有的子树还是丢弃它并挂载一个新的子树。如果从render返回的组件严格等于来自前一次渲染的组件，React通过将其与新的子树进行差分来递归更新子树。如果它们不相等，前一个子树将被完全卸载。</p><p id="f06d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe na nb nc nd b">TransformedComponent</code>是在render中生成的，它对每个渲染都有一个新的引用，这会导致不必要的卸载。</p><p id="a1bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你必须把<code class="fe na nb nc nd b">TransformedComponent</code>放在渲染里面，另一种方法是应用<code class="fe na nb nc nd b">useMemo</code>来保持渲染之间的引用。</p><p id="aa82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">withColor</code>变换颜色。如果我们也想改变字体样式为斜体呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/ca1539edabf43f0ac125986d3f6eec1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*diIaITd4fHq6y9Ne9zFvEg.png"/></div></figure><p id="9e8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建另一个HOC来转换字体样式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="97de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个附加的特设被命名为<code class="fe na nb nc nd b">withFontStyle</code>(第1-8行)。它使用<code class="fe na nb nc nd b">props</code>并提取出<code class="fe na nb nc nd b">fontStyle</code>(如果定义了的话)。否则，它使用<code class="fe na nb nc nd b">normal</code>作为默认的字体样式(第2行)。<code class="fe na nb nc nd b">rest</code>道具被传递给原始组件(第5行)。</p><p id="b4b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个HOC用一个<code class="fe na nb nc nd b">div</code>包装原始组件，样式为<code class="fe na nb nc nd b">fontStyle</code>(第4行)，在第24行定义为<code class="fe na nb nc nd b">italic</code>。</p><p id="85c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们在第21行写了两个hoc。</p><p id="c4dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想在原始组件中转换道具，比如原始值的倍数，会怎么样？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/2e11db7cc98c3c4489f30067e1281323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*zLlohFbrLeqaofDS9RhPNQ.png"/></div></figure><p id="19fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再来一杯也行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="184b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个新的特设被命名为<code class="fe na nb nc nd b">withMultipleValue</code>(第1 - 9行)。它采用<code class="fe na nb nc nd b">props</code>并提取出<code class="fe na nb nc nd b">factor</code>(如果已定义)。否则，它使用<code class="fe na nb nc nd b">1</code>作为默认因子(第2行)。在第3行计算一个新值，该值替换第6行的原始值。<code class="fe na nb nc nd b">newprops</code>被传递到原始组件(第8行)。</p><p id="acb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该HOC应用于第31行，乘以第36行定义的因子<code class="fe na nb nc nd b">5</code>。</p><p id="8de3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在31-33行组成了三个hoc。这些行看起来有点拥挤，但是如果你安装了<code class="fe na nb nc nd b"><a class="ae ky" href="https://github.com/ramda/ramda" rel="noopener ugc nofollow" target="_blank">ramda</a> </code>，它们可以被格式化成这样:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="fa72" class="nk md it nd b gy nl nm l nn no">import compose from "ramda";</span><span id="13fc" class="nk md it nd b gy np nm l nn no">const TransformedComponent = compose(<br/>  withMultipleValue,<br/>  withFontStyle, <br/>  withColor,<br/>)(BaseComponent);</span></pre><p id="5ccc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果使用<a class="ae ky" href="https://medium.com/better-programming/10-fun-facts-about-create-react-app-eb7124aa3785" rel="noopener"> Create React App </a>，<code class="fe na nb nc nd b"><a class="ae ky" href="https://medium.com/better-programming/lodash-create-react-apps-built-in-library-for-debounce-and-throttle-with-hooks-3418087f44d8" rel="noopener">lodash</a></code> <a class="ae ky" href="https://medium.com/better-programming/lodash-create-react-apps-built-in-library-for-debounce-and-throttle-with-hooks-3418087f44d8" rel="noopener">是内置的</a>，第31-33行可以写成:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="f1b1" class="nk md it nd b gy nl nm l nn no">import flowRight from "lodash/flowRight";</span><span id="dc16" class="nk md it nd b gy np nm l nn no">const TransformedComponent = flowRight(<br/>  withMultipleValue,<br/>  withFontStyle,<br/>  withColor,<br/>)(BaseComponent);</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e647" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">渲染道具</h1><p id="11bb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">hoc运行良好。为什么我们需要渲染道具？</p><p id="85cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，hoc用的是静态构图，但是渲染道具用的是动态构图。</p><p id="d673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">渲染道具指的是一种使用道具在React组件之间共享代码的技术，该道具的值是返回React元素的函数。具有呈现属性的组件调用此函数，而不是实现自己的呈现。</p><p id="9abf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用渲染道具的库有<a class="ae ky" href="https://reacttraining.com/react-router/web/api/Route/render-func" rel="noopener ugc nofollow" target="_blank"> React Router </a>、<a class="ae ky" href="https://github.com/paypal/downshift" rel="noopener ugc nofollow" target="_blank">down down</a>和<a class="ae ky" href="https://github.com/jaredpalmer/formik" rel="noopener ugc nofollow" target="_blank"> Formik </a>。</p><blockquote class="nq nr ns"><p id="fe1b" class="kz la nt lb b lc ld ju le lf lg jx lh nu lj lk ll nv ln lo lp nw lr ls lt lu im bi translated">据说大部分hoc都可以用带渲染道具的常规组件来完成。</p></blockquote><p id="1e74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从概念上讲，hoc为现有组件提供了额外的逻辑和行为。渲染道具为组件提供了预期的逻辑和行为，可以应用于任何视觉表示。</p><p id="9f5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何将HOC、<code class="fe na nb nc nd b">withColor</code>转换为渲染道具实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="76bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第1-4行定义了采用渲染道具的<code class="fe na nb nc nd b">ColorComp</code>。在第3行，<code class="fe na nb nc nd b">color</code>逻辑被设置为外部的<code class="fe na nb nc nd b">div</code>，它可以应用于任何渲染的组件。</p><p id="4a20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第8-10行部署<code class="fe na nb nc nd b">ColorComp</code>，渲染属性设置为<code class="fe na nb nc nd b">BaseComponent</code>。</p><p id="269a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第12行将<code class="fe na nb nc nd b">color</code>初始化为<code class="fe na nb nc nd b">blue</code>。</p><p id="96e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这种模式被称为渲染道具，但并不一定要命名为渲染。任何作为渲染函数的道具在技术上都是渲染道具。</p><p id="77db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在第3行和第9行将<code class="fe na nb nc nd b">render</code>重命名为<code class="fe na nb nc nd b">test</code>。它的功能也和它被称为<code class="fe na nb nc nd b">render</code>一样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b9f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果出于某种原因你真的需要一个特设，你可以通过在渲染道具上创建一个特设来添加到上面的代码中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="24f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第6-8行是渲染道具(第7行)之上的特设。此HOC用于第12行。它和普通的特设工作组一样有效。</p><p id="db5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经尝试了各种方法来使用渲染道具实现<code class="fe na nb nc nd b">withColor</code>。把<code class="fe na nb nc nd b">withFontStyle</code>也转换成渲染道具怎么样？</p><p id="11f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是源代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f385" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第1-4行定义了采用渲染道具的<code class="fe na nb nc nd b">FontStyleComp</code>。在第3行，<code class="fe na nb nc nd b">fontStyle</code>逻辑被设置为外部的<code class="fe na nb nc nd b">div</code>，它可以应用于任何渲染的组件。</p><p id="37ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第14-19行部署<code class="fe na nb nc nd b">FontStyleComp</code>，渲染属性设置为<code class="fe na nb nc nd b">ColorComponent</code>，渲染属性设置为<code class="fe na nb nc nd b">BaseComponent</code>。</p><p id="da1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第23行将<code class="fe na nb nc nd b">fontStyle</code>初始化为<code class="fe na nb nc nd b">italic</code>。</p><p id="1398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把<code class="fe na nb nc nd b">withMultipleValue</code>也转换成渲染道具怎么样？</p><p id="68a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是源代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7529" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第1-4行定义了采用渲染道具的<code class="fe na nb nc nd b">MultipleValueComp</code>。在第3行，它提供了基于<code class="fe na nb nc nd b">factor</code>计算新值的逻辑，然后将渲染道具中的任何内容渲染为可视表示。</p><p id="cb15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第24-37行部署了设置为<code class="fe na nb nc nd b">FontStyleComponent</code>的渲染属性<code class="fe na nb nc nd b">FontStyleComp</code>，这是一个带有渲染属性的嵌套组件。</p><p id="1a5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第41行将<code class="fe na nb nc nd b">factor</code>初始化为<code class="fe na nb nc nd b">5</code>。</p><p id="273c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经给出了hoc和渲染道具的例子。当应用程序有大量嵌套组件时，您会看到通常称为“包装器地狱”的问题</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c8f6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">无头UI组件</h1><p id="e61e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">无头用户界面组件是通过不提供界面来提供最大视觉灵活性的组件。它将组件的逻辑和行为从其可视化表示中分离出来。</p><p id="70ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个著名的无头实现是<code class="fe na nb nc nd b"><a class="ae ky" href="https://www.merrickchristensen.com/articles/headless-user-interface-components/" rel="noopener ugc nofollow" target="_blank">&lt;CoinFlip/&gt;</a></code>。它使用<code class="fe na nb nc nd b">children</code>来实现渲染道具，并强调了<em class="nt">Unix哲学的基础</em>:</p><blockquote class="nq nr ns"><p id="bbcb" class="kz la nt lb b lc ld ju le lf lg jx lh nu lj lk ll nv ln lo lp nw lr ls lt lu im bi translated">分离原则:政策与机制分离；将接口与引擎分开。</p><p id="1826" class="kz la nt lb b lc ld ju le lf lg jx lh nu lj lk ll nv ln lo lp nw lr ls lt lu im bi translated">埃里克·雷蒙德</p></blockquote><h2 id="2587" class="nk md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated"><strong class="ak">带渲染道具的无头UI组件</strong></h2><p id="eaa6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">无头UI组件使得渲染道具流行起来，因为它们需要一种方法来动态地将逻辑和行为应用于任何组件。与hoc相比，它为大规模组件提供了更大的灵活性。</p><p id="4bbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无头UI组件可以提供它的<code class="fe na nb nc nd b">children</code>方法和值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">CombinedComp</code>在第1-7行创建一个无头UI组件，为其子组件提供三个方法:<code class="fe na nb nc nd b">getFactor</code>(第3行)、<code class="fe na nb nc nd b">getColor</code>(第4行)和<code class="fe na nb nc nd b">getFontStyle</code>(第5行)。</p><p id="4f78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当组件在第12 -18行使用时，这些方法对它的<code class="fe na nb nc nd b">children</code>元素可用(第14-16行)。逻辑和行为被重用不是很美好吗？</p><h2 id="6b7f" class="nk md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">带有自定义挂钩的无头UI组件</h2><p id="2b0f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来是<a class="ae ky" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React钩子</a>，它创建React组件，而不从类组件扩展。除了内置钩子之外，还有<a class="ae ky" href="https://medium.com/better-programming/everyone-can-build-a-custom-hook-e0f1c6802ffe" rel="noopener">自定义钩子</a>，它是围绕现有钩子的一个包装函数。这是一种重用有状态逻辑和行为的机制，这些逻辑和行为是针对每种用法而隔离的。</p><p id="9a32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">钩子是反应世界里的龙卷风。它们实现了函数式编程的承诺。钩子很容易编写，也很容易使用。他们结束了渲染道具造成的“包装地狱”。</p><p id="6ee5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，无头UI组件继续存在。在定制钩子的帮助下，无头UI组件变得更加流行。</p><p id="78ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是<a class="ae ky" href="https://github.com/jxom/awesome-react-headless-components" rel="noopener ugc nofollow" target="_blank">牛逼React无头组件</a>列表:</p><ul class=""><li id="a373" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu on oo op oq bi translated"><a class="ae ky" href="https://github.com/americanexpress/react-albus" rel="noopener ugc nofollow" target="_blank"> React Albus </a> : React组件库，用于构建声明式多步骤流程(向导)。</li><li id="8a74" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><a class="ae ky" href="https://github.com/deseretdigital/dayzed" rel="noopener ugc nofollow" target="_blank"> Dayzed </a>:构建简单、灵活、符合WAI-ARIA的React日期选择器组件的原语。</li><li id="435c" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><a class="ae ky" href="https://github.com/paypal/downshift" rel="noopener ugc nofollow" target="_blank">降档</a>:构建简单、灵活、符合WAI-ARIA标准的增强型输入反应组件的原语。</li><li id="41d6" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><a class="ae ky" href="https://github.com/react-tools/react-ranger" rel="noopener ugc nofollow" target="_blank">React Ranger</a>:React中构建范围和多范围滑块的无头渲染道具组件。</li><li id="de40" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><a class="ae ky" href="https://github.com/jxom/react-selected" rel="noopener ugc nofollow" target="_blank">React Selected</a>:React component构建灵活易访问的单选按钮/元素。</li><li id="4844" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><a class="ae ky" href="https://github.com/jxom/react-t-minus" rel="noopener ugc nofollow" target="_blank"> React T-Minus </a> : React组件处理简单的倒计时。</li><li id="6b25" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><a class="ae ky" href="https://github.com/kentcdodds/react-toggled" rel="noopener ugc nofollow" target="_blank">React Toggled</a>:React component构建简单、灵活、可访问的toggle组件。</li><li id="751a" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><a class="ae ky" href="https://github.com/ianstormtaylor/react-values" rel="noopener ugc nofollow" target="_blank"> React Values </a>:一组微小的、可组合的React组件，用于处理带有渲染道具的状态。</li><li id="0ac1" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><a class="ae ky" href="https://github.com/tannerlinsley/react-table" rel="noopener ugc nofollow" target="_blank"> React Table </a>:挂钩，用于搭建轻便、快速、可扩展的桌子。</li></ul><p id="6441" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用一个自定义挂钩重写了前面的无头UI组件示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">useCombinedComp</code>在第1-10行用三种方法创建一个无头UI组件:<code class="fe na nb nc nd b">getFactor</code>(第4行)、<code class="fe na nb nc nd b">getColor</code>(第5行)和<code class="fe na nb nc nd b">getFontStyle</code>(第6行)。</p><p id="1579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在第15行使用自定义钩子时，这些方法在<code class="fe na nb nc nd b">App</code>组件中可用(第16-20行)。</p><p id="7ade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定制钩子使得构建过程简单明了。您准备好构建自己的无头UI组件了吗？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2fe3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="afae" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">React诞生于2013年5月。历史是一派胡言。</p><p id="2812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下事实仍然成立:</p><ul class=""><li id="51f9" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu on oo op oq bi translated">大部分hoc可以通过渲染道具来完成。</li><li id="6efd" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">hoc使用静态合成，而渲染道具使用动态合成。</li><li id="7de4" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">React钩子是动态的，没有包装器地狱。</li><li id="b723" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">反应钩子结束渲染道具，但是hoc继续。</li><li id="7a79" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">无头UI组件很神奇:它们没有UI，但是有UI功能。</li></ul><p id="a62e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae ky" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p></div></div>    
</body>
</html>