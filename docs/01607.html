<html>
<head>
<title>Recursion Inside JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的递归</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/recursion-inside-javascript-cde90a37e934?source=collection_archive---------1-----------------------#2019-09-28">https://betterprogramming.pub/recursion-inside-javascript-cde90a37e934?source=collection_archive---------1-----------------------#2019-09-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="321d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JavaScript中一个强大的概念</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9614dec330677ce06364b9a835e680d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MRYTI8QkuojaNtE466JRbQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">Clark ti BBS在Unsplash上拍摄的照片</em></p></figure><p id="f6bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是递归的新手，这篇文章有望帮助你更清楚地理解这个概念。</p><p id="e362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript开发人员使用许多技术来构建强大的应用程序，今天我们将讨论<em class="lv">递归</em>——一个简单地调用自身直到满足条件的函数。</p><p id="d550" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们有一个青蛙列表，我们想计算它们舌头宽度的总和。</p><p id="e9ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然有几种方法可以实现我们的目标，但是为了这篇文章，我们将使用递归来解释它是如何工作的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="02aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个示例代码有效地调用它自己，直到它达到它的目标——青蛙舌头所有宽度的总和。</p><h2 id="ef22" class="ly lz it bd ma mb mc dn md me mf dp mg li mh mi mj lm mk ml mm lq mn mo mp mq bi translated">下面是函数内部发生的情况</h2><p id="ce64" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">首先，它检查是否因为某种原因，我们传入了一个无效的青蛙参数。这是用来防止应用程序崩溃，而是返回初始数字。</p><p id="3a75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还使用了一个<code class="fe mw mx my mz b">console.error</code>来通知开发人员他搞砸了，并去做得更好。</p><p id="8ade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如<a class="ae na" href="https://medium.com/better-programming/currying-inside-javascript-a19f29600880" rel="noopener">库里函数</a>一样，让一个函数成为递归函数需要遵循一些规则。否则，函数不会变成递归函数。在构造递归函数时，有三个最重要的关键特性需要考虑。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="36aa" class="ni lz it bd ma nj nk nl md nm nn no mg jz np ka mj kc nq kd mm kf nr kg mp ns bi translated">递归的三个重要规则</h1><h2 id="49f4" class="ly lz it bd ma mb mc dn md me mf dp mg li mh mi mj lm mk ml mm lq mn mo mp mq bi translated">1.函数应该有一个自毁的条件</h2><p id="1ee7" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">所有递归函数都应该遵循的三个重要规则中的第一个是函数可以用来终止(或自毁)自身的条件。</p><p id="7363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有终止自身的条件，您的代码很有可能会被引入意想不到的错误。通常，这些错误是你想要避免的，因为它是灾难性的，比如<em class="lv">无限循环</em>或<em class="lv">不正确的数据类型</em>，它们会导致你的应用崩溃。</p><p id="e5f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在一天结束时总会有一个终止条件，但你想成为发号施令的人。这是递归的主要工作之一。</p><p id="bce1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，你的函数很有可能会无限运行下去，因为它唯一知道的没有终止条件的事情就是调用自己，直到有东西停止它——而这个东西就是我们最可怕的噩梦:无限循环。</p><p id="9a26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们前面的示例代码中，我们的第一个条件是<em class="lv">终止条件</em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="3d87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe mw mx my mz b">frogs</code>参数是无效的数据类型，我们的应用程序可能会在没有这种情况下崩溃，因为之后的代码使用了只有数组才能使用的方法:</p><pre class="kj kk kl km gt nt mz nu nv aw nw bi"><span id="8f6c" class="ly lz it mz b gy nx ny l nz oa">if (frogs.length === 0) {<br/>  return totalWidth<br/>}</span></pre><p id="462c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们使用错误的数据类型调用函数，例如<code class="fe mw mx my mz b">null</code>:</p><pre class="kj kk kl km gt nt mz nu nv aw nw bi"><span id="6370" class="ly lz it mz b gy nx ny l nz oa">const result = findTotalFrogWidths(0, null)</span></pre><p id="a7c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们得到一个导致程序崩溃的错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><h2 id="f51b" class="ly lz it bd ma mb mc dn md me mf dp mg li mh mi mj lm mk ml mm lq mn mo mp mq bi translated">2.该函数必须有一个基本条件</h2><p id="c58b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">三个关键特征中的第二个是有一个基本条件。基本条件对递归函数的作用与终止条件非常相似，除了它代表你的目标——一个快乐的结局！</p><p id="23b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本用例通常用一个<code class="fe mw mx my mz b">if</code>语句来声明。代码片段中的第二个条件是<em class="lv">基础案例</em>:</p><pre class="kj kk kl km gt nt mz nu nv aw nw bi"><span id="c6fe" class="ly lz it mz b gy nx ny l nz oa"><em class="lv">// We have reached the end. Return the total sum</em><br/>if (frogs.length === 0) {<br/>  return totalWidth<br/>}</span></pre><p id="fe17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之所以说它是基本条件，是因为当<code class="fe mw mx my mz b">frogs</code>数组为<em class="lv">空</em>时，不再有更多的项需要迭代，所以我们不能再做什么了，我们只返回总和。</p><h2 id="d156" class="ly lz it bd ma mb mc dn md me mf dp mg li mh mi mj lm mk ml mm lq mn mo mp mq bi translated">3.自称为</h2><p id="73b1" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">最后，三个中的最后一个定义了一个条件，如果该条件仍然有效，函数必须调用自己(这意味着不满足<em class="lv">终止</em> <strong class="lb iu"> <em class="lv">和</em> </strong> <em class="lv">基本条件</em>)。</p><p id="e59d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归的这一部分构成了递归中的“re”。为了满足基本条件或终止条件，函数必须<em class="lv"> re </em> do(调用)自身继续，直到满足其中一个条件。</p><p id="0292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个取自<a class="ae na" href="https://stackoverflow.com/questions/40982840/javascript-recursion-with-loop" rel="noopener ugc nofollow" target="_blank">堆栈溢出链接</a>的不同例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="a76a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个代码片段中，<code class="fe mw mx my mz b">test</code>是一个函数，它接受一个参数<code class="fe mw mx my mz b">x</code>(应该是一个数字类型)并反复调用自己，同时递增<code class="fe mw mx my mz b">x</code>的值，直到它不再小于<code class="fe mw mx my mz b">3</code>。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="0d60" class="ni lz it bd ma nj nk nl md nm nn no mg jz np ka mj kc nq kd mm kf nr kg mp ns bi translated">结论</h1><p id="ee6c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">而这就是本文的结尾！我希望你发现这是有价值的，并期待在未来更多。</p></div></div>    
</body>
</html>