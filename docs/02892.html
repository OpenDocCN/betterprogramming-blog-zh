<html>
<head>
<title>Use React Hooks to Share States Between your Service Workers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React挂钩在服务人员之间共享状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-hooks-state-share-with-service-workers-9fa7fa7ab7b1?source=collection_archive---------13-----------------------#2020-01-07">https://betterprogramming.pub/react-hooks-state-share-with-service-workers-9fa7fa7ab7b1?source=collection_archive---------13-----------------------#2020-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c8b3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">跨选项卡和窗口通信</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a688392b91b629c54f82f549c72d9ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LOJXVs3O1U7wQcd4mRAfew.gif"/></div></div></figure><p id="ca15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">构建渐进式web应用程序(PWA)通常代表即时访问，无论网络状态如何，但PWA可以通过使用服务人员提供更多功能，包括跨多个浏览器选项卡和窗口的状态共享。</p><p id="8c3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">跨选项卡共享状态可以有多种用途——对于这个特定的示例，让我们考虑一个每次添加或删除产品时都会更新的电子商务购物车。通过将服务工作者与React挂钩结合起来，我们可以有效地实现跨选项卡和窗口的状态共享。让我们来探索一下。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="2227" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">动手反应</h1><p id="7711" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">我们将开始在我们的状态中声明购物车计数器，并创建负责增加和减少袋子上产品计数器的函数。例如，您可以在产品组件内部的行动按钮上调用这些函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/d261cb9090abe2c5da40e90dfe46d50f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K7rSxfn9n5WEnmTQUDWZ-g.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">第一步:<a class="ae mz" href="https://gist.github.com/lucasestevao/39151511f03878fc24b863dcfba7344c#file-step01-js" rel="noopener ugc nofollow" target="_blank">使用状态和辅助功能</a></p></figure><p id="d7ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在与服务人员合作之前，我们必须确保该功能在浏览器中可用，只有这样我们才能安全地注册我们的<code class="fe na nb nc nd b">serviceWorker.js</code>。按照惯例，服务人员的可用性用<code class="fe na nb nc nd b">'serviceWorker' in navigator</code>来验证，但是编码无论如何都不会影响结果。</p><p id="75a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">考虑到在加载页面的转换过程中我们不需要任何动作，我们将在页面加载后应用<a class="ae mz" href="https://developers.google.com/web/fundamentals/primers/service-workers/registration" rel="noopener ugc nofollow" target="_blank">最佳实践</a>来注册服务工作者，从而避免任何性能差距。</p><p id="6011" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在这里的目标是一旦服务人员<a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/ready" rel="noopener ugc nofollow" target="_blank">准备好</a>向<a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/message_event" rel="noopener ugc nofollow" target="_blank">消息事件</a>添加监听器。通过这种方式，当事件被触发并且有数据可用时，我们可以用通过服务工作者发送的值来更新购物车的状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/b4c73510768874421c37b60a8afafb6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VCSuWcbww6o29T4SU_hEKA.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">步骤2: <a class="ae mz" href="https://gist.github.com/lucasestevao/39151511f03878fc24b863dcfba7344c#file-step02-js" rel="noopener ugc nofollow" target="_blank"> useEffect，serviceWorker寄存器，ready和addEventListener </a></p></figure><p id="71c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，我们需要从我们的状态中注入<code class="fe na nb nc nd b">setCounter</code>函数和我们声明的<code class="fe na nb nc nd b">sw</code>变量，以使用<code class="fe na nb nc nd b">useEffect</code>钩子，并在每次从袋子中添加或取出产品时更新计数器。另一方面，我使用了<a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank">可选的链接操作符</a>，据称是为了提高可读性，让代码更整洁。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="a0f1" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">设置服务人员</h1><p id="ad24" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">在<code class="fe na nb nc nd b">serviceWorker.js</code>中，我们将把一个函数绑定到消息事件，从中我们将检索伴随事件而来的数据和客户端的ID(浏览器标签或窗口)。我使用析构赋值语法只解包我需要的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/cc649a807f81ed6b26545521a0f9d9bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RKqAiMCnEb-WwaSAN5wXMg.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">第三步:<a class="ae mz" href="https://gist.github.com/lucasestevao/39151511f03878fc24b863dcfba7344c#file-step03-js" rel="noopener ugc nofollow" target="_blank"> serviceworker.js，clients，matchAll和client postMessage </a></p></figure><p id="8738" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当<code class="fe na nb nc nd b">message</code>事件被触发时，我们将调用<code class="fe na nb nc nd b"><a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/API/Clients" rel="noopener ugc nofollow" target="_blank">Clients</a></code>接口的<code class="fe na nb nc nd b"><a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/API/Clients/matchAll" rel="noopener ugc nofollow" target="_blank">matchAll</a></code>方法。这将为服务工作器<code class="fe na nb nc nd b"><a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/API/Client" rel="noopener ugc nofollow" target="_blank">Client</a></code>对象列表返回一个<code class="fe na nb nc nd b">Promise</code>，它可能代表一个浏览器选项卡或窗口。这将有助于我们获得所有且仅由我们在应用程序中注册的服务人员控制的服务人员客户端。</p><p id="9892" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们有了我们的选项卡和窗口列表(<code class="fe na nb nc nd b">clients</code>)，我们就仔细检查每一个并验证它是否是当前的客户端。在这种情况下，我们使用<code class="fe na nb nc nd b"><a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/API/Client/postMessage" rel="noopener ugc nofollow" target="_blank">postMessage</a></code>方法发送一条消息，其中包含我们在事件中收到的数据。这个方法允许我们的服务人员向客户端发送消息。该消息依次在<code class="fe na nb nc nd b">navigator.serviceWorker</code>的<code class="fe na nb nc nd b">message</code>事件中被接收。</p><p id="b033" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此时，我们能够将服务工作者文件中的操作(postMessage)与我们在React应用程序中声明的侦听器连接起来。下一步是从我们的React应用程序触发对我们的服务人员的操作。</p><p id="396d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们进入下一步之前，我建议将<code class="fe na nb nc nd b"><a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/skipWaiting" rel="noopener ugc nofollow" target="_blank">skipWaiting</a></code>添加到我们服务人员的install事件中。该方法强制等待的服务工作者成为活动的服务工作者。它还确保对底层服务工作者的任何更新将立即对当前客户端和所有其他活动客户端生效，从而为我们的用例提供更好的用户体验。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/0fbe0f8d9dd4ec000c387dde89ce5d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wa_pGLnDNNeRhtOXaVKS3A.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">步骤3.1: <a class="ae mz" href="https://gist.github.com/lucasestevao/39151511f03878fc24b863dcfba7344c#file-step03-js" rel="noopener ugc nofollow" target="_blank"> serviceworker.js，安装并跳过等待</a></p></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="9a3c" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">总结解决方案</h1><p id="c935" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">当用户从一个窗口添加或移除产品时，他们会在屏幕上立即看到状态更新。现在我们需要一个函数来告诉我们的服务人员更新所有其他的选项卡和窗口。</p><p id="1b69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用服务工作者<code class="fe na nb nc nd b"><a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/controller" rel="noopener ugc nofollow" target="_blank">controller</a></code>上可用的<code class="fe na nb nc nd b"><a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage" rel="noopener ugc nofollow" target="_blank">postMessage</a></code>，将状态值作为参数传递。</p><p id="eb83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">控制器是<code class="fe na nb nc nd b">ServiceWorkerContainer</code>接口的只读属性，并返回一个<code class="fe na nb nc nd b">ServiceWorker</code>对象，该对象从其父对象<code class="fe na nb nc nd b">Worker</code>继承方法，其中<code class="fe na nb nc nd b">postMessage</code>方法可用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/b9c78cd4fc5a340c6362337ce8b6781c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*184KZL-WIxcpJI-uYaNYCw.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">第四步。<a class="ae mz" href="https://gist.github.com/lucasestevao/39151511f03878fc24b863dcfba7344c#file-step04-js" rel="noopener ugc nofollow" target="_blank">控制器和工人后消息</a></p></figure><p id="8452" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们在自己的辅助函数中调用<code class="fe na nb nc nd b">stateToServiceWorker</code>函数来减少和增加状态。这个循环是完整的——我们可以向服务人员发送更新并从其接收更新，同时保持多个选项卡和窗口的简洁状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/99d2a4faf48bab3e8d4882d2c3a4ca44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TxTp6ONQnTUz7pNRhoOgqg.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">第五步:<a class="ae mz" href="https://gist.github.com/lucasestevao/39151511f03878fc24b863dcfba7344c#file-step05-js" rel="noopener ugc nofollow" target="_blank"> serviceworker.js，安装并跳过等待</a></p></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="0e74" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">资源</h1><p id="6e86" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">下面你可以找到这个用例的完整代码。</p><p id="581f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">GitHub:</strong><a class="ae mz" href="https://github.com/lucasestevao/react-serviceworker-state-share/tree/master/" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/lucasestevao/react-service worker-state-share/tree/master/</a></p><p id="837b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">code sandbox:</strong><a class="ae mz" href="https://codesandbox.io/s/github/lucasestevao/react-serviceworker-state-share/tree/master/" rel="noopener ugc nofollow" target="_blank">https://code sandbox . io/s/github/lucasestevao/react-service worker-state-share/tree/master/</a></p><p id="6b96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">【https://csb-nxdkl-pjh3c3wz3.now.sh/】直播项目:<a class="ae mz" href="https://csb-nxdkl-pjh3c3wz3.now.sh/" rel="noopener ugc nofollow" target="_blank"/></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/b6d4fa2f55a6a5bebacf9998306e1e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYEjQc1jbo2Y9qQ_9WtxeA.png"/></div></div></figure><p id="9384" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>