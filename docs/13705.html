<html>
<head>
<title>I’m a Fan of Python’s Default Map. Can Kotlin Do the Same?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是Python默认地图的粉丝。科特林也能做到吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/im-a-fan-of-python-s-default-map-can-kotlin-do-the-same-b75187186f32?source=collection_archive---------7-----------------------#2022-09-18">https://betterprogramming.pub/im-a-fan-of-python-s-default-map-can-kotlin-do-the-same-b75187186f32?source=collection_archive---------7-----------------------#2022-09-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2495" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">见见科特林版本的defaultDict</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/74540aeddc0a2ca47e1dd43a80000214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pk-VDLtzBpCRZFRR7O9mgg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一张世界地图</p></figure><p id="d9dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们都知道什么是(散列)映射，如果你知道Python编程语言，你可能在某个时候遇到过<code class="fe lu lv lw lx b">defaultdict</code>。我想知道Kotlin中是否有相同的构造，我将在本文中解释我的发现。</p><p id="b914" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python的<code class="fe lu lv lw lx b">defaultdict</code>文档包括几个例子可以在<a class="ae ly" href="https://docs.python.org/2/library/collections.html#defaultdict-examples" rel="noopener ugc nofollow" target="_blank">这里</a>找到。下面的代码片段演示了它的基本用法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="04d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认字典的名字来源于这样一个事实，即它包含了它还不知道的键的默认值。就像上面的例子，一个客户端试图从映射中取出一个随机值，结果得到一个值<code class="fe lu lv lw lx b">0</code>,尽管从来没有任何东西写到映射中。</p><p id="6849" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">defaultdict</code>也可以用于整数之外的其他类型，并确保在未知的键访问中不会出现<code class="fe lu lv lw lx b">KeyError</code>。相反，它为未知键提供了一个默认值，这对于分组和计数算法非常有用，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="d715" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个小工具非常有用，我经常用它来解决你在很多很多技术面试中遇到的算法问题，我在这里写了关于<a class="ae ly" href="https://medium.com/better-programming/i-share-my-top-4-tips-for-succeeding-in-your-next-technical-coding-interview-21408f142b1b" rel="noopener">的</a>。</p><p id="15ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们考虑一下Kotlin编程语言，看看我们是否可以拥有与Python的<code class="fe lu lv lw lx b">defaultdict</code>相同的行为。</p><h1 id="acdb" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">一个简单的问题</h1><p id="8050" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">假设我们要编写一个通用函数，该函数接受一个集合并返回一个映射，该映射包含原始集合中与其出现次数相关联的元素:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="fa1e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然在Kotlin中有一个自然的函数方法来实现这一点，但我们想先考虑一些迭代方法。先说下面这个。</p><h1 id="41c1" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">方法1:没有默认值的迭代解决方案</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="319d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以为这个算法使用一个<code class="fe lu lv lw lx b">MutableMap</code>。当迭代所有的值时，我们查看地图，看它以前是否被见过。如果是，我们递增计数器；否则，我们将初始计数<code class="fe lu lv lw lx b">1</code>放入映射中。让我们看看如何更好地利用显式缺省值。</p><h1 id="8359" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">方法2:带有显式默认值的迭代解决方案</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="6418" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为前一个解决方案的替代方案，我们可以利用<code class="fe lu lv lw lx b">putIfAbsent</code>来确保元素被初始化为0，这样我们就可以安全地递增下面一行中的计数器。在这种情况下，我们所做的是提供一个显式的默认值。另一个类似的工具是<code class="fe lu lv lw lx b">getOrDefault</code>:</p><pre class="kj kk kl km gt my lx mz na aw nb bi"><span id="5bfa" class="nc mc it lx b gy nd ne l nf ng">countMap[e] = countMap.getOrDefault(e, 0) + 1</span></pre><p id="6da3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过<code class="fe lu lv lw lx b">putIfAbsent</code>或<code class="fe lu lv lw lx b">getOrDefault</code>提供明确的缺省值会带来简单易懂的解决方案，但我们可以做得更好。</p><h1 id="44a2" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">隐式缺省迭代解法</h1><p id="7ef8" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">类似于Python的<code class="fe lu lv lw lx b">defaultdict</code>，Kotlin附带了一个简洁的<a class="ae ly" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/with-default.html" rel="noopener ugc nofollow" target="_blank">扩展</a>叫做<code class="fe lu lv lw lx b">MutableMap::withDefault</code>，看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="906a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个扩展允许为在映射中没有关联值的键提供一个初始化器。让我们在解决方案中使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="f564" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它进一步简化了代码，因为我们不再需要处理迭代中的未知值。因为我们使用的是默认映射，所以我们可以安全地从中获取值，并在进行过程中递增计数器。</p><h2 id="0759" class="nc mc it bd md nh ni dn mh nj nk dp ml lh nl nm mn ll nn no mp lp np nq mr nr bi translated">重要说明</h2><p id="f4a5" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">使用<code class="fe lu lv lw lx b">withDefault</code>扩展时需要注意一件重要的事情，这是它的文档的一部分:</p><blockquote class="ns nt nu"><p id="1af3" class="ky kz nv la b lb lc ju ld le lf jx lg nw li lj lk nx lm ln lo ny lq lr ls lt im bi translated"><em class="it"> […]当原始映射不包含指定键的值，并且值是通过【Map.getValue】函数</em>  <em class="it"> […] </em>获得的 <strong class="la iu"> <em class="it">时，使用该隐式默认值</em></strong></p></blockquote><p id="77ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">仅当您使用<code class="fe lu lv lw lx b">Map::getValue</code>时，才会提供默认值，而使用索引操作符访问地图时，情况并非如此。</p><p id="57c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样做的原因是<code class="fe lu lv lw lx b">Map</code>接口的契约，它说:</p><blockquote class="ns nt nu"><p id="a481" class="ky kz nv la b lb lc ju ld le lf jx lg nw li lj lk nx lm ln lo ny lq lr ls lt im bi translated"><em class="it">返回与给定的【关键字】相对应的值，或者</em> <code class="fe lu lv lw lx b"><em class="it">null</em></code> <em class="it">如果这样的关键字在地图中不存在。</em></p></blockquote><p id="649b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然默认地图想要履行这个契约，那么在不存在key的情况下除了<code class="fe lu lv lw lx b">null</code>之外不能返回任何东西，这个问题之前已经在<a class="ae ly" href="https://discuss.kotlinlang.org/t/map-withdefault-not-defaulting/7691" rel="noopener ugc nofollow" target="_blank"> Kotlin论坛</a>讨论过了。</p><h1 id="8e07" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">让我们习惯性地</h1><p id="87b7" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">好的，我们看到Kotlin确实提供了在地图中提供默认值的方法，这很好。但是，像我们在上面的例子中那样写代码是习惯性的吗？嗯，看情况。使用Kotlin自带的分组和计数功能的函数式API，大多数情况都可以用简单得多的方式解决。</p><p id="1c5d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管如此，了解备选方案还是有好处的，因为在某些情况下，您可能会选择使用迭代方法。如果你的目标是时间和空间上最优的解决方案，这一点尤其正确。让我为您提供我们代码的简化版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="381a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它仍然使用了一个显式的<code class="fe lu lv lw lx b">for</code>循环，但是通过使用<code class="fe lu lv lw lx b">apply</code>得到了简化，它允许我们在一条语句中初始化map。你可以在这里阅读<code class="fe lu lv lw lx b">apply</code>和所有其他范围函数<a class="ae ly" href="https://medium.com/@s1m0nw1/kotlin-and-its-5-powerful-scope-functions-cc7b1c7a5400" rel="noopener"/>。</p><p id="c5b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Kotlin中有几十种方法可以解决给定的问题，但是可能最短的(虽然不是最佳的)一种<strong class="la iu">是</strong>一种功能方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h1 id="e19c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="1b79" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我们可以使用Kotlin以许多不同的方式解决简单的算法。与Python类似，您可以使用默认值提供者初始化地图，但需要注意常规索引操作访问不会像您预期的那样工作。</p><p id="cc17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如文件所述，必须使用<code class="fe lu lv lw lx b">getValue</code>功能。由于Kotlin附带了一个非常有用的标准库，所以您应该考虑尽可能多地使用它。这意味着，在大多数情况下，实现分组或计数等常见的事情不需要从头开始实现，而是利用标准库中现有的功能来完成。</p><p id="018d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，如果你的目标是最优的解决方案，例如，在一次编码面试中，了解功能方法的替代方案是很重要的，这使得评估时间和空间的复杂性变得很困难。知道如何使用默认映射是编写可理解的高性能代码的重要一步。</p></div></div>    
</body>
</html>