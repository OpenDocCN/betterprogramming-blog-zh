<html>
<head>
<title>How to Use the Room Persistence Library With Kotlin Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过Kotlin流使用房间持久性库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-the-room-persistence-library-with-kotlin-flow-c73f461a0819?source=collection_archive---------2-----------------------#2020-04-03">https://betterprogramming.pub/how-to-use-the-room-persistence-library-with-kotlin-flow-c73f461a0819?source=collection_archive---------2-----------------------#2020-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="edd6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实现从数据库到用户界面的连续数据流</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bb963abf70c9b201383969d2a7952d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kly5S1wgk9DBQCnLliHVSA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@viniciusamano?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Vinicius Amano </a>在<a class="ae ky" href="https://unsplash.com/s/photos/room?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7c99" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">这篇文章的要点</h1><p id="c20c" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><a class="ae ky" href="https://kotlinlang.org/docs/reference/coroutines/flow.html" rel="noopener ugc nofollow" target="_blank"> Kotlin流</a>是Coroutines团队的一个新的强大特性。使用它从本地数据库获得持续更新使得Android应用程序更具反应性。</p><p id="9eda" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">到本文结束时，您将学习如何将Kotlin流与<a class="ae ky" href="https://developer.android.com/topic/libraries/architecture/room" rel="noopener ugc nofollow" target="_blank"> Room persistence库</a>一起使用，以及如何使用流仅观察表中的特定行。</p><p id="ddf4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">观察数据列表或数据库表中的特定行是一个现有的特性，但是使用Kotlin Flow进行观察会更有效。</p><p id="492c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">尤其是当您更新数据库中的内容，并希望用最新数据更新应用程序的先前屏幕时，您已经开始观察来自<code class="fe mz na nb nc b">Dao</code>的数据。</p><p id="a595" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在进入深入的技术内容之前，让我们看看需要的必要步骤。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="4b7a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated"><strong class="ak">整合</strong></h1><p id="b8af" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">将房间数据库与目前最新版本的AndroidX、Kotlin和Coroutines支持相集成。这里，我们使用<code class="fe mz na nb nc b">kept</code>代替注释处理器。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="225a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">实体</h1><p id="50a7" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">任何数据类上面的<code class="fe mz na nb nc b">@Entity</code>注释表示数据库中的一个表。</p><p id="4115" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">类中的每个字段都是数据库表中的一列，我们可以通过用<strong class="ma iu"> </strong> <code class="fe mz na nb nc b">@ColumnInfo (name = “column_name”)</code>注释该字段来给该列指定一个特定的名称，并且至少应该有一个主键字段。</p><p id="ef19" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">假设我们有一个电视节目的数据库，其中名称是主键；因此，我们不能在数据库中有两个同名的节目。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="eba7" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">大刀</h1><p id="b9b2" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Dao(数据访问对象)<strong class="ma iu"> </strong>是一个带注释<code class="fe mz na nb nc b">@Dao</code>的接口类；使用<code class="fe mz na nb nc b">Dao</code>接口，我们可以从数据库中访问数据(<code class="fe mz na nb nc b">@Entity</code>)。</p><p id="3b89" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在这里，我们有一个<code class="fe mz na nb nc b">Dao</code>接口，它对电视节目列表进行简单的GET和SET操作。现在为了简单起见，我们在<code class="fe mz na nb nc b">getTvShows </code>上使用<code class="fe mz na nb nc b">LiveData</code>而不是Flow。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7fae" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">是时候向数据库中添加一些数据了，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4329" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">到目前为止，我们使用<code class="fe mz na nb nc b">Dao</code>函数从数据库获取数据并更新UI。由于这是一种<code class="fe mz na nb nc b">livedata</code>排放，它将具有生命周期意识。</p><p id="ae54" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">假设您最初从数据库中获得数据并更新了UI，现在我们将另一个show (Lucifer)添加到<code class="fe mz na nb nc b">Tvshows</code>表中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1abd" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在Flow之前，我们需要显式地检查是否有任何额外的数据添加到数据库中，并更新UI，因为只有当数据在另一端发布时，实时数据才会发出数据。</p><p id="1ea9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">但是有了Flow，房间数据库会处理这些变化，并将它们发布到相应的观察点，而不需要任何额外的工作。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="4063" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">理论够了，我们来看看怎么用流量</h1><p id="d484" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们将从改变动态数据在<code class="fe mz na nb nc b">Dao</code>接口中流动开始。看一看:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="347c" class="nj lh it nc b gy nk nl l nm nn">@Query("SELECT * FROM FavTvShows")<br/>fun getAllshows(): <strong class="nc iu">Flow</strong>&lt;List&lt;FavTvShows&gt;&gt;</span></pre><p id="2f90" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">既然我们已经移除了另一端的实时数据，我们就不能使用可观测量了。我们必须使用<code class="fe mz na nb nc b">collect</code>，一个内联扩展函数来从<code class="fe mz na nb nc b">Dao</code>获取数据。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3f83" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在，每当表中的一个显示被更新时，协程将使用数据库中该表的整个列表触发collect扩展。</p><p id="eb51" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">然而，这种行为意味着如果我们更新一个不相关的行，比如Suits show，那么流就会发出GOT、Lucifer和其他具有相同数据的show。</p><p id="3074" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这是因为<a class="ae ky" href="https://www.sqlite.org/" rel="noopener ugc nofollow" target="_blank"> SQLite </a>只允许表级通知；因此，Room触发整个查询以确保您已经更新了数据。</p><p id="f548" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">您可以使用像<code class="fe mz na nb nc b"><a class="ae ky" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html" rel="noopener ugc nofollow" target="_blank">distinctUntilChanged</a></code>这样的流操作符，以确保您将只接收特定的行更新。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4a51" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在，当您想要观察Suits行中的变化时，您可以通过使用<code class="fe mz na nb nc b">getShowDistinctUntilChanged</code>函数并将节目名称作为参数传递来实现，Room确保您只在特定节目更新时得到通知。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c0fc" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>