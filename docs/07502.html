<html>
<head>
<title>15 Commonly Asked NodeJS Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">15个常见的面试问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/15-commonly-asked-nodejs-interview-questions-2b0254700f80?source=collection_archive---------2-----------------------#2021-01-21">https://betterprogramming.pub/15-commonly-asked-nodejs-interview-questions-2b0254700f80?source=collection_archive---------2-----------------------#2021-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e1e5" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">面试问题</h2><div class=""/><div class=""><h2 id="1474" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">熟悉下一次面试中你可能会遇到的问题</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/cee59ec342dce8014039f6af9a312ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cyyDw3rKxpuObHP2ZKjjew.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="219b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于一次成功的编程面试来说，准备和知识一样重要。准备让你有信心参加面试，没有不确定的紧张。如果是人生第一次面对编程面试，更是如此。</p><p id="8708" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了帮助Node.js开发人员为面试做好必要的准备，我列出了15个与Node.js和web开发相关的常见面试问题。这些问题和答案也将促使你在大面试前温习任何你觉得需要改进的地方。</p><p id="252f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本文中，我们将重点关注与Node.js相关的问题。但是，请记住，关于JavaScript的问题在Node.js面试中非常常见，因此，您也可以准备一些这样的问题。我们不久前写了一篇关于<a class="ae md" href="https://livecodestream.dev/post/20-common-javascript-interview-questions/" rel="noopener ugc nofollow" target="_blank">常见JavaScript面试问题</a>的文章，涵盖了所有这些基础。</p><p id="a960" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，让我们来看看你在下次面试中可能会被问到的与节点相关的问题。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="f312" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">Node.js和Javascript有什么不同？</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/7b62093cc71c6dfbf370fc84682d4177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JTsTE5WsdmZMRsMOfyBWhQ.png"/></div></div></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="00be" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">什么时候该用，什么时候不该用Node.js？</h1><p id="20b0" class="pw-post-body-paragraph lh li it lj b lk ne kd lm ln nf kg lp lq ng ls lt lu nh lw lx ly ni ma mb mc im bi translated">Node.js是异步的、事件驱动的、非阻塞的、单线程的。它使Node成为开发以下类型应用程序的完美候选:</p><ul class=""><li id="eddb" class="nj nk it lj b lk ll ln lo lq nl lu nm ly nn mc no np nq nr bi translated">实时应用程序，如聊天和提供实时更新的应用程序。</li><li id="c80b" class="nj nk it lj b lk ns ln nt lq nu lu nv ly nw mc no np nq nr bi translated">向大量观众播放视频或其他多媒体内容的流媒体应用程序。</li><li id="3019" class="nj nk it lj b lk ns ln nt lq nu lu nv ly nw mc no np nq nr bi translated">其他I/O密集型应用，如协作平台。</li><li id="b403" class="nj nk it lj b lk ns ln nt lq nu lu nv ly nw mc no np nq nr bi translated">遵循微服务架构的Web后端。</li></ul><p id="6905" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然而，Node.js的独特品质使得它对于其他类型的应用程序来说并不是理想的选择。执行CPU密集型任务(如复杂的数学计算)的应用程序不能很好地使用Node.js，因为它是单线程执行的。</p><p id="a480" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你想了解更多，请查看我们的文章<a class="ae md" href="https://livecodestream.dev/post/when-you-should-and-should-not-use-nodejs-for-your-project/" rel="noopener ugc nofollow" target="_blank"> Node.js架构以及何时在项目中使用node . js</a>。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="1fae" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">EventEmitter是做什么的？</h1><p id="fc1c" class="pw-post-body-paragraph lh li it lj b lk ne kd lm ln nf kg lp lq ng ls lt lu nh lw lx ly ni ma mb mc im bi translated">Node.js中每个能够发出事件的对象都是<code class="fe nx ny nz oa b">EventEmitter</code>类的成员。<code class="fe nx ny nz oa b">http</code>模块就是这样一个例子。</p><p id="d22e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">所有的<code class="fe nx ny nz oa b">EventEmitter</code>类都可以使用<code class="fe nx ny nz oa b">eventEmitter.on()</code>函数将事件监听器附加到事件上。然后，一旦捕捉到这样的事件，它的侦听器就会被同步调用，一个接一个。</p><pre class="ks kt ku kv gt ob oa oc od aw oe bi"><span id="126c" class="of mm it oa b gy og oh l oi oj">const events = require("events");<br/>const eventEmitter = new events.EventEmitter();</span><span id="29a6" class="of mm it oa b gy ok oh l oi oj">const eventListener = function(){<br/>    console.log("event triggered");<br/>}</span><span id="4f1d" class="of mm it oa b gy ok oh l oi oj">eventEmitter.on("emitted", eventListener);</span><span id="0157" class="of mm it oa b gy ok oh l oi oj">eventEmitter.emit("emitted");</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="0ede" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">Node的事件循环是什么？</h1><p id="aa76" class="pw-post-body-paragraph lh li it lj b lk ne kd lm ln nf kg lp lq ng ls lt lu nh lw lx ly ni ma mb mc im bi translated">由于Node.js是单线程的，所以它必须是非阻塞的，以防止线程在需要很长时间才能完成的任务上花费太多时间。事件循环负责实现这种非阻塞行为。它的工作是使用应用程序线程调度未完成的任务。</p><p id="b17e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们知道，节点使用回调来处理异步函数在其任务完成时返回的响应。与创建任务的事件类似，任务的完成也会发出一个事件。Node.js将需要处理的事件添加到事件队列中。</p><p id="6552" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">事件循环遍历事件队列中的事件，并调度何时执行它们相关的回调函数。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="bf0b" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">什么是节点流？</h1><p id="f581" class="pw-post-body-paragraph lh li it lj b lk ne kd lm ln nf kg lp lq ng ls lt lu nh lw lx ly ni ma mb mc im bi translated">流是从源读取或写入数据并将其传输到连续流目标的管道。有四种类型的流:</p><ul class=""><li id="1d91" class="nj nk it lj b lk ll ln lo lq nl lu nm ly nn mc no np nq nr bi translated">可读。</li><li id="f8ae" class="nj nk it lj b lk ns ln nt lq nu lu nv ly nw mc no np nq nr bi translated">可写。</li><li id="80b7" class="nj nk it lj b lk ns ln nt lq nu lu nv ly nw mc no np nq nr bi translated">双工(可读和可写)。</li><li id="e7b3" class="nj nk it lj b lk ns ln nt lq nu lu nv ly nw mc no np nq nr bi translated">转换(一种双工流。使用输入计算输出)。</li></ul><p id="f8b9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">每个流也是一个<code class="fe nx ny nz oa b">EventEmitter</code>。这意味着当流中没有数据时，当流中有数据时，或者当流中的数据从程序中刷新时，流对象可以发出事件。</p><pre class="ks kt ku kv gt ob oa oc od aw oe bi"><span id="4c4b" class="of mm it oa b gy og oh l oi oj">const fs = require("fs");<br/>const readableStream = fs.createReadStream("test.txt");<br/>let content = "";</span><span id="16da" class="of mm it oa b gy ok oh l oi oj">readableStream.on("data", (chunk) =&gt; {<br/>  content += chunk;<br/>});</span><span id="3406" class="of mm it oa b gy ok oh l oi oj">readableStream.on("end", () =&gt; {<br/>  console.log(content);<br/>});</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="b5d3" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">Readfile和Createreadstream函数有什么区别？</h1><p id="e694" class="pw-post-body-paragraph lh li it lj b lk ne kd lm ln nf kg lp lq ng ls lt lu nh lw lx ly ni ma mb mc im bi translated"><code class="fe nx ny nz oa b">readFile</code>函数异步读取文件的全部内容，并在传递给用户之前将其存储在内存中。</p><p id="1ab8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe nx ny nz oa b">createReadStream</code>使用一个可读的流来逐块读取文件，而不是将整个文件存储在内存中。</p><p id="74ce" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe nx ny nz oa b">createReadStream</code>与<code class="fe nx ny nz oa b">readFile</code>相比，优化了文件读取操作，使用的内存更少，速度更快。如果文件相当大，用户不需要等待很长时间就可以获得全部内容，因为用户在阅读文件时会收到小块内容。</p><pre class="ks kt ku kv gt ob oa oc od aw oe bi"><span id="d767" class="of mm it oa b gy og oh l oi oj">const fs = require("fs");</span><span id="681b" class="of mm it oa b gy ok oh l oi oj">fs.readFile("test.txt", (err, content) =&gt; {<br/>  console.log( content);<br/>});</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="b42e" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">如何处理node.js中未捕获的异常？</h1><p id="5a5d" class="pw-post-body-paragraph lh li it lj b lk ne kd lm ln nf kg lp lq ng ls lt lu nh lw lx ly ni ma mb mc im bi translated">我们可以在应用程序的进程级捕捉应用程序中抛出的未捕捉到的异常。为此，我们给<code class="fe nx ny nz oa b">process</code>全局对象附加了一个监听器:</p><pre class="ks kt ku kv gt ob oa oc od aw oe bi"><span id="d05f" class="of mm it oa b gy og oh l oi oj">process.on("uncaughtException", (err) =&gt; {<br/>  console.log("exception caught: ", err);<br/>});</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="bf42" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">节点能充分利用多处理器系统吗？</h1><p id="b5b6" class="pw-post-body-paragraph lh li it lj b lk ne kd lm ln nf kg lp lq ng ls lt lu nh lw lx ly ni ma mb mc im bi translated">节点应用程序总是单线程的。因此，自然地，应用程序只使用单个处理器，即使运行在多处理器系统上。</p><p id="007f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但Node的核心模块之一Cluster为节点应用程序提供了支持，以利用多个内核。它允许我们创建多个工作进程，这些工作进程可以在几个内核上并行运行，并共享一个端口来侦听事件。</p><p id="1a18" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里，每个进程使用IPC与主线程通信，并根据需要将服务器句柄传递给其他进程。主进程可以自己监听端口，并将每个新连接循环传递给子进程，或者将端口分配给子进程，以便子进程监听请求。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="f151" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">node.js中使用的反应器设计模式是什么？</h1><p id="28c7" class="pw-post-body-paragraph lh li it lj b lk ne kd lm ln nf kg lp lq ng ls lt lu nh lw lx ly ni ma mb mc im bi translated">反应器模式用于维护Node.js中的非阻塞I/O操作。它为每个I/O操作附加一个回调函数(一个处理程序)。然后，在创建请求时，将处理程序提交给多路分解器。</p><p id="2513" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">多路分解器收集应用程序中发出的每个I/O请求，并将它们作为事件排列在队列中。这个队列就是我们所说的事件队列。事件排队后，解复用器返回应用程序线程的控制权。</p><p id="a716" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">同时，事件循环遍历事件队列中的每个事件，并调用附加的回调来处理事件响应。</p><p id="bf8d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是Node.js使用的反应器模式。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="3569" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">单线程Web后端相对于多线程有什么好处？</h1><p id="076a" class="pw-post-body-paragraph lh li it lj b lk ne kd lm ln nf kg lp lq ng ls lt lu nh lw lx ly ni ma mb mc im bi translated">尽管Node是单线程的，但大多数用于后端开发的编程语言都提供了多线程来处理应用程序操作。</p><p id="e9d6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为什么只有单线程有利于后端开发？</p><ul class=""><li id="bdf3" class="nj nk it lj b lk ll ln lo lq nl lu nm ly nn mc no np nq nr bi translated">开发人员更容易实现应用程序。我们的应用程序在生产过程中没有突然遇到意外竞争情况的风险。</li><li id="193e" class="nj nk it lj b lk ns ln nt lq nu lu nv ly nw mc no np nq nr bi translated">单线程应用程序很容易扩展。</li><li id="b02b" class="nj nk it lj b lk ns ln nt lq nu lu nv ly nw mc no np nq nr bi translated">它们可以在没有太多延迟的情况下同时处理大量的用户请求。相比之下，当流量较高时，多线程后端必须等待线程池中的一个线程空闲，以服务于用户请求。由于节点的非阻塞特性，用户请求不会在单线程上停留太长时间(只有在操作不是CPU密集型的时候才会这样)。</li></ul></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="1d16" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">节点中的REPL是什么？</h1><p id="e199" class="pw-post-body-paragraph lh li it lj b lk ne kd lm ln nf kg lp lq ng ls lt lu nh lw lx ly ni ma mb mc im bi translated">REPL代表读取-评估-打印-循环。这是一个虚拟的环境，你可以在其中轻松地运行编程语言。Node带有一个内置的REPL来运行JavaScript代码。它类似于我们在浏览器中用来运行JavaScript代码的控制台。</p><p id="6abe" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">要启动节点REPL，只需在命令行上运行命令Node。然后，一旦在一行中编写了一行JavaScript代码，就可以在下一行中看到它的输出。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="319f" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">process.nexttick和Setimmediate函数有什么区别？</h1><p id="19d0" class="pw-post-body-paragraph lh li it lj b lk ne kd lm ln nf kg lp lq ng ls lt lu nh lw lx ly ni ma mb mc im bi translated">传递给<code class="fe nx ny nz oa b">setImmediate</code>函数的回调在事件队列上事件循环的下一次迭代中执行。</p><p id="e995" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">另一方面，传递给<code class="fe nx ny nz oa b">process.nextTick</code>的回调在事件循环的下一次迭代之前执行，并且在程序中当前运行的操作完成之后执行。在应用程序启动时，它的回调在事件循环开始遍历事件队列之前被调用。</p><p id="658a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，<code class="fe nx ny nz oa b">process.nextTick</code>的回调总是在<code class="fe nx ny nz oa b">setImmediate</code>的回调之前被调用。</p><p id="9ed4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果我们考虑下面的代码片段:</p><pre class="ks kt ku kv gt ob oa oc od aw oe bi"><span id="8721" class="of mm it oa b gy og oh l oi oj">setImmediate(() =&gt; {<br/>  console.log("first");<br/>})</span><span id="1938" class="of mm it oa b gy ok oh l oi oj">process.nextTick(() =&gt; {<br/>  console.log("second");<br/>})</span><span id="29d9" class="of mm it oa b gy ok oh l oi oj">console.log("third");</span></pre><p id="646b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">输出按以下顺序打印。</p><pre class="ks kt ku kv gt ob oa oc od aw oe bi"><span id="ac58" class="of mm it oa b gy og oh l oi oj">third<br/>second<br/>first</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="5038" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">什么是存根？</h1><p id="761b" class="pw-post-body-paragraph lh li it lj b lk ne kd lm ln nf kg lp lq ng ls lt lu nh lw lx ly ni ma mb mc im bi translated">测试应用程序时会用到存根。它们模拟给定组件或模块的行为，以便您可以专注于您想要测试的代码部分。通过使用存根代替与测试无关的组件，您不必担心外部组件会影响结果。</p><p id="22e8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">例如，如果您正在测试的组件在您期望测试的部分之前有一个文件读取操作，您可以使用一个存根来模拟该行为并返回一个模拟内容，而不实际读取文件。</p><p id="c4fe" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在Node中，我们使用像Sinon这样的库来实现这个目的。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="6003" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">为什么在Express中将“应用程序”和“服务器”分开是一种好的做法？</h1><p id="ed69" class="pw-post-body-paragraph lh li it lj b lk ne kd lm ln nf kg lp lq ng ls lt lu nh lw lx ly ni ma mb mc im bi translated">通过在Express中分离<code class="fe nx ny nz oa b">app</code>和<code class="fe nx ny nz oa b">server</code>，我们可以将API实现与网络相关的配置分离开来。这允许我们在不执行网络调用的情况下执行API测试。这也保证了更快的测试执行和更好的代码覆盖度量。</p><p id="6b10" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了实现这种分离，您应该在单独的文件中声明API和服务器。这里我们使用两个文件:<code class="fe nx ny nz oa b">app.js</code>和<code class="fe nx ny nz oa b">server.js</code>:</p><pre class="ks kt ku kv gt ob oa oc od aw oe bi"><span id="23cd" class="of mm it oa b gy og oh l oi oj">//app.js<br/>const express = require("express");<br/>const app = express();</span><span id="bed8" class="of mm it oa b gy ok oh l oi oj">app.use("/", index);<br/>app.use("/contact", contact);<br/>app.use("/user", user);</span><span id="a3f6" class="of mm it oa b gy ok oh l oi oj">module.exports = app;<br/></span><span id="58b8" class="of mm it oa b gy ok oh l oi oj">//server.js<br/>const http = require("http");<br/>const app = require("/app");</span><span id="9d02" class="of mm it oa b gy ok oh l oi oj">app.set('port', process.env.PORT);</span><span id="2bf2" class="of mm it oa b gy ok oh l oi oj">const http = http.createServer(app);</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="400c" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">什么是Yarn和Npm？为什么要使用纱线而不是Npm？</h1><p id="3926" class="pw-post-body-paragraph lh li it lj b lk ne kd lm ln nf kg lp lq ng ls lt lu nh lw lx ly ni ma mb mc im bi translated"><code class="fe nx ny nz oa b">npm</code>是Node.js发布的默认包管理器。它有一个大型的公共和私有包库，存储在一个名为emp registry的数据库中，用户可以通过npm的命令行客户端访问该数据库。在npm的帮助下，用户可以轻松地管理项目中使用的依赖关系。</p><p id="981e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe nx ny nz oa b">yarn</code>也是一个软件包管理器，它的发布是为了解决npm的一些缺点。然而，yarn依赖npm注册表来为用户提供对包的访问。因为yarn的底层结构是基于npm本身的，所以如果您从npm迁移到yarn，您的项目结构和工作流不必经历重大的改变。</p><p id="6f57" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">就像我之前提到的，在某些情况下，yarn提供了比npm更好的功能。不像npm，它缓存你下载的每一个包，所以你不必在需要的时候重新下载。</p><p id="0416" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它还通过使用校验和来验证包的完整性，从而提供了更好的安全性。它保证了在某个系统上工作的包在其他系统上的工作方式完全相同。这些就是为什么你会选择纱线而不是npm进行包装管理的原因。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="36e8" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">结论</h1><p id="9f24" class="pw-post-body-paragraph lh li it lj b lk ne kd lm ln nf kg lp lq ng ls lt lu nh lw lx ly ni ma mb mc im bi translated">在这篇文章中，我们讨论了15个最常见的Node.js面试问题，以帮助你更好地准备下一次面试。知道你可能会被问到的问题类型，知道他们的答案，会给你自信去回答面试问题，而不会感到怀疑和紧张。</p><p id="aedd" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">无论你何时面对这个重要的面试，我们都祝你好运，并祝你成功！</p></div></div>    
</body>
</html>