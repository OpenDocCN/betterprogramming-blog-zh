<html>
<head>
<title>How to Use Stateful Operations in Kafka Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Kafka流中使用有状态操作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-stateful-operations-in-kafka-streams-1cff4da41329?source=collection_archive---------1-----------------------#2020-03-12">https://betterprogramming.pub/how-to-use-stateful-operations-in-kafka-streams-1cff4da41329?source=collection_archive---------1-----------------------#2020-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ee30" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索Kafka Streams DSL API中的有状态操作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/81dfe9813db29c321ece36b6e9eabd2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VnEFM0-NSAgsbQdV"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">内森·杜姆劳在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="85e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://medium.com/better-programming/learn-stream-processing-with-kafka-streams-stateless-operations-2111080e6c53" rel="noopener"><a class="ae kv" href="https://kafka.apache.org/documentation/streams/" rel="noopener ugc nofollow" target="_blank">Kafka Streams</a>API博客系列的第一部分</a>涵盖了无状态<strong class="ky ir"> </strong>函数，如<code class="fe ls lt lu lv b">filter</code>、<code class="fe ls lt lu lv b">map</code>等。</p><div class="lw lx gp gr ly lz"><a href="https://medium.com/better-programming/learn-stream-processing-with-kafka-streams-stateless-operations-2111080e6c53" rel="noopener follow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">使用Kafka流学习流处理</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">无状态操作</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">medium.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kp lz"/></div></div></a></div><p id="b728" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一部分中，我们将探索Kafka Streams DSL API中有状态的<strong class="ky ir"> </strong>操作。我们将重点关注聚合操作，如<code class="fe ls lt lu lv b">aggregate</code>、<code class="fe ls lt lu lv b">count</code>和<code class="fe ls lt lu lv b">reduce</code>，并讨论相关的概念。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="71cb" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">聚合</h1><p id="f0bb" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">聚合操作应用于相同关键字的记录。Kafka Streams支持以下聚合:<code class="fe ls lt lu lv b">aggregate</code>、<code class="fe ls lt lu lv b">count</code>和<code class="fe ls lt lu lv b">reduce</code>。正如上一篇文章中提到的，分组是聚合的先决条件。您可以在<code class="fe ls lt lu lv b">KStream</code>或<code class="fe ls lt lu lv b">KTable</code>上运行<code class="fe ls lt lu lv b">groupBy</code>(或其变体)，这将分别产生<code class="fe ls lt lu lv b">KGroupedStream</code>和<code class="fe ls lt lu lv b">KGroupedTable</code>。</p><p id="8d85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:<code class="fe ls lt lu lv b">KTable</code>分组没有在无状态操作博客中讨论。</p><h2 id="ee6f" class="ns mw iq bd mx nt nu dn nb nv nw dp nf lf nx ny nh lj nz oa nj ln ob oc nl od bi translated">总计</h2><p id="8693" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated"><code class="fe ls lt lu lv b">aggregate</code>功能有两个关键组件:<code class="fe ls lt lu lv b">Initializer</code>和<code class="fe ls lt lu lv b">Aggregator</code>。当接收到第一条记录时，调用<code class="fe ls lt lu lv b">Initializer</code>并将其用作<code class="fe ls lt lu lv b">Aggregator</code>的起点。对于随后的记录，<code class="fe ls lt lu lv b">Aggregator</code>使用当前记录和计算的合计(到目前为止)进行计算。从概念上讲，这是在无限数据集上执行的有状态计算。它是有状态的，因为计算当前状态时考虑了当前状态(键值记录)和最新状态(当前聚合)。这可用于移动平均、求和、计数等情况。</p><p id="003a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个如何计算计数的示例(即特定密钥被接收的次数)。GitHub 上的<a class="ae kv" href="https://github.com/abhirockzz/kafka-streams-apis/tree/master/stateful-ops" rel="noopener ugc nofollow" target="_blank">代码示例:</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="56ca" class="ns mw iq bd mx nt nu dn nb nv nw dp nf lf nx ny nh lj nz oa nj ln ob oc nl od bi translated">数数</h2><p id="4465" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated"><code class="fe ls lt lu lv b">count</code>是一种常用的聚合形式，以至于它被作为一流的操作来提供。一旦您通过键(<code class="fe ls lt lu lv b">KGroupedStream</code>)对流记录进行了分组，您就可以通过使用这个操作来计算特定键的记录数。</p><p id="69b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">做事情的<code class="fe ls lt lu lv b">aggregate</code>方式可以被一个单独的方法调用代替！</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="71bb" class="ns mw iq lv b gy ok ol l om on">StreamsBuilder builder = new StreamsBuilder();<br/>KStream&lt;String, String&gt; stream = builder.stream(INPUT_TOPIC);</span><span id="1269" class="ns mw iq lv b gy oo ol l om on">stream.groupByKey().count();</span></pre><h2 id="bd1d" class="ns mw iq bd mx nt nu dn nb nv nw dp nf lf nx ny nh lj nz oa nj ln ob oc nl od bi translated">减少</h2><p id="7808" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">您可以使用<code class="fe ls lt lu lv b">reduce</code>来组合值流。前面提到的<code class="fe ls lt lu lv b">aggregate</code>操作是<code class="fe ls lt lu lv b">reduce</code>的推广形式。可以实现<code class="fe ls lt lu lv b">sum</code>、<code class="fe ls lt lu lv b">min</code>、<code class="fe ls lt lu lv b">max</code>等功能。下面是一个<code class="fe ls lt lu lv b">max</code>的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="3d21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:所有的聚合操作都忽略带有<code class="fe ls lt lu lv b">null</code>键的记录，这是显而易见的，因为这些函数集的目标就是对特定键的记录进行操作。</p><h2 id="8940" class="ns mw iq bd mx nt nu dn nb nv nw dp nf lf nx ny nh lj nz oa nj ln ob oc nl od bi translated">聚合和状态存储</h2><p id="e4ba" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">在上面的例子中，聚合值被推送到输出主题。不过，这不是强制性的。可以将聚合结果存储在本地状态存储中。这里有一个例子:</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="f852" class="ns mw iq lv b gy ok ol l om on">StreamsBuilder builder = new StreamsBuilder();<br/>KStream&lt;String, String&gt; stream = builder.stream(INPUT_TOPIC);</span><span id="88b3" class="ns mw iq lv b gy oo ol l om on">stream.groupByKey().count(Materialized.as("count-store"));</span></pre><p id="68f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，对<code class="fe ls lt lu lv b">count</code>的调用还创建了一个名为<code class="fe ls lt lu lv b">count-store</code>的本地状态存储，然后可以使用交互式查询对其进行自省。</p><p id="122a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些状态存储可以在内存中，也可以使用<code class="fe ls lt lu lv b">RocksDB</code>存储在磁盘上。这考虑到了<code class="fe ls lt lu lv b">scalability</code>,因为每个状态存储都本地存在于特定的Kafka Streams应用程序中，该应用程序处理来自主题的不同分区的输入。因此，整体状态分布在(潜在的)应用程序的多个实例中(除了<code class="fe ls lt lu lv b">GlobalKTables</code>的情况)。另一个关键属性是<code class="fe ls lt lu lv b">high availability</code>，因为这些状态存储的内容被备份到Kafka中作为<code class="fe ls lt lu lv b">changelog</code>或<code class="fe ls lt lu lv b">compacted</code>主题(尽管这可以被禁用)，这提供了高可用性。如果一个应用程序实例崩溃，它的状态存储内容可以从Kafka本身恢复。</p><h2 id="c951" class="ns mw iq bd mx nt nu dn nb nv nw dp nf lf nx ny nh lj nz oa nj ln ob oc nl od bi translated"><code class="fe ls lt lu lv b">KGroupedTable</code></h2><p id="5378" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">当在一个<code class="fe ls lt lu lv b">KTable</code>上调用<code class="fe ls lt lu lv b">groupBy</code> *操作时，获得一个<code class="fe ls lt lu lv b">KGroupedTable</code>。就像<code class="fe ls lt lu lv b">KGroupedStream</code>一样，拥有一个<code class="fe ls lt lu lv b">KGroupedTable</code>是在一个<code class="fe ls lt lu lv b">KTable</code>上应用聚合的先决条件。<code class="fe ls lt lu lv b">aggregate</code>、<code class="fe ls lt lu lv b">count</code>和<code class="fe ls lt lu lv b">reduce</code>在<code class="fe ls lt lu lv b">KGroupedTable</code>中的工作方式与它们在<code class="fe ls lt lu lv b">KGroupedStream</code>中的工作方式相同。</p><p id="2839" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是有一个重要的区别需要强调。从概念上来说，<code class="fe ls lt lu lv b">KTable</code>与<code class="fe ls lt lu lv b">KStream</code>不同，因为它表示某个时间点的数据快照(非常像数据库表)。它是一个可变实体，与代表不可变+无限记录序列的<code class="fe ls lt lu lv b">KStream</code>相反。为了考虑这种差异，<code class="fe ls lt lu lv b">KGroupedTable</code>中的<code class="fe ls lt lu lv b">aggregate</code>和<code class="fe ls lt lu lv b">reduce</code>函数还添加了一个额外的<code class="fe ls lt lu lv b">Aggregator</code>(通常称为减法器)，当更新一个键或获得一个<code class="fe ls lt lu lv b">null</code>值时会调用该函数。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="cbc9" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">开窗术</h1><p id="70d9" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">有状态的Kafka流操作也支持<code class="fe ls lt lu lv b">Windowing</code>。这允许您将流处理管道的范围限定在特定的时间窗口/范围内(例如，跟踪每分钟的链接点击量或每小时的唯一页面浏览量)。</p><p id="0959" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要对一组记录执行<code class="fe ls lt lu lv b">Windowed</code>聚合，您必须创建一个<code class="fe ls lt lu lv b">KGroupedStream</code>(如上所述)，在<code class="fe ls lt lu lv b">KStream</code>上使用<code class="fe ls lt lu lv b">groupBy</code>，然后使用<code class="fe ls lt lu lv b">windowedBy</code>操作(有两种重载形式)。您可以在传统窗口(翻滚、跳跃或滑动)或基于会话的时间窗口之间进行选择。</p><p id="e67b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在一个<code class="fe ls lt lu lv b">KGroupedStream</code>上使用<code class="fe ls lt lu lv b">windowedBy(Windows&lt;W&gt; windows)</code>会返回一个<code class="fe ls lt lu lv b">TimeWindowedKStream</code>，在此基础上您可以调用上述聚合操作。例如，如果您想要特定时间范围(比如五分钟)内的点击次数，请选择滚动时间窗口。这将确保记录在给定的时间范围内清楚地分开。换句话说，来自用户1的从上午10:05到10:05的点击将被单独聚集(计数),并且新的时间段(窗口)从上午10:06开始，在此期间点击计数器被重置为零并再次计数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="30cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其他窗口类型包括:</p><ul class=""><li id="1c25" class="op oq iq ky b kz la lc ld lf or lj os ln ot lr ou ov ow ox bi translated"><code class="fe ls lt lu lv b">Tumbling</code>从不重叠的时间窗口。一条记录只能是一个窗口的一部分。</li><li id="0c84" class="op oq iq ky b kz oy lc oz lf pa lj pb ln pc lr ou ov ow ox bi translated"><code class="fe ls lt lu lv b">Hopping</code>时间窗口，其中记录可以出现在一个或多个时间范围/窗口中。</li><li id="e798" class="op oq iq ky b kz oy lc oz lf pa lj pb ln pc lr ou ov ow ox bi translated"><code class="fe ls lt lu lv b">Sliding</code>时间窗口用于<code class="fe ls lt lu lv b">Joining</code>操作。</li></ul><p id="1964" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有另一种叫做<code class="fe ls lt lu lv b">Joining</code>的有状态操作。这是一个广泛的主题，本身就值得写一整篇文章(或者另一个系列)。</p><p id="bde0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想考虑“会话”(由定义的非活动间隙分隔的活动周期)，请使用<code class="fe ls lt lu lv b">windowedBy(SessionWindows windows)</code>，它返回一个<code class="fe ls lt lu lv b">SessionWindowedKStream</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="ce6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kafka Streams博客系列的这一部分到此结束。请继续关注下一部分，它将演示如何使用内置的测试工具来测试Kafka Streams应用程序。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="86f6" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">参考</h1><p id="c6ba" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">请不要忘记查看以下卡夫卡流资源</p><ul class=""><li id="30cf" class="op oq iq ky b kz la lc ld lf or lj os ln ot lr ou ov ow ox bi translated"><a class="ae kv" href="https://kafka.apache.org/documentation/streams/" rel="noopener ugc nofollow" target="_blank">卡夫卡文献</a></li><li id="41e0" class="op oq iq ky b kz oy lc oz lf pa lj pb ln pc lr ou ov ow ox bi translated"><a class="ae kv" href="https://kafka.apache.org/24/javadoc/index.html?org/apache/kafka/streams/" rel="noopener ugc nofollow" target="_blank">卡夫卡流Javadocs </a></li></ul></div></div>    
</body>
</html>