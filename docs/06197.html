<html>
<head>
<title>3 Years of Kubernetes in Production–Here’s What We Learned</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3年的Kubernetes生产——以下是我们学到的东西</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-years-of-kubernetes-in-production-heres-what-we-learned-44e77e1749c8?source=collection_archive---------0-----------------------#2020-09-09">https://betterprogramming.pub/3-years-of-kubernetes-in-production-heres-what-we-learned-44e77e1749c8?source=collection_archive---------0-----------------------#2020-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1e69" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从我们的Kubernetes期刊中获得的关键信息</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/299c3f10fe0f52938d481c3d375c64d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XCCAVSiKLzPWDCLM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杰西卡·刘易斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="47ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在2017年开始构建我们的第一个Kubernetes集群，版本1.9.4。我们有两个集群，一个运行在裸机RHEL虚拟机上，另一个运行在AWS EC2上。</p><p id="428f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今，我们的Kubernetes基础架构设备群由分布在多个数据中心的400多台虚拟机组成。该平台托管高度可用的关键任务软件应用和系统，以管理拥有近400万台活动设备的大型实时网络。</p><p id="6061" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes最终让我们的生活变得更容易，但这是一个艰难的旅程，一个范式的转变。不仅仅是我们的技能和工具，还有我们的设计和思维都发生了彻底的转变。我们不得不采用多种新技术，并大规模投资来升级和提高我们的团队和基础设施。</p><p id="430c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回顾过去，在生产中运行Kubernetes三年后，这里是我们的日志中的关键经验。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/digital-diplomacy/how-a-faulty-visa-system-is-killing-the-technology-market-adcd8588d880" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">一个有缺陷的签证系统是如何扼杀技术市场的</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">工作签证上的移民软件工程师的困境</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="80fe" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">1.Java应用程序的奇特案例</h1><p id="9976" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">当谈到微服务和容器化时，工程师们倾向于避免使用Java，主要是因为它臭名昭著的内存管理。然而，现在情况发生了变化，Java的容器兼容性在过去几年里有所提高。毕竟，像<code class="fe nr ns nt nu b">Apache Kafka</code>和<code class="fe nr ns nt nu b">Elasticsearch</code>这样无处不在的系统都运行在Java上。</p><p id="2620" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到2017-2018年，我们有几个运行在Java版本8上的应用程序。这些人通常很难理解像Docker这样的容器环境，并且因为堆内存问题和不寻常的垃圾收集趋势而崩溃。我们了解到这些都是由于JVM不能支持Linux <code class="fe nr ns nt nu b">cgroups</code>和<code class="fe nr ns nt nu b">namespaces</code>造成的，而Linux和T3是容器化技术的核心。</p><p id="cf7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，从那以后，Oracle一直在不断改进Java在容器领域的兼容性。甚至Java 8的后续补丁也引入了实验性的JVM标志来解决这些问题，<code class="fe nr ns nt nu b">XX:+UnlockExperimentalVMOptions</code>和<code class="fe nr ns nt nu b">XX:+UseCGroupMemoryLimitForHeap</code></p><p id="6ff7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，尽管有了所有的改进，不可否认的是，与Python或Go等同行相比，Java仍然有占用内存和启动时间慢的坏名声。它主要是由JVM的内存管理和类加载器引起的。</p><p id="0dbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，如果我们<em class="nv">有</em>选择Java，我们保证它是版本11或以上。我们的Kubernetes内存限制在JVM最大堆内存(<code class="fe nr ns nt nu b">-Xmx</code>)的基础上设置为1GB，用于预留空间。也就是说，如果JVM使用8GB的堆内存，我们的Kubernetes应用程序的资源限制将是9GB。有了它，生活变得更加美好。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/why-java-is-dying-b02b5fd44db9" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">为什么Java正在消亡</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">Java的未来会怎样？</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="nw l mj mk ml mh mm ks ly"/></div></div></a></div></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2ad5" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">2.Kubernetes生命周期升级</h1><p id="73a9" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Kubernetes的生命周期管理，比如升级或增强，非常麻烦，尤其是如果你已经在<a class="ae ky" href="https://platform9.com/blog/where-to-install-kubernetes-bare-metal-vs-vms-vs-cloud/" rel="noopener ugc nofollow" target="_blank">裸机或虚拟机</a>上构建了自己的集群。对于升级，我们认识到最简单的方法是使用最新版本构建新的集群，并将工作负载从旧的转移到新的。投入就地节点升级的努力和规划是不值得的。</p><p id="a9cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes有多个需要升级的移动部件。从Docker到CNI插件，如印花布或法兰绒，你需要仔细地把它们拼凑在一起才能工作。虽然像Kubespray、Kubeone、Kops和Kubeaws这样的项目使它变得更容易，但它们都有缺点。</p><p id="a720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在RHEL虚拟机上使用Kubespray构建了我们的集群。Kubespray很棒，它有构建、添加和删除新节点、升级版本的剧本，以及我们在生产中操作Kubernetes所需的几乎所有东西。但是，升级手册附带了一个免责声明，阻止我们跳过哪怕是很小的版本。因此，必须通过所有中间版本才能到达目标版本。</p><p id="e43b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要点是，如果您计划使用Kubernetes或者已经在使用，请考虑生命周期活动以及您的解决方案如何解决这个问题。构建和运行集群相对来说更容易，但是生命周期维护是一个全新的游戏，有多个移动部分。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="b11c" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">3.构建和部署</h1><p id="dd7c" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">准备好重新设计您的整个构建和部署管道。对于Kubernetes世界，我们的构建过程和部署必须经历一个完整的转变。不仅Jenkins pipelines进行了大量的重组，还使用了helm等新工具，制定了新的git流程和构建策略，标记了docker图像，并对Helm部署图进行了版本控制。</p><p id="3d26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将需要一个策略来维护不仅仅是代码，还有Kubernetes部署文件、Docker文件、Docker图像、舵图，并设计一种方法将它们链接在一起。</p><p id="ffba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过几次反复，我们决定采用以下设计。</p><ul class=""><li id="e7a5" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">应用程序代码和它的舵图驻留在单独的git存储库中。这使得我们可以分别对它们进行版本控制。(<a class="ae ky" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本化</a>)</li><li id="6ae9" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">然后，我们将图表版本与应用程序版本一起保存，并使用它来跟踪发布。所以比如<code class="fe nr ns nt nu b">app-1.2.0</code>和<code class="fe nr ns nt nu b">charts-1.1.0</code>一起部署。如果只有舵值文件改变，那么只有图表的补丁版本会改变。(例如从<code class="fe nr ns nt nu b">1.1.0</code>到<code class="fe nr ns nt nu b">1.1.1</code>)。所有这些版本都是由每个存储库中的发行说明规定的，<code class="fe nr ns nt nu b">RELEASE.txt</code>。</li><li id="3b56" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">像Apache Kafka或Redis这样的系统应用程序的代码不是我们构建或修改的，它们的工作方式不同。也就是说，我们没有两个git存储库，因为Docker标签只是Helm chart版本控制的一部分。如果我们为了升级而更改了docker标签，我们会在图表的标签中增加主要版本。</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="4105" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">4.活跃性和就绪性调查(双刃剑)</h1><p id="1e9d" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Kubernetes的活跃性和就绪性探测是自主解决系统问题的优秀特性。它们可以在出现故障时重启容器，并转移不健康实例的流量。但是在某些故障条件下，这些探测可能成为一把双刃剑，影响应用程序的启动和恢复，特别是像消息传递平台或数据库这样的有状态应用程序。</p><p id="3196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的卡夫卡体系就是这种情况的受害者。我们用一个<code class="fe nr ns nt nu b">replicationFactor of 3 </code>和一个<code class="fe nr ns nt nu b">minInSyncReplica of 2.</code>运行了一个<code class="fe nr ns nt nu b">3 Broker 3 Zookeeper</code>状态集。当Kafka在意外的系统故障或崩溃后启动时，就会出现这个问题。这导致它在启动时运行额外的脚本来修复损坏的索引，根据严重性，这需要10到30分钟。由于这一额外的时间，活动性探针将不断失败，向Kafka发出终止信号以重新启动。这阻止了卡夫卡去修正指数，一起开始。</p><p id="74e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的解决方案是在活动性探测器设置中配置<code class="fe nr ns nt nu b"><strong class="lb iu">initialDelaySeconds</strong></code>，以在容器启动后延迟探测器评估。但问题是，当然，这很难确定。有些恢复甚至需要一个小时，我们需要提供足够的空间来解决这个问题。但是你越增加<code class="fe nr ns nt nu b"><strong class="lb iu">initialDelaySeconds</strong></code>，你的恢复能力就越慢，因为在启动失败时，Kubernetes需要更长的时间来重新启动你的容器。</p><p id="5cfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，折中的办法是评估<code class="fe nr ns nt nu b"><strong class="lb iu">initialDelaySeconds</strong></code>字段的值，以便它更好地平衡您在Kubernetes中寻求的弹性和应用程序在所有故障条件下(磁盘故障、网络故障、系统崩溃等)成功启动所需的时间。)</p><blockquote class="ol om on"><p id="ce85" class="kz la nv lb b lc ld ju le lf lg jx lh oo lj lk ll op ln lo lp oq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">更新</em> </strong> <em class="it">:如果您使用的是最近几个最新版本，</em> <a class="ae ky" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/" rel="noopener ugc nofollow" target="_blank"> <em class="it"> Kubernetes引入了第三种探针类型，称为“启动探针”，来解决这个问题</em> </a> <em class="it">。从</em> <code class="fe nr ns nt nu b"><em class="it">alpha from 1.16 </em></code> <em class="it">到</em> <code class="fe nr ns nt nu b"><em class="it">beta from 1.18</em></code> <em class="it">都有。</em></p><p id="b487" class="kz la nv lb b lc ld ju le lf lg jx lh oo lj lk ll op ln lo lp oq lr ls lt lu im bi translated"><em class="it">启动探测器禁用就绪性和活动性检查，直到容器启动，确保应用程序的启动不被中断。</em></p></blockquote></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2028" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">5.暴露外部IP</h1><p id="7abc" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们了解到，使用静态外部IP公开服务会对内核的连接跟踪机制产生巨大的影响。除非计划周密，否则它会大规模崩溃。</p><p id="4e36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的集群运行在<code class="fe nr ns nt nu b">Calico for CNI </code>和<code class="fe nr ns nt nu b">BGP</code>上，作为我们在Kubernetes内部的路由协议，并与边缘路由器对等。对于Kubeproxy，我们使用<code class="fe nr ns nt nu b">IP Tables</code>模式。我们在通过外部IP公开的Kubernetes中托管大量服务，每天处理数百万个连接。由于来自软件定义网络的所有SNAT和伪装，Kubernetes需要一种机制来跟踪所有这些逻辑流。为了实现这一点，它使用内核的<code class="fe nr ns nt nu b">Conntrack and netfilter</code>工具来管理这些到静态IP的外部连接，静态IP然后转换为内部服务IP，再转换为您的pod IP。这都是通过<code class="fe nr ns nt nu b">conntrack</code>表和IP表完成的。</p><p id="2d71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这张表有其局限性。一旦达到极限，您的Kubernetes集群(底层的操作系统内核)将不再能够接受新的连接。在RHEL，你可以这样检查。</p><pre class="kj kk kl km gt or nu os ot aw ou bi"><span id="edaf" class="ov mv it nu b gy ow ox l oy oz">$  sysctl net.netfilter.nf_conntrack_count net.netfilter.nf_conntrack_maxnet.netfilter.nf_conntrack_count = 167012<br/>net.netfilter.nf_conntrack_max = 262144</span></pre><p id="c2d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决这一问题的一些方法是使用边缘路由器对等多个节点，这样到静态IP的传入连接就会分散到整个集群。因此，如果您的集群有一大群机器，累积起来，您可能有一个大的<code class="fe nr ns nt nu b">conntrack</code>表来处理大量的传入连接。</p><p id="70c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在2017年开始时，这完全让我们感到困惑，但最近，Calico在2019年发表了一项关于这一点的详细研究，题为“<a class="ae ky" href="https://www.projectcalico.org/when-linux-conntrack-is-no-longer-your-friend/" rel="noopener ugc nofollow" target="_blank">为什么conntrack不再是你的朋友</a>”</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ly"><a href="https://medium.com/better-programming/4-simple-kubernetes-terminal-customizations-to-boost-your-productivity-deda60a19924" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">4个简单的Kubernetes终端定制来提高您的生产力</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">这是我在生产中用于管理大规模Kubernetes集群的工具</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="pa l mj mk ml mh mm ks ly"/></div></div></a></div><h1 id="7408" class="mu mv it bd mw mx pb mz na nb pc nd ne jz pd ka ng kc pe kd ni kf pf kg nk nl bi translated">你真的需要Kubernetes吗？</h1><p id="89f6" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">三年过去了，我们仍然每天都在发现和学习新的东西。这是一个复杂的平台，有其自身的一系列挑战，特别是构建和维护环境的开销。它将改变你的设计、思维和架构，并要求你的团队提升技能和规模以适应这种转变。</p><p id="60f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果你在云上，并且能够使用Kubernetes作为“服务”，它可以减轻你的大部分平台维护开销，比如“我如何扩展我的内部网络CIDR？”或者“我如何升级我的Kubernetes版本？”</p><p id="a5fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们意识到你需要问自己的第一个问题是“你绝对需要Kubernetes吗？”这有助于评估你的问题，以及Kubernetes解决问题的重要程度。</p><p id="1b47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes转型并不便宜。您为它支付的价格必须真正证明“您的”用例以及它如何利用平台。如果是这样，那么Kubernetes可以极大地提高你的生产力。</p><blockquote class="pg"><p id="a3b5" class="ph pi it bd pj pk pl pm pn po pp lu dk translated">记住，为了技术而技术是没有意义的。</p></blockquote></div></div>    
</body>
</html>