<html>
<head>
<title>Flutter Battery App Made With Klutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Klutter制作的Flutter电池应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/flutter-battery-app-made-with-klutter-74d47002efb1?source=collection_archive---------2-----------------------#2022-07-02">https://betterprogramming.pub/flutter-battery-app-made-with-klutter-74d47002efb1?source=collection_archive---------2-----------------------#2022-07-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="59f8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建你的第一个Klutter插件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7873b5e7d1fc30e669a45a6904c2f32e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GILRAqkAHH84405l"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/es/@mroz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">菲利普·姆罗兹</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5fea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">差不多7个月和500次提交之后，一个新的里程碑到来了:Klutter现在可以在<a class="ae kv" href="https://pub.dev/packages/klutter" rel="noopener ugc nofollow" target="_blank"> pub.dev </a>上下载了！有什么比做一个小演示更好的方式来庆祝一个里程碑呢？</p><p id="1a5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们带着Klutter试驾一下，重做一下Flutter电池app。<strong class="ky ir">注:</strong>本教程最新版本见<a class="ae kv" href="https://buijs.dev/klutter-2/" rel="noopener ugc nofollow" target="_blank"> buijs.dev </a>原文。</p><p id="f5a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你已经熟悉了方法通道和在Flutter中使用特定于平台的代码，那么跳过这一节，直接从有趣的东西开始:<a class="ae kv" href="https://buijs.dev/klutter-2/#Step%201:%20Create%20a%20Klutter%20project" rel="noopener ugc nofollow" target="_blank">教程</a>。</p><p id="a3d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你还没有跳过它，那么我建议你看一下在<a class="ae kv" href="https://docs.flutter.dev/development/platform-integration/platform-channels" rel="noopener ugc nofollow" target="_blank">文档</a>中的章节<em class="ls">例子:使用平台通道调用特定平台的iOS和Android代码</em>。</p><p id="c57e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，Flutter团队使用一个示例应用程序battery app来演示如何使用方法通道在iOS和Android上调用特定于平台的代码。这个过程包括在Flutter端编写Dart代码，在Android上编写Java/Kotlin代码，在iOS上编写Swift代码，然后将它们粘合在一起。在进入下一个教程之前，有这些知识作为背景是很好的。</p><h1 id="67c2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">步骤1:创建一个Klutter项目</h1><p id="c403" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">首先创建一个新应用程序:</p><ul class=""><li id="8e25" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">在终端运行中:<code class="fe mz na nb nc b">flutter create –org com.example –template=plugin –platforms=android,ios batterylevel</code>。<strong class="ky ir">注意:</strong>可能看不到，但使用双破折号'-'。</li><li id="5bdc" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">将Klutter框架作为依赖项安装:</li><li id="d0a4" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">将克鲁特:^0.1.3添加到你的<code class="fe mz na nb nc b">pubspec.yaml</code>依赖块中。</li><li id="82cb" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">在终端运行:<code class="fe mz na nb nc b">flutter pub get</code></li><li id="be5d" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">在终端运行中:<code class="fe mz na nb nc b">flutter pub run klutter:producer init</code></li></ul><p id="90a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Klutter现在已经在插件项目中初始化了。让我们回顾一下Klutter所做的改变。以下Gradle文件应该添加到插件项目的根文件夹中:</p><ul class=""><li id="0c2a" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe mz na nb nc b">settings.gradle.kts</code></li><li id="54a1" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><code class="fe mz na nb nc b">build.gradle.kts</code></li><li id="e363" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><code class="fe mz na nb nc b">gradlew</code></li><li id="0d9f" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><code class="fe mz na nb nc b">gradlew.bat</code></li><li id="37d7" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><code class="fe mz na nb nc b">gradle.wrapper/gradle-wrapper.jar</code></li><li id="8e56" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><code class="fe mz na nb nc b">gradle.wrapper/gradle-wrapper.properties</code></li></ul><p id="0267" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建Kotlin多平台模块(我们将在几分钟内完成)需要这些文件。最有趣的是build.gradle.kts文件。我想在此强调几个要点。</p><p id="213a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先是dependencies块，它向JVM类路径添加了一些库:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="91f8" class="nm lu iq nc b gy nn no l np nq">dependencies {<br/>    classpath("org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.10")<br/>    classpath("com.android.tools.build:gradle:7.0.4")<br/>    classpath("dev.buijs.klutter:core:2022.r6-7.alpha")<br/>    classpath("dev.buijs.klutter.gradle:dev.buijs.klutter.gradle.gradle.plugin:2022.r6-7.alpha")<br/>}</span></pre><p id="83f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通俗地说，这意味着这些库在平台模块中是可用的。因此，在这里我们看到我们的项目Kotlin多平台模块将与:</p><ul class=""><li id="7324" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">科特林版本1.6.10</li><li id="8f05" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">Android Gradle版本7.0.4</li><li id="7b0d" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">Klutter核心版本2022 . R6–7 . alpha</li><li id="e9c7" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">Klutter Gradle版本2022 . R6–7 . alpha</li></ul><p id="a33e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想了解更多关于Klutter Gradle插件的信息，请阅读这里。</p><p id="63e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，在repositories块中，添加buijs-dev maven存储库以下载Klutter库:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="b73b" class="nm lu iq nc b gy nn no l np nq">maven { url = uri("https://repsy.io/mvn/buijs-dev/klutter") }</span></pre><p id="d88d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，有几个注册的Klutter任务将用于构建我们的插件:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="2612" class="nm lu iq nc b gy nn no l np nq">tasks.register("klutterInstallPlatform", Exec::class) {<br/>    commandLine("bash", "./gradlew", "clean", "build", "-p", "platform")<br/>    finalizedBy("klutterCopyAarFile", "klutterCopyFramework")<br/>}</span><span id="075e" class="nm lu iq nc b gy nr no l np nq">tasks.register("klutterCopyAarFile", Copy::class) {<br/>    from("platform/build/outputs/aar/batterylevel-release.aar")<br/>    into("android/klutter")<br/>    rename { fileName -&gt;<br/>        fileName.replace("batterylevel-release", "platform")<br/>    }<br/>}</span><span id="25da" class="nm lu iq nc b gy nr no l np nq">tasks.register("klutterCopyFramework", Copy::class) {<br/>    from("platform/build/fat-framework/release")<br/>    into("ios/Klutter")<br/>}</span></pre><h1 id="5971" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">步骤2:编写特定于平台的代码</h1><p id="e8d7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">转到根文件夹中的平台模块。src文件夹应该包含一个<code class="fe mz na nb nc b">androidMain</code>、<code class="fe mz na nb nc b">commonMain</code>和<code class="fe mz na nb nc b">iosMain</code>文件夹。这些文件夹中有一些示例代码。继续删除它们:</p><ul class=""><li id="b3af" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe mz na nb nc b">androidMain/Platform.kt</code></li><li id="813a" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><code class="fe mz na nb nc b">commonMain/Greeting.kt</code></li><li id="74e1" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><code class="fe mz na nb nc b">commonMain/Platform.kt</code></li><li id="f091" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><code class="fe mz na nb nc b">iosMain/Platform.kt</code></li></ul><p id="a9d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mz na nb nc b">commonMain</code>中创建一个名为BatteryLevel的新文件。增加以下内容:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="9b2a" class="nm lu iq nc b gy nn no l np nq">package com.example.batterylevel.platform</span><span id="e733" class="nm lu iq nc b gy nr no l np nq">expect class BatteryLevel(context: Any?) {<br/>  val level: Float?<br/>}</span></pre><p id="5d28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个类是我们的平台接口。我们有一个<code class="fe mz na nb nc b">BatteryLevel</code>类，它的构造函数需要一个对象，这个对象可以是任何类型，也可以是null。所以基本上可能有也可能没有一个物体，如果它在那里，它可能是任何东西。最后，我们有一个名为level的类成员，它可能会也可能不会返回浮点值。我们将很快看到为什么它是这样一个开放定义的契约。</p><p id="c4a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后请注意<code class="fe mz na nb nc b">expect</code>关键字。这个关键字是Kotlin多平台<a class="ae kv" href="https://kotlinlang.org/docs/multiplatform-connect-to-apis.html" rel="noopener ugc nofollow" target="_blank">特性</a>。这意味着对于这个类，在<code class="fe mz na nb nc b">androidMain</code>和<code class="fe mz na nb nc b">commonMain</code> <code class="fe mz na nb nc b">src</code>文件夹中应该有特定于平台的实现。让我们创造这些吧！</p><p id="4606" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mz na nb nc b">androidMain</code>中新建一个名为<code class="fe mz na nb nc b">BatteryLevel</code>的文件，并添加以下内容:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="89df" class="nm lu iq nc b gy nn no l np nq">package com.example.batterylevel.platform</span><span id="b34f" class="nm lu iq nc b gy nr no l np nq">import android.content.Context<br/>import android.os.BatteryManager</span><span id="5193" class="nm lu iq nc b gy nr no l np nq">actual class BatteryLevel actual constructor(context: Any?) {</span><span id="4054" class="nm lu iq nc b gy nr no l np nq">  actual val level: Float? = context?.let {<br/>    getBatteryLevel(context as Context).toFloat()<br/>  }</span><span id="69a9" class="nm lu iq nc b gy nr no l np nq">  private fun getBatteryLevel(context: Context): Int {<br/>    val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) as BatteryManager<br/>    return batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)<br/>  }</span><span id="4ca0" class="nm lu iq nc b gy nr no l np nq">}</span></pre><p id="ddf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mz na nb nc b">iosMain</code>中新建一个名为<code class="fe mz na nb nc b">BatteryLevel</code>的文件，并添加以下内容:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="c331" class="nm lu iq nc b gy nn no l np nq">package com.example.batterylevel.platform</span><span id="5ea4" class="nm lu iq nc b gy nr no l np nq">import platform.UIKit.UIDevice</span><span id="545d" class="nm lu iq nc b gy nr no l np nq">actual class BatteryLevel actual constructor(context: Any?) {</span><span id="72df" class="nm lu iq nc b gy nr no l np nq">  actual val level: Float? = UIDevice.currentDevice.batteryLevel.let {<br/>    if(it &lt; 0) null else it * 100<br/>  }</span><span id="da9e" class="nm lu iq nc b gy nr no l np nq">}</span></pre><p id="8063" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像<code class="fe mz na nb nc b">expect</code>关键字一样，<code class="fe mz na nb nc b">actual</code>也是一个Kotlin多平台特性。</p><p id="29e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">iosMain</code>和<code class="fe mz na nb nc b">androidMain</code>中的<code class="fe mz na nb nc b">actual</code>类是我们在<code class="fe mz na nb nc b">commonMain</code>类中定义的接口的实现。</p><p id="b007" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只需这几行代码，我们就可以在Android和iOS上调用特定于平台的代码！</p><p id="a29e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注</strong>:如果iOS设备禁用了电池监控，那么<code class="fe mz na nb nc b">batteryLevel</code>返回-1.0。为了本教程的简单，我们假设它是启用的，但对于一个生产应用程序，你必须考虑这一点。</p><p id="5750" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在需要做的就是定义一个将被Flutter调用的服务。在<code class="fe mz na nb nc b">commonMain</code>中添加一个名为<code class="fe mz na nb nc b">Platform</code>的新文件。添加以下代码:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="8b4e" class="nm lu iq nc b gy nn no l np nq">package com.example.batterylevel.platform</span><span id="3fac" class="nm lu iq nc b gy nr no l np nq">import dev.buijs.klutter.annotations.kmp.*</span><span id="874f" class="nm lu iq nc b gy nr no l np nq">class Platform {</span><span id="dd74" class="nm lu iq nc b gy nr no l np nq">  @AndroidContext<br/>  @KlutterAdaptee(name = "getBatteryLevel")<br/>  fun getBatteryLevel(context: Any): Double? {<br/>    return BatteryLevel(context).level?.toDouble()<br/>  }</span><span id="221f" class="nm lu iq nc b gy nr no l np nq">}</span></pre><p id="eed4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里发生了一些事情。我们创建了一个<code class="fe mz na nb nc b">BatteryLevel</code>的实例，它是我们在<code class="fe mz na nb nc b">commonMain</code>中定义的接口。在运行时，这要么是我们在Android设备上的<code class="fe mz na nb nc b">androidMain</code>中定义的<code class="fe mz na nb nc b">BatteryLevel</code>实现的实例，要么是iOS设备上的<code class="fe mz na nb nc b">iosMain</code>实现的实例。</p><p id="826a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还看到2个注释:<code class="fe mz na nb nc b">@AndroidContext</code>和<code class="fe mz na nb nc b">@KlutterAdaptee(name = “getBatteryLevel”)</code>。<code class="fe mz na nb nc b">KlutterAdaptee</code>告诉Klutter为该方法生成方法通道代码，并将其添加到Flutter库文件中。<code class="fe mz na nb nc b">AndroidContext</code>是一个可选的注释，告诉Klutter在从Android调用这个方法时传入一个(Android)上下文的实例。</p><p id="ba8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将Float转换为Double值，因为Klutter还不支持Float值。</p><h1 id="2aa3" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">步骤3:构建Flutter库</h1><ul class=""><li id="7a94" class="mq mr iq ky b kz ml lc mm lf ns lj nt ln nu lr mv mw mx my bi translated">在根文件夹中打开一个终端，运行:<code class="fe mz na nb nc b">flutter pub run klutter:producer install=platform</code></li><li id="f45c" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">在终端运行:<code class="fe mz na nb nc b">flutter pub run klutter:producer install=library</code></li></ul><p id="8096" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些命令执行以下步骤:</p><ul class=""><li id="4705" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">为iOS(框架)和Android (aar)构建工件。</li><li id="b54a" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">在lib中生成dart文件。</li><li id="7783" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">在<code class="fe mz na nb nc b">root/android</code>中生成方法-通道代码。</li><li id="5f87" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">在<code class="fe mz na nb nc b">root/ios</code>中生成方法-通道代码。</li></ul><p id="a83d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的图书馆现在可以使用了。我们很快就会这样做，但首先，为了好玩和笑声，让我们看看Klutter为我们创造了什么。</p><p id="3920" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开root/lib文件夹，应该有一个名为<code class="fe mz na nb nc b">batterylevel.dart</code>的文件。该文件应包含以下内容:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="0f3f" class="nm lu iq nc b gy nn no l np nq">import 'dart:async';</span><span id="6e87" class="nm lu iq nc b gy nr no l np nq">import 'package:flutter/services.dart';<br/>import 'package:flutter/widgets.dart';<br/>import 'package:klutter/klutter.dart';</span><span id="3fd5" class="nm lu iq nc b gy nr no l np nq">/// Autogenerated by Klutter Framework.<br/>///<br/>/// Do net edit directly, but recommended to store in VCS.<br/>///<br/>/// Adapter class which handles communication with the KMP library.<br/>class Batterylevel {<br/>  static const MethodChannel _channel =<br/>  MethodChannel('com.example.batterylevel');</span><span id="fd67" class="nm lu iq nc b gy nr no l np nq">  static Future&lt;AdapterResponse&lt;double&gt;&gt; getBatteryLevel(<br/>    State caller, {<br/>      void Function(double)? onSuccess,<br/>      void Function(Exception)? onFailure,<br/>      void Function()? onNullValue,<br/>      void Function(AdapterResponse&lt;double&gt;)? onComplete,<br/>    }) async {<br/>    try {<br/>      final json = await _channel.invokeMethod('getBatteryLevel');<br/>      final value = json?.toDouble();<br/>      final AdapterResponse&lt;double&gt; response = AdapterResponse.success(value);</span><span id="ff93" class="nm lu iq nc b gy nr no l np nq">      if (caller.mounted) {<br/>        onComplete?.call(response);<br/>        if (value == null) {<br/>          onNullValue?.call();<br/>        } else {<br/>          onSuccess?.call(value!);<br/>        }<br/>      }</span><span id="ab95" class="nm lu iq nc b gy nr no l np nq">      return response;<br/>    } catch (e) {<br/>      final exception = e is Error ? Exception(e.stackTrace) : e as Exception;</span><span id="470d" class="nm lu iq nc b gy nr no l np nq">      final AdapterResponse&lt;double&gt; response =<br/>      AdapterResponse.failure(exception);</span><span id="c1f3" class="nm lu iq nc b gy nr no l np nq">      if (caller.mounted) {<br/>        onComplete?.call(response);<br/>        onFailure?.call(exception);<br/>      }</span><span id="1e8b" class="nm lu iq nc b gy nr no l np nq">      return response;<br/>    }<br/>  }<br/>}</span></pre><p id="b937" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个Dart类是我们将从Flutter应用程序中使用的接口。我们看到创建了一个名为<code class="fe mz na nb nc b">com.example.batterylevel</code>的方法通道。</p><p id="f63b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是Flutter应用程序将用来与平台通信的通道。有一种方法叫做<code class="fe mz na nb nc b">getBatteryLevel</code>。这个名字来源于我们之前使用的<code class="fe mz na nb nc b">@KlutterAdaptee</code>注释。</p><h1 id="830c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">步骤4:测试库</h1><p id="b250" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在这一步，我们将添加一个非常基本的UI来验证插件的工作方式。Flutter方便地自动生成一个依赖于我们插件的示例Flutter应用程序。打开<code class="fe mz na nb nc b">root/example</code>文件夹中的<code class="fe mz na nb nc b">pubspec.yaml</code>，添加一个对Klutter的依赖。像往常一样，在添加一个依赖项后运行flutter pub get。</p><p id="4b2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在终端运行中:</p><ul class=""><li id="743b" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe mz na nb nc b">flutter pub run klutter:consumer init</code></li><li id="1393" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><code class="fe mz na nb nc b">flutter pub run klutter:consumer add=batterylevel</code></li></ul><p id="113b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mz na nb nc b">example/lib</code>文件夹中的<code class="fe mz na nb nc b">main.dart</code>文件。您将看到<code class="fe mz na nb nc b">batterylevel</code>包已经被导入，并且有一些基本的UI代码。然而，这将不再工作，因为我们改变了我们的库代码。继续删除除了<code class="fe mz na nb nc b">initState</code>方法之外的<code class="fe mz na nb nc b">_MyAppState</code>类中的所有内容:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="e691" class="nm lu iq nc b gy nn no l np nq">class _MyAppState extends State&lt;MyApp&gt; {</span><span id="4c89" class="nm lu iq nc b gy nr no l np nq">  @override<br/>  void initState() {<br/>    super.initState();<br/>  }</span><span id="0296" class="nm lu iq nc b gy nr no l np nq">}</span></pre><p id="1257" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加用户界面代码:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="e54c" class="nm lu iq nc b gy nn no l np nq">class _MyAppState extends State&lt;MyApp&gt; {</span><span id="4d40" class="nm lu iq nc b gy nr no l np nq">  @override<br/>  void initState() {<br/>    super.initState();<br/>  }</span><span id="c65b" class="nm lu iq nc b gy nr no l np nq">  @override<br/>  Widget build(BuildContext context) {<br/>    return MaterialApp(<br/>      home: Scaffold(<br/>        appBar: AppBar(<br/>          title: const Text('BatteryLevel Example'),<br/>        ),<br/>        body: Center(<br/>          child: Column(<br/>            mainAxisAlignment: MainAxisAlignment.spaceEvenly,<br/>            children: [<br/>              ElevatedButton(<br/>                child: const Text('Get Battery Level'),<br/>                onPressed: _getBatteryLevel,<br/>              ),<br/>              Text(_batteryLevel),<br/>            ],<br/>          ),<br/>        ),<br/>      ),<br/>    );<br/>  }<br/>  <br/>}</span></pre><p id="523e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经有了视图，剩下的就是调用我们的<code class="fe mz na nb nc b">Batterylevel</code>库了。为此，添加一个字符串变量来保存<code class="fe mz na nb nc b">batterylevel</code>状态:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="ee9a" class="nm lu iq nc b gy nn no l np nq">String _batteryLevel = '...';</span></pre><p id="48a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，添加<code class="fe mz na nb nc b">getBatteryLevel</code>方法:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="e7a6" class="nm lu iq nc b gy nn no l np nq">Future&lt;void&gt; _getBatteryLevel() async {<br/>  await Batterylevel.getBatteryLevel(this,<br/>    onSuccess: (level) =&gt; setState(() {<br/>      _batteryLevel = "Battery level at $level%.";<br/>    }),<br/>    onFailure: (exception) =&gt; setState(() {<br/>      _batteryLevel = "Failed to get battery level: $exception.";<br/>    }),<br/>    onNullValue: () =&gt; setState(() {<br/>      _batteryLevel = "Unknown battery level.";<br/>    }),<br/>  );<br/>}</span></pre><p id="125f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意不需要try-catch块来捕捉<code class="fe mz na nb nc b">PlatformExceptions</code>。这都是由自动生成的Klutter代码处理的。<code class="fe mz na nb nc b">BatteryLevel</code>库总是会返回一个响应。</p><p id="7146" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们定义了几个回调函数，它们将根据平台调用给出的响应来运行。通过将对当前小部件的引用添加到方法调用(this ),我们使该方法能够检查小部件是否仍然被挂载。这样做是为了避免万一小部件已经被丢弃时调用<code class="fe mz na nb nc b">setState</code>。</p><p id="b40c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">概括一下，这是我们最后的Flutter UI:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="d497" class="nm lu iq nc b gy nn no l np nq">import 'package:flutter/material.dart';<br/>import 'dart:async';</span><span id="a5cf" class="nm lu iq nc b gy nr no l np nq">import 'package:batterylevel/batterylevel.dart';</span><span id="c07a" class="nm lu iq nc b gy nr no l np nq">void main() {<br/>  runApp(const MyApp());<br/>}</span><span id="0480" class="nm lu iq nc b gy nr no l np nq">class MyApp extends StatefulWidget {<br/>  const MyApp({Key? key}) : super(key: key);</span><span id="4cba" class="nm lu iq nc b gy nr no l np nq">  @override<br/>  State&lt;MyApp&gt; createState() =&gt; _MyAppState();<br/>}</span><span id="6c17" class="nm lu iq nc b gy nr no l np nq">class _MyAppState extends State&lt;MyApp&gt; {</span><span id="a41b" class="nm lu iq nc b gy nr no l np nq">  @override<br/>  void initState() {<br/>    super.initState();<br/>  }</span><span id="dc25" class="nm lu iq nc b gy nr no l np nq">  String _batteryLevel = '...';</span><span id="d755" class="nm lu iq nc b gy nr no l np nq">  Future&lt;void&gt; _getBatteryLevel() async {<br/>    await Batterylevel.getBatteryLevel(this,<br/>      onSuccess: (level) =&gt; setState(() {<br/>        _batteryLevel = "Battery level at $level%.";<br/>      }),<br/>      onFailure: (exception) =&gt; setState(() {<br/>        _batteryLevel = "Failed to get battery level: $exception.";<br/>      }),<br/>      onNullValue: () =&gt; setState(() {<br/>        _batteryLevel = "Unknown battery level.";<br/>      }),<br/>    );<br/>  }</span><span id="6454" class="nm lu iq nc b gy nr no l np nq">  @override<br/>  Widget build(BuildContext context) {<br/>    return MaterialApp(<br/>      home: Scaffold(<br/>        appBar: AppBar(<br/>          title: const Text('BatteryLevel Example'),<br/>        ),<br/>        body: Center(<br/>          child: Column(<br/>            mainAxisAlignment: MainAxisAlignment.spaceEvenly,<br/>            children: [<br/>              ElevatedButton(<br/>                child: const Text('Get Battery Level'),<br/>                onPressed: _getBatteryLevel,<br/>              ),<br/>              Text(_batteryLevel),<br/>            ],<br/>          ),<br/>        ),<br/>      ),<br/>    );<br/>  }</span><span id="3b8f" class="nm lu iq nc b gy nr no l np nq">}</span></pre><p id="20ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开一个Android模拟器，运行应用程序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/60980798977707b44557b73d3f5e9df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/0*P1Yy9EdwvotH0iCo.png"/></div></figure><p id="3d62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">按下按钮应该会显示当前的电池电量:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/91d40e531fcd029915ca8e6fe97a1681.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/0*lZgrNMRt1ct_zAak.png"/></div></figure><p id="23a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，在iOS模拟器中进行同样的操作，如果iOS设备上的电池监控被禁用(很可能是),您应该会看到以下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/62c8edc19bd1b9254882bdecabef1abd.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/0*NA0v5Me0Tl2WkP6E.png"/></div></figure><p id="2e0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅此而已。祝贺你的第一个Klutter插件！</p><p id="9d3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Klutter能做的还很多，比如基于平台包中的Kotlin代码在Dart中生成完整的DTO类。参见Klutter Gradle <a class="ae kv" href="https://github.com/buijs-dev/klutter" rel="noopener ugc nofollow" target="_blank">文档</a>中的示例。</p></div></div>    
</body>
</html>