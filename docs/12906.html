<html>
<head>
<title>Monads for Go Programmers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋程序员的单子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/monads-for-go-programmers-6cda2b978cb1?source=collection_archive---------3-----------------------#2022-07-11">https://betterprogramming.pub/monads-for-go-programmers-6cda2b978cb1?source=collection_archive---------3-----------------------#2022-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b7aa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/8c061b0333d36f0fab6c8a0038c7c64f.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/0*43Djm3LnABmrW5fl"/></div></figure><p id="4e50" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">单子是关于函数组合和隐藏它的乏味部分。</p><p id="0bc5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">做了7年的Go程序员后，输入<code class="fe lj lk ll lm b">if err != nil</code>会变得相当乏味。每次我输入<code class="fe lj lk ll lm b">if err != nil</code>的时候，我都会感谢地鼠为我提供了一种可读性很强的语言和很棒的工具，但同时我也会诅咒他们让我觉得自己是被拘留的巴特·辛普森。</p><p id="74eb" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><a class="ae ln" href="https://anvaka.github.io/common-words/#?lang=go" rel="noopener ugc nofollow" target="_blank">我怀疑我不是唯一的一个</a>，但是</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="84a9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">单子不仅仅用于隐藏一些错误处理，还可以用于列表理解和并发，这里仅举几个例子。</p><p id="a746" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">不要读这个</p><p id="fee6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在埃里克·梅耶尔关于Edx 的<a class="ae ln" href="https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0" rel="noopener ugc nofollow" target="_blank">函数式编程课程介绍中，他要求我们不要再写关于<code class="fe lj lk ll lm b">monads</code>的文章，因为已经有很多了。</a></p><p id="3f80" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我推荐你去看巴托兹·米莱斯基关于范畴理论的视频，它的高潮是一个视频，这是我见过的对单子的最好解释，而不是读这篇文章。</p><p id="7116" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在停止阅读！</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="7b6b" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">函子</h1><p id="7806" class="pw-post-body-paragraph kn ko iq kp b kq mp jr ks kt mq ju kv kw mr ky kz la ms lc ld le mt lg lh li ij bi translated">好吧，好吧…唉…记住我警告过你。</p><p id="4d62" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我解释<code class="fe lj lk ll lm b">monads</code>之前，我首先需要解释一下<code class="fe lj lk ll lm b">functors</code>。A <code class="fe lj lk ll lm b">functor</code>是a <code class="fe lj lk ll lm b">monad</code>的超类，这意味着所有的<code class="fe lj lk ll lm b">monads</code>也是<code class="fe lj lk ll lm b">functors</code>。我在解释<code class="fe lj lk ll lm b">monads</code>的时候会用到<code class="fe lj lk ll lm b">functors</code>，所以请不要粉饰这一节。</p><p id="8560" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们可以把一个<code class="fe lj lk ll lm b">functor</code>看作一个容器，它包含一种类型的项目。</p><p id="c4a1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">例子包括:</p><ul class=""><li id="7d0f" class="mu mv iq kp b kq kr kt ku kw mw la mx le my li mz na nb nc bi translated">包含T: <code class="fe lj lk ll lm b">[]T</code>类型项目的片是一个容器，其中的项目被排序到一个列表中。</li><li id="da79" class="mu mv iq kp b kq nd kt ne kw nf la ng le nh li mz na nb nc bi translated">树:<code class="fe lj lk ll lm b">type Node[T any] struct { Value T; Children []Node[T] }</code>是一个容器，它的项目被构造成一棵树；</li><li id="0dcb" class="mu mv iq kp b kq nd kt ne kw nf la ng le nh li mz na nb nc bi translated">一个通道:<code class="fe lj lk ll lm b">&lt;-chan T</code>是一个容器，像一个装水的管子；</li><li id="2064" class="mu mv iq kp b kq nd kt ne kw nf la ng le nh li mz na nb nc bi translated">指针:<code class="fe lj lk ll lm b">*T</code>是一个容器，可以是空的，也可以包含一个项目；</li><li id="5326" class="mu mv iq kp b kq nd kt ne kw nf la ng le nh li mz na nb nc bi translated">一个函数:<code class="fe lj lk ll lm b">func(A) T</code>是一个容器，就像一个锁箱，首先需要一把钥匙，才能看到物品；</li><li id="e254" class="mu mv iq kp b kq nd kt ne kw nf la ng le nh li mz na nb nc bi translated">多返回值:<code class="fe lj lk ll lm b">func() (T, error)</code>是一个可能包含一个项目的容器。我们可以将错误视为容器的一部分。从这里开始，我们将把<code class="fe lj lk ll lm b">(T, error)</code>称为一个元组。</li></ul><blockquote class="ni nj nk"><p id="07d7" class="kn ko nl kp b kq kr jr ks kt ku ju kv nm kx ky kz nn lb lc ld no lf lg lh li ij bi translated">非Go程序员:Go没有代数数据类型或联合类型。这意味着不是函数返回值<code class="fe lj lk ll lm b"><em class="iq">or</em></code>错误，而是程序员返回值<code class="fe lj lk ll lm b"><em class="iq">and</em></code>错误，其中一个通常为零。有时我们打破惯例，返回一个值和一个错误，但两者都不为零，只是为了混淆彼此。哦，我们玩得很开心。</p><p id="c084" class="kn ko nl kp b kq kr jr ks kt ku ju kv nm kx ky kz nn lb lc ld no lf lg lh li ij bi translated">在Go中拥有联合类型最流行的方法是拥有一个接口(抽象类)，然后在接口类型上拥有一个类型开关(一种非常简单的模式匹配形式)。</p></blockquote><p id="0496" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">容器成为<code class="fe lj lk ll lm b">functor</code>的另一个要求是，我们需要为该容器类型实现<code class="fe lj lk ll lm b">fmap</code>函数。<code class="fe lj lk ll lm b">fmap</code>函数将函数应用于容器中的每一项，而不会以任何方式修改容器或结构。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="a4e7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">你可能从Hadoop的MapReduce、Python、Ruby或你能想到的几乎任何其他语言中认出了一个经典的例子，那就是slice的<code class="fe lj lk ll lm b">map</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="6672" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们也可以为一棵树实现<code class="fe lj lk ll lm b">fmap</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="749e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">或者一个频道:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="ff94" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">或者一个指针:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="d4cc" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">或者一个函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="27b3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">或者返回错误的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="e769" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">所有这些容器及其各自的<code class="fe lj lk ll lm b">fmap</code>实现都是<code class="fe lj lk ll lm b">functors</code>的例子。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="74f3" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">功能组成</h1><p id="eedd" class="pw-post-body-paragraph kn ko iq kp b kq mp jr ks kt mq ju kv kw mr ky kz la ms lc ld le mt lg lh li ij bi translated">既然我们知道a <code class="fe lj lk ll lm b">functor</code>只是:</p><ul class=""><li id="c7f8" class="mu mv iq kp b kq kr kt ku kw mw la mx le my li mz na nb nc bi translated">容器的抽象名称，并且</li><li id="5b80" class="mu mv iq kp b kq nd kt ne kw nf la ng le nh li mz na nb nc bi translated">我们可以对容器中的物品应用一个函数</li></ul><p id="8964" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">，我们可以得到整个要点:a的抽象概念<code class="fe lj lk ll lm b">monad</code>。</p><p id="d660" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">A <code class="fe lj lk ll lm b">monad</code>简单来说就是点缀型的。嗯……好吧，这无助于解释，太抽象了。这是试图解释什么是<code class="fe lj lk ll lm b">monad</code>的典型问题。这就像试图解释什么是“副作用”,这太宽泛了。让我来解释一下抽象a <code class="fe lj lk ll lm b">monad</code>的原因。原因是要编写返回这些修饰类型的函数。</p><p id="c921" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">先说朴素的函数构成，没有修饰的类型。在本例中，我们想要组合两个函数<code class="fe lj lk ll lm b">f</code>和<code class="fe lj lk ll lm b">g</code>，并返回一个函数，该函数接受<code class="fe lj lk ll lm b">f</code>所期望的输入，并返回来自<code class="fe lj lk ll lm b">g</code>的输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="00d2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">显然，只有当<code class="fe lj lk ll lm b">f</code>的输出类型与<code class="fe lj lk ll lm b">g</code>的输入类型匹配时，这才会起作用。另一个版本是编写返回错误的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="413a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在我们可以尝试将这个错误抽象为一个修饰<code class="fe lj lk ll lm b">M</code>,看看我们还剩下什么:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="1479" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们必须返回一个将<code class="fe lj lk ll lm b">A</code>作为输入参数的函数，所以我们从声明返回函数开始。现在我们有了一个<code class="fe lj lk ll lm b">A</code>，我们可以调用<code class="fe lj lk ll lm b">f</code>并得到一个类型为<code class="fe lj lk ll lm b">M[B]</code>的值<code class="fe lj lk ll lm b">mb</code>，但是现在呢？</p><p id="26e4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们做得不够，因为它太抽象了。我的意思是现在我们有了<code class="fe lj lk ll lm b">mb</code>，我们该做什么？当我们知道这是一个错误时，我们可以检查它，但是现在它被抽象掉了，我们就不能检查了。但是…如果我们知道我们的修饰<code class="fe lj lk ll lm b">M</code>也是一个<code class="fe lj lk ll lm b">functor</code>，那么我们可以<code class="fe lj lk ll lm b">fmap</code>超过<code class="fe lj lk ll lm b">M</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="3a8f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们想要对<code class="fe lj lk ll lm b">fmap</code>使用的函数<code class="fe lj lk ll lm b">g</code>不像<code class="fe lj lk ll lm b">C</code>那样返回简单类型，而是返回<code class="fe lj lk ll lm b">M[C]</code>。幸运的是这对<code class="fe lj lk ll lm b">fmap</code>来说不是问题，但是它稍微改变了类型签名:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="dedf" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">所以现在我们有了一个类型为<code class="fe lj lk ll lm b">M[M[C]]</code>的值<code class="fe lj lk ll lm b">mmc</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="3784" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们需要一种从<code class="fe lj lk ll lm b">M[M[C]]</code>到<code class="fe lj lk ll lm b">M[C]</code>的方法。</p><p id="0a67" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们需要我们的修饰<code class="fe lj lk ll lm b">M</code>不仅仅是一个<code class="fe lj lk ll lm b">functor</code>，还要有另一个属性。这个额外的属性是一个名为<code class="fe lj lk ll lm b">join</code>的函数，为每个<code class="fe lj lk ll lm b">monad</code>定义，就像为每个<code class="fe lj lk ll lm b">functor</code>定义<code class="fe lj lk ll lm b">fmap</code>一样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="6f0e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定join，我们现在可以写:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="fd8d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这意味着如果修饰定义了<code class="fe lj lk ll lm b">fmap</code>和<code class="fe lj lk ll lm b">join</code>，我们可以组合两个返回修饰类型的函数。换句话说，对于要成为<code class="fe lj lk ll lm b">monad</code>的类型，需要为它定义这两个函数。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="b3d9" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">加入</h1><p id="9b63" class="pw-post-body-paragraph kn ko iq kp b kq mp jr ks kt mq ju kv kw mr ky kz la ms lc ld le mt lg lh li ij bi translated">单子是<code class="fe lj lk ll lm b">functors</code>，我们不需要再为它们定义<code class="fe lj lk ll lm b">fmap</code>。我们只需要定义一下<code class="fe lj lk ll lm b">join</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="b086" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们现在将定义<code class="fe lj lk ll lm b">join</code>为:</p><ul class=""><li id="c902" class="mu mv iq kp b kq kr kt ku kw mw la mx le my li mz na nb nc bi translated">列表，这将导致列表理解，</li><li id="beff" class="mu mv iq kp b kq nd kt ne kw nf la ng le nh li mz na nb nc bi translated">错误，这将导致一元错误处理和</li><li id="3664" class="mu mv iq kp b kq nd kt ne kw nf la ng le nh li mz na nb nc bi translated">通道，这将产生一个并发管道。</li></ul><h2 id="8705" class="np ly iq bd lz nq nr dn md ns nt dp mh kw nu nv mj la nw nx ml le ny nz mn oa bi translated">列出理解</h2><p id="3748" class="pw-post-body-paragraph kn ko iq kp b kq mp jr ks kt mq ju kv kw mr ky kz la ms lc ld le mt lg lh li ij bi translated">在切片上连接是最简单的，也可能是最容易开始的。<code class="fe lj lk ll lm b">join</code>函数只是连接所有的切片。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="a13f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们看看为什么我们再次需要<code class="fe lj lk ll lm b">join</code>，但是这次特别关注切片。下面是我们的切片合成函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="c072" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果我们将<code class="fe lj lk ll lm b">a</code>传递给<code class="fe lj lk ll lm b">f</code>，我们将得到类型为<code class="fe lj lk ll lm b">[]B</code>的<code class="fe lj lk ll lm b">bs</code>。</p><p id="c46e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们现在可以用<code class="fe lj lk ll lm b">g</code>覆盖<code class="fe lj lk ll lm b">fmap</code>，这将给我们一个类型为<code class="fe lj lk ll lm b">[][]C</code>而不是<code class="fe lj lk ll lm b">[]C</code>的值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="5ee7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这就是为什么我们需要<code class="fe lj lk ll lm b">join</code>。我们需要从<code class="fe lj lk ll lm b">css</code>到<code class="fe lj lk ll lm b">cs</code>或者从<code class="fe lj lk ll lm b">[][]C</code>到<code class="fe lj lk ll lm b">[]C</code>。</p><p id="2a23" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们来看一个更具体的例子:</p><p id="c99c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果我们替换我们的类型:</p><ul class=""><li id="2eaa" class="mu mv iq kp b kq kr kt ku kw mw la mx le my li mz na nb nc bi translated"><code class="fe lj lk ll lm b">A</code>为<code class="fe lj lk ll lm b">int</code>型，</li><li id="1346" class="mu mv iq kp b kq nd kt ne kw nf la ng le nh li mz na nb nc bi translated"><code class="fe lj lk ll lm b">B</code>为类型<code class="fe lj lk ll lm b">int64</code>和</li><li id="2395" class="mu mv iq kp b kq nd kt ne kw nf la ng le nh li mz na nb nc bi translated"><code class="fe lj lk ll lm b">C</code>为<code class="fe lj lk ll lm b">string</code>型。</li></ul><p id="3e12" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">那么我们的功能就变成了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="b82e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在我们可以在一个例子中使用它们:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="3ff0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这让我们第一次有了切片<code class="fe lj lk ll lm b">monad</code>。</p><p id="9225" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有趣的是，这正是列表理解在Haskell中的工作方式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="ac0e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是您可能会从Python中更好地识别它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><h2 id="c8c7" class="np ly iq bd lz nq nr dn md ns nt dp mh kw nu nv mj la nw nx ml le ny nz mn oa bi translated">一元错误处理</h2><p id="10da" class="pw-post-body-paragraph kn ko iq kp b kq mp jr ks kt mq ju kv kw mr ky kz la ms lc ld le mt lg lh li ij bi translated">我们也可以在返回一个值和一个错误的函数上定义<code class="fe lj lk ll lm b">join</code>。为此，我们首先需要再次回到<code class="fe lj lk ll lm b">fmap</code>函数，因为Go中有一些特质。</p><p id="2dc7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是我们的<code class="fe lj lk ll lm b">fmap</code>函数，它返回一个值和一个错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="e169" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们知道我们的compose函数将使用函数<code class="fe lj lk ll lm b">f</code>调用<code class="fe lj lk ll lm b">fmap</code>，该函数也返回一个错误。这将导致我们的<code class="fe lj lk ll lm b">fmap</code>签名看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="295d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">不幸的是元组在围棋中不是一等公民，所以我们不能写:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="a88d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有几种方法可以解决这个问题。我更喜欢使用函数，因为返回元组的函数仍然是一等公民:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="dfdd" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在我们可以为返回一个值和一个错误的函数定义我们的<code class="fe lj lk ll lm b">fmap</code>,使用我们的工作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="ea32" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这让我们回到了我们的要点，我们在<code class="fe lj lk ll lm b">(func() (C, error), error)</code>上的<code class="fe lj lk ll lm b">join</code>函数。它非常简单，只是为我们做了一个错误检查。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="86be" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们现在可以使用我们的compose函数，因为我们已经定义了<code class="fe lj lk ll lm b">join</code>和<code class="fe lj lk ll lm b">fmap</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="ff82" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这导致我们必须做更少的错误检查，因为<code class="fe lj lk ll lm b">monad</code>使用<code class="fe lj lk ll lm b">join</code>函数在后台为我们做了这些。</p><p id="eaf3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是另一个<a class="ae ln" href="https://speakerdeck.com/rebeccaskinner/monadic-error-handling-in-go?slide=77" rel="noopener ugc nofollow" target="_blank">例子</a>，我感觉像巴特·辛普森:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="2f2e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">从技术上讲,<code class="fe lj lk ll lm b">compose</code>可以接受两个以上的函数作为参数。这意味着我们可以在一次调用中将上述所有函数链接在一起，并重写上面的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="bc5b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">还有许多其他的<code class="fe lj lk ll lm b">monads</code>。想出任何两个返回相同修饰类型的函数，并且您想要组合它们。再来做一个例子。</p><h2 id="7aa6" class="np ly iq bd lz nq nr dn md ns nt dp mh kw nu nv mj la nw nx ml le ny nz mn oa bi translated">并行管道</h2><p id="ccf2" class="pw-post-body-paragraph kn ko iq kp b kq mp jr ks kt mq ju kv kw mr ky kz la ms lc ld le mt lg lh li ij bi translated">我们也可以在通道上定义<code class="fe lj lk ll lm b">join</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="2af0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这里我们有一个通道<code class="fe lj lk ll lm b">in</code>，它将为我们提供更多类型<code class="fe lj lk ll lm b">T</code>的通道。我们首先创建<code class="fe lj lk ll lm b">out</code>通道，启动一个go例程，这个例程将被用来为它提供信息，然后返回它。在go例程中，我们为从<code class="fe lj lk ll lm b">in</code>读取的每个通道启动一个新的go例程。这些go例程将它们的输入事件发送到<code class="fe lj lk ll lm b">out</code>，将多个输入合并成一个流。最后，我们使用一个等待组来确保一旦接收到所有输入就关闭<code class="fe lj lk ll lm b">out</code>通道。</p><p id="9625" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">简而言之，我们正在从<code class="fe lj lk ll lm b">in</code>读取所有<code class="fe lj lk ll lm b">T</code>并将它们全部推送到<code class="fe lj lk ll lm b">out</code>通道。</p><blockquote class="ni nj nk"><p id="5f46" class="kn ko nl kp b kq kr jr ks kt ku ju kv nm kx ky kz nn lb lc ld no lf lg lh li ij bi translated">非go程序员:我必须将<code class="fe lj lk ll lm b">c</code>作为参数传递给内部Go例程，因为<code class="fe lj lk ll lm b">c</code>是一个单一变量，它接受通道中每个元素的值。这意味着，如果我们只是在闭包内使用它，而不是通过将它作为参数传递来创建值的副本，我们可能只会从最新的通道中读取。这是围棋程序员常犯的错误。</p></blockquote><p id="45fc" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这意味着我们可以在返回通道的函数上定义一个组合函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="f7dc" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">由于<code class="fe lj lk ll lm b">join</code>的实现方式，我们几乎可以免费获得并发。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="b60a" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">戈德里夫</h1><p id="4a10" class="pw-post-body-paragraph kn ko iq kp b kq mp jr ks kt mq ju kv kw mr ky kz la ms lc ld le mt lg lh li ij bi translated">如果你想使用这些工具，你可以在Go right中使用泛型或者用<a class="ae ln" href="https://github.com/awalterschulze/goderive" rel="noopener ugc nofollow" target="_blank"> goderive </a>生成代码，这允许你一次编写两个以上的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob lp l"/></div></figure><h1 id="85ad" class="lx ly iq bd lz ma oc mc md me od mg mh jw oe jx mj jz of ka ml kc og kd mn mo bi translated">少挥手</h1><p id="b4b5" class="pw-post-body-paragraph kn ko iq kp b kq mp jr ks kt mq ju kv kw mr ky kz la ms lc ld le mt lg lh li ij bi translated">这是对<code class="fe lj lk ll lm b">monads</code>的一个非常粗略的解释，为了让事情更简单，我故意省略了很多东西，但是还有一件事我想讲一下。</p><p id="501e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">从技术上讲，我们在上一节中定义的构造函数被称为<code class="fe lj lk ll lm b">Kleisli Arrow</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="6a47" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当人们谈论<code class="fe lj lk ll lm b">monads</code>时，他们很少提到<code class="fe lj lk ll lm b">Kleisli Arrow</code>，这是我理解<code class="fe lj lk ll lm b">monads</code>的关键。如果你运气好，他们会用<code class="fe lj lk ll lm b">fmap</code>和<code class="fe lj lk ll lm b">join</code>来解释，但是如果你运气不好，像我一样，他们会用bind函数来解释。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="8850" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为什么？</p><p id="e8f1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因为<code class="fe lj lk ll lm b">bind</code>是Haskell中的函数，如果你想让它被认为是<code class="fe lj lk ll lm b">Monad</code>的话，你需要为你的类型实现它。</p><p id="98cb" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们在这里重复一下compose函数的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="d7e5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果实现了<code class="fe lj lk ll lm b">bind</code>函数，那么我们可以简单地调用它，而不是<code class="fe lj lk ll lm b">fmap</code>和<code class="fe lj lk ll lm b">join</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="13ed" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">也就是说<code class="fe lj lk ll lm b">bind(mb, g)</code> = <code class="fe lj lk ll lm b">join(fmap(g, mb))</code>。</p><p id="687c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">根据语言的不同，列表的<code class="fe lj lk ll lm b">bind</code>功能可能是<code class="fe lj lk ll lm b">concatMap</code>或<code class="fe lj lk ll lm b">flatMap</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><h2 id="1b25" class="np ly iq bd lz nq nr dn md ns nt dp mh kw nu nv mj la nw nx ml le ny nz mn oa bi translated">斜视</h2><p id="766b" class="pw-post-body-paragraph kn ko iq kp b kq mp jr ks kt mq ju kv kw mr ky kz la ms lc ld le mt lg lh li ij bi translated">我发现Go开始模糊我在<code class="fe lj lk ll lm b">bind</code>和<code class="fe lj lk ll lm b">Kleisli Arrow</code>之间的界限。Go返回元组中的错误，但元组不是一等公民。例如，这段代码将无法编译，因为您无法以内嵌的方式将<code class="fe lj lk ll lm b">f</code>的结果传递给<code class="fe lj lk ll lm b">g</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="d135" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">你必须把它写出来:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="b974" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">或者你必须让<code class="fe lj lk ll lm b">g</code>接受一个函数作为输入，因为函数是一等公民。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="7286" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但这意味着我们的绑定函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="3c8b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">错误定义如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="ce2f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">使用起来并不有趣，除非我们将元组压缩成一个函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="c2a1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果我们眯着眼睛看，我们可以看到我们返回的元组也是一个函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="4f25" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果我们再眯着眼睛看，我们可以看到这是我们的合成函数，其中<code class="fe lj lk ll lm b">f</code>只接受零个参数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="f371" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">哒哒，我们有我们的<code class="fe lj lk ll lm b">Kleisli Arrow</code>，只要眯几眼。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="6c80" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">结论</h1><p id="a476" class="pw-post-body-paragraph kn ko iq kp b kq mp jr ks kt mq ju kv kw mr ky kz la ms lc ld le mt lg lh li ij bi translated">单子抽象掉了一些用修饰类型构成函数的重复逻辑，这样你就不会觉得自己像是被拘留的巴特·辛普森，而是像是在滑板上的巴特·辛普森，在轮到他击球的时候投球。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="oi oj di ok bf ol"><div class="gh gi oh"><img src="../Images/6274689cf6572cb2ea4679cdceba2fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FpoPS8gXscftbIMA.jpg"/></div></div></figure><p id="3699" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果你想在Go中尝试<code class="fe lj lk ll lm b">monads</code>和其他函数式编程概念，那么你可以使用我的代码生成器<a class="ae ln" href="https://www.youtube.com/watch?v=qFYByoGFIUE" rel="noopener ugc nofollow" target="_blank"> GoDerive </a>来实现。</p><blockquote class="ni nj nk"><p id="21b9" class="kn ko nl kp b kq kr jr ks kt ku ju kv nm kx ky kz nn lb lc ld no lf lg lh li ij bi translated">警告:函数式编程的关键概念之一是不变性。这不仅使程序更容易推理，而且允许编译器优化。为了模拟这种不变性，在Go中，你将倾向于复制大量的结构，这将导致非最优的性能。函数式编程语言能够避免这种情况的原因正是因为它们可以依赖于不变性，并且总是指向旧的值，而不是再次复制它们。</p><p id="f279" class="kn ko nl kp b kq kr jr ks kt ku ju kv nm kx ky kz nn lb lc ld no lf lg lh li ij bi translated">如果真的想过渡到函数式编程，我会推荐<a class="ae ln" href="http://elm-lang.org/" rel="noopener ugc nofollow" target="_blank"> Elm </a>。它是一种用于前端的静态类型的函数式编程语言。学习函数式语言就像学习命令式语言一样简单。我在一天内完成了这个<a class="ae ln" href="https://guide.elm-lang.org/" rel="noopener ugc nofollow" target="_blank">指南</a>,当天晚上我就能够开始高效工作了。造物主特意通过消除理解单子的需要，使学习语言变得容易。我个人发现<code class="fe lj lk ll lm b">Elm</code>在前端与Go在后端结合使用非常有趣。如果你开始对Go和Elm感到厌烦，不要担心还有很多东西要学，Haskell在等着你。</p></blockquote><h1 id="42c7" class="lx ly iq bd lz ma oc mc md me od mg mh jw oe jx mj jz of ka ml kc og kd mn mo bi translated">谢谢你</h1><ul class=""><li id="b957" class="mu mv iq kp b kq mp kt mq kw om la on le oo li mz na nb nc bi translated"><a class="ae ln" href="https://jbrandhorst.com/" rel="noopener ugc nofollow" target="_blank"> Johan Brandhorst </a>负责校对，并督促我写博客。</li><li id="f9e3" class="mu mv iq kp b kq nd kt ne kw nf la ng le nh li mz na nb nc bi translated"><a class="ae ln" href="https://github.com/uroboros" rel="noopener ugc nofollow" target="_blank"> Ryan Lemmer </a>负责校对和“副作用”一行。</li><li id="a3a0" class="mu mv iq kp b kq nd kt ne kw nf la ng le nh li mz na nb nc bi translated"><a class="ae ln" href="https://www.linkedin.com/in/anton-hendriks-1b549514/" rel="noopener ugc nofollow" target="_blank">安东·亨德里克斯</a>校对和许多简化。</li><li id="defd" class="mu mv iq kp b kq nd kt ne kw nf la ng le nh li mz na nb nc bi translated"><a class="ae ln" href="http://www.cs.sun.ac.za/~abvdm/" rel="noopener ugc nofollow" target="_blank"> Brink van der Merwe </a>校对。</li></ul><h1 id="95a8" class="lx ly iq bd lz ma oc mc md me od mg mh jw oe jx mj jz of ka ml kc og kd mn mo bi translated">引用的</h1><ul class=""><li id="d88e" class="mu mv iq kp b kq mp kt mq kw om la on le oo li mz na nb nc bi translated"><a class="ae ln" href="https://golangweekly.com/issues/179" rel="noopener ugc nofollow" target="_blank">戈朗周刊</a></li><li id="a0db" class="mu mv iq kp b kq nd kt ne kw nf la ng le nh li mz na nb nc bi translated"><a class="ae ln" href="https://github.com/awalterschulze/blog/raw/main/waltercv/topofrhaskell.png" rel="noopener ugc nofollow" target="_blank">顶部</a>的<a class="ae ln" href="https://www.reddit.com/r/haskell/comments/73afpz/monads_for_go_programmers/" rel="noopener ugc nofollow" target="_blank">r/哈斯克尔</a></li></ul></div></div>    
</body>
</html>