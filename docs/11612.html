<html>
<head>
<title>5 New Hooks in React 18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 18中的5个新挂钩</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-new-hooks-in-react-18-300aa713cefe?source=collection_archive---------1-----------------------#2022-04-04">https://betterprogramming.pub/5-new-hooks-in-react-18-300aa713cefe?source=collection_archive---------1-----------------------#2022-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4777" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索useTransition、useDeferredValue、useId、useSyncExternalStore、useInsertionEffect和useEffect双重挂载</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/35f6f075d01dd91588309dfd549bc235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GR63wpJXUZ0B4bfw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@zane404?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">赞·李</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="bce3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/the-complete-guide-to-react-18-dd8763430345"> React 18于2022年3月29日上映</a>。它在版本中引入了5个新的挂钩:</p><ul class=""><li id="a3a6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">useTransition</code></li><li id="1b01" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">useDeferredValue</code></li><li id="eefc" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">useId</code></li><li id="8a0d" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">useSyncExternalStore</code></li><li id="a2f6" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">useInsertionEffect</code></li></ul><p id="4dc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将详细探讨这些挂钩。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c88b" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">在Create React应用程序中设置工作环境</h1><p id="d1a8" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们使用<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/an-in-depth-guide-for-create-react-app-5-cra-5-b94b03c233f2"> Create React App </a>作为基础来探索这些新的钩子。以下命令创建一个React项目:</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="00be" class="nv mv it mh b gy nw nx l ny nz">npx create-react-app react-release-18<br/>cd react-release-18</span></pre><p id="3f45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React版本自动指向React 18。目前，它仍然使用遗留的根API。如果您执行npm start，将会出现一条警告消息:</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="46e6" class="nv mv it mh b gy nw nx l ny nz">react-dom.development.js:86 Warning: ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: <a class="ae ky" href="https://reactjs.org/link/switch-to-createroot" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/link/switch-to-createroot</a></span></pre><p id="c910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新的根API由<code class="fe me mf mg mh b">createRoot</code>调用，它增加了React 18的所有改进，并支持并发特性。下面的<code class="fe me mf mg mh b">src/index.js</code>被修改为具有新的根API:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="1847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第2行从<code class="fe me mf mg mh b">'react-dom/client'</code>导入<code class="fe me mf mg mh b">createRoot</code>。</p><p id="b273" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第8行调用<code class="fe me mf mg mh b">createRoot</code>来生成<code class="fe me mf mg mh b">root</code>。</p><p id="869a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工作环境已经准备好让我们去探索了。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="7cfb" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">使用过渡</h1><p id="8d37" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe me mf mg mh b">useTransition()</code>是一个用于过渡的钩子。它返回转换状态和启动转换的函数。</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="369f" class="nv mv it mh b gy nw nx l ny nz">const [isPending, startTransition] = useTransition();</span></pre><p id="b6dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反应状态更新分为两类:</p><ul class=""><li id="2b03" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">紧急更新——它们反映了直接的交互，如打字、点击、按压、拖动等。</li><li id="2af9" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">转换更新—它们将用户界面从一个视图转换到另一个视图。</li></ul><p id="4573" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转换中的更新让位于更紧急的更新。这里有一个<code class="fe me mf mg mh b">useTransition</code>的例子，放在<code class="fe me mf mg mh b">src/App.js</code>里:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="d0d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的应用程序由两个组件组成(第25–32行):</p><ul class=""><li id="862f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">button</code>(第25行):这是一个简单的按钮。显示号码由第14行的<code class="fe me mf mg mh b">value</code>控制。点击按钮增加<code class="fe me mf mg mh b">value</code>(第19行，急快更新)<code class="fe me mf mg mh b">value2</code>(第20行，过渡慢更新)。</li><li id="a7c1" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">SlowUI</code>(第26–32行):组件在第3–11行定义，生成由第15行<code class="fe me mf mg mh b">value2</code>控制的<code class="fe me mf mg mh b">100000+</code> <code class="fe me mf mg mh b">span</code>元素。更新这么多元素需要更长的时间。第16行的<code class="fe me mf mg mh b">useTransition</code>返回转换状态<code class="fe me mf mg mh b">isPending</code>，以及启动转换的功能<code class="fe me mf mg mh b">startTransition</code>。当<code class="fe me mf mg mh b">startTransition</code>在第20行被调用时，<code class="fe me mf mg mh b">isPending</code>变成<code class="fe me mf mg mh b">true</code>，并且<code class="fe me mf mg mh b">SlowUI</code>半不透明(浅色)并带有陈旧数据(第28行)。当转换完成时，<code class="fe me mf mg mh b">isPending</code>变为<code class="fe me mf mg mh b">false</code>，并且<code class="fe me mf mg mh b">SlowUI</code>变为完全不透明(纯色),数据更新。</li></ul><p id="4335" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe me mf mg mh b">npm start</code>执行代码。下面的视频显示，UI增加了按钮数量，并且<code class="fe me mf mg mh b">SlowUI</code>变为半不透明，数据陈旧。经过一段时间后，<code class="fe me mf mg mh b">SlowUI</code>会因为更新的数据而变得不透明。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者提供的视频</p></figure><p id="e0a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试移除第20行的<code class="fe me mf mg mh b">startTransition</code>以直接调用<code class="fe me mf mg mh b">setValue2(value2 + 1)</code>。您可以看到，在这么多更新同时发生的情况下，UI不再起作用。</p><p id="07b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">useTransition</code>吊钩返回<code class="fe me mf mg mh b">isPending</code>和<code class="fe me mf mg mh b">startTransition</code>。如果您不需要显示<code class="fe me mf mg mh b">isPending</code>的特殊用户界面，请删除第16行，并在代码顶部添加以下行。</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="31fd" class="nv mv it mh b gy nw nx l ny nz">import { startTransition } from 'react';</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f791" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">useDeferredValue</h1><p id="f841" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe me mf mg mh b">useDeferredValue(value)</code>是一个钩子，它接受一个值并返回该值的一个新副本，该副本将服从更紧急的更新。在紧急更新完成之前，会保留先前的值。然后，呈现新值。这个钩子类似于<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/lodash-create-react-apps-built-in-library-for-debounce-and-throttle-with-hooks-3418087f44d8">使用去抖动或节流来延迟更新</a>。</p><p id="af36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个<code class="fe me mf mg mh b">useDeferredValue</code>的例子，放在<code class="fe me mf mg mh b">src/App.js</code>里:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="220d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的应用程序由三个组件组成(第23–27行):</p><ul class=""><li id="3145" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">(第23行):这是一个简单的按钮。显示号码由第14行的<code class="fe me mf mg mh b">value</code>控制。点击按钮增加<code class="fe me mf mg mh b">value</code>(第18行，加急快速更新)。</li><li id="8961" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">div</code>(第24行):显示<code class="fe me mf mg mh b">deferredValue</code>。</li><li id="d4c0" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">SlowUI</code>(第25–27行):组件在第3–11行定义，生成<code class="fe me mf mg mh b">50000</code>固定数量的<code class="fe me mf mg mh b">span</code>元素。虽然组件没有道具，视觉上也不更新，但是更新这么多元素需要很长时间。</li></ul><p id="ce8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe me mf mg mh b">npm start</code>执行代码。下面的视频显示，UI首先增加按钮数量，延迟值在一段时间后更新。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者提供的视频</p></figure><p id="dc76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">useDeferredValue</code>可与<code class="fe me mf mg mh b">startTransition</code>和<code class="fe me mf mg mh b">useTransition</code>配合使用。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="23d9" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">useId</h1><p id="408c" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在Web应用程序中，有些情况下需要唯一的id，例如:</p><ul class=""><li id="084c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">&lt;label for="ID"&gt;</code>，其中<code class="fe me mf mg mh b">for</code>属性必须等于相关元素的<code class="fe me mf mg mh b">id</code>属性，才能将它们绑定在一起。</li><li id="43cc" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">aria-labelledby</code>，其中<code class="fe me mf mg mh b">aria-labelledby</code>属性可以接受多个id。</li></ul><p id="2d27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">useId()</code>是一个生成唯一id的钩子:</p><ul class=""><li id="943b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">这个id在服务器和客户端都是稳定的，这避免了<a class="ae ky" href="https://javascript.plainenglish.io/a-hands-on-guide-for-a-server-side-rendering-react-app-dd1efa3ec0d8" rel="noopener ugc nofollow" target="_blank">服务器端渲染</a>的水合不匹配。</li><li id="eab4" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">这个id对于整个应用程序来说是唯一的。在多根应用程序的情况下，<code class="fe me mf mg mh b">createRoot</code> / <code class="fe me mf mg mh b">hydrateRoot</code>有一个可选的属性<code class="fe me mf mg mh b">identifierPrefix</code>，它可以用来添加一个前缀以防止冲突。</li><li id="b624" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">该id可以附加前缀和/或后缀，以生成在组件中使用的多个唯一id。看似琐碎。但是，<code class="fe me mf mg mh b">useId</code>是从<code class="fe me mf mg mh b">useOpaqueIdentifier</code>进化而来的，它会产生一个不透明的id，不能被操作。</li></ul><p id="9916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个<code class="fe me mf mg mh b">useId</code>的例子，放在<code class="fe me mf mg mh b">src/App.js</code>里:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="f618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的应用程序由三部分组成(第38–40行):</p><ul class=""><li id="6c13" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">Comp1</code>:在第3-6行定义，生成并显示一个id<code class="fe me mf mg mh b">:r0:</code>。</li><li id="89d0" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">Comp2</code>:在第8-23行定义，生成一个id，<code class="fe me mf mg mh b">:r1:</code>。从这个id中，它派生出两个唯一的id，<code class="fe me mf mg mh b">:r1:-1</code>(用于<code class="fe me mf mg mh b">Label 1</code> +输入字段)和<code class="fe me mf mg mh b">:r1:-2</code>(用于<code class="fe me mf mg mh b">Label 2</code> +输入字段)。</li><li id="b491" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">Comp3</code>:在第25–33行定义，生成并显示一个id<code class="fe me mf mg mh b">:r2:</code>。从他的一个id中，它为属性<code class="fe me mf mg mh b">aria-labelledby</code>派生出三个唯一的id<code class="fe me mf mg mh b">:r1:-a</code>、<code class="fe me mf mg mh b">:r1:-b</code>和<code class="fe me mf mg mh b">:r1:-c</code>。</li></ul><p id="b31d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe me mf mg mh b">npm start</code>执行代码。我们看到下面的UI，以及Chrome DevTools中生成的HTML元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/65738861c7fc73ab07be0f93025c948e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Auq01ps1FduujhpLzqILIw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="a2dd" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">useSyncExternalStore</h1><p id="9fdc" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe me mf mg mh b">useSyncExternalStore</code>是一个钩子，推荐用于从外部数据源(存储)读取和订阅。</p><p id="c71e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是钩子的签名:</p><pre class="kj kk kl km gt nr mh ns nt aw nu bi"><span id="95b4" class="nv mv it mh b gy nw nx l ny nz">const state = useSyncExternalStore(subscribe, getSnapshot[, getServerSnapshot]);</span></pre><p id="a6ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法接受三个参数:</p><ul class=""><li id="1967" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">subscribe</code>:这是一个注册回调的函数，只要商店发生变化就会调用这个函数。</li><li id="d783" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">getSnapshot</code>:返回商店当前值的函数。</li><li id="8e66" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">getServerSnapshot</code>:返回服务器渲染时使用的快照的函数。这是一个可选参数。</li></ul><p id="e2d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法返回商店的值，<code class="fe me mf mg mh b">state</code>。</p><p id="2ff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建一个<code class="fe me mf mg mh b">useSyncExternalStore</code>的例子，它读取当前的浏览器窗口宽度并显示在屏幕上。</p><p id="b34e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用以下代码替换现有的<code class="fe me mf mg mh b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="c561" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的应用程序调用<code class="fe me mf mg mh b">useSyncExternalStore</code>:</p><ul class=""><li id="1766" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">subscribe</code>(第5–10行):它为窗口<code class="fe me mf mg mh b">resize</code>事件监听器注册一个回调。</li><li id="71a8" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">getSnapshot</code>(第11行):返回当前浏览器窗口宽度。</li><li id="b240" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">getServerSnapshot</code>(第12行):是用于服务器渲染的，这里不需要，或者简单返回<code class="fe me mf mg mh b">-1</code>。</li></ul><p id="b842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe me mf mg mh b">npm start</code>执行代码。下面的视频显示了用户界面在调整大小时显示浏览器窗口的宽度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者提供的视频</p></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="8114" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">useInsertionEffect</h1><p id="6acf" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">接受包含命令性的、可能有效的代码的函数，这些代码是突变、订阅、定时器、日志和其他副作用。默认情况下，效果在每次完成渲染后运行，但是调用可以用数组的第二个参数来控制。</p><p id="2a47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">useLayoutEffect</code>与<code class="fe me mf mg mh b">useEffect</code>具有相同的签名，但是它在所有DOM突变后同步触发。即在<code class="fe me mf mg mh b">useEffect</code>之前启动。它用于从DOM中读取布局并同步重新渲染。在浏览器有机会画图之前，<code class="fe me mf mg mh b">useLayoutEffect</code>内部安排的更新将被同步刷新。</p><p id="f363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">useInsertionEffect</code>在React 18中引入。它与<code class="fe me mf mg mh b">useEffect</code>具有相同的签名，但是它在所有DOM突变之前同步触发。即它在<code class="fe me mf mg mh b">useLayoutEffect</code>之前被激发。它用于在读取布局之前将样式注入DOM。</p><p id="ce05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">useInsertionEffect</code>是针对CSS-in-JS库的，比如<code class="fe me mf mg mh b"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/build-advanced-react-input-fields-using-styled-components-and-storybook-js-a231b9b2438#e765-bf98276875df">styled-components</a></code>。由于这个钩子的作用域有限，所以它不能访问<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/most-things-you-want-to-know-about-react-refs-29901ebf28c6"> refs </a>，也不能调度更新。</p><p id="4e1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子放在<code class="fe me mf mg mh b">src/App.js</code>中，比较<code class="fe me mf mg mh b">useEffect</code>、<code class="fe me mf mg mh b">useLayoutEffect</code>和<code class="fe me mf mg mh b">useInsertionEffect</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="4af0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的应用程序有一个<code class="fe me mf mg mh b">App</code>(第15–31行)和一个<code class="fe me mf mg mh b">Child</code>组件(第3–13行)。两个都叫<code class="fe me mf mg mh b">useEffect</code>、<code class="fe me mf mg mh b">useLayoutEffect</code>、<code class="fe me mf mg mh b">useInsertionEffect</code>。</p><p id="88f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe me mf mg mh b">npm start</code>执行代码，我们会看到显示的文本和控制台输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/7719b2f92b2e59e53c0ad176413e2273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A6zybgKARMB38D-64jWKwA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a433" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些效果按以下顺序调用:</p><ul class=""><li id="ab18" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">useInsertionEffect</code>孩子叫。</li><li id="029f" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">useInsertionEffect</code> app叫。</li><li id="69b5" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">useLayoutEffect</code>孩子叫。</li><li id="d782" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">useLayoutEffect</code> app叫。</li><li id="0f0d" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">useEffect</code>子叫。</li><li id="18b4" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">useEffect</code> app叫。</li></ul><p id="6ea0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是预期的顺序。</p><p id="6435" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，为什么他们被叫两次？</p><p id="70e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着React 18的发布，<code class="fe me mf mg mh b">StrictMode</code>获得了一个称为严格效果模式的附加行为。当严格效果被启用时，React故意在开发模式中为新安装的组件<em class="og">双调用效果(<code class="fe me mf mg mh b">mount</code>-&gt;-<code class="fe me mf mg mh b">unmount</code>-&gt;-<code class="fe me mf mg mh b">mount</code>)。有趣的是，<code class="fe me mf mg mh b">useInsertionEffect</code>并不是叫两次。</em></p><p id="ebfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行<code class="fe me mf mg mh b">npm run build</code>和<code class="fe me mf mg mh b">serve -s build</code>。我们可以验证在<a class="ae ky" href="https://javascript.plainenglish.io/a-hands-on-guide-for-creating-a-production-ready-react-app-864ad98e7497" rel="noopener ugc nofollow" target="_blank"> <em class="og">生产模式</em> </a>下，这个app只挂载一次。</p><p id="564c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到开发模式。在<code class="fe me mf mg mh b">npm start</code>之后，将文本修改为<code class="fe me mf mg mh b">Random Text is changed</code>，并保存<code class="fe me mf mg mh b">src/App.js</code>。额外的控制台日志显示了这些效果是如何在更改时调用的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/48513f7058c6d2afec665018b4e395c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nA3bigRIbTrH7ZukSk-qMw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9622" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">useInsertionEffect</code>如果我们想让钩子在所有DOM突变之前触发，就使用这个钩子。然而，<code class="fe me mf mg mh b">useInsertionEffect</code>是为CSS-in-JS库设计的。对于普通的应用开发者来说，<code class="fe me mf mg mh b">useEffect</code>或者<code class="fe me mf mg mh b">useLayoutEffect</code>更常用。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f738" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="7be9" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们已经解释了React 18中的5个新钩子，并举例说明了它们的用法。</p><p id="692e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候让你尝试一下了吗？</p><p id="b293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。如果你有兴趣，可以看看我的其他媒体文章。</p></div></div>    
</body>
</html>