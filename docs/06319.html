<html>
<head>
<title>The Special Meaning of Underscores in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中下划线的特殊含义</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-special-meaning-of-underscores-in-python-9ceaaeb41007?source=collection_archive---------7-----------------------#2020-09-21">https://betterprogramming.pub/the-special-meaning-of-underscores-in-python-9ceaaeb41007?source=collection_archive---------7-----------------------#2020-09-21</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="b9cb" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">使用下划线的不同方式</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/f87ea4953f7d909239dfeea9aade6a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZjAus_epZkkJG5Uixb7avA.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">来自<a class="ae kz" href="https://www.pexels.com/photo/aerial-photography-of-blue-car-on-road-1552224/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kz" href="https://www.pexels.com/@thelazyartist?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">懒惰艺术家画廊</a>的照片</p></figure><h1 id="0e95" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">Python中的下划线</h1><p id="ba99" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">下划线在Python中有特殊的含义。在Python中，它们被用在不同的地方。</p><p id="56e3" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">以下是Python中使用的不同类型的下划线:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj mt"><img src="../Images/ce1d5fac67c19ccffa2d8fa151931f4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*enVwMOUrM1JO5eyP.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片来源:作者</p></figure></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h1 id="3603" class="la lb iu bd lc ld nb lf lg lh nc lj lk ka nd kb lm kd ne ke lo kg nf kh lq lr bi translated">1.单下划线</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj mt"><img src="../Images/2fcfb5f4649c56473ca7a5f6bfaab3f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*QygnoSk7eKgYuYel.png"/></div></figure><h2 id="ccfe" class="ng lb iu bd lc nh ni dn lg nj nk dp lk mb nl nm lm mf nn no lo mj np nq lq nr bi translated">保存最后执行的表达式的值</h2><p id="9bda" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">单个下划线用于保存Python交互式命令提示符中最后执行的表达式的值。我们也可以将值保存到另一个变量中。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ns"><img src="../Images/f69ade0bb492827a300fbbf7230b768e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bxajYHRunLDGlmqc.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Python交互式命令提示符中使用的单下划线</p></figure><h2 id="b7f4" class="ng lb iu bd lc nh ni dn lg nj nk dp lk mb nl nm lm mf nn no lo mj np nq lq nr bi translated">忽略循环中的值</h2><p id="9d97" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">Python中的单下划线<code class="fe nt nu nv nw b">_</code>用于忽略一些值。如果我们不想使用某些值，可以给<code class="fe nt nu nv nw b">_</code>赋值。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">循环中使用的单下划线</p></figure><h2 id="251c" class="ng lb iu bd lc nh ni dn lg nj nk dp lk mb nl nm lm mf nn no lo mj np nq lq nr bi translated">忽略元组解包中的值</h2><p id="e5bd" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">如果我们想在元组解包时忽略一些值，我们可以将这些值赋给<code class="fe nt nu nv nw b">_</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><strong class="ak">元组解包中的单下划线</strong></p></figure><h2 id="be3f" class="ng lb iu bd lc nh ni dn lg nj nk dp lk mb nl nm lm mf nn no lo mj np nq lq nr bi translated">用于数字文字</h2><p id="7b87" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">在整数、浮点和复数文本中，下划线可以用作数字分组的可视分隔符。下划线没有语义含义，文字被解析为下划线不存在。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div></figure></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h1 id="94fc" class="la lb iu bd lc ld nb lf lg lh nc lj lk ka nd kb lm kd ne ke lo kg nf kh lq lr bi translated">2.单前导下划线</h1><p id="bcea" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">变量名、方法名和类名中可以使用单个前导下划线。它表明那些带有单个前导下划线的变量、方法和类名被程序员视为“私有”的。如果我们指定<code class="fe nt nu nv nw b">from M import * </code>，那些以单个前导下划线开头的名字不会被导入。如果我们想要导入那些变量/方法，我们必须在导入时指定名称。</p><p id="cc9d" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">引用<a class="ae kz" href="https://www.python.org/dev/peps/pep-0008/#descriptive-naming-styles" rel="noopener ugc nofollow" target="_blank"> PEP-8 </a></p><blockquote class="nz oa ob"><p id="659f" class="ls lt oc lu b lv mo jv lx ly mp jy ma od mq md me oe mr mh mi of ms ml mm mn in bi translated"><em class="iu">" _ single _ leading _下划线:弱“内部使用”指示符。<br/>例如，从M导入*不导入名称以下划线开头的对象。"</em></p></blockquote><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div></figure><p id="28af" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">将上述Python文件<code class="fe nt nu nv nw b">c1.py</code>导入到<code class="fe nt nu nv nw b">c2.py</code></p><p id="285c" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">示例:<code class="fe nt nu nv nw b">from c1 import *</code></p><p id="14b6" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">不能访问只有一个前导下划线的变量和函数。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div></figure><p id="291e" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">如果我们想导入只有一个前导下划线的变量和函数，我们必须在导入时提到名字。</p><p id="6b88" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">示例:<code class="fe nt nu nv nw b"> from c1 import _a,_sub</code></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">导入具有单个下划线前缀的变量和函数</p></figure></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h1 id="9b6a" class="la lb iu bd lc ld nb lf lg lh nc lj lk ka nd kb lm kd ne ke lo kg nf kh lq lr bi translated">3.单个尾随下划线</h1><p id="0bda" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">单个尾随下划线用于避免与Python关键字冲突。</p><p id="c734" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">引用<a class="ae kz" href="https://www.python.org/dev/peps/pep-0008/#descriptive-naming-styles" rel="noopener ugc nofollow" target="_blank"> PEP-8 </a>的话:</p><blockquote class="nz oa ob"><p id="3869" class="ls lt oc lu b lv mo jv lx ly mp jy ma od mq md me oe mr mh mi of ms ml mm mn in bi translated"><em class="iu">" single _ trailing _下划线_:按照约定使用，以避免与Python关键字冲突"</em></p></blockquote><pre class="kk kl km kn gu og nw oh oi aw oj bi"><span id="2a04" class="ng lb iu nw b gz ok ol l om on">list=[1,2,3]</span><span id="8c74" class="ng lb iu nw b gz oo ol l om on">t=(5,6,7)</span><span id="425d" class="ng lb iu nw b gz oo ol l om on"><em class="oc">#Coverting tuple to list using list() constructor<br/></em>t1=list(t)<br/><em class="oc">#Output:TypeError: 'list' object is not callable</em></span></pre><p id="bdca" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">在上面的例子中，我们可以使用<code class="fe nt nu nv nw b"> list_</code>作为变量名，以避免与Python关键字<code class="fe nt nu nv nw b">list</code>的冲突。</p><pre class="kk kl km kn gu og nw oh oi aw oj bi"><span id="4f15" class="ng lb iu nw b gz ok ol l om on">list_=[1,2,3]</span><span id="5b0e" class="ng lb iu nw b gz oo ol l om on">t=(5,6,7)</span><span id="7c62" class="ng lb iu nw b gz oo ol l om on"><em class="oc">#Coverting tuple to list using list() constructor<br/></em>t1=list(t)<br/>print (t1)<em class="oc">#Output:[5, 6, 7]</em></span></pre></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h1 id="4e7e" class="la lb iu bd lc ld nb lf lg lh nc lj lk ka nd kb lm kd ne ke lo kg nf kh lq lr bi translated">4.双前导下划线</h1><p id="8c85" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">双下划线告诉Python解释器重写子类的属性名和方法名，以避免命名冲突。解释器用类扩展改变属性名被称为<em class="oc">名称篡改</em>。</p><p id="b976" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><code class="fe nt nu nv nw b">self._className__methodname()</code>而不是<code class="fe nt nu nv nw b">self.__methodname()</code></p><p id="ef75" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><code class="fe nt nu nv nw b">self._classname__attributename</code>而不是<code class="fe nt nu nv nw b">self.__attributename</code></p><p id="9283" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">根据<a class="ae kz" href="https://docs.python.org/3.8/tutorial/classes.html#private-variables" rel="noopener ugc nofollow" target="_blank"> Python文档</a>:</p><blockquote class="nz oa ob"><p id="3808" class="ls lt oc lu b lv mo jv lx ly mp jy ma od mq md me oe mr mh mi of ms ml mm mn in bi translated"><em class="iu">“名称混淆有助于让子类覆盖方法而不中断类内方法调用。”</em></p></blockquote><p id="b08f" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">引用<a class="ae kz" href="https://www.python.org/dev/peps/pep-0008/#descriptive-naming-styles" rel="noopener ugc nofollow" target="_blank"> PEP-8 </a>:</p><blockquote class="nz oa ob"><p id="721c" class="ls lt oc lu b lv mo jv lx ly mp jy ma od mq md me oe mr mh mi of ms ml mm mn in bi translated"><em class="iu">" _ _ double _ leading _下划线:命名类属性时，调用name mangling(在类FooBar内，__boo变成_FooBar__boo)" </em></p></blockquote><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">名字叫莽林</p></figure><p id="f1ef" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">具有相同方法名的继承类:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在继承的类中使用了名称篡改</p></figure></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h1 id="0bcf" class="la lb iu bd lc ld nb lf lg lh nc lj lk ka nd kb lm kd ne ke lo kg nf kh lq lr bi translated">5.双前导和双尾随下划线</h1><p id="5095" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">Python中的特殊方法用双前导和双尾随下划线命名。它们在Python中被称为<em class="oc">魔法方法</em> / <em class="oc"> dunder方法</em>。</p><p id="9697" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">例子:<code class="fe nt nu nv nw b">__init__,__str__,__repr__,__len__</code>。这些神奇的方法在Python中有特殊的含义。我们可以覆盖这些来改变我们类的行为。</p><p id="95de" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">引用<a class="ae kz" href="https://www.python.org/dev/peps/pep-0008/#descriptive-naming-styles" rel="noopener ugc nofollow" target="_blank"> PEP-8 </a></p><blockquote class="nz oa ob"><p id="3c0a" class="ls lt oc lu b lv mo jv lx ly mp jy ma od mq md me oe mr mh mi of ms ml mm mn in bi translated"><em class="iu"/><code class="fe nt nu nv nw b"><em class="iu">__double_leading_and_trailing_underscore__</em></code><em class="iu">:“神奇”的对象或属性，它们存在于用户控制的名称空间中。如</em><code class="fe nt nu nv nw b"><em class="iu">__init__</em></code><em class="iu"/><code class="fe nt nu nv nw b"><em class="iu"> __import__</em></code><em class="iu">或</em> <code class="fe nt nu nv nw b"><em class="iu">__file__</em></code> <em class="iu">。千万不要发明这样的名字；请仅按照记录使用它们。”</em></p></blockquote><p id="d6e7" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">按照Python惯例，避免使用带有双前导和双尾随下划线的变量名。</p><p id="42cf" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">我们可以使用<code class="fe nt nu nv nw b">dir()</code>函数来查看该类继承的神奇方法。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">魔术方法/邓德方法</p></figure></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h1 id="c1d7" class="la lb iu bd lc ld nb lf lg lh nc lj lk ka nd kb lm kd ne ke lo kg nf kh lq lr bi translated">资源</h1><ul class=""><li id="0d55" class="op oq iu lu b lv lw ly lz mb or mf os mj ot mn ou ov ow ox bi translated"><a class="ae kz" href="https://docs.python.org/3.8/tutorial/classes.html#private-variables" rel="noopener ugc nofollow" target="_blank">私有变量</a></li><li id="3291" class="op oq iu lu b lv oy ly oz mb pa mf pb mj pc mn ou ov ow ox bi translated"><a class="ae kz" href="https://www.python.org/dev/peps/pep-0515/" rel="noopener ugc nofollow" target="_blank">数字文字中的下划线</a></li></ul></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><p id="4005" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><em class="oc">观看此空间，了解更多关于Python和数据科学的文章。如果你喜欢多看我的教程，就关注我的</em> <a class="ae kz" href="https://medium.com/@IndhumathyChelliah" rel="noopener"> <strong class="lu iv"> <em class="oc">中</em></strong></a><a class="ae kz" href="https://www.linkedin.com/in/indhumathy-chelliah/" rel="noopener ugc nofollow" target="_blank"><strong class="lu iv"><em class="oc">LinkedIn</em></strong></a><strong class="lu iv"><em class="oc"/></strong><a class="ae kz" href="https://twitter.com/IndhuChelliah" rel="noopener ugc nofollow" target="_blank"><strong class="lu iv"><em class="oc">推特</em> </strong> </a> <strong class="lu iv"> <em class="oc">。</em>T46】</strong></p><p id="8416" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">感谢阅读！</p></div></div>    
</body>
</html>