<html>
<head>
<title>6 TypeScript Typing System Tricks You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该知道的6个打字系统技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-typescript-typing-system-tricks-you-should-know-5aa39bda8049?source=collection_archive---------1-----------------------#2021-07-19">https://betterprogramming.pub/6-typescript-typing-system-tricks-you-should-know-5aa39bda8049?source=collection_archive---------1-----------------------#2021-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3d54" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我从使用TypeScript的类型系统中学到了什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9fb1cc503cd522c9518be51534458695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oUWzCXLJ5Jpm2iSwMzY3uw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@melissaaskew?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">梅丽莎·艾斯丘</a>在<a class="ae ky" href="https://unsplash.com/s/photos/shapes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="e330" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript是关于类型的。它是一种具有强大编译时类型检查的强类型语言。同时，它的静态类型是可选的，所以它与JavaScript兼容。</p><p id="0300" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我从事打字工作已经三年多了。在这个旅程中学到了很多，但我仍然有在日常工作中学习新功能或技巧的惊喜。</p><p id="49f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我通过使用打字系统学到的一些最佳实践:</p><ul class=""><li id="9f2c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="#376f4" rel="noopener ugc nofollow">具体点</a></li><li id="175c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#c116" rel="noopener ugc nofollow">启用严格模式</a></li><li id="48c1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#07d6" rel="noopener ugc nofollow">对泛型应用类型参数约束</a></li><li id="7136" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#9643" rel="noopener ugc nofollow">使用类型推理代替显式声明</a></li><li id="af6b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#6eeb" rel="noopener ugc nofollow">尽量少用</a></li><li id="1f67" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#6086" rel="noopener ugc nofollow">只读的不变性</a></li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="76f4" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">具体点</h1><p id="9049" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在TypeScript中，类型是数据的形状或数据的结构(<a class="ae ky" href="https://www.typescriptlang.org/play#example/structural-typing" rel="noopener ugc nofollow" target="_blank">结构类型化</a>)。有了类型信息，TypeScript的编译器将在编译时给你早期警告来检测错误，而不是让你得到一个难看的运行时错误。</p><p id="eb3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在定义类型时，我们希望数据结构尽可能的具体。使用简洁的类型将有助于编译器更好地工作。定义良好的类型可以作为自我解释的文档，使代码更具可读性。</p><p id="7f5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的原则是越简洁(越窄)越好。TypeScript的强大之处在于它为结构类型、映射类型和条件类型提供了<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#control-flow-based-type-analysis" rel="noopener ugc nofollow" target="_blank">基于控制流的类型分析</a>、类型推理和<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/basic-types.html" rel="noopener ugc nofollow" target="_blank">类型断言</a>。有了这个强大的工具箱，<a class="ae ky" href="https://blog.logrocket.com/type-flowing-rethinking-typescript-typing-system/" rel="noopener ugc nofollow" target="_blank">你可以构建一个约束良好的类型系统来最大化类型安全的好处。</a></p><p id="499e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们有一个名为<code class="fe nn no np nq b">PayGrade</code>的类型:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="7ff7" class="nv mr it nq b gy nw nx l ny nz">type PayGrade: number;</span></pre><p id="5438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以把它变得更具体，因为我们知道它是从<code class="fe nn no np nq b">1</code>到<code class="fe nn no np nq b">5</code>:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="626a" class="nv mr it nq b gy nw nx l ny nz">type PayGrade = 1 | 2 | 3 | 4 | 5;</span></pre><p id="28df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想在语义上更好地表达类型，下面是改进后的版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="9e60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使您的代码具有强类型，它会变得更加健壮。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c116" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">启用严格模式</h1><p id="050f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">TypeScript的严格模式将允许更严格的类型检查规则。可能的话应该打开。可以在<code class="fe nn no np nq b">tsconfig.json</code>中启用严格模式:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="460d" class="nv mr it nq b gy nw nx l ny nz">{  "compilerOptions": <br/>    {    <br/>        "strict": true,  <br/>    }<br/>}</span></pre><p id="22ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格模式实际上是一组七个选项的快捷方式，每个选项都可以单独打开/关闭，以便进行精细控制。</p><p id="b9fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在处理现有项目，并且无法启用所有选项，以下两条规则比其他规则更重要:</p><ul class=""><li id="0eec" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nn no np nq b">noImplicitAny</code> —使用隐含的<code class="fe nn no np nq b">any</code>类型出错。</li><li id="6f69" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nn no np nq b">strictNullChecks</code> —不能将<code class="fe nn no np nq b">null</code>或<code class="fe nn no np nq b">undefined</code>赋给变量，除非将其明确设置为允许。</li></ul><p id="f4e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他规则包括:</p><ul class=""><li id="26bb" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nn no np nq b">noImplicitThis</code> —不允许您引用带有隐含<code class="fe nn no np nq b">any</code>类型的<code class="fe nn no np nq b">this</code>。</li><li id="2cd6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nn no np nq b">alwaysStrict"</code> —将“使用严格”设置在所有编译的JS文件的顶部。</li><li id="9b5e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nn no np nq b">strictBindCallApply</code> —开启对函数的<code class="fe nn no np nq b">bind</code>、<code class="fe nn no np nq b">call</code>和<code class="fe nn no np nq b">apply</code>方法的严格检查。</li><li id="929e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nn no np nq b">strictFunctionTypes</code> —将函数类型检查设置为<em class="oc">逆变</em>，而不是默认的<em class="oc">双变量。</em></li><li id="7939" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nn no np nq b">strictPropertyInitialization</code> —强制类属性被赋予默认值或在构造函数中初始化。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="07d6" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">将类型参数约束应用于泛型</h1><p id="5558" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">泛型允许类型作为参数。当使用泛型类型参数时，我们应该用约束来声明参数。另一种类型或接口可以约束它。</p><p id="3a5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下示例显示了如何使用<code class="fe nn no np nq b">extends</code>关键字将类型参数约束为<code class="fe nn no np nq b">Animal</code>类型:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="e1eb" class="nv mr it nq b gy nw nx l ny nz">type Animal = {<br/>  owner: string;<br/>}<br/>function feedPets&lt;T extends Animal&gt;(pets: T[]): void { }</span></pre><p id="0137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果参数以不同的类型传入，将显示编译时错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/3b4d34aa601041d8a9ac742f8aa0a5c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UJ2sg0TMILHr4a9BYDup4w.png"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9643" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">使用类型推理而不是显式声明</h1><p id="5c0c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们可以使用类型推断来简化我们的代码。TypeScript的编译器可以计算出简单类型表达式的类型，包括变量、返回类型等。在许多情况下，没有理由显式声明类型。代码越简单越好。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="24ab" class="nv mr it nq b gy nw nx l ny nz">const x: string = 'John'; // string is redundant here</span></pre><p id="5b84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，也有例外。对于复杂表达式，显式类型声明有助于提高可读性。</p><p id="bb8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个例外是函数参数，<strong class="lb iu"> </strong>如同<strong class="lb iu"> </strong>它们是永远不会被推断出来的。如果没有类型声明，将对它们使用<code class="fe nn no np nq b">any</code>。</p><p id="ee05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数的返回类型可以通过TypeScript来推断。但是如果你的函数有一个复杂的返回类型，为了可读性，最好声明一个显式的返回类型。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6eeb" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">尽量少用<code class="fe nn no np nq b">any </code></h1><p id="e17d" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在大多数情况下，我们应该避免使用<code class="fe nn no np nq b">any</code>。使用<code class="fe nn no np nq b">any</code>可能是让您继续代码的快捷方式，但是它会在编译时隐藏错误或潜在问题。换句话说，<code class="fe nn no np nq b">any</code>类型忽略了类型脚本的最大好处:强类型。</p><p id="9517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑改用<code class="fe nn no np nq b">unknown</code>。使用<code class="fe nn no np nq b">unknown</code>类型，你可以给它赋值，但是如果不转换或缩小类型，你就不能使用它。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="d8a5" class="nv mr it nq b gy nw nx l ny nz">const data: unknown = value;</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6086" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">只读的不变性</h1><p id="7f93" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Immutable_object" rel="noopener ugc nofollow" target="_blank">不变性</a>使得推理你的代码变得容易，并且避免了变异数据带来的复杂性。TypeScript提供了实现不变性的<code class="fe nn no np nq b">readonly</code>修饰符，以及<code class="fe nn no np nq b"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank">Readonly</a></code> <a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank">实用程序类型</a>。</p><p id="4cd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">readonly</code> <strong class="lb iu"> </strong>修饰符可以应用于接口或类的属性，所以它们不能被重新分配。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="0bd1" class="nv mr it nq b gy nw nx l ny nz">class Fish {<br/>   constructor(public readonly name: string) {}<br/>}</span></pre><p id="c2ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">Readonly&lt;T&gt;</code>构造一个类型，该类型将<code class="fe nn no np nq b">readonly</code>修饰符应用于泛型类型<code class="fe nn no np nq b">T</code>的所有编译时属性。这意味着构造的<code class="fe nn no np nq b">T</code>的属性不能被重新分配。当类型被共享时，用<code class="fe nn no np nq b">Readonly</code>实用程序类型声明不可变类型是一个很好的实践。</p><p id="f375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意<code class="fe nn no np nq b">readonly</code>修饰符和<code class="fe nn no np nq b">Readonly</code>实用程序类型都只在编译时有效——在运行时无效。</p><p id="c2e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要阅读更多关于TypeScript中的readonly和常量的内容，可以看看我的另一篇文章。</p><div class="oe of gp gr og oh"><a href="https://medium.com/codex/how-to-share-constants-in-typescript-project-8f76a2e40352" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">如何在Typescript项目中共享常数</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">避免神奇的字符串，使你的应用程序可维护和强类型化</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">medium.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="115a" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">摘要</h1><p id="16c3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在本文中，我讨论了关于类型脚本类型的最佳实践。</p><p id="edec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过声明简洁的类型并正确使用TypeScript的类型系统，我们可以创建一个可读性更好、可维护性更强、更健壮的代码库。</p><p id="00ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，你可能也喜欢阅读我的其他打字稿文章。</p><div class="oe of gp gr og oh"><a href="https://sunnysun-5694.medium.com/path-to-functional-style-a-typescript-refactoring-example-f5f052fe4d84" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">函数式风格之路:一个类型脚本重构示例</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">本文讨论如何将命令式风格的功能重构为函数式风格。功能是…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">sunnysun-5694.medium.com</p></div></div><div class="oq l"><div class="ow l os ot ou oq ov ks oh"/></div></div></a></div><div class="oe of gp gr og oh"><a rel="noopener  ugc nofollow" target="_blank" href="/typescripts-record-type-explained-691372b1a449"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">解释了TypeScript的记录类型</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">您想知道的关于记录实用程序类型的所有信息</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">better编程. pub</p></div></div><div class="oq l"><div class="ox l os ot ou oq ov ks oh"/></div></div></a></div><p id="313a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oc">如果您还不是Medium、</em> <a class="ae ky" href="https://sunnysun-5694.medium.com/membership" rel="noopener"> <strong class="lb iu"> <em class="oc">的付费会员，您可以通过访问此链接</em> </strong> </a> <em class="oc">进行注册。你可以无限制地阅读媒体上的所有报道。我会收你一部分会员费作为介绍费。</em></p></div></div>    
</body>
</html>