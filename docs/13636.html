<html>
<head>
<title>7 Ways To Fetch Data in React Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React应用程序中获取数据的7种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-ways-to-fetch-data-in-react-applications-11fb03c6f6e0?source=collection_archive---------6-----------------------#2022-09-13">https://betterprogramming.pub/7-ways-to-fetch-data-in-react-applications-11fb03c6f6e0?source=collection_archive---------6-----------------------#2022-09-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="edb0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果没有合适的工具，数据获取和缓存很快就会变得繁琐和复杂</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5c6f61cfd75bfd9cdc253293ba853d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lS7PkKFGuH4o2IhykqhgmQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯·安德拉沃斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="5ab1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="eb36" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们的React应用程序通常用于呈现数据集。创建组件并设计它们的样式是故事的一部分。但是我们的数据需要来自某个地方。在许多情况下，我们从API中获取数据——无论是我们自己的API还是第三方的API。</p><p id="a10d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这种数据获取有许多方面:缓存数据、错误处理、验证请求和重新获取陈旧数据，等等。</p><p id="bd9e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在过去几年中，许多解决方案似乎可以帮助我们完成上述任务:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/1d1d875975f9fc95b1ed9f5d0da7fee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*v_zGIqFkWLao_5YV8re1SQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们将看到的七种流行工具。</p></figure><p id="8310" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们简要回顾一下这七个流行的工具，用一些样板代码展示每个解决方案在实践中是如何实现的。</p><p id="f8d1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你可以在我的<a class="ae ky" href="https://gitlab.com/gvanderput/gerard-fetching-methods" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> GitLab资源库</strong> </a>中找到工作示例(每个示例都是不同的分支)。</p><blockquote class="mt mu mv"><p id="28b4" class="lr ls mw lt b lu mn ju lw lx mo jx lz mx mp mc md my mq mg mh mz mr mk ml mm im bi translated">注意:我们按照复杂程度的顺序来回顾它们。我们从一些更复杂和完整的工具开始，以更简单的工具结束。还要注意，我们完全忽略了代码示例中的错误处理，因此我们可以专注于核心功能。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/668e76e863a2bba01c2d3334ea8bd812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QEOm1bZWfarOe7oe"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/es/@solomin_d?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马頔·索罗明</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="b1f9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">1.继电器</h1><p id="3854" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Relay (第二个版本被称为“Relay Modern”)是一个高级框架，用于使用React和GraphQL构建数据驱动的应用程序，由脸书创建。</p><p id="c030" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在最初的试验和实验之后，Relay Modern于2017年4月18日<a class="ae ky" href="https://engineering.fb.com/2017/04/18/web/relay-modern-simpler-faster-more-extensible/" rel="noopener ugc nofollow" target="_blank">发布</a>，此前它已经由<a class="ae ky" href="https://twitter.com/wincent" rel="noopener ugc nofollow" target="_blank"> Greg Hurell </a>和<a class="ae ky" href="https://twitter.com/en_js?lang=en" rel="noopener ugc nofollow" target="_blank"> Joe Savona </a>以及其他几个人开发并重新组装。葛瑞格在他的部落格上写了一篇关于这个发展的背景故事。</p><p id="d7f3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这不是胆小的人的工具。在开始之前，它需要相当多的样板代码和设置。即使这些都到位了，如果你对此知之甚少，你还会留下许多问题和挑战。</p><p id="2644" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">也就是说，它非常强大，性能卓越。一个明显的例子是:Facebook.com使用Relay(以及自2021年以来对开发者更友好的<a class="ae ky" href="https://relay.dev/blog/2021/03/09/introducing-relay-hooks/" rel="noopener ugc nofollow" target="_blank">中继挂钩</a> <a class="ae ky" href="https://developers.facebook.com/blog/post/2021/03/09/introducing-relay-hooks-improved-react-apis-relay/" rel="noopener ugc nofollow" target="_blank">)。</a></p><p id="2075" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要开始，您需要定义一个通用的fetch函数，即所谓的中继环境，并且您需要运行中继编译器(最好是作为开发期间的监视进程)。GraphQL模式也需要存储在您的存储库中(<code class="fe nb nc nd ne b"><a class="ae ky" href="https://www.npmjs.com/package/get-graphql-schema" rel="noopener ugc nofollow" target="_blank">get-graphql-schema</a></code>可能会派上用场)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/7654cdacfa8813c60bdf4f08396f6760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xIoNfMfFhfz_-gbav43tYw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">中继编译器在开发过程中监视变化。</p></figure><h1 id="e372" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">2.阿波罗客户端</h1><p id="ac0b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">JavaScript丛林中最难对付的动物的另一个有力竞争者是<a class="ae ky" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank">Apollo Client</a>:<em class="mw">一个全面的JavaScript状态管理库，使您能够使用GraphQL </em>管理本地和远程数据。</p><p id="4616" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在很小程度上，它与Relay相当(但要知道，也有很大的不同)。</p><p id="78f3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是我自己经常使用的一个库。对我来说，这个库的关键是它很好地完成了它的工作，并且高度可定制，但是你必须小心缓存策略。默认情况下，缓存似乎工作得很好——老实说，确实如此。但是一旦您的应用程序开始增长，并且您需要诸如分页或数据过滤之类的功能(例如，使用不同的变量多次运行相同的查询)，您可能会遇到必须定制缓存功能的情况。维持这种逻辑很快就变得相当困难。</p><p id="e90f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">与接力赛相比，它更容易准备和进行。您定义了一个客户端，通过一个专用的提供者使该客户端可用，然后您就可以开始工作了。但是不要低估在你满意之前你必须为定制你的设置付出的努力。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/d65c13c61309ed51b85a54262edfc213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IpzCI11xvEcHwcIBYF2RhQ.png"/></div></div></figure><h1 id="fa75" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">3.传递查询v4(反应查询)</h1><blockquote class="mt mu mv"><p id="6436" class="lr ls mw lt b lu mn ju lw lx mo jx lz mx mp mc md my mq mg mh mz mr mk ml mm im bi translated">注意:TanStack查询以前叫做<code class="fe nb nc nd ne b"><em class="it">react-query</em></code>。他们<a class="ae ky" href="https://twitter.com/tannerlinsley/status/1549785943837515776" rel="noopener ugc nofollow" target="_blank">在2022年7月将</a>更名为TanStack Query(<a class="ae ky" href="https://tanstack.com/blog/announcing-tanstack-query-v4" rel="noopener ugc nofollow" target="_blank">来源</a>)，并且他们很快就会有几个框架的适配器，比如Vue、Svelte和Solid。在撰写本文时，唯一完成的适配器是React的一个实现，方便地称为<code class="fe nb nc nd ne b"><em class="it">React Query</em></code>。</p></blockquote><p id="1ead" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我们转向不太复杂的库和工具之前，我们可以看看游戏中的另一个大玩家:<a class="ae ky" href="https://tanstack.com/query/v4/docs/overview" rel="noopener ugc nofollow" target="_blank"> TanStack Query </a>。微软、沃尔沃、易贝和优步等公司都使用它，如果我们忽略它，那就太愚蠢了。</p><p id="bbc9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它开箱即用，但高度可配置，并具有许多功能，如支持窗口焦点的重新提取、分页、预取、滚动恢复等等。</p><p id="a965" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它需要少量的样板代码来运行。同样，就像我们刚刚看到的Apollo Client一样，我们需要创建一个客户端，让它对提供者可用，并且我们可以开始使用可用的钩子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="a692" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">4.SWR</h1><p id="2ec2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">不如Apollo Client和TanStack Query流行，但绝对不是一个可以忽略的包:Vercel的<a class="ae ky" href="https://swr.vercel.app" rel="noopener ugc nofollow" target="_blank"> SWR </a> (Vercel是Next.js的创建者)。</p><p id="fed3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">与我们已经看过的其他三种解决方案相比，SWR是最容易开始使用的。您只需导入并使用<code class="fe nb nc nd ne b">useSWR</code>钩子通过自定义的、用户定义的fetch函数获取数据(在本例中我们使用的是本地Fetch API):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f0c9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不要被这一切的简单所迷惑。SWR提供的钩子功能强大，支持分页、突变、预取和SSR(服务器端呈现)。</p><h1 id="3b0a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">5.反应异步挂钩</h1><p id="f6cc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">React-async-hook是由<a class="ae ky" href="https://twitter.com/sebastienlorber" rel="noopener ugc nofollow" target="_blank"> Sébastien Lorber </a>(时事通讯<code class="fe nb nc nd ne b"><a class="ae ky" href="https://thisweekinreact.com" rel="noopener ugc nofollow" target="_blank">thisweekinreact.com</a></code>的作者)创建的一个微型库，它没有我们已经看到的功能更全的库使用得多。也就是说，比较它们是不公平的(主要的论点是react-async-hook没有内置的缓存支持——从设计上来说)。</p><p id="61f9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="https://github.com/slorber/react-async-hook" rel="noopener ugc nofollow" target="_blank">自述文件</a>的第一行写道:</p><blockquote class="mt mu mv"><p id="b1b2" class="lr ls mw lt b lu mn ju lw lx mo jx lz mx mp mc md my mq mg mh mz mr mk ml mm im bi translated">"这个小小的图书馆只做一件事，而且做得很好."</p></blockquote><p id="305e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">尽管readme文件列出了几个特性，但归结起来就是:这个库非常擅长获取数据(使用提供的<code class="fe nb nc nd ne b">useAsync</code>钩子)。</p><p id="4fb4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以取消请求、触发重新提取、处理突变和竞争情况，等等。如您所见，这完全取决于请求获取数据。作者还认为库功能是完整的，这意味着没有积极的开发(改变实际代码的最近一次提交是在2021年9月<a class="ae ky" href="https://github.com/slorber/react-async-hook/commit/51a02e20df0b0e91d550dd8f599405f00a2a06f2" rel="noopener ugc nofollow" target="_blank">)。</a></p><p id="0ccd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是考虑到偶尔对readme文件的小规模提交，Sébastien似乎会密切关注它。</p><p id="beff" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">类似于SWR，使用react-async-hook很容易。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/dbb153c78a8c3fe61d3d728f11b2ed2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RA9wtJwMj9k0vc8gNoWrmA.png"/></div></div></figure><h1 id="bf68" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">6.Axios</h1><p id="1e27" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">每周下载量超过3000万次。)，我们可以有把握地得出结论，Axios是一个功能强大的小工具，它的工作做得非常好。许多流行的库都依赖Axios。</p><blockquote class="mt mu mv"><p id="cd90" class="lr ls mw lt b lu mn ju lw lx mo jx lz mx mp mc md my mq mg mh mz mr mk ml mm im bi translated">" Axios是一个简单的基于promise的HTTP客户端，用于浏览器和node.js . "</p></blockquote><p id="db75" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">换句话说，我们可以用它来(高度)配置和发出HTTP请求。它与我们上面看到的功能更全的库配合得很好，这些库要求我们提供自己的获取功能(比如TanStack查询和SWR)。如果您需要对HTTP请求进行细粒度的控制，这是绝对必要的。</p><p id="bdf3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您已经有一段时间了，您可能还记得使用jQuery的<code class="fe nb nc nd ne b">$.ajax()</code>函数来发出异步的"<a class="ae ky" href="https://en.wikipedia.org/wiki/Ajax_(programming)" rel="noopener ugc nofollow" target="_blank"> Ajax </a>"请求是很常见的。在某种程度上，我们可以将Axios与jQuery的<code class="fe nb nc nd ne b">ajax()</code>函数进行比较(但我不认为我对Axios的这种说法公正)。</p><p id="db76" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意，Axios是非常原始和裸露的。对于React应用程序中的数据获取，它不是一个成熟的解决方案。但是它可以补充像TanStack Query和SWR这样的库，这样你就有了一个完整的数据流解决方案。</p><p id="ca1d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">假设您是React新手，对数据获取没有太多经验。在这种情况下，我建议在使用更复杂的功能之前，先试用一下Axios(或者Fetch API，见下一章),以便更好地理解正在发生的事情。</p><p id="a8ac" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">用Axios获取数据的一个非常简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="ecf2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">7.获取API</h1><p id="213c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后但同样重要的是，我们应该提到<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取API </a>，几乎所有主流浏览器都支持它。随着2022年4月Node.js 18的发布，默认情况下会启用一个全局<code class="fe nb nc nd ne b">fetch</code>功能(尽管他们在<a class="ae ky" href="https://nodejs.org/en/blog/announcements/v18-release-announce/" rel="noopener ugc nofollow" target="_blank">公告</a>中称之为实验性功能)，用于Node.js驱动的后端环境。</p><p id="c54b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Fetch API是发出HTTP请求的现代答案。但是要记住它是一个相当低级的API。你可以用它提出请求，但仅此而已。对于您的应用程序来说，这不是一个完整的解决方案(请注意在这方面与Axios的相似性)。</p><p id="a40d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以，Fetch API和Axios在很多方面都很相似。注意，如果您的应用程序需要向后兼容旧的浏览器，建议使用Axios(或者Fetch API的polyfill)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="137a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">最后的话</h1><p id="b5bb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于大多数应用程序来说，从服务器获取数据并拥有本地数据(状态)和缓存策略是必不可少的。幸运的是，多年来已经开发出了几种解决方案，为我们省去了许多麻烦。</p><p id="1ebd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我写了一篇关于你应该知道的七个流行工具和库的短文。但是，如果您想成为一名优秀的(React)开发人员，您应该首先致力于很好地理解数据获取和缓存的“幕后”情况。</p><p id="9c24" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">记住，你可以在我的<a class="ae ky" href="https://gitlab.com/gvanderput/gerard-fetching-methods" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> GitLab资源库</strong> </a>中找到所有工作示例(每个示例都是不同的分支)。</p><p id="88c8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">感谢您的宝贵时间！</p><p id="c9c1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">杰勒德</p></div></div>    
</body>
</html>