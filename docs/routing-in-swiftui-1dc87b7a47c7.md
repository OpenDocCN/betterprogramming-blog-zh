# SwiftUI 中的路由

> 原文：<https://betterprogramming.pub/routing-in-swiftui-1dc87b7a47c7>

## SwiftUI 中路由的 2 种解决方案

![](img/0cb18e0b9816903ff89dbb159aeec85e.png)

Javier Allegue Barros[在](https://unsplash.com/@soymeraki?utm_source=medium&utm_medium=referral) [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

# 目的

*   将导航逻辑与视图层分离。它允许你在不修改视图的情况下改变导航。
*   通过使导航更加灵活来简化任务的实现，如深度链接

# SwiftUI 特定信息

SwiftUI 的声明性质使得将导航从视图层中分离出来很有挑战性。推送导航需要在视图中插入一个`NavigationLink`。模态表示需要在视图代码中的某个地方添加`.sheet`修饰符。您必须为`NavigationLink`和`.sheet`提供目的地视图。同样，一般来说，您将使用`@state`属性来触发导航。

这与 UIKit 不同。例如，要在 UIKit 中有模式地呈现一个视图，在当前视图控制器上调用`present` 并传递一个目的视图控制器来显示就足够了。这可以在呈现视图控制器之外轻松完成。

# 解决方法

我们将考虑两种不同的解决方案来将导航从视图层中分离出来。两者都使用本地 SwiftUI 导航方法`NavigationLink`和`.sheet`修饰符。但是提供目的地视图和导航状态将被转移到路由器。

1.  **具有触发视图的路由器:**路由器将返回所有可能导航路线的触发子视图，以将它们插入到呈现视图中。这样的子视图代码片段将包含一个`NavigationLink`或`.sheet`修饰符，以及一个指定的目的视图，并将使用一个`@state`属性，通过绑定存储在路由器中。这样，呈现的视图将不再依赖于导航代码和目的地，而只依赖于路由器协议。
2.  **带有类型擦除修饰符的路由器:**一个正在呈现的视图将被配置为带有通用修饰符，用于呈现任何其他视图。被路由器初始化后，这些修改器将通过绑定跟踪存储在路由器中的导航状态，并在路由器改变该状态时执行导航。路由器还将具有所有可能的导航功能。这些函数将改变状态并触发导航。

## 用法示例

为了更容易理解，让我们在一个简单示例的上下文中考虑这两种解决方案。

该项目将由两个简单的视图组成:一个带有单个按钮的呈现视图和一个当用户点击按钮时应该导航到的呈现视图。呈现的视图将显示从呈现视图传递的文本。点击该文本将会关闭显示的视图。

# 1.带触发视图的路由器

## 呈现视图

呈现视图由知道如何导航到呈现视图的路由器初始化。路由器提供了一个触发器视图，插入该视图后，可以响应用户交互来执行所需的导航。

使用`PresentingRouterProtocol`代替实际的路由器类允许我们很容易地改变导航逻辑，并用模拟路由器初始化`PresentingView`进行测试。

我们应该用`@StateObject`(iOS 14 可用)包装路由器属性。这是因为导航状态驻留在路由器中，并且视图应该在状态改变时更新。此外，与`@ObservedObject`，相反，该包装器避免了每次更新所有者视图时重新创建路由器。这对于我们实现基于`NavigationLink`的推送导航至关重要。

## 路由器协议

有两个协议。第一个视图由可以导航到其他视图的路由器使用。

`NavigationState` 将被实现为子类中的一个结构。它将包含所有可能的导航路线的状态变量。`binding` 是一个方便的函数，用于获取已有状态变量的绑定。

另一个协议用于视图的路由器，这些视图以模态方式呈现或在导航视图上推送。它能让我们回到过去。

通常，路由器会同时符合`PresentingRouter`和`PresentedRouter`协议。

## 路由器实施

符合`PresentingRouterProtocol`的路由器应该能够导航到详细视图。所以它的`navigationState`应该包含这个路由的变量。

`presentDetails` 函数使用来自`NavigatingRouter`协议扩展的`binding`函数来提供对相应状态变量的访问，包括目的地视图的路由器和返回的触发视图。目的地路由器将使用此绑定来删除。触发器视图将使用该绑定来触发导航。

## 触发视图

路由器返回执行实际导航的触发视图，以响应用户操作。我们将只回顾两种最有用的触发视图，尽管可能有更多的触发视图。两者都接受一个内容视图，并将其转换成一个可以导航到指定目标视图的结果按钮。

第一个是上面例子中使用的`SheetButton` ***，*** 。它用 SwiftUI `.sheet`修饰符实现了模态导航。

第二个是`NavigationButton`。它提供用内部的`NavigationLink`实现的推送导航。

我们使用`NavigationLink` 初始化器与*`isActive`*绑定在这里因为我们要在路由器中保持导航状态。**

**在`SheetButton`和`NavigationButton`中拥有相同的初始化参数使得将导航类型从模态呈现改为推送导航变得容易——反之亦然。**

## **BasePresentedRouter 类**

**取消功能是很常见的。因此，我们还将介绍一个简单的基本路由器类。**

## **呈现的视图**

**细节视图只能显示，不执行任何其他类型的导航。正因为如此，我们将使用基本的`BasePresentedRouter` 路由器，这里不进行子类化。**

**我们可以在`PresentedView`中声明没有包装器的`router`属性，因为我们只使用它来解除，所以视图不需要监听路由器的状态变化。**

**当用户点击文本时，我们隐藏视图。**

# **2.具有类型擦除修饰符的路由器**

**这个解决方案中的导航以不同的方式实现——使用修饰符。我称它们为*类型删除*，因为它们不依赖于特定的目的地视图。添加一次后，他们可以导航到任何视图。**

## **呈现视图**

**为了允许将任何视图推到导航视图上，我们应该添加一个`.navigation`修饰符，并将路由器作为单个参数传递。类似地，为了能够呈现一个表，我们使用了一个`.sheet`修饰符。我们可以将它添加到`body`的任何子视图中。是一个自定义的`.sheet` 修饰符，以路由器为参数。**

**通过按钮的操作调用路由器的`presentDetails`功能，呈现视图导航到呈现视图。**

## **路由器实施**

**基类`Router`实现了`ObservableObject`协议，它的状态用`@Published`包装，以允许状态变化传播到视图并更新导航。**

**`navigating`变量将推送导航驱动到`NavigationView`上。它的值应该是目标视图。**

**`presentingSheet`是驾驶单演示。它的值也应该是目标视图。**

**`isPresented`是一个绑定到状态变量的布尔值，它驱动导航到当前视图。它应该从呈现路由器传递。**

**相应地，通过将目的地视图设置为`navigation`或`presentingSheet`状态属性，可以触发推送或模式导航。下面是路由器子类的一个方便界面。**

**正如您在上面看到的，路由器应该通过绑定到驱动所有者视图表示的`Bool`属性来初始化。我们可以通过以下接口从呈现路由器获得它:**

**`boolBinding`这是一个私有函数，通过关键路径访问状态来实现。下面是路由器的私有扩展，其中也包含用于`.navigation`和`.sheet`修饰符的`binding` 函数。**

## **。导航和。纸张修改器**

**`.navigation``.sheet`*实际上是添加到`View`扩展中的函数。他们以一个路由器为参数，将生成的视图修改器与路由器中对应的导航状态绑定:`navigation` 和*`presentingSheet`*变量。*****

***`NavigationModifier` 在`NavigationLink` 内部实现，使用提供的绑定触发展现。***

**`SheetModifier` 是用 SwiftUI `.sheet` 修改器以非常相似的方式实现的。**

****细分路由器****

**基本`Router`类的上述实现允许它的子类非常简单。我们只需要为可用的导航选项添加功能。**

**在我们的例子中，它将是一个单独的`presentDetails`函数。为了执行导航，我们需要创建一个目的地视图，用相应的路由器初始化它，并使用基类的一个便利方法(`navigateTo`或`presentSheet`)来触发所需类型的导航。**

**然后，当我们想要呈现`PresentedView`时，我们可以从任何视点代码调用它。在我们的例子中是按钮的动作闭包。**

**如果我们想从推送导航切换到模态，我们唯一需要做的就是将`navigateTo` 调用替换为`presentSheet`。**

## **呈现的视图**

**与第一个解决方案相同。**

# **深层链接**

**这两种解决方案在路由器内部都有导航状态。这使我们能够通过简单地改变路由器的状态来执行导航和实现深度链接。但是，第一种解决方案需要添加适当的触发器视图，以允许可能的深层链接路由。第二种解决方案对目标视图使用类型擦除。所以只需要一般的`.navigation`和`.sheet`修改器。**

# **比较**

**这两种解决方案都将导航逻辑从视图层中分离出来。两者都将导航状态存储在路由器中。两者都需要一些代码来插入到视图中进行导航。该代码在内部使用了`NavigationLink`或`.sheet`修饰符。**

**在这两种解决方案中，将导航类型从模态导航更改为推送导航是微不足道的，反之亦然。**

**在第一种解决方案中，导航是通过路由器返回的触发器视图来执行的。并且在第二种解决方案中使用通用类型擦除修饰符。在第一个解决方案中，我们需要通过插入相应的触发子视图来预配置一个包含所有可能路径的视图。在第二种解决方案中，添加新路线不需要更改视图，因为`.navigation`和`.sheet`修改器支持任何目的地视图。**

**例如，假设某个视图可以导航到三个不同视图，将它们推到一个导航堆栈上。在这种情况下，我们需要在第一个解决方案中插入三个触发视图，在第二个解决方案中只插入一个`.navigation`修改器。这种差异使得第二种解决方案中的导航更加灵活。**

**子类化在第二个解决方案中更简单，因为有存储所有导航状态的基本路由器超类。**

**第二种解决方案的一个缺点是基类需要存储所有三个导航状态变量:`navigating`、`presentingSheet`和`isPresented`，即使它们并不都是特定子类必须使用的。**

# **资源**

**您可以在我的 GitHub 资源库中找到本文中使用的源代码:**

*   **[带触发视图的路由](https://github.com/ihorvovk/Routing-in-SwiftUI-with-trigger-views)**
*   **[使用类型删除修饰符的路由](https://github.com/ihorvovk/Routing-in-SwiftUI-with-type-erased-modifiers)**