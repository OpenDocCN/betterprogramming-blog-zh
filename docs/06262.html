<html>
<head>
<title>Why Keys Matter in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么键在React中很重要</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-react-keys-matter-an-introduction-136b7447cefc?source=collection_archive---------3-----------------------#2020-09-15">https://betterprogramming.pub/why-react-keys-matter-an-introduction-136b7447cefc?source=collection_archive---------3-----------------------#2020-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1157" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及为什么您不应该忽略控制台中的关键警告</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/18ac878d607018c4b722fc5916abdc94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NPY9H-wYI-nKN2pShSoSeg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="a840" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在React中处理任何类型的列表时，如果您忘记包含一个<code class="fe lu lv lw lx b">key</code>属性，您将经常会遇到这个警告:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="76ba" class="mc md it lx b gy me mf l mg mh">Warning: Each child in a list should have a unique "key" prop</span></pre><p id="b8c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，React为什么告诉你要包含键，为什么它很重要？</p><p id="9146" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将解释React键的基本概念，为什么它们很重要，以及如何正确使用它们。让我们跳进来吧！</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="e94d" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">什么是反应键？</h1><p id="200a" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">简单地说，它们是在列表的子元素中传递的属性，目的是:</p><ul class=""><li id="6505" class="nl nm it la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated">确定添加了哪些元素。</li><li id="36e5" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">确定哪些元素被更新。</li><li id="fedc" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">确定哪些元素被删除。</li></ul><p id="6062" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，密钥作为元素的标识，就像护照用于标识人一样。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="8505" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">我们为什么需要它们？</h1><p id="e1ba" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">此时，您可能想知道为什么我们需要钥匙。毕竟，我们可以通过元素的ID、类名、父/子、索引、属性等来识别元素。答案是因为React的<a class="ae nz" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank"> Diffing算法</a>。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="15db" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">差分算法:简要说明</h1><p id="8b3e" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">React应用程序由组件树组成。每当任何组件中出现属性或状态更改时，React都会将其组件重新呈现到虚拟DOM中。diffing算法从根节点开始，在组件树的每一层比较新的虚拟DOM和旧的DOM。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/e736d9516cb72c4605b73eecfee7d653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*koGUWUTHb0UymLWdYZBRhg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae nz" href="https://blog.zairza.in/how-reactjs-works-behind-the-scene-e25689f4b2c5" rel="noopener ugc nofollow" target="_blank">扎伊尔扎</a>拍摄。</p></figure><p id="707a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该算法找到更新实际DOM所需的最少操作数。它是这样做的:</p><h2 id="23eb" class="mc md it bd mq ob oc dn mu od oe dp my lh of og na ll oh oi nc lp oj ok ne ol bi translated">1.按类型比较节点(即<code class="fe lu lv lw lx b">&lt;div&gt;</code>与<code class="fe lu lv lw lx b">&lt;span&gt;</code>)</h2><p id="c341" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">如果它们不同，则销毁并从头构建一个新组件。</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="8739" class="mc md it lx b gy me mf l mg mh">// virtual DOM<br/>&lt;div&gt;&lt;MyComponent/&gt;&lt;/div&gt;</span><span id="47bc" class="mc md it lx b gy om mf l mg mh">// real DOM<br/>&lt;span&gt;&lt;MyComponent/&gt;&lt;/span&gt;</span></pre><p id="f861" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，这会导致<code class="fe lu lv lw lx b">&lt;MyComponent/&gt;</code>被销毁和重建。</p><h2 id="fb9d" class="mc md it bd mq ob oc dn mu od oe dp my lh of og na ll oh oi nc lp oj ok ne ol bi translated">2.如果节点类型相同，则按属性进行比较</h2><p id="d4f0" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">如果它们不同，只更新属性。</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="15fe" class="mc md it lx b gy me mf l mg mh">// virtual DOM<br/>&lt;div className="after" title="stuff" /&gt;</span><span id="9efe" class="mc md it lx b gy om mf l mg mh">// real DOM<br/>&lt;div className="before" title="stuff" /&gt;</span></pre><p id="093f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，这导致将<code class="fe lu lv lw lx b">className</code>更新为<code class="fe lu lv lw lx b">after</code>。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="863e" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">列表呢？</h1><p id="5bdf" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">对于列表，React将同时在它们的两个子节点上递归，找出任何差异，然后将它们修补到真正的DOM(如果有的话)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="088d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，这会导致在<code class="fe lu lv lw lx b">&lt;li&gt;second&lt;/li&gt;</code>之后添加<code class="fe lu lv lw lx b">&lt;li&gt;third&lt;/li&gt;</code>。</p><p id="d5a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，一切顺利。但是现在，不是在列表的底部添加一个元素，而是在开头添加一个新元素，会怎么样呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="366a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个例子将导致React将每一个<code class="fe lu lv lw lx b">&lt;li&gt;</code>重新呈现给真实的DOM，因为它没有意识到它可以简单地将<code class="fe lu lv lw lx b">&lt;li&gt;zero&lt;/li&gt;</code>添加到列表的开头。</p><p id="01e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种低效率会导致问题，尤其是在较大的应用程序中。因此，键为这个问题提供了一个简单的解决方案。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="687a" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">使用钥匙的正确方法:id</h1><p id="fe74" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">您可以轻松地向列表元素添加键，如下所示:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="aabb" class="mc md it lx b gy me mf l mg mh">&lt;li key="1"&gt;first&lt;/li&gt;<br/>&lt;li key="2"&gt;second&lt;/li&gt;<br/>&lt;li key="3"&gt;third&lt;/li&gt;</span></pre><p id="aad6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">键应该是唯一的标识符，这样每个元素都可以被正确地识别。因此，建议使用一些唯一生成的<code class="fe lu lv lw lx b">id</code>作为密钥。您甚至可以将键分配给动态呈现的列表:</p><pre class="kj kk kl km gt ly lx lz ma aw mb bi"><span id="eac6" class="mc md it lx b gy me mf l mg mh">const todoItems = todos.map((todo) =&gt;<br/>  &lt;li key={todo.id}&gt;<br/>    {todo.text}<br/>  &lt;/li&gt;<br/>);</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="70de" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">使用键的错误方法:索引</h1><p id="6260" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">当对列表进行某些更改时，使用<code class="fe lu lv lw lx b">index</code>作为键会导致问题。见<a class="ae nz" href="https://cdn.hashnode.com/res/hashnode/image/upload/v1599068972819/lz8pCKOZ8.gif?auto=format,compress&amp;gif-q=60" rel="noopener ugc nofollow" target="_blank">我做的这个演示</a>来说明这个问题。</p><p id="433d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，当向学生列表添加新元素时，<code class="fe lu lv lw lx b">Notes</code>属性没有正确映射，因为列表的索引是键。</p><p id="10d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，属性的值(<code class="fe lu lv lw lx b">greenroots</code>和<code class="fe lu lv lw lx b">mycodinghabits</code>)将总是位于索引0和1，即使它们对应的列表元素已经改变了它们在列表中的位置。</p><p id="5d8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看<a class="ae nz" href="https://cdn.hashnode.com/res/hashnode/image/upload/v1599068096879/rLfwCVVE9.gif?auto=format,compress&amp;gif-q=60" rel="noopener ugc nofollow" target="_blank">如果我们使用<code class="fe lu lv lw lx b">Student ID</code>作为键，它会是什么样子。</a></p><p id="5926" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个<a class="ae nz" href="https://cdn.hashnode.com/res/hashnode/image/upload/v1598988192522/8kCzUo9Bf.gif?auto=format,compress&amp;gif-q=60" rel="noopener ugc nofollow" target="_blank">并排对比</a>。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="917e" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">结论</h1><p id="78bc" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">键的主要目的是帮助React区分元素，提高区分虚拟和真实DOM时的性能。要使用键，只需在元素内添加道具，如<code class="fe lu lv lw lx b">&lt;li&gt;</code>。</p><p id="3940" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">唯一id是分配给键的最佳值。如果列表是静态的(不能更改)并且其中的元素没有<code class="fe lu lv lw lx b">id</code>属性，那么只能使用<code class="fe lu lv lw lx b">index</code>作为键。</p><p id="2733" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的阅读。希望这篇文章有用。如果你有任何问题，请在下面评论。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="d5ca" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">资源</h1><ul class=""><li id="5208" class="nl nm it la b lb ng le nh lh op ll oq lp or lt nq nr ns nt bi translated"><a class="ae nz" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">反应差分算法</a></li><li id="4baf" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated"><a class="ae nz" href="https://reactjs.org/docs/lists-and-keys.html" rel="noopener ugc nofollow" target="_blank">反应列表和按键</a></li><li id="0a63" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated"><a class="ae nz" href="https://github.com/victoria-lo/react-keys-tutorial" rel="noopener ugc nofollow" target="_blank">演示回购</a></li><li id="5d77" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated"><a class="ae nz" href="https://victoria-lo.github.io/react-keys-tutorial/" rel="noopener ugc nofollow" target="_blank">参观演示</a></li></ul></div></div>    
</body>
</html>