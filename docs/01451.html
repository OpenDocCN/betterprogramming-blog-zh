<html>
<head>
<title>Converting Callbacks to Promises Like a Pro in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像Node.js中的专家一样将回调转换为承诺</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/converting-callbacks-to-promises-like-a-pro-in-node-js-f5d4d466a1a7?source=collection_archive---------6-----------------------#2019-09-11">https://betterprogramming.pub/converting-callbacks-to-promises-like-a-pro-in-node-js-f5d4d466a1a7?source=collection_archive---------6-----------------------#2019-09-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/da2caacf52db60316a9ad282ec7370f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m7mp5WTuOU44CwZp"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">马科斯·迈尔在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="022c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Node中，默认情况下异步处理I/O操作，Node处理异步调用的最初方式是使用回调。</p><p id="bf86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回调只是作为参数传递给其他函数的函数。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="0038" class="ln lo it lj b gy lp lq l lr ls">const fs = require('fs');</span><span id="3248" class="ln lo it lj b gy lt lq l lr ls">fs.readFile('someFilePath', (err, data) =&gt; {<br/>  if(err){<br/>  //do something when  error occurred while reading file<br/>  }<br/>  //do something here with the file data<br/>})</span></pre><p id="8de7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们异步读取一个文件，并根据是否发生错误来执行某些操作。</p><p id="21da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Node中，有一个使用错误优先回调的约定(即，传递给回调函数的第一个参数是错误对象)，之后，只传递其他参数(参见上面的代码示例)。</p><p id="d36a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">注意:</strong>回调并不意味着代码中的异步调用。</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="lu lv l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">代码1</p></figure><p id="1b5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们使用了一个回调函数，而且是完全同步的。所以回调并不一定意味着我们代码中的异步</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="cf3a" class="md lo it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">使用回调</h1><p id="7cbe" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">我们将举一个异步的例子，然后使用回调来编写它，然后我们将它转换成基于承诺的代码。</p><p id="1467" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有一个文件，里面的数字是按行写的。</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="2f28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们要做的是使用<code class="fe nf ng nh lj b">node</code> <code class="fe nf ng nh lj b">fs</code>模块从<code class="fe nf ng nh lj b">num.txt</code>文件中读取所有的数字，然后将它们转换成一个数组。然后，我们将使用基于回调的编码方式过滤出那些偶数。</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="lu lv l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">代码2</p></figure><p id="d55d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="75dc" class="ln lo it lj b gy lp lq l lr ls">Even Numbers :  [ '102', '104', '106' ]</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="40f0" class="md lo it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">利用承诺</h1><p id="0c7f" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">从ES5开始，JavaScript就有了对承诺的原生支持，我个人觉得承诺是比回调更好的处理异步代码的方式。在回调中，我们会陷入一种叫做<em class="ni">回调地狱、</em>的东西，这真的会让我们的代码更难阅读和理解。</p><p id="e464" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">promises允许我们分别处理成功和错误，并允许我们链接多个异步调用而不是嵌套它们，这基本上防止了回调地狱，而不是将回调作为参数传递并在同一位置处理错误。</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="lu lv l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">代码3</p></figure><p id="d09a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="090a" class="ln lo it lj b gy lp lq l lr ls">Even Numbers :  [ '102', '104', '106' ]</span></pre><p id="be32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们在这里也取得了同样的结果，而且是以一种更简单的方式。</p><p id="91a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是在Node中处理异步代码的传统方式是通过回调。此外，成千上万的库是使用这种风格编写的，使用您的库的开发人员可能会认为您在他们使用您的库之前为他们提供了错误优先的回调接口。</p><p id="d678" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以更好的方法是给用户两个界面——传统的回调和新的承诺——这样他们可以两个都用，或者用他们更舒服的一个。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="94db" class="md lo it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">回电和承诺</h1><p id="05ed" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">我们要做的是将回调参数标记为可选的，这样如果用户通过了回调，他或她将被调用，并带有错误和数据。否则，一个承诺被解决或拒绝，然后我们必须处理它。</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="lu lv l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">代码4</p></figure><p id="6ec7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="3c7b" class="ln lo it lj b gy lp lq l lr ls">Even Numbers :  [ '102', '104', '106' ]<br/>Odd Numbers :  [ '101', '103', '105' ]</span></pre><p id="35a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们在函数<code class="fe nf ng nh lj b">readFileAsArray</code>中将默认值赋给回调函数，每当我们使用Promise时，我们不传递那个回调函数。然后使用默认回调函数，这对我们没有用。</p><p id="1c67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是当传递回调函数时，我们传递的值会覆盖默认的回调值。然后调用这个传递的回调函数，我们可以在回调函数中操作数据。</p><p id="2f87" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在基于承诺的呼叫中打印偶数，在基于回拨的呼叫中打印奇数。</p></div></div>    
</body>
</html>