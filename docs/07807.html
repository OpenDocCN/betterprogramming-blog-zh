<html>
<head>
<title>9 Useful Functional Programming Solutions You Can Learn (in TypeScript and Node)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您可以学习的9个有用的函数式编程解决方案(在TypeScript和Node中)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/9-useful-functional-programming-solutions-you-can-learn-with-typescript-and-node-2eab5ba097f0?source=collection_archive---------5-----------------------#2021-02-22">https://betterprogramming.pub/9-useful-functional-programming-solutions-you-can-learn-with-typescript-and-node-2eab5ba097f0?source=collection_archive---------5-----------------------#2021-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="20b0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">web开发人员易于理解的编码示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f6c3205eeb0c3222da0a6c00e2347030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-051M-qWyqkiIRUVK1dEw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@jeswinthomas?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰斯温·托马斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/math-board?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="48d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">对于葡萄牙语读者:感谢</em><a class="lw lx ep" href="https://medium.com/u/716f61682dba?source=post_page-----2eab5ba097f0--------------------------------" rel="noopener" target="_blank"><em class="lv">Alison Miazaki</em></a><em class="lv">将我的故事翻译成葡萄牙语:</em><a class="ae ky" href="https://alisonmiazaki.medium.com/9-solu%C3%A7%C3%B5es-pr%C3%A1ticas-em-programa%C3%A7%C3%A3o-funcional-para-voc%C3%AA-saber-em-typescript-e-node-b69af9ef86ea" rel="noopener"><em class="lv">9 Solu es práticas em Programa ao funcial para VOCêsaber(em TypeScript e Node)</em></a><em class="lv">。</em></p><p id="3ba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为软件开发人员，我们都经历过这种情况:我们正在编写或审查一段代码。然后不知从哪里，我们的直觉告诉我们可以进一步简化代码。或者，如果我们熟悉命令式编程，似乎有一种“函数式”方法可以解决问题。“功能性”解决方案唾手可得，但我们却无法将它写下来。</p><p id="d649" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我写这篇文章是为了帮助自己摆脱这种情况。毕竟，我们可以从任何地方获得灵感。这是一个找到正确的解决方法的提示的问题。提示越接近我们正在寻找的解决方案，效果越好。</p><p id="7249" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将按照问题的简单性来完成一系列常见的编码任务。我对Node 10使用了TypeScript来测试每个解决方案。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="e9c1" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">1.单元测试中的模仿</h1><h2 id="af2f" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">问题</h2><p id="6599" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">测试异步函数时，您希望在本地运行测试时使用模拟数据。</p><h2 id="ee28" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">非功能方法</h2><p id="a41a" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">使用一个<code class="fe no np nq nr b">if-else</code>语句来决定运行哪个函数，是异步的还是模拟的。</p><h2 id="bc49" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">功能方法</h2><p id="176c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">将异步和模拟函数赋给它们的变量。使用三元运算符根据当前环境确定使用哪个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的代码片段。</p></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="4240" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">2.A/B测试或实验</h1><h2 id="064f" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">问题</h2><p id="9c2d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">您想要显示web应用程序的两个或更多不同的变体:变体A和b。</p><h2 id="8f5a" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">非功能方法</h2><p id="9f4a" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">使用一个<code class="fe no np nq nr b">if-else</code>语句来决定显示哪个变量。</p><h2 id="d3a4" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">功能方法</h2><p id="d830" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">将显示函数分配给它们的变量。创建一个对象，将函数变量映射到它们对应的变量。使用变量作为对象键，使用函数变量作为对象值。使用对象hashmap显示变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的代码片段。</p></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="9353" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">3.对一段数据执行一系列函数</h1><h2 id="fe52" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">问题</h2><p id="75fc" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">有许多函数接受一个对象，对该对象执行一系列更新，然后返回一个更新或转换后的对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的代码片段。</p></figure><h2 id="2ede" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">非功能方法</h2><p id="c858" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">您可以逐行执行该函数。例如，用一个<code class="fe no np nq nr b">id</code>初始化一个<code class="fe no np nq nr b">employee</code>对象。然后一系列函数将更新<code class="fe no np nq nr b">employee</code>对象并返回更新后的<code class="fe no np nq nr b">employee</code>对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的代码片段。代码从第17行开始执行函数。</p></figure><p id="03d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码完成了这项工作。你一行一行地将每个函数应用到变异的<code class="fe no np nq nr b">employee</code>对象上。想象一下，如果你需要增加一个新的功能。您可以添加新的一行来调用该函数，并将<code class="fe no np nq nr b">employee</code>对象作为参数传递。不错，但我们可以做得更好。</p><h2 id="9db0" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">功能方法</h2><p id="ca66" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">函数方式是在一个数组中分配函数，使用<code class="fe no np nq nr b">forEach</code>遍历该数组，并将每个函数应用于参数。注意，在应用数组中的第一个函数后传递的<code class="fe no np nq nr b">employee</code>参数将是前一个函数的返回值。函数的使用顺序与它们在数组中的放置顺序相同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的代码片段。第17行指定了数组中的函数。</p></figure><p id="6ef5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果需要添加另一个函数来执行，则在<code class="fe no np nq nr b">personFunctionsArray</code>数组中添加另一个条目。您不需要将返回值重新分配给<code class="fe no np nq nr b">employee</code>，并将其作为参数传递给下一个函数。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="dbeb" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">4.简单计算器</h1><h2 id="aeb7" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">问题</h2><p id="af45" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">您希望实现一个接受两个数字的简单计算器。</p><h2 id="0483" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">非功能方法</h2><p id="73d0" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">面向对象的方法是创建一个包含计算操作的<code class="fe no np nq nr b">Calculator</code>类作为该类中的方法，即<code class="fe no np nq nr b">add</code>和<code class="fe no np nq nr b">subtract</code>。如果您想要添加更多的操作，您将更新该类以添加每个操作的相应方法。另一种方法是为每个操作编写单独的函数。例如，实现<code class="fe no np nq nr b">calculateSum()</code>和<code class="fe no np nq nr b">calculateDifference()</code>功能。</p><h2 id="5097" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">功能方法</h2><p id="8ae4" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">创建一个<code class="fe no np nq nr b">calculate()</code>函数，该函数接受一个操作函数(如<code class="fe no np nq nr b">add()</code>)作为参数来执行您想要的计算。计算的函数也是独立的，您可以使用它，而无需将其作为参数传递。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的代码片段。将运算函数作为参数传递给calculate函数。</p></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="e20d" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">5.转换计算器</h1><h2 id="ab02" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">问题</h2><p id="5215" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">将<code class="fe no np nq nr b">meter</code>转换成英制单位<code class="fe no np nq nr b">mile</code>、<code class="fe no np nq nr b">yard</code>、<code class="fe no np nq nr b">foot</code>、<code class="fe no np nq nr b">inch</code>。这些单位转换函数采用<code class="fe no np nq nr b">meter</code>中的值<code class="fe no np nq nr b">x</code>，并返回转换后的值，该值采用英制单位，并以其对应的符号进行格式化。</p><h2 id="961f" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">非功能方法</h2><p id="7d5c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">为每个转换写一个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的代码片段。转换从第6行开始。</p></figure><p id="a22c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，转换函数中的重复代码很明显。每个函数中的乘法和字符串格式化都是重复的。</p><h2 id="c284" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">功能方法</h2><p id="969c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">尝试通过创建一个处理不同转换的函数来解决这个问题，同时最大化行为略有不同的函数之间的代码重用。</p><p id="d22c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的<code class="fe no np nq nr b">createConverter()</code>函数接受转换值<code class="fe no np nq nr b">v</code>和符号<code class="fe no np nq nr b">s</code>参数。它返回一个采用<code class="fe no np nq nr b">x</code>参数的函数，这是您想要转换的值。</p><pre class="kj kk kl km gt nu nr nv nw aw nx bi"><span id="1e80" class="mx mg it nr b gy ny nz l oa ob">const createConverter = (v: number, s: string) =&gt; <br/> (x: number) =&gt; `${x * v} ${s}`</span></pre><p id="725e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重复使用上面的<code class="fe no np nq nr b">createConverter</code>函数，形成转换函数。</p><pre class="kj kk kl km gt nu nr nv nw aw nx bi"><span id="1c0b" class="mx mg it nr b gy ny nz l oa ob">const meterToMile = createConverter(0.0006213689, 'mi')<br/>console.log(meterToMile(1000))</span></pre><p id="8fa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您在保持代码可维护性的同时最大化了重用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="b87e" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">6.验证函数参数</h1><h2 id="9fa1" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">问题</h2><p id="70f3" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">您有一个执行减法运算的函数，给定一个<code class="fe no np nq nr b">minuend</code>和一个<code class="fe no np nq nr b">subtrahend</code>作为它的参数，并返回<code class="fe no np nq nr b">difference</code>。返回值只能是非负数。因此，您需要验证您的参数，使得<code class="fe no np nq nr b">minuend</code>应该总是大于或等于<code class="fe no np nq nr b">subtrahend</code> : <code class="fe no np nq nr b">minuend &gt;= subtrahend</code>。</p><pre class="kj kk kl km gt nu nr nv nw aw nx bi"><span id="c0de" class="mx mg it nr b gy ny nz l oa ob">const minus = (minuend: number, subtrahend: number): number =&gt; <br/>    minuend - subtrahend</span></pre><p id="78db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">据<a class="ae ky" href="https://classace.io/learn/math/3rdgrade/completing-three-digit-subtraction-equations" rel="noopener ugc nofollow" target="_blank">级高手</a>:</p><blockquote class="oc od oe"><p id="75b1" class="kz la lv lb b lc ld ju le lf lg jx lh of lj lk ll og ln lo lp oh lr ls lt lu im bi translated">-"<code class="fe no np nq nr b">minuend</code>——这是最大的数，或者说是整体，从中要拿走一部分。</p><p id="a7cd" class="kz la lv lb b lc ld ju le lf lg jx lh of lj lk ll og ln lo lp oh lr ls lt lu im bi translated">- <code class="fe no np nq nr b">subtrahend</code> —这是从<code class="fe no np nq nr b">minuend</code>上取下的零件。</p><p id="a883" class="kz la lv lb b lc ld ju le lf lg jx lh of lj lk ll og ln lo lp oh lr ls lt lu im bi translated">-差——这是减法后剩下的部分。"</p></blockquote><h2 id="59ce" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">非功能方法</h2><p id="f559" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">验证参数的典型方法是添加一个有条件的提前返回或退出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="e431" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码是有效的。然而，这个函数做的不止一件事。它不仅返回差异，还验证参数。违反了<a class="ae ky" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">固体</a>中的单一责任原则。</p><h2 id="56fd" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">功能方法</h2><p id="a51e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">首先，创建一个单独的函数来验证参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><pre class="kj kk kl km gt nu nr nv nw aw nx bi"><span id="fe73" class="mx mg it nr b gy ny nz l oa ob">const minus = (minuend: number, subtrahend: number): number =&gt; <br/>    minuend - subtrahend</span></pre><p id="59a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建调用<code class="fe no np nq nr b">minuendGreaterThanSubtrahend()</code>验证函数的<code class="fe no np nq nr b">minusPositiveDifference()</code>函数，并将<code class="fe no np nq nr b">minus()</code>函数作为其参数。然后将调用这个<code class="fe no np nq nr b">minusPositiveDifference()</code>来确保在执行减法之前首先验证您的参数。</p><pre class="kj kk kl km gt nu nr nv nw aw nx bi"><span id="c5f7" class="mx mg it nr b gy ny nz l oa ob">const minusPositiveDifference = minuendGreaterThanSubtrahend(minus)</span></pre><p id="87ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个功能在解决问题的同时都在做一件事情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的代码片段。在保持代码符合单一责任原则的同时验证参数的函数式方法。</p></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="4187" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">7.单词计数器</h1><h2 id="ae02" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">问题</h2><p id="7c0a" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">你把一串单词或一首诗赋给了一个变量。您希望计算一个单词在字符串中出现的次数。这个问题类似于拥有一个数组并想计算数组中某些元素出现的次数。</p><pre class="kj kk kl km gt nu nr nv nw aw nx bi"><span id="8a44" class="mx mg it nr b gy ny nz l oa ob">const poemInput: string = <br/>`Hold fast to dreams<br/>For if dreams die<br/>Life is a broken-winged bird<br/>That cannot fly<br/>Hold fast to dreams<br/>For when dreams go<br/>Life is a barren field<br/>Frozen with snow`.replace(/(\r\n|\n|\r)/gm, ' ').toLowerCase()</span></pre><p id="2ac3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">若要简化字符串，请用空格替换换行符，并将其转换为小写。</p><h2 id="d4ef" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">非功能方法</h2><p id="214a" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">使用散列表来记录单词出现的次数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="4875" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">功能方法</h2><p id="2139" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">使用带有<code class="fe no np nq nr b">wordCounter</code>散列表的<code class="fe no np nq nr b">reduce</code>作为累加器，使用<code class="fe no np nq nr b">word</code>作为元素进行处理。</p><p id="b4ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用spread操作符来提取<code class="fe no np nq nr b">wordCounter</code>散列表的键和值。</p><p id="5e11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用三元运算符检查单词是否已经在散列表中。如果它在hashmap中，就增加这个值。否则赋值<code class="fe no np nq nr b">1</code>，表示该词第一次出现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的代码片段。如果您已经熟悉了函数式编程，那么函数式解决方案会更简洁、更易于阅读。</p></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="8513" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">8:寻找字谜</h1><h2 id="5a4c" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">问题</h2><blockquote class="oi"><p id="2192" class="oj ok it bd ol om on oo op oq or lu dk translated">变位词是通过重新排列不同单词或短语的字母而形成的单词或短语，通常使用所有原始字母一次— <a class="ae ky" href="https://en.wikipedia.org/wiki/Anagram" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="e789" class="pw-post-body-paragraph kz la it lb b lc os ju le lf ot jx lh li ou lk ll lm ov lo lp lq ow ls lt lu im bi translated">给定一个单词，您希望从提供的单词数组中找到它的变位词。</p><p id="bdb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在注释中有一组单词及其相应的变位词。</p><pre class="kj kk kl km gt nu nr nv nw aw nx bi"><span id="4f60" class="mx mg it nr b gy ny nz l oa ob">const words: Array&lt;string&gt; = [<br/>  'rat',      // tar<br/>  'car',      // arc<br/>  'below',    // elbow<br/>  'taste',    // state<br/>  'cried',    // cider<br/>  'study',    // dusty<br/>  'thing',    // night<br/>  'chin',     // inch<br/>  'grab',     // brag<br/>  'act',      // cat<br/>  'robed',    // bored<br/>  'vase',     // save<br/>  'glean',    // angel<br/>  'desserts', // stressed<br/>]</span></pre><p id="9e9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输入可以是可能的变位词之一。</p><pre class="kj kk kl km gt nu nr nv nw aw nx bi"><span id="c754" class="mx mg it nr b gy ny nz l oa ob">const input: string = 'save'</span></pre><h2 id="f59b" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">非功能方法</h2><p id="5420" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">网上有很多这种问题的非功能性解决方案的例子，这里就不一一赘述了。</p><h2 id="9c98" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">功能方法</h2><p id="da1c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">您可以结合使用JavaScript内置的<code class="fe no np nq nr b">filter</code>和<code class="fe no np nq nr b">reduce</code>函数来解决这个问题。改变示例7中使用<code class="fe no np nq nr b">reduce</code>的同一个<code class="fe no np nq nr b">countWords</code>函数的用途，但是不是计算单词，而是计算单词中的字母。</p><pre class="kj kk kl km gt nu nr nv nw aw nx bi"><span id="a7b9" class="mx mg it nr b gy ny nz l oa ob">const countLetters = (word: Array&lt;string&gt;) =&gt;<br/>  word.reduce((letterCounter: Map&lt;string, number&gt;, letter: string) =&gt; ({<br/>    ...letterCounter,<br/>    [letter]: letterCounter[letter] ? letterCounter[letter] + 1 : 1,<br/>  }), new Map&lt;string, number&gt;());</span></pre><p id="5bf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe no np nq nr b">filter</code>功能过滤与您的<code class="fe no np nq nr b">input</code>值具有相同字母和长度的单词。</p><pre class="kj kk kl km gt nu nr nv nw aw nx bi"><span id="70df" class="mx mg it nr b gy ny nz l oa ob">const findAnagrams = (word: string, words: Array&lt;string&gt;): Array&lt;string&gt; =&gt; {<br/>  return words<br/>    .filter(entry =&gt; hasSameLetterCount(word, entry))<br/>    .filter(anagram =&gt; anagram !== word);<br/>}</span></pre><p id="9f2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的解决方案如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的代码片段。该解决方案结合使用了filter()和reduce()函数。</p></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="db79" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">9.表单验证</h1><h2 id="e76d" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">问题</h2><p id="60d0" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">您有一个接受用户输入的表单，您需要验证输入。一些简单的验证标准可以包括至少三个字符长的用户名，或者用户需要输入有效的电子邮件地址。</p><pre class="kj kk kl km gt nu nr nv nw aw nx bi"><span id="d4d9" class="mx mg it nr b gy ny nz l oa ob">const currentInputValues: Object = {<br/>  username: 'ar',<br/>  email: 'me@',<br/>}</span></pre><h2 id="35bc" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">非功能方法</h2><p id="e2fd" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">网上有很多这种问题的非功能性解决方案的例子，我就不在这里赘述了。</p><h2 id="ec02" class="mx mg it bd mh my mz dn ml na nb dp mp li nc nd mr lm ne nf mt lq ng nh mv ni bi translated">功能方法</h2><p id="edb5" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">从输入标准的hashmap开始，其中键是字段，值是输入标准的数组。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ba07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">hasMinCharacters</code>和<code class="fe no np nq nr b">hasValidEmail</code>功能检查输入并返回错误信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="4b29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe no np nq nr b">reduce</code>和<code class="fe no np nq nr b">map</code>的组合，通过根据相应的验证标准测试每个输入，积累返回的错误信息。使用<code class="fe no np nq nr b">filter</code>排除空字符串。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的代码片段。该解决方案使用reduce、map和filter。</p></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="b3dc" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结论</h1><p id="be96" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">概括一下:</p><ul class=""><li id="e571" class="ox oy it lb b lc ld lf lg li oz lm pa lq pb lu pc pd pe pf bi translated">示例1、2和3是如何将函数视为数据的好例子。</li><li id="3064" class="ox oy it lb b lc pg lf ph li pi lm pj lq pk lu pc pd pe pf bi translated">示例4展示了您可以使用函数作为参数。</li><li id="b2c9" class="ox oy it lb b lc pg lf ph li pi lm pj lq pk lu pc pd pe pf bi translated">示例5展示了您可以使用函数作为返回值。</li><li id="8a1b" class="ox oy it lb b lc pg lf ph li pi lm pj lq pk lu pc pd pe pf bi translated">示例6展示了如何使用高阶函数。</li><li id="baf4" class="ox oy it lb b lc pg lf ph li pi lm pj lq pk lu pc pd pe pf bi translated">示例7-9结合了前面的概念和内置函数，如<code class="fe no np nq nr b">map</code>、<code class="fe no np nq nr b">reduce</code>和<code class="fe no np nq nr b">filter</code>。</li></ul><p id="2b70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我并不是建议您在遇到同样的问题时，应该总是使用上面概述的功能性解决方案。有时这是偏好或编码风格的问题。如果你在写下你的解决方案之前考虑其他因素也会有所帮助，比如你现有的代码库、团队成员和编码指南。</p><p id="80ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您的函数式编程之旅到目前为止都很有趣！</p><p id="b2f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在下面找到本文中使用的代码示例:</p><div class="pl pm gp gr pn po"><a href="https://github.com/ardydedase/fp-node-ts" rel="noopener  ugc nofollow" target="_blank"><div class="pp ab fo"><div class="pq ab pr cl cj ps"><h2 class="bd iu gy z fp pt fr fs pu fu fw is bi translated">ardydedase/fp-node-ts</h2><div class="pv l"><h3 class="bd b gy z fp pt fr fs pu fu fw dk translated">在GitHub上创建一个帐户，为ardydedase/fp-node-ts开发做贡献。</h3></div><div class="pw l"><p class="bd b dl z fp pt fr fs pu fu fw dk translated">github.com</p></div></div><div class="px l"><div class="py l pz qa qb px qc ks po"/></div></div></a></div></div></div>    
</body>
</html>