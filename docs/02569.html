<html>
<head>
<title>The Power of the Composite Design Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中复合设计模式的威力</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-of-the-composite-design-pattern-in-javascript-51eef5eaaa05?source=collection_archive---------10-----------------------#2019-12-09">https://betterprogramming.pub/the-power-of-the-composite-design-pattern-in-javascript-51eef5eaaa05?source=collection_archive---------10-----------------------#2019-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5965" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用复合模式编写代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2b306d6ea820253177c8fb2c68dc050b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2yKpI-DmLmNlSi2SdAZGww.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿尔瓦罗·雷耶斯在<a class="ae ky" href="https://unsplash.com/s/photos/design?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7ca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将讨论JavaScript中的<em class="lv">复合设计模式</em>。</p><p id="f251" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在软件工程中，复合模式是这样一种模式，在这种模式中，一组对象将被当作单个对象的单个实例来对待，从而导致这些对象和组合的一致性。</p><p id="0a2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复合的目的是<em class="lv">将</em>多个对象组合成某个<a class="ae ky" href="https://en.wikipedia.org/wiki/Tree_structure" rel="noopener ugc nofollow" target="_blank">树形结构</a>。这个树形结构代表一个<em class="lv">部分-整体层次</em>。</p><p id="0798" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更详细地理解复合图案，我们必须理解什么是部分-整体，以及从视觉角度看它是什么样子。</p><p id="9466" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用术语来说，部分-整体关系基本上是集合中的每个对象是<em class="lv">整体</em>组合的<em class="lv">部分</em>。这个<em class="lv">整体</em>组成是<em class="lv">部分</em>的集合。</p><p id="f025" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们想到部分-整体<em class="lv">层次</em>时，它是一个树形结构，其中每个<em class="lv">个体的</em>叶子或“节点”被视为与树中的其他叶子或节点相同。这意味着一组或一组对象(叶子/节点的子树)也是一个叶子或节点。</p><p id="08ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从视觉的角度来看，这样的一个例子可能看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/6a0ccb90b6d868dddc51c5ae5bad66ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/0*mT3qvb1u7KxJmjPY.jpg"/></div></figure><p id="5ca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们对部分-整体的概念有了更清晰的理解，让我们回到术语<em class="lv">复合</em>。我们说过复合的目的是将这些对象(叶子/节点)组合成一棵树，代表这个概念。</p><p id="d600" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，复合设计模式是集合<em class="lv">中的每一项都可以容纳其他集合</em>本身，使它们能够创建深度嵌套的结构。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="a1a0" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">解剖学</h1><p id="23df" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">树结构中的每个节点共享一组公共的属性和方法，这使它们能够支持单个对象，并将它们视为对象集合。</p><p id="e47d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该接口促进了递归算法的构造和设计，并迭代复合集合中的每个对象。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="292e" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">谁使用该模式？</h1><p id="f557" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">操作系统使用这种模式，这反过来又导致了一些有用的特性，比如允许我们在其他目录中创建目录。</p><p id="1151" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件(此时我们可以将目录中的任何东西称为“项目”，这更有意义)是整个组合(目录)的叶/节点(部分)。</p><p id="c07c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个目录中创建一个子目录也是一个叶子/节点，包括其他项目，如视频、图像等。然而，目录或子目录也是一个组合，因为它也是部分(对象/文件/等)的集合。).</p><p id="b70e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像React和<a class="ae ky" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue </a>这样的流行库广泛使用复合模式来构建健壮的、可重用的接口。你在网页上看到的一切都被表示为一个<em class="lv">组件</em>。</p><p id="6f9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网页的每个组件都是树的一片叶子，并且可以将多个组件组合在一起以创建新的叶子。(当这种情况发生时，它是一个<em class="lv">复合</em>，但它仍然是树的一片叶子)。</p><p id="1e15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个强大的概念，因为它有助于使库的消费者更容易开发，此外还使构建利用许多对象的可伸缩应用程序变得非常方便。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="4c4e" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">我们为什么要关心这种模式？</h1><p id="c950" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">最简单的说法:<em class="lv">因为强大。</em></p><p id="3d4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复合设计模式之所以如此强大，是因为它能够将一个对象视为复合对象。这是可能的，因为它们都共享一个公共接口。</p><p id="af31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着您可以重用对象，而不用担心与其他对象不兼容。</p><p id="803d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你开发一个应用程序时，你会遇到这样的情况:你处理的对象是一个树形结构，在你的代码中采用这种模式是一个非常好的决定。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="3bb8" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">例子</h1><p id="1424" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">假设我们正在为一项新业务构建一个应用程序，其主要目的是帮助医生获得远程医疗平台的资格。他们通过为法律要求的强制性文件收集签名来做到这一点。</p><p id="32d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将有一个<code class="fe nb nc nd ne b">Document</code>类，它将有一个默认值为<code class="fe nb nc nd ne b">false</code>的<code class="fe nb nc nd ne b">signature</code>属性。如果医生签署了文档，<code class="fe nb nc nd ne b">signature</code>应该将其值翻转到他们的签名。</p><p id="428f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还定义了一个<code class="fe nb nc nd ne b">sign</code>方法来帮助实现这个功能。</p><p id="9bb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是<code class="fe nb nc nd ne b">Document</code>的外观:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="07b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们实现复合模式时，我们将支持类似于a <code class="fe nb nc nd ne b">Document</code>定义的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="682d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这种模式的美妙之处来了。请注意我们最近的两个代码片段。让我们从视觉角度来看这个问题:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/68adb4c23ad9a87e6c92b5f613514215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d7QFPYl5k8H51ZLX.jpg"/></div></div></figure><p id="bdf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！看起来我们走在正确的道路上。我们之所以知道这一点，是因为我们所拥有的与之前的图表相似:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/59c3f32d47943a1a1b2bd37e09de442e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/0*h0xa0QuJ2r17Qvza.jpg"/></div></figure><p id="b266" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们的树结构包含两个叶子/节点，即<code class="fe nb nc nd ne b">Document</code>和<code class="fe nb nc nd ne b">DocumentComposite</code>。它们共享相同的接口，因此它们都充当整个复合树的“部分”。</p><p id="9b1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的事情是树的一个叶子/节点不是<em class="lv">复合的(T2)是<em class="lv">而不是</em>一个对象的集合或组，所以它将在那里停止。</em></p><p id="db7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<em class="lv">是</em>组合的叶子/节点持有一组部分(在我们的例子中是<code class="fe nb nc nd ne b">items</code>)。记住，<code class="fe nb nc nd ne b">Document</code>和<code class="fe nb nc nd ne b">DocumentComposite</code>共享一个接口，共享<code class="fe nb nc nd ne b">sign</code>方法。</p><p id="bd35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，这其中的力量在哪里呢？</p><p id="af06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，尽管<code class="fe nb nc nd ne b">DocumentComposite</code>共享相同的接口，因为它有一个<code class="fe nb nc nd ne b">sign</code>方法，就像<code class="fe nb nc nd ne b">Document</code>一样，但它实际上实现了一个更健壮的方法，同时仍然保持了最终目标。</p><p id="a1b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，不要这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以改变我们的代码，使之更健壮，利用复合的优势:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="da38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在复合方法中，在我们添加了我们需要的文档后，我们只需要<code class="fe nb nc nd ne b">sign</code>一次，它就会签署所有的文档。</p><p id="aeb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过查看<code class="fe nb nc nd ne b">console.log(forms)</code>的结果来确认这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/3cbb244b7edf9a1e45a007a92b214bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_k3i6YN8kz1DnCzD.jpg"/></div></div></figure><p id="28eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在之前的例子中，我们必须手动将项目添加到一个数组中，自己循环遍历每个文档，然后<code class="fe nb nc nd ne b">sign</code>它们。</p><p id="867a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们也不要忘记我们的<code class="fe nb nc nd ne b">DocumentComposite</code>可以保存一系列物品的事实。</p><p id="3317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，当我们这样做的时候:</p><pre class="kj kk kl km gt nk ne nl nm aw nn bi"><span id="598c" class="no mf it ne b gy np nq l nr ns">forms.add(pr2Form) <em class="lv">// Document</em><br/>forms.add(w2Form) <em class="lv">// Document</em></span></pre><p id="f935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的图表变成了这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/59c37fe0205422288e423487e576dbc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PO-cfB6ylccZQcFc.jpg"/></div></div></figure><p id="23f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与我们添加两个表单时的原始图表非常相似:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/948afd79edfcfb5241efe9a05e9688fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/0*ZItk4w96CJeKPOdZ.jpg"/></div></figure><p id="6a2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们的树停止了，因为树的最后一片叶子只渲染了两片叶子，这与最后一张截图并不完全相同。如果我们将<code class="fe nb nc nd ne b">w2form</code>合成，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="576c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们的树会继续生长:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/2de0a3de7bdb8992b5e24edeac74a66e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/0*SdTkYpaHApwAi6bx.jpg"/></div></figure><p id="ef3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们仍然实现了同样的目标，即我们需要签署强制性文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/3e2d82dc0cfe3ea711ffd1d7fb3ca691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/0*KLwcgUolGbgix3pe.jpg"/></div></figure><p id="cb1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是复合模式的力量。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="de29" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">结论</h1><p id="151c" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">这篇文章到此结束！我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>