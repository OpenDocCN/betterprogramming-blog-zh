<html>
<head>
<title>Creating Python Models From SQL Tables With Regex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Regex从SQL表创建Python模型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-python-models-from-sql-tables-with-regex-1e1bfd95ece6?source=collection_archive---------4-----------------------#2022-11-21">https://betterprogramming.pub/creating-python-models-from-sql-tables-with-regex-1e1bfd95ece6?source=collection_archive---------4-----------------------#2022-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9686" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从SQL表写几十个Python模型？你总是可以使用正则表达式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/84566aaa0684cc40b323ef7fd990bfa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDifGuphvWOtTSTzgBa36w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk">Photo by 李进: <a class="ae kv" href="https://www.pexels.com/photo/low-angle-photography-of-gray-spiral-building-3172740/" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com/photo/low-angle-photography-of-gray-spiral-building-3172740/</a></p></figure><p id="2a4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将回顾读取SQL文件的步骤，并将所有的<code class="fe ls lt lu lv b">CREATE TABLE</code>语句与一个非常简单的正则表达式模式进行匹配，然后从所述表中编写Python类/模型的字符串。最终代码<a class="ae kv" href="https://github.com/AlbertoV5/psql-to-models" rel="noopener ugc nofollow" target="_blank">在这里。</a></p><p id="f0d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，在这个练习中，我们将使用Python 3.10。这些结果设计用于FastAPI 0.86.0、SQLAlchemy 1.4和Pydantic 1.10。我们也在遵循<a class="ae kv" href="https://github.com/faraday-academy/fast-api-lms" rel="noopener ugc nofollow" target="_blank">这种</a>风格的FastAPI，我们使用的是PostgreSQL 14.5。</p><p id="4c53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将使用<a class="ae kv" href="https://github.com/MIT-LCP/mimic-code/blob/main/mimic-iii/buildmimic/postgres/postgres_create_tables.sql" rel="noopener ugc nofollow" target="_blank"> this </a> SQL模式作为我们的用例，因此我们希望将所有26个没有分区的表转换为SQLAlchemy/Pydantic模型。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="03ff" class="ma mb iq lv b be mc md l me mf">python --version</span></pre><pre class="mg lw lv lx bn ly lz bi"><span id="33a8" class="ma mb iq lv b be mc md l mh mf">Python 3.10.7</span></pre><h1 id="c341" class="mi mb iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">从main开始</h1><p id="88fd" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">这将是一个回顾性的过程，所以我们将从主要功能开始，然后从那里往下。</p><p id="3bab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们想读取一个<code class="fe ls lt lu lv b">.sql</code>文件，然后输出2。py文件，一个用于SQLAlchemy模型，另一个用于Pydantic模型，其中包括模式匹配和字符串处理。一旦我们有了实现细节，我们将回到主函数，但是现在，让我们从头开始看一下。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="75d0" class="ma mb iq lv b be mc md l me mf">def main(argv: Arguments):<br/>    """Read .sql file with CREATE TABLE queries and store models"""<br/>    with open(Path(argv.input).resolve()) as file:<br/>        sql_string = file.read()<br/>    # Match pattern<br/>    pattern = r"(?:CREATE TABLE )((.|\n*?));"<br/>    tables: list[Table] = [<br/>        Table.from_string(table[0]) for table in re.findall(patterb, sql_string)<br/>    ]<br/>    # String processing<br/>    alchemy_data = ALCHEMY_HEADER<br/>    pydantic_data = PYDANTIC_HEADER<br/>    for model, pydantic in generate_strings(tables):<br/>        alchemy_data += model<br/>        pydantic_data += pydantic<br/>    # Output<br/>    with open(Path(argv.alchemy).resolve(), "w") as file:<br/>        file.write(alchemy_data)<br/>    with open(Path(argv.pydantic).resolve(), "w") as file:<br/>        file.write(pydantic_data)</span></pre><p id="2453" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正则表达式模式说:“查找CREATE TABLE，但不包括它”，然后“包括由任何东西或换行符组成的任何数量的子组”，然后“以非贪婪的方式重复该子组任何次数”，以及“以分号结束”。非贪婪部分意味着它将匹配尽可能少的重复，所以我们停在“；”。</p><p id="277a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们已经有了大致的了解，我们可以进入具体的方法、类和常量。</p><h1 id="905e" class="mi mb iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">标题常量</h1><p id="b68e" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我们正在生成依赖于其他库的python文件，因此我们将创建与我们当前用例的导入相匹配的字符串。我们需要SQLAlchemy类型以及Alchemy文件的<code class="fe ls lt lu lv b">declarative base</code>,以及Pydantic文件的Pydantic BaseModel和datetime类型。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="5629" class="ma mb iq lv b be mc md l me mf">ALCHEMY_HEADER = '''"""<br/>SQLAlchemy Models<br/>"""<br/>from sqlalchemy import Column, Integer, String, CHAR, TIMESTAMP, SmallInteger<br/>from sqlalchemy.dialects.postgresql import DOUBLE_PRECISION<br/>from db.setup import Base<br/>'''<br/><br/>PYDANTIC_HEADER = '''"""<br/>Pydantic Models<br/>"""<br/>from pydantic import BaseModel<br/>from datetime import datetime<br/>'''</span></pre><h1 id="3524" class="mi mb iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">助手功能</h1><p id="fc3e" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">回想我们的主过程，编写输出文件之前的最后一步是使用<code class="fe ls lt lu lv b">generate_strings</code>函数创建两个模型字符串。这个函数将遍历一个表对象列表，这些表对象表示我们之前通过Regex匹配的每个SQL表字符串，然后调用创建模型字符串的方法(用Python语法)并将它们交给主过程。我们使用<code class="fe ls lt lu lv b">is_valid</code>函数作为正则表达式模式的“拐杖”,因为我们不介意匹配所有的表，然后过滤掉不需要的表。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="6cf5" class="ma mb iq lv b be mc md l me mf">BANNED_TABLES = ["chartevents_"]<br/><br/>def is_valid(table: Table) -&gt; bool:<br/>    """Whether table is not in banned tables."""<br/>    for banned in BANNED_TABLES:<br/>        if banned in table.name:<br/>            return False<br/>    return True<br/><br/><br/>def generate_strings(tables: list[Table]) -&gt; Generator[tuple[str, str], None, None]:<br/>    """Yields SQLAlchemy and Pydantic Models as strings for each table."""<br/>    for table in tables:<br/>        table.get_constraints()<br/>        alchemy = f"\n{table.make_alchemy()}" if is_valid(table) else ""<br/>        pydantic = f"\n{table.make_pydantic()}" if is_valid(table) else ""<br/>        yield alchemy, pydantic</span></pre><h1 id="cb20" class="mi mb iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">总管的顶部和底部</h1><p id="4097" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在查看“Table”类的实现之前，我们将在main函数和参数解析器中包含导入，以便向主文件添加上下文。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="9c1e" class="ma mb iq lv b be mc md l me mf">from typing import Generator, Protocol<br/>from argparse import ArgumentParser<br/>from pathlib import Path<br/>import re<br/><br/>from .table import Table<br/><br/><br/>class Arguments(Protocol):<br/>    input: str<br/>    alchemy: str<br/>    pydantic: str</span></pre><p id="96a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的论点是文件的位置。这个文件的名字是<code class="fe ls lt lu lv b">__main__.py</code>，因为我们使用这个工具作为一个模块，我们可以从命令行调用。更多信息请点击这里:<a class="ae kv" href="https://github.com/AlbertoV5/psql-to-models" rel="noopener ugc nofollow" target="_blank">https://github.com/AlbertoV5/psql-to-models</a></p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="7c7d" class="ma mb iq lv b be mc md l me mf">if __name__ == "__main__":<br/>    default_sql_input = "./schema.sql"<br/>    default_alchemy_output = "./models_alchemy.py"<br/>    default_pydantic_output = "./models_pydantic.py"<br/>    args = ArgumentParser(<br/>        prog="Convert PostgreSQL schema to SQLAlchemy and Pydantic Models.",<br/>        usage=f"python -m psql-to-models",<br/>        description="Regex-match the .sql schema file and outputs SQLAlchemy and Pydantic models as .py files.",<br/>    )<br/>    args.add_argument(<br/>        "-i",<br/>        "--input",<br/>        metavar="input",<br/>        default=f"{default_sql_input}",<br/>        help=f"PostgreSQL Schema input file. Defaults to {default_sql_input}.",<br/>    )<br/>    args.add_argument(<br/>        "-a",<br/>        "--alchemy",<br/>        metavar="output_alchemy",<br/>        default=f"{default_alchemy_output}",<br/>        help=f"SQLAlchemy Models output. Defaults to {default_alchemy_output}",<br/>    )<br/>    args.add_argument(<br/>        "-p",<br/>        "--pydantic",<br/>        metavar="output_pydantic",<br/>        default=f"{default_pydantic_output}",<br/>        help=f"Pydantic Models output. Defaults to {default_pydantic_output}",<br/>    )<br/>    main(args.parse_args())</span></pre><h1 id="b3bc" class="mi mb iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">表格类</h1><p id="475c" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">现在我们已经有了程序的整体逻辑，我们将转到“Table”类，它表示整个SQL表语句，并具有处理它和创建模型字符串的方法。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="5a50" class="ma mb iq lv b be mc md l me mf">"""<br/>Table representation and processor.<br/>Call any get_* functions before calling make_* functions.<br/>"""<br/>from dataclasses import dataclass<br/>from .column import Column<br/><br/><br/>@dataclass<br/>class Table:<br/>    name: str<br/>    columns: list[Column]<br/><br/>    @classmethod<br/>    def from_string(cls, table: str) -&gt; "Table":<br/>        """Create Table from string."""<br/>        data = table.split("\n")<br/>        return Table(<br/>            name=data[0], columns=[Column.from_string(col) for col in data[2:-1]]<br/>        )<br/><br/>    def get_constraints(self) -&gt; None:<br/>        """Use the CONSTRAINT columns to modify the rest of the columns."""<br/>        constraints = [col.params for col in self.columns if col.name == "CONSTRAINT"]<br/>        data = [c.replace(")", "").split("(") for c in constraints]<br/>        data = {k.strip(): v.strip() for v, k in data}<br/>        for column in self.columns:<br/>            for k in data:<br/>                if column.name == k:<br/>                    column.primary_key = (<br/>                        "primary_key=True" if data[k] == "PRIMARY KEY" else ""<br/>                    )<br/>                    column.unique = "unique=True" if data[k] == "UNIQUE" else ""<br/><br/>    def make_alchemy(self) -&gt; str:<br/>        """Make SQLAlchemy model string from this Table."""<br/>        cols = "\n    ".join(<br/>            col.make_alchemy_column()<br/>            for col in self.columns<br/>            if col.name != "CONSTRAINT"<br/>        )<br/>        return (<br/>            f"class {self.name.capitalize()}(Base):\n\n"<br/>            f'    __tablename__ = "{self.name.lower()}"\n\n'<br/>            f"    {cols}\n\n"<br/>        )<br/><br/>    def make_pydantic(self) -&gt; str:<br/>        """Make Pydantic model string from this Table."""<br/>        params = "\n    ".join(<br/>            col.make_pydantic_column()<br/>            for col in self.columns<br/>            if col.name != "CONSTRAINT"<br/>        )<br/>        return (<br/>            f"class {self.name.capitalize()}(BaseModel):\n\n"<br/>            f"    {params}\n\n"<br/>            f"    class Config:\n"<br/>            f"        orm_mode = True\n\n"<br/>        )</span></pre><p id="3c97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们要使用的构造函数是一个类方法。我们可以选择一个post-init进程，或者我们可以将它创建为一个外部工厂函数，但是为了方便起见，我们选择将它保留为Table类的一部分。Table类的设计是将处理分成处理列列表中信息的<code class="fe ls lt lu lv b">get</code>方法和将列数据转换成字符串的<code class="fe ls lt lu lv b">make</code>方法。</p><p id="dcdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Column类类似于Table，但是专门解析列的SQL语句(“column_name INT NOT NULL”)，并且它具有为模型的属性创建字符串的方法。</p><p id="d3c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用<code class="fe ls lt lu lv b">get_constraints</code>在列列表中查找<code class="fe ls lt lu lv b">CONSTRAINT</code> SQL语句，然后修改实际列的属性，这包括<code class="fe ls lt lu lv b">primary_key</code> <strong class="ky ir"> </strong>属性、<code class="fe ls lt lu lv b">unique</code>属性等。</p><h1 id="8e6d" class="mi mb iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">列类</h1><p id="83bb" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我们需要将单个SQL语句拆分成不同的属性，我们可以用它们来描述名称或类型，以及表达约束，比如在SQLAlchemy中将unique表示为“UNIQUE ”,或者在Pydantic中将NOT NULL表示为“optional”。</p><p id="7cc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个类可以命名为“Statement ”,因为它包括任何其他可能不是“column”的SQL语句，但是我们在表级别对它们进行归纳和过滤。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="fba5" class="ma mb iq lv b be mc md l me mf">"""<br/>Column representation and processor.<br/>"""<br/>from dataclasses import dataclass<br/>from .types import TYPE_LOOKUP<br/><br/><br/>@dataclass<br/>class Column:<br/>    name: str<br/>    type: str<br/>    params: str<br/>    primary_key: str = ""<br/>    unique: str = ""<br/><br/>    @classmethod<br/>    def from_string(cls, col: str) -&gt; "Column":<br/>        """Create column from string."""<br/>        data = col.strip().replace(",", "").split(" ", maxsplit=2)<br/>        return Column(<br/>            name=data[0], type=data[1], params=data[2] if len(data) &gt; 2 else ""<br/>        )<br/><br/>    def get_type(self, sqlalchemy: bool = True) -&gt; str:<br/>        """<br/>        Lookup types and return either SQLAlchemy's or Pydantic's.<br/>        """<br/>        t = self.type.replace(")", "").split("(")<br/>        index = 0 if sqlalchemy else 1<br/>        if len(t) &gt; 1:<br/>            return (<br/>                f"{TYPE_LOOKUP[t[0]][index]}({t[1]})"<br/>                if sqlalchemy<br/>                else TYPE_LOOKUP[t[0]][index]<br/>            )<br/>        return TYPE_LOOKUP[self.type][index]<br/><br/>    def make_alchemy_column(self) -&gt; str:<br/>        """Make SQLAlchemy Model column string."""<br/>        return (<br/>            f"{self.name.lower()} = Column("<br/>            f"{self.get_type()}"<br/>            f"{', nullable=False' if 'NOT NULL' in self.params else ''}"<br/>            f"{'' if self.primary_key == '' else f', {self.primary_key}'}"<br/>            f"{'' if self.unique == '' else f', {self.unique}'}"<br/>            f")"<br/>        )<br/><br/>    def make_pydantic_column(self) -&gt; str:<br/>        """Make Pydantic Model column string."""<br/>        return (<br/>            f"{self.name.lower()}: "<br/>            f"{self.get_type(sqlalchemy=False)}"<br/>            f"{'' if 'NOT NULL' in self.params else ' | None'}"<br/>        )</span></pre><p id="08be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们重复了“类方法作为构造函数”模式以及Table类中的<strong class="ky ir"> </strong> <code class="fe ls lt lu lv b">get</code>然后<strong class="ky ir"> </strong> <code class="fe ls lt lu lv b">make</code> <strong class="ky ir"> </strong>模式，但这次我们包括了<code class="fe ls lt lu lv b">TYPE_LOOKUP</code>常量，它将帮助我们将SQL类型“翻译”成我们感兴趣的其他类型。</p><p id="4123" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，可选模式被转换为“新的”Python 3.10语法，因此应该对其进行修改，以支持以前Python版本的“可选或联合”。</p><h1 id="2db6" class="mi mb iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">类型查找表</h1><p id="4b74" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated"><code class="fe ls lt lu lv b">TYPE_LOOKUP</code>字典将作为一个查找表，我们可以在其中找到每种SQL类型的Python等价体(在本例中是PostgreSQL ),并保存在它自己的<code class="fe ls lt lu lv b">types.py</code>文件中。</p><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="a0d5" class="ma mb iq lv b be mc md l me mf">"""Define constants for type lookup."""<br/><br/>TYPE_LOOKUP: dict[str, tuple[str, str]] = {<br/>    "INT": ("Integer", "int"),<br/>    "SMALLINT": ("SmallInteger", "int"),<br/>    "VARCHAR": ("String", "str"),<br/>    "TIMESTAMP": ("TIMESTAMP", "datetime"),<br/>    "DOUBLE": ("DOUBLE_PRECISION", "float"),<br/>    "CHAR": ("CHAR", "str"),<br/>    "TEXT": ("String", "str"),<br/>}<br/>"""Values are tuples of SQLAlchemy Model Type and Pydantic/Python Type."""</span></pre><p id="f355" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这迫使我们使用元组而不是新级别的键来访问每个值，因为我们假设我们将只对两个目标模型使用该工具，另外任何其他模型都可以通过扩展元组来简单地包含。</p><h1 id="f7f2" class="mi mb iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">返回主页</h1><p id="06ed" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">现在我们已经了解了处理字符串的方法，我们可以回过头来回顾一下主过程。它可以概括为:</p><ol class=""><li id="e76f" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">匹配正则表达式模式。</li><li id="16d6" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">用我们的数据类存储和处理字符串。</li><li id="8059" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">创建一个新的“Python字符串”, Python理解为SQLAlchemy和Pydantic模型。</li></ol><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="acd0" class="ma mb iq lv b be mc md l me mf"># Pattern Matching<br/>pattern = r"(?:CREATE TABLE )((.|\n)*?);"<br/>tables: list[Table] = [<br/>    Table.from_string(table[0]) for table in re.findall(pattern, sql_string)<br/>]<br/># String Processing<br/>alchemy_data = ALCHEMY_HEADER<br/>pydantic_data = PYDANTIC_HEADER<br/>for model, pydantic in generate_strings(tables):<br/>    alchemy_data += model<br/>    pydantic_data += pydantic</span></pre><p id="8c60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在每一个用例中，我们需要改变的值是标题常量和我们的<code class="fe ls lt lu lv b">LOOKUP_TYPE</code>字典，因为根据项目的性质，我们可能有不同的列集和需求。</p><p id="3c06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的情况下，这个工具解决了我当时面临的问题，所以我让它保持现在的样子，并分享它，目的是在未来回到它身边，并激励任何其他用户可能会发现它对适应他们的需求很有用，所以你去吧，我希望这是有用的。</p><h1 id="d6d6" class="mi mb iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">结果</h1><p id="803b" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">您可以在这里找到这个用例<a class="ae kv" href="https://github.com/AlbertoV5/psql-to-models/tree/main/example" rel="noopener ugc nofollow" target="_blank">的结果。</a></p><p id="9104" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是预览:</p><h2 id="6559" class="ns mb iq bd mj nt nu dn mn nv nw dp mr lf nx ny mt lj nz oa mv ln ob oc mx od bi translated">SQL文件</h2><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="8182" class="ma mb iq lv b be mc md l me mf">CREATE TABLE DATETIMEEVENTS<br/>(<br/>  ROW_ID INT NOT NULL,<br/> SUBJECT_ID INT NOT NULL,<br/> HADM_ID INT,<br/> ICUSTAY_ID INT,<br/> ITEMID INT NOT NULL,<br/> CHARTTIME TIMESTAMP(0) NOT NULL,<br/> STORETIME TIMESTAMP(0) NOT NULL,<br/> CGID INT NOT NULL,<br/> VALUE TIMESTAMP(0),<br/> VALUEUOM VARCHAR(50) NOT NULL,<br/> WARNING SMALLINT,<br/> ERROR SMALLINT,<br/> RESULTSTATUS VARCHAR(50),<br/> STOPPED VARCHAR(50),<br/> CONSTRAINT datetime_rowid_pk PRIMARY KEY (ROW_ID)<br/>) ;<br/><br/>DROP TABLE IF EXISTS DIAGNOSES_ICD CASCADE;<br/>CREATE TABLE DIAGNOSES_ICD<br/>(<br/>  ROW_ID INT NOT NULL,<br/> SUBJECT_ID INT NOT NULL,<br/> HADM_ID INT NOT NULL,<br/> SEQ_NUM INT,<br/> ICD9_CODE VARCHAR(10),<br/> CONSTRAINT diagnosesicd_rowid_pk PRIMARY KEY (ROW_ID)<br/>) ;</span></pre><h2 id="4ff6" class="ns mb iq bd mj nt nu dn mn nv nw dp mr lf nx ny mt lj nz oa mv ln ob oc mx od bi translated">SQLAlchemy模型</h2><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="b01f" class="ma mb iq lv b be mc md l me mf">class Datetimeevents(Base):<br/><br/>    __tablename__ = "datetimeevents"<br/><br/>    row_id = Column(Integer, nullable=False, primary_key=True)<br/>    subject_id = Column(Integer, nullable=False)<br/>    hadm_id = Column(Integer)<br/>    icustay_id = Column(Integer)<br/>    itemid = Column(Integer, nullable=False)<br/>    charttime = Column(TIMESTAMP(0), nullable=False)<br/>    storetime = Column(TIMESTAMP(0), nullable=False)<br/>    cgid = Column(Integer, nullable=False)<br/>    value = Column(TIMESTAMP(0))<br/>    valueuom = Column(String(50), nullable=False)<br/>    warning = Column(SmallInteger)<br/>    error = Column(SmallInteger)<br/>    resultstatus = Column(String(50))<br/>    stopped = Column(String(50))<br/><br/><br/>class Diagnoses_icd(Base):<br/><br/>    __tablename__ = "diagnoses_icd"<br/><br/>    row_id = Column(Integer, nullable=False, primary_key=True)<br/>    subject_id = Column(Integer, nullable=False)<br/>    hadm_id = Column(Integer, nullable=False)<br/>    seq_num = Column(Integer)<br/>    icd9_code = Column(String(10))</span></pre><h2 id="17ca" class="ns mb iq bd mj nt nu dn mn nv nw dp mr lf nx ny mt lj nz oa mv ln ob oc mx od bi translated">Pydantic模型</h2><pre class="kg kh ki kj gt lw lv lx bn ly lz bi"><span id="ec77" class="ma mb iq lv b be mc md l me mf">class Datetimeevents(BaseModel):<br/><br/>    row_id: int<br/>    subject_id: int<br/>    hadm_id: int | None<br/>    icustay_id: int | None<br/>    itemid: int<br/>    charttime: datetime<br/>    storetime: datetime<br/>    cgid: int<br/>    value: datetime | None<br/>    valueuom: str<br/>    warning: int | None<br/>    error: int | None<br/>    resultstatus: str | None<br/>    stopped: str | None<br/><br/>    class Config:<br/>        orm_mode = True<br/><br/><br/>class Diagnoses_icd(BaseModel):<br/><br/>    row_id: int<br/>    subject_id: int<br/>    hadm_id: int<br/>    seq_num: int | None<br/>    icd9_code: str | None<br/><br/>    class Config:<br/>        orm_mode = True</span></pre><h1 id="4fd2" class="mi mb iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">脚注</h1><p id="6b13" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated"><a class="ae kv" href="https://stackoverflow.com/questions/766372/python-non-greedy-regexes" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/766372/python-non-greedy-regexes</a></p><p id="6b40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://docs.sqlalchemy.org/en/14/orm/mapping_styles.html#orm-declarative-mapping" rel="noopener ugc nofollow" target="_blank">https://docs . sqlalchemy . org/en/14/ORM/mapping _ styles . html # ORM-declarative-mapping</a></p><p id="562f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://pydantic-docs.helpmanual.io/usage/models/" rel="noopener ugc nofollow" target="_blank">https://pydantic-docs.helpmanual.io/usage/models/</a></p><p id="3f63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://docs.python.org/3/library/dataclasses.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/dataclasses.html</a></p><p id="ca59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">【https://docs.python.org/3/library/typing.html#typing. T2】可选</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="b8dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">【https://github.com】最初发表于<a class="ae kv" href="https://github.com/AlbertoV5/python-blog/blob/main/static/sql-converter.md" rel="noopener ugc nofollow" target="_blank"><em class="ol"/></a><em class="ol">。</em></p></div></div>    
</body>
</html>