<html>
<head>
<title>An Alternative to Outbox Pattern for Microservices Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务架构发件箱模式的替代方案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-alternative-to-outbox-pattern-7564562843ae?source=collection_archive---------2-----------------------#2022-04-11">https://betterprogramming.pub/an-alternative-to-outbox-pattern-7564562843ae?source=collection_archive---------2-----------------------#2022-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f29b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">满足两阶段信息</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b3fc75669c56cf17cd19ab5042a5cd1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V5MhqWGyIYg_BLv_"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">摄</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="b13c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文提出了发件箱的另一种模式:两阶段消息。它不是基于消息队列，而是基于<a class="ae kv" href="https://github.com/dtm-labs/dtm" rel="noopener ugc nofollow" target="_blank">github.com/dtm-labs/dtm</a>，一个高度可用的分布式事务框架。</p><p id="a305" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">银行间转账是典型的分布式交易场景，其中A需要通过银行向B转账。A和B的余额不在同一家银行，因此它们不存储在单个数据库中。这种转移通常也会跨越微服务。</p><p id="6c63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">主要问题是转移必须同时更新两个系统——A’余额的增加和B’余额的减少。这被称为众所周知的“双重写入”。两次更新之间的进程崩溃会使整个系统处于不一致的状态。</p><p id="02c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个“双重写入”问题可以通过发件箱模式来解决。发件箱模式的原理可以在这里找到:<a class="ae kv" href="https://microservices.io/patterns/data/transactional-outbox.html" rel="noopener ugc nofollow" target="_blank">事务型发件箱</a></p><h1 id="7f25" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">两阶段消息</h1><p id="7f96" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，让我们看一下如何使用新模式完成上述传输任务。以下代码在Go中，其他语言如C#，PHP可以在这里找到:<a class="ae kv" href="https://en.dtm.pub/ref/sdk.html" rel="noopener ugc nofollow" target="_blank">DTM SDK</a></p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="6536" class="mu lt iq mq b gy mv mw l mx my">msg := dtmcli.NewMsg(DtmServer, gid).<br/>	Add(busi.Busi+"/TransIn", &amp;TransReq{Amount: 30})<br/>err := msg.DoAndSubmitDB(busi.Busi+"/QueryPrepared", db, func(tx *sql.Tx) error {<br/>	return AdjustBalance(tx, busi.TransOutUID, -req.Amount)<br/>})</span></pre><p id="6e54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中:</p><ul class=""><li id="7073" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">第一个新的DTM <code class="fe ni nj nk mq b">msg</code>全局事务，传递DTM服务器地址和全局事务id</li><li id="1bec" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated">向<code class="fe ni nj nk mq b">msg</code>添加一个分支业务，即转账操作TransIn，以及需要传递给该服务的数据，金额为30美元</li><li id="d025" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated">然后调用<code class="fe ni nj nk mq b">msg</code>的DoAndSubmitDB。该功能将确保<code class="fe ni nj nk mq b">msg</code>的业务和提交的原子执行，要么都成功，要么都失败。该功能有三个参数:</li></ul><ol class=""><li id="7de3" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr nq nf ng nh bi translated">稍后将解释检查返回URL</li><li id="2b70" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr nq nf ng nh bi translated">DB是业务的数据库对象</li><li id="1caa" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr nq nf ng nh bi translated">在我们的例子中，业务功能是为A的余额借记30美元</li></ol><p id="59f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当A的余额递减成功后进程立即崩溃会发生什么？超时之后，DTM将调用检查返回URL来查询递减是成功还是不成功。我们可以通过粘贴以下代码来完成检查返回服务:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="1819" class="mu lt iq mq b gy mv mw l mx my">app.GET(BusiAPI+"/QueryPrepared", dtmutil.WrapHandler2(func(c *gin.Context) interface{} {<br/>		return MustBarrierFromGin(c).QueryPrepared(db)<br/>	}))</span></pre><p id="1b0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">写完这两段代码后，一个2阶段消息就完成了，比发件箱更容易使用。</p><h1 id="d474" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">运行它</h1><p id="79d6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您可以通过运行以下命令来运行上面的示例。</p><h2 id="420f" class="mu lt iq bd lu nr ns dn ly nt nu dp mc lf nv nw me lj nx ny mg ln nz oa mi ob bi translated">运行DTM</h2><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3d87" class="mu lt iq mq b gy mv mw l mx my">git clone https://github.com/dtm-labs/dtm &amp;&amp; cd dtm<br/>go run main.go</span></pre><h2 id="2f2a" class="mu lt iq bd lu nr ns dn ly nt nu dp mc lf nv nw me lj nx ny mg ln nz oa mi ob bi translated">运行示例</h2><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e6e0" class="mu lt iq mq b gy mv mw l mx my">git clone https://github.com/dtm-labs/dtm-examples &amp;&amp; cd dtm-examples<br/>go run main.go http_msg_doAndCommit</span></pre><h1 id="1383" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">成功的过程</h1><p id="87a1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe ni nj nk mq b">DoAndSubmitDB</code>如何保证成功的业务执行和消息提交的原子性？请参见下面的时序图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/74ebdaf4abf1a7a4f4dd36ed4605a035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q9Y-n-3ECKFmrotsuhCaow.png"/></div></div></figure><p id="4784" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，时序图中的5个步骤将正常完成，并且全局事务完成。这里需要说明一下:<code class="fe ni nj nk mq b">msg</code>的承诺分两个阶段做，先准备，后提交。</p><p id="c1a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在DTM收到准备请求后，它不调用分支事务，而是等待后续的提交。只有当它收到提交请求时，它才开始分支调用，并最终完成全局事务。</p><h1 id="1a8c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">提交后崩溃</h1><p id="b897" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在分布式系统中，需要考虑各种停机和网络异常，所以我们来看看会发生什么。</p><p id="6a5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们想要实现的最重要的目标是业务执行和消息提交组成一个原子操作。所以我们先来看看，如果在业务执行之后、消息提交之前出现宕机故障，会发生什么，以及新模式将如何确保原子性。</p><p id="05f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看这种情况下的时序图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/8f9fd4bb86ddd9c9816bdb319b0b591f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4eqQl_NqqO7RCTBJab64qg.png"/></div></div></figure><p id="123e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，DTM将轮询在某个超时后只准备好而没有提交的消息，并调用消息指定的检查服务来查询业务执行是否成功。</p><p id="eb51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个检查服务进入消息表，并查询业务的本地事务是否已经提交。</p><ul class=""><li id="a8b7" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">Committed:返回成功，dtm提交全局事务并继续下一个子事务调用</li><li id="51de" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated">回滚:返回失败，dtm终止全局事务，不再进行子事务调用</li><li id="a784" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated">进行中:该检查将等待最终结果，然后进行到上一个提交/回滚的情况</li><li id="e6fb" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated">未开始:该检查将插入数据，以确保业务的本地事务最终失败</li></ul><h1 id="4a5c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">承诺前崩溃</h1><p id="b316" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们看一下正在回滚的本地事务的时序图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/5b1893b8207f82f189beafe432a7047a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7EUbPk1pjCACa_W1UgGw5A.png"/></div></div></figure><p id="f1cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果进程在dtm收到准备调用之后、事务提交之前立即崩溃，本地数据库将检测到进程的断开，并自动回滚本地事务。</p><p id="da4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随后，dtm会轮询已超时的全局事务，即只准备好但未提交和签回的事务。check-back服务发现本地事务已经回滚，并将结果返回给dtm。dtm接收指示rollbacked的结果，然后将全局事务标记为失败，最后结束全局事务。</p><h1 id="313f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">两阶段消息与发件箱</h1><p id="e2f2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">发件箱模式还可以确保数据的最终一致性。就使用发件箱模式而言，所需的工作包括</p><ul class=""><li id="be02" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">执行本地事务中的本地业务逻辑，将消息插入消息表，最后提交。</li><li id="dcaf" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated">编写轮询任务，从本地消息表中获取消息，并将它们发送到消息队列。该步骤可能使用另一种技术<a class="ae kv" href="https://debezium.io/blog/2018/07/19/advantages-of-log-based-change-data-capture/" rel="noopener ugc nofollow" target="_blank">基于日志的变更数据捕获</a>，而不是定期执行SQL来轮询。</li><li id="c923" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated">消费信息。</li></ul><p id="9e85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与发件箱相比，2阶段消息具有以下优点。</p><ul class=""><li id="6a9e" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">不需要学习或维护任何消息队列</li><li id="5b36" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated">没有要处理的轮询任务</li><li id="b133" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated">不需要消耗消息</li></ul><p id="9e31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2-阶段消息只需要DTM，它比消息队列更容易学习或维护。所有涉及到的技巧都是函数调用和服务调用，这是所有开发者都熟悉的东西。</p><ul class=""><li id="4dcd" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">两阶段消息的公开接口完全独立于队列，并且只与实际的业务和服务调用相关，这使得它对开发人员更加友好</li><li id="8e29" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated">2阶段消息不必考虑消息堆叠和其他故障，因为2阶段消息只依赖于dtm。开发者可以把dtm想象成和系统中任何其他普通的无状态服务一样，只依赖于背后的存储，Mysql/Redis。</li><li id="5f9c" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated">消息队列是异步的，而两阶段消息同时支持异步和同步。默认行为是异步的，您可以通过设置<code class="fe ni nj nk mq b">msg.WaitResult=true</code>来等待下游服务同步完成。</li><li id="3b19" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated">两阶段消息还支持同时指定多个下游服务</li></ul><h2 id="c873" class="mu lt iq bd lu nr ns dn ly nt nu dp mc lf nv nw me lj nx ny mg ln nz oa mi ob bi translated">两阶段信息的应用</h2><p id="5827" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">2-阶段消息可以显著降低最终一致性解决方案的难度并得到广泛应用，这里有两个典型的应用。</p><ul class=""><li id="2192" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated"><a class="ae kv" href="https://en.dtm.pub/app/flash.html" rel="noopener ugc nofollow" target="_blank">闪购系统</a>:这种架构可以在单台机器上轻松承载数万个订单请求，并确保扣除的库存数量与订单数量准确匹配</li><li id="0066" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated"><a class="ae kv" href="https://en.dtm.pub/app/cache.html" rel="noopener ugc nofollow" target="_blank">缓存一致性</a>:这种架构可以通过一个两阶段消息轻松保证数据库和缓存的一致性，这比队列或订阅bin-log解决方案要好得多</li></ul><p id="1ee4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://github.com/dtm-labs/dtm-examples" rel="noopener ugc nofollow" target="_blank"> dtm-examples </a>中可以找到结合使用Redis、Mongo存储引擎和两阶段消息的示例</p><h1 id="9426" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">核对原则</h1><p id="ea95" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">check-back服务出现在前面的时序图以及界面中。这种校验设计首先存在于RocketMQ中，实现留给开发人员手工处理。在两阶段消息中，它由复制粘贴代码自动处理。那么自动加工的原理是什么呢？</p><p id="5b72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了执行检查，我们首先在业务数据库实例中创建一个单独的表，其中存储了<code class="fe ni nj nk mq b">gid</code>(全局事务id)。处理业务事务时，Gid被写入该表。</p><p id="b3df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们用gid检查时，如果我们在表中找到gid，那么就意味着本地事务已经提交，所以我们可以向dtm返回本地事务已经提交的结果。</p><p id="5fcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们用gid检查时，如果我们在表中没有找到gid，那么这意味着本地事务还没有被提交。有三种可能的结果:</p><ol class=""><li id="c9ef" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr nq nf ng nh bi translated">交易仍在进行中。</li><li id="c8b1" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr nq nf ng nh bi translated">事务已被回滚。</li><li id="ce92" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr nq nf ng nh bi translated">交易尚未开始。</li></ol><p id="07bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我搜索了很多关于RocketMQ的检查返回的信息，但是没有找到一个无错误的解决方案。大多数建议是，如果没有找到gid，那么什么也不做，在接下来的10秒钟内等待下一次检查。如果检查持续了2分钟或更长时间，仍然找不到gid，则认为本地事务已回滚。</p><p id="62f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下情况存在问题。</p><ul class=""><li id="c05b" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">在极端情况下，可能会发生数据库故障(如进程暂停或磁盘堵塞)，持续时间超过2分钟，最后数据被提交。但是RocketMQ假设事务被回滚，并取消全局事务，使数据处于不一致的状态。</li><li id="83c2" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr ne nf ng nh bi translated">如果一个本地事务已经被回滚，但是check-back服务在两分钟之内，会每10秒钟不断地轮询一次，给服务器造成不必要的负载。</li></ul><p id="e667" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">dtm的2阶段消息解决方案彻底解决了这些问题。它的工作原理如下。</p><ol class=""><li id="6a7c" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr nq nf ng nh bi translated">当处理一个本地事务时，gid被插入到表<code class="fe ni nj nk mq b">dtm_barrier.barrier</code>中，插入原因为<code class="fe ni nj nk mq b">COMMITTED</code>。表<code class="fe ni nj nk mq b">dtm_barrier.barrier</code>在gid上有唯一的索引。</li><li id="ea11" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr nq nf ng nh bi translated">当检查回来时，两阶段消息不直接查询gid是否存在，而是插入忽略具有相同gid的行，以及原因<code class="fe ni nj nk mq b">ROLLBACKED</code>。此时，如果表中已经有一条gid为的记录，那么新的插入操作将被忽略，否则将插入该行。</li><li id="9c52" class="mz na iq ky b kz nl lc nm lf nn lj no ln np lr nq nf ng nh bi translated">用gid查询表中的记录，如果记录的原因是<code class="fe ni nj nk mq b">COMMITTED</code>，则本地事务已经提交；如果记录的原因是<code class="fe ni nj nk mq b">ROLLBACKED</code>，那么本地事务已经回滚或将回滚。</li></ol><p id="7830" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，两阶段消息如何区分进行中的消息和回滚的消息呢？诀窍在于在检查返回期间插入的数据。如果在检查时数据库事务仍在进行中，则插入操作将被进行中的事务阻塞，因为检查中的插入操作将等待进行中的事务持有的行锁。如果插入操作正常返回，那么数据库中的本地事务一定已经结束。</p><h1 id="f3fc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">普通邮件</h1><p id="793d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">两阶段消息不仅可以替换发件箱，还可以替换正常消息模式。如果您直接调用Submit，那么它类似于普通的消息模式，但是提供了一个更加灵活和简单的接口。</p><p id="b3f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设一个应用程序场景，其中UI上有一个按钮，可以参与授予对两本电子书的永久访问权限的活动。在这种情况下，服务器端可以这样处理:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="6775" class="mu lt iq mq b gy mv mw l mx my">msg := dtmcli.NewMsg(DtmServer, gid).<br/>	Add(busi.Busi+"/AuthBook", &amp;Req{UID: 1, BookID: 5}).<br/>	Add(busi.Busi+"/AuthBook", &amp;Req{UID: 1, BookID: 6})<br/>err := msg.Submit()</span></pre><p id="35b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法还提供了不依赖于消息队列的异步接口。</p><h1 id="2c88" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摘要</h1><p id="fda9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">本文中提出的两阶段消息有一个简单而优雅的接口，它带来了比发件箱更优雅的模式。</p><p id="ca17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎参观github.com/dtm-labs/dtm。这是一个致力于使微服务中的分布式事务更容易的项目。它支持多种语言和多种模式，如两阶段消息、Saga、Tcc和Xa。</p></div></div>    
</body>
</html>