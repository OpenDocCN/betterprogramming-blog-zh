<html>
<head>
<title>What’s Going On With Those Swift Substrings?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">那些雨燕子串是怎么回事？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-going-on-with-those-swift-substrings-83c58cedf596?source=collection_archive---------5-----------------------#2020-01-18">https://betterprogramming.pub/whats-going-on-with-those-swift-substrings-83c58cedf596?source=collection_archive---------5-----------------------#2020-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4c5e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看当你分解一根弦时会发生什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/98a6ce056b4efadd716fb06952d015ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G2hgMyuTM4UZK63XFne6Ng.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@prochurchmedia?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亲教会媒体</a>在<a class="ae ky" href="https://unsplash.com/s/photos/cut-paper?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e2d7" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">笔记</h1><p id="20b9" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">尽管我们认为字符串切片是软件开发中的一项常见任务，但许多Swift开发人员发现<code class="fe mu mv mw mx b">substring</code>很复杂，令人沮丧。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="57a2" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">比较其他语言中的子字符串</h1><p id="1a5b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">让我们看看substring在其他计算机语言中是如何工作的:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="3647" class="nc lh it mx b gy nd ne l nf ng">C++: str.substr(2,8)<br/>Java: str.substring(2,8)<br/>Python: str[2,8]<br/>Objective-C: [str substringWithRange:NSMakeRange(2,6)]</span></pre><p id="134a" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">现在让我们看看substring在Swift中是如何工作的:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="550a" class="nc lh it mx b gy nd ne l nf ng">var startIndex = str.index(str.startIndex, offsetBy: 2)<br/>var endIndex    =   str.index(startIndex, offsetBy: 6)<br/>var substring = str[startIndex..&lt;endIndex]</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="026a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">问题的根源——UTF-8</h1><p id="d1d9" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">为了理解字符串是如何工作的，我们需要回到基础——Unicode和UTF-8。</p><p id="2d45" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">当我们处理字符串时，我们感觉我们在处理一个纯文本，只是一系列符号和数字，但这是一个谎言。过去是这样的，当时计算机使用的是一种叫做ASCII的东西。</p><p id="ebdc" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">ASCII是一种将所有重要字符(字母、数字、符号)表示为32到127之间的数字的方式，所以每个字符占用一个字节的内存。</p><p id="6485" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">而127到255呢？每个开发人员都可以用它做他们想做的任何事情，所以你可以想象当计算机离开美国到非英语国家时我们有多混乱。</p><p id="76d1" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">这就是Unicode发挥作用的地方——在世界上几乎每种语言中，Unicode都是表示你能想到的每个字母和数字的方式，不仅如此，Unicode还非常适合表示表情符号。</p><p id="c882" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">因此，Unicode字符映射表是一个四字节的映射表，由于我们输入的大多数字符是英文字母和数字，为每个字符分配四个字节是非常低效的，而在大多数情况下，一个字节就足够了。</p><p id="46aa" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">这是矩阵的最后一块-&gt;编码，在这种情况下，UTF-8。</p><p id="6a2a" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">UTF-8是一种将Unicode字符串编码成更小数据块的方法，因此效率更高。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="30f7" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">UTF-8是如何在引擎盖下工作的？</h1><p id="60be" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">你可以在网上找到大量关于文本编码的材料，所以我不会在这篇文章中深入探讨，但我至少会试着解释一下基础知识。</p><p id="3d97" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">Unicode保存四个字节的字符映射数据。前127个字符是传统的ASCII，接下来的1920个字符是拉丁语言、阿拉伯语、希伯来语等。之后，我们可以找到中文、日文和韩文，等等。</p><p id="2f51" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">所以，根据上面的内容，你可以理解，比如在处理英语的时候，在大多数情况下我们不需要利用所有的四个字节，我们可以只使用映射的第一个字节。</p><p id="3959" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">那么，编码是如何工作的呢？我们如何知道每个字符使用了多少字节？我们使用数据的第一位来通知编码器我们为这个字符分配了多少字节。</p><p id="89ae" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">理解这一点的最好方法是通过例子。让我们试着代表UTF 8中的字符。</p><p id="7ebc" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">“←”的Unicode十六进制值是U+20A4，这意味着它将占用三个字节的内存。20A4的二进制值是<strong class="ma iu"> </strong> 0010 0000 1010 0100。</p><p id="a9c0" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">现在，我们要宣布我们将使用三个字节的内存，所以我们从三位1开始，然后是0:</p><p id="cd4f" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi">1110</p><p id="541f" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">然后，为了完成第一个字节，我们将取20A4的前四位，并完成UTF-8值的第一个字节:</p><p id="5bcc" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi">1110–0010</p><p id="f770" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">对于第二个字节，我们从10开始，之后是20A4的下六位:</p><p id="6483" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi">1110–0010 1000–0010</p><p id="4422" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">对于第三个字节，我们也要这样做—从10开始，然后是20A4的剩余6位:</p><p id="c2b5" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi">1110–0010 1000–0010 1010–0100</p><p id="6e1a" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">而这就是我们在UTF-8和世界上几乎每一个符号中代表“←”的方式。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="4d15" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">UTF 8比UTF 16好，对吧？</h1><p id="53a5" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">是的。我的意思是，不。嗯，这很复杂…这取决于你用它做什么。</p><p id="75ce" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">例如，如果大部分符号位于ASCII区域(英语和数字)，UTF-8可能非常有效。但是如果你用中文书写或者使用很多表情符号，那么UTF-16可能更适合这种情况。</p><p id="9ce2" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">就像上一部分一样，我要用一个例子来说明。</p><p id="d99c" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">UTF-8中的字符串“AB”将是“41 42”，而在UTF-16中是“41 00 42 00”。</p><p id="c70e" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">但是中文字符串“いろは”在UTF-8中将是“E3 81 84 E3 82 8D E3 81 AF ”,在UTF-16中将是“44 30 8d 30 6f 30”——占了一半的空间。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e8ea" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">Swift中编码与子字符串有什么关系？</h1><p id="1945" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">想象下一个字符串:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="3229" class="nc lh it mx b gy nd ne l nf ng">let str = “I have a friend called 摩西, nice name 😀, ha?”</span></pre><p id="dcb4" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">上面的字符串有43个字符，但是它占用了50个字节的空间。由于前面对UTF-8工作原理的解释，你已经理解了字符数和字节数的区别。</p><p id="9988" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi">For example, the name “摩西”, which holds two characters, takes six bytes of space, and the single emoji “😀” takes four bytes of space (!).</p><p id="bbb0" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">让我们看看当我们试图打印字符串的长度时会发生什么:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="4ffc" class="nc lh it mx b gy nd ne l nf ng">print(str.count) // print 43<br/>print(str.utf8.count) //print 50</span></pre><p id="291c" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">如果，理论上，你可以做<code class="fe mu mv mw mx b">str[10]</code>，你会期望编译器到达变量中的第10位并返回<code class="fe mu mv mw mx b">f</code>。但要做到这一点，编译器需要了解字符串中第10个元素的内存地址是什么。</p><p id="b63a" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">如果每个字符总是占用一个字节，这将非常容易，但由于它的大小未知，编译器需要从字符串的开头迭代，直到它到达第10个元素，正因为如此，这是一个O(n)操作，只是为了访问单个变量。</p><p id="e7b0" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">所以，当你试图做类似于<code class="fe mu mv mw mx b">str[10…15]</code>的事情时，你需要迭代字符串两次来得到一个子串。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="06d6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">遇见弦。索引</h1><p id="9121" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">为了有效地进行字符串操作，我们使用了<code class="fe mu mv mw mx b">String.Index</code>。<code class="fe mu mv mw mx b">String.Index</code>是表示字符串中计算位置的结构。</p><p id="313a" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">因为我们不想为了得到一个子串而迭代字符串两次，所以可以用<code class="fe mu mv mw mx b">String.Index</code>只迭代一次。</p><p id="7063" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">我们迭代到第一个索引，然后从第一个索引迭代到第二个索引。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e819" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">使用索引的好处是它已经被计算过了。您可以保存它，传递它，并重用它，而不是让编译器在每次您想要访问特定位置时迭代该字符串。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="1009" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">更多字符串效率技巧</h1><p id="cd7d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Swift中的字符串除了<code class="fe mu mv mw mx b">String.Index</code>还有更多效率招数。</p><p id="58ce" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">例如，您是否知道当您对一个字符串进行子字符串化时，您不会为该子字符串获得一个新分配的空间？它只是对原始字符串的内存部分的引用，因此字符串及其子字符串共享它们的存储，这在内存和性能方面都是高效的。</p><p id="37c9" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">这意味着子字符串是一个临时变量，如果您想继续使用字符串片段，您需要将其转换为字符串。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d456" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">Swift的另一个巧妙技巧是COW(写时复制)。COW的意思是当你复制一个变量(集合类型和字符串)时，它会共享同一个存储空间，直到你修改了新的副本才会分配新的内存。这是懒惰的内存分配。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="0f35" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">字符串扩展</h1><p id="6a28" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果您仍然想做类似于<code class="fe mu mv mw mx b">str[5..&lt;10]</code>的事情来获得子串，那么您可以添加一个字符串扩展来实现这一目的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4ec1" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">但是记住这不是最有效的方法，如果你想让你的程序运行得更快，推荐使用<code class="fe mu mv mw mx b">String.Index</code>。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5c37" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">摘要</h1><p id="cb27" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">一个字符串不是一个简单的数组，它是一个复杂而不同的野兽。Swift语言开发人员选择了性能和内存效率的方法，而不是可读性。</p><p id="e1a2" class="pw-post-body-paragraph ly lz it ma b mb nh ju md me ni jx mg mh nj mj mk ml nk mn mo mp nl mr ms mt im bi translated">幸运的是，我们可以通过添加一个字符串扩展在可读性和效率之间进行选择(就像在其他开发领域一样),这和许多其他情况一样，使我们作为开发人员的生活变得更加容易。</p></div></div>    
</body>
</html>