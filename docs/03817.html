<html>
<head>
<title>How to Build a RESTful API With Go and MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Go和MongoDB构建RESTful API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-restful-api-with-go-and-mongodb-93e59cbbee88?source=collection_archive---------6-----------------------#2020-03-06">https://betterprogramming.pub/building-a-restful-api-with-go-and-mongodb-93e59cbbee88?source=collection_archive---------6-----------------------#2020-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="75b2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们使用纤程来构建一个API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6a0f3506d830a53542d58c868abdb076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z5MRUcK70zfflfBQjj5YIA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@yipvick?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">叶维克</a>在<a class="ae ky" href="https://unsplash.com/s/photos/fiber?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="c36d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们将学习如何用<a class="ae ky" href="https://github.com/gofiber/fiber" rel="noopener ugc nofollow" target="_blank">纤程</a>构建一个RESTful API，这是一个据说是最快的Go框架之一。我们还将使用MongoDB来存储数据。</p><blockquote class="lv lw lx"><p id="2f0b" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">Fiber是一个受Express启发的web框架，构建在Fasthttp之上，fast http是Go最快的HTTP引擎。旨在以零内存分配和性能为目标，为快速开发提供便利。</p></blockquote><p id="3d40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我假设你已经安装了Go。如果没有，这很简单——只需下载软件包并<a class="ae ky" href="https://golang.org/dl/" rel="noopener ugc nofollow" target="_blank">按照说明</a>进行操作。</p><p id="fccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><h1 id="ae35" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">通过Docker安装和启动MongoDB</h1><p id="ef0e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将使用MongoDB作为数据库，为了简单起见，我们将使用Docker映像。</p><p id="d2b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，<a class="ae ky" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank">下载安装Docker </a>。</p><p id="c2f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们需要得到MongoDB图像。打开您的终端并键入以下内容:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c3e2" class="ne md it na b gy nf ng l nh ni">docker pull mongo</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/ab9808aae7bb94a91b367f14f74cdc12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMc7QB65cDfPF-bNcxw6KA.png"/></div></div></figure><p id="16cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下载完成后，只需使用以下命令启动docker容器:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="aadb" class="ne md it na b gy nf ng l nh ni">docker run --name mongo-db -p 27017:27017 -d mongo:latest</span></pre><p id="0e8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">端口参数<code class="fe nk nl nm na b">-p 27017:27017</code>非常重要。它告诉Docker容器公开这个端口，以便从容器外部访问。否则，您将无法从应用程序连接到数据库。</p><p id="b73e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。随着容器的运行，我们现在可以使用URL <code class="fe nk nl nm na b">mongodb://localhost:27017</code>访问MongoDB实例。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="0a6d" class="mc md it bd me mf nu mh mi mj nv ml mm jz nw ka mo kc nx kd mq kf ny kg ms mt bi translated">创建Go项目</h1><p id="8569" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">既然我们已经运行了<code class="fe nk nl nm na b">DataBase</code>,是时候开始创建我们的应用程序了。</p><p id="4279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nk nl nm na b">$HOME/go/src directory</code>中创建一个文件夹。在本教程中，我们称之为<code class="fe nk nl nm na b">my-rest-api</code>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4312" class="ne md it na b gy nf ng l nh ni">mkdir my-rest-api</span></pre><p id="02a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个文件夹中，为了告诉Go我们将使用<a class="ae ky" href="https://blog.golang.org/using-go-modules" rel="noopener ugc nofollow" target="_blank"> Go模块</a>，我们需要运行以下命令:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d5dc" class="ne md it na b gy nf ng l nh ni">go mod init my-rest-api</span></pre><p id="9892" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令将创建<code class="fe nk nl nm na b">go.mod</code>文件。这个文件保存了这个应用程序中使用的包的信息。Go <code class="fe nk nl nm na b">Modules</code>是在Go版本1.11中引入的，它给了我们一个处理包的简单方法。</p><p id="95b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，创建<code class="fe nk nl nm na b">main.go</code>文件，这个文件将是我们的应用程序及其main方法的入口点。</p><p id="6748" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个文件只打印文本“Hello world”现在回到控制台，构建并运行您的go应用程序，只是为了测试它是否工作正常。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0114" class="ne md it na b gy nf ng l nh ni">$ go build<br/>$ ./my-rest-api</span></pre><p id="07f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个命令构建应用程序并生成一个应用程序名的文件——在我们的例子中是<code class="fe nk nl nm na b">my-rest-api</code>。第二个命令运行它。它应该打印文本“Hello world”如果印出来，都是好的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/284bfcff5e764171c4019947f3a0cf4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*XcpbTAVs_JZaAN35DG0j-A.png"/></div></figure></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="0b44" class="mc md it bd me mf nu mh mi mj nv ml mm jz nw ka mo kc nx kd mq kf ny kg ms mt bi translated">获取Go库</h1><p id="feb8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们开始获取构建项目所需的库。我们将使用Fiber作为web框架，使用MongoDB作为数据库。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="90ee" class="ne md it na b gy nf ng l nh ni">$ go get github.com/gofiber/fiber</span><span id="e29d" class="ne md it na b gy oa ng l nh ni">$ go get go.mongodb.org/mongo-driver/mongo</span></pre><p id="5274" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些命令将下载库并将它们存储在我们的Go目录中，所以从现在开始我们可以在任何需要的项目中使用它们。</p><p id="29df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，当我们在项目根目录下运行这些命令时，Go将使用这些包更新我们的<code class="fe nk nl nm na b">go.mod</code>文件，并生成一个<code class="fe nk nl nm na b">go.sum</code>文件，其中包含每个下载包的校验和。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="62d0" class="mc md it bd me mf nu mh mi mj nv ml mm jz nw ka mo kc nx kd mq kf ny kg ms mt bi translated">设置HTTP路由</h1><p id="3ba6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们已经运行了MongoDB实例，创建了Go项目并下载了依赖项，是时候开始编写API本身了。</p><p id="9396" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，导入纤程库，就在包声明之后。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9e7b" class="ne md it na b gy nf ng l nh ni">import “github.com/gofiber/fiber”</span></pre><p id="9ad7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后写主要方法:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ca41" class="ne md it na b gy nf ng l nh ni">func main() {<br/>  app := fiber.New()<br/>  app.Get("/person/:id?", getPerson)<br/>  app.Post("/person", createPerson)<br/>  app.Put("/person/:id", updatePerson)<br/>  app.Delete("/person/:id", deletePerson)<br/>  app.Listen(port)<br/>}</span></pre><p id="b64d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">main函数实例化一个Fiber实例，声明将提供哪些路由及其处理程序，并开始监听端口8000。</p><p id="51ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些处理程序是接收一个<code class="fe nk nl nm na b">fiber.Ctx</code>作为参数的函数。这个对象保存了关于请求和响应的所有信息，并具有我们可以用来与它们进行交互的函数。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e7b0" class="ne md it na b gy nf ng l nh ni">func getPerson(c *fiber.Ctx) {</span><span id="b268" class="ne md it na b gy oa ng l nh ni">}</span><span id="df07" class="ne md it na b gy oa ng l nh ni">func createPerson(c *fiber.Ctx) {</span><span id="a122" class="ne md it na b gy oa ng l nh ni">}</span><span id="56a7" class="ne md it na b gy oa ng l nh ni">func updatePerson(c *fiber.Ctx) {</span><span id="4824" class="ne md it na b gy oa ng l nh ni">}</span><span id="9295" class="ne md it na b gy oa ng l nh ni">func deletePerson(c *fiber.Ctx) {</span><span id="694a" class="ne md it na b gy oa ng l nh ni">}</span></pre></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="d4be" class="mc md it bd me mf nu mh mi mj nv ml mm jz nw ka mo kc nx kd mq kf ny kg ms mt bi translated">正在连接到MongoDB</h1><p id="d243" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了避免重复的代码，我们将编写单独的函数来处理与数据库的交互。主要我们需要两个函数——第一个负责与数据库的连接，第二个将返回一个<code class="fe nk nl nm na b">Collection</code>对象，我们可以在其中执行操作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">db.go</p></figure></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="366d" class="mc md it bd me mf nu mh mi mj nv ml mm jz nw ka mo kc nx kd mq kf ny kg ms mt bi translated">编写处理程序的逻辑</h1><p id="7e96" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">操作是最简单的。</p><ul class=""><li id="f1bd" class="od oe it lb b lc ld lf lg li of lm og lq oh lu oi oj ok ol bi translated"><code class="fe nk nl nm na b">Get</code>:返回一个或多个结果。</li><li id="b1cb" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><code class="fe nk nl nm na b">Post</code>:向数据库添加一个条目。</li><li id="30bf" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><code class="fe nk nl nm na b">Put</code>:更新一个条目。</li><li id="d9d1" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><code class="fe nk nl nm na b">Delete</code>:删除一个条目。</li></ul><p id="51c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一有更多逻辑的方法是<code class="fe nk nl nm na b">GetPerson</code> <em class="ly"> </em>，因为如果传递了<code class="fe nk nl nm na b">id</code>，它返回一个结果，否则返回多个结果。</p><p id="69d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在函数之前，我们声明我们的常数。这是避免输入错误的好方法，也很实用——如果我们需要更改这些值，我们只需在一个地方更改它们。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="44be" class="ne md it na b gy nf ng l nh ni">const dbName = “personsdb”</span><span id="e409" class="ne md it na b gy oa ng l nh ni">const collectionName = “person”</span><span id="7dab" class="ne md it na b gy oa ng l nh ni">const port = 800</span></pre><p id="cc71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们将用来在数据库上持久化的<code class="fe nk nl nm na b">Person</code>结构:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7d8c" class="ne md it na b gy nf ng l nh ni">type <em class="ly">Person</em> struct {</span><span id="2bf1" class="ne md it na b gy oa ng l nh ni">_id <em class="ly">string</em> `json:”id,omitempty”`</span><span id="bf7f" class="ne md it na b gy oa ng l nh ni">FirstName <em class="ly">string</em> `json:”firstname,omitempty”`</span><span id="82db" class="ne md it na b gy oa ng l nh ni">LastName <em class="ly">string</em> `json:”lastname,omitempty”`</span><span id="94fd" class="ne md it na b gy oa ng l nh ni">Email <em class="ly">string</em> `json:”email,omitempty”`</span><span id="d3c7" class="ne md it na b gy oa ng l nh ni">Age <em class="ly">int</em> `json:”age,omitempty”`</span><span id="81fc" class="ne md it na b gy oa ng l nh ni">}</span></pre></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="b7f6" class="mc md it bd me mf nu mh mi mj nv ml mm jz nw ka mo kc nx kd mq kf ny kg ms mt bi translated">邮政</h1><p id="d887" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">由于MongoDB的工作方式，我们将从<code class="fe nk nl nm na b">POST</code>方法开始。只有在插入第一个文档时，数据库才真正创建，因此我们至少需要插入一个人来创建数据库本身。</p><p id="e480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上下文变量中，我们可以通过函数<code class="fe nk nl nm na b">Body</code>访问请求的主体，所以我们需要调用它并解析到我们的<code class="fe nk nl nm na b">Person</code>对象。然后我们调用MongoDB将其插入数据库。如果有错误，我们返回状态代码500，这意味着“内部服务器错误”，<em class="ly"> </em>并发送MongoDB返回的错误描述。如果插入操作成功运行，我们解析对JSON的响应，并将其与响应一起发送回去。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建人</p></figure><p id="3158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面可以看到响应，是插入文档的<code class="fe nk nl nm na b">id</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/fca38975fedeea78c559efc40d2f40ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ION9AWjESX61EFNOXyXzaw.png"/></div></div></figure></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="4044" class="mc md it bd me mf nu mh mi mj nv ml mm jz nw ka mo kc nx kd mq kf ny kg ms mt bi translated">得到</h1><p id="2883" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们插入第一个<code class="fe nk nl nm na b">Person</code>之后，我们可以用<code class="fe nk nl nm na b">GET</code>方法检索它。</p><p id="d4b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们声明它的路由的方式是，它可以有一个<code class="fe nk nl nm na b">id</code>作为参数，也可以没有——这就是为什么我们在路由声明中把<code class="fe nk nl nm na b">?</code>放在<code class="fe nk nl nm na b">:id</code>之后。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="846e" class="ne md it na b gy nf ng l nh ni">app.Get("/person/:id?", getPerson)</span></pre><p id="1a38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用函数<code class="fe nk nl nm na b">Params() </code>访问URL参数，传递参数的名称。在我们的例子中，那是它的<code class="fe nk nl nm na b">id</code>，所以我们称之为<code class="fe nk nl nm na b">c.Params("id")</code>。因为这里的参数是可选的，我们需要检查它是否被传递。如果是，我们把它作为过滤器传递给我们对数据库的查询，如果不是，我们检索所有没有过滤器的结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GetPerson</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/dd78eff4b78e5ae91bc93036ac696a97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Icw5Ye81SHFcgh_VF_wEQ.png"/></div></div></figure></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="6539" class="mc md it bd me mf nu mh mi mj nv ml mm jz nw ka mo kc nx kd mq kf ny kg ms mt bi translated">放</h1><p id="19d7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">更新几乎与创建功能相同。区别在于我们发送到MongoDB的方式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更新人员</p></figure><p id="7e08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MongoDB返回给我们的也不一样。现在，它返回关于找到和更新了多少文档的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/3ab1f4b21a46aeee05d1b642c511a68d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aYvq590MTdk1KqCikZeCDQ.png"/></div></div></figure><h2 id="ec01" class="ne md it bd me os ot dn mi ou ov dp mm li ow ox mo lm oy oz mq lq pa pb ms pc bi translated">删除</h2><p id="263d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后是删除功能，这也很简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">删除人员</p></figure><p id="5313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这次MongoDB向我们返回已删除文档的数量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/822a10e456547033ac92abfe1f0c9280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3IaosZhY6mjazoKS07rzmQ.png"/></div></div></figure></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="ad9d" class="mc md it bd me mf nu mh mi mj nv ml mm jz nw ka mo kc nx kd mq kf ny kg ms mt bi translated">结论</h1><p id="f813" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你可以在GIT 上看到<a class="ae ky" href="https://github.com/ednofedulo/go-rest-api" rel="noopener ugc nofollow" target="_blank">完整的代码。</a></p></div></div>    
</body>
</html>