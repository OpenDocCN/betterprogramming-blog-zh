<html>
<head>
<title>The Mystery of MongoDB Indexing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MongoDB索引的奥秘</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-mystery-of-mongodb-indexing-af61766647dc?source=collection_archive---------9-----------------------#2022-04-25">https://betterprogramming.pub/the-mystery-of-mongodb-indexing-af61766647dc?source=collection_archive---------9-----------------------#2022-04-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4d9c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解ESR规则和索引交集</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/98b59c025e08f436955681f1fa9cd3ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kJ-YeMcMK3K7POhJ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">杰里米·毕晓普在<a class="ae kv" href="https://unsplash.com/photos/vGjGvtSfys4" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="72de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我相信我们都熟悉MySQL的索引规则。因为它是从B+树构建的，所以MySQL索引有一个最左边的匹配规则。为了使查询与索引匹配，MySQL查询语法中使用的列是从左到右排列的。例如:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="5121" class="lx ly iq lt b gy lz ma l mb mc">SELECT * FROM table WHERE a = 1 AND b &gt; 2 ORDER BY c;</span></pre><p id="8ed5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种查询最有效的索引是像<code class="fe md me mf lt b">(a, b, c)</code>这样的复合索引。但是，这样的索引不能应用于</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="168c" class="lx ly iq lt b gy lz ma l mb mc">SELECT * FROM table WHERE a = 1 ORDER BY c;</span></pre><p id="287a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为它缺少必要的<code class="fe md me mf lt b">b</code>列。</p><p id="8959" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是MySQL的索引规则，一般来说，关系数据库遵循几乎相同的规则来实现。但是，MongoDB用B树实现有细微的区别。</p><h1 id="6cf5" class="mg ly iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated"><a class="ae kv" href="https://www.mongodb.com/docs/manual/tutorial/equality-sort-range-rule/#std-label-esr-indexing-rule" rel="noopener ugc nofollow" target="_blank"> MongoDB ESR规则</a></h1><p id="5f8e" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们将继续使用上一节中提到的查询作为演示。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="f8d3" class="lx ly iq lt b gy lz ma l mb mc">db.table.find({a: 1, b: {$gt: 2}}).sort({c: 1})</span></pre><p id="1272" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与前面提到的MySQL查询非常相似，但是MongoDB的MQL被重写。然而，对于这样的查询有效的索引是<code class="fe md me mf lt b">(a, c, b)</code>，而不是前面提到的<code class="fe md me mf lt b">(a, b, c)</code>。</p><p id="00d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为MongoDB的复合索引必须遵循ESR (Equality，Sort，Range)规则。因此，在上面的例子中，<code class="fe md me mf lt b">b</code>用于范围匹配，<code class="fe md me mf lt b">c</code>用于排序，所以正确的索引顺序是<code class="fe md me mf lt b">c</code>在<code class="fe md me mf lt b">b</code>之前。</p><h1 id="00c2" class="mg ly iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated"><a class="ae kv" href="https://www.mongodb.com/docs/manual/core/index-intersection/" rel="noopener ugc nofollow" target="_blank"> MongoDB索引交集</a></h1><p id="3fd8" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">除了与关系数据库不同的ESR规则，MongoDB还有另一个奥秘:它可以在同一个查询中使用多个(比如说2个)索引，这被称为索引交集。</p><p id="9d6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">继续以上一节中的查询为例。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="24c7" class="lx ly iq lt b gy lz ma l mb mc">db.table.find({a: 1, b: {$gt: 2}}).sort({c: 1})</span></pre><p id="635e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了提高查询性能，我们建议使用<code class="fe md me mf lt b">(a, c, b)</code>复合索引，但实际上，我们可以用两个索引达到相同的结果。</p><ol class=""><li id="bced" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">b</li><li id="d6de" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">(甲、丙)</li></ol><p id="17a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们创建一个单一索引<code class="fe md me mf lt b">b</code>和一个复合索引<code class="fe md me mf lt b">(a, c)</code>，这也可以提高查询性能。</p><p id="7956" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们为什么要用<code class="fe md me mf lt b">(a, c)</code>？因为即使是指数交集也必须遵循ESR规则，所以我们把ES和r分开。</p><p id="1ea2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这有什么好处？最大的好处是指数的构成变得更加灵活。如果只创建一个索引<code class="fe md me mf lt b">(a, c, b)</code>，那么如果单独查询<code class="fe md me mf lt b">b</code>，就没有匹配的索引可以使用，所以必须额外创建一个<code class="fe md me mf lt b">b</code>的索引。众所周知，索引其实是一种成本，会占用内存，影响写入效率。换句话说，如果一个更紧凑的索引可以用来覆盖更复杂的查询条件，那么这样的索引将更有价值。</p><h1 id="64c8" class="mg ly iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated"><a class="ae kv" href="https://www.mongodb.com/docs/manual/tutorial/equality-sort-range-rule/#additional-considerations" rel="noopener ugc nofollow" target="_blank"> MongoDB ESR“隐藏”规则</a></h1><p id="5e9a" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">当使用MySQL时，我们使用<code class="fe md me mf lt b">IN</code>进行范围查询，但是<code class="fe md me mf lt b">IN</code>实际上是MySQL中的一个等式。也就是说，当查询为<code class="fe md me mf lt b">WHERE a IN (2, 3)</code>时实际上等同于<code class="fe md me mf lt b">WHERE a = 2 OR a = 3</code>。</p><p id="da63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，在MongoDB中，却不是。</p><p id="2516" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你只是简单地使用一个列<code class="fe md me mf lt b">$in</code>，那么它仍然具有与MySQL相同的行为。</p><p id="0cdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如<code class="fe md me mf lt b">find({a: {$in: [2, 3]}})</code>和<code class="fe md me mf lt b">find({$or: [{a: 2}, {a: 3}]})</code>是等价的，都属于ESR法则的E。</p><p id="f9a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果与sort一起使用，那么<code class="fe md me mf lt b">$in</code>将被视为范围匹配，例如r:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="9e99" class="lx ly iq lt b gy lz ma l mb mc">find({a: {$in: [2, 3]}}).sort({b: 1})</span></pre><p id="0231" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里<code class="fe md me mf lt b">a</code>被当作R，所以为了满足这样的查询，要创建的索引应该是<code class="fe md me mf lt b">(b, a)</code>而不是<code class="fe md me mf lt b">(a, b)</code>。</p><h1 id="5c3c" class="mg ly iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">结论</h1><p id="97e1" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">如果您只有使用关系数据库的经验，很容易被功能丰富的NoSQL数据库所迷惑，特别是因为底层的MongoDB实际上是一个类似于关系数据库的B树家族。但是在实现细节上还是有很大的差异。</p><p id="c464" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在创建MongoDB索引时，注意ESR规则尤为重要。许多从MySQL迁移过来的用户很容易在没有注意到它的情况下被这条规则所困扰。</p><p id="6eee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，即使是使用<code class="fe md me mf lt b">(a, b, c)</code>的索引，在数据量很小时也不会产生问题；MongoDB在内存中排序，但是当数据量增长到一定大小时，MongoDB无法在内存中加载整个数据集，使用硬盘访问。那么表现会很悲剧。</p><p id="9955" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，索引交集特性为用户创建索引提供了更大的灵活性，并为他们提供了更多样化的查询。但是，在使用指数交集时，了解ESR规则也很重要，以免得不偿失。</p></div></div>    
</body>
</html>