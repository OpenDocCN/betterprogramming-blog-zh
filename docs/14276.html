<html>
<head>
<title>Top 3 SVG Animation Techniques</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">三大SVG动画技术</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/top-3-svg-animation-techniques-317225194230?source=collection_archive---------11-----------------------#2022-11-23">https://betterprogramming.pub/top-3-svg-animation-techniques-317225194230?source=collection_archive---------11-----------------------#2022-11-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9eee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这些奇妙功能的简要指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d309ad0ce8038870494cfac6ac7292db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OtTOvpo4iuis0cS5WWJL1Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="f24d" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">1.变形路径</h1><p id="fa5c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们知道SVG具有允许绘制复杂形状的<code class="fe mm mn mo mp b">&lt;path/&gt;</code>元素。其中一个有趣的技术是使用这个库，它可以为从一个路径到另一个路径的平滑过渡创建插值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="d188" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">首先，让我们在Figma中创建一些任意对象。它看起来可能是这样的(如果一个对象包含几个形状，请注意，您应该以Figma将其转换为一个路径的方式合并它们):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/3d56aeb65c9710c354753fceb1d41080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gpnW9ACvTBBvie-PShhOww.jpeg"/></div></div></figure><p id="b47c" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">之后，我们需要转换SVG路径中的每个形状——右键单击所选形状，然后选择“复制/粘贴为-&gt;复制为SVG”选项:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/900d1cf5973053085a4ffe4010ae1b2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XmjWlk0bXGHuZ9mxIcPtdg.png"/></div></div></figure><p id="405d" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">以下SVG被复制到剪贴板中:</p><pre class="kj kk kl km gt mz mp na bn nb nc bi"><span id="4aee" class="nd kz it mp b be ne nf l ng nh">&lt;svg width="50" height="50" viewBox="0 0 50 50" fill="none" &gt;<br/>    &lt;path d="M50 25C50 38.8071 38.8071 50 25 50C11.1929 50 0 38.8071 0 25C0 11.1929 11.1929 0 25 0C38.8071 0 50 11.1929 50 25Z" fill="#FBB503"/&gt;<br/>&lt;/svg&gt;</span></pre><p id="7401" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">我们对字符串感兴趣，它是内部的<code class="fe mm mn mo mp b">d</code>属性。一旦我们对所有形状执行了这些步骤，我们就会得到以下路径集:</p><pre class="kj kk kl km gt mz mp na bn nb nc bi"><span id="98b5" class="nd kz it mp b be ne nf l ng nh">const circlePath = 'M50 25C50 38.8071 38.8071 50 25 50C11.1929 50 0 38.8071 0 25C0 11.1929 11.1929 0 25 0C38.8071 0 50 11.1929 50 25Z';;<br/>const moonPath = 'M18.5 25C18.5 38.8071 25 50 25 50C11.1929 50 0 38.8071 0 25C0 11.1929 11.1929 0 25 0C25 0 18.5 11.1929 18.5 25Z';;<br/>const bowPath = 'M32.5634 4.97243C34.8622 4.36552 37.0171 3.59038 38.9747 2.88622C45.6264 0.493523 50 -1.07968 50 7.55108C50 16.1818 45.6264 14.6086 38.9747 12.2159C37.0075 11.5083 34.841 10.729 32.5294 10.1207C31.4665 12.9705 28.7202 15 25.5 15C22.1937 15 19.387 12.8605 18.389 9.89044C15.7317 10.523 13.251 11.4153 11.0253 12.2159C4.37355 14.6086 0 16.1818 0 7.55108C0 -1.07968 4.37355 0.493523 11.0253 2.88622C13.2423 3.68369 15.7123 4.57219 18.3579 5.20427C19.3276 2.18508 22.1586 0 25.5 0C28.7552 0 31.5261 2.07386 32.5634 4.97243Z';;<br/>const crossPath = 'M20.3352 39.5258C17.9425 46.1775 16.3692 50.5511 25 50.5511C33.6308 50.5511 32.0576 46.1775 29.6649 39.5258C28.3742 35.9377 26.845 31.6866 26.5505 27.1015C31.1355 27.3961 35.3866 28.9252 38.9747 30.2159C45.6265 32.6086 50 34.1818 50 25.5511C50 16.9203 45.6265 18.4935 38.9747 20.8862C35.3866 22.1769 31.1355 23.7061 26.5505 24.0006C26.845 19.4156 28.3742 15.1645 29.6649 11.5764C32.0576 4.92464 33.6308 0.551086 25 0.551086C16.3692 0.551086 17.9425 4.92464 20.3352 11.5764C21.6258 15.1645 23.155 19.4156 23.4496 24.0006C18.8645 23.7061 14.6134 22.1769 11.0253 20.8862C4.37354 18.4935 0 16.9203 0 25.5511C0 34.1818 4.37354 32.6086 11.0253 30.2159C14.6134 28.9252 18.8645 27.3961 23.4496 27.1015C23.155 31.6866 21.6258 35.9377 20.3352 39.5258Z';;<br/>const starPath = 'M26 0L32.0619 18.6565H51.6785L35.8083 30.1869L41.8702 48.8435L26 37.3131L10.1298 48.8435L16.1917 30.1869L0.321474 18.6565H19.9381L26 0Z';;</span></pre><p id="461b" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">库<a class="ae ni" href="https://github.com/veltman/flubber\" rel="noopener ugc nofollow" target="_blank"> flubber </a>帮助我们创建两个形状之间的平滑过渡。</p><pre class="kj kk kl km gt mz mp na bn nb nc bi"><span id="b715" class="nd kz it mp b be ne nf l ng nh">yarn add flubber</span></pre><p id="e6d1" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">这个API非常简单。我们需要创建一个传递两条路径的插值器，它返回一个函数。使用从0到1的值调用此函数会返回一个新的中间路径，用于平滑过渡。代码如下:</p><pre class="kj kk kl km gt mz mp na bn nb nc bi"><span id="3e75" class="nd kz it mp b be ne nf l ng nh">const interpolator = flubber.interpolate(crossPath, starPath);<br/><br/>interpolator(0); // returns an SVG cross path string<br/>interpolator(0.5); // returns something halfway between the cross and the star<br/>interpolator(1); // returns an SVG star path string</span></pre><p id="e791" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/ed482b7f221fed84b04d11e80afae226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1s8Xs_Vt4oyOFBGDeguZlg.jpeg"/></div></div></figure><p id="5de3" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">我们需要将它与React集成。为了简化我们的任务，我将使用两个依赖项:<br/> - <code class="fe mm mn mo mp b">usehooks-ts</code>:一个包含许多有用钩子的库。我们将使用<code class="fe mm mn mo mp b">useInterval</code>钩子(实现<a class="ae ni" href="https://usehooks-ts.com/react-hook/use-interval" rel="noopener ugc nofollow" target="_blank">这里是</a>)；<br/> - <code class="fe mm mn mo mp b">framer-motion</code>:动画库，我们将使用<code class="fe mm mn mo mp b">animate</code>——一个动画化任何值的函数(更多细节<a class="ae ni" href="https://www.framer.com/docs/animate-function/" rel="noopener ugc nofollow" target="_blank">在这里</a>)。</p><p id="e4aa" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">让我们创建我们的<code class="fe mm mn mo mp b">MorphPath</code>组件。正如我们所料，道具应该是两条路径:<code class="fe mm mn mo mp b">fromPath</code>和<code class="fe mm mn mo mp b">toPath</code>。此外，我们可能会公开一些参数，这些参数允许我们更具体地设置动画行为:</p><pre class="kj kk kl km gt mz mp na bn nb nc bi"><span id="22af" class="nd kz it mp b be ne nf l ng nh">import { interpolate } from 'flubber';<br/>import { animate, Spring, Tween } from 'framer-motion';<br/>import { useEffect, useRef, useState } from 'react';<br/><br/>type MorphPathProps = {<br/>  fromPath: string;<br/>  toPath: string;<br/>  animation?: (Tween | Spring) &amp; { delay?: number; type?: 'tween' | 'spring' };<br/>};<br/><br/>const MorphPath = ({ fromPath, toPath, animation }: MorphPathProps) =&gt; {<br/>  // create interpolator for smooth transition paths from fromPath to toPath<br/>  const interpolatorRef = useRef&lt;any&gt;();<br/>  useEffect(() =&gt; {<br/>    interpolatorRef.current = interpolate(fromPath, toPath, {<br/>      maxSegmentLength: 0.1,<br/>    });<br/>  }, [fromPath, toPath]);<br/><br/>  // animate value from 0 to 1 <br/>  const [progress, setProgress] = useState(0);<br/>  useEffect(() =&gt; {<br/>    animate(0, 1, {<br/>      ...animation,<br/>      onUpdate: (val) =&gt; {<br/>        setProgress(val);<br/>      },<br/>    });<br/>  }, [fromPath, toPath, animation]);<br/><br/>  // for each new animated progress value invoking<br/>  // interpolator and set a new inperpolated path into React state<br/>  const [path, setPath] = useState&lt;null | string&gt;(null);<br/>  useEffect(() =&gt; {<br/>    if (interpolatorRef.current) {<br/>      setPath(interpolatorRef.current(progress));<br/>    }<br/>  }, [progress]);<br/><br/>  if (!path) {<br/>    return null;<br/>  }<br/><br/>  return &lt;path d={path} fill='#FBB503' /&gt;;<br/>};</span></pre><p id="fbd6" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">我们需要使用这个组件，每两秒钟，我们创建一个新的序列<code class="fe mm mn mo mp b">fromPath</code>和<code class="fe mm mn mo mp b">toPath</code>:</p><pre class="kj kk kl km gt mz mp na bn nb nc bi"><span id="9c02" class="nd kz it mp b be ne nf l ng nh">const circlePath = '...';<br/>const moonPath = '...';<br/>const bowPath = '...';<br/>const crossPath = '...';<br/>const starPath = '';<br/><br/>const paths = [circlePath, moonPath, bowPath, crossPath, starPath];<br/><br/>const MorphMoonToSun = () =&gt; {<br/>  const [index, setIndex] = useState(0);<br/><br/>  useInterval(() =&gt; {<br/>    setIndex((prev) =&gt; prev + 1);<br/>  }, 2000);<br/><br/>  return (<br/>    &lt;div style={styles.container}&gt;<br/>      &lt;svg viewBox='0 0 52 52' style={styles.svg}&gt;<br/>        &lt;MorphPath<br/>          fromPath={paths[index % paths.length]}<br/>          toPath={paths[(index + 1) % paths.length]}<br/>          animation={{ duration: 1 }}<br/>        /&gt;<br/>      &lt;/svg&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="b28c" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">干得好。没那么难。</p><h1 id="ba3f" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">2.动画描边属性</h1><p id="b203" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">另一个非常常用的动画。这是一个笔画属性的动画，我们可以看一下如何动态绘制路径，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e944" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">这里最酷的部分是它实现起来非常简单。该动画仅基于两个CSS属性<code class="fe mm mn mo mp b">— stroke-dasharray</code>和<code class="fe mm mn mo mp b">stroke-dashofset</code>。这些属性负责定义用于绘制形状轮廓的虚线和间隙图案:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/bec99864a9e479027145e90d922a2cba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HtqMgR_F4Y_wj5VSoSd2Gw.jpeg"/></div></div></figure><p id="024f" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">因此，如果我们知道路径的长度(我们可以通过JS API提取它)，我们可以创建一个模式，其中间隔和破折号的长度等于路径的长度。通过操纵偏移值，我们可以创建一个类似于开始绘制笔画的效果，但从字面上看，这意味着我们沿着笔画路径移动一条虚线:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/a97b8d4c28a505feab60df480ed5759c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uaoBECis46VHJf69iR4-kQ.gif"/></div></div></figure><p id="04e7" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">你可以玩这个沙盒来更深入地理解正在发生的事情(改变滚动条，看看路径是如何变化的):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="676a" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">让我们总结一下我们将要实现的内容:</p><ul class=""><li id="b199" class="nm nn it ls b lt ms lw mt lz no md np mh nq ml nr ns nt nu bi translated">定义路径长度(JS为<code class="fe mm mn mo mp b">path.getTotalLength()</code>提供了一个特殊API，并将这个值设置为<code class="fe mm mn mo mp b">stroke-dasharray</code>。它将在动画时间内保持静态</li><li id="92b2" class="nm nn it ls b lt nv lw nw lz nx md ny mh nz ml nr ns nt nu bi translated">将<code class="fe mm mn mo mp b">stroke-dashofset</code>属性从<code class="fe mm mn mo mp b">-totalLengthPath</code>动画到<code class="fe mm mn mo mp b">0</code></li></ul><p id="d86b" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">该组件可能如下所示:</p><pre class="kj kk kl km gt mz mp na bn nb nc bi"><span id="8646" class="nd kz it mp b be ne nf l ng nh">import { animate, Spring, Tween } from "framer-motion";<br/>import { useEffect, useRef, useState } from "react";<br/><br/>type AnimatedPathProps = {<br/>  path: string;<br/>  animation?: (Tween | Spring) &amp; { delay?: number; type?: "tween" | "spring" };<br/>};<br/><br/>const AnimatedPath = ({ path, animation }: AnimatedPathProps) =&gt; {<br/>  const pathRef = useRef&lt;SVGPathElement&gt;(null);<br/>  const [totalPathLength, setTotalPathLength] = useState(0);<br/>  const [animatedOffset, setAnimatedOffset] = useState(-totalPathLength);<br/>  <br/>  // via JS API calculate length of path<br/>  // and defining stroke-dasharray propert with pattern<br/>  // where length of dash and gap equal total length of path<br/>  useEffect(() =&gt; {<br/>    if (pathRef.current) {<br/>      const pathLength = pathRef.current.getTotalLength();<br/>      setTotalPathLength(pathLength);<br/>      setAnimatedOffset(-pathLength);<br/>    }<br/>  }, []);<br/><br/>  // animate offset of dashes and change<br/>  // value in a range [-totalPath:ength, 0]<br/>  useEffect(() =&gt; {<br/>    animate(-totalPathLength, 0, {<br/>      ...animation,<br/>      onUpdate: (val) =&gt; {<br/>        setAnimatedOffset(() =&gt; val);<br/>      }<br/>    });<br/>  }, [totalPathLength, animation]);<br/><br/>  return (<br/>    &lt;path<br/>      d={path}<br/>      ref={pathRef}<br/>      stroke="red"<br/>      fill="none"<br/>      strokeWidth={10}<br/>      strokeDasharray={totalPathLength}<br/>      strokeDashoffset={animatedOffset}<br/>    /&gt;<br/>  );<br/>};<br/><br/>export default AnimatedPath;</span></pre><p id="0082" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">下面是我们如何使用这个组件:</p><pre class="kj kk kl km gt mz mp na bn nb nc bi"><span id="53c1" class="nd kz it mp b be ne nf l ng nh">import AnimatedPath from "./components/AnimatedPath";<br/>import { useInterval } from "usehooks-ts";<br/>import "./styles.css";<br/>import { useState } from "react";<br/><br/>const defaultPath = [<br/>  { path: "...path for letter 1" },<br/>  { path: "...path for letter 2" },<br/>  // ... other path letters<br/>];<br/><br/>const animationDuration = 0.8;<br/><br/>export default function App() {<br/>  return (<br/>    &lt;div style={styles.container}&gt;<br/>      &lt;svg<br/>        viewBox="0 0 2600 1350"<br/>        width="500"<br/>        style={styles.svg}<br/>      &gt;<br/>        {defaultPath.map((path, i) =&gt; (<br/>          &lt;AnimatedPath<br/>            path={path.path}<br/>            key={i}<br/>            animation={{<br/>              duration: animationDuration,<br/>              delay: i * animationDuration * 0.5<br/>            }}<br/>          /&gt;<br/>        ))}<br/>      &lt;/svg&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="b26a" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">对于任何其他细节，你可以看看上面附加的代码沙箱。</p><h1 id="56d8" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">3.使用SVG遮罩</h1><p id="5a4e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">您应该注意到<code class="fe mm mn mo mp b">&lt;mask/&gt;</code>元素，它定义了将当前对象合成到背景中的alpha蒙版。当你将遮罩应用于特定元素时，白色像素下的所有内容都将可见，黑色像素下的所有内容都将不可见。</p><p id="5fb3" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">假设我们有两张由波兰餐饮服务提供的令人惊叹的菜肴图片，让我们将它们一张一张地放在SVG中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/775105f06edf1a00516ce7ff75b00aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YTn2c5fN-D1GrRRzwAoatA.jpeg"/></div></div></figure><p id="b7c5" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">在Figma中，让我们也创建任何填充白色的任意形状(记住，白色像素下的所有内容都将在蒙版中可见)。它可能看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/3d88968c7fae664eabccf5182a45a7da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmjzrk5MDSVWAfksn7WKbQ.jpeg"/></div></div></figure><p id="c1e1" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">最后一步是使用我们在上一步中得到的路径作为SVG中的掩码:</p><p id="8c46" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">最终的SVG如下所示:</p><pre class="kj kk kl km gt mz mp na bn nb nc bi"><span id="1732" class="nd kz it mp b be ne nf l ng nh">&lt;svg viewBox='0 0 1050 1624' width='300'&gt;<br/>  &lt;mask id='transition'&gt;<br/>    &lt;path d="M-206 4.29153e-05H-57C-57 4.29153e-05 458.5 -84.5 406.5 136.5C354.5 357.5 568.5 257 611 438.5C653.5 620 495 694.5 495 819C495 943.5 644 986.5 644 1142.5C644 1298.5 383.74 1148.09 534.5 1467C557.9 1516.5 687.5 1509 637.5 1575C587.5 1641 -55.7292 1631.7 -57 1624H-206V4.29153e-05Z" fill="white"/&gt;<br/>  &lt;/mask&gt;<br/>  &lt;image href='/src/media/001.jpg' width="1050"/&gt;<br/>  &lt;image href='/src/media/002.jpg' width="1050" mask='url(#transition)' /&gt;<br/>&lt;/svg&gt;</span></pre><p id="4036" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">在这里，我们用<code class="fe mm mn mo mp b">id="transition"</code>在<code class="fe mm mn mo mp b">&lt;mask/&gt;</code>元素内放置蒙版路径，并为第二个图像分配一个新属性<code class="fe mm mn mo mp b">mask</code>，并定义将要使用哪个蒙版:<code class="fe mm mn mo mp b">mask='url(#transition)'</code>。</p><p id="58b3" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">最后，我们得到以下结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="39a0" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">但是挺无聊的。让我们在第一章中开发的组件<code class="fe mm mn mo mp b">MorphPath</code>的基础上添加一些动画。但在此之前，让我们在Figma中描绘一些中间路径(假设为0%、25%、50%、75%和100%)。它有助于更好地管理插值路径转换:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/a6b33d1f9c828282d1c39bb9ef5cf6dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6vcfVCpj6LuhDHBXLySsQ.jpeg"/></div></div></figure><p id="87f2" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">像往常一样，我们需要从每个路径的<code class="fe mm mn mo mp b">d</code>属性中提取字符串并定义常量:</p><pre class="kj kk kl km gt mz mp na bn nb nc bi"><span id="bc8c" class="nd kz it mp b be ne nf l ng nh">const path00 =<br/>  "M-192 -1H-43C-43 -1 -129 87 -135 164C-141 241 -67.2419 331.14 -43 405C3 545.151 34.5 685 -14 815C-62.5 945 -91.5 928 -25.5 1128.5C40.5 1329 -94.0519 1351 -25.5 1504C9 1581 -41.1948 1633.94 -43 1623H-192V-1Z";<br/>const path25 =<br/>  "M-206 0H-57C-57 0 102.5 27.5 179 151.5C255.5 275.5 179 275.5 179 467C179 658.5 395.5 699.5 395.5 824C395.5 948.5 90 980 90 1136C90 1292 373.5 1155 303.5 1496C276.832 1625.91 -55.1948 1634.94 -57 1624H-206V0Z";<br/>const path50 =<br/>  "M-206 4.29153e-05H-57C-57 4.29153e-05 458.5 -84.5 406.5 136.5C354.5 357.5 568.5 257 611 438.5C653.5 620 495 694.5 495 819C495 943.5 644 986.5 644 1142.5C644 1298.5 383.74 1148.09 534.5 1467C557.9 1516.5 687.5 1509 637.5 1575C587.5 1641 -55.7292 1631.7 -57 1624H-206V4.29153e-05Z";<br/><br/>const path75 =<br/>  "M-206 8.7738e-05H-57C-57 8.7738e-05 831.5 -107.5 944.5 146C1057.5 399.5 798 289 840.5 470.5C883 652 1048.5 696.5 1048.5 821C1048.5 945.5 743.5 960 805.5 1119.5C867.5 1279 874.063 1218.5 944.5 1367.5C967.9 1417 1003.5 1573 910 1622.5C816.5 1672 -55.7292 1631.7 -57 1624H-206V8.7738e-05Z";<br/>const path100 =<br/>  "M-206 7.62939e-05H-57C-57 7.62939e-05 975.5 -291.5 1088.5 -38C1201.5 215.5 1118 274 1160.5 455.5C1203 637 1048.5 696.5 1048.5 821C1048.5 945.5 1081 1022 1143 1181.5C1205 1341 1115.06 1391 1185.5 1540C1208.9 1589.5 1094 1622 1000.5 1671.5C907 1721 -55.7292 1631.7 -57 1624H-206V7.62939e-05Z";<br/><br/>const paths = [path00, path25, path50, path75, path100];</span></pre><p id="cb26" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">因为我们已经实现了<code class="fe mm mn mo mp b">MorphPath</code>组件，所以最终的代码应该是这样的:</p><pre class="kj kk kl km gt mz mp na bn nb nc bi"><span id="96a0" class="nd kz it mp b be ne nf l ng nh">// some code skipped for brevity, the full version<br/>// see in codesanbox attech below<br/>import { MorphPath } from "./components/MorphPath";<br/><br/>const path00 = '...';<br/>const path25 = '...';<br/>const path50 = '...';<br/>const path75 = '...';<br/>const path100 = '...';<br/><br/>const paths = [path00, path25, path50, path75, path100];<br/><br/>export default function App() {<br/>  const [pathIndex, setPathIndex] = useState(0);<br/><br/>  useInterval(() =&gt; {<br/>    setPathIndex((prev) =&gt; prev + 1);<br/>  }, 1000);<br/><br/>  return (<br/>    &lt;div style={styles.container}&gt;<br/>      &lt;svg viewBox="0 0 525 813" style={styles.svg}&gt;<br/>        &lt;mask id="transition"&gt;<br/>          &lt;MorphPath<br/>            fromPath={paths[pathIndex % paths.length]}<br/>            toPath={paths[(pathIndex + 1) % paths.length]}<br/>            fill="white"<br/>            animation={{ duration: 1 }}<br/>          /&gt;<br/>        &lt;/mask&gt;<br/>        &lt;image href="/001.jpg" /&gt;<br/>        &lt;image href="/002.jpg" mask="url(#transition)" /&gt;<br/>      &lt;/svg&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="3261" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">最终的结果看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="af8f" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">我希望你喜欢阅读这篇文章。我很高兴看到任何关于应该被涵盖的项目的评论，并且我感谢任何对改进文章的帮助。</p><p id="4b42" class="pw-post-body-paragraph lq lr it ls b lt ms ju lv lw mt jx ly lz mu mb mc md mv mf mg mh mw mj mk ml im bi translated">谢谢你。</p></div></div>    
</body>
</html>