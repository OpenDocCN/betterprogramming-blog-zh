<html>
<head>
<title>What’s New in Angular 10</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular 10的新功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-10-new-features-dbc779061dc8?source=collection_archive---------0-----------------------#2020-06-23">https://betterprogramming.pub/angular-10-new-features-dbc779061dc8?source=collection_archive---------0-----------------------#2020-06-23</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="d9ed" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://rakiabensassi.medium.com/list/software-engineering-7a179a23ebfd" rel="noopener">网页开发</a></h2><div class=""/><div class=""><h2 id="0d50" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">Google开发的web框架带给我们的新特性和突破性变化</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/7b263e944779b05a85c3795135ab1d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1Ns9GhC2yobPNPj0"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">亚历克斯·科特利亚斯基在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7f77" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">Angular 10是跨整个平台的主要版本，包括框架、Angular材料和CLI，将于6月24日推出。这意味着什么？</p><p id="0a62" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">就像很多Angular社区的成员一样，我尝试着去关注新闻，看看Angular 10给我们带来了什么。我读了很多文章，但我觉得我在编程世界里是个新手。我多年的Angular 经验并没有帮助我很好地理解那些文章在谈论什么。</p><p id="37dc" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">因此，我决定写一篇新文章，介绍Angular 10中的新特性，让它更容易理解。</p><p id="b046" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在我向您介绍最重要的变化以及它们对您、您的项目和Angular landscape的意义之前，我将解释一些有趣的事情，并揭开伴随的术语的神秘面纱。让我们开始吧。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="99d4" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">术语</h1><h2 id="3296" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">微syntax</h2><p id="8c2e" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">Angular <a class="ae li" href="https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855" rel="noopener ugc nofollow" target="_blank"> microsyntax </a>允许您以紧凑、友好的字符串形式配置指令。microsyntax解析器将该字符串翻译成<code class="fe nu nv nw nx b">&lt;ng-template&gt;</code>上的属性。所以你不用写<code class="fe nu nv nw nx b">&lt;ng-template ngFor [ngForOf]="items"&gt;&lt;div&gt;{{item}}&lt;/div&gt;&lt;/ng-template</code>，而是写<code class="fe nu nv nw nx b">&lt;div *ngFor="let item of items"&gt;{{item}}&lt;/div&gt;</code>。</p><h2 id="ae13" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">绑定表达式</h2><p id="d568" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">Angular中有四种不同类型的数据绑定:</p><ul class=""><li id="9ab6" class="ny nz iu ll b lm ln lp lq ls oa lw ob ma oc me od oe of og bi translated"><strong class="ll je">事件绑定:</strong>例如:<code class="fe nu nv nw nx b">&lt;button <strong class="ll je">(</strong>click<strong class="ll je">)</strong>="updateName()"&gt;Update button&lt;/button&gt;</code></li><li id="04bd" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">双向数据绑定:</strong>一种数据从组件到视图双向流动的机制。组件和视图总是同步的，在任何一端所做的更改都会立即双向更新。例如:<code class="fe nu nv nw nx b">&lt;input <strong class="ll je">[(</strong>ngModel<strong class="ll je">)]</strong>="name"&gt;</code>。</li><li id="f940" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">插值:</strong>表示组件中变量的文本放在模板的双花括号中。例子:<code class="fe nu nv nw nx b">&lt;p&gt;<strong class="ll je">{{</strong> name <strong class="ll je">}}</strong>&lt;/p&gt;</code>。</li><li id="ddd1" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">属性绑定:</strong>属性绑定是一种单向机制，允许您设置视图元素的属性。例如:<br/> <code class="fe nu nv nw nx b"> &lt;button <strong class="ll je">[</strong>disabled<strong class="ll je">]</strong>="buttonDisabled"&gt;&lt;/button&gt;</code>。</li></ul><h2 id="c99b" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">抽象语法树</h2><p id="7a94" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">AST是<em class="om">抽象语法树的缩写。</em>它是从编程语言中的语句和表达式生成的标记的表示。使用AST，解释器或编译器可以生成机器代码或评估指令。角度模板AST是HTML AST的转换和注释版本，它具有以下功能:</p><ul class=""><li id="d399" class="ny nz iu ll b lm ln lp lq ls oa lw ob ma oc me od oe of og bi translated">将角度模板语法快捷方式，如<code class="fe nu nv nw nx b">*ngFor</code>和<code class="fe nu nv nw nx b">[name]</code>，转换成它们的规范版本(和<code class="fe nu nv nw nx b">bind-name</code>)</li><li id="5a38" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated">收集引用(<code class="fe nu nv nw nx b">#</code>属性)和变量(<code class="fe nu nv nw nx b">let-</code>属性)。</li><li id="32fa" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated">使用收集的变量和引用解析和转换绑定表达式AST中的绑定表达式</li></ul><h2 id="e07d" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">简洁的</h2><p id="85ca" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">terser是一个用于ES6+的JavaScript解析器、解析器和压缩器工具包。Angular CLI团队在Angular CLI 7.0中为构建的缩小阶段转移到terser，因为不再维护uglify-es，而且uglify-js不支持ES6+。</p><h2 id="7c4d" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">' UrlMatcher '</h2><p id="4c6c" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated"><code class="fe nu nv nw nx b">UrlMatcher</code>是根据URL匹配路线的功能。当<code class="fe nu nv nw nx b">path</code>和<code class="fe nu nv nw nx b">pathMatch</code>的组合不够有表现力时，你可以为<code class="fe nu nv nw nx b">Route.matcher</code>实现一个定制的URL匹配器。</p><pre class="kt ku kv kw gu on nx oo op aw oq bi"><span id="1391" class="ne mn iu nx b gz or os l ot ou">type <a class="ae li" href="https://angular.io/api/router/UrlMatcher" rel="noopener ugc nofollow" target="_blank">UrlMatcher</a> = (segments: <a class="ae li" href="https://angular.io/api/router/UrlSegment" rel="noopener ugc nofollow" target="_blank">UrlSegment</a>[], group: <a class="ae li" href="https://angular.io/api/router/UrlSegmentGroup" rel="noopener ugc nofollow" target="_blank">UrlSegmentGroup</a>, route: <a class="ae li" href="https://angular.io/api/router/Route" rel="noopener ugc nofollow" target="_blank">Route</a>) =&gt; <a class="ae li" href="https://angular.io/api/router/UrlMatchResult" rel="noopener ugc nofollow" target="_blank">UrlMatchResult</a>;</span></pre><p id="6c65" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">以下匹配器匹配HTML文件:</p><pre class="kt ku kv kw gu on nx oo op aw oq bi"><span id="684c" class="ne mn iu nx b gz or os l ot ou">content_copy<!-- -->export function htmlFiles(url: <a class="ae li" href="https://angular.io/api/router/UrlSegment" rel="noopener ugc nofollow" target="_blank">UrlSegment</a>[]) {<br/>  return url.length === 1 &amp;&amp; url[0].path.endsWith('.html') ? ({consumed: url}) : null;<br/>}</span><span id="384c" class="ne mn iu nx b gz ov os l ot ou">export const routes = [{ matcher: htmlFiles, component: AnyComponent }];</span></pre><h2 id="8dc6" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">巴泽尔</h2><p id="d228" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">Bazel 是Angular CLI的构建器，在版本10中已被弃用。这种不赞成的理由如下:</p><ul class=""><li id="f362" class="ny nz iu ll b lm ln lp lq ls oa lw ob ma oc me od oe of og bi translated">Bazel网络生态系统仍在快速发展</li><li id="8471" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated">Angular Ivy编译器的引入使得以更快、更有效的方式使用Bazel成为可能</li><li id="74e6" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated">如果不进行权衡，基于webpack的Angular CLI的功能对等性很难实现，这对于许多Angular用户来说是不可接受的</li></ul><h2 id="d344" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">角度语言服务</h2><p id="6f8b" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">Angular Language Service是一个分析引擎，它集成到您的代码编辑器中，并为它提供了一种在Angular模板中完成、跟踪引用、错误、提示和导航的方法。</p><p id="bc77" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">它可以在单独的HTML文件中使用外部模板，也可以使用内嵌模板。您的编辑器会自动检测到您正在打开一个角度文件。然后它使用Angular语言服务来读取你的<code class="fe nu nv nw nx b">tsconfig.json</code>文件，找到你的应用程序中所有的模板，然后为你打开的任何模板提供语言服务。</p><div class="kt ku kv kw gu ab cb"><figure class="ow kx ox oy oz pa pb paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><img src="../Images/fc88f9ef25f7cfdb9c9b6789511a3b1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:336/1*d1BpEbjTPTHhX7b85fII5w.gif"/></div></figure><figure class="ow kx pc oy oz pa pb paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><img src="../Images/8f2c655222ece8a45b04eb928c49603a.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/1*n6leOIjnnvs9ixs5T4CAmA.gif"/></div></figure><figure class="ow kx pd oy oz pa pb paragraph-image"><img src="../Images/dc5372cda8125476f07ec9f75491f54f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*njtQZnLHaLarDmY_6j5SDg.gif"/><p class="le lf gk gi gj lg lh bd b be z dk pe di pf pg translated"><a class="ae li" href="https://angular.io/guide/language-service" rel="noopener ugc nofollow" target="_blank">角语服务</a></p></figure></div><p id="9827" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">它可以作为Visual Studio代码、WebStorm和Sublime Text的扩展。您可以使用以下命令<a class="ae li" href="https://angular.io/guide/language-service" rel="noopener ugc nofollow" target="_blank">安装它</a>:</p><pre class="kt ku kv kw gu on nx oo op aw oq bi"><span id="208a" class="ne mn iu nx b gz or os l ot ou">npm install --save-dev @angular/language-service</span></pre><p id="4209" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe nu nv nw nx b">@angular/language-service</code>是TypeScript语言服务的包装器(就像<code class="fe nu nv nw nx b">ngtsc</code>包装了<code class="fe nu nv nw nx b">tsc</code>)，并通过对角度概念的具体理解扩展了对TypeScript的分析。它可以在Typescript中的组件类和模板中的表达式之间架起一座桥梁。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="77e9" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">编译器哲学</h1><p id="ad89" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">Angular提供了两种编译应用程序的方法:</p><ul class=""><li id="cfa2" class="ny nz iu ll b lm ln lp lq ls oa lw ob ma oc me od oe of og bi translated">实时(JIT)，运行时在浏览器中编译你的应用。这是默认设置，直到角度8。</li><li id="0f4a" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated">提前(AOT)，在构建时编译你的应用和库。这是自Angular 9以来的默认设置。</li></ul><p id="f162" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">Ivy完全重写了编译器(和运行时),目的是:</p><ul class=""><li id="3b97" class="ny nz iu ll b lm ln lp lq ls oa lw ob ma oc me od oe of og bi translated">达到更好的构建时间(通过更多的增量编译)</li><li id="7a55" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated">达到更好的构建规模(生成的代码与树抖动更兼容)</li><li id="6e61" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated">释放新的潜在特性(元编程或高阶组件、组件而不是模块的延迟加载、不基于Zone.js的新变化检测系统等)..)</li></ul><p id="fa22" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">视图引擎是Ivy的前身。</p><p id="7556" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们可以将Ivy上所做的工作分为三类，如<a class="ae li" href="https://github.com/angular/angular/blob/master/packages/core/src/render3/STATUS.md" rel="noopener ugc nofollow" target="_blank">实现状态</a>中所述:</p><ol class=""><li id="b507" class="ny nz iu ll b lm ln lp lq ls oa lw ob ma oc me ph oe of og bi translated"><code class="fe nu nv nw nx b">@angular/compiler-cli</code>:打印transformer管道，包括两个命令行工具:<code class="fe nu nv nw nx b">ngtsc</code>和<code class="fe nu nv nw nx b">ngcc</code></li><li id="65ef" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me ph oe of og bi translated">Ivy编译器，将装饰者转换成Ivy</li><li id="ea59" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me ph oe of og bi translated"><code class="fe nu nv nw nx b">@angular/core</code>:可以被<code class="fe nu nv nw nx b">@angular/compiler</code>转换的装饰者</li></ol><p id="9d38" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">为了理解编译器是如何设置的，理解幕后的Typescript体系结构是有帮助的。</p><h2 id="e15c" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">打字稿传输程序体系结构</h2><p id="1cec" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">下图显示了正常的<code class="fe nu nv nw nx b">tsc</code>流程以及将<code class="fe nu nv nw nx b">.ts</code>文件转换成<code class="fe nu nv nw nx b">.js</code>文件的步骤。(<code class="fe nu nv nw nx b">tsc</code>来自Typescript CLI。它编译由<code class="fe nu nv nw nx b">tsconfig.json</code>定义的最接近的项目。)</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pi"><img src="../Images/5eef4be60ba32db2c24de19d138febb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*XByFtwFWgmevLgrka-6DyQ.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://github.com/ikatyang/angular-html-parser/blob/master/packages/compiler/design/architecture.md" rel="noopener ugc nofollow" target="_blank">打字稿架构</a></p></figure><p id="0a36" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">以下是对此流程的简要解释:</p><ul class=""><li id="a6fc" class="ny nz iu ll b lm ln lp lq ls oa lw ob ma oc me od oe of og bi translated"><strong class="ll je">解析:</strong>一个传统的递归下降解析器，做了一点调整以支持增量解析，它发出一个AST。这是一个帮助识别当前文件中导入了哪些文件的树。</li><li id="8adb" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">类型检查器:</strong>该步骤构建一个符号表，然后对文件中的每个表达式进行类型分析，报告发现的错误</li><li id="6f34" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je"> Transform: </strong>一组AST到AST的转换，执行各种任务，比如删除类型声明，将模块和类声明降级为ES5，将<code class="fe nu nv nw nx b">async</code>方法转换为状态机等。</li><li id="1856" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">打印:</strong>TS到JS的转换</li></ul><h2 id="63bd" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">角度编译步骤</h2><p id="e69f" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">Angular编译器构建在常规TypeScript体系结构之上，使用它的三个主要阶段:程序创建、类型检查和发射——外加一个分析步骤和一个解析步骤:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pj"><img src="../Images/b0b3d5388abc87e781cc2c141bffe269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*xnOmwP7uV9oZKg9IQhFi8w.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://www.youtube.com/watch?v=anphffaCZrQ&amp;feature=youtu.be" rel="noopener ugc nofollow" target="_blank">角度编译器架构</a></p></figure><ul class=""><li id="442d" class="ny nz iu ll b lm ln lp lq ls oa lw ob ma oc me od oe of og bi translated"><strong class="ll je">程序创建:</strong>从<code class="fe nu nv nw nx b">tsconfig.json</code>开始</li><li id="5422" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">分析:</strong>逐类检查TS代码，寻找有棱角的东西并收集关于结构的信息</li><li id="4669" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated">解决:立刻查看整个程序，理解它并做出优化决策</li><li id="8345" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated">类型检查:就像普通的TypeScript编译器一样，它验证组件模板中的表达式并报告错误。这个过程没有被<code class="fe nu nv nw nx b">ngtsc</code>扩展或修改。</li><li id="aa87" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je"> Emit: </strong>为每个修饰类生成角度代码，并对其进行修补。它将类型脚本代码转换为JavaScript。整个过程中最昂贵的操作。</li></ul><h2 id="5fbe" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">两个新的编译器入口点</h2><p id="963b" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">Angular引入了两个编译器入口点:<code class="fe nu nv nw nx b">ngtsc</code>和<code class="fe nu nv nw nx b">ngcc</code>。</p><p id="8a0b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe nu nv nw nx b"><strong class="ll je">ngtsc</strong></code></p><p id="32b4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">编译兼容Ivy的代码。这是一个从类型脚本到JavaScript的转换程序，它寻找像<code class="fe nu nv nw nx b">@Component</code>这样的角度装饰器，并用它们特定的角度运行时指令/对应物替换它们，像<code class="fe nu nv nw nx b">ɵɵdefineComponent</code>。这是围绕<code class="fe nu nv nw nx b">tsc</code>的最小包装。当<code class="fe nu nv nw nx b">tsconfig.json</code>文件中的<code class="fe nu nv nw nx b">angularCompilerOption</code> <code class="fe nu nv nw nx b">enableIvy</code>标志设置为<code class="fe nu nv nw nx b">true</code>时，<code class="fe nu nv nw nx b">ngc</code>作为<code class="fe nu nv nw nx b">ngtsc</code>运行。</p><p id="df84" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je">编译流程</strong></p><p id="7ac4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当<code class="fe nu nv nw nx b">ngtsc</code>开始运行时，它首先解析<code class="fe nu nv nw nx b">tsconfig.json</code>文件，然后创建一个<code class="fe nu nv nw nx b">ts.Program</code>。在运行上述转换之前，需要做几件事情:</p><ul class=""><li id="41f6" class="ny nz iu ll b lm ln lp lq ls oa lw ob ma oc me od oe of og bi translated">必须为包含装饰器的输入源文件收集元数据</li><li id="df10" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><code class="fe nu nv nw nx b">@Component</code>decorator中列出的资源文件必须异步解析。例如，CLI可能希望运行webpack来产生对<code class="fe nu nv nw nx b">@Component</code>的<code class="fe nu nv nw nx b">styleUrls</code>属性的<code class="fe nu nv nw nx b">.css</code>输入。</li><li id="e9bd" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated">必须运行诊断，这将创建<code class="fe nu nv nw nx b">TypeChecker</code>并触及程序中的每个节点(一个相当昂贵的操作)</li></ul><p id="65d2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe nu nv nw nx b"><strong class="ll je">ngcc</strong></code></p><p id="1498" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe nu nv nw nx b">ngcc</code>代表角度兼容性编译器。它将Ivy之前的模块(旧样式)转换为Ivy兼容的代码。它处理来自npm的代码并生成等价的Ivy版本，就好像代码是用<code class="fe nu nv nw nx b">ngtsc</code>编译的一样。<code class="fe nu nv nw nx b">ngcc</code>也可以作为webpack这样的代码加载器的一部分运行，让来自<code class="fe nu nv nw nx b">node_modules</code>的包动态传输。</p><p id="567f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je">如何使用</strong> <code class="fe nu nv nw nx b"><strong class="ll je">ngcc</strong></code></p><p id="17d9" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">通过添加一个<code class="fe nu nv nw nx b">postinstall</code> npm脚本，可以在每次安装<code class="fe nu nv nw nx b">node_modules</code>后运行<code class="fe nu nv nw nx b">ngcc</code>:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pk"><img src="../Images/adf1efa2bfcab1397513aa0c3bce8fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*cWInOcv-8pSnPX9ZtljkvA.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">在'<a class="ae li" href="https://angular.io/guide/ivy" rel="noopener ugc nofollow" target="_blank"> postinstall </a>中使用' ngcc '的一种方法</p></figure><p id="51e3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果您正在使用Angular 8——这是Ivy的第一步——并且您想在启用Ivy的情况下启动一个新项目，您可以使用带有<code class="fe nu nv nw nx b">ng new</code>命令的<code class="fe nu nv nw nx b">--enable-ivy</code> <strong class="ll je"> </strong>标志:</p><pre class="kt ku kv kw gu on nx oo op aw oq bi"><span id="57f0" class="ne mn iu nx b gz or os l ot ou">ng new shiny-ivy-app --enable-ivy</span></pre><p id="d84b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">新项目是为Ivy自动配置的。在项目的<em class="om"> </em> <code class="fe nu nv nw nx b">tsconfig.app.json</code>文件中<code class="fe nu nv nw nx b">enableIvy</code>选项设置为<code class="fe nu nv nw nx b">true</code>:</p><pre class="kt ku kv kw gu on nx oo op aw oq bi"><span id="5b70" class="ne mn iu nx b gz or os l ot ou">"angularCompilerOptions": {<br/>  "enableIvy": true<br/>}</span></pre><p id="5fc5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">最后，您可以通过在新创建的项目文件夹中执行<code class="fe nu nv nw nx b">ngc</code>命令来运行编译器:</p><pre class="kt ku kv kw gu on nx oo op aw oq bi"><span id="4a92" class="ne mn iu nx b gz or os l ot ou">node_modules/.bin/ngc</span></pre><p id="6abf" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然后，您可以在<code class="fe nu nv nw nx b">dist/out-tsc</code>文件夹中检查生成的代码。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="506d" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">Angular 10的主要特点</h1><p id="f9f6" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">对谷歌开发的框架的升级更侧重于生态系统的改进，而不是新功能。角度10设置为小于以前的版本。到目前为止，最新初步版本中的主要特性包括:</p><h2 id="5f90" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">特征</h2><ul class=""><li id="f083" class="ny nz iu ll b lm np lp nq ls pl lw pm ma pn me od oe of og bi translated">此外，可选的更严格的设置在使用<code class="fe nu nv nw nx b">ng new</code>通过<code class="fe nu nv nw nx b">ng new -- strict</code>创建新的工作空间时提供了更严格的项目设置。启用此标志将使用新设置初始化新项目，以提高可维护性，帮助捕捉错误，并允许CLI对应用程序进行高级优化。</li><li id="68a2" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><code class="fe nu nv nw nx b"><strong class="ll je">language-service</strong></code> <strong class="ll je"> : </strong>增加了一个编译器接口，封装了实际的<code class="fe nu nv nw nx b">ngtsc</code>编译器。特定于<code class="fe nu nv nw nx b">language-service</code>的编译器使用项目接口管理多个<a class="ae li" href="https://github.com/angular/angular/commit/1142c37" rel="noopener ugc nofollow" target="_blank">类型检查</a>文件，根据需要创建<code class="fe nu nv nw nx b">ScriptInfo</code>文件。</li><li id="008c" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><code class="fe nu nv nw nx b"><strong class="ll je">language-service</strong></code> <strong class="ll je"> : </strong>去除HTML实体的自动补全。自动完成功能将从HTML实体中移除，如<code class="fe nu nv nw nx b">&amp;amp;</code>、<code class="fe nu nv nw nx b">&amp;lt;</code>等。，因为它超出了Angular LS的核心功能，而且它的价值和性能成本都值得怀疑。</li><li id="6a68" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">编译器:</strong>为属性读取和方法调用增加了名称跨度</li><li id="98b2" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">编译器:</strong>依赖信息和<code class="fe nu nv nw nx b">ng-content</code>选择器被添加到元数据中。这个<a class="ae li" href="https://github.com/angular/angular/pull/35695" rel="noopener ugc nofollow" target="_blank">提议的编译器特性</a>将提供对工具有用的额外元数据，例如Angular语言服务，提供为库中定义的指令/组件提供建议的能力。</li><li id="5f17" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">编译器:</strong> <a class="ae li" href="https://github.com/angular/angular/pull/36133" rel="noopener ugc nofollow" target="_blank">将microsyntax表达式的<code class="fe nu nv nw nx b">ExpressionBinding</code>中的正确值范围的</a>传播到<code class="fe nu nv nw nx b">ParsedProperty</code>，这又将范围传播到模板ASTs(VE和Ivy)</li><li id="4892" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><code class="fe nu nv nw nx b"><strong class="ll je">ngcc</strong></code> <strong class="ll je"> : </strong>允许配置异步锁定超时。这增加了对用于设置<code class="fe nu nv nw nx b">AsyncLocker</code>的<code class="fe nu nv nw nx b">retryAttempts</code>和<code class="fe nu nv nw nx b">retryDelay</code>选项的<code class="fe nu nv nw nx b">ngcc.config.js</code>文件的支持。集成测试添加了一个新的超时检查，并使用<code class="fe nu nv nw nx b">ngcc.config.js</code>来减少超时时间，以防止测试花费太长时间。</li><li id="ceb2" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><code class="fe nu nv nw nx b"><strong class="ll je">ngcc</strong></code> <strong class="ll je"> : </strong>基于程序的<a class="ae li" href="https://github.com/angular/angular/commit/f3ccd29" rel="noopener ugc nofollow" target="_blank">入口点查找器</a>已经实现。该查找器被设计为只处理由<code class="fe nu nv nw nx b">tsconfig.json</code>文件定义的程序可到达的入口点。如果安装了大量的依赖项，但实际上只有一小部分入口点被导入到应用程序中，那么使用这个选项可以加快处理速度。</li><li id="8110" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je"> Bazel: </strong>从闭包到开发模式文件的显式映射被公开。这个特性针对的是开发工具，它必须将产品构建输入转换成它们的开发模式等价物。</li><li id="805e" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">本地化:</strong>支持多个翻译文件的合并。以前，每个语言环境只能加载一个翻译文件。现在，用户可以为每个地区指定多个文件，每个文件的翻译将通过一个消息ID合并在一起。合并是基于先赢的方法。因此，如果您有三个要合并的文件— <code class="fe nu nv nw nx b">"a.xlf”</code>、<code class="fe nu nv nw nx b">"b.xmb"</code>和<code class="fe nu nv nw nx b">"c.json"</code>——那么将使用来自<code class="fe nu nv nw nx b">"a.xlf”</code>的任何消息，而不是来自<code class="fe nu nv nw nx b">"b.xmb"</code>或<code class="fe nu nv nw nx b">"c.json"</code>的消息……等等。在实践中，这意味着您应该将文件按最重要的顺序放在第一位，然后进行后备翻译。</li><li id="7173" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">路由器:</strong>对于路由器来说，<code class="fe nu nv nw nx b">CanLoad</code>守卫现在可以返回<code class="fe nu nv nw nx b">Urltree</code>。一名<code class="fe nu nv nw nx b">CanLoad</code>护卫返回<code class="fe nu nv nw nx b">Urltree</code>取消当前导航并重定向。这与目前增加的<code class="fe nu nv nw nx b">CanActivate</code>守卫的行为相匹配。这不影响预压。一个<code class="fe nu nv nw nx b">CanLoad</code>保护块阻止任何预压；任何带有<code class="fe nu nv nw nx b">CanLoad</code>保护的路线都不会被预加载，保护也不会作为预加载的一部分被执行。</li><li id="78ef" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">角状材料:</strong>角状材料现在包括一个<a class="ae li" href="https://next.material.angular.io/components/datepicker/overview#date-range-selection" rel="noopener ugc nofollow" target="_blank">新的日期范围选择器</a>。要使用新的日期范围选择器，您可以使用<code class="fe nu nv nw nx b">mat-date-range-input</code>和<code class="fe nu nv nw nx b">mat-date-range-picker</code>组件。</li></ul><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj po"><img src="../Images/37de1b163a7c7b4b41ad0555674d8ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/0*cArB6i1vkamJ84sF"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">角度材料新日期范围选取器</p></figure><p id="2bb2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je">性能改进</strong></p><ul class=""><li id="477e" class="ny nz iu ll b lm ln lp lq ls oa lw ob ma oc me od oe of og bi translated"><code class="fe nu nv nw nx b"><strong class="ll je">compiler-cli</strong></code> <strong class="ll je"> : </strong>增量执行模板类型检查，将Ivy模板类型检查拆分成多个文件</li><li id="e875" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><code class="fe nu nv nw nx b"><strong class="ll je">ngcc</strong></code> <strong class="ll je"> : </strong>现在允许立即报告过时的锁文件。此外，在运行之间缓存一个解析过的<code class="fe nu nv nw nx b">.tsconfig</code>文件。</li><li id="039b" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><code class="fe nu nv nw nx b"><strong class="ll je">ngcc</strong></code> <strong class="ll je"> : </strong>减小入口点清单文件的大小。包的基本路径和入口点是已知的，所以不需要将它们存储在文件中。避免了存储不必要的空数组。以前，即使一个入口点不需要处理，<code class="fe nu nv nw nx b"><strong class="ll je">ngcc</strong></code>也会解析入口点的文件来计算依赖关系，这对于大型节点模块来说会花费很多时间。</li><li id="b8e6" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><code class="fe nu nv nw nx b"><strong class="ll je">ngcc</strong></code> <strong class="ll je"> : </strong>为了提高性能，<code class="fe nu nv nw nx b">basePaths</code>的计算被偷懒了，所以在<code class="fe nu nv nw nx b">TargetedEntryPointFinder</code>中只在需要时才工作。以前，<code class="fe nu nv nw nx b">basePaths</code>是在finder被实例化时计算的，这在目标入口点已经被处理的情况下是一种浪费。</li></ul><h2 id="dafa" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">重大变化</h2><ul class=""><li id="037d" class="ny nz iu ll b lm np lp nq ls pl lw pm ma pn me od oe of og bi translated"><strong class="ll je"> Typescript 3.9 </strong>现已推出，对TypeScript 3.8的支持已被移除。TypeScript 3.6和TypeScript 3.7也不再受支持。</li><li id="085e" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated">TSlib，包含帮助器函数的TypeScript的运行时库，已更新到<a class="ae li" href="https://github.com/microsoft/tslib/releases/tag/2.0.0" rel="noopener ugc nofollow" target="_blank"> v2.0. </a></li><li id="68e2" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated">用于TypeScript的TSLint静态分析工具已更新到版本6。</li><li id="9195" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated">Angular包格式不再包括ESM5或FESM5包，节省了运行Angular包和库的<code class="fe nu nv nw nx b">yarn</code>或<code class="fe nu nv nw nx b">npm install</code>时的下载和安装时间。</li><li id="26e8" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated">新项目的浏览器配置已更新，排除了较旧的、较少使用的浏览器。不赞成对Internet Explorer 9、Internet Explorer 10和Internet Explorer Mobile提供支持。</li><li id="83a6" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">服务人员:</strong>以前，从缓存中检索资源时会考虑<code class="fe nu nv nw nx b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Vary" rel="noopener ugc nofollow" target="_blank">Vary</a></code>头，这完全阻止了对缓存资产的检索(由于<code class="fe nu nv nw nx b">ServiceWorker</code>-实现细节)，并由于不同浏览器中的不一致/错误实现而导致不可预测的行为。现在，当从<code class="fe nu nv nw nx b">ServiceWorker</code>缓存中检索资源时，<code class="fe nu nv nw nx b">Vary</code>头被忽略，这可能导致资源被检索，即使它们的头是不同的。如果您的应用程序需要根据请求头区分其响应，请确保Angular <code class="fe nu nv nw nx b">ServiceWorker</code>配置了<a class="ae li" href="https://angular.io/guide/service-worker-config" rel="noopener ugc nofollow" target="_blank">以避免缓存受影响的资源。</a></li><li id="f2fe" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">路由器:</strong>任何返回<code class="fe nu nv nw nx b">EMPTY</code>的解析器都会取消导航。如果您想让导航继续，您需要更新解析器来发出一些值，(例如，<code class="fe nu nv nw nx b">defaultIfEmpty(...)</code>、<code class="fe nu nv nw nx b">of(..)</code>等)。</li><li id="3731" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">常见:</strong>更新了关于跨越午夜的日时段格式的逻辑。当使用<code class="fe nu nv nw nx b">b</code>或<code class="fe nu nv nw nx b">B</code>格式代码格式化时间时，呈现的字符串不能正确处理跨越数天的日周期。相反，这种逻辑正在退回到<code class="fe nu nv nw nx b">AM</code>的违约案例。这个逻辑已经过了更新，所以它匹配一天中超过午夜的时间，所以它现在会呈现正确的输出，例如在英语中的<code class="fe nu nv nw nx b">at night</code>。使用<code class="fe nu nv nw nx b">formatDate()</code>或<code class="fe nu nv nw nx b">DatePipe</code>或<code class="fe nu nv nw nx b">b</code>和<code class="fe nu nv nw nx b">B</code>格式代码的应用程序将受到这一变化的影响。</li><li id="db69" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated">关于未知元素的警告现在被记录为错误。这不会破坏你的应用程序，但是它可能会使那些不希望通过<code class="fe nu nv nw nx b">console.error</code>记录任何东西的工具出错。</li><li id="8ba6" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">核心:</strong> Angular npm包不再包含<em class="om"> </em> JSDoc <em class="om"> </em>注释来支持闭包编译器的高级优化。Angular包中对闭包编译器的支持是实验性的，已经中断了很长时间。从TS3.9开始，闭包不能与JavaScript emit一起使用。如需更多信息和更新，请点击此<a class="ae li" href="https://github.com/microsoft/TypeScript/issues/38374" rel="noopener ugc nofollow" target="_blank">链接</a>。<br/>如果您过去将闭包编译器与Angular一起使用，您可能会更好地直接使用从源代码构建的Angular包，而不是使用npm上的版本，后者主要针对webpack/Rollup + terser构建管道进行了优化。作为一个临时的解决方法，您可以考虑使用带有闭包标志<code class="fe nu nv nw nx b">--compilation_level=SIMPLE</code>的当前构建管道。这个标志将确保您的构建管道产生可构建和可运行的工件，代价是由于禁用了高级优化而增加了有效负载的大小。</li><li id="cfe7" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">核心:</strong>通用已成为<code class="fe nu nv nw nx b">ModuleWithProviders</code>的必备。<code class="fe nu nv nw nx b">ModuleWithProviders</code>模式需要一个泛型类型参数来与Ivy编译和呈现管道一起工作，但是在提交之前，View Engine允许省略泛型类型。如果开发人员在您的应用程序代码中使用没有泛型类型的<code class="fe nu nv nw nx b">ModuleWithProviders</code>，版本10的迁移将为您更新代码。</li></ul><p id="680f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">但是，如果开发人员正在使用视图引擎，并且依赖于省略了泛型类型的库，您现在会得到类似于以下内容的构建时错误:</p><pre class="kt ku kv kw gu on nx oo op aw oq bi"><span id="e9c7" class="ne mn iu nx b gz or os l ot ou">error TS2314: Generic type 'ModuleWithProviders&lt;T&gt;' requires 1 type argument(s).</span></pre><p id="2634" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在这种情况下，<code class="fe nu nv nw nx b">ngcc</code>帮不了你(因为是Ivy专用的)，迁移只覆盖应用代码。您应该联系库作者来修复他们的库，以便在他们使用该类时提供类型参数。作为一种变通方法，可以在<code class="fe nu nv nw nx b">.tsconfig</code>文件中将<code class="fe nu nv nw nx b">skipLibChecks</code>设置为<code class="fe nu nv nw nx b">false</code>，或者您可以更新您的应用程序以使用Ivy。</p><h2 id="21c9" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">错误修复</h2><ul class=""><li id="c7d3" class="ny nz iu ll b lm np lp nq ls pl lw pm ma pn me od oe of og bi translated"><strong class="ll je">路由器:</strong> <code class="fe nu nv nw nx b">UrlMatcher</code>现在被允许返回<code class="fe nu nv nw nx b">null</code></li><li id="5c1d" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">核心:</strong> <code class="fe nu nv nw nx b">undecorated-classes-with-decorated-fields</code>迁移不修饰派生类</li><li id="fce7" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated"><strong class="ll je">服务人员:</strong> <a class="ae li" href="https://github.com/angular/angular/pull/35870" rel="noopener ugc nofollow" target="_blank">防止</a>软件注册策略影响app稳定性</li><li id="56d4" class="ny nz iu ll b lm oh lp oi ls oj lw ok ma ol me od oe of og bi translated">已经修复了许多错误，包括编译器避免了多孔数组中的未定义表达式，以及<a class="ae li" href="https://github.com/angular/angular/pull/36367" rel="noopener ugc nofollow" target="_blank">内核避免了导入不存在的符号时的迁移错误</a>。对于<a class="ae li" href="https://github.com/angular/angular/pull/36200" rel="noopener ugc nofollow" target="_blank"> terser内联错误</a>，内核中也有一个变通方法。另一个bug修复<a class="ae li" href="https://github.com/angular/angular/pull/36649" rel="noopener ugc nofollow" target="_blank">正确识别了受测试平台</a>中覆盖影响的模块。</li></ul></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="949c" class="mm mn iu bd mo mp mq mr ms mt mu mv mw kj mx kk my km mz kn na kp nb kq nc nd bi translated">编译器兼容性问题</h1><p id="836b" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">需要一个兼容性功能来逐步迁移到Ivy而不中断更改。它确保Ivy和非Ivy库在迁移期间可以共存。</p><p id="881c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">并非所有角度代码都是同时编译的。应用程序依赖于共享库，这些库以编译形式<em class="om"> </em>发布在npm上，而不是作为类型脚本源代码。即使一个应用程序是使用<code class="fe nu nv nw nx b">ngtsc</code>构建的，它的依赖项也可能没有。</p><p id="fbd5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果一个特定的库不是用<code class="fe nu nv nw nx b">ngtsc</code>编译的，那么在它的<code class="fe nu nv nw nx b">.js</code>中就没有具体化的装饰属性。将它链接到一个不是以同样方式编译的依赖项会在运行时失败。</p><h2 id="c89e" class="ne mn iu bd mo nf ng dn ms nh ni dp mw ls nj nk my lw nl nm na ma nn no nc ja bi translated">转换前Ivy代码</h2><p id="9286" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">由于Ivy代码只能链接到其他Ivy代码，因此要构建应用程序，npm中所有Ivy之前的依赖项都必须转换为Ivy依赖项。这种转换必须作为在应用程序上运行<code class="fe nu nv nw nx b">ngtsc</code>的前奏，并且未来的编译和链接操作需要针对依赖关系的这种转换版本进行。</p><h1 id="9db9" class="mm mn iu bd mo mp pp mr ms mt pq mv mw kj pr kk my km ps kn na kp pt kq nc nd bi translated">升级到角度10</h1><p id="973b" class="pw-post-body-paragraph lj lk iu ll b lm np ke lo lp nq kh lr ls nr lu lv lw ns ly lz ma nt mc md me in bi translated">要更新您当前的Angular安装，您可以运行以下命令(参见Angular更新指南<a class="ae li" href="https://update.angular.io" rel="noopener ugc nofollow" target="_blank">此处为</a>):</p><pre class="kt ku kv kw gu on nx oo op aw oq bi"><span id="f1d9" class="ne mn iu nx b gz or os l ot ou">ng update @angular/cli @angular/core</span></pre><p id="33a4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你可以在<a class="ae li" href="https://github.com/angular/angular/releases?ref=morioh.com" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到Angular 10版本，在<a class="ae li" href="https://github.com/angular/angular/blob/master/CHANGELOG.md#1000-next6-2020-05-07" rel="noopener ugc nofollow" target="_blank">的变更日志</a>中找到更多细节。</p><p id="2ac7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">感谢阅读。我希望这有所帮助。如果你有任何问题，请随时回复。</p><p id="c2ff" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这篇文章最后一次更新是在2020年6月29日。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><p id="d891" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">🧠💡我为一群聪明、好奇的人写关于工程、技术和领导力的文章。<a class="ae li" href="https://rakiabensassi.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll je">加入我的免费电子邮件简讯，独家获取</strong> </a> <strong class="ll je"> </strong>或在此注册Medium <a class="ae li" href="https://rakiabensassi.medium.com/membership" rel="noopener">。</a></p><p id="3daa" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><em class="om">你可以在Udemy上查看我的</em> <strong class="ll je"> <em class="om">视频课程</em></strong><em class="om">:</em><a class="ae li" href="https://www.udemy.com/course/identify-and-fix-javascript-memory-leaks/" rel="noopener ugc nofollow" target="_blank"><em class="om">如何识别、诊断、修复Web Apps中的内存泄漏</em> </a> <em class="om">。</em></p><div class="pu pv gq gs pw px"><a rel="noopener  ugc nofollow" target="_blank" href="/frontend-architecture-376e6323ef9b"><div class="py ab fp"><div class="pz ab qa cl cj qb"><h2 class="bd je gz z fq qc fs ft qd fv fx jd bi translated">我从设计企业应用程序中学到的10个教训</h2><div class="qe l"><h3 class="bd b gz z fq qc fs ft qd fv fx dk translated">前端架构从来都不是“一劳永逸”的命题，没有任何设计或计划是完美或完整的</h3></div><div class="qf l"><p class="bd b dl z fq qc fs ft qd fv fx dk translated">better编程. pub</p></div></div><div class="qg l"><div class="qh l qi qj qk qg ql lc px"/></div></div></a></div><div class="pu pv gq gs pw px"><a rel="noopener  ugc nofollow" target="_blank" href="/angular-13-features-ef528a9ae16f"><div class="py ab fp"><div class="pz ab qa cl cj qb"><h2 class="bd je gz z fq qc fs ft qd fv fx jd bi translated">Angular 13的新功能</h2><div class="qe l"><h3 class="bd b gz z fq qc fs ft qd fv fx dk translated">100% Ivy，更好的组件API，不支持IE11，等等</h3></div><div class="qf l"><p class="bd b dl z fq qc fs ft qd fv fx dk translated">better编程. pub</p></div></div><div class="qg l"><div class="qm l qi qj qk qg ql lc px"/></div></div></a></div></div></div>    
</body>
</html>