<html>
<head>
<title>Building an Offline-First Application With Node.js and SQLite</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node.js和SQLite构建离线优先的应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-an-offline-first-application-with-node-js-and-sqlite-ae3836aec229?source=collection_archive---------14-----------------------#2022-04-12">https://betterprogramming.pub/building-an-offline-first-application-with-node-js-and-sqlite-ae3836aec229?source=collection_archive---------14-----------------------#2022-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="af9a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">渐进式web应用程序的逐步介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/003581c1bfb56dae6f2b6c4ada0624d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KGNvXiYQGoAlRNlw.png"/></div></div></figure><p id="e206" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">“离线优先”是一种应用程序开发模式，在这种模式下，开发人员确保应用程序的功能不会受到网络连接暂时中断的影响。渐进式web应用程序，感觉上像本地应用程序，但运行起来像web应用程序，通常是建立在这种范式上的。</p><p id="adbf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本教程将教你如何用Node.js和SQLite数据库构建一个离线优先的应用程序。让我们从渐进式web应用程序的介绍开始。</p><h1 id="3e64" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">PWA简介</strong></h1><p id="93d5" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated"><a class="ae mn" href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps" rel="noopener ugc nofollow" target="_blank">渐进式网络应用</a> (PWAs)是使用服务人员、清单和其他网络平台功能和渐进式增强的网络应用，为用户提供可与本地应用相媲美的体验。</p><p id="2abf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就效率而言，PWAs有时可以胜过原生应用。它们按需运行，并且始终可用，无需消耗宝贵的智能手机内存或数据。当选择PWA而不是相同应用程序的本机版本时，用户消耗的数据更少。他们仍然可以将PWA保存到他们的主屏幕；它不需要完全下载就可以安装。</p><h1 id="de6f" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">我们在建造什么？</h1><p id="0159" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">为了展示渐进式web应用程序的威力，我们将构建一个简单的博客应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mo"><img src="../Images/40864db047b3a09d8093949aa1896798.png" data-original-src="https://miro.medium.com/v2/0*4PsueTJs55cSAeCl"/></div></figure><p id="cc8c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用户将能够像其他PWA一样与它进行交互，例如<a class="ae mn" href="https://love2dev.com/blog/twitter-pwa-windows-store/" rel="noopener ugc nofollow" target="_blank"> Twitter PWA </a>。让我们开门见山吧。</p><h1 id="87a1" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">初始化NodeJs应用程序</strong></h1><p id="9cf5" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">让我们把手弄脏吧。首先，我们将使用下面的命令创建项目文件夹:</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="acc4" class="mu lr it mq b gy mv mw l mx my">mkdir PWA &amp;&amp; cd PWA</span></pre><p id="167c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们将使用以下命令初始化Node.js应用程序:</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="7e3a" class="mu lr it mq b gy mv mw l mx my">npm init -y</span></pre><p id="0031" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的命令为应用程序创建了一个<code class="fe mz na nb mq b">package.json</code>文件。</p><p id="e034" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，在我们的项目文件夹中创建以下文件夹结构:</p><p id="6858" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">📦┣📂公开<br/> ┃ ┣📂css <br/> ┃ ┣📂图标<br/> ┃ ┣📂图片<br/> ┃ ┣📂┃ ┗📜index.html<br/>┗📜package.json</p><h1 id="30a5" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">设置快递服务器</strong></h1><p id="e453" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">使用我们的应用程序设置，让我们使用下面的命令安装Express来创建Node.js服务器:</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="67b9" class="mu lr it mq b gy mv mw l mx my">npm install express</span></pre><p id="713e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们将在public文件夹中创建几个文件夹和文件:</p><ul class=""><li id="c2d0" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nh ni nj nk bi translated"><code class="fe mz na nb mq b">css/style.css</code>文件</li><li id="d260" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated"><code class="fe mz na nb mq b">js/app.js</code>文件</li></ul><p id="2b32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，使用下面的代码片段在项目根目录中创建一个<code class="fe mz na nb mq b">index.js</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="fe43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在代码片段中，我们导入<code class="fe mz na nb mq b">express</code>来创建我们的服务器和<code class="fe mz na nb mq b">path</code>模块。我们配置了我们的<code class="fe mz na nb mq b">app</code>来使用<code class="fe mz na nb mq b">express.static</code>方法呈现我们的静态文件，该方法采用静态文件夹(public)的路径，然后我们创建了应用程序的根路径并呈现了<code class="fe mz na nb mq b">index.html</code>文件。然后我们配置了<code class="fe mz na nb mq b">app</code>监听<code class="fe mz na nb mq b">port 8000</code>。</p><h1 id="70be" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">连接到SQLite数据库</strong></h1><p id="f05d" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">为我们的应用程序设置好服务器后，让我们创建并连接我们的应用程序来保存我们的博客详细信息。要开始安装，请运行以下命令来安装sqlite3依赖项:</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="e803" class="mu lr it mq b gy mv mw l mx my">npm install sqlite3</span></pre><p id="a953" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，在<code class="fe mz na nb mq b">index.js</code>文件的入口点，添加下面的代码片段来创建应用程序并将其连接到SQLite数据库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="586c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将创建一个博客列表，存储在数据库中，稍后用下面的代码片段呈现给客户端:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2b7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们应用程序中的每个block post都有一个<code class="fe mz na nb mq b">id</code>、<code class="fe mz na nb mq b">title</code>、<code class="fe mz na nb mq b">avatar</code>和<code class="fe mz na nb mq b">intro</code>字段。</p><p id="7b82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，创建一个名为<code class="fe mz na nb mq b">blogs</code>的数据库表，并用下面的代码片段保存我们刚刚创建的博客细节:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2f34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在代码片段中，我们使用<code class="fe mz na nb mq b">db.run</code>创建了一个表<code class="fe mz na nb mq b">blogs</code>。<code class="fe mz na nb mq b">db.run</code>方法将一个SQL查询作为参数，然后我们遍历我们的博客数组，并将它们插入到我们刚刚使用js map函数创建的博客表中。</p><h1 id="9c71" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">查看数据库记录</h1><p id="c5a4" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">现在，让我们来查看我们刚刚使用<a class="ae mn" href="https://arctype.com/" rel="noopener ugc nofollow" target="_blank"> Arctype </a>创建的记录。要使用Arctype查看SQLite数据库中的记录，请执行以下步骤:</p><ul class=""><li id="7260" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nh ni nj nk bi translated">安装Arctype</li><li id="7bc7" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated">用<code class="fe mz na nb mq b">node index.js</code>运行应用程序，创建数据库</li><li id="6714" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated">启动Arctype，然后单击SQLite选项卡</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mo"><img src="../Images/59c60050655fa372ff024dd41bf42c18.png" data-original-src="https://miro.medium.com/v2/0*G_AdOk9El9ws5dzt"/></div></figure><ul class=""><li id="c616" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nh ni nj nk bi translated">单击选择SQLite文件按钮，找到运行服务器时生成的<code class="fe mz na nb mq b">db.sqlite</code>文件。</li><li id="b271" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated">您应该会看到<code class="fe mz na nb mq b">blogs</code>表和我们创建的记录，如下图所示:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mo"><img src="../Images/fa5d98f82dcd26010ca5c72e03f4f0ff.png" data-original-src="https://miro.medium.com/v2/0*2_NIq9uyWwFnw1JI"/></div></figure><h1 id="656c" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">呈现页面</h1><p id="af33" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">此时，我们已经将应用程序连接到一个SQLite数据库，并在数据库中插入了一些记录。现在，打开<code class="fe mz na nb mq b">index.html</code>文件并添加以下代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="87e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在上面的文件中创建了一个简单的标记，链接到我们的清单，我们将在下一节创建这个文件，<code class="fe mz na nb mq b">styles</code>和<code class="fe mz na nb mq b">app.js </code>文件。</p><p id="2b3b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们将在我们的<code class="fe mz na nb mq b">index.js</code>文件中创建一个<code class="fe mz na nb mq b">blogs</code>路由来将博客返回到客户端。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="8ffe" class="mu lr it mq b gy mv mw l mx my">...<br/>app.get("/blogs", (req, res) =&gt; {<br/>  res.status(200).json({<br/>    blogs,<br/>  });<br/>});<br/>...</span></pre><p id="1d0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的<code class="fe mz na nb mq b">public/js/app.js</code>文件中，我们将向博客端点发送一个get请求，从我们的后端获取博客。然后我们遍历博客，将目标指向<code class="fe mz na nb mq b">container</code>类，并用下面的代码显示它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c7f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还将使用下面的代码片段在<code class="fe mz na nb mq b">public/css/style.css</code>中为我们的应用程序添加一些样式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f38f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在打开<code class="fe mz na nb mq b">package.json</code>文件并添加启动脚本。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="f590" class="mu lr it mq b gy mv mw l mx my">"start": "node index.js"</span></pre><p id="a8e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至此，我们已经建立了我们的应用程序。但是，当服务器没有运行或者没有用于生产的网络连接时，我们不能运行我们的应用程序。让我们在下一部分进行设置。</p><h1 id="29c8" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">优化应用</strong></h1><p id="766d" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们需要让我们的应用程序兼容所有的屏幕尺寸。我们还将通过在我们的<code class="fe mz na nb mq b">index.html</code>文件的head部分添加下面的标记来添加一个主题颜色。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="5404" class="mu lr it mq b gy mv mw l mx my">&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;<br/>&lt;meta name="theme-color" content="#16a0d6e7"/&gt;</span></pre><h1 id="49f9" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">创建一份货单</h1><p id="f77d" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们需要描述我们的应用程序，以及当它安装在用户的设备上时应该如何表现。我们可以通过创建一个清单来做到这一点。</p><div class="ns nt gp gr nu nv"><a href="https://developer.mozilla.org/en-US/docs/Web/Manifest" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">Web应用程序清单| MDN</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">Web应用程序清单是称为渐进式web应用程序(PWAs)的web技术集合的一部分，它是网站…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">developer.mozilla.org</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ks nv"/></div></div></a></div><p id="fadb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在项目根目录下创建一个<code class="fe mz na nb mq b">manifest</code>文件，并添加以下配置:</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="d950" class="mu lr it mq b gy mv mw l mx my">{<br/>    "name": "Blogger"<br/>    "short_name": "Blogger"<br/>    "start_url": "/",<br/>    "display": "standalone",<br/>    "background_color": "#0e9c95",<br/>    "theme_color": "#16a0d6e7",<br/>    "orientation": "portrait",<br/>    "icons": []<br/>}</span></pre><p id="c12b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的清单中，我们定义了以下配置:</p><ul class=""><li id="7047" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nh ni nj nk bi translated"><code class="fe mz na nb mq b">name</code>:定义应用的显示名称。</li><li id="561e" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated"><code class="fe mz na nb mq b">short_name</code>:定义安装后将显示在应用图标下的名称。</li><li id="608e" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated"><code class="fe mz na nb mq b">start_url</code>:这告诉浏览器应用的根URL。</li><li id="b638" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated"><code class="fe mz na nb mq b">display</code>:这告诉浏览器如何显示应用。</li><li id="bd87" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated"><code class="fe mz na nb mq b">background_color</code>:定义应用程序安装时的背景颜色。</li><li id="cf69" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated"><code class="fe mz na nb mq b">theme_color</code>:定义状态栏的颜色。</li><li id="71cf" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated"><code class="fe mz na nb mq b">orientation</code>:定义应用程序显示时使用的方向。</li><li id="d7d7" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated"><code class="fe mz na nb mq b">icons</code>:这定义了不同大小的图标或图像用作我们的应用程序主页图标。</li></ul><p id="d379" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">手动创建我们的主屏幕图标可能是一项非常复杂的任务，但不用担心。我们将利用名为<a class="ae mn" href="https://www.npmjs.com/package/pwa-asset-generator" rel="noopener ugc nofollow" target="_blank"> pwa-asset-generator </a>的第三方模块，使用下面的命令从公共目录中的主应用程序图标生成不同大小的图标:</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="7e6e" class="mu lr it mq b gy mv mw l mx my">#change directory to the public folder<br/>cd public<br/>#generate icons<br/>npx pwa-asset-generator logo.png icons</span></pre><p id="7416" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的命令将在public文件夹中创建一个<code class="fe mz na nb mq b">icons</code>文件夹，其中包含我们的应用程序的许多图标，以及终端上的一些JSON，我们将把它们粘贴到清单中的图标数组中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mo"><img src="../Images/0fd5bc4668035ee6ff85f0e9222e5a7c.png" data-original-src="https://miro.medium.com/v2/0*FeDp6wZ9DWLiUVGA"/></div></figure><p id="cb60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">清单中的图标数组应该如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="af99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，该命令还生成了指向所生成图标的标记链接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mo"><img src="../Images/68c80c639e489f0103fda29cfa52cb48.png" data-original-src="https://miro.medium.com/v2/0*rSXBS6qpu-mKECMj"/></div></figure><p id="1d8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将标记复制并粘贴到<code class="fe mz na nb mq b">public/index.html</code>文件中标记的head部分。</p><h1 id="c6e8" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">设置服务人员</strong></h1><p id="1a6a" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">创建好清单后，让我们设置服务人员。服务工作器是一段JavaScript代码，您的浏览器在一个单独的线程中在后台运行，处理您为将来的请求保存的资产和数据的缓存，以便为您的应用程序提供离线支持。</p><p id="2464" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，在公共文件夹中创建一个<code class="fe mz na nb mq b">blogger.serviceWorker.js</code>文件。对于服务人员，有许多事件(<code class="fe mz na nb mq b">push</code>、<code class="fe mz na nb mq b">activate</code>、<code class="fe mz na nb mq b">install</code>、<code class="fe mz na nb mq b">fetch</code>、<code class="fe mz na nb mq b">message</code>、<code class="fe mz na nb mq b">sync</code>)，但对于本教程中的演示，我们将涵盖<code class="fe mz na nb mq b">install</code>、<code class="fe mz na nb mq b">activate</code>和<code class="fe mz na nb mq b">fetch</code>事件。在此之前，我们需要创建一个数组来存储我们在应用程序中使用的所有资产。</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="e90f" class="mu lr it mq b gy mv mw l mx my">const assets = [<br/>  "/",<br/>  "css/style.css",<br/>  "js/app.js",<br/>  "/images/blog1.jpg",<br/>  "/images/blog2.jpg",<br/>  "/images/blog3.jpg,"<br/>];</span></pre><p id="3633" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们将监听<code class="fe mz na nb mq b">install</code>事件来注册并保存我们的静态文件到浏览器的缓存中。这个过程需要一些时间来完成。为了跳过等待，我们将使用<code class="fe mz na nb mq b">skipWaiting()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="4138" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，每当服务工作者被更新时，我们需要清除缓存以删除旧的资产。为此，我们来听一下下面的<code class="fe mz na nb mq b">activate</code>代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="16ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们对服务工作者使用了<code class="fe mz na nb mq b">waitUntil</code>方法。该方法等待操作完成，然后我们在删除它们之前检查我们试图清除的资产是否是我们当前应用程序的资产。</p><p id="9ab9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们需要存储在缓存中的文件来使用它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="cee2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当在页面上发出请求时，PWA将检查我们的缓存，如果缓存中有数据，则从缓存中读取数据，而不是访问网络。然后，使用<code class="fe mz na nb mq b">respondWith</code>方法，我们覆盖浏览器的默认设置，让我们的事件返回一个承诺。当缓存完成后，我们可以返回对应于<code class="fe mz na nb mq b">evt.request</code>的缓存。当缓存准备好时，我们可以返回与<code class="fe mz na nb mq b">evt.request</code>匹配的缓存。</p><p id="0016" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经成功设置了我们的服务人员。现在让我们在应用程序中使用它。</p><h1 id="a807" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">登记服务人员</strong></h1><p id="54d8" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">现在，让我们用下面的代码片段在我们的<code class="fe mz na nb mq b">public/js/app.js</code>文件中注册我们的服务人员:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ab97" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我们检查我们的应用程序的浏览器是否支持服务工作者(当然，不是所有的浏览器都支持服务工作者)，然后注册我们的服务工作者文件。</p><p id="47cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，用下面的命令运行应用程序:</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="4290" class="mu lr it mq b gy mv mw l mx my">npm start</span></pre><p id="bf04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在你的浏览器中点击<code class="fe mz na nb mq b">localhost:8000</code>进入应用程序。</p><h1 id="481b" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">谷歌灯塔检查</strong></h1><p id="5967" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">现在，让我们使用<a class="ae mn" href="https://developers.google.com/web/tools/lighthouse" rel="noopener ugc nofollow" target="_blank"> Google Lighthouse </a>检查来检查我们是否正确设置了PWA。右键单击您的浏览器并选择“检查”在inspect选项卡上，选择lighthouse并单击generate report。如果您的应用程序一切顺利，您应该会看到如下截图所示的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mo"><img src="../Images/4b76998b61581b7346a2432fbdb2861a.png" data-original-src="https://miro.medium.com/v2/0*gqzyLjYevsXjQAuu"/></div></figure><p id="0695" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经成功创建了我们的第一个应用程序。您也可以停止服务器，在脱机模式下测试应用程序。</p><h1 id="5f0a" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated"><strong class="ak">结论</strong></h1><p id="ac50" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">渐进式web应用程序(PWA)使用现代API，通过单一代码库提供增强的功能、可靠性和可安装性。它们允许您的最终用户使用您的应用程序，不管他们是否有互联网连接。</p><p id="fb4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您应该可以随意派生<a class="ae mn" href="https://github.com/Claradev32/Offline-first-App" rel="noopener ugc nofollow" target="_blank">库</a>并向项目添加额外的特性。</p><p id="030d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">祝你好运！</p></div></div>    
</body>
</html>