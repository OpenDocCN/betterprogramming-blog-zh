<html>
<head>
<title>Create a Retro Guestbook Page Using GitHub Events and Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GitHub事件和动作创建一个复古留言簿页面</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-retro-guestbook-page-using-github-events-and-actions-d60999a5a782?source=collection_archive---------24-----------------------#2020-02-11">https://betterprogramming.pub/create-a-retro-guestbook-page-using-github-events-and-actions-d60999a5a782?source=collection_archive---------24-----------------------#2020-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="548c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用一点点命令行魔法从晦涩中拯救GitHub存储库事件的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0a50a2dc77ffd3ba691f010e1d3dd719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TFKMr7P5kbtoqyHttRls8g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@5tep5?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚历山大·波波夫</a>在<a class="ae ky" href="https://unsplash.com/s/photos/techno?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="7cd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在GitHub上工作的团队依靠事件数据进行协作。记录为问题、拉动请求和注释的数据对于理解项目变得至关重要。</p><p id="41f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了GitHub动作，我们就有机会以编程方式访问和保存我们存储库中的GitHub事件数据。让数据成为存储库本身的一部分是在GitHub之外保存数据的一种方式——它还让我们能够在一个面向前端的网站上展示数据，例如GitHub页面。</p><p id="6f61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且，如果你像我一样，你可以把<a class="ae ky" href="https://github.com/victoriadrake/github-guestbook/issues/1" rel="noopener ugc nofollow" target="_blank"> GitHub问题评论</a>变成<a class="ae ky" href="https://victoria.dev/github-guestbook/" rel="noopener ugc nofollow" target="_blank">牛逼的90后留言簿页面</a>！</p><p id="f784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管是什么用法，基本概念都是一样的。我们可以使用动作来访问、保存和显示GitHub事件数据——只需一个工作流文件。为了说明这个过程，我将带你浏览一下让我的留言簿闪闪发光的<a class="ae ky" href="https://github.com/victoriadrake/github-guestbook/blob/master/.github/workflows/publish-comments.yml" rel="noopener ugc nofollow" target="_blank">工作流代码</a>。</p><p id="8efb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于GitHub动作的介绍，包括如何触发工作流，请参见<a class="ae ky" href="https://medium.com/better-programming/build-a-tool-agnostic-ci-cd-flow-with-github-actions-3d4f4a6238de" rel="noopener">使用GitHub动作构建工具无关的CI/CD流</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b41c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">访问GitHub事件数据</h1><p id="dbe2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">动作工作流在具有一些默认环境变量的环境中运行。这里有很多方便的信息，包括事件数据。访问事件数据最完整的方法是使用<code class="fe mz na nb nc b">$GITHUB_EVENT_PATH</code>变量，这是包含完整JSON事件有效负载的文件的路径。</p><p id="2851" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">展开的路径看起来像<code class="fe mz na nb nc b">/home/runner/work/_temp/_github_workflow/event.json</code>，它的数据对应于它的webhook事件。你可以在GitHub REST API <a class="ae ky" href="https://developer.github.com/webhooks/#events" rel="noopener ugc nofollow" target="_blank">事件类型和有效载荷</a>中找到webhook事件数据的文档。为了使JSON数据在工作流环境中可用，您可以使用类似于<code class="fe mz na nb nc b">jq</code>的工具来解析事件数据并将其放入环境变量中。</p><p id="990c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，我从一个<a class="ae ky" href="https://developer.github.com/v3/activity/events/types/#issuecommentevent" rel="noopener ugc nofollow" target="_blank">问题评论事件</a>中抓取评论ID:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="753b" class="nh md it nc b gy ni nj l nk nl">ID="$(jq '.comment.id' $GITHUB_EVENT_PATH)"</span></pre><p id="8bdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数事件数据也可以通过<code class="fe mz na nb nc b"><a class="ae ky" href="https://help.github.com/en/github/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions#github-context" rel="noopener ugc nofollow" target="_blank">github.event</a></code> <a class="ae ky" href="https://help.github.com/en/github/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions#github-context" rel="noopener ugc nofollow" target="_blank">上下文变量</a>获得，无需解析JSON。使用点符号访问这些字段，如下例所示，我获取了相同的注释ID:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="10e2" class="nh md it nc b gy ni nj l nk nl">ID=${{ github.event.comment.id }}</span></pre><p id="29c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我的留言簿，我想显示带有用户句柄以及日期和时间的条目。我可以像这样捕获这个事件数据:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b4fe" class="nh md it nc b gy ni nj l nk nl">AUTHOR=${{ github.event.comment.user.login }}<br/>DATE=${{ github.event.comment.created_at }}</span></pre><p id="2720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Shell变量可以方便地访问数据，但是它们是短暂的。每次运行都会重新创建工作流环境——甚至在一个步骤中设置的shell变量也不会持续到其他步骤。要持久化捕获的数据，您有两个选择:使用工件，或者将它提交给存储库。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a1e3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">保留事件数据:使用工件</h1><p id="5b91" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用工件，您可以在工作流作业之间持久化数据，而无需将数据提交到存储库。例如，当您希望在将数据放在更永久的地方之前转换或合并数据时，这是很方便的。有必要在工作流作业之间保存数据，因为:</p><blockquote class="nm nn no"><p id="f08e" class="kz la np lb b lc ld ju le lf lg jx lh nq lj lk ll nr ln lo lp ns lr ls lt lu im bi translated">工作流中的每个作业都在虚拟环境的一个新实例中运行。当作业完成时，运行程序终止并删除虚拟环境的实例。<em class="it"> — </em> <a class="ae ky" href="https://help.github.com/en/github/automating-your-workflow-with-github-actions/persisting-workflow-data-using-artifacts" rel="noopener ugc nofollow" target="_blank"> <em class="it">使用工件</em> </a> <em class="it">持久化工作流数据。</em></p></blockquote><p id="351f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个动作帮助使用工件:<code class="fe mz na nb nc b">upload-artifact</code>和<code class="fe mz na nb nc b">download-artifact</code>。您可以使用这些操作使文件对同一工作流程中的其他作业可用。完整示例见<a class="ae ky" href="https://help.github.com/en/github/automating-your-workflow-with-github-actions/persisting-workflow-data-using-artifacts#passing-data-between-jobs-in-a-workflow" rel="noopener ugc nofollow" target="_blank">在工作流程</a>中的任务间传递数据。</p><p id="5478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">upload-artifact</code>动作的<code class="fe mz na nb nc b">action.yml</code>包含关键字的<a class="ae ky" href="https://github.com/actions/upload-artifact/blob/master/action.yml" rel="noopener ugc nofollow" target="_blank">解释</a>。上传的文件以<code class="fe mz na nb nc b">.zip</code>格式保存。同一个工作流运行中的另一个作业可以使用<code class="fe mz na nb nc b">download-artifact</code>动作来利用另一个步骤中的数据。</p><p id="f689" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以在存储库的“操作”选项卡下的“工作流运行”页面上手动下载归档文件。</p><p id="aeed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在作业之间保存工作流数据不会对存储库文件进行任何更改，因为生成的工件只存在于工作流环境中。就我个人而言，在shell环境中工作很舒服，我看到了工件的一个狭窄的用例，尽管我没有提到它们。除了在任务之间传递数据之外，它们还可以用来创建<code class="fe mz na nb nc b">.zip</code>格式的文档，比如说，测试输出数据。在我的留言簿示例中，我只是在一个作业中运行了所有必要的步骤，不需要在作业之间传递数据。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2b2f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">保留事件数据:将工作流文件推送到存储库</h1><p id="cdcb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了将工作流中捕获的数据保存在存储库中，有必要将这些数据添加并推送到Git存储库中。您可以在工作流中通过使用shell命令创建包含数据的新文件或将数据附加到现有文件来实现这一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d42f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在工作流程中创建文件</h1><p id="6838" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要在工作流程中处理存储库文件，使用<code class="fe mz na nb nc b"><a class="ae ky" href="https://github.com/actions/checkout" rel="noopener ugc nofollow" target="_blank">checkout</a></code> <a class="ae ky" href="https://github.com/actions/checkout" rel="noopener ugc nofollow" target="_blank">动作</a>获取一个副本进行处理:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f47c" class="nh md it nc b gy ni nj l nk nl">- uses: actions/checkout@master<br/>  with:<br/>    fetch-depth: 1</span></pre><p id="26e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了给我的留言簿添加评论，我将shell变量中捕获的事件数据转换成适当的文件，在<a class="ae ky" href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html" rel="noopener ugc nofollow" target="_blank"> shell参数扩展</a>中使用替换来净化用户输入并将换行符转换成段落。我以前写过<a class="ae ky" href="https://victoria.dev/blog/sql-injection-and-xss-what-white-hat-hackers-know-about-trusting-user-input/" rel="noopener ugc nofollow" target="_blank">为什么应该小心对待用户输入</a>。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d802" class="nh md it nc b gy ni nj l nk nl">- name: Turn comment into file<br/>  run: |<br/>    ID=${{ github.event.comment.id }}<br/>    AUTHOR=${{ github.event.comment.user.login }}<br/>    DATE=${{ github.event.comment.created_at }}<br/>    COMMENT=$(echo "${{ github.event.comment.body }}")<br/>    NO_TAGS=${COMMENT//[&lt;&gt;]/\`}<br/>    FOLDER=comments</span><span id="c36a" class="nh md it nc b gy nt nj l nk nl">    printf '%b\n' "&lt;div class=\"comment\"&gt;&lt;p&gt;${AUTHOR} says:&lt;/p&gt;&lt;p&gt;${NO_TAGS//$'\n'/\&lt;\/p\&gt;\&lt;p\&gt;}&lt;/p&gt;&lt;p&gt;${DATE}&lt;/p&gt;&lt;/div&gt;\r\n" &gt; ${FOLDER}/${ID}.html</span></pre><p id="835d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<code class="fe mz na nb nc b">printf</code>并使用<code class="fe mz na nb nc b">&gt;</code>将其输出定向到一个新文件，事件数据被转换成一个HTML文件，用注释ID号命名，包含捕获的事件数据。格式化后，它看起来像这样:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="47c5" class="nh md it nc b gy ni nj l nk nl">&lt;div class="comment"&gt;<br/>    &lt;p&gt;victoriadrake says:&lt;/p&gt;<br/>    &lt;p&gt;This is a comment!&lt;/p&gt;<br/>    &lt;p&gt;2020–02-04T00:28:36Z&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="ac4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用注释时，使用注释ID命名文件的一个效果是，具有相同ID的新文件将覆盖以前的文件。这对于留言簿来说很方便，因为它允许对评论进行任何编辑来替换原始的评论文件。</p><p id="69cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你使用像Hugo这样的静态站点生成器，你可以构建一个markdown格式的文件，把它放在你的<code class="fe mz na nb nc b">content/</code>文件夹中，常规的站点构建会处理剩下的事情。在我的简单留言簿的例子中，我有一个额外的步骤将各个评论文件合并到一个页面中。每次运行时，它都会用<code class="fe mz na nb nc b">header.html</code>部分(<code class="fe mz na nb nc b">&gt;</code>)覆盖现有的<code class="fe mz na nb nc b">index.html</code>，然后按照降序查找并追加(<code class="fe mz na nb nc b">&gt;&gt;</code>)所有注释文件的内容，最后追加<code class="fe mz na nb nc b">footer.html</code>部分以结束页面。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2bad" class="nh md it nc b gy ni nj l nk nl">- name: Assemble page<br/>  run: |<br/>    cat header.html &gt; index.html<br/>    find comments/ -name "*.html" | sort -r | xargs -I % cat % &gt;&gt; index.html<br/>    cat footer.html &gt;&gt; index.html</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2b9e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">向存储库提交更改</h1><p id="6e60" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">由于<code class="fe mz na nb nc b">checkout</code>操作与克隆存储库并不完全相同，所以在撰写本文时还有一些<a class="ae ky" href="https://github.community/t5/GitHub-Actions/Checkout-Action-does-not-create-local-master-and-has-no-options/td-p/31575" rel="noopener ugc nofollow" target="_blank">问题</a>需要解决。对于<code class="fe mz na nb nc b">pull</code>、<code class="fe mz na nb nc b">checkout</code>，需要几个额外的步骤，并且成功地将<code class="fe mz na nb nc b">push</code>改变回<code class="fe mz na nb nc b">master</code>分支，但是这在shell中是相当普通的。</p><p id="34c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是添加、提交和将工作流所做的更改推回到存储库的<code class="fe mz na nb nc b">master</code>分支的步骤。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5843" class="nh md it nc b gy ni nj l nk nl">- name: Push changes to repo<br/>  run: |<br/>    REMOTE=https://${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}<br/>    git config user.email "${{ github.actor }}@users.noreply.github.com"<br/>    git config user.name "${{ github.actor }}"</span><span id="aec7" class="nh md it nc b gy nt nj l nk nl">    git pull ${REMOTE}<br/>    git checkout master<br/>    git add .<br/>    git status<br/>    git commit -am "Add new comment"<br/>    git push ${REMOTE} master</span></pre><p id="ccd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，远程存储库是使用<code class="fe mz na nb nc b">github.repository</code>上下文变量指定的。为了让我们的工作流被允许推送到master，我们使用默认的 <code class="fe mz na nb nc b"><a class="ae ky" href="https://help.github.com/en/github/automating-your-workflow-with-github-actions/authenticating-with-the-github_token" rel="noopener ugc nofollow" target="_blank">secrets.GITHUB_TOKEN</a></code> <a class="ae ky" href="https://help.github.com/en/github/automating-your-workflow-with-github-actions/authenticating-with-the-github_token" rel="noopener ugc nofollow" target="_blank">变量</a>。</p><p id="cdb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于工作流环境是崭新的，我们需要配置Git。在上面的例子中，我使用了<code class="fe mz na nb nc b">github.actor</code>上下文变量来输入启动工作流的帐户的用户名。使用<a class="ae ky" href="https://help.github.com/en/github/setting-up-and-managing-your-github-user-account/setting-your-commit-email-address#setting-your-commit-email-address-on-github" rel="noopener ugc nofollow" target="_blank">默认</a> <code class="fe mz na nb nc b"><a class="ae ky" href="https://help.github.com/en/github/setting-up-and-managing-your-github-user-account/setting-your-commit-email-address#setting-your-commit-email-address-on-github" rel="noopener ugc nofollow" target="_blank">noreply</a></code> <a class="ae ky" href="https://help.github.com/en/github/setting-up-and-managing-your-github-user-account/setting-your-commit-email-address#setting-your-commit-email-address-on-github" rel="noopener ugc nofollow" target="_blank"> GitHub电子邮件地址</a>类似地配置电子邮件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fb8c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">显示事件数据</h1><p id="4181" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你使用的GitHub页面带有默认的<code class="fe mz na nb nc b">secrets.GITHUB_TOKEN</code>变量，并且没有站点生成器，那么在工作流中将变更推送到存储库只会更新存储库文件。GitHub页面构建将失败，并显示错误消息“您的站点在构建时遇到问题:页面构建失败。”</p><p id="7ff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要启用触发Pages站点构建的操作，您需要创建一个个人访问令牌。这个令牌可以<a class="ae ky" href="https://help.github.com/en/github/automating-your-workflow-with-github-actions/creating-and-using-encrypted-secrets" rel="noopener ugc nofollow" target="_blank">作为一个秘密存储在存储库</a>设置中，并传递到工作流中，代替默认的<code class="fe mz na nb nc b">secrets.GITHUB_TOKEN</code>变量。在这篇文章中，我写了更多关于<a class="ae ky" href="https://victoria.dev/blog/a-lightweight-tool-agnostic-ci/cd-flow-with-github-actions/#environment-and-variables" rel="noopener ugc nofollow" target="_blank">动作环境和变量的内容。</a></p><p id="f4d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用个人访问令牌，由操作工作流发起的推送也将更新页面站点。你可以通过<a class="ae ky" href="https://github.com/victoriadrake/github-guestbook/issues/1" rel="noopener ugc nofollow" target="_blank">在我的<a class="ae ky" href="https://victoria.dev/github-guestbook/" rel="noopener ugc nofollow" target="_blank">留言簿</a>里留言</a>来亲眼看看！评论创建事件触发工作流，然后需要大约30秒到1分钟来运行和更新留言簿页面。</p><p id="06b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在需要站点构建来发布变更的情况下，比如使用Hugo时，动作也可以做到这一点。然而，为了避免产生意外的循环，<a class="ae ky" href="https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#about-workflow-events" rel="noopener ugc nofollow" target="_blank">一个动作工作流不会触发另一个</a>。相反，用Makefile 处理<a class="ae ky" href="https://victoria.dev/blog/a-portable-makefile-for-continuous-delivery-with-hugo-and-github-pages/" rel="noopener ugc nofollow" target="_blank">构建站点的过程非常方便，任何工作流都可以运行它。只需将运行Makefile作为工作流作业的最后一步，必要时使用存储库标记:</a></p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2644" class="nh md it nc b gy ni nj l nk nl">- name: Run Makefile<br/>  env:<br/>    TOKEN: ${{ secrets.GITHUB_TOKEN }}<br/>  run: make all</span></pre><p id="856d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这确保了工作流的最后一步是构建和部署更新的站点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f2fd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不再有事件数据范围</h1><p id="5fc0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">GitHub Actions提供了一种捕捉和利用事件数据的简洁方式，因此它不仅在GitHub中可用。可能性只受你想象力的限制！这里有一些让我们创造的东西的想法:</p><ul class=""><li id="e20e" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">面向公众的问题板，没有GitHub帐户的客户可以在这里查看项目问题并给出反馈。</li><li id="bba1" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">任何存储库的新问题、评论或PRs的自动更新RSS源。</li><li id="1426" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">一个静态站点的评论系统，利用GitHub发布评论作为输入方法。</li><li id="c4a2" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">一个很棒的90年代留言簿页面！</li></ul><p id="6bf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我说过我做了一个90年代的留言簿页面吗？我内心深处的城市呆子有点兴奋！</p></div></div>    
</body>
</html>