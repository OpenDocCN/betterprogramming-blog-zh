<html>
<head>
<title>How To Symbolicate Crash Logs in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在iOS中标记崩溃日志</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-symbolicate-crash-logs-in-ios-b05637591364?source=collection_archive---------3-----------------------#2021-01-27">https://betterprogramming.pub/how-to-symbolicate-crash-logs-in-ios-b05637591364?source=collection_archive---------3-----------------------#2021-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b703" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在为时已晚之前修复错误</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b886069524395d36ac80d142a47f59f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8D5RNA7Ug3QMhHIs"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="1bf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们都希望我们的应用程序稳定可靠地运行在客户的所有设备上。然而，由于大多数软件固有的复杂性，我们永远无法保证即使是生产代码也会100%没有bug。无论是程序员的错误、操作系统的缺陷还是第三方库中的错误，崩溃都不可避免地会不时出现。</p><p id="0a81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当这种情况发生时，我们作为软件工程师的工作就是迅速找到解决方案。这就是崩溃日志派上用场的地方。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="767b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是崩溃日志？</h1><p id="23b9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当一个应用程序在iOS设备上崩溃时，系统会生成崩溃报告或崩溃日志<strong class="lb iu">T5，并保存在设备上。这包含了对我们的调查非常有用的大量信息。最重要的是，它包含一个完整的堆栈跟踪，向您显示崩溃时每个正在执行的线程正在做什么。</strong></p><p id="f19c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些信息是以十六进制地址的形式报告的，对人类观察者来说没有太大的帮助，所以我们必须通过一个叫做<em class="mz">符号化</em>的过程将它们翻译成可读的函数名和行号。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2060" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何获取崩溃日志</h1><p id="ed9e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你的应用已经发布在App Store上或者正在试飞中，那么获得一份坠毁报告是相当简单的:</p><blockquote class="na nb nc"><p id="9bfc" class="kz la mz lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">“TestFlight和App Store为你提交的每一个应用版本收集崩溃报告。</p><p id="88d3" class="kz la mz lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi">…</p><p id="c399" class="kz la mz lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">来自发送诊断和使用信息的客户的崩溃报告显示在崩溃管理器中。</p><p id="0928" class="kz la mz lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi">…</p><p id="6fa4" class="kz la mz lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">无论共享诊断和使用数据的设备设置如何，应用程序的TestFlight用户都会自动与您共享崩溃报告。“— <a class="ae ky" href="https://developer.apple.com/documentation/xcode/diagnosing_issues_using_crash_reports_and_device_logs/acquiring_crash_reports_and_diagnostic_logs" rel="noopener ugc nofollow" target="_blank">苹果开发者</a></p></blockquote><p id="fcc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在Xcode的崩溃管理器中找不到崩溃日志，最简单的方法是这样。</p><p id="91f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在应用崩溃的设备上，进入设置-&gt;隐私-&gt;分析和改进-&gt;分析数据。在这里，你会发现一堆文件来自你设备上的所有应用程序。开始在顶部的搜索栏中输入你的应用程序的名称，瞧:你已经有了这个应用程序生成的所有崩溃日志。打开报告后，您可以将它传输到您的计算机上，或者让报告崩溃的用户通过电子邮件将其发送给您。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9b2a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何处理崩溃日志</h1><p id="fa28" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你以前从未看过事故报告，以下是第一眼看上去的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/f72a4f68361d0f12571f3a94d63369fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vh2sq3q_hMJS_u5ETlKbNg.png"/></div></div></figure><p id="7f2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在顶部，您可以看到进程信息，如<em class="mz">事件标识符</em>(唯一标识崩溃)、<em class="mz">崩溃报告器键</em>(映射到设备ID的唯一键)、<em class="mz">硬件型号</em>和<em class="mz">进程</em>，这是应用程序的名称(我非常有创意地将此示例命名为应用程序崩溃示例)。</p><p id="d9dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们有像发布时间和操作系统版本的东西。在那下面，有一些关于异常类型的细节，我们也可以看到是什么线程导致了崩溃。</p><p id="0cd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所有这些之后是有趣的部分，我们称之为<em class="mz">线程回溯</em>。这将提供崩溃发生时所有活动帧的列表。</p><p id="2e45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一开始看起来难以理解，我可以理解，但让我们看看每段文字代表了什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/06c416c1ae87a83479cba0df217c1bf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*wm2YDPCzPAxr4W9ENpbqKg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="da07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，至少我们有了导致应用程序崩溃的函数的十六进制地址。不过，这仍然没有多大意义，所以是时候卷起袖子，象征性地完成这份报告了。</p><p id="33ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，你应该尝试通过Xcode符号化你的崩溃日志。这很简单。按照<a class="ae ky" href="https://stackoverflow.com/a/25927122/10706839" rel="noopener ugc nofollow" target="_blank">这个栈溢出答案</a>中的步骤就可以了。如果在这之后，你看到内存地址旁边的函数名和行号，那么万岁！您有一个符号化的崩溃报告，可以继续进行调试。</p><p id="8091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您没有看到任何变化，那么请继续阅读，因为我将向您展示如何手动符号化它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="deee" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">找到正确的dSYM文件</h1><p id="eeb4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要开始符号化过程，您需要找到相关的dSYM文件。</p><p id="2427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的应用程序在App Store上发布或在TestFlight上可用，您可以通过App Store Connect获得dSYMs。选择你的应用程序，进入TestFlight，选择构建版本，进入“构建元数据”，在“一般信息”下，你会发现一个“包括符号”选项，你可以在那里下载dSYM文件。</p><p id="43ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果上述方法不管用，您可以从您的构建档案中获得dSYMs。为此，在Finder中导航到相关的构建(除非您更改了它，否则归档保存在~/Library/Developer/Xcode/Archives)，右键单击<code class="fe ni nj nk nl b">.xcarchive</code>文件，然后选择“显示包内容”</p><p id="0c36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你面前有一堆dSYM文件。你到底需要哪一个？其标题与您想要象征的二进制文件的编译UUID相匹配的那个。</p><p id="0e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你觉得怎么样？最简单的方法是打开你的崩溃日志，搜索<code class="fe ni nj nk nl b">slice_uuid</code>。这将放在报告的开头。</p><p id="5426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的例子中，它看起来像这样:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="9f7a" class="nq md it nl b gy nr ns l nt nu">“slice_uuid”:”d1abc7f3-e81d-3264–847e-4fb2578b43dd”</span></pre><p id="d9a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，您必须找到具有匹配标题的dSYM。例如，我必须搜索<code class="fe ni nj nk nl b">d1abc7f3-e81d-3264–847e-4fb2578b43dd.dSYM</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4a4c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">做实际的象征</h1><p id="5399" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经完成了所有的前期工作，所以我们可以开始实际工作了。为此，我们使用我们值得信赖的老朋友——命令行。我们有一个专门为此目的制定的命令。它被称为<code class="fe ni nj nk nl b">atos</code>，它将十六进制地址转换成函数名和行号。</p><p id="c735" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在命令行中键入以下命令，让我们看看如何使用它以及可以传入哪些参数:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="080a" class="nq md it nl b gy nr ns l nt nu">atos -h</span></pre><p id="8647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到以下信息:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="6001" class="nq md it nl b gy nr ns l nt nu">Usage: atos [-p pid] [-o executable] [-f file] [-s slide | -l loadAddress] [-arch architecture] [-printHeader] [-fullPath] [address …]</span></pre><p id="480c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所有这些可能的参数中，我们将只输入以下四个:<code class="fe ni nj nk nl b">architecture</code>、<code class="fe ni nj nk nl b">executable</code>、<code class="fe ni nj nk nl b">load address</code>和<code class="fe ni nj nk nl b">address</code>。</p><p id="2859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说<code class="fe ni nj nk nl b">architecture</code>。在您的崩溃日志中，向下滚动到“二进制映像”部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/e7db90a21457ef2f30b6a706619c2bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vzOQpt6Jxr6PyII2r7MdTA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">iOS崩溃报告:二进制映像部分</p></figure><p id="4bc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在二进制映像名称旁边找到了二进制架构。在我们这里是<a class="ae ky" href="https://en.wikipedia.org/wiki/AArch64" rel="noopener ugc nofollow" target="_blank"> arm64 </a>。</p><p id="feaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe ni nj nk nl b">executable</code>，我们通过以下路径:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="86f6" class="nq md it nl b gy nr ns l nt nu">&lt;PathToDSYMFile&gt;/Contents/Resources/DWARF/&lt;BinaryName&gt;</span></pre><p id="3391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在我们象征的二进制图像的开头找到了<code class="fe ni nj nk nl b">load address</code>。上图可以看到，对我来说，是<code class="fe ni nj nk nl b">0x100bb0000</code>。</p><p id="94e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个参数是<code class="fe ni nj nk nl b">address</code>，它是帧的内存地址。如果您返回到我谈到线程回溯中的帧的部分，您可以在本文的第二幅图像中看到这一点。例如，对于帧#5，<code class="fe ni nj nk nl b">address</code>是<code class="fe ni nj nk nl b">0x0000000100bb6080</code>。</p><p id="8278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果要对多个帧进行符号化，则不必多次调用该命令。只需输入用逗号分隔的所有地址。</p><p id="e027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们完整的神奇配方:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="0648" class="nq md it nl b gy nr ns l nt nu">atos -arch &lt;Binary Architecture&gt; -o &lt;Path to dSYM file&gt;/Contents/Resources/DWARF/&lt;binary image name&gt; -l &lt;load address&gt; &lt;address to symbolicate&gt;</span></pre><p id="e86d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及我们当前示例的实际实现:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="d6e7" class="nq md it nl b gy nr ns l nt nu">atos -arch arm64 -o dSYMs/D1ABC7F3-E81D-3264–847E-4FB2578B43DD.dSYM/Contents/Resources/DWARF/CrashLogExample -l 0x100bb0000 0x0000000100bb6080</span></pre><p id="d2cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您有望在控制台中看到函数名和行号。如果是这样，这里的工作就完成了，您可以继续调试了。另一方面，如果您在控制台输出中看到类似于<code class="fe ni nj nk nl b">_hidden#710_</code>的内容，那么请继续阅读。</p><p id="cfd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为当您从存档中导出<code class="fe ni nj nk nl b">.ipa</code>文件进行分发时，您启用了位代码。然而，没有必要担心，因为我们只需要一个额外的步骤就可以从我们的崩溃日志中获得一些有用的信息。</p><p id="3857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个拼图的最后一块被称为<em class="mz">符号图</em>，这是Xcode在归档应用程序的过程中生成的一个附加文件。在符号映射的帮助下，我们能够恢复混淆的dSYM文件。</p><p id="dc80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们为此需要的命令叫做<code class="fe ni nj nk nl b">dsymutil</code>。如果我们检查它在终端中做了什么，我们会看到:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="3085" class="nq md it nl b gy nr ns l nt nu">OVERVIEW: manipulate archived DWARF debug symbol files. dsymutil links the DWARF debug information found in the object files for the executable &lt;input file&gt; by using debug symbols information contained in its symbol table.</span></pre><p id="f0fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用该命令的方式是:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="d774" class="nq md it nl b gy nr ns l nt nu">dsymutil -symbol-map &lt;path to BCSymbolMaps&gt; &lt;path to dSYM file&gt;</span></pre><p id="ef01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将它应用到我们当前的例子中:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="02b2" class="nq md it nl b gy nr ns l nt nu">dsymutil -symbol-map CrashLogExample.xcarchive/BCSymbolMaps dSYMs/D1ABC7F3-E81D-3264–847E-4FB2578B43DD.dSYM</span></pre><p id="f37b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您再次运行<code class="fe ni nj nk nl b">atos</code>命令，您应该最终在控制台中看到相关的函数名和行号。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8826" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="4fd6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">程序员通常不喜欢调试和符号化崩溃报告。很明显，它无法与无中生有这种创造性的、或许更能激发智力的练习相比。然而，如果我们希望某个东西可靠地运行和工作，这只是我们必须做的一项工作。</p><p id="ce2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你现在知道下一次如何处理崩溃报告。</p><p id="e5de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您花时间阅读这篇文章。如果你有任何想法、建议或问题，请在下面的评论中留下。</p></div></div>    
</body>
</html>