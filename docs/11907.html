<html>
<head>
<title>How Does React’s Interruptible Updates work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React的可中断更新是如何工作的？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-does-reacts-interruptible-updates-work-5340bcaadb1a?source=collection_archive---------5-----------------------#2022-04-26">https://betterprogramming.pub/how-does-reacts-interruptible-updates-work-5340bcaadb1a?source=collection_archive---------5-----------------------#2022-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ccab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Vue为什么不用光纤架构？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bb267e635323a626bd11ed2cdd90157e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mTVb0dtVC1E8ow-m"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="cee1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React 18发布，最重要的变化是支持纤程架构。它帮助React实现异步的、可中断的更新。这篇文章将向你揭示它是如何工作的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ac4f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么反应纤维？</h1><p id="ad8b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因为在17版本之前，虚拟DOM的Diff是以递归的方式完成的，递归的过程是不能中断的。这是因为一旦中断，当它再次开始时，它不知道当前的处理在哪里。</p><p id="ff70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用identity也是一个禁忌，因为DOM中的操作可能很复杂，并且DOM树的结构可能会发生巨大的变化。</p><p id="daa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不间断的递归过程会导致JavaScript代码执行时间过长。浏览器的渲染工作和JavaScript的执行在同一个线程上。这就导致页面不能及时变化，让用户有卡顿感。</p><p id="e2e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以React团队采用了纤程架构。</p><h1 id="cea4" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">什么是反应纤维？</h1><p id="6aae" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">React Fiber可以理解为React内部实现的一组状态更新机制。</p><p id="bf18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，它可以被中断和恢复。并且恢复后，之前的计算结果和中间状态可以重复使用。</p><p id="3581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，它还支持更新任务的不同优先级。它允许那些高优先级的任务(如用户输入、动画等。)尽可能早地呈现在页面上。</p><p id="3ebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体到代码，它是一个类似链表的数据结构。那么我们来看看<a class="ae ky" href="https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiber.new.js#L122" rel="noopener ugc nofollow" target="_blank">源代码</a>中FiberNode的定义:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="d84d" class="nj md it nf b gy nk nl l nm nn"><strong class="nf iu">// Instance</strong><br/>this.tag = tag;<br/>this.key = key;<br/>this.elementType = null;<br/>this.type = null;<br/>this.stateNode = null;</span><span id="0379" class="nj md it nf b gy no nl l nm nn"><strong class="nf iu">// Fiber</strong><br/>// Connect with other fibers<br/>this.return = null;<br/>this.child = null;<br/>this.sibling = null;<br/>this.index = 0;</span><span id="b1ad" class="nj md it nf b gy no nl l nm nn">this.ref = null;</span><span id="44be" class="nj md it nf b gy no nl l nm nn"><strong class="nf iu">// Properties of a unit of work</strong><br/>this.pendingProps = pendingProps;<br/>this.memoizedProps = null;<br/>this.updateQueue = null;<br/>this.memoizedState = null;<br/>this.dependencies = null;</span><span id="c23f" class="nj md it nf b gy no nl l nm nn">this.mode = mode;</span><span id="b0d5" class="nj md it nf b gy no nl l nm nn"><strong class="nf iu">// Effects<br/>// Markup after Diff, used to map to the real DOM</strong><br/>this.flags = NoFlags;<br/>this.subtreeFlags = NoFlags;<br/>this.deletions = null;</span><span id="fe95" class="nj md it nf b gy no nl l nm nn"><strong class="nf iu">// Update schedule priority</strong><br/>this.lanes = NoLanes;<br/>this.childLanes = NoLanes;</span><span id="d9dd" class="nj md it nf b gy no nl l nm nn"><strong class="nf iu">// Current Fiber backup from last update<br/>// It will be compared with the current latest Fiber, which is Diff</strong><br/>this.alternate = null;</span></pre><p id="3021" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我添加了额外的注释，源代码是<a class="ae ky" href="https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiber.new.js#L122" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="35cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我重点解释一下纤程节点的连接信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/9b0926ad53163cca0b66b89004fea07c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CFxHzFud3qCb9wEaMru5VQ.png"/></div></div></figure><p id="3dd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，它们是按照这种类似链表的逻辑链接在一起的。</p><p id="a1ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个节点都被视为一个“工作单元”，当浏览器空闲时，每次只处理一个“工作单元”。因为分割的工作单元足够小，所以JavaScript的执行时间相当短。所以这并不妨碍浏览器的渲染工作。</p><p id="f632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更具体地说，用伪代码表示这个过程如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="9068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们分析一下Fiber节点在挂载阶段和更新阶段是如何工作的。</p><h1 id="e979" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">增加</h1><p id="5939" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这种情况下的纤程节点树实际上经历了Diff算法。但是，由于之前的纤程节点不存在，因此该Diff将使用替换标志来标记所有纤程节点。</p><p id="fa67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在提交阶段，将根据标识修改真正的DOM。这是附加物。</p><h1 id="8d42" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">更新</h1><p id="07f3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在更新期间，还将生成一个纤程节点树。此时会比较之前已经映射到真实DOM的纤程节点树，标记出变化的纤程节点。</p><p id="dcec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在提交阶段，将根据标识修改真正的DOM。这可能是添加、删除、修改属性等。</p><p id="dd4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种技术被称为双重缓存。但是Vue.js为什么不用双缓存呢？</p><p id="cfb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为和Vue相比，React并不确切知道一个更新(状态改变)会影响哪个DOM(组件)。所以需要从头(根)到尾计算，并且在计算过程中尽可能重用之前的DOM。</p><p id="2ef8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归计算在此过程的早期使用。尽管执行JS的时间稍长，但直接操作DOM仍然有性能优势。</p><p id="084e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在使用纤程结构代替递归。核心思想是将计算成本平摊到每个渲染帧中。同时，还添加了优先级模型，允许那些优先级较高的更新提前呈现在页面上。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="ca51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。如果你有兴趣，可以看看<a class="ae ky" href="https://medium.com/@islizeqiang/index-of-my-stories-published-in-2022-3c6e3cb94c07" rel="noopener">我的其他媒体文章</a>。</p></div></div>    
</body>
</html>