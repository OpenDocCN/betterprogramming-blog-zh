<html>
<head>
<title>Why Does KeyPath Have Two Type Signatures in Swift 5.2?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么在Swift 5.2中KeyPath有两种类型签名？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-keypath-has-two-type-signatures-in-swift-5-2-7dcd4a40ca12?source=collection_archive---------21-----------------------#2020-03-03">https://betterprogramming.pub/why-keypath-has-two-type-signatures-in-swift-5-2-7dcd4a40ca12?source=collection_archive---------21-----------------------#2020-03-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1a3f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更好的关键路径</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6aab80ede72b4e00e86055539680c751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDbXOK7hsVWN8_gdfTFBNQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ante_kante?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">安特·哈默斯特</a>在<a class="ae ky" href="https://unsplash.com/s/photos/two?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="821e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们踏上探索Swift 5.1编译器的<code class="fe lv lw lx ly b">KeyPath</code>类型的旅程，并尝试理解为什么它是Swift在数学上的重要特性。</p><p id="7718" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一探索将引导我们发现Swift缺失的功能。但是不要担心，这正是Swift 5.2将添加到<code class="fe lv lw lx ly b">KeyPath</code>类型中的东西:一个更内在的类型签名。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6625" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">今日<code class="fe lv lw lx ly b">KeyPath</code>(Swift 5.1)</h1><p id="3cb0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">KeyPath</code>类型对于描述如何访问类型内部的变量非常有用。</p><p id="3da9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个例子。这里，我们用一个名为<code class="fe lv lw lx ly b">agePath</code>的变量来表示<code class="fe lv lw lx ly b">Human</code>结构的任何实例的年龄属性的位置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f3cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">KeyPath</code>抽象出封装在一个类型中的任何Swift变量的getter <code class="fe lv lw lx ly b">get{}</code>和setter <code class="fe lv lw lx ly b">set{}</code>功能(如果有的话)。</p><p id="580a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当试图编写专注于获取或设置类型变量的泛型算法而不需要了解底层类型的细节时,<code class="fe lv lw lx ly b">KeyPath</code>大放异彩。</p><p id="ad17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用一个<code class="fe lv lw lx ly b">KeyPath</code>来提取<code class="fe lv lw lx ly b">Human</code>列表中的所有年龄或任何其他属性。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="cad4" class="nj mh it ly b gy nk nl l nm nn">func extract&lt;Value&gt;(humans: [Human], path: KeyPath&lt;Human, Value&gt;) -&gt; [Value] {<br/>    humans.map { $0[keyPath: path] }<br/>    <br/>}<br/><br/>let ages = extract(humans: [steve, jeff], path: agePath)</span></pre><p id="1900" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果编译器没有为所有的<code class="fe lv lw lx ly b">Human</code>类型的变量生成一个<code class="fe lv lw lx ly b">KeyPath</code>，我们将不得不自己编写它。让我们通过关注<code class="fe lv lw lx ly b">KeyPath</code>的getter功能来尝试做到这一点。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="1c2e" class="nj mh it ly b gy nk nl l nm nn">let manualAgePath: (Human) -&gt; Int = { human in<br/>    return human.age<br/>}<br/><br/>let jeffManualAge = manualAgePath(jeff)</span></pre><p id="69e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于之前定义的<code class="fe lv lw lx ly b">extract</code>功能，这将转化为以下内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f70c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们刚刚获得了一种调用<code class="fe lv lw lx ly b">.map</code>函数的好方法。没有一些额外的工作，将一个<code class="fe lv lw lx ly b">KeyPath</code>传递给<code class="fe lv lw lx ly b">map</code>是无法实现的(Swift 5.1)。代码<code class="fe lv lw lx ly b">[jeff, steve].map(\Human.age)</code>无法编译。</p><p id="0c6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以编写一个助手来将<code class="fe lv lw lx ly b">KeyPath&lt;Root, Value&gt;</code>转换成<code class="fe lv lw lx ly b">(Root) -&gt; Value</code>类型的函数，但是编译器不会为我们这么做。</p><p id="62b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译器应该在这里帮助我们吗？没有明显的理由说明为什么会这样...让我们很快回到这个问题上来。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="286d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">元组</h1><p id="4804" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">具有两个字段的结构听起来很熟悉，让我们尝试以另一种方式定义<code class="fe lv lw lx ly b">Human</code>类型。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="e217" class="nj mh it ly b gy nk nl l nm nn">typealias HumanTuple = (Int, String)<br/><br/>let tupleJeff: HumanTuple = (5, "Jeff")<br/>let tupleSteve: HumanTuple = (32, "Steve")</span></pre><p id="bdab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只是捕捉到了和以前一样的信息。但是年龄的<code class="fe lv lw lx ly b">KeyPath</code>在哪里？</p><p id="92dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">tuple类型有两个重要的变量。变量<code class="fe lv lw lx ly b">0</code>和<code class="fe lv lw lx ly b">1</code>来访问一个元组的第一个和第二个属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1c3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意编译器如何在一个元组上创建<code class="fe lv lw lx ly b">0</code>和<code class="fe lv lw lx ly b">1</code>属性，以便我们访问该元组中的内容。如果没有这些属性，元组类型将毫无用处。</p><p id="46f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候了解tuple和Swift <code class="fe lv lw lx ly b">struct</code>是如何相互关联的了。通过回答这个问题，我们将解开对<code class="fe lv lw lx ly b">KeyPath</code>及其重要性的理解。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b00b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">两种类型的产品</h1><p id="1f2b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对于我们的其余探索，让我们假设swift类型由集合表示(数学集合，而不是Swift类型<code class="fe lv lw lx ly b">Set</code>)。准确地说，是包含该类型可表达的所有可能值的集合。</p><p id="ade7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，类型<code class="fe lv lw lx ly b">Bool</code>可以被视为两个值<code class="fe lv lw lx ly b">true</code>和<code class="fe lv lw lx ly b">false</code>的集合。以下符号用于描述该集合。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="d480" class="nj mh it ly b gy nk nl l nm nn">Bool = ｛ true, false ｝</span></pre><p id="171c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个例子是有三种情况的简单<code class="fe lv lw lx ly b">enum</code>。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="3707" class="nj mh it ly b gy nk nl l nm nn">enum Color {<br/>    case red<br/>    case blue<br/>    case green<br/>}</span></pre><p id="a9dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关联的集合就是这个<code class="fe lv lw lx ly b">enum</code>可以取的三个值。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="e8f3" class="nj mh it ly b gy nk nl l nm nn">Color = ｛ red, blue, green ｝<br/>	  = ｛ blue, green, red ｝<br/>	  = ｛ green, red, blue ｝</span></pre><p id="073b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们使用等号<code class="fe lv lw lx ly b">=</code>来表示集合之间的相等。等式提醒我们，集合中的顺序并不重要。</p><p id="75a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以定义两个集合<code class="fe lv lw lx ly b">X</code>和<code class="fe lv lw lx ly b">Y</code>的乘积，表示为<code class="fe lv lw lx ly b">X×Y</code>，通过创建由这些集合生成的所有可能的对。为了命名一对对象，我们将使用Swift用于元组的相同符号。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="cad1" class="nj mh it ly b gy nk nl l nm nn">Bool×Color = ｛ (true,blue), (true,red), (true,green), (false,blue), (false,red), (false,green) ｝</span></pre><p id="ba35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也适用于无限集合，如<code class="fe lv lw lx ly b">Int</code>和<code class="fe lv lw lx ly b">String</code>(假设计算机有无限内存来表示它们...).</p><p id="5a1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，从这个角度来看，类型<code class="fe lv lw lx ly b">Human</code>和<code class="fe lv lw lx ly b">HumanTuple</code>是相同的。它们是类型<code class="fe lv lw lx ly b">Int</code>和<code class="fe lv lw lx ly b">String</code>的产品。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="c2e7" class="nj mh it ly b gy nk nl l nm nn">Human = HumanTuple<br/>	  = Int×String<br/>	  =｛ ..., (5,"Jeff"), (32,"Steve"), (26, "Simon"), ... ｝</span></pre><p id="501b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更一般地说，在<code class="fe lv lw lx ly b">swift</code>中，我们会有以下两种类型。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="ecab" class="nj mh it ly b gy nk nl l nm nn">struct PairStruct&lt;A,B&gt; {<br/>    let a: A<br/>    let b: B<br/>}<br/><br/>typealias PairTuple&lt;A,B&gt; = (A,B)</span></pre><p id="cc69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当作为器械包查看时，类型<code class="fe lv lw lx ly b">PairStruct</code>和<code class="fe lv lw lx ly b">PairTuple</code>是相同的。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="f2e3" class="nj mh it ly b gy nk nl l nm nn">PairStruct = PairTuple<br/>		   = A×B<br/>		   =｛ all possible pairs ｝<br/>		   =｛ (a,b) where a∊A, b∊B ｝</span></pre><p id="1436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们代表了两种原始类型<code class="fe lv lw lx ly b">A</code>和<code class="fe lv lw lx ly b">B</code>的所有组合。综上所述，从集合的角度来看，元组和<code class="fe lv lw lx ly b">struct</code>是一样的。现在，是时候找到产品类型中的<code class="fe lv lw lx ly b">KeyPath</code>了。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e315" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">集合的乘积，又来了！</h1><p id="1ebf" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们试着找出两个集合乘积的等价定义。通过对集合的乘积有一个等价但不同的框架，我们将找到拼图中缺失的那块。</p><p id="7a25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们随机选择一个类型，例如<code class="fe lv lw lx ly b">Double</code>(我们可以用任何类型替换<code class="fe lv lw lx ly b">Double</code>)。</p><p id="5723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在选择从<code class="fe lv lw lx ly b">Double</code>到<code class="fe lv lw lx ly b">Int</code>和从<code class="fe lv lw lx ly b">Double</code>到<code class="fe lv lw lx ly b">String</code>的两个函数的随机实现(我们可以用任何实现替换！).</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="150a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住<code class="fe lv lw lx ly b">f</code>和<code class="fe lv lw lx ly b">g</code>，让我们用下面的类型签名实现我们能想到的最自然的函数。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="ec47" class="nj mh it ly b gy nk nl l nm nn">func h(x: Double) -&gt; PairTuple&lt;Int, String&gt; {<br/>    fatalError()<br/>}</span></pre><p id="23a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以简单地使用这些来创建一个元组。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="4eb4" class="nj mh it ly b gy nk nl l nm nn">func h(_ x: Double) -&gt; PairTuple&lt;Int, String&gt; {<br/>    (f(x), g(x))<br/>}</span></pre><p id="e0fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们前面已经看到，为了使tuple类型有用，我们需要一种方法来提取第一个和第二个组件。</p><p id="754d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，编译器自动为我们提供了变量<code class="fe lv lw lx ly b">0</code>和<code class="fe lv lw lx ly b">1</code>。我们可以通过为<code class="fe lv lw lx ly b">PairTuple</code>类型创建两个函数来表达这种提取能力。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cfb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们称这些函数为<em class="no">投影图</em>。想象一个光源产生一个阴影，一个投影贴图把元组投影回原来的类型。根据我们在<code class="fe lv lw lx ly b">PairTuple&lt;Int, String&gt;</code>前面放置光源的位置，我们会看到阴影<code class="fe lv lw lx ly b">Int</code>或<code class="fe lv lw lx ly b">String</code>。</p><p id="9f3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且，没有一个影子的<em class="no">影子。从这个意义上说，投射一个影子会给我们同样的影子。严格地说，投影图是合成的幂等函数:<em class="no">多次应用它将给出相同的结果。</em></em></p><p id="8e59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要看到这一点，重新定义<code class="fe lv lw lx ly b">proj_1</code>以返回类型<code class="fe lv lw lx ly b">(Int,String)</code>和返回值<code class="fe lv lw lx ly b">(p.0, "")</code>。我们观察到<code class="fe lv lw lx ly b">proj_1(proj_1(x)) == proj_1(x)</code>对于我们构造的所有<code class="fe lv lw lx ly b">x</code>。</p><p id="e0f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们注意到，如果我们选择值为<code class="fe lv lw lx ly b">3.4</code>的<code class="fe lv lw lx ly b">Double</code>，我们有两个等式。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="cb71" class="nj mh it ly b gy nk nl l nm nn">proj_1(h(3.4)) == f(3.4)<br/>proj_2(h(3.4)) == g(3.4)</span></pre><p id="a716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe lv lw lx ly b">Double</code>的所有选择也是如此！这意味着函数<code class="fe lv lw lx ly b">f</code>等于函数<code class="fe lv lw lx ly b">{ x in proj_1(h(x)) }</code>并且<code class="fe lv lw lx ly b">g</code>等于函数<code class="fe lv lw lx ly b">{ x in proj_2(h(x)) }</code>。</p><p id="71b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更简单地说，我们看到，不管我们走哪条路，沿着下图中的箭头走都会得到相同的答案。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl np"><img src="../Images/ee8c2ac3736c0238a1e5a5089390c786.png" data-original-src="https://miro.medium.com/v2/format:webp/1*a6Vr8M2Q6QvLnV7FMZ9-Zg.png"/></div></figure><p id="6d5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们重新定义我们对任何<code class="fe lv lw lx ly b">PairTuple</code>的预测。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="118e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从新的角度来定义这个产品。</p><p id="49ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两种类型<code class="fe lv lw lx ly b">A</code>和<code class="fe lv lw lx ly b">B</code>(用于投影图<code class="fe lv lw lx ly b">p_1</code>和<code class="fe lv lw lx ly b">p_2</code>)的乘积称为<code class="fe lv lw lx ly b">A × B</code>，是唯一的集合，因此对于任何类型<code class="fe lv lw lx ly b">T</code>、任何函数<code class="fe lv lw lx ly b">(T) -&gt; A</code>、任何函数<code class="fe lv lw lx ly b">(T) -&gt; B</code>，我们可以编写一个唯一的函数<code class="fe lv lw lx ly b">h</code>，这样沿着箭头(见下图)可以得到相同的答案。</p><p id="7732" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这需要理解很多，但是下一张图应该直观地总结它，并帮助理解这个定义。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl np"><img src="../Images/ef511112ac89c5d7d2f9e5f2228d2da0.png" data-original-src="https://miro.medium.com/v2/format:webp/1*aMmPSfEUtQvdWEBQle9aRg.png"/></div></figure><p id="f1bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过前面的观察和一些工作，我们可以(这里我们不做)证明我们的两种类型乘积的定义是等价的。这意味着通过使用其中一个定义，我们可以推导出另一个定义，反之亦然。</p><p id="f543" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了说服我们自己这些定义是等价的，让我们试着将新的定义应用到我们之前的例子<code class="fe lv lw lx ly b">Bool×Color</code>。试着去掉这个集合乘积的一个元素，例如，<code class="fe lv lw lx ly b">(true, blue)</code>，想象它是新定义的乘积集。</p><p id="4502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能看出什么不对吗？它将显示该产品是通过投影图的透镜理解任何函数<code class="fe lv lw lx ly b">f</code>和<code class="fe lv lw lx ly b">g</code>的最佳(且唯一)集合(投影的最佳分解集合)。</p><p id="7c8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们刚刚展示了投影图<code class="fe lv lw lx ly b">p_1</code>和<code class="fe lv lw lx ly b">p_2</code>是产品定义的一部分。</p><p id="484d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">PairTuple</code>类型上，从函数的角度来看，它们是<code class="fe lv lw lx ly b">0</code>和<code class="fe lv lw lx ly b">1</code>变量。在<code class="fe lv lw lx ly b">PairStruct</code>上，它们是<code class="fe lv lw lx ly b">a</code>和<code class="fe lv lw lx ly b">b</code>变量，或者从函数的角度看是<code class="fe lv lw lx ly b">\PairStruct.a</code>和<code class="fe lv lw lx ly b">\PairStruct.b</code> <code class="fe lv lw lx ly b">KeyPath</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="57e5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">未来的关键路径(Swift 5.2)</h1><p id="17c4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">多好的旅程啊！我们从如何使用<code class="fe lv lw lx ly b">KeyPath</code>的例子开始，以理解元组和<code class="fe lv lw lx ly b">struct</code>的一些抽象定义结束。</p><p id="5999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此过程中，我们改变了对<code class="fe lv lw lx ly b">struct</code>的观点，将其视为两个集合的乘积，然后我们重新审视了乘积的定义并发现了投影图。</p><p id="fe9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们发现了产品功能<code class="fe lv lw lx ly b">proj_1</code>和<code class="fe lv lw lx ly b">proj_2</code>的内在本质。</p><p id="5e05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在的问题是:<code class="fe lv lw lx ly b">swift</code>中的投影图在哪里？”答案是你在<code class="fe lv lw lx ly b">swift 5.1</code>里找不到它们。</p><p id="cfc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在<code class="fe lv lw lx ly b">swift 5.2</code>中，编译器会自动将<code class="fe lv lw lx ly b">KeyPath&lt;Root, Value&gt;</code>提升到与类型签名<code class="fe lv lw lx ly b">(Root) -&gt; Value</code>相关联的投影图！因此，下面的代码将会编译:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="f577" class="nj mh it ly b gy nk nl l nm nn">[jeff, steve].map(\Human.age) // Swift 5.2<br/>[jeff, steve].map { $0[keyPath: \.age] } // swift 5.1</span></pre><p id="ae98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，从计算Swift 5.2中两种类型(或任意数量的类型)乘积的角度来看，<code class="fe lv lw lx ly b">KeyPath</code>将拥有其自然类型签名。</p></div></div>    
</body>
</html>