<html>
<head>
<title>How to Use Async/await With .map in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Async/await？JavaScript中的地图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-async-await-with-map-in-js-5059043564e0?source=collection_archive---------2-----------------------#2022-04-19">https://betterprogramming.pub/how-to-use-async-await-with-map-in-js-5059043564e0?source=collection_archive---------2-----------------------#2022-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aa16" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">并且知道<code class="fe kf kg kh ki b">Promise.all</code>是否比“for of”快</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/3b6846914cd1c908f4ada0d395643eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*blQfcFKoOSDLBkRN"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">保罗·史密斯在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="884b" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在某种程度上，您可能想知道如何在像<code class="fe kf kg kh ki b">.map</code>或<code class="fe kf kg kh ki b">.forEach</code>这样的方法中使用异步函数。在这个简短的指南中，您将看到最常见的错误是什么以及如何解决它们。</p><p id="1431" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为此，我们将在<code class="fe kf kg kh ki b">index.ts</code>文件中包含以下基本代码:</p><pre class="kk kl km kn gt lw ki lx ly aw lz bi"><span id="0c96" class="ma mb iq ki b gy mc md l me mf">const usernames: string[] = ["jordanrjdev", "anonymous123", "channelyy"];</span><span id="79d7" class="ma mb iq ki b gy mg md l me mf">const simulateFetchData = (username: string): Promise&lt;string&gt; =&gt; {<br/>  return new Promise((resolve) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      resolve(`${username} is a valid username`);<br/>    }, 1000);<br/>  });<br/>}</span></pre><p id="39ed" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如你所见，我们有一个用户名数组和一个函数，它接受一个参数并返回一个字符串。</p><p id="a4e3" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在我们将迭代用户名数组，用map方法获得每个用户的模拟数据:</p><pre class="kk kl km kn gt lw ki lx ly aw lz bi"><span id="5ac7" class="ma mb iq ki b gy mc md l me mf">const dataUsers = usernames.map(async (username) =&gt; {<br/>   return await simulateFetchData(username);<br/>});<br/>console.log(dataUsers);</span></pre><p id="02d6" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但是当执行此操作时，我们将在控制台中看到以下结果:</p><pre class="kk kl km kn gt lw ki lx ly aw lz bi"><span id="3e85" class="ma mb iq ki b gy mc md l me mf">[ Promise { &lt;pending&gt; }, Promise { &lt;pending&gt; }, Promise { &lt;pending&gt; } ]</span></pre><p id="308d" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">因此，为了解决这个问题，我们有两个选择，即使用<code class="fe kf kg kh ki b">Promise.all</code>或使用<code class="fe kf kg kh ki b">for of</code>:</p><h1 id="99f2" class="mh mb iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">对于...来说</h1><p id="5a86" class="pw-post-body-paragraph la lb iq lc b ld my jr lf lg mz ju li lj na ll lm ln nb lp lq lr nc lt lu lv ij bi translated">我们将使用一个<code class="fe kf kg kh ki b">for of</code>来解决这个非常常见的错误，它会让我们在寻找最合适的解决方案时浪费大量时间。</p><pre class="kk kl km kn gt lw ki lx ly aw lz bi"><span id="8ac8" class="ma mb iq ki b gy mc md l me mf">const getWithForOf = async() =&gt; {<br/>   console.time("for of");<br/>   const data = []<br/>   for (const username of usernames) {<br/>     let dataUser = await simulateFetchData(username);<br/>     data.push(dataUser);<br/>   }<br/>   console.timeEnd("for of");<br/>}<br/>getWithForOf();</span></pre><p id="1d4a" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">使用这个选项，代码将按顺序执行，因此您可以等待每个调用。这将有助于我们在进行下一次迭代之前解决每一次迭代。</p><p id="9dd0" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">请记住，如果我们进行N次迭代，每次迭代需要1秒钟来解决。在我们的例子中，这意味着执行完这部分代码总共需要3秒钟。由于<code class="fe kf kg kh ki b">console.time</code>，我们可以在控制台输出中看到这一点:</p><pre class="kk kl km kn gt lw ki lx ly aw lz bi"><span id="c1f6" class="ma mb iq ki b gy mc md l me mf">for of: 3.012s</span></pre><h1 id="a1d6" class="mh mb iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">承诺。所有</h1><p id="4278" class="pw-post-body-paragraph la lb iq lc b ld my jr lf lg mz ju li lj na ll lm ln nb lp lq lr nc lt lu lv ij bi translated">现在我们将使用<code class="fe kf kg kh ki b">promise.all</code>方法来解决我们的问题，所以我们将有下面的代码:</p><pre class="kk kl km kn gt lw ki lx ly aw lz bi"><span id="7c9f" class="ma mb iq ki b gy mc md l me mf">const getWithPromiseAll = async() =&gt; {<br/>   console.time("promise all");<br/>   let data = await Promise.all(usernames.map(async (username) =&gt; {<br/>     return await simulateFetchData(username);<br/>   }))<br/>   console.timeEnd("promise all");<br/>}</span><span id="fa7d" class="ma mb iq ki b gy mg md l me mf">getWithPromiseAll();</span></pre><p id="a1f7" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如您所见，我们有一个接收承诺数组的Promise.all方法，请记住以下代码:</p><pre class="kk kl km kn gt lw ki lx ly aw lz bi"><span id="d2c2" class="ma mb iq ki b gy mc md l me mf">usernames.map(async (username) =&gt; {return await simulateFetchData(username);})</span></pre><p id="655c" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">返回一个承诺数组，这正是我们所需要的，所以我们将它传递给<code class="fe kf kg kh ki b">Promise.all</code>来解决它们。</p><p id="c604" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">此方法将导致并行解析所有异步代码。</p><p id="3b3f" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">所以与<code class="fe kf kg kh ki b">for of</code>不同，让我们看看在控制台中执行这个功能需要多长时间:</p><pre class="kk kl km kn gt lw ki lx ly aw lz bi"><span id="3ffa" class="ma mb iq ki b gy mc md l me mf">promise all: 980.3000000119209ms</span></pre><p id="d482" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">因此，如果我们有N个异步函数，它们将被执行和解析，而无需在它们之间等待，这在某些特定情况下会派上用场。</p><blockquote class="nd ne nf"><p id="31af" class="la lb ng lc b ld le jr lf lg lh ju li nh lk ll lm ni lo lp lq nj ls lt lu lv ij bi translated"><em class="iq">有时出于性能原因，我们需要与</em> <code class="fe kf kg kh ki b"><em class="iq">Promise.all</em></code> <em class="iq">并行执行我们的承诺，其他时候我们需要与</em> <code class="fe kf kg kh ki b"><em class="iq">for of</em></code> <em class="iq">循环顺序执行。重要的是你了解每一个之间的区别，以及如何适应你的需要。</em></p></blockquote><p id="00f1" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">您可以在这个代码沙盒存储库中看到完整的代码</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="fd79" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>