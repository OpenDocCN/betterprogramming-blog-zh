<html>
<head>
<title>Solving the Balancing Brackets Problem in O(n) Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">O(n)时间内解决平衡支架问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/this-how-compilers-evaluate-expressions-and-know-when-you-omit-brackets-semi-colons-d2c262a81b0a?source=collection_archive---------14-----------------------#2019-08-29">https://betterprogramming.pub/this-how-compilers-evaluate-expressions-and-know-when-you-omit-brackets-semi-colons-d2c262a81b0a?source=collection_archive---------14-----------------------#2019-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ac1f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编译器如何知道你何时省略了括号和分号</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a6f1641b3911955e40b2ad823c54688a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xU2FRPLK9KxG5EkeMlgRNw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@jiangxulei1990?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">青 晨</a> on <a class="ae kv" href="https://unsplash.com/search/photos/balance?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></p></figure><p id="d1c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你猜怎么着？事实上，编译器不是能看穿你每一行代码的通灵生物。我要给你一些见解，每次你错配一对括号时，他们是如何准确地指出你的。</p><p id="3beb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天我们将解决一个关于平衡支架的问题。我将向您展示问题陈述和强力方法，并在我们深入研究解决方案之前给您一个提示:暂停一会儿，尝试思考这个问题。我总是鼓励人们自己尝试一些东西，因为你的好奇心将在你成为什么样的开发人员中扮演重要角色。</p><p id="fcd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便说一下，如果你没有看过我的关于栈的教程，也没有任何关于栈的经验，或者你想复习一下，至少可以看看关于在O(1)时间内解决最小栈问题的教程。</p><p id="fc9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，继续吧？是啊！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="cb7a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">平衡括号</h1><p id="1d94" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">括号有三种:[] {}()。给定一个字符串，检查字符串中的所有括号是否平衡。如果所有的开始和结束括号顺序正确，并且相互匹配，则字符串是平衡的。</p><p id="ee91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是一些平衡琴弦:</p><ul class=""><li id="2d37" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated"><strong class="ky ir"> {} </strong></li><li id="9661" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir">(喂)【世界】</strong></li><li id="6036" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir"> [({}{}{})([])] </strong></li></ul><p id="a5a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一些不平衡的:</p><ul class=""><li id="a255" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated"><strong class="ky ir">(你好</strong> —没有结尾<strong class="ky ir"> ) </strong>。</li><li id="21ca" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir">([)]</strong>——在<strong class="ky ir"> () </strong>中<strong class="ky ir"> [ </strong>被不恰当地包围。</li><li id="d41c" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><strong class="ky ir"> )( </strong> —有个结尾<strong class="ky ir"> ) </strong>前面没有<strong class="ky ir"> ( </strong>)。</li></ul><p id="c9d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一行平衡，返回<code class="fe nk nl nm nn b">true</code>，否则返回<code class="fe nk nl nm nn b">false</code>。</p><h2 id="10c6" class="no ma iq bd mb np nq dn mf nr ns dp mj lf nt nu ml lj nv nw mn ln nx ny mp nz bi translated">例子</h2><p id="177f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">以下是三个测试案例:</p><ul class=""><li id="cab8" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated"><code class="fe nk nl nm nn b">puts balanced_<em class="oa">brackets?(‘(hello)[world]’)</em></code></li></ul><p id="5271" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nk nl nm nn b"><em class="oa"># =&gt; true</em></code></p><ul class=""><li id="da9a" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated"><code class="fe nk nl nm nn b"><em class="oa">puts balanced_</em>brackets?(‘([)]’)</code></li></ul><p id="315e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nk nl nm nn b"># =&gt; false</code></p><p id="c510" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nk nl nm nn b">puts balanced_brackets?(‘[({}{}{})([])]’)</code></p><p id="74ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nk nl nm nn b"># =&gt; true</code></p><p id="d8fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提示:愿栈与你同在！我鼓励你在这一点上暂停一下，进行一点头脑风暴。</p><p id="ddd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上主菜！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="cc8a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">解决办法</h1><p id="9fdc" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我将要声明一些类和方法，但是为了避免重复，我不会在本教程中带你看每个类和方法是做什么的。如果你想对这些类和方法有更多的了解，可以看看我的关于最小堆栈问题的教程(如上所述)。</p><p id="b3e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，因为堆栈是基于节点的，所以我们需要设置我们的节点类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="b9a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们初始化堆栈:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="2cfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们请来了少校<code class="fe nk nl nm nn b">pushFront</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="748e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后<code class="fe nk nl nm nn b">popFront</code>它的对应物:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="cb0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，<code class="fe nk nl nm nn b">topFront</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="f215" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，<code class="fe nk nl nm nn b">is_empty?</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="6b6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们来看看最吸引人的地方:我们如何确保一组括号是平衡的？去卡车那里！</p><p id="99a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将把它分成三个部分:</p><ul class=""><li id="19d2" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">初始化我们的堆栈</li><li id="39c1" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">在我们的绳子上循环</li><li id="d795" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">返回<code class="fe nk nl nm nn b">true</code>如果我们设法到达循环的终点</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="66d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看在我们的循环中应该发生什么:</p><ul class=""><li id="b5d0" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">当堆栈为空时，我们希望将字符串中的第一个字符推送到堆栈中，这样我们就有了可以与后续字符进行比较的东西。(如果是括号，只推字符)。</li><li id="ba2e" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">如果一个字符是一个开括号，我们想把它推入堆栈。</li><li id="c6d7" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">如果一个字符是一个闭括号，我们要检查我们是否只是把它的前半部分放入堆栈，如果是，那么就有一个匹配。我们通过从堆栈中移除开始的一半来庆祝这场比赛。</li><li id="7d5f" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">如果我们得到一个闭括号，而不是把它的左半部分放入堆栈，那么我们就有一对不快乐的夫妇。循环应立即停止并返回<code class="fe nk nl nm nn b">false</code>。</li><li id="a5b9" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">但是，假设我们有这样的东西<code class="fe nk nl nm nn b">'[()'</code>。请注意，我们有一个左方括号，没有一个关闭它。接下来会发生什么？我们如何处理这种边缘情况？当循环结束时，我们只是检查堆栈是否为空。</li></ul><p id="86e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:读了一些代码后，你可能会奇怪为什么我没有声明一个包含所有括号类型的数组，并使用像<code class="fe nk nl nm nn b">.include?</code>这样的方法。好吧，简单的答案是像这样的方法实际上有O(n)的时间复杂度。这意味着当你将它们嵌套在一个循环中时，你的复杂度从O(n)变为O(n)，这是性能差的同义词。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7e26" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">让我们写一些代码</strong></h1><p id="8e34" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">首先，解决空栈问题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="ec40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，在比较当前索引的值和三种类型的开括号的值时，使用了布尔运算符。这是因为像这样的比较是常数时间操作O(1 ),而不是像<code class="fe nk nl nm nn b">.include?</code>这样的操作。</p><p id="20f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们只需要推送一个带左括号的字符:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="410a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们需要处理三种不同类型的右括号的边界情况。为此，我使用了下面的switch语句:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="c41c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次我们遇到一个结束括号，我们使用<code class="fe nk nl nm nn b">topFront</code>来查看我们在堆栈上推的最后一个括号。如果它与右括号匹配，我们弹出——移除堆栈顶部的内容，继续循环，直到到达字符串的末尾。</p><p id="f6f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，还记得这个<code class="fe nk nl nm nn b">'[()'</code>？我们仍然需要注意这一点，以防我们遇到一个值得尊敬的对手，他试图欺骗我们的程序。只需在您的<code class="fe nk nl nm nn b">return true</code>语句前添加这一行:</p><p id="3899" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nk nl nm nn b">return false if s.first.next_node</code></p><p id="eacc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们到达字符串末尾时，它检查堆栈是否为空。如果不是，那么我们没有关闭我们应该关闭的所有括号。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d0a2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="4c2f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这就是了。这基本上是编译器如何获得他们的精神力量！众所周知，平衡括号是编译器执行的最重要的操作之一。</p><p id="71f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请务必在下面的回复中留下一些评论。我很想知道你的想法。</p><p id="0fe2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在<a class="ae kv" href="https://github.com/Oluwadamilareolusakin/balancing-brackets" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到这个教程的代码。</p></div></div>    
</body>
</html>