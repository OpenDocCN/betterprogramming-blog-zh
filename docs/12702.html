<html>
<head>
<title>Extracting Lazily Loaded Elements for UI Testing in a SwiftUI iOS App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI iOS应用中提取延迟加载的元素进行UI测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ios-extracting-lazily-loaded-elements-for-ui-testing-5541ea190586?source=collection_archive---------10-----------------------#2022-06-23">https://betterprogramming.pub/ios-extracting-lazily-loaded-elements-for-ui-testing-5541ea190586?source=collection_archive---------10-----------------------#2022-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c008" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建强大的SwiftUI应用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/869df57f9951b848d518c7e6506df1a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDyp-iQz-fZykPvfZ-4yMw.jpeg"/></div></div></figure></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><p id="dce7" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">延迟加载是在线应用程序使用的一种强大的优化技术，其中数据是按需加载的，而不是整体加载的。在线应用程序不断地发送和接收数据，任何减少不必要的交易数据量的方法对最终用户和应用程序本身都有好处。这款应用的后端服务器承受的压力较小，最终用户也不会一直等待数据加载。那么问题出在哪里？</p><p id="dac6" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><em class="lu">快速提示:如果您想直接跳到函数&amp;的实现，请跳到“创建自定义滑动函数”</em></p><h2 id="6bb5" class="lv lw iq bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">寻找延迟加载元素的挑战</h2><p id="bd3f" class="pw-post-body-paragraph ky kz iq la b lb mo jr ld le mp ju lg lh mq lj lk ll mr ln lo lp ms lr ls lt ij bi translated">当运行iOS的自动化UI测试时，非常重要的一点是要注意，我们本质上被应用程序的可访问性层次结构所提供的东西所束缚。就iOS和<code class="fe mt mu mv mw b">XCUITest</code>而言，可访问性层次结构是应用程序用户界面的文本表示。当我们在自动化UI测试中使用断言函数来检查元素的存在时，这就是我们正在测试的。</p><p id="df54" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这实际上是我们的真实来源，应用程序内代码中设置的元素可以通过改变其作为可访问性对象的状态来包含或排除在层次结构之外。延迟加载视图和堆栈导致的问题是，预期的元素可能会加载，也可能不会加载。如果它还没有被加载，它可能存在，但是就你的UI测试而言，它不存在。我们需要一种方法来找到我们需要的东西。</p><h2 id="c70f" class="lv lw iq bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">可访问性层次结构示例:LazyVStack与VStack</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/a2fc4b0e49b7d8eb9b933cdf849382af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SxXLeua8eO8NRsGRT7DMxQ.png"/></div></div></figure><p id="f73c" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">上面显示的是我们将要测试的应用程序的可访问性层次结构。这些层次表示已知的包含绿色单元格的堆栈。当捕获这个层次结构的快照时，对于延迟加载和正常加载的VStacks，我们处于完全相同的应用程序状态；只不过，其中一个提供了更多的信息。</p><p id="bf34" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们的灰色示例向下延伸，列出了VStack包含的所有99个元素，而黑色的顶部只列出了<code class="fe mt mu mv mw b">LazyVStack</code>中加载的内容。出于测试目的，检查常规VStack中是否存在单元格“n”将非常容易，所有内容都已加载！然而，在现实世界中，你不太可能遇到这种有利于考试的情况。</p><h2 id="925a" class="lv lw iq bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">目标</h2><ul class=""><li id="4906" class="my mz iq la b lb mo le mp lh na ll nb lp nc lt nd ne nf ng bi translated"><strong class="la ir">我们如何找到一个卸载的细胞？:</strong>我们将通过向预期元素的方向滑动来找到它。这样做会更新层次结构。</li><li id="a245" class="my mz iq la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">我们如何安全地找到它？:我们创建了一个定制的、可配置的滑动方法来搜索我们的目标元素，直到找到为止。</li></ul><p id="e1e7" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们想要创建一个定制的刷卡功能而不是使用现有的<code class="fe mt mu mv mw b">swipe{Direction}()</code>功能的原因是，使用默认功能迫使我们在达到期望值之前硬编码一组刷卡次数。相反，我们想要能够模拟用户行为并找到所需元素的东西。</p><p id="0baa" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这个应用程序的源代码可以在这里<a class="ae nm" href="https://github.com/martusheff/lazy-loading-ui-testing" rel="noopener ugc nofollow" target="_blank">克隆。</a></p><h2 id="ab9e" class="lv lw iq bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">熟悉应用程序</h2><p id="cd43" class="pw-post-body-paragraph ky kz iq la b lb mo jr ld le mp ju lg lh mq lj lk ll mr ln lo lp ms lr ls lt ij bi translated">这个应用程序(GIF'd below)有4个主要部分，都与我们之前发现的问题相关并具有示范性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/56262365cb851333073553250c3a84be.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/1*Ec26lq-R_7EVQaKr-drMPg.gif"/></div></figure><ol class=""><li id="122a" class="my mz iq la b lb lc le lf lh no ll np lp nq lt nr ne nf ng bi translated">简单文本标题“我的自定义滚动视图”</li><li id="2bf5" class="my mz iq la b lb nh le ni lh nj ll nk lp nl lt nr ne nf ng bi translated">LazyVStack(绿色)</li><li id="6d8d" class="my mz iq la b lb nh le ni lh nj ll nk lp nl lt nr ne nf ng bi translated">LazyHStack(红色)</li><li id="33ba" class="my mz iq la b lb nh le ni lh nj ll nk lp nl lt nr ne nf ng bi translated">自动滚动按钮，按顺序；绿色堆栈开始，绿色堆栈结束，红色堆栈开始，红色堆栈结束。</li></ol><p id="59c2" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这个应用程序为我们提供了一个测试四个方向滑动功能的平台。</p><h2 id="c332" class="lv lw iq bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">设置我们的测试环境</h2><p id="2e55" class="pw-post-body-paragraph ky kz iq la b lb mo jr ld le mp ju lg lh mq lj lk ll mr ln lo lp ms lr ls lt ij bi translated">下面是起始代码，也可以在上面链接的库的主分支上找到。在进行测试之前，我们在这里设置了一个非常简单的页面对象模型设计模式。<br/> <em class="lu"> <br/>如果您想直接跳转到最终代码，请从关联回购中检出“已完成”分支。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="31d7" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这里我们使用3个主要的类:</p><ol class=""><li id="d77a" class="my mz iq la b lb lc le lf lh no ll np lp nq lt nr ne nf ng bi translated"><code class="fe mt mu mv mw b">LazyLoadUITests</code>:我们的UI测试类，我们的测试函数在其中运行和执行。</li><li id="d944" class="my mz iq la b lb nh le ni lh nj ll nk lp nl lt nr ne nf ng bi translated"><code class="fe mt mu mv mw b">BasePage</code>:参考我们的应用程序的基础页面。</li><li id="836d" class="my mz iq la b lb nh le ni lh nj ll nk lp nl lt nr ne nf ng bi translated"><code class="fe mt mu mv mw b">LazyLoadPage</code>:<strong class="la ir"/><code class="fe mt mu mv mw b">BasePage</code>的一个扩展，所有与LazyLoad屏幕相关的东西都将驻留在这里。</li></ol><p id="87f0" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是POM(页面对象模型)的一个非常简单的例子。POM的高级描述如下:将所有与元素声明和属性检索相关的内容保存在页面类中(<code class="fe mt mu mv mw b">BasePage</code>，<code class="fe mt mu mv mw b">LazyLoadPage</code>)，让UI测试类在页面类的帮助下处理断言。</p><h2 id="9e04" class="lv lw iq bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated"><strong class="ak">创建我们的自定义刷卡功能</strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><ol class=""><li id="7846" class="my mz iq la b lb lc le lf lh no ll np lp nq lt nr ne nf ng bi translated"><code class="fe mt mu mv mw b"><strong class="la ir">e</strong>lement</code>:传入的第一个参数是目标元素，或者换句话说，是我们试图寻找的元素。如果找到，该功能将返回并停止向上滑动。</li><li id="00aa" class="my mz iq la b lb nh le ni lh nj ll nk lp nl lt nr ne nf ng bi translated"><code class="fe mt mu mv mw b">maxAttempts</code>:我们想要在视图上滑动的最大次数。这是可配置的，可以防止测试永远停留在寻找不存在的东西。</li><li id="5a8d" class="my mz iq la b lb nh le ni lh nj ll nk lp nl lt nr ne nf ng bi translated"><code class="fe mt mu mv mw b">velocity</code>:我们每秒刷过的像素数。</li></ol><p id="a570" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们的自定义滑动功能将会借用现有的由<code class="fe mt mu mv mw b">XCTest</code>提供的<code class="fe mt mu mv mw b">swipe{Direction}()</code>功能。我们将重复这个动作，直到两件事情中的一件发生；找到了目标元素，或者我们已经达到了最大尝试次数。我们正在滑动的元素是<code class="fe mt mu mv mw b">self</code>，因为我们是从一个<code class="fe mt mu mv mw b">XCUIElement</code>延伸出来的。</p><p id="1a05" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这意味着我们将要调用这个助手函数的元素是包含目标视图的视图/元素。另外，请注意，一旦找到该函数，它不会返回任何内容…这是有意的。很像最初的<code class="fe mt mu mv mw b">swipe{Direction}()</code>功能，它独立工作。测试全流程示例，包括<code class="fe mt mu mv mw b">swipeDownTo(...)</code>的使用，如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="e08f" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是该函数的完整运行情况！</p><ul class=""><li id="d80c" class="my mz iq la b lb lc le lf lh no ll np lp nq lt nd ne nf ng bi translated">首先看看#1是否存在。</li><li id="ba12" class="my mz iq la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">使用我们创建的函数滑动到#67，直到找到为止，然后检查它。</li><li id="5936" class="my mz iq la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">点击向下按钮，将我们带到堆栈的底部。</li><li id="aa65" class="my mz iq la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">检查#99是否存在。</li><li id="4eac" class="my mz iq la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">使用类似的功能向下滑动，直到找到#17，然后检查它。</li><li id="1095" class="my mz iq la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">点击向上按钮，让我们回到堆栈的顶部。</li><li id="71e1" class="my mz iq la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">检查#1是否存在。</li></ul><p id="06a3" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">请随意优化，让它完全符合您的需求！我发现这个功能非常有用，可以避免因为视图变大而导致我们失败的不稳定测试的不断更新。随着这些视图中的单元数量/大小的增加，默认的<code class="fe mt mu mv mw b">swipeUp()</code>不再让模拟器到达需要完成测试的地方。这个函数提供了一些灵活性。</p><h2 id="ffdb" class="lv lw iq bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">挑战</h2><p id="b687" class="pw-post-body-paragraph ky kz iq la b lb mo jr ld le mp ju lg lh mq lj lk ll mr ln lo lp ms lr ls lt ij bi translated">你可能会注意到我没有完成文章中的左/右滑动部分。我把这作为一个挑战，虽然如果你想要解决方案，它将在<code class="fe mt mu mv mw b">completed</code> <em class="lu"> </em>分支<em class="lu">上提供。</em></p><p id="cfd1" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">回购链接:</p><div class="nu nv gp gr nw nx"><a href="https://github.com/martusheff/lazy-loading-ui-testing" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">GitHub-martusheff/lazy-loading-ui-Testing:iOS:为UI测试提取延迟加载的元素</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">github.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol kp nx"/></div></div></a></div><p id="6638" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">提示/窍门:</p><ul class=""><li id="ef98" class="my mz iq la b lb lc le lf lh no ll np lp nq lt nd ne nf ng bi translated">在测试函数中的一行上放置一个断点，并输入<code class="fe mt mu mv mw b">po print(XCUIApplication().debugDescription)</code>来打印应用程序的可访问性层次结构，并访问元素的标识符。</li><li id="5d40" class="my mz iq la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">如果在克隆回购时遇到任何构建错误，请将“签名和功能”下的捆绑包标识符和团队更新到您的信息中。</li></ul></div></div>    
</body>
</html>