<html>
<head>
<title>Passing Any Type in C++ Like in Python to Simplify Our Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像Python一样传递C++中的任何类型来简化我们的代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/passing-any-type-in-c-like-in-python-to-simplify-our-code-3af72347282d?source=collection_archive---------5-----------------------#2021-11-08">https://betterprogramming.pub/passing-any-type-in-c-like-in-python-to-simplify-our-code-3af72347282d?source=collection_archive---------5-----------------------#2021-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5055" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解像std::any这样的类型如何帮助我们简化代码，以及它是如何工作的，这样我们就可以在开发应用程序时确定它是否满足我们的需求</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/72ecaff83834b626e11163bd40ebf378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2KV7UHKi5bnG1L3G"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">詹姆斯·哈里森在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="baff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先讨论为什么我们需要使用任何类型，并举例说明，然后讨论如何使用类型擦除技术实现它，最后讨论它如何分配内存，看看它是否适合我们用C++编写应用程序的需要。</p><h1 id="3515" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">传递任何类型—为什么我们需要它</h1><h2 id="7f40" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">动态类型语言</h2><p id="2279" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在像Python这样的动态类型编程语言中，我们可以将任何类型传递给函数，并在运行时检查它是否具有函数需要的属性。例如，函数有一个名为input的参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="96d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们传递了一个错误的参数类型，比如一个int，<code class="fe ng nh ni nj b">function(3)</code>，将会引发一个异常AttributeError。</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="91db" class="mn lw it nj b gy no np l nq nr">AttributeError: 'int' object has no attribute 'x'</span></pre><p id="6494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们传递一个具有“x”属性的类型时，我们的函数就成功执行了。方法也是如此，如果存在同名的方法，就会执行，否则就会引发异常。</p><h2 id="cd23" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">静态类型语言</h2><p id="f3ef" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在像C++这样的静态类型编程语言中，我们严格地需要参数的类型。与Python不同，类型检查是在编译时执行的，这就是为什么我们需要知道类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="fb25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们传递了一个错误的参数类型，比如一个int，<code class="fe ng nh ni nj b">function(3)</code>，我们会得到下面的编译错误。</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="0201" class="mn lw it nj b gy no np l nq nr">error: invalid initialization of reference of type ‘const Input&amp;’ from expression of type ‘int’</span></pre><blockquote class="ns"><p id="a68a" class="nt nu it bd nv nw nx ny nz oa ob lu dk translated">我们可以看到，不同之处在于执行类型检查的时间，在运行时与在编译时。</p></blockquote><h2 id="cb51" class="mn lw it bd lx mo oc dn mb mq od dp mf li oe mt mh lm of mv mj lq og mx ml my bi translated">在什么场景下我们需要在C++中传递任何类型？</h2><p id="9d53" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在某些情况下，当使用像C++这样的静态类型语言时，我们会希望将任何类型传递给我们的函数。让我们通过一个例子来演示这个场景。</p><p id="6bfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望有一个名为<code class="fe ng nh ni nj b">AnimalFeeder</code>的类，它将<code class="fe ng nh ni nj b">Animal</code>对象存储在一个容器中，比如<code class="fe ng nh ni nj b">std::map</code>，我们希望在这个类中实现一个名为<code class="fe ng nh ni nj b">Feed(animalType, food)</code>的统一函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/51cb237c6ed91ec82e20ae05140445e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*cDRXQDXh_pyFGBk32DrKIQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">序列图(图片由作者提供)</p></figure><p id="c5f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">举个例子，我们有四种不同类型的动物，它们吃不同类型的食物:</p><ul class=""><li id="1b23" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu on oo op oq bi translated">牛吃草</li><li id="da52" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">鸟吃种子</li><li id="8054" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">鱼吃虫子</li><li id="fb60" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">大象吃水果</li></ul><p id="c938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将它们存储在容器中，它们需要从同一个名为Animal的类中继承。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/d3d134e0266d7a58f68af16fed8390e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*hbTe-drakX5d_4tH9wDCXQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">类图(图片由作者提供)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/3b44643ab4c4a7bac61157e5690e7a2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*Bs8QEfjvZBwEjvl6pO9qBg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">动物与食物的关系(图片由作者提供)</p></figure><p id="5ed5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有传递任何类型的能力，我们可以实现函数重载，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d13f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们实现<code class="fe ng nh ni nj b">AnimalFeeder</code>类如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><blockquote class="ns"><p id="22e2" class="nt nu it bd nv nw nx ny nz oa ob lu dk translated">这只是针对4种类型，想象一下，如果我们有100种或更多类型，我们需要添加许多看起来非常相似的代码。</p></blockquote><h2 id="31e1" class="mn lw it bd lx mo oc dn mb mq od dp mf li oe mt mh lm of mv mj lq og mx ml my bi translated">std::任何救援</h2><p id="b3f4" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">请记住，我们的目标是有一个单一的接口，以避免重复，并使我们的代码更容易阅读。为此，我们可以使用从C++17开始添加的<code class="fe ng nh ni nj b">std::any</code>。</p><p id="8911" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">std::any</code>是单个对象/值的类型安全容器。我们可以用<code class="fe ng nh ni nj b">std::any</code>包装任何类型。</p><p id="3e76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看使用<code class="fe ng nh ni nj b">std::any</code>时的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1093" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以有一个单一的界面，<code class="fe ng nh ni nj b">void Feed(const std::any&amp;)</code>用于所有类型的动物。而下面是用<code class="fe ng nh ni nj b">std::any</code>实现的<code class="fe ng nh ni nj b">AnimalFeeder</code>类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="bfcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在比过载版本简单多了。<code class="fe ng nh ni nj b">Animal</code>类的具体实现如<code class="fe ng nh ni nj b">Cow</code>可以通过使用<code class="fe ng nh ni nj b">std::any_cast&lt;Grass&gt;(food)</code>来取回类型。</p><p id="6d82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经看到了任何类型类如何帮助我们简化代码，让我们看看它是如何工作的。通过了解它在幕后是如何工作的，我们可以确定它是否可以用于我们的应用程序。</p><h1 id="187a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">擦除文字以覆盖任何文字—概述</h1><p id="c0f1" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">对于包装任何类型的类，我们可以使用C++中称为类型擦除的技术。这种技术通过结合编译时Duck类型化(模板和面向对象编程)来删除所包含对象的类型。我写了一篇文章，讨论了下面的类型擦除技术的细节，请阅读它以了解更多关于类型擦除的信息。</p><div class="oy oz gp gr pa pb"><a href="https://towardsdatascience.com/c-type-erasure-wrapping-any-type-7f8511634849" rel="noopener follow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">C++类型擦除:包装任何类型</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">了解如何用C++编写类中任何类型的包装器，以提高代码的抽象层次。</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp ks pb"/></div></div></a></div><p id="1e22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了正确地管理被包含对象的生存期，包装器必须制作一个副本，并可能从自由存储中为它分配内存。为了形象化，下面是我们上面例子的类图——包装不同类型动物食品的任何类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/43c965b05828b0adf6f7b37b2d14d1d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*ScGj2m72uvuKByr9RLYSjQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">任何类型包装的类图(图片由作者提供)</p></figure><p id="2a8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们将我们的对象包装在一个<code class="fe ng nh ni nj b">std::any</code>中时，发生的事情是它被包装在一个名为<code class="fe ng nh ni nj b">Wrapper&lt;&gt;</code>的类模板中，并存储在free-store中，可能在一个智能指针中。</p><p id="c14a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们调用<code class="fe ng nh ni nj b">std::any food = Grass()</code> <strong class="lb iu"> </strong>来包装我们的对象时，发生的情况如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7816" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构造一个类型为<code class="fe ng nh ni nj b">Wrapper&lt;Grass&gt;</code> <strong class="lb iu"> </strong>的唯一指针。这只是为了说明内部发生了什么，省略了一些细节。</p><h1 id="e0fa" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">正确恢复类型</h1><p id="4cec" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们的类型现在被包装和复制，但是我们如何把它转换回原来的类型呢？这是使用<code class="fe ng nh ni nj b">std::any</code>的好处之一，否则，如果它不能把原来的类型还给我们，就和使用void指针<code class="fe ng nh ni nj b">(void *)</code>一样，多了一些额外的成本。</p><p id="f04e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的包装类中，我们必须实现一个返回所包含对象类型的接口。为此，我们可以在C++中使用<code class="fe ng nh ni nj b">typeid</code>操作符，返回一个<code class="fe ng nh ni nj b">std::type_info</code>类型的对象。实现类型擦除技术的包装器的完整代码如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e982" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果被查询的类型与包含的对象类型匹配，我们可以实现一个非成员函数，通过强制转换来获取原始类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ec3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个实现，我们可以用它来包装一个整数，并将其转换回整数，如下面的代码片段所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9360" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们调用<code class="fe ng nh ni nj b">cast&lt;int&gt;(any)</code>时，您可以看到发生了什么，我们进行了一些函数调用以及动态分派(通过虚拟表的函数调用)。这是我们为这个抽象付出的额外成本。</p><h1 id="84c8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">它是如何处理小物体的？</h1><p id="0a81" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">任何类型的实现都有另一个与性能相关的方面，那就是小对象优化。</p><p id="436e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的最后一段代码中，我们可以包装小对象，比如基本类型(int、float等)。)如果我们不小心，因为我们从自由存储/堆中分配内存，我们的实现可能会导致内存分段。</p><p id="bf40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解内存分段如何发生的细节，请参阅我关于内存分配/释放的文章。</p><div class="oy oz gp gr pa pb"><a href="https://towardsdatascience.com/c-memory-allocation-deallocation-for-data-processing-1b204fb8a9c" rel="noopener follow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">用于数据处理的C++内存分配/释放</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">理解如何管理内存将有助于我们更明智地分配/释放内存。</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="pr l pm pn po pk pp ks pb"/></div></div></a></div><p id="72e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据C++标准，<strong class="lb iu"> std::任何</strong>实现都应该避免从自由存储/堆中为小对象动态分配内存。但是，它是特定于实现的，不能保证。</p><p id="eb85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">概括地说，有两种不同的方法来处理小对象:</p><ul class=""><li id="0fed" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu on oo op oq bi translated">对小对象使用内存池</li><li id="4e84" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">就地存放小物件</li></ul><h2 id="c456" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">小对象的内存池</h2><p id="ec5d" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">“小”的含义没有标准，一些编译器使用两个指针<em class="ps">的大小，而另一些使用更大的大小。使用这种方法，我们可以预先分配一大块内存，并通过重写new和delete操作符来管理内部的内存分配/释放请求，这样我们就可以控制从哪里分配内存。在以后的另一篇文章中会有更多的介绍。</em></p><p id="d692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以想象，我们想要预分配的内存大小是特定于实现的。</p><h2 id="a142" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">就地存放小物件</h2><p id="dcd8" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">使用这种方法，在编译时，我们需要确定所包含对象的大小是否“小”。如果它很小，我们就地存储包含的对象，否则，我们让C++运行时为它动态分配内存。</p><p id="86b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">细节相当复杂，我们可以在以后的帖子中再讨论。但是，这个想法是有一个有两个成员的工会。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9af8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以下情况下选择就地存储:</p><ul class=""><li id="fddc" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu on oo op oq bi translated">类型满足<a class="ae ky" href="https://en.cppreference.com/w/cpp/types/is_move_constructible" rel="noopener ugc nofollow" target="_blank">is _ not row _ move _ constructive</a></li><li id="5b10" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">包含的对象类型的大小≤<code class="fe ng nh ni nj b">static_alloc</code>的大小</li></ul><p id="2128" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，将选择动态存储。</p><h1 id="e32f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">关键要点</h1><p id="6e07" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">总而言之，</p><ul class=""><li id="178b" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu on oo op oq bi translated">在C++中，我们可以像在Python中一样将任何类型传递给函数</li><li id="4c4d" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">从C++17开始支持<code class="fe ng nh ni nj b">std::any</code></li><li id="868d" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">在某些情况下，简化我们的代码并使其更具可读性是很有用的</li><li id="d8d9" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">任何类型的实现都使用类型擦除技术，这是模板+ OOP的组合</li><li id="1dab" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">包装器实现了一个统一的接口<code class="fe ng nh ni nj b">std::type_info (*behavior)()</code> <strong class="lb iu"> </strong>，这样我们就可以恢复原来的类型</li><li id="3cea" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">C++标准鼓励对小对象的内存分配进行优化，但这并不保证</li><li id="d8fe" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">如果您的应用程序关心内存分段，您可能希望编写自己的Any类型，它使用内存池，而不是大多数库中实现的简单的就地/动态存储方法</li></ul></div></div>    
</body>
</html>