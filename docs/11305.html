<html>
<head>
<title>SwiftUI: Choosing an Application Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI:选择应用架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-choosing-an-application-architecture-6ec9289f8e8f?source=collection_archive---------0-----------------------#2022-03-08">https://betterprogramming.pub/swiftui-choosing-an-application-architecture-6ec9289f8e8f?source=collection_archive---------0-----------------------#2022-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eee9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果不知道自己需要什么，就很难决定。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c67b25da6f31fbc6f3ba4d474451108b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I1YSDLPLKcgrQmwRsj-e5g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Patrick Schneider 在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7f48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI软件开发的声明式方法使得为iOS、Mac和苹果生态系统的其余部分编写现代应用程序变得非常非常容易。</p><p id="8968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是SwiftUI并非没有自己的挑战和问题，其中一个问题就是我们应该在全新的SwiftUI应用程序中使用什么样的架构？</p><p id="dd01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个经常被问到的问题，也是一个经常被回答的问题——也许没有人会感到惊讶。事实上，有很多很多关于这个主题的文章、书籍和演讲。</p><p id="b814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，其中相当一部分是由渴望将自己喜欢的架构引入SwiftUI的人完成的。因此，我们面临着铺天盖地的文章告诉我们为什么应该使用MVVM，或反应/Redux，或清洁，或毒蛇，或TCA。或者根本没有。</p><p id="d99a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于我自己写的关于这个问题的文章，我想在这方面我和其他人一样有罪。</p><p id="8b71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，问题仍然存在:我们应该选择哪一个？</p><p id="8231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何决定？</p><p id="3d3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用什么标准来做选择？</p><p id="d3f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么标准…真的吗？</p><p id="a200" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你看，随着最后一个问题，地平线上开始出现一丝曙光。也许，只是也许，如果我们知道另一个问题的答案，回答我们的架构问题会更容易:</p><p id="ecc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望我们的架构解决什么问题？</p><h2 id="5831" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">定义问题</h2><p id="4566" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">物理学家有句老话:时间是阻止一切事情同时发生的东西。</p><p id="403a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然时间存在，既然一切<em class="mt">不会同时发生，我们人类决定创造一些计量单位，以便更好地组织事物。</em></p><p id="0738" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分钟和秒钟之类的东西。我们进一步聚合和分组为小时和天、月和年等不同的时间段。共同的单位，一个共同的<em class="mt">框架</em>我们可以用它来讨论时间。来管理它。去<em class="mt">了解</em>它。</p><p id="2e5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，虽然我们可以用一大块代码来编写我们的应用程序，但是作为软件开发人员，我们选择了用代码来编写应用程序。相反，我们试图将我们的应用程序分解成更容易理解的小单元。我们试图编写具有良好定义的角色、行为和责任的类、结构和函数。这是一个观点。那是一个模型。这里的代码是一个提供模型的服务。诸如此类。</p><p id="4e01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用程序架构基本上可以归结为我们用来决定如何将代码分割成所有这些独立组件的规则。为什么那部分去<em class="mt">那里</em>，为什么这部分去<em class="mt">这里</em>。</p><p id="d083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多年来，我们制定了一些指导方针来帮助我们。类似于<em class="mt">单一责任原则、</em>开闭原则、依赖倒置原则、和<em class="mt">关注点分离</em>的思想。</p><p id="f3b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这还不够的话，我们甚至还增加了一些高级概念，如<em class="mt">单一事实来源</em>、<em class="mt">函数式编程</em>和<em class="mt">单向数据流</em>。</p><p id="f9b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些想法中的一些可以很好地结合在一起。其他的会增加额外的复杂性，实际上甚至会使一个简单的程序更难编写、理解和维护。还有一些不过是善意的尝试，试图在Swift和iOS上强加在其他语言和其他平台上发现的限制和问题。</p><p id="8a43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用程序架构——任何应用程序架构——都试图将所有这些规则和指导方针整理和平衡成一组我们可以使用和遵循的最佳实践。</p><p id="615c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的努力成功了，如果我们很好地选择了我们的组件和架构，我们最终会得到一个功能强大、优雅、易于理解的软件。</p><p id="66c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以。如果我们要为SwiftUI定义一个理想的架构…我们到底想从它那里得到什么？</p><h2 id="2af8" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">性能和兼容性</h2><p id="dfbc" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果有人问我这个问题，我的首要标准之一将是它需要与SwiftUI本身很好地协同工作。</p><p id="0255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了用简单的声明性接口定义我们的布局，SwiftUI还带来了另一个主要概念:状态，以及一条数据的单一真实来源的概念。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/e0872914753709fabed1e3c63d85e23c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*jZdHDG1Fm8wUVhkImKuI0A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">WWDC 19“通过SwiftUI的数据流”演示</p></figure><p id="6a4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新状态，程序自动显示变化，在这个过程中重新配置和动画。</p><p id="ce4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有些人将单一来源的真理发挥到了极致。他们问，如果一个给定的数据应该有一个真实的来源，那么为什么不为整个应用程序提供一个真实的来源呢？</p><p id="779f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是基于React/Redux背后的概念的体系结构的基础，虽然这个概念乍一看似乎合乎逻辑，但当应用于SwiftUI时，它并非没有缺陷。</p><p id="67ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在SwiftUI 中的<a class="ae ky" href="https://medium.com/swlh/deep-inside-views-state-and-performance-in-swiftui-d23a3a44b79" rel="noopener">深入内部视图、状态和性能中详细描述了这一点，但底线是SwiftUI可以非常有效地确定任何给定数据变更的后果，并且它只会重绘受该变更影响的界面部分。</a></p><p id="bc85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，创建单个全局状态，我们可能会在较大的应用程序中遇到性能问题，在这些应用程序中，对该状态的更改需要SwiftUI在每次发生<em class="mt">任何</em>更改时检查和/或重建整个视图树(即整个应用程序)中的每个依赖项。</p><p id="98f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如苹果在SwiftUI 演示中的<em class="mt">数据流所指出的，另一种方法是将状态绑定到尽可能低的视图层次结构中。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/036e18a922c884d0698444081e7855bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*Apcknu7YFqUvypWbNrohNw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">WWDC19“通过SwiftUI的数据流”演示</p></figure><p id="ac4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在层次结构的底层绑定时，我们极大地减少了所需的界面更新和渲染的数量，因为任何给定的状态变化只会影响视图树的一小部分。</p><p id="9b8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大型全局状态的另一个缺点是，如果您将该状态导入到单个视图中，那么每个人都可以看到所有内容。因此，在不遍历视图中的每一行代码的情况下，您如何确定给定视图可能正在访问或操作什么信息呢？</p><p id="b9cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不太好。</p><p id="aa27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以编写额外的代码来过滤状态，使之适合正在讨论的视图…但是您基本上是在编写更多的代码来解决您自己创造的问题。</p><p id="12d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有点不太理想的情况。</p><p id="0d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对SwiftUI幕后发生的事情感兴趣，我强烈建议你阅读SwiftUI 文章中的<a class="ae ky" href="https://medium.com/swlh/deep-inside-views-state-and-performance-in-swiftui-d23a3a44b79" rel="noopener">深层观点、状态和性能，但同时我认为我们可以利用上述问题来排除那些类型的架构。</a></p><p id="6972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么下一步是什么？</p><h2 id="b2e8" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">简单</h2><p id="e53f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">SwiftUI为编写应用程序带来了一种简单的声明式方法。也许更确切地说，是<em class="mt">简洁</em>。你可以用很少的代码完成很多工作。</p><p id="e6dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，给我们自己和我们的应用程序增加过于正式的架构的负担将是一种耻辱，这又一次显著地增加了我们需要编写的代码量。</p><p id="830d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尤其是样板代码。这可能只是个人偏好，但我讨厌样板代码。此外，我也认为更多的代码会导致更多的错误，因为更多的代码会给那些小傻瓜更多的藏身之处。由于样板代码是样板，为了避免重新输入所有内容，它往往会被复制和粘贴很多次…这反过来会导致您的代码中出现偷偷摸摸的复制/粘贴错误。</p><p id="6e60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，这倾向于排除过于正式的架构，如VIPER，它坚持将应用程序的每一部分都分解成视图、交互器、呈现器、实体和路由器。VIPER架构在很大程度上是基于SOLID的<em class="mt">单一责任原则</em>，但从我的角度来看，它倾向于将这一思想发挥到极致。</p><p id="26a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">VIPER传统上是与基于UIKit的应用程序配对的，在这种情况下，我们很不幸地倾向于为应用程序中的每个屏幕创建一个大的UIViewController。制作不同的视图、xib和嵌套视图控制器通常是非常麻烦的工作，所以我们经常懒得这么做。</p><p id="ac6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们寻找一种方法，将尽可能多的逻辑和用户交互移出视图控制器……我们做到了，每一个都进入了它自己的小部分。</p><p id="6d75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">VIPER创建了许多小的活动部件，因此为管理VIPER应用程序而编写的代码中有很大一部分是为了管理VIPER本身。</p><p id="78d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SwiftUI的 <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/viper-for-swiftui-please-no-ee61ce99694c"> <em class="mt"> VIPER中，我写了很多关于这个主题的内容。求你了。</em>号</a></p><p id="a20e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，那么使用另一个UIKit通用的架构怎么样，比如MVP？</p><h2 id="62bf" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">MVP:模型-视图-演示者。</h2><p id="007e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">MVP是许多UIKit应用程序中使用的经典架构模式。</p><p id="b0b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里大部分逻辑从ViewController转移到一个称为Presenter的对象。给定屏幕的大部分业务逻辑都是在那里执行的，当需要更改时，presenter向给定视图发送消息，告诉它需要更改和重绘。</p><p id="48fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是经典的面向对象的消息传递方法……当您试图将它与SwiftUI一起使用时，它会有一些缺点。</p><p id="efbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先也是最重要的是，与UIKit不同，SwiftUI视图不是视图。它只是我们界面的一个定义。那个定义<em class="mt">可能</em>生成一个视图，或者它可能只是在一个视图上创建一个层。也可能是别的什么。</p><p id="7eed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，你在代码中看到<code class="fe mw mx my mz b">HStack</code>和<code class="fe mw mx my mz b">VStack</code>，你可能<em class="mt">认为</em>正在创建一个<code class="fe mw mx my mz b">UIStackView</code> …但事实并非如此。在SwiftUI <code class="fe mw mx my mz b">HStack</code>和<code class="fe mw mx my mz b">VStack</code>中，“视图”主要作为布局引擎的指令。它们不是堆栈视图。</p><p id="3ad5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，从一个演示者到一个特定视图的消息传递是不可能的。目标“对象”首先并不是一个真正的对象，演示者不能持有对它的引用，整个方案很快就分崩离析了。</p><p id="93fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有。MVP也不是很合适。</p><p id="6dd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么什么是？</p><h2 id="3e01" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">查看合成</h2><p id="c425" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果有一件事在WWDC的各种SwiftUI会议中反复出现，那就是SwiftUI视图是极其轻量级的，创建它们几乎没有性能损失。</p><p id="1bf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在SwiftUI中，您可以根据应用程序的需要创建尽可能多的独特和特殊用途的视图，这是您的独特优势。</p><p id="d4bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经在SwiftUI合成的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/best-practices-in-swiftui-composition-282b02772a24">最佳实践</a>和SwiftUI的<a class="ae ky" href="https://medium.com/swlh/structural-decomposition-in-swiftui-8892e512b18e" rel="noopener">视图合成</a>中写了很多关于这个概念的文章，所以如果你想知道更多，我建议你把这些文章添加到你的阅读列表中。</p><p id="cd90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这里关键的一点是，如果我们用较小的视图和视图组件构建我们的应用程序，那么我们就不需要像VIPER或MVP这样的解决方案通常会产生的额外的复杂性。</p><h2 id="d8cc" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">测试</h2><p id="030a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">然而，有可能把钟摆摆得太远，并根据目前所说的一切决定我们根本不需要任何<em class="mt">架构。只要把我们所有的代码塞进一堆小视图里，然后就完事了。</em></p><p id="3b1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑以下观点。</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="d6a0" class="lv lw it mz b gy ne nf l ng nh">struct OrderDetailsRowView: View {<br/>    var item: OrderItem<br/>    var body: some View {<br/>        HStack {<br/>            if item.quantity == 1 {<br/>                Text(item.name)<br/>            } else {<br/>                Text("\(item.name) $(\(item.quantity, specifier: "%.2f") @ $\(item.price, specifier: "%.2f")")<br/>            }<br/>            Spacer()<br/>            Text("$(\(item.total, specifier: "%.2f")")<br/>        }<br/>    }<br/>}</span></pre><p id="ead7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是SwiftUI中小型专用视图的一个很好的例子。除了所有的逻辑和格式都被塞进了视图体之外，这也许很棒。</p><p id="9ac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得我们很难编写测试用例来确保这个视图的输出是正确的。</p><h2 id="06c2" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">关注点分离</h2><p id="8172" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">经常提出的主要架构是MVVM(模型-视图-视图模型)。</p><p id="b984" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，它实际上应该写成Model-View Model-View(MVMV ),因为视图模型是应用程序数据(模型)和视图需求(布局)之间的中介。</p><p id="05f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用视图模型时，我们希望将尽可能多的逻辑移出视图，留下非常容易理解的代码。</p><p id="b2b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是关注点分离的一个很好的例子。我们将业务逻辑放在围栏的一边，而将所有视图表示和布局放在另一边。</p><p id="1a5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以用一个例子来更好地说明，所以让我们考虑一个不同的SwiftUI视图，它是我们前面的<code class="fe mw mx my mz b">OrderDetailsRowView</code>视图的父视图:</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="41e1" class="lv lw it mz b gy ne nf l ng nh">struct OrderDetailsView: View {</span><span id="dd05" class="lv lw it mz b gy ni nf l ng nh">  @StateObject var vm = OrderDetailsViewModel()</span><span id="b6d5" class="lv lw it mz b gy ni nf l ng nh">  var body: some View {<br/>     Form {<br/>        if vm.message.hasMessage {<br/>            StatusMessageView(type: vm.message)<br/>        }        </span><span id="748a" class="lv lw it mz b gy ni nf l ng nh">        LabelValueRowView(label: "Order", value: vm.dateValue)<br/>          <br/>        ForEach(vm.items) { item in<br/>            OrderDetailsRowView(item: item)<br/>        }        </span><span id="f868" class="lv lw it mz b gy ni nf l ng nh">        if vm.hasDiscount {<br/>            LabelValueRowView(label: "Subtotal", value: vm.subtotal)<br/>            OrderDetailsDiscountView(value: vm.discount)<br/>        }        </span><span id="33cb" class="lv lw it mz b gy ni nf l ng nh">        LabelValueRowView(label: vml.totalLabel, value: vm.total)        </span><span id="d5ba" class="lv lw it mz b gy ni nf l ng nh">        Button("Order Again") {<br/>            self.vm.reorder()<br/>        }<br/>     }<br/>     .onAppear {<br/>        vm.load()<br/>     }</span><span id="c692" class="lv lw it mz b gy ni nf l ng nh">   }<br/>}</span></pre><p id="79d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，这个视图中的所有东西都是由视图模型驱动的。</p><p id="840f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有条件值和计算值都来自视图模型。有几个<code class="fe mw mx my mz b">if</code>语句控制某些元素的可见性，但是同样，这些<em class="mt">决策</em>背后的逻辑是在模型中制定的。视图只是执行它们。</p><p id="02dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当状态改变时，比方说通过点击“Order Again”按钮，视图再次基于视图模型重新生成</p><p id="d4f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们测试我们的视图模型，如果我们看到期望的输出，如果<em class="mt">我们的视图正确地绑定到我们的视图模型，那么我们可以相当有把握地说我们的屏幕——以及我们的代码——是正确的。</em></p><h2 id="fe12" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">测试专用视图</h2><p id="6dab" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">虽然我个人认为MVVM非常适合SwiftUI，但在某些情况下，甚至<em class="mt"> it </em>也可能有些矫枉过正。<em class="mt">不是每个视图都需要不同的视图模型。</em></p><p id="d7b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以重构原始的细节行视图，如下所示。</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="ab3b" class="lv lw it mz b gy ne nf l ng nh">struct OrderDetailsRowView: View {</span><span id="8eeb" class="lv lw it mz b gy ni nf l ng nh">    var item: OrderItem</span><span id="c08f" class="lv lw it mz b gy ni nf l ng nh">    var body: some View {<br/>        HStack {<br/>            Text(itemDescription)<br/>            Spacer()<br/>            Text(itemTotal)<br/>        }<br/>    }</span><span id="6333" class="lv lw it mz b gy ni nf l ng nh">    var itemDescription: String {<br/>        if item.quantity == 1 {<br/>            return item.name<br/>        } else {<br/>            return "\(item.name) (\(item.formattedQuantity) @ \(item.formattedPrice))"<br/>        }<br/>    }</span><span id="784e" class="lv lw it mz b gy ni nf l ng nh">    var itemTotal: String {<br/>        item.formattedTotal<br/>    }<br/>}</span></pre><p id="b345" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定这个视图体，很容易理解我们显示的是两个数据片段，从业务逻辑的角度来看，没有什么会出错的。</p><p id="7ac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着条件逻辑和格式分解成不同的变量，可以用一个条目实例化视图<em class="mt">本身</em>，用<em class="mt">测试</em>我们的逻辑，看它是否正确，然后用两个条目创建另一个视图并测试它。</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="580c" class="lv lw it mz b gy ne nf l ng nh">func testOrderDetailsRowView() {</span><span id="153d" class="lv lw it mz b gy ni nf l ng nh">    let view1 = OrderDetailsRowView(item: OrderItem.mock1)<br/>    XCTAssert(view1.itemDescription == "Soft Drink")<br/>    XCTAssert(view1.itemTotal == "$1.99")</span><span id="14bc" class="lv lw it mz b gy ni nf l ng nh">    let view2 = OrderDetailsRowView(item: OrderItem.mock2)<br/>    XCTAssert(view2.itemDescription == "Cheeseburger (2 @ $4.99)")<br/>    XCTAssert(view2.itemTotal == "$9.98")</span><span id="f4a5" class="lv lw it mz b gy ni nf l ng nh">}</span></pre><p id="57aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们只需要将尽可能多的逻辑从视图主体的<em class="mt">移出</em>，并将其放入我们可以从视图外部的<em class="mt">看到的变量和函数中。</em></p><p id="07b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为，套用一句军事格言:如果我们能看到它，我们就能测试它。</p><p id="4c4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，如果一个给定的视图开始变得太大，我会开始考虑如何将它分成更小的视图，或者开始将我的条件代码和格式转移到一个专用的视图模型中。</p><p id="3e59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个给定的视图需要处理API请求、处理错误和错误消息、管理空列表等边缘情况，那么我肯定会转向专用的视图模型。</p><p id="7607" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mt">有关使用网络请求逻辑正确设置虚拟机的更多信息，请参见:</em> <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/swiftui-view-models-are-not-protocols-8c415c0325b1"> <em class="mt">在SwiftUI中使用视图模型协议？你做错了。</em> </a></p><h2 id="9262" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">SwiftUI架构的标准</h2><p id="d19e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">总而言之，我选择SwiftUI架构的标准如下…</p><ol class=""><li id="ac4c" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">无论应用程序大小如何，它都必须是高性能的。</li><li id="fbb0" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">它必须与SwiftUI行为和状态管理兼容。</li><li id="401c" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">它应该简洁、轻量、适应性强、灵活。</li><li id="f7eb" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">它鼓励SwiftUI视图合成。</li><li id="33ef" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">它支持测试。</li></ol><p id="18c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，它让SwiftUI成为SwiftUI。</p><h2 id="c220" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">完成块</h2><p id="e998" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">看起来好像是我牵着你的手，带你走上了站在MVVM祭坛前的道路(公平地说，这正是我所做的)。但至少我们现在知道了<em class="mt">为什么</em>我们会在它面前，基于我们所做的选择。</p><p id="9cf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你同意我的标准吗？你自己有吗？同意我的结论还是我错过了什么？不管怎样，我都想知道，所以请在下面的评论区给我留言。</p><pre class="kj kk kl km gt na mz nb nc aw nd bi"><span id="aa38" class="lv lw it mz b gy ne nf l ng nh"><strong class="mz iu">Want more interesting stories?</strong></span><span id="8244" class="lv lw it mz b gy ni nf l ng nh">Feel free to check out the other articles in my <a class="ae ky" href="https://michaellong.medium.com/the-swiftui-series-abc180690a9d" rel="noopener">SwiftUI Series</a>.</span></pre></div></div>    
</body>
</html>