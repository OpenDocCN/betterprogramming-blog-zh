<html>
<head>
<title>How to Make Unit Tests for ViewModel Easier to Write and Maintain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使ViewModel的单元测试更容易编写和维护</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-make-unit-tests-for-viewmodel-easier-to-write-and-maintain-a7efd74cc4db?source=collection_archive---------2-----------------------#2022-07-25">https://betterprogramming.pub/how-to-make-unit-tests-for-viewmodel-easier-to-write-and-maintain-a7efd74cc4db?source=collection_archive---------2-----------------------#2022-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c734" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用干净的代码帮助自己和他人</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/81a1efcbc60e5f1f959fc864b5db0261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_wCh6APtMwVSf8YB"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">托尼·佩佩在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4c54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我是TDD的忠实粉丝。但是我的TDD曾经在我开始为<code class="fe ls lt lu lv b">ViewModel</code>写代码的时候就结束了。我过去常常遭受单元测试变得一团糟的痛苦。我添加到<code class="fe ls lt lu lv b">ViewModel</code>的逻辑越多，我在单元测试中产生的混乱就越多。</p><p id="4ac7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终，我会删除<code class="fe ls lt lu lv b">ViewModel</code>的测试，因为维护和编写新的测试太难了。但是如果没有测试，我过去常常会被我(或者另一个开发者)引入的错误所困扰。</p><p id="c5dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么为什么为<code class="fe ls lt lu lv b">ViewModel</code>编写单元测试很难呢？</p><ul class=""><li id="5805" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><code class="fe ls lt lu lv b">ViewModel</code>一个复杂的屏幕可能由十个或更多的依赖项组成。</li><li id="9cc8" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">每个<code class="fe ls lt lu lv b">ViewModel</code>依赖的类都有一个或多个<code class="fe ls lt lu lv b">ViewModel</code>使用的公共方法。</li><li id="fef9" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">一些公共方法可能返回不同的结果来改变<code class="fe ls lt lu lv b">ViewModel</code>的行为。</li><li id="7c0c" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">有时，我们必须验证一个或多个类的调用序列。例如，它可以是视图的状态，一个视图被显示而另一个被隐藏。此外，我们可能必须验证一个类的一个方法已经被调用，但是另一个方法没有被调用。</li><li id="f0b2" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">在单元测试中重用代码会很棒。</li></ul><p id="1d9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我将所有困难的列表缩小到以下问题:</p><ul class=""><li id="9f5c" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">如何处理<code class="fe ls lt lu lv b">ViewModel</code>状态验证的复杂性？</li><li id="9a81" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">如何处理<code class="fe ls lt lu lv b">ViewModel</code>实例化的复杂性？</li><li id="3c89" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">如何处理与<code class="fe ls lt lu lv b">ViewModel</code> s交互的复杂性？</li></ul><p id="84ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但在我开始回答这些问题之前，我想说几件事:</p><ul class=""><li id="3662" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">这篇文章是关于如何为<code class="fe ls lt lu lv b">ViewModel</code>组织测试来帮助你轻松地维护和编写新的测试。</li><li id="165b" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">我将尽可能保持例子的简单性。解决方案可能看起来像过度工程，但它们在真实项目中大放异彩。在文章的最后，我将展示我正在从事的项目的测试片段。</li></ul><p id="060f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始吧。</p><h1 id="6598" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">例子</h1><p id="e92f" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">让我们考虑简单的加载/内容/错误情况:</p><ul class=""><li id="9680" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">获取数据时会显示加载器状态。</li><li id="f579" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">如果数据加载成功，将显示内容状态。</li><li id="6154" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">如果数据加载有错误，将显示错误状态。</li><li id="9aeb" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">当用户点击重试按钮时，数据被加载并显示。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1b35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们也编写如下所示的单元测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="d805" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">问题1:如何处理ViewModel状态验证的复杂性？</h1><p id="170b" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">可能的解决方案:我发现使用Verifier很有帮助。Verifier是包含验证逻辑的实用程序类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b9e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在重构<code class="fe ls lt lu lv b">SomeViewModelTest</code>之后，看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1b46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是验证器的一些好处:</p><ul class=""><li id="b764" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">它增加了单元测试的可读性。</li><li id="97ef" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">它减少了代码重复。</li><li id="cac9" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">Android Studio可以给出什么可以验证的提示。所以当你写一个新的测试时，很难遗漏一些东西。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/d4089b9d5b368c16aba8d65a15e5acaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*TSEynbPK8fur_2-yMMJ7Dg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对于新的测试或者重构旧的测试特别有用</p></figure><h1 id="acc8" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">问题2:如何处理单元测试中ViewModel实例化的复杂性？</h1><p id="d6f0" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">可能的解决方案:我发现使用<code class="fe ls lt lu lv b">ViewModelBuilder</code>很有帮助。<code class="fe ls lt lu lv b">ViewModelBuilder</code>是一个实用程序类，负责配置<code class="fe ls lt lu lv b">ViewModel</code>来满足我们的需求。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="fa80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嘲讽逻辑被移到了<code class="fe ls lt lu lv b">ViewModelBuilder</code>。给每个方法起一个描述性的名字是很重要的。所以你可以花更少的精力去阅读测试函数的主体。</p><p id="0394" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们重构一下<code class="fe ls lt lu lv b">SomeViewModelTest</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="ee78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是<code class="fe ls lt lu lv b">ViewModelBuilder</code>的好处:</p><ul class=""><li id="3ca5" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">嘲讽逻辑可以在不同的测试中重用。</li><li id="2efb" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">增加单元测试的可读性。视图模型的实例化不会产生混乱。</li><li id="8720" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">Android Studio可以给出什么可以被嘲讽的提示。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/ff3533f2c8155f335937886c01b25033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*EBNDoPxn34tHu6OFTV2MhQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对于新的测试或者重构旧的测试特别有用</p></figure><h1 id="92ac" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">问题3:如何在单元测试中处理与ViewModel交互的复杂性？</h1><p id="905a" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">可能的解决方案:我发现使用<code class="fe ls lt lu lv b">Cases</code>类很有帮助。<code class="fe ls lt lu lv b">Cases</code>类是一个实用程序类，它封装了与<code class="fe ls lt lu lv b">ViewModel</code>的交互逻辑。所以它负责:</p><ul class=""><li id="254d" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">在<code class="fe ls lt lu lv b">ViewModel</code>实例化后模仿依赖关系。</li><li id="bf9e" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">用<code class="fe ls lt lu lv b">ViewModel</code>封装交互逻辑(例如为点击调用公共方法或者为片段或活动调用调用公共方法等)。</li></ul><h2 id="14f5" class="nl ml iq bd mm nm nn dn mq no np dp mu lf nq nr mw lj ns nt my ln nu nv na nw bi translated">有必要上案例课吗？</h2><p id="5402" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">我相信是的。与<code class="fe ls lt lu lv b">ViewModel</code>的交互可能相当复杂。对于新的测试，经常需要以特定的顺序反复调用相同的公共方法<code class="fe ls lt lu lv b">ViewModel</code>。也可能有热的可观察物在随机或特定的时间发出改变<code class="fe ls lt lu lv b">ViewModel</code>行为的事件。</p><h2 id="b122" class="nl ml iq bd mm nm nn dn mq no np dp mu lf nq nr mw lj ns nt my ln nu nv na nw bi translated">例子</h2><p id="2878" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">让我们考虑下面的例子:</p><ol class=""><li id="c29f" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr nx mc md me bi translated"><code class="fe ls lt lu lv b">ViewModel</code>的数据加载错误。</li><li id="d176" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr nx mc md me bi translated">用户点击重试按钮</li><li id="f662" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr nx mc md me bi translated"><code class="fe ls lt lu lv b">ViewModel</code>的数据加载成功并显示。</li></ol><p id="5868" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们编写<code class="fe ls lt lu lv b">Cases</code>类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4338" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="97ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">拥有<code class="fe ls lt lu lv b">Cases</code>级的好处:</p><ul class=""><li id="591c" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">它允许在测试之间重用交互逻辑。</li><li id="8969" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">对<code class="fe ls lt lu lv b">Cases</code>类的方法的显式命名给出了测试中发生的事情的明确想法。所以增加了可读性。</li><li id="b1e2" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">Android Studio给出了可以使用什么case的提示。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/e696209491349e9bc9d403b7d078adee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*smmi-dkHt0JFcoX02I9OWQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对于新的测试或者重构旧的测试特别有用</p></figure><h1 id="3552" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">来自真实项目的例子</h1><p id="2472" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">比较下面两个单元测试。第一个写的很马虎。第二篇是根据这些方法写的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">草率编写的单元测试</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用模式进行单元测试</p></figure><p id="c36e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些只是已经编写的42个单元测试中的两个。</p><p id="c0ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果使用第一种方法编写单元测试，由于可读性差，编写新的单元测试或更改旧的单元测试会很复杂。还有大量的代码重复。</p><p id="83c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二种方法消除了所有这些缺点。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="e93c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>