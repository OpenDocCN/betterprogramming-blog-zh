<html>
<head>
<title>How To Write Reactive Apps in Flutter Using Flutter Bloc</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Flutter Bloc在Flutter中编写反应式应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-reactive-apps-in-flutter-using-multiblocproviders-45e6f2c8598e?source=collection_archive---------7-----------------------#2021-06-22">https://betterprogramming.pub/create-reactive-apps-in-flutter-using-multiblocproviders-45e6f2c8598e?source=collection_archive---------7-----------------------#2021-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8142" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">揭开MultiBlocProviders的神秘面纱，同时在此过程中提供出色的用户体验。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5e12e0d3be8e87de5f2c3735c89401f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N2Z4vVBx99jQGr2T"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">詹姆斯·温斯科特在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="20bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">颤振席卷了整个世界。越来越多的人转向it，越来越多的公司使用它来构建他们的应用程序。迁移背后的原因不是fluth本身，而是过去几年中生态系统的成熟。</p><p id="ecaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你曾经编写过Flutter应用程序，你可能知道一个名为<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/felangel/cubit" rel="noopener ugc nofollow" target="_blank">Cubit</a></code>的库。<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/felangel/cubit" rel="noopener ugc nofollow" target="_blank">Cubit</a></code>是一个帮助实现反应式编程的状态管理库。当构建移动应用时，你需要某种状态管理。否则，你的数据会到处都是。</p><p id="5aa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们今天根本不会谈论<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/felangel/cubit" rel="noopener ugc nofollow" target="_blank">Cubit</a></code>。我们将讨论颤动集团。更具体地说，我们如何使用<code class="fe ls lt lu lv b"><a class="ae kv" href="https://pub.dev/packages/flutter_bloc" rel="noopener ugc nofollow" target="_blank">flutter_bloc</a></code>库在Flutter中实现多块提供者。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="fabe" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">什么是Flutter BLoC？</h1><p id="0688" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><a class="ae kv" href="https://pub.dev/packages/flutter_bloc" rel="noopener ugc nofollow" target="_blank">flutter_bloc</a></code>是一个状态管理库，是前面提到的<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/felangel/cubit" rel="noopener ugc nofollow" target="_blank">Cubit</a></code>库的延续。它提供了一个易于使用的BLoC模式实现。您不再需要从头开始编写自己的流和事件订阅，因为<code class="fe ls lt lu lv b"><a class="ae kv" href="https://pub.dev/packages/flutter_bloc" rel="noopener ugc nofollow" target="_blank">flutter_bloc</a></code>会为您完成所有工作。</p><h2 id="3f24" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lf ng nh mq lj ni nj ms ln nk nl mu nm bi translated">什么是集团模式？</h2><p id="a96e" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">BLoC代表“业务逻辑组件”它是由Flutter开发人员开发的一种模式，用于解决关注点分离问题。在Flutter中，您可以混合前端代码和业务逻辑，这使得创建不可读的意大利面条式代码变得非常容易。此外，干净的颤振代码通常涉及使用缩进，这可能会使您的混乱既长又宽(字面意思！).</p><p id="a573" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开发人员也选择实现BLoC模式，因为它具有固有的反应性。您可以通过创建侦听器来使您的应用程序对BLoC更加敏感。每次收到事件时，每个侦听器都会触发UI重建。本质上，我们将为我们的UI订阅数据流。</p><h2 id="3109" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lf ng nh mq lj ni nj ms ln nk nl mu nm bi translated">什么是BlocProviders？</h2><p id="6049" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">Bloc提供程序初始化bloc并将其提供给其子节点。它是一种类似于<em class="lw"/><em class="lw"/>的注射机构。bloc提供者中的小部件可以从<code class="fe ls lt lu lv b">BuildContext</code>访问bloc，并从那里发出事件。因为构建上下文是传递下来的，所以您可以很容易地访问部件树深处的块提供者。</p><h2 id="acc7" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lf ng nh mq lj ni nj ms ln nk nl mu nm bi translated">多块提供者怎么样？</h2><p id="428e" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">多块提供程序是一个允许初始化多个块实例的小部件。当您需要一次更新多个组件时，您可以在父小部件上初始化一个多块提供者，然后从上下文中获取每个提供者。检索提供者将使您能够向流发送事件，从而更新组件。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="ea5f" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">使用颤振集团的利与弊</h1><p id="ef00" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">尽管<code class="fe ls lt lu lv b"><a class="ae kv" href="https://pub.dev/packages/flutter_bloc" rel="noopener ugc nofollow" target="_blank">flutter_bloc</a></code>似乎是你的应用程序的一个显而易见的选择，你可能要考虑利弊。我做过研究，结合自己和团队使用的经验，我觉得可以给你更广阔的视野。</p><h2 id="02bb" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lf ng nh mq lj ni nj ms ln nk nl mu nm bi translated">优点:简单</h2><p id="73ae" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">使用第三方库的目标显然是简化过程。颤振集团就是这样做的。您不必像在其他情况下那样学习反应式编程概念。产生的代码是可读和可管理的。</p><h2 id="c5ca" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lf ng nh mq lj ni nj ms ln nk nl mu nm bi translated">优点:灵活的状态管理</h2><p id="f2de" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">在我看来，Flutter Bloc对于它所解决的问题类型是非常灵活的。您可以从最小的组件轻松触发状态更改。你所需要的是<code class="fe ls lt lu lv b">BuildContext</code>，你实际上已经准备好了。</p><h2 id="ff57" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lf ng nh mq lj ni nj ms ln nk nl mu nm bi translated">缺点:对于小应用来说太复杂了</h2><p id="40f3" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">尽管这很简单，但我确实认为Flutter Bloc对于小应用来说是大材小用。从使用BLoC模式中获益不多的应用根本不应该实现Flutter Bloc(很明显)。</p><h2 id="36f3" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lf ng nh mq lj ni nj ms ln nk nl mu nm bi translated">缺点:更难的学习曲线</h2><p id="27b0" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">阻塞模式本身是一个很难理解概念，更不用说颤动阻塞了。集团是一个完全不同概念。也许这一点听起来不真诚，因为它证明了集团多于动荡集团。但是，因为需要对BLoC有一个很好的理解，甚至理解正在发生的事情，我认为它仍然需要说。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="e602" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">正在初始化MultiBlocProvider</h1><p id="7ab4" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">首先，您必须在应用程序启动时初始化多块提供程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者的代码片段</p></figure><p id="f10a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">直觉上很简单。你只需要在做任何事情之前初始化<code class="fe ls lt lu lv b">runApp</code>函数中的<code class="fe ls lt lu lv b">MultiBlocProvider</code>。然后在里面创建你想要初始化的<code class="fe ls lt lu lv b">BlocProviders</code>。</p><p id="3c8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不用担心<code class="fe ls lt lu lv b">BlocProvider</code>在组件初始化之前被调用。<a class="ae kv" href="https://pub.dev/documentation/flutter_bloc/latest/flutter_bloc/BlocProvider/lazy.html" rel="noopener ugc nofollow" target="_blank">因为</a> <code class="fe ls lt lu lv b"><a class="ae kv" href="https://pub.dev/documentation/flutter_bloc/latest/flutter_bloc/BlocProvider/lazy.html" rel="noopener ugc nofollow" target="_blank">BlocProvider</a></code> <a class="ae kv" href="https://pub.dev/documentation/flutter_bloc/latest/flutter_bloc/BlocProvider/lazy.html" rel="noopener ugc nofollow" target="_blank">默认是懒惰的</a>，所以只有当第一个请求bloc的事件被调用时才会调用。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="c8ad" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">从上下文调用BlocProvider</h1><p id="dca6" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">现在每当你需要调用一个事件时，你只需要从块内部访问上下文。只要小部件的父部件被包装在一个<code class="fe ls lt lu lv b">MultiBlocProvider</code>中，您就可以通过这种方式安全地访问这个块:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="5ed4" class="nb mf iq lv b gy nt nu l nv nw">BlocProvider.of&lt;ProductBloc&gt;(context)</span></pre><p id="25d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这种方式可以访问<code class="fe ls lt lu lv b">ProductBloc</code>或<code class="fe ls lt lu lv b">SessionBloc</code>。将事件添加到流中后，侦听器将在接收到其预期状态后更新UI。为此，您可以利用<code class="fe ls lt lu lv b">BlocBuilder</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者的代码片段</p></figure><p id="8906" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以把它添加到你应用的任何地方，它会自动重建。只要确保你没有在其中重新启动同一个块的<code class="fe ls lt lu lv b">BlocBuilder</code>。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="8d23" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">为什么我们需要多集团提供商？</h1><p id="ebdd" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">我们需要多块提供者来解决与同时更新具有不同状态的多个组件相关的问题。我知道这听起来非常接近使用多集团提供商的基本前提，我在重复我自己。但是听我说完。</p><p id="4ce4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个很好的例子是一个移动市场应用程序，您需要在搜索产品的同时获取购物车中的产品。因为有两个不同的事件，所以需要有两个块提供者。</p><p id="5bc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等等，有没有可能把它们都合并到一个事件状态里？是的，但是每次你添加一个商品到你的购物车时，你都必须得到产品。该集团将失去其原子性。</p><p id="8526" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你也不能连续调用两个返回不同状态的事件。例如:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="84a9" class="nb mf iq lv b gy nt nu l nv nw">BlocProvider.of&lt;ProductBloc&gt;(context)<br/>  ..add(GetProduct())<br/>  ..add(GetCart())</span></pre><p id="3a2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以在产品块上添加一个<code class="fe ls lt lu lv b">Cart</code>事件，并在检索产品后调用它。但是因为在<code class="fe ls lt lu lv b">GetProduct</code>之后调用了另一个事件，所以先前加载产品数据的监听器也被触发，状态发生变化。</p><p id="28f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决这个问题同时仍然获得我们需要的原子性的一种方法是通过创建多个块并连续调用:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="2c1f" class="nb mf iq lv b gy nt nu l nv nw">BlocProvider.of&lt;ProductBloc&gt;(context)<br/>  ..add(GetProduct())</span><span id="8d3b" class="nb mf iq lv b gy nx nu l nv nw">BlocProvider.of&lt;CartBloc&gt;(context)<br/>  ..add(GetCart())</span></pre><p id="0736" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们可以将<code class="fe ls lt lu lv b">ProductBloc</code>和<code class="fe ls lt lu lv b">CartBloc</code>的<code class="fe ls lt lu lv b">BlocBuilder</code>分离成不同的组件。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="7e54" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">最后的话</h1><p id="6beb" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">创建反应式应用从来都不容易。但是有了Flutter和BLoC，完全可以有一个流畅的反应式app。你不需要担心你的组件在应该更新的时候没有更新，你可以提高你的应用程序的UX质量。没有什么比反应式应用程序更能说明UX的优秀了。</p><p id="962c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终，用户体验是关键。出色的用户体验自然会带来更多的用户参与。赢得用户不仅要营销你的产品，还要给他们能想象到的最好的体验。</p></div></div>    
</body>
</html>