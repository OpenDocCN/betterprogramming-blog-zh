<html>
<head>
<title>Implementing MVVM With RxSwift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RxSwift实施MVVM</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ios-mvvm-with-rxswift-part-1-ff9f8102a3c9?source=collection_archive---------8-----------------------#2020-03-12">https://betterprogramming.pub/ios-mvvm-with-rxswift-part-1-ff9f8102a3c9?source=collection_archive---------8-----------------------#2020-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8295" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">架构设计和实现</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2ba539f5ed1e79645dfb18e802adcae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*blGsegHF1QCp_XUEpOllsA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Rx +苹果</p></figure><h1 id="471c" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">介绍</h1><p id="018c" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">大家好。这一系列文章将是关于我最喜欢的两项技术，<a class="ae mj" href="https://github.com/ReactiveX/RxSwift" rel="noopener ugc nofollow" target="_blank"> RxSwift </a>和MVVM。</p><p id="4de8" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我从2015年开始使用Rx，并在过去一年中与MVVM一起在一个拥有超过80，000名用户的生产应用程序中广泛使用，分享我获得的知识是正确的。</p><p id="110b" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">首先，第一部分的内容是:</p><ul class=""><li id="007e" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi mu mv mw mx bi translated">建筑模式介绍。</li><li id="b74a" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">MVC、MVVM和主要区别。</li><li id="9d24" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">MVVM与纯雨燕的例子。</li><li id="82c6" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">同样的例子还有MVVM、RxSwift和<a class="ae mj" href="https://github.com/ReactiveX/RxSwift/tree/master/RxCocoa" rel="noopener ugc nofollow" target="_blank"> RxCocoa </a>。</li></ul></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="38b2" class="kv kw iq bd kx ky nk la lb lc nl le lf jw nm jx lh jz nn ka lj kc no kd ll lm bi translated">建筑模式</h1><p id="f7b6" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">正如我们所知，从软件的早期开始，我们就可以识别出作为开发人员所面临的问题中的一些模式，并且似乎有一些解决这些问题的方案比其他方案更合适。</p><p id="6499" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">随着软件技术的发展，这些解决方案采取了一种事实上的方式来解决特定的问题，因此被称为<em class="np">架构模式</em>。</p><p id="4ab9" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">现在，大多数软件框架在它们的堆栈中包含了这些模式，即使你从未听说过它们，你也一直在使用它们。一个简单的例子是<a class="ae mj" href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank"> Django </a>和许多其他web框架已经采用MVC作为它们的架构模式。</p><p id="5008" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">但是，什么是架构模式呢？</p><blockquote class="nq"><p id="fa50" class="nr ns iq bd nt nu nv nw nx ny nz mi dk translated">“一个<strong class="ak">架构模式</strong>是一个<strong class="ak">通用</strong>，<strong class="ak">可重用</strong>，<strong class="ak">解决方案</strong>，用于解决给定<strong class="ak">上下文</strong>中软件架构中<strong class="ak">常见的问题</strong>。”—维基百科</p></blockquote><p id="117a" class="pw-post-body-paragraph ln lo iq lp b lq oa jr ls lt ob ju lv lw oc ly lz ma od mc md me oe mg mh mi ij bi translated">让我们来分解这个定义中突出显示的部分。</p><h2 id="9c3f" class="of kw iq bd kx og oh dn lb oi oj dp lf lw ok ol lh ma om on lj me oo op ll oq bi translated"><strong class="ak">通用且可重复使用</strong></h2><ul class=""><li id="2530" class="mp mq iq lp b lq lr lt lu lw or ma os me ot mi mu mv mw mx bi translated">意味着架构模式应该是<em class="np">平台和语言</em>不可知的。相同的模式可以用于不同的软件框架。如果我们每次转换环境都需要发明一种新的模式，那就没什么意义了。</li><li id="9da7" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">此外，我们应该能够在任何类型的软件或系统中使用模式，从命令行界面、web应用程序、由多个子系统组成的复杂航空电子软件、<strong class="lp ir"> </strong>等等。一个很好的架构模式的例子是<a class="ae mj" href="https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html" rel="noopener ugc nofollow" target="_blank">分层模式或分层架构</a>，这种模式很容易适应前面提到的所有项目结构。通过使用这种架构模式，您可以在一个层的基础上实现关注点的分离，而不必受限于任何特定的技术、编程语言或项目类型。</li></ul><h2 id="3ae3" class="of kw iq bd kx og oh dn lb oi oj dp lf lw ok ol lh ma om on lj me oo op ll oq bi translated"><strong class="ak">语境</strong></h2><p id="156d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">意味着问题的本质。</p><p id="c031" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">如果你想在一个系统的不同部分甚至不同系统之间进行相互通信，那么你的问题的上下文或<em class="np">域</em>就是通信和数据交换，因此，你必须寻找一种模式来解决这个问题，例如<a class="ae mj" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" rel="noopener ugc nofollow" target="_blank">发布-订阅模式</a>。</p><h2 id="59d2" class="of kw iq bd kx og oh dn lb oi oj dp lf lw ok ol lh ma om on lj me oo op ll oq bi translated">结论</h2><p id="dc1e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">总之，我认为架构模式是解决问题的良方。就像一份烹饪食谱一样，在实现过程中，有空间进行微小的修改，以更好地适应您的编程风格、框架、语言等。</p><p id="aa13" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">但是你必须小心，引入太多的修改，你最终会得到一个新的“模式”,尽管它适合你当前的项目，但可能不像需要的那样通用，也不太适合你的下一个项目。</p><p id="974d" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">永远记住模式的定义，它应该是通用的和可重用的。</p><p id="85cf" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我不是想阻止你定制图案。除此之外，我们已经看到了这样的定制或者以一种好的方式对原始模式的增强，最终作为后继者留下来。考虑MVVM协调器(我们将在本系列的后面讨论它)作为这样一个例子。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="367b" class="kv kw iq bd kx ky nk la lb lc nl le lf jw nm jx lh jz nn ka lj kc no kd ll lm bi translated">UI架构模式</h1><p id="13f8" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在软件工程的早期，计算机程序是由穿孔卡来表示的，穿孔卡中既有程序，也有运行程序的数据。</p><p id="c873" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">随着计算机的发展，输入和输出设备也在发展。如今，我们有各种各样的输出设备，从小型移动显示器到虚拟现实耳机。</p><p id="c2fb" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">前端软件开发(包括移动应用)的典型过程是加载一些数据，将其呈现给最终用户，并处理用户输入。</p><p id="1d4a" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这是一个乏味的任务，我们将在整个应用程序中的许多场合做，因此需要用一些严格的规则来构造它。</p><p id="56a3" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这种结构将帮助我们在类之间分配职责，这意味着任何工程师都能够回答:“哪个类负责给定的任务？”对于任何给定的屏幕，即使我们之前没有看到这段代码。</p><p id="7980" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">如下，代码将更容易理解，也更容易维护。</p><h2 id="ef29" class="of kw iq bd kx og oh dn lb oi oj dp lf lw ok ol lh ma om on lj me oo op ll oq bi translated">模型-视图-控制器</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/1342ea88eb0edfe7d32ff8cb19d074b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*la8KCs0AKSzVGShoLQo2oQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">苹果的MVC</p></figure><p id="020f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">也被称为Massive-View-Controller，它受到了苹果公司的青睐，并在一定程度上内置于iOS中。</p><p id="af32" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">当我们为一个应用程序添加一个新的屏幕时，一个名为<code class="fe ov ow ox oy b">ViewController</code>的新文件及其伴随的<code class="fe ov ow ox oy b">.xib</code>就会生成——除非你使用故事板，在这种情况下，故事板将包含界面定义。</p><p id="68ee" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">MVC将关注点分成三组类。</p><ul class=""><li id="2d0e" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi mu mv mw mx bi translated">模型-将存储您的数据的模型。</li><li id="d715" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">查看— <code class="fe ov ow ox oy b">.xib</code>或<code class="fe ov ow ox oy b">.storyboard</code>文件。</li><li id="0a83" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">控制器——模型和视图之间的中介，负责加载和呈现数据以及处理用户输入。</li></ul><p id="5973" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">虽然它在应用程序不太复杂的早期就发挥了作用，但现在已经有一段时间了，所以我们可以肯定它是不可扩展的。</p><p id="b4ed" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">随着应用程序的增长，根据应用程序的复杂程度，最终视图控制器可能会有数千行代码。</p><p id="c1dc" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">此外，由于您的代码驻留在<code class="fe ov ow ox oy b">ViewController</code>中，很难进行单元测试。</p><h2 id="3c8c" class="of kw iq bd kx og oh dn lb oi oj dp lf lw ok ol lh ma om on lj me oo op ll oq bi translated">模型-视图-视图模型</h2><p id="7184" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">MVVM把对象分成三组，就像MVC一样。这些组如下:</p><ul class=""><li id="d4d2" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi mu mv mw mx bi translated">模型——在MVC中，模型将存储您的数据。</li><li id="f7b9" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">视图-视图控制器和XIB。</li><li id="5611" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">ViewModel——在<code class="fe ov ow ox oy b">View</code>和<code class="fe ov ow ox oy b">Model</code>之间的<em class="np">中介</em>。</li></ul><p id="8381" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">查看这些类类型，我们清楚地看到<code class="fe ov ow ox oy b">View</code>不再仅仅是一个XIB，而是<code class="fe ov ow ox oy b">ViewController</code>和伴随的XIB文件的组合。这听起来好多了。</p><p id="84b1" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">然而，MVVM让它如此不同的关键因素是<code class="fe ov ow ox oy b">ViewModel</code>对<code class="fe ov ow ox oy b">View</code>一无所知。相反，<code class="fe ov ow ox oy b">View</code>观察<code class="fe ov ow ox oy b">ViewModel</code>数据的变化并自我更新。</p><p id="e30d" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这种观察是通过KVO、通知甚至关闭来实现的。我发现这三个都很不方便，因为你必须写很多样板文件。让我们看一个相当简单的闭包例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oz pa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ViewModel.swift</p></figure><p id="a4cc" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我知道！38行代码，用于拥有一个计数器并能够递增它。如果您想拥有可维护和可伸缩的代码，这是您必须承受的负担。你不能跳过样板部分。</p><p id="81e3" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">但是也有一个好处。我们可以很容易地对我们的<code class="fe ov ow ox oy b">ViewModel</code>进行单元测试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="b249" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">最后，查看这里充当视图的<code class="fe ov ow ox oy b">ViewController</code>，我们看到它负责绑定到<code class="fe ov ow ox oy b">ViewModel</code>属性变更。</p><p id="1a3f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我一直在说视图约束或观察了<code class="fe ov ow ox oy b">ViewModel</code>，但是我还没有解释为什么这是MVVM如此重要的一部分。这种观察模式以这样一种方式解耦了我们的代码，即<code class="fe ov ow ox oy b">ViewModel</code>不是你的应用程序中任何特定屏幕的一部分。</p><p id="424f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">相反，例如，当你想在列表中显示电影时，可以单独使用加载电影的<code class="fe ov ow ox oy b">ViewModel</code>，或者当你想通过加载电视节目的<code class="fe ov ow ox oy b">ViewModel</code>在iPad屏幕上显示电影时，可以与其他<code class="fe ov ow ox oy b">ViewModel</code>结合使用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oz pa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">视图控制器</p></figure><p id="017f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">总而言之，很明显，MVVM通过在类之间分配责任来帮助我们编写干净的代码。<code class="fe ov ow ox oy b">ViewModel</code>负责数据准备，而<code class="fe ov ow ox oy b">View</code>负责展示。此外，我们还可以轻松地对我们的功能进行单元测试。</p><p id="c062" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">MVVM的缺点是我们需要编写额外的代码来将<code class="fe ov ow ox oy b">View</code>类粘合到<code class="fe ov ow ox oy b">ViewModel</code>。对于我们需要存储的每个变量，我们必须声明一个闭包。</p><p id="b00c" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">也许如果我们使用KVO或通知，我们可以跳过这一部分，但仍然，我们必须写一些代码来观察变化，然后更新用户界面。老实说，样板代码对所有架构模式都是必要的，不管你是做MVP还是VIPER。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="835d" class="kv kw iq bd kx ky nk la lb lc nl le lf jw nm jx lh jz nn ka lj kc no kd ll lm bi translated">采用RxSwift的MVVM—消除样板文件</h1><p id="d657" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">通过利用RxSwift的功能，我们可以摆脱这种样板文件。Rx提供胶水。</p><h2 id="2ff9" class="of kw iq bd kx og oh dn lb oi oj dp lf lw ok ol lh ma om on lj me oo op ll oq bi translated">Rx是什么？RxSwift？</h2><blockquote class="nq"><p id="bd9d" class="nr ns iq bd nt nu nv nw nx ny nz mi dk translated">" Rx是一个用于<strong class="ak">异步编程</strong>和<strong class="ak">可观察</strong> <strong class="ak">流</strong>的API。"—<a class="ae mj" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">react vex . io</a></p></blockquote><figure class="pc pd pe pf pg kk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/bfd406023eb5136ef7046a759349d237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*pUwd-zd-p-nsgncT9VtVxw.png"/></div></figure><p id="417a" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">Rx是一组严格定义的规范，而不是具体的实现。另一方面，RxSwift是这种编程范式的实现<em class="np">，它尊重这种语言的习惯用法</em>。</p><p id="9ed5" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在Rx世界中，反应模式是由<code class="fe ov ow ox oy b">Observable</code> ( <code class="fe ov ow ox oy b"><a class="ae mj" href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md#rxswift-traits" rel="noopener ugc nofollow" target="_blank">Single</a></code> <a class="ae mj" href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md#rxswift-traits" rel="noopener ugc nofollow" target="_blank">、</a> <code class="fe ov ow ox oy b"><a class="ae mj" href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md#rxswift-traits" rel="noopener ugc nofollow" target="_blank">Completable</a></code> <a class="ae mj" href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md#rxswift-traits" rel="noopener ugc nofollow" target="_blank">、</a> <code class="fe ov ow ox oy b"><a class="ae mj" href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md#rxswift-traits" rel="noopener ugc nofollow" target="_blank">Maybe</a></code> <a class="ae mj" href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md#rxswift-traits" rel="noopener ugc nofollow" target="_blank">是<code class="fe ov ow ox oy b">Observable</code>的特质</a>——或变体)实现的。</p><p id="1991" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">Observable为各种观察者提供了订阅的方法，以及处理异步操作的方式，例如读取文件内容、从网络获取数据，甚至进行一些繁重的计算都可能是这样的异步操作。</p><p id="19e3" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">此外，还有一些操作符可用于过滤、转换和合并您的流。</p><p id="1b2e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">事实上，Rx太棒了，苹果已经编写了自己的框架，<a class="ae mj" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank"> Combine </a>，作为基于数据流和发布/订阅模式的iOS 13的一部分。</p><p id="db39" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">Combine和Rx的概念非常相似，Combine目前在功能性方面落后，但我想这是公平的。罗马不是一天建成的，Rx在五年前，也就是2015年4月首次发布。</p><h2 id="af3f" class="of kw iq bd kx og oh dn lb oi oj dp lf lw ok ol lh ma om on lj me oo op ll oq bi translated">RxCocoa</h2><p id="a248" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">RxCocoa引入了一组新的特征，<code class="fe ov ow ox oy b"><a class="ae mj" href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md#rxcocoa-traits" rel="noopener ugc nofollow" target="_blank">Driver</a></code> <a class="ae mj" href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md#rxcocoa-traits" rel="noopener ugc nofollow" target="_blank">，</a> <code class="fe ov ow ox oy b"><a class="ae mj" href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md#rxcocoa-traits" rel="noopener ugc nofollow" target="_blank">Signal</a></code> <a class="ae mj" href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md#rxcocoa-traits" rel="noopener ugc nofollow" target="_blank">，</a> <code class="fe ov ow ox oy b"><a class="ae mj" href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md#rxcocoa-traits" rel="noopener ugc nofollow" target="_blank">ControlEvent</a></code> <a class="ae mj" href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md#rxcocoa-traits" rel="noopener ugc nofollow" target="_blank">，</a> <code class="fe ov ow ox oy b"><a class="ae mj" href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md#rxcocoa-traits" rel="noopener ugc nofollow" target="_blank">ControlProperty</a></code>来缓解处理异步操作和UI更新的问题。</p><p id="4704" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">简单来说，如果你开始写Rx，<code class="fe ov ow ox oy b">DispatchQueue.main.async {}</code>很快就会被弃用。</p><p id="a13f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">最重要的是，RxCocoa通过<code class="fe ov ow ox oy b">rx</code>代理为<code class="fe ov ow ox oy b">UIView</code>的公共属性(如<code class="fe ov ow ox oy b">isHidden</code>和<code class="fe ov ow ox oy b">alpha</code>)提供绑定，甚至为一些更具体的属性(如<code class="fe ov ow ox oy b">UILabel</code>的<code class="fe ov ow ox oy b">text</code>和<code class="fe ov ow ox oy b">attributedText</code>)提供绑定。</p><p id="5229" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">就像这样，你现在可以将一个字符串的可观察对象绑定到一个标签的文本上，当可观察对象发出新的值时，标签的文本也会改变。</p><p id="9091" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">让我们看看第一个例子中的视图控制器是什么样子的，用Rx重写。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oz pa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">RxViewModel</p></figure><p id="a141" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我告诉过你，样板文件是你无法摆脱的，但你肯定可以消除它。在我的MVVM实现中，我决定将<code class="fe ov ow ox oy b">ViewModel</code>的输入和输出分成两个结构。</p><p id="ebe9" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在输入中，我们声明了一个名为<code class="fe ov ow ox oy b">PublishRelay</code>的新变量。Out按钮将触发该继电器，进而触发<code class="fe ov ow ox oy b">scan</code>。但是什么是<code class="fe ov ow ox oy b">scan</code>？Scan是一个类似于<code class="fe ov ow ox oy b">reduce</code>的运算符。</p><p id="f62b" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">给定一个种子和一个累加器，函数将在每个项目上触发函数。区别它们的细节是,<code class="fe ov ow ox oy b">scan</code>将在每次触发时发出结果，而<code class="fe ov ow ox oy b">reduce</code>将在给定的可观察结果完成时发出。</p><p id="e9f2" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">瞧，这是我们的视图控制器的代码。我们所要做的就是将按钮点击绑定到<code class="fe ov ow ox oy b">PublishRelay</code>输入，将输出绑定到标签的文本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oz pa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">视图控制器</p></figure><p id="0ad8" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">感谢您花时间阅读这篇文章，我期待在下面的评论区看到您的想法。</p><p id="a611" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">敬请关注，在本系列的下一部分中，我们将讨论网络，进行一些适当的错误处理，并且我将向您展示当连接恢复时，如何从无网络错误中恢复。</p></div></div>    
</body>
</html>