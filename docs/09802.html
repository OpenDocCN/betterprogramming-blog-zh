<html>
<head>
<title>6 Principles To Write Better Modules for Your iOS Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为你的iOS应用程序编写更好的模块的6个原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-principles-to-write-better-modules-for-your-ios-applications-3257c26e5df2?source=collection_archive---------1-----------------------#2021-10-13">https://betterprogramming.pub/6-principles-to-write-better-modules-for-your-ios-applications-3257c26e5df2?source=collection_archive---------1-----------------------#2021-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="14bb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在编写你的模块和库的时候要记住什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/04f5993bf75cd02dfe67b4c8a87b1d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FcEZ5kspHo5jnDYF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kaleidico?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">万花筒</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="588c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢的一项任务是编写库和模块来加速我的同事。</p><p id="0c34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最有收获的时刻之一发生在一个同事来感谢我，因为我正在开发的一个库帮他节省了将近一周的时间。</p><p id="4c1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天我想分享我在应用程序中实现库或模块时通常遵循的五个原则。</p><h1 id="7128" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.限制API表面</h1><p id="7d1d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">API表面是模块向外部世界公开的部分。它也被称为<code class="fe ms mt mu mv b">public</code>接口。</p><p id="8b38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个表面应该尽可能小。这让我们在未来的变化中更加灵活。这似乎违反直觉:如果我们公开一些函数和类型，我们怎么会不够灵活呢？</p><p id="4d43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不知道有多少客户会使用我们的图书馆。如果我们只暴露几个元素，我们肯定知道他们正在使用它们。另一方面，我们提供的元素越多，我们对客户如何使用我们的模块的了解就越少。</p><p id="8344" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，删除一个特性总是一个突破性的改变，因为依赖该特性的客户端将停止工作。相反，添加一个新特性永远不会中断:如果我们添加一个新特性，我们不会冒中断客户端的风险。从小处着手，我们可以更灵活地添加具有不同参数或新行为的新方法。</p><p id="590e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大型API表面的另一个问题是成本更高:表面需要维护。还有，表面越高，出现bug的概率越高。而且修复bug很贵。</p><h2 id="2a0d" class="mw lw it bd lx mx my dn mb mz na dp mf li nb nc mh lm nd ne mj lq nf ng ml nh bi translated">推论:只提供一种执行操作的方法</h2><p id="f846" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有时，提供不同的方法来执行相同的操作可能很有诱惑力。典型的例子是接受特定类型并为其他类型重载的方法。</p><p id="7b0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然用两种不同的方式提供相同的功能看起来很容易，但最好选择一种方式并坚持下去。用不同的方法执行相同的操作有很多缺点:</p><ol class=""><li id="ca0b" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">这给客户带来了困惑。他们应该使用哪种替代方案？</li><li id="159b" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">它可能会引入需要修复的错误。</li><li id="4fea" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">它引入了双重标准。下次我们必须实现一个特性时，我们会花时间决定如何实现它。另外，它使工作量加倍。</li></ol><p id="2fbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写小包装器将一个域映射到另一个域通常很容易。如果客户端使用的是不同的范例，它总是可以围绕库编写一个小的包装器。</p><p id="6968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">围绕库编写包装器的一个积极的副作用是，客户端的应用程序变得与我们的库分离。如果他们需要把我们的库换成另一个库(或者如果我们发布了我们库的一个新的主要版本)，这是一件好事。</p><h1 id="bb1d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.尊重语义版本</h1><p id="5d25" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本化</a>是业界用来注释SDK特定版本的标准。它基于三个数字，用点分隔:M.m.p。</p><ol class=""><li id="b522" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">第一个数字— <strong class="lb iu"> M </strong> —表示库的<strong class="lb iu">主</strong>版本。</li><li id="4ab4" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">第二个数字—<strong class="lb iu">m</strong>—表示库的<strong class="lb iu">次要</strong>版本。</li><li id="2476" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">第三个数字— <strong class="lb iu"> p </strong> —表示库的<strong class="lb iu">补丁</strong>版本。</li></ol><p id="a62b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些数字包含了新版本库的意义和期望。</p><ul class=""><li id="33e8" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nw no np nq bi translated">补丁发布必须对我们库的客户尽可能透明。他们应该能够引入库的最新补丁，而不改变他们的代码库。补丁发布通常是错误修复和内部细节的变化，不会影响系统的行为。</li><li id="3317" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nw no np nq bi translated">较小的版本包括附加的变化和新特性。在这种情况下，模块的客户端应该能够将库的最新版本带入他们的代码库中，而无需更改任何一行代码。</li><li id="4f96" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nw no np nq bi translated">主要的变化包括方法签名的变化和系统行为的重大变化。他们正在突破变革。当将库更新到主要版本时，客户希望在他们的代码库中执行一些更改。</li></ul><p id="a55a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最好尽量减少破坏性的变化。我们不希望客户不得不为我们模块的每个版本更新代码库。</p><p id="ac56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，记住要写清楚变更日志和迁移指南，尤其是在发布主要版本的时候。这将使库的采用更加容易。</p><h1 id="1cdb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.提供信息错误</h1><p id="3379" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设我们需要使用库中定义的类型。此类型有一个失败的初始值设定项。你更喜欢哪种选择:失败时返回<code class="fe ms mt mu mv b">nil</code>的<code class="fe ms mt mu mv b">init</code>还是抛出错误告诉你失败原因的<code class="fe ms mt mu mv b">init</code>？</p><p id="627e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有什么比试图创建一个对象并收到一个<code class="fe ms mt mu mv b">nil</code>值，却不知道为什么会这样更令人沮丧的了。以下示例显示了两种方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4d47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们可以看到失败的初始化器(它没有给出任何信息)和抛出的初始化器。从客户端的角度来看，错误提供了更多的信息和从错误中恢复的可能性，最终会要求用户进行不同的输入。</p><h2 id="0ba2" class="mw lw it bd lx mx my dn mb mz na dp mf li nb nc mh lm nd ne mj lq nf ng ml nh bi translated">推论:绝不崩溃</h2><p id="a922" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">作为推论，内部模块永远不应该故意崩溃。是的，有些情况在结构上是无法获得的，我们可能会尝试使用bang <code class="fe ms mt mu mv b">!</code>或<code class="fe ms mt mu mv b">fatalError</code>来简化我们的代码。</p><p id="d98e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">建议避免这些解决方案，至少有两个原因:</p><ol class=""><li id="434e" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">没有什么比看到你的应用崩溃，并发现这是由于第三方库发生更令人沮丧的了。</li><li id="7ea1" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">它们使你的代码更难测试。不可能用<code class="fe ms mt mu mv b">fatalError</code>干净地测试一个代码分支。</li></ol><p id="e7c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很难用<code class="fe ms mt mu mv b">fatalError</code> s测试函数有一个非常具体的原因。<code class="fe ms mt mu mv b">fatalError</code>签名如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="8ab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它返回一个叫做<code class="fe ms mt mu mv b">Never</code>的特殊类型。这个签名告诉编译器这个函数永远不会终止。测试一个永不返回的函数的唯一方法是在一个无限循环中阻塞它的执行。每次你需要测试一个<code class="fe ms mt mu mv b">fatalError</code>的时候，你的测试总会有一个挂起的线程。如果有许多致命错误，测试套件可能永远不会终止，因为它耗尽了线程来执行一些剩余的测试。</p><h1 id="e170" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4.永远尊重客户的应用程序</h1><p id="e829" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在某些情况下，我们需要处理由客户端应用程序创建和管理的组件。对于功能模块和提供一些UI的库来说，尤其如此。</p><p id="fe0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个典型的例子可能是一个支付库，它提供不同的屏幕来设置支付，或者是一个onboarding模块，它要求用户提供一些信息。在这两种情况下，它们都可以向应用程序请求一个<code class="fe ms mt mu mv b">NavigationController</code>，用于从库中推送一些<code class="fe ms mt mu mv b">ViewController</code>。</p><p id="142a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该始终注意这些类型，避免设置自己的委托。如果我们盲目设置它们，我们就有替换应用程序安装的那些的风险。</p><p id="4ced" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个可能的解决方案是创建一个包装委托，这样可以保存原始委托并将事件转发给它。在解除或卸载SDK时，我们应该将委托重置为初始值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="22ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们可以看到如何包装一个<code class="fe ms mt mu mv b">UINavigationControllerDelegate</code>。</p><p id="2041" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要几个属性来跟踪<code class="fe ms mt mu mv b">navigationController</code>和<code class="fe ms mt mu mv b">appDelegate</code>。这些应该是<code class="fe ms mt mu mv b">weak</code>以避免引用循环。在属性中存储这些对象后，我们可以安全地更改<code class="fe ms mt mu mv b">delegate</code>。</p><p id="e044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当要解散SDK时，必须调用<code class="fe ms mt mu mv b">unload</code>方法。在该方法中，我们只是用之前保存的委托替换当前的委托。</p><p id="4f75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在委托的方法中，我们:</p><ol class=""><li id="471b" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">检查我们是否真的必须在SDK中执行一些操作。</li><li id="0439" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">如果没有，我们调用最初的<code class="fe ms mt mu mv b">appDelegate</code>方法，让应用程序表现得好像SDK不存在一样。</li></ol><h1 id="6fdc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">5.始终验证输入</h1><p id="61f2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们应该始终验证从应用程序接收到的输入。例如，如果我们的SDK需要财政代码或信用卡号，我们应该检查应用程序是否传递了有效的类型。</p><p id="9e28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最喜欢的确保这一点的方法是使用定义良好的类型，比如<code class="fe ms mt mu mv b">CreditCardNumber</code>，它在<code class="fe ms mt mu mv b">init</code>中包含一些验证，如果出错，抛出一个信息性错误，遵循原则三。</p><p id="3545" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不仅确保了我们在编译时使用有效的类型，还减少了一种叫做<a class="ae ky" href="https://refactoring.guru/smells/primitive-obsession" rel="noopener ugc nofollow" target="_blank">原语困扰</a>的代码味道:当我们为特定领域的实体使用原语类型时。<code class="fe ms mt mu mv b">CreditCardNumber</code>就是一个很好的例子；我们可以使用正确的类型，而不是使用简单的<code class="fe ms mt mu mv b">String</code>来保证信用卡的结构，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="ae94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这种类型，我们在初始化器中执行所有的验证步骤。如果出现问题，应用程序可以很容易地恢复，这要感谢类型抛出的明确错误。如果值是有效的，我们不必在代码库中执行任何其他验证。</p><p id="6676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法还有另外两个优点:</p><ol class=""><li id="2bcc" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">它将所有的验证推到流程的开始，允许我们快速失败并避免任何无用的计算。</li><li id="cd3f" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">它防止将值用于其他目的。例如，如果我们只使用字符串，我们可能最终会使用信用卡值而不是会话id。</li></ol><h1 id="e533" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">6.编写清晰简洁的文档</h1><p id="910d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">编写文档可能看起来像是无意义的成本；它不会立即做任何事情，并且可能会与代码不同步。</p><p id="fffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，作为开发人员，当出现问题时，这是我们首先要检查的。当我们不得不使用文档不清晰的框架时，我们通常会抱怨。</p><p id="8832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">良好的文档包括:</p><ul class=""><li id="5c37" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nw no np nq bi translated">一个方法能做什么。</li><li id="88e2" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nw no np nq bi translated">它的参数是什么。</li><li id="a3aa" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nw no np nq bi translated">它返回的内容。</li><li id="f0e0" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nw no np nq bi translated">它会抛出什么错误以及何时抛出。</li><li id="d83f" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nw no np nq bi translated">任何对客户有用的具体细节:例如，它的复杂性。</li></ul><h1 id="95ae" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="21aa" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在今天的文章中，我们探讨了在代码库中开发库和特性模块时应该遵循的一些原则。总结一下:</p><ol class=""><li id="d1e5" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">限制API的表面——只提供一种执行操作的方式。</li><li id="aebf" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">尊重语义版本。</li><li id="8451" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">提供信息性错误——永不崩溃。</li><li id="cb87" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">永远尊重客户端的app。</li><li id="ca94" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">验证输入。</li><li id="efd2" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">编写有意义的文档。</li></ol><p id="49c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们遵循这些原则，我们会交付高质量的模块，这不会让我们的客户感到惊讶。当一个bug出现时，一个快乐的客户也会更加宽容。</p><p id="310b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到底，我们都是第三方库的用户。如果我们都遵循这些原则，我们就可以生活在一个代码更好、挫折更少、开发人员体验总体更好的世界里。</p></div></div>    
</body>
</html>