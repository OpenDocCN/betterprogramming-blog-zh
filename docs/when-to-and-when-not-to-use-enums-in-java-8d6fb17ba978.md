# Java 中什么时候使用枚举，什么时候不使用枚举

> 原文：<https://betterprogramming.pub/when-to-and-when-not-to-use-enums-in-java-8d6fb17ba978>

## 枚举是一种代码气味吗？

![](img/19d2a61d963a0ef0b82298d85cc9d54a.png)

[布莱克](https://unsplash.com/@blakeconnally)在 [Unsplash](https://unsplash.com/photos/B3l0g6HLxr8) 上拍照

许多人认为枚举是代码味道，是 OOPs 中的反模式。某些书也引用枚举作为代码气味，如下所示。

警告根据经验，枚举是代码的味道，应该被重构为多态类依赖注入。马克·西曼

在大多数情况下，枚举闻起来是因为它经常被滥用，但这并不意味着你必须避免它们。如果使用得当，枚举可以成为你武器库中的强大工具。在这篇文章中，我想简单回顾一下什么时候应该使用枚举，什么时候不应该使用枚举。

# 枚举的快速复习

枚举通常用于表示一组常数。它们是使用 enum 关键字创建的，常量之间用逗号分隔。

枚举通常在 switch 语句中用于检查相应的值:

# 枚举就是字符串列表，对吗？

枚举通常被认为是字符串常量:命名的值，可以在以后赋值和识别。但这并不是故事的全部，如果你就此打住，你只是浏览了表面。

枚举实际上是作为类实现的，枚举值是它们的实例。

枚举“房屋”的类表示

这意味着枚举可以像任何其他类一样拥有属性和方法。

示例摘自[https://docs . Oracle . com/javase/tutorial/Java/javaOO/enum . html](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html)

所有的 enum 类都继承了 Java 标准类 *java.lang.Enum* ，它们从这个类继承了一些潜在有用的方法。

你应该知道的继承方法有`name()`、`ordinal()`和静态方法`values()`。

`name()`方法返回与枚举值中定义的名称完全相同的名称。`ordinal()`方法返回一个数值，它反映了枚举的声明顺序，从零开始。举个例子，

values()方法通常更有用。它返回一个包含所有枚举值的数组，并可用于遍历这些值。这里有一个例子。

# 何时以及为何使用枚举:

虽然枚举不仅仅是一个字符串列表，但枚举最常见的用例是表示一个常量列表。但是我们为什么需要枚举呢？为什么不能用简单的字符串数组？

我们举个例子。假设你正在用下面的一组输入命令构建一个游戏。

您的程序中会有代码对这些命令做出反应，然后调用正确的方法来执行它们。在下面的代码片段中，我假设字符串变量`commandWord`保存键入的单词:

这个解决方案有什么问题？确实有两个基本问题立即凸显出来:类型安全和全球化。

## **类型安全**

在开关盒中，字母 P 是“Pass”中的大写字母，编译器无法检测到这一点。

现在让我们使用枚举重写相同的内容:

如果您在此处错误地键入了 case 标签或赋值，编译器会检测到并通知您。

## **全球化**

如果你决定将程序翻译成不同的语言(假设移动命令现在是移动)，这将导致错误。如果你只是改变数组中的命令字，程序会编译，但是功能会中断。

# enum 什么时候是代码味？

## 枚举迫使你使用多个开关的情况

枚举被认为是代码味道的一个主要原因是它们诱使你在代码中散布 switch 语句。这有什么问题呢？

考虑这个场景

干净代码的例子:敏捷软件工艺手册(罗伯特·c·马丁)

这里有一些明显的问题。它违反了多个 OOP 最佳实践:

*   当添加新的雇员类型时，函数会增长，可读性会降低。
*   它违反了[单一责任原则](https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html) (SRP)，因为它改变的原因不止一个。
*   它违反了[开闭原则](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle#:~:text=In%20object%2Doriented%20programming%2C%20the,without%20modifying%20its%20source%20code.) (OCP)，因为每当添加新类型时，它都必须改变。
*   类似于这个函数，将会有无限数量的其他函数具有相同的结构。isPayday(员工 e，日期日期)或 deliverPay(员工 e，金钱支付)或许多其他的。向枚举添加额外的值意味着在代码中找到该类型的每一次使用，并且可能需要为新值添加新的分支。

不幸的是，我们不能总是避免 switch 语句，但是我们*可以*确保每个 switch 语句都被隐藏在一个低级类中。

使用 Robert C. Martin 在 Clean code: *中提出的“ONE SWITCH”规则，对于给定的选择类型，可能只有一个 SWITCH 语句。该 switch 语句中的案例必须创建多态对象，以取代系统其余部分中的其他此类 switch 语句。*

干净代码的例子:敏捷软件工艺手册(罗伯特·c·马丁)

在这里，添加一个新类型仅仅意味着创建一个实现接口的新类——更改集中在一个地方，更容易进行。

> 注意:如果你已经有了一个类层次结构，这个技术就不能应用了。在面向对象编程中，不能通过继承来创建双重层次。但是你可以使用这里提到的另一种技术:[https://refactoring . guru/replace-type-code-with-state-strategy](https://refactoring.guru/replace-type-code-with-state-strategy)

## **枚举导致次优建模**

与前一个问题类似，这也不是枚举的单独问题。不幸的是，枚举有时会导致糟糕的数据模型设计决策。

考虑前面的例子。

假设我们想要存储关于薪水的信息。“销售人员”的工资是基于佣金的，所以我们希望存储财产佣金百分比。最简单的方法是向类中添加一个新属性。

然而，该属性与“工程师”无关，因为他们没有基于佣金的工资。所以现在你有了一个与“工程师”无关的属性，这不是一个非常干净的表示数据的方式。

更好的设计方法是使用子类。

这可能是显而易见的，但正如大多数显而易见的事情一样——它不是，所以我认为它值得一提。

就是这样！基本上，如果你认为你在编译时知道“某物”所有可能的值，并且可以用一个简单的值来表示，你可以把它表示为一个枚举类型。但是，当您在多个开关案例中使用这些枚举时，您应该注意了。

同样，这些要点中的一些对你来说可能非常明显，或者可能碰巧有帮助。