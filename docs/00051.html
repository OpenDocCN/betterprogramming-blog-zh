<html>
<head>
<title>Docker’s Voting App on Swarm, Kubernetes and Nomad</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker在Swarm、Kubernetes和Nomad上的投票应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dockers-voting-app-on-swarm-kubernetes-and-nomad-8835a82050cf?source=collection_archive---------2-----------------------#2017-08-24">https://betterprogramming.pub/dockers-voting-app-on-swarm-kubernetes-and-nomad-8835a82050cf?source=collection_archive---------2-----------------------#2017-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/29f21b943f4c1cd974bb6a7123c69b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*fGnRt6bdSsVUd4kLh478Cw.png"/></div></figure><h1 id="8414" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="9565" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">当你在技术领域工作时，你一定要有好奇心，因为保持学习和跟上时代是很重要的。这个地区的发展速度非常快。</p><p id="ebb8" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">容器编排是一个如此热门的话题，即使你有自己喜欢的工具(我的心属于<a class="ae ly" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank"> Docker Swarm </a>)，看看其他工具是如何工作的，并从中学习也总是很有趣的。</p><p id="0c94" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">在本文中，我们将使用Docker的投票应用程序，并将其部署在Swarm、<a class="ae ly" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>和<a class="ae ly" href="https://www.nomadproject.io/" rel="noopener ugc nofollow" target="_blank"> HashiCorp Nomad </a>上。我希望你在阅读这篇文章的时候会和我在做实验的时候一样开心。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9a46" class="jx jy it bd jz ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku bi translated">投票应用程序</h1><p id="e77d" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我在以前的文章中使用过(也滥用过)投票应用。这个应用程序遵循微服务架构。它由五个服务组成，如下图所示。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ml"><img src="../Images/42781883492d0eaaaa272040c939e90d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LaLpavOVZGWNiLI_."/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">Docker的投票应用架构(<a class="ae ly" href="https://github.com/docker/example-voting-app" rel="noopener ugc nofollow" target="_blank">https://github.com/docker/example-voting-app</a>)</p></figure><ul class=""><li id="6e2f" class="my mz it kx b ky lt lc lu lg na lk nb lo nc ls nd ne nf ng bi translated">投票-使用户能够在猫和狗之间进行选择的前端。</li><li id="a855" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">Redis —存储投票的数据库。</li><li id="d91e" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">Worker —从Redis获取投票并将结果存储在Postgres数据库中的服务。</li><li id="b60b" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">Db —存储投票结果的Postgres数据库。</li><li id="455b" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">结果—前端，显示投票结果。</li></ul><p id="7366" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">正如我们在GitHub资源库中看到的，投票应用程序有几个合成文件。</p><div class="nm nn gp gr no np"><a href="https://github.com/docker/example-voting-app" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">docker/示例-投票-应用程序</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">示例-投票-应用程序-示例Docker编写应用程序</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od jv np"/></div></div></a></div><p id="1bef" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated"><code class="fe oe of og oh b">docker-stack.yml</code>是应用程序的生产就绪表示。这个文件的内容是:</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="53b8" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">基本上，这个文件中定义了六个服务，但是投票App架构中只定义了五个服务。附加的一个是“可视化器”；一个伟大的工具，它提供了一个清晰的界面，显示服务的任务部署在哪里。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="12d7" class="jx jy it bd jz ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku bi translated">码头工人群</h1><p id="22e7" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Docker Swarm是Docker容器的集群和调度工具。借助Swarm，IT管理员和开发人员可以将Docker节点集群作为单个虚拟系统来建立和管理。</p><h2 id="b8ab" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">蜂群的概念</h2><p id="2db8" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">一个Swarm集群由几个节点组成——一些节点充当管理者，另一些节点充当工作者。</p><ul class=""><li id="3d86" class="my mz it kx b ky lt lc lu lg na lk nb lo nc ls nd ne nf ng bi translated">管理节点是负责集群内部状态的节点。</li><li id="2e28" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">工作节点是执行任务(运行容器)的节点。</li></ul><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ow"><img src="../Images/ee602058d076c15d1fff705e62027060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KtqL-QkmCmYjbjk_2kARsg.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">群集群的体系结构</p></figure><p id="ca18" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">正如我们所看到的，管理器共享一个内部分布式存储，以便维护集群的一致状态。这通过Raft分布式一致性算法的日志来确保。</p><p id="4e20" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">注意:如果您想了解更多关于群中Raft日志的使用，您可能会对下面的文章感兴趣。</p><div class="nm nn gp gr no np"><a href="https://medium.com/lucjuggery/raft-logs-on-swarm-mode-1351eff1e690" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">群体模式下的木筏日志</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">TL；速度三角形定位法(dead reckoning)</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">medium.com</p></div></div><div class="ny l"><div class="ox l oa ob oc ny od jv np"/></div></div></a></div><p id="0d36" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">在Swarm中，<strong class="kx iu">服务</strong>定义了应用程序的一部分需要如何在容器中运行和部署。</p><h2 id="977b" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">安装码头平台</h2><p id="23c5" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果您的机器上没有安装Docker，您可以从以下位置下载适用于您的操作系统的社区版并进行安装。</p><div class="nm nn gp gr no np"><a href="https://www.docker.com/community-edition" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">社区版</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">为主要的桌面和云平台安装Docker和易于使用的安装程序。</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">www.docker.com</p></div></div><div class="ny l"><div class="oy l oa ob oc ny od jv np"/></div></div></a></div><h2 id="9202" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">蜂群的产生</h2><p id="0810" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">一旦安装了Docker，你只需要一个简单的命令就可以运行一个集群。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="a1aa" class="ok jy it oh b gy pd pe l pf pg"><strong class="oh iu">$ docker swarm init</strong></span></pre><p id="6628" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">是啊！这就是拥有一个蜂群所需要的一切。一个单节点集群，但仍然是一个包含所有相关进程的群集群。</p><h2 id="c5bd" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">应用程序的部署</h2><p id="8622" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在投票应用程序的GitHub存储库中提供的撰写文件中，docker-stack.yml是需要用来在Swarm上部署应用程序的文件。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="1f43" class="ok jy it oh b gy pd pe l pf pg"><strong class="oh iu">$ docker stack deploy -c docker-stack.yml app</strong><br/>Creating network app_backend<br/>Creating network app_default<br/>Creating network app_frontend<br/>Creating service app_visualizer<br/>Creating service app_redis<br/>Creating service app_db<br/>Creating service app_vote<br/>Creating service app_result<br/>Creating service app_worker</span></pre><p id="4235" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">当我在Docker for Mac上运行堆栈时，我可以直接从本地主机访问应用程序。可以从投票界面(端口5000)选择CATS或DOGS，并在端口5001上查看结果。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ph"><img src="../Images/cdc0fae8110625444f2fa2a0d816d131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lbmpnyrjJ0rfzdoHfjBeoQ.png"/></div></div></figure><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ph"><img src="../Images/554f0070a63b9bdb64496d240ea53841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EMTdfAuzXHgSBGplmJtayg.png"/></div></div></figure><p id="1b8c" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">我不会在这里讨论细节，但我只想向您展示这个应用程序在Swarm上部署是多么容易。</p><p id="46ff" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">如果您想要更深入地了解如何在多节点集群上部署相同的应用程序，您可以查看下面的文章。</p><div class="nm nn gp gr no np"><a href="https://medium.com/lucjuggery/deploy-the-voting-apps-stack-on-a-docker-swarm-4390fd5eee4" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">使用Compose版本3在Docker Swarm上部署投票应用程序</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">有了Docker 1.13，现在可以从docker-compose文件部署堆栈。让我们测试一下并部署投票…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">medium.com</p></div></div><div class="ny l"><div class="pi l oa ob oc ny od jv np"/></div></div></a></div><h1 id="abc3" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">库伯内特斯</h1><p id="6565" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Kubernetes是一个开源系统，用于自动化部署、扩展和管理容器化的应用程序。</p><h2 id="0a67" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">Kubernetes概念</h2><p id="e7e1" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Kubernetes集群由几个主节点和节点组成。</p><ul class=""><li id="630a" class="my mz it kx b ky lt lc lu lg na lk nb lo nc ls nd ne nf ng bi translated">主设备处理集群的控制平面(管理集群的状态、调度任务、对集群的事件做出反应)。</li><li id="1c35" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">节点(以前称为Minions)提供运行时来执行应用程序容器(通过Pods)。</li></ul><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi pj"><img src="../Images/b7f5727170e48ce4bcf63cf914671efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2n7a_9paxCGgdTzaKqqJtA.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">Kubernetes集群的架构</p></figure><p id="b8a4" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">为了对Kubernetes集群运行命令，使用了<code class="fe oe of og oh b">kubectl</code> <strong class="kx iu"> </strong>命令行工具。我们将在下面看到它用法的几个例子。</p><p id="2020" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">为了理解如何部署应用程序，我们需要了解Kubernetes的几个高级对象:</p><ul class=""><li id="e0ba" class="my mz it kx b ky lt lc lu lg na lk nb lo nc ls nd ne nf ng bi translated">一艘<code class="fe oe of og oh b">Pod</code>是能够部署在一艘<code class="fe oe of og oh b">Node</code>T10上的最小单位。这是一组必须一起运行的容器。然而，通常一个Pod只包含一个容器。</li><li id="7016" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated"><code class="fe oe of og oh b">ReplicaSet</code>确保指定数量的pod副本在任何给定时间运行。</li><li id="078f" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">一个<code class="fe oe of og oh b">Deployment</code>管理<code class="fe oe of og oh b">ReplicaSet</code>，并允许处理滚动更新、蓝/绿部署、金丝雀测试等。</li><li id="4ba5" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">一个<code class="fe oe of og oh b">Service</code>定义了一个<code class="fe oe of og oh b">Pods</code> <strong class="kx iu"> </strong>的逻辑集合和一个访问它们的策略。</li></ul><p id="b51a" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">在本章中，我们将为投票应用程序的每个服务使用一个<code class="fe oe of og oh b">Deployment</code>和一个<code class="fe oe of og oh b">Service</code>对象。</p><h2 id="b014" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">安装<code class="fe oe of og oh b">kubectl</code></h2><p id="4006" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><code class="fe oe of og oh b">kubectl</code>是用于在Kubernetes上部署和管理应用程序的命令行工具。</p><div class="nm nn gp gr no np"><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">安装并设置kubectl</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">生产级容器编排</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">kubernetes.io</p></div></div></div></a></div><p id="91df" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">它可以很容易地按照官方文件安装。例如，要在MacOS上安装它，需要运行以下命令。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="58aa" class="ok jy it oh b gy pd pe l pf pg">$ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl</span><span id="55e4" class="ok jy it oh b gy pk pe l pf pg">$ chmod +x ./kubectl</span><span id="a958" class="ok jy it oh b gy pk pe l pf pg">$ sudo mv ./kubectl /usr/local/bin/kubectl</span></pre><h2 id="a43d" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">安装Minikube</h2><p id="901f" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><a class="ae ly" href="https://kubernetes.io/docs/setup/minikube/" rel="noopener ugc nofollow" target="_blank"> Minikube </a>是Kubernetes的一体化设置。它创建一个本地虚拟机，例如在<a class="ae ly" href="https://www.virtualbox.org/wiki/Downloads" rel="noopener ugc nofollow" target="_blank"> VirtualBox </a>上，并运行一个运行所有Kubernetes进程的单节点集群。很明显，它不是一个应该用来设置生产集群的工具，但是对于开发和测试来说，它非常方便。</p><div class="nm nn gp gr no np"><a href="https://github.com/kubernetes/minikube" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">kubernetes/minikube</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">minikube -在当地经营Kubernetes</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="pl l oa ob oc ny od jv np"/></div></div></a></div><h2 id="8e0d" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">创建单节点集群</h2><p id="e90e" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">一旦安装了Minikube，我们只需要发出<code class="fe oe of og oh b">start</code>命令来设置我们的单节点Kubernetes集群。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="ea01" class="ok jy it oh b gy pd pe l pf pg"><strong class="oh iu">$ minikube start</strong><br/>Starting local Kubernetes v1.7.0 cluster…<br/>Starting VM…<br/>Downloading Minikube ISO<br/> 97.80 MB / 97.80 MB [==============================================] 100.00% 0s<br/>Getting VM IP address…<br/>Moving files into cluster…<br/>Setting up certs…<br/>Starting cluster components…<br/>Connecting to cluster…<br/>Setting up kubeconfig…<br/>Kubectl is now configured to use the cluster.</span></pre><h2 id="3cb9" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">Kubernetes描述符</h2><p id="b172" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在Kubernetes上，容器不是直接运行的，而是通过由<code class="fe oe of og oh b">Deployment</code>管理的<code class="fe oe of og oh b">ReplicaSet</code>。</p><p id="c325" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">下面是一个描述<code class="fe oe of og oh b">Deployment</code>的. yml文件的例子。一个<code class="fe oe of og oh b">ReplicaSet</code>将确保一个使用Nginx的Pod的两个副本正在运行。</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="0b4d" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">正如我们将在下面看到的，为了创建部署，我们需要使用<code class="fe oe of og oh b">kubectl</code>命令行工具。</p><p id="52c4" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">为了在Kubernetes中定义一个完整的微服务应用程序，我们需要为每个服务创建一个部署文件。我们可以手动操作，也可以使用<a class="ae ly" href="http://kompose.io" rel="noopener ugc nofollow" target="_blank"> Kompose </a>来帮助我们完成这项任务。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cf14" class="jx jy it bd jz ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku bi translated">使用Kompose创建部署和服务</h1><p id="0c5d" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Kompose 是一个很棒的工具，可以将Docker合成文件转换成Kubernetes使用的描述符文件(用于部署和服务)。这非常方便，而且确实加快了移民的进程。</p><div class="nm nn gp gr no np"><a href="http://kompose.io" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">Kubernetes + Compose = Kompose</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">kompose是一个帮助熟悉docker-compose的用户迁移到Kubernetes的工具。它需要一个Docker合成文件和…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">kompose.io</p></div></div></div></a></div><p id="bded" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">注意事项:</p><ul class=""><li id="aa35" class="my mz it kx b ky lt lc lu lg na lk nb lo nc ls nd ne nf ng bi translated">Kompose没有<em class="pm">可以使用的</em>，因为描述符文件可以手动写入，但是当使用时，它确实可以加速部署。</li><li id="ffeb" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">Kompose没有考虑Docker合成文件中使用的所有选项。</li></ul><p id="3601" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">以下命令在Linux或MacOS上安装kom pose 1 . 0 . 0版。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="122d" class="ok jy it oh b gy pd pe l pf pg"># Linux<br/><strong class="oh iu">$ curl -L https://github.com/kubernetes/kompose/releases/download/v1.0.0/kompose-linux-amd64 -o kompose</strong></span><span id="8519" class="ok jy it oh b gy pk pe l pf pg"># macOS<br/><strong class="oh iu">$ curl -L https://github.com/kubernetes/kompose/releases/download/v1.0.0/kompose-darwin-amd64 -o kompose<br/><br/>$ chmod +x kompose<br/>$ sudo mv ./kompose /usr/local/bin/kompose</strong></span></pre><p id="363b" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">在对原始的<code class="fe oe of og oh b">docker-stack.yml</code>文件应用Kompose之前，我们将修改该文件，并删除每个服务的<code class="fe oe of og oh b">deploy</code>键。不考虑该键，它会在生成描述符文件时引发错误。我们还可以删除有关网络的信息。然后，我们将使用下面的文件，重命名为<code class="fe oe of og oh b">docker-stack-k8s.yml</code>，提供给Kompose。</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="4fdf" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">从<code class="fe oe of og oh b">docker-stack-k8s.yml</code>文件中，我们可以使用下面的命令生成投票应用程序的描述符。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="f691" class="ok jy it oh b gy pd pe l pf pg"><strong class="oh iu">$ kompose convert --file docker-stack-k8s.yml</strong><br/>WARN Volume mount on the host "/var/run/docker.sock" isn't supported - ignoring path on the host<br/>INFO Kubernetes file "db-service.yaml" created<br/>INFO Kubernetes file "redis-service.yaml" created<br/>INFO Kubernetes file "result-service.yaml" created<br/>INFO Kubernetes file "visualizer-service.yaml" created<br/>INFO Kubernetes file "vote-service.yaml" created<br/>INFO Kubernetes file "worker-service.yaml" created<br/>INFO Kubernetes file "db-deployment.yaml" created<br/>INFO Kubernetes file "db-data-persistentvolumeclaim.yaml" created<br/>INFO Kubernetes file "redis-deployment.yaml" created<br/>INFO Kubernetes file "result-deployment.yaml" created<br/>INFO Kubernetes file "visualizer-deployment.yaml" created<br/>INFO Kubernetes file "visualizer-claim0-persistentvolumeclaim.yaml" created<br/>INFO Kubernetes file "vote-deployment.yaml" created<br/>INFO Kubernetes file "worker-deployment.yaml" created</span></pre><p id="f5ee" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">我们可以看到，对于每个服务，都创建了一个部署和一个服务文件。</p><p id="1ec8" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">我们只收到一个与visualizer服务相关的警告，因为Docker套接字无法安装。但是，我们不会尝试运行这项服务，而是专注于其他服务。</p><h2 id="562f" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">应用程序的部署</h2><p id="d578" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">使用kubectl，我们将创建描述符文件中定义的所有组件。我们指出位于当前文件夹中的文件。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="2cdf" class="ok jy it oh b gy pd pe l pf pg"><strong class="oh iu">$ kubectl create -f .<br/></strong>persistentvolumeclaim "db-data" created<br/>deployment "db" created<br/>service "db" created<br/>deployment "redis" created<br/>service "redis" created<br/>deployment "result" created<br/>service "result" created<br/>persistentvolumeclaim "visualizer-claim0" created<br/>deployment "visualizer" created<br/>service "visualizer" created<br/>deployment "vote" created<br/>service "vote" created<br/>deployment "worker" created<br/>service "worker" created<br/>unable to decode "docker-stack-k8s.yml":...</span></pre><p id="42a4" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">注意:当我们将修改后的合成文件留在当前文件夹中时，我们会得到一个错误，因为它无法被解析。这个错误可以被忽略而没有风险。</p><p id="db65" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">下面的命令显示了创建的服务和部署。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="0949" class="ok jy it oh b gy pd pe l pf pg"><strong class="oh iu">$ kubectl get services</strong><br/>NAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)     AGE<br/>db           None         &lt;none&gt;        55555/TCP   3m<br/>kubernetes   10.0.0.1     &lt;none&gt;        443/TCP     4m<br/>redis        10.0.0.64    &lt;none&gt;        6379/TCP    3m<br/>result       10.0.0.121   &lt;none&gt;        5001/TCP    3m<br/>visualizer   10.0.0.110   &lt;none&gt;        8080/TCP    3m<br/>vote         10.0.0.142   &lt;none&gt;        5000/TCP    3m<br/>worker       None         &lt;none&gt;        55555/TCP   3m</span><span id="d34d" class="ok jy it oh b gy pk pe l pf pg"><strong class="oh iu">$ kubectl get deployment</strong><br/>NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br/>db           1         1         1            1           3m<br/>redis        1         1         1            1           3m<br/>result       1         1         1            1           3m<br/>visualizer   1         1         1            1           3m<br/>vote         1         1         1            1           3m<br/>worker       1         1         1            1           3m</span></pre><h2 id="0f19" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">向外界公开应用程序</h2><p id="efe4" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">为了访问<code class="fe oe of og oh b">vote</code>和<code class="fe oe of og oh b">result</code>接口，我们需要稍微修改为它们创建的服务。</p><p id="eb7f" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">下面的文件是为<code class="fe oe of og oh b">vote</code> <strong class="kx iu">生成的描述符。</strong></p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="9e73" class="ok jy it oh b gy pd pe l pf pg">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  creationTimestamp: null<br/>  labels:<br/>    io.kompose.service: vote<br/>  name: vote<br/>spec:<br/>  ports:<br/>  - name: "5000"<br/>    port: 5000<br/>    targetPort: 80<br/>  selector:<br/>    io.kompose.service: vote<br/>status:<br/>  loadBalancer: {}</span></pre><p id="3f28" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">我们将修改服务类型，并将默认类型<code class="fe oe of og oh b">ClusterIP</code><strong class="kx iu"/>改为<code class="fe oe of og oh b">NodePort</code>。虽然<code class="fe oe of og oh b">ClusterIP</code>允许内部访问服务，但是<code class="fe oe of og oh b">NodePort</code>允许在集群的每个节点上发布一个端口，并使其对外部世界可用。我们将为<code class="fe oe of og oh b">result</code>做同样的事情，因为我们希望<code class="fe oe of og oh b">vote</code>和<code class="fe oe of og oh b">result</code>都可以从外部访问。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="f2f6" class="ok jy it oh b gy pd pe l pf pg">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  labels:<br/>    io.kompose.service: vote<br/>  name: vote<br/>spec:<br/>  <strong class="oh iu">type: NodePort</strong><br/>  ports:<br/>  - name: "5000"<br/>    port: 5000<br/>    targetPort: 80<br/>  selector:<br/>    io.kompose.service: vote</span></pre><p id="3cec" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">一旦两个服务(投票和结果)的修改完成，我们就可以重新创建它们。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="c4ea" class="ok jy it oh b gy pd pe l pf pg"><strong class="oh iu">$ kubectl delete svc vote<br/>$ kubectl delete svc result</strong></span><span id="cca7" class="ok jy it oh b gy pk pe l pf pg"><strong class="oh iu">$ kubectl create -f vote-service.yaml</strong><br/>service "vote" created</span><span id="c6be" class="ok jy it oh b gy pk pe l pf pg"><strong class="oh iu">$ kubectl create -f result-service.yaml</strong><br/>service "result" created</span></pre><h2 id="2a72" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated"><strong class="ak">访问应用程序</strong></h2><p id="818a" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在让我们获取<code class="fe oe of og oh b">vote</code>和<code class="fe oe of og oh b">result</code>服务的详细信息，并检索每个服务公开的端口。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="d3b1" class="ok jy it oh b gy pd pe l pf pg"><strong class="oh iu">$ kubectl get svc vote result</strong><br/>NAME      CLUSTER-IP   EXTERNAL-IP   PORT(S)          AGE<br/>vote      10.0.0.215   &lt;nodes&gt;       5000:<strong class="oh iu">30069</strong>/TCP   15m<br/>result    10.0.0.49    &lt;nodes&gt;       5001:<strong class="oh iu">31873</strong>/TCP   8m</span></pre><p id="b526" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated"><code class="fe oe of og oh b">Vote</code>在30069端口可用，<code class="fe oe of og oh b">result</code>在31873端口可用。我们现在可以投票，看看结果。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi pn"><img src="../Images/d84facd8a2e3e264d35780445a0cc84f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2BglGQCutU6B7t-WdXkT3g.png"/></div></div></figure><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi pn"><img src="../Images/fed9888e3f1355201df48d034cdc601a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q6zaeo04G5Qzt994eQzIPA.png"/></div></div></figure><p id="50ea" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">对Kubernetes的组件有了一些基本的了解后，我们设法非常容易地部署了投票应用程序。Kompose在这个过程中确实帮了我们。</p><h1 id="8875" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">哈希公司的游牧者</h1><p id="c0da" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Nomad是一个管理机器集群并在其上运行应用程序的工具。Nomad抛弃了抽象的机器和应用程序的位置，取而代之的是让用户声明他们想要运行什么。然后，Nomad处理它们应该在哪里运行，以及如何运行。</p><h2 id="b885" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">游牧者的概念</h2><p id="a57a" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">一个游牧集群由<strong class="kx iu">代理</strong>组成，它们可以在<strong class="kx iu">服务器</strong>或<strong class="kx iu">客户端</strong>模式下运行。</p><ul class=""><li id="effe" class="my mz it kx b ky lt lc lu lg na lk nb lo nc ls nd ne nf ng bi translated">服务器承担作为<a class="ae ly" href="https://www.nomadproject.io/docs/internals/consensus.html" rel="noopener ugc nofollow" target="_blank">共识协议</a>的一部分的责任，该协议允许服务器执行领导者选举和状态复制。</li><li id="bc96" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">客户端节点是非常轻量级的，因为它们与服务器节点交互，并且维护自己的很少状态。客户端节点是运行任务的地方。</li></ul><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi po"><img src="../Images/4ba1b18cb925656c471fe560e95985b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7q7XQOPgc5NDSMM4oUQp9Q.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">游牧集群的体系结构</p></figure><p id="540c" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">几种类型的任务可以在一个Nomad集群上运行。Docker工作负载可以使用<code class="fe oe of og oh b">docker</code>驱动程序运行。这是我们将用来运行投票应用程序的驱动程序。</p><p id="c25b" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">为了在Nomad上部署应用程序，我们需要首先理解几个概念(Nomad词汇表中的<em class="pm">节</em>):</p><ul class=""><li id="efbf" class="my mz it kx b ky lt lc lu lg na lk nb lo nc ls nd ne nf ng bi translated">一个<em class="pm">任务</em>是Nomad应该运行的任务的声明性规范。它是在作业文件(HCL中的文本文件，Hashicorp配置语言)中定义的。一个作业可以有多组任务中的一组<strong class="kx iu">。</strong>作业由用户提交，代表一种<em class="pm">期望状态</em>。</li><li id="2282" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">一个<em class="pm">组</em>包含一组位于同一台机器上的任务。</li><li id="3a90" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">一个<em class="pm">任务</em>是一个正在运行的进程；我们示例中的Docker容器。</li><li id="c96e" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">使用<em class="pm">分配</em>完成任务到客户端的映射。分配用于声明作业中的一组任务应该在特定节点上运行。</li></ul><p id="a12f" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">Nomad的文档中描述了更多的章节。</p><h2 id="11a1" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">设置</h2><p id="6694" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在本例中，我们将在用Docker Machine创建的Docker主机上运行应用程序。它的本地IP是192.168.1.100。我们将从运行Consul开始，用于服务注册和发现。然后我们将启动Nomad，并将投票应用程序的服务部署为Nomad作业。</p><h2 id="b541" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">获取服务注册和发现的咨询</h2><p id="207c" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">为了确保服务注册和发现，建议使用一个工具，如Consul，它不作为游牧作业运行。</p><p id="2eb7" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">领事可以从下面的网站下载。</p><div class="nm nn gp gr no np"><a href="https://www.consul.io/downloads.html" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">下载领事-哈希公司的领事</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">下载领事</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">HashiCorp领事下载Consul ww . Consul . io</p></div></div><div class="ny l"><div class="pp l oa ob oc ny od jv np"/></div></div></a></div><p id="a375" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">以下命令在本地启动Consul服务器。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="f574" class="ok jy it oh b gy pd pe l pf pg">$ consul agent -dev -client=0.0.0.0 -dns-port=53 -recursor=8.8.8.8</span></pre><p id="a82d" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">让我们更详细地了解一下所使用的选项:</p><ul class=""><li id="7c97" class="my mz it kx b ky lt lc lu lg na lk nb lo nc ls nd ne nf ng bi translated"><code class="fe oe of og oh b">-dev</code>是一个方便的标志，它建立了一个包含服务器和客户端的咨询集群。除非出于开发和测试目的，否则不得使用此选项</li><li id="de19" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated"><code class="fe oe of og oh b">-client=0.0.0.0</code>允许我们从主机的任何接口访问consul服务(API和DNS服务器)。这是需要的，因为Nomad将在localhost接口上连接到Consul，而容器将通过Docker桥(通常类似于172.17.x.x)连接。</li><li id="b91e" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated"><code class="fe oe of og oh b">-dns-port=53</code>指定领事的DNS服务器使用的端口(默认为8600)。我们已经将它设置为标准的53端口，所以可以从容器内部使用Consul DNS。</li><li id="2ab5" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated"><code class="fe oe of og oh b">-recursor=8.8.8.8</code>指定另一个DNS服务器来处理Consul无法处理的请求。</li></ul><h2 id="509e" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">获得游牧民族</h2><p id="ec72" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Nomad是一个用Go编写的二进制文件，可以从下面的位置下载。</p><div class="nm nn gp gr no np"><a href="https://www.nomadproject.io/downloads.html" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">下载Nomad—hashi corp的Nomad</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">下载Nomad</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">HashiCorp的Nomad下载Nomad ww . Nomad project . io</p></div></div><div class="ny l"><div class="pq l oa ob oc ny od jv np"/></div></div></a></div><h2 id="ac93" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">创建单节点集群</h2><p id="730f" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">一旦下载了Nomad，我们就可以使用以下配置运行代理。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="981c" class="ok jy it oh b gy pd pe l pf pg">// nomad.hcl<br/>bind_addr = "0.0.0.0"</span><span id="be38" class="ok jy it oh b gy pk pe l pf pg">data_dir  = "/var/lib/nomad"</span><span id="bae7" class="ok jy it oh b gy pk pe l pf pg">server {<br/>  enabled          = true<br/>  bootstrap_expect = 1<br/>}</span><span id="c9d8" class="ok jy it oh b gy pk pe l pf pg">client {<br/>  enabled       = true<br/>  network_speed = 100<br/>}</span></pre><p id="9267" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">该代理将同时作为服务器和客户端运行。我们指定了<code class="fe oe of og oh b">bind_addr</code>来监听任何接口，因此可以从外部访问任务。让我们使用以下配置启动一个Nomad代理:</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="7292" class="ok jy it oh b gy pd pe l pf pg"><strong class="oh iu">$ nomad agent -config=nomad.hcl</strong><br/>==&gt; WARNING: Bootstrap mode enabled! Potentially unsafe operation.<br/>    Loaded configuration from nomad-v2.hcl<br/>==&gt; Starting Nomad agent...<br/>==&gt; Nomad agent configuration:</span><span id="9077" class="ok jy it oh b gy pk pe l pf pg">Client: true<br/>             Log Level: INFO<br/>                Region: global (DC: dc1)<br/>                Server: true<br/>               Version: 0.6.0</span><span id="9095" class="ok jy it oh b gy pk pe l pf pg">==&gt; Nomad agent started! Log data will stream in below:</span></pre><p id="cc2c" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">注意:默认情况下，Nomad连接到本地Consul实例。</p><p id="0c26" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">我们刚刚设置了一个单节点集群。下面列出了唯一成员的信息。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="520b" class="ok jy it oh b gy pd pe l pf pg"><strong class="oh iu">$ nomad server-members</strong><br/>Name                  Address    Port  Status  Leader  Protocol  Build  Datacenter  Region<br/>neptune.local.global  192.168.1.100  4648  alive   true    2         0.6.0  dc1         global</span></pre><h2 id="c365" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">应用程序的部署</h2><p id="3de9" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">从前面的例子中，我们看到，为了在Swarm上部署投票应用程序，可以直接使用Compose文件。在Kubernetes上部署应用程序时，可以从这个相同的合成文件创建描述符文件。现在让我们看看如何在Nomad上部署我们的投票应用程序。</p><p id="2aee" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">首先，在Hashicorp的世界里，没有像Kompose这样的工具可以顺利地将Docker Compose应用程序迁移到Nomad。这可能是未来开源项目的一个想法。描述工作、组、任务<strong class="kx iu"> </strong>(以及其他游牧节)的文件需要手动编写。</p><p id="98a7" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">我们将详细讨论为Redis和我们的应用程序的投票服务定义作业。对于其他服务来说，这个过程非常相似。</p><h2 id="eec3" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">Redis作业的定义</h2><p id="19e4" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">以下文件定义了应用程序的Redis部分。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="884f" class="ok jy it oh b gy pd pe l pf pg">// redis.nomad<strong class="oh iu"><br/>job</strong> "redis-nomad" {<br/>  datacenters = ["dc1"]<br/>  type = "service"<br/>  <strong class="oh iu">group</strong> "redis-group" {<br/>    <strong class="oh iu">task</strong> "redis" {<br/>      driver = "docker"<br/>      config {<br/>        image = "redis:3.2"<br/>        port_map {<br/>          db = 6379<br/>        }<br/>      }<br/>      resources {<br/>        cpu    = 500 # 500 MHz<br/>        memory = 256 # 256MB<br/>        network {<br/>          mbits = 10<br/>          port "db" {}<br/>        }<br/>      }<br/>      service {<br/>        name = "redis"<br/>        address_mode = "driver"<br/>        port = "db"<br/>        check {<br/>          name     = "alive"<br/>          type     = "tcp"<br/>          interval = "10s"<br/>          timeout  = "2s"<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="5b0f" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">让我们再解释一下。</p><ul class=""><li id="4b7b" class="my mz it kx b ky lt lc lu lg na lk nb lo nc ls nd ne nf ng bi translated">工作名称是<code class="fe oe of og oh b">redis-nomad</code>。</li><li id="93c0" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">作业的类型是<strong class="kx iu"> <em class="pm">服务</em> </strong>(这意味着一个长时间运行的任务)。</li><li id="8a32" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">定义了一个组，用一个任意的名字；它包含一个单一的任务。</li><li id="4510" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">一个名为Redis的任务正在使用Docker驱动程序，这意味着它将在一个容器中运行。</li><li id="e2a1" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">Redis任务被配置为使用redis:3.2 Docker映像，并在集群中公开标记为<code class="fe oe of og oh b">db</code>的端口6379。</li><li id="b8f6" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">在<code class="fe oe of og oh b">resources</code>块中，定义了一些<code class="fe oe of og oh b">cpu</code>和<code class="fe oe of og oh b">memory</code>约束。</li><li id="4843" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated">在<code class="fe oe of og oh b">network</code>块中，我们指定端口<code class="fe oe of og oh b">db</code>应该被动态分配。</li><li id="4ff2" class="my mz it kx b ky nh lc ni lg nj lk nk lo nl ls nd ne nf ng bi translated"><code class="fe oe of og oh b">service</code>块定义了如何在Consul中处理注册；服务名、应该指定的IP地址(容器的IP)以及健康检查的定义。</li></ul><p id="f6a6" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">为了检查这个作业是否可以正确运行，我们首先使用<code class="fe oe of og oh b">plan</code>命令。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="4616" class="ok jy it oh b gy pd pe l pf pg"><strong class="oh iu">$ nomad plan redis.nomad</strong><br/>+ Job: "nomad-redis"<br/>+ Task Group: "cache" (1 create)<br/>  + Task: "redis" (forces create)</span><span id="35e5" class="ok jy it oh b gy pk pe l pf pg">Scheduler dry-run:<br/>- All tasks successfully allocated.</span><span id="26b3" class="ok jy it oh b gy pk pe l pf pg">Job Modify Index: 0<br/>To submit the job with version verification run:</span><span id="5997" class="ok jy it oh b gy pk pe l pf pg">nomad run -check-index 0 redis.nomad</span><span id="717e" class="ok jy it oh b gy pk pe l pf pg">When running the job with the check-index flag, the job will only be run if the server side version matches the job modify index returned. If the index has changed, another user has modified the job and the plan's results are potentially invalid.</span></pre><p id="d4d4" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">一切似乎都很好，现在让我们看看作业是否可以部署任务。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="6472" class="ok jy it oh b gy pd pe l pf pg"><strong class="oh iu">$ nomad run redis.nomad</strong><br/>==&gt; Monitoring evaluation "1e729627"<br/>    Evaluation triggered by job "nomad-redis"<br/>    Allocation "<strong class="oh iu">bf3fc4b2</strong>" created: node "b0d927cd", group "cache"<br/>    Evaluation status changed: "pending" -&gt; "complete"<br/>==&gt; Evaluation "1e729627" finished with status "complete"</span></pre><p id="7147" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">从这个输出中，我们可以看到一个分配被创建。我们来看看这个的状态。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="84f0" class="ok jy it oh b gy pd pe l pf pg"><strong class="oh iu">$ nomad alloc-status bf3fc4b2</strong><br/>ID                  = bf3fc4b2<br/>Eval ID             = 1e729627<br/>Name                = nomad-redis.cache[0]<br/>Node ID             = b0d927cd<br/>Job ID              = nomad-redis<br/>Job Version         = 0<br/>Client Status       = running<br/>Client Description  = &lt;none&gt;<br/>Desired Status      = run<br/>Desired Description = &lt;none&gt;<br/>Created At          = 08/23/17 21:52:03 CEST</span><span id="9149" class="ok jy it oh b gy pk pe l pf pg"><strong class="oh iu">Task "redis" is "running"</strong><br/>Task Resources<br/>CPU        Memory           Disk     IOPS  Addresses<br/>1/500 MHz  6.3 MiB/256 MiB  300 MiB  0     db: 192.168.1.100:21886</span><span id="242e" class="ok jy it oh b gy pk pe l pf pg">Task Events:<br/>Started At     = 08/23/17 19:52:03 UTC<br/>Finished At    = N/A<br/>Total Restarts = 0<br/>Last Restart   = N/A</span><span id="bc26" class="ok jy it oh b gy pk pe l pf pg">Recent Events:<br/>Time                    Type        Description<br/>08/23/17 21:52:03 CEST  Started     Task started by client<br/>08/23/17 21:52:03 CEST  Task Setup  Building Task Directory<br/>08/23/17 21:52:03 CEST  Received    Task received by client</span></pre><p id="dabd" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">任务(容器)似乎运行正常。让我们检查一下Consul DNS服务器，确保服务注册正确。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="24e5" class="ok jy it oh b gy pd pe l pf pg"><strong class="oh iu">$ dig @localhost SRV redis.service.consul</strong></span><span id="bedb" class="ok jy it oh b gy pk pe l pf pg">; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Ubuntu &lt;&lt;&gt;&gt; <a class="ae ly" href="http://twitter.com/localhost" rel="noopener ugc nofollow" target="_blank">@localhost</a> SRV redis.service.consul<br/>; (1 server found)<br/>;; global options: +cmd<br/>;; Got answer:<br/>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 35884<br/>;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 2</span><span id="085a" class="ok jy it oh b gy pk pe l pf pg">;; OPT PSEUDOSECTION:<br/>; EDNS: version: 0, flags:; udp: 4096<br/>;; QUESTION SECTION:<br/>;redis.service.consul.  IN SRV</span><span id="773d" class="ok jy it oh b gy pk pe l pf pg">;; ANSWER SECTION:<br/>redis.service.consul. 0 IN SRV 1 1 <strong class="oh iu">6379</strong> ac110002.addr.dc1.consul.</span><span id="5cd8" class="ok jy it oh b gy pk pe l pf pg">;; ADDITIONAL SECTION:<br/>ac110002.addr.dc1.consul. 0 IN A <strong class="oh iu">172.17.0.2</strong></span><span id="ca09" class="ok jy it oh b gy pk pe l pf pg">;; Query time: 0 msec<br/>;; SERVER: 127.0.0.1#53(127.0.0.1)<br/>;; WHEN: Wed Aug 23 23:08:36 CEST 2017<br/>;; MSG SIZE  rcvd: 103</span></pre><p id="808a" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">我们可以看到，该任务被分配了IP 172.17.0.2(在Docker的网桥上),其端口是6379，正如我们所定义的。</p><h2 id="118b" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated">投票工作的定义</h2><p id="0705" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在让我们为<code class="fe oe of og oh b">vote</code>服务定义作业。我们将使用下面的作业文件。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="232b" class="ok jy it oh b gy pd pe l pf pg">// job.nomad<strong class="oh iu"><br/>job</strong> "vote-nomad" {<br/>  datacenters = ["dc1"]<br/>  type = "service"<br/>  <strong class="oh iu">group</strong> "vote-group" {<br/>    <strong class="oh iu">task</strong> "vote" {<br/>      driver = "docker"<br/>      config {<br/>        image = "dockersamples/examplevotingapp_vote:before"<br/>        <strong class="oh iu">dns_search_domains = ["service.dc1.consul"]<br/>        dns_servers = ["172.17.0.1", "8.8.8.8"]</strong><br/>        port_map {<br/>          http = 80<br/>        }<br/>      }<br/>      service {<br/>        name = "vote"<br/>        port = "http"<br/>        check {<br/>          name = "vote interface running on 80"<br/>          interval = "10s"<br/>          timeout  = "5s"<br/>          type     = "http"<br/>          protocol = "http"<br/>          path     = "/"<br/>        }<br/>      }<br/>      resources {<br/>        cpu    = 500 # 500 MHz<br/>        memory = 256 # 256MB<br/>        network {<br/>          port "http" {<br/>             static = 5000<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="1c62" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">与我们用于Redis的作业文件有一些不同。</p><ul class=""><li id="6f77" class="my mz it kx b ky lt lc lu lg na lk nb lo nc ls nd ne nf ng bi translated">任务只使用任务名连接到Redis。下面的例子是投票服务中使用的<code class="fe oe of og oh b">app.py</code>文件的例外。</li></ul><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="577f" class="ok jy it oh b gy pd pe l pf pg">// app.py<br/>def get_redis():    <br/>    if not hasattr(g, 'redis'):        <br/>       g.redis = Redis(host="<strong class="oh iu">redis</strong>", db=0, socket_timeout=5)  <br/>    return g.redis</span></pre><p id="124e" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">在这种情况下，投票的容器需要使用Consul DNS来获取Redis容器的IP。容器的DNS请求通过Docker桥(172.17.0.1)处理。还指定了<code class="fe oe of og oh b">dns_search_domains</code>，因为服务X在Consul中注册为<code class="fe oe of og oh b">X.service.dc1.consul</code>。</p><ul class=""><li id="a0be" class="my mz it kx b ky lt lc lu lg na lk nb lo nc ls nd ne nf ng bi translated">我们定义了一个静态端口，以便可以从集群外部通过端口5000访问投票服务。</li></ul><p id="711f" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">我们可以对其他服务使用相同的配置:<code class="fe oe of og oh b">worker</code>、<code class="fe oe of og oh b">postgres</code>和<code class="fe oe of og oh b">result</code>。</p><h2 id="9474" class="ok jy it bd jz ol om dn kd on oo dp kh lg op oq kl lk or os kp lo ot ou kt ov bi translated"><strong class="ak">访问应用程序</strong></h2><p id="df6a" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">一旦所有作业都已启动，我们就可以检查状态，应该会看到所有作业都在运行。</p><pre class="mm mn mo mp gt oz oh pa pb aw pc bi"><span id="2639" class="ok jy it oh b gy pd pe l pf pg"><strong class="oh iu">$ nomad status</strong><br/>ID              Type     Priority  Status   Submit Date<br/>nomad-postgres  service  50        running  08/23/17 22:12:04 CEST<br/>nomad-redis     service  50        running  08/23/17 22:11:46 CEST<br/>result-nomad    service  50        running  08/23/17 22:12:10 CEST<br/>vote-nomad      service  50        running  08/23/17 22:11:54 CEST<br/>worker-nomad    service  50        running  08/23/17 22:13:19 CEST</span></pre><p id="0e69" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">我们还可以在Consul的界面中看到所有已注册且健康的服务。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi pr"><img src="../Images/12d65bb595ae34b59404f9d1d6443ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kQboWn_FgvBsJ3tNOkcy3Q.png"/></div></div></figure><p id="ac59" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">从节点IP(本例中为192.168.1.100)，我们可以访问投票和结果接口。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ps"><img src="../Images/0d1091980ebdc6552d3e6616d44b3b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LUtz4sRHvKoMBktBVR0gVA.png"/></div></div></figure><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ps"><img src="../Images/6e563f06ca60dbe973446460e1a1ed19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HclQeWFNBN3YczPKnHY7CA.png"/></div></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ce42" class="jx jy it bd jz ka mg kc kd ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku bi translated">摘要</h1><p id="5270" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Docker的投票应用程序是一个很好的演示应用程序。我很好奇是否可以在不修改代码的情况下，在一些主要的编排工具上部署它。答案是肯定的——而且不需要太多调整。</p><p id="4c2c" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">我希望这篇文章有助于理解Swarm、Kubernetes和Nomad的一些基础知识。我很想听听你们是如何运行Docker工作负载的，以及你们使用的是哪种编排工具。</p></div></div>    
</body>
</html>