<html>
<head>
<title>Using Events in Node.js (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js中使用事件(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-events-in-node-js-part-2-50d26d817b26?source=collection_archive---------3-----------------------#2019-12-06">https://betterprogramming.pub/using-events-in-node-js-part-2-50d26d817b26?source=collection_archive---------3-----------------------#2019-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1d59" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何附加和移除事件侦听器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fb3dfdce259ae6f2c9ed2a244069bcbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5X-mi5QED1SBLXW5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@pabloheimplatz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pablo Heimplatz </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5b29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有阅读第一部分，我建议你在继续阅读之前先阅读一下。</p><p id="feab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>的核心特性是异步编程。这意味着Node.js中的代码可能不会按顺序执行。因此，数据可能无法在固定的时间内确定。</p><p id="0a97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着，为了获得我们需要的所有数据，我们必须在获得数据时在应用程序中传递数据。这可以通过在Node.js应用程序中发出、侦听和处理事件来实现。</p><p id="f08b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当发出具有给定名称的事件时，如果侦听器被指定侦听具有该名称的事件，则该事件可以侦听侦听器。事件发射器函数被同步调用。事件侦听器代码是一个回调函数，它接受数据的参数并对其进行处理。</p><p id="df4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Node.js有一个<code class="fe lv lw lx ly b">EventEmitter</code>类，可以通过我们创建的一个新类来扩展，以发出可以被事件监听器监听的事件。在本文中，我们从第1部分继续。</p><p id="c5a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第1部分中，我们向您展示了如何定义<code class="fe lv lw lx ly b">EventEmitters</code>，附加事件监听器，并使用<code class="fe lv lw lx ly b">once</code>和<code class="fe lv lw lx ly b">removeListener</code>函数控制它们何时监听。</p><p id="d857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将从第1部分继续，探索可用于控制事件发出和侦听方式的其他函数。<code class="fe lv lw lx ly b">EventEmitter</code>也有许多getter函数，用于获取我们定义的<code class="fe lv lw lx ly b">EventEmitter</code>的数据。</p><p id="7fb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得被监听事件的名称，我们可以使用<code class="fe lv lw lx ly b">eventNames</code>函数。该函数不带参数，返回一个事件标识符数组，其中可能包含字符串或符号。</p><p id="eef7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以在下面的代码中使用它:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="498f" class="md me it ly b gy mf mg l mh mi">const EventEmitter = require('events');<br/>const eventEmitter = new EventEmitter();<br/>eventEmitter.on('event1', () =&gt; {});<br/>eventEmitter.on('event2', () =&gt; {});</span><span id="3965" class="md me it ly b gy mj mg l mh mi">const sym = Symbol('event3');<br/>eventEmitter.on(sym, () =&gt; {});</span><span id="5ad7" class="md me it ly b gy mj mg l mh mi">console.log(eventEmitter.eventNames());</span></pre><p id="547d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行上面的代码时，我们记录了以下内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a3d0" class="md me it ly b gy mf mg l mh mi">[ 'event1', 'event2', Symbol(event3) ]</span></pre><p id="e11a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得可以附加到单个事件的最大数量的侦听器，我们可以使用<code class="fe lv lw lx ly b">getMaxListeners</code>函数。它不接受任何参数，并返回当前可附加到一个事件的最大侦听器数量。</p><p id="b1db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以附加到事件的事件监听器的最大数量可以由<code class="fe lv lw lx ly b">setMaxListeners</code>函数设置，默认值是10。例如，我们可以在下面的示例中使用它:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="338d" class="md me it ly b gy mf mg l mh mi">const EventEmitter = require('events');<br/>const eventEmitter = new EventEmitter();<br/>console.log(eventEmitter.getMaxListeners());</span></pre><p id="8af3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe lv lw lx ly b">listenerCount</code>函数来获取附加到一个事件的事件侦听器的数量。它采用一个字符串或符号参数作为事件名称，并返回一个整数，其中包含附加到事件的事件侦听器的数量，事件名称传递到参数中。</p><p id="6fff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以在下面的代码中使用它:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="67ee" class="md me it ly b gy mf mg l mh mi">const EventEmitter = require('events');<br/>const eventEmitter = new EventEmitter();</span><span id="23cb" class="md me it ly b gy mj mg l mh mi">for (let i = 1; i &lt;= 5; i++) {<br/>  eventEmitter.on('event', () =&gt; { });<br/>}</span><span id="cdaa" class="md me it ly b gy mj mg l mh mi">console.log(eventEmitter.listenerCount('event'));</span></pre><p id="3b6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果运行上面的代码，我们会得到5个日志，因为我们将5个事件侦听器附加到了<code class="fe lv lw lx ly b">event</code>事件。</p><p id="f75a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将事件监听器函数附加到给定的事件，我们可以使用<code class="fe lv lw lx ly b">listeners</code>函数。它接受带有事件名称的字符串或符号，并返回事件侦听器函数的数组。</p><p id="afb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它返回侦听器的副本，而不是原始副本。例如，我们可以在下面的例子中使用它:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b037" class="md me it ly b gy mf mg l mh mi">[ '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)' ]</span></pre><p id="135a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将一个事件监听器附加到给定事件的数组监听器的开头，我们可以使用<code class="fe lv lw lx ly b">prependListener</code>函数。</p><p id="119d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数将事件名称作为第一个参数，将事件侦听器函数作为第二个参数。例如，我们可以编写以下代码:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4547" class="md me it ly b gy mf mg l mh mi">const EventEmitter = require('events');<br/>const eventEmitter = new EventEmitter();</span><span id="9cd7" class="md me it ly b gy mj mg l mh mi">for (let i = 1; i &lt;= 5; i++) {<br/>  eventEmitter.on('event', () =&gt; console.log(`Listener ${i} for 'event' event invoked`));<br/>}</span><span id="3f81" class="md me it ly b gy mj mg l mh mi">eventEmitter.prependListener('event', () =&gt; console.log('Prepended listener invoked'))</span><span id="82a4" class="md me it ly b gy mj mg l mh mi">console.log(eventEmitter.listeners('event').map(f =&gt; f.toString()));</span></pre><p id="d0fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行上面的代码，我们会记录以下内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="2e9a" class="md me it ly b gy mf mg l mh mi">[ '() =&gt; console.log(\'Prepended listener invoked\')',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)' ]</span></pre><p id="d127" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，预先考虑的事件侦听器在数组的第一个槽中。如果我们添加<code class="fe lv lw lx ly b">eventEmitter.emit('event')</code>来发出<code class="fe lv lw lx ly b">event</code>事件，如下面的代码所示:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="c6f5" class="md me it ly b gy mf mg l mh mi">const EventEmitter = require('events');<br/>const eventEmitter = new EventEmitter();</span><span id="75ae" class="md me it ly b gy mj mg l mh mi">for (let i = 1; i &lt;= 5; i++) {<br/>  eventEmitter.on('event', () =&gt; console.log(`Listener ${i} for 'event' event invoked`));<br/>}</span><span id="2c82" class="md me it ly b gy mj mg l mh mi">eventEmitter.prependListener('event', () =&gt; console.log('Prepended listener invoked'))</span><span id="0f4c" class="md me it ly b gy mj mg l mh mi">console.log(eventEmitter.listeners('event').map(f =&gt; f.toString()));</span></pre><p id="1c59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们用<code class="fe lv lw lx ly b">console.log</code>语句记录了以下内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="3e7e" class="md me it ly b gy mf mg l mh mi">[ '() =&gt; console.log(\'Prepended listener invoked\')',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)' ]<br/>Prepended listener invoked<br/>Listener 1 for 'event' event invoked<br/>Listener 2 for 'event' event invoked<br/>Listener 3 for 'event' event invoked<br/>Listener 4 for 'event' event invoked<br/>Listener 5 for 'event' event invoked</span></pre><p id="12cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还看到，我们添加到事件侦听器数组中的侦听器首先被调用，因为侦听器的处理顺序与它们添加到数组中的顺序相同。</p><p id="7d77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想预先设置一个只处理一次发出事件的事件监听器，我们可以使用<code class="fe lv lw lx ly b">prependOnceListener</code>来代替。例如，我们可以在下面的代码中使用它:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="1373" class="md me it ly b gy mf mg l mh mi">const EventEmitter = require('events');<br/>const eventEmitter = new EventEmitter();<br/>for (let i = 1; i &lt;= 5; i++) {<br/>  eventEmitter.on('event', () =&gt; console.log(`Listener ${i} for 'event' event invoked`));<br/>}<br/>eventEmitter.prependOnceListener('event', () =&gt; console.log('Prepended once listener invoked'))</span><span id="898f" class="md me it ly b gy mj mg l mh mi">eventEmitter.emit('event');<br/>eventEmitter.emit('event');</span></pre><p id="4630" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行上面的代码，我们可以看到在<code class="fe lv lw lx ly b">console.log</code>语句中记录了以下内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="bf2e" class="md me it ly b gy mf mg l mh mi">Prepended once listener invoked<br/>Listener 1 for 'event' event invoked<br/>Listener 2 for 'event' event invoked<br/>Listener 3 for 'event' event invoked<br/>Listener 4 for 'event' event invoked<br/>Listener 5 for 'event' event invoked<br/>Listener 1 for 'event' event invoked<br/>Listener 2 for 'event' event invoked<br/>Listener 3 for 'event' event invoked<br/>Listener 4 for 'event' event invoked<br/>Listener 5 for 'event' event invoked</span></pre><p id="1f41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，我们用<code class="fe lv lw lx ly b">prependOnceListener</code>前置的监听器只运行一次。如果我们用<code class="fe lv lw lx ly b">prependOnceListener</code>函数附加一个<code class="fe lv lw lx ly b">event</code>监听器，这就是我们所期望的。</p><p id="a1c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要删除给定事件的所有事件监听器，我们可以使用<code class="fe lv lw lx ly b">removeAllListeners</code>函数。它采用一个字符串或符号参数作为事件标识符。</p><p id="65f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，当在程序的其他组件中创建<code class="fe lv lw lx ly b">EventEmitter</code>时，删除附加在代码中其他地方的事件监听器是一种不好的做法。它返回一个对<code class="fe lv lw lx ly b">EventEmitter</code>的引用，这样调用就可以被链接起来。</p><p id="381e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以编写以下代码来删除<code class="fe lv lw lx ly b">event</code>事件的所有事件侦听器:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d81e" class="md me it ly b gy mf mg l mh mi">const EventEmitter = require('events');<br/>const eventEmitter = new EventEmitter();<br/>for (let i = 1; i &lt;= 5; i++) {<br/>  eventEmitter.on('event', () =&gt; console.log(`Listener ${i} for 'event' event invoked`));<br/>}<br/>eventEmitter.prependOnceListener('event', () =&gt; console.log('Prepended once listener invoked'))</span><span id="8d70" class="md me it ly b gy mj mg l mh mi">console.log('Before remove all listeners\n', eventEmitter.listeners('event').map(f =&gt; f.toString()));</span><span id="e7d8" class="md me it ly b gy mj mg l mh mi">eventEmitter.removeAllListeners('event');</span><span id="aeef" class="md me it ly b gy mj mg l mh mi">console.log('After remove all listeners\n', eventEmitter.listeners('event'));</span></pre><p id="53d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当上面的代码运行时，我们记录了以下内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="9833" class="md me it ly b gy mf mg l mh mi">Before remove all listeners<br/> [ '() =&gt; console.log(\'Prepended once listener invoked\')',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)',<br/>  '() =&gt; console.log(`Listener ${i} for \'event\' event invoked`)' ]<br/>After remove all listeners<br/> []</span></pre><p id="51ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要删除给定事件的单个事件监听器，我们可以使用<code class="fe lv lw lx ly b">removeListener</code>函数。它接受一个带有事件标识符的字符串或符号的参数，以及一个对附加到给定事件的侦听器的引用。</p><p id="d188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它返回一个对<code class="fe lv lw lx ly b">EventEmitter</code>的引用，这样调用就可以被链接起来。我们可以在下面的代码中使用它:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e0dc" class="md me it ly b gy mf mg l mh mi">const EventEmitter = require('events');<br/>const eventEmitter = new EventEmitter();</span><span id="6f0b" class="md me it ly b gy mj mg l mh mi">const listener1 = () =&gt; console.log('listener1 invoked');<br/>const listener2 = () =&gt; console.log('listener2 invoked');</span><span id="130b" class="md me it ly b gy mj mg l mh mi">eventEmitter.on('event', listener1);<br/>eventEmitter.on('event', listener2);</span><span id="9707" class="md me it ly b gy mj mg l mh mi">console.log('Before remove listeners\n', eventEmitter.listeners('event').length);</span><span id="6d7a" class="md me it ly b gy mj mg l mh mi">eventEmitter<br/>  .removeListener('event', listener1)<br/>  .removeListener('event', listener2);</span><span id="1cad" class="md me it ly b gy mj mg l mh mi">console.log('After remove listeners\n', eventEmitter.listeners('event').length);</span></pre><p id="8207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行上面的代码时，我们用<code class="fe lv lw lx ly b">console.log</code>语句记录了以下内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="babc" class="md me it ly b gy mf mg l mh mi">Before remove listeners<br/> 2<br/>After remove listeners<br/> 0</span></pre><p id="e273" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，<code class="fe lv lw lx ly b">removeListener</code>可以被链接起来，让我们一次删除一个监听器。被删除的侦听器不再侦听事件。</p><p id="9d5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个侦听器被多次附加到一个事件，那么它可能被称为事件侦听器被附加以移除所有事件侦听器的次数。</p><p id="4b88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在这个场景中调用一次<code class="fe lv lw lx ly b">removeListener</code>函数，它将删除最近添加的事件监听器。移除事件侦听器后，将更新给定事件的事件侦听器数组。</p><p id="4d9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得一个事件的事件监听器数组，包括包装器，我们可以使用<code class="fe lv lw lx ly b">rawListeners</code>函数。例如，我们可以将其用作以下代码:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="27ca" class="md me it ly b gy mf mg l mh mi">const EventEmitter = require('events');<br/>const eventEmitter = new EventEmitter();</span><span id="91e4" class="md me it ly b gy mj mg l mh mi">const listener1 = () =&gt; console.log('listener1 invoked');<br/>const listener2 = () =&gt; console.log('listener2 invoked');</span><span id="c336" class="md me it ly b gy mj mg l mh mi">eventEmitter.once('event', listener1);<br/>eventEmitter.on('event', listener2);</span><span id="7893" class="md me it ly b gy mj mg l mh mi">const rawListeners = eventEmitter.rawListeners('event');<br/>rawListeners[0].listener();</span></pre><p id="e6e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行上面的代码，我们会看到<code class="fe lv lw lx ly b">listener1 invoked</code>被记录。这是因为<code class="fe lv lw lx ly b">eventEmitter.once</code>包装了传递给它的监听器函数。</p><p id="157a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将与实际的事件侦听器一起返回。因此，我们可以通过运行<code class="fe lv lw lx ly b">rawListeners[0].listener();</code>来运行实际的事件监听器函数。</p><p id="7ec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对第二个侦听器不起作用，因为当我们调用<code class="fe lv lw lx ly b">eventEmitter.on</code>来附加一个侦听器时，没有包装器来包装侦听器函数。</p><p id="cd40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Node.js的一个重要特性就是异步编程。这意味着Node.js中的代码可能不会按顺序执行。因此，数据可能无法在固定的时间内确定。</p><p id="a80a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着，为了获得我们需要的所有数据，我们必须在获得数据时在应用程序中传递数据。我们可以发出事件并在Node.js应用程序中处理它们。</p><p id="92af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当发出具有给定名称的事件时，如果侦听器被指定侦听具有该名称的事件，则该事件可以侦听侦听器。事件发射器函数被同步调用。</p><p id="c26f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事件侦听器代码是一个回调函数，它接受数据的参数并对其进行处理。Node.js有一个<code class="fe lv lw lx ly b">EventEmitter</code>类，可以通过我们创建的一个新类来扩展，以发出可以被事件监听器监听的事件。</p><p id="ea37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">EventEmitter</code>类，我们可以添加和删除带有内置函数的事件监听器。我们可以同时或一次移除一个。</p><p id="6307" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们不应该从不是我们编写的事件发射器中移除监听器，因为这会给其他正在编写代码的人造成混乱，因为其他程序员不希望从其他模块中移除内置监听器。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="06ed" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">资源</h1><ul class=""><li id="3b28" class="ni nj it lb b lc nk lf nl li nm lm nn lq no lu np nq nr ns bi translated"><a class="ae ky" href="https://medium.com/better-programming/using-events-in-node-js-the-basics-9a9c44dcbe30" rel="noopener">使用Node.js中的事件(第1部分)</a></li></ul></div></div>    
</body>
</html>