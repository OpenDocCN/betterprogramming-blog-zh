<html>
<head>
<title>5 Advanced Python Concepts: Explanations and Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5个高级Python概念:解释和应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-advanced-python-concepts-explanations-and-applications-99a03f6bd1bd?source=collection_archive---------1-----------------------#2020-08-20">https://betterprogramming.pub/5-advanced-python-concepts-explanations-and-applications-99a03f6bd1bd?source=collection_archive---------1-----------------------#2020-08-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7265" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Lambda函数、理解、生成器、装饰器和哈希能力</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/39e5253dd8eb3527fce7ca2c98d9594b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pDcty_1TiSc1vNUk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@nasa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NASA </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f072" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您对基本数据结构及其关键功能有了很好的理解后，就该探索Python中的一些更高级的技术了。在本文中，我想回顾一下您可以在代码中利用的五个概念。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9ddb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.λ函数</h1><p id="c799" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Lambda函数在Python中也被称为匿名函数。有些人干脆称它们为兰姆达斯。它们的语法如下:<code class="fe mz na nb nc b">lambda arguments: expression</code>。本质上，我们使用lambda关键字来表示lambda函数的声明。然后我们列出自变量，自变量的数量可以是零，也可以是更多。在冒号后面，我们列出了使用这些参数进行任何适用操作的表达式。</p><p id="31f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Lambda函数在我们需要短期一次性使用函数的情况下特别有用。例如，几个内置函数有key参数，我们可以为它设置一个lambda函数。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用Lambda函数排序</p></figure><p id="3ba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们想要对元组列表进行排序。默认情况下，元组将根据包含的每个项目进行排序。在这种情况下，排序基于姓名的首字母。然而，我们想通过分数来求解，分数是元组的第二项。为了实现这一点，我们利用了lambda函数，其中的<code class="fe mz na nb nc b">x</code>参数引用了要排序的每个元组。因为分数是每个元组中的第二项，所以我们只需要指定索引1来访问第二项。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f853" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak"> 2。理解</strong></h1><p id="9dc4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可能被提到最多的例子是理解技巧。<strong class="lb iu">本质上，这种技术允许我们使用现有的iterable </strong>创建一个列表、字典或集合，它们分别被命名为列表理解、字典理解和集合理解。以下代码片段向您展示了这些用法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">（听力或阅读）理解测试</p></figure><p id="8242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些理解的语法看起来相似。这里有一个微分形式的快速突出。需要注意的是，你可以添加条件来保留你需要的物品。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="01f7" class="nj md it nc b gy nk nl l nm nn"><strong class="nc iu">List Comprehension:</strong> [expr for x in iterable]<br/><strong class="nc iu">Dictionary Comprehension:</strong> {key_expr: value_expr for x in iterable}<br/><strong class="nc iu">Set Comprehension:</strong> {expr for x in iterable}</span><span id="27df" class="nj md it nc b gy no nl l nm nn"><strong class="nc iu">With Optional Conditions:</strong><br/>[expr for x in iterable if condition]<br/>{key_expr: value_expr for x in iterable if condition}<br/>{expr for x in iterable if condition}</span></pre><p id="33f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些理解可以非常方便地创建这些容器数据类型，而不是实现for循环。更重要的是，<strong class="lb iu">它们通常比for循环更快，因此性能更好</strong>，应该是这些操作的首选方式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a96e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.发电机</h1><p id="60f8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">之前，我提到过iterables，它指的是可以迭代的Python对象。在迭代过程中，iterable被转换为迭代器，以便迭代器可以在需要时呈现元素。一种特殊的迭代器是生成器。与列表和字典等典型的可迭代对象不同，它们的所有元素都被加载到内存中，生成器以一种懒惰的方式生成元素，而不需要将所有元素都加载到内存中，因此它们是内存高效的可迭代对象。下面的代码片段显示了一个简单的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单的生成器示例</p></figure><p id="6561" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，generator函数使用了关键字<code class="fe mz na nb nc b">yield</code>来生成一个生成器。在迭代过程中，这些元素按顺序呈现。</p><p id="9fc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器的一个实际使用案例是处理大量数据——当所有数据都被加载时，它可能会降低计算机的速度，或者根本无法加载，因为数据量非常大。例如，一个简单的例子是计算整数1-10，000，000，000的和。我在电脑上试了10亿，发现大小在8 GB左右。所以，如果我尝试的话，100亿大约是80 GB，这可能会使程序甚至我的电脑崩溃。由于无法创建列表，我无法使用列表来计算总数。在这种情况下，我们应该考虑发电机。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生成器用例</p></figure><p id="d873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，我们可以创建一个生成器，一次生成一个整数，这样可以节省内存。上面的代码片段向您展示了另一种称为生成器表达式的有用技术，它的格式如下:<code class="fe mz na nb nc b">(expr for item in iterable)</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b50b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.装修工</h1><p id="c4c4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">装饰器是高阶函数，它修改其他函数的行为，而不影响它们的核心功能。你可以把其他功能想象成普通的甜甜圈；装饰就是给甜甜圈涂上涂层的过程。不管你怎么装饰它们，它们还是甜甜圈。换句话说，decorators只是在函数的外观或其他一些非本质方面做了一些调整，而没有改变它们的内部算法。让我们用一个简单的例子来看看装饰者。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">装饰者示例</p></figure><p id="109d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子向你展示了如何声明一个装饰函数，以及如何用它来装饰其他函数。如你所见，装饰函数<code class="fe mz na nb nc b">timing</code>将另一个函数作为参数，它记录了被装饰函数的运行时间。值得注意的是，修饰函数返回函数作为其输出。要使用decorator，我们只需使用@符号作为前缀，将它放在另一个函数的顶部，这表明下面声明的函数是由这个指定的decorator函数修饰的。下面的代码向您展示了装修是什么样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">计时功能</p></figure><p id="eb18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现许多关于装饰者的教程都没有提到的一件事是@wraps decorator在装饰函数声明中的使用。我强烈推荐使用它(参见前面的代码片段的第6行)，原因在我之前的博客文章中已经介绍过了。</p><div class="np nq gp gr nr ns"><a href="https://towardsdatascience.com/why-you-should-wrap-decorators-in-python-5ac3676835f9" rel="noopener follow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">为什么应该用Python包装Decorators</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">利用functools.wraps</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og ks ns"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="90ce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.哈希能力</h1><p id="3639" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们学习Python字典时，我们知道键需要是可散列的。hashable是什么意思？Hashable仅仅意味着一个特定的Python对象可以被散列，其过程被称为散列。下图显示了哈希工作原理的简化流程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/925ff2328d442af0981a05f61a2646a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/0*UHQjkLCsW2fsfQL2.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">哈希的一般过程(<a class="ae ky" href="https://en.wikipedia.org/wiki/Hash_function" rel="noopener ugc nofollow" target="_blank">维基百科</a>，公共领域)</p></figure><p id="ed95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从本质上来说，散列是使用散列函数(有时称为hasher)将Python对象(图中称为键)转换为数字散列值(图中称为散列)的过程。判断特定Python对象的一个快速方法是使用内置的<code class="fe mz na nb nc b">hash()</code>函数获取哈希值。如果对象不可散列，Python将为我们抛出一个<code class="fe mz na nb nc b">TypeError</code>异常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">哈希能力和哈希</p></figure><p id="dfb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，散列需要时间，可能比构建列表和元组要慢。所以问题是——我们为什么要费心使用哈希来实现字典呢？另外，您可能听说过集合中的元素也需要是可哈希的。在幕后，创建字典和集合都需要构建哈希表。下面的代码片段向您展示了特定对象的可散列性如何影响它们用作字典键的资格。</p><p id="4099" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用哈希的最大优势是在字典中获取元素的即时查找时间(即O(1)时间复杂度)。类似地，检查一个特定的项目是否在集合中也需要一个固定的时间。换句话说，使用散列作为实现机制为各种常见的操作提供了高效率，例如项目检索、项目插入和项目检查，代价是在幕后拥有散列表的开销。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">常数查找时间</p></figure><p id="7b24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了模拟真实的情况，我们生成一些随机的整数来获得项目获取的平均查找时间。如您所见，即使字典中有100，000个条目，查找时间也保持不变，这突出了实现哈希表作为字典存储机制的优势。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="58b1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="38dd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们回顾了Python中的五个高级概念。以下是最关键的外卖信息的快速回顾。</p><ul class=""><li id="785d" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu on oo op oq bi translated"><strong class="lb iu">λ函数。</strong>你使用lambda函数进行简单的操作，通常是在另一个函数调用中，比如<code class="fe mz na nb nc b">sorted()</code>或者<code class="fe mz na nb nc b">max()</code>。</li><li id="a440" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><strong class="lb iu">理解。</strong>它们是从可重复项创建列表、字典和集合的方便而有效的方法。</li><li id="f272" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><strong class="lb iu">发电机。生成器是延迟求值的迭代器，仅在被请求时才呈现项目，因此它们非常节省内存。当您按顺序处理大量数据时，应该使用它们。</strong></li><li id="bf2f" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><strong class="lb iu">装修工。当你想对当前函数进行一些非算法的修改时，Decorators非常有用。另外，装饰者可以重复使用。一旦定义好了，它们就可以随心所欲地修饰许多功能。</strong></li><li id="a842" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><strong class="lb iu">具有适应性。</strong> Hashability是Python对象的必需特性，可以用作字典键或集合元素。它们提供了一种高效的项目检索和插入机制，以及成员检查机制。</li></ul></div></div>    
</body>
</html>