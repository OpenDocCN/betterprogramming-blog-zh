<html>
<head>
<title>Simplify Your React Component’s State With a State Machine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用状态机简化React组件的状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/simplify-your-react-components-state-with-a-state-machine-8e9c9a4ee1f6?source=collection_archive---------1-----------------------#2022-08-28">https://betterprogramming.pub/simplify-your-react-components-state-with-a-state-machine-8e9c9a4ee1f6?source=collection_archive---------1-----------------------#2022-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a926" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用<strong class="ak">减速器</strong>不费吹灰之力实现全类型状态机。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/54f8604777003680995142ed88e298c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EO_DecLJ6-ex0ELT"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">蒂莫·沃尔茨在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="fe36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为React开发人员，我们都不得不在状态变得无法管理的组件上工作。在我们修改它之前，它可能是一个笨拙而有效的组件。我们添加的一点点额外代码又给组件制造了一个崩溃的机会。裂缝很快开始出现。</p><p id="eb17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种恐怖故事通常涉及组件有条件地做事情或显示东西，并且组件的可能状态有很多。</p><h1 id="27ae" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">走错路的旅行</h1><p id="7ae5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我带你一起踏上一段旅程，在这段旅程中，实现一个简单的组件很快就会走错方向。</p><p id="efbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们被要求实现一个写着<strong class="ky ir">的“启动”按钮💥点击时发出砰的一声。酷，我们声明一个按钮，点击时改变它的状态，根据它的状态设置文本，我们就完成了:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8a15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，一切顺利。</p><p id="4989" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们被告知需要在点击按钮时调用一个名为<code class="fe mr ms mt mu b">fire</code>的函数。这是一个需要时间来完成的异步功能。所以我们应该显示文本<strong class="ky ir">🚀在等待的时候开火。</strong></p><p id="0a52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧…所以当用户点击按钮的时候，我们要记住<code class="fe mr ms mt mu b">fire</code>已经被调用了，但是还没有触发。所以我们添加另一个布尔as状态，我们称之为<code class="fe mr ms mt mu b">firing</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="fc2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，那有点天真。如果我们运行这段代码并点击按钮，它只会说<strong class="ky ir">🚀无限期开火。发现错误了吗？是的，我们忘记在操作完成后重置<code class="fe mr ms mt mu b">firing</code>状态。所以我们现在处于一个无人区，在这里<code class="fe mr ms mt mu b">firing</code>和<code class="fe mr ms mt mu b">fired</code>同时都是真的。</strong></p><p id="1195" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，让我们来修复这个处理程序:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="758a" class="mz lt iq mu b gy na nb l nc nd">const handleClick = async () =&gt; {<br/>  setFiring(true);<br/>  await fire();<br/>  <strong class="mu ir">setFiring(false);</strong><br/>  setFired(true);<br/>};</span></pre><p id="8979" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是等等！如果用户想重新开火，再次点击按钮怎么办？我们还需要在函数开始时重置<code class="fe mr ms mt mu b">fired</code>标志:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="1339" class="mz lt iq mu b gy na nb l nc nd">const handleClick = async () =&gt; {<br/>  <strong class="mu ir">setFired(false);</strong><br/>  setFiring(true);<br/>  await fire();<br/>  setFiring(false);<br/>  setFired(true);<br/>};</span></pre><p id="88db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有案件处理完毕！</p><p id="3fd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">咚咚咚。新的要求来了！我忘记说了，但是<code class="fe mr ms mt mu b">fire</code>功能可能会不时地失败……当这种情况发生时，我们希望将文本改为<strong class="ky ir">🤷哦…' </strong>并防止再次发生火灾(健康和安全，你知道…)</p><p id="5b4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">咩！再来一面旗子，就搞定了。<code class="fe mr ms mt mu b">faulted</code>怎么样？我们可以使用一个<strong class="ky ir"> try-catch </strong>块来设置它。如果设置了<code class="fe mr ms mt mu b">faulted</code>标志，我们将忽略点击。<br/>此外，我们不要忘记在发生这种情况时重置其他标志，因为我们刚刚了解到…</p><p id="8d22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="f1f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯……让我们再读几遍，以确保它是正确的。是的，我想是的。实现起来并不难，不是吗？真的，还不算太糟。</p><p id="178b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几天或几周后，新的需求出现了。我们已经忘记了这个代码。现在看起来不再那么清晰了。我们可能需要向它添加更多的状态，改变条件或者添加更多的UI来改变当前的状态。事实是，我们已经为裂缝的出现创造了机会。如果我们不注意，随着要处理的案例数量不断增加，组件最终将处于一种不可能的状态。</p><h1 id="ef1c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们能做得更好吗？</h1><p id="d8d7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们当然可以！</p><p id="23a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有经验的开发人员会注意到组件只能处于几种状态:</p><ul class=""><li id="ea93" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><code class="fe mr ms mt mu b">initial</code>:按钮没有被交互</li><li id="cd30" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe mr ms mt mu b">firing</code>:我们已经给<code class="fe mr ms mt mu b">fire</code>打了电话，正在等待完成</li><li id="fe89" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe mr ms mt mu b">fired</code> : <code class="fe mr ms mt mu b">fire</code>已成功完成</li><li id="bbab" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe mr ms mt mu b">faulted</code> : <code class="fe mr ms mt mu b">fire</code>失败</li></ul><p id="1c4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们可以只用一个枚举来存储当前状态，而不是三个布尔。使用这个枚举，我们只需要处理4种情况(可能的状态)，而不是潜在的8种情况(2^3，3个布尔值的可能组合的数量)。</p><p id="78cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但还有更多！以前使用过<code class="fe mr ms mt mu b"><a class="ae kv" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">useReducer</a></code>钩子的开发人员知道，reducers提供了一种管理复杂状态和避免不一致的好方法。这个想法是，你分派一个动作(比如:‘fire’…)，reducer负责剩下的，返回一个新的状态。</p><p id="b7e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们刚刚说过，我们的组件只能处于多种状态(fire，fired…)，而且<code class="fe mr ms mt mu b"><a class="ae kv" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">useReducer</a></code>可以用于管理状态和调度动作(“fire”…)。</p><p id="31c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对我来说，这听起来很像一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="noopener ugc nofollow" target="_blank">状态机</a>:</p><blockquote class="ns nt nu"><p id="fe84" class="kw kx nv ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated">一个<strong class="ky ir">有限状态机</strong> ( <strong class="ky ir"> FSM </strong> ) […]或者简称为<strong class="ky ir">状态机</strong>，是一个数学<a class="ae kv" href="https://en.wikipedia.org/wiki/Model_of_computation" rel="noopener ugc nofollow" target="_blank">计算模型</a>。它是一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Abstract_machine" rel="noopener ugc nofollow" target="_blank">抽象机器</a>，在任何给定的时间，它可以处于有限个<a class="ae kv" href="https://en.wikipedia.org/wiki/State_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <em class="iq">状态</em> </a>中的一个状态。FSM可以根据某些<a class="ae kv" href="https://en.wikipedia.org/wiki/Input_(computer_science)" rel="noopener ugc nofollow" target="_blank">输入</a>从一种状态变为另一种状态；从一种状态到另一种状态的变化称为<em class="iq">转换</em>。</p></blockquote><p id="f243" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，按照<code class="fe mr ms mt mu b">useReducer</code>的行话，我们只是把这些转换<em class="nv">动作叫做</em>。但是是一样的。这些转变有时也被称为<em class="nv">事件</em>。</p><h1 id="5ad9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">状态机宝宝！</h1><p id="d2e7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">因此，让我们尝试用我们已经确定的状态和事件(转换)来绘制一个模式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/14e232d477bfe9deef8a1089e3568003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*MY-24voTFIum_cyq6pQQ5w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Fire按钮，表示为状态机</p></figure><p id="98a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以用TypeScript枚举状态和事件，并编写一个从一种状态转换到另一种状态的<code class="fe mr ms mt mu b">reducer</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ed8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，我们已经将状态机转换为一个<code class="fe mr ms mt mu b">switch</code>语句，该语句查看当前状态并基于接收到的事件返回一个新状态。<code class="fe mr ms mt mu b">Initial</code>和<code class="fe mr ms mt mu b">Fired</code>状态已经合并在一起，因为它们以相同的方式处理“火灾”事件，并且<code class="fe mr ms mt mu b">Faulted</code>已经从语句中省略，因为它是一个死胡同(没有从该状态出来的转换)。</p><p id="c912" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，请注意，我们已经使用了<code class="fe mr ms mt mu b">Reducer&lt;ButtonState, ButtonEvent&gt;</code>来强制状态和动作的类型(或者在本例中是<em class="nv">事件</em>)被reducer接受。这将在我们使用它时给我们类型安全和正确的完成。</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="6665" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一个旁注，我觉得我必须提到<code class="fe mr ms mt mu b">ButtonState</code>和<code class="fe mr ms mt mu b">ButtonEvent</code>可以使用<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">文字类型</strong> </a>来声明:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="b596" class="mz lt iq mu b gy na nb l nc nd"><em class="nv">type ButtonState = "initial" | "firing" | "fired" | "faulted";<br/>type ButtonEvent = "fire" | "success" | "fail";</em></span></pre><p id="110b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个比较简洁，我经常看到在状态机中使用。它也比枚举更有效，因为TypeScript不必为它发出额外的JavaScript。</p><p id="bcf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想你可以叫我布玛儿，因为我仍然在这里使用枚举。不要像我一样！</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="a883" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们有一个健壮的、全类型的状态机。要使用它，我们所要做就是用函数<code class="fe mr ms mt mu b">reducer</code>调用<code class="fe mr ms mt mu b">useReducer</code>并指定初始状态。钩子将返回当前状态和一个我们可以调用来触发转换的<code class="fe mr ms mt mu b">dispatch</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a8a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它变短了吗？也许吧。不确定。为了清晰起见，我们稍微改变了设置按钮文本的方式，仍然有添加进去的<strong class="ky ir">缩减器</strong>的代码。</p><p id="3a57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但更重要的是，我们已经消除了无效状态的风险，并将所有状态逻辑提取到一个地方。组件本身的声明性更强，因此更容易阅读，并且不再需要担心导致状态改变的许多条件。</p><h1 id="1388" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">就这些吗？</h1><p id="5692" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">是的，就这些。在React中实现状态机非常简单。这很好，因为它允许我们关注我们的状态机应该是什么样的，而不是如何实现它们。</p><p id="f732" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，我们可以通过在<strong class="ky ir"> reducer </strong>、<strong class="ky ir"> </strong>中使用<code class="fe mr ms mt mu b">console.warn</code>来进一步改进代码，以防被调度的事件在当前状态下不受支持(或者抛出一个错误，<em class="nv"> #FailFast </em>)。在这个例子中，我们决定简单地忽略它并返回到当前状态。</p><p id="b22f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果你想寻找更多，你可能想去看看<code class="fe mr ms mt mu b"><a class="ae kv" href="https://xstate.js.org/docs/" rel="noopener ugc nofollow" target="_blank">XState</a></code>。它可以说是目前实现状态机的最好和最全面的库。我之前做的模式实际上是用他们的可视化编辑器设计的，<a class="ae kv" href="https://stately.ai/" rel="noopener ugc nofollow" target="_blank">庄严的</a>。你甚至可以让它为你生成代码！只是要注意<a class="ae kv" href="https://xstate.js.org/docs/guides/typescript.html" rel="noopener ugc nofollow" target="_blank">类型脚本支持不是为胆小的</a>准备的，所以你可能想把它留给更高级的用例。</p></div></div>    
</body>
</html>