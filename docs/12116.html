<html>
<head>
<title>build.gradle: The Source File I Used to Neglect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">build.gradle:我曾经忽略的源文件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-gradle-the-source-file-we-tend-to-neglect-b05d728b42c4?source=collection_archive---------7-----------------------#2022-05-12">https://betterprogramming.pub/build-gradle-the-source-file-we-tend-to-neglect-b05d728b42c4?source=collection_archive---------7-----------------------#2022-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="534b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解build.gradle的基础知识</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/162e45f9931cb9f1d6aeddaacc2ad074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IJdzQ6gV5UuZnkiQ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/es/@duc154?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">đức trịnh</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0321" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章不会包含关于Gradle和Groovy/Kotlin的扩展信息。主要目的是为Android开发者的日常任务提供基本的“提示和技巧”。</p><p id="71fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有什么比忽视一个<code class="fe ls lt lu lv b"><strong class="ky ir">build.gradle</strong></code>文件更糟糕的呢？忽略了两个<code class="fe ls lt lu lv b"><strong class="ky ir">build.gradle</strong></code>文件！事情还会更糟吗？当然，你可以在你的应用程序中添加更多的模块，这样你就可以忽略更多的构建文件了！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="6b9b" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">这些文件有什么区别？</h1><p id="ab4c" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">有一个顶级的Gradle文件。在Android Studio中，你会看到它是<code class="fe ls lt lu lv b">build.gradle (Project: project_name)</code>和每个模块的另一个构建文件<code class="fe ls lt lu lv b">build.gradle (Module: project_name.module_name)</code>。<br/>顶层构建文件通过<code class="fe ls lt lu lv b">buildscript</code>为Gradle本身提供配置，通过<code class="fe ls lt lu lv b">allprojects</code>为项目的所有模块提供配置。<br/>模块的构建文件提供了其所属模块的配置和执行细节。</p><h1 id="2b13" class="md me iq bd mf mg na mi mj mk nb mm mn jw nc jx mp jz nd ka mr kc ne kd mt mu bi translated">在Android Studio中查看所有Gradle任务</h1><p id="4953" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在Android Studio中，你可以在IDE的这一部分看到所有Gradle任务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/17efcd91be3da25c258a2ba5ff574a4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*ZCbsE5otCuTKkzgQZtci6g.png"/></div></figure><p id="ba71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你没有看到<code class="fe ls lt lu lv b">Tasks</code>文件夹，我不能给你更多关于如何让它工作的信息…但是<em class="ng">莱米特</em>绝对可以给你<a class="ae kv" href="https://stackoverflow.com/a/67406955" rel="noopener ugc nofollow" target="_blank">指路</a>。<br/>现在已经显示了<code class="fe ls lt lu lv b">Tasks</code>，你可以双击运行其中的任何一个。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="0186" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">让我们编码</h1><p id="b911" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">对于这个例子，我们假设我们的项目有两种风格(<code class="fe ls lt lu lv b">simple</code>、<code class="fe ls lt lu lv b">advanced</code>)。</p><h1 id="7ff6" class="md me iq bd mf mg na mi mj mk nb mm mn jw nc jx mp jz nd ka mr kc ne kd mt mu bi translated">从公共回购插入库</h1><p id="4bd4" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">插入库的通常方法是转到每个模块的构建文件的<code class="fe ls lt lu lv b">dependencies</code>部分，并编写<code class="fe ls lt lu lv b">implementation 'androidx.appcompat:appcompat:1.2.0'</code>。</p><h1 id="375f" class="md me iq bd mf mg na mi mj mk nb mm mn jw nc jx mp jz nd ka mr kc ne kd mt mu bi translated">每种口味的依赖性</h1><p id="a6b5" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们可以为每种风格添加一个新的库依赖。这可以通过编写<code class="fe ls lt lu lv b">simpleImplementation 'androidx.appcompat:appcompat:1.2.0'</code>为我们的应用程序的<code class="fe ls lt lu lv b">simple</code>风格添加一个依赖项来实现。</p><h1 id="c7e4" class="md me iq bd mf mg na mi mj mk nb mm mn jw nc jx mp jz nd ka mr kc ne kd mt mu bi translated">为本地文件夹或存储库插入库</h1><p id="143e" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在某些特殊情况下，我们可能需要从本地文件夹添加依赖项。通常我们将库添加到将要使用的模块的<code class="fe ls lt lu lv b">libs</code>文件夹中。</p><blockquote class="nh ni nj"><p id="4abb" class="kw kx ng ky b kz la jr lb lc ld ju le nk lg lh li nl lk ll lm nm lo lp lq lr ij bi translated">对于我们的例子，假设我们有一个本地图书馆“balloon.aar”。<br/>这个库是<a class="ae kv" href="https://github.com/skydoves/Balloon" rel="noopener ugc nofollow" target="_blank"> skydoves/Balloon </a>，我下载它是为了演示。</p></blockquote><p id="11d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想在你的<code class="fe ls lt lu lv b">libs</code>文件夹下添加所有风格的库，你可以把<code class="fe ls lt lu lv b">implementation fileTree(dir: 'libs', include:['*.aar'])</code>写到每个模块的构建文件的<code class="fe ls lt lu lv b">dependencies</code>部分。</p><p id="298c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">除了添加一个像文件一样的库，你还可以让一个文件夹的行为像一个仓库</strong>。我们应该在顶层编译文件中编写<code class="fe ls lt lu lv b">flatDir { dirs “repo" }</code>,如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="fafb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们已经准备好添加库，放在<code class="fe ls lt lu lv b">repo</code>文件夹下，通过将<code class="fe ls lt lu lv b">implementation (name:"balloon", ext:"aar")</code>写到每个模块的构建文件的<code class="fe ls lt lu lv b">dependencies</code>部分。</p><h1 id="6cda" class="md me iq bd mf mg na mi mj mk nb mm mn jw nc jx mp jz nd ka mr kc ne kd mt mu bi translated">梯度阶段</h1><p id="bffe" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">Gradle有3个不同的<a class="ae kv" href="https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:build_phases" rel="noopener ugc nofollow" target="_blank">构建阶段</a>。在本节中，我们将看到如何为<strong class="ky ir">配置</strong>和<strong class="ky ir">执行</strong>阶段编写构建指令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d31c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">doFirst</code>和<code class="fe ls lt lu lv b">doLast</code>将进入<strong class="ky ir">执行</strong>阶段，但这两个程序块之外的任何程序块都将在<strong class="ky ir">配置</strong>期间执行。<br/>假设您想要运行一个名为<code class="fe ls lt lu lv b">anotherTask</code>的任务，您将在运行控制台输出中看到<code class="fe ls lt lu lv b">a1SampleTask</code>的行<code class="fe ls lt lu lv b">A1 -&gt; Configuration phase</code>。无论您选择执行哪个任务，任务的配置都会一直发生。</p><h1 id="c0cd" class="md me iq bd mf mg na mi mj mk nb mm mn jw nc jx mp jz nd ka mr kc ne kd mt mu bi translated">结合任务</h1><p id="86dd" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">假设您有两个任务(<code class="fe ls lt lu lv b">a1SampleTask</code>、<code class="fe ls lt lu lv b">a2SampleTask</code>)，您希望在它们之间建立一些联系。<br/>如果你想执行<code class="fe ls lt lu lv b">a2SampleTask</code>但是<code class="fe ls lt lu lv b">a1SampleTask</code>应该总是在前面运行，你可以通过彼此依赖来绑定它们(<code class="fe ls lt lu lv b">a2SampleTask.dependsOn(a1SampleTask)</code>)。<br/>一个轻得多的键合是<code class="fe ls lt lu lv b">a2SampleTask.mustRunAfter(a1SampleTask)</code>。当你单独执行<code class="fe ls lt lu lv b">a2SampleTask</code>时，它不会运行<code class="fe ls lt lu lv b">a1SampleTask</code>。但是，如果你想同时执行<code class="fe ls lt lu lv b">a2SampleTask</code>和<code class="fe ls lt lu lv b">a1SampleTask</code>，它总是在<code class="fe ls lt lu lv b">a2SampleTask</code>之前执行<code class="fe ls lt lu lv b">a1SampleTask</code>。</p><h1 id="e7e6" class="md me iq bd mf mg na mi mj mk nb mm mn jw nc jx mp jz nd ka mr kc ne kd mt mu bi translated">动态任务</h1><p id="02ac" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">有些任务依赖于从一开始就不存在的任务。有些任务和属性是稍后创建的，例如应用程序变体。<br/>你不能像我们之前看到的那样创建一个任务，并使用像<code class="fe ls lt lu lv b">simpleDebugSampleTask</code>这样的变体。如果您想在安装应用程序后运行它(这使您依赖于应用程序变体)，您应该创建一个动态任务，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="aaf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，您必须在创建自己的任务之前检查<code class="fe ls lt lu lv b">variant</code>及其<code class="fe ls lt lu lv b">install</code>任务，该任务也是动态的。</p><h1 id="acef" class="md me iq bd mf mg na mi mj mk nb mm mn jw nc jx mp jz nd ka mr kc ne kd mt mu bi translated">插件实现</h1><p id="a7e4" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们有两种方法为Gradle编写插件(<strong class="ky ir">二进制插件</strong>和<strong class="ky ir">脚本插件</strong>)。在本例中，我们将创建一个动态任务来修改导出的apk文件的名称。<br/>在<code class="fe ls lt lu lv b">app</code>模块中新建一个文件<code class="fe ls lt lu lv b">outputFilesHandling.gradle</code>，并在其中创建一个动态任务(用于重命名导出的apk文件)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="babb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后你可以去你的<code class="fe ls lt lu lv b">app</code>模块，应用这个任务(<code class="fe ls lt lu lv b">apply from: outputFilesHandling.gradle"</code>)。确保使用<code class="fe ls lt lu lv b">apply from</code>而不是<code class="fe ls lt lu lv b">apply plugin</code>。</p><p id="cc18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">脚本插件足以应对我们的大多数挑战。如果你想进一步实现并公开分享你的插件，你必须使用二进制插件。沙鲁克可以<a class="ae kv" href="https://proandroiddev.com/gradlepluginandroidsdk-8a2494cbd238" rel="noopener ugc nofollow" target="_blank">帮你</a>做这个！</p><h1 id="59b8" class="md me iq bd mf mg na mi mj mk nb mm mn jw nc jx mp jz nd ka mr kc ne kd mt mu bi translated">本指南的项目</h1><p id="eb82" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">如果你想看到以上所有内容和更多的Android属性，请访问我的示例项目。</p></div></div>    
</body>
</html>