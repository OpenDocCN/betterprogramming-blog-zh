<html>
<head>
<title>Managing Focus in SwiftUI List Views</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI列表视图中管理焦点</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/managing-focus-in-swiftui-list-views-286b139e6bca?source=collection_archive---------9-----------------------#2021-11-09">https://betterprogramming.pub/managing-focus-in-swiftui-list-views-286b139e6bca?source=collection_archive---------9-----------------------#2021-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="6830" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">高级SwiftUI列表视图</h2><div class=""/><div class=""><h2 id="36d1" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">看看focus state——iOS 15引入的新属性包装器</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/fbcb13571f1879fe768d8b5b596917ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lpHKpPcLcobDZgYvuYdpaw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><em class="lh">基于SF符号</em>中“范围”图标的图像</p></figure><p id="ddd0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">管理焦点对于几乎任何类型的UI来说都是一个重要的方面——正确地管理焦点可以帮助你的用户更快更有效地浏览你的应用。在桌面用户界面中，我们希望能够通过按tab键来浏览表单上的输入字段，在移动设备上这一点同样重要。例如，在苹果的提醒应用程序中，光标会自动放置在你创建的任何新提醒中，当你点击enter键时，光标会前进到下一行。这样，您可以非常高效地添加新元素。</p><p id="3807" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">苹果在最新版本的SwiftUI中增加了对处理焦点的支持——这包括设置和观察焦点。</p><p id="a0cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">苹果自己的文档和其他人的<a class="ae me" href="https://swiftwithmajid.com/2020/12/02/focus-management-in-swiftui/" rel="noopener ugc nofollow" target="_blank">博客</a>和<a class="ae me" href="https://www.youtube.com/watch?v=GqXVFXnLVH4" rel="noopener ugc nofollow" target="_blank">视频</a>中的大多数例子都只讨论了如何以简单的形式使用它，比如登录表单。不包括高级用例，比如在可编辑列表中管理焦点。</p><p id="839e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我将向您展示如何在允许用户编辑列表中的元素的应用程序中管理焦点状态。例如，我将使用Make It So，这是我正在开发的一个待办事项应用程序。Make It So是苹果提醒应用程序的复制品，其想法是计算出仅使用SwiftUI和Firebase我们可以接近原始应用程序的程度(详情见此<a class="ae me" href="https://twitter.com/peterfriese/status/1453467058302291975" rel="noopener ugc nofollow" target="_blank"> Twitter帖子</a></p><h1 id="89f3" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">如何在SwiftUI中管理焦点</h1><blockquote class="mx my mz"><p id="e36d" class="li lj na lk b ll lm kd ln lo lp kg lq nb ls lt lu nc lw lx ly nd ma mb mc md im bi translated">一句警告:以下内容只能在iOS 15.2上的SwiftUI 3中使用，因此您需要Xcode 13.2测试版。在撰写本文时，还没有针对物理设备的iOS 15.2版本，所以目前你只能在模拟器上使用它。我相信苹果很快就会推出这款产品，他们甚至可能会对当前版本的iOS发布一个错误修复程序。</p></blockquote><p id="8593" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在WWDC 2021上，苹果推出了<code class="fe ne nf ng nh b">@FocusState</code>，这是一个属性包装器，可以用来跟踪和修改场景中的焦点。</p><p id="1d93" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以使用一个<code class="fe ne nf ng nh b">Bool</code>或者一个<code class="fe ne nf ng nh b">enum</code>来跟踪你的UI中哪个元素被聚焦。</p><p id="26bc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面的例子使用一个带有两个案例的<code class="fe ne nf ng nh b">enum</code>来跟踪一个简单用户概要表单的焦点。正如您在<code class="fe ne nf ng nh b">Button</code>的闭包中看到的，我们可以通过编程来设置焦点，例如，如果用户忘记填写必填字段。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4ecd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种方法适用于只有少数输入元素的简单输入表单，但是对于显示无限数量元素的<code class="fe ne nf ng nh b">List</code>视图或其他动态视图是不可行的。</p><h1 id="0b87" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">如何管理列表中的焦点</h1><p id="2fc6" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">为了管理<code class="fe ne nf ng nh b">List</code>视图中的焦点，我们可以利用Swift <code class="fe ne nf ng nh b">enum</code>支持相关价值的事实。这允许我们定义一个<code class="fe ne nf ng nh b">enum</code>来保存我们想要聚焦的列表元素的<code class="fe ne nf ng nh b">id</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e76f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样，我们可以定义一个局部变量<code class="fe ne nf ng nh b">focusedReminder</code>，它是<code class="fe ne nf ng nh b">Focusable</code>枚举的一个实例，并使用<code class="fe ne nf ng nh b">@FocusState</code>包装它。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="80a2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当用户点击<em class="na">新提醒</em>工具栏按钮时，我们向<code class="fe ne nf ng nh b">reminders</code>数组添加一个新的<code class="fe ne nf ng nh b">Reminder</code>。为了将焦点设置到这个新创建的提醒的行中，我们需要做的就是使用新提醒的<code class="fe ne nf ng nh b">id</code>作为关联值来创建一个<code class="fe ne nf ng nh b">Focusable</code>枚举的实例，并将其分配给<code class="fe ne nf ng nh b">focusedReminder</code>属性:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="18bc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这几乎就是在SwiftUI <code class="fe ne nf ng nh b">List</code>视图中实现基本焦点管理所需的一切！</p><h1 id="3942" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">处理回车键</h1><p id="145a" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">现在让我们把注意力转向苹果提醒应用程序的另一个特性，它将提高我们应用程序的UX:当用户点击<em class="na"> Enter </em>键时，添加新元素(并聚焦它们)。</p><p id="84b4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当用户向视图提交值时，我们可以使用<code class="fe ne nf ng nh b">.onSubmit</code>视图修饰符来运行代码。默认情况下，这将在用户点击<em class="na"> Enter </em>键时触发:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f2aa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这很好，但是所有的新元素都将被添加到列表的<em class="na">端</em>中。如果用户只是在列表的开头或中间编辑待办事项，这有点出乎意料。</p><p id="4d14" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们更新插入新项目的代码，并确保新项目直接插入到当前聚焦的元素之后:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="dd40" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这很好，但是有一个小问题:如果用户连续几次点击<em class="na"> Enter </em>键而没有输入任何文本，我们将会得到一堆空行——这并不理想。提醒应用程序自动删除空行，所以让我们看看我们是否也可以实现这一点。</p><p id="d464" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您一直关注此事，您可能会注意到另一个问题:我们视图的代码变得越来越拥挤，我们将声明性UI代码与大量命令性代码混合在一起。</p><h1 id="3d72" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">MVVM怎么样？</h1><p id="bd5e" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">现在，那些一直关注我的博客和视频的人都知道我喜欢在SwiftUI中使用MVVM方法，所以让我们来看看如何引入一个视图模型来整理视图代码，同时实现一个移除空行的解决方案。</p><p id="8dd4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">理想情况下，视图模型应该包含<code class="fe ne nf ng nh b">Reminder</code>的数组、焦点状态和创建新提醒的代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e55c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意我们是如何访问<code class="fe ne nf ng nh b">createNewReminder</code>中的<code class="fe ne nf ng nh b">focusedReminder</code>焦点状态来找出在哪里插入新的提醒，然后将焦点设置在新添加/插入的提醒上。</p><p id="45e0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">显然，<code class="fe ne nf ng nh b">FocusableListView</code>视图也需要更新，以反映我们不再使用本地<code class="fe ne nf ng nh b">@State</code>变量，而是使用<code class="fe ne nf ng nh b">@ObservableObject</code>变量的事实:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="825d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这一切看起来很棒，但是当运行这段代码时，您会注意到焦点处理不再工作，相反，我们会收到一个SwiftUI运行时警告，提示<em class="na">在视图主体之外访问FocusState的值。这将导致初始值的恒定绑定，并且不会更新</em>:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi np"><img src="../Images/a272e4e524507c02ba35032e5f7fa5ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*pc2Q7vlPiNE_IpzG.png"/></div></figure><p id="ff1c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是因为<code class="fe ne nf ng nh b">@FocusState</code>符合<code class="fe ne nf ng nh b">DynamicProperty</code>，只能在视图内部使用。</p><p id="300b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们需要找到另一种方法来同步视图和视图模型之间的焦点状态。对视图属性变化做出反应的一种方式是<code class="fe ne nf ng nh b">.onChange(of:)</code>视图修改器。</p><p id="f57a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了在视图模型和视图之间同步焦点状态，我们可以</p><ol class=""><li id="9640" class="nq nr it lk b ll lm lo lp lr ns lv nt lz nu md nv nw nx ny bi translated">将<code class="fe ne nf ng nh b">@FocusState</code>添加回视图</li><li id="42a3" class="nq nr it lk b ll nz lo oa lr ob lv oc lz od md nv nw nx ny bi translated">在视图模型上将<code class="fe ne nf ng nh b">focusedReminder</code>标记为<code class="fe ne nf ng nh b">@Published</code>属性</li><li id="7c25" class="nq nr it lk b ll nz lo oa lr ob lv oc lz od md nv nw nx ny bi translated">并使用<code class="fe ne nf ng nh b">onChange(of:)</code>同步它们</li></ol><p id="4a58" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">像这样:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ni nj l"/></div></figure><blockquote class="mx my mz"><p id="a6e0" class="li lj na lk b ll lm kd ln lo lp kg lq nb ls lt lu nc lw lx ly nd ma mb mc md im bi translated">旁注:这可以通过提取代码同步到<code class="fe ne nf ng nh b">View</code>的扩展中来进一步清理。</p></blockquote><p id="210b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">至此，我们已经清理了我们的实现——视图关注于显示方面，而视图模型处理数据模型的更新以及视图和模型之间的转换</p><h1 id="bd93" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">消除空元素</h1><p id="f99f" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">使用视图模型给我们带来了另一个好处——因为视图模型上的<code class="fe ne nf ng nh b">focusedReminder</code>属性是一个已发布的属性，我们可以为它附加一个合并管道，并对属性的变化做出反应。这将允许我们检测先前聚焦的元素何时是空元素，并因此移除它。</p><p id="195f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为此，我们需要在视图模型上增加一个属性来跟踪先前聚焦的<code class="fe ne nf ng nh b">Reminder</code>，然后安装一个合并管道，一旦空的<code class="fe ne nf ng nh b">Reminder</code>的行失去焦点，就删除它们:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="7757" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">结论</h1><p id="df3b" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">这是一个关于如何为SwiftUI <code class="fe ne nf ng nh b">List</code> s实施焦点管理的旋风式概述。结果看起来相当令人信服:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oe"><img src="../Images/6ccb38b149b999b8cc871f07ea626d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fTWKi8a55zJr1nHo.gif"/></div></div></figure><p id="1fd2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要了解如何在更大的环境中使用这些代码，请查看MakeItSo 的<a class="ae me" href="https://github.com/peterfriese/MakeItSo/tree/develop" rel="noopener ugc nofollow" target="_blank">回购。MakeItSo的用户界面更接近原版——毕竟，它试图尽可能地复制提醒应用程序。</a></p><p id="9552" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">代码存在于<a class="ae me" href="https://github.com/peterfriese/MakeItSo/tree/develop" rel="noopener ugc nofollow" target="_blank">开发分支</a>中，这里是包含我们在这篇博文中讨论的代码的两个提交:</p><ul class=""><li id="ee75" class="nq nr it lk b ll lm lo lp lr ns lv nt lz nu md of nw nx ny bi translated"><a class="ae me" href="https://github.com/peterfriese/MakeItSo/commit/fbcc56fe167c70d96ccd83a656cb4401b90fd940" rel="noopener ugc nofollow" target="_blank"> ✨实施焦点管理peterfriese/make itso @ fbcc 56 f</a></li><li id="3972" class="nq nr it lk b ll nz lo oa lr ob lv oc lz od md of nw nx ny bi translated"><a class="ae me" href="https://github.com/peterfriese/MakeItSo/commit/0dd0b7274ef56ecbda6d20aa3562aa4a9fc0d495" rel="noopener ugc nofollow" target="_blank"> ✨删除单元格失去焦点时的空任务peterfriese/make itso @ 0 dd0 b 72</a></li></ul><p id="633c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想在我继续开发MakeItSo的过程中<a class="ae me" href="https://twitter.com/peterfriese/status/1453467058302291975" rel="noopener ugc nofollow" target="_blank">跟随</a>，<a class="ae me" href="https://www.getrevue.co/profile/peterfriese" rel="noopener ugc nofollow" target="_blank">订阅我的时事通讯</a>，或者<a class="ae me" href="https://twitter.com/peterfriese" rel="noopener ugc nofollow" target="_blank">在Twitter上关注我</a>。</p><p id="4a77" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢阅读！</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><p id="2614" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="na">原载于</em><a class="ae me" href="https://peterfriese.dev/swiftui-list-focus/" rel="noopener ugc nofollow" target="_blank"><em class="na">https://peterfriese . dev</em></a><em class="na">。</em></p></div></div>    
</body>
</html>