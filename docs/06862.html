<html>
<head>
<title>Making a Responsive Header With MaterialUI and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用MaterialUI和React制作响应式标题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/making-a-basic-header-responsive-with-materialui-and-react-2198fac923c8?source=collection_archive---------0-----------------------#2020-11-12">https://betterprogramming.pub/making-a-basic-header-responsive-with-materialui-and-react-2198fac923c8?source=collection_archive---------0-----------------------#2020-11-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9c56" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第二部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d39b59472e46fd97824d495d29ca9907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KRjkvfiDuPm09xyV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@unstable_affliction?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊万·班杜拉</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="6e2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗨！之前，我们学习了<a class="ae ky" href="https://medium.com/better-programming/building-a-basic-header-with-materialui-and-react-js-d650f75b4b0a" rel="noopener">如何使用材质UI和React构建一个基本的</a> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://medium.com/better-programming/building-a-basic-header-with-materialui-and-react-js-d650f75b4b0a" rel="noopener">Header</a></code> <a class="ae ky" href="https://medium.com/better-programming/building-a-basic-header-with-materialui-and-react-js-d650f75b4b0a" rel="noopener">组件</a>来实现下面的静态结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/4fee3cc0a1b98b3077bd3ff58e27d87d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9OYxDfaIa75FBYo0.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="db55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，当用户调整屏幕大小时，让我们将这个静态桌面版本变成一个移动视图。响应式设计很重要，因为当用户在他们的移动设备上浏览你的web应用时，你不会想剥夺他们的良好体验。如果你还没有这样做，在继续之前，看看我之前的教程来构建一个基本的桌面标题！</p><p id="1858" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程结束时，我们将实现以下目标:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/8edc1f2cb5bfa039f70babce7369ef51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*jc46R__bxxvXYh2j.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GIF鸣谢:作者</p></figure><p id="697b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！仅供参考:你可以访问GitHub 上的<a class="ae ky" href="https://github.com/vuonga1103/responsive-header-tutorial/blob/master/src/Header.js" rel="noopener ugc nofollow" target="_blank">源代码来跟进。</a></p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="a470" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">1.使用useEffect()和useState()挂钩来设置响应性</h1><p id="3882" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">将以下代码添加到<code class="fe lv lw lx ly b">Header</code>组件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="40a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来分解一下:</p><ul class=""><li id="6260" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">首先，我们设置函数<code class="fe lv lw lx ly b">setResponsiveNess</code>，并在内部调用它<code class="fe lv lw lx ly b">useEffect()</code>。这负责根据窗口的<code class="fe lv lw lx ly b">innerWidth</code>将<code class="fe lv lw lx ly b">mobileView</code>状态设置为<code class="fe lv lw lx ly b">true</code>或<code class="fe lv lw lx ly b">false</code>。</li><li id="87cb" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">我们在<code class="fe lv lw lx ly b">useEffect</code>回调中返回一个清理函数。将调用这个返回的函数来执行所需的清理。当组件卸载时，我们希望删除我们的resize事件侦听器。</li><li id="95b7" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">然后，我们向窗口对象添加一个事件监听器，监听用户何时调整窗口大小，并添加一个调用<code class="fe lv lw lx ly b">setResponsiveness</code>的回调函数。</li><li id="4765" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">我们在我们的<code class="fe lv lw lx ly b">useState()</code>钩子中设置了状态<code class="fe lv lw lx ly b">mobileView</code>,并从状态中解构了<code class="fe lv lw lx ly b">mobileView</code>,这样我们可以在以后引用它。</li><li id="a520" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">最后，我们确保已经从React导入了<code class="fe lv lw lx ly b">useEffect</code>和<code class="fe lv lw lx ly b">useState</code>。</li></ul><p id="da8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在我们的<code class="fe lv lw lx ly b">Header</code>组件的返回语句中，添加<code class="fe lv lw lx ly b">{mobileView ? displayMobile() : displayDesktop()}</code>，这样我们就有了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><ul class=""><li id="024e" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">根据状态<code class="fe lv lw lx ly b">mobileView</code>是否设置为<code class="fe lv lw lx ly b">true</code>或<code class="fe lv lw lx ly b">false</code>，我们将调用<code class="fe lv lw lx ly b">displayMobile()</code>或<code class="fe lv lw lx ly b">displayDesktop()</code>。之前，我们编写了<code class="fe lv lw lx ly b">displayDesktop()</code>，它返回必要的JSX来显示桌面版的标题。我们现在来写<code class="fe lv lw lx ly b">displayMobile()</code>！</li></ul></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="4c93" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">2.添加显示移动工具栏的功能</h1><p id="ee99" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">首先，我们导入<code class="fe lv lw lx ly b">@material-ui/icons</code>库来访问我们将要使用的菜单图标。运行<code class="fe lv lw lx ly b">npm i @material-ui/icons</code>，然后将<code class="fe lv lw lx ly b">import MenuIcon from “@material-ui/icons/Menu”;</code>添加到我们的<code class="fe lv lw lx ly b">Header</code>组件中。从<code class="fe lv lw lx ly b">@material-ui/core</code>导入<code class="fe lv lw lx ly b">IconButton</code>。然后将以下代码添加到我们的<code class="fe lv lw lx ly b">Header</code>组件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="7951" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来消化一下:</p><ul class=""><li id="5eb4" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">我们将从<code class="fe lv lw lx ly b">@material-ui/icons/Menu</code>库中导入的<code class="fe lv lw lx ly b">MenuIcon</code>(又名抽屉图标)包装在<code class="fe lv lw lx ly b">IconButton</code>包装器中。</li><li id="d022" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">我们将一些道具传递给<code class="fe lv lw lx ly b">IconButton</code>组件(这是使用ES6语法构造的):<code class="fe lv lw lx ly b">edge: "start"</code>允许按钮位于工具栏的开始位置。<code class="fe lv lw lx ly b">color: "inherit"</code>让图标继承最接近的顶层组件指定的颜色。<code class="fe lv lw lx ly b">“aria-label": “menu"</code>和<code class="fe lv lw lx ly b">“aria-haspopup": “true"</code>分别用于让屏幕阅读器通知有视觉障碍的用户这个元素是一个菜单和一个弹出窗口。</li><li id="bfdf" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">然后，我们将先前定义的<code class="fe lv lw lx ly b">femmecubatorLogo</code>放入，并将其包装在<code class="fe lv lw lx ly b">div</code>中。</li></ul><p id="73af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们调整屏幕大小，我们应该有:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/8d9d7740ee9de2a505c83604a5d47bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RKz_4outKnGUJwpWRLeWXw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="619e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要去掉移动视图中的填充，只需将下面的内容添加到我们的header类的<code class="fe lv lw lx ly b">makeStyles()</code>钩子中:</p><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="0ff4" class="oa mj it ly b gy ob oc l od oe">"<a class="ae ky" href="http://twitter.com/media" rel="noopener ugc nofollow" target="_blank">@media</a> (max-width: 900px)": {<br/>      paddingLeft: 0,<br/>    },</span></pre><p id="b854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样屏幕小于900px时，<code class="fe lv lw lx ly b">paddingLeft</code>就会是<code class="fe lv lw lx ly b">0</code>。我们应该有:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="2e5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">填充固定:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/dc8f952df21cabbfb0d804b25d92be04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L6XnLprHef_EmuKPIyni8A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="b9f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不错！现在，让我们添加一些逻辑，以便当我们单击菜单图标时，我们在应用程序的一侧显示抽屉菜单。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="cc5d" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">3.添加逻辑来处理抽屉按钮的点击</h1><ul class=""><li id="9a8a" class="nh ni it lb b lc na lf nb li og lm oh lq oi lu nm nn no np bi translated">将<code class="fe lv lw lx ly b">onClick: handleDrawerOpen</code>添加到<code class="fe lv lw lx ly b">IconButton</code>的道具列表中:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><ul class=""><li id="8062" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">在<code class="fe lv lw lx ly b">displayMobile()</code>内编写<code class="fe lv lw lx ly b">handleDrawerOpen</code>函数:</li></ul><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="7ef1" class="oa mj it ly b gy ob oc l od oe">const displayMobile = () =&gt; {<br/>    const handleDrawerOpen = () =&gt;<br/>    setState((prevState) =&gt; ({ ...prevState, drawerOpen: true }));<br/>...</span></pre><ul class=""><li id="74e3" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">将<code class="fe lv lw lx ly b">drawerOpen</code>添加到我们的<code class="fe lv lw lx ly b">useState()</code>钩子中，将其初始化为<code class="fe lv lw lx ly b">false</code>。此外，从state中解构<code class="fe lv lw lx ly b">drawerOpen</code>,以便我们稍后可以引用该变量。</li></ul><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="0083" class="oa mj it ly b gy ob oc l od oe">const [state, setState] = useState({<br/>    mobileView: false,<br/>    drawerOpen: false<br/>  });</span><span id="8121" class="oa mj it ly b gy oj oc l od oe">const { mobileView, drawerOpen } = state;</span></pre><p id="0e8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在，每当我们点击菜单图标按钮时，<code class="fe lv lw lx ly b">drawerOpen</code>就会被设置为<code class="fe lv lw lx ly b">true</code>。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="47d2" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">4.将抽屉组件添加到工具栏</h1><p id="b9e4" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">接下来，我们向我们的<code class="fe lv lw lx ly b">Toolbar</code>添加一个<code class="fe lv lw lx ly b">Drawer</code>组件。确保从<code class="fe lv lw lx ly b">@material-ui/core</code>导入:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="3264" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来分析一下<code class="fe lv lw lx ly b">Drawer</code>到底是怎么回事:</p><ul class=""><li id="a60a" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated"><code class="fe lv lw lx ly b">anchor: “left”</code>将抽屉固定在屏幕左侧。</li><li id="ca7f" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe lv lw lx ly b">open: drawerOpen</code>:根据我们的状态<code class="fe lv lw lx ly b">drawerOpen</code>是<code class="fe lv lw lx ly b">true</code>还是<code class="fe lv lw lx ly b">false</code>，我们的<code class="fe lv lw lx ly b">Drawer</code>要么显示，要么不显示。</li><li id="2f34" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe lv lw lx ly b">onClose: handleDrawerClose</code>确保当我们点击抽屉外的任何东西时，会调用<code class="fe lv lw lx ly b">handleDrawerClose</code>函数。这会将<code class="fe lv lw lx ly b">drawerOpen</code>状态设置为<code class="fe lv lw lx ly b">false</code>，从而关闭抽屉。</li></ul><p id="13a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们在抽屉中添加了一个名为<code class="fe lv lw lx ly b">getDrawerChoices()</code>的<code class="fe lv lw lx ly b">div</code>，它负责显示供用户点击的菜单选项。让我们来编写<code class="fe lv lw lx ly b">getDrawerChoice</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是怎么回事:</p><ul class=""><li id="09ac" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">我们映射<code class="fe lv lw lx ly b">headersData</code>集合中的每个项目，从每个项目中解构<code class="fe lv lw lx ly b">label</code>和<code class="fe lv lw lx ly b">href</code>键。</li><li id="5053" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">每个对象被映射到一个<code class="fe lv lw lx ly b">Link</code>并从<code class="fe lv lw lx ly b">@material-ui/core</code>导入。</li><li id="75f3" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">我们指定该组件是我们之前从<code class="fe lv lw lx ly b">react-router-dom</code>导入的<code class="fe lv lw lx ly b">RouterLink</code>。</li><li id="104e" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe lv lw lx ly b">to: href</code>允许用户点击导航到<code class="fe lv lw lx ly b">href</code>路线。</li><li id="96e9" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">我们确保指定了<code class="fe lv lw lx ly b">color</code>和<code class="fe lv lw lx ly b">key</code>，并将<code class="fe lv lw lx ly b">textDecoration</code>设置为<code class="fe lv lw lx ly b">none</code>以删除链接的默认下划线。</li><li id="aa4b" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">最后，我们使用<code class="fe lv lw lx ly b">MenuItem</code>(从<code class="fe lv lw lx ly b"><a class="ae ky" href="http://twitter.com/material" rel="noopener ugc nofollow" target="_blank">@material</a>-ui/core</code>导入)并在其中添加我们的<code class="fe lv lw lx ly b">label</code>。</li></ul><p id="a491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们现在点击菜单图标时，我们看到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/e9b0863bc6cd605f4051ba1763ec114e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6n-usubioZvS_sW1GhNkGw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="3deb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击这些菜单选项会将我们带到相应的路线。</p><p id="6983" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在要做的最后一件事是给我们的抽屉添加一些衬垫。</p><ul class=""><li id="fa03" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">将<code class="fe lv lw lx ly b">drawerContainer</code>类添加到保存抽屉选择的<code class="fe lv lw lx ly b">div</code>中:</li></ul><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="508c" class="oa mj it ly b gy ob oc l od oe">&lt;Drawer anchor="left" open={drawerOpen} onClose={handleDrawerClose}&gt;<br/>   &lt;div className={drawerContainer}&gt;{getDrawerChoices()}&lt;/div&gt;<br/>&lt;/Drawer</span></pre><ul class=""><li id="7a14" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">然后在<code class="fe lv lw lx ly b">makeStyles()</code>中样式<code class="fe lv lw lx ly b">drawerContainer</code>:</li></ul><pre class="kj kk kl km gt nw ly nx ny aw nz bi"><span id="ec24" class="oa mj it ly b gy ob oc l od oe">const useStyles = makeStyles(() =&gt; ({<br/>...<br/>  drawerContainer: {<br/>    padding: "20px 30px",<br/>  }<br/>}));</span></pre><p id="fdf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧啊。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/327371d2f7df794503a9001f5b356f36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*R7GE7jkipfvILEGY.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="9e1b" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结论</h1><p id="46ea" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">访问GitHub 上的<a class="ae ky" href="https://github.com/vuonga1103/responsive-header-tutorial/blob/master/src/Header.js" rel="noopener ugc nofollow" target="_blank">源代码。随意定制你喜欢的！</a></p><p id="c10e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，更多信息可在<a class="ae ky" href="https://material-ui.com" rel="noopener ugc nofollow" target="_blank">材料UI文档</a>中找到。</p><p id="0145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的关注。希望这篇教程对你有帮助！</p></div></div>    
</body>
</html>