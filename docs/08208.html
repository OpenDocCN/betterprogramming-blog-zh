<html>
<head>
<title>Understanding Concurrent Development in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解iOS中的并发开发</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-concurrent-development-in-ios-c4b6c711cf9f?source=collection_archive---------14-----------------------#2021-04-06">https://betterprogramming.pub/understanding-concurrent-development-in-ios-c4b6c711cf9f?source=collection_archive---------14-----------------------#2021-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f173" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用OperationQueue处理复杂的流</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e960a35d9bf1b647fe5838f42274b2d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w9xha-AH8dq6ZrzM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@juniperphoton?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> JuniperPhoton </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="f2b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并发和异步是任何应用程序的两大主题。我们每天都在使用异步代码进行网络请求和其他操作，我们需要掌握它。</p><p id="b96d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并发编程是一个更隐蔽的话题，但是它也可以出现在任何应用程序中。如果我们开发一个图像处理应用程序，并希望同时对不同的图像应用不同的滤镜来创建一个拼贴画，该怎么办？有了并发开发，我们不必等待所有的过滤按顺序完成。如果我们同时应用所有的过滤器，我们只能等待最慢的一个。这个话题如此重要，以至于苹果提供了一个<a class="ae ky" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html" rel="noopener ugc nofollow" target="_blank">并发编程指南</a>。</p><p id="4dbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们将探索如何使用最重要的抽象之一来开发异步和并发代码:<code class="fe lv lw lx ly b">OperationQueue</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="773a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么是操作队列？</h1><p id="7745" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/operationqueue" rel="noopener ugc nofollow" target="_blank">OperationQueue</a></code>是一个抽象，它让我们把我们的代码看作一个叫做<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/operation" rel="noopener ugc nofollow" target="_blank">Operation</a></code>的工作单元。我们可以安排它们异步执行，同时运行多个操作。决定我们的操作何时运行的是操作系统。</p><p id="0206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个决定是通过考虑两个方面做出的:有多少资源可用，以及我们可以用来配置<code class="fe lv lw lx ly b">OperationQueue</code>和<code class="fe lv lw lx ly b">Operation</code>本身的一系列设置。常见设置有:</p><ul class=""><li id="7fd4" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><code class="fe lv lw lx ly b">OperationQueue.maxConcurrentOperationCount</code>:<code class="fe lv lw lx ly b">OperationQueue</code>可以同时运行的操作数。默认情况下，它被设置为<code class="fe lv lw lx ly b">defaultMaxConcurrentOperationCount</code>，该值由iOS决定。</li></ul><p id="9c54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">注意:我们可以将</em> <code class="fe lv lw lx ly b"><em class="nm">maxConcurrentOperationCount</em></code> <em class="nm">设置为</em> <code class="fe lv lw lx ly b"><em class="nm">1</em></code> <em class="nm">来实现一个串行队列。当我们必须对共享资源进行操作，并且不想手动处理多线程、锁和信号量时，这是一种非常有用的同步机制！</em></p><ul class=""><li id="4dc3" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><code class="fe lv lw lx ly b">OperationQueue.qualityOfService</code>:此值用作我们入队的所有操作的默认服务质量(QoS)值，当这些操作尚未指定QoS时。具有高QoS的操作在具有较低QoS的操作之前执行。</li><li id="4a75" class="nd ne it lb b lc nn lf no li np lm nq lq nr lu ni nj nk nl bi translated"><code class="fe lv lw lx ly b">OperationQueue.isSuspended</code>:是否暂停<code class="fe lv lw lx ly b">OperationQueue</code>。当处于挂起状态时，我们可以让操作入队，但它们不会被执行。</li><li id="efdd" class="nd ne it lb b lc nn lf no li np lm nq lq nr lu ni nj nk nl bi translated"><code class="fe lv lw lx ly b">Operation.isReady</code>:操作是否准备好执行。</li><li id="c7ed" class="nd ne it lb b lc nn lf no li np lm nq lq nr lu ni nj nk nl bi translated"><code class="fe lv lw lx ly b">Operation.isCancelled</code>:是否取消操作。当一个排队的操作成为下一个要执行的操作时，<code class="fe lv lw lx ly b">OperationQueue</code>检查它是否被取消。如果是，队列将不会执行该操作。</li><li id="47b1" class="nd ne it lb b lc nn lf no li np lm nq lq nr lu ni nj nk nl bi translated"><code class="fe lv lw lx ly b">Operation.queuePriority</code>:该值与服务的QoS一起使用，决定哪个操作可以运行。当有多个具有相同QoS的操作准备执行时，<code class="fe lv lw lx ly b">OperationQueue</code>检查队列优先级并选择具有最高值的操作。</li><li id="6ea3" class="nd ne it lb b lc nn lf no li np lm nq lq nr lu ni nj nk nl bi translated"><code class="fe lv lw lx ly b">Operation.dependencies</code>:该数组包含一组必须在当前操作运行之前完成的操作。例如，我们可以定义一个依赖于其他<em class="nm">过滤器</em>操作的<em class="nm">合并</em>操作。<em class="nm">联合收割机</em>操作必须等待所有其他操作完成后才能运行。</li></ul><h2 id="35f9" class="ns mh it bd mi nt nu dn mm nv nw dp mq li nx ny ms lm nz oa mu lq ob oc mw od bi translated">使用操作队列</h2><p id="072f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">OperationQueue</code>很简单。我们使用默认的初始化器创建一个新的队列。我们可以为它的一般行为设置一些属性，并为它命名。该名称有助于区分不同的队列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="861d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，<code class="fe lv lw lx ly b">OperationQueue</code>是<em class="nm">而不是</em>暂停。一旦插入新操作，如果队列有足够的资源，它将开始执行该操作。一旦创建了队列，我们就可以开始入队操作了。我们可以在两种不同类型的操作之间进行选择:<code class="fe lv lw lx ly b">BlockOperation</code>或<code class="fe lv lw lx ly b">Operation</code>类的定制实现。</p><p id="43a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">BlockOperation</code>是最简单的类型。我们可以通过使用<code class="fe lv lw lx ly b">addOperation(_ block: <a class="ae ky" href="http://twitter.com/escaping" rel="noopener ugc nofollow" target="_blank">@escaping</a> () -&gt; Void)</code>重载来添加一个<code class="fe lv lw lx ly b">BlockOperation</code>。<code class="fe lv lw lx ly b">BlockOperations</code>不支持QoS、优先级或依赖性。它们可以通过使用<code class="fe lv lw lx ly b">OperationQueue</code>的方法取消，但是一旦开始，我们就无法阻止它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="2ebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们不需要太多的控制，并且希望在方便的时候以异步方式运行一些代码时，这些简化的操作非常有用。</p><p id="295c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<code class="fe lv lw lx ly b">Operation</code>是一个抽象类，我们可以将其用作自定义操作的父类。我们可以定义任意多的子类，并将它们提交给同一个<code class="fe lv lw lx ly b">OperationQueue</code>。</p><p id="173e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这个子类，我们必须在两种执行模式之间进行选择:同步和异步执行。以下是他们的不同之处:</p><ul class=""><li id="579a" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">同步操作要求我们实现<code class="fe lv lw lx ly b">Operation</code>类的<code class="fe lv lw lx ly b">main()</code>函数。如果队列已达到最大并发操作数，则可能必须等到main方法返回后才能开始另一个操作。</li><li id="1520" class="nd ne it lb b lc nn lf no li np lm nq lq nr lu ni nj nk nl bi translated">异步操作要求我们实现<code class="fe lv lw lx ly b">start()</code>方法以及一系列其他变量，如<code class="fe lv lw lx ly b">isAsynchronous</code>、<code class="fe lv lw lx ly b">isExecuting</code>和<code class="fe lv lw lx ly b">isFinished</code>。<code class="fe lv lw lx ly b">start</code>方法必须启动一个异步操作，比如网络调用。我们的职责是处理<code class="fe lv lw lx ly b">Operation</code>状态，更新<code class="fe lv lw lx ly b">isExecuting</code>、<code class="fe lv lw lx ly b">isFinished</code>和其他与状态相关的属性。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="9459" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的用例允许任务取消，我们需要使用标准的<code class="fe lv lw lx ly b">Operation</code>。正确处理取消是我们作为并发开发人员的职责之一。典型的方法是在<code class="fe lv lw lx ly b">main()</code>执行的不同点检查取消状态，如果已经取消，则终止操作。如果操作在任何时候被取消，我们应该回滚该操作执行的所有更改。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7482" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">操作队列与调度队列</h1><p id="d064" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">OperationQueue</code>和<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue" rel="noopener ugc nofollow" target="_blank">DispatchQueue</a></code>是亲戚。我很确定你已经用过几次<code class="fe lv lw lx ly b">DispatchQueues</code>。<code class="fe lv lw lx ly b">DispatchQueue.main.async</code>或<code class="fe lv lw lx ly b">DispatchQueue.global().async</code>是将执行转移到适当线程的常见代码片段。</p><p id="4dab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法没有什么不好。大多数时候，我们仍然需要访问主队列来更新应用程序的UI。然而，调度队列有一些限制。<a class="ae ky" href="https://tclementdev.com/posts/what_went_wrong_with_the_libdispatch.html" rel="noopener ugc nofollow" target="_blank">这篇文章</a>阐明了我们对分派队列没有多少控制权。任务一旦提交给他们，就没了。如果它不终止，或者如果它无限循环，我们无法停止它，我们是在浪费资源。当这样的事情发生时，我们完全失去了对任务的访问。我们不能探索它运行在哪个线程上，检查它的状态，或者取消它。</p><p id="0b22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，使用<code class="fe lv lw lx ly b">OperationQueue</code>，我们总是可以访问<code class="fe lv lw lx ly b">operations</code>数组，检查排队操作的状态，检查正在运行的操作，并最终停止它们。</p><p id="8902" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据经验法则:</p><ul class=""><li id="e821" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">如果需要在主线程中分派一些工作，使用<code class="fe lv lw lx ly b">DispatchQueue.main</code>。</li><li id="9b32" class="nd ne it lb b lc nn lf no li np lm nq lq nr lu ni nj nk nl bi translated">如果你不得不偶尔分派一些任务，并且对它们的管理不感兴趣，你可以使用<code class="fe lv lw lx ly b">DispatchQueue.global()</code>。</li><li id="d50a" class="nd ne it lb b lc nn lf no li np lm nq lq nr lu ni nj nk nl bi translated">如果应用程序非常依赖异步操作，但您对精细管理不感兴趣，请使用带有<code class="fe lv lw lx ly b">BlockOperations</code>的<code class="fe lv lw lx ly b">OperationQueue</code>。</li><li id="cc86" class="nd ne it lb b lc nn lf no li np lm nq lq nr lu ni nj nk nl bi translated">如果应用程序需要编排不同的复杂活动，包括取消、优先级和其他奇特的功能，那么使用带有一些自定义功能的<code class="fe lv lw lx ly b">OperationQueue</code>。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5bd0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="1c58" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在今天的文章中，我们探讨了<code class="fe lv lw lx ly b">OperationQueue</code>的主要概念，以及我们如何利用这种抽象来调度不同线程上的大量工作。</p><p id="e818" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经研究了它们支持的操作类型，以及如何对它们进行定制。最后，我们分析了<code class="fe lv lw lx ly b">OperationQueue</code>和<code class="fe lv lw lx ly b">DispatchQueue</code>的区别。</p><p id="c970" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要提示:<code class="fe lv lw lx ly b">OperationQueue</code>不会因联合收割机而死亡，也不会因<code class="fe lv lw lx ly b">async/await</code>而死亡。虽然它们可能看起来像相似的机制，但它们可以用于非常不同的目的。例如，我们已经可以在一个<code class="fe lv lw lx ly b">BlockOperation</code>中使用Combine的一些出版商来实现复杂的结果。</p><p id="b32e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往，为正确的工作使用正确的工具！</p></div></div>    
</body>
</html>