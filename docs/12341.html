<html>
<head>
<title>How To Inspect Objects in Python? 9 Functions To Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中检查对象？需要了解的9项功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-inspect-objects-in-python-9-functions-to-know-b1b152fe6bde?source=collection_archive---------5-----------------------#2022-05-30">https://betterprogramming.pub/how-to-inspect-objects-in-python-9-functions-to-know-b1b152fe6bde?source=collection_archive---------5-----------------------#2022-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9128" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">大大提高你的发展</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/47be2e14a70d9d53c1f40543995dcbc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0kVngMVkakKQUHrE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@hudsonhintze?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">哈德逊·辛慈</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="44da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python是一种典型的面向对象语言，其中一切都是围绕对象组织的——内置和自定义的类、实例、模块和函数。当我们处理对象时，经常需要检查它们是什么，以便我们可以相应地使用它们。</p><p id="4a5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将介绍九个函数来从各个方面检查对象。重要的是，在适用的情况下，我还将讨论与每个功能相关的特性。</p><p id="1bfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，让我们开始吧。</p><h1 id="f741" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak"> 1。打印</strong></h1><p id="8c30" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在开发阶段，我们可以使用<code class="fe ms mt mu mv b">print</code>函数在控制台中检查一个对象或其特定属性。以下代码显示了内置数据类型的一些实例的打印输出消息:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="cbb1" class="na lw it mv b gy nb nc l nd ne">numbers_tuple = (1, 2, 3)<br/>numbers_dict = {1: "one", 2: "two", 3: "three"}</span><span id="f3a5" class="na lw it mv b gy nf nc l nd ne">&gt;&gt;&gt; print(numbers_tuple)<br/>(1, 2, 3)<br/>&gt;&gt;&gt; print(numbers_dict)<br/>{1: 'one', 2: 'two', 3: 'three'}</span></pre><p id="c516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，打印的消息类似于原始数据的样子。但是，当您打印自定义类的实例时，它可能看起来有所不同:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="ee2a" class="na lw it mv b gy nb nc l nd ne">class Student:<br/>    def __init__(self, name, student_id):<br/>        self.name = name<br/>        self.student_id = student_id</span><span id="8618" class="na lw it mv b gy nf nc l nd ne">&gt;&gt;&gt; student = Student("John Smith", 19302)<br/>&gt;&gt;&gt; print(student)<br/>&lt;__main__.Student object at 0x7fce50a3fd30&gt;</span></pre><p id="5be1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它不显示实例存储的数据。相反，它只告诉你它是位于指定内存地址的<code class="fe ms mt mu mv b">Student</code>的实例对象。我们如何让<code class="fe ms mt mu mv b">print</code>函数与一个自定义类一起工作？您需要在类中定义<code class="fe ms mt mu mv b">__str__</code>方法:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="34e9" class="na lw it mv b gy nb nc l nd ne">class Student:<br/>    def __init__(self, name, student_id):<br/>        self.name = name<br/>        self.student_id = student_id</span><span id="534b" class="na lw it mv b gy nf nc l nd ne">    def __str__(self):<br/>        return f"Student #{self.student_id}: {self.name}"</span><span id="70b5" class="na lw it mv b gy nf nc l nd ne">&gt;&gt;&gt; student = Student("John Smith", 19302)<br/>&gt;&gt;&gt; print(student)<br/>Student #19302: John Smith</span></pre><p id="3720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe ms mt mu mv b">__str__ </code>方法，我们返回一个描述实例对象的字符串值。在这种情况下，关键信息是姓名和学生ID号。实现<code class="fe ms mt mu mv b">__str__</code>后，在这个实例对象上调用print会打印出更有意义的数据。</p><h1 id="e910" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak"> 2。类型</strong></h1><p id="cfd7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">内置的<code class="fe ms mt mu mv b">type</code>函数返回实现该对象的类的名称。对于一个类的实例对象，你会得到相应的类。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="cb2a" class="na lw it mv b gy nb nc l nd ne">&gt;&gt;&gt; type(numbers_tuple)<br/>&lt;class 'tuple'&gt;<br/>&gt;&gt;&gt; type(numbers_dict)<br/>&lt;class 'dict'&gt;</span></pre><p id="7c40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您将实例的类型与特定类型进行比较时，您应该使用<code class="fe ms mt mu mv b">is</code>而不是<code class="fe ms mt mu mv b">==</code>作为比较。下面是一些例子:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="0980" class="na lw it mv b gy nb nc l nd ne">&gt;&gt;&gt; type(numbers_tuple) is tuple<br/>True<br/>&gt;&gt;&gt; type(numbers_dict) is dict<br/>True</span></pre><p id="9ca3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，尽管使用<code class="fe ms mt mu mv b">==</code>会得到相同的评估结果，但是类型被认为是单例对象，您应该使用identity test ( <code class="fe ms mt mu mv b">is</code>)。</p><p id="7080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将实例的类型与特定的类型进行比较，如上所示。然而，这通常不是最好的主意。相反，当我们想要找出一个对象是否是一个类的实例时，我们更喜欢使用下一个函数— <code class="fe ms mt mu mv b">isinstance</code>。</p><h1 id="f6d4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.isinstance</h1><p id="fa3e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe ms mt mu mv b">isinstance</code>函数返回一个布尔值，表明一个对象是一个类的实例。下面是一些例子:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="07df" class="na lw it mv b gy nb nc l nd ne">&gt;&gt;&gt; isinstance(numbers_tuple, tuple)<br/>True<br/>&gt;&gt;&gt; isinstance(numbers_dict, dict)<br/>True</span></pre><p id="a3df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，您不能只指定一个类—为了方便起见，如果需要，您可以指定多个类，如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="6bf5" class="na lw it mv b gy nb nc l nd ne">&gt;&gt;&gt; isinstance(numbers_tuple, (list, tuple, set))<br/>True</span></pre><p id="9fe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，如果对象是指定类中任何一个类的实例，那么上面代码的等价物如下所示，求值结果为<code class="fe ms mt mu mv b">True</code>。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="0df8" class="na lw it mv b gy nb nc l nd ne">isinstance(numbers_tuple, list) or isinstance(numbers_tuple, tuple) or isinstance(numbers_tuple, set)</span></pre><p id="c9fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你更喜欢使用<code class="fe ms mt mu mv b">isinstance</code>而不是<code class="fe ms mt mu mv b">type</code>比较的一个重要原因是它可以开箱即用地处理子类化。也就是说，当您创建子类的实例对象时，<code class="fe ms mt mu mv b">isinstance</code>也会评估<code class="fe ms mt mu mv b">True</code>，如果您检查该对象是否是超类的实例，如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="2c69" class="na lw it mv b gy nb nc l nd ne">class CollegeStudent(Student):<br/>    pass</span><span id="7c20" class="na lw it mv b gy nf nc l nd ne">&gt;&gt;&gt; college_student = CollegeStudent("John Smith", 19302)<br/>&gt;&gt;&gt; isinstance(college_student, Student)<br/>True</span></pre><p id="92a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相比之下，<code class="fe ms mt mu mv b">type</code>函数不能直接处理涉及子类化的比较，如下所示，因此不够灵活。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="a0ce" class="na lw it mv b gy nb nc l nd ne">&gt;&gt;&gt; type(college_student) is Student<br/>False</span></pre><h1 id="57d0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4.问题分类</h1><p id="e0fc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">既然我们刚刚谈到了子类化，你应该知道我们可以使用<code class="fe ms mt mu mv b">issubclass</code>来确定一个类是否是超类的子类。用法应该非常简单明了；它使用以下内容:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="e55c" class="na lw it mv b gy nb nc l nd ne">&gt;&gt;&gt; issubclass(CollegeStudent, Student)<br/>True</span></pre><p id="010b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数唯一可能的棘手部分是哪个参数先出现——子类还是超类。我的建议是你简单地造一个句子:我想用<code class="fe ms mt mu mv b">issubclass</code>来检查a是否是<code class="fe ms mt mu mv b">b</code>的子类，用这个顺序，我们会有如下:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="0ae1" class="na lw it mv b gy nb nc l nd ne">issubclass(a, b)</span></pre><h1 id="de8d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">5.请求即付的</h1><p id="a3af" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们一直在谈论课程。您可能知道，类是一种可调用的，这意味着我们可以使用调用操作符——一对括号——来调用类。一般来说，如果一个对象可以被调用，我们说它是可调用的。为了检查一个对象是否可调用，我们可以使用<code class="fe ms mt mu mv b">callable</code>函数。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="bbe8" class="na lw it mv b gy nb nc l nd ne">&gt;&gt;&gt; callable(tuple)<br/>True<br/>&gt;&gt;&gt; callable(Student)<br/>True</span></pre><p id="9dd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类是可调用的原因是我们可以调用类来构造实例。另一种重要的可调用类型是函数，如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="7340" class="na lw it mv b gy nb nc l nd ne">def triple(number):<br/>    return number * 3</span><span id="4ddd" class="na lw it mv b gy nf nc l nd ne">&gt;&gt;&gt; callable(triple)<br/>True</span></pre><p id="eb02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了类和函数之外，您甚至可以通过覆盖<code class="fe ms mt mu mv b">__call__</code>方法使自定义类的实例可调用，如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="ce56" class="na lw it mv b gy nb nc l nd ne">class Student:<br/>    def __init__(self, name, student_id):<br/>        self.name = name<br/>        self.student_id = student_id</span><span id="9ed2" class="na lw it mv b gy nf nc l nd ne">    def __call__(self):<br/>        print(f"{self.name} completed the semester.")</span><span id="4e67" class="na lw it mv b gy nf nc l nd ne">&gt;&gt;&gt; student = Student("John Smith", 19302)<br/>&gt;&gt;&gt; student()<br/>John Smith completed the semester.</span></pre><h1 id="0fe2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">6.易消化的</h1><p id="9930" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">既然我们已经讨论了callable，那么讨论另一个表也是合理的。Hashable描述一个对象是否可以被散列。但是<code class="fe ms mt mu mv b">hash</code>是什么意思呢？<code class="fe ms mt mu mv b">Hash</code>意味着您使用一个预定义的函数(称为哈希函数)将一个对象转换成另一种表示，称为哈希值或简称为哈希。在Python中，哈希值是整数。您可以使用<code class="fe ms mt mu mv b">hash</code>函数获得哈希值，如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="62df" class="na lw it mv b gy nb nc l nd ne">&gt;&gt;&gt; hash(numbers_tuple)<br/>529344067295497451</span></pre><p id="dd60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这个数字在您的计算机上可能会有所不同。</p><p id="2239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，并不是所有的对象都是可哈希的。对于内置数据类型，可变对象，如<code class="fe ms mt mu mv b">dict</code>，是不可改变的。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="f46b" class="na lw it mv b gy nb nc l nd ne">&gt;&gt;&gt; hash(numbers_dict)<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>TypeError: unhashable type: 'dict'</span></pre><p id="887b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因是哈希值与其原始数据一一匹配。对于可变对象，如果它们是可散列的，假设你最初获得一个散列值。后来，您更新了对象，更新后的对象应该具有不同的哈希值，这违反了一对一的要求。因此，为了解决这个难题，Python要求我们不能散列可变对象。</p><p id="c44f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，要检查对象的可散列性，您可以简单地调用对象上的<code class="fe ms mt mu mv b">hash</code>函数。如果它是可散列的，您将获得散列值——否则，您将遇到一个<code class="fe ms mt mu mv b">TypeError</code>异常。</p><p id="3d27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想直接检查对象的哈希能力，而不依赖于可能的异常引发，您可以使用下面的替代方法:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="6c60" class="na lw it mv b gy nb nc l nd ne">from collections.abc import Hashable</span><span id="2455" class="na lw it mv b gy nf nc l nd ne">&gt;&gt;&gt; isinstance(numbers_tuple, Hashable)<br/>True<br/>&gt;&gt;&gt; isinstance(numbers_dict, Hashable)<br/>False</span></pre><p id="533c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">Hashable</code>代表一个抽象类，它为那些实例对象可以被散列的类定义了一个通用行为。</p><h1 id="4f09" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">7.身份证明（identification）</h1><p id="a7e3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当你想获得一个对象的标识时，你可以使用<code class="fe ms mt mu mv b">id</code>函数，它返回该对象的内存地址。参见下面的一些例子:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="b71d" class="na lw it mv b gy nb nc l nd ne">&gt;&gt;&gt; id(numbers_tuple)<br/>140524092985536<br/>&gt;&gt;&gt; id(numbers_dict)<br/>140522741441408</span></pre><p id="0219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在任何给定的时间，每个内存地址应该唯一地标识一个对象。这就是为什么您可以使用内存地址进行身份检查。如果两个对象有相同的内存地址，它们就是同一个对象:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="2111" class="na lw it mv b gy nb nc l nd ne">if id(a) == id(b):<br/>    assert a is b</span></pre><p id="a6d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了获取对象的身份之外，<code class="fe ms mt mu mv b">id</code>函数对于了解浅拷贝和深拷贝之间的区别也很有用，这在处理可变对象(比如列表)时会很棘手。</p><p id="4e77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于浅层副本，您将获得最外层列表的副本，而不是内部列表的副本。考虑下面的例子:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="5f28" class="na lw it mv b gy nb nc l nd ne">from copy import copy, deepcopy</span><span id="7bed" class="na lw it mv b gy nf nc l nd ne">numbers = [[1, 2, 3], [4, 5, 6]]<br/>numbers_copy = copy(numbers)</span><span id="289c" class="na lw it mv b gy nf nc l nd ne">assert id(numbers) != id(numbers_copy)<br/>assert numbers is not numbers_copy</span></pre><p id="f36c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我在<code class="fe ms mt mu mv b">copy</code>模块中使用了<code class="fe ms mt mu mv b">copy</code>函数，而不是list的<code class="fe ms mt mu mv b">copy</code>方法，因为<code class="fe ms mt mu mv b">copy</code>模块不仅可以复制列表，还可以复制对象，具有更好的泛化能力。对于浅层复制，不会复制内部列表。观察下面的效果:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="4f5e" class="na lw it mv b gy nb nc l nd ne">assert id(numbers[0]) == id(numbers_copy[0])<br/>assert id(numbers[1]) == id(numbers_copy[1])</span></pre><p id="23c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相比之下，深层副本将为除最外层列表之外的内部列表创建不同的副本:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="d6d5" class="na lw it mv b gy nb nc l nd ne">numbers_deepcopy = deepcopy(numbers)</span><span id="6a31" class="na lw it mv b gy nf nc l nd ne">assert id(numbers) != id(numbers_deepcopy)<br/>assert id(numbers[0]) != id(numbers_deepcopy[0])<br/>assert id(numbers[1]) != id(numbers_deepcopy[1])</span></pre><h1 id="b6f8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">8.哈萨特</h1><p id="baed" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果想检查一个对象是否有特定的属性，可以使用<code class="fe ms mt mu mv b">hasattr</code>函数。下面是一些例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="731f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与这个功能相关的是编码风格的选择:LBYL(三思而后行)vs. EAFP(请求原谅比请求许可容易)。当你使用<code class="fe ms mt mu mv b">hasattr</code>来检查一个对象的特定属性时，这是LBYL风格——我在这个对象上做这样的操作安全吗，像下面这样？</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="a64c" class="na lw it mv b gy nb nc l nd ne">if hasattr(obj, "specific_attr"):<br/>    # do something with the obj<br/>else:<br/>    # can't do such with the object</span></pre><p id="4060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相比之下，当您使用EAFP时，您只需直接运行操作，并在无法对对象执行此类操作时处理可能的异常，如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="ec09" class="na lw it mv b gy nb nc l nd ne">try:<br/>    obj.specific_attr() # suppose it's a method call<br/>except AttributeError:<br/>    # can't do such with the object</span></pre><p id="bf50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，我们使用了<code class="fe ms mt mu mv b">try…except…</code>语句，其中的<code class="fe ms mt mu mv b">try</code>子句试图运行可能不工作的代码。如果出现任何异常，在本例中是一个<code class="fe ms mt mu mv b">AttributeError</code>，我们在<code class="fe ms mt mu mv b">except</code>子句中处理它。</p><p id="c0e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，我们更喜欢使用EAFP风格，因为它通常比LBYL更快，后者需要在执行操作之前进行条件检查。相比之下，EAFP只是运行它，而不需要检查条件。</p><h1 id="3741" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak"> 9。方向</strong></h1><p id="77f3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果您对了解一个对象的所有方法和属性感兴趣，您可以使用<code class="fe ms mt mu mv b">dir</code>函数。当你处理一个新类型的对象时，比如一个第三方库中的对象，并且你不知道什么方法和属性可用于这样的类型，你可以使用这个。</p><p id="2397" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如我们经常用熊猫做数据处理，关键数据结构是<code class="fe ms mt mu mv b">DataFrame</code>，用一个<code class="fe ms mt mu mv b">DataFrame</code>对象就能发现我们能做什么。请注意，我只是提供了一个属性的缩写列表，因为它太长了！</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="68ce" class="na lw it mv b gy nb nc l nd ne">&gt;&gt;&gt; import pandas as pd<br/>&gt;&gt;&gt; df = pd.DataFrame()<br/>&gt;&gt;&gt; dir(df)<br/>['T', '_AXIS_LEN', '_AXIS_ORDERS', '_AXIS_REVERSED', '_AXIS_TO_AXIS_NUMBER', '_HANDLED_TYPES', '__abs__', '__add__', '__and__', '__annotations__', ..., 'value_counts', 'values', 'var', 'where', 'xs']</span></pre><p id="27ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当列表过长时，我们如何利用它？假设我想对数据进行排序，但是您可以简单地过滤包含sort的属性，如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="37b6" class="na lw it mv b gy nb nc l nd ne">&gt;&gt;&gt; [x for x in dir(df) if x.find("sort") &gt;= 0]<br/>['sort_index', 'sort_values']</span></pre><p id="fbfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一个更短的列表，你只需要查找这两个方法的信息来学习使用<code class="fe ms mt mu mv b">DataFrame</code>对象排序。</p><h1 id="bd30" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="b392" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对象是任何应用程序的核心。如果您掌握了这些功能，您会发现检查对象和相应地应用特定操作没有问题。</p><p id="59c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章。</p></div></div>    
</body>
</html>