<html>
<head>
<title>Custom Style Operations in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中的自定义风格操作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/custom-style-operations-in-swiftui-7becf805ef89?source=collection_archive---------24-----------------------#2020-01-21">https://betterprogramming.pub/custom-style-operations-in-swiftui-7becf805ef89?source=collection_archive---------24-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4e2f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">视图协议的有用扩展</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a773d7cd3dd1445291946b287e1d11c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ftBLSwuza-Nnu3IXsGBcaQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://stock.adobe.com/" rel="noopener ugc nofollow" target="_blank"> AdobeStock </a>上的<a class="ae ky" href="https://stock.adobe.com/contributor/206761448/vander?load_type=author&amp;prev_url=detail&amp;asset_id=176613772" rel="noopener ugc nofollow" target="_blank"> Vander </a>拍照。</p></figure><p id="b1c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI提供了几种组织常用样式的方法。视图修饰符是最常被谈论的，但是让我们看看其他一些清理样式代码的方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ebf8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">通过扩展视图协议进行全局视图操作</strong></h1><p id="bc3f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设我们想在圆角视图上创建一个内部笔划。我们可以做的一个方法是用一个<code class="fe mz na nb nc b">RoundedRectangle</code>覆盖我们的视图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="949c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们发现自己不断地向视图中添加这些代码，我们可以扩展视图，使它对我们所有的视图都可用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="07dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以简单地通过使用我们的自定义操作来重新创建我们的<code class="fe mz na nb nc b">innerStroke</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c539" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">自定义组件中的作用域样式操作</strong></h1><p id="aa95" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">与上面的方法类似，我们可以确定只适用于特定组件的操作的范围。</p><p id="6668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何将它应用到一个名为<code class="fe mz na nb nc b">FocusableElement</code>的定制元素中。这个元素简单地应用不同的样式，给出一个布尔值，<code class="fe mz na nb nc b">isFocused</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="dbfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，这个组件有一个庞大的初始化器。让我们通过将样式参数转移到自定义样式操作中来简化它。</p><p id="bbf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们用我们的<code class="fe mz na nb nc b">isFocussed</code>属性创建一个新的初始化器，并将我们之前的初始化器标记为私有。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2fd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将我们之前的初始化器标记为private，我们可以确保我们的自定义样式只能通过自定义操作来修改。</p><p id="cb0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，让我们将所有的样式属性标记为私有。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6bc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们添加我们的作用域操作来访问和更改这些属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们可以简单地通过在自定义视图中重新声明函数来覆盖预先存在的视图协议操作(如<code class="fe mz na nb nc b">cornerRadius</code>)的行为。</p><p id="13c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以将自定义元素操作付诸实施了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，一旦您使用了自定义元素操作范围之外的操作，您将无法访问组件的自定义操作。</p><p id="59a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在包含任何全局操作之前，请确保包含任何限定范围的操作。</p><p id="0c8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你喜欢这篇文章！</p></div></div>    
</body>
</html>