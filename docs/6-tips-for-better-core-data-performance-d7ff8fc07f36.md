# 提高核心数据性能的 6 个技巧

> 原文：<https://betterprogramming.pub/6-tips-for-better-core-data-performance-d7ff8fc07f36>

## 我们从数百万人使用的应用程序中的核心数据中学到了什么

![](img/957167ac7db26fbea391f7b91b9dd146.png)

[法比奥](https://unsplash.com/@fabioha?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片。

在编写核心数据代码时考虑性能有助于为您的应用做好未来准备。您的数据库在开始时可能很小，但它很容易增长，从而导致查询速度慢和用户体验差。

从 2017 年开始写 WeTransfer app 的 [Collect 开始，我就一直在写很多核心数据相关的代码，几乎每天都要接触。随着数百万用户添加大量内容，执行核心数据相关代码已经成为我们团队的一项重要技能。](https://collect.bywetransfer.com/)

多年来，我们已经形成了许多见解，我很高兴分享你应该知道的六个技巧。

# 1.利用后台管理的对象上下文

我们从一开始就没有做的一件事是利用后台托管对象上下文。我们只使用视图上下文来执行任何与核心数据相关的任务:插入新内容、删除内容、获取内容等。

刚开始的时候，我们的 app 比较小。仅仅利用视图上下文并不是一个真正的问题，也不会导致任何与核心数据相关的明显的性能损失。显然，一旦我们的应用程序开始增长，我们就意识到视图上下文与主队列相关联。缓慢的查询阻塞了我们的用户界面，我们的应用程序响应变得更慢。

通常，最佳实践是在后台队列上执行数据处理，因为这可能会占用大量 CPU 资源。像将 JSON 导入核心数据这样的例子可能会阻塞视图上下文，导致用户界面无响应。

解决方案是利用后台管理的对象上下文。最新的 API 使得从持久容器创建新的上下文变得容易:

```
let backgroundContext = persistentContainer.newBackgroundContext()
```

我推荐这个方法而不是`NSManagedObjectContext(concurrenyType:)`初始化器，因为它将自动与`NSPersistentStoreCoordinator`相关联，并将被设置为消费`NSManagedObjectContextDidSave`广播。这使您的背景上下文与视图上下文保持同步。

您可以将这个后台上下文保存在一个自定义的持久容器子类中。这样，您可以重用您的后台上下文，并且只需管理两个上下文。这使您的核心数据结构易于理解，并防止出现多个不同步的上下文。

如果您只需要在少数地方使用背景上下文，那么您也可以决定使用`performBackgroundTask(_:)`方法来就地创建背景上下文:

```
persistentContainer.performBackgroundTask { (backgroundContext) in
    // .. Core Data Code
}
```

然而，这个方法每次被调用时都会创建一个新的`NSManagedObjectContext`。如果您更频繁地调度到后台上下文，您可能需要考虑使用共享的后台上下文。

## 不要在队列之间传递 NSManagedObject 实例

编写多线程核心数据代码比使用单一视图上下文复杂得多。这是因为您不能简单地将从视图上下文实例化的`NSManagedObject`传递给后台上下文。这样做会导致崩溃和潜在的数据损坏。

当需要将一个托管对象从一个队列移动到另一个队列时，您可以使用`NSManagedObjectID`，它是线程安全的:

# 2.仅在需要时保存托管对象上下文

保存托管对象上下文会将所有当前更改提交给上下文的父存储。可以想象，这不是一个廉价的操作，只有在需要确保核心数据的性能时才应该使用。

首先，重要的是检查是否有任何东西可以保存。如果没有要提交的更改，也没有理由执行保存。通过创建一个`saveIfNeeded`方法，您可以让自己轻松地检查这一点:

## 仔细考虑何时保存您的更改

除了用`saveIfNeeded`代替`save()`，你还需要考虑一个保存是否有意义。尽管上下文可能已经更改，但直接提交这些更改并不总是必要的。

例如，如果您要将多个项目导入到数据库中，您可能只想在后台上下文中导入所有项目后进行保存。保存之后通常是 UI 更新，一个接一个的多次保存很容易导致不必要的重新加载。除此之外，要考虑到在后台上下文中保存的更改被合并到视图上下文中，很快也会阻塞主队列。所以，一定要自觉！

# 3.只取你需要的东西

获取数据是一项昂贵的任务，需要尽可能地提高性能，以使您的应用程序为大型数据集做好准备。以下代码是一个常见错误:

这段代码会将所有插入的对象加载到内存中，同时过滤带有名称的内容。

使用谓词只获取需要的对象更有效。上面的过滤器可以用一个`NSPredicate`写成:

这有两个优点:

*   只有需要的对象才会被加载到内存中。
*   你不需要迭代所有的对象。

谓词非常灵活，应该允许您在大多数情况下获取所需的数据集，同时保持核心数据的性能。

# 4.利用提取限制

继续前面的例子，当您只打算显示数据集的一部分时，设置获取限制是很重要的。

例如，假设您只需要所有内容项的前三个名称。在这种情况下，没有必要将所有具有名称的内容项加载到内存中。我们可以通过设置获取限制来防止这种情况:

这段代码将只返回带有名称的前三个内容项。

# 5.使用 NSBatchDeleteRequest 一次删除多个对象

与其遍历数据集逐个删除每个对象，不如使用运行速度更快的`NSBatchDeleteRequest`,因为它在持久存储本身的 SQL 级别运行。

你可以在我以前写的一篇文章中了解更多关于批量删除请求的信息。

# 6.知道如何调试核心数据代码

与您编写的所有代码一样，重要的是知道一旦代码的性能不如预期时如何优化和调试它。有许多调试的方法，在我的博客文章中有很好的解释。

# 结论

从一开始就编写高性能的核心数据代码有助于您为未来的大型数据集准备应用程序。尽管您的应用程序可能在开始时运行良好，但一旦您的数据库和模型增长，它很容易就会变慢。通过利用后台上下文、智能获取请求和批量删除请求，您已经使核心数据代码的性能更高了。

感谢阅读！