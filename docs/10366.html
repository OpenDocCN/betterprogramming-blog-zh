<html>
<head>
<title>Reverse Engineering TypeScript Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逆向工程打字稿类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/reverse-engineering-typescript-types-21196a97a0f6?source=collection_archive---------4-----------------------#2022-01-02">https://betterprogramming.pub/reverse-engineering-typescript-types-21196a97a0f6?source=collection_archive---------4-----------------------#2022-01-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6455" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看看<code class="fe kf kg kh ki b">typeof</code>和<code class="fe kf kg kh ki b">keyof</code>是如何协同工作的</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/11e5521ad2b5eea35086a9a22aa26800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FPwdfrhUGtDTQ3_qj1MupA.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者照片</p></figure><p id="24fc" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">他们说，打字很容易。它只是说你希望你的变量是什么类型/函数是什么类型/等等。，他们说。但是“他们”忽略的是，作为开发人员，我们花在阅读代码上的时间比写代码的时间要多，并且理解你的变量应该在别人的代码中使用什么类型可能是一个整天的项目，特别是如果你试图使用的代码被设计成灵活的。</p><p id="e837" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">虽然互联网上有大量关于编写灵活类型的参考资料，但很少有资料告诉您如何识别被编写为灵活的类型，以及如何准确地给出该类型所需要的内容。</p><p id="e085" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我特别发现<code class="fe kf kg kh ki b">typeof</code>和<code class="fe kf kg kh ki b">keyof</code>非常令人困惑。我曾经说过“typeof意味着它拥有它所拥有的类型，keyof意味着它拥有它所拥有的键。”这主要是因为我是从试图理解在某个地方给变量什么类型的角度来看待它的，而不是从试图构造一个灵活类型的角度来看待它的。</p><p id="f877" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我的顿悟来自于我自己尝试构建越来越多的灵活类型，并看到<code class="fe kf kg kh ki b">typeof</code>和<code class="fe kf kg kh ki b">keyof</code>如何一起工作使这成为可能。</p><p id="4792" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">因此，我认为这将有助于浏览我发现非常粗糙的开源类型，并解构它是如何组合在一起的，以及我认为作者在每一步试图完成的内容。请注意，我只是将这种类型作为一个例子，这个过程并不特定于包含在react-testing-library中的代码，也不真正与测试直接相关。</p><h1 id="eebf" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">反应-测试-库呈现结果</h1><p id="918b" class="pw-post-body-paragraph kz la iq lb b lc mn jr le lf mo ju lh li mp lk ll lm mq lo lp lq mr ls lt lu ij bi translated">我们将要看到的类型是<a class="ae ms" href="https://github.com/testing-library/react-testing-library/blob/main/types/index.d.ts" rel="noopener ugc nofollow" target="_blank">反应-测试-库呈现结果</a>。尽情欣赏这个宝贝吧:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="24ae" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们花点时间讨论一下这是什么，以及我们为什么关心(或者我为什么关心——大多数人可能永远不会关心这种特殊类型)。当您从react-testing-library调用render()时，返回的就是这个类型。换句话说，它是您想象中的DOM的一种表示，带有一些您可以在测试中使用的附加功能。</p><p id="efee" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">大多数使用render的<a class="ae ms" href="https://testing-library.com/docs/react-testing-library/api#render-result" rel="noopener ugc nofollow" target="_blank">示例</a>显示通过<a class="ae ms" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#object_destructuring" rel="noopener ugc nofollow" target="_blank">析构</a>将结果直接转储到变量中，这允许Typescript推断各个部分的类型，例如<a class="ae ms" href="https://testing-library.com/docs/queries/about" rel="noopener ugc nofollow" target="_blank">查询</a>。</p><p id="2410" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果你是一个初出茅庐的人，并且你还没有被<a class="ae ms" href="https://kentcdodds.com/blog/avoid-nesting-when-youre-testing" rel="noopener ugc nofollow" target="_blank">强迫使用<code class="fe kf kg kh ki b">beforeEach</code>和<code class="fe kf kg kh ki b">afterEach</code>来保持你的测试不被打扰</a>，你可能只是想存储一个对类似<code class="fe kf kg kh ki b">findByTestId</code>或<code class="fe kf kg kh ki b">queryByText</code>的引用。</p><p id="a883" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">为了做到这一点，你必须在<code class="fe kf kg kh ki b">beforeEach</code>之外声明变量，这样就可以从你的测试中访问它。这意味着你必须知道那个变量应该是什么类型(除非你是一个彻头彻尾的野蛮人，并且使用了<code class="fe kf kg kh ki b">any</code>，在这种情况下，你为什么还要读这篇文章)。</p><p id="fd48" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这就是原因。现在让我们把它拆开，看看我们能从中得到什么。</p><h1 id="f48f" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">泛型、类型和扩展(哦，我的天)</h1><p id="7109" class="pw-post-body-paragraph kz la iq lb b lc mn jr le lf mo ju lh li mp lk ll lm mq lo lp lq mr ls lt lu ij bi translated">由于缺乏更好的系统，我通常会首先尝试从左到右、从上到下阅读一种类型，尽管这通常不是理解它的最佳方式。让我们从这个开始:</p><pre class="kk kl km kn gt mv ki mw mx aw my bi"><span id="9a71" class="mz lw iq ki b gy na nb l nc nd">export type RenderResult&lt; Q extends Queries = typeof queries, Container extends Element | DocumentFragment = HTMLElement,&gt;</span></pre><p id="0edd" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这是创建我们的类型<code class="fe kf kg kh ki b">RenderResult</code>，使用一个<a class="ae ms" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">通用</a>输入类型<code class="fe kf kg kh ki b">Q</code>，它扩展了<code class="fe kf kg kh ki b">Queries</code>并默认为<code class="fe kf kg kh ki b">typeof queries</code>。我们就此打住，因为我已经像什么了？？？</p><p id="e7cc" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">为了弄清楚查询意味着什么，我们需要进入<a class="ae ms" href="https://github.com/testing-library/dom-testing-library/blob/main/types/get-queries-for-element.d.ts" rel="noopener ugc nofollow" target="_blank"> dom-testing-library </a>。我可以写一整篇关于如何找到引用类型的文章，但不是今天。那种类型看起来像这样。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5db9" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">那是什么意思？这意味着Queries描述了一个hash，它的每个属性都是一个函数，以一个<code class="fe kf kg kh ki b">HTMLElement</code>作为它的第一个参数，然后是一些其他的参数，它将返回给你一个<code class="fe kf kg kh ki b">HTMLElement</code>(或者别的什么——你自己阅读潜在返回列表的其余部分)。</p><p id="1ef0" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这里的默认值是描述这种散列的类型。一种思考<code class="fe kf kg kh ki b">typeof</code>的方式是想象你去一家汽车经销商那里看到这辆可爱的红色汽车。“那是什么型号的车？”</p><p id="181e" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">“这是一个Ferarri。”</p><p id="27d6" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">您有一个汽车的<em class="ne">实例</em>，您可以从该实例向后工作，计算出您拥有的汽车的<em class="ne">类型</em>。或者是Typescript编译器。让我们看看是否能够理解Typescript在这个实例中“看到”了什么。</p><p id="a7a7" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在<code class="fe kf kg kh ki b">RenderResult</code>的情况下，您有一个导入的“变量”<code class="fe kf kg kh ki b">queries</code>，并且<a class="ae ms" href="https://www.typescriptlang.org/docs/handbook/2/typeof-types.html" rel="noopener ugc nofollow" target="_blank">类型的操作符</a>检查它以发现它的属性是什么。我把变量放在引号中，因为它比那稍微复杂一些，但是这已经是一篇很长的文章了，所以我不打算继续下去了🐰洞。</p><p id="aacb" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们看看<code class="fe kf kg kh ki b">queries</code>，看看它告诉了我们什么关于我们的类型。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b773" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们在这里可以看到，<a class="ae ms" href="https://github.com/testing-library/dom-testing-library/blob/main/types/queries.d.ts" rel="noopener ugc nofollow" target="_blank">查询</a>文件的导出实际上包含了我们正在寻找的两个键，<code class="fe kf kg kh ki b">queryByText</code>和<code class="fe kf kg kh ki b">findByTestId</code>。然后我们能不能只输入这些变量中的一个(或者上面不太具体的<code class="fe kf kg kh ki b">Query</code>)。很遗憾，不，我们还没完。</p><p id="bc16" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果查看这些类型，您会发现这两个查询的第一个参数都是一个<code class="fe kf kg kh ki b">HTMLElement</code>。与本例中用于<code class="fe kf kg kh ki b">getByText</code>的参数相比，<a class="ae ms" href="https://testing-library.com/docs/react-testing-library/api#asfragment" rel="noopener ugc nofollow" target="_blank">从react-testing-library API文档中复制了</a>(第17行，作为参数传递给click)。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="389a" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">那是正则表达式，不是<code class="fe kf kg kh ki b">HTMLElement</code>。这是怎么回事？长话短说，有许多不同的方法来访问查询，其中一种是从react-testing-library导入它们(它在内部支持dom-testing-library)。</p><p id="b553" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">当您以这种方式导入查询时，它们是“<a class="ae ms" rel="noopener ugc nofollow" target="_blank" href="/what-is-a-pure-function-3b4af9352f6f">纯</a>”函数，因此它们需要对要查询的元素的引用。当你从<code class="fe kf kg kh ki b">RenderResult</code>中析构它们时，它们实际上是被渲染的根元素的方法。他们不需要引用那个元素。不言自明。</p><h1 id="7a22" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">打开这个的钥匙</h1><p id="b494" class="pw-post-body-paragraph kz la iq lb b lc mn jr le lf mo ju lh li mp lk ll lm mq lo lp lq mr ls lt lu ij bi translated">感觉这并没有让我们前进多少，不是吗？一个更聪明的人会在那里切断它，只使用进口版本或只使用<a class="ae ms" href="https://testing-library.com/docs/queries/about/#screen" rel="noopener ugc nofollow" target="_blank">屏幕</a>。但那样你就不会看到这篇文章了，所以就这样了。让我们回头看看<code class="fe kf kg kh ki b">RenderResult</code> type，看看对我们有没有帮助。提醒一下，<code class="fe kf kg kh ki b">RenderResult</code>看起来是这样的:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4db1" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们刚刚发现<code class="fe kf kg kh ki b">queries</code>导出包含了我们正在寻找的键，只是类型与我们想要存储为变量的函数不完全匹配。看看能不能找到一些参照<code class="fe kf kg kh ki b">queries</code>按键的东西。哦，看哪！在第18行。<code class="fe kf kg kh ki b">typeof queries</code>是通用类型Q的默认类型，这里我们要说一些东西<code class="fe kf kg kh ki b">keyof Q</code>。</p><p id="efab" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在此之前，我们先来讨论一下第4行的“=”和第18行开头的花括号之间的所有代码。这基本上是一个普通的Typescript类型，它定义了一个<code class="fe kf kg kh ki b">RenderResult</code>拥有的所有<em class="ne">和其他</em>属性。这些属性都不是我们要寻找的难以捉摸的<code class="fe kf kg kh ki b">findByTestId</code>或<code class="fe kf kg kh ki b">queryByText</code>，所以我们将忽略整个部分。</p><p id="1c42" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果您看一下“&amp;”的右边，您会看到在大括号内的整行。如果你稍微眯着眼睛，你可以看到这是一个<a class="ae ms" href="https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types" rel="noopener ugc nofollow" target="_blank">交叉类型</a>。说白了(对不起国际读者)，这是一个<em class="ne">新的</em>类型，它包含左边类型的所有属性<em class="ne">和右边类型的所有属性</em>。哪些是…什么…？</p><p id="3276" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们稍微思考一下，假设这不是一个类型，而是一个Javascript函数。该函数的目的是设置一个属性，该属性的名称将作为参数传入，该属性的值也将被指定为参数:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ec7f" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这是因为，在JavaScript中，我们可以用字符串指定对象属性，就像这样:</p><pre class="kk kl km kn gt mv ki mw mx aw my bi"><span id="f2e3" class="mz lw iq ki b gy na nb l nc nd">car[‘color’] = ‘red’;</span></pre><p id="137e" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">Typescript可以做大致相同的事情，使用<a class="ae ms" href="https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html" rel="noopener ugc nofollow" target="_blank">索引访问类型</a>。如果我们再次查看我们的查询导出</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2091" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><code class="fe kf kg kh ki b">typeof queries[“queryByText”]</code>应该是一个函数，它接受的参数看起来像<code class="fe kf kg kh ki b">QueryByText</code>接受的参数，并根据<code class="fe kf kg kh ki b">QueryByText</code>的返回类型返回某种类型的<code class="fe kf kg kh ki b">HTMLElement</code>。接下来，如果我们可以访问特定键的类型，我们就可以编写代码来“循环”查询的所有导出，并引用这些键中的每一个。</p><p id="e0ae" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">事实证明，这正是<code class="fe kf kg kh ki b">{[P in keyof Q]: BoundFunction&lt;Q[P]&gt;}</code>正在发生的事情。</p><p id="e457" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">那么这些<code class="fe kf kg kh ki b">BoundFunction</code>是什么？让我们暂时忽略<code class="fe kf kg kh ki b">BoundFunction</code>本身(我们会回来的，我保证)，只看<code class="fe kf kg kh ki b">&lt;Q[P]&gt;</code>。这看起来是不是很像我们的JS函数访问一个对象的可变属性？我会替你回答，是的，是的(如果你要回答不，很抱歉)。这就是它正在做的事情。我们的“对象”<code class="fe kf kg kh ki b">Q</code>，实际上是我们从类型定义的第一行看到的泛型类型，默认为<code class="fe kf kg kh ki b">queries</code>的导出类型。这听起来很拗口，但是跳过其中的任何区别都会让这个问题变得更加难以理解。</p><p id="4732" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我认为<code class="fe kf kg kh ki b">[P in keyof Q]</code>有点像为<code class="fe kf kg kh ki b">Q</code>的每个属性创建一个“变量”<code class="fe kf kg kh ki b">P</code>的循环。然后在冒号的右边，我们说<code class="fe kf kg kh ki b">BoundFunction</code>想要用作其泛型类型的类型是<code class="fe kf kg kh ki b">queries[‘whatever is in P’]</code>的实际类型。我们想出了在上面追踪的方法。</p><p id="3791" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这意味着在我们的交集类型中<code class="fe kf kg kh ki b">findByTestId</code>的键应该是<code class="fe kf kg kh ki b">BoundFunction&lt;typeof queries[‘findByTestId’]&gt;</code>。我将把它作为一个练习留给读者去查看<a class="ae ms" href="https://github.com/testing-library/dom-testing-library/blob/main/types/get-queries-for-element.d.ts#L3-L8" rel="noopener ugc nofollow" target="_blank"> BoundFunction </a>以确切了解它是如何修改类型的。</p><h1 id="bf26" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">但是为什么呢？</h1><p id="bdf8" class="pw-post-body-paragraph kz la iq lb b lc mn jr le lf mo ju lh li mp lk ll lm mq lo lp lq mr ls lt lu ij bi translated">如果你受不了了，只想回去工作，我理解。我们已经完成了帖子的“实质性”部分，现在我们进入了我对为什么要这样做的猜测。享受你剩下的一天。</p><p id="c2d9" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">对于其他人来说，让我们想想是什么可能促使某人这样对自己(和我们！)</p><p id="8084" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我的第一个想法是，如果您想创建一个自我维护的类型，可以向库中添加新的查询，而无需手动更新类型，这将是一种方法。然而，同样的文件中有对<code class="fe kf kg kh ki b">BoundFunction</code>的定义，也有一个很长的类型，即<a class="ae ms" href="https://github.com/testing-library/dom-testing-library/blob/main/types/get-queries-for-element.d.ts#L12-L155" rel="noopener ugc nofollow" target="_blank">显式地重复查询</a>的所有键，所以这看起来不太可能。</p><p id="4874" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">最后，看起来这一切都是为了允许库的用户使用他们自己的查询来扩展库。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3a4d" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">您可以看到,<code class="fe kf kg kh ki b">BoundFunctions</code>查看是否获得了<code class="fe kf kg kh ki b">queries</code>的所有键，如果是，它在最后附加任何用户提供的查询之前，用去掉容器参数的新定义手动覆盖每个键。如果它没有得到类似于<code class="fe kf kg kh ki b">queries</code>的类型，它只是从用户提供的查询中动态创建绑定查询。我想知道这是否是在添加可扩展性之前就存在的代码的结果，或者是否有一些限制使得使用手动方法比使用动态方法更好，会很有趣。世人可能永远不会知道。</p><h1 id="4030" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">走捷径</h1><p id="f247" class="pw-post-body-paragraph kz la iq lb b lc mn jr le lf mo ju lh li mp lk ll lm mq lo lp lq mr ls lt lu ij bi translated">尽管如此，我最终还是认识到，经常重复自己是在TypeScript中做事的最快方式，同时通过跳过创建临时变量的步骤来创建完全难以辨认的代码，然后我必须研究该变量的类型。所以我给你的建议是开门见山，做TS想让你做的事情，即使你之前学到的每个原则都要求不要那样做。当然，除非你碰巧想理解我们刚刚经历的那种含义。那就自便吧。</p><p id="1daa" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果你喜欢这个，考虑阅读</p><div class="nf ng gp gr nh ni"><a href="https://amy-blankenship.medium.com/why-typescript-wont-save-your-project-704c1dfdf8f1" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">为什么Typescript不会保存您的项目</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">如果您必须在Typescript和TDD之间做出选择，请选择TDD</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">amy-blankenship.medium.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw kt ni"/></div></div></a></div><p id="735a" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果你正在考虑订阅Medium，并且想直接支持我订阅，你可以在这里做</p><div class="nf ng gp gr nh ni"><a href="https://amy-blankenship.medium.com/membership" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">加入我的介绍链接媒体-艾米布兰肯希普</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">阅读艾米·布兰肯希普(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">amy-blankenship.medium.com</p></div></div><div class="nr l"><div class="nx l nt nu nv nr nw kt ni"/></div></div></a></div></div></div>    
</body>
</html>