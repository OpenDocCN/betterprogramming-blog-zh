<html>
<head>
<title>Clock-In/Out System Part 3: Basic Back End (II) — UsersModule</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">上下班打卡系统第3部分:基本后端(二)——用户模块</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/part-3-clock-in-out-system-basic-backend-ii-usersmodule-a56f42b20f62?source=collection_archive---------1-----------------------#2018-12-03">https://betterprogramming.pub/part-3-clock-in-out-system-basic-backend-ii-usersmodule-a56f42b20f62?source=collection_archive---------1-----------------------#2018-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8e55" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">NestJS + Angular教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/27028d592125269574905771e8218205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*KhCkmbtORw2Ux3n5WCrtzA.png"/></div></figure><p id="4f5c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这篇文章是我描述上下班打卡系统的系列文章的一部分。如果你想了解更多，你可以阅读以下内容:</p><ul class=""><li id="ace6" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-1-clock-in-out-system-diagram-a0a51bab02a7?source=post_page---------------------------" rel="noopener">上下班打卡系统第1部分:图</a></li><li id="02aa" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-2-clock-in-out-system-basic-backend-i-authmodule-66d4a5c56122?source=post_page---------------------------" rel="noopener">上下班打卡系统第二部分:基础后端— AuthModule </a></li><li id="f56b" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-3-clock-in-out-system-basic-backend-ii-usersmodule-a56f42b20f62?source=post_page---------------------------" rel="noopener">上下班打卡系统第3部分:基本后端——用户模块</a></li><li id="570e" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-4-clock-in-out-system-basic-backend-iii-appmodule-850dd17883e?source=post_page---------------------------" rel="noopener">上下班打卡系统第4部分:基础后端— AppModule </a></li><li id="4035" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-5-clock-in-out-system-seed-database-and-migration-data-cf037be21aac?source=post_page---------------------------" rel="noopener">上下班打卡系统第5部分:种子数据库和迁移数据</a></li><li id="09ca" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-6-clock-in-out-system-basic-frontend-an-7e5f9ed08c3f?source=post_page---------------------------" rel="noopener">上下班打卡系统第6部分:基本前端</a></li><li id="cb20" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-7-deploy-backend-nestjs-docker-docker-compose-2429c0b6aa9c?source=post_page---------------------------" rel="noopener">上下班打卡系统第7部分:使用Docker/Docker-Compose部署后端(NestJS)</a></li><li id="8948" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-8-clock-in-out-system-deploy-frontend-angular-6-using-environments-ad267325d3b6?source=post_page---------------------------" rel="noopener">上下班打卡系统第8部分:使用环境部署前端(角度6+)</a></li><li id="e6a0" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-9-testing-backend-testing-2d021f48403b?source=post_page---------------------------" rel="noopener">上下班打卡系统第9部分:后端测试——服务的单元测试</a></li><li id="9ede" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-10-testing-backend-testing-unit-testing-controllers-4177370ef581?source=post_page---------------------------" rel="noopener">上下班打卡系统第10部分:后端测试——控制器单元测试</a></li><li id="ddde" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第11部分:后端测试-e2e测试</li><li id="9c7b" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第12部分:前端测试单元测试</li><li id="701a" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第13部分:前端测试集成测试</li></ul><p id="b8a3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在之前的帖子中，我介绍了基本的后端结构和第一个模块(<code class="fe mb mc md me b">AuthModule</code>)。我建议您在阅读这篇文章之前先阅读那篇文章，这样您就可以了解整个系统。本帖将呈现用于管理用户信息的<code class="fe mb mc md me b">UsersModule</code>。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="382d" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">用<code class="fe mb mc md me b">UsersModule</code>管理用户信息</h1><p id="6fc9" class="pw-post-body-paragraph kq kr it ks b kt ne ju kv kw nf jx ky kz ng lb lc ld nh lf lg lh ni lj lk ll im bi translated">服务<code class="fe mb mc md me b">UserService</code>提供了两个重要的方法:</p><ol class=""><li id="76e4" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll nj ls lt lu bi translated"><code class="fe mb mc md me b">getUsersWithoutKey</code></li><li id="17c3" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll nj ls lt lu bi translated"><code class="fe mb mc md me b">addUser</code></li></ol><p id="bc9e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这些方法用于发现用户是否没有有效的id卡，并将用户添加到系统中。</p><p id="6bfb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第一步是展示<code class="fe mb mc md me b">UsersModule</code>的文件结构，如图1所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/6f2401ef17adf6a2bc183bef8b8f51c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*6mEVlUiORhxVl1JX.png"/></div><p class="nl nm gj gh gi nn no bd b be z dk translated">图一。</p></figure><p id="239a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这个模块的开发中，我们使用了与<code class="fe mb mc md me b">AuthModule</code>中相同的目录结构，但是我们有了一个名为<code class="fe mb mc md me b">controllers</code>的新目录，它用于使用RESTful API将这个模块与外部进行通信。</p><p id="ab69" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">此外，您可以看到两个实体，因为在这个模块中，我们需要两个表(<code class="fe mb mc md me b">User</code>和<code class="fe mb mc md me b">UserSchedule</code>)。</p><p id="b9f8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">模块的文件如以下代码所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi np"><img src="../Images/8e2ce6c9f6cb85efbc7af5d524eae2a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zCFemzoBahUCEL_BGCLtzA.png"/></div></div></figure><p id="8f58" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">该模块只导入<code class="fe mb mc md me b">DatabaseModule</code>用<a class="ae lv" href="https://typeorm.io/" rel="noopener ugc nofollow" target="_blank">类型表单</a>连接我们的<a class="ae lv" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> Postgres </a>，导出<code class="fe mb mc md me b">AppController</code>中使用的<code class="fe mb mc md me b">UserService</code>。</p><p id="09d6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">该模块定义了控制器<code class="fe mb mc md me b">UserController</code>，该控制器将用于该模块与外部的通信。</p><h1 id="b71a" class="mm mn it bd mo mp nu mr ms mt nv mv mw jz nw ka my kc nx kd na kf ny kg nc nd bi translated">实体</h1><p id="4ab4" class="pw-post-body-paragraph kq kr it ks b kt ne ju kv kw nf jx ky kz ng lb lc ld nh lf lg lh ni lj lk ll im bi translated">在本模块中，我们需要使用两个实体:</p><ul class=""><li id="da19" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><code class="fe mb mc md me b">User</code>:该实体定义用户信息。</li><li id="95c7" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe mb mc md me b">Scheduler</code>:该实体定义了用户的调度器(弱实体)。</li></ul><p id="72fc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，定义实体的第一步是通过注入来定义允许在我们的服务中使用<code class="fe mb mc md me b">UserRepository</code> <strong class="ks iu"> </strong>的提供者。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi nz"><img src="../Images/27009e0ebfedd006544f4d0934e92162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ll4enyWIZTnq8wBrZyr-_g.png"/></div></div></figure><p id="2b3d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第一个实体是用户，由以下字段定义:</p><ul class=""><li id="fc9b" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><code class="fe mb mc md me b">uid</code>:用户的UID。在本例中，是用户的“姓，名”的字符串。</li><li id="20e7" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe mb mc md me b">name</code>:用户名称。该字段用于在屏幕上显示名称。</li><li id="6ad2" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe mb mc md me b">auth</code>:这就是表格<code class="fe mb mc md me b">Auth</code>和<code class="fe mb mc md me b">Users</code>的关系。此字段是用户的身份认证列表。</li><li id="6b38" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe mb mc md me b">key</code>:分配给用户的按键。</li><li id="76bc" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe mb mc md me b">schedule</code>:这是最重要的领域之一，因为它是用户和他们的时间表之间的关系。用户模块的第二个实体是。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oa"><img src="../Images/fec87e46c7f45b2ec085a7cd374ce317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rk22TDjJwedZP9nS3yo1zA.png"/></div></div></figure><p id="341c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe mb mc md me b">UserSchedule</code>实体用于反映用户必须在建筑物中的每个会话。该表中存储的字段如下:</p><ul class=""><li id="8a33" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><code class="fe mb mc md me b">UID</code><code class="fe mb mc md me b">UserSchedule</code>的UID。该字段由数据库自动生成。</li><li id="6289" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe mb mc md me b">day</code>用户在一周中的哪一天(0到6相当于周日到周六)。</li><li id="45c6" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">用户在建筑物中的时间(从0到11相当于从8:15到22:10，但是关系不是线性的。但是，有一个函数可以完成这项任务)。</li><li id="f6b4" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe mb mc md me b">room</code>用户所在的空间，在那个小时。</li><li id="d6fe" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe mb mc md me b">user</code>表格<code class="fe mb mc md me b">UserSchedule</code>和<code class="fe mb mc md me b">User</code>的关系。许多<code class="fe mb mc md me b">UserSchedule</code>都与一个<code class="fe mb mc md me b">User</code>相关。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi ob"><img src="../Images/eb376b2aa5f9273454fde54139c194b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qB4EJTV0QBcFWozhX6VYkw.png"/></div></div></figure><p id="e454" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，系统由三个表组成:</p><ul class=""><li id="b4e1" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><code class="fe mb mc md me b">User</code>系统中用户及其密钥的信息。</li><li id="c057" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe mb mc md me b">User-Schedule</code>关于日程和用户所在房间的信息。</li><li id="6805" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe mb mc md me b">Auth</code>上下班打卡信息(包括时间戳)。</li></ul><h1 id="d954" class="mm mn it bd mo mp nu mr ms mt nv mv mw jz nw ka my kc nx kd na kf ny kg nc nd bi translated">常数和dto</h1><p id="a354" class="pw-post-body-paragraph kq kr it ks b kt ne ju kv kw nf jx ky kz ng lb lc ld nh lf lg lh ni lj lk ll im bi translated">下一部分很简单，和上一篇文章一样。在本节中，我们定义常数和dto以获得更好的代码。</p><p id="f11b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">常量用于清理字符串或数字的代码，而d to用于从客户端验证用户。</p><p id="5e49" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在文件<code class="fe mb mc md me b">user.constants.ts</code>、<strong class="ks iu">、</strong>中可以看到几个数组:</p><ul class=""><li id="4fad" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><code class="fe mb mc md me b">SCHEDULE_EXCLUDE</code>将从列表中排除的调度程序列表(用户必须在建筑物内)。</li><li id="5d6f" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe mb mc md me b">SCHEDULE_HOURS</code>开始和结束用户会话的不同时间。</li><li id="6117" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">几个常数导出格式的时刻，或在不同的工作班次的第一个和最后一个小时。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oc"><img src="../Images/d471c735cf522c456190fe460173b17a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJY_oPdR-LgMjfkxknf8pA.png"/></div></div></figure><p id="2dda" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe mb mc md me b">user.dto</code>文件也很简单。在这个文件中，您可以看到一个类的定义，其中定义了两个字段(<code class="fe mb mc md me b">UID</code>和<code class="fe mb mc md me b">name</code>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi od"><img src="../Images/4fef5beeb9af25ffa43fdf4b9df57e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7f85UM9L_47H_jXTmbvKnQ.png"/></div></div></figure><h1 id="89eb" class="mm mn it bd mo mp nu mr ms mt nv mv mw jz nw ka my kc nx kd na kf ny kg nc nd bi translated">控制器</h1><p id="4f2a" class="pw-post-body-paragraph kq kr it ks b kt ne ju kv kw nf jx ky kz ng lb lc ld nh lf lg lh ni lj lk ll im bi translated">现在是介绍用户控制器的时候了。</p><p id="7286" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这个文件中，您可以看到控制器名为<code class="fe mb mc md me b">user</code> <strong class="ks iu"> </strong>，并且使用了两个动词:</p><ul class=""><li id="e1ef" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><code class="fe mb mc md me b">GET /user</code>该方法从服务中调用方法<code class="fe mb mc md me b">getUsersWithoutKey</code>,以获取所有未键入系统的用户(用于填充来自客户端的信息)。</li><li id="1e99" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe mb mc md me b">POST /user</code>这个方法从服务中调用方法<code class="fe mb mc md me b">addUser</code>来为用户添加密钥。实际上，<code class="fe mb mc md me b">POST</code>的主体应该是UID和key。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oe"><img src="../Images/3ce9904a5da93089e2dde0ff404f9c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uwf2GksEsd3WE-BAl_2ziQ.png"/></div></div></figure><h1 id="a906" class="mm mn it bd mo mp nu mr ms mt nv mv mw jz nw ka my kc nx kd na kf ny kg nc nd bi translated">服务</h1><p id="5a09" class="pw-post-body-paragraph kq kr it ks b kt ne ju kv kw nf jx ky kz ng lb lc ld nh lf lg lh ni lj lk ll im bi translated">最后，这个模块最重要的部分是服务，因为模块的逻辑在这个文件中。</p><p id="b012" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe mb mc md me b">UserService</code>有三个重要的方法:</p><ul class=""><li id="77b5" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><code class="fe mb mc md me b">getUsersWithoutKey</code>在这个方法中，返回值是来自TypeORM的<code class="fe mb mc md me b">UserEntity[]</code>的<em class="of">承诺</em>。因此，这个方法的目标是使用<code class="fe mb mc md me b">ORM</code>调用正确的<code class="fe mb mc md me b">SELECT</code>句子，这存在于具有<code class="fe mb mc md me b">NULL</code>键值的所有用户中。</li><li id="67f4" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe mb mc md me b">addUser</code>在这个方法中，返回值是一个<em class="of">承诺</em>，从TypeORM的方法save返回。所以，<code class="fe mb mc md me b">addUser</code>是TypeORM的包装器，它是<code class="fe mb mc md me b">INSERT/UPDATE</code>句子的包装器。</li><li id="3dce" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe mb mc md me b">getUsersWorkingNow</code>该方法不在<code class="fe mb mc md me b">UsersModule</code>内使用，而是从<code class="fe mb mc md me b">AppController</code>开始使用。该方法返回一个<code class="fe mb mc md me b">UsersEntity[]</code>的<em class="of">承诺</em>，该承诺由此刻在大楼中的所有用户组成。该方法使用库<a class="ae lv" href="https://momentjs.com/" rel="noopener ugc nofollow" target="_blank"> Moment.js </a>。这将在“糟糕的代码”中完成，带有很多代码味道，但我更喜欢使用几个变量来清理代码。此外，我使用了一个私有函数<code class="fe mb mc md me b">isMorning</code> <strong class="ks iu"> </strong>，它允许我知道系统是在上午还是下午。这是因为有几个用户早上几个小时，下午几个小时都在大楼里。返回的<code class="fe mb mc md me b">Users</code>包含当天的认证列表(使用下限和上限)。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi og"><img src="../Images/e77e9d89f0f29fd50bd8d6a1bfeb72a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cy0JZUobEkgpYkTomevACA.png"/></div></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="9d82" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结论</h1><p id="8116" class="pw-post-body-paragraph kq kr it ks b kt ne ju kv kw nf jx ky kz ng lb lc ld nh lf lg lh ni lj lk ll im bi translated">‌In:这一块，我已经解释了我的<code class="fe mb mc md me b">UsersModule</code>，它非常简单，因为我在编码中使用了干净的代码。</p><p id="cad5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">该模块用于保存关于用户和打卡/下班的信息。</p><p id="da77" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">方法<code class="fe mb mc md me b">getUsersMustBeWorkingNow</code>是系统的主要方法，因为该方法使用几个约束返回必须在建筑物中的用户列表。这些约束很容易定制。</p><p id="d947" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在本系列的后续文章中，我将解释<code class="fe mb mc md me b">AppModule</code>，它将客户端与服务器端以及它们之间的服务器端模块进行通信。</p><ul class=""><li id="71c5" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated">该项目的GitHub是https://github.com/Caballerog/clock-in-out的<a class="ae lv" href="https://github.com/Caballerog/clock-in-out" rel="noopener ugc nofollow" target="_blank"/></li><li id="a8da" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">这一块的GitHub分支是<a class="ae lv" href="https://github.com/Caballerog/clock-in-out/tree/part3-basic-backend-users" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Caballerog/clock-in-out/tree/part 3-basic-back end-users</a></li></ul></div></div>    
</body>
</html>