<html>
<head>
<title>Everything You Should Know About JavaScript Proxy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于JavaScript代理你应该知道的一切</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/everything-you-should-know-about-javascript-proxy-67576f2e069e?source=collection_archive---------5-----------------------#2020-10-29">https://betterprogramming.pub/everything-you-should-know-about-javascript-proxy-67576f2e069e?source=collection_archive---------5-----------------------#2020-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b624" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">立即开始在您的JavaScript代码中使用代理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/811f1217f48b56e74c6d9398a5be8164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XTOKpftxWoDXQbDvWW6ybQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">奥斯卡·伊尔迪兹上传于Unsplash</p></figure><p id="09b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先:MDN 对<code class="fe lu lv lw lx b">Proxy</code>的官方定义是:</p><blockquote class="lz ma mb"><p id="160d" class="ky kz mc la b lb lc ju ld le lf jx lg md li lj lk me lm ln lo mf lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">Proxy</code>对象使你能够为另一个对象创建一个代理，它可以截取并重新定义那个对象的基本操作</p></blockquote><p id="5511" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，在深入挖掘之前，让我们先讨论一些现实生活中的例子，以便最后我们可以更好地了解<code class="fe lu lv lw lx b">Proxy</code> <em class="mc">。</em>这是<a class="ae ly" href="https://medium.com/@bf2" rel="noopener"> bitfish </a>在他的<a class="ae ly" href="https://medium.com/javascript-in-plain-english/why-proxies-in-javascript-are-fantastic-db100ddc10a0" rel="noopener">文章</a>里是怎么解释的。</p><p id="6b76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为人类，我们在日常生活中有很多事情要做，例如阅读电子邮件、接收快递等。有时候，我们可能会因为许多额外的和不必要的任务而感到有点焦虑——比如有许多垃圾邮件，需要一些努力和时间才能清除它们，或者收到的快递可能包含恐怖分子放置的炸弹，威胁到我们的安全(只是一种可能性)。</p><p id="32b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是你希望有人保护你免受这种威胁的地方:一个忠诚的管家。我们需要有人为我们做额外的事情来保护我们正在做的事情。</p><p id="30fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们回到基础——JavaScript。我们知道我们可以扩展JavaScript来使用面向对象编程范例提供的特性，比如封装、抽象、类、对象等等。我们可以说，每个JavaScript开发人员都使用对象，在对象中保存一些信息是很常见的。</p><p id="4c17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是当我们这样做时(使用对象)，我们的代码变得不那么安全。因为JavaScript对象总是裸着运行，你可以用它们做任何事情。</p><p id="a740" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，为了解决这个问题，ECMAScript 2015中引入了一个名为Proxy的新功能，通常称为ES6。通过代理，我们可以为对象找到一个忠实的管家，帮助我们增强对象的原有功能。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="b439" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">什么是JavaScript代理对象？</h1><blockquote class="lz ma mb"><p id="aa76" class="ky kz mc la b lb lc ju ld le lf jx lg md li lj lk me lm ln lo mf lq lr ls lt im bi translated">“JavaScript代理是一个包装另一个对象(目标)并拦截目标对象的基本操作的对象。”— <a class="ae ly" href="https://www.javascripttutorial.net/es6/javascript-proxy/" rel="noopener ugc nofollow" target="_blank"> Javascript教程</a></p></blockquote><p id="eb4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于一个人来说，我们可能会有阅读邮件、收取快递等操作。，管家可以帮我们做。对于一个对象，基本操作可以是属性查找、赋值、枚举和函数调用等。，这也可以通过代理对象来增强。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/7a54c282c1a14b85ba890c173e4b0329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/0*Ug6NnJW_8IfNHBAK.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代理对象的简单说明</p></figure><h2 id="174a" class="ng mo it bd mp nh ni dn mt nj nk dp mx lh nl nm mz ll nn no nb lp np nq nd nr bi translated">创建代理对象</h2><p id="9f07" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">最基本的，你可以使用下面的语法来创建一个<code class="fe lu lv lw lx b">Proxy</code>。</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="e430" class="ng mo it lx b gy ob oc l od oe">let proxy = new Proxy(target, handler);</span></pre><p id="7df7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在哪里</p><ul class=""><li id="642b" class="of og it la b lb lc le lf lh oh ll oi lp oj lt ok ol om on bi translated"><code class="fe lu lv lw lx b">target</code>是要包装的对象</li><li id="af33" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated"><code class="fe lu lv lw lx b">handler</code>是一个包含控制<code class="fe lu lv lw lx b">target</code>行为的方法的对象。在<code class="fe lu lv lw lx b">handler</code>对象内部的方法被称为陷阱。</li></ul><p id="f20f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个<code class="fe lu lv lw lx b">Proxy</code>在目标对象周围创建一个不可检测的屏障，将所有操作重定向到处理程序对象。如果我们发送一个空的<code class="fe lu lv lw lx b">handler</code>，代理只是原始对象周围的一个空包装器。</p><h2 id="dc04" class="ng mo it bd mp nh ni dn mt nj nk dp mx lh nl nm mz ll nn no nb lp np nq nd nr bi translated">一个简单的代理示例</h2><p id="4f0a" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">首先，让我们定义一个名为<code class="fe lu lv lw lx b">user</code>的新对象。</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="fc2f" class="ng mo it lx b gy ob oc l od oe">const user = { <br/>    firstName: ‘John’, <br/>    lastName: ‘Doe’, <br/>    email: ‘john.doe@example.com’, <br/>}</span></pre><p id="ce7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，定义一个<code class="fe lu lv lw lx b">handler</code>对象:</p><blockquote class="lz ma mb"><p id="2b59" class="ky kz mc la b lb lc ju ld le lf jx lg md li lj lk me lm ln lo mf lq lr ls lt im bi translated">在处理程序中，我们可以列出我们想要代理的动作。例如，如果我们想在控制台中打印出一条语句，同时获取一个对象属性，我们可以这样写:</p></blockquote><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="a5cd" class="ng mo it lx b gy ob oc l od oe">const handler = {     <br/>    get(item, property, itemProxy) {         <br/>        console.log(`Property ${property} has been read.`); <br/>        return target[property];     <br/>    } <br/>}</span></pre><p id="1cae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">get</code>函数可以接受三个参数:</p><ul class=""><li id="2b12" class="of og it la b lb lc le lf lh oh ll oi lp oj lt ok ol om on bi translated"><code class="fe lu lv lw lx b">item</code>:就是物体本身。</li><li id="550b" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated"><code class="fe lu lv lw lx b">proerty</code>:您正在尝试读取的属性的名称。</li><li id="1e5e" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated"><code class="fe lu lv lw lx b">itemProxy</code>:是我们刚刚创建的管家对象。</li></ul><p id="80cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，创建一个<code class="fe lu lv lw lx b">proxy</code>对象，这非常简单，就像这样:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="86cd" class="ng mo it lx b gy ob oc l od oe">const proxyUser = new Proxy(user, handler);</span></pre><p id="fc76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">proxyUser</code>对象使用<code class="fe lu lv lw lx b">user</code>对象存储数据。<code class="fe lu lv lw lx b">proxyUser</code>可以访问<code class="fe lu lv lw lx b">user</code>对象的所有属性</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/42539c43c0b9f7ffbac834dbc83684c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/0*0hxLkzpYEuuK68cY.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上面示例代码的图示</p></figure><p id="f713" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们通过<code class="fe lu lv lw lx b">proxyUser</code>对象访问<code class="fe lu lv lw lx b">user</code>对象的<code class="fe lu lv lw lx b">firstName</code>和<code class="fe lu lv lw lx b">lastName</code>属性:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="0644" class="ng mo it lx b gy ob oc l od oe">console.log(proxyUser.firstName);<br/>console.log(proxyUser.lastName);</span></pre><p id="bc62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出将如下所示:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="aa2b" class="ng mo it lx b gy ob oc l od oe">Property firstName has been read. <br/>John <br/>Property lastName has been read. <br/>Doe</span></pre><p id="e11f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，<code class="fe lu lv lw lx b">get</code>函数的返回值是读取该属性的结果。因为我们还不想改变任何东西，所以我们只返回原始对象的属性值。</p><p id="7253" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果有必要，我们也可以改变结果。例如，我们可以这样做:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="01d8" class="ng mo it lx b gy ob oc l od oe">let obj = {a: 1, b:2}</span><span id="e235" class="ng mo it lx b gy ou oc l od oe">let handler = {<br/>  get: function(item, property, itemProxy){<br/>    console.log(`You are getting the value of '${property}'     property`)<br/>    return item[property] * 2<br/>  }<br/>}</span><span id="dd7c" class="ng mo it lx b gy ou oc l od oe">let objProxy = new Proxy(obj, handler)</span><span id="c436" class="ng mo it lx b gy ou oc l od oe">console.log(objProxy.a)<br/>console.log(objProxy.b)</span></pre><p id="67b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它将输出以下内容:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="f2f4" class="ng mo it lx b gy ob oc l od oe">You are getting the value of 'a' property <br/>2<br/>You are getting the value of 'b' property <br/>4</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="9f52" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">代理陷阱</h1><h2 id="123c" class="ng mo it bd mp nh ni dn mt nj nk dp mx lh nl nm mz ll nn no nb lp np nq nd nr bi translated"><code class="fe lu lv lw lx b">get()</code>陷阱</h2><p id="c718" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">当通过代理对象访问<code class="fe lu lv lw lx b">target</code>对象的属性时，触发<code class="fe lu lv lw lx b">get()</code>陷阱。</p><p id="691a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在前面的例子中，当<code class="fe lu lv lw lx b">proxyUser</code>对象访问<code class="fe lu lv lw lx b">user</code>对象的属性时，会输出一条消息。</p><h2 id="d15a" class="ng mo it bd mp nh ni dn mt nj nk dp mx lh nl nm mz ll nn no nb lp np nq nd nr bi translated"><code class="fe lu lv lw lx b">set()</code>陷阱</h2><p id="39af" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">除了拦截对属性的读取，我们还可以拦截对属性的修改。像这样:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="6ea8" class="ng mo it lx b gy ob oc l od oe">let obj = {a: 1, b:2}</span><span id="8ab5" class="ng mo it lx b gy ou oc l od oe">let handler = {<br/>  set: function(item, property, value, itemProxy){<br/>    console.log(`You are setting '${value}' to '${property}' property`)<br/>    item[property] = value<br/>  }<br/>}</span><span id="9617" class="ng mo it lx b gy ou oc l od oe">let objProxy = new Proxy(obj, handler)</span></pre><p id="0912" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果我们尝试更新属性的值，我们将看到如下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/fb7705bea1bba66cc0cf77b245593803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*SChCEmf3cgXk3CHSz_NCbQ.png"/></div></figure><p id="6314" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们需要在设置属性值时传递一个额外的值，所以上面的<code class="fe lu lv lw lx b">set</code>函数比<code class="fe lu lv lw lx b">get</code>函数多接受一个参数。</p><p id="59e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了拦截对属性的读取和修改，代理可以拦截对象上总共13个<strong class="la iu">操作/陷阱</strong>。</p><p id="945f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它们是:</p><ul class=""><li id="0cbd" class="of og it la b lb lc le lf lh oh ll oi lp oj lt ok ol om on bi translated"><strong class="la iu"> get(item，propKey，itemProxy): </strong>拦截对象属性的读取操作，如<code class="fe lu lv lw lx b">obj.a</code>、<code class="fe lu lv lw lx b">ojb['b']</code></li><li id="8fef" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated"><strong class="la iu"> set(item，propKey，value，itemProxy): </strong>拦截对象属性的设置操作，如<code class="fe lu lv lw lx b">obj.a = 1</code>。</li><li id="45c5" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated"><strong class="la iu"> has(item，propKey): </strong>拦截<code class="fe lu lv lw lx b">propKey in objProxy</code>的运算，返回一个布尔值。</li><li id="61b8" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated"><strong class="la iu"> deleteProperty(item，propKey): </strong>拦截<code class="fe lu lv lw lx b">delete proxy[propKey]</code>的操作，返回一个布尔值。</li><li id="6dac" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated"><strong class="la iu"> ownKeys(item): </strong>拦截<code class="fe lu lv lw lx b">Object.getOwnPropertyNames(proxy)</code>、<code class="fe lu lv lw lx b">Object.getOwnPropertySymbols(proxy)</code>、<code class="fe lu lv lw lx b">Object.keys(proxy)</code>、<code class="fe lu lv lw lx b">for...in</code>等操作，返回一个数组。方法返回所有目标对象自身属性的属性名，而<code class="fe lu lv lw lx b">Object.keys()</code>的返回结果只包含目标对象自身的可枚举属性。</li><li id="74fc" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated"><strong class="la iu">getOwnPropertyDescriptor(item，propKey): </strong>拦截<code class="fe lu lv lw lx b">Object.getOwnPropertyDescriptor(proxy, propKey)</code>的操作，返回属性的描述符。</li><li id="193e" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated"><strong class="la iu"> defineProperty(item，propKey，propDesc): </strong> Intercepter这些操作:<code class="fe lu lv lw lx b">Object.defineProperty(proxy, propKey, propDesc）</code>，<code class="fe lu lv lw lx b">Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li><li id="3c67" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated"><strong class="la iu">prevent extensions(item):</strong>拦截<code class="fe lu lv lw lx b">Object.preventExtensions(proxy)</code>的操作，返回一个布尔值。</li><li id="5fd9" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated"><strong class="la iu"> getPrototypeOf(item): </strong>拦截<code class="fe lu lv lw lx b">Object.getPrototypeOf(proxy)</code>的操作，返回一个对象。</li><li id="5d68" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated"><strong class="la iu"> isExtensible(item): </strong>截取<code class="fe lu lv lw lx b">Object.isExtensible(proxy)</code>的操作，返回一个布尔值。</li><li id="46c7" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated"><strong class="la iu"> setPrototypeOf(item，proto): </strong>截取<code class="fe lu lv lw lx b">Object.setPrototypeOf(proxy, proto)</code>的操作，返回一个布尔值。</li></ul><p id="d090" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果目标对象是一个函数，还有两个额外的操作需要拦截。</p><ul class=""><li id="a01b" class="of og it la b lb lc le lf lh oh ll oi lp oj lt ok ol om on bi translated"><strong class="la iu"> apply(item，object，args): </strong>拦截函数调用操作，如<code class="fe lu lv lw lx b">proxy(...args)</code>、<code class="fe lu lv lw lx b">proxy.call(object, ...args)</code>、<code class="fe lu lv lw lx b">proxy.apply(...)</code>。</li><li id="48ab" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated"><strong class="la iu"> construct(item，args): </strong>拦截代理实例作为构造函数调用的操作，比如<code class="fe lu lv lw lx b">new proxy(...args)</code>。</li></ul><p id="25b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们进入一些用例，看看<code class="fe lu lv lw lx b"><em class="mc">Proxy</em></code>实际上能为我们做什么。以下是<a class="ae ly" href="https://medium.com/@bf2" rel="noopener"> bitfish </a>在他的<a class="ae ly" href="https://medium.com/javascript-in-plain-english/why-proxies-in-javascript-are-fantastic-db100ddc10a0" rel="noopener">文章</a>中分享的用例，其中代理可以成为救世主。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="9f6b" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">实现数组的负索引</h1><p id="3ca7" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">一些编程语言，比如Python，支持数组的负索引。</p><p id="fae8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">负索引以数组的最后一个位置为起点，向前计数。比如:</p><ul class=""><li id="931c" class="of og it la b lb lc le lf lh oh ll oi lp oj lt ok ol om on bi translated">arr[-1]是数组的最后一个元素。</li><li id="5639" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated">arr[-4]是数组中倒数第四个元素。</li></ul><blockquote class="lz ma mb"><p id="c3c2" class="ky kz mc la b lb lc ju ld le lf jx lg md li lj lk me lm ln lo mf lq lr ls lt im bi translated">这不是一个强大而有用的特性。但是不幸的是，JavaScript现在不支持数组负索引。</p></blockquote><p id="3058" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你试图这样做，你会得到<em class="mc">未定义的</em>，就像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/b42dea7792b044077ebd96ae8e268864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*zgBp4R9hkAU1afonU9yBrQ.png"/></div></figure><blockquote class="lz ma mb"><p id="7d82" class="ky kz mc la b lb lc ju ld le lf jx lg md li lj lk me lm ln lo mf lq lr ls lt im bi translated">在这里，如果我们真的必须在代码中使用负索引，代理会非常有用。</p></blockquote><p id="e99b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以将一个数组包装成一个代理对象。当用户试图访问负索引时，我们可以通过代理的get方法拦截这个操作。然后，根据之前定义的规则，将负索引转换为正索引，访问完成。</p><p id="e3f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看如何使用<em class="mc">代理</em>来实现这一点。</p><p id="f9de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我们的要求是:当用户试图访问一个属性，这个属性是一个数组的索引，并且发现它是一个负索引时，那么拦截并相应地处理它。如果属性不是一个指数，或者如果指数是正的，我们不做任何事情。</p><p id="b675" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，Proxy的get方法会拦截对数组所有属性的访问，包括对数组的一个索引的访问和对数组其他属性的访问。仅当属性名可以转换为整数时，才执行访问数组中元素的操作。我们实际上需要截取这个操作来访问数组中的元素。</p><p id="ba91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过检查一个数组的属性是否可以转换成整数来确定它是否是一个索引。</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="fe18" class="ng mo it lx b gy ob oc l od oe">Number(propKey) != NaN &amp;&amp; Number.isInteger(Number(propKey))</span></pre><p id="a4e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是完整的代码:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="58b4" class="ng mo it lx b gy ob oc l od oe">function negativeArray(array) {<br/>  return new Proxy(array, {<br/>    get: function(target, propKey){<br/>      if (Number(propKey) != NaN &amp;&amp; Number.isInteger(Number(propKey)) &amp;&amp; Number(propKey) &lt; 0) {<br/>        propKey = String(target.length + Number(propKey));<br/>      }<br/>      return target[propKey]<br/>    }<br/>  })<br/>}</span></pre><p id="6659" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看Chrome的开发者工具中的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/ff9a32d4d01d4f6765058dd5c51c6289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RGtmiFSUQp0SfWRrSUz92w.png"/></div></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="a504" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">数据有效性</h1><p id="7a9c" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">众所周知，javascript是一种弱类型语言。通常，当一个对象被创建时，它是裸运行的。任何人都可以修改。</p><p id="b557" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是大多数情况下，对象的属性值需要满足某些条件。例如，记录用户信息的对象在其年龄字段中应该有一个大于0的整数，通常小于150。</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="6b95" class="ng mo it lx b gy ob oc l od oe">let person1 = {<br/>  name: 'Jon',<br/>  age: 23<br/>}</span></pre><p id="acf0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，默认情况下，JavaScript不提供安全机制，您可以随意更改该值。</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="5f3f" class="ng mo it lx b gy ob oc l od oe">person1.age = 9999<br/>person1.age = 'hello world'</span></pre><p id="3082" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了使我们的代码更加安全，我们可以用代理来包装我们的对象。我们可以截取对象的set操作，验证age字段的新值是否符合规则。</p><p id="ed1e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是我们如何用代码做到这一点:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="ab5f" class="ng mo it lx b gy ob oc l od oe">let ageValidate = {<br/>  set (item, property, value) {<br/>    if (property === 'age') {<br/>      if (!Number.isInteger(value) || value &lt; 0 || value &gt; 150) {<br/>        throw new TypeError('age should be an integer between 0 and 150');<br/>      }<br/>    }<br/>    item[property] = value<br/>  }<br/>}</span></pre><p id="f8cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们尝试修改这个属性的值，我们可以看到我们设置的保护机制正在工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/3d6d8621863cd779aa5c8e9c3e640f89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Wuen4R6sNjV53j1WwEFQQ.png"/></div></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="4d07" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">关联属性</h1><p id="82f2" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">很多时候，一个对象的属性是相互关联的。例如，对于存储用户信息的对象，其邮政编码和位置是两个高度相关的属性。当用户的邮政编码确定后，他的位置也就确定了。</p><p id="83bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了适应不同国家的读者，我在这里使用一个虚拟的例子。假设位置和邮政编码具有以下关系:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="0374" class="ng mo it lx b gy ob oc l od oe">JavaScript Street  --  232200</span><span id="806c" class="ng mo it lx b gy ou oc l od oe">Python Street -- 234422</span><span id="b141" class="ng mo it lx b gy ou oc l od oe">Golang Street -- 231142</span></pre><p id="e188" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是用代码表达他们关系的结果。</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="062c" class="ng mo it lx b gy ob oc l od oe">const location2postcode = {<br/>  'JavaScript Street': 232200,<br/>  'Python Street': 234422,<br/>  'Golang Street': 231142<br/>}</span><span id="1077" class="ng mo it lx b gy ou oc l od oe">const postcode2location = {<br/>  '232200': 'JavaScript Street',<br/>  '234422': 'Python Street',<br/>  '231142': 'Golang Street'<br/>}</span></pre><p id="fd55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后看一个例子:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="8221" class="ng mo it lx b gy ob oc l od oe">let person = {<br/>  name: 'Jon'<br/>}</span><span id="bb3e" class="ng mo it lx b gy ou oc l od oe">person.postcode = 232200</span></pre><p id="1936" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们希望能够在设置<code class="fe lu lv lw lx b">person.postcode=232200</code>时自动触发<code class="fe lu lv lw lx b">person.location='JavaScript Street'</code>。</p><p id="fd4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解决方案如下:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="8c57" class="ng mo it lx b gy ob oc l od oe">let postcodeValidate = {<br/>  set(item, property, value) {<br/>    if(property === 'location') {<br/>      item.postcode = location2postcode[value]<br/>      <br/>    }<br/>    if(property === 'postcode'){<br/>      item.location = postcode2location[value]<br/>    }<br/>  }<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/4b574b39550e40de687a35134b64e7d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uQ5YsdQ4ViiIsduqhs1CVQ.png"/></div></div></figure><p id="f33b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我们将<code class="fe lu lv lw lx b">postcode</code>和<code class="fe lu lv lw lx b">location</code>绑定在一起。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="c939" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">私有财产</h1><p id="1bc2" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">我们知道JavaScript从来不支持私有属性。这使得我们在编写代码的时候无法合理地管理访问权限。</p><p id="d4ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了解决这个问题，JavaScript社区的惯例是以字符<code class="fe lu lv lw lx b">_</code>开头的字段被视为私有属性。</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="d7db" class="ng mo it lx b gy ob oc l od oe">var obj = {<br/>  a: 1,<br/>  _value: 22<br/>}</span></pre><p id="6017" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上述<code class="fe lu lv lw lx b">_value</code>房产被视为私有。但是，需要注意的是，这只是一个约定，在语言层面上没有这样的规则。</p><p id="27d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们有了代理，我们可以模拟私有属性特性。</p><p id="8f11" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与普通房产相比，私有房产具有以下特点:</p><ul class=""><li id="014e" class="of og it la b lb lc le lf lh oh ll oi lp oj lt ok ol om on bi translated">无法读取此属性的值</li><li id="dc51" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated">当用户试图访问对象的键时，该属性不明显</li></ul><p id="7a6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以检查前面提到的代理的13个拦截操作，并看到有3个操作需要被拦截。</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="830b" class="ng mo it lx b gy ob oc l od oe">function setPrivateField(obj, prefix = "_"){<br/>  return new Proxy(obj, {<br/>    // Intercept the operation of `propKey in objProxy`<br/>    has: (obj, prop) =&gt; {},    </span><span id="9c82" class="ng mo it lx b gy ou oc l od oe">    // Intercept the operations such as `Object.keys(proxy)`<br/>    ownKeys: obj =&gt; {},    </span><span id="a829" class="ng mo it lx b gy ou oc l od oe">    //Intercepts the reading operation of object properties<br/>    get: (obj, prop, rec) =&gt; {})<br/>    });<br/>}</span></pre><p id="c8eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们将适当的判断语句添加到模板中:如果发现用户试图访问以<code class="fe lu lv lw lx b">_</code>开头的字段，访问将被拒绝。</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="bb15" class="ng mo it lx b gy ob oc l od oe">function setPrivateField(obj, prefix = "_"){<br/>  return new Proxy(obj, {<br/>    has: (obj, prop) =&gt; {<br/>      if(typeof prop === "string" &amp;&amp; prop.startsWith(prefix)){<br/>        return false<br/>      }<br/>      return prop in obj<br/>    },<br/>    ownKeys: obj =&gt; {<br/>      return Reflect.ownKeys(obj).filter(<br/>        prop =&gt; typeof prop !== "string" || !prop.startsWith(prefix)<br/>      )<br/>    },<br/>    get: (obj, prop) =&gt; {<br/>      if(typeof prop === "string" &amp;&amp; prop.startsWith(prefix)){<br/>        return undefined<br/>      }<br/>      return obj[prop]<br/>    }<br/>  });<br/>}</span></pre><p id="41a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是该示例的最终代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/81b200bb202de69dd3a9851033725f74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ioR8JLrA0E8bhVIVGA89iA.png"/></div></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="0005" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="16bd" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">我们已经了解了JavaScript中的<code class="fe lu lv lw lx b">Proxy </code>到底是什么，它的一些用例是什么。我们现在知道如何使用代理来监视对象。现在，您应该能够通过在handler对象中使用trap方法向它们添加行为。我希望你现在有足够的灵感来探索JavaScript中使用<code class="fe lu lv lw lx b">Proxy</code>的可能性。</p><p id="f889" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。我希望这篇文章对你有帮助。请随时提出一些问题或建议作为回应。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="a376" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">资源</h1><ul class=""><li id="f053" class="of og it la b lb ns le nt lh pb ll pc lp pd lt ok ol om on bi translated"><a class="ae ly" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">代理</a></li><li id="9df7" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated"><a class="ae ly" href="https://www.javascripttutorial.net/es6/javascript-proxy/" rel="noopener ugc nofollow" target="_blank"> JavaScript代理</a></li><li id="2414" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated"><a class="ae ly" href="https://medium.com/javascript-in-plain-english/why-proxies-in-javascript-are-fantastic-db100ddc10a0" rel="noopener">为什么代理是JavaScript中的瑰宝？</a></li><li id="ca24" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated"><a class="ae ly" href="https://indepth.dev/getting-started-with-modern-javascript-proxy/" rel="noopener ugc nofollow" target="_blank">现代JavaScript代理入门</a></li></ul></div></div>    
</body>
</html>