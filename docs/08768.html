<html>
<head>
<title>How To Add Compression to Caching in Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Spring Boot的缓存中添加压缩</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-add-compression-to-caching-in-spring-boot-d4d21533167c?source=collection_archive---------7-----------------------#2021-06-09">https://betterprogramming.pub/how-to-add-compression-to-caching-in-spring-boot-d4d21533167c?source=collection_archive---------7-----------------------#2021-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f7ac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">释放您的缓存</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/886adad917036d07316396321d9e3a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u2JL5XkSEn-y0Qi0PqAjrg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@fatosi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">法托斯Bytyqi </a>在<a class="ae ky" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="3a36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RAM是云提供商提供的最昂贵的资源之一。因此，将所有缓存数据存储在内存缓存中是有代价的。这就是为什么实现旨在不浪费它的技术是至关重要的。</p><p id="1a8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，当您的Spring Boot应用程序和缓存服务器共存于同一台机器上，共享底层资源时，这实际上是不可避免的。事实上，缓存从应用程序中窃取的RAM越少越好。此外，众所周知，序列化的Java对象会占用大量空间。因此，通过缓存它们，您的RAM可能很容易就耗尽空间。</p><p id="49e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是压缩发挥作用的地方！</p><p id="a484" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何用Kotlin和Java在Spring Boot<a class="ae ky" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank">的缓存系统中添加压缩。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5621" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">压缩和缓存</h1><p id="b3d8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通常，在Spring Boot中处理缓存时，数据被序列化，然后存储在缓存中。需要时，数据被搜索、反序列化，最后以原始格式返回给应用程序，在本例中用Java/Kotlin对象表示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/884356fb27c3e5f29044743dc5bb37bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*Ylla5ax5W69My0T7r6iBsw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正常缓存流程图。图片由作者提供。</p></figure><p id="db12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加压缩层意味着在序列化数据之后压缩数据，在反序列化之前解压缩数据，修改正常流程如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/4cb919c3ed12011e50388dca9ee70f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*68z8xc7aJxltUXeg0OhI_w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">压缩数据缓存流程图</p></figure><p id="c520" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">压缩数据减少了缓存的大小，并为您提供了两种选择:</p><ol class=""><li id="0983" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">减少缓存服务器所需的RAM，为您省钱。</li><li id="9345" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">保持缓存大小不变，但允许您保存更多的数据。</li></ol><p id="6361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个选项都很棒，但是压缩也会带来开销。特别是，压缩和解压缩需要花费时间，这可能会大大降低缓存的性能优势。这代表了RAM和CPU之间的权衡，这取决于您是否发现这种方法适合您的特定情况。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="49a1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实现压缩逻辑</h1><p id="7f89" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">请记住，上面介绍的方法可以被Spring Boot支持的任何<a class="ae ky" href="https://docs.spring.io/spring-boot/docs/1.3.0.M1/reference/html/boot-features-caching.html#_supported_cache_providers" rel="noopener ugc nofollow" target="_blank">缓存提供商</a>采用。让我们看看如何使用一个<a class="ae ky" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>缓存来实现它。这可以通过注册一个从<code class="fe np nq nr ns b"><a class="ae ky" href="https://docs.spring.io/spring-data/redis/docs/current/api/org/springframework/data/redis/serializer/JdkSerializationRedisSerializer.html" rel="noopener ugc nofollow" target="_blank">JdkSerializationRedisSerializer</a></code>继承的自定义类作为默认Redis序列化器来轻松实现。</p><p id="0fd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，您需要定义一个有效的Redis序列化程序来实现压缩和解压缩逻辑，如上图所示。您将看到如何使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Gzip" rel="noopener ugc nofollow" target="_blank"> GZIP </a>，它是在Java中本地实现的，但是其他压缩方法也是可能的。另外，<a class="ae ky" href="https://commons.apache.org/proper/commons-io/" rel="noopener ugc nofollow" target="_blank"> Commons IO </a>库将用于保持解压缩逻辑简单。</p><p id="8ed6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是Gradle用户，请将此依赖项添加到项目的构建文件中:</p><pre class="kj kk kl km gt nt ns nu nv aw nw bi"><span id="a005" class="nx md it ns b gy ny nz l oa ob">compile "commons-io:commons-io:2.9.0"</span></pre><p id="f488" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，如果您是Maven用户，请将以下依赖项添加到项目的构建POM中:</p><pre class="kj kk kl km gt nt ns nu nv aw nw bi"><span id="3e10" class="nx md it ns b gy ny nz l oa ob">&lt;dependency&gt;<br/>    &lt;groupId&gt;commons-io&lt;/groupId&gt;<br/>    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;<br/>    &lt;version&gt;2.9.0&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="07c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您已经具备了定义自定义Redis序列化程序所需的一切。</p><h2 id="661f" class="nx md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">Java 语言(一种计算机语言，尤用于创建网站)</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="c775" class="nx md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">科特林</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="58c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，您需要将刚刚定义的类声明为默认的Redis值序列化程序。这可以通过在实现<code class="fe np nq nr ns b"><a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/CachingConfigurerSupport.html" rel="noopener ugc nofollow" target="_blank">CachingConfigurerSupport</a></code>的自定义<code class="fe np nq nr ns b"><a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html" rel="noopener ugc nofollow" target="_blank">@Configuration</a></code>注释类中注册一个<code class="fe np nq nr ns b">RedisCacheConfiguration</code> <a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Primary.html" rel="noopener ugc nofollow" target="_blank">主bean </a>来实现，如下所示:</p><h2 id="a994" class="nx md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">Java 语言(一种计算机语言，尤用于创建网站)</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="5421" class="nx md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">科特林</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="067a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧啊！您的Redis缓存将比以往更加自由！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a8ec" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">奖金</h1><p id="fdec" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">处理缓存可能会带来一些只有彻底清理才能解决的问题。这正是你应该通过添加一些管理工具来保护自己的原因，如这里的<a class="ae ky" href="https://levelup.gitconnected.com/building-an-api-to-clear-all-the-caches-of-your-spring-boot-application-2d0dfdfe71b3" rel="noopener ugc nofollow" target="_blank">所解释的</a>。</p><div class="op oq gp gr or os"><a href="https://levelup.gitconnected.com/building-an-api-to-clear-all-the-caches-of-your-spring-boot-application-2d0dfdfe71b3" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">构建一个API来清除Spring Boot应用程序的所有缓存</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">通过按需清除所有缓存数据来避免一致性问题</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div><p id="38ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，当错误发生时，你应该总是能够理解发生了什么。这就是为什么在您的Spring Boot应用程序中正确地<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-handle-cache-related-errors-in-spring-boot-679333e1beb7">处理与缓存相关的错误可能变得不可避免。</a></p><div class="op oq gp gr or os"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-handle-cache-related-errors-in-spring-boot-679333e1beb7"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">如何处理Spring Boot中与缓存相关的错误</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">保护您的Spring Boot应用程序免受缓存故障的影响</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">better编程. pub</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg ks os"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8125" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="dcac" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">处理内存中的缓存可能会显著增加架构的成本。这就是为什么您应该采用旨在减少缓存数据空间的方法。正如我们刚刚看到的，在您的Spring Boot应用程序中向缓存系统添加压缩逻辑并不复杂，因此它允许您节省空间和金钱。</p><p id="d86d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望这篇文章对你有所帮助。如果有任何问题、意见或建议，请随时联系我。</p></div></div>    
</body>
</html>