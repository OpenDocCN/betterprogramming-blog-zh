<html>
<head>
<title>Solidity Gas Optimizations Tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">固体气体优化技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solidity-gas-optimizations-and-tricks-2bcee0f9f1f2?source=collection_archive---------0-----------------------#2022-10-02">https://betterprogramming.pub/solidity-gas-optimizations-and-tricks-2bcee0f9f1f2?source=collection_archive---------0-----------------------#2022-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2cf0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">优化以太坊区块链费用的深入指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/99875a2c8c5cd19fd0ee4770a5e1fa37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2-cfQyzB4Ti1egWS.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="0be9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这篇文章是关于可靠性的高级气体优化。在这里你可以找到所有gas优化代码的最佳实践！我经常根据我的要点更新这篇文章<a class="ae lr" href="https://gist.github.com/grGred/9bab8b9bad0cd42fc23d4e31e7347144" rel="noopener ugc nofollow" target="_blank">。不要羞于开始。</a></p><p id="e807" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">固体气是在以太坊区块链进行交易所需的费用。gas的目的是限制系统将执行的事务数量。这限制了计算永远运行和垃圾网络。</p><h1 id="52c3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">将Pragma升级到最新的Solidity编译器版本</h1><p id="2f14" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">使用新的编译器版本和优化器免费提供气体优化和额外的安全检查！</p><p id="c772" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">版本<code class="fe mp mq mr ms b">0.8.*</code>相对于<code class="fe mp mq mr ms b">&lt;0.8.0</code>的优势在于:</p><ul class=""><li id="2db7" class="mt mu iq kx b ky kz lb lc le mv li mw lm mx lq my mz na nb bi translated">Safemath默认来自<code class="fe mp mq mr ms b">0.8.0</code>(可能比一些基于库的safemath更高效)。</li><li id="dedb" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated"><a class="ae lr" href="https://blog.soliditylang.org/2021/03/02/saving-gas-with-simple-inliner/" rel="noopener ugc nofollow" target="_blank">来自<code class="fe mp mq mr ms b">0.8.2</code>的低级内嵌器</a>，导致更便宜的运行时气体。当契约具有小功能时尤其相关。例如，OpenZeppelin库通常有许多小的辅助函数，如果它们没有被内联，它们会额外花费20到40 gas，因为函数调用需要两个额外的跳转指令和额外的堆栈操作。</li><li id="5036" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated"><a class="ae lr" href="https://blog.soliditylang.org/2021/03/23/solidity-0.8.3-release-announcement/#optimizer-improvements" rel="noopener ugc nofollow" target="_blank">打包结构中的优化器改进</a>:在<code class="fe mp mq mr ms b">0.8.3</code>之前，存储打包结构，在某些情况下，他们使用了额外的存储读取操作。在<a class="ae lr" href="https://eips.ethereum.org/EIPS/eip-2929" rel="noopener ugc nofollow" target="_blank"> EIP-2929 </a>之后，如果插槽已经是冷的，这意味着不必要的堆栈操作和额外的部署时间成本。然而，如果插槽已经是热的，这意味着除了相同的不必要的堆叠操作和额外的部署时间成本之外，还有100 gas的额外成本。</li><li id="1da6" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated"><a class="ae lr" href="https://blog.soliditylang.org/2021/04/21/custom-errors" rel="noopener ugc nofollow" target="_blank">自定义错误</a>来自<code class="fe mp mq mr ms b">0.8.4</code>，导致部署和运行时成本降低。注意:运行时开销仅在满足恢复条件时才相关。简而言之，用自定义错误替换恢复字符串。</li><li id="1dd0" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">坚固性<code class="fe mp mq mr ms b">0.8.10</code>有一个有用的变化，即<a class="ae lr" href="https://blog.soliditylang.org/2021/11/09/solidity-0.8.10-release-announcement/" rel="noopener ugc nofollow" target="_blank">降低了期望返回值的外部调用</a>的气体成本。如果需要返回数据，代码生成器将跳过外部协定的存在性检查。在这种情况下，如果合同不存在，ABI解码器将恢复。<code class="fe mp mq mr ms b">0.8.10</code>还使能纯Yul模式的新EVM码发生器。</li><li id="8bf0" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated"><a class="ae lr" href="https://blog.soliditylang.org/2022/06/15/solidity-0.8.15-release-announcement/" rel="noopener ugc nofollow" target="_blank">Yul优化器中改进的内联试探法</a>。在Solidity版本<code class="fe mp mq mr ms b">0.8.15</code>之前，编译器在决定是否内联一个函数时非常保守。这是必要的，因为内联很容易增加堆栈压力，导致可怕的<code class="fe mp mq mr ms b">Stack too deep</code>错误。在<code class="fe mp mq mr ms b">0.8.15</code>中，内联的必要条件被放宽了。基准测试表明，这一变化显著减小了字节码的大小(这会影响部署成本)，而对运行时gas使用的影响较小。</li><li id="115a" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated"><a class="ae lr" href="https://blog.soliditylang.org/2022/09/08/solidity-0.8.17-release-announcement/" rel="noopener ugc nofollow" target="_blank">溢出更高效地检查乘法运算</a>Solidity v 0 . 8 . 17 . Yul优化器:在调用有条件地终止外部EVM调用的Yul函数之前，防止不正确地移除存储写入；将零长度操作的起始偏移量简化为零。代码生成器:更有效的乘法溢出检查。</li></ul><h1 id="8bde" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">For循环改进</h1><h2 id="9a54" class="nh lt iq bd lu ni nj dn ly nk nl dp mc le nm nn me li no np mg lm nq nr mi ns bi translated">缓存for循环中的长度</h2><p id="f790" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在循环的每次迭代中读取数组长度在堆栈中需要6个gas(三个用于<code class="fe mp mq mr ms b">mload</code>，三个用于放置<code class="fe mp mq mr ms b">memory_offset</code>)。在堆栈中缓存数组长度可以在每次迭代中节省大约3 gas。我建议在for循环之前将数组的长度存储在一个变量中。</p><p id="88d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数组arr和以下循环的示例:</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="7e1f" class="nh lt iq ms b gy nx ny l nz oa">for (uint i = 0; i &lt; length; i++) {<br/>    // do something that doesn't change the value of i<br/>}</span></pre><p id="75fb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的例子中，solidity编译器将总是在每次迭代中读取数组的长度。</p><ol class=""><li id="7257" class="mt mu iq kx b ky kz lb lc le mv li mw lm mx lq ob mz na nb bi translated">如果是存储阵列，这是一个额外的<code class="fe mp mq mr ms b">sload</code>操作(除了第一次以外，每次迭代都有100个额外的gas ( <a class="ae lr" href="https://eips.ethereum.org/EIPS/eip-2929" rel="noopener ugc nofollow" target="_blank"> EIP-2929 </a>))，</li><li id="72aa" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq ob mz na nb bi translated">如果是一个<code class="fe mp mq mr ms b">memory</code>数组，这是一个额外的<code class="fe mp mq mr ms b">mload</code>操作(除了第一次，每次迭代有3个额外的gas)，</li><li id="e39c" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq ob mz na nb bi translated">如果是一个<code class="fe mp mq mr ms b">calldata</code>数组，这是一个额外的<code class="fe mp mq mr ms b">calldataload</code>操作(除了第一次，每次迭代有3个额外的gas)这些额外的开销可以通过缓存数组长度(在堆栈中)来避免:</li></ol><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="7481" class="nh lt iq ms b gy nx ny l nz oa">uint length = arr.length;<br/>for (uint i = 0; i &lt; length; i++) {<br/>    // do something that doesn't change arr.length<br/>}</span></pre><p id="d7a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的例子中，<code class="fe mp mq mr ms b">sload</code>或<code class="fe mp mq mr ms b">mload</code>或<code class="fe mp mq mr ms b">calldataload</code>操作只被调用一次，随后被廉价的<code class="fe mp mq mr ms b">dupN</code>指令所替代。即使<code class="fe mp mq mr ms b">mload</code>、<code class="fe mp mq mr ms b">calldataload</code>和<code class="fe mp mq mr ms b">dupN</code>具有相同的气体成本，但是<code class="fe mp mq mr ms b">mload</code>和<code class="fe mp mq mr ms b">calldataload</code>需要额外的<code class="fe mp mq mr ms b">dupN</code>来将偏移量放入堆栈，即额外的3个气体。</p><p id="3988" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果它是一个存储阵列，或者如果它的循环很长，那么这种优化就特别重要。</p><h2 id="314d" class="nh lt iq bd lu ni nj dn ly nk nl dp mc le nm nn me li no np mg lm nq nr mi ns bi translated">可以不检查for循环的post条件中的增量</h2><p id="a8bc" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在Solidity 0.8+中，有一个默认的无符号整数溢出检查。可以在for循环中取消对它的检查，在每次迭代中节省一些时间，但是要以牺牲一些代码可读性为代价，因为这个取消检查<a class="ae lr" href="https://github.com/ethereum/solidity/issues/10695" rel="noopener ugc nofollow" target="_blank">不能内联</a>。</p><p id="23b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一个循环的例子:</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="7114" class="nh lt iq ms b gy nx ny l nz oa">for (uint i = 0; i &lt; length; i++) {<br/>    // do something that doesn't change the value of i<br/>}</span></pre><p id="f49a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本例中，for循环的post条件，即<code class="fe mp mq mr ms b">i++</code>涉及检查算术，这不是必需的。这是因为I的值总是严格小于<code class="fe mp mq mr ms b">length &lt;= 2**256 - 1</code>。因此，<code class="fe mp mq mr ms b">i</code>的理论最大值进入for循环体<code class="fe mp mq mr ms b">is 2**256 - 2</code>。这意味着for循环中的<code class="fe mp mq mr ms b">i++</code>永远不会溢出。无论如何，溢出检查是由编译器执行的。</p><p id="820c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不幸的是，Solidity optimizer不够智能，无法检测到这一点并取消检查。您应该使用以下代码手动执行此操作:</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="ff22" class="nh lt iq ms b gy nx ny l nz oa">for (uint i = 0; i &lt; length; i = unchecked_inc(i)) {<br/>    // do something that doesn't change the value of i<br/>}</span><span id="70e9" class="nh lt iq ms b gy oc ny l nz oa">function unchecked_inc(uint i) returns (uint) {<br/>    unchecked {<br/>        return i + 1;<br/>    }<br/>}</span></pre><p id="e6e5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">或者使用以下内容:</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="cb8e" class="nh lt iq ms b gy nx ny l nz oa">for (uint i = 0; i &lt; length;) {<br/>    // do something that doesn't change the value of i<br/>    unchecked { i++; }<br/>}</span></pre><p id="04fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意对<code class="fe mp mq mr ms b">unchecked_inc</code>的调用是内联的，这一点很重要。这仅适用于从<code class="fe mp mq mr ms b">0.8.2</code>开始的坚固性版本。</p><p id="132f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">节约汽油:粗略地说，每次循环迭代可以节约30-40汽油。对于冗长的循环，这一点非常重要！(这仅在使用默认的可靠性检查算法时才相关。)</p><h2 id="6b39" class="nh lt iq bd lu ni nj dn ly nk nl dp mc le nm nn me li no np mg lm nq nr mi ns bi translated"><code class="fe mp mq mr ms b">++i</code>与<code class="fe mp mq mr ms b">i++</code>或<code class="fe mp mq mr ms b">i += 1</code>相比，消耗的汽油更少</h2><p id="ef45" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">与无符号整数的<code class="fe mp mq mr ms b">i++</code>或<code class="fe mp mq mr ms b"> i += 1</code>相比，<code class="fe mp mq mr ms b">++i </code>消耗更少的gas，因为预增量更便宜(每次迭代大约5 gas)。即使启用了优化器，这种说法也是正确的。</p><p id="a39f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例:<code class="fe mp mq mr ms b">i++</code>递增<code class="fe mp mq mr ms b">i</code>，返回<code class="fe mp mq mr ms b">i</code>的初始值，如下图:</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="708c" class="nh lt iq ms b gy nx ny l nz oa">uint i = 1; <br/>i++; // == 1 but i == 2</span></pre><p id="3c70" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是<code class="fe mp mq mr ms b">++i</code>返回实际增加的值。</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="6a14" class="nh lt iq ms b gy nx ny l nz oa">uint i = 1; <br/>++i; // == 2 and i == 2 too, so no need for a temporary variable</span></pre><p id="8cbe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第一种情况下，编译器必须创建一个临时变量(当使用时)来返回<code class="fe mp mq mr ms b">1</code>而不是<code class="fe mp mq mr ms b">2</code>。</p><h2 id="2859" class="nh lt iq bd lu ni nj dn ly nk nl dp mc le nm nn me li no np mg lm nq nr mi ns bi translated">不需要用默认值显式初始化变量</h2><p id="8204" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果一个变量没有被设置/初始化，它被假定为具有默认值(0代表uint，false代表bool，address(0)代表address，等等。).用默认值显式初始化它是一种反模式，而且浪费时间。例如:<code class="fe mp mq mr ms b">for (uint256 i = 0; i &lt; numIterations; ++i) {</code>应替换为:<code class="fe mp mq mr ms b">for (uint256 i; i &lt; numIterations; ++i) {</code></p><h2 id="8952" class="nh lt iq bd lu ni nj dn ly nk nl dp mc le nm nn me li no np mg lm nq nr mi ns bi translated">不要删除for循环中<code class="fe mp mq mr ms b">i</code>变量的初始化</h2><p id="f4ea" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我看到很多项目中，开发人员错误地认为在for循环之外移除<code class="fe mp mq mr ms b">i</code>变量可以节省时间。在下面的片段中，您可以看到这是错误的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="9667" class="nh lt iq bd lu ni nj dn ly nk nl dp mc le nm nn me li no np mg lm nq nr mi ns bi translated">总而言之，最佳气体优化回路将是:</h2><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="c8da" class="nh lt iq ms b gy nx ny l nz oa">uint length = arr.length;<br/>for (uint i; i &lt; length;) {<br/>    unchecked { ++i; }<br/>}</span></pre><h1 id="7af8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">对函数参数使用calldata而不是内存</h1><p id="8e5c" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在某些情况下，将函数参数放在<code class="fe mp mq mr ms b">calldata</code>中比放在<code class="fe mp mq mr ms b">memory</code>中更好。当参数在外部函数上为只读时，数据位置应为<code class="fe mp mq mr ms b">calldata</code>。</p><p id="6b0d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="2fee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的例子中，动态数组arr有存储位置<code class="fe mp mq mr ms b">memory</code>。当函数被外部调用时，数组值保存在<code class="fe mp mq mr ms b">calldata</code>中，并在ABI解码期间复制到<code class="fe mp mq mr ms b">memory</code>(使用操作码<code class="fe mp mq mr ms b">calldataload</code>和<code class="fe mp mq mr ms b">mstore</code>)。在for循环期间，<code class="fe mp mq mr ms b">arr[i]</code>使用<code class="fe mp mq mr ms b">mload</code>访问<code class="fe mp mq mr ms b">memory</code>中的值。然而，对于上面的例子，这是低效的。请考虑下面的代码片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="fede" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码片段中，使用<code class="fe mp mq mr ms b">calldataload</code>直接从<code class="fe mp mq mr ms b">calldata</code>读取值，而不是通过<code class="fe mp mq mr ms b">memory</code>。也就是说，没有携带该值的中间<code class="fe mp mq mr ms b">memory</code>操作。</p><p id="d3d0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">节省汽油:在前一个例子中，ABI解码从在for循环中将值从<code class="fe mp mq mr ms b">calldata</code>复制到<code class="fe mp mq mr ms b">memory</code>开始。每次迭代将花费至少60个气体。在后一个例子中，这是完全可以避免的。这还将减少指令的数量，从而减少合同的部署时间成本。</p><p id="7f36" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简而言之，如果函数参数是只读的，就用<code class="fe mp mq mr ms b">calldata</code>代替<code class="fe mp mq mr ms b">memory</code>。</p><p id="5441" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，在旧的Solidity版本中，将一些函数参数从<code class="fe mp mq mr ms b">memory</code>更改为<code class="fe mp mq mr ms b">calldata</code>可能会导致“未实现的特性错误”这可以通过使用更新的(<code class="fe mp mq mr ms b">0.8.*</code> ) Solidity编译器来避免。</p><h1 id="6185" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">尽可能将状态变量改为不可变的</h1><p id="1458" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated"><a class="ae lr" href="https://blog.soliditylang.org/2020/04/06/solidity-0.6.5-release-announcement/" rel="noopener ugc nofollow" target="_blank"> Solidity 0.6.5 </a>引入了不可变作为主要特性。它允许在构造时设置契约级变量，这些变量存储在代码中而不是存储中。</p><p id="66c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个例子:</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="f619" class="nh lt iq ms b gy nx ny l nz oa">contract C {<br/>    /// The owner is set during contruction time, and never changed afterwards.<br/>    address public owner = msg.sender;<br/>}</span></pre><p id="c3cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的例子中，每次调用函数<code class="fe mp mq mr ms b">owner()</code>都使用一个<code class="fe mp mq mr ms b">sload</code>从存储器中读取数据。在<a class="ae lr" href="https://eips.ethereum.org/EIPS/eip-2929" rel="noopener ugc nofollow" target="_blank"> EIP-2929 </a>之后，这需要2100气体冷却或100气体加热。但是，下面的代码片段更省气:</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="0e7e" class="nh lt iq ms b gy nx ny l nz oa">contract C {<br/>    /// The owner is set during contruction time, and never changed afterwards.<br/>    address public immutable owner = msg.sender;<br/>}</span></pre><p id="c018" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的例子中，所有者状态变量的每个存储读取由指令<code class="fe mp mq mr ms b">push32</code>值代替，其中该值在契约构造时间期间设置。不像上一个例子，这个只需要3块钱。</p><h1 id="1e4c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">将keccak变量的常量更改为不可变</h1><p id="f727" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">常量keccak变量的使用导致了额外的散列(以及gas)。这导致每当使用该变量时就执行keccak操作，相对于只存储输出散列来说，增加了gas成本。更改为<code class="fe mp mq mr ms b">immutable </code>将仅对合同部署执行哈希运算，这将节省汽油。您应该使用<code class="fe mp mq mr ms b">immutables</code>直到引用的问题被实现，然后您只需在部署时为计算支付gas成本。</p><p id="9576" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="dc72" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如你在编译器版本<code class="fe mp mq mr ms b">0.8.15</code>上看到的，优化器运行200次时，不变量更便宜，可以节省20%的汽油。对于其他变量，<code class="fe mp mq mr ms b">constants</code>等于<code class="fe mp mq mr ms b">immutables</code>。</p><p id="8d52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">参见:(<a class="ae lr" href="https://github.com/ethereum/solidity/issues/9232#issuecomment-646131646" rel="noopener ugc nofollow" target="_blank">以太坊/solidity#9232(评论)</a>，<a class="ae lr" href="https://github.com/seen-haus/seen-contracts/issues/29" rel="noopener ugc nofollow" target="_blank">低效哈希常数</a>)。</p><h1 id="b63b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">考虑使用短的还原字符串</h1><p id="4dd8" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">让我们考虑下面的require语句:</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="376e" class="nh lt iq ms b gy nx ny l nz oa">// condition is boolean<br/>// str is a string<br/>require(condition, str)</span></pre><p id="08a7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">字符串str被分割成32字节大小的块，然后使用<code class="fe mp mq mr ms b">mstore</code>存储在<code class="fe mp mq mr ms b">memory</code>中，然后<code class="fe mp mq mr ms b">memory</code>偏移量被提供给<code class="fe mp mq mr ms b">revert(offset, length)</code>。对于短于32字节的块，以及低优化运行值(通常甚至是默认值200)，solidity编译器用<code class="fe mp mq mr ms b">shl(value, short-value))</code>代替<code class="fe mp mq mr ms b">push32</code> val，其中val是字符串的32字节十六进制表示，在最低有效位上填充0。其中短值没有任何0填充。</p><p id="5724" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这节省了部署代码中的总字节数，从而节省了部署时间成本，代价是在运行时增加了6个gas。这意味着较短的恢复字符串节省了合同的部署时间成本。请注意，这种节省与-optimize-runs的高值无关，因为Solidity编译器不会用等价的<code class="fe mp mq mr ms b">shl(..., ...)</code>替换<code class="fe mp mq mr ms b">push32</code>值。</p><p id="9266" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">回头看，字符串的每个32字节块都需要一个额外的<code class="fe mp mq mr ms b">mstore</code>。即<code class="fe mp mq mr ms b">mstore</code>、<code class="fe mp mq mr ms b">memory</code>扩展成本以及堆栈操作的额外成本。请注意，这个运行时开销仅在满足恢复条件时才相关。</p><p id="a8f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">总的来说，较短的还原字符串可以节省部署时间和运行时成本。</p><p id="61af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，如果您的合同已经允许至少使用Solidity <code class="fe mp mq mr ms b">0.8.4</code>，那么请考虑使用<a class="ae lr" href="https://blog.soliditylang.org/2021/04/21/custom-errors" rel="noopener ugc nofollow" target="_blank">自定义错误</a>。这更加节省气体，同时允许开发者使用<a class="ae lr" href="https://docs.soliditylang.org/en/latest/natspec-format.html" rel="noopener ugc nofollow" target="_blank"> NatSpec </a>详细描述错误。这种方法的一个缺点是一些工具可能对此没有适当的支持。</p><h1 id="44bb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">将克隆用于廉价的合同部署</h1><p id="fb08" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">这里有一个例子:</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="0e75" class="nh lt iq ms b gy nx ny l nz oa">function _executeTransfer(address _owner, uint256 _idx) internal {<br/>         (bytes32 salt, ) = precompute(_owner, _idx);<br/>         new FlashEscrow{salt: salt}( //gas: deployment can cost less through clones<br/>             nftAddress,<br/>             _encodeFlashEscrowPayload(_idx)<br/>         );<br/>     }</span></pre><p id="3889" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有一种方法可以在使用克隆的部署上节省大量的气体:<a class="ae lr" href="https://www.youtube.com/watch?v=3Mw-pMmJ7TA" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin video </a>这是一个被Porter Finance采用的解决方案。他们意识到使用克隆进行部署要便宜10倍。我建议在工厂合同中采用类似的模式。</p><p id="d79a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">参见:<a class="ae lr" href="https://github.com/porter-finance/v1-core/issues/15#issuecomment-1035639516" rel="noopener ugc nofollow" target="_blank">波特-财务/v1-核心#15(注释)</a> <a class="ae lr" href="https://github.com/porter-finance/v1-core/pull/34" rel="noopener ugc nofollow" target="_blank">波特-财务/v1-核心#34 </a></p><h1 id="6ac4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用修饰符而不是函数来节省汽油</h1><p id="0eac" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">具有修改量和内部查看功能的两个合同的实例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a4c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">差异:</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="94ca" class="nh lt iq ms b gy nx ny l nz oa">Deploy Modifier.sol<br/>108727<br/>Deploy Inlined.sol<br/>110473<br/>Modifier.foo<br/>21532<br/>Inlined.foo<br/>21556</span></pre><p id="9514" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">启用了<code class="fe mp mq mr ms b">0.8.9</code>编译器和优化。正如你所看到的，用修改器部署更便宜，可以节省30点汽油。但有时修饰符会增加契约的代码量。</p><h1 id="884a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在修饰符中使用内部视图函数来保存字节码</h1><p id="57d4" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">建议将修饰符require语句移到<code class="fe mp mq mr ms b">internal virtual function</code>中。这减少了使用修饰符的已编译契约的大小。当修饰符被多次使用时，将require放在内部函数中会减小契约的大小。<code class="fe mp mq mr ms b">private</code>和<code class="fe mp mq mr ms b">internal</code>功能的调配气成本没有区别。</p><p id="355c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随着坚实度<code class="fe mp mq mr ms b">0.8.14</code>和优化打开(200):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="0a3c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">参见:<a class="ae lr" href="https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3347/" rel="noopener ugc nofollow" target="_blank">优化可拥有和可停用修改量的大小影响#3347 </a> <a class="ae lr" href="https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3223" rel="noopener ugc nofollow" target="_blank">减少</a> <code class="fe mp mq mr ms b"><a class="ae lr" href="https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3223" rel="noopener ugc nofollow" target="_blank">onlyOwner</a></code> <a class="ae lr" href="https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3223" rel="noopener ugc nofollow" target="_blank">修改量</a>的合同大小和部署气。</p><h1 id="4bcb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><code class="fe mp mq mr ms b">&gt;=</code>比<code class="fe mp mq mr ms b">&gt;</code>便宜</h1><p id="f632" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">非严格不等式(<code class="fe mp mq mr ms b">&gt;=</code>)比严格不等式(<code class="fe mp mq mr ms b">&gt;</code>)便宜。这是由于一些补充检查(<code class="fe mp mq mr ms b">ISZERO</code>，3气体)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e6d9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">节省汽油:不严格的不平等将为你节省15-20英镑的汽油。</p></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><h1 id="3929" class="ls lt iq bd lu lv om lx ly lz on mb mc jw oo jx me jz op ka mg kc oq kd mi mj bi translated"><code class="fe mp mq mr ms b">&gt; 0</code>有时比<code class="fe mp mq mr ms b">!= 0</code>便宜</h1><p id="eb99" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">对于启用了优化器的require语句中的无符号整数，<code class="fe mp mq mr ms b">!= 0</code>比<code class="fe mp mq mr ms b">&gt; 0</code>消耗更少的gas。但是<code class="fe mp mq mr ms b">&gt; 0</code>比<code class="fe mp mq mr ms b">!=</code>便宜，因为它启用了优化器，并且在require语句之外。<a class="ae lr" href="https://twitter.com/gzeon/status/1485428085885640706" rel="noopener ugc nofollow" target="_blank">https://twitter.com/gzeon/status/1485428085885640706</a></p><p id="ed43" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">禁用优化器的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="3a8a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">启用优化器的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="56d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">节省汽油:它将为你节省大约10块汽油。</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="ee22" class="nh lt iq ms b gy nx ny l nz oa">To sum up on 0.8.15:<br/>    Without optimizer:<br/>        In require:<br/>            `&gt; 0` equals to `!= 0`<br/>        Outside require:<br/>            `&gt; 0` more expensive than `!= 0` <br/>    With optimizer:<br/>        In require:<br/>            `&gt; 0` more expensive than `!= 0`<br/>        Outside require:<br/>            `&gt; 0` cheaper than `!= 0`</span></pre><p id="118c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">参见:<a class="ae lr" href="https://twitter.com/gzeon/status/1485428085885640706" rel="noopener ugc nofollow" target="_blank">https://twitter.com/gzeon/status/1485428085885640706</a></p><h1 id="aaa6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">如果可能，使用右/左移代替除法/乘法</h1><p id="c20f" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">通过将log2(x)向右/向左移位，可以计算除以任何2的幂的数x的除法/乘法。虽然<code class="fe mp mq mr ms b">DIV</code>操作码使用5种气体，但<code class="fe mp mq mr ms b">SHR</code>操作码仅使用3种气体。此外，Solidity的除法运算还包括一个防止被0除的功能，通过移位可以绕过该功能。</p><h1 id="5c72" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用双Require代替运算符&amp;&amp;</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="d4cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">节省汽油:使用双<code class="fe mp mq mr ms b">require</code>可以在优化器开启的情况下节省大约10点汽油。</p><h1 id="8eb6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用自定义错误而不是还原字符串来节省时间</h1><p id="3e38" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我之前已经提到过了，我强烈推荐使用这个。来自Solidity <code class="fe mp mq mr ms b">0.8.4</code>的自定义错误比revert strings更便宜(满足revert条件时更便宜的部署成本和运行时成本)来源:<a class="ae lr" href="https://blog.soliditylang.org/2021/04/21/custom-errors/" rel="noopener ugc nofollow" target="_blank">https://blog.soliditylang.org/2021/04/21/custom-errors/</a>:从<a class="ae lr" href="https://github.com/ethereum/solidity/releases/tag/v0.8.4" rel="noopener ugc nofollow" target="_blank"> Solidity </a> <code class="fe mp mq mr ms b"><a class="ae lr" href="https://github.com/ethereum/solidity/releases/tag/v0.8.4" rel="noopener ugc nofollow" target="_blank">v0.8.4</a></code>开始，有一种方便又气的方式，通过使用自定义错误向用户解释为什么一个操作失败了。</p><p id="a17a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">到目前为止，您已经可以使用字符串来提供关于故障的更多信息(例如<code class="fe mp mq mr ms b"> revert("Insufficient funds.");</code>)，但是它们相当昂贵，尤其是当涉及到部署成本时，并且很难在其中使用动态信息。自定义错误是使用error语句定义的，可以在契约内部和外部使用(包括接口和库)。</p><h1 id="845f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">对于变量和功能，公共/外部/内部/私有之间的气体成本没有差异</h1><p id="a948" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">出于安全考虑还是严格定义函数可见性比较好，但不会影响用气。但这将影响这些功能部署天然气成本。<code class="fe mp mq mr ms b">internal</code>和<code class="fe mp mq mr ms b">private</code>功能在调配气成本上没有区别。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a4e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mp mq mr ms b">Public</code>变量与<code class="fe mp mq mr ms b">internal</code>和<code class="fe mp mq mr ms b">private</code>变量的成本相同:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="7c68" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">顺便说一下，可变的能见度影响部署的气体。<code class="fe mp mq mr ms b">public</code>变量的成本比<code class="fe mp mq mr ms b">private</code>或<code class="fe mp mq mr ms b">internal</code>高，但<code class="fe mp mq mr ms b">private</code>和<code class="fe mp mq mr ms b">internal</code>的调配气成本没有区别。</p><h1 id="d486" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在内存中缓存存储变量以节省汽油</h1><p id="a09f" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">每当你不止一次从<code class="fe mp mq mr ms b">storage</code>中读取数据时，在<code class="fe mp mq mr ms b">memory</code>中缓存变量的气体成本更低:a <code class="fe mp mq mr ms b">SLOAD</code>花费100气体，而<code class="fe mp mq mr ms b">MLOAD</code>和<code class="fe mp mq mr ms b">MSTORE</code>花费3气体。</p><p id="62a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">节省汽油:至少97汽油。</p><h1 id="2d74" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">小心不要将整个结构复制到内存中</h1><p id="24e8" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">有时候，在<code class="fe mp mq mr ms b">memory</code>里用<code class="fe mp mq mr ms b">storage</code>比抄<code class="fe mp mq mr ms b">struct</code>更好。这里有一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="609c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里，<code class="fe mp mq mr ms b">memory</code>中的一个副本的成本是3 <code class="fe mp mq mr ms b">SLOADs</code>和3 <code class="fe mp mq mr ms b">MSTORES</code>。两个变量通过MLOAD ( <code class="fe mp mq mr ms b">position.owner</code>和<code class="fe mp mq mr ms b">position.unlockAt</code>)只读取一次，一个读取两次(<code class="fe mp mq mr ms b">position.lockAmount</code>)。最好把<code class="fe mp mq mr ms b">memory</code>关键字换成<code class="fe mp mq mr ms b">storage</code>，只复制<code class="fe mp mq mr ms b">memory</code>中的<code class="fe mp mq mr ms b">position.lockAmount</code>。</p><h1 id="dfb7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">通过保存存储变量的引用来帮助优化器</h1><p id="b2b0" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">为了帮助优化器，声明一个<code class="fe mp mq mr ms b">storage</code>类型的变量并使用它，而不是在映射或数组中重复获取引用。效果可能相当显著。</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="d2b8" class="nh lt iq ms b gy nx ny l nz oa">function borrow(<br/>   Position storage position = positions[_nftIndex];</span></pre><h1 id="1127" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用带有大量前导零的地址</h1><p id="b673" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果你有两个地址——0x 000000 a 4323…和0x0000000000f38210。由于前导零，您可以将它们打包到同一个存储槽中，然后在使用它们时只需预先添加必要数量的零。这可以为您节省存储空间，例如检查合同的所有者。</p><h1 id="f885" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">写入现有的存储插槽比使用新的要便宜</h1><p id="9528" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">EIP——2200年用汽油改变了很多，现在如果你持有1魏的代币，使用代币比持有0元更便宜。这里有很多东西要解开，所以只要谷歌EIP 2200，如果你想学习，但一般来说，如果你需要使用存储插槽，不要清空它，如果你打算以后再装满它。</p><h1 id="1d38" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">固体包装结构</h1><p id="f7f8" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated"><a class="ae lr" href="https://dev.to/javier123454321/solidity-gas-optimizations-pt-3-packing-structs-23f4" rel="noopener ugc nofollow" target="_blank">在这里构造包装物品</a>。</p><p id="36b5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个基本的优化，但重要的是要知道，结构应该组织，使他们按顺序增加到256位大小的倍数。因此，请使用以下内容:</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="717e" class="nh lt iq ms b gy nx ny l nz oa">Struct {<br/>    uint112 <br/>    uint112 <br/>    uint256 <br/>}</span></pre><p id="2523" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">而不是:</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="d088" class="nh lt iq ms b gy nx ny l nz oa">Struct {<br/>    uint112 <br/>    uint256 <br/>    uint112<br/>}</span></pre><p id="aad0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">契约中变量的顺序也是如此。遵循优化的顺序，为部署节省汽油。因此，请使用以下内容:</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="1443" class="nh lt iq ms b gy nx ny l nz oa">contract Test {<br/>    uint256 // 2 storage slots<br/>    address // address is 20 bytes and bool is 1 byte are packed in one slot<br/>    bool<br/>}</span></pre><p id="4c58" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">而不是:</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="752a" class="nh lt iq ms b gy nx ny l nz oa">contract Test {<br/>    address // 3 storage slots<br/>    uint256 <br/>    bool<br/>}</span></pre><h1 id="83af" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用Gasleft()测量已用气体，而不是检查交易气体成本，以便找到气体优化</h1><p id="3116" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在审计gas优化改进的代码时，使用<a class="ae lr" href="https://www.npmjs.com/package/hardhat-gas-reporter" rel="noopener ugc nofollow" target="_blank">安全帽gas reporter </a>非常方便。它将显示每个单元测试的气体使用量。但是，如果您没有时间初始化一个新项目并为您的函数编写测试，或者您想要检查一个关于gas优化的神话，您就不应该查看事务的gas成本。不要忘记在Solidity中，<a class="ae lr" href="https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92" rel="noopener">函数名和它们在契约中的顺序</a>取不同的气体量。</p><p id="72f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个例子:</p><pre class="kg kh ki kj gt nt ms nu nv aw nw bi"><span id="f966" class="nh lt iq ms b gy nx ny l nz oa">contract Test {<br/>    function a() public { // 125 gas<br/>    }<br/>    <br/>    function b() public { // 147 gas<br/>    }<br/>}</span></pre><p id="79dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是为什么您应该将事务的主体包装为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e59a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不要忘记在相同的条件下测试这两种功能。记住提示“写入现有的存储插槽比使用新的便宜。”</p></div></div>    
</body>
</html>