<html>
<head>
<title>Setup a 3D Chessboard With SwiftUI and RealityKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI和RealityKit设置3D棋盘</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-3d-chess-with-swiftui-and-realitykit-43d84095e46?source=collection_archive---------8-----------------------#2022-12-05">https://betterprogramming.pub/build-a-3d-chess-with-swiftui-and-realitykit-43d84095e46?source=collection_archive---------8-----------------------#2022-12-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c842" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用SwiftUI、RealityKit、ARKit和Multipeer框架</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/989ec9d912dd7efe36458fdd6e48f3f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IzmZwnLTlXV3dqEnyNorrw.png"/></div></div></figure><p id="1095" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今年[2022]我花了大部分时间探索SceneKit。我记录了一次旅行，在medium上你可以找到差不多24篇关于这个主题的文章。在涵盖了SceneKit中的大部分元素之后，我决定在2023年转移到RealityKit/ARKit。</p><p id="51a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然我不确定从哪里开始，但我在ARKit上观看了WWDC2022的最新演示，然后RealityKit和well它没有帮助。我查了一下哪个先来，然后是我能查到的最早的WWDC。</p><p id="7f6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我看的这个是WWDC2019上的“<a class="ae lq" href="https://developer.apple.com/videos/play/wwdc2019/605/" rel="noopener ugc nofollow" target="_blank">用RealityKit </a>构建应用”。这几乎是一个灵光乍现的时刻。我不禁反思SceneKit和RealityKit的相似之处。RealityKit是SceneKit。他们可能是在考虑到多处理的情况下从头开始开发它的，但是在许多情况下，这些原语看起来几乎是相同的。他们想尽可能平稳地从一个过渡到另一个。事实上，如果你甚至可以在没有摄像头的情况下创建一个基于RealityKit的应用程序，这个应用程序最终看起来就像你在SceneKit上做的一样。ARKit似乎是RealityKit不可分割的一部分，所以它们就像阴和阳；一个只有和另一个在一起才有意义。</p><p id="2fd0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看完演示后，我决定使用RealityKit/ARKit重建我在<a class="ae lq" href="https://medium.com/better-programming/start-building-a-3d-chess-game-using-scenekit-and-swiftui-3d072b025db2" rel="noopener">这篇论文</a>中描述的象棋游戏，重点放在前两个部分。建立一个原型并用游戏状态整理它。</p><h1 id="1ab3" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">原型</h1><h2 id="6c8d" class="mj ls it bd lt mk ml dn lx mm mn dp mb ld mo mp md lh mq mr mf ll ms mt mh mu bi translated">不可再现</h2><p id="26a9" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">bon——所以都快2023年了，没有让时光倒流，对我来说使用UIKit构建计划将与WWDC2019演示文稿中描述的计划相同，只有一些小的更改和更新。<br/>我复制了我上一篇SceneKit文章后面的代码，并将其作为构建的基础。我的UIRepresentable和你想象的一样简单，只有十行左右。</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="69dd" class="nf ls it nb b be ng nh l ni nj">struct CustomARView: UIViewRepresentable {<br/>    typealias UIViewType = ARView<br/>    <br/>    var view:ARView<br/>    var options: [Any] = []<br/>    <br/>    func makeUIView(context: Context) -&gt; ARView {<br/>        view.session.delegate = context.coordinator<br/>        return view<br/>    }<br/>    <br/>    func updateUIView(_ view: ARView, context: Context) {<br/>    }<br/>    <br/>    func makeCoordinator() -&gt; Coordinator {<br/>        Coordinator(self.view)<br/>    }<br/><br/>    // coordinator <br/>}</span></pre><h2 id="646f" class="mj ls it bd lt mk ml dn lx mm mn dp mb ld mo mp md lh mq mr mf ll ms mt mh mu bi translated">协调器类</h2><p id="421d" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">coordinator类同样简单，这里是框架代码，没什么特别的。</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="dc54" class="nf ls it nb b be ng nh l ni nj">class Coordinator: NSObject, ARSessionDelegate {<br/>        private let arView: ARView<br/><br/>        init(_ view: ARView) {<br/>            <br/>            self.arView = view<br/>            super.init()<br/>            <br/>         }</span></pre><p id="13bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这一点上，这是显而易见的；我在一个屏幕上播放了WWDC2019，并在另一个屏幕上更新了协调器内的代码。我在这里建立了一个原型，所以，不需要整个板，只需要基本的代码，理解语义和语法。</p><p id="f636" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我最初遇到了一个小问题，因为我的模型看起来像怪物，这很容易解决。我在transform的语法上遇到了第二个障碍，这与我的预期不同，尽管令人惊喜的是，苹果公司在这里很好地记录了它，并且它也很快得到了解决。</p><p id="fc1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是最基本的——事实上，我甚至领先一步，因为我已经为我的原型使用了3D模型，只是我使用了错误的调用来加载它们。我在同步做这件事，导致我的应用程序冻结。我在这个<a class="ae lq" href="https://stackoverflow.com/questions/62752649/realitykit-asynchronous-model-loading-doesnt-work" rel="noopener ugc nofollow" target="_blank">的帮助下改进了异步代码，所以发布</a>。这里的变量加载属于可取消类型。【WWDC2019代码都不会编译】。</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="4e08" class="nf ls it nb b be ng nh l ni nj">loading = Entity.loadModelAsync(named: assetName)<br/>    .sink(receiveCompletion: { completion in<br/>        if case let .failure(error) = completion {<br/>            print("Unable to load a model due to error \(error)")<br/>        }<br/>        self.loading?.cancel()<br/>        <br/>    }, receiveValue: { [self] (entity: Entity) in<br/>        if let entity = entity as? ModelEntity {<br/>            let piecePlayer = entity<br/>            loading?.cancel()<br/>            print("Congrats! Model is successfully loaded!")<br/>            piecePlayer.position = SIMD3(x: 0, y: 0, z: 0)<br/>            piecePlayer.setScale(SIMD3(0.01,0.01,0.01), relativeTo: piecePlayer)<br/>            piecePlayer.generateCollisionShapes(recursive: true)<br/>            piecePlayer.name = "GCHKing"<br/>            anchor.addChild(piecePlayer)<br/>        }<br/>    })</span></pre><p id="124f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我仍然需要冲浪板。在SceneKit中，我已经用立方体构建了一个，但它对RealityKit来说没什么意义，所以我决定在这段代码中使用一个普通的网格。我将代码嵌入到几个循环和几个布尔运算中，以得到完整的电路板。</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="3f97" class="nf ls it nb b be ng nh l ni nj">let material = SimpleMaterial(color: .black, isMetallic: true)<br/>let plainMesh = MeshResource.generatePlane(width: 0.1, depth: 0.1)<br/>let entity = ModelEntity(mesh: plainMesh, materials: [material])<br/>anchor.addChild(entity)</span></pre><p id="dbd7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在WWDC2019上构建游戏进行了一半——但在这一点上，我遇到了另一个障碍。照明不工作——这是一个有用的问题，因为我不知道照明在ARKit中是如何工作的，并在这里找到了一些有用的代码。</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="1784" class="nf ls it nb b be ng nh l ni nj">directionalLight.light.color = .white<br/>directionalLight.light.intensity = 500<br/>directionalLight.light.isRealWorldProxy = true<br/>directionalLight.shadow?.maximumDistance = 1<br/>directionalLight.shadow?.depthBias = 4.0<br/>directionalLight.orientation = simd_quatf(angle: Float(0).degrees2radians(),<br/>                                           axis: [0,1,0])<br/><br/>let lightAnchor = AnchorEntity(world: [0,1,0])<br/>lightAnchor.addChild(directionalLight)<br/>arView.scene.anchors.append(lightAnchor)</span></pre><h2 id="116c" class="mj ls it bd lt mk ml dn lx mm mn dp mb ld mo mp md lh mq mr mf ll ms mt mh mu bi translated">游戏状态</h2><p id="861f" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">bon——当我们进行到WWDC2019演示的这一部分时，我怀疑他们的时间不多了。我猜这是因为他们没有解释如何将他们解释的实体/组件代码与它集成。更糟糕的是，我被async代码中糟糕的ModelEntity命名弄糊涂了。在演示中，他们称之为“模型”。这个名字实际上意味着你需要在带有<code class="fe nk nl nm nb b">model.model</code>的模型中引用这个模型——不好，苹果。</p><p id="c4f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回到现实世界，你有两个棋手，一白一黑，轮流下。因此，我的自定义组件将是您刚刚点击的棋子的颜色，以确保它是您要移动的布景。我还想给不同的部分赋予一个值，一个语义，我可以用它来判断谁赢了或者输了游戏。</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="c0d7" class="nf ls it nb b be ng nh l ni nj">enum PieceColor: Codable {<br/>    case black<br/>    case white<br/>}<br/><br/>struct PieceComponent: Component, Codable {<br/>    var color: PieceColor<br/>    var value: Int<br/>}<br/><br/>class ChessEntity: Entity, HasModel, HasCollision, HasPhysics {<br/>    //public var model: ModelEntity!<br/>    public var piece: PieceComponent {<br/>        get { return components[PieceComponent.self] ?? PieceComponent(color: .white, value: 0) }<br/>        set { components[PieceComponent.self] = newValue }<br/>    }<br/>}</span></pre><p id="5c1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在我创建的自定义类中添加了一个新组件来表示棋子，以及您可以对它们采取的动作。在这一点上，我只是想要一个最小可行的产品。</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="e99e" class="nf ls it nb b be ng nh l ni nj">extension ChessEntity {<br/>    func movePiece() {<br/>        print("name \(self.name)")<br/>        self.transform.translation -= SIMD3&lt;Float&gt;(0,0,-0.1)<br/>    }<br/>}</span></pre><p id="a1c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您与现有例程集成的代码，即资产的加载和当有人点击某个部分时的检测/操作。您需要对设置了实体的负载进行的更改只有两行。</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="66fd" class="nf ls it nb b be ng nh l ni nj">let piecePlayer = ChessEntity()<br/>piecePlayer.model = entity.model<br/></span></pre><p id="37e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">把重要的棋子放好之后，我就准备给象棋游戏添加动作了。我从WWDC2019展示中获得的行动或多或少。从简单的<code class="fe nk nl nm nb b">UITapgestureRecognizer</code>触发的代码。</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="73c6" class="nf ls it nb b be ng nh l ni nj">@objc func handleTap2(_ sender: UIGestureRecognizer? = nil) {<br/>    let tapLocation = sender?.location(in: arView)<br/>    if let piece = arView.entity(at: tapLocation!) as? ChessEntity {<br/>        piece.movePiece()<br/>    }<br/>    <br/>}</span></pre><h2 id="fae7" class="mj ls it bd lt mk ml dn lx mm mn dp mb ld mo mp md lh mq mr mf ll ms mt mh mu bi translated">图像</h2><p id="9d78" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">一切就绪后，我搭建了棋盘，并把我的棋子放在上面。我为下一步做好了准备。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/d76acf56ebdc4acb1c8a529984844cec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-dxKlYelTPMGxtiuE-EyOg.png"/></div></div></figure><h2 id="21f2" class="mj ls it bd lt mk ml dn lx mm mn dp mb ld mo mp md lh mq mr mf ll ms mt mh mu bi translated">将来的</h2><p id="a8a8" class="pw-post-body-paragraph ku kv it kw b kx mv ju kz la mw jx lc ld mx lf lg lh my lj lk ll mz ln lo lp im bi translated">这就是增强现实版国际象棋的原型，不仅使用了RealityKit，还使用了ARKit——这两者感觉几乎不可分割。</p><p id="fcf6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，仍然有相当多的东西需要实现——在演示中，他们完成了一个多人版本，这是与SceneKit的一个显著区别，也是我必须实现的。我希望这一次我能比上次做得更多一点。或许在游戏中加入一些智能。</p><p id="de44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我的思绪回到了2022年3月我开始这段旅程的时候。我当时认为SceneKit没有死；它只是在休息。现在说我是否改变了主意还为时过早，但我对RealityKit和SceneKit之间的相似之处感到惊讶。</p><p id="c306" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也就是说，四处搜索，我找到了托尼·莫拉莱斯的这篇优秀的<a class="ae lq" href="https://1984.dev/Limitations-of-RealityKit-1-0" rel="noopener ugc nofollow" target="_blank">作品</a> <em class="no">，他在两年前写了一篇文章比较了这两者。我后来找到了他，他告诉我“我的大部分问题都已经解决了”——现在看起来和听起来都像RealityKit已经取代了scene kit——如果明年这个时候我改变了主意，我会让你知道，那时我自己有机会真正深入了解这一点。请在媒体上关注我，保持对这个主题的关注。</em></p></div></div>    
</body>
</html>