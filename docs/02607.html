<html>
<head>
<title>What Are RPCs in Golang?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang中的RPC是什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rpc-in-golang-19661033942?source=collection_archive---------2-----------------------#2019-12-12">https://betterprogramming.pub/rpc-in-golang-19661033942?source=collection_archive---------2-----------------------#2019-12-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f9d0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Go中远程过程调用概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8a658e7726f7541f3644983ced47d4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mi2TsC7qnEgOK4KJW51qEQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@seefromthesky?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ishan @seefromthesky </a>在<a class="ae ky" href="https://unsplash.com/s/photos/network?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="60f2" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">什么是RPC？</h1><p id="24d7" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><em class="mu">远程过程调用</em> (RPC)是分布式计算中的子程序。RPC的远程实现类似于本地调用，但通常并不相同。RPC通常要求将对象名、函数名或参数传递给远程服务器，然后服务器将处理后的结果返回给客户端(请求-响应)。RPC可以通过TCP、UDP或HTTP协议进行通信。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/b5e5aadd4c0270320e96f9b1b93884cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRwG6MGLSVR8V-EyE7ZVGA.png"/></div></div></figure><p id="fc8d" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">Golang中有三种类型的实现，即:</p><ul class=""><li id="4d4d" class="nb nc it ma b mb mw me mx mh nd ml ne mp nf mt ng nh ni nj bi translated"><code class="fe nk nl nm nn b">net/rpc</code></li><li id="5b48" class="nb nc it ma b mb no me np mh nq ml nr mp ns mt ng nh ni nj bi translated"><code class="fe nk nl nm nn b">net/rpc/jsonrpc</code></li><li id="afe7" class="nb nc it ma b mb no me np mh nq ml nr mp ns mt ng nh ni nj bi translated"><code class="fe nk nl nm nn b">gRPC</code></li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="fff9" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">net/rpc</h1><p id="c95a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><a class="ae ky" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Golang官方文档</a>使用<code class="fe nk nl nm nn b">net/rpc </code>包中的<code class="fe nk nl nm nn b">encoding/gob</code>作为编码或解码方法，支持TCP或HTTP协议。但是因为<code class="fe nk nl nm nn b">gob</code>编码只在Golang中使用，所以只支持用Golang编写的服务器端和客户端交互。</p><p id="1ca9" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">服务器端的例子<code class="fe nk nl nm nn b">net/rpc</code>:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="f513" class="nx lh it nn b gy ny nz l oa ob">package main</span><span id="0115" class="nx lh it nn b gy oc nz l oa ob">import (</span><span id="9ec5" class="nx lh it nn b gy oc nz l oa ob">   "fmt"</span><span id="0716" class="nx lh it nn b gy oc nz l oa ob">   "log"</span><span id="7a69" class="nx lh it nn b gy oc nz l oa ob">   "net"</span><span id="a625" class="nx lh it nn b gy oc nz l oa ob">   "net/rpc"</span><span id="0a59" class="nx lh it nn b gy oc nz l oa ob">)</span><span id="11ef" class="nx lh it nn b gy oc nz l oa ob">type Listener int<br/></span><span id="9009" class="nx lh it nn b gy oc nz l oa ob">type Reply struct {</span><span id="f56e" class="nx lh it nn b gy oc nz l oa ob">   Data string</span><span id="ad7b" class="nx lh it nn b gy oc nz l oa ob">}</span><span id="06f0" class="nx lh it nn b gy oc nz l oa ob">func (l *Listener) GetLine(line []byte, reply *Reply) error {</span><span id="eba6" class="nx lh it nn b gy oc nz l oa ob">   rv := string(line)</span><span id="d5db" class="nx lh it nn b gy oc nz l oa ob">   fmt.Printf("Receive: %v\n", rv)</span><span id="1df4" class="nx lh it nn b gy oc nz l oa ob">   *reply = Reply{rv}</span><span id="3198" class="nx lh it nn b gy oc nz l oa ob">   return nil</span><span id="7a0a" class="nx lh it nn b gy oc nz l oa ob">}</span><span id="31cf" class="nx lh it nn b gy oc nz l oa ob">func main() {</span><span id="7cbb" class="nx lh it nn b gy oc nz l oa ob">   addy, err := net.ResolveTCPAddr("tcp", "0.0.0.0:12345")</span><span id="8fff" class="nx lh it nn b gy oc nz l oa ob">   if err != nil {</span><span id="d8fa" class="nx lh it nn b gy oc nz l oa ob">     log.Fatal(err)</span><span id="85d1" class="nx lh it nn b gy oc nz l oa ob">   }</span><span id="fda5" class="nx lh it nn b gy oc nz l oa ob">   inbound, err := net.ListenTCP("tcp", addy)</span><span id="1ed6" class="nx lh it nn b gy oc nz l oa ob">   if err != nil {</span><span id="be78" class="nx lh it nn b gy oc nz l oa ob">     log.Fatal(err)</span><span id="f213" class="nx lh it nn b gy oc nz l oa ob">   }</span><span id="0800" class="nx lh it nn b gy oc nz l oa ob">   listener := new(Listener)</span><span id="6976" class="nx lh it nn b gy oc nz l oa ob">   rpc.Register(listener)</span><span id="070d" class="nx lh it nn b gy oc nz l oa ob">   rpc.Accept(inbound)</span><span id="cd6a" class="nx lh it nn b gy oc nz l oa ob">}</span></pre><p id="90f2" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">在这个例子中，我们注意到<code class="fe nk nl nm nn b">GetLine</code>函数被添加到了<code class="fe nk nl nm nn b">Listener</code>中。该函数将返回一个<code class="fe nk nl nm nn b">error</code>类型，同时期待来自客户端的内容行和回复。它也必须是一个指针，所以声明一个<code class="fe nk nl nm nn b">Reply</code>结构来存储相应的<code class="fe nk nl nm nn b">Data</code>。</p><p id="49e2" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">在主函数中，首先我们使用<code class="fe nk nl nm nn b">net.ResolveTCPAddr</code>和<code class="fe nk nl nm nn b">net.ListenTCP</code>建立一个TCP连接，监听来自所有地址的12345端口。最后，我们使用<code class="fe nk nl nm nn b">rpc.Register</code>注册要监听的连接，接受来自上述TCP连接的所有请求。</p><p id="f9a9" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">客户端示例<code class="fe nk nl nm nn b">net/rpc</code>:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="65d0" class="nx lh it nn b gy ny nz l oa ob">package main</span><span id="198f" class="nx lh it nn b gy oc nz l oa ob">import (</span><span id="c8ee" class="nx lh it nn b gy oc nz l oa ob">   "bufio"</span><span id="d349" class="nx lh it nn b gy oc nz l oa ob">   "log"</span><span id="5f6c" class="nx lh it nn b gy oc nz l oa ob">   "net/rpc"</span><span id="49e4" class="nx lh it nn b gy oc nz l oa ob">   "os"</span><span id="2ef8" class="nx lh it nn b gy oc nz l oa ob">)</span><span id="63ae" class="nx lh it nn b gy oc nz l oa ob">type Reply struct {</span><span id="0b70" class="nx lh it nn b gy oc nz l oa ob">   Data string</span><span id="07bf" class="nx lh it nn b gy oc nz l oa ob">}</span><span id="dea7" class="nx lh it nn b gy oc nz l oa ob">func main() {</span><span id="d44f" class="nx lh it nn b gy oc nz l oa ob">   client, err := rpc.Dial("tcp", "localhost:12345")</span><span id="7a2f" class="nx lh it nn b gy oc nz l oa ob">   if err != nil {</span><span id="8f5f" class="nx lh it nn b gy oc nz l oa ob">      log.Fatal(err)</span><span id="0e84" class="nx lh it nn b gy oc nz l oa ob">    }<br/></span><span id="9671" class="nx lh it nn b gy oc nz l oa ob">   in := bufio.NewReader(os.Stdin)</span><span id="8948" class="nx lh it nn b gy oc nz l oa ob">   for {</span><span id="c8e7" class="nx lh it nn b gy oc nz l oa ob">      line, _, err := in.ReadLine()</span><span id="7d91" class="nx lh it nn b gy oc nz l oa ob">      if err != nil {</span><span id="59aa" class="nx lh it nn b gy oc nz l oa ob">         log.Fatal(err)</span><span id="ad0b" class="nx lh it nn b gy oc nz l oa ob">      }</span><span id="3224" class="nx lh it nn b gy oc nz l oa ob">      var reply Reply</span><span id="b17b" class="nx lh it nn b gy oc nz l oa ob">      err = client.Call("Listener.GetLine", line, &amp;reply)</span><span id="28ca" class="nx lh it nn b gy oc nz l oa ob">      if err != nil {</span><span id="67c8" class="nx lh it nn b gy oc nz l oa ob">        log.Fatal(err)</span><span id="d0cb" class="nx lh it nn b gy oc nz l oa ob">      }</span><span id="f512" class="nx lh it nn b gy oc nz l oa ob">      log.Printf("Reply: %v, Data: %v", reply, reply.Data)</span><span id="7a4b" class="nx lh it nn b gy oc nz l oa ob">    }</span><span id="a281" class="nx lh it nn b gy oc nz l oa ob">}</span></pre><p id="b652" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">客户端将使用<code class="fe nk nl nm nn b">rpc.Dial</code>建立到服务器和端口的连接，这是一个无限的<code class="fe nk nl nm nn b">for</code>循环，带有<code class="fe nk nl nm nn b">ReadLine</code>函数，接受来自接收端口的输入。如果其间的线路有任何中断，这将触发<code class="fe nk nl nm nn b">client.Call</code>并启动<code class="fe nk nl nm nn b">GetLine</code>功能。通过这个过程，<code class="fe nk nl nm nn b">reply</code>将被存储在数据库中，我们可以用<code class="fe nk nl nm nn b">reply.Data</code>将它调用出来(基本上，这意味着我们输入的就是我们在输出中得到的)。让我们试着运行代码:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="1ab0" class="nx lh it nn b gy ny nz l oa ob">❯ go run simple_server.go<br/>Receive: hi<br/>Receive: haha</span><span id="1e4e" class="nx lh it nn b gy oc nz l oa ob">❯ go run simple_client.go<br/>hi<br/>2019/12/05 18:19:14 Reply: {hi}, Data: hi<br/>haha<br/>2019/12/05 18:19:15 Reply: {haha}, Data: haha</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="956f" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">net/rpc/jsonrpc</h1><p id="948d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe nk nl nm nn b">net/rpc</code>只支持Golang，所以Go库在跨语言平台中使用<code class="fe nk nl nm nn b">net/rpc/jsonrpc</code>支持RPC。要实现与上面相同的应用程序，我们只需更改<code class="fe nk nl nm nn b">main()</code>函数中的<code class="fe nk nl nm nn b">rpc.Accept</code>。</p><p id="ae53" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">服务器端的例子<code class="fe nk nl nm nn b">net/rpc/jsonrpc</code>:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="7fab" class="nx lh it nn b gy ny nz l oa ob">import "net/rpc/jsonrpc"</span><span id="a4d7" class="nx lh it nn b gy oc nz l oa ob">func main() {</span><span id="2aba" class="nx lh it nn b gy oc nz l oa ob">   addy, err := net.ResolveTCPAddr("tcp", "0.0.0.0:12345")</span><span id="dc33" class="nx lh it nn b gy oc nz l oa ob">   if err != nil {</span><span id="c731" class="nx lh it nn b gy oc nz l oa ob">     log.Fatal(err)</span><span id="0c39" class="nx lh it nn b gy oc nz l oa ob">   }</span><span id="8a25" class="nx lh it nn b gy oc nz l oa ob">   inbound, err := net.ListenTCP("tcp", addy)</span><span id="2088" class="nx lh it nn b gy oc nz l oa ob">   if err != nil {</span><span id="fb3b" class="nx lh it nn b gy oc nz l oa ob">     log.Fatal(err)</span><span id="7971" class="nx lh it nn b gy oc nz l oa ob">   }</span><span id="85bc" class="nx lh it nn b gy oc nz l oa ob">   listener := new(Listener)</span><span id="9e95" class="nx lh it nn b gy oc nz l oa ob">   rpc.Register(listener)</span><span id="aa66" class="nx lh it nn b gy oc nz l oa ob">   for {</span><span id="9e09" class="nx lh it nn b gy oc nz l oa ob">     conn, err := inbound.Accept()</span><span id="6272" class="nx lh it nn b gy oc nz l oa ob">     if err != nil {</span><span id="2a9b" class="nx lh it nn b gy oc nz l oa ob">       continue</span><span id="3aae" class="nx lh it nn b gy oc nz l oa ob">     }</span><span id="76a8" class="nx lh it nn b gy oc nz l oa ob">   jsonrpc.ServeConn(conn)</span><span id="96d3" class="nx lh it nn b gy oc nz l oa ob">   }</span><span id="7e97" class="nx lh it nn b gy oc nz l oa ob">}</span></pre><p id="2337" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">客户端示例<code class="fe nk nl nm nn b">net/rpc/jsonrpc</code>:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="d8d6" class="nx lh it nn b gy ny nz l oa ob">func main() {</span><span id="ec1a" class="nx lh it nn b gy oc nz l oa ob">   client, err := jsonrpc.Dial("tcp", "localhost:12345") //Only change this</span><span id="bff7" class="nx lh it nn b gy oc nz l oa ob">   if err != nil {</span><span id="7f25" class="nx lh it nn b gy oc nz l oa ob">     log.Fatal(err)</span><span id="f301" class="nx lh it nn b gy oc nz l oa ob">   }</span><span id="e172" class="nx lh it nn b gy oc nz l oa ob">   in := bufio.NewReader(os.Stdin)</span><span id="187a" class="nx lh it nn b gy oc nz l oa ob">   for {</span><span id="09f3" class="nx lh it nn b gy oc nz l oa ob">     line, _, err := in.ReadLine()</span><span id="668b" class="nx lh it nn b gy oc nz l oa ob">     if err != nil {</span><span id="61fe" class="nx lh it nn b gy oc nz l oa ob">       log.Fatal(err)</span><span id="6b03" class="nx lh it nn b gy oc nz l oa ob">     }</span><span id="814b" class="nx lh it nn b gy oc nz l oa ob">   var reply Reply</span><span id="9315" class="nx lh it nn b gy oc nz l oa ob">   err = client.Call("Listener.GetLine", line, &amp;reply)</span><span id="286b" class="nx lh it nn b gy oc nz l oa ob">     if err != nil {</span><span id="d0c5" class="nx lh it nn b gy oc nz l oa ob">       log.Fatal(err)</span><span id="94b5" class="nx lh it nn b gy oc nz l oa ob">     }</span><span id="baef" class="nx lh it nn b gy oc nz l oa ob">   log.Printf("Reply: %v, Data: %v", reply, reply.Data)</span><span id="714e" class="nx lh it nn b gy oc nz l oa ob">   }</span><span id="cef8" class="nx lh it nn b gy oc nz l oa ob">}</span></pre><p id="03fe" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated"><code class="fe nk nl nm nn b">json-rpc</code>基于TCP协议，目前尚不支持HTTP方法。结果将与上一个示例相同:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="e560" class="nx lh it nn b gy ny nz l oa ob">❯ go run simple_server.go<br/>Receive: hi<br/>Receive: haha</span><span id="f6dc" class="nx lh it nn b gy oc nz l oa ob">❯ go run simple_client.go<br/>hi<br/>2019/12/05 20:20:19 Reply: {hi}, Data: hi<br/>haha<br/>2019/12/05 20:20:20 Reply: {haha}, Data: haha</span></pre><p id="2423" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">请求中的JSON对象有两个对应的结构:<code class="fe nk nl nm nn b">clientRequest</code>和<code class="fe nk nl nm nn b">serverRequest</code>。</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="9b3e" class="nx lh it nn b gy ny nz l oa ob">type serverRequest struct {</span><span id="78e1" class="nx lh it nn b gy oc nz l oa ob">   Method string           `json:"method"`</span><span id="ae92" class="nx lh it nn b gy oc nz l oa ob">   Params *json.RawMessage `json:"params"`</span><span id="9e0d" class="nx lh it nn b gy oc nz l oa ob">   Id     *json.RawMessage `json:"id"`</span><span id="0262" class="nx lh it nn b gy oc nz l oa ob">}</span><span id="c7f4" class="nx lh it nn b gy oc nz l oa ob">type clientRequest struct {</span><span id="fe72" class="nx lh it nn b gy oc nz l oa ob">   Method string         `json:"method"`</span><span id="f60c" class="nx lh it nn b gy oc nz l oa ob">   Params [1]interface{} `json:"params"`</span><span id="cadc" class="nx lh it nn b gy oc nz l oa ob">   Id     uint64         `json:"id"`</span><span id="31a6" class="nx lh it nn b gy oc nz l oa ob">}</span></pre><p id="2d05" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">我们可以在其他编程语言中使用这个结构来发送消息。让我们在命令行中尝试一下:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="1f9e" class="nx lh it nn b gy ny nz l oa ob">❯ echo -n "hihi" |base64  # Parameters must be base64 encoded</span><span id="a9c1" class="nx lh it nn b gy oc nz l oa ob">aGloaQ==</span><span id="14d0" class="nx lh it nn b gy oc nz l oa ob">~/strconv.code/rpc master*</span><span id="4684" class="nx lh it nn b gy oc nz l oa ob">❯ echo -e '{"method": "Listener.GetLine","params": ["aGloaQ=="], "id": 0}' | nc localhost 12345</span><span id="11d7" class="nx lh it nn b gy oc nz l oa ob">{"id":0,"result":{"Data":"hihi"},"error":null}</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="80e2" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">gRPC</h1><p id="e14c" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe nk nl nm nn b">jsonRPC</code>可以支持其他语言但不支持HTTP方法的事实限制了它在现实生活中的应用。因此，对于生产环境，我们通常使用像<code class="fe nk nl nm nn b">Thrift</code>或<code class="fe nk nl nm nn b">gRPC</code>这样的替代方法来克服这个问题。</p><p id="302c" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">gRPC是Google推出的一个高性能、广泛使用的开源RPC框架。它主要是为基于HTTP/2标准协议的现代应用程序中的并发性而设计的。它是用Protobuf序列化协议开发的，支持Python、Golang和Java等流行语言。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8077" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">原蟾蜍</h1><p id="95f5" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Protocol_Buffers" rel="noopener ugc nofollow" target="_blank"> <em class="mu"> Protobuf </em> </a>是Protocol Buffers的缩写，其中<em class="mu"> </em>是Google的语言中立、平台中立、可扩展的序列化结构化数据的机制，类似于XML或JSON格式。它重量轻、速度快，非常适合在RPC网络中存储数据或交换数据。</p><p id="eb12" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">首先，安装Protobuf:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="616d" class="nx lh it nn b gy ny nz l oa ob">❯ brew install protobuf</span><span id="7940" class="nx lh it nn b gy oc nz l oa ob">❯ protoc --version</span><span id="cf0e" class="nx lh it nn b gy oc nz l oa ob">libprotoc 3.7.1</span><span id="2c5c" class="nx lh it nn b gy oc nz l oa ob">go get -u github.com/golang/protobuf/{proto,protoc-gen-go}</span></pre><p id="5461" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">然后，根据<a class="ae ky" href="https://en.wikipedia.org/wiki/Protocol_Buffers" rel="noopener ugc nofollow" target="_blank"> proto3 </a>写入样本数据:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="80dd" class="nx lh it nn b gy ny nz l oa ob">syntax = "proto3";</span><span id="2310" class="nx lh it nn b gy oc nz l oa ob">package simple;</span><span id="1d96" class="nx lh it nn b gy oc nz l oa ob">// Request</span><span id="ec30" class="nx lh it nn b gy oc nz l oa ob">message SimpleRequest {</span><span id="f1dd" class="nx lh it nn b gy oc nz l oa ob">string data = 1;</span><span id="7244" class="nx lh it nn b gy oc nz l oa ob">}</span><span id="1535" class="nx lh it nn b gy oc nz l oa ob">// Response</span><span id="e503" class="nx lh it nn b gy oc nz l oa ob">message SimpleResponse {</span><span id="c692" class="nx lh it nn b gy oc nz l oa ob">string data = 1;</span><span id="0e3d" class="nx lh it nn b gy oc nz l oa ob">}</span><span id="f5b2" class="nx lh it nn b gy oc nz l oa ob">// rpc method</span><span id="b8e6" class="nx lh it nn b gy oc nz l oa ob">service Simple {</span><span id="30c6" class="nx lh it nn b gy oc nz l oa ob">  rpc  GetLine (SimpleRequest) returns (SimpleResponse);</span><span id="a43e" class="nx lh it nn b gy oc nz l oa ob">}</span></pre><p id="5216" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">上面例子中的<code class="fe nk nl nm nn b">request</code>和<code class="fe nk nl nm nn b">response</code>只有一个<code class="fe nk nl nm nn b">data</code>字符串。<code class="fe nk nl nm nn b">Simple</code>服务只有一个以<code class="fe nk nl nm nn b">SimpleRequest</code>为输入的<code class="fe nk nl nm nn b">GetLine</code>方法，它返回<code class="fe nk nl nm nn b">SimpleResponse</code>。让我们试一试:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="146e" class="nx lh it nn b gy ny nz l oa ob">❯ mkdir src/simple</span><span id="9de4" class="nx lh it nn b gy oc nz l oa ob">❯ protoc --go_out=plugins=grpc:src/simple simple.proto</span><span id="aba2" class="nx lh it nn b gy oc nz l oa ob">❯ ll src/simple</span><span id="c620" class="nx lh it nn b gy oc nz l oa ob">total 8.0K</span><span id="ff01" class="nx lh it nn b gy oc nz l oa ob">-rw-r--r-- 1 xiaoxi staff 7.0K Dec 05 21:43 simple.pb.go</span></pre><p id="b57e" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">这成功地在<code class="fe nk nl nm nn b">src/simple</code>下创建了一个<code class="fe nk nl nm nn b">simple.pb.go</code>文件来支持gRPC。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ccda" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">如何使用gRPC</h1><p id="0722" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">首先，安装gRPC:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="910e" class="nx lh it nn b gy ny nz l oa ob">❯ go get -u google.golang.org/grpc</span></pre><p id="d9b9" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">然后，将<code class="fe nk nl nm nn b">src/simple</code>导入代码:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="4e2b" class="nx lh it nn b gy ny nz l oa ob">package main</span><span id="ad32" class="nx lh it nn b gy oc nz l oa ob">import (</span><span id="6184" class="nx lh it nn b gy oc nz l oa ob">   "fmt"</span><span id="41ef" class="nx lh it nn b gy oc nz l oa ob">   "log"</span><span id="fa14" class="nx lh it nn b gy oc nz l oa ob">   "net"</span><span id="0d80" class="nx lh it nn b gy oc nz l oa ob">   pb "./src/simple"</span><span id="5e94" class="nx lh it nn b gy oc nz l oa ob">   "golang.org/x/net/context"</span><span id="dd54" class="nx lh it nn b gy oc nz l oa ob">   "google.golang.org/grpc"</span><span id="eabb" class="nx lh it nn b gy oc nz l oa ob">)</span><span id="dbb0" class="nx lh it nn b gy oc nz l oa ob">type Listener int</span><span id="b1fe" class="nx lh it nn b gy oc nz l oa ob">func (l *Listener) GetLine(ctx context.Context, in *pb.SimpleRequest) (*pb.SimpleResponse, error) {</span><span id="2e14" class="nx lh it nn b gy oc nz l oa ob">   rv := in.Data</span><span id="a3e6" class="nx lh it nn b gy oc nz l oa ob">   fmt.Printf("Receive: %v\n", rv)</span><span id="0db2" class="nx lh it nn b gy oc nz l oa ob">   return &amp;pb.SimpleResponse{Data: rv}, nil</span><span id="feaa" class="nx lh it nn b gy oc nz l oa ob">}</span><span id="0719" class="nx lh it nn b gy oc nz l oa ob">func main() {</span><span id="e182" class="nx lh it nn b gy oc nz l oa ob">   addy, err := net.ResolveTCPAddr("tcp", "0.0.0.0:12345")</span><span id="db05" class="nx lh it nn b gy oc nz l oa ob">   if err != nil {</span><span id="5582" class="nx lh it nn b gy oc nz l oa ob">     log.Fatal(err)</span><span id="4f20" class="nx lh it nn b gy oc nz l oa ob">   }</span><span id="146b" class="nx lh it nn b gy oc nz l oa ob">   inbound, err := net.ListenTCP("tcp", addy)</span><span id="df9b" class="nx lh it nn b gy oc nz l oa ob">   if err != nil {</span><span id="5372" class="nx lh it nn b gy oc nz l oa ob">     log.Fatal(err)</span><span id="649f" class="nx lh it nn b gy oc nz l oa ob">   }</span><span id="dd86" class="nx lh it nn b gy oc nz l oa ob">   s := grpc.NewServer()</span><span id="96ea" class="nx lh it nn b gy oc nz l oa ob">   listener := new(Listener)</span><span id="8cef" class="nx lh it nn b gy oc nz l oa ob">   pb.RegisterSimpleServer(s, listener)</span><span id="af00" class="nx lh it nn b gy oc nz l oa ob">   s.Serve(inbound)</span><span id="bd44" class="nx lh it nn b gy oc nz l oa ob">}</span></pre><p id="c421" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">我们注意到<code class="fe nk nl nm nn b">pb "./src/simple"</code>是作为一个包导入的，并被重命名为<code class="fe nk nl nm nn b">pb</code>。</p><p id="49ce" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated"><code class="fe nk nl nm nn b">GetLine</code>功能的第一个参数是<code class="fe nk nl nm nn b">context.Context</code>。第二个参数是<code class="fe nk nl nm nn b">*pb.Simple-Request</code>(请求在<code class="fe nk nl nm nn b">.proto</code>文件中定义)。该函数将返回<code class="fe nk nl nm nn b">(*pb.SimpleResponse, error)</code>，其中<code class="fe nk nl nm nn b">pb.SimpleResponse</code>对应于<code class="fe nk nl nm nn b">.proto</code>文件中的定义。另一方面，尽管<code class="fe nk nl nm nn b">SimpleRequest</code>和<code class="fe nk nl nm nn b">SimpleResponse</code>在<code class="fe nk nl nm nn b">.proto</code>文件中是骆驼文，但使用时需要大写。</p><p id="7ec7" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">客户端:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="6d74" class="nx lh it nn b gy ny nz l oa ob">package main</span><span id="89eb" class="nx lh it nn b gy oc nz l oa ob">import (</span><span id="6af7" class="nx lh it nn b gy oc nz l oa ob">   "bufio"</span><span id="9caa" class="nx lh it nn b gy oc nz l oa ob">   "log"</span><span id="1a6a" class="nx lh it nn b gy oc nz l oa ob">   "os"</span><span id="5d46" class="nx lh it nn b gy oc nz l oa ob">   pb "./src/simple"</span><span id="5c09" class="nx lh it nn b gy oc nz l oa ob">   "golang.org/x/net/context"</span><span id="c041" class="nx lh it nn b gy oc nz l oa ob">   "google.golang.org/grpc"</span><span id="9c4e" class="nx lh it nn b gy oc nz l oa ob">)</span><span id="caa1" class="nx lh it nn b gy oc nz l oa ob">func main() {</span><span id="4f46" class="nx lh it nn b gy oc nz l oa ob">   conn, err := grpc.Dial("localhost:12345", grpc.WithInsecure())</span><span id="c6dc" class="nx lh it nn b gy oc nz l oa ob">     if err != nil {</span><span id="1613" class="nx lh it nn b gy oc nz l oa ob">       log.Fatal(err)</span><span id="fc88" class="nx lh it nn b gy oc nz l oa ob">     }</span><span id="4552" class="nx lh it nn b gy oc nz l oa ob">   c := pb.NewSimpleClient(conn)</span><span id="a6b4" class="nx lh it nn b gy oc nz l oa ob">   in := bufio.NewReader(os.Stdin)</span><span id="bf91" class="nx lh it nn b gy oc nz l oa ob">   for {</span><span id="2fb3" class="nx lh it nn b gy oc nz l oa ob">     line, _, err := in.ReadLine()</span><span id="6fec" class="nx lh it nn b gy oc nz l oa ob">       if err != nil {</span><span id="09df" class="nx lh it nn b gy oc nz l oa ob">          log.Fatal(err)</span><span id="a809" class="nx lh it nn b gy oc nz l oa ob">       }</span><span id="2115" class="nx lh it nn b gy oc nz l oa ob">     reply, err := c.GetLine(context.Background(), &amp;pb.SimpleRequest{Data: string(line)})</span><span id="9292" class="nx lh it nn b gy oc nz l oa ob">     if err != nil {</span><span id="13aa" class="nx lh it nn b gy oc nz l oa ob">        log.Fatal(err)</span><span id="fece" class="nx lh it nn b gy oc nz l oa ob">     }</span><span id="cbb6" class="nx lh it nn b gy oc nz l oa ob">     log.Printf("Reply: %v, Data: %v", reply, reply.Data)</span><span id="56ff" class="nx lh it nn b gy oc nz l oa ob">   }</span><span id="101d" class="nx lh it nn b gy oc nz l oa ob">}</span></pre><p id="eeee" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">首先，使用<code class="fe nk nl nm nn b">grpc.Dial("localhost:12345", rpc.WithInsecure())</code>建立连接。然后使用<code class="fe nk nl nm nn b">pb.NewSimpleClient</code>创建一个新的<code class="fe nk nl nm nn b">simpleClient</code>实例，格式为<code class="fe nk nl nm nn b">XXXClient</code>。(XXX之前在<code class="fe nk nl nm nn b">.proto</code>文件中定义，用于<code class="fe nk nl nm nn b">service Simple</code>中的<code class="fe nk nl nm nn b">simple</code>)。</p><p id="3e96" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">使用以下命令来使用RPC:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="2445" class="nx lh it nn b gy ny nz l oa ob">reply, err := c.GetLine(context.Background(), &amp;pb.SimpleRequest{Data: string(line)})</span></pre><p id="addb" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated"><code class="fe nk nl nm nn b">GetLine</code>在<code class="fe nk nl nm nn b">.proto</code>文件(<code class="fe nk nl nm nn b">rpc GetLine(SimpleRequest) returns (SimpleResponse)</code>)中定义。第一个参数是<code class="fe nk nl nm nn b">context.Background()</code>。第二个参数是<code class="fe nk nl nm nn b">request</code>。因为线是<code class="fe nk nl nm nn b">[]byte</code>型的，所以需要转换成<code class="fe nk nl nm nn b">string</code>。响应<code class="fe nk nl nm nn b">reply</code>是<code class="fe nk nl nm nn b">SimpleReponse</code>的实例，可以从<code class="fe nk nl nm nn b">reply.Data</code>获得:</p><pre class="kj kk kl km gt nt nn nu nv aw nw bi"><span id="1253" class="nx lh it nn b gy ny nz l oa ob">❯ go run grpc_server.go<br/>Receive: hi<br/>Receive: Haha<br/>Receive: vvv</span><span id="0fc9" class="nx lh it nn b gy oc nz l oa ob">❯ go run grpc_client.go<br/>hi</span><span id="516c" class="nx lh it nn b gy oc nz l oa ob">2019/12/06 <!-- -->07:57:48 Reply: data:"hi" , Data: hi<br/>Haha<br/>2019/12/06<!-- --> 07:57:51 Reply: data:"Haha" , Data: Haha<br/>vvv<br/>2019/12/06<!-- --> 07:57:53 Reply: data:"vvv" , Data: vvv</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="db4b" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh my mj mk ml mz mn mo mp na mr ms mt im bi translated">在这篇文章中，我们解释了RPC(远程过程调用)和Golang中的三种实现类型。此外，我们还介绍了<code class="fe nk nl nm nn b">net/rpc</code>、<code class="fe nk nl nm nn b">net/jsonrpc</code>和<code class="fe nk nl nm nn b">grpc</code>的代码示例。编码快乐！</p></div></div>    
</body>
</html>