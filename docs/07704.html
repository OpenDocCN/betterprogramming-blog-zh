<html>
<head>
<title>GraphQL Subscriptions With Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Go的GraphQL订阅</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/graphql-subscriptions-with-go-6eb25dec5cd1?source=collection_archive---------3-----------------------#2021-02-11">https://betterprogramming.pub/graphql-subscriptions-with-go-6eb25dec5cd1?source=collection_archive---------3-----------------------#2021-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d17d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用GraphQL订阅实现一个实时应用程序并运行</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/621027af2aa3d8bb1dd0b87ab4e873f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mWLbH3jFKM9tEy9ZJ8cDA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@othentikisra" rel="noopener ugc nofollow" target="_blank"> israel palacio </a>拍摄，经作者修改</p></figure><p id="9dfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将带您了解如何用Go实现GraphQL订阅。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3ea7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">属国</h1><p id="df93" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">所需的依赖关系如下:</p><h2 id="0354" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">服务器端</h2><ul class=""><li id="c652" class="nl nm it lb b lc mu lf mv li nn lm no lq np lu nq nr ns nt bi translated"><a class="ae ky" href="https://github.com/labstack/echo" rel="noopener ugc nofollow" target="_blank">回声</a></li><li id="a3b5" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><a class="ae ky" href="https://github.com/gorilla/websocket" rel="noopener ugc nofollow" target="_blank">大猩猩/网络插座</a></li><li id="1d9d" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><a class="ae ky" href="https://github.com/99designs/gqlgen" rel="noopener ugc nofollow" target="_blank">99设计/gqlgen </a></li></ul><h2 id="4647" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">前端侧</h2><ul class=""><li id="9d95" class="nl nm it lb b lc mu lf mv li nn lm no lq np lu nq nr ns nt bi translated"><a class="ae ky" href="https://github.com/apollographql/apollo-client" rel="noopener ugc nofollow" target="_blank">阿波罗/阿波罗客户端</a></li><li id="71db" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><a class="ae ky" href="https://github.com/chakra-ui/chakra-ui" rel="noopener ugc nofollow" target="_blank">查克拉-ui/查克拉-ui </a></li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="370a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">GraphQL订阅</h1><p id="8194" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://www.apollographql.com/docs/react/data/subscriptions/" rel="noopener ugc nofollow" target="_blank"> GraphQL订阅</a>使您能够定期获取数据，而无需从客户端轮询。订阅通过WebSockets保持活动连接，并在检测到更新后立即通知您。</p><h1 id="9dd5" class="mc md it bd me mf nz mh mi mj oa ml mm jz ob ka mo kc oc kd mq kf od kg ms mt bi translated">Redis流</h1><p id="10f3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在版本2中，Redis提供了一个<a class="ae ky" href="https://redis.io/topics/pubsub" rel="noopener ugc nofollow" target="_blank">发布/订阅</a>特性，可以分离发布者和订阅者。通过使用这一点，发布者可以在一个通道上向任意数量的订阅者发送消息，而不需要知道有哪些订阅者。</p><p id="0cf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在版本5中，Redis提供了一个名为<a class="ae ky" href="https://redis.io/topics/streams-intro" rel="noopener ugc nofollow" target="_blank"> Redis Stream </a>的新特性。</p><p id="b12f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Redis流的概念与Redis发布/订阅相关，但是在消费数据的方式上有一些基本的区别。它们之间的主要区别是存储消息的方式。在发布/订阅模式下，消息被发送，但从不存储。在流中，所有的消息都无限期地存储在流中，这允许不同的消费者通过记住上一个消息的ID来知道新消息是从哪个点开始的。</p><p id="ba96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在一个聊天应用程序中，你将能够从头看到所有的消息，并知道哪条消息是新的，即使你在中午进入房间。</p><p id="3d7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将把Redis流用于多个连接来共享数据。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9309" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实施概述</h1><ul class=""><li id="e303" class="nl nm it lb b lc mu lf mv li nn lm no lq np lu nq nr ns nt bi translated">设置Redis服务器</li><li id="eeed" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">设置回显服务器</li><li id="48af" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">设置图表QL</li><li id="876b" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">在GraphQL中启用WebSocket CORS</li><li id="0ffc" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">配置Redis客户端</li><li id="79b9" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">实现GraphQL解析器</li><li id="14cc" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">设置React应用程序</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f3e8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置Redis服务器</h1><p id="199b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我们将使用<a class="ae ky" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>创建一个Redis服务器。</p><p id="d110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe oe of og oh b">docker-compose.yml</code>中写入配置:</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="d08b" class="mz md it oh b gy om on l oo op">version: '3'<br/>services:<br/>  redis:<br/>    image: redis:5.0.7<br/>    volumes:<br/>      - redis-data:/data<br/>    ports:<br/>      - '6379:6379'<br/>volumes:<br/>  redis-data:<br/>    driver: local</span></pre><p id="1d95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并通过运行以下命令启动服务器:</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="5a14" class="mz md it oh b gy om on l oo op">docker-compose up</span></pre><p id="1d63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您遇到这样的消息:</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="4a27" class="mz md it oh b gy om on l oo op">...</span><span id="c9aa" class="mz md it oh b gy oq on l oo op">WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span><span id="833c" class="mz md it oh b gy oq on l oo op">...</span></pre><p id="dca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您必须在一台虚拟机上为Docker for Mac配置它。</p><p id="e83d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过运行以下命令，在Docker for Mac上输入虚拟机:</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="861d" class="mz md it oh b gy om on l oo op">docker run -it --privileged --pid=host debian nsenter -t 1 -m -u -n -i sh</span></pre><p id="c5c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把这个放到终端上:</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="2fd3" class="mz md it oh b gy om on l oo op">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled<br/>echo never &gt; /sys/kernel/mm/transparent_hugepage/defrag</span></pre><p id="4053" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">退出终端并再次启动它:</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="2a65" class="mz md it oh b gy om on l oo op">docker-compose up</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8c87" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置回显服务器</h1><p id="5f10" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来，我们将使用Echo包设置一个服务器。</p><p id="03a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe oe of og oh b">main.go</code>并编写如下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="41c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="http://localhost:8080:" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080: </a>看到<code class="fe oe of og oh b">Welcome</code>页面</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/fa0f54a7c310df2ae9fe50549f497711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OHUy88oaD8mG9nXOXtpF3g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">欢迎页面</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cf32" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置GraphQL</h1><p id="7e67" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来，我们将使用<a class="ae ky" href="https://github.com/99designs/gqlgen" rel="noopener ugc nofollow" target="_blank"> gqlgen </a>来设置GraphQL。</p><p id="d2f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要初始化包，请运行以下命令:</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="0729" class="mz md it oh b gy om on l oo op">go run github.com/99designs/gqlgen init</span></pre><p id="457e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将在您的项目中生成以下布局:</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="20e1" class="mz md it oh b gy om on l oo op">├── go.mod<br/>├── go.sum<br/>├── gqlgen.yml<br/>├── graph<br/>│   ├── generated<br/>│   │   └── generated.go<br/>│   ├── model<br/>│   │   └── models_gen.go<br/>│   ├── resolver.go<br/>│   ├── schema.graphqls<br/>│   └── schema.resolvers.go<br/>└── server.go</span></pre><p id="6962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oe of og oh b">server.go</code>应该是这个布局中的一个入口点，但是我们将删除它并将gqlgen处理程序放在<code class="fe oe of og oh b">main.go</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="7864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导航到<a class="ae ky" href="http://localhost:8080/playground" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/playground</a>，你会看到游乐场页面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/7a765f24d0e178ba6d27f94bd8f1e4ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*keVkS2xTeTh4IFU26bYmOg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">游乐场页面</p></figure><p id="733f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简化<code class="fe oe of og oh b">main.go</code>中的代码，我们将提取与路由到<code class="fe oe of og oh b">infrastructure/router/router.go</code>相关的代码，并将其导入，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="72a4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在GraphQL中启用WebSocket CORS</h1><p id="332f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">gqlgen为WebSocket 提供了现成的<a class="ae ky" href="https://github.com/99designs/gqlgen/blob/3a31a752df764738b1f6e99408df3b169d514784/handler/handler.go#L28-L31" rel="noopener ugc nofollow" target="_blank">传输，所以我们不需要配置它。</a></p><p id="4c1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，它不包括CORS实现，所以我们需要手动添加它。</p><p id="b060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了做到这一点，让我们像这样添加<code class="fe oe of og oh b">infrastructure/graphql/server.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="c0a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将接受来自客户的任何请求。</p><p id="3849" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后像这样导入到<code class="fe oe of og oh b">main.go</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="b924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经准备好在我们的服务器中建立一个WebSocket连接。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0bc0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">配置Redis客户端</h1><p id="92a8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来，我们将在应用程序中配置Redis客户机。</p><p id="379e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，像这样在<code class="fe oe of og oh b">infrastructure/datastore/redis.go</code>中创建一个配置文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="369c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并在<code class="fe oe of og oh b">main.go</code>中导入这个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8181" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实现Redis流</h1><p id="0f41" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来，我们将在应用程序中实现Redis流。</p><p id="35ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们像这样在<code class="fe oe of og oh b">graph/resolver.go</code>中添加一些代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="741d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oe of og oh b">SubscribeRedis</code>将通过一个通道监听Redis流并提供数据。</p><p id="d9d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将创建一个名为<code class="fe oe of og oh b">room</code>的流来存储我们的数据。为了定期获取流中的数据，我们需要通过带有<code class="fe oe of og oh b">BLOCK</code>选项的<code class="fe oe of og oh b">XREAD</code>来监听流。使用BLOCK选项，流将在指定的时间内等待新的传入消息的添加。在这种情况下，我们指定了<code class="fe oe of og oh b">0</code>，这意味着它将一直等到有消息进来。</p><p id="7d19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要获取数据，我们需要指定ID。在这种情况下，我们将为ID指定<code class="fe oe of og oh b">$</code>，这意味着它将只在发出<code class="fe oe of og oh b">XREAD</code>之后获得消息。</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="364b" class="mz md it oh b gy om on l oo op">streams, err := r.RedisClient.XRead(&amp;redis.XReadArgs{<br/>   Streams: []string{"room", "$"},<br/>   Block:   0,<br/>}).Result()</span></pre><p id="4681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到<code class="fe oe of og oh b">main.go</code>并运行订阅:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="070a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并在<code class="fe oe of og oh b">infrastructure/router/router.go</code>中创建一条订阅路线，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cdd9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实现GraphQL解析器</h1><p id="4cae" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于服务器中的最后一步，我们将向模式中添加实现。</p><p id="5007" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，转到<code class="fe oe of og oh b">graph/schema.graphqls</code>，像这样添加模式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="3bab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并运行命令来生成解析程序。</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="8608" class="mz md it oh b gy om on l oo op">go run github.com/99designs/gqlgen</span></pre><p id="5e53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这生成了基于我们上面定义的模式的函数<code class="fe oe of og oh b">graph/schema.resolvers.go</code>。</p><p id="9af1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们像这样给<code class="fe oe of og oh b">graph/schema.resolvers.go</code>添加实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="0082" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经准备好了服务器，可以定期向客户端提供消息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="24bb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置客户端应用程序</h1><p id="55b2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了快速开始，我们将使用<a class="ae ky" href="https://create-react-app.dev/docs/getting-started/" rel="noopener ugc nofollow" target="_blank"> Create React App </a>来生成一个React应用程序。</p><p id="ad16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在根目录下运行以下命令:</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="442b" class="mz md it oh b gy om on l oo op">npx create-react-app frontend --template typescript</span></pre><p id="4f4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装后，通过运行以下命令运行开发服务器:</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="19e6" class="mz md it oh b gy om on l oo op">yarn start</span></pre><p id="a84f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到欢迎页面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/4d4ba2ead2a9413e6c9776cc6ba66731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lbeiiY5MOKNONIqE.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">欢迎页面</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9f6b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">建立一个阿波罗客户端</h1><p id="7c03" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将使用Apollo客户端作为GraphQL的客户端模块。</p><p id="61e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们安装我们需要的软件包:</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="8c98" class="mz md it oh b gy om on l oo op">cd frontend</span><span id="ecc3" class="mz md it oh b gy oq on l oo op">yarn add @apollo/client graphql <!-- -->subscriptions-transport-ws</span></pre><p id="57d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并在<code class="fe oe of og oh b">frontend/src/lib/apolloClient.ts</code>创建一个Apollo客户端:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="b6a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe oe of og oh b">ApolloProvider</code>将<code class="fe oe of og oh b">App</code>组件与客户端包装在一起:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="bbf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您启动前端服务器时，您将看到HTTP连接成功地升级了WebSockets。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/8aa1ed92ba60d727894c2aafd3470eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IzEc3HAbhRyD4iKPv1ajXQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">WebSockets连接</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3458" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实现组件</h1><p id="e2f8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来，我们将创建一个组件来显示消息。</p><p id="84b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将安装Chakra UI来创建我们的表单:</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="30fb" class="mz md it oh b gy om on l oo op">yarn add @chakra-ui/react @emotion/react @emotion/styled framer-motion</span></pre><p id="b743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe oe of og oh b">src/Component.ts</code>并输入如下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="3903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一次呈现中，我们将从查询中获取所有消息，然后启动订阅来获取新的消息。</p><p id="30a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并将其包含在<code class="fe oe of og oh b">src/App.ts</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="de8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们准备测试我们的应用程序。</p><p id="eba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在浏览器中准备两个选项卡并提交一条消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/4a366bc8d519b9f3488539dbfc21bed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dcrKpFvgILBHx3iz14v8vQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试</p></figure><p id="ddd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，两个选项卡同时显示消息。重新加载后，它显示Redis流中存储的所有消息。</p><p id="212d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经实现了与GraphQL和Redis Stream的实时通信。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f271" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="cdda" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们已经介绍了如何使用gqlgen和Redis Stream实现GraphQL订阅。在前端，我们使用Apollo客户端实现了实时聊天服务。如果你按照那个教程，一步一步去实现，你会发现其实没那么复杂。</p><p id="4e65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是<a class="ae ky" href="https://github.com/manakuro/golang-graphql-subscriptions" rel="noopener ugc nofollow" target="_blank">最终代码库</a>。</p><p id="5a1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你觉得有用。</p></div></div>    
</body>
</html>