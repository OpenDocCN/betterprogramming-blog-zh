# Golang 的 3 个陷阱我希望我能早点知道

> 原文：<https://betterprogramming.pub/3-pitfalls-in-golang-i-wish-i-knew-3f208a8402a7>

## 我从零开始学习围棋

![](img/8069daf3253c0f85e0b42e03670840d5.png)

图片来源:作者

去年，我们在生产中开发了一个复杂的半实时系统。我们决定用 [Golang](https://golang.org/) 来写。我们在围棋方面几乎没有经验，所以你可以想象，这并不简单。

快进一年:该系统在生产中运行，并成为 ClimaCell 产品的主要支柱之一。

精通意味着你有足够的经验知道你正在使用的平台的陷阱是什么，以及如何避免它们。

我想描述我们在 Golang 的任务中遇到的三个陷阱，希望它能帮助你避免它们。

# 射程可变性

考虑下面的例子:

我们有一个保存结构实例的通道。我们用`range`操作符迭代通道。你认为这段代码的输出会是什么？

```
6
6
6
6
6
9
9
9
9
9
```

很奇怪，不是吗？我们期望看到数字 1-9(当然不是有序的)。

我们实际看到的是循环变量可变性的结果:

在每一次迭代中，我们都要处理一个 struct 实例。结构是值类型——它们在每次迭代中被复制到`for`迭代变量中。这里的关键词是*复制*。为了避免大量内存打印，我们在循环开始时创建一个单独的实例，并在每次迭代中复制数据，而不是在每次迭代中创建一个新的变量实例。

闭包是等式的另一部分:go 中的闭包(像在大多数语言中一样)保存闭包中对象的引用(不复制数据)，所以内部 go 例程引用迭代的对象，这意味着所有 Go 例程对同一个实例获得相同的引用。

## 解决方案

首先，要意识到这种情况的发生。这不是小事，因为这是与其他语言完全不同的行为(C#中的`for-each`, JS 中的`for-of`——在这些语言中，循环变量是不可变的)。

为了避免这个陷阱，在循环范围内捕获变量，从而自己创建一个新的实例，然后按照自己的意愿使用它:

这里我们使用内部 go 例程的函数调用来捕获`a`，有效地复制它。也可以显式复制:

## 笔记

*   对于大型数据集，注意捕获循环变量将创建大量的对象，每个对象都被保存，直到底层的 go 例程被执行。因此，如果对象包含几个字段，考虑只捕获执行内部例程所需的字段。
*   `for-range`作为数组的附加表现形式。它还创建了一个索引循环变量。请注意，索引循环变量也是可变的，也就是说，要在 go 例程中使用它，可以像使用值循环变量一样捕获它。
*   在当前的 Go 版本(1.15)中，我们看到的初始代码实际上会抛出一个错误，帮助我们避免这个问题，并强制我们捕获我们需要的数据。

# 当心:=

Golang 有两个赋值操作符，`=`和`:=`:

```
var num int
num = 3

name := "yossi"
```

`:=`非常有用，允许我们避免在赋值前声明变量。这实际上是当今许多类型化语言中的常见做法(比如 C#中的`var`)。它非常有用，并保持代码更干净(拙见)。

尽管这很可爱，但是当与 Golang、scope 和多个返回值中的一些其他行为结合使用时，我们可能会遇到意想不到的行为。考虑下面的例子:

在这个例子中，我们从某个地方读取一个字符串数组并打印出来:

```
there
are
no
strings
on
me
```

请注意`:=`的用法:

```
data, err := getData()
```

注意，即使已经声明了`data`,我们仍然可以使用`:=`,因为`err`不是——这是一种很好的简化方式，可以创建更简洁的代码。

现在让我们稍微修改一下代码:

你认为这段代码的结果会是什么？

```
kill switch is off
Data was fetched! 6
```

很奇怪，不是吗？因为关闭了 kill 开关，所以我们加载了数据——我们甚至打印了数据的长度。那么为什么代码不像以前那样打印出来呢？

你猜对了——因为`:=`！

Golang 中的作用域(像大多数现代语言一样)是用`{}`定义的。这里，这个`if`创建了一个新的作用域:

```
if killswitch == "" {
	...		
}
```

因为我们使用了`:=`，Go 会把`data`和`err`都当作新变量！也就是说，`if`子句中的`data`实际上是一个新变量，当作用域关闭时，它被丢弃。

我们在初始化流程中遇到过几次这样的行为——通常会公开某种包变量，完全按照这里的描述进行初始化，并带有一个 kill 开关，允许我们在生产中禁用某些行为。上面的实现将导致系统的无效状态。

## 解决方案

意识——我已经说过了吗？:)

在某些情况下，如果没有使用`if`子句中的内部变量，Go 编译器会发出警告甚至错误，例如:

所以编译时要注意警告。

尽管如此，有时我们确实在作用域内使用了变量，所以不会出现错误。

无论如何，最好的做法是尽量避免使用`:=`简写，尤其是当它与多个返回值和错误处理相关时，并且在决定使用它时保持额外的注意力:

这将导致以下结果:

```
kill switch is off
Data was fetched! 6
there
are
no
strings
on
me
```

记住，随着代码的发展，不同的人会修改它。以前不在不同范围内的代码将来可能会在不同范围内。当您修改现有代码时，尤其是将它转移到不同的范围时，请保持警惕。

# 工人池。工人船长

考虑下面的例子:

和以前一样——我们在一个通道上有一个`for-range`循环。假设`process`函数包含一个我们需要运行的算法，并且不是很快。如果我们处理 100，000 个项目，上面的代码将运行几乎三个小时(在示例中，流程运行 100 毫秒)。所以，让我们这样做:

我们不是串行处理项目，而是为通道中的每个项目分派一个 go 例程。我们希望利用 Go 惊人的并发处理能力来帮助我们更快地处理数据:

理论上，这也适用于 100K 的物品，对吗？

不幸的是，答案是“视情况而定”。

要理解为什么，我们需要理解当我们调度一个 go 例程时会发生什么。我不会深入研究它，因为它超出了本文的范围。简而言之，运行时创建一个包含所有与 go 例程相关的数据的对象，并存储它。当 go 例程的执行完成时，它被逐出。go routine 对象的最小大小是 2K，但是它可以达到 1GB(在 64 位机器上)。

到目前为止，您可能已经知道我们要去哪里了——我们创建的 go 例程越多，我们创建的对象就越多，因此内存消耗也在增加。此外，go 例程需要来自 CPU 的执行时间来进行实际执行，因此我们拥有的内核越少，这些对象在内存中等待执行的时间就越多。

在低资源环境中(lambda 函数，K8s pods 有严格的限制)，CPU 和内存都是有限的，即使在 100K go 例程中，代码示例也会对内存造成压力(同样，这取决于有多少内存可用于实例)。在我们的例子中，在具有 128MB 内存的云函数中，我们能够在崩溃之前处理大约 100K 个项目。

注意，从应用程序的角度来看，我们需要的实际数据非常小——在本例中，是一个简单的 int。大部分内存消耗是 go 例程本身。

## 解决方案

工人池！

工人池允许我们管理我们拥有的 go 例程的数量，保持低内存消耗。让我们看一个工人池的相同例子:

我们将工作池的数量限制为 100 个，并为每个工作池创建一个 go 例程:

可以把通道想象成一个队列，其中每个 worker go 例程都是队列的消费者。Go 的通道允许多个 go 例程监听同一个通道，其中通道中的每个项目将被处理一次。

## 好的一面

我们现在可以规划我们的环境，因为现在的内存印迹是可以预期和测量的:

```
the size of the worker pool * expected size of a single go routine (min 2K)
```

## 不利方面

执行时间会增加。当我们限制内存使用时，我们以增加的执行时间为代价。为什么？以前，我们为每个项目分派一个 go 例程来处理——有效地为每个项目创建一个消费者。这给了我们几乎无限的规模和高并发性。实际上，这是不正确的，因为 go 例程的执行依赖于运行应用程序的内核的可用性。这意味着我们必须根据我们运行的平台来优化工作人员的数量，但是在高容量系统中这样做是有意义的。

## 总结

工作池让我们对代码的执行有了更多的控制。它们为我们提供了可预测性，因此我们可以规划和优化我们的代码和平台，以扩展到高吞吐量和高数据量。

在应用程序需要迭代数据集的情况下，我建议总是使用工作池——即使是很小的数据集。使用工人池，我们现在能够在云功能中处理数百万个项目，而不会接近平台允许的极限，从而为我们提供足够的扩展空间。

## 笔记

*   工人的数量应该是可配置的(例如`env`变量)，允许你在你运行的每个平台上玩这个数字并达到你想要的结果。
*   将通道大小至少设置为池中的工作线程数。这将允许数据生产者填充队列，并防止工人在数据生成时空闲等待。也使它可配置。

# 结论

让我们成为更好的专业人士的是从错误中学习的能力。但是从别人那里学习也同样重要。

如果你走到这一步——谢谢！

亲爱的读者，我希望我们在这里看到的能够帮助你，避免我们在 Golang 的旅程中所犯的错误。