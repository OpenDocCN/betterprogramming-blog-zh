<html>
<head>
<title>C++ Smart Pointer Explained Through Intuitive Visuals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过直观的视觉效果解释C++智能指针</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-smart-pointer-iii-909512a5eb05?source=collection_archive---------7-----------------------#2022-04-27">https://betterprogramming.pub/understanding-smart-pointer-iii-909512a5eb05?source=collection_archive---------7-----------------------#2022-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="3dea" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">有效的C++</h2><div class=""/><div class=""><h2 id="d0ab" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">我的C++指针系列的第3部分</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/daf2b439dbc94efb749367a3b7173215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wYw8dYdGd0JabdkBrMiwIQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">一个指向T的指针，另一个指向控制块，其中后者是指向内存的指针，后者对std::shared_ptr进行引用计数。</p></figure><pre class="ks kt ku kv gt lh li lj lk aw ll bi"><span id="82b5" class="lm ln it li b gy lo lp l lq lr">· <a class="ae ls" href="#3da7" rel="noopener ugc nofollow">Overview</a><br/>· <a class="ae ls" href="#0925" rel="noopener ugc nofollow">Item 18:</a> U<!-- -->nique_ptr<!-- --> for exclusive-ownership resource management.<br/>  ∘ <a class="ae ls" href="#901d" rel="noopener ugc nofollow">An Exclusive Relationship</a><br/>  ∘ <a class="ae ls" href="#19f7" rel="noopener ugc nofollow">Raw Pointers</a><br/>  ∘ <a class="ae ls" href="#d8a0" rel="noopener ugc nofollow">The smart pointer</a><br/>  ∘ <a class="ae ls" href="#6821" rel="noopener ugc nofollow">Custom deleters</a><br/>  ∘ <a class="ae ls" href="#df8a" rel="noopener ugc nofollow">Custom interface</a><br/>  ∘ <a class="ae ls" href="#78f9" rel="noopener ugc nofollow">Tips for Smart Pointers</a><br/>· <a class="ae ls" href="#8f63" rel="noopener ugc nofollow">Item 19:</a> S<!-- -->hared_ptr<!-- --> for shared-ownership resource management.<br/>  ∘ <a class="ae ls" href="#cf8e" rel="noopener ugc nofollow">Analogy: Simple reference counting</a><br/>  ∘ <a class="ae ls" href="#f4b0" rel="noopener ugc nofollow">Detour: Physical class layout</a><br/>· <a class="ae ls" href="#5716" rel="noopener ugc nofollow">Item 21:</a> Prefer <!-- -->unique_ptr<!-- --> and <!-- -->shared_ptr<!-- --> to direct use of <!-- -->new.<br/>  ∘ <a class="ae ls" href="#0242" rel="noopener ugc nofollow">Goal: No raw new or delete</a><br/>  ∘ <a class="ae ls" href="#9426" rel="noopener ugc nofollow">Preferred Usage</a><br/>· <a class="ae ls" href="#61de" rel="noopener ugc nofollow">Conclusion</a><br/>· <a class="ae ls" href="#705d" rel="noopener ugc nofollow">References</a></span></pre><h1 id="3da7" class="lt ln it bd lu lv lw lx ly lz ma mb mc ki md kj me kl mf km mg ko mh kp mi mj bi translated">概观</h1><p id="8bcf" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">让我们继续讨论智能指针:C++中的一个对象，它获得了原始指针的优点，同时克服了它们的缺点。这是该系列的第三部分(参见<a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/smart-pointers-in-cpp-708486276526">第一部分</a>【1】和<a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/understanding-smart-pointers-in-cpp-6c3854593503">第二部分</a>【2】)。</p><p id="7009" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">我们直观地探索C++中智能指针的概念。我们将参考一本所有C++开发者都应该熟悉的书，即Scott Meyers著的<em class="nl">有效的现代c++</em>[3]。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/c0a9dcfd8c37135b529bda18a856fc5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fzXbSjm9hNWOQvEkFI3EGA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">博客中使用的所有可视化效果都是作者使用<a class="ae ls" href="https://lucid.app/" rel="noopener ugc nofollow" target="_blank"> LucidChart </a>创建的。</p></figure><h1 id="0925" class="lt ln it bd lu lv lw lx ly lz ma mb mc ki md kj me kl mf km mg ko mh kp mi mj bi translated"><strong class="ak">第18项:</strong></h1><p id="4334" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">使用<code class="fe nn no np li b">std::unique_ptr</code>进行独占资源管理。[3]</p><h2 id="901d" class="lm ln it bd lu nq nr dn ly ns nt dp mc mt nu nv me mx nw nx mg nb ny nz mi iz bi translated">排他性的关系</h2><p id="66fc" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">动态内存(即动态分配的内存<em class="nl"/>)可通过<a class="ae ls" href="https://www.educba.com/what-is-heap-memory/#:~:text=Heap%20memory%20is%20a%20part,can%20be%20static%20or%20dynamic." rel="noopener ugc nofollow" target="_blank">堆</a>访问。</p><h2 id="19f7" class="lm ln it bd lu nq nr dn ly ns nt dp mc mt nu nv me mx nw nx mg nb ny nz mi iz bi translated">原始指针</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/9c376dd035516bb16d6d0f87072c2109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*TvB9dVTnpPZx0xPZRyH82w.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">任何通过“new”分配给堆内存的指针都必须通过“delete”释放，否则，内存会泄漏。来源— <a class="ob oc ep" href="https://medium.com/u/8049fa781539?source=post_page-----909512a5eb05--------------------------------" rel="noopener" target="_blank">约瑟夫·罗宾逊博士</a>(即作者)。</p></figure><h2 id="d8a0" class="lm ln it bd lu nq nr dn ly ns nt dp mc mt nu nv me mx nw nx mg nb ny nz mi iz bi translated">智能指针</h2><p id="b73a" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">回头看看原始指针。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi od"><img src="../Images/e93dbc872eda944cd1a61ee087d7d4e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*8kVHB6uXGnU-ULPNdwVa8Q.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">原始指针(T*)是可复制的。如果复制了一份，那么这两个人中谁拥有所有权？</p></figure><p id="b98a" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated"><code class="fe nn no np li b"><strong class="mm jd">std::unique_ptr&lt;T&gt;</strong></code></p><div class="ks kt ku kv gt ab cb"><figure class="oe kw of og oh oi oj paragraph-image"><img src="../Images/e409c725b5966194988f7d6bb714e747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*puUfg_Pd9TjNt5Fcc8MPsw.png"/></figure><figure class="oe kw ok og oh oi oj paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/b70da182cdcfaeacf9a85efa3104de64.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*xohqBnrA99nB7U9T_HrU3w.png"/></div></figure></div><p id="8956" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated"><code class="fe nn no np li b">unique_ptr</code>是可移动的(即只移动)。</p><p id="c08c" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated"><code class="fe nn no np li b"><strong class="mm jd">std::unique_ptr&lt;T[]&gt;</strong></code></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/ee71106b8d0638c024493258a994bb51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*Ntxf9YQbH87bbmVil0DHpQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">数组类型有一个专门化。</p></figure><p id="e933" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated"><code class="fe nn no np li b"><strong class="mm jd">std::unique_ptr&lt;T, Deleter&gt;</strong></code></p><div class="ks kt ku kv gt ab cb"><figure class="oe kw om og oh oi oj paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/af4efd6d448c1b25242867fb102f5d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*pQPec684DLstF-ZG3_MDzQ.png"/></div></figure><figure class="oe kw on og oh oi oj paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/7b50daa5b53d0d43cf0a7e456288f5c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*JqtZljdYlTmynIIS80rAfg.png"/></div></figure></div><h2 id="6821" class="lm ln it bd lu nq nr dn ly ns nt dp mc mt nu nv me mx nw nx mg nb ny nz mi iz bi translated">自定义删除程序</h2><p id="b270" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">启用整洁的事物。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="df8a" class="lm ln it bd lu nq nr dn ly ns nt dp mc mt nu nv me mx nw nx mg nb ny nz mi iz bi translated">自定义界面</h2><p id="1d7c" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">与C语言编程OpenSSL接口。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="3c42" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">让我们看看我们的构造函数:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div></figure><ul class=""><li id="ce23" class="oq or it mm b mn ng mq nh mt os mx ot nb ou nf ov ow ox oy bi translated">按值接受<code class="fe nn no np li b">unique_ptr</code>。</li><li id="c4d9" class="oq or it mm b mn oz mq pa mt pb mx pc nb pd nf ov ow ox oy bi translated">通常，通过值获取指针所有权的函数被称为接收器。</li><li id="2465" class="oq or it mm b mn oz mq pa mt pb mx pc nb pd nf ov ow ox oy bi translated"><code class="fe nn no np li b">unique_ptr</code> <em class="nl">汇</em>按所有权传递转移。</li><li id="db26" class="oq or it mm b mn oz mq pa mt pb mx pc nb pd nf ov ow ox oy bi translated">调用构造函数需要一个<code class="fe nn no np li b">unique_ptr</code>。因此，一个人必须拥有<code class="fe nn no np li b">X509_REQ</code>结构的<em class="nl">所有权</em>。通过按值获取<code class="fe nn no np li b">unique_ptr</code>(即通过<code class="fe nn no np li b">move</code>)，构造函数表明它<em class="nl">获得了那个<code class="fe nn no np li b">X509_REQ</code>的所有权</em>。</li><li id="e93b" class="oq or it mm b mn oz mq pa mt pb mx pc nb pd nf ov ow ox oy bi translated">请注意，<code class="fe nn no np li b">unique_ptr</code>是低级、非RAII、原始资源(<code class="fe nn no np li b">X509_REQ</code>)和高级RAII对象(<code class="fe nn no np li b">MyCSR</code>)之间的粘合剂。</li></ul><h2 id="78f9" class="lm ln it bd lu nq nr dn ly ns nt dp mc mt nu nv me mx nw nx mg nb ny nz mi iz bi translated">智能指针提示</h2><p id="9a3d" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">—将智能指针类型视为原始指针类型。</p><ul class=""><li id="f95a" class="oq or it mm b mn ng mq nh mt os mx ot nb ou nf ov ow ox oy bi translated">按值传递。</li><li id="6ab7" class="oq or it mm b mn oz mq pa mt pb mx pc nb pd nf ov ow ox oy bi translated">按值返回(当然)。</li><li id="d197" class="oq or it mm b mn oz mq pa mt pb mx pc nb pd nf ov ow ox oy bi translated">通过引用传递指针通常是一种代码味道。</li></ul><p id="0cd4" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">—智能指针也是如此。</p><ul class=""><li id="07be" class="oq or it mm b mn ng mq nh mt os mx ot nb ou nf ov ow ox oy bi translated">以<code class="fe nn no np li b">unique_ptr</code>为值的函数显示<strong class="mm jd"> <em class="nl">所有权转移</em> </strong>。</li><li id="6a1e" class="oq or it mm b mn oz mq pa mt pb mx pc nb pd nf ov ow ox oy bi translated">甚至显示出<strong class="mm jd"> <em class="nl">什么</em> </strong>责任被转移，因为责任被编码在<code class="fe nn no np li b">deleter</code>类型中。</li><li id="8c4a" class="oq or it mm b mn oz mq pa mt pb mx pc nb pd nf ov ow ox oy bi translated">通常，职责是简单地调用<code class="fe nn no np li b">delete</code>。</li></ul><p id="000a" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">—智能指针是经常实现的细节和粘合剂。</p><ul class=""><li id="5da2" class="oq or it mm b mn ng mq nh mt os mx ot nb ou nf ov ow ox oy bi translated">将<code class="fe nn no np li b">unique_ptr</code>或<code class="fe nn no np li b">shared_ptr</code>烘焙成<strong class="mm jd"> <em class="nl">接口</em> </strong>可能会有代码味。使用类似于<code class="fe nn no np li b">MyCSR</code>的类来代替。</li></ul><h1 id="8f63" class="lt ln it bd lu lv lw lx ly lz ma mb mc ki md kj me kl mf km mg ko mh kp mi mj bi translated"><strong class="ak">第19项</strong></h1><p id="8941" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated"><strong class="mm jd">使用</strong> <code class="fe nn no np li b"><strong class="mm jd">shared_ptr</strong></code> <strong class="mm jd">进行共有资源管理。[3] </strong></p><p id="dc7b" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated"><code class="fe nn no np li b">shared_ptr</code>和<code class="fe nn no np li b">unique_ptr</code>表面相似。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="0c43" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">然而，它比这复杂得多。</p><p id="91ff" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated"><code class="fe nn no np li b">shared_ptr</code>表示共有<em class="nl">所有权</em>。具体来说，<strong class="mm jd"> <em class="nl">引用计数</em> </strong>。</p><h2 id="cf8e" class="lm ln it bd lu nq nr dn ly ns nt dp mc mt nu nv me mx nw nx mg nb ny nz mi iz bi translated">类比:简单的引用计数</h2><blockquote class="pe pf pg"><p id="66b5" class="mk ml nl mm b mn ng kd mp mq nh kg ms ph ni mv mw pi nj mz na pj nk nd ne nf im bi translated">最后一个离开房间的人请关灯好吗？</p></blockquote><p id="d406" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">假设是一个很大的房间，你怎么知道你是不是最后一个？</p><p id="6777" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">在进入时，所有的受试者都要在罐子里放一个代币。然后，在离开时，每人拿回一个代币。所以<strong class="mm jd">最后</strong>令牌表示你是最后一个人。</p><p id="5fd3" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">请注意，在我们的计划中，所有人都必须合作。任何没有留下令牌就进入的人都有被留在黑暗中的危险！</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="cde6" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">让我们看看它的成员:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="d105" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">那<code class="fe nn no np li b">shared_ptr&lt;int&gt;</code>呢？我们可以在哪里存储int对象的引用计数？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/177dab8df625dae704239bc67196cd74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*9heuZi-KiHgQTJXtgsF-kA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><code class="fe nn no np li b">'shared_ptr'</code>将参考计数存储在单独的“控制块”中</p></figure><p id="d6d9" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated"><strong class="mm jd">复制一个</strong>T1】</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/0e3bfcfdd238a4a191c08a460f566c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*mxIJDwXKdXicuf99Z_KsQw.png"/></div></figure><p id="aea3" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">当<code class="fe nn no np li b">shared_ptr</code>已经持有一个指针时，为什么控制块还需要一个指向被控对象的指针？</p><h2 id="f4b0" class="lm ln it bd lu nq nr dn ly ns nt dp mc mt nu nv me mx nw nx mg nb ny nz mi iz bi translated">迂回:物理类布局</h2><div class="ks kt ku kv gt ab cb"><figure class="oe kw pm og oh oi oj paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/7803d5a6b48ae2eac9e11bebfee2a66d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*DM3brekG8xjaXePTZgoWMQ.png"/></div></figure><figure class="oe kw pn og oh oi oj paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/18557f0a4b725bd97e90dd9c6a5cacfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*ZaW0nNsh6NMHAQR0oh9S2A.png"/></div></figure></div><p id="1fa6" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated"><code class="fe nn no np li b"><strong class="mm jd">shared_ptr</strong></code><strong class="mm jd">--</strong>-<code class="fe nn no np li b"><strong class="mm jd">deleter."</strong></code></p><p id="2630" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">与<code class="fe nn no np li b">unique_ptr</code>不同的是，<code class="fe nn no np li b">shared_ptr</code>在物理堆分配的对象和所有权的概念之间放置了一个间接层。</p><p id="2043" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated"><code class="fe nn no np li b">shared_ptr</code>实例实质上参与了<strong class="mm jd">控制块</strong>的引用计数<em class="nl">所有权</em>。控制块本身是“删除受控对象”的唯一仲裁者</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi po"><img src="../Images/8c015ef0b548b45279cd7d93850cce93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*vAhTHWOqqK69-kGa47raag.png"/></div></figure><h1 id="5716" class="lt ln it bd lu lv lw lx ly lz ma mb mc ki md kj me kl mf km mg ko mh kp mi mj bi translated"><strong class="ak">第21项:</strong></h1><p id="2401" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated"><strong class="mm jd">更喜欢</strong><code class="fe nn no np li b"><strong class="mm jd">unique_ptr</strong></code><strong class="mm jd"/><code class="fe nn no np li b"><strong class="mm jd">shared_ptr</strong></code><strong class="mm jd">直接用</strong> <code class="fe nn no np li b"><strong class="mm jd">new</strong></code> <strong class="mm jd">。[3] </strong></p><h2 id="0242" class="lm ln it bd lu nq nr dn ly ns nt dp mc mt nu nv me mx nw nx mg nb ny nz mi iz bi translated">目标:无raw <code class="fe nn no np li b">new</code>或<code class="fe nn no np li b">delete</code></h2><p id="aa47" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">C++内存管理第一法则:(1)每一个<code class="fe nn no np li b">new</code>都必须有一个匹配的<code class="fe nn no np li b">delete</code>，反之亦然。</p><p id="c698" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">C++内存管理的第二条规则:(2)停止使用手动调用<code class="fe nn no np li b">delete</code>！使用智能指针，其析构函数会在适当的时候自动调用<code class="fe nn no np li b">delete</code>。</p><p id="891d" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">但是如果我们停止写作<code class="fe nn no np li b">delete</code>...根据第一条规则，我们不能停止写作吗？</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">请注意，正在调用“new ”:我们希望避免这种情况。</p></figure><p id="b07a" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">运筹学</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">“new”作为输入传递给“shared_ptr”构造函数。下一节是首选用法，在这里任何时候都不调用“new”。</p></figure><p id="972d" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">是啊！如果我们不打算写<code class="fe nn no np li b">delete</code>，那么就停止写<code class="fe nn no np li b">new</code>。</p><p id="4dcd" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">每当我们堆分配一些东西时，我们将使用一个工厂函数返回已经包装在智能指针中的东西<strong class="mm jd"> <em class="nl">。</em> </strong></p><p id="2df0" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">我们不应该用手去触摸原始指针。</p><h2 id="9426" class="lm ln it bd lu nq nr dn ly ns nt dp mc mt nu nv me mx nw nx mg nb ny nz mi iz bi translated">首选用法</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">不需要开发人员称之为“新”太棒了。！</p></figure><p id="13b1" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated"><code class="fe nn no np li b"><strong class="mm jd">make_shared</strong></code> <strong class="mm jd">甚至可以优化。</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/ed027eada61335fdd3f62bd188d11f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*ZS0RbWk58susgazULSgJxQ.png"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div></figure></div><div class="ab cl pq pr hx ps" role="separator"><span class="pt bw bk pu pv pw"/><span class="pt bw bk pu pv pw"/><span class="pt bw bk pu pv"/></div><div class="im in io ip iq"><pre class="ks kt ku kv gt lh li lj lk aw ll bi"><span id="6b1f" class="lm ln it li b gy lo lp l lq lr">💡 `unique_ptr&lt;T&gt;` is implicitly convertible to `shared_ptr&lt;T&gt;`...<!-- --> </span></pre></div><div class="ab cl pq pr hx ps" role="separator"><span class="pt bw bk pu pv pw"/><span class="pt bw bk pu pv pw"/><span class="pt bw bk pu pv"/></div><div class="im in io ip iq"><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">从unique_ptr强制转换共享指针，而不是相反。</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi px"><img src="../Images/0e3043a14ec02a4c0f9c43df66e5a387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*qBn5Ws7vk3zfuhypX2I0Aw.png"/></div></div></figure><h1 id="61de" class="lt ln it bd lu lv lw lx ly lz ma mb mc ki md kj me kl mf km mg ko mh kp mi mj bi translated">结论</h1><h2 id="dcc0" class="lm ln it bd lu nq nr dn ly ns nt dp mc mt nu nv me mx nw nx mg nb ny nz mi iz bi translated">使用<code class="fe nn no np li b">make_shared and make_unique</code></h2><ul class=""><li id="586c" class="oq or it mm b mn mo mq mr mt py mx pz nb qa nf ov ow ox oy bi translated"><code class="fe nn no np li b">make_shared</code>和<code class="fe nn no np li b">make_unique</code>包生<code class="fe nn no np li b">new</code>，正如<code class="fe nn no np li b">~shared_ptr</code>和<code class="fe nn no np li b">~unique_ptr</code>包生<code class="fe nn no np li b">delete</code>。</li><li id="d5ba" class="oq or it mm b mn oz mq pa mt pb mx pc nb pd nf ov ow ox oy bi translated">永远不要用手触摸原始指针，然后永远不需要担心它们会泄漏。</li><li id="8614" class="oq or it mm b mn oz mq pa mt pb mx pc nb pd nf ov ow ox oy bi translated"><code class="fe nn no np li b">make_shared</code>可以进行性能优化。</li></ul><h1 id="705d" class="lt ln it bd lu lv lw lx ly lz ma mb mc ki md kj me kl mf km mg ko mh kp mi mj bi translated">参考</h1><p id="8486" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">[1] <a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/smart-pointers-in-cpp-708486276526"> <strong class="mm jd">理解C++中的智能指针</strong> </a></p><p id="5957" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">[2] <a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/understanding-smart-pointers-in-cpp-6c3854593503"> <strong class="mm jd">现代C++:仔细看看智能指针</strong> </a></p><p id="b2ee" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated"><a class="ae ls" href="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/" rel="noopener ugc nofollow" target="_blank"><strong class="mm jd">【3】有效的现代C++ </strong> </a></p><h2 id="3cc9" class="lm ln it bd lu nq nr dn ly ns nt dp mc mt nu nv me mx nw nx mg nb ny nz mi iz bi translated">额外资源</h2><p id="0d18" class="pw-post-body-paragraph mk ml it mm b mn mo kd mp mq mr kg ms mt mu mv mw mx my mz na nb nc nd ne nf im bi translated">可视化效果和一些例子的灵感来自于Arthur O'Dwyer的伟大演讲，YouTube上的<em class="nl">回到基础:智能指针</em>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qb op l"/></div></figure><p id="a06a" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">Yusuf Aksoy关于STL函子的博客:</p><div class="qc qd gp gr qe qf"><a href="https://medium.com/@yusufaksoyeng/function-objects-functors-in-c-62e6b9cb8876" rel="noopener follow" target="_blank"><div class="qg ab fo"><div class="qh ab qi cl cj qj"><h2 class="bd jd gy z fp qk fr fs ql fu fw jc bi translated">C++中的函数对象(函子)</h2><div class="qm l"><h3 class="bd b gy z fp qk fr fs ql fu fw dk translated">在这篇博文中，我想解释什么是函数对象，以及它们如何被用来解决不同的…</h3></div><div class="qn l"><p class="bd b dl z fp qk fr fs ql fu fw dk translated">medium.com</p></div></div><div class="qo l"><div class="qp l qq qr qs qo qt lb qf"/></div></div></a></div><p id="8a2f" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">C++20中引入的新特性，例如由<a class="ob oc ep" href="https://medium.com/u/74161854f6a1?source=post_page-----909512a5eb05--------------------------------" rel="noopener" target="_blank"> Gajendra Gulgulia </a>撰写的关于<em class="nl">概念</em>的博客系列</p><div class="qc qd gp gr qe qf"><a href="https://ggulgulia.medium.com/c-20-concepts-part-1-the-basics-40f051c72776" rel="noopener follow" target="_blank"><div class="qg ab fo"><div class="qh ab qi cl cj qj"><h2 class="bd jd gy z fp qk fr fs ql fu fw jc bi translated">C++ 20概念:第1部分(基础)</h2><div class="qm l"><h3 class="bd b gy z fp qk fr fs ql fu fw dk translated">用本文中的简单例子编写您的第一个概念</h3></div><div class="qn l"><p class="bd b dl z fp qk fr fs ql fu fw dk translated">ggulgulia.medium.com</p></div></div><div class="qo l"><div class="qu l qq qr qs qo qt lb qf"/></div></div></a></div><p id="fd29" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">更完整的C++指南，如Syed Khizaruddin的系列文章，</p><div class="qc qd gp gr qe qf"><a href="https://khizaruddins.medium.com/c-complete-developer-guide-part-1-124d2298c98b" rel="noopener follow" target="_blank"><div class="qg ab fo"><div class="qh ab qi cl cj qj"><h2 class="bd jd gy z fp qk fr fs ql fu fw jc bi translated">C++:完整的开发人员指南—第1部分</h2><div class="qm l"><h3 class="bd b gy z fp qk fr fs ql fu fw dk translated">C++所有编程语言之母</h3></div><div class="qn l"><p class="bd b dl z fp qk fr fs ql fu fw dk translated">khizaruddins.medium.com</p></div></div><div class="qo l"><div class="qv l qq qr qs qo qt lb qf"/></div></div></a></div><p id="c99d" class="pw-post-body-paragraph mk ml it mm b mn ng kd mp mq nh kg ms mt ni mv mw mx nj mz na nb nk nd ne nf im bi translated">还有更多+更多即将到来！</p></div><div class="ab cl pq pr hx ps" role="separator"><span class="pt bw bk pu pv pw"/><span class="pt bw bk pu pv pw"/><span class="pt bw bk pu pv"/></div><div class="im in io ip iq"><pre class="ks kt ku kv gt lh li lj lk aw ll bi"><span id="f27b" class="lm ln it li b gy lo lp l lq lr"><strong class="li jd">Want to Connect?</strong></span><span id="4e81" class="lm ln it li b gy qw lp l lq lr">Follow Dr. Robinson on <a class="ae ls" href="https://www.linkedin.com/company/superannotate/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>, <a class="ae ls" href="https://twitter.com/jrobvision" rel="noopener ugc nofollow" target="_blank">Twitter</a>, <a class="ae ls" href="https://www.facebook.com/superannotate" rel="noopener ugc nofollow" target="_blank">Facebook</a>, and <a class="ae ls" href="https://www.instagram.com/doctor__jjj/" rel="noopener ugc nofollow" target="_blank">Instagram</a>.</span><span id="9e43" class="lm ln it li b gy qw lp l lq lr">Visit my homepage for papers, blogs, email signups, and more!</span></pre><div class="qc qd gp gr qe qf"><a href="https://www.jrobs-vision.com/" rel="noopener  ugc nofollow" target="_blank"><div class="qg ab fo"><div class="qh ab qi cl cj qj"><h2 class="bd jd gy z fp qk fr fs ql fu fw jc bi translated">人工智能工程师|约瑟夫·p·罗宾逊</h2><div class="qm l"><h3 class="bd b gy z fp qk fr fs ql fu fw dk translated">问候！我是Vicarious Surgical的人工智能工程师，致力于推进下一代外科机器人技术。我的…</h3></div><div class="qn l"><p class="bd b dl z fp qk fr fs ql fu fw dk translated">www.jrobs-vision.com</p></div></div><div class="qo l"><div class="qx l qq qr qs qo qt lb qf"/></div></div></a></div></div></div>    
</body>
</html>