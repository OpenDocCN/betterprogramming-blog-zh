<html>
<head>
<title>How to Develop a Konami Code for Any App With Stencil</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为任何带有模板的应用程序开发Konami代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/develop-a-konami-code-for-any-apps-with-stencil-bd8b11a50071?source=collection_archive---------5-----------------------#2020-04-19">https://betterprogramming.pub/develop-a-konami-code-for-any-apps-with-stencil-bd8b11a50071?source=collection_archive---------5-----------------------#2020-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9b9f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在任何现代web应用程序中添加密码功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c35e04e590fdfec8e64331f57bb29531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xQKl3mFjtshpfAN2gQZ4Bw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@coopery?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">穆罕默德·诺哈西</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="951d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经连续分享了35篇<a class="ae ky" href="https://medium.com/@david.dalbusco/one-trick-a-day-d-34-469a0336a07e" rel="noopener">每日一招</a>的博文，直到原定的瑞士新冠肺炎隔离期结束的日期，2020年4月19日。</p><p id="85f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一里程碑被推迟了，但尽管我们必须继续努力，一些微小的积极迹象已经出现。希望更好的日子就在前面。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="73ec" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Konami密码</h1><p id="d2fb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Konami Code是一种出现在许多Konami视频游戏中的作弊代码，允许玩家在按下游戏控制器上的一系列按钮时显示隐藏的功能或解锁成就:⬆️、⬆️、⬇️、⬇️、⬅️、➡️、⬅️、➡️。</p><p id="74fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于它在流行文化中找到了一席之地，许多网站或应用程序目前正在使用它来提供动画，让我们这些极客和书呆子笑一笑😄。</p><p id="85f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我认为这是一个介绍<a class="ae ky" href="https://stenciljs.com/" rel="noopener ugc nofollow" target="_blank">模板</a>的好例子，也是一个结束这一系列文章的有趣想法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/3ba9f43af6fa3893bf249053fc230412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*4ys6BI2a0KM10GxgnxNmpQ.gif"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8ca3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">开始</h1><p id="c00d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我们使用CLI创建新的独立组件。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="41e5" class="nf md it nb b gy ng nh l ni nj">npm init stencil</span></pre><p id="5831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出现提示时，选择<code class="fe nk nl nm nb b">component</code>作为启动器类型，并提供<code class="fe nk nl nm nb b">konami-code</code>作为项目名称。完成后，跳转到目录并安装依赖项。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e65f" class="nf md it nb b gy ng nh l ni nj">cd konami-code &amp;&amp; npm install</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2877" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">空白组件</h1><p id="958d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">starter组件是用一些“Hello World！”类型代码。这就是为什么，为了让这个教程更容易理解，我们先清理一下。</p><p id="897c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们不会重命名包和文件，因为我们会在之后将其发布到<a class="ae ky" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>中。</p><p id="7af5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们编辑<code class="fe nk nl nm nb b">./src/component/my-component/my-component.tsx</code>来修改属性标签，以便使用我们的组件作为<code class="fe nk nl nm nb b">&lt;konami-code/&gt;</code>。而且，还会渲染“哈都肯！”因为《街头霸王2涡轮增压》把常规代码放在初始闪屏之前，使涡轮增压达到八星⭐.</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="eb96" class="nf md it nb b gy ng nh l ni nj">import { Component, h } from "@stencil/core";<br/><br/>@Component({<br/>  tag: "konami-code",<br/>  styleUrl: "my-component.css",<br/>  shadow: true,<br/>})<br/>export class MyComponent {<br/>  render() {<br/>    return &lt;div&gt;Hadouken!&lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="8a22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还没有修改CSS，但是为了测试目的，我们修改了<code class="fe nk nl nm nb b">./src/index.html</code>，以反映新的<code class="fe nk nl nm nb b">tag</code>名称。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ce9e" class="nf md it nb b gy ng nh l ni nj">&lt;!DOCTYPE html&gt;<br/>&lt;html dir="ltr" lang="en"&gt;<br/>&lt;head&gt;<br/>  &lt;meta charset="utf-8"&gt;<br/>  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=5.0"&gt;<br/>  &lt;title&gt;Stencil Component Starter&lt;/title&gt;<br/><br/>  &lt;script type="module" src="/build/konami-code.esm.js"&gt;&lt;/script&gt;<br/>  &lt;script nomodule src="/build/konami-code.js"&gt;&lt;/script&gt;<br/><br/>&lt;/head&gt;<br/>&lt;body&gt;<br/><br/>  &lt;h1&gt;Konami Code&lt;/h1&gt;<br/><br/>  &lt;p&gt;Develop A "Konami Code" For Any Apps With Stencil&lt;/p&gt;<br/><br/>  &lt;p&gt;Hit: ⬆️,  ⬆️, ⬇️, ⬇️, ⬅️, ➡️️, ⬅️, ➡️, 🅱️, 🅰️&lt;/p&gt;<br/><br/>  &lt;konami-code&gt;&lt;/konami-code&gt;<br/><br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="5f86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行我们的项目(<code class="fe nk nl nm nb b">npm run start</code>)，您的默认浏览器应该在地址<code class="fe nk nl nm nb b">http://localhost:3333</code>自动打开，您应该能够看到呈现的以下元素:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/0b7a70fa0b775542e17de864481cbef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQHNSTCKskWew5o9IQvidg.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="30cf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">侦查</h1><p id="2c54" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">默认情况下，我们将隐藏我们的组件内容，并希望只有在特定的键盘按键序列(⬆️、⬆️、⬇️、⬇️、⬅️、➡️、⬅️、➡️)被点击时才显示它。</p><p id="8d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以在我们的<code class="fe nk nl nm nb b">./src/components/my-component/my-component.tsx</code>中将它定义为一个只读数组。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c5cf" class="nf md it nb b gy ng nh l ni nj">private readonly konamiCode: string[] = [<br/>  "ArrowUp",<br/>  "ArrowUp",<br/>  "ArrowDown",<br/>  "ArrowDown",<br/>  "ArrowLeft",<br/>  "ArrowRight",<br/>  "ArrowLeft",<br/>  "ArrowRight",<br/>  "KeyB",<br/>  "KeyA"<br/>];</span></pre><p id="0924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了监听事件，我们通常注册和注销<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/EventListener" rel="noopener ugc nofollow" target="_blank"> EventListener </a>。关于Stencil的一个很酷的事情是，它使得通过使用<a class="ae ky" href="https://stenciljs.com/docs/events" rel="noopener ugc nofollow" target="_blank">装饰器</a>来做这些事情成为可能。保持代码的整洁非常好。</p><p id="8aea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们对跟踪键盘按键感兴趣，所以我们在监听<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/keydown_event" rel="noopener ugc nofollow" target="_blank"> keydown </a>事件。</p><p id="e090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，为了将用户密钥列表与代码序列进行比较，我们将密钥保存在一个新的数组中。我们还负责将它的最大长度限制为与序列完全相同的长度(使用<code class="fe nk nl nm nb b">shift</code>我们分别删除数组中的第一个对象和内存中保存的最老的键)，最后将它们作为<code class="fe nk nl nm nb b">string</code>进行比较(<code class="fe nk nl nm nb b">join</code>使用提供的分隔符解析数组)。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="cc1a" class="nf md it nb b gy ng nh l ni nj">private keys: string[] = [];<br/><br/>@Listen("keydown", { target: "document" })<br/>onKeydown($event: KeyboardEvent) {<br/>  this.keys.push($event.code);<br/><br/>  if (this.keys.length &gt; this.konamiCode.length) {<br/>    this.keys.shift();<br/>  }<br/><br/>  const match = this.konamiCode.join(",") === this.keys.join(",");<br/>}</span></pre><p id="cf26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一点上，我们的布局应该不会改变，但是如果我们为了演示的目的在监听器函数的末尾添加一个<code class="fe nk nl nm nb b">console.log($event.code, match);</code>，我们应该能够通过观察调试器来测试我们的组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/ae5e9c62884a6311645fd0ac31bc331f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*wQ5VT43wJ_V_1FU1hCDfag.gif"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6333" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">条件渲染</h1><p id="0f29" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了有条件地呈现我们代码的结果，我们引入了一个新的<a class="ae ky" href="https://stenciljs.com/docs/state" rel="noopener ugc nofollow" target="_blank">状态</a>变量，如果对其进行修改，将会导致组件<code class="fe nk nl nm nb b">render</code>函数被再次调用。</p><p id="2d6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用它来有条件地呈现我们的消息“Hadouken！”</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="d781" class="nf md it nb b gy ng nh l ni nj">import {Component, h, Listen, State} from '@stencil/core';<br/><br/>@Component({<br/>  tag: "konami-code",<br/>  styleUrl: "my-component.css",<br/>  shadow: true,<br/>})<br/>export class MyComponent {<br/>  @State()<br/>  private match: boolean = false;<br/>  <br/>  private readonly konamiCode: string[] = [<br/>    "ArrowUp",<br/>    "ArrowUp",<br/>    "ArrowDown",<br/>    "ArrowDown",<br/>    "ArrowLeft",<br/>    "ArrowRight",<br/>    "ArrowLeft",<br/>    "ArrowRight",<br/>    "KeyB",<br/>    "KeyA",<br/>  ];<br/><br/>  private keys: string[] = [];<br/><br/>  @Listen("keydown", { target: "document" })<br/>  onKeydown($event: KeyboardEvent) {<br/>    this.keys.push($event.code);<br/><br/>    if (this.keys.length &gt; this.konamiCode.length) {<br/>      this.keys.shift();<br/>    }<br/><br/>    this.match = <br/>         this.konamiCode.join(",") === this.keys.join(",");<br/>  }<br/><br/>  render() {<br/>    return &lt;div&gt;{this.match ? "Hadouken!" : undefined}&lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="3bc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想在你的浏览器中测试它，你现在应该注意到消息在默认情况下消失了，但是你可以让它在你点击Konami代码序列时出现🎉。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/83e6d5192a9b3bfb199d9eefee3cad96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*v9T9jbZxtk5CwbdXL54iZQ.gif"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0d85" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">动态内容</h1><p id="c3df" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可能有兴趣让用户指定他们自己的消息，而不是“Hadouken！”毕竟，也许有些人更愿意展示“Shoryuken！”😁。</p><p id="ea74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我们可以将固定文本转换成一个<code class="fe nk nl nm nb b">&lt;slot/&gt;</code>。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="30b3" class="nf md it nb b gy ng nh l ni nj">render() {<br/>  return &lt;div&gt;{this.match ? &lt;slot&gt;Hadouken!&lt;/slot&gt; : undefined}<br/>         &lt;/div&gt;;<br/>}</span></pre><p id="f137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近了解到，我们可以为<code class="fe nk nl nm nb b">&lt;slot/&gt;</code>提供一个默认值。这样做，如果提供了开槽元素，它将显示，如果没有，默认的“Hadouken！”将被使用。</p><p id="b601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:<code class="fe nk nl nm nb b">&lt;konami-code&gt;&lt;/konami-code&gt;</code>显示“Hadouken！”但是<code class="fe nk nl nm nb b">&lt;konami-code&gt;Shoryuken!&lt;/konami-code&gt;</code>渲染，嗯，“肖玉肯！”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/1d15501afccb6f30a9b27849ad175180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*6vLBzlgN4xZ-6xXvbdUfaw.gif"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fd9e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">风格</h1><p id="7402" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">即使它完成了工作，我们的组件也可以有点风格化。这就是为什么我建议我们将它修改为<code class="fe nk nl nm nb b">visible</code>而不是逻辑渲染的原因。</p><p id="00d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以在屏幕中央显示信息。</p><p id="3a38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我们引入了<a class="ae ky" href="https://stenciljs.com/docs/host-element" rel="noopener ugc nofollow" target="_blank">宿主元素</a>来有条件地设置所有组件的样式。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c904" class="nf md it nb b gy ng nh l ni nj">render() {<br/>  return &lt;Host class={this.match ? 'visible' : undefined}&gt;<br/>    &lt;div&gt;&lt;slot&gt;Hadouken!&lt;/slot&gt;&lt;/div&gt;<br/>  &lt;/Host&gt;;<br/>}</span></pre><p id="e225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe nk nl nm nb b">&lt;Host/&gt;</code>元素必须从<code class="fe nk nl nm nb b">@stencil/core</code>导入。</p><p id="194e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了给组件设置样式，我们修改了它的相关样式<code class="fe nk nl nm nb b">./src/components/my-component/my-components.css</code>。我们定义了我们的<code class="fe nk nl nm nb b">:host</code>，组件，来覆盖整个屏幕，并且我们设置我们的信息显示在屏幕的中间。</p><p id="6faa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们通过一个类来应用消息的可见性，不管是否在容器上设置，我们添加了一个相关的样式<code class="fe nk nl nm nb b">:host(.visible)</code>来实际显示消息。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="f411" class="nf md it nb b gy ng nh l ni nj">:host {<br/>  display: block;<br/><br/>  position: absolute;<br/>  top: 0;<br/>  left: 0;<br/>  right: 0;<br/>  bottom: 0;<br/><br/>  z-index: 1;<br/><br/>  visibility: hidden;<br/>  opacity: 0;<br/><br/>  background: rgba(0, 0, 0, 0.8);<br/>  transition: opacity 250ms ease-in;<br/>}<br/><br/>:host(.visible) {<br/>  visibility: inherit;<br/>  opacity: 1;<br/>}<br/><br/>div {<br/>  position: absolute;<br/><br/>  top: 50%;<br/>  left: 50%;<br/><br/>  transform: translate(-50%, -50%);<br/><br/>  color: white;<br/>  font-size: 4rem;<br/>}</span></pre><p id="8076" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在浏览器中再次尝试我们的组件，结果应该会更平滑一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/8b0f79211d49e777be97c76408706a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*TCSHaGf7dWwmPEDxobD4XA.gif"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="62f3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">关闭复活节彩蛋</h1><p id="f711" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">很好，如果Konami代码序列被命中，我们已经在我们的应用程序中平滑地显示了一个复活节彩蛋，但是，正如您可能已经注意到的，消息一旦显示就会保持打开状态。</p><p id="9dca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种可能的方法来处理这个问题。一个快速解决方案是在容器上发生<code class="fe nk nl nm nb b">click</code>事件，从而重置我们的<code class="fe nk nl nm nb b">match</code>状态。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5464" class="nf md it nb b gy ng nh l ni nj">render() {<br/>  return &lt;Host <br/>          class={this.match ? 'visible' : undefined} <br/>          onClick={() =&gt; this.match = false}&gt;<br/>    &lt;div&gt;&lt;slot&gt;Hadouken!&lt;/slot&gt;&lt;/div&gt;<br/>  &lt;/Host&gt;;<br/>}</span></pre><p id="a33e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以防万一，我还建议在不使用style时阻止容器上的事件。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ee49" class="nf md it nb b gy ng nh l ni nj">:host {<br/>  pointer-events: none;<br/>}<br/><br/>:host(.visible) {<br/>  visibility: inherit;<br/>  opacity: 1;<br/>}</span></pre><p id="69cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以通过点击鼠标来关闭我们的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/0935bb9a33488d2c14b7c37222b13709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*ybD_Ot6mbL3MMjuWp2B3RQ.gif"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4312" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">总共</h1><p id="a515" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">总之，我们的组件包含很少的代码:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9c46" class="nf md it nb b gy ng nh l ni nj">import {Component, h, Listen, State, Host} from '@stencil/core';<br/><br/>@Component({<br/>  tag: "konami-code",<br/>  styleUrl: "my-component.css",<br/>  shadow: true,<br/>})<br/>export class MyComponent {<br/>  @State()<br/>  private match: boolean = false;<br/>  <br/>  private readonly konamiCode: string[] = [<br/>    "ArrowUp",<br/>    "ArrowUp",<br/>    "ArrowDown",<br/>    "ArrowDown",<br/>    "ArrowLeft",<br/>    "ArrowRight",<br/>    "ArrowLeft",<br/>    "ArrowRight",<br/>    "KeyB",<br/>    "KeyA",<br/>  ];<br/><br/>  private keys: string[] = [];<br/><br/>  @Listen("keydown", { target: "document" })<br/>  onKeydown($event: KeyboardEvent) {<br/>    this.keys.push($event.code);<br/><br/>    if (this.keys.length &gt; this.konamiCode.length) {<br/>      this.keys.shift();<br/>    }<br/><br/>    this.match = <br/>         this.konamiCode.join(",") === this.keys.join(",");<br/>  }<br/><br/>  render() {<br/>    return &lt;Host <br/>          class={this.match ? 'visible' : undefined} <br/>          onClick={() =&gt; this.match = false}&gt;<br/>      &lt;div&gt;&lt;slot&gt;Hadouken!&lt;/slot&gt;&lt;/div&gt;<br/>    &lt;/Host&gt;;<br/>  }<br/>}</span></pre><p id="3d3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的风格几乎和我们的组件一样长😅。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="37b5" class="nf md it nb b gy ng nh l ni nj">:host {<br/>  display: block;<br/><br/>  position: absolute;<br/>  top: 0;<br/>  left: 0;<br/>  right: 0;<br/>  bottom: 0;<br/><br/>  z-index: 1;<br/><br/>  visibility: hidden;<br/>  opacity: 0;<br/><br/>  background: rgba(0, 0, 0, 0.8);<br/>  transition: opacity 250ms ease-in;<br/><br/>  pointer-events: none;<br/>}<br/><br/>:host(.visible) {<br/>  visibility: inherit;<br/>  opacity: 1;<br/><br/>  pointer-events: all;<br/>  cursor: pointer;<br/>}<br/><br/>div {<br/>  position: absolute;<br/><br/>  top: 50%;<br/>  left: 50%;<br/><br/>  transform: translate(-50%, -50%);<br/><br/>  color: white;<br/>  font-size: 4rem;<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0571" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">奖金</h1><p id="81d7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了演示的目的，我还编写了一个向键盘显示事件的小组件，这是本文的第一个GIF。如果感兴趣，这是它的代码。关于我们已经实施的计划，没有什么特别的。</p><p id="d3d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一需要注意的技巧是这些与数组的链接。如果您正在操作一个，您必须创建一个新的来触发对函数<code class="fe nk nl nm nb b">render</code>的新调用。此外，如果是动态渲染，为每个项目设置<code class="fe nk nl nm nb b">key</code>属性更安全。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="6290" class="nf md it nb b gy ng nh l ni nj">import {Component, h, Listen, State} from '@stencil/core';<br/><br/>@Component({<br/>  tag: "konami-keys",<br/>  shadow: true,<br/>})<br/>export class MyKeys {<br/>  @State()<br/>  private keys: string[] = [];<br/><br/>  @Listen("keydown", { target: "document" })<br/>  onKeydown($event: KeyboardEvent) {<br/>    this.keys = [...this.keys, $event.code];</span><span id="34b1" class="nf md it nb b gy no nh l ni nj">    // 10 being the length of the Konami Code<br/>    if (this.keys.length &gt; 10) {<br/>      this.keys.shift();<br/>    }<br/>  }<br/><br/>  render() {<br/>    return this.keys.map((key: string, i: number) =&gt; {<br/>      return &lt;span key={i}&gt;{this.renderKey(key)}&amp;nbsp;&lt;/span&gt;;<br/>    });<br/>  }<br/><br/>  private renderKey(key: string) {<br/>    if (key=== "ArrowUp") {<br/>      return "⬆️";<br/>    } else if (key=== "ArrowDown") {<br/>      return "⬇️";<br/>    } else if (key=== "ArrowLeft") {<br/>      return "⬅️";<br/>    } else if (key=== "ArrowRight") {<br/>      return "➡️";<br/>    } else if (key=== "KeyB") {<br/>      return "🅱️";<br/>    } else if (key=== "KeyA") {<br/>      return "🅰️";<br/>    } else {<br/>      return key;<br/>    }<br/>  }<br/>}</span></pre></div></div>    
</body>
</html>