<html>
<head>
<title>Three Ways to Use the Walrus Operator in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中使用Walrus运算符的三种方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/three-ways-to-use-the-walrus-operator-in-python-d5550f3a7dd?source=collection_archive---------0-----------------------#2019-11-12">https://betterprogramming.pub/three-ways-to-use-the-walrus-operator-in-python-d5550f3a7dd?source=collection_archive---------0-----------------------#2019-11-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3ba2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用这个新的运算符扩展您的工具箱</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e0ae829a6fa423cffa66719f031e6d9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7WijsMHv9h53hElebdPA7Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@florinkozma?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">弗罗林·科兹马</a>在<a class="ae ky" href="https://unsplash.com/s/photos/walrus?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7934" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着Python 3.8的发布，赋值表达式操作符(也称为<a class="ae ky" href="https://medium.com/better-programming/what-is-the-walrus-operator-in-python-5846eaeb9d95" rel="noopener"> walrus操作符</a>)也发布了。</p><p id="6708" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运算符允许将值的赋值传递给表达式。这通常会将语句数减少一个。例如:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0bd2" class="ma mb it lw b gy mc md l me mf">my_list = [1,2,3]</span><span id="743c" class="ma mb it lw b gy mg md l me mf">count = len(my_list)<br/>if count &gt; 3:<br/>   print(f"Error, {count} is too many items")</span><span id="ecf4" class="ma mb it lw b gy mg md l me mf"># when converting to walrus operator...</span><span id="233c" class="ma mb it lw b gy mg md l me mf">if (count := len(my_list)) &gt; 3:<br/>   print(f"Error, {count} is too many items")</span></pre><p id="1477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不得不快速看一眼或者眨几下眼睛，你就会理解对这位新操作员的担忧。这似乎是为了最小的利益而混淆了两个简单的陈述。</p><p id="ee4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设对于<em class="mh">为什么</em> <strong class="lb iu"> <em class="mh"> </em> </strong>引入这个操作符有一个合理的答案，那么自然的问题就是<em class="mh">它在现实世界中如何有用？</em></p><p id="9d55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现了三个领域，我已经并将继续采用海象运营商。此外，除了节省一行代码之外，每种方法都有一个附带的好处，我将分享这一点。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="32ac" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">While循环</h1><p id="9a10" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">While循环似乎是实现walrus操作符最常引用的上下文。在这里使用walrus操作符的好处是，您可以合并while语句中的表达式和修饰语。我无法告诉你我写了多少次无限循环，因为我忘了在while循环的末尾添加修饰符语句。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3a26" class="ma mb it lw b gy mc md l me mf">line = f.readLine()</span><span id="e750" class="ma mb it lw b gy mg md l me mf">while line:<br/>   print(line)<br/>   line = f.readLine()</span><span id="49db" class="ma mb it lw b gy mg md l me mf">while line := f.readLine():<br/>   print(line)</span></pre><p id="42c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，要小心。使用walrus操作符更适合传统的do/while循环，因为赋值发生在表达式之前。请参见下面的差异:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7e7f" class="ma mb it lw b gy mc md l me mf">n = 0<br/>while n &lt; 3:<br/>   print(n) # 0,1,2<br/>   n += 1</span><span id="1e61" class="ma mb it lw b gy mg md l me mf">w = 0<br/>while (w := w + 1) &lt; 3:<br/>   print(w) # 1,2</span></pre><p id="bda5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我有限的经验，我发现它在替换无限while循环时最有用:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="69dd" class="ma mb it lw b gy mc md l me mf">while True:<br/>   p = input("Enter the password: ")<br/>   if p == "the password":<br/>      break</span><span id="558b" class="ma mb it lw b gy mg md l me mf">while (p := input("Enter the password: ")) != "the password":<br/>   continue</span></pre><p id="a8ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">能够将while循环变成几乎一条语句已经很棒了。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="cacf" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">列表理解</h1><p id="4e1b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我发现walrus操作符对优化我的一些列表理解语句很有帮助。我寻找的两个标准是1)过滤数据的需要和2)存储征税函数的结果。首先，让我们看一个传统的列表理解语句:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="be63" class="ma mb it lw b gy mc md l me mf">scores = [22,54,75,89]</span><span id="df0c" class="ma mb it lw b gy mg md l me mf">valid_scores = [<br/>   longFunction(n)<br/>   for n in scores<br/>   if longFunction(n)<br/>]</span></pre><p id="0b3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意情况<code class="fe nl nm nn lw b">if longFunction(n)</code>？注意到我们的<code class="fe nl nm nn lw b">longFunction()</code>被调用了两次吗？这是海象操作员的候选人。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2954" class="ma mb it lw b gy mc md l me mf">scores = [22,54,75,89]</span><span id="f3c5" class="ma mb it lw b gy mg md l me mf">valid_scores = [<br/>   result<br/>   for n in scores<br/>   result := longFunction(n)<br/>]</span></pre><p id="069f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们优化的代码中，<code class="fe nl nm nn lw b">longFunction()</code>只被调用一次，潜在地减少了理解语句中调用总数的一半。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="61cb" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">处理返回的数据</h1><p id="7d8b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">这是对我来说最有帮助的walrus操作符的实现。我经常使用名为iFormBuilder的移动数据收集软件。具体来说，我请求记录(数据行)，如果我的查询返回数据，我需要处理它。下面是我每天写的一段代码:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="aa94" class="ma mb it lw b gy mc md l me mf"># look for failed inspections<br/># if there are failed inspections, assign to technician</span><span id="6cf8" class="ma mb it lw b gy mg md l me mf">records = api.readFailedRecords()<br/>if len(records) &gt; 0:<br/>   for record in records:<br/>      api.assignToTechnician(record)</span></pre><p id="d148" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经开始使用duck typing合并记录的读取和检查，所以只有当返回的列表有数据时才执行这个块:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4c56" class="ma mb it lw b gy mc md l me mf">if records := api.readFailedRecords():<br/>   for record in records:<br/>      api.assignToTechnician(record)</span></pre><p id="50a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就可读性而言，这种重构是破坏性最小的——事实上，我发现在这种情况下，walrus操作符更容易阅读。这与前两个例子形成了对比，在这两个例子中，可读性受到了小的影响，有利于安心和性能。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="b09d" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">结论</h1><p id="59fc" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">海象运营商是新的和有争议的，但只有时间会告诉它如何接受。你开始在你的代码中使用它了吗？</p></div></div>    
</body>
</html>