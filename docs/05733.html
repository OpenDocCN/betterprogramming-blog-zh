<html>
<head>
<title>Coroutines in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的协同程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/coroutines-in-python-building-blocks-of-asynchronous-programming-40c39d9ed420?source=collection_archive---------0-----------------------#2020-08-02">https://betterprogramming.pub/coroutines-in-python-building-blocks-of-asynchronous-programming-40c39d9ed420?source=collection_archive---------0-----------------------#2020-08-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7a2e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">异步编程的构造块</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/06cef4479dd81f8ad8ff1b42d101bba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oY7ecaw_6u-YRy1l"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@imlst?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瓦列里·费多托夫</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">先决条件:你应该了解迭代器，以及Python中的for循环是如何在幕后工作的。你不需要知道任何关于生成器、协程或者</em> <code class="fe lw lx ly lz b"><em class="lv">yield</em></code> <em class="lv">关键字的知识。</em></p><p id="1018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只是快速概述一下Python中for循环的工作原理:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="bdf8" class="mg mh it lz b gy mi mj l mk ml">OUTPUT :</span><span id="6ae2" class="mg mh it lz b gy mm mj l mk ml">1<br/>2<br/>3<br/>4<br/>5</span></pre><p id="fbe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码等效于下面给出的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="baf7" class="mg mh it lz b gy mi mj l mk ml">OUTPUT :</span><span id="6589" class="mg mh it lz b gy mm mj l mk ml">1<br/>2<br/>3<br/>4<br/>5</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="62f9" class="mu mh it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">什么是协程？</h1><p id="fc08" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">协程基本上是一些函数，它们的执行可以在某个特定的点暂停/中止，然后我们可以随时从那个点继续执行。</p><p id="a833" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一种机制——或者更准确地说，一个关键字——通过它我们可以插入一个检查点，并告诉程序我们希望在这里暂停函数的执行，并将控制返回到调用它的地方。我们随时都可以恢复死刑。</p><p id="ab23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，我们可以使用<code class="fe lw lx ly lz b">yield</code>关键字暂停函数的执行。</p><p id="9ddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事情变得有趣起来:</p><ul class=""><li id="b138" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">我们可以把协程看作一个函数，它有一个或多个检查点，在这些检查点上，执行将被暂停，控制权将返回到调用它的地方。</li><li id="5306" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">本质上，协程是一个分成许多部分的函数，当我们使用<code class="fe lw lx ly lz b">next</code>函数执行for循环的每次迭代时，我们可以执行协程的每个部分。</li></ul><p id="6e7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个基本的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="4c88" class="mg mh it lz b gy mi mj l mk ml">OUTPUT :</span><span id="6f05" class="mg mh it lz b gy mm mj l mk ml">&lt;class 'generator'&gt;<br/>Function Starts<br/>Function Ends</span></pre><p id="4005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从输出中，我们注意到一些事情:</p><ul class=""><li id="49df" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">首先，我们需要调用协程/函数，它将为我们提供一个生成器对象。</li><li id="f6f2" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">生成器对象的行为类似于迭代器，但是在迭代器的情况下，我们遍历的是可迭代对象。有了生成器，我们正在执行协程的一部分。</li><li id="c35d" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">正如在for循环的幕后抛出并捕获一个<code class="fe lw lx ly lz b">StopIteration</code>异常一样，在这种情况下，当执行协程的最后一部分时，也会发生同样的情况。</li></ul><p id="f489" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，函数在中间的暂停非常有趣，并带来了一些可能性:</p><ul class=""><li id="2f67" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">当函数暂停时，我们什么也不做，这就是我们刚才看到的情况。</li><li id="ef95" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">假设一个变量在一个函数中被修改了几次，我们想要这个特定变量在某个检查点的值。然后当我们在那个特定的检查点暂停那个函数时，它返回那个变量的值。</li></ul><p id="1f14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="b6ee" class="mg mh it lz b gy mi mj l mk ml">OUTPUT :</span><span id="0660" class="mg mh it lz b gy mm mj l mk ml">Function Part 1<br/>5<br/>Function part 2<br/>12<br/>Function part 3</span></pre><p id="9e39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，<code class="fe lw lx ly lz b">x</code>的值由<code class="fe lw lx ly lz b">yield</code>在不同的检查点返回，因为函数执行已经暂停。</p><p id="4806" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当我们执行函数的最后一部分，并且函数中没有剩余产出时，在执行完最后一部分后，将引发一个<code class="fe lw lx ly lz b">StopIteration</code>异常。</p><p id="bf3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像迭代器试图执行下一个函数，但是iterable中没有元素了，它也会引发<code class="fe lw lx ly lz b">StopIteration</code>异常。</p><ul class=""><li id="44ac" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">假设我们想在某个检查点(即函数的某个状态)发送一个值(可以是常量也可以是变量)。我们也可以使用<code class="fe lw lx ly lz b">yield</code>关键字来实现。当我们想要发送一个值时，我们将使用<code class="fe lw lx ly lz b">send</code>函数而不是<code class="fe lw lx ly lz b">next</code>。</li></ul><p id="d5d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="76f7" class="mg mh it lz b gy mi mj l mk ml">OUTPUT :</span><span id="085b" class="mg mh it lz b gy mm mj l mk ml">Function part 1<br/>6<br/>Function part 2<br/>12<br/>Function part 3</span></pre><p id="1851" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在使用<code class="fe lw lx ly lz b">send</code>之前使用<code class="fe lw lx ly lz b">next</code>的原因是我们只能在<code class="fe lw lx ly lz b">yield</code>检查点使用<code class="fe lw lx ly lz b">send</code>，而<code class="fe lw lx ly lz b">yield</code>在表达式的右边。所以为了到达第一个<code class="fe lw lx ly lz b">yield</code>，我们必须使用<code class="fe lw lx ly lz b">next</code>函数。</p><p id="9644" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在这里有一个有趣的协程应用。假设我们想在两个函数之间来回切换，就像我们在多线程中做的那样。在多线程中，直到操作系统遇到一个<code class="fe lw lx ly lz b">interrupt</code>，它将继续执行。在这种情况下，我们可以随时切换。</p><p id="d9cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><pre class="kj kk kl km gt mc lz md me aw mf bi"><span id="edc8" class="mg mh it lz b gy mi mj l mk ml">OUTPUT :</span><span id="ddbc" class="mg mh it lz b gy mm mj l mk ml">Function 1 part 1<br/>Function 2 part 1<br/>Function 1 part 2<br/>Function 1 part 3<br/>Function 2 part 2<br/>Function 2 part 3<br/>Function 2 part 4<br/>Function 1 part 4<br/>Function 1 part 5</span></pre><p id="298f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们可以看到，只要我们愿意，我们可以在协程之间来回切换。</p><p id="a4ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们编写自己的定制调度程序来处理多个协程之间的切换，我们就可以用单线程实现我们用多线程实现的功能。</p><p id="44c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协程有许多应用，例如并发，也可以实现其他编程模式，如网络编程中的生产者-消费者或发送者-接收者。我将在接下来的文章中探讨这些问题。</p><p id="d981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协程也是asyncio、twisted、aiohttp等许多框架的构建模块。也可以把它们链在一起做管道，解决问题。</p></div></div>    
</body>
</html>