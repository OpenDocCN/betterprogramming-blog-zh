<html>
<head>
<title>Encrypted Websockets with Express and Socket.io</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Express和Socket.io加密Websockets</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/secure-websockets-with-express-and-socket-io-d9a0976c1427?source=collection_archive---------2-----------------------#2019-11-05">https://betterprogramming.pub/secure-websockets-with-express-and-socket-io-d9a0976c1427?source=collection_archive---------2-----------------------#2019-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8bd9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在开发和生产Express中配置SSL加密的Websockets</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3e848221a9377b13b807e56567fc3f6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WzbZ8sZUijkJK5nlcO43ig.jpeg"/></div></div></figure><p id="0c32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您刚刚生成了一个新的<a class="ae lq" href="https://www.npmjs.com/package/express" rel="noopener ugc nofollow" target="_blank"> Express </a>项目，准备开发您的下一个API——这恰好需要一个安全的WebSocket连接。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="5cb6" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu"># firing up yet another Express boilerplate with </strong><a class="ae lq" href="https://www.npmjs.com/package/express#quick-start" rel="noopener ugc nofollow" target="_blank"><strong class="ls iu">express-generator</strong></a></span><span id="0e67" class="lw lx it ls b gy mc lz l ma mb">express secure-websocket</span></pre><p id="57bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章从这里开始——一个新的Express样板文件——带您完成配置安全Websocket的过程，从加密的Nginx <a class="ae lq" href="https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/" rel="noopener ugc nofollow" target="_blank">反向代理</a>到运行在PM2上的加密Socket.io服务。</p><p id="764b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更具体地说，我们将涵盖:</p><ul class=""><li id="3a3d" class="md me it kw b kx ky la lb ld mf lh mg ll mh lp mi mj mk ml bi translated">如何为您的开发环境生成自签名SSL证书，以模拟生产环境的加密连接</li><li id="9aa8" class="md me it kw b kx mm la mn ld mo lh mp ll mq lp mi mj mk ml bi translated">创建一个<code class="fe mr ms mt ls b">SocketService</code> ES6类来管理Websocket服务器的初始化过程</li><li id="7f16" class="md me it kw b kx mm la mn ld mo lh mp ll mq lp mi mj mk ml bi translated">使用<a class="ae lq" href="https://pm2.keymetrics.io/" rel="noopener ugc nofollow" target="_blank"> PM2 </a>进程管理器运行我们的Express服务器，并配置Nginx来代理对它的安全请求</li></ul><p id="b552" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mu">HTTPS网页上的所有内容都必须加密，包括Websocket连接。Safari等主流浏览器会阻止加密网页上不安全的Websocket连接(这是一种“混合内容”的场景，加密网页试图连接到非加密服务)。这篇文章关注的是这个问题的解决方案，所以它永远不会应用到你的应用程序中。</em></p><p id="ac4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要的另一个依赖项是<code class="fe mr ms mt ls b"><a class="ae lq" href="https://www.npmjs.com/package/socket.io" rel="noopener ugc nofollow" target="_blank">socket-io</a></code>:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="cafb" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu"># install socket.io</strong></span><span id="b11b" class="lw lx it ls b gy mc lz l ma mb">cd secure-websocket &amp;&amp; yarn add socket.io</span></pre><p id="985e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，对于这样的设置，我们的首要任务是准备好SSL证书来服务Websocket。对于您的生产服务器，您最有可能从可信机构购买证书，但是出于开发目的，我们将需要自签名证书来加密<code class="fe mr ms mt ls b">localhost</code>。</p><p id="b683" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在进入一些代码之前，下一节将介绍使用<code class="fe mr ms mt ls b"><a class="ae lq" href="https://www.openssl.org/" rel="noopener ugc nofollow" target="_blank">openssl</a></code>为您的开发环境生成自签名证书的过程。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="5d53" class="nc lx it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">为开发生成自签名证书</h1><p id="f711" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">出于本地开发的目的，我们将生成一个自签名的SSL证书，用于加密的WebSocket。存储这些证书最简单的方法是在您的项目文件夹中放置一个<code class="fe mr ms mt ls b">ssl/</code>目录，这个目录在您的<code class="fe mr ms mt ls b">.gitignore</code>文件的源代码控制中被忽略了:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="715d" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu">// .gitignore</strong></span><span id="5fc4" class="lw lx it ls b gy mc lz l ma mb"># development<br/>/ssl</span></pre><p id="1cf4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该目录位于托管<code class="fe mr ms mt ls b">.crt</code>和<code class="fe mr ms mt ls b">.key</code>文件的项目文件夹中:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="bc23" class="lw lx it ls b gy ly lz l ma mb">/secure-websocket<br/>   /ssl<br/>      <strong class="ls iu">server.crt<br/>      server.key</strong><br/>   ...</span></pre><p id="5436" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">两个加粗的文件是我们想用<code class="fe mr ms mt ls b">openssl</code>生成的证书文件。它们将在开发模式下初始化我们的套接字服务器时使用。</p><h2 id="18dc" class="lw lx it bd nd ny nz dn nh oa ob dp nl ld oc od nn lh oe of np ll og oh nr oi bi translated">生成证书</h2><p id="cbae" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">任何人都可以在没有CA帮助的情况下生成自己的证书。唯一的区别是，您自己制作的证书，而不是从受信任的一方购买的，不会被其他任何人信任。</p><p id="f86e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于本地开发，这很好——我们只希望这些证书模拟进出Websocket的加密数据流。</p><p id="4006" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mu">作为购买SSL证书的替代方案，我们有</em><a class="ae lq" href="https://certbot.eff.org/" rel="noopener ugc nofollow" target="_blank"><em class="mu">Certbot</em></a><em class="mu">，这是一个免费的开源工具，可以自动使用</em> <a class="ae lq" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank"> <em class="mu">让我们来加密</em> </a> <em class="mu">证书。谷歌Chrome甚至是Let's Encrypt的“白金赞助商”，因此在可预见的未来，Chrome不信任它的可能性很小。但是，请记住，Let's Encrypt没有绿条支持——它们停留在域级别的验证。</em></p><p id="a767" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为<code class="fe mr ms mt ls b">localhost</code>生成私钥和自签名证书的最简单方法是使用一个<code class="fe mr ms mt ls b">openssl</code>命令。创建并跳转到项目目录中的<code class="fe mr ms mt ls b">/ssl</code>文件夹来生成它们:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="8c84" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu"># jump into ssl folder</strong><br/>mkdir ssl &amp;&amp; cd ssl</span><span id="736e" class="lw lx it ls b gy mc lz l ma mb"><strong class="ls iu"># generate certificate for localhost</strong></span><span id="cb01" class="lw lx it ls b gy mc lz l ma mb">openssl req -x509 \<br/>  -out localhost.crt \<br/>  -keyout localhost.key \<br/>  -newkey rsa:2048 -nodes -sha256 \<br/>  -subj '/CN=localhost' \<br/>  -extensions EXT -config &lt;( \<br/>   printf "[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth")</span></pre><p id="ddc9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行上面的代码，您将在终端中收到以下输出，验证密钥和证书已成功生成:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="1180" class="lw lx it ls b gy ly lz l ma mb">Generating a 2048 bit RSA private key<br/>..........+++<br/>................................+++<br/>writing new private key to 'localhost.key'<br/>-----</span></pre><h2 id="9f33" class="lw lx it bd nd ny nz dn nh oa ob dp nl ld oc od nn lh oe of np ll og oh nr oi bi translated">信任证书(在macOS上)</h2><p id="c36c" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">现在，在信任证书之前，需要采取几个重要步骤。</p><p id="1e76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这部分是基于macOS开发的，但是同样的概念也适用于其他系统——系统必须信任证书。</p><p id="7ea2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请按照以下说明来信任带有钥匙串访问的证书:</p><ul class=""><li id="c995" class="md me it kw b kx ky la lb ld mf lh mg ll mh lp mi mj mk ml bi translated">双击<code class="fe mr ms mt ls b">localhost.crt</code>在钥匙串访问中打开它。</li><li id="7013" class="md me it kw b kx mm la mn ld mo lh mp ll mq lp mi mj mk ml bi translated">双击证书列表中的<code class="fe mr ms mt ls b">localhost</code>证书</li><li id="de83" class="md me it kw b kx mm la mn ld mo lh mp ll mq lp mi mj mk ml bi translated">在信任部分下，切换到<code class="fe mr ms mt ls b">Always Trust</code></li></ul><p id="8240" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的屏幕截图说明了这一过程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/cdf6158d12bc5891593c6b470578eb3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pUYcn6ek05uDAU9HCwyamQ.png"/></div></div><p class="ok ol gj gh gi om on bd b be z dk translated">使用<strong class="bd oo">证书</strong>，双击<strong class="bd oo"> localhost </strong>证书文件，将信任设置切换为<strong class="bd oo">始终信任</strong>。</p></figure><h2 id="54cf" class="lw lx it bd nd ny nz dn nh oa ob dp nl ld oc od nn lh oe of np ll og oh nr oi bi translated">现在重启你的机器</h2><p id="ea4d" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">在这些改变生效之前还有最后一步:重启你的机器。否则，由于证书颁发机构不受信任，您的证书将在浏览器中无效。</p><p id="40a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们的证书已经设置好了，我们现在可以继续创建SocketService类，它将处理我们的socket.io连接。我们还将探索一些管理代码的技巧，同时使其对多环境友好。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="fdc7" class="nc lx it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">返回Javascript: SocketService类</h1><p id="c0f2" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">在本节中，我们将定义一个<code class="fe mr ms mt ls b">SocketService</code>类来管理我们的Websocket连接。完整的<code class="fe mr ms mt ls b">SocketService</code>类作为Github要点提供在文章的最后。</p><h2 id="a481" class="lw lx it bd nd ny nz dn nh oa ob dp nl ld oc od nn lh oe of np ll og oh nr oi bi translated">SocketService概述</h2><p id="2273" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated"><code class="fe mr ms mt ls b">SocketService</code>将您的express <code class="fe mr ms mt ls b">app</code>和一个端口号作为它的构造函数参数——这只是我们启动和运行Websocket所需的两个数据。在它的构造函数中，<code class="fe mr ms mt ls b">SocketService</code>声明了一个HTTPS服务器(在这里我们的SSL证书发挥了作用)，并将结果对象存储为一个类属性:<code class="fe mr ms mt ls b">this.server</code>。</p><p id="4ce7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从这里，我们可以简单地实例化一个新的<code class="fe mr ms mt ls b">SocketService</code>，并在<code class="fe mr ms mt ls b">app.js</code>中用一个单独的方法<code class="fe mr ms mt ls b">initServer()</code>初始化套接字服务器:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="f274" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu">// app.js</strong></span><span id="52c2" class="lw lx it ls b gy mc lz l ma mb">var SocketService = require('./SocketService');</span><span id="688b" class="lw lx it ls b gy mc lz l ma mb"><em class="mu">...</em></span><span id="4d42" class="lw lx it ls b gy mc lz l ma mb">var socket = new SocketService(app, 3003);<br/>socket.initServer();</span></pre><p id="b265" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mu">我在这里使用了</em> <code class="fe mr ms mt ls b"><em class="mu">var</em></code> <em class="mu">变量声明以符合Express的样板代码，但是</em> <code class="fe mr ms mt ls b"><em class="mu">const</em></code> <em class="mu">也可以在这里使用。</em></p><p id="3330" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您想知道此时<code class="fe mr ms mt ls b">initServer()</code>是什么样子，它只是实例化socket.io并在我们传递给构造函数的端口监听:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="e85b" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu">// SocketService.js initServer() method</strong></span><span id="8fc1" class="lw lx it ls b gy mc lz l ma mb">initServer () {<br/>   this.io = require('socket.io')(this.server);<br/>   this.server.listen(this.port);<br/>}</span></pre><p id="a89c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，我们将<code class="fe mr ms mt ls b">socket.io</code>实例存储在另一个类属性<code class="fe mr ms mt ls b">this.io</code>中。从这里我们可以引用这个类属性来定义io事件，所有这些都从<code class="fe mr ms mt ls b">app.js</code>内部继续:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="0b85" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu">// app.js continued</strong></span><span id="80ce" class="lw lx it ls b gy mc lz l ma mb">socket.io.on('connection', socket =&gt; {<br/>   ...<br/>}</span></pre><p id="c943" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我已经将套接字实例化和<code class="fe mr ms mt ls b">initServer()</code>方法分开，以将WebSocket连接从类实例化中分离出来——这是一个很好的实践，因为它使您的逻辑更具可读性和灵活性。为什么？因为在某些情况下，您不会希望Websocket立即初始化——我们可能希望在满足某些条件时有条件地初始化套接字服务器。<code class="fe mr ms mt ls b">constructor()</code>很有用，但是我们不希望它做太多:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="4f95" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu">// At this stage, our Websocket is configured</strong><br/>var socket = new SocketService(app, 3003);</span><span id="ed74" class="lw lx it ls b gy mc lz l ma mb">// further setup and initialisation...</span><span id="0b03" class="lw lx it ls b gy mc lz l ma mb"><strong class="ls iu">// Now when we are ready, initialise socket.io and listen at port</strong><br/>socket.initServer();</span></pre><p id="6a70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个更加灵活的解决方案，它遵循面向对象的方法来管理套接字连接。接下来让我们深入研究一下<code class="fe mr ms mt ls b">SocketService</code>模块和构造函数。</p><h2 id="cc45" class="lw lx it bd nd ny nz dn nh oa ob dp nl ld oc od nn lh oe of np ll og oh nr oi bi translated">SocketService模块和构造函数</h2><p id="e5c1" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated"><code class="fe mr ms mt ls b">SocketService</code>只是一个ES6类，我们在顶部定义它的依赖项，定义类，然后提供它作为模块的唯一导出:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="811d" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu">// import dependencies<br/></strong>var fs = require('fs');<br/>var https = require('https');<br/>var path = require('path');</span><span id="8497" class="lw lx it ls b gy mc lz l ma mb"><strong class="ls iu">// define the class<br/></strong>class SocketService {<br/>   constructor(app, port) {<br/>      ... <br/>   }</span><span id="0468" class="lw lx it ls b gy mc lz l ma mb">   initServer() { <br/>      ...<br/>   }<br/>}</span><span id="7ff4" class="lw lx it ls b gy mc lz l ma mb"><strong class="ls iu">// export the class<br/></strong>module.exports = SocketService;</span></pre><p id="4db7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mu">如果你在一个模块中定义了多个类，你的</em> <code class="fe mr ms mt ls b"><em class="mu">module.exports</em></code> <em class="mu">可以扩展成一个类的对象。</em></p><p id="9adc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mr ms mt ls b">constructor()</code>首先将我们提供的端口设置为一个类属性，然后引入一个基于<code class="fe mr ms mt ls b">process.env.NODE_ENV</code>的<strong class="kw iu"> switch语句</strong>——NodeJS提供的一个环境变量，用于确定我们所处的环境。然后，此switch语句用于根据我们的环境配置不同的HTTPS服务器:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="1f01" class="lw lx it ls b gy ly lz l ma mb">constructor (app, port) {<br/>   this.port = port;</span><span id="4613" class="lw lx it ls b gy mc lz l ma mb">   switch (process.env.NODE_ENV) {<br/>      case 'development':<br/>        // define development https server<br/>      break;</span><span id="4d48" class="lw lx it ls b gy mc lz l ma mb">      default:<br/>        //define production https server<br/>   }<br/>}</span></pre><p id="f92a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我们将<code class="fe mr ms mt ls b">default</code>案例视为我们的生产服务器。这种语法非常灵活，如果您的应用程序需要，您也可以在其中加入一个<code class="fe mr ms mt ls b">staging</code>案例，为您的每个环境定义一个定制的HTTPS服务器。</p><p id="0fa0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要试验更多的<code class="fe mr ms mt ls b">NODE_ENV</code>值，只需在运行express时提供环境变量:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="b6af" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu"># providing NODE_ENV when starting your express server</strong></span><span id="c215" class="lw lx it ls b gy mc lz l ma mb">NODE_ENV=production yarn start</span></pre><p id="a3c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还在switch语句中使用了环境变量来帮助我们的SSL证书。让我们先看看我们是如何定义<code class="fe mr ms mt ls b">development</code>服务器的:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="b432" class="lw lx it ls b gy ly lz l ma mb">case 'development':<br/>   this.server =<br/>      https.createServer({<br/>         key: fs.readFileSync(<br/>           path.resolve(<br/>              process.env.SSL_DEV_KEY || './ssl/localhost.key'<br/>           )<br/>         ),<br/>         cert: fs.readFileSync(<br/>            path.resolve(<br/>               process.env.SSL_DEV_CRT || './ssl/localhost.crt'<br/>            )<br/>         )<br/>      }, app);<br/>break;</span></pre><p id="515d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个模块中发生了很多事情，但是我们只是通过之前导入的<code class="fe mr ms mt ls b">https</code>模块配置了一个HTTPS服务器，将结果存储为一个<code class="fe mr ms mt ls b">server</code>类属性。让我们进一步分析一下:</p><ul class=""><li id="35f9" class="md me it kw b kx ky la lb ld mf lh mg ll mh lp mi mj mk ml bi translated"><code class="fe mr ms mt ls b">https.createServer()</code>(文档<a class="ae lq" href="https://node.readthedocs.io/en/stable/api/https/#httpscreateserveroptions-requestlistener" rel="noopener ugc nofollow" target="_blank">此处为</a>)提供了<code class="fe mr ms mt ls b">key</code>和<code class="fe mr ms mt ls b">cert</code>字段供我们插入证书。正如我们将进一步看到的，我们还可以为证书的ca-bundle文件使用一个<code class="fe mr ms mt ls b">ca</code>字段。出于开发目的，这是不需要的。</li><li id="7a89" class="md me it kw b kx mm la mn ld mo lh mp ll mq lp mi mj mk ml bi translated">我们使用导入的<code class="fe mr ms mt ls b"><a class="ae lq" href="https://nodejs.org/api/fs.html" rel="noopener ugc nofollow" target="_blank">fs</a></code>模块返回文件路径的内容，使用<code class="fe mr ms mt ls b"><a class="ae lq" href="https://nodejs.org/api/fs.html#fs_fs_readfilesync_path_options" rel="noopener ugc nofollow" target="_blank">fs.readFileSync()</a></code>。然而，我们提供的文件路径是<em class="mu">相对文件路径</em>，而不是绝对路径——我们知道它们存在于我们的<code class="fe mr ms mt ls b">ssl/</code>文件夹中，与当前文件位于同一目录，这就是为什么我们使用了<code class="fe mr ms mt ls b">./ssl/&lt;name_of_cert&gt;</code>的相对路径。</li><li id="ef55" class="md me it kw b kx mm la mn ld mo lh mp ll mq lp mi mj mk ml bi translated">为了适应这些相对路径，我们使用了来自我们导入的<code class="fe mr ms mt ls b">path</code>模块的<code class="fe mr ms mt ls b">path.resolve()</code>。现在，我们的证书将在<code class="fe mr ms mt ls b">fs.readFileSync()</code>之前找到并解决，不会出现问题。</li><li id="11ee" class="md me it kw b kx mm la mn ld mo lh mp ll mq lp mi mj mk ml bi translated">我们实际上在<code class="fe mr ms mt ls b">path.resolve()</code>中有一个条件语句——我们首先检查环境变量是否存在——分别是<code class="fe mr ms mt ls b">SSL_DEV_KEY</code>和<code class="fe mr ms mt ls b">SSL_DEV_CRT</code>——让我们可以在启动服务器时选择提供一个自定义路径。如果这些环境变量不存在，我们将使用提供的字符串:</li></ul><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="6c91" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu">// environment variable if provided <em class="mu">or</em> default string fallback value</strong></span><span id="d714" class="lw lx it ls b gy mc lz l ma mb">path.resolve(<br/>   process.env.SSL_DEV_KEY || './ssl/localhost.key'<br/>);</span></pre><p id="4737" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果一个开发团队进行了讨论并突然决定将<code class="fe mr ms mt ls b">ssl/</code>目录移动到一个新的位置，那么我们可以使用这些环境变量并简单地重启服务器进程以使更改生效:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="6b79" class="lw lx it ls b gy ly lz l ma mb">SSL_DEV_KEY=<strong class="ls iu">./new/location/localhost.key</strong> yarn start</span></pre><p id="5979" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们看看默认情况下的生产服务器，它使用类似的设置:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="d4cf" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu">// production server - default case</strong></span><span id="b33d" class="lw lx it ls b gy mc lz l ma mb">default:<br/>   this.server = https.createServer({<br/>      key: fs.readFileSync(<br/>         process.env.SSL_PDT_KEY || '/etc/nginx/ssl/domain.key'<br/>      ),<br/>      cert: fs.readFileSync(<br/>         process.env.SSL_PDT_CRT || '/etc/nginx/ssl/domain.crt'<br/>      ),<br/>      ca: fs.readFileSync(<br/>         process.env.SSL_PDT_CA || '/etc/nginx/ssl/domain.ca-bundle'<br/>      ),<br/>      requestCert: true,<br/>      rejectUnauthorized: false<br/>   }, app);</span></pre><p id="e208" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一次我们采用了绝对文件路径，从文件位置中省略了<code class="fe mr ms mt ls b">path.resolve()</code>。如果您求助于可能存储在文件系统上其他地方的生产SSL证书，比如Nginx <code class="fe mr ms mt ls b">ssl/</code>目录，这就更有意义了。还为ca-bundle文件提供了<code class="fe mr ms mt ls b">https.createServer()</code>的<code class="fe mr ms mt ls b">ca</code>字段。</p><p id="8084" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还包括设置为<code class="fe mr ms mt ls b">true</code>的<code class="fe mr ms mt ls b">requestCert</code>字段，确保使用证书认证。<code class="fe mr ms mt ls b">rejectUnauthorized</code>也被设置为<code class="fe mr ms mt ls b">false</code>，因为如果您在设置中找不到任何错误，授权失败导致的错误可能会成为连接的障碍。一旦你确认没有额外的检查也能正常工作，就切换到<code class="fe mr ms mt ls b">true</code>。</p><p id="41b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mu">如果</em> <code class="fe mr ms mt ls b"><em class="mu">rejectUnauthorized</em></code> <em class="mu">设置为</em> <code class="fe mr ms mt ls b"><em class="mu">true</em></code> <em class="mu">(这也是它的默认值)，服务器证书将根据提供的ca列表进行验证。如果验证失败，将发出一个</em> <code class="fe mr ms mt ls b"><em class="mu">error</em></code> <em class="mu">事件。在发送HTTP请求之前，在连接级别进行验证。</em></p><p id="831a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那是<code class="fe mr ms mt ls b">SocketService</code>的构造器盖的。现在再看一下<code class="fe mr ms mt ls b">initServer()</code>，很清楚我们是如何获取已经配置好的<code class="fe mr ms mt ls b">this.server</code>和<code class="fe mr ms mt ls b">this.port</code>值来初始化socket.io:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="debb" class="lw lx it ls b gy ly lz l ma mb">initServer () {<br/>   this.io = require('socket.io')(<strong class="ls iu">this.server</strong>);<br/>   this.server.listen(<strong class="ls iu">this.port</strong>);<br/> }</span></pre><h2 id="0a8c" class="lw lx it bd nd ny nz dn nh oa ob dp nl ld oc od nn lh oe of np ll og oh nr oi bi translated">在app.js中实例化SocketService</h2><p id="8bab" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">我们简要介绍了<code class="fe mr ms mt ls b">SocketService</code>实例化在<code class="fe mr ms mt ls b">app.js</code>中是如何发生的，但是让我们扩展一下，当一个客户端连接和断开服务时，有<code class="fe mr ms mt ls b">console.log()</code>输出。</p><p id="c73e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了简单起见，让我们将实例化的WebSocket放在配置完<code class="fe mr ms mt ls b">app</code>之后，结束的<code class="fe mr ms mt ls b">module.exports = app;</code>行之前:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="5d2b" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu">// app.js</strong></span><span id="3b97" class="lw lx it ls b gy mc lz l ma mb">var SocketService = require('./SocketService');</span><span id="67a1" class="lw lx it ls b gy mc lz l ma mb">...</span><span id="5a7d" class="lw lx it ls b gy mc lz l ma mb">var mySocket = new SocketService(app, 3003);<br/>mySocket.initServer();</span><span id="7007" class="lw lx it ls b gy mc lz l ma mb">mySocket.io.on('connection', socket =&gt; {<br/>   console.log('client connected');</span><span id="8efb" class="lw lx it ls b gy mc lz l ma mb">   // define more events here...<br/>   <br/>   socket.on('disconnect', reason =&gt; {<br/>    console.log(client disconnected);<br/>    console.log(reason);<br/>  });<br/>}</span><span id="7f02" class="lw lx it ls b gy mc lz l ma mb">module.exports = app;</span><span id="ec1e" class="lw lx it ls b gy mc lz l ma mb">// end of file</span></pre><p id="10d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了这些，我们就可以运行服务器了。为此，将使用<a class="ae lq" href="https://pm2.keymetrics.io/" rel="noopener ugc nofollow" target="_blank"> PM2 </a>流程管理器。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="bed3" class="nc lx it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">和PM2一起跑快车</h1><p id="59cf" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">无论是在本地还是在生产服务器上，开始使用PM2都非常简单。如果您尚未安装，请全局安装PM2:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="6385" class="lw lx it ls b gy ly lz l ma mb">yarn global add pm2</span></pre><p id="84c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在您的express项目目录中，将您的服务器作为PM2进程启动的最快方法是简单地运行带有<code class="fe mr ms mt ls b">--watch</code>标志的<code class="fe mr ms mt ls b">start</code>命令——当对源代码进行更改时，它会自动重新启动进程:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="09e7" class="lw lx it ls b gy ly lz l ma mb">PORT=3001 pm2 start bin/www --name 'secure-websocket' --watch</span></pre><p id="a46a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，在初始化PM2进程之前，我们已经定义了运行服务器的端口。当我们将Nginx请求路由到服务器时，这很重要。</p><h2 id="5e4f" class="lw lx it bd nd ny nz dn nh oa ob dp nl ld oc od nn lh oe of np ll og oh nr oi bi translated">而是使用PM2生态系统文件</h2><p id="dc78" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">然而，有一种更复杂的方式来启动PM2进程——PM2称之为“<a class="ae lq" href="https://pm2.keymetrics.io/docs/usage/quick-start/#ecosystem-file" rel="noopener ugc nofollow" target="_blank">生态系统文件</a>”，我们在启动进程时会用到它。</p><p id="c9f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">生态系统文件可以配置一个或多个同时运行的应用程序或进程。对于我们的用例，我们可以使用一个生态系统文件来配置我们前面定义的环境变量。在您的项目目录中创建以下<code class="fe mr ms mt ls b">ecosystem.config.js</code>文件:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="0cac" class="lw lx it ls b gy ly lz l ma mb">module.exports = {<br/>  apps: [<br/>    {<br/>      name: 'secure-websocket',<br/>      cwd: '~/www/secure-websocket',<br/>      script: 'npm',<br/>      args: 'start',<br/>      env: {<br/>        PORT: 3001,<br/>        NODE_ENV: 'production',<br/>        SSL_DEV_KEY: './ssl/server.key',<br/>        SSL_DEV_CRT: './ssl/server.crt',<br/>        SSL_PDT_KEY: '/etc/nginx/ssl/domain.key',<br/>        SSL_PDT_CRT: '/etc/nginx/ssl/domain.crt',<br/>        SSL_PDT_CA: '/etc/nginx/ssl/domain.ca-bundle',<br/>      },<br/>    },<br/>  ],<br/>};</span></pre><p id="97ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如您所见，我们可以在<code class="fe mr ms mt ls b">env</code>字段中以一种可管理的方式定义环境变量。我们还提供了其他数据，如端口、进程名和启动命令，所有这些都在这个文件中。</p><p id="4ba4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们只需参考这个生态系统文件，就可以在项目目录中启动PM2流程:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="e5fa" class="lw lx it ls b gy ly lz l ma mb">pm2 start ecosystem.config.js --watch</span></pre><p id="2c11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mu">根据该文件中提供的数据的敏感度，您可能希望将</em> <code class="fe mr ms mt ls b"><em class="mu">ecosystem.config.js</em></code> <em class="mu">的所有实例添加到</em> <code class="fe mr ms mt ls b"><em class="mu">.gitignore</em></code> <em class="mu">中。Node JS环境中的环境变量通常用于存储敏感值，如API键。</em></p><p id="a1fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个难题的最后一部分是通过Nginx反向代理为您的生产服务器路由流量。现在让我们来讨论这个。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="dd85" class="nc lx it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">Nginx Websocket反向代理</h1><p id="1e7b" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">为WebSocket设置代理传递的方式与标准API服务非常相似。下面的基本配置监听端口443，这是我们的加密通道，并将请求传递给运行在<code class="fe mr ms mt ls b">localhost:3001</code>上的PM2快速进程。</p><p id="6d6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将此配置添加到您的<code class="fe mr ms mt ls b">/etc/nginx/conf.d</code>目录中，将粗体值更改为您自己的值:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="fd7d" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu"># /etc/nginx/conf.d/domain.com.conf</strong></span><span id="5d2c" class="lw lx it ls b gy mc lz l ma mb">server {<br/>  listen 443;<br/>  server_name <strong class="ls iu">domain.com www.domain.com</strong>;</span><span id="57af" class="lw lx it ls b gy mc lz l ma mb">  ssl on;<br/>  ssl_certificate <strong class="ls iu">/etc/nginx/ssl/domain.crt</strong>;<br/>  ssl_certificate_key <strong class="ls iu">/etc/nginx/ssl/domain.key</strong>;<br/>  ssl_session_cache shared:SSL:1m;<br/>  ssl_session_timeout  10m;<br/>  ssl_ciphers HIGH:!aNULL:!MD5;<br/>  ssl_prefer_server_ciphers on;</span><span id="ea1f" class="lw lx it ls b gy mc lz l ma mb">  resolver 127.0.0.1;<br/>  ssl_stapling on;<br/>  ssl_stapling_verify on;<br/>  ssl_trusted_certificate <strong class="ls iu">/etc/nginx/ssl/domain.ca-bundle;</strong></span><span id="04e7" class="lw lx it ls b gy mc lz l ma mb">  location / {<br/>    proxy_set_header   X-Forwarded-For $remote_addr;<br/>    proxy_set_header   Host $http_host;<br/>    proxy_pass         "<a class="ae lq" href="https://localhost:3001" rel="noopener ugc nofollow" target="_blank">https://localhost:<strong class="ls iu">3001</strong></a>";<br/>    proxy_http_version 1.1;<br/>    proxy_set_header   Upgrade $http_upgrade;<br/>    proxy_set_header   Connection "upgrade";<br/>  }<br/>}</span></pre><p id="b72e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个设置提供了一个加密的数据通道，加密的请求进入我们的服务器，由Nginx处理，然后被代理到我们的安全WebSocket服务。因为我们在内部代理请求，所以不需要从防火墙打开端口<code class="fe mr ms mt ls b">3001</code>，或者您正在使用的任何端口。</p><p id="0816" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mu">可以在Nignx层执行其他身份验证方法，例如测试请求报头以确保它们来自已知的发送方。当然，这也可以在节点层进行测试。</em></p><p id="ccda" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">准备好这个配置文件后，继续重新启动Nginx服务，以便将服务器添加到您的配置中:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="548f" class="lw lx it ls b gy ly lz l ma mb">sudo service nginx restart</span></pre><h2 id="b16b" class="lw lx it bd nd ny nz dn nh oa ob dp nl ld oc od nn lh oe of np ll og oh nr oi bi translated">从前端安全连接</h2><p id="9842" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">最后，记住从你的前端应用安全地连接到Websocket。例如，在Javascript应用程序中使用<code class="fe mr ms mt ls b"><a class="ae lq" href="https://www.npmjs.com/package/socket.io-client" rel="noopener ugc nofollow" target="_blank">socket.io-client</a></code>包:</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="5d93" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls iu">// connecting to a secure websocket from the frontend</strong></span><span id="5673" class="lw lx it ls b gy mc lz l ma mb">import io from 'socket.io-client';</span><span id="c02f" class="lw lx it ls b gy mc lz l ma mb">const socket = io.connect('<strong class="ls iu">https</strong>://localhost:3001/', {<br/>   transports: ['websocket'],<br/>   <strong class="ls iu">secure: true</strong><br/>});</span></pre><p id="9284" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让您的服务URL以<code class="fe mr ms mt ls b">https</code>开始，并将<code class="fe mr ms mt ls b">secure</code>配置设置为<code class="fe mr ms mt ls b">true</code>。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="9ce7" class="nc lx it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">摘要</h1><p id="11ad" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">本文介绍了使用Express和Socket.io以及PM2和Nginx的安全WebSocket连接设置。</p><p id="3739" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了帮助将一个安全的Websocket解决方案应用到现实世界的用例中，我发表了一篇关于构建针对实时价格数据的价格图表SVG的文章。作为一个有趣的挑战，你能把SVG数据和一个活动的websocket连接联系起来吗？</p><div class="op oq gp gr or os"><a href="https://medium.com/@rossbulat/react-real-time-price-chart-svg-components-3f93767fc350" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">React:实时价格图表SVG组件</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">如何在React中实现实时SVG线图</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">medium.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div><p id="29b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是<code class="fe mr ms mt ls b">SocketService.js</code>的全部要点——它可以作为您自己服务的良好基础:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure></div></div>    
</body>
</html>