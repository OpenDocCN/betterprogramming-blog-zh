<html>
<head>
<title>Intro to Angular Reactive Forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角反应形式介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/intro-to-angular-reactive-forms-fc5cd636ce1f?source=collection_archive---------7-----------------------#2022-07-14">https://betterprogramming.pub/intro-to-angular-reactive-forms-fc5cd636ce1f?source=collection_archive---------7-----------------------#2022-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="bb4e" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/@lorenzozar/list/angular-5496c492a185" rel="noopener">棱角分明的</a></h2><div class=""/><div class=""><h2 id="9987" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">通过一步一步地建立一个简单的形式来探索角反应形式</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/29614289cec13f73543ee06c4ed09317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PSjr-3tASsVvIClL"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@parrish?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">帕里什·弗里曼</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="613d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Angular提供了两种通过表单处理用户输入的主要方法:反应式和模板驱动式。这两种方法都建立在通用表单API之上。</p><p id="2d17" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这篇文章中，我将按照反应式方法构建一个表单，也称为模型驱动表单。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/f95ec3cb596f74a9793c01b5f745c127.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*Ia0oFFdKsIwYRNA-UCJNsg.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">带有验证器的简单反应形式</p></figure><p id="a11c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我写了一篇<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-angular-template-driven-forms-cd3a1b10380a">介绍Angular模板驱动的表单</a>，其中我使用模板驱动的方法构建了相同的表单。</p><p id="2f7b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我发现使用这两种方法构建相同的表单有助于更好地理解差异。</p><h1 id="a76a" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">反应式方法概述</h1><p id="c42d" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">根据<a class="ae le" href="https://angular.io/guide/forms-overview#choosing-an-approach" rel="noopener ugc nofollow" target="_blank">文档</a>，反应式表单“提供对底层表单对象模型的直接、明确的访问。</p><p id="7c20" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果表单是应用程序的关键部分，或者你已经在使用反应式模式构建应用程序，那么就使用反应式表单。”</p><p id="d1b2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">此外，他们补充说，反应式表单比模板驱动的表单更健壮:它们更具可伸缩性、可重用性和可测试性。</p><h2 id="ccaa" class="na md iq bd me nb nc dn mi nd ne dp mm lo nf ng mo ls nh ni mq lw nj nk ms iw bi translated">不要认为这是板上钉钉的事</h2><p id="805c" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">关于最佳方法的争论可能永远不会有结果。</p><p id="9e3d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">你更喜欢模板驱动的表单还是反应式表单？</p><p id="b49b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在Angular Plus秀播客中，他们给了谷歌Angular开发者专家、IdeaBlade总裁兼联合创始人沃德·贝尔空间。</p><p id="1476" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Ward Bell多年来一直使用模板驱动的表单，并且是该领域最好的专家之一。</p><p id="61fd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">确保你听了这一集来形成(lol)你的观点。</p><h1 id="2212" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">FormsModule和两个指令</h1><p id="4dd3" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">首先，我们需要记住导入<a class="ae le" href="https://angular.io/api/forms/ReactiveFormsModule" rel="noopener ugc nofollow" target="_blank"> ReactiveFormsModule </a>，因为它“导出了反应式表单所需的基础设施和指令。”</p><p id="d551" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因此，我们在<code class="fe nl nm nn no b">app.module.ts</code>中导入<code class="fe nl nm nn no b">ReactiveFormsModule</code>。</p><pre class="kp kq kr ks gt np no nq nr aw ns bi"><span id="d2f1" class="na md iq no b gy nt nu l nv nw">import { ReactiveFormsModule } from '@angular/forms';</span></pre><p id="de7d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">并在<code class="fe nl nm nn no b">@NgModule.</code>的进口报关</p><pre class="kp kq kr ks gt np no nq nr aw ns bi"><span id="a223" class="na md iq no b gy nt nu l nv nw">imports: [BrowserModule, FormsModule, ReactiveFormsModule],</span></pre><p id="6171" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">注意，<code class="fe nl nm nn no b">FormsModule</code>在那里是因为同一个应用程序在另一个组件中使用了模板驱动的表单。</p><p id="3363" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果我们两个都需要，我们应该两个都进口。</p><p id="fe62" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">然而，<code class="fe nl nm nn no b">FormsModule</code>很重要，因为<code class="fe nl nm nn no b">NgModel</code>和<code class="fe nl nm nn no b">NgForm</code>指令都是从<code class="fe nl nm nn no b">FormsModule</code>导出的。</p><h1 id="b777" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">构建表单元素</h1><p id="c020" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">理论上，我们可以从类或者模板开始。</p><p id="99dd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">然而，“反应式表单提供了一种模型驱动的方法来处理值随时间变化的表单输入。”</p><p id="0f4e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在反应式表单中，从类开始更自然，尽管有些人可能更喜欢从模板开始，这完全没问题。</p><p id="0d61" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">由于介绍了角度模板驱动的表单，我从一个通用的表单元素开始；我将遵循这种方法来说明一些事情是相同的。</p><h1 id="4647" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">通用表单元素</h1><p id="cdc9" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">角度形状中的一般形状元素可能如下所示:</p><pre class="kp kq kr ks gt np no nq nr aw ns bi"><span id="b645" class="na md iq no b gy nt nu l nv nw">&lt;div&gt;<br/>  &lt;label for="email"&gt;Email&lt;/label&gt;<br/>  &lt;input type="email" id="email" [formControl]="email" /&gt;<br/>&lt;/div&gt;</span></pre><p id="b265" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">再一次，这是非常普通的HTML，除了<code class="fe nl nm nn no b">[formControl]=”email"</code>。</p><p id="20a0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe nl nm nn no b">formControl</code>绑定来自<code class="fe nl nm nn no b">FormControlDirective</code>，后者来自我们上面导入的<code class="fe nl nm nn no b">ReactiveFormsModule </code>。</p><p id="0238" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果您熟悉角度语法，这并不新鲜，因为它看起来类似于属性绑定。</p><h2 id="ba3d" class="na md iq bd me nb nc dn mi nd ne dp mm lo nf ng mo ls nh ni mq lw nj nk ms iw bi translated">它绑定到什么？</h2><p id="2486" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">它绑定到类中的email属性。</p><p id="c0cc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">导入<code class="fe nl nm nn no b">FormControl</code>后，我们可以给<code class="fe nl nm nn no b">email</code>分配一个新的<code class="fe nl nm nn no b">FormControl</code>实例。<code class="fe nl nm nn no b">FormControl</code>“跟踪单个表单控件的值和验证状态，”<a class="ae le" href="https://angular.io/api/forms/FormControl#formcontrol" rel="noopener ugc nofollow" target="_blank"> angular.io </a>。</p><pre class="kp kq kr ks gt np no nq nr aw ns bi"><span id="bf84" class="na md iq no b gy nt nu l nv nw">import { Component } from '@angular/core';<br/>import { FormControl } from '@angular/forms';</span><span id="5196" class="na md iq no b gy nx nu l nv nw">...<br/>export class ReactiveFormComponent {<br/>  email = new FormControl('');<br/>}</span></pre><p id="ee43" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这种情况下，通过使用<code class="fe nl nm nn no b">new FormControl('')</code>，我们将<code class="fe nl nm nn no b">email</code>的初始值设置为空字符串。</p><p id="3aa8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">多亏了<code class="fe nl nm nn no b">FormControl</code>，我们可以监听、更新和验证表单元素的状态。</p><p id="3dbb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您可以获得双向绑定的所有好处，甚至更多，比如验证。</p><p id="74f3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们将很快进行验证。</p><h2 id="9117" class="na md iq bd me nb nc dn mi nd ne dp mm lo nf ng mo ls nh ni mq lw nj nk ms iw bi translated">显示表单控件值</h2><p id="7f17" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">您可以通过使用插值和模板中的<code class="fe nl nm nn no b">value</code>属性轻松显示该值，如下所示:</p><pre class="kp kq kr ks gt np no nq nr aw ns bi"><span id="7879" class="na md iq no b gy nt nu l nv nw">&lt;p&gt;Value: {{ email.value }}&lt;/p&gt;</span></pre><p id="321d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">第二种方式是“通过<code class="fe nl nm nn no b">valueChanges</code> observable，您可以使用AsyncPipe监听模板中表单值的变化，或者使用subscribe()方法监听组件类中表单值的变化”，<a class="ae le" href="https://angular.io/guide/reactive-forms#displaying-a-form-control-value" rel="noopener ugc nofollow" target="_blank"> angular.io </a>。</p><h1 id="2a27" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">从一种元素到一种形式</h1><p id="9970" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">从上面的通用元素开始，我们可以创建以下形式:</p><pre class="kp kq kr ks gt np no nq nr aw ns bi"><span id="1ae0" class="na md iq no b gy nt nu l nv nw">import { Component } from '@angular/core';<br/>import { FormGroup, FormControl } from '@angular/forms';</span><span id="91a5" class="na md iq no b gy nx nu l nv nw">...<br/>reactiveForm = new FormGroup({<br/>    name: new FormControl(''),<br/>    email: new FormControl(''),<br/>    age: new FormControl(''),<br/>});</span></pre><p id="4f9e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">注意，我们必须从@angular/forms导入每个组件中的<code class="fe nl nm nn no b">FormGroup</code>,在那里我们要创建一个新的<code class="fe nl nm nn no b">FormGroup</code>实例。</p><p id="a9ec" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们在类中创建了一个<code class="fe nl nm nn no b">FormGroup</code>实例。FormGroup”跟踪一组FormControl实例的值和有效性状态。</p><p id="c979" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">然后，我们需要使用属性绑定将模板中的<code class="fe nl nm nn no b">FormGroup</code>模型和视图关联起来。</p><p id="f3c8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">至于模板驱动的表单，我们希望有一种方法将表单作为一个整体来处理，而不是处理每个元素。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ny nz l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">初始反应形式</p></figure><h2 id="8536" class="na md iq bd me nb nc dn mi nd ne dp mm lo nf ng mo ls nh ni mq lw nj nk ms iw bi translated">一阶差分</h2><p id="c3a9" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">我们可以在<code class="fe nl nm nn no b">form</code>标签中看到模板驱动表单的第一个区别。我们不再使用参考变量了。</p><h2 id="8a8f" class="na md iq bd me nb nc dn mi nd ne dp mm lo nf ng mo ls nh ni mq lw nj nk ms iw bi translated">第二个区别</h2><p id="4d49" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">第二个区别是<code class="fe nl nm nn no b">formControlName</code>。</p><p id="e0ee" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">由<code class="fe nl nm nn no b">FormControlName</code>指令提供的<code class="fe nl nm nn no b">formControlName</code>输入将每个单独的输入绑定到<code class="fe nl nm nn no b">FormGroup</code>、<a class="ae le" href="https://angular.io/guide/reactive-forms#grouping-form-controls" rel="noopener ugc nofollow" target="_blank"> angular.io </a>中定义的表单控件。</p><p id="3600" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但是，表单组实例为模型值提供了真实的来源。</p><h2 id="0919" class="na md iq bd me nb nc dn mi nd ne dp mm lo nf ng mo ls nh ni mq lw nj nk ms iw bi translated">第三个区别</h2><p id="2e78" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">第三个区别是我们不需要在输入标签中使用name属性。</p><p id="9de3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">你的应用不会崩溃，但是你会在你的控制台上看到一个难看的错误。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/b5068fdb3ca7686acdd3696163ae4ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M5qxb9VnJE5VAUj0-usXAw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">当我们忘记模板驱动的表单中的name属性时，控制台中的错误。</p></figure><p id="e364" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">顺便提一下，你也可以通过使用一个<a class="ae le" href="https://angular.io/guide/reactive-forms#grouping-form-controls" rel="noopener ugc nofollow" target="_blank">表单数组</a>将控件分组到一个表单中。本帖不讨论这个。</p><h1 id="dec0" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">确认</h1><p id="d1b6" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">目前，我们还没有确认。</p><p id="ae80" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">反应式表单通过称为验证器的特殊函数来处理验证。Angular提供了<a class="ae le" href="https://angular.io/api/forms/Validators" rel="noopener ugc nofollow" target="_blank">内置的验证器</a>，您可以使用现成的验证器。</p><p id="df6d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">使用验证器最简单的方法是将它们作为第二个参数传递给<code class="fe nl nm nn no b">FormControl</code>。</p><pre class="kp kq kr ks gt np no nq nr aw ns bi"><span id="35b9" class="na md iq no b gy nt nu l nv nw">reactiveForm = new FormGroup({<br/>    name: new FormControl('', Validators.required),<br/>    email: new FormControl(''),<br/>    age: new FormControl('', [<br/>      Validators.required,<br/>      Validators.max(99),<br/>      Validators.min(18),<br/>    ]),<br/>});</span></pre><p id="f9e8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在代码片段中，我添加了两个验证器。第一个使<code class="fe nl nm nn no b">name</code>成为必需。第二个验证器检查<code class="fe nl nm nn no b">age</code>是否在18和99之间。</p><p id="b8e4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通过更新“提交”按钮，如下所示:</p><pre class="kp kq kr ks gt np no nq nr aw ns bi"><span id="a6e9" class="na md iq no b gy nt nu l nv nw">&lt;button type="submit" [disabled]="reactiveForm.invalid"&gt;Submit&lt;/button&gt;</span></pre><p id="d6a2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们确保只有当表单有效时，按钮才是活动的，例如，满足验证器中的条件。</p><p id="ed0a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当内置验证器不够用时，我们甚至可以为更复杂的情况创建<a class="ae le" href="https://angular.io/guide/form-validation#defining-custom-validators" rel="noopener ugc nofollow" target="_blank">定制验证器</a>。</p><h1 id="d0f9" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">快速小结</h1><p id="68ba" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">Angular提供了两种主要的构建表单的方法:反应式和模板驱动式。在这篇文章中，我们探讨了反应式方法。</p><p id="7a4f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这两种方法都建立在通用表单API之上。</p><ol class=""><li id="6d58" class="ob oc iq lh b li lj ll lm lo od ls oe lw of ma og oh oi oj bi translated">在<code class="fe nl nm nn no b">app.module.ts</code>中导入<code class="fe nl nm nn no b">ReactiveFormsModule</code></li><li id="36bd" class="ob oc iq lh b li ok ll ol lo om ls on lw oo ma og oh oi oj bi translated">使用<code class="fe nl nm nn no b">new FormControl()</code>实例化一个表单控件</li><li id="9d0e" class="ob oc iq lh b li ok ll ol lo om ls on lw oo ma og oh oi oj bi translated">使用<code class="fe nl nm nn no b">new FormGroup()</code>创建一组表单控件</li><li id="2b6b" class="ob oc iq lh b li ok ll ol lo om ls on lw oo ma og oh oi oj bi translated">通过属性绑定<code class="fe nl nm nn no b">[FormGroup]="myFormGroupName"</code>将类中的<code class="fe nl nm nn no b">FormGroup</code>模型与视图绑定</li><li id="91c9" class="ob oc iq lh b li ok ll ol lo om ls on lw oo ma og oh oi oj bi translated">导入<code class="fe nl nm nn no b">ReactiveFormsModule</code>后<code class="fe nl nm nn no b">&lt;form&gt;</code>标签默认实现<code class="fe nl nm nn no b">NgForm</code></li></ol><p id="a01d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">可以随意看看GitHub上的<a class="ae le" href="https://github.com/lorenzojkrl/formication/tree/main/src/app/components/reactive-form" rel="noopener ugc nofollow" target="_blank">代码。</a></p></div></div>    
</body>
</html>