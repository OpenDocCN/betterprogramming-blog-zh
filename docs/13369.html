<html>
<head>
<title>Writing Better Code With Go Concurrency Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go并发模式编写更好的代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-better-code-with-go-concurrency-patterns-9bc5f9f73519?source=collection_archive---------1-----------------------#2022-08-22">https://betterprogramming.pub/writing-better-code-with-go-concurrency-patterns-9bc5f9f73519?source=collection_archive---------1-----------------------#2022-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8eda" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">每个开发人员都应该知道的简单技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d0cfbde0e0b78f015431f7804a4f6095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rte70IBPku3IV587QwNH8g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">塞尔吉奥·索萨在<a class="ae ky" href="https://www.pexels.com/photo/gray-concrete-roadway-1828469/" rel="noopener ugc nofollow" target="_blank">的照片</a></p></figure><p id="f189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着Goroutines的出现，编写并发程序变得前所未有的简单。</p><p id="fa29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然很方便，但是如果不小心处理，Goroutines也很容易出现难以追踪的错误。</p><p id="dfb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好消息是，如果您对Go并发模式有充分的了解，其中一些是可以预防的。</p><p id="065d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接下来的几分钟里，我将向您介绍一些行之有效的实践，让您能够在Go中编写更安全、更高效的并发代码。</p><p id="afbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><h1 id="b0ad" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是Go并发模式？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/d3213b3e383d35e686a9f26a5bdb5a72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HaVTuCs6ecCxOzfIKPVoNQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@hebertsantos/" rel="noopener ugc nofollow" target="_blank">赫伯特·桑多斯</a>在<a class="ae ky" href="https://www.pexels.com/photo/man-practicing-martial-arts-with-swords-8461245/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</p></figure><p id="454d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go并发模式与常见的OOP设计模式没有任何相似之处。</p><p id="7f97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它不是一套教条的、分类良好的模式，指导你如何构建代码。</p><p id="11d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，它是一个实践列表，回答了以下问题，</p><ul class=""><li id="be64" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated">我们如何处理Goroutines中的错误？</li><li id="852c" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">我们如何阻止所有不再需要的Goroutines？</li><li id="beec" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">我们应该在哪里关闭一个频道？</li><li id="100c" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">我们如何安排Goroutines来增加程序的吞吐量？</li></ul><p id="69b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表从这里开始，不再赘述，让我们深入第一个模式。</p><h1 id="33fd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">发送方必须始终关闭通道</h1><p id="87ef" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">必须始终优雅地关闭通道，以防止<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/common-goroutine-leaks-that-you-should-avoid-fe12d12d6ee"> Goroutine泄漏</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">发送到关闭的通道会导致死机</p></figure><p id="b8f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从封闭通道中读取将总是产生两个参数:</p><ul class=""><li id="b58a" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated">元素的零类型值</li><li id="d460" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">指示通道是否打开的布尔参数</li></ul><p id="ff8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，发送到封闭的通道会立即引起恐慌。</p><p id="a62f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，发送方应该总是代替接收方关闭通道。</p><p id="4827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以防止发送方意外输出到关闭的通道，并确保一致性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">发送方应关闭通道</p></figure><p id="0ddc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，一旦所有的数据都被发送，发送者就关闭通道。当通道关闭时，接收者自动退出循环。</p><h1 id="3acb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">生成器模式</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/71978c1a3008eb26343ec0e90760b52e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*OArqmmOgRuXNdvjq7Pg3Jw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">当接收者同时消费时，生成器将输入数据输入到通道中</p></figure><p id="5f4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个典型的Go并发程序由一个生产者和一个消费者通过一个通道进行通信组成。</p><p id="e755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生产者生成数据流，并通过信道将其发送给消费者。</p><p id="0a55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">generator模式在单独的Goroutine中生成数据，而不是等待所有数据都被创建后再进行处理。</p><p id="6958" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得消费者能够同时处理数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据生成和消费是同时进行的</p></figure><ol class=""><li id="1dbd" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nk mu mv mw bi translated">生成器创建一个通道并立即返回</li><li id="7d18" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">通过单独的Goroutine，生成器将输入集输入到通道中</li><li id="13ab" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">消费者通过信道循环并同时处理数据</li><li id="bb42" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">请注意，生成器(发送方)是关闭<code class="fe nl nm nn no b">inputCh</code>的那个</li></ol><h1 id="c1a4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">作为一等公民的错误</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/b28e987f828c57f793e53319ad89aaf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*36wa0aVOiGIo3VxZB8L9jA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Andrea Piacquadio 在<a class="ae ky" href="https://www.pexels.com/photo/thoughtful-man-using-smartphone-on-street-3800149/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄的照片</p></figure><p id="5ec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并发Goroutine独立于其父进程运行。因此，当错误发生时，可能很难推理出正确的做法。</p><p id="92ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下列要点中的消费者为例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">消费者不知道如何处理错误</p></figure><p id="c197" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当错误发生时，它使我们的消费者处于尴尬的境地。将错误记录到控制台并不是一个理想的解决方案。</p><p id="48ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Goroutine不应该在没有完整上下文的情况下处理错误，而是应该将错误返回给知道应该做什么的人，在大多数情况下，是我们的主Goroutine。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/8baec65544750fe56f259b944511f063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*CIS_CMd-cvzkDLU7gZF0hg.png"/></div></figure><p id="2f8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下示例显示了该问题的解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据和错误一起被发送回主例程</p></figure><ol class=""><li id="d8e9" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nk mu mv mw bi translated">我们创建了一个新的结构类型<code class="fe nl nm nn no b">Result</code>,它耦合了结果和错误</li><li id="d9b7" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">在<code class="fe nl nm nn no b">consumer</code>函数中，我们<code class="fe nl nm nn no b">callDatabase</code>通过<code class="fe nl nm nn no b">resultCh</code>返回<code class="fe nl nm nn no b">Result</code>结构中的结果和错误</li><li id="b3ca" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">主函数循环通过<code class="fe nl nm nn no b">resultCh</code>并处理结果和错误</li></ol><p id="1774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Goroutine中的错误应该与其结果类型相关联，并传递回知道程序完整状态的主Goroutine。</p><p id="2d9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">底线是一个错误应该被认为是一等公民。它应该和我们程序中的所有其他参数一样受到同等的重视。</p><p id="810d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，消费者关闭了<code class="fe nl nm nn no b">resultCh</code>，因为它是通道的发送者。</p><h1 id="b2a2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">突然停止</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/ff8e0ee173bb8b22e900d1059c789368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xVSUMDLgug4NlSBSMgvdqQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://www.pexels.com/@pixabay/" rel="noopener ugc nofollow" target="_blank">像素</a>在<a class="ae ky" href="https://www.pexels.com/photo/red-stop-sign-39080/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄的照片</p></figure><p id="4c1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发送方在通道上被阻塞，直到接收方准备好在另一端接收数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">发电机被无限期阻塞</p></figure><p id="722c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，生成器<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/common-goroutine-leaks-that-you-should-avoid-fe12d12d6ee">被无限期阻塞</a>，因为一旦处理程序退出，就没有接收者检索数据。</p><p id="8d1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当不再需要时，我们如何安排所有Goroutines终止？</p><p id="7ba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案在于显式取消。</p><p id="21aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从封闭通道接收将立即进行，并返回元素的零类型值。</p><p id="ddfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过利用这个属性，我们可以创建一个<code class="fe nl nm nn no b">Done</code>通道，通过关闭<code class="fe nl nm nn no b">Done</code>通道来终止所有的Goroutines。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过doneCh显式取消</p></figure><ol class=""><li id="bce6" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nk mu mv mw bi translated">我们创建一个<code class="fe nl nm nn no b">doneCh</code>，它接受一个空的结构(不管它接受什么)</li><li id="a8c1" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated"><code class="fe nl nm nn no b">generator</code>函数监听<code class="fe nl nm nn no b">select</code>语句中的<code class="fe nl nm nn no b">doneCh</code></li><li id="efa8" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">当处理器退出时，它关闭<code class="fe nl nm nn no b">doneCh</code></li><li id="def6" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated"><code class="fe nl nm nn no b">generator</code>中的<code class="fe nl nm nn no b">select</code>语句运行第一种情况并立即返回</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/8ca3d263fde7e6fda68a90cc26917613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wRBVmc0M8TljN0kbI_qOdw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">所有goroutines都监听DoneChannel，如果该频道关闭，则退出</p></figure><p id="dbe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以将<code class="fe nl nm nn no b">doneCh</code>传递给所有正在运行的Goroutines，并通过关闭它来通知它们返回。</p><p id="4352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，您可以用<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/understanding-context-in-golang-7f574d9d94e0">上下文包</a>中的<code class="fe nl nm nn no b">ctx.Done()</code>函数替换<code class="fe nl nm nn no b">doneCh</code>。</p><h1 id="51e0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">管道模式</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/647264eddad92f91781e88370b4c5602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*Mi2Dn6f2qCOT2XXDRxtnkw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">管道模式</p></figure><p id="faac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">管道是一系列接收数据、处理数据并将其传递到另一个阶段的阶段。</p><p id="a5c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个不使用Goroutine的简单管道示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">钻孔管道</p></figure><p id="7807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一个示例中，我们将<code class="fe nl nm nn no b">1</code>添加到输入中，并将结果传递到乘法阶段进行进一步处理。</p><p id="e349" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">管道的好处是显而易见的</p><ul class=""><li id="008c" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated">它将管道中每个阶段的关注点分开。每个阶段只负责一件事。</li><li id="6b84" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">阶段是模块化的，允许我们混合和匹配阶段的组合方式。</li></ul><p id="7802" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上示例中的阶段按顺序运行。每个阶段只能在前一阶段处理完所有数据后开始。</p><p id="6b37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用Goroutine和通道，阶段可以并发地运行和处理数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/961f7932e46d1089eab4be1e227ae209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PUcTo6f2VbSpnpxBCRVlew.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用Goroutines和通道的管道模式</p></figure><p id="e9d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们转换我们的<code class="fe nl nm nn no b">add</code>和<code class="fe nl nm nn no b">multiply</code>函数来接收一个<code class="fe nl nm nn no b">inputCh</code>并输出一个<code class="fe nl nm nn no b">resultCh</code>。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将阶段与通道相加和相乘</p></figure><p id="35c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把主函数中的所有东西结合起来。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结合一切</p></figure><ol class=""><li id="88d8" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nk mu mv mw bi translated">我们使用<code class="fe nl nm nn no b">generator</code>函数创建一个数据流</li><li id="8910" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">我们创建一个<code class="fe nl nm nn no b">doneCh</code>并传递给所有Goroutines进行显式取消</li><li id="bb1e" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">然后我们将<code class="fe nl nm nn no b">add</code>和<code class="fe nl nm nn no b">multiply</code>阶段链接在一起</li><li id="4807" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">每当<code class="fe nl nm nn no b">add</code>函数处理完一个输入。它会立即将结果传递到乘法阶段进行进一步处理</li></ol><p id="f63f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个阶段同时处理数据，并在完成后立即将其传递给下一个阶段。</p><p id="3503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，乘法和加法阶段可以混合和匹配，以产生不同的结果。</p><h1 id="f5b0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">扇出，扇入</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/bbf62ef0aa0aebbc5ea58f97a95c5504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*wWMhMypygxHMJ4_uBbeyqA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扇出、扇入模式</p></figure><p id="de98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照流水线模式，如果其中一个流水线阶段计算量更大，需要更长的处理时间，会发生什么情况？</p><p id="82b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有上游数据将被搁置，下游阶段将被闲置。</p><p id="b7cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最直观的解决办法是在工作量最大的地方增加工人数量。</p><p id="92a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是扇出、扇入模式发挥作用的地方。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/dbaec9d4a659ff71688cd776ec605bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*0x9X69lbml5zEBZ8L9vLiQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扇出</p></figure><p id="a5b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">扇出，简而言之，是指在特定阶段产生更多的Goroutines以增加其吞吐量，换句话说，就是解复用。</p><p id="1494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设前面的管道示例中的<code class="fe nl nm nn no b">add</code>函数计算量很大，我们希望增加<code class="fe nl nm nn no b">add</code>工作器的数量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扇出</p></figure><ol class=""><li id="f573" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nk mu mv mw bi translated"><code class="fe nl nm nn no b">fanOut</code>函数接收一个<code class="fe nl nm nn no b">inputCh</code>并产生十个<code class="fe nl nm nn no b">add</code>go routine来同时处理输入流</li><li id="8da9" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">由于每个<code class="fe nl nm nn no b">add</code> Goroutine返回它们的<code class="fe nl nm nn no b">resultCh</code>，我们将结果通道存储在一个片上，并将它们返回给主函数</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/60072518c571ade94ef02354a247ec44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*_XzvlLSgtNrtoq0Vv7PmDw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扇入</p></figure><p id="8cc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，扇入将多个结果合并到一个通道中，也称为多路复用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扇入</p></figure><ol class=""><li id="8f1d" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nk mu mv mw bi translated"><code class="fe nl nm nn no b">fanIn</code>函数接收一部分通道(<code class="fe nl nm nn no b">fanOut</code>函数产生它们)</li><li id="93b4" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">对于每个通道，我们生成一个单独的Goroutine来从通道获取数据，并将其提供给<code class="fe nl nm nn no b">finalCh</code>。</li><li id="b6af" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">在函数的最后，我们生成一个单独的Goroutine来等待所有go routine完成并关闭<code class="fe nl nm nn no b">finalCh</code></li><li id="834b" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">然后，我们将合并后的通道— <code class="fe nl nm nn no b">finalCh</code>返回到主函数</li><li id="3610" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">在每次迭代中，<code class="fe nl nm nn no b">chClosure</code>作为<code class="fe nl nm nn no b">ch</code>的闭包</li></ol><p id="cc1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">综合所有内容，我们得到如下结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扇出，扇入</p></figure><ol class=""><li id="68c8" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nk mu mv mw bi translated">我们使用<code class="fe nl nm nn no b">generator</code>创建一个数据流<code class="fe nl nm nn no b">inputCh</code></li><li id="db4d" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">我们使用<code class="fe nl nm nn no b">fanOut</code>为我们的<code class="fe nl nm nn no b">add</code>函数生成十个工人</li><li id="99ab" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">我们使用<code class="fe nl nm nn no b">fanIn</code>函数合并所有的<code class="fe nl nm nn no b">channels</code></li><li id="4934" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">然后，我们将<code class="fe nl nm nn no b">addResultCh</code>传递到<code class="fe nl nm nn no b">multiply</code>阶段进行进一步处理</li></ol><p id="4261" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用扇出、扇入模式，我们可以为管道的单个阶段增加工人的数量，从而增加程序的吞吐量。</p><h1 id="937b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">旗语</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/10ac19afc919ee17805ec5fc299e4b63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fWJqyjf-bQsMu9fHi_rzWQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">所有Goroutines同时查询共享资源</p></figure><p id="ac2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着您产生更多的Goroutines来并发处理请求，这给我们留下了另一个问题。</p><p id="1c9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果所有的Goroutines都访问相同的共享资源，比如远程缓存，会发生什么？</p><p id="1237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用无限数量的并发请求轰炸您的缓存肯定会立即降低您的缓存。</p><p id="633c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是信号量派上用场的地方。</p><p id="69e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与互斥锁不同，互斥锁允许单个线程一次访问一个资源，信号量允许<code class="fe nl nm nn no b">N</code>个线程一次访问一个资源。</p><p id="056e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用缓冲通道的概念，我们可以很容易地设计信号量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">旗语</p></figure><ol class=""><li id="0541" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nk mu mv mw bi translated"><code class="fe nl nm nn no b">NewSemaphore</code>通过创建一个容量为<code class="fe nl nm nn no b">maxReq</code>的缓冲通道来发起一个<code class="fe nl nm nn no b">Semaphore</code></li><li id="59b0" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">当一个例程<code class="fe nl nm nn no b">Acquire</code>发出信号量时，我们向<code class="fe nl nm nn no b">semaCh</code>发送一个空结构</li><li id="96f6" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">当缓冲通道满时，对<code class="fe nl nm nn no b">Acquire</code>的调用将被阻塞</li><li id="7ee8" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">当一个Goroutine <code class="fe nl nm nn no b">Release</code>一个信号量时，一个空的结构将被送出通道，在缓冲通道中为后续的<code class="fe nl nm nn no b">Acquire</code>创建空间</li></ol><p id="d898" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">信号量示例</p></figure><ol class=""><li id="c79a" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nk mu mv mw bi translated">我们创建一个容量为<code class="fe nl nm nn no b">2</code>的信号量</li><li id="5750" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">我们生成十个Goroutines来处理某些任务</li><li id="5efa" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">每个Goroutine在处理之前都会获取一个信号量</li><li id="fcdf" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nk mu mv mw bi translated">由于有十个任务，并发任务的最大数量是<code class="fe nl nm nn no b">2</code>，处理所有任务所需的总时间将是五秒(每个任务花费一秒)</li></ol><p id="164e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的代码会产生以下输出，这证实了我们的假设。</p><pre class="kj kk kl km gt ny no nz oa aw ob bi"><span id="9248" class="oc lw it no b gy od oe l of og">11:35:09 Running worker 9<br/>11:35:09 Running worker 0<br/>11:35:10 Running worker 6<br/>11:35:10 Running worker 4<br/>11:35:11 Running worker 5<br/>11:35:11 Running worker 7<br/>11:35:12 Running worker 2<br/>11:35:12 Running worker 1<br/>11:35:13 Running worker 3<br/>11:35:13 Running worker 8</span></pre><h1 id="c889" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/24e761da6c85ac754910651683bc6a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z2RdQcoJs2_gYB9WCfPhJw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://www.pexels.com/@tbphotography/" rel="noopener ugc nofollow" target="_blank">坦贝拉·博勒</a>在<a class="ae ky" href="https://www.pexels.com/photo/photo-of-man-running-during-daytime-2803160/" rel="noopener ugc nofollow" target="_blank">像素上拍摄的照片</a></p></figure><p id="3e8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在结束这篇长篇大论的文章之前，让我们回顾一下迄今为止我们所经历的</p><ul class=""><li id="4108" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated">在发送方总是关闭你的通道</li><li id="0c82" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">利用生成器模式同时生成您的输入数据流</li><li id="e788" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">将您的错误与结果结合起来，并将它们发送回主Goroutine</li><li id="bc15" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">使用完成通道或上下文包进行显式取消</li><li id="d833" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">使用管道模式将您的代码分成多个并发阶段</li><li id="180e" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">通过扇出、扇入模式增加流水线级的吞吐量</li><li id="44e0" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">创建一个信号量来管理代码中的最大并发工作线程数</li></ul><p id="71e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住这些简单的模式，我希望你现在可以在Go中编写更好更高效的并发代码！</p><p id="f346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说完了，下次再见！</p></div></div>    
</body>
</html>