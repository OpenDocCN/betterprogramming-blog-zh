<html>
<head>
<title>The Power of Recursion in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中递归的力量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-of-recursion-in-javascript-af57107a1a5a?source=collection_archive---------5-----------------------#2020-03-29">https://betterprogramming.pub/the-power-of-recursion-in-javascript-af57107a1a5a?source=collection_archive---------5-----------------------#2020-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8dd7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">递归是一种增强</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a657461667a5ffcf253682a8a990cffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vg_DR8J6mZFBkbBTSV2Cuw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">Joshua Sortino在Unsplash上拍摄的照片</em></p></figure><p id="0c2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae lv" href="https://en.wikipedia.org/wiki/Recursion" rel="noopener ugc nofollow" target="_blank">递归</a>是计算机编程中一个强大的概念，函数只需调用自己。在学习了基础知识之后，尽快学习递归是多么重要，这一点我怎么强调都不为过。</p><p id="ed95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解递归的概念以及如何创建递归将有助于你像程序员一样思考，这将有助于你编写更健壮的代码。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="89ed" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">递归的好处</h1><p id="3b28" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">一般来说，在某些情况下应用递归时，您几乎总能从中获得以下好处:</p><ol class=""><li id="5def" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">你节省了代码行。</li><li id="a2f1" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">您的代码可以看起来更干净(因此应用干净的代码实践，即使这不是您的意图)。</li><li id="4306" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">它有助于节省编写和调试代码的时间。</li><li id="ffae" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">它减少了运行算法的时间量(<a class="ae lv" href="https://en.wikipedia.org/wiki/Time_complexity" rel="noopener ugc nofollow" target="_blank">时间复杂度</a>)。</li><li id="b43a" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">有助于在处理树形结构时轻松解决问题。</li><li id="e4de" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">有助于<em class="no">可视化</em>算法(<a class="ae lv" href="https://algorithm-visualizer.org/" rel="noopener ugc nofollow" target="_blank">不信我？</a>)。</li></ol></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4470" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">递归的缺点</h1><ol class=""><li id="5145" class="na nb it lb b lc mv lf mw li np lm nq lq nr lu nf ng nh ni bi translated">它<em class="no">可以</em>慢一些——在这种情况下，它会占用更多的堆栈空间(开销)。</li><li id="aa42" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">如果不使用<a class="ae lv" href="https://en.wikipedia.org/wiki/Tail_call" rel="noopener ugc nofollow" target="_blank">尾部调用优化</a>，则使用比循环更多的内存。</li></ol></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="109d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">我们需要它吗？</h1><p id="cf3e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">实际上，您可以使用迭代来执行任何算法。问题是，你必须知道<em class="no">什么时候</em>最好应用递归——只有这样递归才是更好的选择，而不是使用迭代。</p><p id="6692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在最适合递归的情况下应用递归时，你就释放了递归的力量，就像在汉诺塔问题中应用递归一样。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1989" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">例子</h1><p id="b36d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">理解递归的一个好方法是查看应用递归来解决问题的工作代码。</p><h2 id="3e62" class="ns me it bd mf nt nu dn mj nv nw dp mn li nx ny mp lm nz oa mr lq ob oc mt od bi translated">遍历对象</h2><p id="fcad" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如前所述，递归有助于在处理树形结构时轻松解决问题。一个深度嵌套的对象是一个树形结构，所以我们将使用一个对象。</p><p id="ec2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个表示HTML DOM元素的对象，其中每个嵌套对象都可以有元素的子元素。每个子元素都是另一个HTML DOM元素，也可以有子元素，所以它可能是一个非常大的对象，这取决于它们的父元素产生了多少子元素。</p><p id="642e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的目标是挖掘每一个对象，不管它的嵌套有多深。</p><p id="79b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将查看它们的<code class="fe oe of og oh b">style</code>属性(表示特定HTML元素的属性)，并将<code class="fe oe of og oh b">border</code>、<code class="fe oe of og oh b">textColor</code>和<code class="fe oe of og oh b">width</code>属性固定到它们的样式表示中，以便在使用JavaScript时可以正常读取它们。</p><p id="4093" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个需要更改的样式对象的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="42fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在HTML中，为了给文本着色，我们需要使用<code class="fe oe of og oh b">color</code>属性，所以我们必须将<code class="fe oe of og oh b">textColor</code>转换为<code class="fe oe of og oh b">color</code>。</p><p id="4ee8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe oe of og oh b">width</code>，我们假设这些小数代表用户设备视口的百分比(应该转换成<code class="fe oe of og oh b">45vw</code>)，需要将<code class="fe oe of og oh b">border</code>对象转换成类似<code class="fe oe of og oh b">{ borderColor: 'hotpink', borderWidth: '2px' }</code>的形状。</p><p id="aee9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用一个表示类似结构的对象，这样我们就可以遍历它并修复所有的样式对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="de74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，这里我们有一个树形结构，嵌套对象出现在<code class="fe oe of og oh b">children</code>属性中。</p><p id="a572" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要创建的第一件事是一个<code class="fe oe of og oh b">transformStyleObject</code>函数，它接受一个style对象来修复它，返回一个可以在JavaScript和DOM中正常使用的新对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="ccba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用常规迭代来遍历对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="0fa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是它开始变得麻烦，原因如下:</p><ol class=""><li id="3cdb" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">它变得更长。</li><li id="1161" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">阅读变得更加困难。</li><li id="745b" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">调试变得更加困难。</li><li id="8e0d" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">它对变化变得更加敏感。</li><li id="dff1" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">测试变得更加困难。</li><li id="8040" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">这变得很烦人，因为你不得不考虑更多的变量名。</li></ol><p id="7579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，可以使用递归来解决上面列出的所有六个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="58cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的实现现在看起来更加优雅，也更容易阅读！这种递归是这样工作的:</p><ol class=""><li id="7940" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><code class="fe oe of og oh b">transformAll</code>接受一个代表HTML DOM元素的<em class="no">单个</em>对象。</li><li id="2319" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">转换该元素的样式属性(在我们的例子中，这是每个HTML DOM元素的目标)。</li><li id="a461" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">通过检查元素的<code class="fe oe of og oh b">children</code>属性来检查是否有嵌套元素。</li><li id="2b35" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">如果有，这个函数将遍历每个子节点，并在每个子节点上重新调用自己的<code class="fe oe of og oh b">transformAll</code>。</li><li id="410f" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">这启动了递归，并将遍历通过<code class="fe oe of og oh b">children</code>找到的每个对象，不管树有多深。</li></ol></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3806" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">使用文件和文件夹</h1><p id="18f3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我个人觉得写更多功能性代码是一种很棒的体验。当有功能代码时，就有更多的优雅。递归非常适合这种情况。</p><p id="6936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们构建一个程序，它将查看文件路径下的每个目录，扫描名为<code class="fe oe of og oh b">__test__</code>的文件夹，并通过查找带有<code class="fe oe of og oh b">.test.js</code>的文件名来检测是否有任何单元测试没有实现。</p><p id="9097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个文件夹都将是一个“模块”，如果<em class="no">没有</em>的<code class="fe oe of og oh b">__test__</code>文件夹<em class="no">或者</em>的<em class="no"> </em> <code class="fe oe of og oh b">__test__</code> <em class="no"> </em>文件夹中没有任何以<code class="fe oe of og oh b">.test.js</code>结尾的文件，我们将假设<em class="no">没有为其实现单元测试。</em></p><p id="1197" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果它发现有一个模块的测试，它将向我们返回一个包含整个目录信息的对象，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="9787" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个操作的最终结果是这些对象的数组，其中每个对象代表一个需要我们注意的文件夹(在我们的例子中是一个模块),因为他们还没有单元测试。</p><p id="3b8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归可以很容易地用来实现这一点。</p><p id="2453" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用了<a class="ae lv" href="https://github.com/trekhleb/javascript-algorithms" rel="noopener ugc nofollow" target="_blank"> JavaScript算法repo </a>，提取出了<code class="fe oe of og oh b">src</code>目录中的所有内容，并有意删除了一些例子中的几个单元测试，以便我们的代码可以在结果中返回这些位置。</p><p id="ec5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面的代码片段从<a class="ae lv" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>导入原生模块。</p><p id="7480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将导入<code class="fe oe of og oh b">fs</code>,并声明一个根目录来开始遍历:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="e950" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们稍后将使用来自<code class="fe oe of og oh b">fs</code>模块的<code class="fe oe of og oh b">isDirectory</code>方法来检测何时进入目录。我个人更喜欢将它包装成一个函数，因为我不喜欢编写完整的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="2a84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将创建一个名为<code class="fe oe of og oh b">hasTest</code>的函数，它接受一个字符串数组，遍历它们，如果它发现有一个测试文件，它将返回<code class="fe oe of og oh b">true</code>，否则返回<code class="fe oe of og oh b">false</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="65de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在对于主函数，我们称之为<code class="fe oe of og oh b">findEmptyTests</code>，它负责累积所有没有实现任何测试的模块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="a86a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到这是一个递归，因为它在这一行中调用了<em class="no">本身</em>:</p><pre class="kj kk kl km gt ok oh ol om aw on bi"><span id="9c6b" class="ns me it oh b gy oo op l oq or">emptyTests = { ...emptyTests, ...findEmptyTests(filepath) }</span></pre><p id="7b58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是最重要的部分！</p><p id="ca8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数的工作方式是，我们可以通过传入一个文件路径来调用<code class="fe oe of og oh b">findEmptyTests</code>。</p><p id="22b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们传入的文件路径是一个目录，它会读取目录中的所有文件，并将文件名存储到<code class="fe oe of og oh b">dir</code>数组中。</p><p id="86ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后会执行一个循环，以便我们可以检查哪个是目录。如果遇到当前迭代<code class="fe oe of og oh b">filepath</code>的目录，它将检查两个条件:</p><ol class=""><li id="d2ab" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">当前迭代文件路径是<code class="fe oe of og oh b">__test__</code>目录本身吗？如果是的话，检查一下那个目录，看看是否有以<code class="fe oe of og oh b">.test.js</code>结尾的文件。如果没有，我们获取关于该模块在回购中的位置的信息。</li><li id="9f90" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">当前迭代的文件路径<em class="no">是不是不是</em>是<code class="fe oe of og oh b">__test__</code>目录而<em class="no"> </em>还是<em class="no"> </em>目录？如果是，则遍历该目录，并在该目录中启动整个函数<em class="no">，并在其后的目录中启动，依此类推。</em></li></ol><p id="4233" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，一旦它完成操作，就返回结果。</p><p id="81b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能已经注意到了<code class="fe oe of og oh b">createMissingTestsObject</code>功能。它只是一个收集文件路径及其目录信息的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="04b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这应该会返回一个丢失单元测试的位置对象！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1a6a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="7cfe" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这个帖子到此结束！我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>