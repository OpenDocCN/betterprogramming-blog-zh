<html>
<head>
<title>7 TypeScript Common Mistakes To Avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">要避免的7个打字稿常见错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-typescript-common-mistakes-to-avoid-581c30e514d6?source=collection_archive---------2-----------------------#2021-08-02">https://betterprogramming.pub/7-typescript-common-mistakes-to-avoid-581c30e514d6?source=collection_archive---------2-----------------------#2021-08-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3bc6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过避免这些常见错误来改进您的类型脚本代码库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d90a3b527b154281b7e0b89580a0144a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4C9n2FOh0w3vCzm6Lur8g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.pexels.com/photo/yelling-formal-man-watching-news-on-laptop-3760778/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae ky" href="https://www.pexels.com/@olly?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Andrea Piacquadio </a>的照片</p></figure><p id="6405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自2012年10月首次出现以来，TypeScript已经获得了广泛的关注，它已经成为web开发领域真正的游戏规则改变者。虽然，有些人一直对使用它持怀疑态度。</p><p id="a6f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当将TypeScript添加到项目中时，开发人员接受它而不是反对它是很重要的。这可能会导致挫折感，并让人觉得TypeScript已经成为一个瓶颈。然而，如果使用得当，拥有一个可读且易于维护的代码库变得至关重要。它有很好的特性，比如映射类型、重载、类型推断、可选类型等等，并且随着不断升级，这些特性越来越好。</p><p id="7c06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么有些人觉得TypeScript损害了他们的生产力？怎么才能防止这种坏名声呢？有没有一些我们可以采纳的最佳实践？</p><p id="0458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们将讨论使用TypeScript时最常见的错误。通过不陷入这些通常的怀疑，我们将看到我们的生产力和代码可维护性的提高。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8829" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.不启用严格模式</h1><p id="7e7f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果没有TypeScript <code class="fe mz na nb nc b">strict</code>模式，打字可能会太松，这将使我们的代码库不那么类型安全。这会给人一种错误的印象，因为有些人认为通过添加TypeScript，所有的打字问题都会自动得到解决。</p><p id="0db8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以后，我们将成为这些类型的受害者。我们可能最终用补丁来修复它们，而不是修复根本原因。这可能会导致认为该工具没有做好工作。</p><p id="eecb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何才能启用严格模式？通过将<code class="fe mz na nb nc b">tsconfig.json</code>文件中的<code class="fe mz na nb nc b">strict</code>参数设置为真来启用，如下图所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="fb1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启用<code class="fe mz na nb nc b">strict</code>模式将启用钩下:</p><ul class=""><li id="4768" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><code class="fe mz na nb nc b">noImplicitAny</code>:这个标志防止我们暴露带有推断<code class="fe mz na nb nc b">any</code>的合同。如果我们不指定类型，无法推断，那么将默认为<code class="fe mz na nb nc b">any</code>。</li><li id="dde2" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe mz na nb nc b">noImplicitThis</code>:防止<code class="fe mz na nb nc b">this</code>关键字不必要的不安全使用。防止不必要的行为将使我们免于一些调试难题，如下所示:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><ul class=""><li id="eb6a" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><code class="fe mz na nb nc b">alwaysStrict</code>:这将确保<code class="fe mz na nb nc b">use strict</code>在我们所有转换的JavaScript文件中发出，除了编译器。这将提示JavaScript引擎代码应该在<code class="fe mz na nb nc b">strict mode</code>中执行。</li><li id="db7e" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe mz na nb nc b">strictBindCallApply</code>:这将确保我们使用正确的参数调用<code class="fe mz na nb nc b">call</code>、<code class="fe mz na nb nc b">bind</code>和<code class="fe mz na nb nc b">apply</code>函数。让我们看一个例子:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><ul class=""><li id="26da" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><code class="fe mz na nb nc b">strictNullChecks</code>:如果该标志为<code class="fe mz na nb nc b">off</code>，<code class="fe mz na nb nc b">undefined</code>，<code class="fe mz na nb nc b">null</code>和<code class="fe mz na nb nc b">false</code>被编译器忽略。这种松散的类型会在运行时导致意外的错误。让我们看一个例子:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><ul class=""><li id="e345" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><code class="fe mz na nb nc b">strictFunctionTypes</code>:有此标志<code class="fe mz na nb nc b">on</code>可确保更彻底地检查功能参数。</li><li id="3712" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe mz na nb nc b">strictPropertyInitialization</code>:当设置为<code class="fe mz na nb nc b">true</code>时，这将强制我们在构造函数中设置所有的属性值。</li></ul><p id="5677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所见，TypeScript的<code class="fe mz na nb nc b">strict</code>变量是上述所有标志的简写。我们可以通过使用<code class="fe mz na nb nc b">strict</code>全部启用它们，或者逐个渐进地启用它们。</p><p id="8ddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更严格的类型将有助于我们在编译时捕获更多的bug。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7a5a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.重新声明接口</h1><p id="3673" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在对组件接口进行类型化时，通常需要相同类型的不同接口变体。这些可以在一个或两个参数上变化。一个常见的错误是手动重新定义这些变化。这将导致:</p><ul class=""><li id="44a1" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">不必要的样板。</li><li id="2611" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">需要多方面的改变。如果一个属性在一个地方发生了变化，那么这个变化需要传播到许多文件。</li></ul><p id="1d5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很久以前，TypeScript提供了一个功能来解决这个问题:映射类型。它们让我们根据我们定义的一些规则，在现有类型的基础上创建新类型。这确实会产生可读性和声明性更强的代码库。</p><p id="fbad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="86fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们保留了一个真实的来源:实体<code class="fe mz na nb nc b">Book</code>。它的所有变体都使用映射类型特性来表达，这大大减少了对代码进行类型化和维护的需求。</p><p id="b555" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">映射类型也可以应用于联合，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a7ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript附带以下映射类型:<code class="fe mz na nb nc b">Omit</code>、<code class="fe mz na nb nc b">Partial</code>、<code class="fe mz na nb nc b">Readonly</code>、<code class="fe mz na nb nc b">Exclude</code>、<code class="fe mz na nb nc b">Extract</code>、<code class="fe mz na nb nc b">NonNullable</code>、<code class="fe mz na nb nc b">ReturnType</code>。</p><p id="feb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建自己的实用程序，并在我们的代码库中重用它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="55e5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.不依赖于类型推断</h1><p id="5eaf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">TypeScript推理是这种编程语言最强大的工具之一。它为我们做了所有的工作。我们只需要确保所有的部分加在一起，尽可能少的干预。</p><p id="013a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现这一目标的关键操作者是<code class="fe mz na nb nc b">typeof</code>。它是一个类似于JavaScript的操作符。它不是返回JavaScript类型，而是返回TypeScript类型。使用这个操作数可以避免我们重新声明相同的类型。</p><p id="e6e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e25e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，注意<code class="fe mz na nb nc b">result</code>参数类型。靠<code class="fe mz na nb nc b">ReturnType&lt;typeof addNumber&gt;</code>比加<code class="fe mz na nb nc b">number</code>型更可取。通过硬编码<code class="fe mz na nb nc b">number</code>类型，我们正在做编译器的工作。最好使用适当的语法来表达我们的类型。TypeScript将为我们做繁重的工作。</p><p id="1b9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个虚拟的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7eee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe mz na nb nc b">Book</code>接口用于特定的场景，甚至不需要创建接口。</p><p id="ef47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过依赖TypeScript的推理，代码变得不那么杂乱，更易于阅读。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="686d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript甚至有<code class="fe mz na nb nc b">infer</code>操作符，它可以与映射类型结合使用，从另一个类型中提取一个类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1785" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们可以看到如何提取数组的类型。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3c85" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.重载的不正确使用</h1><p id="cc83" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">TypeScript支持本机重载。这很好，因为它可以提高我们合同的可读性。但是，它不同于其他类型化重载语言。</p><p id="a614" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些场景可能会使我们的代码更加复杂和冗长。为了防止这种情况，我们需要记住两条规则:</p><h2 id="32f3" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">1.避免编写仅尾部参数不同的几个重载</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0cc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到两个接口是如何相等的，但是第一个接口比第二个接口更冗长。在这种情况下，最好使用可选参数。</p><h2 id="9b5a" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">2.避免编写只有一种参数类型不同的重载</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像前面的例子一样，第一个接口变得非常冗长。最好使用联合。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3dab" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.使用函数类型</h1><p id="8a56" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">TypeScript附带了<code class="fe mz na nb nc b">Function</code>类型。这就像使用关键字<code class="fe mz na nb nc b">any</code>一样，但只用于函数。遗憾的是，启用<code class="fe mz na nb nc b">strict</code>模式不会阻止我们使用它。</p><p id="a163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面介绍一下<code class="fe mz na nb nc b">Function</code>型:</p><ul class=""><li id="2f4e" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">它接受任意数量和类型的参数。</li><li id="5d73" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">返回类型始终是<code class="fe mz na nb nc b">any</code>。</li></ul><p id="dfea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2615" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，通过使用一个显式的函数定义，我们的回调函数更加易读和类型安全。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2640" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.依靠第三方实现不变性</h1><p id="8615" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当使用函数式编程范式时，TypeScript会有很大的帮助。它提供了所有必要的工具来确保我们不会改变我们的对象。我们不需要在我们的代码库中添加沉重的库，比如ImmutableJS。</p><p id="cfd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过下面的例子来看看我们可以使用的一些工具:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ab28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你从上面的例子中看到的，我们有很多工具来保护我们的对象免于变异。</p><p id="4a79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用内置的特性，我们将保持我们的包轻便，类型一致。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="febf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.不理解推断/从不关键字</h1><p id="e7e5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">infer</code>和<code class="fe mz na nb nc b">never</code>关键字很方便，在许多情况下都有帮助，例如:</p><h2 id="da47" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">暗示</h2><p id="66d4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用<code class="fe mz na nb nc b">infer</code>关键字就像告诉TypeScript，“我想把你推断在这个位置的任何东西赋值给一个新的类型变量。”</p><p id="1eee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0cd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，随着<code class="fe mz na nb nc b">array</code>扩展<code class="fe mz na nb nc b">infer U[]</code>，变量<code class="fe mz na nb nc b">X</code>将等于一个<code class="fe mz na nb nc b">Number</code>。</p><h2 id="1649" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">从不</h2><p id="cc0b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">never</code>类型表示从不出现的值的类型。</p><p id="1a30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3a4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们可以使用<code class="fe mz na nb nc b">never</code>类型来表达我们不希望某个属性可赋值。</p><p id="8f72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于同样的目的，我们可以使用<code class="fe mz na nb nc b">Omit</code>映射类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="469d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，你可以看到它的缺点。它更冗长。如果你检查<code class="fe mz na nb nc b">Omit</code>的内部，它使用<code class="fe mz na nb nc b">Exclude</code>，而<code class="fe mz na nb nc b">Exclude</code>又使用<code class="fe mz na nb nc b">never</code>类型。</p><p id="ba27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依靠<code class="fe mz na nb nc b">infer</code>和<code class="fe mz na nb nc b">never</code>关键字，我们可以省去复制任何类型的麻烦，更好地表达我们的接口。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3dd1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="bcd6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些指南很容易遵循，旨在帮助您接受TypeScript，而不是与之对抗。TypeScript旨在帮助您构建更好的代码，而不是妨碍您。</p><p id="c5fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过应用这些简单的技巧，你将拥有一个更好的、更简洁的、易于维护的代码库。</p><p id="3485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们是否遗漏了在你的项目中经常发生的一些常见错误？请在评论中分享。</p><p id="3836" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干杯。</p><p id="90fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不是中等会员？支持我<a class="ae ky" href="http://dioxmio.medium.com/membership" rel="noopener">成为这里的</a>。</p><h1 id="dba3" class="mc md it bd me mf of mh mi mj og ml mm jz oh ka mo kc oi kd mq kf oj kg ms mt bi translated">有关系的</h1><div class="ok ol gp gr om on"><a rel="noopener  ugc nofollow" target="_blank" href="/top-5-typescript-features-you-should-master-2358db9ab3d5"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">您应该掌握的五大打字稿功能</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">使用这些必须知道的特性来提高您的打字稿知识</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">better编程. pub</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div><div class="ok ol gp gr om on"><a rel="noopener  ugc nofollow" target="_blank" href="/whats-new-in-typescript-4-4-e17d63b84b86"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">TypeScript 4.4有什么新功能？</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">改进的控制流分析、索引签名等等</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">better编程. pub</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb ks on"/></div></div></a></div><div class="ok ol gp gr om on"><a rel="noopener  ugc nofollow" target="_blank" href="/mastering-function-overloading-in-typescript-97108369570a"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">在TypeScript中掌握函数重载</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">使用重载功能创建更全面、更易读的函数类型</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">better编程. pub</p></div></div><div class="ow l"><div class="pd l oy oz pa ow pb ks on"/></div></div></a></div></div></div>    
</body>
</html>