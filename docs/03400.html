<html>
<head>
<title>JavaScript Native Methods You May Not Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您可能不知道的JavaScript本地方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-native-methods-you-may-not-know-ccc4b8aa5cfd?source=collection_archive---------7-----------------------#2020-02-07">https://betterprogramming.pub/javascript-native-methods-you-may-not-know-ccc4b8aa5cfd?source=collection_archive---------7-----------------------#2020-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="006e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JavaScript中强大但经常被忽视的本机方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ad59d473390eac5d51233ab09230f353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v0O86GFV7H15ol_r9xwNPA.jpeg"/></div></div></figure><p id="2c09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">自从ES6发布以来，许多新的、舒适的、方便的本地方法已经被添加到JavaScript的新标准中。</p><p id="07ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我从GitHub仓库中看到了许多旧代码。这并不一定意味着它们不好——但是我将向您介绍的这些特性将有助于您的代码更易读、更漂亮。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="6ee0" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">数字.伊斯南对伊斯南</h1><p id="0992" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated"><code class="fe mu mv mw mx b">NaN</code>是一个数字类型。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="bfa9" class="nc ly it mx b gy nd ne l nf ng">typeof NaN === 'number'</span></pre><p id="8254" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以你分不清<code class="fe mu mv mw mx b">NaN</code>和数字。</p><p id="aca1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">甚至<code class="fe mu mv mw mx b">Object.prototype.toString.call</code>对<code class="fe mu mv mw mx b">NaN</code>和数字都返回<code class="fe mu mv mw mx b">[object Number]</code>。你可能知道有一个<code class="fe mu mv mw mx b">isNaN</code>方法来检查参数是否为<code class="fe mu mv mw mx b">NaN</code>。但是从ES6开始，<code class="fe mu mv mw mx b">number</code>构造函数开始包含<code class="fe mu mv mw mx b">isNaN</code>作为它的方法。那有什么不同？</p><ul class=""><li id="61e3" class="nh ni it kw b kx ky la lb ld nj lh nk ll nl lp nm nn no np bi translated"><code class="fe mu mv mw mx b">isNaN</code> —检查传递的值是否不是数字或不能转换成数字。</li><li id="8ff2" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated"><code class="fe mu mv mw mx b">Number.isNaN</code> —检查传递的值是否不是数字。</li></ul><p id="ff6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是例子。而且这个话题已经被<a class="ae nv" href="https://stackoverflow.com/questions/33164725/confusion-between-isnan-and-number-isnan-in-javascript" rel="noopener ugc nofollow" target="_blank">栈溢出</a>的人处理过了。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="2787" class="nc ly it mx b gy nd ne l nf ng">Number.isNaN({});<br/>// &lt;- false, {} is not NaN<br/>Number.isNaN('ponyfoo')<br/>// &lt;- false, 'ponyfoo' is not NaN<br/>Number.isNaN(NaN)<br/>// &lt;- true, NaN is NaN<br/>Number.isNaN('pony'/'foo')<br/>// &lt;- true, 'pony'/'foo' is NaN, NaN is NaN<br/><br/>isNaN({});<br/>// &lt;- true, {} is not a number<br/>isNaN('ponyfoo')<br/>// &lt;- true, 'ponyfoo' is not a number<br/>isNaN(NaN)<br/>// &lt;- true, NaN is not a number<br/>isNaN('pony'/'foo')<br/>// &lt;- true, 'pony'/'foo' is NaN, NaN is not a number</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="e5f8" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">number . is有限与is有限</h1><p id="31a8" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">在JavaScript中，像1/0这样的计算不会产生错误。而是给你<code class="fe mu mv mw mx b">Infinit</code>，这是一个全局属性。</p><p id="6e2e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，如何检查一个值是否是无穷大的值呢？你不能。但是你可以用<code class="fe mu mv mw mx b">isFinite</code>和<code class="fe mu mv mw mx b">Number.isFinite</code>来检查一个值是否是有限值。</p><p id="a8b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基本上它们的工作原理是一样的，但是它们彼此之间略有不同。</p><ul class=""><li id="3ff6" class="nh ni it kw b kx ky la lb ld nj lh nk ll nl lp nm nn no np bi translated"><code class="fe mu mv mw mx b">isFinite</code> —检查传递的值是否有限。如果类型不是<code class="fe mu mv mw mx b">Number</code>，则传递的值被转换为<code class="fe mu mv mw mx b">Number</code>。</li><li id="401e" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated"><code class="fe mu mv mw mx b">Number.isFinite</code> —检查传递的值是否有限。传递的值不会转换成<code class="fe mu mv mw mx b">Number</code>。</li></ul><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="82a7" class="nc ly it mx b gy nd ne l nf ng">Number.isFinite(Infinity) // false<br/>isFinite(Infinity) // false</span><span id="8b05" class="nc ly it mx b gy nw ne l nf ng">Number.isFinite(NaN) // false<br/>isFinite(NaN) // false</span><span id="5d33" class="nc ly it mx b gy nw ne l nf ng">Number.isFinite(2e64) // true<br/>isFinite(2e64) // true</span><span id="5267" class="nc ly it mx b gy nw ne l nf ng">Number.isFinite(undefined) // false<br/>isFinite(undefined) // false</span><span id="cb4b" class="nc ly it mx b gy nw ne l nf ng">Number.isFinite(null) // false<br/>isFinite(null) // true</span><span id="d2ce" class="nc ly it mx b gy nw ne l nf ng">Number.isFinite('0') // false<br/>isFinite('0') // true</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="d4e1" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">Math.floor vs. Math.trunc</h1><p id="dccc" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">在过去，当你需要取出一个数值的点右边的数字时，你可能会使用<code class="fe mu mv mw mx b">Math.floor</code>。但是从现在开始，如果你真正想要的只是整数部分，尽量使用<code class="fe mu mv mw mx b">Math.trunc</code>。</p><ul class=""><li id="51e8" class="nh ni it kw b kx ky la lb ld nj lh nk ll nl lp nm nn no np bi translated"><code class="fe mu mv mw mx b">Math.floor</code> —返回小于或等于给定数字的最大整数。</li><li id="0236" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated"><code class="fe mu mv mw mx b">Math.trunc</code> —截断点及其右侧的数字。</li></ul><p id="e956" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基本上，如果给定的数是正数，它们会给出完全相同的结果。但是如果给定的数字是负数，结果就不同了。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="2a24" class="nc ly it mx b gy nd ne l nf ng">Math.floor(1.23) // 1<br/>Math.trunc(1.23) // 1</span><span id="a756" class="nc ly it mx b gy nw ne l nf ng">Math.floor(-5.3) // -6<br/>Math.trunc(-5.3) // -5</span><span id="bc4a" class="nc ly it mx b gy nw ne l nf ng">Math.floor(-0.1) // -1<br/>Math.trunc(-0.1) // -0</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="2d9a" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">array . prototype . index of vs . array . prototype . includes</h1><p id="8906" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">当你在一个给定的数组中寻找某个值时，你如何找到它？我见过很多开发者使用<code class="fe mu mv mw mx b">Array.prototype.indexOf</code>，就像下面这个例子。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="7750" class="nc ly it mx b gy nd ne l nf ng">const arr = [1, 2, 3, 4];</span><span id="4f97" class="nc ly it mx b gy nw ne l nf ng">if (arr.indexOf(1) &gt; -1) {<br/>  ...<br/>}</span></pre><ul class=""><li id="0909" class="nh ni it kw b kx ky la lb ld nj lh nk ll nl lp nm nn no np bi translated"><code class="fe mu mv mw mx b">Array.prototype.indexOf</code> —返回给定元素在数组中的第一个索引，如果不存在则返回<code class="fe mu mv mw mx b">-1</code></li><li id="1631" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated"><code class="fe mu mv mw mx b">Array.prototype.includes </code> —检查给定数组是否包含您要查找的特定值，并返回结果<code class="fe mu mv mw mx b">true</code> / <code class="fe mu mv mw mx b">false</code></li></ul><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="11db" class="nc ly it mx b gy nd ne l nf ng">const students = ['Hong', 'James', 'Mark', 'James'];</span><span id="1c8e" class="nc ly it mx b gy nw ne l nf ng">students.indexOf('Mark') // 1<br/>students.includes('James') // true</span><span id="04ec" class="nc ly it mx b gy nw ne l nf ng">students.indexOf('Sam') // -1<br/>students.includes('Sam') // false</span></pre><p id="5189" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">小心点。由于Unicode的差异，传递的值区分大小写。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="12f6" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">String.prototype.repeat与手动for循环</h1><p id="f20a" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">在添加这个特性之前，您制作字符串的方式，比如<code class="fe mu mv mw mx b">abcabcabc</code>，是复制字符串，然后将它们连接成一个空字符串，连接次数不限。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="f642" class="nc ly it mx b gy nd ne l nf ng">var str = 'abc';<br/>var res = '';</span><span id="99e0" class="nc ly it mx b gy nw ne l nf ng">var copyTimes = 3;</span><span id="56f5" class="nc ly it mx b gy nw ne l nf ng">for (var i = 0; i &lt; copyTimes; i += 1) {<br/>  for (var j = 0; j &lt; str.length; j += 1) {<br/>    res += str[j];<br/>  }<br/>}</span></pre><p id="b54a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是这本书太长了，很乱，有时很难读懂。为此，可以使用<code class="fe mu mv mw mx b">String.prototype.repeat</code>。你所需要做的就是传递一个数字，这个数字表示你想要复制字符串的次数。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="a379" class="nc ly it mx b gy nd ne l nf ng">'abc'.repeat(3) // "abcabcabc"<br/>'hi '.repeat(2) // "hi hi "</span><span id="3ee9" class="nc ly it mx b gy nw ne l nf ng">'empty'.repeat(0) // ""<br/>'empty'.repeat(null) // ""<br/>'empty'.repeat(undefined) // ""<br/>'empty'.repeat(NaN) // ""</span><span id="0ce8" class="nc ly it mx b gy nw ne l nf ng">'error'.repeat(-1) // RangeError<br/>'error'.repeat(Infinity) // RangeError</span></pre><p id="1766" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">传递的值不能是负数，必须小于无穷大，并且不能超过溢出的最大字符串大小。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="94b6" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">String.prototype.match与String.prototype.includes</h1><p id="7e5d" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">要检查字符串中是否包含某些单词，有两种方法可以完成— <code class="fe mu mv mw mx b">match</code>和<code class="fe mu mv mw mx b">includes</code>。</p><ul class=""><li id="2780" class="nh ni it kw b kx ky la lb ld nj lh nk ll nl lp nm nn no np bi translated"><code class="fe mu mv mw mx b">String.prototype.match</code> —采用RegExp类型的参数。RegExp中支持的所有标志都可以使用。</li><li id="4423" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated"><code class="fe mu mv mw mx b">String.prototype.includes</code> —取两个参数，<code class="fe mu mv mw mx b">searchString</code>为第一个参数，<code class="fe mu mv mw mx b">position</code>为第二个参数。如果<code class="fe mu mv mw mx b">position</code>没有通过，将使用默认值<code class="fe mu mv mw mx b">0</code>。</li></ul><p id="c7b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">区别在于<code class="fe mu mv mw mx b">includes</code>区分大小写，而<code class="fe mu mv mw mx b">match</code>不区分大小写。您可以将<code class="fe mu mv mw mx b">i</code>标志放在RegExp中，使其不区分大小写。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="e0b6" class="nc ly it mx b gy nd ne l nf ng">const name = 'jane';<br/>const nameReg = /jane/i;</span><span id="e596" class="nc ly it mx b gy nw ne l nf ng">const str = 'Jane is a student';</span><span id="71a3" class="nc ly it mx b gy nw ne l nf ng">str.includes(name) // false<br/>str.match(nameReg) <br/>// ["Jane", index: 0, input: "Jane is a student", groups: undefined]</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="b374" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">String.prototype.concat与String.prototype.padStart</h1><p id="3aff" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated"><code class="fe mu mv mw mx b">padStart</code>当你想在一些字符串的开头追加一些字符串的时候是一个强大的方法。</p><p id="7315" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另外，<code class="fe mu mv mw mx b">concat</code>也可以很好地完成这个任务。但是主要的区别是<code class="fe mu mv mw mx b">padStart</code>重复将从结果字符串的第一个索引填充到当前字符串的第一个索引的字符串。</p><p id="8610" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我会告诉你如何使用这个功能。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="8716" class="nc ly it mx b gy nd ne l nf ng">const rep = 'abc';<br/>const str = 'xyz';</span></pre><p id="370e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有两根弦。我想做的是把<code class="fe mu mv mw mx b">rep</code>加在<code class="fe mu mv mw mx b">xyz </code>前面——但不只是一次。我想让它重复几次。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="2fbb" class="nc ly it mx b gy nd ne l nf ng">str.padStart(10, rep);</span></pre><p id="f803" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">padStart</code>有两个参数——新创建的结果字符串和将要重复的字符串的总长度。理解这个函数最简单的方法就是用空格写下字母。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="4b8d" class="nc ly it mx b gy nd ne l nf ng">// create empty 10 blanks<br/>1) _ _ _ _ _ _ _ _ _ _ </span><span id="c46f" class="nc ly it mx b gy nw ne l nf ng">// fill out 'xyz' in str<br/>2) _ _ _ _ _ _ _ x y z</span><span id="e5ea" class="nc ly it mx b gy nw ne l nf ng">// repeat 'abc' in rep, <br/>// up until the first letter of 'xyz' appears<br/>3) a b c a b c a x y z</span><span id="4735" class="nc ly it mx b gy nw ne l nf ng">// the result will be<br/>4) abcabcxyz</span></pre><p id="a3a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个函数对这个特性非常有用，用<code class="fe mu mv mw mx b">concat</code>肯定很难做到这一点，它也执行一个字符串追加。</p><p id="1442" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">padEnd</code>从位置的末端开始。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="e9d3" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">结论</h1><p id="f196" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">JavaScript中有许多有趣且有用的方法，但并不常见。但这并不意味着它们毫无用处。如何在各种情况下使用它们完全取决于你。</p><h2 id="783c" class="nc ly it bd lz nx ny dn md nz oa dp mh ld ob oc mj lh od oe ml ll of og mn oh bi translated">资源</h2><ul class=""><li id="a761" class="nh ni it kw b kx mp la mq ld oi lh oj ll ok lp nm nn no np bi translated"><a class="ae nv" href="https://stackoverflow.com/questions/33164725/confusion-between-isnan-and-number-isnan-in-javascript" rel="noopener ugc nofollow" target="_blank">JavaScript中的isNaN和Number.isNaN混淆</a></li><li id="0969" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae nv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite" rel="noopener ugc nofollow" target="_blank"> Number.isFinite — MDN </a></li><li id="444d" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae nv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite" rel="noopener ugc nofollow" target="_blank"> isFinite — MDN </a></li><li id="0205" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae nv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc" rel="noopener ugc nofollow" target="_blank"> Math.trunc — MDN </a></li><li id="0a72" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae nv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor" rel="noopener ugc nofollow" target="_blank"> Math.floor — MDN </a></li><li id="5015" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae nv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" rel="noopener ugc nofollow" target="_blank">array . prototype . index of—MDN</a></li><li id="dd43" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae nv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" rel="noopener ugc nofollow" target="_blank">array . prototype . includes—MDN</a></li><li id="d5d4" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae nv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat" rel="noopener ugc nofollow" target="_blank">string . prototype . repeat—MDN</a></li><li id="d50c" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae nv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match" rel="noopener ugc nofollow" target="_blank">string . prototype . math—MDN</a></li><li id="fb3b" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae nv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes" rel="noopener ugc nofollow" target="_blank">string . prototype . includes—MDN</a></li><li id="2a3b" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated"><a class="ae nv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart" rel="noopener ugc nofollow" target="_blank">string . prototype . pad start—MDN</a></li></ul></div></div>    
</body>
</html>