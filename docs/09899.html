<html>
<head>
<title>Running Ghost in a Multi-Region Google Kubernetes Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在多区域Google Kubernetes引擎中运行Ghost</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/running-ghost-in-a-multi-region-google-kubernetes-engine-db9de8ba784e?source=collection_archive---------6-----------------------#2021-10-27">https://betterprogramming.pub/running-ghost-in-a-multi-region-google-kubernetes-engine-db9de8ba784e?source=collection_archive---------6-----------------------#2021-10-27</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="9e89" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">全球部署应用程序</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/cb66f427dda0a282ad425fba977eb702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8LrEdbBO_mhDxEx0"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">本·怀特在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="0c70" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">最初我计划使用我的“Hello World”应用程序，但我认为是时候使用现实世界的应用程序了。我的灵感来自于另一位媒体作家<a class="ae kw" href="https://medium.com/@george.af.field" rel="noopener">乔治·菲尔德</a>和他的“<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/10-side-hustles-to-make-extra-money-as-a-software-engineer-a290e66c7ce9">10 Side Hustles to Make Extra dose As a Software Engineer</a>”文章。</p><p id="2c63" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">他提到<a class="ae kw" href="https://ghost.org/" rel="noopener ugc nofollow" target="_blank">Ghost</a>——一个为内容创作者提供的博客内容管理系统——作为一个额外赚钱的工具。幸运的是，Ghost团队有一个公开的Ghost Docker映像<a class="ae kw" href="https://hub.docker.com/_/ghost" rel="noopener ugc nofollow" target="_blank">，我们可以在这次演示中使用它。</a></p><p id="0d6f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">TL；博士？检查<a class="ae kw" href="https://github.com/Escoto/GKE-Ghost-Deployment" rel="noopener ugc nofollow" target="_blank">我的GitHub repo </a>的完整脚本。</p><p id="0abc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这是我关于容器的系列博客的继续。点击这里查看之前的博客:</p><ul class=""><li id="9f3e" class="lt lu ir kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated"><a class="ae kw" href="https://medium.com/codex/kubernetes-and-terraform-in-google-cloud-3fc9e1c81e0" rel="noopener">Google Cloud中的Kubernetes引擎和Terraform</a></li><li id="f54b" class="lt lu ir kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated"><a class="ae kw" href="https://medium.com/codex/kubernetes-in-google-cloud-f27bb8cc6603" rel="noopener">谷歌云中的Kubernetes</a></li><li id="57ed" class="lt lu ir kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated"><a class="ae kw" href="https://medium.com/codex/containerizing-your-application-b1644385e2ef" rel="noopener">将您的第一个应用程序容器化</a></li></ul></div><div class="ab cl mh mi hv mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ik il im in io"><h1 id="b2c8" class="mo mp ir bd mq mr ms mt mu mv mw mx my jx mz jy na ka nb kb nc kd nd ke ne nf bi translated">要求</h1><ul class=""><li id="e760" class="lt lu ir kz b la ng ld nh lg ni lk nj lo nk ls ly lz ma mb bi translated">一个<a class="ae kw" href="https://cloud.google.com/resource-manager/docs/creating-managing-projects#creating_a_project" rel="noopener ugc nofollow" target="_blank"> GCP项目</a></li><li id="b4df" class="lt lu ir kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">启用所需的API</li><li id="01a2" class="lt lu ir kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">在你的本地机器上安装谷歌SDK</li><li id="909c" class="lt lu ir kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">安装<a class="ae kw" href="https://learn.hashicorp.com/tutorials/terraform/install-cli" rel="noopener ugc nofollow" target="_blank">地形</a></li></ul><blockquote class="nl nm nn"><p id="c057" class="kx ky no kz b la lb js lc ld le jv lf np lh li lj nq ll lm ln nr lp lq lr ls ik bi translated">如果用Google的云壳SDK，Terraform开箱即用！！</p></blockquote><h1 id="08eb" class="mo mp ir bd mq mr ns mt mu mv nt mx my jx nu jy na ka nv kb nc kd nw ke ne nf bi translated">未来的任务</h1><p id="894b" class="pw-post-body-paragraph kx ky ir kz b la ng js lc ld nh jv lf lg nx li lj lk ny lm ln lo nz lq lr ls ik bi translated">我们面临的任务是探索在多个地区运行我们的应用程序的可能性。如果我们已经以<code class="fe oa ob oc od b">regional</code>的身份运行集群(正如我在上一篇文章中所做的)，那么应用程序已经部署在多个区域中。但是，地震和龙卷风会同时摧毁所有这些区域吗？大多数<em class="no">可能不是</em>，但客户的延迟至少会得到改善。</p><p id="ab37" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">有人提议在多个地区托管应用程序有多种原因，但现在我们想把重点放在有趣的部分——完成它。</p><h1 id="d89a" class="mo mp ir bd mq mr ns mt mu mv nt mx my jx nu jy na ka nv kb nc kd nw ke ne nf bi translated">可能吗？—是的！</h1><p id="9d27" class="pw-post-body-paragraph kx ky ir kz b la ng js lc ld nh jv lf lg nx li lj lk ny lm ln lo nz lq lr ls ik bi translated">为了更容易理解，您可以从</p><pre class="kh ki kj kk gu oe od of og aw oh bi"><span id="9ec9" class="oi mp ir od b gz oj ok l ol om">$&gt; git clone <a class="ae kw" href="https://github.com/Escoto/GKE-Ghost-Deployment.git" rel="noopener ugc nofollow" target="_blank">https://github.com/Escoto/GKE-Ghost-Deployment.git</a><br/>$&gt; cd Deployment/</span></pre><p id="8298" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这是我们今天的目标。此图描述了同一个VPC中的两个GKE集群，它们通过外部全局负载平衡器对外公开。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj on"><img src="../Images/10f17a14e3c2045daa5893bad092fdd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CAJwTPvvyuLW1YB_iyUrdg.png"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">由<a class="ae kw" href="https://medium.com/@raescoto" rel="noopener">作者</a>使用<a class="ae kw" href="https://www.gliffy.com/" rel="noopener ugc nofollow" target="_blank"> Gliffy </a></p></figure><p id="db74" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在，这张图片总结了需求并隐藏了所有的复杂性。实际上，完成这项工作并不像看起来那么简单，至少与区域性的GKE相比是如此。</p><p id="dae8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当创建区域GKE时，<a class="ae kw" href="https://registry.terraform.io/providers/hashicorp/kubernetes/latest/docs" rel="noopener ugc nofollow" target="_blank">Terraform Kubernetes Provider</a>是一个魅力所在，它负责创建负载平衡器并向世界公开您的服务，而您甚至不会注意到这一切正在发生。</p><p id="defe" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">与此同时，当您想要将您的应用程序部署到多个GKE集群时，一个GKE不能是负载平衡器的唯一所有者。负载均衡器必须在不同的实例之间“共享”,因此文件略有变化，它不再是GKE声明的LB，LB现在是一个独立的服务，您必须将每个GKE集群注册为后端服务。</p><h1 id="8eaa" class="mo mp ir bd mq mr ns mt mu mv nt mx my jx nu jy na ka nv kb nc kd nw ke ne nf bi translated">怎么会？！</h1><blockquote class="nl nm nn"><p id="8005" class="kx ky no kz b la lb js lc ld le jv lf np lh li lj nq ll lm ln nr lp lq lr ls ik bi translated">请记住，这只是一个例子，我并没有严格遵循Terraform的最佳实践，这也不是一个生产就绪的解决方案。相反，为了这个实验，我们专注于完成它。</p></blockquote><p id="2bf1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在我以前的博客中，我用一个区域中的每个区域做了一个区域聚类。让我们迭代这个解决方案，首先创建一些<a class="ae kw" href="https://learn.hashicorp.com/tutorials/terraform/module" rel="noopener ugc nofollow" target="_blank"> Terraform模块</a>，一个用于Kubernetes服务，一个用于Kubernetes集群；这些模块将允许我们通过简单地传递变量在不同的区域创建多个一致的集群。</p><p id="dd36" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在这一点上，我的目录看起来像这样，并且在整个练习中它将保持这样。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj oo"><img src="../Images/88b67f7774df7cb390d23db660153d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*Vq6LLwkuLpSPhMx27oCPow.png"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">创建两个模块</p></figure><p id="77f3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">网络资源可能是创建新模块的一个原因，但现在让我们将它们保留在这里。如图所示，我们需要一个VPC和两个子网络，每个区域一个子网；对于这个例子，我选择德国和芬兰。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="op oq l"/></div></figure><p id="64ae" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如你所见，我使用了几个局部变量，如果你想看到它们的完整声明，请看看<a class="ae kw" href="https://github.com/Escoto/GKE-Ghost-Deployment/blob/main/Deployment/main.tf" rel="noopener ugc nofollow" target="_blank">回购</a>。</p><p id="219d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">有了网络，我们现在可以看看将利用它们的集群模块。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="op oq l"/></div></figure><p id="c8ee" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果你注意这个集群的声明，我们提供了<em class="no">区域</em>作为<code class="fe oa ob oc od b">location</code>，这反过来使它成为区域性的。基本上，这意味着它将在每个区域上创建一个实例组，然后我们必须在负载平衡器上注册该实例组，以便可以向它们发送流量。</p><p id="240d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这个过程要求我们打开我们的Kubernetes服务将通过一个名为<a class="ae kw" href="https://cloud.google.com/sdk/gcloud/reference/compute/instance-groups/get-named-ports" rel="noopener ugc nofollow" target="_blank">的端口</a>使用的端口。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="op oq l"/></div></figure><p id="a931" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在这里，我将演示如何打开一个端口，如果你看到了完整的脚本，你会注意到我是如何为每个实例组打开端口的。这不是非常可扩展的，因为用一句话来说有点“硬编码”,并且将我们锁定在只有三个区域的区域。目前，这足以让我们的练习继续进行。</p><p id="4556" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">该模块就绪后，我们可以返回主脚本，开始创建区域集群，它们的端口<code class="fe oa ob oc od b">30000</code>将为我们打开。现在我们只想要两个，每个地区一个。这将产生六个实例组，每个区域的每个区域一个。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="op oq l"/></div></figure><p id="d76c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">服务器就位后，我们可以创建一个负载平衡器来在它们之间分配连接。</p><p id="92d1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在使用单个集群时，Kubernetes为我们隐藏了这部分基础设施的配置，但在这种情况下，我们需要自己进行设置。</p><p id="c663" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">重要的是要注意</p><ul class=""><li id="8b4c" class="lt lu ir kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated"><a class="ae kw" href="https://cloud.google.com/vpc/docs/add-remove-network-tags" rel="noopener ugc nofollow" target="_blank">网络标签</a></li><li id="6074" class="lt lu ir kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">指定港口<code class="fe oa ob oc od b">http:30000</code></li><li id="dc55" class="lt lu ir kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">添加VPC</li></ul><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="op oq l"/></div></figure><p id="ec1a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">此时，我们有了一个运行应用程序的地方，以及一个负责分发工作的服务。现在让我们配置一个Kubernetes服务，它将把我们的应用程序暴露给我们之前为实例组配置的同一个开放端口。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="op oq l"/></div></figure><p id="432a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">长话短说，我给你们展示的是库伯内特斯<code class="fe oa ob oc od b">Service</code>而不是<code class="fe oa ob oc od b">Deployment</code>，你们可以在这里找到<a class="ae kw" href="https://github.com/Escoto/GKE-Ghost-Deployment/blob/main/Deployment/ghost_module/main.tf" rel="noopener ugc nofollow" target="_blank"/>。这里我将重点放在服务上，因为它负责公开我们的应用程序。在部署中有一些棘手的事情需要配置，但这些都是Ghost特有的，你可以在<a class="ae kw" href="https://ghost.org/docs/config/#running-ghost-with-config-env-variables" rel="noopener ugc nofollow" target="_blank">的文档</a>中找到它们。</p><p id="78db" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">此时，这个练习开始变得有趣了。在我以前的文章中，我在同一个文件中有Kubernetes Provider+Deployment+Service。如果你想把它变成一个模块，你不能，你必须把提供者和实现分开。我实际上花了很多时间来处理这个问题，直到我终于找到了<a class="ae kw" href="https://medium.com/@paveltuzov" rel="noopener"> Pavel Tuzov </a>在这里解释我的问题"<a class="ae kw" href="https://itnext.io/terraform-dont-use-kubernetes-provider-with-your-cluster-resource-d8ec5319d14a" rel="noopener ugc nofollow" target="_blank"> Terraform:不要将Kubernetes provider用于您的集群资源！</a>”。</p><p id="6285" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">因此，回到主脚本，我们需要声明两个别名提供者——每个集群上的每个部署一个。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="op oq l"/></div></figure><p id="78b7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">最后，提供者就位后，我们现在可以继续配置我们的应用程序部署。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="op oq l"/></div></figure><p id="dbea" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们现在可以运行我们都喜欢的命令了</p><pre class="kh ki kj kk gu oe od of og aw oh bi"><span id="5b6d" class="oi mp ir od b gz oj ok l ol om">$&gt; terraform init<br/>$&gt; terraform plan<br/>$&gt; terraform apply</span></pre><p id="370a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果你使用我的脚本，在计划之后，你应该得到类似这样的东西:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj or"><img src="../Images/e8aaf0d219b5fc8254746721b0531588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*P_xXKZ3gewSdGg7F7NTa3Q.png"/></div></figure><p id="5464" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">然后:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj os"><img src="../Images/7f730ceeac1677373bb9e755bb1366ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9wC2E_prw90SrvGsldYT6A.png"/></div></div></figure><p id="7cc0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">一旦terraform完成创建所有服务，我们必须等待大约3分钟，以便所有服务完成预热。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ot"><img src="../Images/f7e403ea64b0b7a2c8012cdf0cbff855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nCUJ9mGiLugxHurDMlf_Ow.png"/></div></div></figure><p id="d585" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">别忘了清理你的环境，这种跑步几分钟并不贵，大概就几毛钱，但是如果你一个月都忘了这个…</p><pre class="kh ki kj kk gu oe od of og aw oh bi"><span id="f9c9" class="oi mp ir od b gz oj ok l ol om">$&gt; terraform destroy</span></pre></div><div class="ab cl mh mi hv mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ik il im in io"><p id="f8b9" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">既然我们可以在全球范围内部署我们的应用程序，我们的任务就完成了。</p><p id="eb59" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们现在可以去喝杯咖啡了！</p></div></div>    
</body>
</html>