<html>
<head>
<title>Docker Tips : about /var/run/docker.sock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker提示:about /var/run/docker.sock</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/about-var-run-docker-sock-3bfd276e12fd?source=collection_archive---------1-----------------------#2017-04-09">https://betterprogramming.pub/about-var-run-docker-sock-3bfd276e12fd?source=collection_archive---------1-----------------------#2017-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fe4c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从容器内与Docker守护进程通信</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e745234a2c25f8d55810feb7d6c0c23b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bKtsM045UOnZcU2QVqcAmg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片修改自<a class="ae ky" href="http://blog.honeybadger.io/how-unicorn-talks-to-nginx-an-introduction-to-unix-sockets-in-ruby/" rel="noopener ugc nofollow" target="_blank">http://blog . honey badger . io</a></p></figure><p id="948d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经从Docker Hub运行过容器，并注意到其中一些容器需要绑定挂载<code class="fe lv lw lx ly b">/var/run/docker.sock</code>文件。这个文件是什么，为什么它有时被容器使用？简而言之:它是Docker守护进程默认监听的Unix套接字，可以用来从容器内部与守护进程通信。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="c221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑一下<a class="ae ky" href="http://portainer.io/" rel="noopener ugc nofollow" target="_blank"> Portainer </a>，一个用于管理Docker主机或Swarm集群的开源管理接口。如果用来管理本地Docker主机Portainer可以用下面的命令运行，绑定挂载主机的Docker的Unix套接字。</p><pre class="kj kk kl km gt mg ly mh mi aw mj bi"><span id="19b8" class="mk ml it ly b gy mm mn l mo mp">$ docker container run -d \<br/>  -p 9000:9000 \<br/>  -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer</span></pre><p id="02d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该界面在端口9000上可用，并允许您管理容器、映像、卷等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/e49f3155d8f0a9a89dee2fa4f051f009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6VM4HeijCSGm3JxzbsFfdQ.png"/></div></div></figure><p id="8599" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完成所有这些管理操作，Portainer通过绑定挂载访问的<code class="fe lv lw lx ly b">/var/run/docker.sock</code>文件与本地Docker守护进程通信。</p><h1 id="a26f" class="mr ml it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak"> Docker守护程序API </strong></h1><p id="7f4f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当Docker平台安装在主机上时，Docker守护进程默认监听<code class="fe lv lw lx ly b">/var/run/docker.sock</code> Unix套接字。这可以从提供给守护进程的选项中看出；它应包含以下条目:</p><p id="0723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">-H unix:///var/run/docker.sock</code></p><blockquote class="nn no np"><p id="c664" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated">注意:可以为守护进程提供额外的<em class="it"> -H </em>选项，这样它也可以监听tcp主机/端口或其他unix套接字。</p></blockquote><p id="88ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://docs.docker.com/engine/api/v1.27" rel="noopener ugc nofollow" target="_blank"> Docker engine API v1.27 </a>(最新版本)中定义的所有HTTP端点都可以通过这个unix套接字使用。</p><h1 id="a796" class="mr ml it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">容器创建</strong></h1><p id="a1da" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">使用Portainer UI，我们可以轻松地运行容器。在幕后，HTTP请求通过<code class="fe lv lw lx ly b">docker.sock</code>被发送到Docker守护进程。让我们用<a class="ae ky" href="https://curl.haxx.se/" rel="noopener ugc nofollow" target="_blank"> <em class="nq"> curl </em> </a> <em class="nq">来说明这一点并创建一个NGINX容器。</em></p><blockquote class="nn no np"><p id="379c" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated">注意:使用HTTP API时，运行容器需要2个步骤:首先需要创建容器，然后才能启动它。</p></blockquote><h2 id="58cf" class="mk ml it bd ms nu nv dn mw nw nx dp na li ny nz nc lm oa ob ne lq oc od ng oe bi translated"><em class="of">创建一个NGINX容器</em></h2><p id="c9fb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">下面的命令使用curl通过unix套接字将<code class="fe lv lw lx ly b"><em class="nq">{“Image”:”nginx”}</em></code>有效负载发送到Docker守护进程的<code class="fe lv lw lx ly b"><em class="nq">/containers/create</em></code>端点。这将创建一个基于NGINX的容器，并返回其ID。</p><pre class="kj kk kl km gt mg ly mh mi aw mj bi"><span id="c56e" class="mk ml it ly b gy mm mn l mo mp">$ curl -XPOST --unix-socket /var/run/docker.sock -d '{"Image":"nginx"}' -H 'Content-Type: application/json' <a class="ae ky" href="http://localhost/containers/create" rel="noopener ugc nofollow" target="_blank">http://localhost/containers/create</a></span><span id="a1f8" class="mk ml it ly b gy og mn l mo mp">{"Id":"fcb65c6147efb862d5ea3a2ef20e793c52f0fafa3eb04e4292cb4784c5777d65","Warnings":null}</span></pre><h2 id="17f9" class="mk ml it bd ms nu nv dn mw nw nx dp na li ny nz nc lm oa ob ne lq oc od ng oe bi translated"><em class="of">启动容器</em></h2><p id="80f6" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">使用上面提供的ID，我们可以定位<code class="fe lv lw lx ly b"><em class="nq">/containers/&lt;ID&gt;/start</em></code>端点来启动新创建的容器。</p><pre class="kj kk kl km gt mg ly mh mi aw mj bi"><span id="14b3" class="mk ml it ly b gy mm mn l mo mp">$ curl -XPOST --unix-socket /var/run/docker.sock <a class="ae ky" href="http://localhost/containers/fcb65c6147efb862d5ea3a2ef20e793c52f0fafa3eb04e4292cb4784c5777d65/start" rel="noopener ugc nofollow" target="_blank">http://localhost/containers/fcb6...7d65/start</a></span></pre><p id="09e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以验证nginx容器已经启动并正在运行。</p><pre class="kj kk kl km gt mg ly mh mi aw mj bi"><span id="6720" class="mk ml it ly b gy mm mn l mo mp">$ docker container ls<br/>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES<br/>fcb65c6147ef nginx “nginx -g ‘daemon …” 5 minutes ago Up 5 seconds 80/tcp, 443/tcp ecstatic_kirch<br/>...</span></pre><p id="57a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这说明了如何使用Docker插座从容器内容易地在罩后创建容器。显然，不会使用curl来创建容器，但是您已经明白了。</p><h1 id="58c5" class="mr ml it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">来自Docker守护进程的流事件</strong></h1><p id="152d" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Docker API还公开了<code class="fe lv lw lx ly b"><em class="nq">/events</em></code>端点，可以用来获取守护进程生成的所有事件的流。例如，负载平衡器可以使用它来获取容器的创建或删除事件，这样它就可以动态地更新其配置。</p><p id="0109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们运行一个简单的容器，并检查如何使用Docker守护进程事件。</p><h1 id="2656" class="mr ml it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><em class="of">运行阿尔卑斯山集装箱</em></h1><p id="1de7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">以下命令以交互模式运行Alpine容器，并绑定挂载<code class="fe lv lw lx ly b">docker.sock</code>。</p><p id="74ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">$ docker run -v /var/run/docker.sock:/var/run/docker.sock -ti alpine sh</code></p><h2 id="c6ca" class="mk ml it bd ms nu nv dn mw nw nx dp na li ny nz nc lm oa ob ne lq oc od ng oe bi translated"><em class="of">监听来自Docker守护进程的事件</em></h2><p id="9bbf" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">从Alpine容器中，我们首先使用apk包管理器安装<strong class="lb iu"> curl </strong>实用程序。</p><p id="54ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"># apk update &amp;&amp; apk add curl</code></p><p id="8a99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以通过Docker套接字向<code class="fe lv lw lx ly b"><em class="nq">/events</em></code>端点发送HTTP请求。该命令挂起，等待来自守护进程的新事件。每个新事件都将从守护进程中流出。</p><p id="c263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">$ curl --unix-socket /var/run/docker.sock http://localhost/events</code></p><h1 id="bec2" class="mr ml it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><em class="of">观察事件</em></h1><p id="8030" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">然后，我们基于NGINX映像创建一个新容器，并通过Alpine容器标准输出来观察Docker守护进程生成的事件。</p><p id="5f8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">$ docker container run -p 8080:80 -d nginx</code></p><p id="e473" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以观察到前一个请求接收了几个事件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="9369" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，发生了三件事:</p><ul class=""><li id="10b2" class="oj ok it lb b lc ld lf lg li ol lm om lq on lu oo op oq or bi translated">容器的创建</li><li id="10a7" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu oo op oq or bi translated">到默认桥接网络的连接</li><li id="8d8b" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu oo op oq or bi translated">容器的起点</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e1fb" class="mr ml it bd ms mt ox mv mw mx oy mz na jz oz ka nc kc pa kd ne kf pb kg ng nh bi translated"><strong class="ak">总结</strong></h1><p id="9d2e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我希望这个简短的解释能让你更好地理解<code class="fe lv lw lx ly b">/var/run/docker.sock</code>文件，以及当bind装入容器时如何使用它。显然，使用这个套接字的应用程序不会使用curl，而是使用专用的库来向守护进程发送HTTP请求。</p><p id="d0d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:绑定安装Docker守护进程套接字赋予容器很大的权力，因为它可以控制守护进程。必须小心使用，并且只能使用我们可以信任的容器。</p></div></div>    
</body>
</html>