<html>
<head>
<title>How to Scrape Modern Websites Without Headless Browsers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在没有无头浏览器的情况下抓取现代网站</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-scrape-modern-websites-without-headless-browsers-d871bbd1119e?source=collection_archive---------1-----------------------#2021-01-05">https://betterprogramming.pub/how-to-scrape-modern-websites-without-headless-browsers-d871bbd1119e?source=collection_archive---------1-----------------------#2021-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="91d8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python和常识</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ecd21dca22074c042954867bcc67912e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OQzcbA8-TQEyGGxF75soBA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯托夫·高尔在<a class="ae ky" href="https://unsplash.com/s/photos/technology?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8195" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多开发人员认为web抓取很难、太慢或者难以扩展——尤其是在使用无头浏览器的时候。根据我的经验，你甚至不用无头浏览器就可以浏览现代网站。它简单、快速且高度可扩展。</p><p id="6321" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不使用Selenium、Puppeteer或任何其他无头浏览器解决方案，而是使用Python请求来展示它是如何工作的。我将解释如何从大多数现代网站在其前端使用的公共API中获取信息。</p><p id="b6d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在传统的web页面中，您的目标是解析HTML并提取相关信息。在现代网站中，前端可能不会包含很多HTML，因为数据是在第一次请求后异步获取的。出于这个原因，大多数人使用无头浏览器——无头浏览器可以执行JavaScript，发出进一步的请求，然后您可以解析整个页面。</p><p id="9dba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是还有一种方法你可以经常使用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3717" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">抓取公共API</h1><p id="c661" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们看看如何使用网站用来带来数据的API。我会刮亚马逊产品评论，并显示你如何做同样的事情。如果你遵循我概述的过程，你可能会惊讶它是多么容易建立。</p><p id="f44f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目标是提取特定产品的所有产品评论。要了解<a class="ae ky" href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/" rel="noopener ugc nofollow" target="_blank">，请点击此处</a>，或寻找其他产品。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/e7c0a3758ff99237d39c48a2ea81b441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlsYhWjNKcL-EM4Fcce4Dg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/" rel="noopener ugc nofollow" target="_blank">产品</a>截图。</p></figure><p id="2e5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的目标是尽可能多地提取评论信息。请记住，无论何时你在搜集数据，贪婪是有代价的。如果您不提取一些信息，那么您将不得不再次运行整个过程，只是为了添加更多的数据。因为抓取的主要部分是HTTP请求，所以处理不会花很长时间，但是您应该尽量减少请求的数量。</p><p id="f052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到产品页面后，点击评分，然后转到“查看所有评论”，这是我们看到的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/20ebdbd2132a388bdb4d5bdcfa5292c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qaFzXhsWJNeSG3SHgwxG_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">产品的<a class="ae ky" href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/product-reviews/0132350882/ref=cm_cr_dp_d_show_all_btm?ie=UTF8&amp;reviewerType=all_reviews" rel="noopener ugc nofollow" target="_blank">评论页面</a></p></figure><p id="d293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是个人评论。我们的目标是从页面中提取信息，而不使用无头浏览器来呈现页面。</p><p id="b542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个过程很简单，需要我的浏览器开发工具。我需要触发评论中的更新，以找到带来评论的请求。当您打开开发工具时，大多数浏览器都会跟踪网络请求，所以在您触发更新之前，请确保它们是打开的。</p><p id="8a00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我将排序从“热门评论”改为“最近”查看我的网络选项卡，它只显示了一个新请求，这意味着评论来自该请求。</p><p id="c387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，由于页面上运行的跟踪和分析代码，每次点击可能会有多个事件，但是如果您对它们进行排序，您将能够找到带来实际信息的请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/bbd3004f70fb1c176da71bebc662d429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o0Z1waTxQzyDVSyhux5fNA.png"/></div></div></figure><p id="630b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是查看“回复”选项卡，了解评论是以什么格式出现的。</p><p id="8649" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，您会有可读的JSON格式的数据，可以很容易地转换和存储。</p><p id="e6cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他时候，正如您将在本例中看到的那样，会稍微困难一点，但并非不可能处理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/336a6d4a4e230eca9fb583ec3c8a7f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Ks_beZ_W9NTPn7_WlYODA.png"/></div></div></figure><p id="cf6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种格式看起来不像HTML、JavaScript或JSON，但它有一种易于理解的模式。稍后，我将展示我们如何使用Python代码来解析它，即使格式很奇怪。</p><p id="f465" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们最初的准备之后，是时候进入代码了。您可以很容易地用您选择的编程语言为请求编写代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/0dc17bb1a28877654bb16b21f5c4c78c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*3yFNM7widxyTfn_n4SWfDA.png"/></div></figure><p id="3cb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了节省时间，我喜欢使用一个方便的卷曲转换器。首先，我将请求复制为cURL，方法是双击它并选择“复制为cURL ”,正如您在前面的截图中看到的。然后我将<a class="ae ky" href="https://curl.trillworks.com/" rel="noopener ugc nofollow" target="_blank">转换器</a>粘贴进去，得到Python代码。</p><p id="258c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注1:有很多方法可以完成这个过程，我只是觉得这个更容易。如果您只是用所使用的头和属性创建一个请求，那就没问题了。</p><p id="5006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注2 <strong class="lb iu"> : </strong>每当我想试验请求时，我会在Postman中导入cURL命令，这样我就可以试验请求并理解端点是如何工作的。但是在本指南中，我将用代码做所有的事情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来分析一下我在做什么。我从浏览器的请求中提取了标题和文章正文。我删除了不需要的头部，保留了使请求看起来真实的头部。永远不要忘记的最重要的标题是<code class="fe ng nh ni nj b">User-Agent</code>。没有了<code class="fe ng nh ni nj b">User-Agent</code>，你可以期待被屏蔽很多次。</p><p id="7539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们传递给post请求的数据中，我们传递语言、产品ID、首选排序和一些其他参数，我在这里就不解释了。通过在实际页面中摆弄过滤器并观察请求如何变化，很容易理解要传递什么样的排序。分页很简单，因为它定义了一个<code class="fe ng nh ni nj b">pageSize</code>和<code class="fe ng nh ni nj b">pageNumber</code>，这是不言自明的。每当分页不是自解释的时候，您可以试验一下页面，看看请求是如何变化的。</p><p id="0863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在post数据中，我们按原样传递大多数参数。其中一些比较重要的是:</p><ul class=""><li id="bf8b" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated"><code class="fe ng nh ni nj b">pageNumber</code>:当前页码</li><li id="68d9" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe ng nh ni nj b">pageSize</code>:每页结果数</li><li id="63c7" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe ng nh ni nj b">asin</code>:产品ID</li><li id="b99f" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe ng nh ni nj b">sortBy</code>:主动排序</li></ul><p id="e10e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">pageNumber</code>和<code class="fe ng nh ni nj b">pageSize</code>参数不言自明。至于排序，我们通过更改实际页面上的排序并查看请求在Network选项卡中的变化来了解它是如何工作的。最后是ID ( <code class="fe ng nh ni nj b">asin</code>)，如果我们查看页面链接，我们会注意到它在这里(以粗体显示):</p><pre class="kj kk kl km gt ny nj nz oa aw ob bi"><span id="f102" class="oc md it nj b gy od oe l of og"><a class="ae ky" href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/#customerReviews" rel="noopener ugc nofollow" target="_blank">https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/<strong class="nj iu">0132350882</strong>/#customerReviews</a></span></pre><p id="fceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解每个参数在未记录的API中的作用，您需要更新页面以查看每个参数是如何变化的。</p><p id="f852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<code class="fe ng nh ni nj b">pageSize</code>的一个重要注意事项是，它可以帮助我们减少获取我们想要的信息所需的请求数量。但是通常没有API会让您输入任何想要的页面大小。这就是为什么我从10岁开始，一直到20岁，结果停止增长。所以最大页面大小是20，我们将使用它。</p><p id="e590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>当你使用非默认的页面尺寸时，你会让目标网站更容易阻止你，所以应该小心。</p><p id="afea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是理解分页是如何工作的，并循环请求。处理分页有三种主要方式:</p><ul class=""><li id="6672" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated"><strong class="lb iu">页码:</strong>即在每个请求中传递一个页码，<code class="fe ng nh ni nj b">1</code>表示第一页，<code class="fe ng nh ni nj b">2</code>表示第二页，依此类推。</li><li id="81a2" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><strong class="lb iu">偏置</strong>:偏置也很常见。如果每页有十个结果，那么第二页的偏移量为十，第三页的偏移量为二十，直到到达结果的末尾。</li><li id="e537" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><strong class="lb iu">游标</strong>:处理分页的另一种常见方式是使用游标。第一页没有，但是第一个请求的响应将为您提供下一个请求的光标，直到您到达末尾。</li></ul><p id="f24a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，API使用一个页码来遍历端点中的页面。我们需要弄清楚是什么指示了请求的结束，这样我们就可以在循环中使用它。</p><p id="fe18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要翻到最后一页，看看会发生什么。在我们的例子中，一个简单的指标是“下一页”按钮被禁用，正如您在下面的截图中看到的。我们会记住这一点——在编写代码时打破循环。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/5f3a700d3378507c52d9d74f938afd50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VdHwuDF_abQNL-PRHe5_MA.png"/></div></div></figure><p id="a199" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们浏览所有页面并收集一些信息。我还将向您展示如何使用Beautiful Soup 4解析HTML片段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="bcd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们分解这段代码，看看它做了什么:</p><pre class="kj kk kl km gt ny nj nz oa aw ob bi"><span id="8400" class="oc md it nj b gy od oe l of og"># We set the new page each time<br/>post_data['pageNumber'] = page<br/># ...<br/># And at the end of the loop we increase the page counter<br/>page += 1</span></pre><p id="e53c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我们必须拆分这些行，这样我们才能解析它们。通过查看API的响应，每一行要么是一个数组，要么是一个包含<code class="fe ng nh ni nj b">&amp;&amp;&amp;</code>的字符串。我采取了一种“请求原谅，而不是允许”的方法，将每个<code class="fe ng nh ni nj b">json.loads</code>包装在一个try/except块中。这将忽略<code class="fe ng nh ni nj b">&amp;&amp;&amp;</code>行，并关注那些实际上是JSON数组的行。</p><p id="23ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后一个接一个，我们处理每一行。有些行是顶部和底部的，不包含实际的评论，所以我们可以安全地忽略这些。最后，我们必须从实际审查中提取相关数据:</p><pre class="kj kk kl km gt ny nj nz oa aw ob bi"><span id="aa9e" class="oc md it nj b gy od oe l of og"># We load the line as JSON<br/>payload = json.loads(line)<br/># And we parse the HTML using Beautiful Soup<br/>html = Soup(payload[2], features="lxml")</span><span id="cea9" class="oc md it nj b gy oi oe l of og"># Stop scraping once we reach the last page<br/>if html.select_one('.a-disabled.a-last'):<br/>  break</span><span id="27ef" class="oc md it nj b gy oi oe l of og">review = html.select_one('.a-section.review')<br/># When the review section is not found we move to the next line<br/>if not review:<br/>  continue</span></pre><p id="e314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是我解释如何从HTML中解析文本的时候了，这需要CSS选择器和一些基本处理的知识。</p><pre class="kj kk kl km gt ny nj nz oa aw ob bi"><span id="4522" class="oc md it nj b gy od oe l of og">reviews.append({</span><span id="e399" class="oc md it nj b gy oi oe l of og"><strong class="nj iu"># To get the stars we split the text that says 1.0 out of 5 for example, and just keep the first number</strong><br/>'stars': float(review.select_one('.review-rating').text.split(' out of ')[0]),</span><span id="01f5" class="oc md it nj b gy oi oe l of og"><strong class="nj iu"># For the text we extract it easily but we need to remove the surrounding new lines and whitespace<br/></strong>'text': review.select_one('.review-text.review-text-content').text.replace("\n\n", "").strip(),</span><span id="fdd7" class="oc md it nj b gy oi oe l of og"><strong class="nj iu"># The date takes some simple splitting once more<br/></strong>'date': review.select_one('.review-date').text.split(' on ')[1],</span><span id="aadc" class="oc md it nj b gy oi oe l of og"><strong class="nj iu"># And the profile name is just a simple selector<br/></strong>'profile_name': review.select_one('.a-profile-name').text<br/>})</span></pre><p id="68e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我没有深入细节——我的目的是解释这个过程，而不是我使用的漂亮的Soup或Python工具。这是任何编程语言都可以遵循的过程。</p><p id="6370" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当前版本的代码遍历页面，从每个评论中提取星星、概要名称、日期和评论。每个审核都存储在一个列表中，您可以保存或进一步处理该列表。因为抓取随时都可能失败，所以经常保存数据并确保您可以轻松地从失败的地方重新启动抓取器非常重要。</p><p id="4053" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这是一个现实生活中的例子，你会想做更多的事情:</p><ul class=""><li id="ef06" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">使用更强大的抓取解决方案(例如scrapy ),支持并发请求、代理、处理和保存数据的管道等。</li><li id="67e7" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">解析日期，这样就可以有一个标准的格式。</li><li id="d25f" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">尽可能提取所有的数据。</li><li id="7616" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">创建一个系统来运行更新和刷新数据。</li></ul><p id="ede1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无头浏览器对于从网站提取信息来说很棒，但是它们真的很重。它们比访问未记录的API更可靠，更不容易出错，但有时访问这些公共API会更快，也更有意义，例如:</p><ul class=""><li id="245a" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">API不会经常改变</li><li id="14a5" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">你只需要得到一次数据</li><li id="3b85" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">速度至关重要</li><li id="d5ee" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">API提供了比页面本身更多的信息</li></ul><p id="cf4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用API进行web抓取有很多合理的理由。你甚至可以说它更尊重服务器，因为它接受的请求更少，并且不需要加载静态资产。</p><p id="7cf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，通过增加请求之间的延迟，将对同一个域的并发请求保持在最低限度，来达到节省的目的。web抓取的目标是访问和分析信息，并从中创造有用的东西，而不是给服务器带来问题或减慢速度。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="2956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>