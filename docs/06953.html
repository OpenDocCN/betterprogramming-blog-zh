<html>
<head>
<title>A Tool for useEffect Dependencies in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中使用效果依赖的工具</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-tool-for-useeffect-dependencies-ca4086b085bb?source=collection_archive---------10-----------------------#2020-11-19">https://betterprogramming.pub/a-tool-for-useeffect-dependencies-ca4086b085bb?source=collection_archive---------10-----------------------#2020-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a8c5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">触发器赋予您决定执行时间的权力</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d95b63c6072e2e329039b0a0dc9dd83c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Il-TNgzYRZeAGcKpv6c_w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">这看起来眼熟吗？作者照片。</p></figure><p id="df02" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">React钩子为函数提供了一个方便的生态系统，它基于对所述函数的依赖关系进行的操作来运行。在某种意义上，<code class="fe lr ls lt lu b">useEffect</code>是一个类似于数据库钩子的概念。数据库挂钩允许您在数据库操作后执行操作。</p><p id="3732" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设您正在构建一个游戏，每当玩家的分数更新时，如果有必要，您也希望更新高分。您可以在用一些常规的业务逻辑写入数据库之前这样做，但是这无疑会增加更新功能。在我看来，它也松散地破坏了几个最佳实践。具体来说，一个函数应该有一个目的和最小的副作用。一旦编写完成，它的功能应该被扩展而不是修改。</p><p id="d122" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一种方法是使用更新后挂钩。这个钩子监听玩家分数的变化，如果这个分数大于最高分，它就用新值执行一次单独的更新。</p><p id="c1dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">useEffect</code>怎么像数据库钩子？它允许我们为一个函数订阅一个或多个在依赖数组中标识的变量变化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="2b3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在前面代码片段中的任何时候<code class="fe lr ls lt lu b">score</code>或<code class="fe lr ls lt lu b">highscore</code>发生变化，<code class="fe lr ls lt lu b">useEffect</code>中的函数就会运行。请注意，这实际上可以运行两次。它总是在<code class="fe lr ls lt lu b">score</code>改变时运行。如果<code class="fe lr ls lt lu b">highscore</code>被更新，它将第二次运行。您现在可以看到，这在概念上类似于数据库挂钩。</p><p id="15f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个相对简单的想法，但是一旦理解了，它就强大了！</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="9186" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">冗长的依赖数组</h1><p id="947b" class="pw-post-body-paragraph kv kw iq kx b ky mw jr la lb mx ju ld le my lg lh li mz lk ll lm na lo lp lq ij bi translated">当您需要对许多数据点进行操作时，会出现一个令人烦恼的问题。对任何依赖项的更改都会导致函数运行。如果您需要引用许多变量，但只想在非常精确的时间运行函数，该怎么办？假设您有以下不可否认的组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb lw l"/></div></figure><p id="9a52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">重点看第二个<code class="fe lr ls lt lu b">useEffect</code>。每当它运行时，它都会增加计数，并根据<code class="fe lr ls lt lu b">count</code>的当前值设置一些本地文本。</p><p id="1707" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我把下面的工具称为“触发器”触发器允许我们准确地知道业务逻辑何时运行。我们来分解一下<code class="fe lr ls lt lu b">useEffect</code>。想象一下它是这样写的:</p><pre class="kg kh ki kj gt nc lu nd ne aw nf bi"><span id="510e" class="ng mf iq lu b gy nh ni l nj nk">useEffect(() =&gt; {<br/>  setCount(count + 1);<br/>  setText(`${text} ${textValues[count % textValues.length]}`);<br/>}, [count, text])</span></pre><p id="cbfa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这显然是不可接受的，因为它无限重播。它改变了<code class="fe lr ls lt lu b">count</code>和<code class="fe lr ls lt lu b">text</code>的值，这将导致它再次运行。通过添加触发器逻辑，我们强制它运行一次业务逻辑。说是<code class="fe lr ls lt lu b">count</code>或者<code class="fe lr ls lt lu b">text</code>变化，但是触发点是<code class="fe lr ls lt lu b">false</code>。它将命中第一个<code class="fe lr ls lt lu b">if</code>语句并结束执行。为了达到业务逻辑，触发器必须是<code class="fe lr ls lt lu b">true</code>。如果是<code class="fe lr ls lt lu b">true</code>，立即设置为<code class="fe lr ls lt lu b">false</code>。没有循环发生。</p><p id="94a6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这还能带来什么好处？它还确保任何业务逻辑都具有最新的值。假设我们在<code class="fe lr ls lt lu b">handleLoad</code>的<code class="fe lr ls lt lu b">then</code>中运行这个逻辑。它要么依赖于闭包(可能有一个竞争条件)，要么将一个函数传递给<code class="fe lr ls lt lu b">setCount</code> / <code class="fe lr ls lt lu b">setText</code>。虽然在这个例子中你可以这样做，但并不总是能够确定变量的下一个序列。如果逻辑依赖于在不同时间点变化的变量，你也不能这样做。</p><p id="deff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这也确保了如果我们需要链接<code class="fe lr ls lt lu b">useEffects</code>，我们可以在不影响调用<code class="fe lr ls lt lu b">useEffect</code>的依赖的情况下触发它。请看第一个<code class="fe lr ls lt lu b">useEffect</code>的例子。因为我们不调用函数，所以我们不需要将函数的依赖项放入依赖数组中。即使我们使用了<code class="fe lr ls lt lu b">useCallback</code>，我们仍然必须引用在依赖关系改变时会改变的回调。所以，我们并没有真的改变什么。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="47e2" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">必要时使用该工具</h1><p id="61b0" class="pw-post-body-paragraph kv kw iq kx b ky mw jr la lb mx ju ld le my lg lh li mz lk ll lm na lo lp lq ij bi translated">虽然这是一个有用的工具，特别是在管理大型依赖关系数组时，但我必须承认我们已经学到的一些其他最佳实践:</p><ol class=""><li id="fff4" class="nl nm iq kx b ky kz lb lc le nn li no lm np lq nq nr ns nt bi translated">简化你的依赖关系。似乎很多单用途的<code class="fe lr ls lt lu b">useEffects</code>比有几个副作用的大的更容易维护。</li><li id="86cb" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated">使用react-hooks/exclusive-deps。如果你是React或React Hooks的新手，这将迫使你理解何时以及为什么你必须改变你的依赖数组。</li><li id="9e4b" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated">小心依赖数组中不必要的引用。有时你会在代码中添加一个依赖项并移除它的引用。如果您不从依赖数组中删除它，它仍然会强制<code class="fe lr ls lt lu b">useEffect</code>在它改变时运行。这可能会导致性能退化。</li><li id="9dff" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated">不要忘乎所以。在任何你想的地方使用触发器。把它想象成你调用函数的新方法。然而，只有在绝对必要时才使用它。否则，很难跟踪依赖关系的变化是如何影响您的状态的。</li></ol></div></div>    
</body>
</html>