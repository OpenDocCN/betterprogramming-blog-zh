<html>
<head>
<title>What’s New in TypeScript 4.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4.0中的新增功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-typescript-4-0-b8513c38fd20?source=collection_archive---------5-----------------------#2020-08-21">https://betterprogramming.pub/whats-new-in-typescript-4-0-b8513c38fd20?source=collection_archive---------5-----------------------#2020-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cfbc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们探索一下最新版本的TypeScript</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/29766f5f853fc25df8aeb4334fd799cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cUSHVUa76DoQrUsF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@andrewtneel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安德鲁·尼尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="35db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript今天(2020年8月20日)宣布了它的最新版本，我想快速回顾一下它的特性和变化。在这个版本中，TypeScript带来了他们最新更新的最终稳定版本。虽然这带来了一个新的主要版本，但并没有比通常更大的突破性变化。所以让我们来看看这个版本有什么新功能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="62d7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">标记元组元素</h1><p id="d5bb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这种语言特性改变了元组的定义方式。以前，元组定义如下:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a874" class="ne md it na b gy nf ng l nh ni">function tuple(...args: [string, number]): void {<br/>    // ...<br/>}</span></pre><p id="ca35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，第一个和第二个元素没有参数名。虽然这些对类型检查没有影响，但是元组位置上缺少标签会使它们更难使用——更难传达我们的意图。(来源:<a class="ae ky" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0/#labeled-tuple-elements" rel="noopener ugc nofollow" target="_blank">devblogs.microsoft.com</a>)</p><p id="6385" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为对此的解决方案，TypeScrip 4.0引入了带标签的元组。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="14c9" class="ne md it na b gy nf ng l nh ni">type Segment = [length: number, count: number];</span></pre><p id="9926" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你要标记一个元素，你必须标记元组中的所有元素。否则，您将收到一条错误消息。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4cb7" class="ne md it na b gy nf ng l nh ni">type Segment = [first: string, number];<br/>//                         ~~~~~~<br/>// error! Tuple members must all have names or all not have names.</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="db06" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">从构造函数推断类属性</h1><p id="493e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们在<code class="fe nj nk nl na b">noImplicitAny</code>模式下配置TypeScript，<strong class="lb iu"><em class="nm"/></strong>TypeScript 4.0可以使用控制流分析来确定类中属性的类型。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f1aa" class="ne md it na b gy nf ng l nh ni">class Test {    <br/>   x;    <br/>   constructor(b: boolean){      <br/>     if(b){        <br/>       this.x = 'hello'      <br/>     } else {        <br/>       this.x = 42;      <br/>     }    <br/>   }<br/>}</span></pre><p id="5215" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以前版本的TypeScript中，上述代码将导致错误。但是4.0版本会编译，TypeScript会推断出<code class="fe nj nk nl na b">x</code>的类型是<code class="fe nj nk nl na b">string</code> <strong class="lb iu"> <em class="nm"> </em> </strong>还是<code class="fe nj nk nl na b">number</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="84f1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">短路赋值运算符</h1><p id="5978" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我相信您一定见过许多语言中的复合赋值运算符。复合赋值运算符将一个运算符应用于两个参数，然后将结果赋给左侧。以下是一些例子:</p><p id="c867" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据Typescript团队说法，</p><blockquote class="nn no np"><p id="08de" class="kz la nm lb b lc ld ju le lf lg jx lh nq lj lk ll nr ln lo lp ns lr ls lt lu im bi translated">但是有三个明显的例外:逻辑<em class="it">和</em> ( <code class="fe nj nk nl na b">&amp;&amp;</code>)、逻辑<em class="it">或</em> ( <code class="fe nj nk nl na b">||</code>)以及无效合并(<code class="fe nj nk nl na b">??</code>)。TypeScript准备在4.0版本中通过引入三个新的赋值操作符来填补这些空白:<code class="fe nj nk nl na b">&amp;&amp;=</code>、<code class="fe nj nk nl na b">||=</code>和<code class="fe nj nk nl na b">??=</code>。(来源:<a class="ae ky" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0/#short-circuiting-assignment-operators" rel="noopener ugc nofollow" target="_blank">devblogs.microsoft.com</a>)</p></blockquote><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b9f9" class="ne md it na b gy nf ng l nh ni">a ||= b;</span><span id="7780" class="ne md it na b gy nt ng l nh ni">// This will be equal to</span><span id="1ae5" class="ne md it na b gy nt ng l nh ni">a || (a = b);</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="92bb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">“catch”子句绑定上的“unknown”</h1><p id="b3e7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">从TypeScript开始，<code class="fe nj nk nl na b">catch</code>子句变量总是被类型化为<code class="fe nj nk nl na b">any</code>，这意味着TypeScript允许您对它们做任何您想做的事情。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a2cc" class="ne md it na b gy nf ng l nh ni">try {<br/>  throw 20;<br/>} catch (err) {<br/>  console.error(err.specialFunction()); <br/>}</span></pre><p id="df06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，错误的类型是<code class="fe nj nk nl na b">any</code>，因此它不是类型安全的。Typescript 4.0对此有一个解决方案，</p><blockquote class="nn no np"><p id="8b2e" class="kz la nm lb b lc ld ju le lf lg jx lh nq lj lk ll nr ln lo lp ns lr ls lt lu im bi translated">TypeScript 4.0现在允许您将<code class="fe nj nk nl na b">catch</code>子句变量的类型指定为<code class="fe nj nk nl na b">unknown</code>。<code class="fe nj nk nl na b">unknown</code>比<code class="fe nj nk nl na b">any</code>更安全，因为它提醒我们在对值进行操作之前需要执行一些类型检查。(来源:<a class="ae ky" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0/#unknown-on-catch" rel="noopener ugc nofollow" target="_blank">devblogs.microsoft.com</a>)</p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3264" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用'- noEmitOnError '提高了构建模式的速度</h1><p id="5ed7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在以前的版本中，当使用<code class="fe nj nk nl na b">--noEmitOnError</code>标志时，在前一次编译后编译一个在<code class="fe nj nk nl na b">--incremental</code>下有错误的程序会非常慢，因为上次编译的任何信息都不会基于<code class="fe nj nk nl na b">--noEmitOnError</code>标志缓存在<code class="fe nj nk nl na b">.tsbuildinfo</code>文件中。</p><p id="6f03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在TypeScript 4.0中，这一点已经改变，现在您将在这些场景中获得巨大的速度提升。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="beca" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">- incremental '带'- noEmit '</h1><p id="f00e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">TypeScript 4.0允许在仍然利用<code class="fe nj nk nl na b">--incremental</code>编译时使用<code class="fe nj nk nl na b">--noEmit</code>标志。这在以前是不允许的，因为<code class="fe nj nk nl na b">--incremental</code>需要发出一个<code class="fe nj nk nl na b">.tsbuildinfo</code>文件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9d28" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">编辑器改进</h1><p id="4542" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Typescript已经成为许多编辑的好伙伴，随着新版本的发布，他们已经拓宽了他们的限制。</p><blockquote class="nn no np"><p id="b08b" class="kz la nm lb b lc ld ju le lf lg jx lh nq lj lk ll nr ln lo lp ns lr ls lt lu im bi translated">TypeScript编译器不仅增强了大多数主流编辑器中TypeScript本身的编辑体验，还增强了Visual Studio系列编辑器及其他编辑器中的JavaScript体验。(来源:<a class="ae ky" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0/#editor-improvements" rel="noopener ugc nofollow" target="_blank">devblogs.microsoft.com</a>)</p></blockquote><p id="2e2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以查看部分支持TypeScript 的编辑器列表，了解您最喜欢的编辑器是否支持使用新版本。</p><p id="b90a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，TypeScript的编辑支持现在可以识别声明何时用<code class="fe nj nk nl na b">/** @deprecated *</code> JSDoc注释标记。</p><p id="9f9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启动时的部分语义模式<strong class="lb iu"> </strong>是TypeScript 4.0中已经包含的另一个实验性特性。他们说，这将是许多项目中加载时间缓慢的一个解决方案。这种新的编辑模式将提供部分体验，直到加载完整的语言服务体验。通常情况下，一个项目需要20到60秒，直到TypeScript完全响应，而这种新模式会将时间减少到几秒钟。</p><p id="6a1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，唯一支持这种模式的编辑器是<a class="ae ky" href="http://code.visualstudio.com/insiders" rel="noopener ugc nofollow" target="_blank">Visual Studio Code Insiders</a>。您可以按照以下步骤进行尝试。</p><ol class=""><li id="bb0c" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">安装<a class="ae ky" href="http://code.visualstudio.com/insiders" rel="noopener ugc nofollow" target="_blank"> Visual Studio代码内部人员</a>。</li><li id="00c7" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><a class="ae ky" href="https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-newer-typescript-versions" rel="noopener ugc nofollow" target="_blank">配置Visual Studio Code Insiders </a>使用测试版或者为Visual Studio Code Insiders安装<a class="ae ky" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next" rel="noopener ugc nofollow" target="_blank"> JavaScript和TypeScript Nightly Extension </a>。</li><li id="2ed3" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">打开你的JSON设置视图:<code class="fe nj nk nl na b">&gt; Preferences: Open Settings (JSON)</code>。</li><li id="15ca" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">添加以下几行:</li></ol><p id="3071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">// The editor will say 'dynamic' is an unknown option, // but don't worry about it for now. It's still experimental. "typescript.tsserver.useSeparateSyntaxServer": "dynamic",</code></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="cf56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了上述特性，TypeScript 4.0还包含许多新特性，如自定义JSX工厂、Varadic元组元素等，你也可以在官方网站上找到它们。另外，如果您想在项目中测试这个最新版本:</p><ul class=""><li id="f0c4" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu oi oa ob oc bi translated">可以用<code class="fe nj nk nl na b">npm install -D typescript</code>。</li><li id="a294" class="nu nv it lb b lc od lf oe li of lm og lq oh lu oi oa ob oc bi translated">你可以通过<a class="ae ky" href="https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild" rel="noopener ugc nofollow" target="_blank"> NuGet </a>得到它。</li></ul></div></div>    
</body>
</html>