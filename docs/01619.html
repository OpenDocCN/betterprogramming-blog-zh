<html>
<head>
<title>How To Create a Dynamic Theme in Flutter Using Provider</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Provider在Flutter中创建动态主题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-dynamic-theme-in-flutter-using-provider-e6ad1f023899?source=collection_archive---------3-----------------------#2019-09-30">https://betterprogramming.pub/how-to-create-a-dynamic-theme-in-flutter-using-provider-e6ad1f023899?source=collection_archive---------3-----------------------#2019-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5d1b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何将黑暗模式添加到您的应用程序中</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6d957ff36ab60344d71d4a329cacb434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kqoy7vrgWAwjAsdLtiQ50w.png"/></div></div></figure><p id="9e2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们都喜欢应用程序中的主题。尤其是所谓的<em class="ln">黑暗题材</em>。一个黑暗的主题现在已经成为移动应用必不可少的一部分。所有主要的应用程序都支持黑暗主题，一些应用程序甚至默认为黑暗主题。</p><blockquote class="lo lp lq"><p id="0a99" class="kr ks ln kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">深色主题会降低设备屏幕发出的亮度，同时仍能满足最低的颜色对比度。它们有助于改善视觉人体工程学，减少眼睛疲劳，根据当前照明条件调整亮度，并有助于在黑暗环境中使用屏幕，同时节省电池电量。配备有机发光二极管屏幕的设备受益于随时关闭黑色像素的能力。</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="a044" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们知道黑暗面的力量，这就是我们在这里的原因！所以让我们用这种力量来舞动吧。</p><p id="d56d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用<a class="ae lw" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank">提供者</a>包。将提供者插件添加到pubspec.yaml文件中。</p><pre class="kg kh ki kj gt lx ly lz ma aw mb bi"><span id="950d" class="mc md iq ly b gy me mf l mg mh">dependencies:   <br/>  <strong class="ly ir">provider: ^3.1.0</strong></span></pre><p id="82c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将创建两个主题——浅色主题和深色主题。我已经手动完成了，但是你可以使用<a class="ae lw" href="https://rxlabz.github.io/panache_web/#/" rel="noopener ugc nofollow" target="_blank"> panache </a>来创建主题。</p><pre class="kg kh ki kj gt lx ly lz ma aw mb bi"><span id="1c93" class="mc md iq ly b gy me mf l mg mh">import 'package:flutter/material.dart';<br/><br/>final darkTheme = ThemeData(<br/>  primarySwatch: Colors.grey,<br/>  primaryColor: Colors.black,<br/>  brightness: Brightness.dark,<br/>  backgroundColor: const Color(0xFF212121),<br/>  accentColor: Colors.white,<br/>  accentIconTheme: IconThemeData(color: Colors.black),<br/>  dividerColor: Colors.black12,<br/>);<br/><br/>final lightTheme = ThemeData(<br/>  primarySwatch: Colors.grey,<br/>  primaryColor: Colors.white,<br/>  brightness: Brightness.light,<br/>  backgroundColor: const Color(0xFFE5E5E5),<br/>  accentColor: Colors.black,<br/>  accentIconTheme: IconThemeData(color: Colors.white),<br/>  dividerColor: Colors.white54,<br/>);</span></pre><p id="8853" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当主题准备好时，我们创建一个主题通知类来通知我们主题的变化:</p><pre class="kg kh ki kj gt lx ly lz ma aw mb bi"><span id="7e3c" class="mc md iq ly b gy me mf l mg mh">import 'package:flutter/material.dart';<br/><br/>class ThemeNotifier with ChangeNotifier {<br/>  ThemeData _themeData;<br/><br/>  ThemeNotifier(this._themeData);<br/><br/>  getTheme() =&gt; _themeData;<br/><br/>  setTheme(ThemeData themeData) async {<br/>    _themeData = themeData;<br/>    notifyListeners();<br/>  }<br/>}</span></pre><p id="7b20" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们用<code class="fe mi mj mk ly b">ChangeNotifierProvider</code>包装我们的应用程序。然后我们就可以用<code class="fe mi mj mk ly b">ThemeNotifier</code>来获取主题了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml lv l"/></div></figure><p id="b735" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是时候手动改变主题了。我们使用<code class="fe mi mj mk ly b"><a class="ae lw" href="https://pub.dev/packages/day_night_switch" rel="noopener ugc nofollow" target="_blank">DayNightSwitch</a></code>来完成这项工作——它的工作方式就像Flutter中普通的switch小部件一样。在<code class="fe mi mj mk ly b"><a class="ae lw" href="https://pub.dev/packages/day_night_switch" rel="noopener ugc nofollow" target="_blank">DayNightSwitch</a></code>的<code class="fe mi mj mk ly b">onChanged</code>回调里面，我们调用<code class="fe mi mj mk ly b">onThemeChanged</code>方法，用<code class="fe mi mj mk ly b">themeNotifier</code>设置主题，通知整个app。</p><pre class="kg kh ki kj gt lx ly lz ma aw mb bi"><span id="9abd" class="mc md iq ly b gy me mf l mg mh">void main() =&gt; runApp(<br/>      ChangeNotifierProvider&lt;ThemeNotifier&gt;(<br/>        builder: (_) =&gt; ThemeNotifier(darkTheme),<br/>        child: MyApp(),<br/>      ),<br/>    );<br/><br/>class MyApp extends StatelessWidget {<br/>  @override<br/>  Widget build(BuildContext context) {<br/>    final themeNotifier = Provider.of&lt;ThemeNotifier&gt;(context);<br/>    return MaterialApp(<br/>      title: 'Chitr',<br/>      theme: themeNotifier.getTheme(),<br/>      home: HomePage(),<br/>    );<br/>  }<br/>}</span></pre><p id="e613" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就是这样。只需几行代码，我们就可以动态地改变应用程序的主题。让我们看看它是什么样子的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/58267f949359629275e4b0e414bd731e.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*2dRXdzkd8Wl6HB9Gxvs9CA.gif"/></div></figure><p id="6ed7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看起来很棒，但是…</p><p id="492e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的主题未被保存，如果我们重新启动应用程序，它将返回默认状态。所以我们使用use <code class="fe mi mj mk ly b">SharedPreferences</code>来存储当前主题。在<code class="fe mi mj mk ly b">onThemeChanged</code>方法中，我们保存当前主题。</p><pre class="kg kh ki kj gt lx ly lz ma aw mb bi"><span id="db26" class="mc md iq ly b gy me mf l mg mh">void onThemeChanged<em class="ln">(</em>bool value, ThemeNotifier themeNotifier<em class="ln">) </em>async <em class="ln">{<br/>  (</em>value<em class="ln">)<br/>      </em>? themeNotifier.setTheme<em class="ln">(</em>darkTheme<em class="ln">)<br/>      </em>: themeNotifier.setTheme<em class="ln">(</em>lightTheme<em class="ln">)</em>;<br/>  var prefs = await SharedPreferences.<em class="ln">getInstance()</em>;<br/>  prefs.setBool<em class="ln">(</em>'darkMode', value<em class="ln">)</em>;<br/><em class="ln">}</em></span></pre><p id="8f2e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在main方法中使用<code class="fe mi mj mk ly b">SharedPreferences</code>值:</p><pre class="kg kh ki kj gt lx ly lz ma aw mb bi"><span id="b95d" class="mc md iq ly b gy me mf l mg mh">SharedPreferences.<em class="ln">getInstance()</em>.then<em class="ln">((</em>prefs<em class="ln">) {<br/>  </em>var darkModeOn = prefs.getBool<em class="ln">(</em>'darkMode'<em class="ln">) </em>?? true;<br/>  runApp<em class="ln">(<br/>    </em>ChangeNotifierProvider<em class="ln">&lt;</em>ThemeNotifier<em class="ln">&gt;(<br/>      </em>builder: <em class="ln">(</em>_<em class="ln">) </em>=&gt; ThemeNotifier<em class="ln">(</em>darkModeOn ? darkTheme : lightTheme<em class="ln">)</em>,<br/>      child: MyApp<em class="ln">()</em>,<br/>    <em class="ln">)</em>,<br/>  <em class="ln">)</em>;<br/><em class="ln">})</em>;</span></pre><p id="5151" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以点击查看完整的源代码<a class="ae lw" href="https://github.com/divyanshub024/chitr" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="b36d" class="mn md iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">推荐阅读</h1><div class="ne nf gp gr ng nh"><a href="https://medium.com/flutter-community/everything-you-need-to-know-about-flutter-page-route-transition-9ef5c1b32823" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">你需要知道的关于Flutter页面路由转换的一切</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">我们知道在Flutter中从一条路线导航到另一条路线是多么容易。我们只需要做推和弹出。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kp nh"/></div></div></a></div></div></div>    
</body>
</html>