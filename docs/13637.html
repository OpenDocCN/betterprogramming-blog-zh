<html>
<head>
<title>Create a Swift Property Wrapper That Works With Optional and Non-Optional Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建使用可选和非可选值的Swift属性包装器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-swift-property-wrapper-that-works-with-optional-and-non-optional-values-fc09d27a44f3?source=collection_archive---------7-----------------------#2022-09-13">https://betterprogramming.pub/create-a-swift-property-wrapper-that-works-with-optional-and-non-optional-values-fc09d27a44f3?source=collection_archive---------7-----------------------#2022-09-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c044" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入探究属性包装器和可解码的魔法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e1b869a7808b5a2f2513a5b461a8f6fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BreajBhsj0uPmkgx5XfgPQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://developer.apple.com/swift/images/swift-og.png" rel="noopener ugc nofollow" target="_blank">https://developer.apple.com/swift/images/swift-og.png</a></p></figure><p id="9a61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">@propertyWrapper</code>是一个解决方案，允许开发人员在管理属性的代码和变量定义之间添加一个逻辑层。自从在Swift 5.1中引入以来，他们已经发现了许多用例，如将数据保存到缓存、在使用前改变变量、数据验证等。</p><p id="1a4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在文档中可以找到许多关于属性包装器的有用信息。以下是一些例子:</p><ul class=""><li id="7f43" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><a class="ae kv" href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html" rel="noopener ugc nofollow" target="_blank">https://docs . swift . org/swift-book/language guide/properties . html</a></li></ul><p id="1ba8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或在提案中</p><ul class=""><li id="0d8e" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><a class="ae kv" href="https://github.com/apple/swift-evolution/blob/main/proposals/0258-property-wrappers.md" rel="noopener ugc nofollow" target="_blank">https://github . com/apple/swift-evolution/blob/main/proposals/0258-property-wrappers . MD</a></li></ul><h1 id="effe" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">介绍</h1><p id="ec55" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我面临的问题是要有一个既能应用于字符串又能应用于可选字符串的单属性包装器，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7080" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更一般的是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="c726" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">真实世界的例子</h1><p id="ab27" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">每个API响应包含一个名为<code class="fe ls lt lu lv b">id</code>的字段，对于每个可以被请求的对象都是唯一的。它可能有以下类型:</p><ul class=""><li id="a3ec" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><code class="fe ls lt lu lv b">Integer</code> : 1，2，3 …</li><li id="0be2" class="lw lx iq ky b kz ne lc nf lf ng lj nh ln ni lr mb mc md me bi translated"><code class="fe ls lt lu lv b">String</code>:“甲”、“乙”、“丙”…</li><li id="9d11" class="lw lx iq ky b kz ne lc nf lf ng lj nh ln ni lr mb mc md me bi translated">或者，在特定情况下，如微服务器错误，它可以为空。</li></ul><p id="d51a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是一些响应示例:</p><h2 id="6c1b" class="nj mg iq bd mh nk nl dn ml nm nn dp mp lf no np mr lj nq nr mt ln ns nt mv nu bi translated">带有字符串id的响应</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="8412" class="nj mg iq bd mh nk nl dn ml nm nn dp mp lf no np mr lj nq nr mt ln ns nt mv nu bi translated">带有int id的响应</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="d61f" class="nj mg iq bd mh nk nl dn ml nm nn dp mp lf no np mr lj nq nr mt ln ns nt mv nu bi translated">没有任何id的响应</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="792b" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">我们来处理吧！</h1><p id="a997" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">当涉及到设计代码时，总是从末尾开始。想想你的解决方案应该是什么样子，并尝试调整你的内部源代码。</p><ul class=""><li id="2ec7" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">每个界面都应该尽可能简单</li><li id="5d6a" class="lw lx iq ky b kz ne lc nf lf ng lj nh ln ni lr mb mc md me bi translated">其他开发人员可用的每一个代码、公共接口或任何一种被广泛使用的源代码都应该简短、信息丰富、易于理解，并且易于使用</li></ul><p id="43c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想到的最简单的解决方案是这样的:</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="a8aa" class="nj mg iq lv b gy nz oa l ob oc">@StringAdaptable var id: String</span></pre><p id="10fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现简单明了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="454c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当从解码器初始化一个值时，它首先被转换为int类型，如果失败，则转换为string类型。当两者都失败时，控制台会抛出一个错误。</p><p id="5d73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它在JSON中运行良好，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2fe2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是当<code class="fe ls lt lu lv b">id</code>变成零值时会发生什么呢？当前代码抛出了一个大家都很熟悉的错误:</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="e39d" class="nj mg iq lv b gy nz oa l ob oc">keyNotFound(CodingKeys(stringValue: “id”, intValue: nil), Swift.DecodingError.Context(codingPath: [], debugDescription: “No value associated with key CodingKeys(stringValue: \”id\”, intValue: nil) (\”id\”).”, underlyingError: nil))</span></pre><p id="af3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好，让我们试着将<code class="fe ls lt lu lv b">id</code>变量改为可选变量:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3706" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一次，我们在运行时发现了两个错误，但在编译时没有。他们在这里:</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="b36b" class="nj mg iq lv b gy nz oa l ob oc">Property type 'String?' does not match 'wrappedValue' type 'String'<br/>Type 'Song' does not conform to protocol 'Decodable'</span></pre><p id="df10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为属性包装器中的<code class="fe ls lt lu lv b">wrappedValue</code>是一个字符串，编译器抛出一个类型不匹配错误，正如您所看到的:</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="be37" class="nj mg iq lv b gy nz oa l ob oc">String? is not a String</span></pre><p id="4b9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，出现第二个错误，表明Song没有实现Decodable。</p><p id="8b90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们停下来想一想如何让这个代码工作。想来想去，只有一个好的明确的办法。<code class="fe ls lt lu lv b">StringAdaptable</code>确认可选和非可选字符串。</p><p id="649d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这让我们想到了最初的问题:</p><h1 id="14ca" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">如何做一个可以添加可选或者非可选的属性包装器？</h1><p id="8d75" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">首先，创建一个将在属性包装中用作通用解决方案的协议。它表明实现该协议的每个类都可以用string表示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="5d11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，两种类型必须实现<code class="fe ls lt lu lv b">ExpressibleByString</code>:</p><ul class=""><li id="e1a4" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">线</li><li id="88b2" class="lw lx iq ky b kz ne lc nf lf ng lj nh ln ni lr mb mc md me bi translated">可选<string/></li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="99a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后是<code class="fe ls lt lu lv b">StringAdaptable</code>的一些变化。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="ed67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">属性包装器(<code class="fe ls lt lu lv b">StringValue</code> ) <strong class="ky ir"> </strong>中的泛型值必须是<code class="fe ls lt lu lv b">ExpressibleByString</code>和<code class="fe ls lt lu lv b">Decodable</code>的类型。类型约束用于强制包装可以处理的两种不同类型。</p><ul class=""><li id="706b" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><code class="fe ls lt lu lv b">String</code></li><li id="933c" class="lw lx iq ky b kz ne lc nf lf ng lj nh ln ni lr mb mc md me bi translated"><code class="fe ls lt lu lv b">Optional&lt;String&gt; aka String?</code></li></ul><p id="ac01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，下面的代码没有显示任何编译错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="fbc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但令人惊讶的是，还是没有效果。在解析过程中，一个空值程序抛出一个错误。它看起来是这样的:</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="ea6e" class="nj mg iq lv b gy nz oa l ob oc">keyNotFound(CodingKeys(stringValue: "albumId", intValue: nil), Swift.DecodingError.Context(codingPath: [], debugDescription: "No value associated with key CodingKeys(stringValue: \"albumId\", intValue: nil) (\"albumId\").", underlyingError: nil))</span></pre><h1 id="8727" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">了解合成器</h1><p id="d023" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">为了找到错误的解决方案，理解Decodable在幕后是如何工作的是很好的。当某个物体符合它时会发生什么？</p><p id="a0e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从合成器如何工作的基本知识开始:</p><ul class=""><li id="3fcc" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">第一步是生成<code class="fe ls lt lu lv b">CodingKeys</code>，如果它们还不存在的话。</li><li id="aec2" class="lw lx iq ky b kz ne lc nf lf ng lj nh ln ni lr mb mc md me bi translated">第二个是生成<code class="fe ls lt lu lv b">init(from: Decoder)</code>，如果它还不存在的话。</li><li id="b0e7" class="lw lx iq ky b kz ne lc nf lf ng lj nh ln ni lr mb mc md me bi translated">第三是翻译属性包装器，如果它们存在的话。</li></ul><p id="de94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一步非常简单，可能错误并不隐藏在其中。</p><p id="4452" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仔细看看第二步。在构造函数初始化之前，必须将属性包装转换为有效的类型。例如，以下属性:</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="2596" class="nj mg iq lv b gy nz oa l ob oc">@StringAdaptable var albumId: String?</span></pre><p id="e666" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">被翻译成</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="2229" class="nj mg iq lv b gy nz oa l ob oc">var albumId: StringAdaptable&lt;String?&gt;</span></pre><p id="ded8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能会令人困惑，也是为什么以前的代码版本不能正确解码带有可选值的JSON。我首先想到的是，可选值将被转换为:</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="57f1" class="nj mg iq lv b gy nz oa l ob oc">var albumId: StringAdaptable&lt;String&gt;?</span></pre><p id="1406" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是一个可解码的合成器不是这样工作的。</p><h1 id="4d20" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">跳转到KeyedDecodingContainer</h1><p id="a70a" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">每种被解码的类型都使用一个类<code class="fe ls lt lu lv b">KeyedDecodingContainer</code>。</p><ul class=""><li id="89b6" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><a class="ae kv" href="https://developer.apple.com/documentation/swift/keyeddecodingcontainer" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/documentation/swift/keyeddecoding container</a></li></ul><p id="468e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了正确解码<code class="fe ls lt lu lv b">@StringAdaptable</code>,必须扩展<code class="fe ls lt lu lv b">KeyedDecodingContainer</code>。它必须支持<code class="fe ls lt lu lv b">StringAdaptable&lt;String&gt;</code>和<code class="fe ls lt lu lv b">StringAdaptable&lt;String?&gt;</code>类型，允许可选和非可选值从JSON准确地转换为预期的变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="77e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一个值出现在给定的JSON中，它将被解析并返回一个给定值。否则，它返回用nil初始化的<code class="fe ls lt lu lv b">StringAdaptable</code>，在代码执行过程中将被nil替换。</p><h1 id="3d7f" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">完整代码</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="c765" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">包裹</h1><p id="8e3f" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Decodable</code>大部分时候就是管用。在引擎盖下，它执行所有JSON编码/解码魔术。但有时，当出现特殊要求时，最好记住，即使在代码执行期间解码有效，在编译之前还有一个额外的步骤:合成。</p><p id="c914" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使带有值的结构简单明了，编译器也会生成许多样板文件来确保程序正确执行。</p><p id="0e29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样。</p><p id="2a22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！敬请关注更多内容。</p></div></div>    
</body>
</html>