<html>
<head>
<title>The Case for pnpm Over npm or Yarn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">pnpm优于npm或Yarn的情况</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-case-for-pnpm-over-npm-or-yarn-2b221607119?source=collection_archive---------2-----------------------#2020-03-19">https://betterprogramming.pub/the-case-for-pnpm-over-npm-or-yarn-2b221607119?source=collection_archive---------2-----------------------#2020-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a7f4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解这个鲜为人知的JavaScript包管理器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5b4323d4b04561c035c2a6c960d48bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ZwobpKb_RVWMkt38Dl3bg.png"/></div></div></figure><p id="6d8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://pnpm.js.org/" rel="noopener ugc nofollow" target="_blank"> pnpm </a>是JavaScript的一个包管理器，像<a class="ae lq" href="https://www.npmjs.com/package/npm" rel="noopener ugc nofollow" target="_blank"> npm </a>和<a class="ae lq" href="https://www.npmjs.com/package/yarn" rel="noopener ugc nofollow" target="_blank"> yarn </a>。我个人觉得pnpm不太为人所知。根据<a class="ae lq" href="https://github.com/pnpm/pnpm" rel="noopener ugc nofollow" target="_blank">资源库</a>中的自述文件，pnpm是:</p><blockquote class="lr ls lt"><p id="899c" class="ku kv lu kw b kx ky ju kz la lb jx lc lv le lf lg lw li lj lk lx lm ln lo lp im bi translated">快速。像npm和Yarn一样快。</p><p id="35df" class="ku kv lu kw b kx ky ju kz la lb jx lc lv le lf lg lw li lj lk lx lm ln lo lp im bi translated">高效。包的一个版本在磁盘上只保存一次。</p><p id="668c" class="ku kv lu kw b kx ky ju kz la lb jx lc lv le lf lg lw li lj lk lx lm ln lo lp im bi translated">对monorepos 来说很棒。</p><p id="dc8c" class="ku kv lu kw b kx ky ju kz la lb jx lc lv le lf lg lw li lj lk lx lm ln lo lp im bi translated">严格。一个包只能访问在其<code class="fe ly lz ma mb b">package.json</code>中指定的依赖项。</p><p id="3641" class="ku kv lu kw b kx ky ju kz la lb jx lc lv le lf lg lw li lj lk lx lm ln lo lp im bi translated">确定性。有一个名为<code class="fe ly lz ma mb b">pnpm-lock.yaml</code>的锁文件。</p><p id="580b" class="ku kv lu kw b kx ky ju kz la lb jx lc lv le lf lg lw li lj lk lx lm ln lo lp im bi translated">适用于任何地方。可在Windows、Linux和OS X上运行。</p></blockquote><p id="7dc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章分享了我将包含60多个包的monorepo(由Yarn workspace + Lerna管理)迁移到pnpm的一些心得。为了更好地理解为什么pnpm是您项目的好解决方案，让我们从一个测验开始。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="e18a" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">恶作剧</h1><p id="8480" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">假设您正在开始一个新的JavaScript项目。像大多数人一样，您用npm或Yarn安装您的依赖项。让我们用npm <strong class="kw iu"> </strong>来做这个例子。您的项目需要快递，因此您需要:</p><pre class="kj kk kl km gt ng mb nh ni aw nj bi"><span id="0364" class="nk mk it mb b gy nl nm l nn no">npm install -g express</span></pre><p id="1260" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">依赖项已安装！</p><p id="6c06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设Express <strong class="kw iu"> </strong>有一个依赖包叫做<code class="fe ly lz ma mb b">debug</code>。</p><p id="47aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你的<code class="fe ly lz ma mb b">node_modules</code>现在怎么样了？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/025e76dd57e15dd1ac47f64177f29287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K9cvzKA7GTmOrXPiMv2yvg.png"/></div></div></figure><p id="8dbb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">试着思考几秒钟…</p><p id="6db2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi">.</p><p id="ae5e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi">.</p><p id="cab9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi">.</p><p id="06a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi">.</p><p id="0ff8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi">.</p><p id="a180" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完成了吗？</p><p id="5855" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您回答了A，您可能会认为这就是依赖关系应该如何工作。</p><p id="5cd2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是如果你用npm或者Yarn来尝试，你会发现实际答案是B，这是一个问题。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="c117" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">为什么这是个问题？</h1><p id="4774" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">有了B中所示的结构，我们的代码现在可以<code class="fe ly lz ma mb b">require('debug')</code>，尽管在我们的<code class="fe ly lz ma mb b">package.json</code>中我们并不明确依赖它。</p><p id="0b28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想想如果发生以下情况会发生什么:</p><ol class=""><li id="7d4f" class="nq nr it kw b kx ky la lb ld ns lh nt ll nu lp nv nw nx ny bi translated">Express使用重大变更更新其<code class="fe ly lz ma mb b">debug</code>依赖关系。</li><li id="8238" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp nv nw nx ny bi translated">Express决定不再依赖<code class="fe ly lz ma mb b">debug</code>。</li></ol><p id="ad59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这两种情况下，我们的代码都将失败，因为它对<code class="fe ly lz ma mb b">debug</code>有一个隐式的依赖。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/3ad90ca35311c1f74eb7b9b7d5a33a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*l2Cpl9NCywDjn3j7VU5USQ.png"/></div><p class="of og gj gh gi oh oi bd b be z dk translated"><em class="oj">校正</em>结构</p></figure><p id="af9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在正确的结构中，我们的代码永远不会访问<code class="fe ly lz ma mb b">debug</code>。这是因为Node.js在<code class="fe ly lz ma mb b">node_modules</code>中查找内容的方式。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="baa0" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">那为什么<code class="fe ly lz ma mb b">npm</code>决定这么做呢？</h1><p id="4786" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">npm实际上在npm3之前实现了上面的结构A，但是它有一些问题。</p><h2 id="10e8" class="nk mk it bd ml ok ol dn mp om on dp mt ld oo op mv lh oq or mx ll os ot mz ou bi translated"><strong class="ak">重复</strong></h2><p id="fb2c" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">如果我们添加<code class="fe ly lz ma mb b">debug</code>作为我们的项目依赖，我们可能会有两个不同的<code class="fe ly lz ma mb b">debug</code>副本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/6215c317738e81ed59d5ec6acb3c37cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*x_sDFtGXysvn5eQmmfHjdg.png"/></div><p class="of og gj gh gi oh oi bd b be z dk translated">“调试”模块被复制</p></figure><p id="fbcc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这方面的问题:</p><ul class=""><li id="9e95" class="nq nr it kw b kx ky la lb ld ns lh nt ll nu lp ow nw nx ny bi translated">我们磁盘中的副本</li><li id="11a4" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp ow nw nx ny bi translated">我们的包中可能有重复项</li><li id="3d60" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp ow nw nx ny bi translated">当存在重复时，一些包会被破坏(例如，React)</li></ul><h2 id="e929" class="nk mk it bd ml ok ol dn mp om on dp mt ld oo op mv lh oq or mx ll os ot mz ou bi translated"><strong class="ak">长嵌套目录</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/50733d377f294486d71b8a5b5de49d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*D1odDwBsm_g2bGC50NOSUw.png"/></div><p class="of og gj gh gi oh oi bd b be z dk translated">嵌套目录地狱</p></figure><p id="594a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有些操作系统不能很好地处理长目录。</p><p id="3bbe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从版本3开始，npm开始使用扁平化<code class="fe ly lz ma mb b">node_modules</code>。<em class="lu"> </em>你可以在这里阅读更多关于这个<a class="ae lq" href="https://npm.github.io/how-npm-works-docs/npm3/how-npm3-works.html" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/dc8851c141e3eb46a3656f6aaa38cb56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3d5HmlM1pBrtegbJCQrpQ.png"/></div></div><p class="of og gj gh gi oh oi bd b be z dk translated">扁平的“节点模块”</p></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="9a81" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">为什么这是个问题？(续)</h1><p id="fab9" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">我们已经知道拥有隐式依赖是不理想的。如果你从事的是规模可观的单边回购，那么问题就更严重了。跟踪一个项目实际使用的依赖项的来源会更加困难。</p><p id="4e73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">重复也是一个问题。尽管Yarn确实<a class="ae lq" href="https://classic.yarnpkg.com/blog/2017/08/02/introducing-workspaces/" rel="noopener ugc nofollow" target="_blank">提升了</a>以优化磁盘空间的使用，但在某些情况下<a class="ae lq" href="https://github.com/yarnpkg/yarn/issues/7572" rel="noopener ugc nofollow" target="_blank">会意外失败</a>。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="04e4" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">pnpm如何解决这些</strong></h1><p id="2410" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">pnpm使用<a class="ae lq" href="https://en.wikipedia.org/wiki/Hard_link" rel="noopener ugc nofollow" target="_blank">硬链接</a>和<a class="ae lq" href="https://en.wikipedia.org/wiki/Symbolic_link" rel="noopener ugc nofollow" target="_blank">符号链接</a>来实现一个半严格的<code class="fe ly lz ma mb b">node_modules</code>结构，并确保一个模块只有一个版本保存在磁盘上。</p><p id="f7e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们在项目中执行<code class="fe ly lz ma mb b">pnpm install express</code>。这就是我们的<code class="fe ly lz ma mb b">node_modules</code>的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/9d1706e7fcd28459d9f9a5ae05321e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*5gSA0qYjNYiz1Ywe1K2yxA.png"/></div><p class="of og gj gh gi oh oi bd b be z dk translated">pnpm的节点模块结构</p></figure><p id="a25f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，我们的代码无法访问<code class="fe ly lz ma mb b">debug</code>，因为它不在根目录<code class="fe ly lz ma mb b">node_modules</code>下。</p><p id="4d6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">pnpm创建一个特殊的<code class="fe ly lz ma mb b">.pnpm</code>目录，包含所有模块的硬链接。在<code class="fe ly lz ma mb b">express/4.0.0</code>下，有<code class="fe ly lz ma mb b">express</code>模块，它是到全局<code class="fe ly lz ma mb b">pnpm-store</code>的硬链接，还有一个<code class="fe ly lz ma mb b">debug</code>符号链接到<code class="fe ly lz ma mb b">debug</code>硬链接，它也链接到全局<code class="fe ly lz ma mb b">pnpm-store</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/2a032c7c72b3dd39864dd88188944867.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*i1hRMcKk11ACFa1gUL857g.png"/></div><p class="of og gj gh gi oh oi bd b be z dk translated">全球“pnpm商店”</p></figure><p id="2688" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">全局<code class="fe ly lz ma mb b">pnpm-store</code>的结构大致相似。我们使用pnpm安装的实际包存储在这里。一般保存在<code class="fe ly lz ma mb b">~/.pnpm-store</code>下。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="024a" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">嗯，它对npm注册表上的每个包都有效吗？</h1><p id="e0a5" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">不幸的是，如果您从Yarn/npm迁移到pnpm，有些包可能无法工作。大多数情况下，这是由于包的<code class="fe ly lz ma mb b">package.json</code>文件中缺少依赖项造成的。</p><p id="4570" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们以<a class="ae lq" href="https://github.com/Leonard-Li777/antd-table-infinity" rel="noopener ugc nofollow" target="_blank"> antd-table-infinity、</a>为例。这个包不依赖于<code class="fe ly lz ma mb b">antd</code>，但是有一些<a class="ae lq" href="https://github.com/Leonard-Li777/antd-table-infinity/blob/d479e49f36dce40dc07dc150be77041cdcc853ea/src/pages/SumTable.js#L1" rel="noopener ugc nofollow" target="_blank">从</a> <code class="fe ly lz ma mb b"><a class="ae lq" href="https://github.com/Leonard-Li777/antd-table-infinity/blob/d479e49f36dce40dc07dc150be77041cdcc853ea/src/pages/SumTable.js#L1" rel="noopener ugc nofollow" target="_blank">antd</a></code>导入的代码。这个包在发布之前也没有捆绑<code class="fe ly lz ma mb b">antd</code>。在大多数情况下，当你使用这个包时，你可能已经安装了<code class="fe ly lz ma mb b">antd</code>。然后，扁平的<code class="fe ly lz ma mb b">node_modules</code>结构允许这个包找到<code class="fe ly lz ma mb b">antd</code>。有了pnpm，这个包就再也找不到<code class="fe ly lz ma mb b">antd</code>了，并且会失败。</p><p id="a554" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">幸运的是，pnpm提供了<a class="ae lq" href="https://pnpm.js.org/en/3.6/hooks" rel="noopener ugc nofollow" target="_blank">钩子</a>，所以我们可以在我们这边解决这种问题。我们可以使用这个简单的钩子手动添加<code class="fe ly lz ma mb b">antd</code>作为<code class="fe ly lz ma mb b">antd-table-infinity</code>的<code class="fe ly lz ma mb b">peerDependency</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div><p class="of og gj gh gi oh oi bd b be z dk translated">简单的“pnpmfile.js”挂钩</p></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="9c2b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">pnpm对我们有什么好处？</h1><p id="ee63" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">在我看来，pnpm的两个主要好处是:</p><h2 id="8ab1" class="nk mk it bd ml ok ol dn mp om on dp mt ld oo op mv lh oq or mx ll os ot mz ou bi translated"><strong class="ak">无重复</strong></h2><ul class=""><li id="51e9" class="nq nr it kw b kx nb la nc ld pd lh pe ll pf lp ow nw nx ny bi translated">您的计算机上只能有一个版本的包</li><li id="a8f4" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp ow nw nx ny bi translated">无论您的机器上有多少JS项目，都可以节省磁盘空间</li><li id="daf4" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp ow nw nx ny bi translated">不再有重复反应的问题</li></ul><h2 id="e1b3" class="nk mk it bd ml ok ol dn mp om on dp mt ld oo op mv lh oq or mx ll os ot mz ou bi translated">严格的</h2><ul class=""><li id="4a67" class="nq nr it kw b kx nb la nc ld pd lh pe ll pf lp ow nw nx ny bi translated">没有对非依赖性的意外访问</li><li id="fd68" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp ow nw nx ny bi translated">更稳定、更一致、更可预测</li><li id="1d2a" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp ow nw nx ny bi translated"><a class="ae lq" href="https://medium.com/pnpm/pnpms-strictness-helps-to-avoid-silly-bugs-9a15fb306308" rel="noopener">避开愚蠢的虫子</a></li></ul><p id="af0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">没有副本意味着无论你的机器中有多少依赖于，比如说，电子的项目，你的机器上只有一个电子版本的副本。<a class="ae lq" href="https://pnpm.js.org/en/workspaces" rel="noopener ugc nofollow" target="_blank">它对monorepos </a>也很有效。没有重复有助于减少磁盘上的monorepo的大小。这种严格性有助于尽早发现难以理解的错误。</p><p id="fa5e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你把你的项目从npm或者Yarn转移到pnpm，你可能会发现一些<code class="fe ly lz ma mb b">unable to resolve module "some-module"</code>错误。您的项目以前可能因为扁平化的<code class="fe ly lz ma mb b">node_modules</code>结构而工作，但是在更严格的结构下会失败——如果您的目标是长期可维护性，这是一件好事！</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="46f2" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">总结</strong></h1><p id="e4df" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">总而言之，pnpm是严格的，它帮助我们节省磁盘空间。这种严格性使得事情更容易预测，并且更早地发现错误。这对你来说是否重要取决于你自己。如果你正在与一个大规模的monorepo合作，我强烈推荐你去看看pnpm。</p><p id="28e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文只涵盖了pnpm必须提供的一些内容。希望你觉得有用！关于pnpm的更多资源可以在下面找到。如果你还没有通读，这是值得的。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="6a82" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">资源:</strong></h1><ul class=""><li id="abd3" class="nq nr it kw b kx nb la nc ld pd lh pe ll pf lp ow nw nx ny bi translated">pnpm的严格有助于避免愚蠢的错误</li><li id="aa14" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp ow nw nx ny bi translated"><a class="ae lq" href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html" rel="noopener ugc nofollow" target="_blank">“为什么要用pnpm？</a></li><li id="972a" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp ow nw nx ny bi translated"><a class="ae lq" href="https://medium.com/pnpm/flat-node-modules-is-not-the-only-way-d2e40f7296a3" rel="noopener">“扁平节点模块不是唯一的方式</a></li><li id="79f2" class="nq nr it kw b kx nz la oa ld ob lh oc ll od lp ow nw nx ny bi translated"><a class="ae lq" href="https://pnpm.js.org/en/faq" rel="noopener ugc nofollow" target="_blank">常见问题pnpm </a></li></ul></div></div>    
</body>
</html>