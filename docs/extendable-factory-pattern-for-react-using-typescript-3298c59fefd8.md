# 使用类型脚本反应可扩展工厂模式

> 原文：<https://betterprogramming.pub/extendable-factory-pattern-for-react-using-typescript-3298c59fefd8>

## 创建一个可扩展的工厂模式，允许模块的用户扩展你的工厂类

![](img/dac29dc99d1a3c2a9dfeed13875261ea.png)

首先，我想简单介绍一下工厂设计模式。当使用同一类型“事物”的不同类时，将这些类的实例化抽象到工厂类/函数中是很有用的。虽然这些工厂是由库/模块的开发者编写的，但是这些库的用户不能简单地添加或覆盖工厂使用的类。因此，我们需要一个简单的解决方案来允许最终开发人员扩展一个工厂类。为了实际解释这种模式，

我会使用 react 库`react-chat-module`，可以在这里找到[。这种教程当然可以移植到其他支持反射的编程语言(C#，Java，…)，见最后 C#中的例子。](https://github.com/mbpictures/react-chat-module)

# 用例

如前所述，我将使用库[**react-chat-library**](https://github.com/mbpictures/react-chat-module)来解释这个想法。这个库允许开发人员在自己的 react 应用程序中只使用一个组件就能实现简单灵活的聊天。

像许多其他聊天或消息应用程序一样，它支持多种类型的消息(文本、音频、视频、图像等)。

为了实现这些不同的消息类型，创建了`MessageFactory`**，*来实例化正确的消息类型。例如，这个工厂可能看起来像这样:*

*不要担心，我们将在几分钟内清理这段代码，但是您可以看到，react 组件是根据`MessageType`返回的。*

*`MessageType` 表示支持的消息类型的联合类型(在本例中为`typing`、`text`、`image`、`video`、`audio`和`file`、*、*)。*

*除了`typing` 和`text` 之外的所有消息也可以有文本消息(例如图像的标签)，然后这两种消息类型被组合在一个子元素中。*

*除了静态方法，您还可以将工厂实现为一个功能组件，这样您就可以像其他组件一样简化它。正如您所看到的，消息的类型是使用 union 类型的强类型，但是不能被库的用户扩展。*

*为了解决这个问题，我们面临两个不同的子问题:如何扩展联合类型和如何传递额外的类，这些类应该由工厂实例化或覆盖？*

# *扩大联合类型*

*为了扩展模块中声明的类型，TypeScript 有一个称为[模块扩充](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)的特性。唯一的问题是，联合类型不能被扩充或合并。为了解决这个问题，我们可以定义一个接口，从中生成我们的联合类型:*

*`MessageType` 的初始值和前面的例子一样，只是我们使用接口生成它。*

*有了这个设置，我们现在可以在另一个模块中增加`MessageType`接口(例如，在我们的应用程序中，当我们想要嵌入组件时):*

*这将向我们的联合类型添加一个新的类型*“test”*，并且我们可以在我们的 *ChatMessage* 接口中将它添加为一个类型。*

# *扩建工厂*

*现在是时候开始棘手的部分了:扩展我们的工厂以提供类覆盖或添加。首先，我创建了一个类型作为 prop 添加，在这里可以定义新的或重写的工厂类:*

*界面中的`hasText` 元素与应用高度相关，因此对于您的任务来说可能是不必要的。*

*正如您所看到的，我定义了一个记录，它由一个字符串(新类型的标识符，在本例中为`MessageType` )和 react 组件组成，react 组件应该被用来代替或附加(这也适用于另一种类，而不是仅适用于 react)。*

*然后我们可以添加一个函数类型，这将创建工厂类的实例:*

*之后，我们必须添加两个(箭头)函数:第一个创建动态工厂实例，第二个创建预定义的实例。这些函数可能如下所示:*

*在动态工厂实例化的函数中可以看到，我们首先检查所提供的`MessageType` 是否存在于所提供的自定义工厂的对象中，如果不存在*则返回 null* 。*

*如果给定类型有一个定制的工厂类，我们使用`React.createElement`创建所提供组件的一个实例(这也适用于“普通”类和反射，更多信息见[。](https://stackoverflow.com/a/15339429)*

*在创建预定义工厂类实例的函数中，主要代码保持不变，只是所有代码路径都返回一个由组件和是否添加文本组件组成的对象。*

*在函数的末尾，我添加了一个调试警告，当用户添加了一个自定义类型的消息，但没有定义工厂类时，就会显示这个警告。我们可以在功能组件`MessageType` 中组合这两个功能，如下所示:*

*如您所见，我们首先调用定制工厂类的函数，以实现覆盖功能。*

*对于添加文本消息，我使用了对同一组件的递归调用，如果组件类型支持文本(在 return 或`CustomFactory` 对象中定义),就会添加该组件，这对于您的用例来说可能已经过时了。*

# *打扫*

*最后一件事，我们想做的，是摆脱这种非常丑陋的如果级联。为此，我们添加一个类型为`CustomFactories` 的对象，并分配我们所有的默认工厂类，然后我们可以删除函数`CreateFactoryInstance` ，取而代之的是，用我们默认类的合并对象和`overrideFactory` 对象调用`CreateDynamicFactoryInstance`，如下所示:*

# *如何扩建工厂*

*要使用组件并扩展工厂，您可以这样做:*

*就是这样！现在，您可以使用工厂设计模式创建库或包，并且可以让模块的用户有机会扩展或覆盖您实现的库。*

# *C#中的示例*

*要在 C#中实现给定示例的类似解决方案，我们可以使用这样的类:*

*在这个例子中，我们有几乎与 TypeScript 版本相同的起点。我们得到了许多不同的`Message` (在本例中只有`MessageImage` 和`MessageVideo`)实现，并希望基于我们想要创建的消息类型创建一个动态实例。*

*主类`Factory`包含一个公共成员`DefaultFactories`，它通过存储类型引用包含默认的工厂类规范(在本例中，创建一个`MessageImage` 或`MessageVideo` 对象)。在`Factory`的构造器中，最终用户有可能提供一个带有附加或替换类引用的字典。*

*考虑到我们的条件，即定制工厂类总是具有更高的优先级，为了得到一个实例，我们合并了两个字典，但是首先，删除`DefaultFactories` 的所有键，它们也在`additionalFactories`中提供。*

*之后，我们可以检查是否可以实例化所提供的类型(如果不能，抛出一个异常)并创建一个实例，我们可以返回该实例。*