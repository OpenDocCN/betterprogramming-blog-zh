<html>
<head>
<title>9 Ways to Boost Your Swift Code Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高Swift代码性能的9种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/9-ways-to-boost-your-swift-code-performance-56e0986dd9ec?source=collection_archive---------2-----------------------#2019-08-05">https://betterprogramming.pub/9-ways-to-boost-your-swift-code-performance-56e0986dd9ec?source=collection_archive---------2-----------------------#2019-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d366" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">挤压雨燕提高速度的一些技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/39e45200cc61f448c8df30d5b6a6f887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xa2BS9HB9cgeqNnlzumBvA.jpeg"/></div></div></figure><h1 id="444c" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak">重要提示</strong></h1><p id="3ddc" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Swift是一种快速语言，并且在每个版本中都变得更快。iOS设备也很快，所以很可能根本不需要这些提示。即使在我们遇到性能问题的情况下，最好的做法是使用缓存、后台线程或任何其他技术来绕过它们。</p><p id="2782" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">但是当处理大数字、慢设备或者仅仅为了理论，知道这些提示不会伤害你。</p><h1 id="f4e1" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak">在构建设置中设置优化级别</strong></h1><p id="dd3b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">优化代码的第一件事是让Xcode自己优化代码。Xcode编译器足够聪明，知道何时可以忽略无用的函数结果，或者直接调用没有子类化的方法，但这可能会带来额外的编译时间或大小的代价。</p><p id="12d8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">转到构建设置，并找到“Swift编译器—代码生成”部分。在那里，您可以找到“优化级别”设置，其中有三个选项:</p><ul class=""><li id="6b8b" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated">没有优化</li><li id="9d35" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">速度优化</li><li id="6c1f" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">尺寸优化</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/a091e3b729bec0c123a3f0f089b444e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kETljSv5oBVFqdMSKJsCZw.png"/></div></div></figure><p id="4d9f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">通常最好为发布版本设置“速度优化”，为调试设置“大小优化”，当然这取决于您的项目需求。</p><p id="4291" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">基本上，如果你需要的是有利于尺寸的动力，那就把优化级别设置为“优化速度”。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="862d" class="ku kv it bd kw kx nj kz la lb nk ld le jz nl ka lg kc nm kd li kf nn kg lk ll bi translated"><strong class="ak">对方法和类使用“Final”和“Private”</strong></h1><p id="95b4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Swift优化级别处理的事情之一是直接或间接调用方法。您可能知道，Swift是一种面向对象的语言，这意味着您可以子类化和覆盖方法来扩展功能。为了让它工作，Swift使用了一种叫做动态调度的东西。</p><p id="efcc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">动态调度是一种算法，它决定每当向对象发送消息时应该调用哪个方法。它使用一个“虚拟表”。</p><p id="2df7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">每当一个对象被请求返回方法地址时，它就在虚拟表中搜索它的地址。这不是一个显而易见的动作——记住，它需要查找一个子类，看看这个方法是否被覆盖，然后返回这个方法。这个方法也可以被另一个子类覆盖，所以它需要一次又一次地这样做，直到到达它的底部。为了帮助Swift优化这项昂贵的任务，您可以在方法、变量甚至整个类的开头添加属性“final”。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="89e0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当您选择在构建设置中优化swift代码时,“final”属性将确保对方法的调用是直接的，而不需要寻找子类实现。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="7a22" class="ku kv it bd kw kx nj kz la lb nk ld le jz nl ka lg kc nm kd li kf nn kg lk ll bi translated"><strong class="ak">在发布版本中避免“打印”</strong></h1><p id="09a2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">打印到控制台对于调试来说很好，但是开发人员有时有一个坏习惯，就是让打印命令在代码中到处浮动。由于打印命令被写入控制台，并且利用了磁盘，这似乎是一个非常昂贵的I/O操作。有多贵？非常。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ca3e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">使用“print”调用的测试运行速度慢了1600倍！</p><p id="2f70" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我的建议是永远不要直接调用" print ",而是用某个类来包装它，并在那个类中添加一个宏，这样你就永远不会忘记那些" print "命令了！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="ae2b" class="ku kv it bd kw kx nj kz la lb nk ld le jz nl ka lg kc nm kd li kf nn kg lk ll bi translated"><strong class="ak">“内联”您的代码</strong></h1><p id="f0e2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">创建小函数始终是最佳实践，每个函数都致力于一项任务。但是将您的代码分成小函数也会带来性能成本——您向堆栈中添加了另一个函数，并且您迫使Swift使用虚拟表来动态调度您的调用。当你想压缩你的代码以获得更高的性能时，你可以放弃你的代码，而“内联”你的方法，这样会更快。同样，这是干净代码和性能之间的权衡。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="d74a" class="ku kv it bd kw kx nj kz la lb nk ld le jz nl ka lg kc nm kd li kf nn kg lk ll bi translated"><strong class="ak">处理阵列</strong></h1><p id="e953" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">大量的性能优化主要是在处理大量的迭代，或者换句话说，数组的时候。</p><p id="ef4f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果您知道数组是如何构建的，并且知道其中的利弊，那么您可以对代码进行额外的优化。</p><p id="6cfe" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下面是一些用数组优化代码的例子:</p><h2 id="bf81" class="nq kv it bd kw nr ns dn la nt nu dp le lv nv nw lg lz nx ny li md nz oa lk ob bi translated"><strong class="ak">迭代数组</strong>时使用“withUnsafeBufferPointer”</h2><p id="428f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">当处理Swift对象时，我们有时会忘记内存问题或安全性，因为Swift正在为我们处理一切。这是以性能为代价的。如果想用安全换取性能，可以使用“withUnsafeBufferPointer”方法来获取数组元素的指针数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="dc88" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">但是您应该小心—如果由于某种原因这些元素被释放，那么当您在代码中处理它时可能会崩溃。</p><h1 id="b54d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak">连续数组</strong></h1><p id="e0af" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这是一种不太熟悉的数组类型，但是当您知道如何利用它时，它会很方便。</p><p id="448a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一般来说，数组将它们的对象保存在内存块中，不一定是连续的。这意味着每当你向数组中添加一个新项时，它都会找到一个空闲块，分配它并将其添加到数组中。这对于提高性能很有帮助，但是对于迭代来说效率较低。所以，如果这是一个你知道要迭代的大数组，ContiguousArray可以是一个解决方案。</p><p id="3d8e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">ContiguousArray确保数组中的所有项彼此相邻。这对寻找下一个元素非常有帮助。但是，像往常一样，我们正在处理一个权衡——这里没有魔法。实际使用ContiguousArray，说我们正在为数组管理添加约束，插入或追加之类的简单操作现在可能会更重。我们现在强制其所有元素都是连续的，所以这取决于您的用例。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="0b4b" class="ku kv it bd kw kx nj kz la lb nk ld le jz nl ka lg kc nm kd li kf nn kg lk ll bi translated"><strong class="ak">在数组</strong>中使用值(结构)而不是引用(类)</h1><p id="1bea" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这是另一个很棒的技巧。您可能知道数组可以桥接到NSArray。NSArray只能保存对象，Array可以保存对象(引用)和值。</p><p id="5033" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当Swift中的数组包含引用时，它会自动获取NSArray的属性，因此无法进行优化。但是，如果您只在数组中保留诸如Int或Structs之类的值，编译器可以很容易地对其进行优化。</p><p id="72bc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果您必须在结构和类之间做出选择，这是结构的一大优势——在数组中保存结构比保存类要有效得多。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1b4c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在上面的例子中，填充结构数组的动作快了四倍！</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="58eb" class="ku kv it bd kw kx nj kz la lb nk ld le jz nl ka lg kc nm kd li kf nn kg lk ll bi translated"><strong class="ak">用链表代替数组</strong></h1><p id="c2b4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">数组使用起来很简单，但是在某些情况下链表会更有效。由于链表只是指向彼此的项目，所以在列表中间插入一个项目非常容易——只需正确连接指针就可以了。在阵列中，成本可能会更高。所以，无论何时你需要替换条目位置，追加等等，链表是非常快速的。另一方面，当你需要排序或查找时，数组比链表表现得更好。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="d221" class="ku kv it bd kw kx nj kz la lb nk ld le jz nl ka lg kc nm kd li kf nn kg lk ll bi translated"><strong class="ak">如果可能的话，将协议限制在类中。</strong></h1><p id="5f94" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果您知道您定义的协议仅用于类，请将其标记为类协议。当编译器知道该协议仅用于类时，它可以优化ARC(自动引用计数),使代码运行得更快。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="e582" class="ku kv it bd kw kx nj kz la lb nk ld le jz nl ka lg kc nm kd li kf nn kg lk ll bi translated"><strong class="ak">权衡表(或“优化价格表”)</strong></h1><p id="fca5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">没有什么是免费的，尤其是速度的提高，所以我在这里总结了上面的技巧，以及在项目中实现它们时需要付出的<em class="oc">代价:</em></p><ul class=""><li id="c32e" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated"><strong class="lo iu">构建设置中的优化级别:</strong>支付:构建规模</li><li id="30d7" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><strong class="lo iu">对方法和类使用“final”和“private”</strong>—支付:子类和分派的约束</li><li id="b388" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><strong class="lo iu">避免发布版本中的“打印”</strong> —付款:控制台无日志</li><li id="193e" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><strong class="lo iu">“内联”您的代码</strong> —付款:重复代码；代码不“干净”</li><li id="1124" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><strong class="lo iu">迭代数组时使用“withsunsafebufferpointer”</strong>—支付:安全</li><li id="8b7b" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><strong class="lo iu"> ContiguousArray </strong> —付款:追加可能会很慢</li><li id="4caa" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">在数组中使用值(结构)而不是引用(类)——支付:取决于你的结构——可以是堆内存</li><li id="43b4" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><strong class="lo iu">使用链表代替数组</strong> —支付:集合分类方法可能很慢，比如排序或查找</li><li id="04cf" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><strong class="lo iu">仅在可能的情况下将协议限制在类别中</strong>。—支付:如题所言—这里有约束。</li></ul></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="4957" class="ku kv it bd kw kx nj kz la lb nk ld le jz nl ka lg kc nm kd li kf nn kg lk ll bi translated"><strong class="ak">总结</strong></h1><p id="03ad" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">正如我在开始时所说的，许多性能问题可以通过使用不同的应用程序架构技术、缓存或任何其他算法方法来解决。</p><p id="2607" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">但是知道如何挤压你的快速引擎以获得最大速度总是好的。</p></div></div>    
</body>
</html>