# 考虑在 React 中使用 console.log

> 原文：<https://betterprogramming.pub/thinking-about-console-log-usage-in-react-1196088b7d9f>

## *更好地使用这一基础开发工具的策略*

![](img/3c3eb15e24cd6e37305df018841cce10.png)

图片来源:defensesystems.com

你是那些过度热情的`console.log`用户之一吗？您是否发现当您打开控制台加载页面时，您收到的基本上是短消息形式的伊利亚特，每条消息都描述了组件的各种属性/状态？

如果你和我一样，有时候你只是想知道你当时组件的一切。很容易忘记谁拥有什么道具，以及这些道具的价值可能是什么，这取决于事件侦听器、父组件等等。国家也是如此。状态的变化在页面上并不总是显而易见的，如果没有很好地利用向控制台发送消息，您可能会发现自己迷失在逻辑中。

然而，你可能倾向于过多地使用`console.log`。当你的组件渲染时，或者道具/状态改变时，这就像地狱一样。最终，当你打开检查器时，你会看到一篇简短的信息小说在等着你。在这一点上，你弊大于利。有各种方法可以解决这个很大程度上是自我强加的问题。

在这篇文章中，我将讨论四种方法，作为开发人员，我们可以改进和规划我们对这段有价值但经常被过度使用的代码的使用。我们将涉及下面描述的每种方法:

1.  撰写具体而简洁的信息
2.  利用`debugger`或`alert`作为替代品
3.  使用组件/常量有选择地打印消息
4.  决定消息的必要性(创建和删除)

通过利用这些策略，您将能够决定何时何地将消息打印到控制台，并确保这些问题的内容是高质量的。

# 1.撰写具体而简洁的信息

我可以保证，如果你的消息太长，参与你项目的开发人员不会对你满意，最终你自己也不会满意。同样的逻辑也适用于内容没有意义或含糊不清的信息。

## 保持简短和甜蜜

没有人愿意在一条控制台消息中阅读一本小说。虽然这个规则也有例外(比如记录组件的属性、从 fetch 接收的数据等。)，通常有补救的方法，在这里的其他策略中有描述。你应该让你的陈述简明扼要。

不要做的一个例子是编写如下消息:

*"示例组件正在渲染。其道具如下:“*

*“示例按钮 1 被点击。这将改变 ExampleComponent 的已解析状态。这意味着在下一次渲染时，将出现逻辑 X，我们应该会看到 ExampleComponent2 添加到了正文中。*

## 第一条消息只需要整理一下

第一条信息并不可怕，但可以缩短。类似于 *"ExampleComponent rendered，props:"* 更简洁，表达了同样的意思。

当涉及到关于组件的消息时，我发现在消息中显式地声明组件的名称很有帮助。

例如，如果你在一个容器中有一个组件，而你的消息只是这个嵌套组件的道具，那对你来说就没什么帮助了。因为它们是道具，所以它们的值将与父组件相似，特别是如果您选择不区分道具的名称。

你最终会混淆什么属于什么，这可能会导致你走上解决一个根本不存在的问题的道路。通过在你的信息中具体化来完全避免这种情况。

## 第二条信息应该完全重写

第二条消息是一场噩梦。对于我在各种代码中看到发布的(令人尴尬的是，写的)消息来说，这有点夸张，但这在很大程度上是一个*告诉，不要展示*的故事。

没有理由一直发布那么长的消息。首先，这么长的东西看着很讨厌。此外，如果你看到一个这样长度的条目被重复发布，它被忽略的可能性就越大。一篇商业写作博客上的简短文章——恰当地命名为“[被又大又糟糕的段落](https://www.businesswritingblog.com/business_writing/2008/01/the-big-bad-par.html)吓跑了”——对这一现象进行了更深入的探讨；长的连续文本令人烦恼，不利于传达整体信息。

第二条信息很具体，这很好，但有太多的事情需要解释清楚。你是说 A 意味着 B 将要发生，这会影响 C，但是直接说 A 正在发生不是更好吗？这条信息也假设得太多了。如果里面的一切都如其所述，那就太好了，但我们都太清楚，即使是最简单的逻辑也可能出错(有人漏掉了括号吗？)

对于第二条信息，有各种各样的补救措施。这听起来像是一个按钮被点击，状态将会改变，所以我们就这么说吧。

*"单击了示例按钮，将 state.resolved 更改为 true。"*

如果 ExampleButton 没有在其他地方被重用，那么我们已经可以假设被更改的状态是其容器的状态(在本例中是 ExampleComponent)。

其次，如果我们愿意，我们可以完全省略关于逻辑的部分。听起来好像如果 example component . state . resolved = = = true，那么将添加 ExampleComponent2。那就比较简单了，甚至可能不值一提。

最后，我们不希望消息预测我们的应用程序中会发生什么，我们希望知道实际发生了什么。如果要追加 ExampleComponent2，可以用几种不同的方式显示。如果它是某种类型的显式元素，您实际上不需要记录它被添加了——您应该在页面上看到它。如果元素更微妙，甚至根据它的用途几乎看不出来，我们应该有一个消息在它呈现时触发，这样我们就知道它做到了。

我意识到长篇大论地写一个长长的`console.log`条目的讽刺意味，我也意识到通过将这个信息分解成更小的片段，人们可能会说我人均创造了更多的片段。然而，考虑到这些额外的消息现在是有条件的——它们应该只在必要的时候出现，而不是像我们之前看到的那种庞大的文本。此外，如前所述，在这一点上，它们的必要性甚至可能没有实际意义。如果是这样的话，那么我们根本不需要它们。

# 2.利用调试器或警报替代 console.log

![](img/ceab6082518d7098cd07e2d65e4b1327.png)

考虑调试器或警报可能更适合信息检索(图片来源:Matt Cummings)

`debugger`和`alert`是开发人员可以用来显示特定数据的另外两个工具。虽然在这方面它们的使用更合适一些，但我相信它们不应该被忽视。

## 使用调试器逐步检查数据的值

`debugger`无论出于什么原因，当你只是想暂停一个进程时，这个功能非常有用。它停止了 JavaScript 的运行，让你可以访问当时正在进行的一切。

使用它的一个很好的例子是在一些长函数中。假设你的函数有多个参数或者定义了自己的变量，等等。当事情开始步入正轨时，最好停下来评估这些参数，而不是记录这些参数。

当这些参数/变量的值发生变化时，这具有双重价值。因为您可以使用`debugger`任意多次，所以您可以选择从哪里开始和停止一个进程。这允许您以渐进的格式评估数据的修改。它使得 bug 和错误更容易确定，而不仅仅是让函数自然运行，同时将各种东西打印到控制台上。

使用`debugger`可以大大减少你对`console.log`的使用，看你用在什么地方。当有很多事情正在进行，并且您想要在特定点分析事情时，它是理想的。因为你可以在这些时候调用`console.log`，你可以在你的应用程序运行的时候从打印中消除很多不必要的垃圾。

## 使用 alert 让您注意到某个特定的数据

用`alert`代替`console.log`更合适一些，但它仍然有它的用途。这对于向您显示错误消息或获取您希望暂时突出显示的一段数据的值非常有用。关于`alert`很酷的一点是，它在某种程度上有点像`debugger`——它会让你在继续使用页面之前确认一些事情。

也就是说，要决定在代码中的什么地方使用这种方法有点困难。您可以决定哪些内容足够重要，可以在页面上得到提醒。考虑到这一点，尝试将它用于您可能会错过但仍然希望以某种方式记录的数据是一个好主意。通过强迫自己去看警告，你忽略其内容的机会就少了。

就像`console.log`一样，如果你用得太多，你最终会让参与你项目的其他人和你自己都感到沮丧。尽量谨慎提醒，以防你真的需要提醒——或者我敢说，提醒*——你的应用程序中发生的重要信息或事件。*

# *3.使用组件/常量有选择地打印消息*

*![](img/cd008c95a6aa67893fcb9d3038e35e40.png)*

*Henrik dnnestad 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片*

*虽然在许多情况下，开发人员会在组件呈现后立即记录消息，但这可能会导致大量消息，尤其是在嵌套组件的实例中。如果您让每个组件在呈现时都发出一条消息，那么消息数量很容易失控。*

*在我最近申请的时候，我遇到了这种情况。这实际上是一个信息太多的问题，在发生无数次之后，我有了一个想法:为什么不做一个简单的按钮来管理我的`console.log`活动呢？一个带有事件监听器来发送消息的按钮是一个易于编码的解决方案。*

*在我们开始组装这个按钮之前，有一点很重要，那就是我把它主要用于状态和道具。虽然肯定还有其他事情可以使用这样的按钮，状态和道具消息是我的主要过剩问题。也就是说，这是一个很好的时机来看看你最常看到的信息，并以此为基础建立你的逻辑。*

*我们将讨论制作这个按钮的两种方法:通过一个组件，或者更快但更简单的利用常量的方法。*

## *为 console.log state/props 创建按钮组件*

*我不打算在这里详述组件的创建，因为我假设您已经知道如何做了。相反，让我们关注一下最终产品的外观:*

```
*<button onClick={() => showPropsOrState()}>Console.log props/state for {props.pCompName}</button>*
```

*我们创建一个按钮，它的`onClick`触发一个回调函数`showPropsOrState`。*

*我有一个 [repo](https://github.com/TimeSmash/metabutton/blob/master/MetaButton.js) 你可以在 GitHub 上看到用于创建这样一个组件的代码。我将在以后的文章中回顾它的创作；现在，只需认识到它可以接收组件的名称、状态或属性，然后根据给出的内容记录它们。*

*使用该按钮可以释放任何后续渲染中将要打印到控制台的内容。然而，您可能会发现自己不想被麻烦地构建自己的组件，即使它不会花费太多时间。在这种情况下，您可以浏览 React 库来找到您需要的组件(无耻的插件:像我的一样，一旦我使它正式)，或者做一些有点垃圾，但简单的事情。*

## *使用常量，但代码较少*

*在制作上面的组件之前，我给我的`constants.js`文件添加了一些功能，就像这个用来展示道具的:*

*我有一个展示组件状态的类似函数。然后，我们可以在各种组件中创建按钮元素，并利用这个函数作为它们的`onClick`回调。*

*这有几个缺点。首先，它实际上只对类组件有效，因为这就是我使用它的全部目的。其次，创建多个按钮元素做同样的事情一点也不枯燥——从 React 的库中创建或利用一个已经存在的组件不是更容易吗？*

*尽管如此，如果您想像这样将消息打印到控制台，导入常量会更容易、更快，但它们在很大程度上是一个补丁解决方案。试着利用更干燥、更灵活的代码来实现这一目的。*

# *4.确定必要的用法并消除不必要的消息*

*![](img/643de45bf06cb6a7e0d202c4c1368b60.png)*

*J. Kelly Brito 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片*

*从主观上来说，最后一种方法是所有方法中最简单的。然而，这种主观性是至关重要的——只有你能决定何时利用`console.log`,这也包括知道何时扔掉不再需要的信息。*

*在决定是否实现日志时，首先要考虑为什么要打印消息。例如，如果你有一个声明组件已安装的句子，探索一下你为什么关心它。在某些领域，知道什么样的生命周期方法正在发生以及何时发生可能是好的。然而，在其他情况下可能完全没有必要。对每个组件都这样做会造成一个巨大的、无组织的混乱。运用这种逻辑，如果你花一点时间考虑你的推理，而不是仅仅出于习惯去做一些事情，从长远来看，你可以为自己省去很多麻烦。*

*也就是说，总有一天有些信息不再需要。你可能已经解决了一个 bug，或者在某个时候获得了你需要的信息。之后，代码中会出现不必要的膨胀，这只会妨碍您的工作。*

*我能理解从你的代码中删除这些的恐惧，但是这段代码确实需要两秒钟才能打出来。如果你不确定是否应该完全去掉其中的一个，就把它注释掉，然后再评估它的用途。不过，这并不是说你应该延长摆脱它们的时间。在某些时候，你需要完全摆脱它们。*

# *结论*

*到本文的这一步，我们已经思考了各种简单的方法和策略，可以用来减少输出到控制台的消息数量。我们还讨论了如何提高这些消息的质量，以及它们的替代方案。在编写代码时请记住这些，并更好地利用这个简单但出色的开发工具。*