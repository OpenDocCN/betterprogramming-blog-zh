<html>
<head>
<title>Drawing Charts in iOS Before SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI之前在iOS中绘制图表</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/drawing-charts-in-ios-before-swiftui-9f95b8612607?source=collection_archive---------5-----------------------#2022-11-12">https://betterprogramming.pub/drawing-charts-in-ios-before-swiftui-9f95b8612607?source=collection_archive---------5-----------------------#2022-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b6d6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用UIKit实现折线图</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4bf99ac687ff8584797a2504222c96b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V5OcnYvCqT6ZEKB6PaWJWw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用craiyon.com生成的图像</p></figure><p id="1598" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们将了解在SwiftUI Charts于2022年推出之前，交互式线性图表是如何在iOS中实现的。</p><p id="a958" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们想象一个相当真实的场景，产品所有者要求您的团队创建一个极简线性图表，该图表将:</p><ul class=""><li id="fe8e" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">显示带有渐变的平滑曲线；</li><li id="0111" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">响应用户的手势在图形上交互显示数据；</li><li id="7cb1" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">当前值应标有垂直线，并显示在附加信息旁边的气泡中；</li><li id="5357" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">如果能在一个区域支持多个图表就好了；</li><li id="ae96" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">iOS和Android最终外观必须有最小的差别。</li></ul><p id="8cea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个相当冗长的解释，但试图形象化它，你会注意到你已经在不同版本的应用程序中多次看到它，如苹果的股票、银行或健身跟踪应用程序。</p><h1 id="f0d9" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">我们走吧</h1><p id="0980" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">每个产品开发都是从研究开始的，很容易发现没有必要重新发明轮子——已经有一个库可以满足我们的需求。它最初是为安卓系统编写的(<a class="ae nc" href="https://github.com/PhilJay/MPAndroidChart" rel="noopener ugc nofollow" target="_blank"> MPAndroidChart </a>作者<a class="ae nc" href="https://github.com/PhilJay" rel="noopener ugc nofollow" target="_blank">菲利普·贾霍达</a>)，它的iOS版本叫做<a class="ae nc" href="https://github.com/danielgindi/Charts" rel="noopener ugc nofollow" target="_blank">图表</a>(作者<a class="ae nc" href="https://github.com/danielgindi" rel="noopener ugc nofollow" target="_blank">丹尼尔·科恩·金迪</a>)</p><p id="c671" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在它的好处中，我想指出以下几点:</p><ul class=""><li id="6545" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">支持多种图表类型；</li><li id="f662" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">许多定制选项可用；</li><li id="0742" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">对应其安卓版长相；</li><li id="92ae" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">与CocoaPods，Carthage，SPM一起安装。</li></ul><p id="1d7c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了可视化最终的产品需求，我们需要以下面的小部件结束:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/b980d227865196d69b36cdd0c876a37c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/1*PSORDsMbp5mC-yt4DjIp-g.gif"/></div></figure><p id="09e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在单独的项目中尝试UI组件和第三方库是最舒服的。让我们创建一个空项目，并用您最喜欢的依赖项管理器安装图表。我更喜欢SPM，所有可用的选项都列在Github页面的<a class="ae nc" href="https://github.com/danielgindi/Charts" rel="noopener ugc nofollow" target="_blank">图表上</a>。</p><p id="8cd3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我不会描述创建项目的初始过程。如果您想获得项目的最终版本并与教程一起工作，可以在<a class="ae nc" href="https://github.com/stepanovgena/LinearChartDemo" rel="noopener ugc nofollow" target="_blank">我的GitHub页面</a>上找到。</p><p id="81c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，让我们创建一个非常基本的线性图表。它将帮助我们理解图表库的整体逻辑，最重要的是，为了达到预期的结果，需要改变什么。</p><p id="46e4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将以下代码添加到我们的视图控制器的<code class="fe ne nf ng nh b">viewDidLoad()</code>中(不要忘记文件头中的<code class="fe ne nf ng nh b">import Charts</code>)</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="66a4" class="nm mg iq nh b be nn no l np nq">override func viewDidLoad() {<br/>    super.viewDidLoad()<br/>    let lineChartEntries = [<br/>        ChartDataEntry(x: 1, y: 2),<br/>        ChartDataEntry(x: 2, y: 4),<br/>        ChartDataEntry(x: 3, y: 3),<br/>    ]<br/>    let dataSet = LineChartDataSet(entries: lineChartEntries)<br/>    let data = LineChartData(dataSet: dataSet)<br/>    let chart = LineChartView()<br/>    chart.data = data<br/>    <br/>    view.addSubview(chart)<br/>    chart.snp.makeConstraints {<br/>        $0.centerY.width.equalToSuperview()<br/>        $0.height.equalTo(300)<br/>    }<br/>}</span></pre><p id="f15d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了掌握图表的逻辑，我建议从这段代码的底部开始反向操作。</p><p id="5c32" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以看到图表区本身是一个<code class="fe ne nf ng nh b">UIView</code>的后代，我们必须将数据设置到其中。图表类型完全是线性图表，对于条形图和其他变体，还有其他专用的视图类型。</p><p id="1ead" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，图表数据类型必须对应于视图类型<code class="fe ne nf ng nh b">LineChartData</code>。这种数据类型有一个接受一些数据集的构造函数(在这个阶段，我们可能会注意到还有一个接受数据集数组的构造函数，这是在一个区域实现多个图表的关键，因为我们记得产品所有者要求尝试并支持这个特性)。</p><p id="49c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数据集类型必须对应于线性图表类型<code class="fe ne nf ng nh b">LineChartDataSet</code>，它是数据条目数组的抽象(最终是图表区域中的点)。每个条目都有X和Y坐标，相当简单。</p><p id="3d94" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们构建并运行我们的项目，看看屏幕上画的是什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/6fbb5bc33848387c1a90d3b58d84d1fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/0*u7q7S3HJ4hdzQmqk"/></div></figure><p id="b5ae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">哦，不，这看起来绝对不像是企业希望我们实现的。那么让我们制定一个改变计划:</p><ul class=""><li id="92e2" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">更改图形线条颜色</li><li id="2c7d" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">从图表中移除点及其注释</li><li id="f01d" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">给我们的曲线添加平滑</li><li id="691d" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">在曲线下方添加渐变</li><li id="aff3" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">移除轴注释</li><li id="7e37" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">移除图例</li><li id="4fff" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">移除网格。</li></ul><h1 id="72f1" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">定制它</h1><p id="d85e" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">这些设置中有些是指图表区，有些是指数据集(这是因为一个区域可以显示多个图表，每个图表都有自己的设置)</p><p id="391f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">图表区设置:</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="0f9b" class="nm mg iq nh b be nn no l np nq">// disable grid<br/>chart.xAxis.drawGridLinesEnabled = false<br/>chart.leftAxis.drawGridLinesEnabled = false<br/>chart.rightAxis.drawGridLinesEnabled = false<br/>chart.drawGridBackgroundEnabled = false<br/>// disable axis annotations<br/>chart.xAxis.drawLabelsEnabled = false<br/>chart.leftAxis.drawLabelsEnabled = false<br/>chart.rightAxis.drawLabelsEnabled = false<br/>// disable legend<br/>chart.legend.enabled = false<br/>// disable zoom<br/>chart.pinchZoomEnabled = false<br/>chart.doubleTapToZoomEnabled = false<br/>// remove artifacts around chart area<br/>chart.xAxis.enabled = false<br/>chart.leftAxis.enabled = false<br/>chart.rightAxis.enabled = false<br/>chart.drawBordersEnabled = false<br/>chart.minOffset = 0<br/>// setting up delegate needed for touches handling<br/>chart.delegate = self</span></pre><p id="00ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于数据集处理，让我们更进一步，创建一个数据集工厂来支持多个图表案例。</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="fe9a" class="nm mg iq nh b be nn no l np nq">/// Factory preparing dataset for a single chart<br/>struct ChartDatasetFactory {<br/>    func makeChartDataset(<br/>        colorAsset: DataColor,<br/>        entries: [ChartDataEntry]<br/>    ) -&gt; LineChartDataSet {<br/>        var dataSet = LineChartDataSet(entries: entries, label: "")<br/><br/>        // chart main settings<br/>        dataSet.setColor(colorAsset.color)<br/>        dataSet.lineWidth = 3<br/>        dataSet.mode = .cubicBezier // curve smoothing<br/>        dataSet.drawValuesEnabled = false // disble values<br/>        dataSet.drawCirclesEnabled = false // disable circles<br/>        dataSet.drawFilledEnabled = true // gradient setting<br/><br/>        // settings for picking values on graph<br/>        dataSet.drawHorizontalHighlightIndicatorEnabled = false // leave only vertical line<br/>        dataSet.highlightLineWidth = 2 // vertical line width<br/>        dataSet.highlightColor = colorAsset.color // vertical line color<br/><br/>        addGradient(to: &amp;dataSet, colorAsset: colorAsset)<br/><br/>        return dataSet<br/>    }<br/>}<br/><br/>private extension ChartDatasetFactory {<br/>    func addGradient(<br/>        to dataSet: inout LineChartDataSet,<br/>        colorAsset: DataColor<br/>    ) {<br/>        let mainColor = colorAsset.color.withAlphaComponent(0.5)<br/>        let secondaryColor = colorAsset.color.withAlphaComponent(0)<br/>        let colors = [<br/>            mainColor.cgColor,<br/>            secondaryColor.cgColor,<br/>            secondaryColor.cgColor<br/>        ] as CFArray<br/>        let locations: [CGFloat] = [0, 0.79, 1]<br/>        if let gradient = CGGradient(<br/>            colorsSpace: CGColorSpaceCreateDeviceRGB(),<br/>            colors: colors,<br/>            locations: locations<br/>        ) {<br/>            dataSet.fill = LinearGradientFill(gradient: gradient, angle: 270)<br/>        }<br/>    }<br/>}</span></pre><p id="9436" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ne nf ng nh b">DataColor</code>是<code class="fe ne nf ng nh b">UIColor</code>之上的抽象，因为我们计划从视图模型中获取图表数据，并且不希望<code class="fe ne nf ng nh b">UIKit</code>泄漏到视图模型层。</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="f85a" class="nm mg iq nh b be nn no l np nq">/// Abstraction above UIColor<br/>enum DataColor {<br/>    case first<br/>    case second<br/>    case third<br/><br/>    var color: UIColor {<br/>        switch self {<br/>        case .first: return UIColor(red: 56/255, green: 58/255, blue: 209/255, alpha: 1)<br/>        case .second: return UIColor(red: 235/255, green: 113/255, blue: 52/255, alpha: 1)<br/>        case .third: return UIColor(red: 52/255, green: 235/255, blue: 143/255, alpha: 1)<br/>        }<br/>    }<br/>}</span></pre><p id="cd1b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们构建并运行一下，看看经过这些调整后我们得到了什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/1a9d59c5db7691c01ffd1249a33d91a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/0*pQ2GKoDFVn7gQhxr"/></div></figure><p id="f55e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">太好了，除了触摸我们都处理好了。现在，图表会在最近的值处绘制一个橙色十字准线。现在让我们来看看哪些事情可以不费吹灰之力地改变，哪些事情必须由我们来实施。</p><h1 id="c743" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">触摸处理</h1><p id="853e" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">让我们回到<code class="fe ne nf ng nh b">dataset</code>工厂，添加这些设置:</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="7f85" class="nm mg iq nh b be nn no l np nq">// selected value display settings<br/>dataSet.drawHorizontalHighlightIndicatorEnabled = false // leave only vertical line<br/>dataSet.highlightLineWidth = 2 // vertical line width<br/>dataSet.highlightColor = colorAsset.color // vertical line color</span></pre><p id="630b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们的图表应该对这样的接触做出反应:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/323863e5531011b5ed944cb38035bec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/0*iJ3pD9wtRNayQbao"/></div></figure><p id="daeb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">剩下的就靠我们去实现了:</p><ul class=""><li id="7e5d" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">选定值圆</li><li id="8626" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">带有附加信息属性(日期、值、颜色图例)的气泡。</li></ul><p id="c91e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里我们有图表区的两个特性来帮助我们。首先，它有一个委托，其次，它可以显示标记。因此，我们的下一步将是创建一个从<code class="fe ne nf ng nh b">MarkerView</code>基类继承的自定义标记:</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="87b2" class="nm mg iq nh b be nn no l np nq">/// Marker for highlighting selected value on graph<br/>final class CircleMarker: MarkerView {<br/>    override func draw(context: CGContext, point: CGPoint) {<br/>        super.draw(context: context, point: point)<br/>        context.setFillColor(UIColor.white.cgColor)<br/>        context.setStrokeColor(UIColor.blue.cgColor)<br/>        context.setLineWidth(2)<br/><br/>        let radius: CGFloat = 8<br/>        let rectangle = CGRect(<br/>            x: point.x - radius,<br/>            y: point.y - radius,<br/>            width: radius * 2,<br/>            height: radius * 2<br/>        )<br/>        context.addEllipse(in: rectangle)<br/>        context.drawPath(using: .fillStroke)<br/>    }<br/>}</span></pre><p id="532a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">至于info bubble，让我们简单地创建一个自定义视图，它的实现对于图表逻辑来说并不重要，您可以在最终项目(<code class="fe ne nf ng nh b">ChartInfoBubbleView</code>)中找到一个实现示例。我们从设计模型中注意到，它必须包含日期、颜色图例和Y值。</p><p id="4b9e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"/></p><p id="9488" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，让我们在图表区域周围创建一个包装器，用于存储区域本身、标记和信息气泡。</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="0769" class="nm mg iq nh b be nn no l np nq">/// Chart view<br/>final class ChartView: UIView {<br/>    private let chart = LineChartView()<br/>    private let circleMarker = CircleMarker()<br/>    private let infoBubble = ChartInfoBubbleView()<br/><br/>    var viewModel: ChartViewModelProtocol? {<br/>        didSet {<br/>            updateChartDatasets()<br/>        }<br/>    }<br/><br/>    override init(frame: CGRect) {<br/>        super.init(frame: frame)<br/>        commonInit()<br/>    }<br/><br/>    required init?(coder: NSCoder) {<br/>        super.init(coder: coder)<br/>        commonInit()<br/>    }<br/>}</span></pre><p id="0f87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，在委托中，我们将添加对<code class="fe ne nf ng nh b">ChartViewDelegate</code>协议的一致性。我们对两种方法特别感兴趣:</p><ul class=""><li id="da0b" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><code class="fe ne nf ng nh b">func chartValueSelected(_ chartView: ChartViewBase, entry: ChartDataEntry, highlight: Highlight) </code> —这里我们获得数据集条目，它的数据将用于信息气泡，它的highlight属性将提供图形上的点坐标。一个重要的细节是使用突出显示的属性<code class="fe ne nf ng nh b">.xPx</code>和<code class="fe ne nf ng nh b">.yPx</code>，而不是<code class="fe ne nf ng nh b">.x</code>和<code class="fe ne nf ng nh b">.y</code>，这可能听起来有点混乱，但这就是它的工作方式；</li><li id="df57" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">我们应该把标记藏在这里。</li></ul><p id="564f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">回到图表区设置，我们将添加标记支持。</p><pre class="kg kh ki kj gt ni nh nj bn nk nl bi"><span id="9302" class="nm mg iq nh b be nn no l np nq">// markers<br/>chart.drawMarkers = true<br/>circleMarker.chartView = chart<br/>chart.marker = circleMarker</span></pre><p id="24c5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们这样做时，下面的逻辑工作:用户的触摸由委托方法处理，我们显示一个圆形标记和一个信息气泡。在线外但在图表区域内轻按时，标记和气泡会被隐藏。</p><p id="ce3a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了避免气泡滑出图表区域，我们可以添加一个非常简单的逻辑来检查气泡视图是否适合图表区域，或者是否必须进行水平或垂直调整。这个逻辑的例子可以在期末专题中找到。</p><p id="30d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">干得好，现在我们已经根据产品要求准备好了功能:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/bc2dbaf68ed7fa3fe6505b5a3f778d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*boHSIDE7xeaVBWkW"/></div></figure><p id="ff52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">眼尖的读者可能已经注意到，我们从XY坐标的点开始，其中X只是数据集中的元素号，Y是值，那么数据是从哪里来的呢？很简单，<code class="fe ne nf ng nh b">ChartDataEntry</code>有几个初始化器，其中之一是<code class="fe ne nf ng nh b">@objc public convenience init(x: Double, y: Double, data: Any?)</code>，其中数据是我们想要包含的任何附加属性，所以我们在那里添加了日历日期，并在委托的触摸处理回调中将其取回。</p><h1 id="9a65" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">最后的想法</h1><p id="7bb3" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">图表库有广泛的定制选项，保持iOS和Android平台之间的一致性，这是产品所有者经常需要的。我们已经通过一个简单的例子证明了这一点，从默认的可视化一直到或多或少真实世界的定制实现。</p><p id="3a83" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从这里去哪里？试着考虑在一个图表区域中实现两行、三行和N行，以及在这方面可能出现的挑战。</p></div></div>    
</body>
</html>