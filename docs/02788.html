<html>
<head>
<title>Create a React Chrome Extension to Filter YouTube Videos Using Narrower Durations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个React Chrome扩展，使用更短的持续时间过滤YouTube视频</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-react-chrome-extension-to-filter-youtube-videos-using-narrower-durations-ce847cf64f49?source=collection_archive---------1-----------------------#2019-12-31">https://betterprogramming.pub/create-a-react-chrome-extension-to-filter-youtube-videos-using-narrower-durations-ce847cf64f49?source=collection_archive---------1-----------------------#2019-12-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a52f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建使用React的强大Chrome扩展</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0a294d7c5c436cd093f55c690ec386c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iuYV17jxwcqG1cayALQaEA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@nordwood?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">诺德伍德主题</a>在<a class="ae ky" href="https://unsplash.com/s/photos/youtube?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f7a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论如何使用脸书的<a class="ae ky" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> Create react App </a>工具在React中创建一个chrome扩展，该工具将为我们提供捆绑功能。这意味着你将能够<code class="fe lv lw lx ly b">npm install</code>你最喜欢的节点模块，并使用它们来开发你的chrome扩展。我们将把我们的代码直接注入到页面中，并访问它的<code class="fe lv lw lx ly b">document</code>。</p><p id="e7a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将让我们的扩展提供一个定制的菜单项，当我们右击一个网页时，这个菜单项就会出现。我们将通过搜索结果关注YouTube的视频页面。当我们通过搜索结果查看视频时，我们的扩展会不断地从结果中删除视频持续时间小于给定的最小持续时间或大于给定的最大持续时间的视频。因此，当我们不断向下滚动，YouTube不断向我们提供新视频时，我们的扩展会不断删除我们不想看到的视频。:)</p><p id="d4a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会问，当YouTube已经给了我们一个持续时间的过滤器时，还有什么意义呢？这是真的，但是他们只允许用户过滤少于4分钟或多于20分钟的持续时间。我不知道你怎么想，但我认为它非常强大，可以过滤更窄的内容，例如持续时间在8到15分钟之间的视频，反之亦然。</p><p id="351a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们只想看来自<a class="ae ky" href="https://www.youtube.com/channel/UC69uYUqvx-vw4luuX7aHNLQ" rel="noopener ugc nofollow" target="_blank">真实犯罪</a>频道的时长在5到10分钟的视频呢？过滤短于四分钟或长于20分钟的视频完全没用。当我们寻找分成几部分的剧集时，我们希望看到5到10分钟的视频，如第1部分(共4部分)、第2部分、第3部分等。，因为这些视频通常平均时长6分钟。当我们浏览搜索结果时，我们不想被40分钟的播客视频轰炸。</p><p id="cbc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将创建一个选项页面以及一个弹出窗口，当单击工具栏中的图标时，只是为了看看它有多简单。</p><p id="da06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(如果你想要GitHub回购的链接，你可以点击<a class="ae ky" href="https://github.com/jsmanifest/react-chrome-ext" rel="noopener ugc nofollow" target="_blank">这里</a>)</p><p id="6a59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章不会详细介绍chrome扩展是如何工作的，所以在进一步阅读之前，我建议仔细阅读<a class="ae ky" href="https://developer.chrome.com/extensions/overview" rel="noopener ugc nofollow" target="_blank">概述</a>以获得本教程剩余部分所需的基本理解。</p><p id="2fca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，在本教程结束时，你可能会注意到我们在这篇文章中将要构建的东西甚至不需要React。但是主要的一点是展示React是如何实现的，以帮助您自己开始。</p><p id="eb8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，我们开始吧！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d32f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">我们的代码结构</h1><p id="3b4f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">总的来说，当我们创建chrome扩展时，我们将内容脚本代码从后台脚本代码中分离出来。正因为如此，如果我们想保留代码捆绑的好处以及在使用捆绑器的现代项目中发现的其他好处，就需要两个额外的步骤来在两个独立的代码库中开发我们的代码。</p><p id="c6bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将把我们的React组件直接注入到一个网页中，这样我们就可以访问它的<code class="fe lv lw lx ly b">document</code> body对象，这样我们就可以操作DOM。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c106" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建项目</h1><p id="e8e2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们要做的第一件事是创建一个<a class="ae ky" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> Create React App </a>项目。我们需要给我们的新项目起一个名字，在本教程中，我们将把我们的项目命名为<code class="fe lv lw lx ly b">react-chrome-ext</code>。</p><p id="12c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在终端中输入:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9f57" class="nh mh it ly b gy ni nj l nk nl">npx create-react-app react-chrome-ext</span></pre><p id="face" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，现在进入目录:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e9ff" class="nh mh it ly b gy ni nj l nk nl">cd react-chrome-ext</span></pre><p id="ce92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要做的第一件事是去掉本教程不需要的东西。这是我们清理后的项目目录:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/72a493887289f72b053ced74ad5a1276.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/0*AwPr2mfgUlnLkccj.jpg"/></div></figure><p id="a6a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们的扩展被使用时，我们需要为我们的扩展提供一种方法来访问当前标签的<code class="fe lv lw lx ly b">document</code>。我们的React组件很可能还没有这种访问权限，因为它被注入到id为<code class="fe lv lw lx ly b">root</code>的元素中，正如我们打开<code class="fe lv lw lx ly b">index.js</code>时看到的:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="33e0" class="nh mh it ly b gy ni nj l nk nl">import React from 'react'<br/>import ReactDOM from 'react-dom'<br/>import './index.css'<br/>import App from './App'</span><span id="5963" class="nh mh it ly b gy nn nj l nk nl">ReactDOM.render(&lt;App /&gt;, document.getElementById('root'))</span></pre><p id="cba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们让它保持原样，那么我们的扩展将只能在网页有一个id为<code class="fe lv lw lx ly b">'root'</code>的实际DOM元素时工作。我们将在执行<code class="fe lv lw lx ly b"><em class="no">ReactDOM.render</em></code>之前，通过将我们自己的元素注入到<code class="fe lv lw lx ly b">document.body</code>中来稍微扭转一下。</p><p id="6864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将创建一个元素并将其附加到<code class="fe lv lw lx ly b">document.body</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3924" class="nh mh it ly b gy ni nj l nk nl">import React from 'react'<br/>import ReactDOM from 'react-dom'<br/>import './index.css'<br/>import App from './App'</span><span id="ff23" class="nh mh it ly b gy nn nj l nk nl">const rootEl = document.createElement('div')<br/>rootEl.id = 'react-chrome-ext'<br/>document.body.appendChild(rootEl)</span><span id="bc37" class="nh mh it ly b gy nn nj l nk nl">ReactDOM.render(&lt;App /&gt;, rootEl)</span></pre><p id="fdce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们将进入<code class="fe lv lw lx ly b">App</code>组件内部，这是我们开始实现扩展的定制代码逻辑的地方(注意:这基本上是我们的内容脚本)。</p><p id="319a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，我们是通过使用搜索功能来扩展YouTube视频列表的。因此，当我们在页面上时，我们希望能够右键单击页面来弹出打开上下文菜单，里面将是我们的自定义菜单项，我们可以单击它来调用过滤器。我们希望我们的内容脚本监听点击事件，以便我们可以调用过滤器。为此，我们需要通过后台脚本注册上下文菜单，并在那里附加click事件监听器。当回调调用时，我们将使用Chrome <a class="ae ky" href="https://developer.chrome.com/extensions/messaging" rel="noopener ugc nofollow" target="_blank"> message </a> API向内容脚本发送信号。因为我们在消息的内容端添加了一个监听器，这就是它检测点击动作的方式。</p><p id="e860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">App.js</code>中，我们将把听众放在一个<code class="fe lv lw lx ly b">React.useEffect</code>上，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="82e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">chrome.runtime.onMessage</code>监听来自我们后台脚本的任何消息。</p><p id="cea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将在<code class="fe lv lw lx ly b">src</code>目录中创建一个名为<code class="fe lv lw lx ly b">bg</code>的目录，并在其中创建一个<code class="fe lv lw lx ly b">background.js</code>文件，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/c2141ae034221699a8b598777ba73696.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/0*J32SJhinduTzpePo.jpg"/></div></figure><p id="8abc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们必须实现扩展的代码，以便在安装时将菜单项注册到上下文菜单，以及当它被单击时会发生什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b4dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">chrome.runtime.onInstalled.addListener((message) =&gt; {</code>行注册我们的回调，以便在安装扩展时调用。这是我们创建上下文菜单的地方，正如我们在这里看到的:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="2a0b" class="nh mh it ly b gy ni nj l nk nl"><em class="no">// Clicking this item will send an event to the content script listening to messages</em><br/>chrome.contextMenus.create({<br/>  title: 'Filter by duration',<br/>  id: 'filter-by-duration',<br/>  contexts: [...contexts, 'browser_action'],<br/>})</span></pre><p id="73d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码稍后将创建这个菜单项(在底部):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/a728693c6e024785aa387a1ab7119995.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/0*QBYYAAMUhygpuCJ0.png"/></div></figure><p id="0033" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了一个<code class="fe lv lw lx ly b">getActiveTab</code>助手函数，这样我们就可以在将来的其他操作中重用它。它只是调用你传递给它的回调，并给你一个对象，代表你当前所在的选项卡。</p><p id="dc73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们添加了处理程序，用于在菜单项被单击时处理click事件，如下所示:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="087f" class="nh mh it ly b gy ni nj l nk nl"><em class="no">// When a context menu item is clicked</em><br/>chrome.contextMenus.onClicked.addListener((info) =&gt; {<br/>  console.log(info)<br/>  if (info.menuItemId === 'filter-by-duration') {<br/>    getActiveTab((tab) =&gt; {<br/>      if (info.menuItemId === 'filter-by-duration') {<br/>        chrome.tabs.sendMessage(tab.id, {<br/>          type: 'filter-by-duration',<br/>          ...info,<br/>        })<br/>      }<br/>    })<br/>  }<br/>})</span></pre><p id="e100" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的重要部分是:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ec1a" class="nh mh it ly b gy ni nj l nk nl">chrome.tabs.sendMessage(tab.id, {<br/>  type: 'filter-by-duration',<br/>  ...info,<br/>})</span></pre><p id="99f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将事件发送到内容脚本，然后我们的<code class="fe lv lw lx ly b">App</code>组件将接收它。</p><p id="3fc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这解释了为什么我们在<code class="fe lv lw lx ly b">App</code>组件中有<code class="fe lv lw lx ly b">chrome.runtime.onMessage.addListener</code>行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将在switch语句中添加根据持续时间过滤视频的逻辑。我们不会编写您最终想要实现的额外内容，比如提供一种在按需查看选项卡时更改过滤器持续时间值的方法，因为这是您自己的事情。因此，出于本教程的考虑，我们将只对持续时间进行硬编码。</p><p id="3bc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续之前，去<a class="ae ky" href="https://youtube.com" rel="noopener ugc nofollow" target="_blank"> YouTube </a>搜索一些东西。在本教程中，我们将只搜索<em class="no">道路愤怒</em>。以下是我们得到的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/7e4219588779557d43d333049aca0ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vmRa4ph4FsBVNYFt.jpg"/></div></div></figure><p id="b125" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在过滤器中硬编码最短10分钟、最长15分钟的持续时间。所以通过查看截图，当我们使用过滤器时，我们应该看不到第一个视频(<em class="no"> 23:42 </em>)和第四个视频(<em class="no"> 9:02 </em>)。</p><p id="d823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们必须查询并遍历页面的<code class="fe lv lw lx ly b">document</code>对象。如果您右键单击页面并转到Inspect Element，您可以通过使用类似于<a class="ae ky" href="https://www.w3schools.com/jsref/met_document_queryselector.asp" rel="noopener ugc nofollow" target="_blank"> document.querySelector </a>的选择器(或者您可以复制下面我的片段)来找出如何定位您需要的元素。我们需要将显示视频持续时间的元素作为目标，并将其转换为一个数字(因为它们是字符串)，以便我们可以应用数学运算来实现我们的目标。</p><p id="6b97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来实现过滤器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5c91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的扩展来说，这些代码应该足够了，但是在chrome上加载我们的扩展之前，我们还需要做一些事情。</p><p id="b5ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想要做的一件事是消除当<code class="fe lv lw lx ly b">chrome is not defined</code>时报错的<code class="fe lv lw lx ly b">eslint</code>错误。我们可以通过将<code class="fe lv lw lx ly b">webextensions: true</code>添加到<code class="fe lv lw lx ly b">package.json</code>中的<code class="fe lv lw lx ly b">eslintConfig</code>属性来解决这个问题:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e94e" class="nh mh it ly b gy ni nj l nk nl">"eslintConfig": {<br/>    "extends": "react-app",<br/>    "env": {<br/>      "webextensions": true<br/>    }<br/>  }</span></pre><p id="fb48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们必须编辑<code class="fe lv lw lx ly b">public</code>目录中的<code class="fe lv lw lx ly b">manifest.json</code>文件。当我们构建我们的项目时，这个<code class="fe lv lw lx ly b">manifest.json</code>文件被复制到<code class="fe lv lw lx ly b">build</code>目录，这是您将要加载到chrome的目录。让我们稍微清理一下<a class="ae ky" href="https://developer.chrome.com/extensions/manifest" rel="noopener ugc nofollow" target="_blank">以便chrome可以理解我们的扩展</a>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="f267" class="nh mh it ly b gy ni nj l nk nl">{<br/>  "manifest_version": 2,<br/>  "version": "1.0.1",<br/>  "name": "React Chrome Extension",<br/>  "content_security_policy": "script-src 'self' 'sha256-xr+HqUtnq8KF3IBn+TQ37Vz0elxg11bPYmNJy5M/p38='; object-src 'self'",<br/>  "background": {<br/>    "scripts": ["background.js"],<br/>    "persistent": false<br/>  },<br/>  "permissions": ["activeTab", "tabs", "contextMenus"]<br/>}</span></pre><p id="e2f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想让chrome获取它们，我们还需要在清单中指定一个<code class="fe lv lw lx ly b">content_scripts</code>属性。通常这是我们输入内容脚本的地方，比如我们的<code class="fe lv lw lx ly b">App.js</code>文件，但是这里的问题是Chrome不能理解未移植的react代码。所以我们需要插入transpiled输出文件，当我们运行<code class="fe lv lw lx ly b">npm run build</code>时，这些文件被发送到<code class="fe lv lw lx ly b">build</code>文件夹。</p><p id="da1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们继续跑<code class="fe lv lw lx ly b">npm run build</code>。我们的构建文件夹最终看起来会像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/f3ab1c7d0f2d99c6d508bb5f45d313d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/0*DUch4c4_RM-hZAy2.jpg"/></div></figure><p id="dfcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望包含在清单中的JavaScript文件是这三个文件:</p><ol class=""><li id="fba3" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated"><code class="fe lv lw lx ly b">static/js/2.2e3b5afd.chunk.js</code></li><li id="3d12" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><code class="fe lv lw lx ly b">static/js/main.bf10c391.chunk.js</code></li><li id="6931" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><code class="fe lv lw lx ly b">static/js/runtime-main.0741577f.js</code></li></ol><p id="f8b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…最终看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ee1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，但现在我们的问题是，每次我们运行<code class="fe lv lw lx ly b">npm run build</code>时，这些JavaScript文件的文件名都会改变，这意味着我们必须手动改变这些行，以便与文件名的动态更新保持同步。这是一种糟糕的开发体验，所以我们将不得不通过退出我们的项目来获得对如何生成输出的控制，从而解决这个问题。</p><p id="9f54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续运行<code class="fe lv lw lx ly b">npm run eject</code></p><p id="3a10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，进入你的<code class="fe lv lw lx ly b">config</code>文件夹，打开<code class="fe lv lw lx ly b">webpack.config.js</code></p><p id="09bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">搜索<code class="fe lv lw lx ly b">.[hash:8]</code>并删除两个事件。</p><p id="bc36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个是<code class="fe lv lw lx ly b">name: 'static/media/[name].[hash:8].[ext]',</code>，因此将其更改为<code class="fe lv lw lx ly b">name: 'static/media/[name].[ext]',</code>，并对另一个进行同样的操作。</p><p id="da81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在进行另一次搜索，寻找<code class="fe lv lw lx ly b">.[contenthash:8]</code>，并删除所有出现的内容。无论何时运行<code class="fe lv lw lx ly b">build</code>命令，您的<code class="fe lv lw lx ly b">js</code>文件都将具有相同的文件名。</p><p id="6cbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在当你运行<code class="fe lv lw lx ly b">npm run build</code>时，那些输出文件每次都保持不变:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/73326fe2defec7b762190464de2f968a.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/0*314coOdJm6bqqhW6.jpg"/></div></figure><p id="691b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可以安全地将这些输入到您的<code class="fe lv lw lx ly b">manifest.json</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="eb28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！现在运行<code class="fe lv lw lx ly b">npm run build</code>，让我们把它加载到Chrome中。在你的地址栏中输入<code class="fe lv lw lx ly b">chrome:extensions</code>，然后点击load unpacked按钮，选择你的<code class="fe lv lw lx ly b">build</code>目录。</p><p id="6d6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的扩展现在应该被加载了！</p><p id="03a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们去<a class="ae ky" href="http://www.youtube.com" rel="noopener ugc nofollow" target="_blank"> YouTube </a>搜索<em class="no">路怒</em>。右键单击页面，然后单击按持续时间过滤。点击之后，扩展应该会根据你的持续时间过滤器从屏幕上删除元素。万岁！</p><p id="b1eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记得在我们之前的一个截图中，我们有几个视频结果，我们提到当我们应用过滤器时，23:54和9:42的视频持续时间不应该显示出来？</p><p id="dfbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这是不是真的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/343abb7abfd57ed6973eb7dd2d3a24ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eo69bfzw96ZTbrNt.gif"/></div></div></figure><p id="8534" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">万岁！</p><p id="446f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们结束本教程之前，让我们继续实现一个<a class="ae ky" href="https://developer.chrome.com/extensions/options" rel="noopener ugc nofollow" target="_blank">选项</a>页面以及一个<a class="ae ky" href="https://developer.chrome.com/extensions/user_interface#popup" rel="noopener ugc nofollow" target="_blank">弹出菜单</a>。</p><p id="980d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当右键单击工具栏中的扩展图标并单击选项项目时，将使用选项页面。</p><p id="86c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您在工具栏中左键单击您的扩展图标时，弹出窗口的使用类似。</p><p id="bf2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在<code class="fe lv lw lx ly b">src/bg/</code>中创建一个<code class="fe lv lw lx ly b">options.html</code>和<code class="fe lv lw lx ly b">popup.html</code>，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/b306ae61f8913f26bd1f5ec58a005ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/0*Dhu7z4d05DIIdKjZ.jpg"/></div></figure><p id="0f28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以输入一个<code class="fe lv lw lx ly b">postbuild</code>脚本到我们的<code class="fe lv lw lx ly b">package.json</code>中，它会在建筑完成后自动运行:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="22df" class="nh mh it ly b gy ni nj l nk nl">"scripts": {<br/>    "start": "node scripts/start.js",<br/>    "prebuild": "rm -rf build",<br/>    "build": "node scripts/build.js",<br/>    "postbuild": "cp src/bg/* build"<br/>}</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1fb1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="c04b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">本帖到此结束！我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>