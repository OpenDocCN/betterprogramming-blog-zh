<html>
<head>
<title>Backup and Restore Containers With Kubernetes Checkpointing API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kubernetes检查点API备份和恢复容器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/backup-and-restore-of-containers-with-kubernetes-checkpointing-api-e310cf29cd4a?source=collection_archive---------3-----------------------#2022-11-15">https://betterprogramming.pub/backup-and-restore-of-containers-with-kubernetes-checkpointing-api-e310cf29cd4a?source=collection_archive---------3-----------------------#2022-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c0ee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Kubernetes v1.25引入了容器检查点API——以下是如何将它用于容器备份和恢复或取证分析</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ee609ce6def0a0717be103f571fa50f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_a9c84oBS_3N0K_jn6Bk1A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">产生稳定的扩散</p></figure><p id="abe8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Kubernetes v1.25引入了容器检查点API作为alpha特性。这提供了一种备份和恢复Pod容器的方法—无需停止它们。</p><p id="88d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个特性主要是针对法庭分析的，但是通用和恢复是任何Kubernetes用户都可以利用的。</p><p id="d368" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，让我们来看看这个全新的功能，看看我们如何在我们的集群中启用它，并利用它进行备份和恢复或取证分析。</p><h1 id="43de" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">设置</h1><p id="fe1f" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在我们开始检查点容器之前，我们需要一个平台来处理kubelet及其工作负载。我们需要一个v1.25+ Kubernetes集群和支持容器检查点的容器运行时。</p><p id="b9e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在用vagger构建的虚拟机内部使用<code class="fe mr ms mt mu b">kubeadm</code>创建这样一个集群。我已经创建了一个<a class="ae mv" href="https://github.com/MartinHeinz/kubeadm-vagrant-playground/tree/container-checkpoint-api" rel="noopener ugc nofollow" target="_blank">库</a>，其中包含了仅用<code class="fe mr ms mt mu b">vagrant up</code>就能启动这样一个集群所必需的一切，所以如果您想继续下去，请查看一下。</p><p id="0d60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想要构建自己的集群，请确保它满足以下条件:</p><p id="efa7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">集群必须启用<code class="fe mr ms mt mu b">ContainerCheckpoint</code>功能标志。对于<code class="fe mr ms mt mu b">kubeadm</code>,使用以下配置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b58f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将把<code class="fe mr ms mt mu b">--feature-gates</code>标志传递给每个集群组件。有关可用特征门的完整列表，请参见<a class="ae mv" href="https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="8b92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还需要使用支持检查点的容器运行时。在撰写本文时，只有<a class="ae mv" href="https://github.com/cri-o/cri-o/pull/6181" rel="noopener ugc nofollow" target="_blank"> CRI-O </a>支持它，而<a class="ae mv" href="https://github.com/containerd/containerd/pull/6965" rel="noopener ugc nofollow" target="_blank"> containerd </a>可能很快就会推出。</p><p id="caad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要用CRI-O配置您的集群，请使用docs 中的<a class="ae mv" href="https://github.com/cri-o/cri-o/blob/main/install.md" rel="noopener ugc nofollow" target="_blank">指令安装它，或者使用上述存储库中的</a><a class="ae mv" href="https://github.com/MartinHeinz/kubeadm-vagrant-playground/blob/container-checkpoint-api/crio.sh" rel="noopener ugc nofollow" target="_blank">便利脚本</a>(您应该在VM中运行它，而不是在您的本地机器上)。</p><p id="8754" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，我们需要为CRI-O启用<a class="ae mv" href="https://github.com/checkpoint-restore/criu" rel="noopener ugc nofollow" target="_blank"> CRIU </a>，这个工具在后台执行实际的检查点操作。</p><p id="7c7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要启用它，我们需要设置<code class="fe mr ms mt mu b">--enable-criu-support=true</code>标志。上面的便利脚本<a class="ae mv" href="https://github.com/MartinHeinz/kubeadm-vagrant-playground/blob/container-checkpoint-api/crio.sh#L75" rel="noopener ugc nofollow" target="_blank">为您完成了</a>的工作。</p><p id="8065" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，如果您计划将它恢复到一个Pod中，您还需要将<code class="fe mr ms mt mu b">--drop-infra-ctr</code>设置为<code class="fe mr ms mt mu b">false.</code>，否则，您将得到带有如下消息的<code class="fe mr ms mt mu b">CreateContainerError</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4ec5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着CRI-O的安装，我们还必须告诉<code class="fe mr ms mt mu b">kubeadm</code>使用其插座，以下配置与照顾:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="de5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了这些，我们就可以使用以下工具加速集群:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a854" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将为我们提供一个单节点集群，例如(注意容器运行时版本):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="156a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="my">注</em> </strong> <em class="my">:一般来说，玩Kubernetes最好最简单的方法就是用KinD。然而，KinD(在撰写本文时)不支持容器检查点。或者，也可以尝试Kubernetes资源库中的</em><a class="ae mv" href="https://github.com/kubernetes/kubernetes/blob/master/hack/local-up-cluster.sh" rel="noopener ugc nofollow" target="_blank"><em class="my">local-up-cluster . sh</em></a><em class="my">脚本。</em></p><h1 id="4b2f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">检查点</h1><p id="54e1" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">这样一来，我们可以尝试创建一个检查点。Kubernetes上的常规操作可以通过<code class="fe mr ms mt mu b">kubectl</code>或对集群API服务器运行<code class="fe mr ms mt mu b">curl</code>命令来完成。然而，这在这里不起作用，因为检查点API只在每个集群节点的<code class="fe mr ms mt mu b">kubelet</code>上公开。</p><p id="5e57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们必须跳到节点上，直接与<code class="fe mr ms mt mu b">kubelet</code>对话:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="22c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要创建检查点，我们还需要一个运行Pod。让我们在<code class="fe mr ms mt mu b">default</code>名称空间中创建一个虚拟Nginx webserver，而不是使用<code class="fe mr ms mt mu b">kube-system</code>中的系统Pods:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4638" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面，您可以看到我们还从节点中删除了污点—这允许我们在节点上调度工作负载，即使它是控制平面的一部分。</p><p id="4e81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，让我们向<code class="fe mr ms mt mu b">kubelet</code>发出一个示例API请求，看看我们是否能得到任何有效的响应:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="db64" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，<code class="fe mr ms mt mu b">kubelet</code>在端口<code class="fe mr ms mt mu b">10250</code>上运行，因此我们<code class="fe mr ms mt mu b">curl</code>它并请求它的所有pod。我们还必须指定CA证书、客户机证书和认证密钥。</p><p id="e641" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在是时候创建一个检查点了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="70ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">检查点API在<code class="fe mr ms mt mu b">.../checkpoint/${NAMESPACE}/${POD}/${CONTAINER}</code>可用，这里我们使用了之前创建的<code class="fe mr ms mt mu b">webserver</code> Pod。这个请求在<code class="fe mr ms mt mu b">/var/lib/kubelet/checkpoints/checkpoint-&lt;pod&gt;_&lt;namespace&gt;-&lt;container&gt;-&lt;timestamp&gt;.tar</code>创建了一个档案。</p><p id="9b98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据您正在使用的设置，在运行上面的<code class="fe mr ms mt mu b">curl</code>之后，您可能会收到类似以下内容的错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="19c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着您的容器运行时(还)不支持检查点，或者它没有被正确启用。</p><h1 id="6526" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">分析</h1><p id="f3a5" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们现在有了一个检查点容器归档，所以让我们看看里面有什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b599" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您不需要运行Pod/container来进行分析，提取并通读上面显示的一些文件可能会给您提供必要的信息。</p><p id="ccf3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也就是说，我不是安全专家，所以我不会在这里给你关于如何分析这些文件的有问题的信息。</p><p id="c1bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为起点，您可能希望在Kubernetes中查看类似于<a class="ae mv" href="https://github.com/google/docker-explorer" rel="noopener ugc nofollow" target="_blank"> docker-explorer </a>或<a class="ae mv" href="https://www.youtube.com/watch?v=MyXROAqO7YI&amp;ab_channel=CNCF%5BCloudNativeComputingFoundation%5D" rel="noopener ugc nofollow" target="_blank"> this talk </a>的容器取证工具。</p><h1 id="8ab4" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">恢复</h1><p id="563d" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">虽然检查点API目前更多地针对取证分析，但它仍然可以用于从档案中恢复Pod/container。</p><p id="0349" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最简单的方法是从检查点归档文件创建映像:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e501" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们使用一个空的(<code class="fe mr ms mt mu b">scratch</code>)图像，我们将归档文件添加到其中。我们需要使用<code class="fe mr ms mt mu b">ADD</code>，因为它会自动提取档案。接下来，我们用<code class="fe mr ms mt mu b">docker</code>或<code class="fe mr ms mt mu b">buildah</code>构建它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0bfb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面我们还指定了注释，它描述了容器的<a class="ae mv" href="https://github.com/cri-o/cri-o/blob/642f60c471b6746652b1671637cbd17a07da5fcf/pkg/annotations/checkpoint.go#L6" rel="noopener ugc nofollow" target="_blank">原始人类可读名称，然后我们将它推送到某个注册中心，以便Kubernetes可以提取它。</a></p><p id="96cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们创建一个Pod，指定之前推送的图像:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="045c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了测试它是否工作，我们可以通过服务和<code class="fe mr ms mt mu b">curl</code>它的IP来暴露Pod:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9394" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而且成功了！我们成功地备份了一个正在运行的Pod，而没有停止它，并将其重新创建到原始状态。</p><h1 id="e7dc" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结束语</h1><p id="8593" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">多亏了CRIU，容器的通用检查点和恢复已经成为可能，但这仍然是Kubernetes的一大步，希望我们能看到这个特性/API升级到Beta，并最终在某个时候正式发布。</p><p id="36b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前面几节演示了检查点API的用法——它非常有用，但也缺少一些基本的特性，比如本机恢复功能或对所有主要容器运行时的支持。因此，如果您在生产(甚至开发)环境/集群中启用它，请注意它的局限性。</p><p id="1d13" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也就是说，该功能是一个非常酷的附加功能，不仅适用于取证分析，在未来，当更好的/本机恢复过程可用时，这可能会成为容器工作负载的适当备份和恢复过程，这对于某些类型的长期运行的Kubernetes工作负载可能非常有用。</p><div class="mz na gp gr nb nc"><a rel="noopener  ugc nofollow" target="_blank" href="/advanced-features-of-kubernetes-horizontal-pod-autoscaler-536ebd7893ad"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">Kubernetes卧式Pod自动秤的先进特性</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">Kubernetes的水平吊舱自动缩放器有一些你可能不知道的功能。以下是如何将它们用于您的…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">better编程. pub</p></div></div><div class="nl l"><div class="nm l nn no np nl nq ks nc"/></div></div></a></div><pre class="kj kk kl km gt nr mu ns bn nt nu bi"><span id="6386" class="nv lv it mu b be nw nx l ny nz">Want to Connect?<br/><br/>This article was originally posted at <a class="ae mv" href="https://martinheinz.dev/blog/85" rel="noopener ugc nofollow" target="_blank">martinheinz.dev</a></span></pre></div></div>    
</body>
</html>