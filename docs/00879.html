<html>
<head>
<title>The Joy of Regular Expressions, Part 2: Character Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正则表达式的乐趣，第2部分:字符类</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-joy-of-regular-expressions-part-2-character-classes-5de72d6a58ae?source=collection_archive---------12-----------------------#2019-07-23">https://betterprogramming.pub/the-joy-of-regular-expressions-part-2-character-classes-5de72d6a58ae?source=collection_archive---------12-----------------------#2019-07-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e2f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">关于正则表达式系列的第二篇文章</em></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/d343cbe83b052769d3a9393368cfc457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xuufhdXGbah-PBbpbves_g.jpeg"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">照片由<a class="ae lf" href="https://unsplash.com/@sapegin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Artem Sapegin </a>在<a class="ae lf" href="https://unsplash.com/search/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="53c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，如标题所示，这篇文章是一个系列的一部分。<a class="ae lf" href="https://medium.com/better-programming/the-joy-of-regular-expressions-part-1-what-is-regex-539dc581e282" rel="noopener">点击这里阅读:正则表达式的快乐，第1部分:什么是正则表达式？</a></p><p id="be24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如前所述，这是一篇面向JavaScript的文章。所有的例子都是使用JS中的<code class="fe lg lh li lj b">.test()</code>方法完成的。也就是说，这种逻辑可以跨几种语言应用，尽管语法可能略有不同。</p><p id="7290" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要快速搜索这篇文章中的关键词(字符类，<code class="fe lg lh li lj b">^</code>插入符号，否定字符类，连字符，速记字符类，单词字符，空白字符，点)，只需使用<code class="fe lg lh li lj b">CTRL/CMD+ F</code>函数。</p><p id="902b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在出现的搜索栏中，键入一个井号<code class="fe lg lh li lj b">#</code>，后跟一个术语(不要用空格分隔多于一个单词的术语)。这将直接带您到涵盖该术语的部分，而不必滚动。</p><p id="2ed3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一如既往，我强烈推荐并鼓励访问Jan Goyvaerts的网站，<a class="ae lf" href="https://www.regular-expressions.info/" rel="noopener ugc nofollow" target="_blank">regular-expressions . info</a>。它以一种彻底的、实用的格式保存了关于regex的信息，并作为程序员进一步探索这一概念的重要资源。</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="60ad" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">入门指南</h1><p id="91bc" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">欢迎回到我关于正则表达式系列的另一篇文章。我们上一次离开是在第1部分中，这里介绍了正则表达式的概念，以及与之相关的关键术语和锚的用法。</p><p id="04f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在那篇文章中，我们简要地提到了字符类，它是正则表达式的一部分，对程序员来说是不可或缺的。</p><p id="f02c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我们将深入探讨他们的利用和与角色群体合作的能力。</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="58e7" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">什么是角色类？</h1><p id="84d3" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">如果你没有读过上一篇文章，我们将会更详细地介绍什么是字符类，这样你就可以理解这些工具是如何在正则表达式中使用的，以及为什么。</p><p id="40fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">字符类是一种告诉正则表达式引擎您想要一个组内字符的匹配的方式。</p><p id="c13c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，我们可以使用一个简单的字符类，比如<code class="fe lg lh li lj b">/[aeiou]/</code>，它将匹配一个单词中的所有元音。</p><p id="e09e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，我们就在对发动机说:“在管柱中，匹配<em class="ko"> a </em>，或<em class="ko"> e </em>，或<em class="ko"> i </em>，或<em class="ko"> o </em>，或<em class="ko"> u </em>。如果不是那些字符中的一个，它就不是匹配的。”</p><p id="a105" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑下面的例子:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8d57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个例子中，我们将字符类缩短为<code class="fe lg lh li lj b">/[ae]/</code>，只匹配字符<em class="ko"> a </em>或<em class="ko"> e </em>。</p><p id="7a53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这适用于像<em class="ko">灰色</em>和<em class="ko">灰色</em>这样的字符串，因为其中有一个<em class="ko"> a </em>或<em class="ko"> e </em>。它对字符串<em class="ko">粉色</em>无效，因为该字符串不包含<em class="ko"> a </em>也不包含<em class="ko"> e. </em></p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="ae8f" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">在字符类中使用连字符可以在一定范围内搜索字符</h1><p id="2f94" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">#连字符，#范围。</p><p id="8c99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然搜索元音字母的正则表达式相对较短，但想象一下，在一个字符类中，您希望匹配任何小写字母。</p><p id="e21c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个长得几乎难以辨认的正则表达式，看起来有点像<code class="fe lg lh li lj b">[abcdefghijklmnopqrstuvwxyz]</code>。这在技术上是可行的，但是不直观，写出来也很痛苦。</p><p id="23b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相反，我们可以使用一个<em class="ko">连字符</em>来告诉正则表达式引擎在一个<em class="ko">字符范围</em>内进行搜索。</p><p id="55ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，<code class="fe lg lh li lj b"> /[a-z]/</code>将匹配所有小写字母，<code class="fe lg lh li lj b">/[A-Z]/</code>将匹配所有大写字母。你甚至可以非常具体，只需要匹配字母表的前五个字母，然后输入<code class="fe lg lh li lj b">/[a-e]/</code>就可以了。</p><p id="78e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至此，我们已经看到了如何使用我们自己的字符来匹配几个不同的字符或一系列字符。但是如果我们想做相反的事情呢？</p><p id="e9cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们要匹配一个辅音——换句话说，任何字母是<em class="ko">而不是</em> a、e、I、o或u。幸运的是，字符类也可以提供排除功能。</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="6492" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">使用^(插入符号)指定一组不匹配的字符</h1><p id="df0b" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated"># <code class="fe lg lh li lj b">^</code>插入符号(字符类)，#negatedcharacterclass</p><p id="fe41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当用在字符类的括号中时，<code class="fe lg lh li lj b">^</code>(插入符号)表示regex引擎匹配除字符类中包含的字符之外的任何字符。</p><p id="796d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当以这种方式构建字符类时，它被称为<em class="ko">否定字符类。</em></p><p id="fd65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到我们之前的例子，假设我们想要匹配一个辅音。我们可以键入/ <code class="fe lg lh li lj b">[^aeiou]/</code>，它将匹配除字符类中的字符之外的任何字符。</p><p id="e662" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是更多的例子:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mu mv l"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">请记住，正则表达式引擎按顺序读取内容。对于第四行和第五行，我们检查“q-不是U的任何东西”是否在提供的字符串中</p></figure><ul class=""><li id="a07b" class="mw mx it js b jt ju jx jy kb my kf mz kj na kn nb nc nd ne bi translated">在第一行代码中，我们查看字符串中是否有非元音字母的字符。字符串中没有元音，所以我们返回了<code class="fe lg lh li lj b">true</code>。</li><li id="fbde" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">在第二行代码中，我们查看字符串<code class="fe lg lh li lj b">‘64’</code>中是否存在数字以外的字符。他们没有，所以我们把<code class="fe lg lh li lj b">false</code>拿回来了。</li><li id="2abf" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">在第三行代码中，我们查看字符串<code class="fe lg lh li lj b">‘Nintendo 64’</code>中是否存在数字以外的字符。这个字符串中有数字，但是我们有大写字符，小写字符，以及一个空白字符在<br/>这个字符串中，所以<code class="fe lg lh li lj b">true</code>被返回。</li><li id="7680" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">在第四行代码中，我们寻找一个紧随其后的不是字符<code class="fe lg lh li lj b">u</code>的<code class="fe lg lh li lj b">q</code>。这失败了，因为我们遇到的第一个<code class="fe lg lh li lj b">q</code>后面是字符<code class="fe lg lh li lj b">u</code>，遇到的第二个<code class="fe lg lh li lj b">q</code>后面没有任何内容，因为它是字符串的结尾。因此，我们得到了返回的<code class="fe lg lh li lj b">false</code>。</li><li id="ec9c" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">在第五行代码中，我们寻找一个紧接着不是字符<code class="fe lg lh li lj b">u</code>的<code class="fe lg lh li lj b">q</code>。我们看到第一个<code class="fe lg lh li lj b">q</code>(在“问题”中)后面跟着一个<code class="fe lg lh li lj b">u</code>，所以失败了。我们看下一个<code class="fe lg lh li lj b">q</code>，后面跟着一个<code class="fe lg lh li lj b">?</code>字符。因为<code class="fe lg lh li lj b">?</code>不是一个<code class="fe lg lh li lj b">u</code>，所以这个传递，我们得到返回的<code class="fe lg lh li lj b">true</code>。</li></ul><p id="8d9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至此，我们已经看到了如何编写字符类来包含和排除某些字符组/范围。</p><p id="2066" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能会发现编写一些更常用的字符类既冗长又乏味。然而，有一个解决方案——速记字符类！</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="ef8a" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">速记字符类提供了一种编写字符类的简化方法</h1><p id="ffda" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">#单词字符，#空格字符</p><p id="60c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为有些字符是常用的，所以有几个快捷键供我们使用，而不是敲出来什么的，比如<code class="fe lg lh li lj b">[a-zA-Z0–9_]</code>。</p><p id="00a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些快捷方式被称为速记字符或速记字符类。</p><p id="30fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有几个我们可以使用:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/d0a1654b8d88dffd0f12fbb7594131c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*-0KNCt7wBY1T6lt3mCkCuQ.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">通过使用速记字符类，我们可以用一种极端截短的方式书写常用的字符组/范围。请注意，对于\s和\S，类的开头包含一个空格。</p></figure><p id="0ab8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上表向我们介绍了通常被称为<em class="ko">单词字符</em>的东西，它被认为是任何字母数字字符，不区分大小写，或下划线字符。</p><p id="c527" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它还向我们介绍了<code class="fe lg lh li lj b">whitespace characters</code>；代表任何形式空白的字符，无论是常规空格、制表符、换行符等等。</p><p id="9344" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请特别注意这个表格的标题——虽然许多形式的空格都有转义字符，但是最基本的形式，一个简单的空格，仅仅被表示为一个空格。</p><p id="cb92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果我们用正则表达式<code class="fe lg lh li lj b">/ /</code>对字符串<code class="fe lg lh li lj b">Super Mario</code>运行<code class="fe lg lh li lj b">.test</code>，我们将得到返回的<code class="fe lg lh li lj b">true</code>，因为正则表达式只是一个空格字符，并且在提供的字符串中的<code class="fe lg lh li lj b">S</code>和<code class="fe lg lh li lj b">M</code>之间存在一个空格字符。</p><p id="cbd4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用速记字符类的例子可以在下面的要点中看到:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="afc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个要点中包含了相当多的信息，但是只要你理解了每个速记字符类的基本用法，你就应该很好，并且可以从那里开始。</p><p id="59a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">试着用你自己的创作来修改这些要点，看看哪些行得通，哪些行不通。</p><p id="6bae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们看到这些快捷键覆盖了很多字符，但是仍然没有一个正则表达式匹配到目前为止我们看到的所有字符。</p><p id="ccbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可能会遇到这样的情况，我们只需要检测是否有任何形式的输入被检测到，或者我们有一个字符串，我们不需要关心其中有什么字符。对于这样的情况，我们可以使用点字符。</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="69b3" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">点元字符几乎匹配任何正则表达式字符</h1><p id="d887" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">#点</p><p id="2a2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">dot <code class="fe lg lh li lj b">.</code>元字符在技术上不是一个字符类，但是可以以非常相似的方式使用。</p><p id="32f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">点匹配几乎任何字符，除了JavaScript中的换行符。</p><p id="d5f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了避开这个界限，regular-expressions.info建议使用字符类<code class="fe lg lh li lj b">[/s/S]</code>。</p><p id="c90a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如前所述，这些速记字符分别匹配任何空白字符和任何非空白字符。</p><p id="3efd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过结合使用这两者，我们创建了一个匹配每个字符的字符类。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mu mv l"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">点字符匹配除换行符之外的几乎所有字符。为了使字符类匹配任何可能的字符，包括换行符，我们使用[\s\S]字符类</p></figure></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="30c8" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">结论</h1><p id="647b" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">恭喜您，您已经成功阅读了本系列关于正则表达式的第二部分！</p><p id="3ea3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到本文结束时，您应该理解字符类包含字符组或字符范围，并且这些组在字符和模式匹配方面可以是包含性的或排他性的。</p><p id="7097" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还学习了一种书写许多常用字符类的速记方法，并接触了点字符，其用法与字符类非常相似。</p><p id="338d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一定要看看这篇文章中包含的GitHub gists，并使用其他资源来进一步扩展你的角色类知识。</p><p id="ef59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下一篇文章中，我们将讨论量词，以及它们的使用如何允许字符重复，或者使字符在匹配方面可选。</p><p id="ed56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到时候见！</p></div></div>    
</body>
</html>