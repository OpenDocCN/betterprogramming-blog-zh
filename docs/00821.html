<html>
<head>
<title>Extending the Python Syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扩展Python语法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/adding-sugar-to-the-python-syntax-e89248ce6e72?source=collection_archive---------6-----------------------#2019-07-17">https://betterprogramming.pub/adding-sugar-to-the-python-syntax-e89248ce6e72?source=collection_archive---------6-----------------------#2019-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/49fc0988dc3ffcb97a7ced5287dfc441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qbXYuHzKD0B8kTbRN0BEwA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(<a class="ae jg" href="https://unsplash.com/photos/72vLY-QMd3w" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></figure><div class=""/><div class=""><h2 id="68d4" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">如何用主包装器给Python语法添加糖</h2></div><p id="cd96" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated"><span class="l lv lw lx bm ly lz ma mb mc di">我</span>爱Python。这是一种非常强大的语言，很容易编写和理解。它也有一个广泛的图书馆生态系统，允许你做你能想到的几乎任何事情(<a class="ae jg" href="https://xkcd.com/353/" rel="noopener ugc nofollow" target="_blank">甚至飞行</a>)。最近，它已经成为数据科学和机器学习的通用语言。我在日常工作中经常使用它，所以我可以说我相当精通它(毕竟我在Google有Python可读性😏 ).</p><p id="0543" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，Python并不完美。我最近开始在空闲时间学习Lisp。在学习的时候，我偶然发现了Lisp的一个我认为非常酷(但是很小)的特性。在定义函数时，Lisp允许使用以前的参数作为默认值。</p><p id="23ac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，假设您正在编写一个<code class="fe md me mf mg b">make_rectangle</code>函数，它将左上角的<code class="fe md me mf mg b">x, y</code>坐标、<code class="fe md me mf mg b">width</code>和<code class="fe md me mf mg b">height</code>作为输入，并返回矩形四个角的<code class="fe md me mf mg b">x, y</code>坐标。在Python中，我们可以很容易地做到这一点:</p><figure class="mh mi mj mk gt iv"><div class="bz fp l di"><div class="ml mm l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">函数在Python中制作一个矩形。</p></figure><p id="2853" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在假设我们希望函数返回squares，如果它只通过了<code class="fe md me mf mg b">width</code>参数。如果您以前从未编程过，您可能会认为合理的做法是设置<code class="fe md me mf mg b">height=width</code>，就像这样:</p><figure class="mh mi mj mk gt iv"><div class="bz fp l di"><div class="ml mm l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">允许“make_rectangle”处理正方形的合理但无效的语法。</p></figure><p id="d334" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不幸的是，它不是有效的Python。如果您尝试运行它，您会得到一个错误:</p><pre class="mh mi mj mk gt mn mg mo mp aw mq bi"><span id="13f6" class="mr ms jj mg b gy mt mu l mv mw">NameError: name 'width' is not defined.</span></pre><p id="28ca" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我个人觉得这是语言的败笔。当然，绕过语法并获得类似的行为是很容易的:</p><figure class="mh mi mj mk gt iv"><div class="bz fp l di"><div class="ml mm l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">允许“make_rectangle”处理正方形的Pythonic方式。</p></figure><p id="f441" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但那让我很生气！语言应该做我想做的事情，而不是相反。我没有屈从于Python的意志，而是创建了一个<code class="fe md me mf mg b">__main__</code>包装器，让我编写自己想要的代码。</p><p id="1ee6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和往常一样，我的GitHub 上有完整的工作代码<a class="ae jg" href="https://github.com/EugenHotaj/python-meta" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="b0d8" class="mx ms jj bd my mz na nb nc nd ne nf ng kp nh kq ni ks nj kt nk kv nl kw nm nn bi translated"><em class="no">主包装纸</em></h1><p id="9956" class="pw-post-body-paragraph ky kz jj la b lb np kk ld le nq kn lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated"><code class="fe md me mf mg b">__main__</code>包装器是一个Python程序，它包装另一个Python程序的<code class="fe md me mf mg b">__main__</code>函数。包装器可以在调用主程序之前运行任何它想要的代码。原来很多工具都是这么写的，比如<a class="ae jg" href="https://docs.python.org/3/library/pdb.html" rel="noopener ugc nofollow" target="_blank"> pdb </a>、<a class="ae jg" href="https://docs.python.org/2/library/profile.html#module-profile" rel="noopener ugc nofollow" target="_blank"> profile </a>等。如果你对所有的细节感兴趣，大卫·比兹利有一个关于这个话题的有趣的演讲。</p><p id="f72a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为包装器在主程序之前运行，所以它有可能在执行主程序之前修改主程序的代码。这意味着我们可以使用<code class="fe md me mf mg b">__main__</code>包装器将类似<code class="fe md me mf mg b">improved_make_rectangle.py</code>的代码转换成类似<code class="fe md me mf mg b">valid_make_rectangle.py</code>的有效Python。这样，我们可以用更令人愉快的语法编写代码，同时Python解释器仍然可以正确地执行它。</p><h2 id="7344" class="mr ms jj bd my nu nv dn nc nw nx dp ng lh ny nz ni ll oa ob nk lp oc od nm oe bi translated">论方法</h2><p id="93bc" class="pw-post-body-paragraph ky kz jj la b lb np kk ld le nq kn lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated"><em class="of">(其他可能方法的快速切线；随意跳过。)</em></p><p id="6da8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我想了很多如何在没有包装器的情况下添加这个功能，也许是通过函数装饰器、上下文管理器等等。然而，我意识到这是不可能的，因为<code class="fe md me mf mg b">improved_make_rectangle.py</code>不是有效的Python。</p><p id="849b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我考虑探索的另一个途径是修改Python解释器本身。我不采用这种方法主要有两个原因:</p><ol class=""><li id="f413" class="og oh jj la b lb lc le lf lh oi ll oj lp ok lt ol om on oo bi translated">这听起来要乏味得多，因为您必须修改底层的C代码。</li><li id="7d54" class="og oh jj la b lb op le oq lh or ll os lp ot lt ol om on oo bi translated">它的可移植性较差，因为它涉及到派生Python解释器。任何想要使用新语法的人都只能通过分叉解释器来实现。相反，<code class="fe md me mf mg b">__main__</code>包装器只是普通的Python。</li></ol><p id="2481" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你知道实现这个功能的更好的方法，请在评论中告诉我。我很有兴趣一探究竟！</p><h1 id="8480" class="mx ms jj bd my mz na nb nc nd ne nf ng kp nh kq ni ks nj kt nk kv nl kw nm nn bi translated">扩展Python语法</h1><p id="04c9" class="pw-post-body-paragraph ky kz jj la b lb np kk ld le nq kn lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">我们需要做的第一件事是创建一个能够运行其他程序的包装器。如[1]所示，这相当简单:</p><figure class="mh mi mj mk gt iv"><div class="bz fp l di"><div class="ml mm l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">编写` __main__ '包装器的通用模板。</p></figure><p id="701c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们执行第17行的主程序时，大部分代码只是确保Python环境设置正确。有趣的部分发生在第7–10行:这里我们读取主程序代码，<code class="fe md me mf mg b">preprocess</code>(即重写)它成为有效的Python，并编译它以执行。我们现在可以像这样运行任何Python程序来包装它:</p><pre class="mh mi mj mk gt mn mg mo mp aw mq bi"><span id="c623" class="mr ms jj mg b gy mt mu l mv mw">python3 -m main_wrapper some_random_program.py</span></pre><p id="955a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，<code class="fe md me mf mg b">preprocess</code>函数是我们自己写的。我们要做的是遍历主程序中的每一行代码，并找到所有函数头，即所有以<code class="fe md me mf mg b">def </code>开头的行(忽略任何前导空格)。然后，对于我们找到的每个头，我们想看看它的参数是否引用了以前定义的参数。如果是这样，我们想通过将它们设置为<code class="fe md me mf mg b">None</code>并将<code class="fe md me mf mg b">argument = argument or prev_argument</code>添加到函数定义的顶部，将它们转换成<code class="fe md me mf mg b">make_rectangle_valid.py</code>的等价物。这在代码中是这样的:</p><figure class="mh mi mj mk gt iv"><div class="bz fp l di"><div class="ml mm l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">将我们的扩展语法转换成有效Python的预处理器。</p></figure><p id="948a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们做了很多隐含的假设，这些假设需要在更健壮的实现中解决。例如，我们假设主程序的代码为每个缩进级别使用4个空格字符(第9行)，并且整个代码遵循PEP 8样式指南(否则，如果<code class="fe md me mf mg b">kwargs</code>在<code class="fe md me mf mg b">=</code>周围有空格，比如<code class="fe md me mf mg b">some_arg = 12</code>，第12行将失败)。虽然我们可以通过一些努力来放松这些假设，但我们在这里已经迈出了良好的第一步。</p><p id="904b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，您可能已经注意到了第10行对<code class="fe md me mf mg b">_buid_arg_to_prev_arg</code>函数的神秘调用。该函数负责解析函数头，并提取引用先前定义的参数的所有参数。为此，它首先删除了所有不是函数参数的内容，比如空格、括号、<code class="fe md me mf mg b">def</code>语句等。然后，对于每个参数，它检查是否引用了任何以前定义的参数，如果是，就将其添加到字典中。最后，字典被返回。这转化为以下代码:</p><figure class="mh mi mj mk gt iv"><div class="bz fp l di"><div class="ml mm l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">一种从参数到先前定义的参数建立字典的函数。</p></figure><p id="be2c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在已经有了让包装器工作的所有组件。这里是<code class="fe md me mf mg b">improved_make_rectangle.py</code>代码，同样带有一个简单的<code class="fe md me mf mg b">__main__</code>方法来检查矩形和正方形的实现:</p><figure class="mh mi mj mk gt iv"><div class="bz fp l di"><div class="ml mm l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">把这些放在一起。</p></figure><p id="b05f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和以前一样，在没有包装器的情况下运行会引发<code class="fe md me mf mg b">NameError:</code></p><pre class="mh mi mj mk gt mn mg mo mp aw mq bi"><span id="5053" class="mr ms jj mg b gy mt mu l mv mw">$ python3 wrapper_test.py<br/>Traceback (most recent call last):<br/>  File "wrapper_test.py", line 1, in &lt;module&gt;<br/>    def make_rectangle(x, y, width, height=width):<br/>NameError: name 'width' is not defined</span></pre><p id="e618" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，当我们使用包装器运行时，消息会在终端中正确地打印出来:</p><pre class="mh mi mj mk gt mn mg mo mp aw mq bi"><span id="42b3" class="mr ms jj mg b gy mt mu l mv mw">$ python3 -m wrap_main wrapper_test.py<br/>Rectangle: ((0, 0), (100, 0), (100, 200), (0, 200))<br/>Square: ((0, 0), (100, 0), (100, 100), (0, 100))</span></pre><h1 id="f03f" class="mx ms jj bd my mz na nb nc nd ne nf ng kp nh kq ni ks nj kt nk kv nl kw nm nn bi translated">结论</h1><p id="936b" class="pw-post-body-paragraph ky kz jj la b lb np kk ld le nq kn lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">在本文中，我们通过编写一个<code class="fe md me mf mg b">__main__</code>包装器给Python添加了一些额外的语法糖。就目前的情况来看，这个包装器相当脆弱，如果您试图在现实世界中使用它，它会非常失败。此外，为了去掉一些多余的行，我们不得不编写大量的代码。所以，综合考虑，包装可能不值得。然而，<code class="fe md me mf mg b">__main__</code>包装器本身是一种通用的元编程技术，它允许您扩展Python来做非常酷和有趣的事情。如果没有别的，他们写起来很有趣🙂。</p><p id="0c70" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p><p id="004d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">欧根·霍塔吉<br/>2019年7月15日</p><p id="4703" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了简洁起见，我在这篇文章中跳过了一些次要的东西。如果你想要完整的细节，请在我的GitHub 上查看完整的工作代码<a class="ae jg" href="https://github.com/EugenHotaj/python-meta" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="8662" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢这篇文章，那就关注我，让我通知你有新的帖子！</p><h1 id="3601" class="mx ms jj bd my mz na nb nc nd ne nf ng kp nh kq ni ks nj kt nk kv nl kw nm nn bi translated">脚注</h1><p id="3261" class="pw-post-body-paragraph ky kz jj la b lb np kk ld le nq kn lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">在所有值得夸耀的事情中，在谷歌拥有Python可读性可能是最愚蠢的。以防不明显，我只是在开玩笑。</p><p id="5da1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果上帝<a class="ae jg" href="https://xkcd.com/224/" rel="noopener ugc nofollow" target="_blank">用Lisp</a>创造了宇宙，我想找出所有大惊小怪的原因。如果你也好奇的话，<a class="ae jg" href="http://www.gigamonkeys.com/book/" rel="noopener ugc nofollow" target="_blank">实用公共Lisp </a>是一本很棒的免费书籍。</p><p id="2ed9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">值得指出的是，以这种方式寻找函数定义是非常脆弱的。虽然这对于快速原型来说是可以的，但是更健壮的东西需要遵循<a class="ae jg" href="https://docs.python.org/3/reference/compound_stmts.html#function-definitions" rel="noopener ugc nofollow" target="_blank"> Python参考文献</a>。</p><h1 id="dcf3" class="mx ms jj bd my mz na nb nc nd ne nf ng kp nh kq ni ks nj kt nk kv nl kw nm nn bi translated">参考</h1><p id="b408" class="pw-post-body-paragraph ky kz jj la b lb np kk ld le nq kn lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">[1] D. Beazley，<a class="ae jg" href="https://speakerdeck.com/dabeaz/modules-and-packages-live-and-let-die?slide=70" rel="noopener ugc nofollow" target="_blank">模块和包:生与死！</a>，PyCon (2015)。</p></div></div>    
</body>
</html>