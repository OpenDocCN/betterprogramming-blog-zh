<html>
<head>
<title>Terraform Features for Dynamic Resource Creation and Provisioning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于动态资源创建和供应的地形特征</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/terraform-features-for-dynamic-resource-creation-and-provisioning-d01672615e4a?source=collection_archive---------4-----------------------#2021-10-06">https://betterprogramming.pub/terraform-features-for-dynamic-resource-creation-and-provisioning-d01672615e4a?source=collection_archive---------4-----------------------#2021-10-06</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="a413" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">当需要更动态的基础设施即代码方法时，您可以做什么</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/f483a359e0498679048a8ebc34a00122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V1VUTssul_iGKyg6"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@kieran_wood?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">基兰·伍德</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="012c" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">动态资源供应</h1><p id="4b9f" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">过去，基础架构的设置和维护通常是手动进行的。一段时间后，管理员只能猜测发生了什么变化。这使得系统不太可能具有相同的配置，因此，问题可能出现在一组机器上，而不会出现在另一组机器上。</p><p id="954f" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">在那个时候，复制一个系统的配置并不是一个硬性要求，因为服务器的数量通常不会经常改变。</p><p id="6b9b" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">然而，在按需创建和销毁服务器和容器的弹性云环境中，需要一天多次从头创建运行时环境。重要的是，这些环境的行为都是一样的，不需要人工干预。</p><p id="5b7a" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">我也在弹性公共云环境上运行我的副业项目。为了管理我的云服务器的设置和配置，我使用了<a class="ae kz" href="https://www.terraform.io" rel="noopener ugc nofollow" target="_blank"> Terraform </a> (TF)。我还使用TF为这些服务器提供应用程序代码。<a class="ae kz" href="https://www.terraform.io/docs/language/resources/provisioners/syntax.html#provisioners-are-a-last-resort" rel="noopener ugc nofollow" target="_blank">似乎不是最佳实践</a>，但是我不想在项目中引入另一个工具，比如Ansible。</p><blockquote class="mt mu mv"><p id="82ba" class="ls lt mw lu b lv mo jv lx ly mp jy ma mx mq md me my mr mh mi mz ms ml mm mn in bi translated">“Terraform是HashiCorp作为代码工具的基础设施。它允许您在可读的声明性配置文件中定义资源和基础架构，并管理基础架构的生命周期。”<br/> — <a class="ae kz" href="https://learn.hashicorp.com/tutorials/terraform/infrastructure-as-code" rel="noopener ugc nofollow" target="_blank">用Terraform | Terraform — HashiCorp学习基础设施代码简介</a></p></blockquote><p id="7bd7" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">下面是设置和配置过程的样子:</p><ol class=""><li id="993a" class="na nb iu lu b lv mo ly mp mb nc mf nd mj ne mn nf ng nh ni bi translated">在<a class="ae kz" href="https://www.hetzner.com/cloud" rel="noopener ugc nofollow" target="_blank"> Hetzner cloud </a>上创建一个新的云服务器</li><li id="75c4" class="na nb iu lu b lv nj ly nk mb nl mf nm mj nn mn nf ng nh ni bi translated">将应用程序复制到云服务器并安装依赖项</li><li id="5f0b" class="na nb iu lu b lv nj ly nk mb nl mf nm mj nn mn nf ng nh ni bi translated">复制systemd配置</li><li id="88ef" class="na nb iu lu b lv nj ly nk mb nl mf nm mj nn mn nf ng nh ni bi translated">启用systemd配置</li><li id="6250" class="na nb iu lu b lv nj ly nk mb nl mf nm mj nn mn nf ng nh ni bi translated">重启云服务器</li><li id="c9de" class="na nb iu lu b lv nj ly nk mb nl mf nm mj nn mn nf ng nh ni bi translated">更新DNS记录</li></ol><p id="50ef" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">我打算将我的辅助项目的主应用程序分成多个模块，这些模块需要在应用程序启动之前分别部署和链接。因此，我在寻找动态创建和提供TF资源的可能性。</p><h1 id="990e" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">地形元论元</h1><p id="be30" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">如上所述，TF提供了人类可读的声明性配置文件<em class="mw"> </em>来管理基础设施的生命周期。因此，. tf文件可以是云基础架构的文本表示，包括服务器、网络、存储等。</p><p id="8c13" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">将动态部分引入静态配置会使阅读和理解发生的事情变得更加困难。然而，如果我们更喜欢灵活性而不是简单性，这个缺点可能是可以接受的。</p><p id="1ba1" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">那么TF提供了什么呢？三个元论元<code class="fe no np nq nr b">for_each</code>、<code class="fe no np nq nr b">count</code>和<code class="fe no np nq nr b">depends_on</code>。</p><p id="f639" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">使用<code class="fe no np nq nr b">count</code>，我们可以创建相同资源的任意数量的实例。例如，多个<a class="ae kz" href="https://aws.amazon.com/ec2/" rel="noopener ugc nofollow" target="_blank"> AWS EC2 </a>实例或<a class="ae kz" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank"> AWS S3 </a>桶。</p><blockquote class="mt mu mv"><p id="e29b" class="ls lt mw lu b lv mo jv lx ly mp jy ma mx mq md me my mr mh mi mz ms ml mm mn in bi translated">“<code class="fe no np nq nr b">count</code>元参数接受一个整数，并创建资源或模块的多个实例。每个实例都有一个与之相关联的独特的基础结构对象，并且在应用配置时会单独创建、更新或销毁每个实例。”<br/>—<a class="ae kz" href="https://www.terraform.io/docs/language/meta-arguments/count.html" rel="noopener ugc nofollow" target="_blank">https://www . terraform . io/docs/language/meta-arguments/count . html</a></p></blockquote><p id="e6b3" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">与<code class="fe no np nq nr b">count</code>类似，<code class="fe no np nq nr b">for_each</code>参数可以基于一个地图或集合的元素创建多个资源。</p><blockquote class="mt mu mv"><p id="fccd" class="ls lt mw lu b lv mo jv lx ly mp jy ma mx mq md me my mr mh mi mz ms ml mm mn in bi translated">“<code class="fe no np nq nr b"><em class="iu">for_each</em></code>元参数接受一个映射或一组字符串，并为该映射或集合中的每个项目创建一个实例。每个实例都有一个与之相关联的独特的基础结构对象，并且在应用配置时会单独创建、更新或销毁每个实例。”<br/>—<a class="ae kz" href="https://www.terraform.io/docs/language/meta-arguments/for_each.html" rel="noopener ugc nofollow" target="_blank">https://www . terraform . io/docs/language/meta-arguments/for _ each . html</a></p></blockquote><p id="4f41" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><code class="fe no np nq nr b">depends_on</code>参数允许我们定义TF模块必须被实例化的顺序。这样，我们可以告诉TF在配置开始之前完成服务器的创建。</p><blockquote class="mt mu mv"><p id="98f1" class="ls lt mw lu b lv mo jv lx ly mp jy ma mx mq md me my mr mh mi mz ms ml mm mn in bi translated">"<code class="fe no np nq nr b">depends_on</code>元参数(如果存在的话)必须是对同一调用模块中的其他资源或子模块的引用列表。在<code class="fe no np nq nr b">depends_on</code>参数值中不允许任意表达式，因为它的值必须在Terraform知道资源关系之前知道，因此在它可以安全地计算表达式之前就知道。<br/>—<a class="ae kz" href="https://www.terraform.io/docs/language/meta-arguments/depends_on.html" rel="noopener ugc nofollow" target="_blank">https://www . terraform . io/docs/language/meta-arguments/depends _ on . html</a></p></blockquote><h1 id="241b" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">行动中的反论点</h1><p id="b2a0" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated"><code class="fe no np nq nr b">count</code>指令使我们能够用相同的配置创建任意数量的资源，如果我们想创建多个实例而不重复，这是很有帮助的。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><h1 id="c1f8" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">实际操作中的for_each参数</h1><p id="3177" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">与<code class="fe no np nq nr b">count</code>类似，<code class="fe no np nq nr b">for_each</code>参数创建一个资源的多个实例。不同之处在于<code class="fe no np nq nr b">for_each</code>确实需要一个列表或一个映射值，它将在给定的映射或集合中设置每个元素的一个实例。</p><p id="a6e7" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">我们可以在服务器资源级别使用<code class="fe no np nq nr b">for_each</code>参数来创建多个具有相同配置和不同名称的服务器。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><p id="be0b" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">但是，我们如何将一个或多个修改——基于一个映射或集合——应用到现有资源，而不是创建同一资源的多个实例呢？</p><p id="c346" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">对于这些情况，我们需要看起来像资源但实际上不是的东西，比如TF <code class="fe no np nq nr b">null_resource</code>。</p><blockquote class="mt mu mv"><p id="ca6c" class="ls lt mw lu b lv mo jv lx ly mp jy ma mx mq md me my mr mh mi mz ms ml mm mn in bi translated">"<code class="fe no np nq nr b">null_resource</code>资源实现了标准的资源生命周期，但是没有采取进一步的行动."<br/><a class="ae kz" href="https://registry.terraform.io/providers/hashicorp/null/latest/docs/resources/resource" rel="noopener ugc nofollow" target="_blank">https://registry . terraform . io/providers/hashi corp/null/latest/docs/resources/resource</a></p></blockquote><p id="ecc8" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">当需要修改现有资源时，可以使用<code class="fe no np nq nr b">null_resource</code>。让我们把上面的例子改为只创建一个服务器，然后在这个服务器上运行多个命令。<code class="fe no np nq nr b">for_each</code>将遍历命令数组，然后在目标服务器上一个接一个地执行每个命令。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><h1 id="3d60" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">操作中的depends_on参数</h1><p id="9154" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">使用<code class="fe no np nq nr b">depends_on</code>参数，我们可以定义创建TF资源的顺序。有了这个指令，我们可以告诉TF在创建数据库之前生成一个存储卷，或者让TF在重新启动服务器之前完成资源设置。</p><p id="9d1e" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">在下面的要点中，我们可以看到两个TF模块:</p><ul class=""><li id="811b" class="na nb iu lu b lv mo ly mp mb nc mf nd mj ne mn nu ng nh ni bi translated">Prometheus活动用户导出器模块</li><li id="38fa" class="na nb iu lu b lv nj ly nk mb nl mf nm mj nn mn nu ng nh ni bi translated">重启模块</li></ul><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><p id="819a" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">重启模块依赖于普罗米修斯模块。因此，TF将在Prometheus之后实例化重启模块。从设置的角度来看，这一点很重要:重启必须在服务器设置完成后进行。</p><p id="cbe2" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">如果你对Prometheus主动用户输出器感兴趣，几周前我写了一个关于它的故事。查看下面的链接:</p><div class="nv nw gq gs nx ny"><a href="https://towardsdatascience.com/how-i-monitor-active-ssh-sessions-with-prometheus-and-grafana-f4811da0a8cc" rel="noopener follow" target="_blank"><div class="nz ab fp"><div class="oa ab ob cl cj oc"><h2 class="bd iv gz z fq od fs ft oe fv fx it bi translated">我如何监控与Prometheus和Grafana的SSH会话</h2><div class="of l"><h3 class="bd b gz z fq od fs ft oe fv fx dk translated">这是时间的问题，而不是事情是否会发生。最好做好准备。</h3></div><div class="og l"><p class="bd b dl z fq od fs ft oe fv fx dk translated">towardsdatascience.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kt ny"/></div></div></a></div><h1 id="de28" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">摘要</h1><p id="b553" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">基础设施即代码(IaC)工具允许我们将基础设施定义为人类可读的代码。它们的静态性质使得通常很容易阅读和理解设置了什么资源。然而，在某些情况下，灵活性和可扩展性可能比可读性更受青睐。</p><p id="84f7" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">TF提供了指令<code class="fe no np nq nr b">count</code>、<code class="fe no np nq nr b">for_each</code>和<code class="fe no np nq nr b">depends_on</code>，在一定程度上允许动态配置。</p></div><div class="ab cl on oo hy op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="in io ip iq ir"><p id="cd06" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">感谢阅读。如果您有任何反馈或进一步的想法，您可以通过Twitter <a class="ae kz" href="https://twitter.com/stfsy" rel="noopener ugc nofollow" target="_blank"> @stfsy </a>联系我</p></div></div>    
</body>
</html>