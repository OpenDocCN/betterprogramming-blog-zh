<html>
<head>
<title>Best Practices With JavaScript Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript承诺的最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-best-practices-promises-45928fbfebe2?source=collection_archive---------5-----------------------#2020-04-16">https://betterprogramming.pub/javascript-best-practices-promises-45928fbfebe2?source=collection_archive---------5-----------------------#2020-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="134a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用承诺清理代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5d228b3a2a18f4442ee0b5dbedbe1346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tMTv7ixeltje8jepPhhHKg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@matthewhenry?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马太·亨利</a>在<a class="ae ky" href="https://unsplash.com/s/photos/patterns?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b81e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写JavaScript代码的一些方法比其他方法更好。</p><p id="1073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究使用最新JavaScript promise特性的最佳实践。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="089e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将非承诺异步代码转换为承诺</h1><p id="203f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以用<code class="fe mz na nb nc b">util.promisify()</code>方法将非承诺的异步代码转换成承诺。这让我们可以用带有表单签名的异步回调函数转换许多函数，表单签名为<code class="fe mz na nb nc b">(err, res)</code>，其中<code class="fe mz na nb nc b">err</code>是一个有错误的对象，<code class="fe mz na nb nc b">res</code>有异步代码的结果。</p><p id="908f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何定义了承诺形式的函数也可以使用这个实用程序返回承诺形式。只要将承诺版本存储为符号属性<code class="fe mz na nb nc b">util.promisify.custom</code>的值，我们就可以得到承诺版本。</p><p id="b228" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，由于<code class="fe mz na nb nc b">setTimeout</code>在Node.js的标准库中有一个基于promise的版本，我们可以将其转换为promise，如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="38d5" class="nh md it nc b gy ni nj l nk nl">const util = require('util');<br/>const sleep = util.promisify(setTimeout);</span><span id="96b0" class="nh md it nc b gy nm nj l nk nl">(async () =&gt; {<br/>  await sleep(1000);<br/>  console.log('slept');<br/>})()</span></pre><p id="e365" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了一个<code class="fe mz na nb nc b">sleep</code>函数，它可以在我们想要的时间暂停执行，而不必嵌套回调。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c719" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">异步链接</h1><p id="0284" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在老方法中，我们用<code class="fe mz na nb nc b">then</code>方法链接承诺。</p><p id="b15e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们写道:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="df29" class="nh md it nc b gy ni nj l nk nl">promise1<br/>  .then((res) =&gt; {<br/>    //...<br/>    return promise2<br/>  })<br/>  .then((res) =&gt; {<br/>    //...<br/>    return promise3<br/>  })<br/>  .then((res) =&gt; {<br/>    //...<br/>  })</span></pre><p id="8d85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用<code class="fe mz na nb nc b">async</code>和<code class="fe mz na nb nc b">await</code>来清理，如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="42af" class="nh md it nc b gy ni nj l nk nl">(async () =&gt; {<br/>  const val1 = await promise1;<br/>  //...<br/>  const val2 = await promise2;<br/>  //...<br/>  const val3 = await promise3;<br/>  //...<br/>})();</span></pre><p id="d8d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这要干净得多，因为resolve promise值被分配给左侧的常量或变量。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5650" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用Catch捕获错误</h1><p id="1737" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">与同步代码一样，我们必须捕捉错误并优雅地处理它们。</p><p id="567d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了用promise代码做到这一点，我们可以调用<code class="fe mz na nb nc b">catch</code>方法。例如:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="72d2" class="nh md it nc b gy ni nj l nk nl">promise1<br/>  .then((res) =&gt; {<br/>    //...<br/>    return promise2<br/>  })<br/>  .then((res) =&gt; {<br/>    //...<br/>    return promise3<br/>  })<br/>  .then((res) =&gt; {<br/>    //...<br/>  })<br/>  .catch((err) =&gt; {<br/>    //...<br/>  })</span></pre><p id="e9e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用<code class="fe mz na nb nc b">async</code>和<code class="fe mz na nb nc b">await</code>，那么我们就像使用同步代码一样使用<code class="fe mz na nb nc b">try...catch</code>，如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6ec2" class="nh md it nc b gy ni nj l nk nl">(async () =&gt; {<br/>  try {<br/>    const val1 = await promise1;<br/>    //...<br/>    const val2 = await promise2;<br/>    //...<br/>    const val3 = await promise3;<br/>    //...<br/>  } catch (ex) {<br/>    //...<br/>  }<br/>})();</span></pre><p id="b1ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个例子中的代码<code class="fe mz na nb nc b">catch</code>将在第一个承诺被拒绝时运行。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="938f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用Finally运行无论承诺的结果如何都应该运行的代码</h1><p id="7f69" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们需要运行应该运行的代码，而不管promise链的结果如何，那么我们应该对async和await代码使用<code class="fe mz na nb nc b">finally</code>方法或<code class="fe mz na nb nc b">finally</code>块。</p><p id="a5c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以如下运行<code class="fe mz na nb nc b">finally</code>中的清理代码:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="38a0" class="nh md it nc b gy ni nj l nk nl">promise1<br/>  .then((res) =&gt; {<br/>    //...<br/>    return promise2<br/>  })<br/>  .then((res) =&gt; {<br/>    //...<br/>    return promise3<br/>  })<br/>  .then((res) =&gt; {<br/>    //...<br/>  })<br/>  .finally((err) =&gt; {<br/>    //...<br/>  })</span></pre><p id="0a90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者我们可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="51f5" class="nh md it nc b gy ni nj l nk nl">(async () =&gt; {<br/>  try {<br/>    const val1 = await promise1;<br/>    //...<br/>    const val2 = await promise2;<br/>    //...<br/>    const val3 = await promise3;<br/>    //...<br/>  } catch (ex) {<br/>    console.log(ex);<br/>  } finally {<br/>    //...<br/>  }<br/>})();</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1db2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用Promise.all()的多个异步调用</h1><p id="4e98" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们想同时运行多个不相关的承诺，那么我们应该使用<code class="fe mz na nb nc b">Promise.all</code>。</p><p id="782d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以一次运行它们，如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="3bab" class="nh md it nc b gy ni nj l nk nl">Promise.all([<br/>    promise1,<br/>    promise2,<br/>    promise3,<br/>  ])<br/>  .then((res) =&gt; {<br/>    //...  <br/>  })</span></pre><p id="a75f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们用<code class="fe mz na nb nc b">async</code>和<code class="fe mz na nb nc b">await</code>，我们可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a4df" class="nh md it nc b gy ni nj l nk nl">(async () =&gt; {<br/>  const [val1, val2, val3] = await Promise.all([<br/>    promise1,<br/>    promise2,<br/>    promise3,<br/>  ])<br/>})();</span></pre><p id="712b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两个例子中，所有三个承诺的解析值要么在<code class="fe mz na nb nc b">res</code>中，要么被分配给左边的一个数组(在第二个例子中)。</p><p id="aa3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，它们会同时运行，而不是等待每个问题解决。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4401" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><ul class=""><li id="17b6" class="nn no it lb b lc mu lf mv li np lm nq lq nr lu ns nt nu nv bi translated">我们可以通过使用承诺来清理我们的异步代码。</li><li id="33f8" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">通过使用<code class="fe mz na nb nc b">util.promisify</code>方法，可以使用节点应用程序将异步代码转换为承诺。</li><li id="cff6" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">如果我们想链承诺，之前一定要添加<code class="fe mz na nb nc b">catch</code>方法或块来优雅地处理错误。</li><li id="c7fe" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe mz na nb nc b">finally</code>无论承诺的结果如何，方法或块都可以用来运行一直运行的代码。</li><li id="f95a" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">对于同时履行不相关的承诺来说是很棒的。</li></ul></div></div>    
</body>
</html>