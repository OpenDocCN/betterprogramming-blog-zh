<html>
<head>
<title>Implementing TextFieldDelegate With Native SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用本机SwiftUI实现TextFieldDelegate</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-textfielddelegate-with-native-swiftui-a013c7ca34?source=collection_archive---------7-----------------------#2021-09-15">https://betterprogramming.pub/implementing-textfielddelegate-with-native-swiftui-a013c7ca34?source=collection_archive---------7-----------------------#2021-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5b3d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用本机SwiftUI了解TextFieldDelegate方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cad84c66a633a7c8e58aa447aab00849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fhq9IBYzX-ICrmxI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@driaug?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Dries Augustyns </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ae3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，离iOS 15的生产发布还有不到一周的时间，我仍然听说SwiftUI还没有准备好生产。可悲的是，它正在成为一个城市神话。</p><p id="8218" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是真的还是当权者不够努力？说实话，有一定道理。<code class="fe lv lw lx ly b">TextView</code>和<code class="fe lv lw lx ly b">ScrollView</code>都是UIKit中UI元素的很好的例子，它们在premier情况下不存在于SwiftUI中，或者后者只被部分实现。但这是一个非常动态的目标，只要付出一点努力，你就能获得非常好的结果。</p><p id="68d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于SwiftUI的布局能力领先UIKit好几光年，我认为这是值得的。</p><p id="7955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看另一个例子，<code class="fe lv lw lx ly b">TextField</code>。这已经在SwiftUI中实现了，但是从表面上看，like <code class="fe lv lw lx ly b">ScrollView</code>并没有完全实现。请和我一起踏上旅程，用更多的精力来研究这个问题。我想尝试用所有的修饰来实现<code class="fe lv lw lx ly b">TextField</code>，而不是诉诸<code class="fe lv lw lx ly b">UIViewRepresentable</code>。我想要一个本地解决方案。</p><h1 id="3433" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">案情摘要</h1><p id="ccf9" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">UIKit中的<code class="fe lv lw lx ly b">TextField</code>带有一个代理来帮助你使用它。在委托协议中，我发现有六个回调函数用于管理编辑，三个用于编辑文本，还有一个用于报告文本选择的变化。</p><p id="e22b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我想尽可能多地实现这些功能，而不求助于<code class="fe lv lw lx ly b">UIViewRepresentable</code>。</p><p id="09b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该从实现一个扩展来报告键盘是否出现在屏幕上开始。</p><p id="29d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果存在，那么显然有人点击了你的<code class="fe lv lw lx ly b">TextField</code>。当然，如果我们有多个TextField，我们可能不知道哪个是SwiftUI。这是一个苹果已经<a class="ae ky" href="https://developer.apple.com/documentation/swiftui/menu/focused(_:)" rel="noopener ugc nofollow" target="_blank">在iOS 15中解决了</a>的疏忽，你会很高兴地知道，但我不打算在这里覆盖它。尽管我认为可以围绕它编写一些代码，但请继续阅读。让我们从检测键盘的代码开始。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6f4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧——当你在使用它的时候，这里是收起键盘的代码——你也需要它。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="a4f8" class="nc ma it ly b gy nd ne l nf ng">func hideKeyboard() {<br/>UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)<br/>}</span></pre><p id="4b98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们有带<code class="fe lv lw lx ly b">onCommit</code>和<code class="fe lv lw lx ly b">onEditingChanged</code>标签的SwiftUI。它们之间的这两个标签覆盖了<code class="fe lv lw lx ly b">textFieldDidDidBeginEditing</code>和<code class="fe lv lw lx ly b">textFieldDidDidEndEditing</code>州。</p><p id="f44e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要管理文本本身的编辑，您可以使用<code class="fe lv lw lx ly b">onChange</code>标签，它可以报告对<code class="fe lv lw lx ly b">TextField</code>的更改并做出相应的响应。</p><p id="bedc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码示例中，我在这里展示了我们将输入限制为仅大写字母:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c52d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快速回顾一下代码的其余部分:</p><ul class=""><li id="9874" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">我们使用一个类来包含文本输入框中引用的变量，这样我就可以轻松地在SwiftUI代码之外访问它。</li><li id="a184" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">在那里使用了<code class="fe lv lw lx ly b">willSet</code>和<code class="fe lv lw lx ly b">didSet</code>模板——我可以添加更多的<code class="fe lv lw lx ly b">PassThroughSubjects</code>。</li><li id="96cf" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">两个神奇的数字<code class="fe lv lw lx ly b">123</code>和<code class="fe lv lw lx ly b">789</code>只不过是对字段的引用，所以我可以判断哪个是当前活动的。</li><li id="5b97" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">这两个字段在出现时都是启用的，显然，如果这样做更有意义，您可以用不同的方式编写代码。</li><li id="a2dd" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">使用模板SwiftUI输入文本<code class="fe lv lw lx ly b">isEditing</code>标志和<code class="fe lv lw lx ly b">currentFieldPublisher</code> ID，控制发送哪个(开始编辑或结束编辑)消息。</li><li id="5b28" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">当您点按字段时显示键盘，当您按下return键时关闭键盘。</li><li id="f9ba" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">增加了一些<code class="fe lv lw lx ly b">PassThroughSubjects</code>来响应开始/结束+清除+启用/禁用组合消息。</li></ul><p id="b02a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的动画GIF显示了不同的消息和字段引用。当您在框中单击数字时，会出现后者。开始编辑显示为绿色圆圈，结束编辑显示为红色圆圈…橙色表示两者都不是。很明显，当我没有在第一个单词bat上输入大写字母时，你什么也看不到。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/eb40346fe6f5c4cb71adc0ec18ee30ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nwfbjI5WjtLGGKzmi9GQAw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SwiftUI TextField的实际实现</p></figure></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="005f" class="lz ma it bd mb mc od me mf mg oe mi mj jz of ka ml kc og kd mn kf oh kg mp mq bi translated">结论</h1><p id="02f0" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">代码中还有几个标签，没什么特别的——只是标准票价。所有这些让我想到这篇短文的结尾。霍普也认为这并不像有些人想让我们相信的那样糟糕。保持冷静，继续编码。</p></div></div>    
</body>
</html>