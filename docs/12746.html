<html>
<head>
<title>Tips to Design a DynamoDB Table</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计DynamoDB表的技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/tips-for-design-a-dynamodb-table-d12faf3d0a67?source=collection_archive---------3-----------------------#2022-06-28">https://betterprogramming.pub/tips-for-design-a-dynamodb-table-d12faf3d0a67?source=collection_archive---------3-----------------------#2022-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="161e" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">我设计DynamoDb表的技巧和诀窍</h2><div class=""/><div class=""><h2 id="2899" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">高效便捷地</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/61511027a0cfb65c4bac71138a3b15d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-CGZPr6WtzRGRySU"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">Jan Antonin Kolar 在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="fc41" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">什么是DynamoDB？</h1><p id="5edb" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">Amazon DynamoDB是一个完全托管的、无服务器的键值NoSQL数据库，旨在运行任何规模的高性能应用程序。在对数据建模时，需要考虑一些事情，比如访问模式和安全性。</p><p id="ff5f" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">今天我将描述一些我在用单表设计来设计DynamoDb表时考虑的技巧。</p><h1 id="b721" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">类型对象的名称</h1><p id="ede9" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">当我的表中有多个类型对象时，我添加对象名作为前缀作为分区键。为什么？如果要使用IAM策略限制访问，可以指定类型对象的名称。在这种情况下，您可以创建一个策略，其中一个组只能读取该类型的对象，另一个组可以读取和写入相同类型的对象。</p><p id="a19c" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><code class="fe my mz na nb b">TYPE#ID</code></p><p id="dfb9" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">示例:</p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="0089" class="ng lg iq nb b gy nh ni l nj nk">Event#123 (for Event Object)</span><span id="7c41" class="ng lg iq nb b gy nl ni l nj nk">User#245 (for User Object)</span></pre><p id="35cc" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">您可以在单独的字段中添加相同的名称:这样，您可以从GSI中查询相同类型的所有记录。</p><h1 id="05ac" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">使用更新项目</h1><p id="a3ae" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">使用<code class="fe my mz na nb b">UpdateItem</code>来更新或添加一个项目是一件好事。如果一个元素已经存在，你不必担心覆盖它，因为<code class="fe my mz na nb b">UpdateItem</code>只更新特定的属性。</p><p id="18f8" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">如果您需要“覆盖”整个项目，您可以使用<code class="fe my mz na nb b">PutItem</code>来代替。</p><h2 id="6f56" class="ng lg iq bd lh nm nn dn ll no np dp lp mg nq nr lr mk ns nt lt mo nu nv lv iw bi translated">创建日期/更新日期</h2><p id="7abb" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">另一个好主意是保存记录的最后更新和创建日期。您可以填写<code class="fe my mz na nb b">updatedAt</code>和<code class="fe my mz na nb b">createdAt</code>来记录审计或向最终用户显示这些信息。</p><p id="364e" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><code class="fe my mz na nb b">createdAt = if_not_exists(createdAt, :now), updatedAt = :now</code></p><h2 id="c69f" class="ng lg iq bd lh nm nn dn ll no np dp lp mg nq nr lr mk ns nt lt mo nu nv lv iw bi translated">来源名称</h2><p id="7680" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">当您有多个更新DynamoDb的源时，您想知道是谁更新了该项。一个好的做法是添加一个带有源名称的字段。</p><p id="b955" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">您可以使用此字段过滤流或审计的元素。</p><p id="43a1" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">例如:在<code class="fe my mz na nb b">dynamodb</code> streams上附加了一个lambda来更新记录。该更新可能会触发更新循环。您可以使用按事件桥筛选条件来筛选具有特定源名称的所有记录。</p><h1 id="52c7" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">所有者Id</h1><p id="e6b3" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在您的分区键中，您可以添加写记录的所有者用户<code class="fe my mz na nb b">id</code>。</p><p id="410e" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><code class="fe my mz na nb b">OWNERID#TYPE#ID</code></p><p id="2543" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">正如我们看到的对象名称，您可以有多个用户，他们可以读写自己的记录。如果在分区键的第一部分添加用户<code class="fe my mz na nb b">id</code>，就可以查询该用户拥有的所有记录。</p><p id="a07b" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">如果您使用IAM策略，您可以限制用户<code class="fe my mz na nb b">id</code>对所有记录的访问，这样，一个用户就不能代替另一个用户访问记录。</p><h1 id="d93b" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">时间戳与ISO日期时间</h1><p id="edc5" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">根据您希望如何检索数据，排序关键字的类型将至关重要。</p><p id="aa33" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">如果您想对数据创建的元素列表进行排序，您可以简单地设置类型<code class="fe my mz na nb b">string</code>并存储<code class="fe my mz na nb b">datetime iso</code>。默认情况下，DynamoDb按字节对元素进行排序。</p><p id="c5c9" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">以下是ISO <code class="fe my mz na nb b">Datetime</code>中过滤日期的一些例子:</p><ul class=""><li id="f986" class="nw nx iq lz b ma mt md mu mg ny mk nz mo oa ms ob oc od oe bi translated">获取所有六月项目</li></ul><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="f715" class="ng lg iq nb b gy nh ni l nj nk">KeyConditionExpression: 'begins_with(#date, “2022–06”)'</span></pre><ul class=""><li id="8a43" class="nw nx iq lz b ma mt md mu mg ny mk nz mo oa ms ob oc od oe bi translated">获取所有6月22日的项目</li></ul><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="e53a" class="ng lg iq nb b gy nh ni l nj nk">KeyConditionExpression: 'begins_with(#date, “2022–06–22”)'</span></pre><p id="8881" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">额外案例:对ISO日期时间使用between-like</p><pre class="kp kq kr ks gt nc nb nd ne aw nf bi"><span id="8502" class="ng lg iq nb b gy nh ni l nj nk">KeyConditionExpression: 'begins_with(#date, "2022–06"),<br/>ExpressionFilter: 'begins_with(#date, "2022–06–21") or begins_with(#date, "2022–06–22")'</span></pre><p id="8e8c" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">有了它，你可以得到两天的数据(像中间)。</p><blockquote class="of og oh"><p id="916f" class="lx ly oi lz b ma mt ka mc md mu kd mf oj mv mi mj ok mw mm mn ol mx mq mr ms ij bi translated">记住:首先DynamoDb查询整个6月的所有数据，然后根据6月22日和21日进行过滤。这不是一个有效的方法，但它是有效的。</p></blockquote><p id="c0c2" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">相反，如果你需要在日期之间过滤，正确的选择是<code class="fe my mz na nb b">timestamp</code>与数字类型。如果您有许多需要这种目的的访问模式，那么效率会更高。</p><p id="c39b" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">今天到此为止！单表设计的最佳实践是什么？我很想听听你的建议。</p><p id="089d" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">谢谢你，再见。</p></div></div>    
</body>
</html>