# 在 Swift 5.1 中使用属性包装器创建历史

> 原文：<https://betterprogramming.pub/creating-a-history-with-property-wrappers-in-swift-5-1-4c0202060a7f>

## 使用属性包装器使调试更容易

![](img/7bb015c30b52e9c230aedf3f0350f3e2.png)

包装属性，就像他们是这只狗——图片来自 [pixabay](https://pixabay.com/photos/pug-dog-pet-animal-puppy-cute-801826/) 的[免费照片](https://pixabay.com/users/free-photos-242387/)

有时，大型代码库会变得非常复杂，很难跟踪特定值在哪里以及如何变化。尤其是当新的开发人员来到一个现有的项目时，很难了解正在发生的事情。

也许你有一个由属性的特定值引起的错误，但是你看不到应用程序是如何到达这一步的。如果能有一份该房产所有价值的历史记录，看看以前发生过什么，岂不是很棒？但是，创建这样的历史将意味着您需要更改代码的许多部分，以便在设置新值时保存它。

在本文中，我们将探讨如何使用 Swift 的新物业包装器，通过对我们希望拥有历史记录的物业进行注释来轻松添加该功能。

## 什么是属性包装器？

属性包装是包装属性的结构，因此名称。这些结构提供对其封装属性的读写访问，并且可以在获取或设置值时执行代码。不要担心——当我们看一个例子时，这将变得更加清晰。

一个简单的用例是在用户默认值或 Keychain 中存储一个更新的值。或者，您可以确保新值在有效范围内，或者进行其他转换或验证。通过使用属性包装器，您可以减少样板代码的数量，因为您只需要编写一次逻辑，并且通过简单地注释您的属性就可以在任何地方使用它。

让我们看一个读取和写入 UserDefaults 的小示例属性包装:

实现将值存储到 UserDefaults 的属性包装。

`//1` —我们创建了一个名为`UserDefaultsContained`的新结构，并在其中添加了`@propertyWrapper`。这个结构有一个泛型参数`Value`，它将是包装属性的类型。

`//2` —每个属性包装器需要一个计算属性`wrappedValue`。这就是奇迹发生的地方。这里，我们指定在获取和设置包装值时应该发生什么。在本例中，我们将只读取和写入标准用户默认值。

`//3` —此外，这个结构有一个`key`用于访问 UserDefauls 中的包装值，还有一个`defaultValue`，在找不到值时用作后备。这两个值是在初始化器中设置的。

该属性包装可以这样使用:

使用属性包装@UserDefaultsContained。

`//1` —首先，我们通过在普通属性声明前添加属性包装器注释来创建一个新的`UserDefaultsContained`属性。在这种情况下，我们只是使用一个简单的布尔标志来存储用户是否已经完成了教程。如前所述，我们需要将两个值`key`和`defaultValue`传递给初始化器。

`//2` —现在我们可以像使用任何其他布尔值一样使用该属性，它将自动存储在 UserDefaults 中。

## 使用属性包装跟踪更改

现在我们已经看到了如何创建和使用属性包装器，让我们看看是否可以使用它们来解决我们在开始时讨论的问题。

实现创建属性历史记录的属性包装。

`//1`—就像之前一样，我们从创建一个新的结构开始。这一次我们称之为`Traceable`，因为我们将能够跟踪包装值的历史。

`//2`—这一次我们需要保留名为`value`的私有属性中的封装值，该值将在访问包装的属性时返回。在前面使用 UserDefaults 的例子中，我们不需要这样做，因为它总是可以通过从 UserDefaults 中读取来访问。为了改进历史信息，我们还将存储定义属性的文件的名称。

`//3`—`value`和`file`都将在初始化器中设置。您可能会注意到，我们首先存储值，然后调用计算属性的 setter`wrappedValue`。起初这似乎是不必要的，但是通过更新`wrappedValue`，我们用第一个元素触发了历史的创建。

`//4` —这里我们定义一个结构`HistoryEntry`来封装历史的一个条目的信息。每个条目都包含值、属性所在的文件名以及值更改的时间。

`//5` —最后，我们得到计算的属性`wrappedValue`。getter 非常简单:我们只需返回值。在 setter 中，我们将值更新为`newValue`，创建一个新条目，并将其添加到现有的历史记录中。

让我们使用这个属性包装器！

使用属性 wrapper @Tracable。

`//1` —假设我们想要为一个整数值创建一个历史记录。我们只需要在财产申报前面加上`@Tracable(file: #file)`就可以了。

`//2` —我们仍然可以像使用任何普通整数一样使用该属性。

`//3` —但是当我们需要更多信息时，我们可以调用`_*<property_name>*.history`并访问该属性的所有值。

# 结论

属性包装器是向属性添加额外功能的好方法。它们允许我们在一个地方定义它们发生了什么，从而帮助我们减少代码。

正如我们所见，它们可以用于各种情况，从持久化到操纵值，最后通过提供值的历史来帮助我们调试代码。