<html>
<head>
<title>Python Operator Overloading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python运算符重载</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-handle-operator-overloading-in-python-8ada8df7e448?source=collection_archive---------8-----------------------#2021-08-16">https://betterprogramming.pub/how-to-handle-operator-overloading-in-python-8ada8df7e448?source=collection_archive---------8-----------------------#2021-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0a3c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在不同的上下文中赋予普通运算符另一种含义</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2d749f0ee9d8758c940aeab1ff64c0f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OLOp0zED6guwtmzS"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@martinshreder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马丁·施瑞德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d0e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python中的运算符重载意味着在不同的上下文中赋予普通运算符另一种含义。</p><p id="a20f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可以用加法运算符<code class="fe lv lw lx ly b">+</code>将两个整数相加:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="ddbf" class="md me it ly b gy mf mg l mh mi">1 + 2</span></pre><p id="c300" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在默认情况下，您不能对自定义类的实例求和:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="7dee" class="md me it ly b gy mf mg l mh mi">apple + banana</span></pre><p id="b6a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是你可以改变这一点。要对自定义对象使用加法运算符<code class="fe lv lw lx ly b">+</code>，需要重载运算符<code class="fe lv lw lx ly b">+</code>。</p><p id="7e7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，您将学习如何重载操作符，使Python操作在您的对象上成为可能。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="92b8" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">Python中的特殊方法</h1><p id="079b" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在开始学习Python中的运算符重载之前，理解特殊方法(也称为双下划线方法或dunder方法)的概念很重要。</p><p id="a9cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特殊方法最简单的例子是一个类的<code class="fe lv lw lx ly b">__init__</code>方法。当创建类的新实例时，调用此方法。</p><p id="645d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="690d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面代码中的最后一行运行了<code class="fe lv lw lx ly b">Bill</code>类的<code class="fe lv lw lx ly b">__init__</code>方法。在这种情况下，它为实例赋值。</p><p id="5697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着打印实例:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e508" class="md me it ly b gy mf mg l mh mi">print(ten_dollars)</span></pre><p id="739b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d3ed" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">&lt;__main__.Bill object at 0x7fd2bcf99d00&gt;</strong></span></pre><p id="fdcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种明确的输出毫无意义。如果您想打印默认的金额，您可以提供一个名为<code class="fe lv lw lx ly b">__str__</code>的特殊方法的实现。它定义了对象的字符串表示。每当您对一个对象调用<code class="fe lv lw lx ly b">print</code>时，这个方法都会被调用。</p><p id="6739" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5df2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d9f8" class="md me it ly b gy mf mg l mh mi">I am a 10 dollar bill</span></pre><p id="824b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，打电话</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4c4d" class="md me it ly b gy mf mg l mh mi">print(ten_dollars)</span></pre><p id="5a5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与以下内容相同:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4104" class="md me it ly b gy mf mg l mh mi">print(ten_dollars.__str__())</span></pre><p id="beba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经了解了Python中特殊方法的工作原理。让我们跳到操作符重载。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b60f" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">Python中的运算符重载</h1><p id="36c7" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">Python运算符适用于内置类型。但是，同一个运算符在不同的内置类型中可能表现不同。</p><p id="ac0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<code class="fe lv lw lx ly b">+</code>运算符执行数字的加法。但是在字符串的上下文中，<code class="fe lv lw lx ly b">+</code>操作符连接两个字符串。这是通过运算符重载实现的。</p><p id="90e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运算符重载在不同的上下文中赋予运算符不同的含义。</p><p id="7ceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们看看如果我们创建一个<code class="fe lv lw lx ly b">Bill</code>类并添加它的两个实例会发生什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2f67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="0ce6" class="md me it ly b gy mf mg l mh mi">TypeError: unsupported operand type(s) for +: 'Bill' and 'Bill'</span></pre><p id="94a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误消息指出不支持将<code class="fe lv lw lx ly b">Bill</code>实例与<code class="fe lv lw lx ly b">+</code>实例相加。</p><p id="b6a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为Python不知道如何添加<code class="fe lv lw lx ly b">Bill</code>实例。所以我们必须在账单的上下文中定义<code class="fe lv lw lx ly b">+</code>的含义。运算符重载会发生这种情况。</p><p id="05b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了重载一个操作符<code class="fe lv lw lx ly b">+</code>，你需要在你的类中提供一个特殊方法的实现。</p><p id="a4e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论何时使用<code class="fe lv lw lx ly b">+</code>，都会调用一个叫做<code class="fe lv lw lx ly b">__add__</code>的特殊方法。</p><p id="8bf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果您想在两个账单上使用<code class="fe lv lw lx ly b">+</code>，在<code class="fe lv lw lx ly b">Bill</code>类中实现<code class="fe lv lw lx ly b">__add__</code>方法并定义预期的行为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="30a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="1cc3" class="md me it ly b gy mf mg l mh mi">15</span></pre><p id="10b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您可以添加两个<code class="fe lv lw lx ly b">Bill</code>的实例。<code class="fe lv lw lx ly b">+</code>操作符调用<code class="fe lv lw lx ly b">__add__</code>方法，该方法知道如何将<code class="fe lv lw lx ly b">Bill</code>的两个实例相加。</p><p id="ad1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，打电话</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="3f73" class="md me it ly b gy mf mg l mh mi">five_dollars + ten_dollars</span></pre><p id="0e20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相当于</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6ffe" class="md me it ly b gy mf mg l mh mi">five_dollars.__add__(ten_dollars)</span></pre><p id="c9f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在可以把账单加起来了。但是也许你希望能够以类似的方式减去账单。为此，在<code class="fe lv lw lx ly b">Bill</code>类中实现名为<code class="fe lv lw lx ly b">__sub__</code>的特殊方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="68e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="00a4" class="md me it ly b gy mf mg l mh mi">8</span></pre><p id="611f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与<code class="fe lv lw lx ly b">__add__</code>方法的工作方式完全相同，除了它从彼此中减去钞票的值。</p><p id="7311" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可以做加法和减法，你可能也想做乘法。为此，在<code class="fe lv lw lx ly b">Bill</code>类中实现名为<code class="fe lv lw lx ly b">__mul__</code>的特殊方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="895f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="ce2d" class="md me it ly b gy mf mg l mh mi">50</span></pre><p id="e703" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且既然你会乘法，也许你也想除法。为此，在<code class="fe lv lw lx ly b">Bill</code>类中实现一个名为<code class="fe lv lw lx ly b">__truediv__</code>的特殊方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="901e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="835d" class="md me it ly b gy mf mg l mh mi">2.0</span></pre><p id="3893" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太棒了。现在你可以用一个<code class="fe lv lw lx ly b">Bill</code>的实例做基本的数学运算，这都要感谢操作符重载。</p><p id="0647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在这里结束，但我想给你看一样东西。</p><p id="265a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您有了一个支持加减乘除的<code class="fe lv lw lx ly b">Bill</code>类。但是它不理解比较，例如:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a772" class="md me it ly b gy mf mg l mh mi">ten_dollars &gt;= five_dollars</span></pre><p id="83aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用运算符重载来解决这个问题。</p><h1 id="21e1" class="mq me it bd mr ms no mu mv mw np my mz jz nq ka nb kc nr kd nd kf ns kg nf ng bi translated">Python中的比较运算符重载</h1><p id="bb49" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">让我们继续与<code class="fe lv lw lx ly b"><a class="ae ky" href="https://gist.github.com/artturijalli/0b7d862bc6a501058469baefd8a1b4ee" rel="noopener ugc nofollow" target="_blank">Bill</a></code>类合作。你现在可以用<code class="fe lv lw lx ly b">Bill</code>实例做基本的数学运算，但是你不能比较它们。</p><p id="3e52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="ff2e" class="md me it ly b gy mf mg l mh mi">TypeError: '&gt;' not supported between instances of 'Bill' and 'Bill'</span></pre><p id="fd12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误信息很清楚。不支持将<code class="fe lv lw lx ly b">Bill</code>实例与运算符<code class="fe lv lw lx ly b">&gt;</code>进行比较。</p><p id="0fb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让您的<code class="fe lv lw lx ly b">Bill</code>实例支持大于比较，您需要依靠操作符重载。</p><p id="37bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这样做之前，您需要理解<code class="fe lv lw lx ly b">&gt;</code>是如何工作的。</p><p id="7a0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您在between之间使用<code class="fe lv lw lx ly b">&gt;</code>时，一个叫做<code class="fe lv lw lx ly b">__gt__</code>的特殊方法被称为under the hood ( <code class="fe lv lw lx ly b">gt</code>的意思是大于)。为了让<code class="fe lv lw lx ly b">Bill</code>实例支持<code class="fe lv lw lx ly b">&gt;</code>比较，它必须实现<code class="fe lv lw lx ly b">__gt__</code>方法。</p><p id="6de5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，将以下内容添加到您的<code class="fe lv lw lx ly b">Bill</code>类中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您可以测试它是否有效:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d47c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="95e1" class="md me it ly b gy mf mg l mh mi">Ten is more than five</span></pre><p id="1678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好，有用。</p><p id="21bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很好的概括引擎盖下的比较</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4b8e" class="md me it ly b gy mf mg l mh mi">ten_dollars &gt; five_dollars</span></pre><p id="60e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它相当于</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8ad0" class="md me it ly b gy mf mg l mh mi">ten_dollars.__gt__(five_dollars)</span></pre><p id="0167" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此,<code class="fe lv lw lx ly b">&gt;</code>操作符调用底层的<code class="fe lv lw lx ly b">__gt__</code>,它比较钞票的<code class="fe lv lw lx ly b">.value</code>属性。</p><p id="9840" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在可以使用<code class="fe lv lw lx ly b">&gt;</code>检查一个账单是否大于另一个账单。但是它不支持更多的比较，即<code class="fe lv lw lx ly b">&lt;</code>、<code class="fe lv lw lx ly b">&lt;=</code>、<code class="fe lv lw lx ly b">&gt;=</code>、<code class="fe lv lw lx ly b">==</code>、<code class="fe lv lw lx ly b">!=</code>。</p><p id="ef46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使<code class="fe lv lw lx ly b">Bill</code>支持所有的基本比较，您需要用各自的特殊方法重载每个比较操作符:</p><p id="cbfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是运算符和相关的特殊方法:</p><ul class=""><li id="5447" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated"><code class="fe lv lw lx ly b">&lt;</code> : <code class="fe lv lw lx ly b">__lt__</code></li><li id="19c2" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><code class="fe lv lw lx ly b">&gt;</code> : <code class="fe lv lw lx ly b">__gt__</code></li><li id="1e7e" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><code class="fe lv lw lx ly b">&lt;=</code> : <code class="fe lv lw lx ly b">__le__</code></li><li id="bf74" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><code class="fe lv lw lx ly b">&gt;=</code> : <code class="fe lv lw lx ly b">__ge__</code></li><li id="a232" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><code class="fe lv lw lx ly b">==</code> : <code class="fe lv lw lx ly b">__eq__</code></li><li id="6a75" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><code class="fe lv lw lx ly b">!=</code> : <code class="fe lv lw lx ly b">__ne__</code></li></ul><p id="7633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将这些实现到<code class="fe lv lw lx ly b">Bill</code>类中:</p><h2 id="3be0" class="md me it bd mr oh oi dn mv oj ok dp mz li ol om nb lm on oo nd lq op oq nf or bi translated">__lt__</h2><p id="badc" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">为了使<code class="fe lv lw lx ly b">Bill</code>支持比<code class="fe lv lw lx ly b">&lt;</code>更少的比较，将下面的方法添加到类中:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="3709" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">def</strong> __lt__(self, otherBill):<br/>    <strong class="ly iu">return</strong> self.value &lt; otherBill.value</span></pre><h2 id="875a" class="md me it bd mr oh oi dn mv oj ok dp mz li ol om nb lm on oo nd lq op oq nf or bi translated">__le__</h2><p id="b93c" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">为了使<code class="fe lv lw lx ly b">Bill</code>支持小于或等于与<code class="fe lv lw lx ly b">&lt;=</code>的比较，在类中添加以下方法:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="07e4" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">def</strong> __le__(self, otherBill):<br/>    <strong class="ly iu">return</strong> self.value &lt;= otherBill.value</span></pre><h2 id="6ed6" class="md me it bd mr oh oi dn mv oj ok dp mz li ol om nb lm on oo nd lq op oq nf or bi translated">__eq__</h2><p id="ec3d" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">为了使<code class="fe lv lw lx ly b">Bill</code>支持等同于操作符<code class="fe lv lw lx ly b">==</code>，在类中添加以下方法:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="39d7" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">def</strong> __eq__(self, otherBill):<br/>    <strong class="ly iu">return</strong> self.value == otherBill.value</span></pre><h2 id="9d71" class="md me it bd mr oh oi dn mv oj ok dp mz li ol om nb lm on oo nd lq op oq nf or bi translated">__ne__</h2><p id="4732" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">为了使<code class="fe lv lw lx ly b">Bill</code>支持不等于运算符<code class="fe lv lw lx ly b">!=</code>,将下面的方法添加到类中:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6d6b" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">def</strong> __ne__(self, otherBill):<br/>    <strong class="ly iu">return</strong> self.value != otherBill.value</span></pre><h2 id="2a94" class="md me it bd mr oh oi dn mv oj ok dp mz li ol om nb lm on oo nd lq op oq nf or bi translated">__gt__</h2><p id="cfeb" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">这个你已经做过了，但是为了完整起见，这里是实现:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a057" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">def</strong> __gt__(self, otherBill):<br/>    <strong class="ly iu">return</strong> self.value &gt; otherBill.value</span></pre><h2 id="07a7" class="md me it bd mr oh oi dn mv oj ok dp mz li ol om nb lm on oo nd lq op oq nf or bi translated">__ge__</h2><p id="570e" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">为了使<code class="fe lv lw lx ly b">Bill</code>支持大于或等于操作符<code class="fe lv lw lx ly b">&gt;=</code>，在类中添加以下方法:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e323" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">def</strong> __ge__(self, otherBill):<br/>    <strong class="ly iu">return</strong> self.value &gt;= otherBill.value</span></pre><p id="5894" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">厉害！现在你的<code class="fe lv lw lx ly b">Bill</code>类应该看起来像<a class="ae ky" href="https://gist.github.com/artturijalli/a6190a1f940a46cad3978a720ccc7641" rel="noopener ugc nofollow" target="_blank">这个</a>。它现在支持基本的数学和比较。</p><p id="69f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例到此结束，本指南到此结束。我希望你喜欢它！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="72a4" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">结论</h1><p id="8368" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">Python操作符重载意味着在不同的上下文中赋予普通操作符另一种含义。</p><p id="8416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<code class="fe lv lw lx ly b">+</code>运算符用于将两个整数相加。但是它也可以被重载以支持添加两个自定义对象。</p><p id="62d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运算符重载是通过为类中的特殊双下划线方法提供实现来实现的。例如，为了支持使用<code class="fe lv lw lx ly b">+</code>的加法，您需要在您的类中实现<code class="fe lv lw lx ly b">__add__</code>方法。</p><p id="aee8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。编码快乐！</p><p id="c48c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我很想加入你的LinkedIn网络。在<a class="ae ky" href="https://www.linkedin.com/in/artturi-jalli-29619413a" rel="noopener ugc nofollow" target="_blank"> Artturi Jalli </a>随意连接。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9697" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">进一步阅读</h1><div class="os ot gp gr ou ov"><a rel="noopener  ugc nofollow" target="_blank" href="/50-python-interview-questions-and-answers-5230fe2a0db6"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">50 Python面试问答</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">Ace您的下一次编码面试</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">better编程. pub</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj ks ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a rel="noopener  ugc nofollow" target="_blank" href="/10-useful-python-snippets-to-code-like-a-pro-e3d9a34e6145"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">10个有用的Python片段，让你像专业人士一样编写代码</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">我每天使用的有用的提示和技巧</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">better编程. pub</p></div></div><div class="pe l"><div class="pk l pg ph pi pe pj ks ov"/></div></div></a></div><h1 id="c5b1" class="mq me it bd mr ms no mu mv mw np my mz jz nq ka nb kc nr kd nd kf ns kg nf ng bi translated">参考</h1><div class="os ot gp gr ou ov"><a href="https://docs.python.org/3/" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">文件</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">欢迎光临！这是Python 3.9.6的文档。</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">docs.python.org</p></div></div></div></a></div></div></div>    
</body>
</html>