<html>
<head>
<title>Implement a Multicast Delegate Design Pattern in Swift 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift 5中实施组播委托设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-a-multicast-delegate-design-pattern-in-swift-5-72079d695cfe?source=collection_archive---------0-----------------------#2021-10-13">https://betterprogramming.pub/implement-a-multicast-delegate-design-pattern-in-swift-5-72079d695cfe?source=collection_archive---------0-----------------------#2021-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f715" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通知几个对象，而不是一个</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e8701e8eff0486cce92a838339c1ec03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6jCLEPYdZeIUesH-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@szolkin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">谢尔盖·佐尔金</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="f9f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将学习如何实现多播代理设计模式。我们将通过创建一个可重用的<code class="fe lv lw lx ly b">MulticastDelegate</code>类并在Xcode项目中使用它来实现。该项目的源代码可以在文章的底部找到。</p><h1 id="f154" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">我们开始吧</h1><p id="c6ed" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们从一个简单的屏幕开始，显示一个分段控件、两个文本字段和一个按钮。该屏幕如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/9171246ca79326bd85636bbc8a54a24d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y0-ko6VZsscqneUJ1BN2QQ.png"/></div></div></figure><p id="ed79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的任务是根据用户是尝试登录还是注册来导航到某个屏幕。我们还想持久化用户的数据。</p><p id="62e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前,<code class="fe lv lw lx ly b">AuthView</code>中的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><ol class=""><li id="0b54" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">我们定义了<code class="fe lv lw lx ly b">AuthDelegate</code>协议，稍后我们将使用它来通知其他类关于<code class="fe lv lw lx ly b">AuthView</code>中发生的事件。</li><li id="a9fa" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">在初始化器中，我们添加了一个堆栈视图，并设置了所需的约束。</li><li id="3114" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">当我们改变分段控件的值时，<code class="fe lv lw lx ly b">segmentedControlHandler</code>将被调用。这里，我们根据控件的值来设置<code class="fe lv lw lx ly b">mode</code>。</li><li id="77c9" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">当我们点击按钮时会调用<code class="fe lv lw lx ly b">actionButtonHandler</code>。稍后我们将更新它来触发委托的方法。</li><li id="a017" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">前面提到的<code class="fe lv lw lx ly b">Mode</code>是一个简单的枚举，它有两种可能的情况:<code class="fe lv lw lx ly b">login</code>和<code class="fe lv lw lx ly b">register</code>。根据<code class="fe lv lw lx ly b">mode</code>，我们设置按钮的标题。</li></ol><p id="fc6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们用下面的代码探索一下<code class="fe lv lw lx ly b">AuthViewController</code>以及<code class="fe lv lw lx ly b">AuthView</code>是如何添加到其中的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><ol class=""><li id="8761" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">Coordinator</code>将负责导航任务。稍后我们将看到如何使用它。</li><li id="a6da" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">一旦我们登录或注册一个新用户，<code class="fe lv lw lx ly b">Storage</code>将持久化<code class="fe lv lw lx ly b">User</code>对象。</li><li id="f83f" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">AuthView</code>被创建为属性并添加到<code class="fe lv lw lx ly b">loadView()</code>方法内的视图控制器中。</li></ol><p id="3d98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，我们的UI准备好了。现在我们需要使<code class="fe lv lw lx ly b">Storage</code>和<code class="fe lv lw lx ly b">Coordinator</code>成为<code class="fe lv lw lx ly b">AuthView</code>的代表成为可能。一旦我们点击<code class="fe lv lw lx ly b">AuthView</code>内的按钮，<code class="fe lv lw lx ly b">Coordinator</code>将导航到相应的屏幕，<code class="fe lv lw lx ly b">Storage</code>将保存用户。</p><h1 id="408a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">多播代理</h1><p id="f8ae" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">让我们创建一个通用的<code class="fe lv lw lx ly b">MulticastDelegate</code>类，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><ol class=""><li id="da38" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">我们创建一个<code class="fe lv lw lx ly b">Wrapper</code>类来包装每个委托，并保存对它的<code class="fe lv lw lx ly b">weak</code>引用。这样做是为了防止滞留循环。</li><li id="4e38" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">我们将一组<code class="fe lv lw lx ly b">Wrapper</code>对象设为私有。同时," real" <code class="fe lv lw lx ly b">delegates</code>属性被创建为包含非零值的数组。</li><li id="c8a2" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">我们使用<code class="fe lv lw lx ly b">add(delegate: T)</code>方法向数组添加一个新的委托。</li><li id="9e49" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">类似地，通过使用<code class="fe lv lw lx ly b">remove(delegate: T)</code>方法，我们删除了一个委托。</li><li id="4dcf" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">当我们需要通知每个代表一个事件时，就会调用<code class="fe lv lw lx ly b">invokeForEachDelegate(_ handler: (T) -&gt; ())</code>。</li></ol><p id="d8c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现了一个多播委托，现在是时候在<code class="fe lv lw lx ly b">AuthView</code>和<code class="fe lv lw lx ly b">AuthViewController</code>中使用它了。</p><p id="703c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先来更新一下<code class="fe lv lw lx ly b">AuthView</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0a5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们执行以下操作:</p><ol class=""><li id="673c" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">增加<code class="fe lv lw lx ly b">multicastAuthDelegate</code>并提供<code class="fe lv lw lx ly b">AuthDelegate</code>作为类型。</li><li id="4e93" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">在<code class="fe lv lw lx ly b">actionButtonHandler(_ sender: UIButton)</code>中，我们称<code class="fe lv lw lx ly b">MulticastDelegate</code>的<code class="fe lv lw lx ly b">invokeForEachDelegate</code>方法。我们添加的每个委托都将调用<code class="fe lv lw lx ly b">AuthDelegate</code>的<code class="fe lv lw lx ly b">actionButtonTapped</code>方法。</li></ol><p id="b189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要更新<code class="fe lv lw lx ly b">AuthViewController</code>中的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0277" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，在<code class="fe lv lw lx ly b">viewDidLoad()</code>中，我们添加了<code class="fe lv lw lx ly b">Coordinator</code>和<code class="fe lv lw lx ly b">Storage</code>作为代理。</p><p id="cf85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当用户点击按钮时，两个代理都将执行他们的工作。这就是<code class="fe lv lw lx ly b">Coordinator</code>任务的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><ol class=""><li id="4db1" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">它依赖于<code class="fe lv lw lx ly b">UINavigationController</code>来执行导航任务。</li><li id="6052" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">在<code class="fe lv lw lx ly b">AuthDelegate</code>的<code class="fe lv lw lx ly b">actionButtonTapped</code>方法中，当<code class="fe lv lw lx ly b">Mode</code>是<code class="fe lv lw lx ly b">.login</code>时，我们导航到<code class="fe lv lw lx ly b">HomeViewController</code>。否则，我们将<code class="fe lv lw lx ly b">AcceptTermsViewController</code>推到导航堆栈上。</li></ol><p id="f396" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Storage</code>只是将<code class="fe lv lw lx ly b">User</code>结构保存在<code class="fe lv lw lx ly b">UserDefaults</code>中(注意，在实际项目中，密码和其他敏感信息应该保存在安全的存储中，比如Keychain)。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="adc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们构建并运行应用程序，然后尝试登录，我们将看到两位代表都按照预期完成了工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/47fa976e3f324b02b1fa5e6edb1d5b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WpQGqdF0lkYWhIDAqoPYKg.png"/></div></div></figure><h1 id="de44" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">资源</h1><p id="2da2" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">源代码可以在<a class="ae ky" href="https://github.com/zafarivaev/multicast-delegate-swift" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。感谢阅读！</p></div></div>    
</body>
</html>