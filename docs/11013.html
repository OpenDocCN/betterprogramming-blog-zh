<html>
<head>
<title>How to Build and Deploy a FastAPI Task Manager App on Vercel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Vercel上构建和部署FastAPI任务管理器应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-and-deploy-a-fastapi-task-manager-app-on-vercel-c3aa82b8365e?source=collection_archive---------4-----------------------#2022-02-10">https://betterprogramming.pub/how-to-build-and-deploy-a-fastapi-task-manager-app-on-vercel-c3aa82b8365e?source=collection_archive---------4-----------------------#2022-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c94d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">构建并部署Postgres FastAPI应用程序</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3f5f2b481c30fe8b54e53309c95880b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-EJUQoq6w6blizXW.png"/></div></div></figure><p id="7d7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">近年来，API已经改变了软件的构建方式，允许更多可重用的代码与任何软件开发工具进行交互。现代的API已经有了定义好的标准(通常是HTTP和REST ),这些标准对开发人员来说是友好的、容易获得的、被广泛理解的，这使得开发人员可以更容易地构建带有安全检查的可维护代码以及全面的文档。</p><p id="fb5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>是一个高性能的Python web框架，使用标准的Python类型提示创建API，允许您轻松创建快速、直观、健壮的web应用程序，并且错误更少。此外，它还内置了对API文档的支持，由Swagger提供支持。</p><p id="3160" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本教程中，我们将通过创建一个简单的任务管理器应用程序来学习如何在Vercel上构建和部署Postgres FastAPI应用程序。为了跟进，确保您为这个项目克隆了<a class="ae lq" href="https://github.com/icode247/PostgresWithFastAPI" rel="noopener ugc nofollow" target="_blank"> Github </a>库。我们开始吧！。</p><h1 id="146b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">先决条件</h1><p id="3d07" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">本教程是一个实践演示。要继续操作，请确保您已经安装了以下软件:</p><ul class=""><li id="c621" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp mt mu mv mw bi translated"><a class="ae lq" href="https://arctype.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> Arctype </strong> </a></li><li id="4de6" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><a class="ae lq" href="https://www.postgresql.org/download/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> Postgres数据库</strong> </a></li><li id="1b4f" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><a class="ae lq" href="https://www.postman.com/downloads/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">邮递员</strong> </a></li><li id="db44" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><a class="ae lq" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">巨蟒</strong> </a></li><li id="2180" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><a class="ae lq" href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> Heroku CLI </strong> </a></li></ul><h1 id="e048" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated"><strong class="ak">什么是Vercel？</strong></h1><p id="0dc8" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><a class="ae lq" href="https://vercel.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> Vercel </strong> </a> <strong class="kw iu">是一个云托管平台，被广泛认为是部署任何前端应用程序的最佳场所。Vercel为其全球边缘网络提供了零配置部署的灵活性，无需费力即可实现动态应用可扩展性。</strong></p><p id="4c26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> Vercel结合了最卓越的开发体验和对最终用户效率的执着关注，以及一系列令人兴奋的特性，如:</strong></p><ul class=""><li id="1700" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp mt mu mv mw bi translated">快速刷新:为您的UI组件提供可靠的实时编辑体验。</li><li id="699f" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><strong class="kw iu">多功能数据获取:将您的页面连接到任何数据源、headless CMS或API，以确保它们可以在每个人的开发环境中工作。</strong></li><li id="62ed" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">localhost完美:所有的云原语，从缓存到无服务器功能，都可以在Localhost上完美运行。</li></ul><h2 id="8a4b" class="nc ls it bd lt nd ne dn lx nf ng dp mb ld nh ni md lh nj nk mf ll nl nm mh nn bi translated"><strong class="ak">建立我们的项目</strong></h2><p id="db42" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在我们深入研究之前，让我们创建项目结构并安装应用程序所需的依赖项。我们将从创建项目文件夹开始。打开您的终端并运行以下命令:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="5e71" class="nc ls it np b gy nt nu l nv nw"><strong class="np iu">mkdir PostgresWithFastAPI &amp;&amp; cd PostgresWithFastAPI<br/>touch {main,database,model,schema,session}.py</strong></span></pre><p id="6876" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">在运行上面的命令并为我们的项目创建了一个虚拟环境(我们将在下一节中介绍)之后，我们的项目结构将如下所示:</strong></p><p id="a02d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">📦┣邮政总局📂__pycache__ <br/> ┣📂环境<br/> ┣📜database.py <br/> ┣📜main.py <br/> ┣📜model.py <br/> ┣📜requirements.txt <br/> ┣📜schema.py <br/> ┗📜session.py </strong></p><p id="b824" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在整个教程中，我们将使用这些文件。</p><h1 id="9b0a" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated"><strong class="ak">创建虚拟环境</strong></h1><p id="9a9f" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">为你构建的Python项目创建一个虚拟环境总是好的。虚拟环境将包含项目的依赖项并隔离它们，从而保持项目整洁有序。我们将使用 <code class="fe nx ny nz np b"><strong class="kw iu">virtualenv</strong></code> <strong class="kw iu"> : </strong>为这个项目创建一个虚拟环境</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="ed2f" class="nc ls it np b gy nt nu l nv nw"><strong class="np iu">pip install virtualenv</strong></span></pre><p id="9480" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">现在，通过运行以下命令创建并激活您的虚拟环境:</strong></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="9c64" class="nc ls it np b gy nt nu l nv nw"><strong class="np iu">python3 -m venv env<br/>source env/bin/activate</strong></span></pre><p id="8593" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经成功地为项目创建了一个虚拟环境。我们还需要用下面的命令安装Fastapi、Uvicorn、Sqlalchemy和psycopg 2-binary:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="57cb" class="nc ls it np b gy nt nu l nv nw">pip install fastapi uvicorn sqlalchemy psycopg2-binary</span></pre><p id="34fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在运行下面的命令，将我们的依赖关系保存在一个<em class="oa"> requirements.txt </em>文件中。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="8b37" class="nc ls it np b gy nt nu l nv nw">pip freeze &gt; requirements.txt</span></pre><p id="e500" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">非常好。现在，让我们继续创建我们的FastAPI服务器。</p><h1 id="ef05" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建FastAPI服务器</h1><p id="a589" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">随着项目的建立，我们现在可以创建我们的FastAPI服务器了。首先，打开项目根目录中的<code class="fe nx ny nz np b">main.py</code>文件，并向其中添加以下代码:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="34fd" class="nc ls it np b gy nt nu l nv nw">from fastapi import FastAPI<br/>app = FastAPI()<br/><br/>@app.get("/")<br/>def read_root():<br/>    return {"message": "Server is up and running!"}</span></pre><p id="e42b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，导航到终端上的项目根目录，并通过运行以下命令测试服务器:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="b46b" class="nc ls it np b gy nt nu l nv nw">uvicorn main:app --reload</span></pre><p id="ac8c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们添加到命令中的<code class="fe nx ny nz np b">— reload</code>标志告诉FastAPI关注我们代码库的更新，如果发现更新，就重新加载服务器。现在，向服务器发出一个<strong class="kw iu"> Get请求</strong>，以确保一切都与<a class="ae lq" href="https://www.postman.com/downloads/" rel="noopener ugc nofollow" target="_blank"> Postman </a>一起工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/8a560b84dc49841ea7dd8036fd566729.png" data-original-src="https://miro.medium.com/v2/0*R1p3pUYEuLEnwopg"/></div></figure><p id="24af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的服务器已经成功创建并运行。接下来，我们需要一个数据库来保存我们的用户记录。让我们开始设置一个。</p><h1 id="f6bb" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">设置Postgres数据库</h1><p id="2129" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们现在可以设置我们的Postgres数据库，用我们的服务器设置来存储我们的用户记录。我们将使用<a class="ae lq" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy ORM </a>(对象关系映射器)来连接我们的数据库和应用程序。首先，我们需要通过以下步骤创建一个数据库。首先，切换到系统的Postgres用户帐户。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="5e00" class="nc ls it np b gy nt nu l nv nw">sudo su - postgres<!-- -->Changing to the Postgres user account</span></pre><p id="7d53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，创建一个新的用户帐户。然后，您可以按照下面的截图继续操作。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="2825" class="nc ls it np b gy nt nu l nv nw">createuser --interactive<!-- -->Creating a new user</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/bd6d3366957f1e0bd704ea146ec50b7f.png" data-original-src="https://miro.medium.com/v2/0*vdT4wB7ko7lCF6Mh"/></div></figure><p id="944f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，创建一个新的数据库。您可以使用以下命令来实现这一点:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="d120" class="nc ls it np b gy nt nu l nv nw">createdb task</span></pre><p id="3505" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们将连接到刚刚创建的数据库。打开<code class="fe nx ny nz np b">database.py</code>文件，并在下面添加以下代码片段:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="a007" class="nc ls it np b gy nt nu l nv nw">from sqlalchemy import create_engine<br/>from sqlalchemy.ext.declarative import declarative_base<br/>from sqlalchemy.orm import sessionmaker<br/>SQLALCHEMY_DATABASE_URL = "postgresql://postgres:1234@localhost:5432/task"<br/>engine = create_engine(SQLALCHEMY_DATABASE_URL)<br/>SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)<br/>Base = declarative_base()</span></pre><p id="32eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，使用我们从<code class="fe nx ny nz np b"><strong class="kw iu">SqlAlchemy</strong></code>导入的<code class="fe nx ny nz np b"><strong class="kw iu">create_engine</strong></code>类连接到我们的数据库。我们还从<code class="fe nx ny nz np b"><strong class="kw iu">sessionmaker</strong></code> <strong class="kw iu"> </strong>类中创建了一个<strong class="kw iu"> </strong> <code class="fe nx ny nz np b"><strong class="kw iu">Sessionlocal</strong></code> <strong class="kw iu"> </strong>实例。<strong class="kw iu"> </strong>我们禁用了<code class="fe nx ny nz np b"><strong class="kw iu">autocommit</strong></code>和<code class="fe nx ny nz np b"><strong class="kw iu">autoflush</strong></code>，然后将数据库引擎绑定到会话。最后，我们从<code class="fe nx ny nz np b"><strong class="kw iu">declarative_base</strong></code> <strong class="kw iu"> </strong>类创建了一个<code class="fe nx ny nz np b"><strong class="kw iu">Base</strong></code>实例，我们将用它来创建应用程序的数据库模型和数据库连接。</p><h1 id="d1e1" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建我们的数据库模型</h1><p id="359a" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">使用我们的Postgres数据库设置，让我们通过创建一个模型来定义如何存储用户的数据。打开<code class="fe nx ny nz np b">model.py</code>文件，并向其中添加以下代码片段。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="12ef" class="nc ls it np b gy nt nu l nv nw">from sqlalchemy.schema import Column<br/>from sqlalchemy.types import String, Integer, Text<br/>from database import Base<br/><br/>class Task(Base):<br/>   __tablename__ = "Tasks"<br/>   id = Column(Integer, primary_key=True, index=True)<br/>   task_name = Column(String(20))<br/>   task_des = Column(Text())<br/>   created_by = Column(String(20))<br/>   date_created = Column(String(15))</span></pre><p id="f7e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们通过导入<code class="fe nx ny nz np b">Column</code>并传递我们期望为数据库中的每个字段存储的数据类型(<code class="fe nx ny nz np b">Integer</code>、<code class="fe nx ny nz np b">String()</code>和<code class="fe nx ny nz np b">Text()</code>)来定义我们的数据模型。</p><p id="55d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还导入了在我们的<code class="fe nx ny nz np b">database.py</code>文件中创建的<code class="fe nx ny nz np b">Base</code>实例，我们用它来创建我们的基本模型类。然后我们使用<code class="fe nx ny nz np b">__tablename__</code>属性设置我们的表名(<code class="fe nx ny nz np b">Tasks</code>)。为了区分存储在数据库表中的数据，我们向id字段添加了<code class="fe nx ny nz np b">primary_key</code>和<code class="fe nx ny nz np b">index</code>参数，并将其设置为true。</p><h1 id="9925" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建我们的数据库模式</h1><p id="fd05" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">让我们为我们的应用程序定义一个模式。我们需要定义一个<a class="ae lq" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank"> Pydantic </a>模式来读取数据并从API返回。打开<code class="fe nx ny nz np b">Schema.py</code>文件，并向其中添加以下代码片段:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="18d9" class="nc ls it np b gy nt nu l nv nw">from pydantic import BaseModel<br/>from typing import Optional<br/><br/>class task_schema(BaseModel):<br/>   task_name :str<br/>   task_des :str<br/>   created_by : Optional[str]= None<br/>   date_created : Optional[str]= None<br/><br/>   class Config:<br/>       orm_mode = True</span></pre><p id="57a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们定义了模型验证，这确保了来自客户端的数据与我们定义的字段具有相同的数据类型。我们将期待<code class="fe nx ny nz np b">task_name</code>和<code class="fe nx ny nz np b">task_des</code>字段的字符串值，以及<code class="fe nx ny nz np b">created_by</code>和<code class="fe nx ny nz np b">date_created</code>字段的可选字符串值。将<code class="fe nx ny nz np b">orm_mode</code>设置为True的子类config将指示Pydantic模型以字典和属性的形式读取数据。</p><h1 id="43ad" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建我们的应用程序路线</h1><p id="f5fb" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">创建好模式后，让我们定义应用程序的路由。首先，打开<code class="fe nx ny nz np b">session.py</code>文件并创建一个<code class="fe nx ny nz np b">create_get_session()</code>函数，用下面的代码片段创建并关闭会话我们的路线:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="235f" class="nc ls it np b gy nt nu l nv nw">import model<br/>from database import SessionLocal, engine<br/><br/>model.Base.metadata.create_all(bind=engine)<br/>def create_get_session():<br/>   try:<br/>       db = SessionLocal()<br/>       yield db<br/>   finally:<br/>       db.close()</span></pre><p id="77eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们通过调用<code class="fe nx ny nz np b">model.Base.metadata.create_all()</code>函数并将其绑定到我们的数据库引擎，使用我们在模型中定义的字段创建了我们的表。</p><p id="c202" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，打开<code class="fe nx ny nz np b">main.py</code>文件，用下面的代码片段导入我们所有的模块:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="103f" class="nc ls it np b gy nt nu l nv nw">from fastapi import FastAPI, Depends, HTTPException<br/>from sqlalchemy.orm import Session<br/>from typing import List<br/>from model import Task<br/>from schema import task_schema<br/>from session import get_database_session<br/>…</span></pre><p id="1faf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，使用下面的代码片段创建<strong class="kw iu"> read_tasks </strong>路线:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="b17d" class="nc ls it np b gy nt nu l nv nw">…<br/>@app.get("/task", response_model=List[task_schema], status_code=200)<br/>async def read_tasks(db: Session = Depends(create_get_session)):<br/>   tasks = db.query(Task).all()<br/>   return tasks<br/>…</span></pre><p id="6310" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们创建了一个<code class="fe nx ny nz np b">read_tasks</code>路由来监听GET请求。我们传入了响应模型，该模型返回数据库中所有任务的列表和状态代码200 (OK)。在我们的<code class="fe nx ny nz np b">read_tasks</code>函数中，引用了我们的模型会话，这将使我们能够在数据库中执行查询。</p><p id="40b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，创建一个<code class="fe nx ny nz np b">create_task</code>路由，用下面的代码片段向我们的数据库添加新任务:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="a7e6" class="nc ls it np b gy nt nu l nv nw">…<br/>@app.post('/task', response_model = task_schema, status_code=201)<br/>async def create_task(task: task_schema, db: Session = Depends(create_get_session)):<br/>   new_task = Task(<br/>        task_name = task.task_name,<br/>        task_des = task.task_des,<br/>        created_by =task.created_by,<br/>        datecreated = task.date_created,<br/>   )<br/>   db.add(new_task)<br/>   db.commit()<br/><br/>   return new_task<br/>…</span></pre><p id="ecac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们创建了一个<code class="fe nx ny nz np b">create_task</code>路由，它将侦听POST请求。这一次，我们的响应模型将返回刚刚创建的任务，状态代码为201(已创建)。然后，我们通过传递一个项目并将其分配给我们的Pydantic模型，从请求体获取数据。此外，我们从模型类中创建了一个<code class="fe nx ny nz np b">new_task</code>对象，并将数据从请求体传递到模型中的字段。然后我们将<code class="fe nx ny nz np b">new_task</code>对象添加到我们的数据库会话中，提交它们并返回创建的对象。</p><p id="c9ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们创建<code class="fe nx ny nz np b">get_task</code>路由，它将返回一个任务，其id在请求参数中指定，代码片段如下:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="b563" class="nc ls it np b gy nt nu l nv nw">…<br/>@app.get("/task/{id}", response_model = task_schema, status_code=200)<br/>async def get_task(id:int,db: Session = Depends(create_get_session)):<br/>   task = db.query(Task).get(id)<br/>   return task<br/>…</span></pre><p id="fcf1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们创建了我们的<code class="fe nx ny nz np b">get_task</code>路由，它也将监听一个GET请求。但是这一次，我们将任务的id作为参数传入端点。我们的响应模型将返回一个状态代码为200(OK)的item对象。然后，我们查询我们的数据库模型(Tasks ),以获取其id在请求参数中指定的任务，并将其返回给用户。</p><p id="3014" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将创建我们的<code class="fe nx ny nz np b">update_task</code>路由，它将监听一个补丁请求，我们还将传入我们的响应模型，它将返回一个更新了状态代码200 (OK)的任务对象。然后，我们在模型中查询其id在请求参数中指定的项目，重置任务的值，将其保存到数据库，刷新数据库，并将更新后的记录对象返回给用户。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="6941" class="nc ls it np b gy nt nu l nv nw">…<br/>@app.patch("/task/{id}", response_model = task_schema, status_code=200)<br/>async def update_task(id:int, task:task_schema, db: Session = Depends(create_get_session)):<br/>   db_task = db.query(Task).get(id)<br/>   db_task.task_name = task.task_name<br/>   db_task.task_des =  task.task_des<br/>   db.commit()<br/>   db.refresh(db_task)<br/><br/>   return db_task<br/>…</span></pre><p id="27a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们将创建<code class="fe nx ny nz np b">delete_task</code>路由，它将侦听一个删除请求，删除其id在请求参数中指定的任务，并返回一个状态代码200 (OK)。我们将在数据库中查询该项，如果数据库中不存在该项，将引发HTTPException错误。然后传入状态代码404(未找到)，并返回null。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="4efc" class="nc ls it np b gy nt nu l nv nw">@app.delete('/task/{id}', status_code=200)<br/>async def delete_task(id:int, db: Session = Depends(create_get_session)):<br/>   db_task = db.query(Task).get(id)<br/>   if not db_task:<br/>       raise HTTPException(status_code="404",detail="Task id does not exist")<br/> <br/>   db.delete(db_task)<br/>   db.commit()<br/><br/>   return None</span></pre><p id="e46a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就这样，我们建立了所有的路线。让我们在本地测试我们的应用程序。</p><h1 id="9807" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">测试应用程序</h1><p id="81b6" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">有了我们的应用程序设置，让我们继续用Postman测试它。我们将从邮政路线开始。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/d27ceeb06e4f6a34ff5ad4f59212a10d.png" data-original-src="https://miro.medium.com/v2/0*0ainavVTRSesi4mC"/></div></figure><p id="55ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，GET路线。我们会用同样的方法测试它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/937202bc44c321b8e59d9e9b951e6436.png" data-original-src="https://miro.medium.com/v2/0*NKmpbRLAAQVwpaph"/></div></figure><p id="6234" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，通过id获取路由。您应该会看到如下所示的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/f170a3b9c5a0f66ca21fe2fe326abd6f.png" data-original-src="https://miro.medium.com/v2/0*Y_mWPDjUwzage6bG"/></div></figure><p id="6210" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来是贴片路线。同样，正确的回答如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/165a596cfabcb54a90b4e4b00057cc45.png" data-original-src="https://miro.medium.com/v2/0*MPRDPMtS0256y3PX"/></div></figure><p id="6eda" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，<strong class="kw iu">删除</strong>路线。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/e2c5672ddb8a0629c1687b09d1bf286d.png" data-original-src="https://miro.medium.com/v2/0*2BYnKh4LM7qv5HlH"/></div></figure><p id="9ea9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一切看起来都很好。现在，让我们将应用程序部署到Vercel上的云中。</p><h1 id="75a8" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">部署到Vercel</h1><p id="9251" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">测试完我们的路线后，我们的应用程序就可以部署到Vercel的云中了。在部署应用程序之前，在Heroku上为项目<a class="ae lq" href="https://devcenter.heroku.com/articles/getting-started-with-python#provision-a-database" rel="noopener ugc nofollow" target="_blank">在这里</a>提供一个远程数据库，并在<code class="fe nx ny nz np b">database.py</code>文件中更新数据库连接字符串。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="a749" class="nc ls it np b gy nt nu l nv nw">SQLALCHEMY_DATABASE_URL = “Remote connection string”</span></pre><p id="aafd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后<a class="ae lq" href="https://vercel.com/signup" rel="noopener ugc nofollow" target="_blank">在Vercel上注册一个账户</a>，用下面的命令安装Vercel CLI工具:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="ed8c" class="nc ls it np b gy nt nu l nv nw">//Ubuntu<br/>sudo npm install vercel<br/><br/>//Windows<br/>npm install -g vercel</span></pre><p id="7159" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">安装完成后，使用以下命令登录到Vercel CLI:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="a828" class="nc ls it np b gy nt nu l nv nw">Vercel login</span></pre><p id="dcd4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的命令将提示您输入想要登录的身份验证帐户。做出选择，然后按回车键。您将被重定向到浏览器中的一个新选项卡，如果您看到一条成功消息，则表明您成功登录了您的帐户。这意味着您现在可以从终端访问您的项目。</p><p id="98ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，您需要一个配置文件来告诉Vercel在哪里可以找到您的<code class="fe nx ny nz np b">main</code>项目文件。在父目录中创建一个<code class="fe nx ny nz np b">vercel.json</code>文件，并添加以下JSON代码片段:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="3ae2" class="nc ls it np b gy nt nu l nv nw">{<br/> "builds": [{ "src": "main.py", "use": "@vercel/python" }],<br/> "routes": [{ "src": "/(.*)", "dest": "main.py" }]<br/>}</span></pre><p id="261b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们创建了一个对象，它指示了应用程序的<code class="fe nx ny nz np b">main</code>文件的路径。我们还说明了在<code class="fe nx ny nz np b">routes</code>对象中构建我们的应用程序时要使用的包。我们将所有路由指向<code class="fe nx ny nz np b">main.py</code>文件。</p><p id="cd12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们将使用下面的命令初始化Vercel:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="fb43" class="nc ls it np b gy nt nu l nv nw">Vercel .</span></pre><p id="86fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上述命令将提示您填写项目详细信息。按照下面截图中的提示去做。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/be138aafebaab003f5685b560511b4d2.png" data-original-src="https://miro.medium.com/v2/0*8ne3FcjGsVWicSe7"/></div></figure><p id="763b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至此，我们的项目已经成功部署在Vercel上。你可以从<a class="ae lq" href="https://fastapidemo.vercel.app/docs" rel="noopener ugc nofollow" target="_blank">链接</a>中测试出来。</p><h1 id="0c54" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">使用arctype可视化我们的数据</h1><p id="764e" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">将我们的应用程序部署在Vercel上后，让我们通过将数据库连接到Arctype来可视化数据库中的记录。要开始，请确保您已经在您的机器上下载并安装了<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/arctype.com"> Arctype </a>。启动Arctype并单击Postgres来创建连接。如果您需要帮助，请点击此<a class="ae lq" href="https://docs.arctype.com/connect/postgresql" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/3170c1bfff58c4021a4a4296a4da1d8a.png" data-original-src="https://miro.medium.com/v2/0*i6Esw6evvt67HUip"/></div></figure><p id="bdab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">选择<strong class="kw iu"> Postgres后，</strong>添加您的数据库凭证，点击<strong class="kw iu">保存</strong>按钮连接数据库。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/bf579de2fda899d831800bdd2a4b6f72.png" data-original-src="https://miro.medium.com/v2/0*yiJTNOMnwF0zWYgb"/></div></figure><p id="e7c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经连接到我们的远程数据库。单击<strong class="kw iu">任务</strong>表，在Arctype的数据库上运行一些查询。您可以从<strong class="kw iu"> Arctype </strong>直接对数据库执行CRUD操作，产生如下所示的输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/66b3f2a1639bc5a11c43d054d7c0b1ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VZ0zqezQzWT0zrft.png"/></div></div></figure><p id="ca06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Arctype是一个功能强大的SQL客户端，具有高级协作和数据可视化工具。请务必尝试找到研究应用程序数据的最佳方法。</p><h1 id="ce03" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="73e1" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在本教程中，您已经学习了如何在Vercel上构建和部署Postgres FastAPI应用程序。我们从简要概述Vercel和FastAPI开始。然后我们创建了一个FastAPI服务器，设置了一个Postgres数据库，将应用程序连接到Postgres，执行CRUD操作，用Arctype可视化数据。</p><p id="1096" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在您已经了解了这些知识，那么您打算如何构建下一个FastAPI应用程序呢？或许你可以从他们的网站上了解更多关于<a class="ae lq" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>和<a class="ae lq" href="https://arctype.com/" rel="noopener ugc nofollow" target="_blank"> Arctype </a>的信息，并将你所学到的作为你下一个项目的灵感。请随时在<a class="ae lq" href="https://twitter.com/EkekentaZion" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上分享您的进展和问题。</p></div></div>    
</body>
</html>