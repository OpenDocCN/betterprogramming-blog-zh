<html>
<head>
<title>Dockerizing Rails Applications Part 2: Automation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对接Rails应用第2部分:自动化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dockerizing-rails-applications-part-2-automation-3092975fa4bb?source=collection_archive---------4-----------------------#2019-12-29">https://betterprogramming.pub/dockerizing-rails-applications-part-2-automation-3092975fa4bb?source=collection_archive---------4-----------------------#2019-12-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8611" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过使用Makefiles简化Rails应用程序的Docker构建</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/811c29287f12c8af09a79bffb0b1d555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f358yujnWx-tkOoW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@arstyy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奥斯汀·尼尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><div class="kz la gp gr lb lc"><a href="https://medium.com/faun/dockerizing-rails-applications-part-1-writing-the-dockerfile-dc32aa25a0da" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">Dockerizing Rails应用程序第1部分:编写Dockerfile</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">让我们开始编写一个优化的Dockerfiles</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">medium.com</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq ks lc"/></div></div></a></div><p id="5235" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我之前的<a class="ae ky" href="https://medium.com/faun/dockerizing-rails-applications-part-1-writing-the-dockerfile-dc32aa25a0da" rel="noopener">文章</a>中，我讨论了一些编写Docker文件的最佳实践，比如使用一个<code class="fe mn mo mp mq b">entrypoint</code>和减少每个Docker文件的<code class="fe mn mo mp mq b">RUN</code>指令数量——以及使用定制的Docker基本映像。</p><p id="70f7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">通过提供完成这项工作所需的命令，本文结尾简要提到了构建和推送Docker映像。下面将再次介绍这些命令。</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="9128" class="mv mw it mq b gy mx my l mz na">$&gt; docker build -t ${IMG}:${IMG_TAG} <!-- -->Dockerfile<br/>$&gt; <!-- -->docker push <!-- -->${IMG}:${IMG_TAG}</span></pre><p id="8082" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">构建图像的Docker命令简单易用；但是，这可能会非常漫长和复杂，尤其是在构建Docker映像需要额外步骤的情况下，例如:</p><ul class=""><li id="6ccd" class="nb nc it lt b lu lv lx ly ma nd me ne mi nf mm ng nh ni nj bi translated">将构建参数传递给<code class="fe mn mo mp mq b">docker build</code>命令</li><li id="40e6" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated">在构建Docker映像之前安装应用程序依赖项</li><li id="587e" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated">生成要附加到Docker图像的标签</li><li id="cf31" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated">在构建Docker映像之前，需要编译源代码</li></ul><p id="9f4b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">以上几点会使构建Docker映像变得更加复杂，因此,<code class="fe mn mo mp mq b">docker build</code>命令会更加复杂和冗长。此外，在管理多个应用程序的情况下，这意味着每个应用程序将具有不同的唯一命令集来构建其Docker映像，尤其是如果这些应用程序是使用不同的编程语言构建的。</p><p id="f128" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">解决这个问题的一个想法是将构建Docker映像的复杂性隐藏在所有Docker服务的统一接口之后。该工具或界面的要求如下:</p><ul class=""><li id="bcfb" class="nb nc it lt b lu lv lx ly ma nd me ne mi nf mm ng nh ni nj bi translated">构建和推送Docker映像应该通过简单的命令来完成</li><li id="f70f" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated">构建和推送Docker映像应该在不同的服务中以相同的方式完成</li></ul><p id="6561" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以简单地通过使用以前的一个叫做<a class="ae ky" href="https://www.gnu.org/software/make/manual/make.html#Makefiles" rel="noopener ugc nofollow" target="_blank"> make </a>的工具来实现这个接口。该命令通常安装在macOS和Linux系统上，用于管理和编译源代码过程，以及定义编译和安装软件应用程序所需的命令。<a class="ae ky" href="https://www.gnu.org/software/make/manual/make.html#Introduction" rel="noopener ugc nofollow" target="_blank"> Makefiles </a>是定义编译和构建源代码指令的文件，这些指令将被<code class="fe mn mo mp mq b">make</code>命令使用。</p><p id="4961" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了解决我们的问题，我们将编写一个Makefile来定义如何构建和推送Docker映像，然后我们将使用<code class="fe mn mo mp mq b"><a class="ae ky" href="https://www.gnu.org/software/make/manual/make.html#Makefiles" rel="noopener ugc nofollow" target="_blank">make</a></code>命令来执行实际的过程，并调用所需的<code class="fe mn mo mp mq b">docker</code>命令。</p><p id="2161" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://www.gnu.org/software/make/manual/make.html#Introduction" rel="noopener ugc nofollow" target="_blank"> Makefile </a>文件的第一部分应该是所有支持的参数配置项目的列表。这是一个让<a class="ae ky" href="https://www.gnu.org/software/make/manual/make.html#Introduction" rel="noopener ugc nofollow" target="_blank"> Makefile </a>更具可读性和灵活性的好主意。</p><p id="5779" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">可以使用环境变量覆盖这些配置项。例如，我们可以设置一个默认的名称空间，然后构建Docker图像，并使用带有额外环境变量的相同的<code class="fe mn mo mp mq b">make</code>命令将它们推送到另一个名称空间——例如<code class="fe mn mo mp mq b">make build</code>和<code class="fe mn mo mp mq b">NAMESPACE=overwritten make build</code>。</p><p id="9b43" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下面是其中一些配置项目的列表，以及对每个项目的描述。</p><ul class=""><li id="7e1d" class="nb nc it lt b lu lv lx ly ma nd me ne mi nf mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">NAMESPACE</code>:项目名称空间将被用作Docker图像的名称空间</li><li id="efce" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">REGISTRY</code>:用于托管Docker映像的Docker注册中心的URL</li><li id="07d3" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">BRANCH</code>:用于构建Docker映像的Git分支。Docker图像将用分支名称标记。例如，从主分支构建的Docker图像将被标记上<code class="fe mn mo mp mq b">master</code>标签，而从<code class="fe mn mo mp mq b">develop</code>分支构建的图像将被标记上<code class="fe mn mo mp mq b">develop</code>标签。</li></ul><p id="6148" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下面是一些应该由<code class="fe mn mo mp mq b">make</code>命令定义和使用的配置项目列表。这些变量的值要么是静态值，比如<code class="fe mn mo mp mq b">image_name</code>，要么是使用Git命令自动生成的，比如<code class="fe mn mo mp mq b">commit_hash</code>。</p><ul class=""><li id="68ab" class="nb nc it lt b lu lv lx ly ma nd me ne mi nf mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">IMAGE_NAME</code>:这将定义Docker图像名称，通常可以与应用程序名称相同</li><li id="968a" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">IMAGE_FULL_NAME</code>:这是包含在注册表和名称空间中的完整Docker映像名称</li><li id="6eb5" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">BRANCH_TAG</code>:这是将用于标记Docker图像的分支标记。这个项目依赖于分支，但是它确保该值可以用作标记——也就是说，该标记不包括任何特殊字符，如<code class="fe mn mo mp mq b">/</code>。</li><li id="dedf" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">COMMIT_HASH</code>:用于构建Docker映像的分支中的最后一个提交散列。我们可以使用这个项目来标记Docker映像，并向Docker映像添加一个标签，这样就可以更容易地找到Docker映像中运行的代码版本。</li><li id="acc6" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">COMMAND</code>:Docker镜像支持的默认命令。对于Rails应用程序，这可能是<code class="fe mn mo mp mq b">rails server</code>命令。</li><li id="5073" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">PORT</code>:服务需要的端口。这些端口将暴露给主机系统。</li><li id="1841" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">CONTAINER_ENV</code>:应用默认环境变量将链接到由<code class="fe mn mo mp mq b">make</code>命令创建的容器</li><li id="f002" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">BUILD_PARAMS</code>:<code class="fe mn mo mp mq b">docker build</code>命令的选项列表</li><li id="d481" class="nb nc it lt b lu nk lx nl ma nm me nn mi no mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">BUILD_ARGS</code>:支持的Docker列表<code class="fe mn mo mp mq b">--build-arg</code></li></ul><p id="227b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下一步是开始定义<code class="fe mn mo mp mq b">Makefile</code>支持的命令。下面是一组建议的make命令列表，这些命令可以使构建、推送和测试Docker映像变得更加容易:</p><ul class=""><li id="c7e3" class="nb nc it lt b lu lv lx ly ma nd me ne mi nf mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">make config</code>:该命令将用于执行构建Docker映像所需的所有操作。这些操作可能是为构建过程安装必要的包，编译包的源代码，或者生成配置文件。下面是一个Rails应用程序的建议<code class="fe mn mo mp mq b">config</code>实现，它将所有gem打包到本地供应商目录中。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><ul class=""><li id="6a46" class="nb nc it lt b lu lv lx ly ma nd me ne mi nf mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">make build</code>:该命令将用于在主机节点上构建并标记Docker映像。下面是Rails应用程序的一个建议实现，它构建Docker图像并用<code class="fe mn mo mp mq b">COMMIT_HASH</code>和<code class="fe mn mo mp mq b">BRANCH_TAG</code>标记它。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><ul class=""><li id="40ef" class="nb nc it lt b lu lv lx ly ma nd me ne mi nf mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">make shell</code>:该命令将从生成的Docker映像创建一个新的容器，并在容器内打开一个shell会话。下面是一个在临时容器中启动一个<code class="fe mn mo mp mq b">sh</code> shell的实现。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><ul class=""><li id="ce9f" class="nb nc it lt b lu lv lx ly ma nd me ne mi nf mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">make run</code>:该命令将用于从前台生成的Docker图像创建一个容器，并执行应用默认命令。下面的代码片段显示了一个<code class="fe mn mo mp mq b">run</code>命令的实现，它将启动一个临时容器，并执行容器内变量<code class="fe mn mo mp mq b">COMMAND</code>中定义的命令。</li></ul><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="e1f8" class="mv mw it mq b gy mx my l mz na">run:<br/>  docker run --rm<!-- --> <!-- -->--name ${NAME}-${BRANCH_TAG} ${CONTAINER_ENV} -it ${PORT} ${IMAGE_FULL_NAME}:${COMMIT_HASH} ${COMMAND}</span></pre><ul class=""><li id="b442" class="nb nc it lt b lu lv lx ly ma nd me ne mi nf mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">make start</code>:该命令将用于从后台生成的Docker图像创建一个容器，并执行应用程序的默认命令。下面的代码片段显示了一个<code class="fe mn mo mp mq b">start</code>命令的实现，它将使用变量<code class="fe mn mo mp mq b">COMMAND</code>中定义的命令在后台启动一个容器。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><ul class=""><li id="9ee6" class="nb nc it lt b lu lv lx ly ma nd me ne mi nf mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">make stop</code>:该命令将停止由<code class="fe mn mo mp mq b">make start</code>命令创建的容器。这可以简单地通过使用<code class="fe mn mo mp mq b">docker rm -f</code>命令来完成。</li></ul><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="4e03" class="mv mw it mq b gy mx my l mz na">stop:<br/>  docker rm -f ${NAME}-${BRANCH_TAG}</span></pre><ul class=""><li id="ade0" class="nb nc it lt b lu lv lx ly ma nd me ne mi nf mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">make push</code>:该命令用于将生成的Docker图像的标签从主机节点推送到Docker注册表。下面的实现将把branch标签和提交hashtags推送到Docker注册中心。另外，如果使用的分支是<code class="fe mn mo mp mq b">master</code>分支，<code class="fe mn mo mp mq b">push</code>命令也会推送<code class="fe mn mo mp mq b">latest</code>标签。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><ul class=""><li id="897e" class="nb nc it lt b lu lv lx ly ma nd me ne mi nf mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">make release</code>:该命令将用于自动执行<code class="fe mn mo mp mq b">config</code>、<code class="fe mn mo mp mq b">build,</code>和<code class="fe mn mo mp mq b">push</code>命令。基本上，它会调用这些子命令中定义的任务。</li></ul><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="ef5b" class="mv mw it mq b gy mx my l mz na">release: config build push</span></pre><ul class=""><li id="316c" class="nb nc it lt b lu lv lx ly ma nd me ne mi nf mm ng nh ni nj bi translated"><code class="fe mn mo mp mq b">make clean</code>:该命令将用于删除使用<code class="fe mn mo mp mq b">config</code>和<code class="fe mn mo mp mq b">build</code>命令生成的所有文件或Docker图像。下面的<code class="fe mn mo mp mq b">clean</code>命令实现删除了由<code class="fe mn mo mp mq b">build</code>命令生成的Docker图像，以及由<code class="fe mn mo mp mq b">config</code>命令创建的Ruby gemset。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="63d8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">完整的<code class="fe mn mo mp mq b">Makefile</code>实现如下所示。该实现可用作Docker <code class="fe mn mo mp mq b">Makefiles</code>的模板，并用于生成Docker图像。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生成文件</p></figure></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="8f99" class="ny mw it bd nz oa ob oc od oe of og oh jz oi ka oj kc ok kd ol kf om kg on oo bi translated"><strong class="ak">结论</strong></h1><p id="058c" class="pw-post-body-paragraph lr ls it lt b lu op ju lw lx oq jx lz ma or mc md me os mg mh mi ot mk ml mm im bi translated">Makefiles有助于简化Docker映像的构建，并将复杂的Docker命令隐藏在简单易用的界面之后。它们有助于标准化跨多个项目构建Docker映像的方式，因此，它们有助于创建简单的CI/CD集成管道。</p><div class="kz la gp gr lb lc"><a href="https://medium.com/faun/dockerizing-rails-applications-part-3-ci-cd-integration-9f2dcd84780f" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">Dockerizing Rails应用程序第3部分:CI/CD集成</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">让我们使用CI/CD工具来自动创建docker映像</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">medium.com</p></div></div><div class="ll l"><div class="ou l ln lo lp ll lq ks lc"/></div></div></a></div></div></div>    
</body>
</html>