<html>
<head>
<title>Benchmarking the Best Way to Reverse a String in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中反转字符串的最佳方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/benchmarking-the-best-way-to-reverse-a-string-in-python-9c73d87b1b1a?source=collection_archive---------4-----------------------#2019-09-16">https://betterprogramming.pub/benchmarking-the-best-way-to-reverse-a-string-in-python-9c73d87b1b1a?source=collection_archive---------4-----------------------#2019-09-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a199" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">六种不同的实现，有一些有趣的结果</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1df60bf830f2ff47e314892d93abdd94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*isz8qHjHydojawJj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@toboote?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂姆·布特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="9170" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python没有任何内建的方法来反转字符串，所以了解这一点很方便，也是一个有趣的练习。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="56b4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设计</h1><p id="0973" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我们只需要考虑在理论上有效实现算法的步骤。一个好的起点是想象我们如何通过一些小的输入来手动地、有条不紊地做到这一点。</p><p id="8db7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向后读取字符串，并将每个字符写入一个新的字符串，直到我们完成。这在O( <em class="mz"> n </em>中运行，其中n是字符串的长度，因为它需要<em class="mz"> n </em>步，并且与<em class="mz"> n </em>的大小成线性比例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/7f1c8f460513851f3bda18b84c58341c.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*sejFdgrozP7th2bNajhhcg.png"/></div></figure><p id="89e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> B) </strong>交换开始字符和结束字符。然后是s+1和e-1等等，直到你的计数器在中间相遇，所有的字符都被交换。这也是O( <em class="mz"> n </em>)因为你需要做同样数量的移动，尽管方式不同。有一些额外的开销，因为交换需要一个临时存储，并且你需要检查计数器是否在每个周期的中间相遇，但是顺序是一样的。此外，由于交换是内联完成的，因此该算法占用的空间更少。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/ef3010ed9a2d60089b208b55a0256cf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*5eWHZLMrFIgXLeN3UvsAsQ.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a8e9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">履行</h1><h2 id="9e0f" class="nc md it bd me nd ne dn mi nf ng dp mm li nh ni mo lm nj nk mq lq nl nm ms nn bi translated"><strong class="ak">向后移动</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="aefc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算输入字符串的长度。使用它向后循环并将每个字符追加到一个新字符串中。附加操作的复杂性取决于解释器中的底层实现。因为Python字符串是不可变的，很可能每个<code class="fe nq nr ns nt b">reversed_output = reversed_output + s[i]</code>都获取输出字符串和新字符的当前状态，并将它们复制到一个新变量中。这不是线性的，因为它遵循模式1 + 2 + 3 … + <em class="mz"> n </em>。t( <em class="mz"> n </em> ( <em class="mz"> n </em> +1)/2)，所以它的顺序是O( <em class="mz"> n </em>)。因此，预计该算法的运行速度会比其他算法慢。</p><h2 id="15cc" class="nc md it bd me nd ne dn mi nf ng dp mm li nh ni mo lm nj nk mq lq nl nm ms nn bi translated"><strong class="ak">向前移动并附加到前面</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ff4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这个函数，我们可以正常地遍历字符串，因为它是可迭代的。在每次迭代中，我们都会将新字符添加到输出字符串的前面。出于同样的原因，预计这将具有与第一算法相似的运行时间。</p><h2 id="07f4" class="nc md it bd me nd ne dn mi nf ng dp mm li nh ni mo lm nj nk mq lq nl nm ms nn bi translated"><strong class="ak">换入列表并加入</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4b7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是内联交换算法的一个实现。我们需要用字符串创建一个列表对象，这样我们就可以在列表可变时进行内联交换。与前两种算法不同，连接操作有效地解决了附加问题。</p><h2 id="42bf" class="nc md it bd me nd ne dn mi nf ng dp mm li nh ni mo lm nj nk mq lq nl nm ms nn bi translated"><strong class="ak">列表、反转、加入</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="819c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个内置的内联列表反转函数，所以它应该与我们新的交换函数相似，并且在运行时间上可能会更好一点。</p><h2 id="f9c1" class="nc md it bd me nd ne dn mi nf ng dp mm li nh ni mo lm nj nk mq lq nl nm ms nn bi translated"><strong class="ak">反转并加入</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="09ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将一个字符串传递给<em class="mz"> reversed </em>，返回一个迭代器，该迭代器被设置为反向遍历列表，其中起始点在末尾，下一个<em class="mz">指向列表中的前一个。这可以直接传递给连接操作。这预计会有不错的表现。</em></p><h2 id="f843" class="nc md it bd me nd ne dn mi nf ng dp mm li nh ni mo lm nj nk mq lq nl nm ms nn bi translated"><strong class="ak">切片</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="12f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">据我所知，<em class="mz"> slice </em>会获取一个列表的子列表，并将其复制到一个新的空间，预计会有类似的良好性能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4827" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">标杆管理</h1><p id="c940" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于每个函数，我都进行了如下测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c929" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我将输入字符串的长度设置为10，000个字符。</p><p id="0e7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试返回最佳五次运行的平均值；这给了算法最好的机会在你的机器上尽可能好地执行。这种类型的测试有助于指出显著的性能差异。跟踪的时间以微秒为单位(1/1，000，000秒)。</p><h2 id="191b" class="nc md it bd me nd ne dn mi nf ng dp mm li nh ni mo lm nj nk mq lq nl nm ms nn bi translated">结果</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/fe7c1809365b0553977925cd35f70788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UkJ0jYW4MUaSgR9PNW9e7A.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/6bea085e7d14a0f16d2afabf47c502d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G99UC7uDOs9Fjaa6Sb0TZA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/b8f5ced64a122dd2b09e66b3b69f5150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w2ZNHH1MuT5aXxazq-c5Xg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/bb28f82fc74420201faca389fef9280d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PDherkWQl246gO7vL_Tqfg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/542966dcb69cb1ba72f1723bdc4d5332.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kjdwS_n7b2xIk8d3SSCiLA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/43d683cabc745449b7b337fc4a63f769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LTqLJl-pNac4u7xiK7c5YQ.png"/></div></div></figure><h2 id="8a44" class="nc md it bd me nd ne dn mi nf ng dp mm li nh ni mo lm nj nk mq lq nl nm ms nn bi translated"><strong class="ak">想法</strong></h2><p id="6870" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如所料，第一个函数表现最差。有趣的是，向前遍历的结果差了多少，因为它们是如此的相似。也许出于某种原因，<code class="fe nq nr ns nt b">reversed_output = reversed_output + s[i]</code>最终比<code class="fe nq nr ns nt b">reversed_output = c + reversed_output</code>快。</p><p id="696b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，我的内联交换函数比内置的反转函数慢六倍，因为它们应该做同样的事情。两者都应该面临设计部分描述的相同的额外开销。检查底层实现时，功能非常相似(只是在<em class="mz"> while </em>表单中)。我想两个关键的区别是，循环似乎是传递指针，而不是进行实际的复制，而我的实现可能正在这样做。其次，整个操作都是用C语言，也就是说天生会更快。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/31ea371a628d574b460f8f01767f3a8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g1BrKaxY3vfwWS0-8bYKxQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/python/cpython/blob/master/Objects/listobject.c" rel="noopener ugc nofollow" target="_blank">https://github . com/python/cpython/blob/master/Objects/listobject . c</a></p></figure><p id="1d9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，很明显切片是最快的，但是为什么呢？同样，可能整个操作都是在C中进行的，没有额外的连接步骤。底层实现似乎没有做任何特别的事情——只是循环复制到另一个列表中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/e8b94e47e57aa2d533927636511a89d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sa08n79J17wPODUWDBP04w.png"/></div></div></figure><p id="fd83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">制造更多的测试来隔离原因可能是有趣的。检查不同的python编译器/解释器会很有用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3a9f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">关键要点</strong></h1><ul class=""><li id="e582" class="oa ob it lb b lc mu lf mv li oc lm od lq oe lu of og oh oi bi translated">在python中，切片是反转字符串最有效的方式。</li><li id="106e" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><em class="mz">反转</em>以在线交换，<em class="mz">反转</em>以复印效果良好且更清晰。</li><li id="b769" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">应该避免在较慢的算法中实现的字符串连接。</li><li id="028e" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">基准测试有助于发现我们无法具体发现的事情。</li><li id="1faf" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">代码运行速度很快——最慢的实现仍然只有大约1毫秒。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c4a5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">本练习的代码</h1><div class="oo op gp gr oq or"><a href="https://github.com/njgibbon/nicks-python-kata/tree/master/nicks_py_algs" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">njgibbon/nicks-python-kata</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">python中的算法。*以各种合理的方式实现各种算法-包括任何被认为是…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div><h2 id="ca74" class="nc md it bd me nd ne dn mi nf ng dp mm li nh ni mo lm nj nk mq lq nl nm ms nn bi translated"><strong class="ak">其他资源</strong></h2><p id="3ace" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">https://www.python.org/dev/peps/pep-0322/<a class="ae ky" href="https://www.python.org/dev/peps/pep-0322/" rel="noopener ugc nofollow" target="_blank"/></p><p id="8de2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">【https://waymoot.org/home/python_string/ T4】</p><p id="1d5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.journaldev.com/23647/python-reverse-string" rel="noopener ugc nofollow" target="_blank">https://www.journaldev.com/23647/python-reverse-string</a></p><p id="bdc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.quora.com/How-is-slicing-implemented-in-python" rel="noopener ugc nofollow" target="_blank">https://www.quora.com/How-is-slicing-implemented-in-python</a></p></div></div>    
</body>
</html>