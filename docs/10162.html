<html>
<head>
<title>How To Containerize And Scale Your Application For Unexpected Traffic or Model Training</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为意外流量或模型训练封装和扩展您的应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-scale-your-application-for-unexpected-traffic-or-model-training-a8b0a0c44d80?source=collection_archive---------4-----------------------#2021-12-07">https://betterprogramming.pub/how-to-scale-your-application-for-unexpected-traffic-or-model-training-a8b0a0c44d80?source=collection_archive---------4-----------------------#2021-12-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b674" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于可伸缩性的实用分步指南，包含有趣的故事。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a89c5c12c3514aecfabe5cdc91a6be70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7TEd6rqXrDGbjjhQ.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank">pix abay</a>Alexas _ Fotos</p></figure><p id="4db3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有没有想过学集装箱化？您是否希望您的应用程序能够针对更高的负载或培训进行扩展？您是一名拥有统计学学位，但没有计算机工程背景，并且饱受可扩展性问题困扰的数据科学家吗？</p><p id="c281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">扩展应用程序应该就像在工作中添加更多的爪牙一样简单。</p><p id="2531" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将:</p><ol class=""><li id="3653" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">浏览应用程序的扩展设计。</li><li id="5e5c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">提供有趣的现实生活中的故事让你理解。</li><li id="9d8b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在您的本地机器上提供易于遵循的逐步指南。</li><li id="7b9b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">解决所有的棘手问题并增强开发过程。</li></ol><p id="1ac9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本系列教程结束时，我们将实现如下可扩展设计:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/be88cb102ff371b71cb2e54620e38181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ag_D2zCZOTXor2IX0TfuWQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片鸣谢:作者。</p></figure><ol class=""><li id="da32" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mk ml mm mn b">Request</code>发送到负载均衡器，而不是直接调用每个应用程序。</li><li id="35bc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mk ml mm mn b">Application</code>是计算公式，并坚持使用主机名的<code class="fe mk ml mm mn b">log.txt</code>。</li><li id="d135" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mk ml mm mn b">Autoscaler</code>监控每个应用程序的计算能力，并相应地扩展应用程序。</li><li id="981e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mk ml mm mn b">log.txt</code>作为一个输出/持久层，你可以根据你的应用用任何数据库替换它。</li></ol><p id="4a0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，让我们开始吧。</p><h1 id="17a9" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">1.可扩展设计</h1><p id="3b5e" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">一个可伸缩的应用程序可以同时处理大量的任务或请求，同时有效地处理这些任务或请求，并为将来增加的任务或请求做好准备。</p><p id="e88f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当应用程序不再能有效地处理额外的请求时，它的可伸缩性就到了极限。有两种缩放类型，水平缩放和垂直缩放。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/8cd2304d1fba97e58f15228654991123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hBPeXWQAxWqSpPGE3NnahQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">垂直缩放与水平缩放。作者图片</p></figure><p id="93d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">垂直扩展是指向现有机器添加额外的能力(CPU、内存)(也称为“纵向扩展”)。水平扩展是指向您的资源池添加更多机器的过程(也称为“向外扩展”)。</p><p id="ebf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于水平扩展的优势，我们在本文中只讨论它:</p><ul class=""><li id="a02d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nm mb mc md bi translated">性能提升。</li><li id="253a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated">从硬件角度来看，扩展更容易。</li><li id="4aa4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated">停机时间缩短了，因为我们有更多的节点在运行。</li><li id="3b2e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated">提高弹性和容错能力。</li></ul></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="f6c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要横向扩展应用程序，应用程序必须是可横向扩展的。一个理想的可伸缩应用应该具有这两个属性:</p><ol class=""><li id="453d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">服务于单一的责任。</li><li id="05e0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">无国籍。无状态的应用程序或进程产生每一个事务，就好像是第一次从零开始。它不存储过去交易的知识或参考。</li></ol><h2 id="c469" class="nu mp it bd mq nv nw dn mu nx ny dp my li nz oa na lm ob oc nc lq od oe ne of bi translated"><strong class="ak"> Storytime —单一责任和无状态</strong></h2><p id="2f23" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">假设你是一家餐馆的老板，你有一家餐馆，衡量标准如下:</p><pre class="kj kk kl km gt og mn oh oi aw oj bi"><span id="b40e" class="nu mp it mn b gy ok ol l om on">+-----------------------------------------+---------+--------------+<br/>|                  Item                   | Metric  |   Resouce    |<br/>+-----------------------------------------+---------+--------------+<br/>| 1. Seat capacity filled at peak hour    |  70%    |  Real estate |<br/>| 2. Customer's request acknowledged time |  6s     |  Waiter/ress |<br/>| <strong class="mn iu">3. Average food serving throughput      |  35mins |  Chef</strong>        |<br/>| 4. Payment service completion           |  15s    |  Cashier     |<br/>+-----------------------------------------+---------+--------------+</span></pre><p id="7697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会做些什么来提高餐厅的效率？开另一家餐馆？招聘一名身兼服务员、厨师和收银员多重职责的超级员工？</p><p id="73b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开另一家餐馆或雇用另一名员工来执行与服务员、厨师、收银员相同的职能是没有意义的，这样做会损害你的钱包！</p><p id="f6dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们实际上需要的是多雇一名厨师来帮助提高上菜量。这就是单一责任的美妙之处。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="69e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了单一责任之外，让我们讨论一下为什么无状态在伸缩中很重要。</p><p id="b7b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们想象A桌和B桌由贾斯汀服务，C桌和D桌由约瑟芬服务。只有这些男女服务员知道每张桌子上提出的要求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/be9da87bc97d097521939902a1b7e6d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uMnsHoDgLwG4l2UAoWw6Dw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">有状态的等待者/ress。作者图片</p></figure><p id="b62f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在食物(苹果派)已经在厨房的洞里准备好了，只有约瑟芬知道如何处理它，因为C桌的状态只有她自己知道。因此，无状态应用程序更适合扩展。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/b4494598da557144f6b59ebbe9315336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C8RTWGg1zldkha3C_-qYJg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无国籍服务员/女服务员。作者图片</p></figure><p id="7df2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存储餐桌状态的订单管理系统(不打算扩展)允许服务员/ress扩展他们的服务，而不是一直保存这些信息。因此，任何服务员都可以把食物送到正确的桌子上，而不是约瑟芬必须知道把苹果派送到c桌。</p><p id="d0f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">汤姆、迪克或哈利(任何一个奴才)都可以把苹果派端上桌c .无状态为尺度。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="7d89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望梦想成为餐馆老板能让我们体会到<strong class="lb iu">单一责任</strong>和<strong class="lb iu">无国籍</strong>帮助扩大规模的好处。</p><p id="e30f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的编码世界，让我们想象我们有一个支付系统，一个登录系统，和一个列表系统捆绑到一个应用程序中(也称为单片应用程序)。</p><p id="1d6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的支付系统过载，影响了用户体验，我们就不想创建另一个电子商务平台。过度杀戮通常意味着资源的浪费。</p><p id="c1fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们对这个过度问题的解决方案是将每个系统/服务容器化，根据需求将功能和环境分开。</p><h1 id="ec0e" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">2.集装箱化和码头工人</h1><p id="cc61" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们需要将软件代码打包成一个可执行文件及其所有依赖项，以便在任何基础设施上统一、一致地扩展和运行。</p><p id="2c1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用集装箱技术和docker软件工具。在我们看到魔法之前，一切都没有意义，稍后会有解释。</p><p id="5c13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本节中，我们将讨论这三个项目。</p><p id="1a02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实验1.1将开发一个监听端口3000的web服务器，并附加一个带有主机名的日志行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/812f1642543a0278184a476af1eab454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Na6X6Kiv4HU9g1R-c1j8Vg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">LAB1.1申请流程图.图片鸣谢:作者</p></figure><p id="bd5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实验室1.2容器化应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/beca032b47b99c177f63610a68932792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8t2AXUmkLfi9beBhDOwgrw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实验1.2的容器化应用程序流程图。图片来源:作者。</p></figure><p id="046f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LAB1.3为它再秤一次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/46cb3db97d8668c2e36eb188445b170e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TesYQquEIbV6MjsMTLNNqw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实验1.3的两个集装箱应用程序的流程图。图片来源:作者</p></figure><p id="4619" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个实验环节的最后都附有一个<a class="ae ky" href="https://github.com/Onewayteo/medium-scalability" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>链接，供您交叉检查。</p><h2 id="a1ae" class="nu mp it bd mq nv nw dn mu nx ny dp my li nz oa na lm ob oc nc lq od oe ne of bi translated">实验1.1:开发web服务器</h2><p id="c7a9" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">为了从头开始理解设计和开发，让我们从头开始开发一个web服务器，然后在LAB1.2中将其容器化。</p><p id="e37f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以“$”开头的代码块是我们在实验过程中需要键入终端的输入。如果您遇到任何问题，请随时发表评论。</p><p id="2335" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，在您的主目录下创建一个新目录。</p><pre class="kj kk kl km gt og mn oh oi aw oj bi"><span id="9919" class="nu mp it mn b gy ok ol l om on">$cd ~<br/>$mkdir medium-scalability<br/>$cd medium-scalability</span></pre><p id="d819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本次实验1结束时，我们应该有一个如下所示的文件夹结构:</p><pre class="kj kk kl km gt og mn oh oi aw oj bi"><span id="10ef" class="nu mp it mn b gy ok ol l om on">medium-scalibility<br/>├── .dockerignore #Created in LAB1.2 <br/>├── Dockerfile    #Created in LAB1.2<br/>├── log<br/>│   └── log.txt   #Created in LAB1.1<br/>├── package.json  #Created in LAB1.1<br/>└── server.js     #Created in LAB1.1</span></pre><p id="eed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，创建一个监听端口3000的<code class="fe mk ml mm mn b">server.js</code>,我们有意不使用python来学习如何自己封装一个应用程序，因为这才是最重要的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><ul class=""><li id="064e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nm mb mc md bi translated">第8–13行定义了route /的过程</li><li id="e724" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated">第15–24行在<code class="fe mk ml mm mn b">~/log/log.txt</code>添加一行当前日期时间和主机名</li><li id="e395" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated">第26–31行有一个平方根的计算循环。</li><li id="d638" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated">第33–36行指定端口并打印到日志中。</li></ul><p id="eef9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Python Django也可以达到同样的效果。</p><p id="3f7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe mk ml mm mn b">package.json</code>并传递下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><ul class=""><li id="01c4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nm mb mc md bi translated">第7行定义了我们在执行<code class="fe mk ml mm mn b">npm start</code>时运行的脚本</li></ul><p id="6c91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在计算机上安装NodeJS</p><div class="ou ov gp gr ow ox"><a href="https://nodejs.org/en/download/" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">下载| Node.js</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">Node.js是基于Chrome的V8 JavaScript引擎构建的JavaScript运行时。</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">nodejs.org</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div><p id="33a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装后，请运行与<code class="fe mk ml mm mn b">python pip</code>相同的<code class="fe mk ml mm mn b">$npm -v</code>并遵循以下命令进行验证:</p><pre class="kj kk kl km gt og mn oh oi aw oj bi"><span id="1ee8" class="nu mp it mn b gy ok ol l om on">$npm install                                                                                                    added 50 packages, and audited 51 packages in 3s<br/>found 0 vulnerabilities</span></pre><p id="b98f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个新目录和<code class="fe mk ml mm mn b">log.txt</code>，然后启动web服务器。</p><pre class="kj kk kl km gt og mn oh oi aw oj bi"><span id="bc43" class="nu mp it mn b gy ok ol l om on">$mkdir ./log<br/>$touch ./log/log.txt<br/>$npm start<br/>&gt; medium-scalability@1.0.0 start<br/>&gt; node server.js</span><span id="6528" class="nu mp it mn b gy pm ol l om on">Listening at <a class="ae ky" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a><br/>Running On:  undefined</span></pre><p id="158f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试<code class="fe mk ml mm mn b">curl locahost:3000</code>或使用您最喜欢的浏览器，地址为localhost:3000，我们应该看到<code class="fe mk ml mm mn b">Request received at undefined, and</code>忽略了现在的主机名<code class="fe mk ml mm mn b">undefined</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/17a4acf7ff71e415abb227f5361e0ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*F18gwOxyqF27j-XNp6Omhg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用程序的预期输出</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/812f1642543a0278184a476af1eab454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Na6X6Kiv4HU9g1R-c1j8Vg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用程序的流程图。图片来源:作者</p></figure><p id="4460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们已经完成的，设置应用程序时会遇到哪些限制？</p><ul class=""><li id="87ea" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nm mb mc md bi translated">这个应用程序是在macOS上开发的，如果我们的服务器运行Ubuntu/Window或Redhat会发生什么，我们可以复制相同的吗？</li><li id="ce78" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated">我们将主机名设为<code class="fe mk ml mm mn b">undefined</code>，这是一个主机/系统依赖项。</li><li id="496d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated">npm已安装，并且手动创建了文件路径和log.txt。如果我们必须在100台主机上安装它们会怎么样？我们是否愿意一个一个地安装它们？</li><li id="1b18" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated">如果我们有另一个需要不同版本的NodeJS/software的应用程序，您想仅仅为了运行不同的应用程序而删除并安装它吗？</li></ul><p id="0bfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决上述问题，我们将它们装箱。在此之前，让我们通过在终端中键入<code class="fe mk ml mm mn b">Control + C</code>来停止本地主机上的web服务器。</p><p id="8cb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你遇到任何问题，你可以在GitHub 上找到<a class="ae ky" href="https://github.com/Onewayteo/medium-scalability/tree/lab2.1_develop_web_server" rel="noopener ugc nofollow" target="_blank"> LAB1.1的代码。</a></p><h2 id="08df" class="nu mp it bd mq nv nw dn mu nx ny dp my li nz oa na lm ob oc nc lq od oe ne of bi translated">实验1.2:应用的容器化</h2><p id="40f0" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">Docker vs图像vs容器</p><ol class=""><li id="be46" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">Docker是一个开源的容器化平台/工具。</li><li id="fa72" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Image是我们将要构建的容器的规范。</li><li id="af6f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">容器是一个实现的形象。容器化的思想是包含软件代码及其所有依赖项，以便它可以在任何孤立的基础设施上统一和一致地运行。</li></ol><h2 id="f0e9" class="nu mp it bd mq nv nw dn mu nx ny dp my li nz oa na lm ob oc nc lq od oe ne of bi translated">story time—Docker vs Image vs Container</h2><p id="ae50" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">码头装卸和集装箱化经常被人们混淆。码头和集装箱化的区别就像Google.com和搜索引擎的区别一样。</p><p id="8205" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Google.com和Docker是软件工具，我们有雅虎或必应作为搜索引擎的替代品。相比较而言，容器化是一种类似于搜索引擎的技术。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="cf5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是什么形象？假设:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/927c9bf3ce4c8a1609fd10cb241b8de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CN_QAffIez-5a-yqRRtu9w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图像的解释。图片鸣谢:作者。</p></figure><ol class=""><li id="4a3b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们买了一台预装了Windows操作系统的新电脑，一切从头开始，然后我们安装了Microsoft Office。</li><li id="685a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在这个特定的时间点，我们希望拍摄应用程序及其虚拟环境的快照。快照就是图像。</li><li id="6525" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">大约7个月后，我们安装了一些有用的应用程序和许多无用的应用程序。</li><li id="f24e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们希望我们的机器像时光机一样，回到只有Window操作系统和Microsoft Office的那个时间点，我们只是简单地实现或构建我们拥有快照的映像。</li></ol></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="4ef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容器是什么？容器是我们构建映像所基于的独立虚拟环境和应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/2a7db00e0a2b1c3e5cd7717a9a79a940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G2tMJ2xSK5P_-mvo"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源于<a class="ae ky" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank">docker.com</a></p></figure><p id="7f14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在主机上安装Docker，我们可以在单个主机上实现或构建多个映像到容器中。他们每个人都有一个孤立的虚拟环境。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="24e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看过电影《<a class="ae ky" href="https://www.imdb.com/title/tt0289879/" rel="noopener ugc nofollow" target="_blank">蝴蝶效应</a>》的话，埃文阅读日志(影像)并旅行回到(建立影像)那个时间点是一个类似的概念。</p><p id="6546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">学习这种超能力来实现我们定义的形象是不是很兴奋？Docker是魔术。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="1854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您的操作系统安装docker引擎，然后验证Docker版本。</p><div class="ou ov gp gr ow ox"><a href="https://docs.docker.com/engine/install/" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">安装Docker引擎</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">Docker Desktop for Linux Docker Desktop帮助您在Mac和Windows上轻松构建、共享和运行容器，就像您做…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">docs.docker.com</p></div></div><div class="pg l"><div class="pq l pi pj pk pg pl ks ox"/></div></div></a></div><pre class="kj kk kl km gt og mn oh oi aw oj bi"><span id="9a48" class="nu mp it mn b gy ok ol l om on">$docker -v<br/>Docker version 20.10.10, build b485636</span></pre><p id="b467" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个新的文本文件名<code class="fe mk ml mm mn b">Dockerfile</code>，这是容器的配置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Dockerfile文件</p></figure><ul class=""><li id="c30c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nm mb mc md bi translated"><code class="fe mk ml mm mn b">FROM node:alpine </code>表示我们要从<strong class="lb iu">镜像</strong> <code class="fe mk ml mm mn b">node:alpine</code>构建一个容器，它基本上是一个安装了node的alpine操作系统。</li><li id="34dc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated"><code class="fe mk ml mm mn b">WORKDIR /app</code>将容器中的工作目录设置为/app(与<code class="fe mk ml mm mn b">mkdir -p /app &amp;&amp; cd /app</code>相同)，类似于我们之前在<code class="fe mk ml mm mn b">~/medium-scalability</code>所做的。</li><li id="d6be" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated"><code class="fe mk ml mm mn b">COPY package.json .</code>将我们的本地主机package.json带到主机<code class="fe mk ml mm mn b">/app/package.json</code>。</li><li id="2de8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated"><code class="fe mk ml mm mn b">RUN npm install</code>根据我们带过来的/app/package.json运行命令npm install at /app。同<code class="fe mk ml mm mn b">pip install -r requirements.txt</code>。</li><li id="53e9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated"><code class="fe mk ml mm mn b">RUN mkdir -p /app/log</code>在容器中创建文件夹/app/log。</li><li id="cae6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated"><code class="fe mk ml mm mn b">COPY . .</code>复制当前localhost目录下除<code class="fe mk ml mm mn b">.dockerignore</code>文件中提到的文件以外的其余文件。</li><li id="5392" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated"><code class="fe mk ml mm mn b">CMD ["npm", "start"]</code>指定初始化容器将执行的命令。</li></ul><p id="d872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个新文件名<code class="fe mk ml mm mn b">.dockerignore</code>，它将忽略docker操作之外的那些文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">。dockerignore</p></figure><p id="3cdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将第17行的<code class="fe mk ml mm mn b"><a class="ae ky" href="https://gist.github.com/Onewayteo/094399289dec03ac8ad0f4bac8adefa3" rel="noopener ugc nofollow" target="_blank">server.js</a></code>修改为<code class="fe mk ml mm mn b">/app/log/log.txt</code></p><p id="1f4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于配置<code class="fe mk ml mm mn b">Dockerfile </code>构建我们的docker <code class="fe mk ml mm mn b">image</code>，名称标记为<code class="fe mk ml mm mn b">-t</code>为<code class="fe mk ml mm mn b">medium-scalability</code></p><pre class="kj kk kl km gt og mn oh oi aw oj bi"><span id="f965" class="nu mp it mn b gy ok ol l om on">$docker build -t medium-scalability .</span></pre><p id="615a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该会看到如下输出:</p><pre class="kj kk kl km gt og mn oh oi aw oj bi"><span id="52dd" class="nu mp it mn b gy ok ol l om on">[internal] load build context<br/>=&gt; transferring context: 32.87kB<br/>=&gt; [2/6] WORKDIR /app<br/>=&gt; [3/6] COPY package.json<br/>=&gt; [4/6] RUN nom install<br/>=&gt; [5/6] RUN mkdir -0 /app/log<br/>=&gt; [6/6] COPY . .<br/>=&gt; exporting to image<br/>=&gt;=&gt; exporting layers<br/>=&gt;=&gt; writing image sha256: 1be65ac6e17e4b5a93498626c1a765d11a1043545b4c2ed39abeeec615ddb039<br/>=&gt;=&gt; naming to docker.10/Library/medium-scalability</span></pre><p id="92e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将经历<code class="fe mk ml mm mn b">Dockerfile</code>中定义的每一步，并创建图像层。</p><p id="0c8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过执行以下命令启动我们的容器:</p><pre class="kj kk kl km gt og mn oh oi aw oj bi"><span id="9062" class="nu mp it mn b gy ok ol l om on">$docker run \<br/>--name scalability-tutorial \<br/>-dp 3000:3000 \<br/>--mount type=bind,source="$(pwd)"/log,target=/app/log \<br/>medium-scalability</span></pre><ul class=""><li id="ae45" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nm mb mc md bi translated"><code class="fe mk ml mm mn b">--name</code>给这个容器命名为<code class="fe mk ml mm mn b">scalability-tutorial</code></li><li id="a378" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated"><code class="fe mk ml mm mn b">-d</code>在“分离”模式下运行新容器(在后台)</li><li id="c16b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated"><code class="fe mk ml mm mn b">-p</code>将主机的端口3000映射到容器的端口3000。如果没有端口映射，我们将无法访问应用程序。</li><li id="eb62" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated"><code class="fe mk ml mm mn b">--mount</code>是捆绑坐骑。<em class="pr">主机</em>上的文件或目录被装入一个容器中。我们正在尝试同步<code class="fe mk ml mm mn b">log.txt</code>的日志目录</li></ul><p id="689d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要列出正在运行的容器:</p><pre class="kj kk kl km gt og mn oh oi aw oj bi"><span id="03a7" class="nu mp it mn b gy ok ol l om on">$docker ps</span></pre><p id="2e64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该看到一个包含容器ID、图像、命令、已创建、状态、端口、名称的条目。</p><p id="2823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们测试一下这个应用程序，或者使用<code class="fe mk ml mm mn b">curl</code>或者使用地址为<code class="fe mk ml mm mn b">localhost:3000</code>的浏览器</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/9f877b264976ac8ead9f4ab3057f06c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*QEfJcGxnyeAdw4aVlM_LxA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">容器的预期输出</p></figure><p id="a739" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们在日志文件中有另一个额外的日志行，主机名为<code class="fe mk ml mm mn b">d816d48f38d6</code>。为什么？</p><p id="e8b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，一个新的运行容器相当于一个新的主机在运行应用程序，这个容器/主机有在系统或<code class="fe mk ml mm mn b">node:alpine</code>中定义的主机名。</p><p id="4ea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用于本地构建映像的常用docker命令:</p><ul class=""><li id="af52" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nm mb mc md bi translated"><code class="fe mk ml mm mn b">docker inspect [CONTAINER_NAME or CONTAINER_ID]</code>返回Docker对象的底层信息。</li><li id="32b0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated"><code class="fe mk ml mm mn b">docker logs CONTAINER_ID</code>取集装箱的原木。</li></ul><p id="0360" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经封装了一个在端口3000监听的web服务器，它将在文件log.txt上附加一个日志行，其中包含处理时间和主机名。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/beca032b47b99c177f63610a68932792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8t2AXUmkLfi9beBhDOwgrw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">集装箱应用程序的流程图。图片来源:作者</p></figure><p id="5107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这还不够，我们需要横向扩展另一个，但我们不能让它们在同一个端口3000上工作。</p><p id="be8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果遇到任何问题，可以在GitHub 上找到<a class="ae ky" href="https://github.com/Onewayteo/medium-scalability/tree/lab2.2_containerize" rel="noopener ugc nofollow" target="_blank"> LAB1.2的代码。</a></p><h2 id="0baa" class="nu mp it bd mq nv nw dn mu nx ny dp my li nz oa na lm ob oc nc lq od oe ne of bi translated">实验1.3:秤</h2><p id="5afa" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">将<code class="fe mk ml mm mn b"><a class="ae ky" href="https://gist.github.com/Onewayteo/094399289dec03ac8ad0f4bac8adefa3" rel="noopener ugc nofollow" target="_blank">server.js</a></code>第5行修改为3001，并运行以下命令:</p><pre class="kj kk kl km gt og mn oh oi aw oj bi"><span id="745b" class="nu mp it mn b gy ok ol l om on">$docker build -t <strong class="mn iu">medium-scalability-3001</strong> .<br/>$docker run \<br/>--name <strong class="mn iu">scalability-tutorial-3001</strong> \<br/>-dp <strong class="mn iu">3001:3001</strong> \<br/>--mount type=bind,source="$(pwd)"/log,target=/app/log \<br/><strong class="mn iu">medium-scalability-3001</strong></span></pre><p id="dad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意下面的输出已经“缓存”了，这是<a class="ae ky" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" rel="noopener ugc nofollow" target="_blank"> Dockerfile最佳实践</a>之一，因为我们<a class="ae ky" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache" rel="noopener ugc nofollow" target="_blank">利用了构建缓存</a>。因为我们在构建了之前的容器后修改了文件<code class="fe mk ml mm mn b">server.js</code>。</p><p id="7de4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mk ml mm mn b">package.json</code>和<code class="fe mk ml mm mn b">node_modules</code>没有变化，因此将<code class="fe mk ml mm mn b">COPY . .</code>作为Dockerfile中的步骤6有助于节省我们的时间和资源，而无需为步骤1至5构建图像层。</p><pre class="kj kk kl km gt og mn oh oi aw oj bi"><span id="3e14" class="nu mp it mn b gy ok ol l om on">=&gt; CACHED [2/6] WORKDIR /app<br/>=&gt; CACHED [3/6] COPY package.json<br/>=&gt; CACHED [4/6] RUN npm install<br/>=&gt; CACHED (5/6] RUN mkdir -p /app/log<br/>=&gt; [6/6] COPY. .<br/>=&gt; exporting to image<br/>=&gt; =&gt; exporting layers<br/>=&gt; =&gt; writing image sha256:18d772e70317c96001e2393a8ab99ca139b766c7c6211ab3b56677630066fc49<br/>=&gt; =&gt; naming to docker. io/library/medium-scalability-3001</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/3d1a9ec619bde80e041578a0df4cb5dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*YHqBfcDxqcLxLq9ZnbYT7Q.png"/></div></figure><p id="b39d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜你！您已经在端口3001上扩展了另一个应用程序，我们应该得到如下所示的东西:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/46cb3db97d8668c2e36eb188445b170e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TesYQquEIbV6MjsMTLNNqw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">两个集装箱应用程序的流程图。图片来源:作者</p></figure><p id="8a7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="pr">如果遇到任何问题，可以在GitHub </em>  <em class="pr">上找到</em> <a class="ae ky" href="https://github.com/Onewayteo/medium-scalability/tree/lab2.3_scale_out_port_3001" rel="noopener ugc nofollow" target="_blank"> <em class="pr"> LAB1.3的代码。</em></a></p><p id="7c2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们已经将一个应用程序容器化，并使用不同的端口向外扩展另一个应用程序，那么向外扩展另外30个应用程序的潜在问题是什么？</p><ul class=""><li id="3932" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nm mb mc md bi translated">我们需要修改不友好端口的<code class="fe mk ml mm mn b">server.js</code>。</li><li id="59d7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated">我们需要用不同的容器名构建容器并维护它们，这并不明智。</li><li id="0304" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated"><code class="fe mk ml mm mn b">request</code>需要确切地知道调用哪个端点、<code class="fe mk ml mm mn b">localhost:3000</code>和<code class="fe mk ml mm mn b">localhost:3001</code>，最终是同一个服务。我们期望调用者知道同一服务的端点吗？</li><li id="f1b7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated">我们如何用一个命令来缩放容器呢？</li><li id="5eab" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated">我们如何自动缩放容器？</li></ul></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="d2c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了突破这些限制，我们将在下一篇文章中讨论负载平衡、容器编排和自动伸缩。请跟随我，让我为你增加更多的价值。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="c8b4" class="mo mp it bd mq mr pu mt mu mv pv mx my jz pw ka na kc px kd nc kf py kg ne nf bi translated">关键要点</h1><p id="cc6b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们已经容器化了一个理想的可伸缩的应用程序，它服务于单一的职责并且是无状态的。</p><p id="18ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容器将软件代码打包成一个可执行文件及其所有依赖项，以便我们在任何基础设施上统一、一致地扩展和运行。</p><p id="ff7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了支持上述优势，我们</p><ul class=""><li id="1e8f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nm mb mc md bi translated">在macOS(或者你的PC的OS)上开发了由于主机依赖性而不能打印主机名的代码，但是现在我们可以了，因为容器化允许我们在新的容器中复制相同的输出，而不管主机的操作系统。</li><li id="c90d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated">手动安装NodeJS/NPM，但这已经由Docker自动完成。</li><li id="7656" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nm mb mc md bi translated">构建了一个开发沙箱，提供了一个隔离的环境，让我们可以开发应用程序，而不必让本地主机应用程序崩溃。应用程序A有NodeJS版本14，应用程序B在docker容器中的NodeJS版本16上运行。</li></ul><p id="3979" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的目的是给你更多的信心，帮助你开始使用集装箱化和Docker。有关更多信息，请参见Docker文档。</p><p id="3509" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如何停止正在运行的容器？</p><div class="ou ov gp gr ow ox"><a href="https://docs.docker.com/" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">码头文件</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">Docker文档的主页</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">docs.docker.com</p></div></div><div class="pg l"><div class="pz l pi pj pk pg pl ks ox"/></div></div></a></div><p id="7352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第2部分于2021年12月27日发布:<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/autoscale-your-application-for-unexpected-traffic-using-kubernetes-ff5ee7d9f22">使用Kubernetes </a>针对意外流量自动调整您的应用</p><h2 id="9bd2" class="nu mp it bd mq nv nw dn mu nx ny dp my li nz oa na lm ob oc nc lq od oe ne of bi translated">放弃</h2><p id="2f99" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">这不是一篇供您深化技能组合的科学论文或深入的技术文章，而是一个有趣而实用的系列，供您构建第一个可伸缩的应用程序，并为您提供另一个理解的角度。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="9dd2" class="mo mp it bd mq mr pu mt mu mv pv mx my jz pw ka na kc px kd nc kf py kg ne nf bi translated">参考</h1><ol class=""><li id="28af" class="lv lw it lb b lc ng lf nh li qa lm qb lq qc lu ma mb mc md bi translated"><a class="ae ky" href="https://docs.docker.com/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/</a></li><li id="035f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">https://www.docker.com/resources/what-container<a class="ae ky" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank"/></li><li id="252b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">【https://www.ibm.com/sg-en/cloud/learn/containerization T4】</li></ol><pre class="kj kk kl km gt og mn oh oi aw oj bi"><span id="996c" class="nu mp it mn b gy ok ol l om on"><strong class="mn iu">Want to Connect With the Author?</strong></span><span id="3a99" class="nu mp it mn b gy pm ol l om on">I enjoy making friends around the world, let’s connect on <a class="ae ky" href="https://www.linkedin.com/in/teowangwei/" rel="noopener ugc nofollow" target="_blank">Linkedin</a>.</span></pre></div></div>    
</body>
</html>