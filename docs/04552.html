<html>
<head>
<title>How to Use GraphQL in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Flutter中使用GraphQL</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-graphql-in-flutter-7decd04a511f?source=collection_archive---------1-----------------------#2020-04-21">https://betterprogramming.pub/how-to-use-graphql-in-flutter-7decd04a511f?source=collection_archive---------1-----------------------#2020-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4753" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建一个简单的待办事项应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9b3d7834c829342120de9dee41baeb42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vyD-7JpQomuM43SUEz13zA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·温克勒在<a class="ae ky" href="https://unsplash.com/s/photos/list?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="c73f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Flutter正在席卷全球，这一点也不奇怪。它提供无与伦比的性能和强大的多平台支持。在本文中，我将带领您将GraphQL集成到Flutter应用程序中，进行查询和执行变异。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8d41" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">GraphQL是什么？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/4a923767d41171e448195469e5bcc85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*zZueFatMtK_31U9A"/></div></figure><p id="1cc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL是由脸书开发的一种查询语言。它应该取代REST作为API通信的一种方式。在本文的其余部分，我将假设一些GraphQL的基础知识。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c6e9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">服务器设置</h1><p id="d27f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">开发GraphQL API超出了本文的范围。相反，我们将使用一个预制的。前往<a class="ae ky" href="https://github.com/r3dm1ke/todo-graphql-example" rel="noopener ugc nofollow" target="_blank">回购</a>并克隆它。我已经从<a class="ae ky" href="https://github.com/haikyuu" rel="noopener ugc nofollow" target="_blank"> @haikyuu </a>那里得到了这个服务器——非常感谢你。</p><p id="3a4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">克隆完成后，在“终端”中打开它并运行:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="7e20" class="nf md it nb b gy ng nh l ni nj">npm i npm start</span></pre><p id="95a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将安装所有依赖项并启动服务器。该服务器是一个基本的待办事项应用后端，允许您创建、查询和修改任务。它是使用<code class="fe nk nl nm nb b">json-graphql-server</code>构建的；一定要去看看。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dca1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">项目设置</h1><p id="306f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在我们启动并运行服务器之后，让我们来设置Flutter项目。创建项目后，目录结构应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/b67e986da0f59c18ef17f9d290836333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*v1xRtCXOXDKiBZUM"/></div></figure><p id="2144" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您尝试运行应用程序，模拟器中应该会出现这种情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/9f2e43b5ac3f424bd008399cc42f2d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/0*hdTfXlvss5c3W0gc"/></div></figure><p id="f91a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜，我们已经成功了一半！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1e22" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">添加GraphQL依赖项</h1><p id="f96d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在我们开始在Flutter应用程序中使用GraphQL之前，我们需要安装一些依赖项。打开<code class="fe nk nl nm nb b">pubspec.yaml</code>文件并在其中添加这一行(在<code class="fe nk nl nm nb b">dependencies</code>部分:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="fc9b" class="nf md it nb b gy ng nh l ni nj">graphql_flutter: ^3.0.0</span></pre><p id="0bb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在使用以下命令安装软件包:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="7d28" class="nf md it nb b gy ng nh l ni nj">flutter pub get</span></pre><p id="a13e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几秒钟后，依赖项就应该安装好了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a181" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">编写一些查询</h1><p id="74b8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如您所知，您使用查询与GraphQL APIs对话。我们将需要其中的三个:一个获取所有任务列表的查询，一个创建新任务的变异，以及一个完成现有任务的变异。在<code class="fe nk nl nm nb b">/lib</code>中创建一个文件<code class="fe nk nl nm nb b">api.dart</code>并将这段代码放入其中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="356e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，注意第1–2行中的导入。第一个是核心Flutter包，它将更新向下传播到组件。第二个是我们之前安装的<code class="fe nk nl nm nb b">graphql_flutter</code>包。</p><p id="701b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第4–9行，我们创建了一个GraphQL <code class="fe nk nl nm nb b">client</code>。它将用于访问我们的API。<code class="fe nk nl nm nb b">link</code>正在使用地址<code class="fe nk nl nm nb b">http://10.0.2.2:3000</code>，因为这是模拟器内部主机的IP地址。如果你在物理设备上运行应用，你需要用你的PC的本地IP地址替换这个地址(或者使用类似<a class="ae ky" href="https://ngrok.com/" rel="noopener ugc nofollow" target="_blank"> ngrok </a>的东西)。</p><p id="4395" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们有疑问。第一种方法非常简单:获取带有字段<code class="fe nk nl nm nb b">id</code>、<code class="fe nk nl nm nb b">title</code>和<code class="fe nk nl nm nb b">completed</code>的所有查询。<code class="fe nk nl nm nb b">createTaskMutation</code>是一个变异创造任务(很明显！)并且它接受两个参数:新创建的任务的<code class="fe nk nl nm nb b">id</code>和它的<code class="fe nk nl nm nb b">title</code>。由于其简单性，我们使用的后端不会检查<code class="fe nk nl nm nb b">id</code>的唯一性。最后一个查询将更新带有<code class="fe nk nl nm nb b">id</code>的任务上的<code class="fe nk nl nm nb b">completed</code>字段。</p><p id="496d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UI还没有变化，所以应用程序看起来应该是一样的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aa18" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置用户界面</h1><p id="5008" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们现在剩下的就是将它绑定到UI。我不会深入解释UI，因为你应该知道一些基本知识。相反，我将关注它如何与GraphQL交互。首先，用以下代码替换<code class="fe nk nl nm nb b">main.dart</code>中的所有代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0e31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您首先应该注意到的是第11行的<code class="fe nk nl nm nb b">GraphQLProvider</code>。通过将整个应用程序包装在其中，我们为GraphQL客户端提供了其余的小部件。这意味着我们可以在应用程序的任何地方运行查询和突变。</p><p id="a2f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，检查第75行中的<code class="fe nk nl nm nb b">_ListPageState</code>类的<code class="fe nk nl nm nb b">build</code>函数。这里，我们使用<code class="fe nk nl nm nb b">Query</code>小部件来运行查询，并将结果传递给其子部件。<code class="fe nk nl nm nb b">Query</code>接受一个<code class="fe nk nl nm nb b">QueryOptions</code>类型的<code class="fe nk nl nm nb b">options</code>参数，它设置查询。<code class="fe nk nl nm nb b">gql(getTasksQuery)</code>将解析该查询，<code class="fe nk nl nm nb b">pollInterval: 1</code>意味着该查询将每秒刷新一次(这是非常低效的，但现在可以了)。</p><p id="7786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nb b">Query</code>将把<code class="fe nk nl nm nb b">QueryResult</code>和<code class="fe nk nl nm nb b">refetch</code>和<code class="fe nk nl nm nb b">fetchMore</code>函数传递给它的<code class="fe nk nl nm nb b">builder</code>回调函数。<code class="fe nk nl nm nb b">QueryResult</code>有字段<code class="fe nk nl nm nb b">loading</code>和<code class="fe nk nl nm nb b">hasException</code>，我们用它们来决定渲染什么(第85-90行)。<code class="fe nk nl nm nb b">refetch</code>每次用户切换任务时，如果我们调用它，就会重新运行查询(也是非常低效的)。<code class="fe nk nl nm nb b">fetchMore</code>是在实现分页时使用的，但我们暂时不讨论它。</p><p id="dea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，看看<code class="fe nk nl nm nb b">TaskList</code>小部件，特别是它的<code class="fe nk nl nm nb b">build</code>函数。它用<code class="fe nk nl nm nb b">Mutation</code>类包装，这与<code class="fe nk nl nm nb b">Query</code>非常相似。主要区别在于<code class="fe nk nl nm nb b">Mutation</code>不会自动执行变异。它将把<code class="fe nk nl nm nb b">RunMutation</code>传递给它的<code class="fe nk nl nm nb b">builder</code>函数，这个函数必须被调用来执行变异。您可以在第121行看到它的运行。它接受一个带有突变参数的映射(在本例中是<code class="fe nk nl nm nb b">id</code>和<code class="fe nk nl nm nb b">completed</code>)。然后我们调用<code class="fe nk nl nm nb b">onRefresh</code>来重新运行查询并获得更新的数据。</p><p id="58cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，第33行的函数<code class="fe nk nl nm nb b">onCreate</code>负责显示一个对话框，询问任务标题并创建任务本身。<code class="fe nk nl nm nb b">AlertDialog</code>被包裹在我们现在熟悉的<code class="fe nk nl nm nb b">Mutation</code>中，第63行称之为变异本身。现在我们正在通过<code class="fe nk nl nm nb b">id</code>和<code class="fe nk nl nm nb b">title</code>；<code class="fe nk nl nm nb b">completed</code>默认为<code class="fe nk nl nm nb b">false</code>。</p><p id="d7ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用程序应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/c4ceac77bbb2ac84304f787bf0e7f460.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/0*HzfXd4k7LZRioPFm"/></div></figure><p id="6240" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在任何时候迷路了，请咨询Github repo。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="98e0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结束语</h1><p id="804e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">感谢您的阅读，我希望您现在知道如何在Flutter中使用GraphQL。在我接下来的文章中，我将讨论性能优化和实时更新。敬请期待！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="88b3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="06d5" class="ns nt it lb b lc mv lf mw li nu lm nv lq nw lu nx ny nz oa bi translated"><a class="ae ky" href="https://flutter.dev/docs" rel="noopener ugc nofollow" target="_blank">颤振单据</a></li><li id="0431" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><a class="ae ky" href="https://github.com/zino-app/graphql-flutter" rel="noopener ugc nofollow" target="_blank"> Graphql-flutter文档</a></li></ul></div></div>    
</body>
</html>