<html>
<head>
<title>Best Practices for Bash Scripts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Bash脚本的最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/best-practices-for-bash-scripts-17229889774d?source=collection_archive---------2-----------------------#2020-04-28">https://betterprogramming.pub/best-practices-for-bash-scripts-17229889774d?source=collection_archive---------2-----------------------#2020-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8f2a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">可靠、高性能和可重用Bash脚本的4分钟指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b6b4e46356cd6d6d4202ad4f995cca5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tkkJGhiYQqFKJp91SAPaIA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lucabravo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卢卡·布拉沃</a>在<a class="ae ky" href="https://unsplash.com/s/photos/scripts?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ff2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调试Bash脚本无异于大海捞针，尤其是在没有及时考虑结构化、日志记录和可靠性的情况下，在现有代码基础上不断增加新代码时。我经常发现自己处于这种情况——有时是由于我自己的错误，有时是在处理复杂的连环车祸时。</p><p id="f9ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遵循一些最佳实践，您肯定可以更好地编写、调试和维护您的脚本。信不信由你，没有什么能比编写干净的、随时可用的Bash代码更令人满意了。</p><p id="9d06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我想强调一下我在过去几年中学到的东西，以及一些经常让我措手不及的常见错误。这很重要，因为每个软件开发人员，在他们职业生涯的某个阶段，肯定会使用脚本来自动化日常操作任务。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1bba" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">了解你的朋友</h1><h2 id="f4b4" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">陷阱处理程序</h2><p id="12f5" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我遇到的大多数Bash脚本在脚本执行过程中发生意外时都没有使用有效的清理机制。</p><p id="1c1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">外部环境也可能导致意外情况，例如从内核接收信号。处理这种情况对于确保脚本足够健壮以在生产系统中运行是非常重要的。我经常使用退出处理程序来应对这种情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Bash中的陷阱处理程序</p></figure><p id="ec84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">trap</code> <em class="nr"> </em>是一个shell内置的，帮助你注册一个清理函数，这个函数在一些<code class="fe nn no np nq b">signals</code>事件中被调用。然而，像<code class="fe nn no np nq b">SIGINT</code>这样的处理程序应该格外小心，防止脚本中止。此外，在大多数情况下，你只需要抓住<code class="fe nn no np nq b">EXIT</code>就可以了，但是这个想法是，你真的可以根据每个信号定制脚本行为。</p><h2 id="5df6" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">设置“内置—快速失败”</h2><p id="706d" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">一旦出现错误就及时捕捉并快速失败是非常重要的。没有什么比继续这样做更糟糕的了:</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="4962" class="mu md it nq b gy nw nx l ny nz">rm -rf ${directory_name}/*</span></pre><p id="6a0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意变量名<code class="fe nn no np nq b">directory_name</code>仍然没有定义。</p><p id="73e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了处理这样的场景，在脚本开始时使用<code class="fe nn no np nq b">set</code> <em class="nr"> </em>内置代码很重要，比如<code class="fe nn no np nq b">set -o errexit</code>、<code class="fe nn no np nq b">set -o pipefail</code>或<code class="fe nn no np nq b">set -o nounset</code> <em class="nr"> </em>。这确保了脚本在遇到任何非零退出代码、使用未定义的变量、失败的管道命令等情况时会立即退出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oa">“设置”快速故障场景的内置功能</em></p></figure><p id="e6e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nr">注意:像</em> <code class="fe nn no np nq b"><em class="nr">set -o errexit</em></code> <em class="nr">这样的内置代码一旦出现“未处理”返回代码(大于零)，就会退出脚本。因此，引入自定义错误处理就更好了，比如:</em></p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="c64a" class="mu md it nq b gy nw nx l ny nz">#!/bin/bash</span><span id="c3ad" class="mu md it nq b gy ob nx l ny nz">error_exit() {<br/> line=$1<br/> shift 1<br/> echo “ERROR: non zero return code from line: $line — $@”<br/> exit 1<br/>}</span><span id="0572" class="mu md it nq b gy ob nx l ny nz">a=0<br/>let a++ || error_exit “$LINENO” “let operation returned non 0 code”<br/>echo “you will never see me”</span><span id="fab3" class="mu md it nq b gy ob nx l ny nz"># run it, now we have useful debugging output<br/>$ bash foo.sh <br/>ERROR: non zero return code from line: 9 — let operation returned non 0 code</span></pre><p id="ebdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将迫使你意识到脚本中所有命令的行为，并在措手不及之前提前处理好这些场景</p><p id="689a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nr">(感谢&amp;感谢</em> <a class="oc od ep" href="https://medium.com/u/57779bdbe11e?source=post_page-----17229889774d--------------------------------" rel="noopener" target="_blank"> <em class="nr">卢蒙森</em> </a> <em class="nr">分享上面的例子)</em></p><h2 id="9cb9" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated"><em class="oa"> ' </em> shellcheck '发现开发过程中的错误</h2><p id="b250" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在您的持续集成/测试管道中集成类似于<code class="fe nn no np nq b"><a class="ae ky" href="https://github.com/koalaman/shellcheck" rel="noopener ugc nofollow" target="_blank">shellcheck</a></code> <em class="nr"> </em>的东西是值得的，它会链接您的Bash代码并强制执行最佳实践。</p><p id="0c53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我个人在我的本地开发环境中使用它来获得关于语法、语义和某些我在开发时可能忽略的代码警告的反馈。它是Bash脚本的静态分析工具，我强烈推荐使用它。</p><h2 id="7c89" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">使用自定义退出代码</h2><p id="9772" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">POSIX强制返回代码不仅仅是<em class="nr">零</em>或<em class="nr">一— </em>，而是<em class="nr">零</em>或<em class="nr">非零。</em>利用这些功能为各种错误情况返回自定义错误代码(在201-254之间)。然后，其他脚本(包装您的脚本)可以使用这些信息来准确理解发生了什么类型的错误，并做出相应的反应。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Bash中的自定义错误代码</p></figure><p id="ab28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nr">注意:请格外小心你定义的变量名，这样你就不会不小心覆盖了来自系统的环境变量</em></p><h2 id="01a1" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">记录器功能</h2><p id="824c" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">美观且结构化的日志记录对于轻松理解脚本执行的输出非常重要。就像其他高级编程语言一样，我总是使用自定义日志函数，比如<code class="fe nn no np nq b">__msg_info</code>、<code class="fe nn no np nq b">__msg_error</code>等。在我的Bash脚本中也是如此。这有助于通过在一个地方进行更改来实施标准化的日志记录结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="71b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我通常更喜欢在我的脚本中有某种类型的<code class="fe nn no np nq b">__init</code>机制，这样的<em class="nr">记录器变量(和其他系统范围的)</em>被初始化或设置为默认值。它们也可能来自调用期间的命令行参数。</p><p id="99f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:<code class="fe nn no np nq b">$ ./run-script.sh --debug</code>之类的</p><p id="cdab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当脚本执行时，它确保这样的<em class="nr">系统范围的</em>设置被设置为缺省值(如果是强制的)或者至少用相关的东西初始化，如果需要的话。我通常基于用户体验和用户将/应该进入的配置细节之间的权衡来做出这个决定。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="910f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为重用和干净的系统状态而设计</h1><h2 id="acbd" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">模块化/可重用代码</h2><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="adf1" class="mu md it nq b gy nw nx l ny nz">├── framework<br/>│   ├── common<br/>│   │   ├── loggers.sh<br/>│   │   ├── mail_reports.sh<br/>│   │   └── slack_reports.sh<br/>│   └── daily_database_operation.sh</span></pre><p id="5a0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">维护一个单独的存储库总是有帮助的，这个存储库可以用来引导您想要开发的新Bash项目/脚本。所有可重用的东西都可以在这样的代码库中维护，并在其他想要使用这些功能的项目中使用<strong class="lb iu"> <em class="nr"> </em> </strong>。它极大地减少了其他脚本的大小，还确保了代码库是小的和可测试的。</p><p id="b297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像上面的例子一样，所有的日志记录功能，像<code class="fe nn no np nq b">__msg_info</code>、<code class="fe nn no np nq b">__msg_error</code>，以及其他像报告空闲时间这样的事情，都可以在<code class="fe nn no np nq b">common/*</code>下单独维护，并在其他像<code class="fe nn no np nq b">daily_database_operations.sh</code>这样的脚本中动态获取。</p><h2 id="ff7b" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">留下干净的状态</h2><p id="a22b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">例如，如果您在脚本执行期间下载一些资源，将所有这些数据存储在一个公共的、随机命名的目录下总是一个最佳实践——比如<code class="fe nn no np nq b">/tmp/AlRhYbD97/*</code>。您可以在这里使用随机文本生成器。</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="b726" class="mu md it nq b gy nw nx l ny nz">rand_dir_name="$(cat /dev/urandom | tr -dc ‘a-zA-Z0–9’ | fold -w 16 | head -n 1)"</span></pre><p id="c628" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稍后，可以确保在<code class="fe nn no np nq b">trap</code>处理程序中清理这些目录(如上所述)。如果这些事情没有得到处理，它们就会堆积起来，在某个阶段会给主机带来意想不到的问题。</p><h2 id="6401" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">使用锁定文件</h2><p id="4f78" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在任何给定的时间点，强制主机上只执行一个脚本实例通常会有所帮助。这可以通过锁文件来管理。</p><p id="2210" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我通常在<code class="fe nn no np nq b">/tmp/project_name/*.lock</code> <em class="nr"> </em>下创建锁文件<em class="nr"> </em>，并在脚本开始时检查它们是否存在。这有助于优雅地退出程序，并避免并行运行的其他脚本对系统状态的意外更改。如果您绝对需要在给定的主机上并行运行相同的脚本，则可能不需要这样做。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="14e5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">衡量和改进</h1><p id="16fe" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们经常需要处理长时间运行的脚本——例如，日常的数据库操作。此类操作通常包括一系列步骤，如下载数据、检查异常、导入数据、发送状态报告等。</p><p id="7679" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我总是尝试将这些步骤分解成单独的脚本，并使用以下方法测量/报告它们的执行状态和时间:</p><p id="6f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">time source "${filepath}" "${args}"&gt;&gt; "${LOG_DIR}/RUN_LOG" 2&gt;&amp;1</code></p><p id="9876" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稍后，我用以下命令获取执行时间:</p><p id="b0e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">tac "${LOG_DIR}/RUN_LOG.txt" | grep -m1 "real"</code></p><p id="53bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这帮助我多次找出脚本中需要优化的有问题/慢的地方。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3e3d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">进一步学习</h1><p id="57bb" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">迄今为止，我遇到的最好的学习资源是苹果公司关于<a class="ae ky" href="https://developer.apple.com/library/archive/documentation/OpenSource/Conceptual/ShellScripting/shell_scripts/shell_scripts.html" rel="noopener ugc nofollow" target="_blank"> Shell脚本基础</a>的文档——我强烈推荐它。</p><p id="e475" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能给你一些思路，帮助你编写健壮的、高性能的脚本，可以安全地在关键系统上使用。下次见，<em class="nr"> tschüss！</em></p></div></div>    
</body>
</html>