<html>
<head>
<title>Python Spline Interpolation How-To</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python样条插值操作指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/python-spline-interpolation-how-to-ef059c214d28?source=collection_archive---------6-----------------------#2022-08-15">https://betterprogramming.pub/python-spline-interpolation-how-to-ef059c214d28?source=collection_archive---------6-----------------------#2022-08-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="15a3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">SciPy插值例程的简短演练</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9fcbea9aabb6bbf1d1dd7216d46d2121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8HIoGDiYECDfq0JE03uJg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:自己的作品</p></figure><p id="1d70" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你曾经在Python中插入过一个函数，你可能想知道为什么有这么多方法来做一件简单的事情。2D插值方法尤其令人兴奋，因为它们使用了关于x轴和y轴顺序的不兼容约定。这里有一个简短的总结，什么时候使用哪个，什么参数遵循哪个约定。</p><h1 id="5f5e" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">一维</h1><p id="5f09" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">1D的情况相对简单。每个插值函数都有自己独特的功能集:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/ec5cc8668be330720308c9cdd1dc583b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WROSfQqDjRdwO9NmEJ3R1g.png"/></div></div></figure><p id="5174" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b"><a class="ae mw" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.html" rel="noopener ugc nofollow" target="_blank">UnivariateSpline</a></code>是唯一一个既能插值又能拟合的。它还接受节点的自定义权重。</p><p id="c575" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b"><a class="ae mw" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html" rel="noopener ugc nofollow" target="_blank">interp1d</a></code>借用了MATLAB的命名惯例。对于默认的线性情况，它使用Python(如果可能的话，使用NumPy)来表示二次和二次以上——Fortran。</p><p id="d84d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b"><a class="ae mw" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.CubicSpline.html" rel="noopener ugc nofollow" target="_blank">CubicSpline</a></code>与其他瘦Fortran包装的方法不同，它主要是用Python实现的(=不太隐晦的错误消息；可能会慢一点)并且只使用Fortran进行稀疏矩阵提升。只有三次样条提供了在各种边界条件之间进行选择的方法(其他的使用“不知道”条件)。</p><p id="0003" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">线性样条完全不需要任何边界条件(方程的个数与未知数的个数相同)。在三次样条中，数据点本身并不能唯一地定义一条样条；需要两个边界条件来匹配未知数的数量，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/158cebcaddf262b302d7a1de3f30ea06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8GhoXPv3UPbPOF16fv_8oQ.png"/></div></div></figure><p id="c665" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据要插值的函数的特征，一种边界条件可能比其他边界条件给出更好的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/91b80ccb4be831dd344fda6be1a11608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pI_k6jctl3PQwvw4LBJBcA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae mw" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.CubicSpline.html" rel="noopener ugc nofollow" target="_blank">文档中的详细信息</a></p></figure><p id="e604" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个交互式仪表板，演示了不同类型的边界条件在实践中是如何工作的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/f321f650cb249d64acf4aeb93eff5887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ihMdBEz-aJvl8ubZaT3PlQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae mw" href="https://si1.alwaysdata.net/myapp" rel="noopener ugc nofollow" target="_blank">网上试试</a></p></figure><p id="f8f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于<code class="fe ms mt mu mv b">sin(x)</code>，最佳边界条件(不出所料)是“周期性的”猜猜哪个条件最适合<code class="fe ms mt mu mv b">1/(1+x²)</code>。</p><p id="6f85" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简而言之，插值1D函数需要做的就是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/324b6d87970fa4f6ed21c3679955e310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JiAS-s9FdjnuB6bN49iY3Q.png"/></div></div></figure><p id="1482" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里使用了默认的“非纽结”边界条件——如果您对要插值的数据一无所知，它们会发挥最大作用。</p><p id="2f8e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您在图上看到以下“特征”，您可以微调边界条件以获得更好的结果:<br/>。一阶导数在边界处消失= &gt; <code class="fe ms mt mu mv b">bc_type=‘clamped’<br/></code>。二阶导数在边界处消失= &gt; <code class="fe ms mt mu mv b">bc_type='natural'<br/></code>。函数是周期性的= &gt; <code class="fe ms mt mu mv b">bc_type='periodic'</code></p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="1d79" class="lu lv it bd lw lx nk lz ma mb nl md me jz nm ka mg kc nn kd mi kf no kg mk ml bi translated">二维</h1><p id="c6d8" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">2D的例子有时会违反直觉。有时候，你需要转置这个或那个；有时候不会。首先，一个图表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/4bd59985c9cda3d63d3c6c8faf723c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*scM2ZP9GcvGpwwb9y0zUJw.png"/></div></div></figure><p id="52df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b"><a class="ae mw" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RectBivariateSpline.html" rel="noopener ugc nofollow" target="_blank">RectBivariateSpline</a></code>(或<code class="fe ms mt mu mv b"><a class="ae mw" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp2d.html" rel="noopener ugc nofollow" target="_blank">interp2d</a></code>，看下面的区别)是你最可能想使用的函数，如果你只有一个2D数组，你想插值(或重采样，或近似)。它期望节点位于规则(=等距)网格或直线(非等距)网格上:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/07dcf2018d3231fc7473cf13c827854d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dv_8ahEV4VE_AfFR3CvPvg.png"/></div></div></figure><p id="c1c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">直线网格允许我们使用对数轴或在最“困难”的区域集中数据点。</p><p id="cdad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b"><a class="ae mw" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.SmoothBivariateSpline.html" rel="noopener ugc nofollow" target="_blank">SmoothBivariateSpline</a></code>对任意分布的点进行操作。它会自动建立一个直线网格，并尽力将点映射到这个网格。然而，这并不是插值这些数据的唯一方法。非直线网格(如scipy . interpole .<a class="ae mw" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.griddata.html" rel="noopener ugc nofollow" target="_blank">grid data</a>)可能会给出更好的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/0ca20f0b741b15c206ff5882f6f443c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pkPJwovD4erzhi6dy7M9iA.png"/></div></div></figure><p id="0e63" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b"><a class="ae mw" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQBivariateSpline.html" rel="noopener ugc nofollow" target="_blank">LSQBivariateSpline</a></code>做同样的事情，但允许你手动选择样条节点的位置。</p><p id="8317" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，<code class="fe ms mt mu mv b"><a class="ae mw" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp2d.html" rel="noopener ugc nofollow" target="_blank">interp2d</a></code>可以作为<code class="fe ms mt mu mv b">RectBivariateSpline</code>或者<code class="fe ms mt mu mv b">SmoothBivariateSpline</code>，这取决于你输入的数据类型。两个主要的干扰是:<br/>–它使用的轴命名惯例与<code class="fe ms mt mu mv b">RectBivariateSpline</code>完全相反(详见下文)。<br/>–要获得三次样条，你需要编写<code class="fe ms mt mu mv b">kind='cubic'</code>，因为默认情况下它是线性的，所以总的来说，击键次数与<code class="fe ms mt mu mv b">RectBivariateSpline</code>:)中的大致相同</p><p id="699a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">早在2013年就有关于贬低interp2d的讨论，但我认为这不太可能很快发生。</p><p id="110c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，确保提供足够的数据点:最小数量是<code class="fe ms mt mu mv b">(k+1)²</code>，其中<code class="fe ms mt mu mv b">k=1</code>表示线性，<code class="fe ms mt mu mv b">k=3</code>表示三次，<code class="fe ms mt mu mv b">k=5</code>表示五次插值，因此三次样条至少需要一个4x4的网格(否则，您将得到一个看起来很奇怪的<a class="ae mw" href="https://scicomp.stackexchange.com/questions/31306/problems-with-pythons-interp-2d" rel="noopener ugc nofollow" target="_blank">错误</a>)。</p><h1 id="4c59" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">interp2d vs RectBilinearRect</h1><p id="dce9" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">关于SciPy中的2D插值，最有问题的一点就是理解哪个轴是x，哪个轴是y，在NumPy中，维度是通过索引引用的，而不是名字；在<a class="ae mw" href="https://docs.xarray.dev/en/stable/" rel="noopener ugc nofollow" target="_blank"> xarray </a>中，它们被自定义名称引用。这样做是有原因的:你可以自由地将第n维与你心目中的任何轴相关联。在<code class="fe ms mt mu mv b">scipy.interpolate</code>中，这个映射是硬编码的；而且<code class="fe ms mt mu mv b">interp2d</code>和<code class="fe ms mt mu mv b">RectBivariateSpline</code>之间硬编码不一致。</p><p id="ecd9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据您正在操作的数据，您可能会发现一种方法是直观和自然的，而另一种方法是非理性和模糊的。两者背后都有逻辑；只是略有不同。需要特别注意的是最后一个论点，<code class="fe ms mt mu mv b">z</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/04b8b77d3a5c502ddbca058006ce7abb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KcXaUfvAFbra7NR-OxEeFA.png"/></div></div></figure><p id="3436" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">函数<code class="fe ms mt mu mv b">f</code>返回的值也受到约定的影响:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/df7164cfdd6533a59aabd293b0aef1f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hu1O2dC7bgGu3fTXiQ4Wtw.png"/></div></div></figure><p id="ad05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据您的需要，您可能更喜欢这两种方法中的一种。在内部，它们都调用完全相同的Fortran例程，所以就精度和速度而言，选择哪一个都没有区别。</p><p id="5e35" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的示例中，计算函数的格网与输入格网相同。通常，您会想要计算不同网格上的值。以下是3D效果图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/56326ee10c7d70aad91d5a2329178b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BQxFHJ5ZyZ2MJQNf43sW4A.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/5c326a4d2a482daeec86465cc1c47622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KOuoTuVx165Qlc93WECmdg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">左:z，原始数据。右:子，插值数据。</p></figure><p id="3503" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在3D中绘制结果的一个基本细节是如何创建meshgrid。<code class="fe ms mt mu mv b">interp2d</code>对应默认的<code class="fe ms mt mu mv b">xy</code>分度模式，而<code class="fe ms mt mu mv b">RectBivariateSpline</code> —对应<code class="fe ms mt mu mv b">ij</code>模式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/f0073425560dd7333ec5ecf072b41e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u3E4VOMf-oZIaOkPnvvcTw.png"/></div></div></figure><h1 id="2764" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">3D绘图库</h1><p id="6c4a" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在Matplotlib中(如<a class="ae mw" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.contour.html" rel="noopener ugc nofollow" target="_blank">轮廓</a>、<a class="ae mw" href="https://matplotlib.org/stable/tutorials/toolkits/mplot3d.html?highlight=plot_surface#mpl_toolkits.mplot3d.Axes3D.plot_surface" rel="noopener ugc nofollow" target="_blank"> plot_surface </a>)，X和Y是二维的，所以一般来说，只要<code class="fe ms mt mu mv b">X</code>、<code class="fe ms mt mu mv b">Y</code>、<code class="fe ms mt mu mv b">Z</code>形状相同，用哪种约定都无所谓。然而<code class="fe ms mt mu mv b">plot_surface</code>(如果没有给出颜色图)对于带有<code class="fe ms mt mu mv b">xy</code>和<code class="fe ms mt mu mv b">ij</code>索引的网格会产生不同的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/0a048206f8bf4c3c2ea6f8d8d3952ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KTa5neR24jMuN2uFFKKubw.png"/></div></div></figure><p id="5f5b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么？带有<code class="fe ms mt mu mv b">xy</code>索引的表面具有指向上方的法向量，因此它被解释为某个3D体积的顶面，并使其更亮。<code class="fe ms mt mu mv b">ij</code>的表面指向下方，所以被解释为底面，渲染的比较暗。在绘制函数<code class="fe ms mt mu mv b">f(x, y)</code>时，它看起来更像一个顶面，因此<code class="fe ms mt mu mv b">xy</code>索引(由<code class="fe ms mt mu mv b">interp2d</code>使用的那个)通常会给出更好的结果。参见<a class="ae mw" href="https://github.com/matplotlib/matplotlib/issues/23570" rel="noopener ugc nofollow" target="_blank"> #23570 </a>。</p><p id="240d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Plotly期望<code class="fe ms mt mu mv b">xy</code>为3D绘图(和一维<code class="fe ms mt mu mv b">x</code>和<code class="fe ms mt mu mv b">y</code>)建立索引；<a class="ae mw" href="https://docs.enthought.com/mayavi/mayavi/auto/mlab_helper_functions.html#surf" rel="noopener ugc nofollow" target="_blank"> Mayavi </a>偏好<code class="fe ms mt mu mv b">ij</code>索引(以及一维或二维<code class="fe ms mt mu mv b">x</code>和<code class="fe ms mt mu mv b">y</code>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/4cc91be95c6ad22fbf9aaf4034d601a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nDex25kW2hdG9hgmv9os-Q.png"/></div></div></figure></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><p id="8ee4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一次你碰巧对数据进行插值或近似时，你希望花更少的时间去考虑哪种插值方法最适合你，哪种指数代表哪种维度。不然给我留个纸条:)。</p></div></div>    
</body>
</html>