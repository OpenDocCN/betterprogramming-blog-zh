<html>
<head>
<title>How To Use Dagger2 in Your Android Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在你的Android库中使用Dagger2</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-dagger2-in-your-android-library-bc6741dfbba4?source=collection_archive---------4-----------------------#2021-07-08">https://betterprogramming.pub/how-to-use-dagger2-in-your-android-library-bc6741dfbba4?source=collection_archive---------4-----------------------#2021-07-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0d04" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Dagger2在Android库中实现依赖注入</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/274bba9317cae1924267eb621867809f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NSkFhHfob30a1HIm"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">吉米·张在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="d65a" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">从这篇文章中吸取教训</h2><p id="99e9" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在本文中，您将学习如何使用Dagger2在Android库中实现依赖注入。本文的重点是AAR库格式，但是我们在这里遵循的过程可以应用于任何库格式。</p><h1 id="e870" class="mo la it bd lb mp mq mr le ms mt mu lh jz mv ka ll kc mw kd lp kf mx kg lt my bi translated">介绍</h1><p id="5bca" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">依赖注入是类获取其他类的引用的另一种方式。例如，有一个类<code class="fe mz na nb nc b">BananaMilkshake</code>，它可能需要<code class="fe mz na nb nc b">Milk</code>类。在这里，<code class="fe mz na nb nc b">BananaMilkShake</code>依赖于<code class="fe mz na nb nc b">Milk</code>类。通常这些必需的类，像<code class="fe mz na nb nc b">Milk</code>，被称为依赖。</p><p id="ce39" class="pw-post-body-paragraph lv lw it lx b ly nd ju ma mb ne jx md li nf mf mg lm ng mi mj lq nh ml mm mn im bi translated">实现依赖注入为您提供了以下优势:</p><ul class=""><li id="c6c7" class="ni nj it lx b ly nd mb ne li nk lm nl lq nm mn nn no np nq bi translated">代码的可重用性</li><li id="0386" class="ni nj it lx b ly nr mb ns li nt lm nu lq nv mn nn no np nq bi translated">易于重构</li><li id="0270" class="ni nj it lx b ly nr mb ns li nt lm nu lq nv mn nn no np nq bi translated">易于测试</li></ul><p id="ee86" class="pw-post-body-paragraph lv lw it lx b ly nd ju ma mb ne jx md li nf mf mg lm ng mi mj lq nh ml mm mn im bi translated">依赖注入有三种类型:</p><ol class=""><li id="4e80" class="ni nj it lx b ly nd mb ne li nk lm nl lq nm mn nw no np nq bi translated">在类本身中创建所需的对象(类似于在<code class="fe mz na nb nc b">BananaMilkshake</code>类中创建的<code class="fe mz na nb nc b">Milk</code>类对象)。</li><li id="512d" class="ni nj it lx b ly nr mb ns li nt lm nu lq nv mn nw no np nq bi translated">从其他地方获取所需的对象(比如Android-activity组件中的上下文)。</li><li id="23f5" class="ni nj it lx b ly nr mb ns li nt lm nu lq nv mn nw no np nq bi translated">提供所需的类对象作为参数(可以通过构造函数来创建)。</li></ol><h1 id="d902" class="mo la it bd lb mp mq mr le ms mt mu lh jz mv ka ll kc mw kd lp kf mx kg lt my bi translated">先决条件</h1><p id="09a4" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在学习如何在Android库中实现DI之前，学习如何使用Dagger2在Android项目中实现DI是非常重要的。如果你是这个概念的新手，我强烈推荐阅读以下几篇文章。</p><ul class=""><li id="a730" class="ni nj it lx b ly nd mb ne li nk lm nl lq nm mn nn no np nq bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/dependency-injection-in-android-with-dagger2-d260b8a72bb0">“使用Dagger2在Android中进行依赖注入”</a></li><li id="c35d" class="ni nj it lx b ly nr mb ns li nt lm nu lq nv mn nn no np nq bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/injecting-android-viewmodels-with-dagger2-in-clean-architecture-744c1fe81530">“如何在Android中用Dagger2建立依赖注入框架”</a></li><li id="5aa4" class="ni nj it lx b ly nr mb ns li nt lm nu lq nv mn nn no np nq bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/injecting-android-viewmodels-with-dagger2-in-clean-architecture-744c1fe81530">“在干净的架构中使用Dagger2注入Android视图模型”</a></li></ul><h1 id="c55b" class="mo la it bd lb mp mq mr le ms mt mu lh jz mv ka ll kc mw kd lp kf mx kg lt my bi translated">Android库</h1><p id="6b02" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">让我们来谈谈Android库，通常开发人员在拥有一个正在多个项目中使用的特性时会创建库。通过将该功能开发为Android库，它可以在组织的应用程序中重用，如果需要，他们可以外包该库。</p><p id="d952" class="pw-post-body-paragraph lv lw it lx b ly nd ju ma mb ne jx md li nf mf mg lm ng mi mj lq nh ml mm mn im bi translated">出于安全考虑，许多开发人员选择使用Android Archive(AAR)格式库来构建。我完全同意他们的观点；AAR很容易在maven存储库中构建和托管，它提供了来自宿主应用程序的代码的完全抽象。如果你想了解更多关于AAR的信息，请阅读下面的文章:</p><div class="nx ny gp gr nz oa"><a href="https://sgkantamani.medium.com/how-to-create-an-android-archive-aar-library-f940cbf5280" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">如何创建Android归档(AAR)库</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">你应该知道的关于AAR的一切。</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">sgkantamani.medium.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ks oa"/></div></div></a></div><h1 id="b5d7" class="mo la it bd lb mp mq mr le ms mt mu lh jz mv ka ll kc mw kd lp kf mx kg lt my bi translated">Android库中的Dagger2</h1><p id="dc64" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">最后来看本文的主要部分，开发人员通常创建应用程序范围组件，并将所有模块链接到它们。最后，它将从Android应用程序类中触发。</p><p id="786b" class="pw-post-body-paragraph lv lw it lx b ly nd ju ma mb ne jx md li nf mf mg lm ng mi mj lq nh ml mm mn im bi translated">但是对于Android库来说，在库中有一个应用程序类并不是最佳实践，因为主机可能已经有了一个应用程序类。在库中创建另一个应用程序类将会产生冲突。</p><p id="b156" class="pw-post-body-paragraph lv lw it lx b ly nd ju ma mb ne jx md li nf mf mg lm ng mi mj lq nh ml mm mn im bi translated">需要记住的另一个方面是，主机应用程序可能会使用Dagger2、Hilt或它自己的依赖注入逻辑。因此，我们不应该依赖主机应用程序来处理与DI相关的任何事情。</p><p id="e6c5" class="pw-post-body-paragraph lv lw it lx b ly nd ju ma mb ne jx md li nf mf mg lm ng mi mj lq nh ml mm mn im bi translated">这里的解决方案是库dagger对象图不应该依赖于宿主应用程序。幸运的是，Dagger能够从应用程序、活动或片段中初始化对象图。所以在我们的例子中，我们可以使用activity或者Fragment，尽管我建议从Activity开始。</p><h1 id="927b" class="mo la it bd lb mp mq mr le ms mt mu lh jz mv ka ll kc mw kd lp kf mx kg lt my bi translated">Android库中的前期工作</h1><p id="e1d6" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">为了更好地理解这种方法，让我们创建一个简单的框架，其中有一个存储库接口及其实现，以及一个简单的数据提供者类。让我们从具有返回字符串列表的单一函数的数据提供者开始。请看以下内容:</p><pre class="kj kk kl km gt op nc oq or aw os bi"><span id="5c6f" class="kz la it nc b gy ot ou l ov ow">class SampleDataProvider {<br/><br/>    fun sampleList() = <em class="ox">listOf</em>&lt;String&gt;(<br/>        "Apple",<br/>        "Orange",<br/>        "Mango",<br/>        "Graps"<br/>    )<br/><br/>}</span></pre><p id="af76" class="pw-post-body-paragraph lv lw it lx b ly nd ju ma mb ne jx md li nf mf mg lm ng mi mj lq nh ml mm mn im bi translated">现在让我们实现存储库及其实现，在其中我们应该从<code class="fe mz na nb nc b">SampleDataProvider</code>类中访问数据。下面看看它是如何工作的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">知识库及其实现</p></figure><p id="db2a" class="pw-post-body-paragraph lv lw it lx b ly nd ju ma mb ne jx md li nf mf mg lm ng mi mj lq nh ml mm mn im bi translated">注意，如果您重新构建应用程序，您将得到一个编译时异常，因为我们要求Dagger在存储库实现中提供数据提供者实例，但没有告诉它如何提供。</p><h1 id="6318" class="mo la it bd lb mp mq mr le ms mt mu lh jz mv ka ll kc mw kd lp kf mx kg lt my bi translated">在Android库中创建Dagger模块</h1><p id="5ebe" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这个编译时错误将我们引向库中的agger模块。在这里，我们需要创建一个带有函数的模块，用binds或provide来告诉dagger如何在调用点被请求时提供依赖关系。看看一个简单的匕首模块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Android库中的简单匕首模块</p></figure><h1 id="fcba" class="mo la it bd lb mp mq mr le ms mt mu lh jz mv ka ll kc mw kd lp kf mx kg lt my bi translated">Dagger库组件</h1><p id="5a8e" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">现在我们需要创建一个简单的Dagger组件，它接受库模块，并且应该从活动中注入。请看以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="8e60" class="pw-post-body-paragraph lv lw it lx b ly nd ju ma mb ne jx md li nf mf mg lm ng mi mj lq nh ml mm mn im bi translated">现在，为了触发dagger代码的生成，我们需要重新构建项目。一旦项目成功重建，我们将可以访问<code class="fe mz na nb nc b"><strong class="lx iu">DaggerLibraryComponent</strong></code><strong class="lx iu"/>，并且我们可以在活动中实际执行注入。看一下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="01c9" class="pw-post-body-paragraph lv lw it lx b ly nd ju ma mb ne jx md li nf mf mg lm ng mi mj lq nh ml mm mn im bi translated">仅此而已。现在您可以在活动中注入<code class="fe mz na nb nc b">SampleRepo</code>并从<code class="fe mz na nb nc b">DataProvider</code>类中访问数据。但是请记住，组件的范围仅限于这里的活动。看一下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在库活动中注入依赖项的最终代码</p></figure><h1 id="c27a" class="mo la it bd lb mp mq mr le ms mt mu lh jz mv ka ll kc mw kd lp kf mx kg lt my bi translated">奖金</h1><p id="7aee" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我最近看到了一篇由<a class="ae ky" href="https://medium.com/u/d255c4fc9d76?source=post_page-----4c9f44d04e68--------------------------------" rel="noopener"> Satya Pavan Kantamani </a>发表的关于Android中通过Kotlin DSL进行依赖管理的优秀文章，强烈推荐:</p><div class="nx ny gp gr nz oa"><a href="https://pavan-careers5208.medium.com/better-dependencies-management-using-buildsrc-kotlin-dsl-eda31cdb81bf" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">使用buildSrc + Kotlin DSL实现更好的依赖性管理</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">依赖关系管理，实现更好的可重用性和易维护性</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">pavan-careers5208.medium.com</p></div></div><div class="oj l"><div class="pa l ol om on oj oo ks oa"/></div></div></a></div><p id="24ae" class="pw-post-body-paragraph lv lw it lx b ly nd ju ma mb ne jx md li nf mf mg lm ng mi mj lq nh ml mm mn im bi translated">目前就这些。希望你学到了有用的东西。</p><p id="8e12" class="pw-post-body-paragraph lv lw it lx b ly nd ju ma mb ne jx md li nf mf mg lm ng mi mj lq nh ml mm mn im bi translated">感谢阅读。</p></div></div>    
</body>
</html>