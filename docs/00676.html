<html>
<head>
<title>10 Things Not to Do When Building React Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建React应用时不要做的10件事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-things-not-to-do-when-building-react-applications-bc26d4f38644?source=collection_archive---------0-----------------------#2019-06-29">https://betterprogramming.pub/10-things-not-to-do-when-building-react-applications-bc26d4f38644?source=collection_archive---------0-----------------------#2019-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="68ac" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">React应用中的最佳实践</h2><div class=""/><div class=""><h2 id="5c76" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">根据我在生产部门的工作经验，应该避免什么</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/464603438c544cbfeab1c6c8e953d9dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7-ckgPLQ0lcF7nYAbkGIaQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://www.pexels.com/photo/flat-screen-monitor-turned-on-in-office-2343475/" rel="noopener ugc nofollow" target="_blank"> Alex Qian </a>从<a class="ae lh" href="https://www.pexels.com/photo/flat-screen-monitor-turned-on-in-office-2343475/" rel="noopener ugc nofollow" target="_blank"> Pexels </a></p></figure><p id="e4dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">React 是一个流行的开发工具，我相信你的React爱好者们会感到很幸运，能够亲手使用这样一个伟大的库。</p><p id="7b00" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不幸的是，生活中没有什么是完美的，React也不例外。React有自己的一套<em class="me">陷阱</em>——如果您现在不处理好它们，其中一些可能会成为您的应用程序的严重问题。</p><p id="ea0e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面是构建React应用程序时不要做的10件事。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="524c" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">1.花太多时间在自己的私人世界里</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/a7467a6623560b9e7a8b9183f1defba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*I9KYeTIJGSFE4M06.jpg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://www.pexels.com/ru-ru/photo/2505333/" rel="noopener ugc nofollow" target="_blank">布鲁诺拍摄</a>来自<a class="ae lh" href="https://www.pexels.com/ru-ru/photo/2505333/" rel="noopener ugc nofollow" target="_blank">像素</a></p></figure><p id="4815" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你花太多时间编码，而没有花时间阅读社区中发生的事情，你就有可能遇到社区中报道的糟糕的编码实践。在你最终发现那些糟糕的编码实践代码是糟糕的之前，你可能会使用它们20次。</p><p id="5436" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当这种情况发生时，您将不得不回头重构这20个代码实现，因为您发现得太晚了。当你这么做的时候，其他人都会走在你前面。当你还在追赶的时候，他们会转向更新的编码新闻。</p><p id="a1b4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当React松开<a class="ae lh" href="https://reactjs.org/docs/hooks-overview.html" rel="noopener ugc nofollow" target="_blank">钩子</a>的时候，我是如此的激动。我开始构建一些迷你项目来玩这些新玩具，每个人都被大肆宣传。在阅读了一些关于钩子将变得稳定的资料后，我开始在我的项目中更加认真地实现它们。我到处都在使用<code class="fe ne nf ng nh b">useState</code>和<code class="fe ne nf ng nh b">useEffect</code><em class="me"/>。</p><p id="9e0a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后我发现有人链接到这条推文，这让我对<code class="fe ne nf ng nh b">useReducer</code>做了更多的研究。这30分钟的研究足以让我回去重构大量代码。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="23f2" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">2.使用。绑定(不是类组件构造函数)</h1><p id="d1f2" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">我想我们大多数React开发者都知道，如果我们想要引用<code class="fe ne nf ng nh b">this </code>来访问他们方法中自己的类实例，我们应该<code class="fe ne nf ng nh b">.bind</code>我们的类方法。(除非你使用<a class="ae lh" href="https://babeljs.io/docs/en/babel-plugin-proposal-class-properties" rel="noopener ugc nofollow" target="_blank"> transpiler </a>来传输你的类属性和方法。)</p><p id="2265" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">太棒了，我也更喜欢用<em class="me">箭头函数</em>声明类方法。</p><p id="e6e6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是我要说的是<em class="me">内联函数。</em>这些是在react组件的<em class="me"> render方法</em>中定义的函数，并作为道具传递给子组件。</p><p id="de30" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当在render方法中定义内联函数时，React开始在每次组件重新呈现时指定一个新的函数实例。由于<a class="ae lh" href="https://www.freecodecamp.org/news/how-to-identify-and-resolve-wasted-renders-in-react-cc4b1e910d10/" rel="noopener ugc nofollow" target="_blank">浪费的重新渲染</a>，这已知会导致性能问题。</p><p id="23aa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们来看看这个例子:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="72e5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们<em class="me">知道</em>的<code class="fe ne nf ng nh b">onClick={() =&gt; sayWhereTheMoneyIs("I don't know")}</code>和<code class="fe ne nf ng nh b">onClick={() =&gt; showThemTheMoney(0.05)}</code>是<em class="me">的内联函数</em>。</p><p id="9c68" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我看过一些鼓励这样做的教程(包括一个来自Udemy的教程):</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5702" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这似乎缓存了引用并避免了不必要的重新渲染，因为他们没有在渲染方法<em class="me">中使用箭头内嵌函数。但是他们实际上仍然在每个渲染阶段创建新的函数。</em></p><p id="2089" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您在React生态系统中关注类组件的趋势，您可能已经知道这一点。</p><p id="3f36" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，自从React钩子发布后，关于<code class="fe ne nf ng nh b">.bind </code>的讨论就少了，因为类组件变得不那么流行了。当谈到<code class="fe ne nf ng nh b">.bind</code>时，人们通常会讨论绑定类方法。此外，上面的例子根本没有绑定到类方法。如果你不小心的话，就更难注意到这里的后果。</p><p id="e9bc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">新人尤其要注意这种反模式！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="cace" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">3.将动态值作为键传递给子级</h1><p id="e5e7" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">你有没有过被迫向被映射的孩子提供唯一的密钥的感觉？最好提供唯一的键:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d19f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在假设<code class="fe ne nf ng nh b">items1 </code>中的一些<code class="fe ne nf ng nh b">to</code>值恰好与<code class="fe ne nf ng nh b">items2</code>中的一些值相同。</p><p id="7fd3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">履行</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="57d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，如果你正在寻找一个支持多个用例的组件，我不推荐这样的解决方案。这是为了特定的用途，我们知道<em class="me"> </em>它将只在那个环境中被重用。支持多种用例的更动态的可重用解决方案可能会被编码得更通用。您仍然应该这样做<em class="me">而不需要</em>改变实现:</p><ol class=""><li id="1c73" class="np nq it lk b ll lm lo lp lr nr lv ns lz nt md nu nv nw nx bi translated">这样，我们现在允许开发人员根据需要随意扩展组件的任何部分，同时保留底层实现。</li><li id="5a4d" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi translated">6.初始化构造函数中的属性</li></ol><p id="c5df" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在构造函数中初始化状态时:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="b4a6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可能会遇到错误。这是因为构造函数只被调用一次，也就是组件第一次被创建的时候。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="478a" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">下一次你试图改变<code class="fe ne nf ng nh b">props</code>的时候，状态将保持它之前的值，因为构造函数在重新渲染时不会被调用。</h1><p id="5fe7" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">如果你还没有遇到这个问题，希望这对你有所帮助！如果您想知道如何让<code class="fe ne nf ng nh b">props </code>与状态同步，更好的方法应该是这样的:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="babd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">7.用&amp;&amp;进行条件渲染</p><p id="7f3c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当有条件地呈现组件时，一个常见的问题是使用<code class="fe ne nf ng nh b"> &amp;&amp;</code>操作符。</p><p id="ebbf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果某个条件不满足它的要求，React将尝试将您提供的任何内容作为替代输出。因此，当我们看这个的时候:</p><p id="e6c0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当<code class="fe ne nf ng nh b">items.length<em class="me"> </em></code>为空时，这实际上会在屏幕上呈现一个数字<em class="me"> 0 </em>。JavaScript认为数字<em class="me"> 0 </em>是一个<a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy" rel="noopener ugc nofollow" target="_blank">假值</a>，所以当<code class="fe ne nf ng nh b">items</code>是一个空数组时，<code class="fe ne nf ng nh b"><em class="me">&amp;&amp;</em></code>操作符不会计算它右边的表达式。它只会返回第一个值。</p><p id="1335" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我想保留语法，我通常会使用双重否定:</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="4afc" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">这样，如果<code class="fe ne nf ng nh b">items</code>是一个空数组，React将不会在屏幕上呈现任何内容，如果计算的输出是一个布尔值。</h1><p id="2d4f" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">8.不传播以前的状态</p><p id="b06b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">偶尔会出现在我的错误列表中的东西来自于不小心实现的状态更新逻辑。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="bd61" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最近的一个情况涉及React钩子，特别是一个<code class="fe ne nf ng nh b">useReducer </code>实现。这是一个成为问题的基本例子:</p><p id="8f31" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当<code class="fe ne nf ng nh b">something</code>函数调用并复制状态时，底层的<code class="fe ne nf ng nh b">items</code>属性没有改变。当我们使用<code class="fe ne nf ng nh b">.splice</code>对它进行变异时，它会变异<code class="fe ne nf ng nh b">state.items</code>，并引入错误。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="1c31" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在更大的代码中，尤其会对此感到厌倦。我们都可能会忘记上面这个小例子，但是当事情变得混乱时，这个<em class="me">总是</em>必须牢记在心。人们很容易忘记这一点，尤其是当您被迫将代码发布到产品中的时候！</p><p id="eac9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">9.没有显式地将属性传递给子组件</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="89cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一般来说，建议您在传递给子组件的属性中要明确。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="014c" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">这有几个很好的理由:</h1><p id="43a5" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">您有一个更容易的调试体验。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="af2f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为一名开发者，你知道每个孩子都接受了什么。</p><p id="a1c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其他开发人员也会知道，并且会更容易阅读代码。</p><p id="b9d9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">更容易理解一个组件将做什么。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="8a7e" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">传递props explicity的另一个好处是，当你这样做的时候，它也以一种每个人都理解的方式记录了你的代码，而不需要正式的文档。这样可以节省时间！</h1><p id="26dd" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">为了确定组件是否应该重新渲染，需要的<em class="me">道具会更少。</em></p><p id="37af" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">可以有一些非常简洁的用例来传播所有的道具。例如，如果在将道具传递给子组件之前，父组件很快需要一两件东西，那么他们(和您)很容易做到:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c006" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">只要确保你不会发现自己处于这样的情况:</p><p id="6e37" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你这样做了，考虑将组件部分拆分成单独的组件，这样会更干净，更具可定制性。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="280d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">10.支柱钻井</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="f915" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">将道具传递给多个子组件就是他们所说的<em class="me">代码味道</em>。</h1><p id="94cd" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi translated">如果你不知道什么是道具钻取，这意味着当一个父级将道具向下传递到树中的多个组件级别时。</p><p id="94b5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，问题不在于父母和孩子。他们应该保持他们的实现不变。中间的组件可能会成为React应用程序中的一个问题。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="bfa1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是因为现在中间的组件紧密耦合，暴露了太多他们不需要的信息。最糟糕的是，当父级重新渲染时，中间的组件也会重新渲染。这为链中的所有子组件产生了多米诺效应。</p><p id="fbc7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个好的解决方案是使用<a class="ae lh" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文</a>来代替。或者，<code class="fe ne nf ng nh b">redux</code>代表道具(因此将被连载)。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="f4f4" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">这篇文章到此结束。我希望这篇文章对你有帮助！</h1><p id="7ea5" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi">Generally, it’s recommended that you be explicit in the props you pass down to child components.</p><p id="1139" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi">There are a few good reasons for this:</p><ol class=""><li id="4b79" class="np nq it lk b ll lm lo lp lr nr lv ns lz nt md nu nv nw nx bi">You have an easier debugging experience.</li><li id="67fe" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi">You as a developer <em class="me">know</em> what is being passed to each child.</li><li id="3d21" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi">Other developers will also know and will have an easier time reading the code.</li><li id="82a3" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi">It’s easier to understand what a component will do.</li><li id="2907" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi">Another great thing about passing down props explicity is that when you do this, it’s also documenting your code in a way where everyone understands without needing formal documentation. And that saves time!</li><li id="b011" class="np nq it lk b ll ny lo nz lr oa lv ob lz oc md nu nv nw nx bi">There will be <em class="me">fewer</em> props needed in order to determine if the component should re-render or not.</li></ol><p id="6d45" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi">There can be some pretty neat use cases for spreading all the props. For example, if a parent quickly needed one or two things before passing the props down to child components, it can be easy for them (and you) to do so:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c034" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi">Just make sure you don’t find yourself in a situation like this:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="af6a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi">And if you do, consider splitting the component parts to separate components so that it’s cleaner and more customizable.</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="b678" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi">10. Prop Drilling</h1><p id="ee20" class="pw-post-body-paragraph li lj it lk b ll ni kd ln lo nj kg lq lr nk lt lu lv nl lx ly lz nm mb mc md im bi">Passing down props to multiple child components is what they call a <em class="me">code smell</em>.</p><p id="f917" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi">If you don’t know what prop drilling is, it means when a parent passes down props to multiple levels of components deep down the tree.</p><p id="b1db" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi">Now, the problem there isn’t the parent or the child. They should keep their implementation the same. It’s the components in the middle that might become an issue in your React apps.</p><p id="6ac1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi">That’s because now the components in the middle are tightly coupled and are exposed to too much information that they don’t need. The worst part is that when the parent re-renders, the components in the middle will also re-render. This creates a domino effect for all the child components down the chain.</p><p id="3174" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi">A good solution is to use <a class="ae lh" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">context</a> instead. Or alternatively, <code class="fe ne nf ng nh b">redux</code> for props (which consequently are going to be serialized).</p><p id="ce50" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi">That concludes the end of this post. I hope you found this article helpful!</p></div></div>    
</body>
</html>