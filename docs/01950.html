<html>
<head>
<title>Pure JavaScript Pattern for State Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于状态管理的纯JavaScript模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pure-javascript-pattern-for-state-management-75fedf0916f6?source=collection_archive---------5-----------------------#2019-10-25">https://betterprogramming.pub/pure-javascript-pattern-for-state-management-75fedf0916f6?source=collection_archive---------5-----------------------#2019-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f7a3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当您可以依赖纯JavaScript时，为什么要依赖第三方工具来管理应用程序状态呢？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9c50e4af8f6f0bd95e27c577d5673ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P1CygvJeYIhcTLpx"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@emilep?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">émile Perron</a>拍摄</p></figure><p id="736d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a> <strong class="ky ir"> </strong>不错，类似的开发者管理app状态的工具也都不错。</p><p id="96e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但我在这里的问题是:“为什么一个JavaScript开发者要依赖第三方工具来管理应用状态，而不是依赖纯JavaScript代码，自己写的？”我认为，这样做的好处微不足道，可以讨论。</p><p id="0c32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，本文旨在理解这种工具应该提供的基本特性，以及它在纯JavaScript中的实现。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7aae" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">抽象讨论</h1><p id="e66b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们直接跳到这种功能的抽象层次。众所周知，这种工具应该提供三个核心特性:</p><ol class=""><li id="68f0" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">远程和本地数据的集中本地存储。</li><li id="a1cf" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">在任何时候，任何视图组件都应该能够读取/写入这些数据。</li><li id="07f0" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">当有数据更新时，这个集中的本地存储应该能够向任何视图组件广播<strong class="ky ir"> </strong>。</li></ol><p id="65d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">说白了，这就是<em class="nk"> MVC模式</em>中控制器的功能。所以，这个工具应该被看作是客户端的视图<strong class="ky ir"> </strong>和服务器的模型<strong class="ky ir"> </strong>之间通信的控制器。</p><p id="7308" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">附言:我的理解是<a class="ae kv" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a> <strong class="ky ir"> </strong>最好地实现了这些要求！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="2015" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">第一项要求的实现</h1><p id="9f91" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">好吧，撇开GraphQL不谈，让我们用纯JavaScript一个接一个地实现所有功能。</p><p id="0ea3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，有了ES6<strong class="ky ir"/><strong class="ky ir"/>带给我们的新选项，比如类和静态方法，特性一将这样实现:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="575d" class="nq ma iq nm b gy nr ns l nt nu">// Controller.js</span><span id="aa64" class="nq ma iq nm b gy nv ns l nt nu">let _instance = null;</span><span id="3377" class="nq ma iq nm b gy nv ns l nt nu">export default class Controller {</span><span id="2355" class="nq ma iq nm b gy nv ns l nt nu">  static get instance() {<br/>    return _instance ? _instance : _instance = <strong class="nm ir">new</strong> <em class="nk">Controller</em>();<br/>  }</span><span id="d752" class="nq ma iq nm b gy nv ns l nt nu">  constructor() {<br/>    <em class="nk">this</em>._core = {};<br/>    window.Controller = <em class="nk">this</em>; //for debugging purposes<br/>  }</span><span id="86d3" class="nq ma iq nm b gy nv ns l nt nu">  get core() {<br/>    return <em class="nk">this</em>._core;<br/>  }</span><span id="0d29" class="nq ma iq nm b gy nv ns l nt nu">  editCore(<em class="nk">prop</em>, <em class="nk">value</em>) {<br/>    <em class="nk">this</em>._core[prop] = value;<br/>  }</span><span id="05ac" class="nq ma iq nm b gy nv ns l nt nu">  foo(<em class="nk">prop</em>, <em class="nk">value</em>) {<br/>    let todo = 1 + value; //some logic here<br/>    <em class="nk">this</em>.editCore(prop, todo);<br/>  }<br/>}</span></pre><p id="ffe2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意静态方法在类中的位置。它不是意外地写在构造函数之上的。写在它上面也是为了反映<strong class="ky ir"> </strong>在这样一个类中<strong class="ky ir"> </strong>的执行顺序。</p><p id="bf87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">众所周知，首先执行静态方法，然后是构造函数，然后是实例的方法。这是因为静态方法是在类上执行的，而不是在实例上，因此是这个顺序。</p><p id="ed89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，这段代码负责将所有数据存储在对象<code class="fe nw nx ny nm b">this._core</code> <strong class="ky ir"> <em class="nk"> </em> </strong>中，并分别通过<code class="fe nw nx ny nm b">get core()</code>和<code class="fe nw nx ny nm b">editCore(prop, value)</code>对其进行读写。</p><p id="d41a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个类还包含一个可能的函数的虚拟实现来处理内核。它从可以进行HTTP获取的函数到简单的算术函数都有。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1eee" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">第二项要求的实施</h1><p id="e484" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在谈谈第二个代码特性。我们如何从任何视图组件读取或写入这样一个集中式本地存储？</p><p id="b14b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以这样做:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="e892" class="nq ma iq nm b gy nr ns l nt nu">// DummyComponent.js</span><span id="a266" class="nq ma iq nm b gy nv ns l nt nu">import Controller from./Controller';</span><span id="86da" class="nq ma iq nm b gy nv ns l nt nu">Controller.instance.editCore('Message', 'Hello World!');</span><span id="05e8" class="nq ma iq nm b gy nv ns l nt nu">console.log(Controller.instance.core);<br/>//logs { Message: "Hello World! }</span></pre><p id="52c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样做的先决条件是<code class="fe nw nx ny nm b">Controller.js</code>和<code class="fe nw nx ny nm b">DummyViewComponent.js</code>在同一个文件夹中，但是这样的东西是可编辑的，在这种情况下只需要修改导入的路径。</p><p id="76db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在用core写<strong class="ky ir"> </strong>很直白。我们只在开始时实例化这个类一次，然后在应用程序的剩余生命周期中处理它。</p><p id="3b10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可以通过<code class="fe nw nx ny nm b">Controller.instance.editCore(‘Message’, ‘Hello World!’)</code> <strong class="ky ir"> <em class="nk"> </em> </strong>的首次写入来实现，或者简单地通过在应用的第一次挂载时执行<code class="fe nw nx ny nm b">Controller.instance;</code> <strong class="ky ir"> <em class="nk"> </em> </strong>来实现。</p><p id="b213" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，核心对象的每次更新都将基于这个实例。</p><p id="66fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要读取核心对象，我们只需使用<code class="fe nw nx ny nm b">get core()</code> <strong class="ky ir"> <em class="nk"> </em> </strong> getter，在<code class="fe nw nx ny nm b">Controller.js</code>中实现即可。因此，在任何给定的时间，在任何视图组件中，我们可以执行<code class="fe nw nx ny nm b">Controller.instance.core</code>，它将返回整个核心对象。</p><p id="b5d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样做的好处是，如果您确定要寻找什么，您还可以访问核心的特定子对象。</p><p id="72bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果您正在寻找一个消息子对象，您可以简单地通过<code class="fe nw nx ny nm b">Controller.instance.core.Message</code>请求它。<strong class="ky ir"> <em class="nk"> </em> </strong>这样，你不会得到整个核心对象，而只是必要的数据。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b3ad" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">第三项要求的实施</h1><p id="2b67" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在，第三个需求应该使我们的控制器能够在每次核心对象发生变化时将核心对象广播到订阅的视图组件。</p><p id="f99f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用公开<code class="fe nw nx ny nm b">subscribe()</code>和<code class="fe nw nx ny nm b">unsubscribe()</code>函数的想法来解决这个需求，这些函数将简单地推送或移除核心中需要这种功能的视图组件。</p><p id="39ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，让我们实现一个<code class="fe nw nx ny nm b">emit()</code>函数，它将在所有订阅的视图组件中执行<code class="fe nw nx ny nm b">next(core)</code>函数，然后每个组件应该负责后续的操作。因此，<code class="fe nw nx ny nm b">next(core)</code>函数将接收更新后的内核作为参数。</p><p id="bcb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实现这样的功能，我们应该以这种方式更新<code class="fe nw nx ny nm b">Controller.js</code>文件:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="6076" class="nq ma iq nm b gy nr ns l nt nu">// Controller.js<br/>import ReactDOM from 'react-dom';</span><span id="eb8d" class="nq ma iq nm b gy nv ns l nt nu">let _instance = null;</span><span id="159f" class="nq ma iq nm b gy nv ns l nt nu">export default class Controller {</span><span id="57ec" class="nq ma iq nm b gy nv ns l nt nu">  .<br/>  .<br/>  .</span><span id="661e" class="nq ma iq nm b gy nv ns l nt nu">  constructor() {<br/>    <em class="nk">this</em>._core = {<br/>      subscribers: [],<br/>    };<br/>    ...<br/>  }</span><span id="0ddf" class="nq ma iq nm b gy nv ns l nt nu">  editCore(<em class="nk">prop</em>, <em class="nk">value</em>) {<br/>    <em class="nk">...</em><br/>    <em class="nk">this</em>._core.subscribers &amp;&amp; <em class="nk">this</em>.emit();<br/>  }</span><span id="9914" class="nq ma iq nm b gy nv ns l nt nu">  emit() {<br/>    <em class="nk">this</em>._core.subscribers.forEach(<em class="nk">subscriber</em> =&gt; <br/>      subscriber.next(<em class="nk">this</em>._core)<br/>    );<br/>  }</span><span id="d5e6" class="nq ma iq nm b gy nv ns l nt nu">  emit() {<br/>    <em class="nk">this</em>._core.subscribers.forEach(<em class="nk">component</em> =&gt; {<br/>      typeof component.next === 'function' &amp;&amp; <br/>        component.next(<em class="nk">this</em>._core);<br/>    });<br/>  }</span><span id="6423" class="nq ma iq nm b gy nv ns l nt nu">  subscribe(<em class="nk">component</em>) {<br/>    !<em class="nk">this</em>._core.subscribers.includes(component) &amp;&amp; <br/>      <em class="nk">this</em>._core.subscribers.push(component);<br/>  }</span><span id="39ad" class="nq ma iq nm b gy nv ns l nt nu">  unsubscribe(<em class="nk">component</em>) {<br/>    <em class="nk">this</em>._core.subscribers.includes(component) &amp;&amp; <br/><em class="nk">this</em>._core.subscribers.splice(<em class="nk">this</em>._core.subscribers.indexOf(component), 1);<br/>  }<br/>}</span></pre><p id="af14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重要的是，核心中的所有更改都要通过提供的<code class="fe nw nx ny nm b">editCore(prop, value)</code> <strong class="ky ir"> <em class="nk"> </em> </strong>函数，因为每次组件被订阅和核心中的更改都会调用<code class="fe nw nx ny nm b">emit()</code>函数。</p><p id="213c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在视图组件中订阅、取消订阅和接收更新的核心就像下面这样简单:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="9b42" class="nq ma iq nm b gy nr ns l nt nu">// VeryFarComponent.js</span><span id="2e87" class="nq ma iq nm b gy nv ns l nt nu">import Controller from./Controller';</span><span id="260a" class="nq ma iq nm b gy nv ns l nt nu">class VeryFarComponent {</span><span id="cd83" class="nq ma iq nm b gy nv ns l nt nu">  next(<em class="nk">core</em>) {<br/>    <em class="nk">console</em>.log('Updated core emitted to VeryFarComponent: ', core);<br/>  }</span><span id="2f43" class="nq ma iq nm b gy nv ns l nt nu">  subscribe() {<br/>    Controller.instance.subscribe(<em class="nk">this</em>);<br/>  }</span><span id="3e53" class="nq ma iq nm b gy nv ns l nt nu">  unsubscribe() {<br/>    Controller.instance.unsubscribe(<em class="nk">this</em>);<br/>  }<br/>}</span></pre><p id="5d1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们想要接收的每个视图组件中实现<code class="fe nw nx ny nm b">next(core)</code>函数是很重要的，否则，仅仅将它订阅到核心不会有任何功能上的影响。</p><p id="9ba9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">建议总是在卸载或其他生命周期取消订阅组件，因为这样我们就剩下不必要的组件对象了。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ea07" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="d921" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这种方法有很多优点，我认为这是实现这种功能的最佳模式，因为:</p><ol class=""><li id="986b" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">一个目标来统治他们！</li><li id="78c2" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">没有第三方复杂或半复杂的库<strong class="ky ir"> </strong>来管理应用状态。</li><li id="9c46" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">非常直观的<strong class="ky ir"> </strong>和简单的学习曲线<strong class="ky ir"> </strong>相比其他库的厚样板。</li><li id="6bfd" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">在任何使用JavaScript的框架中都能工作<strong class="ky ir"> </strong>。</li><li id="8fbf" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">28 <strong class="ky ir"> </strong> JavaScript行<strong class="ky ir"> </strong>交付一个全功能的状态管理工具。</li><li id="bda5" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">订阅上没有<strong class="ky ir"> </strong>可能的内存泄漏，因为在<code class="fe nw nx ny nm b">emit()</code>中，我们可以对未安装的组件执行自动检查。在这种情况下，<code class="fe nw nx ny nm b">emit()</code>将执行另一个分支，该分支将简单地从<code class="fe nw nx ny nm b">core.subscribers</code>对象中删除相应的组件。</li></ol><p id="f809" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">*所有这些的一个<a class="ae kv" href="http://controller.surge.sh/" rel="noopener ugc nofollow" target="_blank"> React.js实现可以在这里找到</a>和它的<a class="ae kv" href="https://github.com/agonqorolli/controller" rel="noopener ugc nofollow" target="_blank">对应的代码库在这里</a>。</p><p id="bb44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我期待着参与下面的建设性讨论。</p></div></div>    
</body>
</html>