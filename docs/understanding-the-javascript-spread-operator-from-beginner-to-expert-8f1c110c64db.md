# 理解 JavaScript Spread 操作符——从初学者到专家

> 原文：<https://betterprogramming.pub/understanding-the-javascript-spread-operator-from-beginner-to-expert-8f1c110c64db>

![](img/ec78ae476050661b3896a9cca3ccb25a.png)

# 介绍

扩展运算符`…`、**、**最早是在 ES6 中引入的。它很快成为最受欢迎的功能之一。以至于尽管它只在数组上工作，有人提议将其功能扩展到对象。这个特性最终在 ES9 中引入。

本教程分为两个部分，旨在向您展示为什么应该使用 spread 运算符，它是如何工作的，并从最基本到最高级深入探究它的用法。

以下是本教程内容的简短总结:

## 第一部分

1.  为什么应该使用扩展运算符
2.  克隆数组/对象
3.  将类似数组的结构转换为数组
4.  作为参数的扩展运算符
5.  向数组/对象添加元素
6.  合并数组/对象

## 第二部分

1.  扩展运算符的高级用途

# 为什么应该使用扩展运算符

读完前面的列表后，您可能会有这样的想法:“但是 JavaScript 具有完成所有这些事情的功能。我为什么要使用 spread 运算符？”请允许我向你介绍不变性。

> 摘自[牛津词典](https://www.lexico.com/en):不变性——不随时间变化或者不能改变。

在软件开发中，我们使用术语“不可变”来指代其状态不能随时间改变的值。其实我们平时用的大部分值(原语值，比如字符串，整数等。)都是不可变的。

然而，当涉及数组和对象时，JavaScript 有一种奇特的行为；事实上，它们是可变的。这可能会成为一个大问题。这里有一个例子，说明为什么:

正如您在前面的代码片段中看到的，我们有一个杰尼龟。我们的杰尼龟有 100 的 HP，因为我们刚刚参观了神奇宝贝中心。

因为我们想要另一个杰尼龟，我们声明了变量`anotherSquirtle`，指定我们最初的杰尼龟作为它的值。经过一场艰苦的战斗，`anotherSquirtle`被打败了。我们因此访问`anotherSquirtle`的 HP 并将其更改为 0。下一步是检查我们原来的杰尼龟。我们`console.log`和…

等等，什么？我们原来的杰尼龟的 HP 降到了 0。怎么会这样呢？我们可怜的杰尼龟怎么了？JavaScript 发生了突变。让我解释一下这是怎么回事。

当我们创建了`anotherSquirtle`变量并将我们最初的杰尼龟赋值给它时，我们真正做的是将一个引用赋值给最初的杰尼龟对象的内存位置。这是因为 JavaScript 数组和对象是引用数据类型。与原始数据类型不同，它们指向存储实际对象/数组的内存地址。

为了更容易理解，您可以将引用数据类型想象成指向全局变量的指针。通过改变引用数据类型的值，我们真正做的是改变全局变量的值。

这意味着当我们将`anotherSquirtle`的的 HP 值更改为 0 时，我们实际上是将内存中存储的杰尼龟对象的 HP 值更改为 0。这就是为什么*`mySquirtle`*的 HP 值是 0——因为`mySquirtle`保存了一个对存储在内存中的对象的引用，我们通过`anotherSquirtle`变量改变了它。谢谢 JavaScript。**

## **我们如何解决这个问题？**

**为了避免变量的意外突变，每当我们想要复制一个数组/对象时，我们必须做的就是创建一个数组/对象的新实例。我们如何实现这一点？**

**使用 spread 运算符。**

# **Spread 运算符是如何工作的？**

> **MDN docs: Spread 语法允许在需要 0 个或多个参数(对于函数调用)或元素(对于数组文本)的地方扩展 iterable，例如数组表达式或字符串，或者在需要 0 个或多个键值对(对于对象文本)的地方扩展对象表达式。**

**简而言之，spread 操作符`…`将包含在 iterable 中的项目展开(iterable*iterable*是任何可以循环的东西，比如字符串、数组、集合等等)。)在一个接收器里面。(接收器是接收传播值的东西。)下面是几个简单的数组示例，可以让您更好地理解它:**

**数组上使用的扩展运算符的三个示例**

**正如你所看到的，当我们在一个数组上使用 spread 操作符时，我们获得了数组中包含的每一项。在所有前面的例子中，接收器是一个函数，即`console.log`函数。很简单，对吧？**

# **克隆数组和对象**

**现在我们知道了 spread 操作符是如何工作的，我们可以利用它来不变地复制数组和对象。怎么会？通过展开内容，然后使用数组或对象文字(分别为`[]`和`{}`)来生成数组/对象的新实例。**

**让我们以前面的杰尼龟为例，通过不可变地克隆`mySquirtle` 变量来修复它:**

**使用扩展操作符不变地复制对象**

**通过用 spread 操作符析构`mySquirtle`变量的内容并使用对象文字，我们创建了杰尼龟对象的一个新实例。这样，我们就防止了意外的变量突变。**

**要复制数组，我们使用完全相同的语法:**

**用 spread 运算符不变地复制数组**

****注意:**请记住，spread 操作符只执行浅层复制。这意味着，如果您在数组/对象中存储了引用数据类型，当您使用 spread 操作符进行复制时，嵌套的数组/对象将包含对原始数组/对象的引用，因此是可变的。**

# **将类似数组的对象转换为数组**

**类似数组的对象与数组非常相似。它们通常有编号元素和长度属性。然而，它们有一个重要的区别:类似数组的对象没有任何数组函数。**

**类似数组的对象包括大多数 DOM 方法返回的 HTML 节点列表、每个 JS 函数中自动生成的参数变量，以及其他一些对象。**

**使用与克隆数组时相同的语法，我们可以使用 spread 操作符将类似数组的结构转换为数组，作为使用`Array.from`的替代方法。这里有一个例子，将一个`nodeList`转换成一个数组:**

**将节点列表转换为数组**

**使用这种技术，我们可以将任何类似数组的结构转换成数组，从而可以访问所有的数组函数。**

# **作为参数的扩展运算符**

**一些函数接受可变数量的参数。这类函数的一个很好的例子是`Math`集合中的函数。对于我们的例子，让我们选择`Math.max()`函数，它接受 *n* 个数字参数，并返回最大的一个。假设我们有一个数组想要传递给`Math.max()`函数。我们怎么做呢？**

**我们可以这样做(不要因为下面的代码而恨我):**

**但是，当然，这样做无异于自杀。如果我们有 20 个值呢？还是 1000？我们真的要通过索引来访问每个值吗？答案是否定的。正如我们已经知道的，spread 操作符接受一个数组并提取每个单独的值。这正是我们要找的。因此，我们可以这样做:**

**让接线员去救援。**

# **添加新元素**

## **向数组中添加项目**

**要向数组中添加新元素，我们首先扩展数组的内容，并使用数组文字`[]` 创建数组的新实例，其中包含原始数组的内容以及我们要添加的值:**

**使用 spread 运算符向数组中添加项**

**正如你所看到的，我们可以添加尽可能多的新项目。**

## **向对象添加属性**

**通过使用与数组相同的语法，我们可以在克隆对象时轻松地添加新属性。稍微转换一下，这里有一个不同的语法来为对象添加属性(它也可以用于数组):**

**正如你所看到的，我们可以直接在对象内部声明和初始化新的变量，而不是在外部。**

# **合并数组/对象**

## **数组**

**我们可以通过展开两个数组并使用数组文字来合并它们，就像前面的例子一样。然而，我们不是简单地添加一个新元素，而是要添加另一个(扩展)数组:**

**用 spread 运算符合并两个数组**

**如果我们有一个对象数组，它也是有效的:**

**用 spread 运算符合并两个对象数组**

## **目标**

**我们可以使用与之前相同的语法将两个(或更多)对象合并成一个对象(您现在可能已经注意到，spread 运算符的用法非常相似，既用于数组也用于对象):**

**用扩展操作符合并两个对象**

# **结论**

**在本教程的第一部分中，我们已经了解了为什么我们应该使用 spread 运算符(不变性！)，它是如何工作的，以及所述运算符的几种基本用法。在教程的第二部分，我们将通过一些高级技术和用例来加深我们对这个操作符的了解。以下是教程第二部分的链接:**

**[了解 JavaScript 扩展运算符—高级用途](https://medium.com/better-programming/understanding-the-javascript-spread-operator-from-beginner-to-expert-part-2-1ec1808d015e)**

**非常感谢您的阅读。**