<html>
<head>
<title>Spring Boot — Continuous Deployment on Kubernetes With ArgoCD and GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot——通过ArgoCD和GitHub行动在Kubernetes上持续部署</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/spring-boot-continuous-deployment-on-kubernetes-with-argocd-and-github-actions-made-easy-cb228bb5f808?source=collection_archive---------5-----------------------#2022-06-16">https://betterprogramming.pub/spring-boot-continuous-deployment-on-kubernetes-with-argocd-and-github-actions-made-easy-cb228bb5f808?source=collection_archive---------5-----------------------#2022-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e0b0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">部署变得简单</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1aa2294d0b5012026dd4cee6ce26c6fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctNo3JE0BepBwambYe2mAA.png"/></div></div></figure><p id="771b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如今<a class="ae ln" href="https://en.wikipedia.org/wiki/DevOps" rel="noopener ugc nofollow" target="_blank"> DevOps </a>、<a class="ae ln" href="https://www.gitops.tech/" rel="noopener ugc nofollow" target="_blank"> GitOps </a>、<a class="ae ln" href="https://en.wikipedia.org/wiki/Continuous_deployment" rel="noopener ugc nofollow" target="_blank">连续部署</a>都是热门话题。有时它看起来像魔术，但实际上它的大部分真的很简单，每个人都应该采用它。自动化管道给我们带来了安全并节省了大量时间。本文中使用的所有工具都是免费的。</p><p id="696d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我们将使用所有<code class="fe lo lp lq lr b">master</code> <em class="ls"> </em>推送事件触发的<a class="ae ln" href="https://docs.github.com/en/actions" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>创建一个非常基本的管道。它将执行项目测试、版本控制和构建。通常我们会在<em class="ls"> pull request open </em>事件上运行测试，这样就不会有未测试的代码被合并到master中，但是为了简单起见，我将在本文中省略它。</p><p id="0980" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将在我们的<a class="ae ln" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>集群中设置<a class="ae ln" href="https://argo-cd.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> ArgoCD </a>(我将使用<a class="ae ln" href="https://www.docker.com/products/docker-desktop/" rel="noopener ugc nofollow" target="_blank"> Docker Desktop </a>提供的集群)。ArgoCD将监控我们的部署<a class="ae ln" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>库，并使用<a class="ae ln" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> DockerHub </a>作为映像源，将每个更改部署到集群中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/3a0930827240b4746bc839ef96b69eaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vU9UumPMyUh4VkFbEsGpOA.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">输送管道</p></figure><p id="42bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们必须在GitHub上创建两个存储库。名字由你决定。</p><p id="352b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将分别称它们为<code class="fe lo lp lq lr b">continuous-delivery-application</code> <em class="ls"> </em>和<code class="fe lo lp lq lr b">continuous-delivery-manifests</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ly"><img src="../Images/04dde49a98aa1611d347b2537b569410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MWSC9e1ytAGUeurxt_oIzg.png"/></div></div></figure><p id="8767" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一个是带有REST端点和单元测试的<a class="ae ln" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>项目。可以通过<a class="ae ln" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank">弹簧初始化</a>轻松生成。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lz"><img src="../Images/b31f12264ea28a37454194d0a2576b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9YSZw6e5IlYdVfNHpWmGg.png"/></div></div></figure><p id="06b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">解压缩项目后，在您喜欢的IDE(例如IntelliJ)中打开它。</p><p id="7dc3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们创建一个返回用户对象列表的REST端点。我们将使用<a class="ae ln" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>协程作为反应端点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="fac5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">路由器发出两个用户，并将他们序列化为JSON格式。您可以通过调用以下URL来测试端点:</p><pre class="kg kh ki kj gt mc lr md me aw mf bi"><span id="b42c" class="mg mh iq lr b gy mi mj l mk ml"><a class="ae ln" href="http://localhost:8080/api/v1/user" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/v1/user</a></span></pre><p id="6eb7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后为服务添加一个简单的单元测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="92ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们可以将第一个CI步骤添加到项目中。让我们在项目的根文件夹中创建一个新目录。</p><p id="d4ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">名称必须是<code class="fe lo lp lq lr b">.github</code>，在这个文件夹中，我们必须创建另一个名为<code class="fe lo lp lq lr b">workflows</code> <em class="ls">的目录。</em></p><p id="dbca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是GitHub定义的动作的强制性命名约定。</p><p id="d010" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe lo lp lq lr b">workflows</code>文件夹中，我们创建一个名为<code class="fe lo lp lq lr b">push-to-master.yml</code>的新文件。这是我们的部署描述清单。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="afd5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">主分支上的每一次推送都将触发工作流。该作业使单元测试得以运行。此时不需要写权限，但在下一个作业中需要。</p><p id="55fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个任务在Ubuntu上运行，第一步是从资源库中签出项目。</p><p id="cacf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之后，安装JDK 17，最后调用<a class="ae ln" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> Gradle </a>的<code class="fe lo lp lq lr b">test</code> <em class="ls"> </em>命令来执行我们之前定义的单元测试。</p><p id="0cf5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在推送项目之前，使用以下命令使<code class="fe lo lp lq lr b">gradlew</code> <em class="ls"> </em>可执行。</p><pre class="kg kh ki kj gt mc lr md me aw mf bi"><span id="87f7" class="mg mh iq lr b gy mi mj l mk ml">git update-index --chmod=+x gradlew</span></pre><p id="7466" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们要设置使用<a class="ae ln" href="https://www.conventionalcommits.org/en/v1.0.0/" rel="noopener ugc nofollow" target="_blank">常规提交</a>的<a class="ae ln" href="https://semantic-release.gitbook.io/semantic-release/" rel="noopener ugc nofollow" target="_blank">语义发布</a>，所以让我们以提交消息后的<em class="ls"> feat: </em>开始所有提交消息。稍后我会解释。</p><p id="502f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">项目被推入GitHub后，我们可以在存储库的Actions页面上检查管道。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mm"><img src="../Images/bda83536480c4242489f4f3a60a98251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8KNLYDJWiZ4TDIvjTbjcg.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">成功的单元测试</p></figure><p id="20fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来我们将添加语义发布插件。这将自动更新项目版本。</p><p id="3497" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">SemRel使用<a class="ae ln" href="https://www.conventionalcommits.org/en/v1.0.0/#summary" rel="noopener ugc nofollow" target="_blank">常规提交标签</a>来决定下一个版本。我们使用<code class="fe lo lp lq lr b">feat</code>更新次要版本，使用<code class="fe lo lp lq lr b">fix</code>更新路径。</p><p id="f074" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还有很多其他的标签，请查看文档。</p><p id="3ce3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们必须在根文件夹中创建<code class="fe lo lp lq lr b">gradle.properties</code>文件并添加下面一行:</p><pre class="kg kh ki kj gt mc lr md me aw mf bi"><span id="7950" class="mg mh iq lr b gy mi mj l mk ml">version=0.0.1</span></pre><p id="3c74" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并将<code class="fe lo lp lq lr b">build.gradle.kts</code>文件中的<code class="fe lo lp lq lr b">version</code> <em class="ls"> </em>更新为:</p><pre class="kg kh ki kj gt mc lr md me aw mf bi"><span id="56ad" class="mg mh iq lr b gy mi mj l mk ml"><em class="ls">version </em>= <em class="ls">project</em>.findProperty("version")!!</span></pre><p id="8644" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">SemRel是一个NodeJS插件，所以我们必须创建另一个名为<code class="fe lo lp lq lr b">package.json</code>的文件，并在其中添加必要的语义发布插件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="d299" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">插件将更新<code class="fe lo lp lq lr b">gradle.properties</code> <em class="ls"> </em>文件中的<em class="ls">版本</em>，并连同自动生成的changelog一起提交回<em class="ls">主</em>。</p><p id="c485" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在将新任务添加到工作流程之前，让我们运行<em class="ls"> </em> <code class="fe lo lp lq lr b">npm install</code>命令。</p><p id="a227" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将生成<code class="fe lo lp lq lr b">package-lock.json</code>文件。</p><p id="7df8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用新任务扩展<code class="fe lo lp lq lr b">push-to-merge.yaml</code>清单。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="a1a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该作业将检出主分支，并运行语义发布步骤。git插件需要访问我们的存储库。</p><p id="2345" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">动作会自动将我们的令牌注入到工作流中，这样我们就可以使用<code class="fe lo lp lq lr b">secrets.GITHUB_TOKEN</code>模板变量获取令牌并将其添加为环境变量。</p><p id="bf1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ls">需求</em>结构确保<code class="fe lo lp lq lr b">run_unit_test</code> <em class="ls"> </em>作业在该作业开始之前运行。没有它，这两个将同时运行。</p><p id="64c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">推送修改后的文件并让工作流运行(不要忘记为提交消息添加fix/feat和冒号前缀)。当流水线完成时，我们可以拉出主分支并检查<code class="fe lo lp lq lr b">gradle.properties</code>文件和<code class="fe lo lp lq lr b">changelog.md</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/94e320f562cc0834875a2c473a9434c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DQj1jwow_jtoukUe7y0Zig.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">现在我们有两个任务在运行</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mo"><img src="../Images/fe733b3c9ba61a2dbd98a4fe30fc583b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*azA09j3Leo5bIabdPnsdPQ.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">自动生成变更日志</p></figure><p id="c1f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用Jib从应用程序中构建Docker容器。<br/>将插件和配置放入<code class="fe lo lp lq lr b">build.gradle.kts</code>文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="9cf4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用亚马逊Coretto Java 17的基础映像。对于图像名称前缀，请使用您自己的帐户名称。</p><p id="afa4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了推动它，我们必须提供DockerHub凭证。我们将使用GitHub Action Secrets将它们作为环境变量注入。图像标签从项目版本中获取其值。这将由语义发布插件计算。</p><p id="9438" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该容器暴露8080端口用于流量，9000端口用于管理端口用于活跃度和就绪性探测。<code class="fe lo lp lq lr b">mainClass</code> <em class="ls"> </em>名必须是包含主函数的类的完全限定名，对于Kotlin，我们必须在它的末尾加上<code class="fe lo lp lq lr b">Kt</code>，因为Kotlin将在这个名字上生成主类。<code class="fe lo lp lq lr b">jvmFlags</code>帮助我们更好地使用容器的内存。</p><p id="1255" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们必须修改<code class="fe lo lp lq lr b">application.yml</code>或<em class="ls"> </em> <code class="fe lo lp lq lr b">application.properties</code>文件，以便在管理端口上启用正常关机和健康探测。这在Kubernetes上是必要的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="ebaf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以将发布作业放入工作流文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">语义发布步骤</p></figure><p id="4d02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，这与测试工作相似。<code class="fe lo lp lq lr b">Jib</code>将创建并推动图像到DockerHub，但正如我所说，我们必须提供我们的凭据。您可以在“设置”选项卡上进行设置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/a921a478a61eac2322aa64ab94dd1cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-0VoN8qd1BRU8hk0W-V69Q.png"/></div></div></figure><p id="47be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从左侧菜单中选择机密/操作，并使用<em class="ls">新存储库机密</em>按钮。</p><p id="51f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完成后，我们可以推动修改。当管道完成时，正确版本的映像应该在DockerHub上。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/4aec72b1b60da4e811b953490aef63f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3TdHe27aqX45uAmN0UZw8A.png"/></div></div></figure><p id="deb5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二个项目包含Kubernetes部署的<a class="ae ln" href="https://kustomize.io/" rel="noopener ugc nofollow" target="_blank"> Kustomize </a>清单。Kustomize是Kubernetes的一个本地配置管理应用程序。其用途类似于头盔，但模板是自由的，默认情况下<code class="fe lo lp lq lr b"><a class="ae ln" href="https://kubernetes.io/docs/tasks/tools/" rel="noopener ugc nofollow" target="_blank">kubectl</a></code> <a class="ae ln" href="https://kubernetes.io/docs/tasks/tools/" rel="noopener ugc nofollow" target="_blank"> </a>包含它。它可以将一堆资源分组并一起部署。</p><p id="cfd5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Kustomize定义了基本模板和环境补丁。让我们在这个项目的根目录下创建两个文件夹。第一个叫做<em class="ls">底座</em>第二个叫做<em class="ls">叠加</em>。</p><p id="a2e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将为应用程序创建一个简单的部署，并为可访问性和负载平衡创建一个集群ip。</p><p id="a5bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将<code class="fe lo lp lq lr b">deployment.yml</code>添加到基本目录中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">部署</p></figure><p id="a83b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将从图像中创建一个<a class="ae ln" href="https://kubernetes.io/docs/concepts/workloads/pods/" rel="noopener ugc nofollow" target="_blank"> Pod </a>。我们还设置了健康探测器和资源限制。</p><p id="143e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用以下内容创建<code class="fe lo lp lq lr b">node-port.yaml</code>,这样集群中的其他应用程序将可以通过<a class="ae ln" href="http://cd-example-url:8080" rel="noopener ugc nofollow" target="_blank">上的其他Pods访问这个地址</a>,并且它还将它绑定到30001端口上的localhost。在实际应用中，您应该创建集群IP和入口控制器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">节点端口</p></figure><p id="052c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Kustomize使用<code class="fe lo lp lq lr b">kustomization.yaml</code>进行操作。我们添加资源和基础映像。我们将从我们的管道中修改<code class="fe lo lp lq lr b">newTag</code> <em class="ls"> </em>参数<em class="ls"> </em>，这样我们就可以在每次主推送时更新镜像版本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">base/kustomization.yaml</p></figure><p id="8124" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来在<code class="fe lo lp lq lr b">overlays</code>文件夹下创建一个名为<code class="fe lo lp lq lr b">production</code>的新目录，并在其中添加另一个<code class="fe lo lp lq lr b">kustomization.yaml</code> <em class="ls"> </em>文件。这将是我们的环境。我们现在不会使用任何补丁，但我们会为每个清单添加一个通用标签，并在该文件中链接基础库定制。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">叠加/生产/kustomization.yaml</p></figure><p id="6a15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以将它放入第二个存储库。</p><p id="6621" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在存储库被推送后，返回到管道文件并定义最后一个作业。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="404a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，它检查应用程序项目的<a class="ae ln" href="http://cd-example-url:8080" rel="noopener ugc nofollow" target="_blank">主</a>分支，并从<em class="ls"> </em> <code class="fe lo lp lq lr b">gradle.properties</code> <em class="ls"> </em>文件中获取实际版本。我们将其设置为环境变量。GitHub Action将这些保存在<em class="ls"> </em> <code class="fe lo lp lq lr b">$GITHUB_ENV</code>变量中。</p><p id="7d02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在接下来的步骤中，它签出第二个项目。默认情况下，管道需要我们的个人访问令牌。操作只对当前存储库有权限。在下一部分，我将向您展示如何注册。</p><p id="274c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在最后一步中，我们使用kustomize命令进行映像版本更新，然后提交并将其推回存储库。</p><p id="ca45" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在push (feat/fix)和管道完成后，必须在两个项目中设置项目版本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/58cb653d43badf7224ce7f4b0abeb8fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hbFj9FE-FTsa0VLgL5FNg.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">所有步骤都完成了</p></figure><p id="60c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以在概要文件设置(不是项目设置)下生成PAT。从菜单中选择开发人员设置，然后单击个人访问令牌。您可以使用按钮生成新令牌。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/77e02150a51d3bc97f1d7763f61bf40d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zgC_ZJYZhHCElzY4vM2jNA.png"/></div></div></figure><p id="ffe9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们需要从管道推送到这个存储库，所以选择repo复选框并添加一个注释。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/fb3d4579ec43b4ca4b3f1a298ff0cc06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uBCQV30v18v1GpFgI2tG3g.png"/></div></div></figure><p id="1883" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">点击页面底部的生成按钮。<br/>复制令牌并保存在某个地方，因为您无法再次检索它。然后创建一个<code class="fe lo lp lq lr b">new project secret</code>，就像我们在使用这个值之前所做的那样，并且名称必须与我们在流水线步骤(PAT)中使用的名称相同。</p><h2 id="4fcb" class="mg mh iq bd mu mv mw dn mx my mz dp na la nb nc nd le ne nf ng li nh ni nj nk bi translated"><strong class="ak">设置ArgoCD </strong></h2><p id="253d" class="pw-post-body-paragraph kr ks iq kt b ku nl jr kw kx nm ju kz la nn lc ld le no lg lh li np lk ll lm ij bi translated">我假设您已经安装了k8s集群(启用Kubernetes的Docker桌面是实现这一点的最简单方法)</p><p id="e550" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了安装ArgoCD，让我们运行以下命令。第一个创建一个新的命名空间，第二个部署Argo。</p><pre class="kg kh ki kj gt mc lr md me aw mf bi"><span id="d0b6" class="mg mh iq lr b gy mi mj l mk ml">kubectl create namespace argocd</span><span id="84c0" class="mg mh iq lr b gy nq mj l mk ml">kubectl apply -n argocd -f <a class="ae ln" href="https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml</a></span></pre><p id="2060" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我现在不打算创建入口控制器，所以只需使用以下命令将Argo UI从集群转发到您的本地计算机。</p><pre class="kg kh ki kj gt mc lr md me aw mf bi"><span id="8ab5" class="mg mh iq lr b gy mi mj l mk ml">kubectl port-forward svc/argocd-server -n argocd 8011:443</span></pre><p id="c063" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">去这个<a class="ae ln" href="https://localhost:8011/" rel="noopener ugc nofollow" target="_blank">网址</a>并登录。默认用户名是<em class="ls"> admin </em>。<br/>在终端中使用以下命令检索默认密码:</p><pre class="kg kh ki kj gt mc lr md me aw mf bi"><span id="2f34" class="mg mh iq lr b gy mi mj l mk ml">kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d</span></pre><p id="f361" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在创建应用程序之前，我们必须将我们的存储库添加到Argo。让我们点击设置(cog)按钮并选择<code class="fe lo lp lq lr b">repository</code> <em class="ls"> </em>菜单项。<br/>我将选择<code class="fe lo lp lq lr b">connect repo using ssh</code>选项，但您可以通过https或app登录回购。</p><p id="18e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">添加名称、存储库url和您的私有ssh密钥，然后单击<em class="ls"> connect </em>按钮。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/a2a474da229b419bf8e6d5217ccf1c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ILFVOAuAQBXnaMjZt4BCUQ.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">连接存储库</p></figure><p id="a3ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回到主页，让我们点击<em class="ls">新应用</em>按钮。</p><p id="4cd7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">填写应用程序名称字段，可以使用任何字符串。这个项目就是<code class="fe lo lp lq lr b">default</code>。</p><p id="1889" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">选择<code class="fe lo lp lq lr b">automatic</code> <em class="ls"> </em>作为同步策略，并添加git库的URL。路径是<code class="fe lo lp lq lr b">overlays/production</code>。</p><p id="8bd8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们必须设置集群URL，这是本地集群的地址。对于Docker Desktop，它是<a class="ae ln" href="http://kubernetes.default.svc." rel="noopener ugc nofollow" target="_blank">http://kubernetes . default . SVC</a>，我们将把应用程序部署到<em class="ls"> default </em>名称空间中。</p><p id="3e40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">点击<em class="ls">创建</em>按钮。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/aec166338653fbbc1548652b49f7b213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2kFjEoLHV8x2lc9CfrhcqA.png"/></div></div></figure><p id="38be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在主页上，您将看到该应用程序。等到它会健康。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/cb7dd33aeddd62a5de41ed7150dd0edb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FU2LTHoDh-xEwyCJgrx9MQ.png"/></div></div></figure><p id="6bbc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当应用程序启动并运行时，打开这个URL 并检查结果。</p><p id="5e9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">单击应用程序的标题，我们可以检查部署的状态。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/fc3fe7b7f8d54994f5c59c08cdd45cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mvXHQ2keLVEAJf0lHGt4xQ.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">应用程序状态</p></figure><p id="01a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们更改应用程序项目中的名称，并将其推回到master branch。构建完成后，ArgoCD将从存储库中获取更改，并部署新的应用程序版本。</p><p id="a2c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据构建时间的不同，有时可能需要5分钟，所以请耐心等待(默认的同步时间是3分钟)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/b57a1f6c931b1a561c34c7a68d3feeaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DgEVmEFDHv2GCPNKLbelQ.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">自动部署新版本</p></figure><p id="66c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以在这个管道中添加很多步骤，比如静态代码分析，将测试覆盖上传到Codecov，等等。</p><p id="6716" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">GitHub上提供了源代码:</p><ul class=""><li id="9734" class="nw nx iq kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated"><a class="ae ln" href="https://github.com/zlaval/continuous-delivery-application" rel="noopener ugc nofollow" target="_blank">应用</a></li><li id="2ac7" class="nw nx iq kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated"><a class="ae ln" href="https://github.com/zlaval/continuous-delivery-manifests" rel="noopener ugc nofollow" target="_blank">部署清单</a></li></ul></div></div>    
</body>
</html>