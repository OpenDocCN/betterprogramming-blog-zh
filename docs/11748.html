<html>
<head>
<title>Deploy Your Django Apps in AWS With CDK (v2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CDK (v2)在AWS中部署Django应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/deploy-your-django-apps-in-aws-with-cdk-v2-997731a4aa50?source=collection_archive---------2-----------------------#2022-04-13">https://betterprogramming.pub/deploy-your-django-apps-in-aws-with-cdk-v2-997731a4aa50?source=collection_archive---------2-----------------------#2022-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c5b0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将基础设施作为代码进行管理</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c1e858cd04e868b3c7562d5da439da6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oSQyPQQ5pZbmrchXt7JG2g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com/s/photos/guide?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@darya_jumelya" rel="noopener ugc nofollow" target="_blank"> Darya Jum </a>拍摄的照片</p></figure><h1 id="6413" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是作为代码的基础设施？</h1><p id="a59a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">基础设施即代码(IaC)意味着通过“代码”而不是手动来配置和管理您的基础设施。这段代码的一个很大的优点是，现在您可以像管理您的软件代码一样管理它。您可以将它提交给某个存储库，您可以比较和检查更改，您可以进行回滚，并且您可以在其他项目中重用代码。</p><p id="fedd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是这种“代码”通常意味着用他们自己的语言编写YAML或JSON配置文件，而这些语言通常并不像您想象的那样对开发人员友好。</p><p id="3874" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，让我们检查这个CloudFormation模板(AWS中的IaC配置文件)的代码，该模板用于创建运行最小flask应用程序的负载平衡Fargate服务:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="fe02" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这种语言主要是陈述性的；语法和结构很复杂，你必须处理大量与网络和权限相关的底层配置。此外，随着架构复杂性的增长，代码行数也在快速增长。所有这些都使得维护这些文件变得很痛苦。</p><h1 id="68a7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">基础设施是用CDK编码</h1><p id="9843" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://docs.aws.amazon.com/cdk/v2/guide/home.html" rel="noopener ugc nofollow" target="_blank">云开发工具包</a> (CDK)通过支持Python、TypeScript和JavaScript等流行的编程语言，将IaC带到了一个新的高度。这允许您通过编写类和实例化对象来进行面向对象编程(OOP ),从而对您的基础设施进行建模。同时，CDK库提供了更高层次的抽象，可以封装与网络和权限相关的细节，选择好的(但可编辑的)默认值。</p><p id="1b1e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，让我们看看用Python中的CDK创建负载平衡的Fargate服务所需的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="fc87" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们可以看到，它只是Python中的OOP，代码行数大幅减少。现在，您可以像维护应用程序代码一样维护您的基础结构代码。您可以应用最佳实践，甚至<a class="ae kv" href="https://aws.amazon.com/blogs/developer/testing-cdk-applications-in-any-language/" rel="noopener ugc nofollow" target="_blank">为它添加单元测试</a>！</p><h1 id="14b0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">CDK基础知识</h1><h2 id="7b06" class="mr kx iq bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated">CDK是如何工作的？</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/7a8b93aa0efca77a9e4752112e1a7248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaZ6hg-VhtEbym03A4cyjw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">亚马逊在<a class="ae kv" href="https://docs.aws.amazon.com/cdk/v2/guide/home.html" rel="noopener ugc nofollow" target="_blank"> cdk文档上的图表</a></p></figure><p id="37cb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">CDK建在云层之上。它采用Python代码并从中合成CloudFormation模板。它附带了一个<a class="ae kv" href="https://docs.aws.amazon.com/cdk/v2/guide/cli.html" rel="noopener ugc nofollow" target="_blank">工具包</a>，允许创建一个新的CDK项目，合成代码，并使用选择的帐户和地区部署它。</p><h2 id="5f8c" class="mr kx iq bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated">CDK基础知识</h2><ul class=""><li id="2770" class="ne nf iq lq b lr ls lu lv lx ng mb nh mf ni mj nj nk nl nm bi translated">构造:<a class="ae kv" href="https://docs.aws.amazon.com/cdk/v2/guide/constructs.html" rel="noopener ugc nofollow" target="_blank">构造</a>代表AWS中的云资源，例如S3桶、负载平衡器或RDS数据库。您通常将它们用作架构的底层构建块。</li><li id="0d6a" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">解决方案构造:<a class="ae kv" href="https://docs.aws.amazon.com/solutions/latest/constructs/welcome.html" rel="noopener ugc nofollow" target="_blank">解决方案构造</a>是一个具有更高抽象层次的构造，它实现了常见的架构模式，例如，负载平衡的ECS+Fargate服务。</li><li id="605b" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">堆栈:一个<a class="ae kv" href="https://docs.aws.amazon.com/cdk/v2/guide/stacks.html" rel="noopener ugc nofollow" target="_blank">堆栈</a>将需要一起部署的资源组合在一起，例如，一个S3桶加上一个CloudFront发行版，它们一起用于服务一些静态文件，一个负载平衡的Fargate服务加上用于服务你的Django应用的自动伸缩策略。</li><li id="bf10" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">阶段:一个<a class="ae kv" href="https://docs.aws.amazon.com/cdk/api/v1/python/aws_cdk.core/Stage.html" rel="noopener ugc nofollow" target="_blank">阶段</a>可以对栈进行分组，以对整个系统的单个实例进行建模。一个阶段可以被实例化多次，以便在多种环境中部署您的应用程序，如测试、登台或生产。</li><li id="9dad" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">app:<a class="ae kv" href="https://docs.aws.amazon.com/cdk/v2/guide/apps.html" rel="noopener ugc nofollow" target="_blank">app</a>是代表整个CDK项目范围的根构造。每个CDK项目实例化一个应用程序，堆栈或阶段作为子节点添加。</li><li id="0660" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">AWS环境:一个<a class="ae kv" href="https://docs.aws.amazon.com/cdk/v2/guide/environments.html" rel="noopener ugc nofollow" target="_blank">环境</a>是一个帐户和一个将要部署堆栈的区域的组合。我们将在实例化一个<code class="fe ns nt nu nv b">Stack</code>时设置AWS环境。</li></ul><h1 id="fe9b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">亲自动手</h1><h2 id="6442" class="mr kx iq bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated"><strong class="ak">先决条件</strong></h2><p id="97af" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这是你开始CDK所需要的:</p><ul class=""><li id="d6f3" class="ne nf iq lq b lr mk lu ml lx nw mb nx mf ny mj nj nk nl nm bi translated">安装Python 3.6或更高版本，包括<code class="fe ns nt nu nv b">pip</code>和<code class="fe ns nt nu nv b">virtualenv</code></li><li id="69fd" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated"><a class="ae kv" href="https://docs.aws.amazon.com/cdk/v2/guide/getting_started.html#getting_started_prerequisites" rel="noopener ugc nofollow" target="_blank">安装CDKv2先决条件</a>(节点，AWS客户端...)</li><li id="0e53" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated"><a class="ae kv" href="https://docs.aws.amazon.com/cdk/v2/guide/getting_started.html#getting_started_install" rel="noopener ugc nofollow" target="_blank">安装AWS CDK工具包</a>。</li></ul><p id="4bca" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">另外，<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/dockerize-your-django-apps-428189407c69">将你的Django应用</a>归档。所选择的架构需要一个容器化的应用程序</p><h2 id="79d8" class="mr kx iq bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated">代码</h2><p id="54d4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">您可以在<a class="ae kv" href="https://github.com/marianobrc/scalable-django-apps" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到这个示例项目的完整代码。</p><h2 id="7123" class="mr kx iq bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated">我们在云中的架构</h2><p id="272b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们将使用ECS和Fargate将Django应用程序作为无服务器容器运行。我们还将添加队列和使用SQS和芹菜的工人，以支持在后台执行长期运行的任务。如果你想了解更多关于这个特定架构的特性，请阅读之前的文章:<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/design-an-auto-scalable-architecture-for-your-django-apps-in-aws-850ca5ec63a1">在AWS中为你的Django应用设计一个可自动伸缩的架构</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/232b4b27e1f6166bd4abf8f0d751859c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NGor2qcDsFLQ1a-9WKTSIA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">你可以在这里得到这个全尺寸的图<a class="ae kv" href="https://drive.google.com/file/d/1r8eDUOzjiWLwNT3uH87PjQ4qounhtBtd/view?usp=sharing" rel="noopener ugc nofollow" target="_blank"/></p></figure><h2 id="4758" class="mr kx iq bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated">定义堆栈</h2><p id="324e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为具有不同生命周期的组件定义单独的栈是一个好的实践，尤其是将有状态和无状态的组件分开。例如，运行Django应用程序的ECS+Fargate服务是无状态的，您可能会更频繁地更新、销毁或重新创建这些资源(例如，在新版本中或在扩展事件中)。</p><p id="b9b7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是数据库是有状态的。你可能不想销毁它或替换它。一般来说，它的生命周期将与应用程序的生命周期分离。</p><p id="78a4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，我们将基础设施代码划分为以下堆栈:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/c08b121a270e91ffaf860a9386a4ff6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*qqXiU39WtRcWaUfK2HSZ3w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">你可以在这里得到这个全尺寸的图<a class="ae kv" href="https://drive.google.com/file/d/1TPdp69ZmivF0s5AO6TvHJZLNmNvzUZ-M/view?usp=sharing" rel="noopener ugc nofollow" target="_blank"/></p></figure><h1 id="90aa" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">从CDK开始</h1><p id="8537" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">先说好玩的部分吧！</p><p id="fcfd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">第一步是创建一个目录，然后使用CDK客户端初始化一个模板项目。我们选择Python语言。目录名会作为项目名，这次是<code class="fe ns nt nu nv b">my-django-app</code>。</p><pre class="kg kh ki kj gt ob nv oc od aw oe bi"><span id="3f66" class="mr kx iq nv b gy of og l oh oi">$ mkdir my-django-app<br/>$ cd my-django-app/<br/>$ cdk init app --language python<br/>Applying project template app for python</span><span id="2a78" class="mr kx iq nv b gy oj og l oh oi">...</span><span id="3810" class="mr kx iq nv b gy oj og l oh oi">Initializing a new git repository...<br/>Please run 'python3 -m venv .venv'!<br/>Executing Creating virtualenv...<br/>✅ All done!</span></pre><p id="b256" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们看看项目结构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/bd64966b57f9fe7561b587dbb114c765.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*-JSp1LsKaLG3sf8Xt6XTZg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">CDK项目初始结构</p></figure><ul class=""><li id="bcd7" class="ne nf iq lq b lr mk lu ml lx nw mb nx mf ny mj nj nk nl nm bi translated">CDK为你创建了一个基础工程和一个虚拟工程。请注意，这个虚拟环境只能在处理基础结构代码时使用，不能用作您的应用程序虚拟环境。避免在此安装应用程序依赖项。</li><li id="d07a" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated"><code class="fe ns nt nu nv b">app.py</code>:这是CDK项目的入口点，根app构造和主栈在这里被实例化。</li><li id="6c00" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">这些是使用CDK所需的核心Python依赖，包括CDK核心库本身。您还可以在此添加包含额外构造或解决方案构造的第三方包。</li><li id="9d08" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">这些是开发过程中需要的其他依赖，例如，在CDK堆栈上运行单元测试。</li><li id="715c" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated"><code class="fe ns nt nu nv b">my_django_app/my_django_app_stack.py</code>:默认情况下，CDK会为你的堆栈创建一个文件夹，为你的应用创建一个堆栈。我们将在这个目录中添加所有的栈。</li></ul><p id="ae3a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，我们将激活virtualenv并安装依赖项:</p><pre class="kg kh ki kj gt ob nv oc od aw oe bi"><span id="df10" class="mr kx iq nv b gy of og l oh oi">$ source .venv/bin/activate<br/>(.venv) $ pip install -r requirements.txt<br/>(.venv) $ pip install -r requirements-dev.txt</span></pre><h2 id="d818" class="mr kx iq bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated">拔靴带</h2><p id="89ef" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">由于我们将在部署过程中生成docker映像等资产，CDK需要<a class="ae kv" href="https://docs.aws.amazon.com/cdk/v2/guide/bootstrapping.html" rel="noopener ugc nofollow" target="_blank">引导</a>。首先，确保您之前已经配置了AWS客户端，或者查看先决条件一节。现在，您需要做的就是使用您的帐户id和地区名称运行bootstrap命令:</p><pre class="kg kh ki kj gt ob nv oc od aw oe bi"><span id="2cde" class="mr kx iq nv b gy of og l oh oi">$ cdk bootstrap aws://123456789123/us-east-2<br/> ⏳  Bootstrapping environment aws://123456789123/us-east-2...<br/>...<br/> ✅  Environment aws://123456789123/us-east-2 bootstrapped</span></pre><h1 id="68dd" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">创建我们的堆栈</strong></h1><p id="e8a7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于每个堆栈，我们将在stacks目录<code class="fe ns nt nu nv b">my_django_app</code> /中添加一个新文件，并且我们将定义一个新的stack子类。</p><h2 id="e5e6" class="mr kx iq bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated"><strong class="ak">网络堆栈</strong></h2><p id="83ae" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们将开始为我们的服务创建我们的<a class="ae kv" href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html" rel="noopener ugc nofollow" target="_blank">虚拟私有云</a> (VPC)、一些<a class="ae kv" href="https://docs.aws.amazon.com/vpc/latest/privatelink/vpc-endpoints.html" rel="noopener ugc nofollow" target="_blank"> VPC端点</a>和一个<a class="ae kv" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/clusters.html" rel="noopener ugc nofollow" target="_blank"> ECS集群</a>。我们的目标是一次性创建这些资源，并与其他栈共享它们来支持我们的架构，因此我们将它们分组到一个独立的<code class="fe ns nt nu nv b">Stack</code>中。</p><p id="c249" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe ns nt nu nv b">my_django_app/network_stack.py</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2a55" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe ns nt nu nv b">NetworkStack</code>类继承自CDK <a class="ae kv" href="https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk/Stack.html" rel="noopener ugc nofollow" target="_blank">栈</a>类。然后我们在<code class="fe ns nt nu nv b">__init__</code>方法中定义我们的资源。首先，我们使用构造<a class="ae kv" href="https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.aws_ec2/Vpc.html" rel="noopener ugc nofollow" target="_blank"> Vpc </a>来创建虚拟专用网络。</p><p id="cd7e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">所有的构造都接受两个第一强制参数:<code class="fe ns nt nu nv b">scope</code>和<code class="fe ns nt nu nv b">id</code>。<code class="fe ns nt nu nv b">scope</code>是对父构造的引用，<code class="fe ns nt nu nv b">id</code>是一个标识字符串，它在该范围内必须是唯一的。在我们的堆栈中，我们将id参数重命名为<code class="fe ns nt nu nv b">construct_id</code>，因为<code class="fe ns nt nu nv b">id</code>是Python中的保留字。</p><p id="29b5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，继续讨论VPC参数，我们选择两个可用性区域(AZ ),因为这是获得高可用性和零NAT网关以降低成本的最低要求。这将为每个AZ生成一个公共和一个私有隔离子网。</p><p id="ddde" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们还需要启用DNS支持和DNS主机名，因为需要使用VPC端点。我们还在亚马逊弹性容器服务(ECS)中创建了一个集群。ECS集群是ECS服务的逻辑分组，Django应用程序和工作人员将被放置在其中。</p><p id="ff90" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，我们为设计中使用的所有托管服务添加VPC端点，否则将需要互联网传出流量(然后是NAT网关):</p><ul class=""><li id="7e61" class="ne nf iq lq b lr mk lu ml lx nw mb nx mf ny mj nj nk nl nm bi translated">S3</li><li id="5ece" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">electroniccashregister电子现金出纳机</li><li id="cfd7" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">CloudWatch日志</li><li id="2707" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">秘密经理</li><li id="3435" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">SQS</li></ul><p id="e30d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，由于CDK在创建资源的过程中会生成随机名称，因此保存一些参数以便以后查找或引用它们是很有用的。在这种情况下，我们将把VPC id和子网id作为参数保存在<a class="ae kv" href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-parameter-store.html" rel="noopener ugc nofollow" target="_blank">系统管理器(SSM)参数存储库</a>中。我们将对所有参数和机密使用以下形式的命名约定:</p><p id="a73c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe ns nt nu nv b">/StageName/ParameterName</code></p><p id="a993" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，例如，登台环境的VPC id参数的全名将是:<code class="fe ns nt nu nv b">/MyDjangoAppStaging/VpcId</code>。</p><h1 id="f3dc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">数据库堆栈</strong></h1><p id="d336" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe ns nt nu nv b">my_django_app/database_stack.py</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="03ee" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了创建数据库，我们使用支持不同数据库引擎的<a class="ae kv" href="https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.aws_rds/ServerlessCluster.html" rel="noopener ugc nofollow" target="_blank"> ServerlessCluster </a>结构。在这种情况下，我们选择PostgreSQL版本10的<a class="ae kv" href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.AuroraPostgreSQL.html" rel="noopener ugc nofollow" target="_blank"> Aurora PostgreSQL </a>引擎(这是撰写本文时支持的最新版本)。</p><p id="f7d6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们还设置了子网和权限，使数据库只能从私有子网访问(Django应用程序将驻留在这里)。</p><p id="d0fd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此外，这一次我们将在<code class="fe ns nt nu nv b">__init__</code>方法中添加一些额外的参数，这样我们就可以在为不同的环境实例化这个堆栈时定制它的一些设置:</p><ul class=""><li id="d489" class="ne nf iq lq b lr mk lu ml lx nw mb nx mf ny mj nj nk nl nm bi translated">VPC:这是数据库将会存在的VPC。这将是我们之前在网络堆栈中创建的VPC。</li><li id="f746" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated"><code class="fe ns nt nu nv b">database_name</code>:这个参数允许我们设置默认数据库的名称，这个名称将在以后被我们的Django应用程序使用。<code class="fe ns nt nu nv b">ServerlessCluster</code>构造用<code class="fe ns nt nu nv b">default_database_name</code>参数中给定的名称创建一个默认数据库。</li><li id="f76e" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated"><code class="fe ns nt nu nv b">min_capacity</code>和<code class="fe ns nt nu nv b">max_capacity</code>:这些参数定义了集群的缩放限制。计算能力以“<a class="ae kv" href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.how-it-works.html#aurora-serverless.architecture" rel="noopener ugc nofollow" target="_blank"> Aurora容量单位</a>”(ACUs)来衡量，它是CPU/内存/网络容量的组合。最低两个acu，最高384。然后，数据库将根据CPU利用率、连接和可用内存的指标组合自动扩展，但始终在定义的限制范围内。</li><li id="b9b2" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated"><code class="fe ns nt nu nv b">auto_pause_minutes</code>:这将允许我们在数据库空闲一定时间后关闭数据库的计算能力，这意味着容量缩减到零。为了节省成本，您可能希望在测试/试运行环境中这样做。下次检测到新连接时，将恢复数据库容量。你应该知道有一个预热时间，可以是一分钟左右。</li><li id="2973" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated"><code class="fe ns nt nu nv b">backup_retention_days</code>:数据库备份在此天数后自动删除。Aurora每天自动备份一次，保留一天的备份是免费的。</li></ul><p id="f6de" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">CDK创建数据库后，会在机密管理器中添加一个新的机密，其中包含数据库集群URL、数据库名称和数据库凭据。因为我们稍后需要找到这个秘密，所以我们将秘密的名称保存在SSM参数存储中。</p><h2 id="61b0" class="mr kx iq bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated"><strong class="ak">静态文件堆栈</strong></h2><p id="cc76" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们将把静态文件存储在一个<a class="ae kv" href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html" rel="noopener ugc nofollow" target="_blank"> S3桶</a>中，并且我们将通过一个<a class="ae kv" href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html" rel="noopener ugc nofollow" target="_blank"> CloudFront发行版</a>来服务它们。</p><p id="ab01" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe ns nt nu nv b">my_django_app/static_files_stack.py</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9bac" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，我们创建一个私有桶。出于安全原因，我们不希望桶是公开的，所以我们阻止任何来自互联网的流量。由于静态文件可以随时重新生成，我们允许CDK根据需要销毁这个桶及其对象。</p><p id="cc69" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后我们创建一个<a class="ae kv" href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html" rel="noopener ugc nofollow" target="_blank">源访问标识</a> (OAI)来允许我们的CloudFront发行版访问桶中的文件。</p><p id="0d53" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此外，如果提供了<code class="fe ns nt nu nv b">cors_allowed_origins </code>，我们将添加一个CORS策略，只允许来自这些域/子域的请求。否则所有的起源都是允许的。</p><p id="5c5c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，这次我们将在<a class="ae kv" href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-parameter-store.html" rel="noopener ugc nofollow" target="_blank"> SSM参数存储</a>中保存s3 bucket名称和CloudFront发行版URL。</p><p id="5fa7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">外部秘密堆栈</strong></p><p id="9878" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">有些参数我们无法预先设定。例如，我们不想在我们的存储库中提交Django <code class="fe ns nt nu nv b">SECRET_KEY</code>值，并且我们直到数据库被部署后才能知道数据库主机URL。</p><p id="3014" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但幸运的是，有一种方法可以让这些参数值在运行时被注入。包含敏感信息的参数(如Django密钥或数据库机密)被加密存储在AWS Secrets Manager中，而其他参数(如TLS证书)可以作为文本存储在AWS SSM参数存储中。</p><p id="db47" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个堆栈将这些类型的参数分组，并允许我们稍后将它们传递给应用程序堆栈和工人堆栈。</p><p id="f520" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe ns nt nu nv b">my_django_app/external_parameters_stack.py</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="aaf1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe ns nt nu nv b">app_secrets</code>字典对包含敏感信息的Django应用程序所需的环境变量进行分组。因此，我们没有对值进行硬编码，而是创建了<a class="ae kv" href="https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.aws_ecs/Secret.html" rel="noopener ugc nofollow" target="_blank"> ecs。秘密</a>对象。这使得当容器启动时，在运行时将值注入到env变量中。</p><p id="d7bf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe ns nt nu nv b">ecs.Secret</code>可以从存储在秘密管理器中的秘密或存储在SSM参数存储中的参数中检索值。此外，secrets manager中的秘密可以存储(加密)为文本或JSON。</p><p id="f2ec" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Django秘密密钥是存储在秘密管理器中的字符串，所以我们使用<code class="fe ns nt nu nv b"><a class="ae kv" href="https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.aws_secretsmanager/Secret.html#aws_cdk.aws_secretsmanager.Secret.from_secret_name_v2" rel="noopener ugc nofollow" target="_blank">secretsmanager.Secret.from_secret_name_v2</a></code>从秘密名称构建秘密对象。注意，您需要在AWS控制台中手动创建这个秘密，并且名称应该与前面提到的约定相匹配，以便使用这个示例代码。</p><p id="8e25" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">数据库机密也存储在机密管理器中。但是它是在创建数据库的过程中自动创建的，它的内容是一个JSON映射，包含数据库主机URL、数据库名称、用户名、密码等。因此，我们使用由数据库栈创建的secret对象，并指定我们想要从中提取每个值的JSON字段。</p><p id="4d34" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">AWS API密钥以文本形式存储在secrets manager中，它们的检索方式与Django密钥相同。(这些AWS键被<code class="fe ns nt nu nv b">django-storages</code>用来在S3存储静态文件)。</p><h1 id="f46b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">应用堆栈</strong></h1><p id="e46c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">你会看到CDK已经自动创建了一个名为<code class="fe ns nt nu nv b">MyDjangoAppStack</code>的空堆栈类。</p><p id="0048" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe ns nt nu nv b">my_django_app/my_django_app_stack.py</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/88259a5d39dc855207bfefe82c3d33f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*srnh3j_uvAxLNHPVZOPzsQ.png"/></div></div></figure><p id="4bf8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们将使用这个堆栈来创建运行Django应用程序所需的基础设施，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a3d4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这种情况下，我们希望将Django应用程序作为ECS服务运行，使用前端负载平衡器，这样我们就可以进行水平扩展。因为这是一个众所周知的架构模式，所以我们可以使用一个名为<a class="ae kv" href="https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.aws_ecs_patterns/ApplicationLoadBalancedFargateService.html" rel="noopener ugc nofollow" target="_blank">ApplicationLoadBalancedFargateService</a>的解决方案。我们还将启用运行状况检查和自动扩展。</p><p id="da93" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，因为我们希望我们的应用程序在我们自己的域中运行于HTTPS之上，所以我们需要一个TLS证书。由于证书创建和验证可能需要一些时间，我们不会使用CDK创建它，但我们会导入它。</p><p id="799c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您可以使用<a class="ae kv" href="https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html" rel="noopener ugc nofollow" target="_blank"> AWS证书管理器</a> (ACM)从AWS控制台创建证书。创建后，我们将证书ARN作为参数保存在SSM参数存储中，并将其导入到此处。稍后，我们使用<a class="ae kv" href="https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.aws_certificatemanager/Certificate.html#aws_cdk.aws_certificatemanager.Certificate.from_certificate_arn" rel="noopener ugc nofollow" target="_blank"> acm实例化一个证书对象。certificate . from _ certificate _ arn</a>。然后我们将在<code class="fe ns nt nu nv b">certificate</code>参数中传递证书对象，同时将<code class="fe ns nt nu nv b">protocol</code>设置为HTTPS，并将<code class="fe ns nt nu nv b">redirect_http=True</code>设置为强制将HTTP请求重定向到HTTPS。</p><p id="fe29" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，设置<code class="fe ns nt nu nv b">public_load_balancer=True</code>将使负载均衡器放在我们的公共子网中，这样它就可以暴露在互联网上。</p><p id="d9f4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，我们设置服务所在的<code class="fe ns nt nu nv b">cluster</code>。我们从cluster参数中获取它，这里我们将传入我们之前在网络堆栈中创建的集群。我们使用一个<a class="ae kv" href="https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.aws_ec2/SubnetSelection.html?highlight=ec2%20subnetselection#aws_cdk.aws_ec2.SubnetSelection" rel="noopener ugc nofollow" target="_blank"> ec2来设置<code class="fe ns nt nu nv b">task_subnets</code>。SubnetSelection </a>使Fargate任务在我们的私有隔离子网中运行；它们只能通过负载平衡器访问，并且不会暴露在互联网上。</p><p id="738d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">接下来，我们设置CPU和内存限制，以及Fargate任务的期望计数。我们已经在堆栈中对这些设置进行了参数化，因此我们可以指定更多或更少的容量和更多或更少的冗余实例，同时稍后为不同的环境(暂存、生产)实例化堆栈。</p><p id="e4f5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们还需要在<code class="fe ns nt nu nv b">task_image_options</code>中定义容器图像选项。我们希望从源代码构建图像，所以我们使用<a class="ae kv" href="https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.aws_ecs/ContainerImage.html#aws_cdk.aws_ecs.ContainerImage.from_asset" rel="noopener ugc nofollow" target="_blank"> ecs。ContainerImage.from_asset </a>并设置repo中docker文件的相对路径，以及要构建的目标(在本例中，prod用于构建生产映像)。</p><p id="2a35" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们指定应用程序监听的端口，以便负载平衡器将请求转发给它。最后，我们传入之前定义的环境变量和秘密。</p><p id="c002" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于健康检查，我们在应用程序中的<code class="fe ns nt nu nv b">/status/</code>处添加了一个状态端点，它在GETs上返回状态200 Ok，因此我们在配置中设置了该URL。我们还设置了阈值，因此一个实例(容器)在三次成功的健康检查后将被标记为健康，在两次失败的健康检查后将被标记为不健康。</p><p id="3d97" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这样，不健康的实例将被自动检测和替换。</p><p id="8ef6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于自动缩放，亚马逊支持不同的缩放策略:<a class="ae kv" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-autoscaling-targettracking.html" rel="noopener ugc nofollow" target="_blank">目标跟踪缩放</a>、<a class="ae kv" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-autoscaling-stepscaling.html" rel="noopener ugc nofollow" target="_blank">步进缩放</a>和<a class="ae kv" href="https://docs.aws.amazon.com/autoscaling/application/userguide/application-auto-scaling-scheduled-scaling.html" rel="noopener ugc nofollow" target="_blank">预定缩放</a>。在这种情况下，因为我们知道CPU使用率与我们的应用程序处理的请求数量相关，所以我们将使用基于CPU使用率指标的目标跟踪策略。</p><p id="795e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当平均CPU利用率超过75%时，横向扩展警报将触发服务自动扩展，以添加另一个任务(增加所需的任务数)来帮助应对增加的负载。相反，当平均CPU利用率持续一段时间低于75%时，扩展警报将触发服务所需数量的减少，以释放资源并降低成本。</p><p id="9cae" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们还设置了最小和最大任务计数，这些设置也是参数，因此我们可以在以后针对不同的环境对它们进行调整。例如，我们可能希望生产环境中至少有两个任务来保证高可用性，但是对于测试/试运行环境，一个任务就足够了。</p><p id="09da" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，我们保存了一些与SSM中的任务相关的参数，这对以后运行一次性任务(例如，在ECS中运行Django命令)很有用。</p><h1 id="1d97" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">DNS路由</strong></h1><p id="14ac" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe ns nt nu nv b">my_django_app/dns_route_to_alb_stack.py</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="0983" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">注册域和创建托管区域需要一些验证步骤，可能需要一些时间，所以我们不会自动与CDK。但是我们可以在AWS控制台中完成第一步，然后导入我们需要的内容。</p><p id="06a9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，我们将通过域名寻找托管区域。然后，我们将设置一些DNS记录，使我们的域指向我们的负载平衡器。由于我们使用的是CDK，如果更换了负载平衡器并且DNS发生了变化，那么DNS记录也会更新。</p><h2 id="1a47" class="mr kx iq bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated"><strong class="ak">队列</strong></h2><p id="b8b3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们将使用<a class="ae kv" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/welcome.html" rel="noopener ugc nofollow" target="_blank">亚马逊简单队列服务</a> (SQS)来创建我们的队列。SQS是一项托管服务，因此我们不需要调配或管理任何服务器、资源或容量。</p><p id="d61d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">它高度可用，并支持存储无限数量的消息。这使得它非常适合作为芹菜的经纪人。忘记必须监视队列是否已满或存储空间是否已满并有可能丢失消息。</p><p id="5d0a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe ns nt nu nv b">my_django_app/queues_stack.py</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="eeab" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们使用<code class="fe ns nt nu nv b">sqs.Queue</code>构造来创建一个队列。我们将使用SQS作为芹菜的代理，这将是默认队列。我们将队列的URL保存在SSM，以便以后在芹菜设置中引用它。</p><h2 id="c6c4" class="mr kx iq bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated"><strong class="ak">工人们</strong></h2><p id="9916" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">工人将读取来自SQS队列的消息，并将执行芹菜任务。我们为工作人员添加了另一个堆栈，以便他们可以独立扩展。</p><p id="346d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe ns nt nu nv b">my_django_app/backend_workers_stack.py</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="38d6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">同样，这是一个众所周知的模式，所以我们可以使用现有的解决方案构造:<a class="ae kv" href="http://QueueProcessingFargateService" rel="noopener ugc nofollow" target="_blank">QueueProcessingFargateService</a>。大多数参数与<a class="ae kv" href="https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.aws_ecs_patterns/ApplicationLoadBalancedFargateService.html" rel="noopener ugc nofollow" target="_blank">ApplicationLoadBalancedFargateService</a>中的参数非常相似，所以我将解释不同的参数。</p><p id="925f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于自动伸缩，这一次我们使用基于队列中消息数量的分步伸缩策略。步骤在<code class="fe ns nt nu nv b">scaling_steps</code>中被指定为字典。对于每个步骤，我们为队列度量中的消息数量定义了一个下限或上限，以及一个要采取的操作，用工作线程数量的增量或减量来表示。</p><p id="1f07" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们允许在栈实例化期间改变这个策略，但是我们也设置了一些合理的默认值。</p><p id="5d59" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">docker映像与Django app服务中使用的映像相同，但是我们覆盖了在容器中执行的命令，以运行启动Celery worker的脚本，而不是启动gunicorn。</p><h2 id="5a5c" class="mr kx iq bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated"><strong class="ak">部署阶段</strong></h2><p id="7f66" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">既然我们已经为所有系统组件定义了堆栈，我们将在<a class="ae kv" href="https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk/Stage.html?highlight=stage#aws_cdk.Stage" rel="noopener ugc nofollow" target="_blank">阶段</a>中对它们进行分组。</p><p id="dae3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe ns nt nu nv b">my_django_app/deployment_stage.py</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ebb8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个阶段代表了整个系统的一个实例，这将使得为以后的测试/试运行或生产创建多个环境变得更加容易。因此，这里我们实例化了我们之前创建的所有堆栈。我们也</p><h2 id="f157" class="mr kx iq bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated"><strong class="ak">增加CDK管道的CI/CD</strong></h2><p id="d255" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">CDK管道不仅允许在应用程序代码发生变化时部署新版本的应用程序，还可以更新基础设施(以及管道本身！)当您的基础架构代码发生变化时。</p><p id="2341" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您可以根据您所使用的分支模型，按照最适合您的需求来对您的管道进行建模。例如，如果您正在跟踪<a class="ae kv" href="https://docs.github.com/en/get-started/quickstart/github-flow" rel="noopener ugc nofollow" target="_blank"> GitHub流</a>，您可能想要在PRs被合并到主分支时触发一个单独的管道。</p><p id="397f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个管道部署到一个测试环境中，在那里您可以运行更多的手动或自动化测试(端到端、集成、UI测试等)。)，并在自动或手动批准后部署到生产环境中。</p><p id="133b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">相反，如果您正在遵循<a class="ae kv" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank"> GitFlow </a>，您可能希望有两条管道:一条由开发分支中的提交触发，它将部署到您的登台环境，另一条由主分支中的提交触发，它将部署到您的生产环境。</p><p id="6b1e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于这个例子，我们将选择GitHub流，它有两个环境，staging和production，在转移到production之前有一个手动批准步骤。那么我们的管道将有以下步骤:</p><ul class=""><li id="42ca" class="ne nf iq lq b lr mk lu ml lx nw mb nx mf ny mj nj nk nl nm bi translated">Source:这个阶段从您的GitHub repo获取源代码，并在您每次向它推送新的提交时触发管道。存储库现在包括您的应用程序代码和基础设施代码。这通过你需要预先创建的AWS CodeStar connection应用程序使用webhooks来实现。</li><li id="c4f7" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">构建:这个阶段执行一个<code class="fe ns nt nu nv b">cdk synth</code>。该步骤的输出是一个<a class="ae kv" href="https://docs.aws.amazon.com/cdk/latest/guide/apps.html#apps_cloud_assembly" rel="noopener ugc nofollow" target="_blank">云组件</a>，它用于执行管道其余部分的所有操作。</li><li id="f89f" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">UpdatePipeline:该阶段使管道根据需要进行自我更新。例如，如果您更新基础结构代码以向管道添加新的部署阶段，管道将自动更新以反映您所做的更改。这也意味着我们只需要在第一次手动部署管道，之后，我们可以修改管道代码并将更改推送到存储库。</li><li id="fa40" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">PublishAssets:这个阶段为应用程序、工作人员等构建并发布Docker图像..到<a class="ae kv" href="http://aws.amazon.com/ecr/" rel="noopener ugc nofollow" target="_blank">亚马逊弹性容器注册中心</a>(亚马逊ECR)，这样它们可以在后续部署中使用。</li><li id="df2c" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">转移:根据需要创建或更新转移环境。在这里，使用最新的docker映像创建或更新ECS服务。我们使用这个环境来做更多的QA工作(例如，集成测试、端到端测试、UI测试)。</li><li id="4fe9" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">生产:在手动批准后，映像被部署到生产阶段。部署新映像，更新ECS中的应用程序。<a class="ae kv" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-ecs.html" rel="noopener ugc nofollow" target="_blank">滚动更新</a>可用于避免停机。</li></ul><p id="ac8f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们定义一下我们的渠道:</p><p id="801c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe ns nt nu nv b">my_django_app/pipeline_stack.py</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="18bf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">堆栈管道类似于任何其他堆栈，但是它将包含管道以及针对我们想要部署的不同环境的系统阶段。</p><p id="b169" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们使用<a class="ae kv" href="https://docs.aws.amazon.com/cdk/v2/guide/cdk_pipeline.html#cdk_pipeline_define" rel="noopener ugc nofollow" target="_blank">代码管道构造</a>创建管道。然后我们添加一个<a class="ae kv" href="https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.pipelines/ShellStep.html" rel="noopener ugc nofollow" target="_blank"> ShellStep </a>，在这里我们指定安装CDK、安装依赖项和合成基础设施代码所需的源代码库和命令。</p><p id="c0dd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们还提供dockerhub凭证，以使用标准的dockerhub帐户，对图像拉取有更高的限制。你可以使用免费帐户，但如果你一天部署几次，你可能会达到拉限制。ShellStep将生成管道的前四个阶段:源代码、构建、更新管道和发布资产。</p><p id="d936" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，我们使用Stage类<code class="fe ns nt nu nv b">MyDjangoAppPipelineStage</code>实例化两个Stage:一个用于staging，名为<code class="fe ns nt nu nv b">MyDjangoAppStaging</code>，另一个用于production，名为<code class="fe ns nt nu nv b">MyDjangoAppProduction</code>。每一个都有不同的设置。例如，对于转移，我们使用最小容量的数据库，启用数据库自动暂停功能，并限制ECS中的任务数量以降低成本。但是在生产中，我们保持数据库始终运行，并且我们设置了更高的扩展限制。</p><p id="c14c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们使用<code class="fe ns nt nu nv b"><a class="ae kv" href="https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.pipelines/CodePipeline.html#aws_cdk.pipelines.CodePipeline.add_stageç" rel="noopener ugc nofollow" target="_blank">add_stage</a></code>方法按照我们希望应用程序部署的顺序将每个阶段添加到管道中。所以首先是筹备阶段，然后是生产阶段。我们还在添加生产阶段时设置了<code class="fe ns nt nu nv b">pre </code>参数，以阻塞管道，直到获得人工批准。</p><p id="8b52" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">既然定义了管道栈，我们需要在入口点<code class="fe ns nt nu nv b">app.py</code>中实例化它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="99da" class="mr kx iq bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated">部署</h2><p id="a749" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们现在需要做的就是使用CDK客户端部署管道:</p><pre class="kg kh ki kj gt ob nv oc od aw oe bi"><span id="7377" class="mr kx iq nv b gy of og l oh oi">$ cdk deploy MyDjangoAppPipeline</span></pre><p id="ec47" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">(你可以在这个视频的<a class="ae kv" href="https://share.vidyard.com/watch/p6VangmRSqWkcw2DU9oMki?" rel="noopener ugc nofollow" target="_blank">中看到部署命令在起作用)。</a></p><p id="5ade" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，CDK合成了CloudFormation堆栈，如果有语法错误或其他问题，您会在stdout中看到它。然后，CDK将在创建角色、策略和安全组之前要求确认。输入“y”表示是，部署过程将开始。您将在shell中看到部署进度，一旦完成，您将在AWS控制台的<a class="ae kv" href="https://us-east-2.console.aws.amazon.com/cloudformation/home?region=us-east-2" rel="noopener ugc nofollow" target="_blank"> CodePipeline面板中看到管道。</a></p><p id="3307" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">部署管道后，它将被触发，所有的栈都将被创建。您可以在AWS控制台的<a class="ae kv" href="https://us-east-2.console.aws.amazon.com/cloudformation/home?region=us-east-2" rel="noopener ugc nofollow" target="_blank"> CloudFormation面板中监控堆栈的创建。</a></p><p id="6776" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是您唯一需要运行部署命令的时候。下次您提交基础架构代码或应用程序代码的任何更改时，管道将更新基础架构，并根据需要更新ECS服务。</p><h1 id="ec54" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">运行命令</strong></h1><p id="b90c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">使用Django时，运行shell命令或脚本是很常见的，比如为后台创建一个超级用户、运行一个定制的数据迁移，或者只是运行出于任何原因需要的任何定制命令或脚本。</p><p id="b645" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是由于应用程序运行在孤立的无状态容器中，我们不能通过ssh进入其中一个容器来获得一个shell并执行我们的命令(这不是一个bug这是一个特点！).但是我们可以在ECS中启动一个一次性的Fargate任务，在同一个集群和子网中，在一个新的容器中运行命令。</p><p id="5337" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因为这个任务是短暂的，一旦命令退出，任务就停止，容器被销毁。我们可以通过使用AWS CLI或AWS SDK调用<a class="ae kv" href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html" rel="noopener ugc nofollow" target="_blank"> RunTask </a> API来触发任务。因为我更喜欢编写Python代码而不是shell脚本，所以我将使用Python SDK (boto3)，并且我将编写一个Python脚本来以这种方式运行ECS中的任何命令。</p><p id="5093" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您将在<code class="fe ns nt nu nv b">/scripts/run_cmd.py</code>找到这个助手脚本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6e67" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该脚本将接受一个命令和一个部署环境名称(我们给我们的暂存或生产阶段的名称)，并且它将启动一个任务以在该环境中执行该命令。</p><p id="f736" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">怎么会？还记得我们在SSM不同堆栈中存储的参数吗？这个脚本将读取这些SSM参数，并使用与Django应用程序相同的设置，在正确的集群中构建运行任务所需的配置。</p><p id="4d2e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">docker映像将与Django应用程序使用的映像相同，但是docker命令将被覆盖。这样，我们可以运行Django命令，并且由于任务可以访问数据库，我们可以使用Django ORM或任何我们需要的东西。</p><h2 id="2268" class="mr kx iq bd ky ms mt dn lc mu mv dp lg lx mw mx li mb my mz lk mf na nb lm nc bi translated"><strong class="ak">用法</strong></h2><p id="84ab" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">首先，我们需要用脚本调用AWS API所需的AWS配置设置一些env变量:</p><pre class="kg kh ki kj gt ob nv oc od aw oe bi"><span id="adac" class="mr kx iq nv b gy of og l oh oi">AWS_ACCOUNT_ID=123456789123<br/>AWS_REGION_NAME=us-east-1<br/>AWS_ACCESS_KEY_ID=SOME4P1KEYID<br/>AWS_SECRET_ACCESS_KEY=sOmeSecretACcesKey</span></pre><p id="5b80" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您可以在您的shell中设置这些env变量，或者您可以在. env文件中设置它们，然后将它们加载到您的shell中。如果您使用的是Linux，您可以使用位于<code class="fe ns nt nu nv b">/scripts/set_env_vars.sh</code>的助手脚本:</p><pre class="kg kh ki kj gt ob nv oc od aw oe bi"><span id="5ddb" class="mr kx iq nv b gy of og l oh oi">$ . ./scripts/set_env_vars.sh</span></pre><p id="6958" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，您可以执行<code class="fe ns nt nu nv b">run_cmd</code>脚本。您可以使用<code class="fe ns nt nu nv b">-h</code>选项运行它来查看使用帮助:</p><pre class="kg kh ki kj gt ob nv oc od aw oe bi"><span id="1a96" class="mr kx iq nv b gy of og l oh oi">(.venv) $ python ./scripts/run_cmd.py -h<br/>usage: run_cmd.py [-h] --env ENV_NAME [--env-var ENV_VARS] command</span><span id="279b" class="mr kx iq nv b gy oj og l oh oi">Run a command as a fargate task in ecs, using the same container and settings used by the App</span><span id="74ec" class="mr kx iq nv b gy oj og l oh oi">positional arguments:<br/>  command</span><span id="a22c" class="mr kx iq nv b gy oj og l oh oi">optional arguments:<br/>  -h, --help          show this help message and exit<br/>  --env ENV_NAME      The environment where the command will be run: MyDjangoAppStaging or MyDjangoAppProduction.<br/>  --env-var ENV_VARS  Set extra env vars as --env-var NAME1=VALUE1 --env-var NAME2=VALUE2</span></pre><p id="cdbd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，现在让我们在staging中为我们的后台创建一个超级用户:</p><pre class="kg kh ki kj gt ob nv oc od aw oe bi"><span id="99a8" class="mr kx iq nv b gy of og l oh oi">(.venv) $ python ./scripts/run_cmd.py "python manage.py createsuperuser --noinput --username admin --<a class="ae kv" href="mailto:email=marianomartinez84@gmail.com" rel="noopener ugc nofollow" target="_blank">email=admin@your-domain.com</a>" --env MyDjangoAppStaging --env-var DJANGO_SUPERUSER_PASSWORD=MyPassWord123<br/>Building execution config for MyDjangoAppStaging<br/>Config loaded:<br/>...<br/>AWS Response:<br/>...</span></pre><p id="e022" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最终的配置和AWS API响应被打印到stdout，以便您可以捕捉任何错误。如果您没有看到错误，这意味着任务已经开始。您可以在AWS控制台的<a class="ae kv" href="https://us-east-2.console.aws.amazon.com/ecs/home?region=us-east-2#/clusters" rel="noopener ugc nofollow" target="_blank"> ECS面板中监控任务状态，也可以在CloudWatch查看日志。</a></p><p id="63a6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>