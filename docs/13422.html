<html>
<head>
<title>Performance Impact of Maps Compared to Slices in Go 1.18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与Go 1.18中的切片相比，地图对性能的影响</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/performance-impact-of-maps-compared-to-slices-in-go-1-18-15352fbd6010?source=collection_archive---------2-----------------------#2022-08-25">https://betterprogramming.pub/performance-impact-of-maps-compared-to-slices-in-go-1-18-15352fbd6010?source=collection_archive---------2-----------------------#2022-08-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f235" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用自定义键会影响性能吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/f1fc67cfd6d3aec493413c9e238e94d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*r82neH261ZPl7sVcHQb05Q.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">地鼠是由<a class="ae kr" href="https://egonelbre.com/" rel="noopener ugc nofollow" target="_blank">埃贡·厄尔布尔</a>画的。</p></figure><p id="9ea5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">正如我在第一部分中提到的，您可以使用固定大小和动态大小的数据集。上次我们比较了阵列和存储片之间的性能差异。结果相当惊人。如果你还没看过，我推荐你先看<a class="ae kr" href="https://henrysteinhauer.medium.com/fixed-vs-dynamic-sized-data-collections-in-go-1-18-cc45c7c1e61b" rel="noopener"/>。然而，对于本文来说，这不是强制性的。今天，我们要看地图。或者，更具体地说，我们将检查与切片相比，使用自定义键是否会影响性能。</p><h1 id="0528" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">介绍</h1><p id="6bef" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">在第一部分，我们提出了我们的主要问题。我们在上一篇文章中已经回答了第一个。但是，第二个仍然是开放的。</p><ul class=""><li id="13ae" class="ml mm iq ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated">̶s̶̶̶l̶̶̶i̶̶̶c̶̶̶e̶̶̶s̶̶̶̶̶̶v̶̶̶s̶̶̶.̶̶̶ ̶̶̶A̶̶̶r̶̶̶r̶̶̶a̶̶̶y̶̶̶s̶̶̶.̶̶̶̶̶̶w̶̶̶h̶̶̶i̶̶̶c̶̶̶h̶̶̶̶̶̶p̶e̶r̶f̶o̶r̶m̶s̶̶̶̶b̶e̶t̶t̶e̶r̶？̶̶̶</li><li id="d137" class="ml mm iq ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">切片vs贴图！使用自定义键会影响性能吗？</li></ul><h1 id="c206" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">地图与切片</h1><p id="3dcc" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">我为每种情况创建了两个基准测试，以获得更详细的视图。一个用于追加值，一个用于检索其中的一些值。我们现在所做的与第一部分非常相似。我们运行基准测试，将结果保存到一个文件中，并与benchstat进行比较。下面你可以看到它们是如何构成的。</p><h2 id="37b6" class="mz lp iq bd lq na nb dn lu nc nd dp ly lb ne nf ma lf ng nh mc lj ni nj me nk bi translated">地图基准测试</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="5f96" class="mz lp iq bd lq na nb dn lu nc nd dp ly lb ne nf ma lf ng nh mc lj ni nj me nk bi translated">切片基准测试</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9ca4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">丰富数据采集:</strong>因此，我们有两个功能。首先，根据传递给函数的数字，我在我的地图/切片上附加了许多数字。第二个是我实际的基准测试。在这里，我调用第一个函数，并测试用所有数字填充我们的地图/切片需要多长时间。</p><p id="afb5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">从数据集合中检索值:</strong>在我们的第二个基准测试中，我们希望从切片/映射中检索值。因此，正如您在上面看到的，我们有一个数组，其中包含了我们想要检索的所有值。现在我们迭代这个数组，并测量从两个不同的数据集中检索值所需的时间。对于我们的切片，我们迭代我们的数据集，直到找到我们的值。对于我们的地图，我们只需要通过特定的键来访问我们的值。</p><h1 id="0ede" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">比较</h1><p id="87db" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">现在最激动人心的部分来了。我们运行、存储和比较基准。在上一篇文章中，我们看到了数组与切片之间的显著差异。但这次会一样吗？我们会看到的。首先，我们需要运行基准测试。为此，Go为我们提供了一个非常简单的开箱即用的命令。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="7f20" class="mz lp iq no b gy ns nt l nu nv">go test -bench="BenchmarkName" -run=^# -count=x | tee filename.txt</span></pre><h2 id="6a2d" class="mz lp iq bd lq na nb dn lu nc nd dp ly lb ne nf ma lf ng nh mc lj ni nj me nk bi translated">丰富数据集</h2><p id="507c" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">存储结果后，我们可以相互比较。我们从我们的基准开始，在那里我们附加新的值。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="f42a" class="mz lp iq no b gy ns nt l nu nv">benchstat slice.txt map.txt</span></pre><p id="f088" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">你可能已经预料到地图会比切片版本慢很多。但是你意识到区别了吗？如下图所示。对于小数据集来说，它相对来说很小。但是随着数字越来越大，差距会迅速扩大。</p><p id="7f5d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在我们的例子中，这种差异在大约<strong class="ku ir"> 1630% </strong>的峰值。当然，我运行了几次测试，结果几乎相同。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi nw"><img src="../Images/c39f93388f363e1530c833bf7d4d9df5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DUpATaAl3e5bwvYccImJSA.jpeg"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">基准-丰富-地图与切片</p></figure><h2 id="7b40" class="mz lp iq bd lq na nb dn lu nc nd dp ly lb ne nf ma lf ng nh mc lj ni nj me nk bi translated">从数据集中检索值</h2><p id="5d99" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">现在是我们第二次基准测试的时候了。请记住，在这种情况下，我们从地图/切片中检索值。下面我们看到的可能是你们大多数人已经预料到的。我们的地图复杂度为O(1)，而我们的切片复杂度为O(n)。这意味着，在这种情况下，映射总是花费相同的时间，而从我们的切片中检索值的时间取决于需要首先迭代的数字的数量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi nw"><img src="../Images/e2c493ff2d710234704b83f39376c9dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GioXTX6jHxJjqHkR5bJ3OQ.jpeg"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">基准—检索—映射与切片</p></figure><h1 id="9716" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">外卖食品</h1><p id="2f64" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">我知道。往往使用贴图或者切片只是必要或者更干净。但是如果你有选择的话，要意识到性能差异。一般来说:<em class="ob">“你的数据集越大，在添加或检索新值时性能差异就越大。”</em></p><h1 id="c3ec" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">最后的想法</h1><p id="c399" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">这是“固定大小与动态大小的数据收集”的第二部分我希望这个比较是有趣的，并且你学到了一些新的东西。如果你有什么要提的或者有什么问题，如果你能在评论里留下来，那就太好了。回头见。</p><p id="6cfe" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">附言</strong>本文是我当前系列的一部分。在接下来的时间里，我将介绍各种通用的助手函数、有趣的基准和有用的特性。</p><p id="d479" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果你和我一样兴奋，敬请期待！</p></div></div>    
</body>
</html>