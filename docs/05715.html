<html>
<head>
<title>Safe State Machines in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的安全状态机</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/safe-state-machines-in-swift-a6e9119ef97c?source=collection_archive---------4-----------------------#2020-07-30">https://betterprogramming.pub/safe-state-machines-in-swift-a6e9119ef97c?source=collection_archive---------4-----------------------#2020-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5942" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用枚举安全键入</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5fd16326d73deb38b365ddc3eb427574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TYWY7ytqtwuZTefA"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">伊利亚·巴甫洛夫在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="291b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">状态机是许多Swift开发人员喜欢、使用和撰写的一种模式。</p><p id="d502" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Swift的枚举和相关类型使它们比其他编程语言更安全。但是我们怎样才能让它们尽可能的安全呢？</p><p id="a410" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">状态机可以被认为是一种数据结构，它可以处于不同的状态，并且只允许状态之间的某些转换。</p><p id="21da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果你有一个电脑游戏，点击主菜单中的“单人游戏”，你很可能不会立即开始游戏，但你会进入一些配置屏幕，然后可能是加载屏幕，只有这样你才能进入游戏。</p><p id="eeae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，你不会在“你赢了”的状态下开始游戏但是你必须真正地演奏它。而且如果游戏是回合制，招式不是所有人同时下的，很可能会有你根本什么都做不了的时候(就游戏逻辑而言)。</p><p id="c3f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">状态机的主要目的是在允许进行哪种转换时封装逻辑。</p><p id="92d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Swift开发人员已经就此撰写了大量文章。例如，参见Swift 中的<a class="ae kv" href="https://levelup.gitconnected.com/state-machine-in-swift-8687673f5df6" rel="noopener ugc nofollow" target="_blank">状态机或Swift </a>中最简单的状态机<a class="ae kv" href="https://albertodebortoli.com/2018/12/16/the-easiest-state-machine-in-swift/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="a85b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些解决方案已经满足了无效调用不做任何事情的基本要求。然而，转换仍然是公开的，因此，如果为您的应用程序编写视图的程序员不知道哪些转换是有效的或无效的，他们可能仍然会向用户显示按钮，这些按钮不做任何事情，而不会让用户在视觉上很明显。</p><p id="da2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题可以通过<a class="ae kv" href="https://lukematthewsutton.com/post/type-safe-state-machines/" rel="noopener ugc nofollow" target="_blank">类型安全状态机</a>解决。</p><p id="e2a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这带来了一个更糟糕的问题:为了存储它们，你必须删除它们的类型，最有可能的是<code class="fe ls lt lu lv b">Any</code>。</p><p id="6408" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然它们是一个很好的玩具，但是一旦你试图用它们做任何实际的事情，所有的安全都失去了。此外，在这个版本中使用enum本身的事实意味着您一次只能进行一次转换，而不是触发一系列转换。</p><p id="51a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我真的想两全其美，我想我找到了一个合理的解决方案，我想在这里分享。</p><p id="c051" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，如果我们想要每个转换触发进一步转换的能力，我们将不得不使用一些<code class="fe ls lt lu lv b">Controller</code>类。所以让我们继续写一个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="63f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在这里使用SwiftUI的<code class="fe ls lt lu lv b">Published</code>和<code class="fe ls lt lu lv b">ObservableObject</code>，但是如果您正在处理非SwiftUI视图，您也可以使用传统的委托模式或<code class="fe ls lt lu lv b">NotificationCenter</code>。</p><p id="c6d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一般规则，我将调用我想要操作的变量<code class="fe ls lt lu lv b">state</code>，将其设为私有，并使用属性观察器在主队列上发布对它的更改——因为只允许在主队列上发布。不过，我们不会在这里使用任何其他队列。</p><p id="6d31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能还注意到<code class="fe ls lt lu lv b">state</code>和<code class="fe ls lt lu lv b">publicState</code>是隐式展开的可选的。我们以后会明白为什么会这样。</p><p id="b284" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们继续定义我们的状态机的状态:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="4884" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，这类似于《生活大爆炸》中的<a class="ae kv" href="https://bigbangtheory.fandom.com/wiki/The_Friendship_Algorithm" rel="noopener ugc nofollow" target="_blank">友谊算法</a>。</p><p id="85f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在棘手的部分来了:我们到底如何添加动作，使得它们只有在正确的情况下才可用？嗯，最明显和简单的方法是将闭包附加到枚举用例上:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="5074" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们确切地知道在每个状态下我们有哪些选择。除了一个问题:我们还没有绑定动作！它们只是随机的闭包，它们做什么将在运行时决定。如何解决这个问题？</p><p id="27a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们回到编写<code class="fe ls lt lu lv b">Controller</code>类的文件。我们要做的第一件事是为枚举中的每个闭包添加空方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="20ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在实现它们之前，我们现在将确保我们的状态机实际上已经初始化。</p><p id="4e9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也就是说，将以下初始化器添加到控制器中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="d9f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你可以明白为什么<code class="fe ls lt lu lv b">state</code>是一个隐式展开的可选变量:如果我们要求<code class="fe ls lt lu lv b">state</code>从一开始就被定义，那么编译器就会抱怨self在所有存储的属性被初始化之前就被使用了。我们刚刚绕过了这个。</p><p id="da0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，在start方法中，我们添加以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="0ec7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们在<code class="fe ls lt lu lv b">start</code>方法中封装了一个随机化的状态转换。只有两种可能的状态可以结束，句号！</p><p id="a08a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们将赋予<code class="fe ls lt lu lv b">askShareAMeal</code>和<code class="fe ls lt lu lv b">leaveMessage</code>意义。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="4240" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，我们在<code class="fe ls lt lu lv b">leaveMessage</code>中做的第一件事就是让用户进入等待状态，不附加任何动作。我们的控制器在回调发生时接管控制权。这将在随机时间之后发生，该时间与以文字表示的左消息的长度成比例。</p><p id="ead3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种方法再次封装了随机化的状态转换。</p><p id="2a41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到现在为止，我们实际上已经得到了一些终端箭头。如果我们潜在的朋友想和我们一起吃饭，我们就完了！</p><p id="d96a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果他们不想和我们一起吃饭，而是想喝一杯热饮，情况也是如此。我们还没有新朋友的唯一情况是，他们既不想和我们一起吃饭，也不想喝饮料:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6b75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要升级要求其他娱乐活动。我们将要求我们的潜在朋友说出一个兴趣，并将该提议与我们的兴趣进行比较。如果我们喜欢我们听到的，我们会分享兴趣，否则，我们会再问。参与兴趣爱好会带来友谊。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="eb28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，将所有可能的转换封装到enum本身非常容易。</p><p id="bb7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，如果您为每个enum用例编写专用的视图，几乎不可能意外地向用户公开一个无效的方法。所有必要的运行时检查都可以在控制器层完成，同时您的视图可以对其状态的正确性相当有信心，因为您总是可以从<code class="fe ls lt lu lv b">Published</code>属性包装器中获得哪些方法是有效的最新信息(以及您的视图所需的所有数据)。</p><p id="d857" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出错的唯一方法是将闭包转义并存储在其他地方，但是这样会有明显的代码味道，你宁愿更改枚举。</p><p id="c6b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的代码可以在<a class="ae kv" href="https://github.com/AnarchoSystems/StateMachine" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><div class="ly lz gp gr ma mb"><a href="https://github.com/AnarchoSystems/StateMachine" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd ir gy z fp mg fr fs mh fu fw ip bi translated">无政府系统/国家机器</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">在GitHub上创建一个帐户，为AnarchoSystems/StateMachine开发做贡献。</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">github.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp kp mb"/></div></div></a></div><p id="b918" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">挑战:</p><ol class=""><li id="7741" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">如您所见，<code class="fe ls lt lu lv b">agreeToInterest</code>方法是唯一真正读取当前状态的方法。如果你想为你的方法提供更好的保护(也就是说，如果你处于错误的状态，不要做任何事情)，这样做可能是个好主意。尤其是当多个进程可以操作状态时，您可能希望读取状态。然而，我们的例子非常简单，您甚至可以消除这个读操作。怎么会？提示:我们的控制器的方法不需要和枚举中的闭包有完全相同的签名。</li><li id="ed7a" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><code class="fe ls lt lu lv b">Interest</code>枚举只有一种情况。案例越多，算法越有意义。理想情况下，每个选项你只需要提议一次。如果控制器用完了选项，您可能还想处理这种情况。</li><li id="5044" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">将已经向用户提出的所有兴趣传递回去，以便他们可以决定打破可能的长循环。</li></ol><p id="1294" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编码快乐！</p></div></div>    
</body>
</html>