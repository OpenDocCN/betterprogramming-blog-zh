<html>
<head>
<title>What’s New in Node.js 15</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js 15的新特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-node-js-15-fc24e87e2590?source=collection_archive---------3-----------------------#2021-01-05">https://betterprogramming.pub/whats-new-in-node-js-15-fc24e87e2590?source=collection_archive---------3-----------------------#2021-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9c41" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Node.js 15新特性的详细信息，包括抛出未处理的拒绝和V8 8.6语言特性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f13595b53e5c7bda966d01d9af7fe222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ypKwBNyZd-kergC_osQFA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="908b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://nodejs.org/en/blog/release/v15.0.0/" rel="noopener ugc nofollow" target="_blank"> Node.js 15 </a>发布于2020年10月20日。它有许多主要特性:</p><ul class=""><li id="318f" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">抛出未处理的拒绝</li><li id="409a" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">V8 8.6语言功能</li><li id="5a46" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://medium.com/better-programming/the-step-by-step-guide-to-understanding-and-adopting-npm-7-914504f7090f" rel="noopener"> NPM 7 </a></li><li id="071c" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">QUIC的实验支持</li><li id="a5f4" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">N-API版本7</li><li id="7fdf" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">异步本地存储API的改进</li></ul><p id="8074" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来探索它们是什么以及如何使用它们。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9ef2" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">使用NVM浏览节点</h1><p id="e6bd" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">在<a class="ae lu" href="https://medium.com/better-programming/use-nvm-to-manage-node-js-and-npm-versions-2bd0d0875f9f" rel="noopener">之前的一篇文章</a>中，我们提供了关于使用<a class="ae lu" href="https://github.com/nvm-sh/nvm" rel="noopener ugc nofollow" target="_blank"> NVM(节点版本管理器)</a>管理Node.js和NPM版本的说明。在我们的环境中，我们安装了Node.js <code class="fe nn no np nq b">12.16.0</code>和NPM <code class="fe nn no np nq b">6.14.8</code>。通过运行<code class="fe nn no np nq b">nvm install node</code>，我们安装了Node.js <code class="fe nn no np nq b">15.4.0</code>和NPM <code class="fe nn no np nq b">7.0.15</code>。</p><p id="8b7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们打开了两个窗口，一个设置为Node.js 12，另一个设置为Node.js 15。</p><p id="d7e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe nn no np nq b">node12</code>窗口上:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="dd33" class="nv mr it nq b gy nw nx l ny nz">$ nvm use 12<br/>Now using node v12.16.0 (npm v6.14.8)</span></pre><p id="acba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe nn no np nq b">node15</code>窗口上:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="e88b" class="nv mr it nq b gy nw nx l ny nz">$ nvm use 15<br/>Now using node v15.4.0 (npm v7.0.15)</span></pre><p id="4a59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们准备探索。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="de8d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">抛出未处理的拒绝</h1><p id="d6e4" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">每当一个承诺被拒绝，并且在事件循环的一个循环中没有错误处理程序附加到该承诺时，就会发出<code class="fe nn no np nq b">unhandledRejection</code>事件。从Node.js 15开始，<code class="fe nn no np nq b">unhandledRejection</code>的默认模式从<code class="fe nn no np nq b">warn</code>更改为<code class="fe nn no np nq b">throw</code>。在<code class="fe nn no np nq b">throw</code>模式下，如果未设置<code class="fe nn no np nq b">unhandledRejection</code>挂钩，则<code class="fe nn no np nq b">unhandledRejection</code>会作为未捕获的异常出现。</p><p id="72ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建一个程序，使承诺被拒绝，并显示一条错误消息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="721e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您在<code class="fe nn no np nq b">node12</code>窗口上运行此代码时，它会显示一条很长的警告消息:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="ded7" class="nv mr it nq b gy nw nx l ny nz">$ node myPromise.js<br/>(node:79104) UnhandledPromiseRejectionWarning: #&lt;Object&gt;<br/>(node:79104) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see <a class="ae lu" href="https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode</a>). (rejection id: 1)<br/>(node:79104) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.Users that have an <!-- -->unhandledRejection<!-- --> hook should see no change in behavior, and it’s still possible to switch modes using the <!-- -->--unhandled-rejections=mode<!-- --> process flag.</span></pre><p id="3590" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe nn no np nq b">node15</code>窗口上运行这段代码，它抛出错误<code class="fe nn no np nq b">UnhandledPromiseRejection</code>:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="2754" class="nv mr it nq b gy nw nx l ny nz">$ node myPromise.js<br/>node:internal/process/promises:227<br/>          triggerUncaughtException(err, true /* fromPromise */);<br/>          ^</span><span id="9d31" class="nv mr it nq b gy oc nx l ny nz">[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason "#&lt;Object&gt;".] {<br/>  code: 'ERR_UNHANDLED_REJECTION'<br/>}</span></pre><p id="579d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面代码的<code class="fe nn no np nq b">then</code>子句中添加一个错误处理程序(<code class="fe nn no np nq b">.catch((</code>错误<code class="fe nn no np nq b">) =&gt; console.log(</code>错误<code class="fe nn no np nq b">.error))</code>也可以)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="10ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，代码可以在<code class="fe nn no np nq b">node12</code>和<code class="fe nn no np nq b">node15</code>窗口上正确运行:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="dbf6" class="nv mr it nq b gy nw nx l ny nz">$ node myPromise.js<br/>The call is rejected with an error</span></pre><p id="4680" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最佳实践是为承诺编写一个错误处理程序。但是，会有没有捕捉到错误的情况。设置<code class="fe nn no np nq b"><a class="ae lu" href="https://nodejs.org/api/process.html#process_event_unhandledrejection" rel="noopener ugc nofollow" target="_blank">unhandledRejection</a></code> <a class="ae lu" href="https://nodejs.org/api/process.html#process_event_unhandledrejection" rel="noopener ugc nofollow" target="_blank">钩子</a>来捕捉潜在的错误是个好主意。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="bbd6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nn no np nq b">unhandledRejection</code>钩子对Node.js 12和Node.js 15都有效。有了那个设定，<code class="fe nn no np nq b">unhandledRejection</code>就可以妥善处理了。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="7660" class="nv mr it nq b gy nw nx l ny nz">$ node myPromise.js<br/>reason is { error: 'The call is rejected with an error' }<br/>promise is Promise { &lt;rejected&gt; { error: 'The call is rejected with an error' } }</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="164e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">V8 8.6语言功能</h1><p id="4e57" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">V8 JavaScript引擎已从8.4更新到8.6。除了性能调整和改进，V8更新还带来了以下语言特性:</p><ul class=""><li id="a872" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><code class="fe nn no np nq b">Promise.any()</code>和<code class="fe nn no np nq b">AggregateError</code>(从V8 8.5开始)</li><li id="616a" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><code class="fe nn no np nq b">await setTimeout</code>和<code class="fe nn no np nq b">AbortController</code>(实验)</li><li id="c1f4" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><code class="fe nn no np nq b">String.prototype.replaceAll()</code>(来自V8 8.5)</li><li id="deb5" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">逻辑赋值运算符<code class="fe nn no np nq b">&amp;&amp;=</code>、<code class="fe nn no np nq b">||=</code>和<code class="fe nn no np nq b">??=</code>(来自V8 8.5)</li></ul><h2 id="4846" class="nv mr it bd ms od oe dn mw of og dp na lh oh oi nc ll oj ok ne lp ol om ng on bi translated">Promise.any()和AggregateError</h2><p id="d1e8" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">首先，我们来看看现有的<code class="fe nn no np nq b">Promise.all()</code>方法。</p><p id="fb0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nn no np nq b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank">Promise.all()</a></code>将可迭代的承诺作为输入，并返回一个承诺，该承诺解析为输入承诺的结果数组。</p><p id="b61b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下程序对两个已解决的承诺调用<code class="fe nn no np nq b">Promise.all()</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="b486" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当所有输入的承诺都已解析时，或者如果输入iterable不包含承诺，则<code class="fe nn no np nq b">Promise.all()</code>返回的承诺将被解析:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="5129" class="nv mr it nq b gy nw nx l ny nz">$ node myPromise.js<br/>[<br/>  { data: 'The data from 5000 ms delay' },<br/>  { data: 'The data from 100 ms delay' }<br/>]</span></pre><p id="d5b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的程序对两个被拒绝的承诺调用<code class="fe nn no np nq b">Promise.all()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="7830" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nn no np nq b">Promise.all()</code>立即拒绝任何输入的承诺拒绝或非承诺抛出错误，并将拒绝第一个拒绝消息或错误:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="871c" class="nv mr it nq b gy nw nx l ny nz">$ node myPromise.js<br/>{ error: 'The error from 100 ms delay' }</span></pre><p id="031b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nn no np nq b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any" rel="noopener ugc nofollow" target="_blank">Promise.any()</a></code>是Node.js 15中新增的。这是<code class="fe nn no np nq b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank">Promise.all()</a></code>的反义词。它接受一个可迭代的承诺，一旦可迭代承诺中的一个承诺实现，就返回一个承诺，该承诺的值将被解析。</p><p id="b4b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的程序对两个已解决的承诺调用<code class="fe nn no np nq b">Promise.any()</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="05d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nn no np nq b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any" rel="noopener ugc nofollow" target="_blank">Promise.any()</a></code>返回第一个已解决的承诺:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="469c" class="nv mr it nq b gy nw nx l ny nz">$ node myPromise.js<br/>{ data: 'The error from 100 ms delay' }</span></pre><p id="ba80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的程序对两个被拒绝的承诺调用<code class="fe nn no np nq b">Promise.any()</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="5521" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果iterable中没有承诺被履行——即所有给定的承诺都被拒绝——返回的承诺将被拒绝，并带有一个<code class="fe nn no np nq b">AggregateError</code>,它是<code class="fe nn no np nq b">Error</code>的一个新子类，将各个错误组合在一起。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="dbd6" class="nv mr it nq b gy nw nx l ny nz">$ node myPromise.js<br/>[AggregateError: All promises were rejected]<br/>[<br/>  { error: 'The error from 5000 ms delay' },<br/>  { error: 'The error from 100 ms delay' }<br/>]</span></pre><h2 id="bc8e" class="nv mr it bd ms od oe dn mw of og dp na lh oh oi nc ll oj ok ne lp ol om ng on bi translated">等待setTimeout和AbortController</h2><p id="2c0c" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">在前面的例子中，我们在promise调用中使用了<code class="fe nn no np nq b">setTimeout</code>。<code class="fe nn no np nq b">WindowOrWorkerGlobalScope</code>的<code class="fe nn no np nq b">setTimeout</code>使用回调。然而，<code class="fe nn no np nq b">timers/promises</code>提供了<code class="fe nn no np nq b">setTimeout</code>的一个有前途的版本，可以和async/await一起使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="cde9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nn no np nq b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController" rel="noopener ugc nofollow" target="_blank">AbortController</a></code>是一个JavaScript对象，允许我们根据需要中止一个或多个web请求。我们以<a class="ae lu" href="https://medium.com/better-programming/the-power-and-convenience-of-useasync-e4a3e4934143" rel="noopener">使用同步</a>为主题给出了如何使用<code class="fe nn no np nq b">AbortController</code>的例子。</p><p id="53ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nn no np nq b">await setTimeout</code>和<code class="fe nn no np nq b">AbortController</code>都是实验特征。</p><h2 id="4993" class="nv mr it bd ms od oe dn mw of og dp na lh oh oi nc ll oj ok ne lp ol om ng on bi translated">String.prototype.replaceAll()</h2><p id="d397" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">首先，我们来看看现有的<code class="fe nn no np nq b">String.prototype.replace()</code>方法。</p><p id="a141" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nn no np nq b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace" rel="noopener ugc nofollow" target="_blank">replace()</a></code>返回一个新字符串，其中某个模式的部分或全部匹配被替换。模式可以是字符串或正则表达式。替换可以是一个字符串，也可以是每次匹配时调用的函数。</p><p id="e331" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果模式是一个字符串，只有第一个匹配项会被替换。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="a855" class="nv mr it nq b gy nw nx l ny nz">'20+1+2+3'.replace('+', '-');</span></pre><p id="48e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">执行上述语句将产生<code class="fe nn no np nq b">“20–1+2+3”</code>。</p><p id="cad9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了用<code class="fe nn no np nq b">‘-’</code>替换所有的<code class="fe nn no np nq b">‘+'</code>，必须使用一个正则表达式。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="2a88" class="nv mr it nq b gy nw nx l ny nz">'20+1+2+3'.replace(/\+/g, '-');</span></pre><p id="c1c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">执行上面的语句会产生<code class="fe nn no np nq b">“20–1-2-3”</code>。</p><p id="1701" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nn no np nq b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll" rel="noopener ugc nofollow" target="_blank">replaceAll()</a></code>是Node.js 15中的新特性，可以避免使用正则表达式。它返回一个新的字符串，其中所有与某个模式匹配的<em class="oo">都被替换掉了。模式可以是字符串或正则表达式，替换可以是字符串或每次匹配都要调用的函数。</em></p><p id="9894" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了<code class="fe nn no np nq b">replaceAll()</code>，我们不必使用正则表达式将所有的<code class="fe nn no np nq b">‘+'</code>替换为<code class="fe nn no np nq b">‘-’</code>。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="c2d5" class="nv mr it nq b gy nw nx l ny nz">'20+1+2+3'.replaceAll('+', '-');</span></pre><p id="25d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">执行上述语句将产生<code class="fe nn no np nq b">“20–1-2-3”</code>。</p><h2 id="cd5a" class="nv mr it bd ms od oe dn mw of og dp na lh oh oi nc ll oj ok ne lp ol om ng on bi translated">逻辑赋值运算符&amp;&amp;=、||=和？？=</h2><p id="8312" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">Node.js 15中增加了一些逻辑赋值操作符。</p><p id="993c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND_assignment" rel="noopener ugc nofollow" target="_blank">逻辑AND赋值</a> ( <code class="fe nn no np nq b">x &amp;&amp;= y</code>)运算符仅在<code class="fe nn no np nq b">x</code>为真时赋值。<code class="fe nn no np nq b">x &amp;&amp;= y</code>等同于<code class="fe nn no np nq b">x &amp;&amp; (x = y)</code>，不等同于<code class="fe nn no np nq b">x = x &amp;&amp; y</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="e656" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR_assignment" rel="noopener ugc nofollow" target="_blank">逻辑OR赋值</a> ( <code class="fe nn no np nq b">x ||= y</code>)运算符仅在<code class="fe nn no np nq b">x</code>为假时赋值。<code class="fe nn no np nq b">x ||= y</code>等同于<code class="fe nn no np nq b">x || (x = y)</code>，不等同于<code class="fe nn no np nq b">x = x || y</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="aae2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_nullish_assignment" rel="noopener ugc nofollow" target="_blank">逻辑无效赋值</a> ( <code class="fe nn no np nq b">x ??= y</code>)运算符仅在<code class="fe nn no np nq b">x</code>为无效(<code class="fe nn no np nq b">null</code>或<code class="fe nn no np nq b">undefined</code>)时赋值。<code class="fe nn no np nq b">x ??= y</code>相当于<code class="fe nn no np nq b">x ?? (x = y)</code>，不等同于<code class="fe nn no np nq b">x = x ?? y</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="459b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">其他变化</h1><p id="8e8c" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">除了抛出未处理的拒绝和V8 8.6语言特性，Node.js 15还有以下变化:</p><ul class=""><li id="3a5e" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><strong class="la iu"> NPM 7 </strong>:有很多变化，包括对等依赖自动安装，包和线程锁文件增强，工作区支持等等。这在<a class="ae lu" href="https://medium.com/better-programming/the-step-by-step-guide-to-understanding-and-adopting-npm-7-914504f7090f" rel="noopener">另一篇文章</a>中有记载。</li><li id="d7a9" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu">QUIC</strong>:UDP传输协议的实验性支持，它是HTTP/3的底层传输协议。它具有TLS 1.3、流量控制、纠错、连接迁移和多路复用的内置安全性。</li><li id="7bbc" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu"> N-API版本7 </strong>:用于构建原生插件的API。独立于底层JavaScript运行时，并作为Node.js本身的一部分进行维护。</li><li id="b465" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu">异步本地存储API的改进</strong>:为大规模应用提供更复杂的日志记录和分析功能。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c798" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="e1eb" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">Node.js 15有很多新的特性和改进，包括突破性的改变。</p><p id="bf44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想了解更新的版本，可以看看下面的文章:</p><ul class=""><li id="5e6f" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/6-major-features-of-node-js-19-b98e28b9670c">node . js 19的6大特色</a></li><li id="ac89" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/5-major-features-of-node-js-18-5f4a164cc9fc">node . js18的5大特色</a></li><li id="a19d" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/3-major-features-of-node-js-17-4bee7135df02">node . js 17的3大特色</a></li><li id="3cd1" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/a-quick-look-at-the-node-js-16-features-d616e8b2f29">快速浏览Node.js 16特性</a></li></ul><p id="1151" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。我希望这有所帮助。如果你有兴趣，可以看看<a class="ae lu" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener">我的其他媒体文章</a>。</p></div></div>    
</body>
</html>