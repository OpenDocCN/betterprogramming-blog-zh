<html>
<head>
<title>How To Disassemble Python Code and Improve It for Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何反汇编Python代码并提高性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-disassemble-python-code-and-improve-it-for-performance-76255a0318d0?source=collection_archive---------6-----------------------#2021-06-30">https://betterprogramming.pub/how-to-disassemble-python-code-and-improve-it-for-performance-76255a0318d0?source=collection_archive---------6-----------------------#2021-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2f9a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用几行代码优化您的Python代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/03edcc733e904df377cec4f44e4621db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EVAWBuMfIh5HbULe"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Nathan Dumlao 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="bbe1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写工作代码是一回事。编写优化的工作代码是另一个例子。在某些情况下，你真的不想花时间优化。让你的十行代码完成<em class="lv"> 0.001秒</em>可能没什么用。</p><p id="2d8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是优化整个项目呢？我们必须承认，在生产环境中工作时，我们的代码需要尽可能地优化。只有在测试环境中，每50-100行花些时间来增强它，才有可能做到这一点。</p><p id="8912" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果导致不明显延迟的代码在一个<code class="fe lw lx ly lz b">for</code>或<code class="fe lw lx ly lz b">while</code>循环中呢？这意味着每次执行<code class="fe lw lx ly lz b">for</code>和<code class="fe lw lx ly lz b">while</code>循环时，您都必须将延迟乘以，导致更大的延迟和内存消耗。</p><p id="6e5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么每个开发人员都应该尽快学会提高他们的代码性能。</p><p id="f897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将向您展示如何:</p><ol class=""><li id="3b86" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">反汇编您的Python代码。</li><li id="3d3b" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">找到并替换可以优化的代码行和流程。</li></ol><p id="d9d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需要再多几行代码来反汇编代码，以便对指令有一个很好的概述，并花几分钟时间来思考使用什么来提高性能。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="aeeb" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">反汇编您的Python代码</h1><p id="f6d7" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">反汇编在优化的时候真的很有用。它给人的眼睛一个清晰的概述，许多指令用在你写的每一行代码中。</p><p id="22b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一步为您提供了评估某个代码片段是否可以在性能方面得到增强所需的一切。</p><p id="1781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用Python的<code class="fe lw lx ly lz b"><a class="ae ky" href="https://docs.python.org/3/library/dis.html" rel="noopener ugc nofollow" target="_blank">dis</a></code>模块反汇编我们的代码。</p><p id="cf15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是反汇编一个简单函数的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="cf51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们导入了<code class="fe lw lx ly lz b">dis</code>模块，然后调用<code class="fe lw lx ly lz b">dis()</code>方法反汇编<code class="fe lw lx ly lz b">my_very_special_function</code>。记住不要包括圆括号。我们不调用这个函数。</p><p id="0e5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="fc60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要了解这个输出是什么:</p><ul class=""><li id="acfa" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu nu mg mh mi bi translated">第一列:代码中相应的行号</li><li id="c655" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu nu mg mh mi bi translated">第二列:相应的字节索引</li><li id="46e3" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu nu mg mh mi bi translated">第三列:<code class="fe lw lx ly lz b">opname</code>，操作的可读名称</li><li id="9a69" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu nu mg mh mi bi translated">第四列:指令的参数</li><li id="4b71" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu nu mg mh mi bi translated">第五列:指令的可读参数</li></ul><p id="b813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，根据功能的不同，可能会多两列。更深入的解释，参考<a class="ae ky" href="https://stackoverflow.com/a/47529318/13532837" rel="noopener ugc nofollow" target="_blank">本栈溢出答案</a>。</p><p id="c931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以反汇编类——不仅仅是函数。将该模块作为CLI参数(<code class="fe lw lx ly lz b">-m dis</code>)调用也使您能够反汇编整个代码。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="5bd3" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">查找和替换可优化的流程</h1><p id="fdd4" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们知道如何分解我们的函数和类。现在我们需要更深入地挖掘反汇编代码，并对其进行优化。</p><p id="b750" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反汇编代码的关键点是查看在运行时执行了哪些指令以及有多少指令。这样，你就可以比较做同样事情的不同代码，看哪一个执行的指令最少。</p><p id="ad3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意:在本文中，您将了解到更少的指令并不总是意味着更好的性能。</em></p><h2 id="1231" class="nv mw it bd mx nw nx dn nb ny nz dp nf li oa ob nh lm oc od nj lq oe of nl og bi translated">字典与许多if和elifs</h2><p id="489d" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">举个例子，让我们用一个我之前文章里的小技巧，<a class="ae ky" href="https://medium.com/p/5486299af27e?source=post_stats_page-------------------------------------" rel="noopener">Python中If-Elif条件太多？使用字典代替</a>。在那里，我将讨论Python字典如何优化众多的<code class="fe lw lx ly lz b">ifs</code>和<code class="fe lw lx ly lz b">elifs</code>。现在，让我们看看在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/too-many-if-elif-conditions-in-python-use-dictionaries-instead-5486299af27e?source=your_stories_page-------------------------------------">文章</a>中讨论的两个实现之间的区别。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="7895" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，在第42行和第46行，我们正在分解这两个函数。一个用四个<code class="fe lw lx ly lz b">ifs</code>和<code class="fe lw lx ly lz b">elifs</code>，另一个用字典。你可以在我的上一篇文章中得到关于这个符号的深入解释。然后在第48行和第52行，我展示了这两个函数做同样的工作。</p><p id="5dae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行该文件时，我们得到以下输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="cd9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会看到字典模式需要的指令更少。例如，它不需要每次都加载以下内容:</p><ul class=""><li id="b319" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu nu mg mh mi bi translated">与<code class="fe lw lx ly lz b">u_in</code>比较的常数(<code class="fe lw lx ly lz b">1,2,3,4</code>)</li><li id="c77c" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu nu mg mh mi bi translated">比较运算符(<code class="fe lw lx ly lz b">==</code>)</li><li id="8de1" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu nu mg mh mi bi translated">全局函数(<code class="fe lw lx ly lz b">say_hello</code>)</li></ul><p id="98a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，如果我们测试两个函数的执行时间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="44b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到<code class="fe lw lx ly lz b">dict_mode</code>总是获得较低的执行时间:</p><pre class="kj kk kl km gt oh lz oi oj aw ok bi"><span id="2e93" class="nv mw it lz b gy ol om l on oo">Hello 2<br/>3.0994415283203125e-06 seconds<br/>++++++++++++++++++++++++<br/>Hello 2<br/>2.6226043701171875e-06 seconds</span></pre><p id="900d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但那是<em class="lv">而不是</em> <strong class="lb iu"> </strong>赢在哪里。事实上，使用<code class="fe lw lx ly lz b">timeit</code>模块，我得到了一些奇怪的结果(记得用<code class="fe lw lx ly lz b">import timeit</code>导入):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="52d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做，我们看到字典模式几乎总是优于<code class="fe lw lx ly lz b">ifs</code>和<code class="fe lw lx ly lz b">elifs</code>模式。</p><p id="537f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当在更大范围内(例如<code class="fe lw lx ly lz b">1000</code>)应用这个测试时，结果会有更多的变化。例如，在第一次执行中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="dfe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二次执行时:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="64dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，拥有最少的指令并不总是意味着更好的时间性能。</p><p id="7751" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个<a class="ae ky" href="https://stackoverflow.com/a/57004292/13532837" rel="noopener ugc nofollow" target="_blank">很棒所以答案</a>通过比较<code class="fe lw lx ly lz b">+</code>运算符和<code class="fe lw lx ly lz b">.__add__</code>方法证明了这一点。</p><p id="e943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，总是测试什么对你的程序更有效。例如，您可以通过使用<code class="fe lw lx ly lz b">timeit</code>模块来完成此操作。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="024e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了作为优化代码的一种简化方式，反汇编还可以让你更好地理解你写的每一行代码实际上发生了什么。例如，您可以了解列表理解是如何工作的，与典型的<code class="fe lw lx ly lz b">for</code>循环相比有什么变化，但主要是为什么它们实际上更有性能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="9600" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe lw lx ly lz b">add_compr()</code>使用列表理解，而<code class="fe lw lx ly lz b">add_for()</code>使用传统的<code class="fe lw lx ly lz b">for</code>循环。执行脚本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ae0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是列表理解的实际分解:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="fe32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你看到它没有加载globals(list)，methods ( <code class="fe lw lx ly lz b">append</code> method)，也不需要<code class="fe lw lx ly lz b">n</code>，因此没有加载和存储。但是与传统的<code class="fe lw lx ly lz b">append()</code> <em class="lv"> </em>方法相比，真正的优化主要在<code class="fe lw lx ly lz b">LIST_APPEND</code>字节码中。</p><p id="b2ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，我们在list comprehension中的执行时间比在<code class="fe lw lx ly lz b">for</code>循环中要低(记得之前通过<code class="fe lw lx ly lz b">import time</code>导入时间模块):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="d4e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是:</p><pre class="kj kk kl km gt oh lz oi oj aw ok bi"><span id="1455" class="nv mw it lz b gy ol om l on oo">Using traditional for loop<br/>5.9604644775390625e-06 seconds</span><span id="2df1" class="nv mw it lz b gy op om l on oo">Using list comprehensions<br/>2.86102294921875e-06 seconds</span></pre><p id="f1ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，在我所有的测试中，对列表的理解总是更快。</p><p id="f26a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，<code class="fe lw lx ly lz b">dis</code>模块帮助你理解哪个版本的代码更快，但主要是<em class="lv">为什么</em>它更快。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="682f" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">结论</h1><p id="a481" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">现在，您已经了解了如何反汇编Python代码，以及它为什么以及如何对以下方面有用:</p><ul class=""><li id="35e1" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu nu mg mh mi bi translated">优化您的代码。</li><li id="8690" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu nu mg mh mi bi translated">对Python的工作原理有了更深入的理解。</li></ul><p id="97ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这是有帮助的，即使大多数中级-高级程序员可能已经知道这一点。还有，我用<code class="fe lw lx ly lz b">dis</code>模块也有一段时间了，我觉得我对它很有了解。但是每个人都会犯错。如果你在这里发现了什么，请评论，我会尽力改正的。</p></div></div>    
</body>
</html>