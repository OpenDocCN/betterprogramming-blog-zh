<html>
<head>
<title>Address These 5 Questions to Understand Python Logging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决这5个问题来理解Python日志记录</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/address-these-5-questions-to-understand-python-logging-e8a45718819?source=collection_archive---------2-----------------------#2020-11-20">https://betterprogramming.pub/address-these-5-questions-to-understand-python-logging-e8a45718819?source=collection_archive---------2-----------------------#2020-11-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="de34" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当您不应该将打印用于记录目的时</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b2c36c33a0eaf22b6eef0c7067bc229d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wLu3bx5ZBzhwRisR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@virussinside?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Artiom Vallat </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="7eba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">软件开发中最令人沮丧的事情是调试一个无法重现的问题。您可能不得不依靠一些不太懂技术的最终用户的各种轶事描述来猜测发生了什么——如果您在交付软件之前没有正确设置日志记录。但是，如果您碰巧有足够的日志信息可以帮助您跟踪问题的根源，那么消除bug可能会花费更少的时间。</p><p id="e63a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将讨论您在Python项目中登录时可能会遇到的五个问题。本文的重点将是内置的日志模块。看完这篇文章，希望你对Python中适当的日志记录有一个合理的认识。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cf62" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.它为什么不使用snake_case命名约定？</h1><p id="8475" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">众所周知，<a class="ae ky" href="https://www.python.org/dev/peps/pep-0008/" rel="noopener ugc nofollow" target="_blank"> PEP 8 </a>规定了我们应该如何在Python中命名事物。本质上，这就是所谓的“snake_case”命名约定。例如，我们有一个发送消息的函数。蟒名应该是<code class="fe mz na nb nc b">send_message</code>。然而，其他一些语言使用camelCase作为函数名。在这种情况下，函数应该命名为<code class="fe mz na nb nc b">sendMessage</code>。</p><p id="926a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与标准库中的其他模块不同，<code class="fe mz na nb nc b"><a class="ae ky" href="https://docs.python.org/3/library/logging.html" rel="noopener ugc nofollow" target="_blank">logging</a></code>模块不使用snake_case命名。相反，它遵循camelCase命名约定。原因是这个模块是作者Vinay Sajip贡献的。根据<a class="ae ky" href="https://old.red-dove.com/python_logging.html" rel="noopener ugc nofollow" target="_blank">作者</a>的说法，这个模块的开发受到了Java的<a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/logging/package-summary.html" rel="noopener ugc nofollow" target="_blank">日志包</a>和Apache的<a class="ae ky" href="https://logging.apache.org/log4j/2.x/index.html" rel="noopener ugc nofollow" target="_blank"> log4j </a>的启发，这两者都使用了camelCase命名约定。作者在本模块中继续了这一约定。好的一面是，尽管该模块不遵循snake_case命名约定，但由于它使用了camelCase命名约定，因此具有内部一致性。因此，考虑到模块的一致性，您不太可能对模块中的各种名称感到困惑。</p><p id="eff1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于感兴趣的用户，关于这个话题可以参考这个<a class="ae ky" href="https://stackoverflow.com/questions/22993667/how-come-the-pythons-logging-module-doesnt-follow-pep8-conventions" rel="noopener ugc nofollow" target="_blank">关于堆栈溢出的讨论</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9e9a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.伐木工是什么？</h1><p id="f456" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们使用日志模块时，我们通常做的第一件事是实例化<code class="fe mz na nb nc b">logger</code>对象。从技术上讲，我们可以通过调用<code class="fe mz na nb nc b">Logger</code>构造函数来创建一个<code class="fe mz na nb nc b">logger</code>对象:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="35ab" class="nh md it nc b gy ni nj l nk nl">import logging</span><span id="d7f2" class="nh md it nc b gy nm nj l nk nl">logger_not_good = logging.Logger("my_app")</span></pre><p id="fcda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，正如上面的<code class="fe mz na nb nc b">logger</code>名称所示，使用构造函数创建<code class="fe mz na nb nc b">logger</code>并不是一个好的做法。相反，最佳实践是使用模块级函数<code class="fe mz na nb nc b">getLogger</code>，它将为给定的应用程序检索相同的<code class="fe mz na nb nc b">logger</code>对象:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="fbeb" class="nh md it nc b gy ni nj l nk nl">logger_good = logging.getLogger("my_app")</span></pre><p id="ea23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如下所示，多次调用<code class="fe mz na nb nc b">getLogger</code>函数检索同一个对象，如其相同的内存地址所示。相比之下，使用构造方法将创建多个实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">记录器对象</p></figure><p id="e02f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">logger</code>对象是控制应用程序或模块日志行为的中心对象。您应该考虑的一些重要事情包括日志级别、处理程序和格式，这些将在接下来的几节中讨论。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="82f0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.日志记录级别意味着什么？</h1><p id="fd36" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">并不是所有的软件问题都有相同的优先级。有些现在需要修复，有些则不需要。我们可以将相同的逻辑应用于我们的日志系统。通过使用不同的日志记录级别，我们可以突出问题的紧迫性/重要性。</p><p id="d7f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在日志模块中，有五个日志级别(或者六个，如果包括初始的<code class="fe mz na nb nc b">NOTSET</code>级别)。这些级别在日志模块中被定义为常量，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">日志记录级别</p></figure><p id="918a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mz na nb nc b">logger</code>，我们可以设置应该保留的日志记录信息的级别。我们将级别设置为<code class="fe mz na nb nc b">warning</code>，这意味着<code class="fe mz na nb nc b">warning</code>及以上级别(即<code class="fe mz na nb nc b">error</code>和<code class="fe mz na nb nc b">critical</code>)的所有日志消息都将被记录:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="3c6d" class="nh md it nc b gy ni nj l nk nl">logger = logging.getLogger(<strong class="nc iu">"my_app"</strong>)<br/>logger.setLevel(logging.WARNING)</span></pre><p id="e94a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从概念上讲，我们可以把<code class="fe mz na nb nc b">logger</code>的级别看作是记录器<strong class="lb iu"> </strong>对日志事件的响应。级别越低，记录器的响应性或包容性就越强。例如，如果您将<code class="fe mz na nb nc b">logger</code>的级别设置为<code class="fe mz na nb nc b">debug</code>，所有日志记录消息都将被记录器捕获。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f414" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.什么是操控者？</h1><p id="5cfe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在上一节中，我们讨论了设置我们的<code class="fe mz na nb nc b">logger</code>的日志记录级别。然而，突出的问题是<code class="fe mz na nb nc b">logger</code>如何写它接收到的日志事件。这是训练者发挥作用的地方。</p><p id="1991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了长期保存，通常的做法是将日志事件写入文件。在这种情况下，我们需要为<code class="fe mz na nb nc b">logger</code>指定文件处理程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">记录到文件</p></figure><ul class=""><li id="7cbc" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">我们首先通过实例化<code class="fe mz na nb nc b">FileHandler</code>类创建了一个文件处理程序，并将其设置为<code class="fe mz na nb nc b">logger</code>。</li><li id="bd11" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">我们向<code class="fe mz na nb nc b">logger</code>发送了一些日志事件，包括<code class="fe mz na nb nc b">error</code>、<code class="fe mz na nb nc b">critical</code>和<code class="fe mz na nb nc b">info</code>日志消息。</li><li id="93b2" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">通过检查日志的内容，我们注意到只有<code class="fe mz na nb nc b">error</code>和<code class="fe mz na nb nc b">critical</code>消息被记录。还记得我们把<code class="fe mz na nb nc b">logger</code>的等级设为<code class="fe mz na nb nc b">warning</code>吗？因为<code class="fe mz na nb nc b">info</code>电平低于<code class="fe mz na nb nc b">warning</code>，所以<code class="fe mz na nb nc b">info</code>消息不会被<code class="fe mz na nb nc b">logger</code>捕获。</li></ul><p id="a879" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子只是向您展示了文件处理程序如何与<code class="fe mz na nb nc b">logger</code>一起工作。日志模块还支持其他类型的处理程序。下面的代码片段向您展示了我们可以创建一个<code class="fe mz na nb nc b">StreamHandler</code>实例，它将在默认情况下登录到交互控制台:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">记录到控制台</p></figure><p id="cce1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，本质上，处理程序是这样指定的，即<code class="fe mz na nb nc b">logger</code>知道在哪里记录日志消息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="13b9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.我怎样才能以一种更方便读者的方式登录？</h1><p id="ba7e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我没有提到的一件事是<em class="od">如何</em>记录日志。但是您可能已经注意到了我们为发送日志消息所做的工作。最方便的方法是简单地使用模块级函数，这些函数用函数本身指定的级别创建日志事件，如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c81d" class="nh md it nc b gy ni nj l nk nl">logger.critical(<strong class="nc iu">"This is a critical message."</strong>)<br/>logger.error(<strong class="nc iu">"This is an error message."</strong>)<br/>logger.warning(<strong class="nc iu">"This is a warning message."</strong>)<br/>logger.info(<strong class="nc iu">"This is an info message."</strong>)<br/>logger.debug(<strong class="nc iu">"This is a debug message."</strong>)</span></pre><p id="aa45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，这些日志消息是日志模块的<code class="fe mz na nb nc b">LogRecord</code>类的实例。<code class="fe mz na nb nc b">LogRecord</code>实例的一些重要属性包括日志的时间戳(即<code class="fe mz na nb nc b">asctime</code>)、日志事件的级别(即<code class="fe mz na nb nc b">levelname</code>)和日志的消息(即<code class="fe mz na nb nc b">message</code>)。这些属性对于通过应用格式来进行更有意义的日志记录是必不可少的，下面将对此进行讨论。</p><p id="6f3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，从调试的角度来看，这些消息并没有太大的意义。至少，我们应该知道这些事件是何时发生的。我们可以对<code class="fe mz na nb nc b">logger</code>应用一些格式来为我们记录这些信息。更具体地说，格式是通过处理程序配置的。换句话说，我们可以为不同的处理程序设置不同的格式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">格式化日志记录</p></figure><ul class=""><li id="df5d" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">在这段代码中，我们创建了一个<code class="fe mz na nb nc b">Formatter</code>对象，它将记录格式化的时间、日志级别和日志事件的消息。</li><li id="63f3" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">如果需要额外的格式，可以进一步设置显示所需信息的<code class="fe mz na nb nc b">Formatter</code>对象，比如模块名。</li><li id="bb30" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">日志记录的输出更加结构化，显示了时间戳，这对将来的调试非常有用。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="329e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="b6a4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本文通过关注日志模块，概述了Python中的日志记录过程。我们讨论了与本模块相关的五个具体问题。我希望读完这篇文章后，您可以对日志模块有一个初步的了解。如果想进一步探讨这个话题，可以参考<a class="ae ky" href="https://docs.python.org/3/library/logging.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><p id="78ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单回顾一下，您可以尝试以下步骤来登录您的项目:</p><ol class=""><li id="3a52" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu oe nv nw nx bi translated">通过调用<code class="fe mz na nb nc b">getLogger </code>函数为您的应用程序检索<code class="fe mz na nb nc b">logger</code>。</li><li id="982a" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu oe nv nw nx bi translated">给你的<code class="fe mz na nb nc b">logger</code>设置一个合适的日志级别。</li><li id="34e7" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu oe nv nw nx bi translated">创建适用的处理程序。为了长期保存，您可能希望将信息记录到物理文件中。</li><li id="7774" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu oe nv nw nx bi translated">为处理程序指定格式，处理程序可以有不同的格式设置。</li><li id="3c15" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu oe nv nw nx bi translated">将手柄连接到您的<code class="fe mz na nb nc b">logger</code>上。</li><li id="8d7c" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu oe nv nw nx bi translated">检查你的日志。</li></ol></div></div>    
</body>
</html>