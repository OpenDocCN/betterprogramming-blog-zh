<html>
<head>
<title>Open-Closed Principle: The Hard Parts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开闭原则:难的部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/open-closed-principle-the-hard-parts-34f142b64bc2?source=collection_archive---------3-----------------------#2022-09-30">https://betterprogramming.pub/open-closed-principle-the-hard-parts-34f142b64bc2?source=collection_archive---------3-----------------------#2022-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="418a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">开闭原理是固体的第二个原理。让我们知道什么是OCP，它的局限性，以及我们如何才能正确地遵循它</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b2e342eb4857ad1d440c21f9482204c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PqLT9jS562-Yuk4qYE5xRA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片</p></figure><h1 id="d210" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">介绍</h1><p id="2c2c" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">坚实的原则是由罗伯特·马丁(Robert C.Martin)制定的一套原则。这些原则的主要目标是设计易于维护、测试、理解和扩展的软件。</p><p id="a812" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这些原则是:</p><ul class=""><li id="8681" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi mu mv mw mx bi translated"><a class="ae mj" rel="noopener ugc nofollow" target="_blank" href="/do-you-really-know-what-is-single-responsibility-5e5d9d59ea58">单一责任原则</a></li><li id="ad76" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">开闭原理</li><li id="387a" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><a class="ae mj" rel="noopener ugc nofollow" target="_blank" href="/liskov-substitution-principle-isnt-complex-just-give-it-a-try-d4f84093ca5f">利斯科夫替代原理</a></li><li id="bed3" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">界面分离原理</li><li id="b116" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">依赖性倒置</li></ul><p id="1e4a" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在前一篇文章中介绍了<a class="ae mj" rel="noopener ugc nofollow" target="_blank" href="/do-you-really-know-what-is-single-responsibility-5e5d9d59ea58">单一责任原则</a>之后，在这篇文章中，我们将讨论开闭原则中的第二个原则。</p><h1 id="9f02" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">让我们在某些事情上达成一致</h1><p id="a0ce" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在深入研究这个原则之前，让我们先就一些事情达成一致。我相信你同意我的观点，软件设计不是一个简单的过程，任何软件的主要特征是在其生命周期中的可变性。</p><p id="068e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">如果我们预先知道这一点，我认为我们需要实现的主要目标是以一种适应这种可变性的方式构建软件，并最小化由于业务需求变化而引入新错误的机会。</p><p id="09ec" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">事实上，SOFT_WARE这个词意味着任何软件都应该是灵活多变的。所以，软件应该遵循一些已被证实的设计原则来实现这个承诺，其中之一就是开闭原则(OCP)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/59006244ebce94f48a42084e398ae266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sb1L71gtvnCQxClji3Gsvg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片来自<a class="ae mj" href="https://unsplash.com/photos/KLLcTHE20bI" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>由<a class="ae mj" href="https://unsplash.com/@nixcreative" rel="noopener ugc nofollow" target="_blank"> Tyler Nix </a>拍摄|高度改变</p></figure><h1 id="86e6" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">该理论</h1><p id="fd1d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">开合原理对立体原理中的“O”负责。Robert C. Martin认为这个原则是“面向对象设计最重要的原则”然而，他不是第一个定义它的人。最初，<a class="ae mj" href="https://en.wikipedia.org/wiki/Bertrand_Meyer" rel="noopener ugc nofollow" target="_blank"> Bertrand Meyer </a>于1988年在他的书<a class="ae mj" href="https://en.wikipedia.org/wiki/Object-Oriented_Software_Construction" rel="noopener ugc nofollow" target="_blank">面向对象软件构造</a>中写到了这一点。他这样表述:</p><blockquote class="ne nf ng"><p id="5daa" class="ln lo nh lp b lq mk jr ls lt ml ju lv ni mm ly lz nj mn mc md nk mo mg mh mi ij bi translated">“软件实体(类、模块、函数等)。)应该对扩展开放，但对修改关闭。”</p></blockquote><p id="db19" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">但这意味着什么呢？简单地说，这意味着如果您的业务需求发生变化，您不应该修改现有的代码(禁止修改)。相反，您应该添加一个新代码，在不影响现有代码的情况下扩展它(为扩展而开放)。</p><p id="ac58" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">因此，符合这一原则的最终实体将具有两个特征:</p><ul class=""><li id="3480" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi mu mv mw mx bi translated">稳定:由于这个实体不允许修改，所以它的行为不会改变，并且定义良好。以便对使用该实体的代码没有副作用。</li><li id="93fb" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">灵活:由于这个实体对扩展是开放的，所以您可以在不影响现有代码的情况下添加新功能。</li></ul><p id="6c8d" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">如果你第一次读到这个原理，你可能会认为这有矛盾。软件应该如何在修改时关闭，同时在扩展时打开？</p><p id="d343" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">好了，为了阐明这一点，我们来介绍一下插件架构。</p><h1 id="326b" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">插件架构作为OCP的一个实例</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/1481f8f1432f56953744f802a0b48be0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Msrh08VxXHdULu3nrvXCw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae mj" href="https://unsplash.com/@sswhelan" rel="noopener ugc nofollow" target="_blank">肖恩·惠兰</a>拍摄的<a class="ae mj" href="https://unsplash.com/photos/NG_a-z0ScM0" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>照片|图像高度有所改变</p></figure><p id="23b4" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在他的<a class="ae mj" href="https://blog.cleancoder.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html" rel="noopener ugc nofollow" target="_blank">文章</a>中，鲍勃大叔说:</p><blockquote class="ne nf ng"><p id="2899" class="ln lo nh lp b lq mk jr ls lt ml ju lv ni mm ly lz nj mn mc md nk mo mg mh mi ij bi translated">“插件系统是开闭原则的最终完善和典范”</p></blockquote><p id="aaad" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">但是是什么让插件架构如此特别呢？想想看，如果你的系统是由一些插件组成的，这些插件可以很容易地插入或拔出，而不会互相影响。每个插件只负责一项工作，而且做得很好。系统对任何需要扩展的新插件一无所知。相反，这个新插件只需要完成系统契约。这意味着添加或删除插件根本不会影响现有的代码。</p><blockquote class="ne nf ng"><p id="9021" class="ln lo nh lp b lq mk jr ls lt ml ju lv ni mm ly lz nj mn mc md nk mo mg mh mi ij bi translated"><em class="iq">是的，如你所想，OCP和SRP在某种程度上是相互关联的。</em></p></blockquote><p id="8c45" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">让我引用鲍勃大叔说的话来强调插件架构有多强大:</p><blockquote class="ne nf ng"><p id="aa0a" class="ln lo nh lp b lq mk jr ls lt ml ju lv ni mm ly lz nj mn mc md nk mo mg mh mi ij bi translated">“如果你的系统设计是基于插件的，比如Vim、Emacs、《我的世界》或者Eclipse，会怎么样？如果您可以插入数据库或GUI会怎么样？如果你能插入新的功能，并拔掉旧的，会怎么样？</p><p id="c0d0" class="ln lo nh lp b lq mk jr ls lt ml ju lv ni mm ly lz nj mn mc md nk mo mg mh mi ij bi translated">如果您的系统的行为很大程度上是由其插件的配置控制的，会怎么样？那会给你什么力量？</p><p id="f5b0" class="ln lo nh lp b lq mk jr ls lt ml ju lv ni mm ly lz nj mn mc md nk mo mg mh mi ij bi translated">添加新功能、新用户界面或新机器/机器界面有多容易？添加或删除SOA有多容易？添加或删除REST有多容易？"</p></blockquote><p id="27de" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">嗯，那很有趣，不是吗？</p><h1 id="bb78" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">你真的很懂吗？</h1><p id="d66b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我相信我学这个原理的时候你和我想的一样:真的！那很有趣。如果我们能在我们的设计或构建任何基于插件的系统中实现这一原则，我们在未来将不会面临任何问题或重大变化。</p><p id="4d3a" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">但是再想一想，如果你需要给你的类增加一个新的特性，你会怎么做？通常，您通常做的第一件事是打开这个类并添加您的特性，这在大多数情况下是非常合理的。</p><p id="c43c" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">看一下这个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="006e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">如果你有前一个例子，你的经理要求你删除税。你要做的第一件事是什么？那是明显的。</p><p id="8fd6" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">那么，在不触及现有代码的情况下添加/删除新的/旧的功能对您来说有意义吗？简而言之，答案是肯定的，但这并不像你想的那么简单。我们继续。</p><h1 id="970d" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">OCP的艰苦地区</h1><p id="cd0a" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我认为，在五项坚实的原则中，OCP是最被误解的。然而，如果你在你的设计中正确地应用它，它会比其他的更有帮助。</p><p id="c8d2" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">也许，你可能会阅读这个原则的定义，然后问自己，我如何才能正确地应用它？我必须遵循什么步骤来实现它？</p><p id="8a40" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">1.不幸的是，没有一种方法可以编写永远不需要修改并且永远可以扩展的代码。可能永远不会修改的一个类是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="af05" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">你可能会注意到这个类在抽象上是极端的。这个类本身没有功能，它的所有功能都传递给了它，所以它可能永远不需要修改。</p><p id="6a33" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">另一方面，看看下面这个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3d3d" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">显然，这个类在具体性上是极端的。这个类只以一种方式做一件事，如果你想改变它的功能，你必须直接修改它。</p><p id="9157" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">实际上，任何有用的代码都必须介于这两个极端之间。它必须部分具体化以实现其功能，如果需要，部分抽象化以易于重用或维护。</p><p id="ba34" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">因此，永远不要有极端的想法，认为你的代码不能修改，只能扩展。请记住，无论是抽象的极端还是具体的极端都有其代价。因此，这里的难点是定义正确的抽象层次，以及定义两个极端之间的平衡点。</p><p id="ceb1" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">识别这一点的一个可能的方法是从具体开始，除非你确定你需要100%的抽象，然后看看应用程序如何随时间发展。当需要更改时，只需在现有代码中进行一两次具体的更改。然而，到了第三次，它可能是一个指示符，表明软件可能在将来继续以这种方式改变。所以你应该考虑重构你的代码来遵循OCP，并提供所需的抽象。</p><p id="548b" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在我看来，OCP并没有告诉你要抽象一切来获得最终的通用设计，因为，那是不可能的。相反，如果你有很强的抽象理由，简单地说，去做，如果你没有，简单地说，不要做。混凝土设计是好的，直到它不是。记住<a class="ae mj" href="https://en.wikipedia.org/wiki/KISS_principle" rel="noopener ugc nofollow" target="_blank">接吻原理</a>。</p><p id="3987" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">因此，不可避免地，你可能需要修改你现有的代码，甚至更多，你的抽象。</p><p id="f4d0" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">2.另一点你必须记住的是处理bug。如果你的类有一个bug，你会怎么做？你会强行扩展它并留下一个有错误的遗留代码来盲目地实现OCP吗？还是直接打开你的类修改这个bug？所以我认为修复bug应该是OCP的一个例外。</p><p id="178a" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">3.我们需要能够预测代码中的变化，并围绕它应用抽象。与此同时，我们不想开发太复杂的软件，试图猜测未来可能必须修改的每一种可能的方式。所以，预测是关键，同时也是最难实现这个原则的。遵循OCP的一个更简洁的方法是引入<a class="ae mj" href="http://codecourse.sourceforge.net/materials/The-Importance-of-Being-Closed.pdf" rel="noopener ugc nofollow" target="_blank">变异点</a> (PV)原理，该原理规定:</p><blockquote class="ne nf ng"><p id="6ba0" class="ln lo nh lp b lq mk jr ls lt ml ju lv ni mm ly lz nj mn mc md nk mo mg mh mi ij bi translated">确定预测的变化点，并围绕它们创建一个稳定的界面。</p></blockquote><p id="8e27" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">但是在预测你的变化时要小心。错误预测变化的成本可能很高:</p><ul class=""><li id="ed5c" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi mu mv mw mx bi translated">如果你预测不会变化的变化，你最终会在过度工程化上浪费你的努力。</li><li id="102b" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">如果您不能预测实际需要的变化，您最终将需要修改大量的现有代码。</li></ul><p id="fa6e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">因此，关于这一点的底线如下:</p><ul class=""><li id="c620" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi mu mv mw mx bi translated">不要因为预测到需要就把东西抽象出来。请记住，开发和维护抽象是有代价的。但是如果事先你100%确定你会需要它，那就去吧。</li><li id="fb79" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">你不应该预测软件中的每一个变化，但是，定义软件中的变化点是你的责任。</li><li id="b535" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">一旦对变化的需求成为现实，就是时候重构你的代码，如果你真的需要的话，提供正确的抽象。</li></ul><h1 id="83df" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">遵循OCP的实用方法</h1><p id="f047" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我已经尽我所能简化了前面的部分，但是如果你迷路了，这里有一些跟随OCP的实用方法:</p><ol class=""><li id="9f95" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi nn mv mw mx bi translated">如果你不能预先预测软件中的变化点，简单地说，从具体而简单的开始。然后，随着软件的发展，开始重构并围绕这些点构建正确的抽象。</li><li id="61ba" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nn mv mw mx bi translated">如果你预先100%地预测了变化点，试着在不使事情过于复杂的情况下，确定你的软件需要的正确的抽象层次。</li></ol><p id="2398" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在理论上介绍了OCP及其局限性之后，让我们跳到实际例子中，看看如何在我们的代码中应用OCP。</p><h1 id="bf07" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">应用OCP的方法</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/72d7b3895489549c1d53faee6ecf2e18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ASuf5m8IgB0XSRSz"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片来自<a class="ae mj" href="https://unsplash.com/photos/7tkDoo2L_Eg" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>由<a class="ae mj" href="https://unsplash.com/@jaye_haych" rel="noopener ugc nofollow" target="_blank"> Jaye Haych </a>拍摄</p></figure><p id="9ac8" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">让我们从这个具体的例子开始，试着用OCP来重构它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="eacc" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">1.功能参数</h1><p id="ca57" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这种方法是应用OCP最简单、最直观的方式，同时也是<a class="ae mj" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>的理想选择。</p><p id="ee6d" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">简单地说，在这种方法中，例如，通过向函数传递参数，我们可以改变它的功能。这个函数可以通过改变它的参数来扩展。</p><p id="56b3" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">让我们通过应用OCP来重构上面的示例，并记住这种方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="196a" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">现在，如您所见，这个函数可以打印任何消息，而不仅仅是固定的消息。所以这个函数通过改变它输出的消息来扩展。</p><h1 id="434d" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">2.通过继承的部分抽象</h1><p id="f595" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">正如我们所说，OCP是由Bertrand Meyer在他的书《面向对象的软件构造》中首次使用的事实上，Meyer最初的方法是使用继承作为应用OCP的核心机制。</p><p id="4b58" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">每当您的类需要更改时，这种方法不是修改现有的功能，而是鼓励您创建一个新的子类，根据需要保存新的实现或覆盖原来的实现。并保持原来的实现不变。</p><p id="bb1f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">让我们重构我们的示例，并记住这种方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f919" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">如你所见，我们没有修改原来的类<code class="fe np nq nr ns b">Logger</code>，而是添加了一个新的子类<code class="fe np nq nr ns b">AnotherLogger</code>，它覆盖了父类的行为，也就是<code class="fe np nq nr ns b">log</code>方法。</p><p id="41ea" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">顺便提一下，如果可能的话，应该避免使用继承，因为如果子类依赖于父类的实现细节，继承会引入紧耦合。如果父类改变了，它会影响子类，它们可能也需要修改。</p><h1 id="b00d" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">3.通过组合和接口的整体抽象</h1><p id="ef0a" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">也许，你以前听说过“编程是为了接口，而不是实现”或者“<a class="ae mj" href="https://en.wikipedia.org/wiki/Composition_over_inheritance" rel="noopener ugc nofollow" target="_blank">复合胜于继承</a>”，不是吗？因为继承的限制，Robert C. Martin重新定义了OCP，使用组合和接口来代替Meyer的继承。但是怎么用呢？</p><p id="f833" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在这种方法中，不是直接在主类中设置新功能，而是将它移到另一个类中，然后通过<a class="ae mj" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>将这个新类引用到主类中。任何注入的类都必须实现一个接口。一旦新类正确实现了这个接口，主类最终就可以使用它的功能了。这就是你如何在继承之上使用组合和接口。</p><p id="516d" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">让我们跳到我们的例子中，使用接口来应用组合:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="225f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">如您所见，现在<code class="fe np nq nr ns b">Logger</code>类独立于任何实体。只有注入的实例必须实现<code class="fe np nq nr ns b">ILogger</code>接口。所以你可以使用<code class="fe np nq nr ns b">AnotherLogger</code>或者任何你想要的记录器，只要它实现了<code class="fe np nq nr ns b">ILogger</code>接口。</p><p id="78fd" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这种方法的主要好处是实现了<a class="ae mj" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" rel="noopener ugc nofollow" target="_blank">多态性</a>，这反过来又实现了<a class="ae mj" href="https://en.wikipedia.org/wiki/Loose_coupling" rel="noopener ugc nofollow" target="_blank">松耦合</a>。</p><p id="b500" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">然而，接口编程引入了一个新的抽象层。接口本身被认为是封闭的，而不是实现，因为一个接口可能同时有许多不同的实现。接口本身被重用，而不是实现。这又会导致松散耦合。</p><h1 id="3e72" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">战略设计模式</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/9ace2ff73da061dff77c87223680262d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1ikqu7WEBESSNwDs"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片来自<a class="ae mj" href="https://unsplash.com/@neon845b" rel="noopener ugc nofollow" target="_blank"> Jani Kaasinen </a>拍摄的<a class="ae mj" href="https://unsplash.com/photos/7VGzV09YnvA" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="f25d" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">策略设计模式是以优雅的方式实现OCP的一个很好的例子。这是最有用的设计模式之一。它主要基于对接口的编程。让我们看看它是如何工作的。</p><p id="9b87" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">你有一个可以用多种方法解决的问题。这些方法被称为策略，每个策略都封装了一个不同的问题解决方案。所有这些策略都必须实现一个接口来解决这个问题。这个问题在一个叫<code class="fe np nq nr ns b">Context</code>的课上。这些策略可以通过多种方式注入到上下文中，比如依赖注入、工厂设计模式，或者简单地通过If条件。请看这张图表:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/33ba9307012fd8e2d3e08fe4a95ed4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/0*0JAcb4_3wbL207OH"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者的策略模式</p></figure><p id="7756" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">现在，您的代码对扩展是开放的，因为它使您能够使用不同的策略，只要它们实现所需的接口。并且对修改关闭，因为上下文类本身不必改变，它用任何策略解决它的问题，不管策略是什么。</p><p id="07de" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我之前写过一篇关于策略模式的文章，你可以在这里查看<a class="ae mj" href="https://medium.com/illumination/strategy-vs-state-vs-template-design-patterns-29f187b0249b" rel="noopener">。</a></p><h1 id="b736" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">OCP的好处</h1><p id="924f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">经过这样的解释，我想你已经知道在你的代码中应用OCP的好处了。让我们总结其中的一些:</p><ol class=""><li id="8155" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi nn mv mw mx bi translated">如果您有一个由许多用户使用的包，您可以让他们能够扩展该包而无需修改它。反过来，这减少了部署的数量，从而最大限度地减少了重大变更。</li><li id="58c3" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nn mv mw mx bi translated">对现有代码的修改越少，引入新错误的可能性就越小。</li><li id="f735" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nn mv mw mx bi translated">代码变得更简单，不复杂，也更容易理解。请看上一节中的策略模式。</li><li id="af28" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nn mv mw mx bi translated">向新类添加新功能使您能够从头开始完美地设计它，而不会污染现有代码或在现有代码中进行变通。</li><li id="5064" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nn mv mw mx bi translated">因为新类不依赖于任何东西，所以你只需要测试它而不是所有现有的代码。</li><li id="bc11" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nn mv mw mx bi translated">接触遗留代码中的现有代码会带来极大的压力，因此在新类中添加新功能可以减轻这种压力。</li><li id="5335" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nn mv mw mx bi translated">您创建的任何新类都遵循单一责任原则。</li><li id="5b76" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nn mv mw mx bi translated">它使您能够完美地模块化代码，从而节省时间和成本。</li></ol><h1 id="fd8f" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">摘要</h1><p id="f371" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在前面的文章中介绍了第一个可靠原则<a class="ae mj" rel="noopener ugc nofollow" target="_blank" href="/do-you-really-know-what-is-single-responsibility-5e5d9d59ea58">单一责任原则</a>之后，我们在这篇文章中讨论了第二个原则，即开闭原则。</p><p id="c79e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">正如我们所见，这个原则是最重要的设计原则之一。遵循它可以让你创建模块化的、可维护的、可读的、易于使用的和可测试的应用程序。</p><p id="b0e1" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">尽管应用这个原则会给你带来好处，但是应用它并不容易。没有一种方法可以应用它，不可能预先预测每一个变化点，也很难定义应用程序真正需要的正确抽象级别。</p><p id="df22" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">除此之外，我们还介绍了遵循这一原则的实用方法。首先，用简单的具体代码解决你的问题。不要预先抽象一切。其次，试着找出你的应用程序中的变化点。如果你有一个不断变化的特性，它可能是一个变化点。最后，如果你已经确定了这些要点，你可能应该考虑OCP，修改你的代码，并尽量使其可扩展以满足未来的需求。</p><p id="3527" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">最后，我们介绍了三种使您能够应用OCP的方法，并且知道推荐的方法是使用组合和接口。</p><p id="f94e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">如果您觉得这篇文章有用，也可以看看这些文章:</p><ul class=""><li id="9862" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi mu mv mw mx bi translated"><a class="ae mj" rel="noopener ugc nofollow" target="_blank" href="/do-you-really-know-what-is-single-responsibility-5e5d9d59ea58">你真的知道单一责任原则是什么吗？</a></li><li id="6011" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><a class="ae mj" rel="noopener ugc nofollow" target="_blank" href="/liskov-substitution-principle-isnt-complex-just-give-it-a-try-d4f84093ca5f">利斯科夫替代原理并不复杂。试一试</a></li><li id="8055" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><a class="ae mj" href="https://javascript.plainenglish.io/4-ways-to-handle-async-operations-in-javascript-266ab51d8166" rel="noopener ugc nofollow" target="_blank">Javascript中处理异步操作的4种方法</a></li><li id="5b3b" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><a class="ae mj" href="https://medium.com/illumination/strategy-vs-state-vs-template-design-patterns-29f187b0249b" rel="noopener">策略vs状态vs模板设计模式</a></li></ul><p id="ec6c" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">非常感谢你陪我到现在。我希望你喜欢阅读这篇文章。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/4e6d76a24dc5b4c0543d6f5f37d43370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7a5ELZvOkMLmVeRv"/></div></div></figure><h1 id="d337" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">资源</h1><ul class=""><li id="43dd" class="mp mq iq lp b lq lr lt lu lw nu ma nv me nw mi mu mv mw mx bi translated"><a class="ae mj" href="https://blog.cleancoder.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html" rel="noopener ugc nofollow" target="_blank">开合原理</a></li><li id="218b" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><a class="ae mj" href="https://app.pluralsight.com/library/courses/csharp-solid-principles/table-of-contents" rel="noopener ugc nofollow" target="_blank">c#开发人员的坚实原则</a></li><li id="e7d4" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><a class="ae mj" href="https://stackify.com/solid-design-open-closed-principle/" rel="noopener ugc nofollow" target="_blank">固体设计原理讲解:开/关原理及代码示例</a></li><li id="370f" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><a class="ae mj" href="https://reflectoring.io/open-closed-principle-explained/" rel="noopener ugc nofollow" target="_blank">开闭原理解释</a></li><li id="3e44" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><a class="ae mj" href="https://blog.ndepend.com/solid-design-the-open-close-principle-ocp/" rel="noopener ugc nofollow" target="_blank">立体设计:启闭原理(OCP) </a></li><li id="a6fa" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><a class="ae mj" href="https://thevaluable.dev/open-closed-principle-revisited/" rel="noopener ugc nofollow" target="_blank">是否应该遵循开闭原则？</a></li><li id="04d0" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><a class="ae mj" href="https://levelup.gitconnected.com/open-closed-principle-is-nothing-about-the-code-270f1c04bebf" rel="noopener ugc nofollow" target="_blank">开闭原理与代码</a>无关</li><li id="bdca" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><a class="ae mj" href="https://medium.com/hackernoon/why-the-open-closed-principle-is-the-one-you-need-to-know-but-dont-176f7e4416d" rel="noopener">为什么开闭原理是你需要知道却不知道的原理</a></li><li id="2d13" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><a class="ae mj" href="https://codeblog.jonskeet.uk/2013/03/15/the-open-closed-principle-in-review/" rel="noopener ugc nofollow" target="_blank">开闭原理，在复习中</a></li></ul></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="1558" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><em class="nh">原载于【https://blog.mayallo.com】<a class="ae mj" href="https://blog.mayallo.com/open-closed-principle-the-hard-parts" rel="noopener ugc nofollow" target="_blank"><em class="nh"/></a><em class="nh">。</em></em></p></div></div>    
</body>
</html>