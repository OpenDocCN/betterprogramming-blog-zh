<html>
<head>
<title>What’s New in TypeScript 4.4?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4.4有什么新功能？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-typescript-4-4-e17d63b84b86?source=collection_archive---------5-----------------------#2021-08-24">https://betterprogramming.pub/whats-new-in-typescript-4-4-e17d63b84b86?source=collection_archive---------5-----------------------#2021-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5dc1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">改进的控制流分析、索引签名等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ba77140fb7b47c09c4646ded7e4dd1f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gO5eLV1YeQa3mUFZKSf-3w.png"/></div></div></figure><p id="8b96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">打字稿<code class="fe lq lr ls lt b">4.4</code>于8月26日发布。我们应该成为早期采用者吗？</p><p id="e180" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">毫无疑问，这个版本将主要集中在它的核心和改进一些现有的功能。</p><p id="2563" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我将重点介绍最相关的变化:</p><ul class=""><li id="ff14" class="lu lv it kw b kx ky la lb ld lw lh lx ll ly lp lz ma mb mc bi translated">别名条件表达式的控制流分析</li><li id="d36c" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">符号和模板文字字符串的索引签名</li><li id="0c26" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">在Catch变量中默认为<code class="fe lq lr ls lt b">unknown</code>类型</li><li id="4564" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">精确的可选属性类型</li><li id="fa2a" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">性能改进</li></ul><p id="b0fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了更好地理解，你可以在这里使用Typescript Playground<a class="ae mi" href="https://www.typescriptlang.org/play" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="e40f" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">别名条件表达式的控制流分析</h1><p id="e273" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">在深入研究这个新特性之前，让我们先了解一下<code class="fe lq lr ls lt b">control flow analysis</code>是什么:</p><blockquote class="ng nh ni"><p id="ca09" class="ku kv nj kw b kx ky ju kz la lb jx lc nk le lf lg nl li lj lk nm lm ln lo lp im bi translated">在计算机科学中，<strong class="kw iu">控制流分析</strong> ( <strong class="kw iu"> CFA </strong>)是一种静态代码分析技术，用于确定程序的控制流。控制流被表示为控制流图(CFG)。对于函数式编程语言和面向对象编程语言，术语CFA以及诸如<em class="it"> k </em> -CFA之类的详细描述都是指计算控制流的特定算法。—维基百科</p></blockquote><p id="15ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Typescript中，CFA意味着编译器会考虑代码流以更好地理解类型。例如，它会考虑类型guards的返回语句来推断变量的类型。</p><p id="646e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="54e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的例子中，因为<code class="fe lq lr ls lt b">typeof text</code>是一个类型守卫，所以该范围内的类型将是<code class="fe lq lr ls lt b">string</code>。因为在类型保护内部有一个<code class="fe lq lr ls lt b">return</code>语句，所以在<code class="fe lq lr ls lt b">if</code>范围之外的类型将是<code class="fe lq lr ls lt b">null | undefined</code>。</p><p id="5cdf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么这个新版本有什么变化呢？长期以来，终审法院取得了最大的进步。</p><p id="b1cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们把它分成三个部分:</p><h2 id="d409" class="np mk it bd ml nq nr dn mp ns nt dp mt ld nu nv mv lh nw nx mx ll ny nz mz oa bi translated"><strong class="ak"> 1。类型保护引用保存在常量/只读变量中</strong></h2><p id="9316" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">当使用条件断言if语句时，Typescript现在将做一些额外的工作。如果变量是一个<code class="fe lq lr ls lt b">const</code>或<code class="fe lq lr ls lt b">readonly</code>变量，它将保留类型保护(如果有的话)。</p><p id="f0f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9895" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果<code class="fe lq lr ls lt b">isString</code>变量是一个<code class="fe lq lr ls lt b">let</code>变量，上面的代码就不起作用。没有保留类型保护，导致代码在<code class="fe lq lr ls lt b">text.trim()</code>失败</p><pre class="kj kk kl km gt ob lt oc od aw oe bi"><span id="07c1" class="np mk it lt b gy of og l oh oi">// isString is declared as let<br/>let isString = typeof text === "string";</span><span id="dc95" class="np mk it lt b gy oj og l oh oi">// ❌ this statement won't work as a Type Guard<br/>if (isString) {<br/> ...<br/>}</span></pre><h2 id="2ddc" class="np mk it bd ml nq nr dn mp ns nt dp mt ld nu nv mv lh nw nx mx ll ny nz mz oa bi translated"><strong class="ak"> 2。您可以组合多个变量</strong></h2><p id="3320" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">类型保护别名将更加智能，甚至可以理解多个变量的组合。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5e89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">bothNonEmpty</code>常量变量保存两种类型守卫的信息。所以<code class="fe lq lr ls lt b">a</code>和<code class="fe lq lr ls lt b">b</code>都属于<code class="fe lq lr ls lt b">if</code>语句中的<code class="fe lq lr ls lt b">string</code>类型。</p><h2 id="2e2d" class="np mk it bd ml nq nr dn mp ns nt dp mt ld nu nv mv lh nw nx mx ll ny nz mz oa bi translated"><strong class="ak"> 3。它是过渡性的</strong></h2><p id="70b5" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">如果您组合具有相关类型保护的变量，这些变量仍将被传播。这意味着可以根据需要组合任意多的类型保护相关变量，而不会丢失任何类型信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="edf3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以在上面的例子中看到，<code class="fe lq lr ls lt b">bothNonEmpty</code>属性保留了类型保护信息。</p><p id="e3b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总之，<code class="fe lq lr ls lt b">CFA</code>已经改进了很多，使得Typescript编译器更加智能。最好的部分是这将在Typescript <code class="fe lq lr ls lt b">4.4</code>中开箱即用。仅仅这个特性就让整个升级物有所值。</p><h1 id="09f4" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">符号和模板文字字符串的索引签名</h1><p id="90c2" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">该功能是已经工作了三年的<code class="fe lq lr ls lt b">Generalized index signatures</code>的超集。那个PR可以在这里找到<a class="ae mi" href="https://github.com/microsoft/TypeScript/pull/26797" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="f212" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Typescript <code class="fe lq lr ls lt b">4.4</code>现在支持索引签名中的<code class="fe lq lr ls lt b">symbol</code>、<code class="fe lq lr ls lt b">unions</code>和<code class="fe lq lr ls lt b">template literal string</code>。只要是由<code class="fe lq lr ls lt b">string</code>、<code class="fe lq lr ls lt b">number</code>或<code class="fe lq lr ls lt b">symbol</code>组成的联管节都被支持。</p><p id="e806" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用<code class="fe lq lr ls lt b">symbol</code>的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7289" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用<code class="fe lq lr ls lt b">literal template string</code>的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="6be3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过能够使用联合，我们可以减少许多样板文件。我们可以更好地表达我们的接口和类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a706" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">索引签名仍然不完美。它们有局限性。他们仍然不支持<code class="fe lq lr ls lt b">Generic Types</code>也不支持<code class="fe lq lr ls lt b">Template Literal Types</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="b90b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管如此，这仍然是一个很棒的特性，它将帮助我们用更少的代码行创建更强大的界面。</p><h1 id="4a08" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">在Catch变量中默认为未知类型</h1><p id="7f99" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">回到Typescript <code class="fe lq lr ls lt b">3.0</code>版本，引入了<code class="fe lq lr ls lt b">unknown</code>类型。在大多数情况下，这是比<code class="fe lq lr ls lt b">any</code>更好的选择。它更加类型安全，因为<code class="fe lq lr ls lt b">any</code>好像根本没有类型检查。</p><p id="0e2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着Typescript的发展，我们发现<code class="fe lq lr ls lt b">any</code>类型的用法越来越少。在<code class="fe lq lr ls lt b">4.4</code>之前，任何catch子句的错误类型都是<code class="fe lq lr ls lt b">any</code>。</p><p id="6482" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了改变这一点，在这个版本中，Typescript添加了一个新的标志<code class="fe lq lr ls lt b">--useUnknownInCatchVariables</code>。当设置为<code class="fe lq lr ls lt b">true</code>时，catch子句错误类型将为<code class="fe lq lr ls lt b">unknown</code>，否则将为<code class="fe lq lr ls lt b">any</code>类型。这面旗帜将是<code class="fe lq lr ls lt b">--strict</code>家族的一部分。</p><p id="baf0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您已经启用了推荐的<code class="fe lq lr ls lt b">--strict</code>，您可能会发现这个新版本打破了您现有的代码库。您可以选择修复它，或者使用标志暂时默认为旧的行为。</p><p id="3c4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="fd82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如何使用合适的错误类型？我们可以使用类型保护，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="5444" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">精确的可选属性类型</h1><p id="10ca" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">当使用Typescript时，有一个反复出现的争论:使属性可选还是使属性<code class="fe lq lr ls lt b">undefined</code>？这确实取决于个人偏好。</p><p id="2392" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Typescript编译器以同样的方式处理这两者。这导致了不一致，会让我们困惑。</p><p id="e789" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="011e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了结束这种不一致性，Typescript现在包含了一个标志:<code class="fe lq lr ls lt b">--exactOptionalPropertyTypes</code>。如果启用，当试图将可选值视为可空值时将显示错误，反之亦然。</p><p id="d77a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们检查一个将<code class="fe lq lr ls lt b">--exactOptionalPropertyTypes</code>设置为true的代码示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="44a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果没有启用该标志，上面的代码将会工作。</p><p id="9df4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认情况下，<code class="fe lq lr ls lt b">--exactOptionalPropertyTypes</code>是禁用的，因为它可能会破坏您的代码库。可能需要少量的初始投资，但最终会有回报。</p><h1 id="0375" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">最终想法</strong></h1><p id="b67d" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">这绝对是一个有趣的版本。在性能方面有一些改进:</p><ul class=""><li id="2454" class="lu lv it kw b kx ky la lb ld lw lh lx ll ly lp lz ma mb mc bi translated">更快的声明发出</li><li id="cfef" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">更快的路径规范化</li><li id="0de2" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">更快的路径映射</li><li id="c9a0" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">使用<code class="fe lq lr ls lt b">--strict</code>加快增量构建</li><li id="de7f" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">更快地生成大输出的源地图</li><li id="0781" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">更快的<code class="fe lq lr ls lt b">--force</code>构建</li></ul><p id="8c8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一次，我认为看不到任何新的闪亮的新功能是好的。相反，Typescript正在关注和改进其核心级别。在我看来，尝试修复一些已经存在了一段时间的已知问题是有意义的。</p><p id="b0a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">唯一的缺点是采用这些新的变化可能会暂时破坏代码库。从长远来看，这样更好，因为我们将有一个更一致的代码。</p><p id="914e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">干杯！</p><p id="86c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不是中等会员？支持我<a class="ae mi" href="http://dioxmio.medium.com/membership" rel="noopener">成为其中一员。</a></p><h1 id="6037" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">有关系的</h1><div class="ok ol gp gr om on"><a rel="noopener  ugc nofollow" target="_blank" href="/7-typescript-common-mistakes-to-avoid-581c30e514d6"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">要避免的7个打字稿常见错误</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">通过避免这些错误来改进您的TypeScript的代码库</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">better编程. pub</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div><div class="ok ol gp gr om on"><a rel="noopener  ugc nofollow" target="_blank" href="/mastering-function-overloading-in-typescript-97108369570a"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">在TypeScript中掌握函数重载</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">使用重载功能创建更全面、更易读的函数类型</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">better编程. pub</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb ks on"/></div></div></a></div></div></div>    
</body>
</html>