<html>
<head>
<title>5 Essential Aspects of Python Closures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python闭包的5个基本方面</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-essential-aspects-of-python-closures-494a04e7b65e?source=collection_archive---------2-----------------------#2021-07-29">https://betterprogramming.pub/5-essential-aspects-of-python-closures-494a04e7b65e?source=collection_archive---------2-----------------------#2021-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fda7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">揭开闭包的神秘面纱——这个概念让许多Python初学者感到困惑</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/312582bb83cc54842a22f76f2aeae93b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Th6IPYeiU2YrLn76"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kurt Cotoaga 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ec03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">闭包并不是Python独有的概念。许多其他编程语言都有相同的概念。虽然很多初学者可能听说过，但不知道到底是什么，怎么用。在本文中，我强调了关于Python闭包的最基本的知识，希望您能更好地理解这个概念。</p><h1 id="4f61" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.内部和外部函数</h1><p id="c6a9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如上所述，闭包存在于许多编程语言中，下面的定义是从<a class="ae ky" href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" rel="noopener ugc nofollow" target="_blank">维基百科</a>中检索到的:</p><blockquote class="ms"><p id="ce8d" class="mt mu it bd mv mw mx my mz na nb lu dk translated">“在<a class="ae ky" href="https://en.wikipedia.org/wiki/Programming_language" rel="noopener ugc nofollow" target="_blank">编程语言</a>中，<strong class="ak">闭包</strong>，也称<strong class="ak">词法闭包</strong>或<strong class="ak">函数闭包</strong>，是一种在具有<a class="ae ky" href="https://en.wikipedia.org/wiki/First-class_function" rel="noopener ugc nofollow" target="_blank">一级函数</a>的语言中实现<a class="ae ky" href="https://en.wikipedia.org/wiki/Lexically_scoped" rel="noopener ugc nofollow" target="_blank">词法范围</a> <a class="ae ky" href="https://en.wikipedia.org/wiki/Name_binding" rel="noopener ugc nofollow" target="_blank">名称绑定</a>的技术。”——维基百科对闭包的定义</p></blockquote><p id="42ec" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">这个定义对许多人来说太专业了，而且不是Python特有的。为了帮助您理解这个概念，这里有一个简单的版本:闭包是在外部函数中创建的内部函数，并使用外部函数的变量。它由外部函数作为输出值返回。还是太技术化了？我也这么认为最好用一个真实的例子来理解。我们先来看下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乘数创建者</p></figure><p id="f5e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，<code class="fe nj nk nl nm b">double_multiplier</code>和<code class="fe nj nk nl nm b">triple_multiplier</code>是两个闭包，因为它们满足闭包的定义，如下所述。</p><ol class=""><li id="9b5f" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe nj nk nl nm b">multipler</code>是在<code class="fe nj nk nl nm b">multiplier_creator</code>函数中创建的内部函数，由于它在<code class="fe nj nk nl nm b">multiplier</code>函数之外，所以被称为外部函数。内部函数通常被称为嵌套函数，因为它嵌套在另一个函数中。</li><li id="ab77" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">创建的内部函数是外部函数的返回值。需要注意的是，<code class="fe nj nk nl nm b">multiplier_creator</code>函数直接返回<code class="fe nj nk nl nm b">multiplier</code>函数，而不是<code class="fe nj nk nl nm b">multiplier</code>函数的输出值。</li><li id="ea14" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">内部函数<code class="fe nj nk nl nm b">multipler</code>使用<code class="fe nj nk nl nm b">n</code>变量，它是外部函数<code class="fe nj nk nl nm b">multiplier_creator</code>的一个参数。内部函数对外部变量的访问也称为非局部变量绑定。</li></ol><p id="57a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非局部变量的绑定可能是闭包最令人困惑的部分。让我们在下一节探讨它。</p><h1 id="ada5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.局部和非局部变量</h1><p id="9578" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当我们使用函数时，我们知道在函数中，我们可以自由地使用任何传递的参数，这些参数被称为局部变量。本质上，函数形成了一个局部作用域，限制了对其变量的访问。</p><p id="fbc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据上面的例子，<code class="fe nj nk nl nm b">multiplier_creator</code>函数定义了一个局部范围，参数<code class="fe nj nk nl nm b">n</code>是一个局部变量。在类似的函数中，内部函数<code class="fe nj nk nl nm b">multiplier</code>定义了另一个局部范围，参数<code class="fe nj nk nl nm b">number</code>是一个局部变量。但是值得注意的是，<code class="fe nj nk nl nm b">multipler</code>函数也使用参数<code class="fe nj nk nl nm b">n</code>。虽然<code class="fe nj nk nl nm b">n</code>对于<code class="fe nj nk nl nm b">multiplier_creator</code>的作用域来说是一个局部变量，但是对于<code class="fe nj nk nl nm b">multipler</code>函数来说却不是局部变量。因此，在示例中，乘数函数使用非局部变量，也称为自由变量。</p><p id="3b01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了局部变量和非局部变量的区别，你们中的一些人可能还听说过全局变量，它是在模块级定义的变量。一些相关术语包括全局和内置作用域。有兴趣的读者可以参考我早前关于<a class="ae ky" href="https://medium.com/swlh/variables-and-scopes-in-python-global-nonlocal-and-local-923a71cb57d4" rel="noopener">这个话题的文章</a>。</p><p id="6f37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到，从内部函数的角度来看，我们将访问外部函数的局部变量的过程称为非局部变量绑定。用绑定来描述这个特性是很有意义的。绑定到底是什么意思？让我们在下一节学习它。</p><h1 id="dc69" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.非局部变量绑定</h1><p id="e693" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">非局部变量的绑定在其他一些语言中也被称为非局部变量捕获来描述闭包的特性。你可以简单地把它概念化为内部函数“拥有”所使用的非局部变量。让我们观察下面的特征:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="d07f" class="of lw it nm b gy og oh l oi oj">&gt;&gt;&gt; del multiplier_creator<br/>&gt;&gt;&gt; double_multiplier(5)<br/>10<br/>&gt;&gt;&gt; triple_multiplier(5)<br/>15</span></pre><p id="382b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们删除了外部函数<code class="fe nj nk nl nm b">multiplier_creator</code>，这样这个函数将变得不可访问。但是注意闭包(即<code class="fe nj nk nl nm b">double_multiplier</code>和<code class="fe nj nk nl nm b">triple_multiplier</code>)使用<code class="fe nj nk nl nm b">multiplier_creator</code>的参数<code class="fe nj nk nl nm b">n</code>。因此，有些人可能认为闭包会停止工作。然而，他们仍然产生了预期的结果。</p><p id="5eb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">潜在的原因是闭包已经建立了它所使用的非局部变量的绑定。换句话说，它有一个绑定变量的副本。为了观察这一特性，考虑一些特殊的检查功能，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0461" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">__code__.co_freevars</code>允许我们检查闭包绑定的非局部变量的名称，<code class="fe nj nk nl nm b">__closure__[0].cell_contents</code>允许我们检查绑定的非局部变量的值。你不必知道这些函数的细节，它们只是底层的实现。</p><p id="a25c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是要知道，因为闭包通过绑定拥有自己的非局部变量副本，所以即使外部函数被移除，它们仍然可以工作。</p><h1 id="0fc4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4.Nonlocal关键字和Unboundlocalerror异常</h1><p id="1269" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当人们创建闭包时，有时会遇到<code class="fe nj nk nl nm b">UnboundLocalError</code>异常。让我们在下面的代码片段中看到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">闭包—unboundlocalrerror</p></figure><p id="70fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，<code class="fe nj nk nl nm b">running_total_multiplier_creator</code>函数似乎可以有效地生成闭包。然而，当我们使用生成的闭包时，会引发<code class="fe nj nk nl nm b">UnboundLocalError</code>异常。这个例外是什么意思？如果您阅读追溯消息，您会发现有问题的代码是<code class="fe nj nk nl nm b">running_total += product</code>。为什么会产生这样的错误呢？以下是解释:</p><ol class=""><li id="1341" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">这一行代码本质上被解释为<code class="fe nj nk nl nm b">running_total = running_total + product</code>。</li><li id="e771" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">变量查找顺序称为LEGB规则，遵循局部-&gt;封闭-&gt;全局-&gt;内置的顺序。当你在内部函数中运行<code class="fe nj nk nl nm b">running_total = xxx</code>时，你在内部函数的局部范围内注册了一个局部变量。当Python继续运行赋值语句右侧的代码时，又遇到了<code class="fe nj nk nl nm b">running_total</code>变量，于是Python开始查找这个变量，并在局部范围内找到了它。但是，它注意到这个变量还没有被赋值，因为它的赋值语句还没有执行完，这就是为什么错误消息说:<code class="fe nj nk nl nm b">local variable ‘running_total’ referenced before assignment</code>。当一个变量在赋值前被引用，这就是所谓的未绑定错误。</li></ol><p id="2948" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们回过头来看一下<code class="fe nj nk nl nm b">multiplier</code>函数，您可能会意识到我们想要使用在<code class="fe nj nk nl nm b">running_total_multiplier_creator</code>函数的作用域内定义的<code class="fe nj nk nl nm b">running_total</code>变量，从<code class="fe nj nk nl nm b">multiplier</code>函数的角度来看，这就是所谓的封闭作用域。为了让内部函数明白<code class="fe nj nk nl nm b">running_total</code>并不是一个局部变量，我们必须通过使用<code class="fe nj nk nl nm b">nonlocal</code>关键字来显式化。以下是正确的版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">闭包—unboundlocalrerror修复</p></figure><p id="b37f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我们简单地声明<code class="fe nj nk nl nm b">running_total</code>是一个非局部变量，这指示Python在查找<code class="fe nj nk nl nm b">running_total</code>变量时绕过局部范围。</p><h1 id="064a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">5.为什么要关闭？</h1><p id="0c1b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">到目前为止，我们已经回顾了什么是闭包，但是您可能想知道为什么我们要费心提供闭包功能？闭包最常见的应用之一是装饰函数的创建。尽管您可能不知道闭包，但我打赌您可能听说过decorators。在Python中，装饰器是修改其他函数的行为而不影响被装饰函数的算法的函数。如果你想更深入地了解闭包，请参考我的关于装饰者的文章。</p><p id="2748" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我将简单介绍一下我们刚刚学到的与闭包相关的装饰器。以下代码向您展示了一个示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">闭包-&gt;装饰器</p></figure><p id="8c99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">simple_logger</code>是一个装饰器，使用它需要一个<code class="fe nj nk nl nm b">@</code>符号作为名字的前缀，并放置在被装饰函数的上方。当你调用<code class="fe nj nk nl nm b">hello_world</code>函数时，会发生以下情况:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="b7fd" class="of lw it nm b gy og oh l oi oj">&gt;&gt;&gt; hello_world()<br/>You're about to call &lt;function hello_world at 0x101ce9790&gt;<br/>Hello, World!<br/>You just called &lt;function hello_world at 0x101ce9790&gt;</span></pre><p id="b22a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个特性背后的原因是修饰函数实际上是一个闭包。装饰过程有以下两个幕后步骤:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="8a15" class="of lw it nm b gy og oh l oi oj"># Step 1<br/>def hello_world():<br/>    print("Hello, World!")</span><span id="202c" class="of lw it nm b gy ok oh l oi oj"># Step 2<br/>hello_world = simple_logger(hello_world)</span></pre><p id="87b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了证明<code class="fe nj nk nl nm b">hello_world</code>确实是一个闭包，我们可以像前面一样运行下面的检查。</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="48a9" class="of lw it nm b gy og oh l oi oj">&gt;&gt;&gt; hello_world.__code__.co_freevars<br/>('func',)<br/>&gt;&gt;&gt; hello_world.__closure__[0].cell_contents<br/>&lt;function hello_world at 0x101ce9790&gt;</span></pre><ul class=""><li id="5166" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ol nt nu nv bi translated">修饰函数<code class="fe nj nk nl nm b">hello_world</code>有一个非局部变量<code class="fe nj nk nl nm b">func</code>。</li><li id="589d" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ol nt nu nv bi translated">绑定值是一个函数。作为一个相关点，重要的是要知道函数只是Python中的常规对象，因此函数可以被视为其他数据模型变量(例如，列表和字典)。</li></ul><h1 id="9166" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="7b99" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，我们回顾了闭包的五个最重要的方面。以下是对这些要点的简要回顾:</p><ul class=""><li id="8f9e" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ol nt nu nv bi translated">内部函数和外部函数是有区别的。闭包是在外部函数中创建的内部函数。</li><li id="426c" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ol nt nu nv bi translated">闭包涉及到非局部变量的绑定。</li><li id="6760" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ol nt nu nv bi translated">一个函数有它的局部作用域。当你使用在函数中创建的变量时，你使用的是局部变量。如果你使用在函数之外创建的变量，你就是在使用非局部变量。</li><li id="cc2c" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ol nt nu nv bi translated">关键字<code class="fe nj nk nl nm b">nonlocal</code>表示一个变量应该被视为一个非局部变量。通常，LEGB规则适用于变量查找。然而，使用<code class="fe nj nk nl nm b">nonlocal</code>关键字，Python将被指示在查找变量时绕过局部范围。</li><li id="71d4" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ol nt nu nv bi translated">装饰是创建替换其原始函数声明的闭包的过程。每一个装饰功能都是一个封闭的引擎盖。</li></ul></div></div>    
</body>
</html>