<html>
<head>
<title>How to Deploy a Django Application With Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Kubernetes部署Django应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-deploy-a-django-application-with-kubernetes-f5814b0688bf?source=collection_archive---------1-----------------------#2022-04-18">https://betterprogramming.pub/how-to-deploy-a-django-application-with-kubernetes-f5814b0688bf?source=collection_archive---------1-----------------------#2022-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6274" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将可扩展的Django应用部署到Kubernetes集群中</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/034f2d98c7ce2cc19053103c141ff6a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kH-t6gSXchjCmYoRMzDzzQ.jpeg"/></div></div></figure><p id="0192" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本教程中，我们将使用Kubernetes (K8s)部署一个容器化的Django应用程序。</p><p id="2591" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank"> Django </a>是一个基于Python的免费开源web框架，遵循模型-模板-视图架构模式。</p><p id="d3dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Kubernetes ，也称为K8s，是一个开源系统，用于自动化容器化应用程序的部署、扩展和管理。</p><h1 id="1d00" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">步骤1——用Docker封装我们的应用程序</h1><p id="eb07" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">让我们创建一个新的Django应用程序:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="300c" class="mq lp iq mm b gy mr ms l mt mu">$<!-- -->django-admin startproject djangokubernetesproject</span></pre><p id="b9c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">导航到<code class="fe mv mw mx mm b">djangokubernetesproject</code>目录:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="624a" class="mq lp iq mm b gy mr ms l mt mu">$cd djangokubernetesproject</span></pre><p id="d61b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之后，我们需要创建一个新的<code class="fe mv mw mx mm b">Dockerfile</code>，Docker将使用它来构建我们的容器映像:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="6f21" class="mq lp iq mm b gy mr ms l mt mu">$vim Dockerfile</span></pre><p id="49b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Dockerfile:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="89e5" class="mq lp iq mm b gy mr ms l mt mu">FROM ubuntu:20.04</span><span id="122a" class="mq lp iq mm b gy my ms l mt mu">RUN apt-get update &amp;&amp; apt-get install -y tzdata &amp;&amp; apt install -y python3.8 python3-pip</span><span id="33bc" class="mq lp iq mm b gy my ms l mt mu">RUN apt install python3-dev libpq-dev nginx -y</span><span id="e7df" class="mq lp iq mm b gy my ms l mt mu">RUN pip install django gunicorn psycopg2</span><span id="938c" class="mq lp iq mm b gy my ms l mt mu">ADD . /app</span><span id="9714" class="mq lp iq mm b gy my ms l mt mu">WORKDIR /app</span><span id="8dfa" class="mq lp iq mm b gy my ms l mt mu">EXPOSE 8000</span><span id="f903" class="mq lp iq mm b gy my ms l mt mu">CMD ["gunicorn", "--bind", ":8000", "--workers", "3", "djangokubernetesproject.wsgi"]</span></pre><p id="baa0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个Dockerfile以官方Ubuntu 20.04 docker镜像为基础，安装Django、Gunicorn、Python3.8，最后暴露出端口8000将用于接受传入的容器连接，用3个workers运行<code class="fe mv mw mx mm b">gunicorn</code>，监听端口8000。</p><p id="bf62" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们使用<code class="fe mv mw mx mm b">docker build</code>来建立我们的形象:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="ddaf" class="mq lp iq mm b gy mr ms l mt mu">$docker build -t djangokubernetesproject.</span></pre><p id="a466" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用<code class="fe mv mw mx mm b">-t</code>标志将图像命名为<code class="fe mv mw mx mm b">djangokubernetesproject</code>，并传入当前目录作为构建上下文，即在将图像容器化时要引用的文件集。</p><p id="894a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Docker构建并标记图像后，使用<code class="fe mv mw mx mm b">docker images</code>列出可用的图像:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="3d5c" class="mq lp iq mm b gy mr ms l mt mu">$docker images</span></pre><p id="6b51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您应该会看到列出的<code class="fe mv mw mx mm b">djangokubernetesproject</code>图像:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="a53e" class="mq lp iq mm b gy mr ms l mt mu">REPOSITORY                                                                                                                           IMAGE ID       CREATED         SIZE<br/>djangokubernetesproject                                                   latest</span></pre><p id="a389" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下一步，我们将在本地运行配置好的容器。</p><h1 id="f8a2" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">步骤2 —创建数据库模式</h1><p id="9238" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">构建并配置好容器后，使用<code class="fe mv mw mx mm b">docker run</code>覆盖Dockerfile中设置的<code class="fe mv mw mx mm b">CMD</code>，并使用<code class="fe mv mw mx mm b">manage.py makemigrations</code>和<code class="fe mv mw mx mm b">manage.py migrate</code>命令创建数据库模式</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="3603" class="mq lp iq mm b gy mr ms l mt mu">$docker run -i -t djangokubernetesproject sh</span></pre><p id="e70c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将在运行的容器中为您提供一个shell提示符</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="a88f" class="mq lp iq mm b gy mr ms l mt mu">#python3 manage.py makemigrations &amp;&amp; python3 manage.py migrate</span></pre><p id="5572" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您正在运行此程序，您应该会看到:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="7653" class="mq lp iq mm b gy mr ms l mt mu">Output</span><span id="b62b" class="mq lp iq mm b gy my ms l mt mu">Operations to perform:<br/>  Apply all migrations: admin, auth, contenttypes, sessions<br/>Running migrations:<br/>  Applying contenttypes.0001_initial... OK<br/>  Applying auth.0001_initial... OK<br/>  Applying admin.0001_initial... OK<br/>  Applying admin.0002_logentry_remove_auto_add... OK<br/>  Applying admin.0003_logentry_add_action_flag_choices... OK<br/>  Applying contenttypes.0002_remove_content_type_name... OK<br/>  Applying auth.0002_alter_permission_name_max_length... OK<br/>  Applying auth.0003_alter_user_email_max_length... OK<br/>  Applying auth.0004_alter_user_username_opts... OK<br/>  Applying auth.0005_alter_user_last_login_null... OK<br/>  Applying auth.0006_require_contenttypes_0002... OK<br/>  Applying auth.0007_alter_validators_add_error_messages... OK<br/>  Applying auth.0008_alter_user_username_max_length... OK<br/>  Applying auth.0009_alter_user_last_name_max_length... OK<br/>  Applying auth.0010_alter_group_name_max_length... OK<br/>  Applying auth.0011_update_proxy_permissions... OK<br/>  Applying auth.0012_alter_user_first_name_max_length... OK<br/>  Applying sessions.0001_initial... OK</span></pre><p id="ce06" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这表明数据库模式已经成功创建。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="9387" class="mq lp iq mm b gy mr ms l mt mu">#python3 manage.py createsuperuser</span></pre><p id="f7eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输入超级用户的用户名、电子邮件地址和密码，创建超级用户后，点击<code class="fe mv mw mx mm b">CTRL+D</code>退出容器并杀死它。</p><p id="0ff5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们运行docker容器。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="0ab7" class="mq lp iq mm b gy mr ms l mt mu">$docker run -p 80:8000 djangokubernetesproject</span></pre><p id="bd70" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您应该看到:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="36f0" class="mq lp iq mm b gy mr ms l mt mu">Output</span><span id="0f08" class="mq lp iq mm b gy my ms l mt mu">[2022-04-18 06:40:37 +0000] [1] [INFO] Starting gunicorn 20.1.0<br/>[2022-04-18 06:40:37 +0000] [1] [INFO] Listening at: <a class="ae ln" href="http://0.0.0.0:8000" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8000</a> (1)<br/>[2022-04-18 06:40:37 +0000] [1] [INFO] Using worker: sync<br/>[2022-04-18 06:40:37 +0000] [9] [INFO] Booting worker with pid: 9<br/>[2022-04-18 06:40:37 +0000] [10] [INFO] Booting worker with pid: 10<br/>[2022-04-18 06:40:37 +0000] [11] [INFO] Booting worker with pid: 11</span></pre><p id="a531" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，我们运行docker文件中定义的默认命令<code class="fe mv mw mx mm b">gunicorn --bind :8000 --workers 3 djangokubernetesproject.wsgi:application</code>，并公开容器端口<code class="fe mv mw mx mm b">8000</code>，以便本地机器上的端口<code class="fe mv mw mx mm b">80</code>被映射到<code class="fe mv mw mx mm b">djangokubernetesproject</code>容器的端口<code class="fe mv mw mx mm b">8000</code>。</p><p id="c9ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，您应该能够通过在地址栏中键入<code class="fe mv mw mx mm b">http://localhost</code>来使用您的网络浏览器导航到<code class="fe mv mw mx mm b">djangokubernetesproject</code>应用程序。</p><p id="696b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">导航到<code class="fe mv mw mx mm b">http://localhost</code>查看djangoapp:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/993213e989f507ff29e99cc1404e6824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8VJlvZOrVJNPWU8cb34Jxg.png"/></div></div></figure><p id="b322" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你完成探索后，在运行Docker容器的终端窗口中点击<code class="fe mv mw mx mm b">CTRL+C</code>来杀死容器。</p><h1 id="46cf" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">步骤3 —将Django应用映像推送到Docker Hub</h1><p id="9079" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">要将您的应用程序部署到Kubernetes，您的应用程序映像必须上传到docker hub注册表。Kubernetes将从其存储库中检索应用程序映像，然后将其部署到您的集群中。</p><p id="ff71" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以使用公开可用的Docker注册中心，比如Docker Hub。Docker Hub还允许您创建私有Docker存储库。公共存储库允许任何人查看和检索容器图像，私有存储库允许您限制对您和您的团队成员的访问。</p><p id="a6cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本教程中，我们将把Django映像推送到公共Docker Hub存储库中。</p><p id="fabb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先登录到本地机器上的<a class="ae ln" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="3f75" class="mq lp iq mm b gy mr ms l mt mu">$docker login</span></pre><p id="bd6a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输入您的Docker Hub用户名和密码登录。成功登录后，您应该会看到:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="75f2" class="mq lp iq mm b gy mr ms l mt mu">Output</span><span id="2b65" class="mq lp iq mm b gy my ms l mt mu">Login Succeeded</span></pre><p id="7555" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Django图像有<code class="fe mv mw mx mm b">djangokubernetesproject:latest</code>标签。要将其推送到您的Docker Hub存储库，请使用您的Docker Hub用户名和repo名称重新标记该映像:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="edc8" class="mq lp iq mm b gy mr ms l mt mu">$docker tag djangokubernetesproject:latest your_dockerhub_username/your_dockerhub_repo_name:latest</span></pre><p id="a358" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将图像推送到回购:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="8166" class="mq lp iq mm b gy mr ms l mt mu">$docker push your_dockerhub_username/your_dockerhub_repo_name:latest</span></pre><p id="8157" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当图像层被推送到Docker Hub时，您会看到一些更新的输出。</p><p id="ced2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在Docker Hub上Kubernetes可以使用您的映像了，您可以开始在集群中部署它了。</p><h1 id="3d91" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">步骤4——使用部署来部署Django应用程序</h1><p id="9438" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在这一步中，您将为Django应用程序创建一个部署。Kubernetes部署是一个<em class="na">控制器</em>，可用于管理集群中的无状态应用程序。控制器是一个控制回路，它通过放大或缩小工作量来调节工作量。控制器还重启并清除故障容器。</p><p id="5e31" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">部署控制一个或多个Pods，Pods是Kubernetes集群中最小的可部署单元。pod封装一个或多个容器。要了解更多关于您可以启动的不同类型的工作负载，请查看<a class="ae ln" href="https://www.digitalocean.com/community/tutorials/an-introduction-to-kubernetes" rel="noopener ugc nofollow" target="_blank">Kubernetes简介</a>。</p><p id="0d30" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先在您最喜欢的编辑器中打开一个名为<code class="fe mv mw mx mm b">django-deployment.yaml</code>的文件:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="7b9d" class="mq lp iq mm b gy mr ms l mt mu">$vim django-deployment.yaml</span></pre><p id="e575" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">粘贴以下部署清单:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="f20a" class="mq lp iq mm b gy mr ms l mt mu">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: django-app<br/>  labels:<br/>    app: django<br/>spec:<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      app: django<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: django<br/>    spec:<br/>      containers:<br/>        - image: your_dockerhub_username/app_repo_name:latest<br/>          name: django<br/>          ports:<br/>            - containerPort: 8000<br/>              name: gunicorn</span></pre><p id="0439" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">填写适当的容器映像名称，引用您在步骤2中推送到Docker Hub的Django项目映像。</p><p id="d173" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们定义了一个名为django-app的Kubernetes部署，并用键值对<code class="fe mv mw mx mm b">app: django</code>对其进行标记。我们指定想要运行在<code class="fe mv mw mx mm b">template</code>字段下定义的Pod的三个副本。</p><p id="bfad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们将<code class="fe mv mw mx mm b">containerPort</code> <code class="fe mv mw mx mm b">8000</code>曝光，命名为<code class="fe mv mw mx mm b">gunicorn</code>。</p><p id="730d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要了解更多关于配置Kubernetes部署的信息，请参考Kubernetes文档中的<a class="ae ln" href="https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/" rel="noopener ugc nofollow" target="_blank">部署</a>。</p><p id="a82d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">编辑完文件后，保存并关闭它。</p><p id="cc4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe mv mw mx mm b">kubectl apply -f</code>在集群中创建部署:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="570a" class="mq lp iq mm b gy mr ms l mt mu">$kubectl apply -f django-deployment.yaml</span></pre><p id="dff2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您应该看到:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="dec6" class="mq lp iq mm b gy mr ms l mt mu">deployment.apps/django-app created</span></pre><p id="5732" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe mv mw mx mm b">kubectl get</code>检查部署是否正确展开:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="4fb4" class="mq lp iq mm b gy mr ms l mt mu">$kubectl get deploy django-app</span></pre><p id="67b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="9f9e" class="mq lp iq mm b gy mr ms l mt mu">NAME        READY   UP-TO-DATE   AVAILABLE   AGE<br/>django-app   3/3     3           3          3m21s</span></pre><p id="5289" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您遇到一个错误或一些不太正常的事情，您可以使用<code class="fe mv mw mx mm b">kubectl describe</code>来检查失败的部署:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="d11c" class="mq lp iq mm b gy mr ms l mt mu">$kubectl describe deplo</span></pre><p id="75bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以使用<code class="fe mv mw mx mm b">kubectl get pod</code>检查两个吊舱:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="d3b0" class="mq lp iq mm b gy mr ms l mt mu">$kubectl get pod</span></pre><p id="a1bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="f893" class="mq lp iq mm b gy mr ms l mt mu">NAME                         READY   STATUS    RESTARTS   AGE<br/>django-app-7c55868755-4wglz   1/1     Running   0             2m5s<br/>django-app-7c55868755-7tpjd   1/1     Running   0             2m5s<br/>django-app-7c55868755-9s4s8   1/1     Running   0             2m5s</span></pre><p id="0b14" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您的Django应用程序的三个副本现在已经在集群中启动并运行。要访问该应用程序，您需要创建一个Kubernetes服务，这是我们接下来要做的。</p><h1 id="1603" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">步骤5-允许使用服务进行外部访问</h1><p id="028e" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在这一步中，您将为您的Django应用程序创建一个服务。Kubernetes服务是一种抽象，它允许您将一组正在运行的pod作为网络服务公开。使用服务，您可以为您的应用程序创建一个稳定的端点，它不会随着pod的死亡和重新创建而改变。</p><p id="094a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有多种服务类型，包括ClusterIP服务，它在集群内部IP上公开服务；节点端口服务，它在称为节点端口的静态端口上公开每个节点上的服务；以及负载平衡器服务，它提供云负载平衡器以将外部流量定向到集群中的单元(通过它自动创建的节点端口)。要了解更多相关信息，请参见Kubernetes文档中的<a class="ae ln" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>。</p><p id="038c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先使用您最喜欢的编辑器创建一个名为<code class="fe mv mw mx mm b">django-svc.yaml</code>的文件:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="e406" class="mq lp iq mm b gy mr ms l mt mu">$vim django-svc.yaml</span></pre><p id="f778" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">粘贴以下服务清单:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="23e8" class="mq lp iq mm b gy mr ms l mt mu">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: django<br/>  labels:<br/>    app: django<br/>spec:<br/>  type: NodePort<br/>  selector:<br/>    app: django<br/>  ports:<br/>    - port: 8000<br/>      targetPort: 8000</span></pre><p id="9bec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们创建了一个名为<code class="fe mv mw mx mm b">django</code>的节点端口服务，并给它贴上了<code class="fe mv mw mx mm b">app: django</code>标签。然后，我们选择带有<code class="fe mv mw mx mm b">app: django</code>标签的后端pod，并将它们的<code class="fe mv mw mx mm b">8000</code>端口作为目标。</p><p id="fbb6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">编辑完文件后，保存并关闭它。</p><p id="4b8d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe mv mw mx mm b">kubectl apply</code>推出服务:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="1a64" class="mq lp iq mm b gy mr ms l mt mu">$kubectl apply -f django-svc.yaml</span></pre><p id="2f92" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="19be" class="mq lp iq mm b gy mr ms l mt mu">service/django created</span></pre><p id="0f53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">确认您的服务是使用<code class="fe mv mw mx mm b">kubectl get svc</code>创建的:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="a007" class="mq lp iq mm b gy mr ms l mt mu">$kubectl get svc django</span></pre><p id="11ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="620e" class="mq lp iq mm b gy mr ms l mt mu">NAME    TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE<br/>django       NodePort    10.107.211.249   &lt;none&gt;        8000:30306/TCP   15s</span></pre><p id="e227" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该输出显示了服务的集群内部IP和节点端口(<code class="fe mv mw mx mm b">30306</code>)。为了连接到服务，我们需要集群节点的外部IP地址:</p><p id="0cca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在web浏览器中，使用http://localhost:30306访问Django应用程序</p><p id="01ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您应该会看到在步骤1中本地访问的Django应用程序接口。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/993213e989f507ff29e99cc1404e6824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8VJlvZOrVJNPWU8cb34Jxg.png"/></div></div></figure><p id="1469" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个阶段，您已经使用一个部署推出了Django应用程序容器的三个副本。您还为这三个副本创建了一个稳定的网络端点，并使用NodePort服务使其可以从外部访问。</p><h1 id="5968" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="b6f0" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在本教程中，您在Kubernetes集群中部署了一个可伸缩的Django应用程序。使用<code class="fe mv mw mx mm b">django-app</code>部署清单中的<code class="fe mv mw mx mm b">replicas</code>字段，可以快速扩大或缩小运行单元。</p><p id="cfbd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下一次我将向您展示如何从GitHub资源库部署您自己的项目。</p></div></div>    
</body>
</html>