<html>
<head>
<title>Build a Game of Chess With SpriteKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用SpriteKit构建一个国际象棋游戏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-game-of-chess-with-spritekit-3229c23bdba0?source=collection_archive---------7-----------------------#2021-08-10">https://betterprogramming.pub/build-a-game-of-chess-with-spritekit-3229c23bdba0?source=collection_archive---------7-----------------------#2021-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="236d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在SpriteKit中以编程方式使用tilesets</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9c85a8ef0ea9ed459ff84759bc950074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JvV-oj0F0Fjr_MJr-yvt4g.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">国际象棋比赛中的头球</p></figure><p id="1402" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我开始涉足计算机领域时，那是很久很久以前的1982年，在一个很远很远的地方，名叫英格兰。微软没有垄断市场，Windows [1995]也不存在。命令行是可行的方法——一边是MSDOS，另一边是UNIX。</p><p id="653d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我在1985年去大学学习计算机科学时，一切都是以命令行为中心的。甚至连IDE都不在大计划中；直到1991年才出现。这是一种从未离开我的工作方式；只是感觉键入一个命令来做你想做的事情比使用GUI更有效。</p><p id="082b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我告诉你我想在SpriteKit中讨论tilemaps时，你不会感到惊讶，这里不是通过GUI Apple build，而是通过代码。感觉像命令行的代码。加入我的旅程，使用tilemaps构建一个国际象棋游戏。Tilemaps是程序员，不是设计师。尽管在我们开始之前，让我们确保我们在这一页上是一致的。</p><p id="7a77" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">自从游戏引擎出现以来，“TileMaps”就一直是游戏引擎不可或缺的一部分。它们的出现是因为设计者和编码者需要有效地描绘背景场景的方法。在初始构建和实际更新方面都很高效。拼贴贴图通过将背景分解成由重复拼贴集合组成的网格来解决这个问题。</p><p id="956a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，棋盘游戏都是关于格子的。tilemap的理想工作，具有附加价值，tile map旨在提供一种简单/有效的方法来检测您所在的瓷砖-实际上非常适合棋盘游戏。一盘棋。</p><p id="a1dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们从基本代码开始:SwiftUI界面中的一个<code class="fe lu lv lw lx b">SpriteKit</code>场景。实际上是两个，因为我想要一个动画封面，你可以在这里读到:</p><div class="ly lz gp gr ma mb"><a rel="noopener  ugc nofollow" target="_blank" href="/text-sfx-with-swiftui-spritekit-c3f9777f0f1c"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd iu gy z fp mg fr fs mh fu fw is bi translated">使用SpriteKit在SwiftUI中创建漂亮的文本效果</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">将SpriteKit和核心图像过滤器集成到SwiftUI应用程序中</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">better编程. pub</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp ks mb"/></div></div></a></div><h1 id="a266" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">棋盘</h1><p id="0e7a" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">为了搭建这块板，我们需要两种瓷砖:深色的和浅色的。为了制作瓷砖，我将使用<code class="fe lu lv lw lx b">CoreImage</code>来绘制和创建纹理。它在编码设计中工作良好，因为它易于布局。所绘制的图像是带有黑色轮廓的着色盒子。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="2c40" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">值得一提的是，网格的布局是纯数学的。场景尺寸为512 x 256这些瓷砖是64 x 32的。为此，单幅图块的大小需要是场景的倍数。除此之外，我需要用它来构建我的代码板。为此，单幅图块的大小需要是场景的倍数。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8700" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来是棋子。我将从<a class="ae np" href="https://thenounproject.com/" rel="noopener ugc nofollow" target="_blank">新项目</a>下载棋子。我只需要每种类型的一个副本，因为我计划再次使用CoreImage过滤器来着色。我下载它们，给我的图像集命名，这样我就可以很容易地迭代，并创建我的精灵。我需要16个兵，4个城堡，4个骑士，4个主教，2个女王和2个国王。这是我将使用的所有图片的合成，我将单独加载。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/85e725cc8348d17fea7049d9fff31eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xud4_lk57VE_ASCjZUaRCg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由Joni为<a class="ae np" href="https://thenounproject.com" rel="noopener ugc nofollow" target="_blank"> thenounproject </a>创建</p></figure><p id="210f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在应用程序中，这个方法有三个调用，带有要加载的图像的名称，也就是“a00”、“b0”和“c0”。我将使用这些图像来建立精灵。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8d7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个方法创建了我使用的精灵，其中有两个值得注意的方法。第一，<code class="fe lu lv lw lx b">resizedImage</code>函数做三件事:</p><ul class=""><li id="858c" class="nr ns it la b lb lc le lf lh nt ll nu lp nv lt nw nx ny nz bi translated">运行一个<code class="fe lu lv lw lx b">CIFilter</code>将图像中所有白色像素的颜色改为颜色X，不幸的是，它的副作用是将透明度也改为白色。</li><li id="6ffa" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">运行一个<code class="fe lu lv lw lx b">CIFilter</code>把新的白色像素变回透明。</li><li id="ad92" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">用新尺寸重绘图像。</li></ul><p id="20ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9ddb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二个“可触摸的sprite”就是这样做的:创建一个可以在棋盘上拖动的sprite，并使用可触摸的Sprite协议触发两个委托方法。这些方法由触地/上升事件触发。</p><pre class="kj kk kl km gt of lx og oh aw oi bi"><span id="2832" class="oj mr it lx b gy ok ol l om on">protocol touchMe: NSObjectProtocol {<br/>  func spriteTouched(box: TouchableSprite)<br/>  func spriteSelected(box: TouchableSprite)<br/>}</span></pre><p id="22e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一种方法基本上是从那个方块中取消所述精灵的注册。第二个将sprite注册在一个新的方块中。在注册它之前，该方法还检查在所述方块上是否已经有一个棋子，如果有，则移除它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/cb966e8dca557767949780318067e824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Vwh5PdIfeeys_ip2All-0Q.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用spriteKit牌组的国际象棋游戏</p></figure><p id="bd99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有这些都让我想到了这篇文章的结尾。这里是<code class="fe lu lv lw lx b">ContentView.swift</code>和主<code class="fe lu lv lw lx b">GameView</code>的完整代码。我没有包括您在本文开头看到的标题。我把它留给你玩。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="2b0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">GameView.swift</code>的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8025" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来去哪里？以下是一些想法:</p><ul class=""><li id="9169" class="nr ns it la b lb lc le lf lh nt ll nu lp nv lt nw nx ny nz bi translated">修正被拖动的精灵不总是出现在顶部的问题。</li><li id="fd79" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">更新用户界面，这样你就可以看到谁赢了/谁输了。</li><li id="02c2" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">实现一个网络代码，这样你就可以和你的朋友一起玩了。</li><li id="8ebe" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">设置一个某种形式的时钟，这样你就可以记录每个玩家花了多长时间才轮到他们。</li><li id="917d" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">验证请求的移动，并且只允许有效的移动。</li><li id="8344" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">以此为基础，创建一个不同的广泛的游戏(跳棋，有人吗？或者可能是围棋比赛)。</li></ul><p id="cb28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。</p></div></div>    
</body>
</html>