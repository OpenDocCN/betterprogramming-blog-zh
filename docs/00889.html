<html>
<head>
<title>Building a Synthesizer in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中构建合成器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-synthesizer-in-swift-866cd15b731?source=collection_archive---------1-----------------------#2019-07-25">https://betterprogramming.pub/building-a-synthesizer-in-swift-866cd15b731?source=collection_archive---------1-----------------------#2019-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f406" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用AVAudioEngine制作音频波形</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/943aefae5256e775cb11c64f035d0eeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8YB2_PbPryzot7gwJ6slgw.jpeg"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">一个随机合成器…</p></figure><p id="d1ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在WWDC 19期间，苹果通过一个短视频悄悄宣布了对AVAudioEngine的一些更新。</p><p id="95f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些更新包括两个全新的AVAudioNodes，称为AVAudioSinkNode和AVAudioSourceNode。在这篇文章中，我们将重点讨论如何使用AVAudioSourceNode为iOS构建音乐合成器。</p><p id="9840" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在苹果的幻灯片中，他们将这两个新节点共同定义为“<em class="lb">的包装器，这是一个用户定义的块，允许应用程序发送或接收来自AVAudioEngine的音频。</em>“在我们的例子中，我们将向音频信号处理网络的输出端发送音频数据。AVAudioSourceNode提供了一个尾部闭包表达式，它接受四个参数。我们只需要最后两个，它们的类型是AVAudioFrameCount和UnsafeMutablePointer(指向一个音频缓冲区列表)。闭包的返回类型是OSStatus，它将用于指示合成器振荡器的DSP(数字信号处理)代码是否运行顺畅。</p><p id="036e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">AVAudioSourceNode可以在实时和手动渲染模式下使用，这意味着它可以用来将音频直接写入音频文件，或者在我们的情况下，在现场环境中创建声音。</p><p id="acc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，苹果给了我们一个极其重要的警告:你在AVAudioSourceNode的块<em class="lb">中写的代码必须是实时兼容的</em>。这意味着在音频线程上，不应该初始化任何对象，也不应该分配任何内存。音频节目实时性尤其重要，因为音频编码的滞后会导致缓冲不足或溢出，从而产生咔哒声和爆裂声。这些咔哒声在现场表演中是毁灭性的，因为它们不仅会损害用户的听力，还会损害用户的扬声器。</p><p id="e90c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，介绍完毕，让我们开始构建合成器吧！</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lc ld l"/></div><p class="kx ky gj gh gi kz la bd b be z dk translated">我们将建立的应用程序的快速视频。</p></figure><p id="5499" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要跟随本教程，您需要Xcode 11或更高版本。如果你想在一个设备上而不是模拟器上运行你完成的应用，那个设备需要安装iOS 13或更高版本。</p><p id="5537" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦你的Xcode是最新的，打开它并导航到<strong class="jp ir">文件- &gt;新建- &gt;项目</strong>。选择<strong class="jp ir"> iOS </strong>和<strong class="jp ir">单视图应用</strong>。将<strong class="jp ir">产品名称</strong>设置为“Swift Synth”或任何您喜欢的名称。点击下一个的<strong class="jp ir">，导航到您想要保存应用程序的目录，然后点击<strong class="jp ir">创建</strong>。</strong></p><p id="0700" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来做一些维护。在本教程中，我将以编程方式设计UI。如果你喜欢，可以随意使用故事板——无论哪种方式都应该很容易理解。</p><p id="65f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">项目应该已经打开到项目设置。如果您不想使用故事板，向下滚动到<strong class="jp ir">常规</strong>中的<strong class="jp ir">部署信息</strong>选项卡，并清除<strong class="jp ir">主界面</strong>右侧的文本字段。接下来，在<strong class="jp ir">项目导航器</strong>中找到<strong class="jp ir"> Main.storyboard </strong>文件并将其删除。最后，我们需要进入<strong class="jp ir"> Info.plist </strong>文件，删除属于<strong class="jp ir">故事板名称</strong>的字段。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi le"><img src="../Images/0bf4c471ce689c104f99d61d402b11d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AQF1T2da3TZPNOfX7y_3Uw.jpeg"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">按照以下步骤清除主界面。</p></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lf"><img src="../Images/14473679144fefcf8688d36f5438aaf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I58ZIxhasjc3fAvqNP6_sA.jpeg"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">单击箭头所指处的减号按钮，删除指示的字段。您必须通过结构向下钻取，才能到达指定的字段。</p></figure><p id="6ae9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">iOS 13和Xcode 11的更新之一是引入了SceneDelegate.swift，它管理你的应用程序中的各种<code class="fe lg lh li lj b">UIScene</code><strong class="jp ir"/>，并专门与顶级<code class="fe lg lh li lj b">UIWindowScene</code> <strong class="jp ir"> </strong>进行交互，以管理多个窗口。</p><p id="bed6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了在配置时设置根视图控制器，我们现在使用<code class="fe lg lh li lj b">scene willConnectTo session: UISceneSession</code>函数。首先，我们应该尝试将场景投射到一个<code class="fe lg lh li lj b">UIWindowScene</code>。如果成功，我们可以继续初始化<code class="fe lg lh li lj b">SceneDelegate</code>的<code class="fe lg lh li lj b">window</code>属性。</p><p id="6535" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将把windowScene的<code class="fe lg lh li lj b">coordinateSpace</code> <strong class="jp ir"> </strong>的<code class="fe lg lh li lj b">bounds</code> <strong class="jp ir"> </strong>传递到包含一帧的初始化器中。接下来，将窗口的<code class="fe lg lh li lj b">windowScene</code>属性设置为我们之前创建的<code class="fe lg lh li lj b">windowScene</code>常量。将窗口的<code class="fe lg lh li lj b">rootViewController</code>设置为<code class="fe lg lh li lj b">ViewController</code>。</p><p id="5fe6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，确保调用window上的<code class="fe lg lh li lj b">makeKeyAndVisible</code>方法来呈现UI。为了确保一切正常，构建并运行应用程序。您应该会看到一个空白屏幕，并且控制台中没有错误。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lk ld l"/></div></figure><p id="afb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，打开ViewController.swift。为了清楚起见，command单击类名并从下拉列表中选择rename选项。在文本框中键入SynthViewController以重命名文件和类。当编程一个新的视图控制器时，我喜欢做的第一件事是用标记注释把它去掉:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lk ld l"/></div></figure><p id="c20a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先创建应用程序的音频部分会更容易。创建一个新的Swift文件(<strong class="jp ir">File-&gt;New-&gt;File</strong>)，命名为<strong class="jp ir"> Synth </strong>。通过导入<code class="fe lg lh li lj b">AVFoundation</code>和<code class="fe lg lh li lj b">Foundation</code>开始:</p><pre class="km kn ko kp gt ll lj lm ln aw lo bi"><span id="a6de" class="lp lq iq lj b gy lr ls l lt lu"><strong class="lj ir">import</strong> AVFoundation</span><span id="e86d" class="lp lq iq lj b gy lv ls l lt lu"><strong class="lj ir">import</strong> Foundation</span></pre><p id="b66f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后创建一个名为<strong class="jp ir"> Synth </strong>的类，并用相同的标记注释将其删除。您还需要创建一个初始化器，尽管我们稍后会修改它的参数:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lk ld l"/></div></figure><p id="57a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将通过在Synth的定义中添加一个静态共享实例属性，使其成为一个<code class="fe lg lh li lj b">singleton</code>。这将允许我们从任何视图控制器轻松访问它:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lk ld l"/></div></figure><p id="6b0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们将添加一些与合成器实际音频相关的属性。第一个是<code class="fe lg lh li lj b">volume</code>属性，它允许我们模拟合成器的开关。我们合成器中最重要的变量是引擎，这是一个音频引擎。音频引擎将承载我们添加到信号链中的音频节点。最后三个是时间变量，我们将在后面详细讨论。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lk ld l"/></div></figure><p id="e28a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要初始化这些属性，先去初始化器，从初始化<code class="fe lg lh li lj b">audioEngine</code>开始。接下来，创建两个引用<code class="fe lg lh li lj b">audioEngine</code>的<code class="fe lg lh li lj b">mainMixerNode</code>和<code class="fe lg lh li lj b">outputNode</code>的常量。</p><p id="4ac4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一次提到的<code class="fe lg lh li lj b">mainMixerNode</code>是连接到<code class="fe lg lh li lj b">outputNode</code>的单例。它充当源节点和<code class="fe lg lh li lj b">outputNode</code>之间的中介。</p><p id="6949" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后通过调用<code class="fe lg lh li lj b">outputNode</code>上总线0的<code class="fe lg lh li lj b">inputFormat</code>函数创建一个<code class="fe lg lh li lj b">format</code>常量。该格式将为我们提供正在使用的设备的默认音频设置。例如，我们可以通过访问格式的<code class="fe lg lh li lj b">sampleRate</code>属性来设置我们的<code class="fe lg lh li lj b">sampleRate</code>属性。如果采样率的概念对你来说是新的，我建议你快速绕道，在youtube上查看音频程序员关于音频软件基础的<a class="ae lw" href="https://www.youtube.com/watch?v=PLuBamvtBZU" rel="noopener ugc nofollow" target="_blank">视频</a>。</p><p id="fa8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，将<code class="fe lg lh li lj b">deltaTime</code>浮子设置为比<code class="fe lg lh li lj b">sampleRate</code>高出一个。增量时间是每个样本被保持的持续时间。例如，如果<code class="fe lg lh li lj b">sampleRate</code>是44，100 Hz，你可以用一秒钟除以44，100来表示每个样本。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lk ld l"/></div></figure><p id="d383" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在已经到了可以开始投入<code class="fe lg lh li lj b">AVAudioSourceNode</code>的时候了。</p><p id="62f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先在<code class="fe lg lh li lj b">Synth</code>类定义之外定义一个叫做<code class="fe lg lh li lj b">Signal</code>的<code class="fe lg lh li lj b">typealias</code>。<code class="fe lg lh li lj b">Signal</code>将是一个闭包类型，它接受一个浮点数来表示时间，并返回一个用于音频样本的浮点数:</p><pre class="km kn ko kp gt ll lj lm ln aw lo bi"><span id="e32f" class="lp lq iq lj b gy lr ls l lt lu"><strong class="lj ir">typealias</strong> Signal = (Float) -&gt; (Float)</span></pre><p id="243d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在<code class="fe lg lh li lj b">Synth</code> <strong class="jp ir"> </strong>内部添加一个名为<code class="fe lg lh li lj b">signal</code>的<code class="fe lg lh li lj b">Signal</code>类型的变量。</p><p id="0d68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，添加一个类型为<code class="fe lg lh li lj b"> AVAudioSourceNode</code>的<code class="fe lg lh li lj b">sourceNode</code>变量。确保<code class="fe lg lh li lj b">lazily</code>初始化<code class="fe lg lh li lj b">sourceNode</code>，因为我们将在其尾随闭包中引用<code class="fe lg lh li lj b">self</code> <strong class="jp ir"> </strong>。您可以按enter键来自动完成一个基本的闭包结构。对于这两个参数，键入下划线，因为它们不是必需的。</p><p id="a5df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后两个应该命名为<code class="fe lg lh li lj b">frameCount</code>和<code class="fe lg lh li lj b">audioBufferList</code>。在这个块中，首先在初始化器中将一个名为<code class="fe lg lh li lj b">ablPointer</code>的指针定义为<code class="fe lg lh li lj b">UnsafeMutableAudioBufferListPointer</code>。<code class="fe lg lh li lj b">audioBufferList</code>保存了一个音频缓冲结构数组，我们将用自定义波形填充它。音频中使用缓冲区，使应用程序有1/44，100秒以上的时间在渲染块中生成样本。音频缓冲区通常包含128到1024个样本。</p><p id="56ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们创建一个for循环来遍历0和我们的<code class="fe lg lh li lj b">frameCount</code>变量之间的索引值。</p><p id="8a45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在音频中，帧是同时发生的样本集。在立体声音频中，每帧包含两个样本，一个用于左耳，另一个用于右耳。在我们的例子中，我们将把两个样本设置为相同的值，因为我们的合成器是单声道的。</p><p id="f71c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在for循环内部，我们将通过用Synth的time属性调用我们的信号闭包来获得<code class="fe lg lh li lj b">sampleVal</code>，然后用<code class="fe lg lh li lj b">deltaTime</code>推进时间。</p><p id="c835" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">指向一个数组，这意味着我们可以这样对待它，并在一个嵌套的for循环中遍历它的内容。</p><p id="4984" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于每一个<code class="fe lg lh li lj b">buffer</code> <strong class="jp ir"> </strong>元素，我们必须将其转换为一个浮点指针。然后，我们可以在当前帧索引缓冲区，并将其设置为之前找到的<code class="fe lg lh li lj b">sampleVal</code>。</p><p id="3c1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，如果一切顺利，不要忘记返回<code class="fe lg lh li lj b">noErr</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lk ld l"/></div></figure><p id="b676" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以回到初始化器，完成Synth的设置。</p><p id="131c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先向转义<code class="fe lg lh li lj b">Signal</code>类型的名为<code class="fe lg lh li lj b">signal</code> <strong class="jp ir"> </strong>的初始化器添加一个参数。然后，在初始化器中，将<code class="fe lg lh li lj b">self.signal</code>设置为<code class="fe lg lh li lj b">signal</code>参数。</p><p id="88f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个类型为<code class="fe lg lh li lj b">AVAudioFormat</code>的<code class="fe lg lh li lj b">inputFormat</code>——用格式的属性填充参数，并将通道限制为一个。然后，将<code class="fe lg lh li lj b">sourceNode</code> <strong class="jp ir"> </strong>附加到<code class="fe lg lh li lj b">audioEngine</code>上，为其引入音频图。</p><p id="05da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以使用<code class="fe lg lh li lj b">inputFormat</code>将<code class="fe lg lh li lj b">sourceNode</code>连接到<code class="fe lg lh li lj b">mainMixer</code>。</p><p id="04ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步是将<code class="fe lg lh li lj b">mainMixer</code>连接到<code class="fe lg lh li lj b">outputNode</code>上。您可以将<code class="fe lg lh li lj b">mainMixer</code>的<code class="fe lg lh li lj b">outputVolume</code>设置为初始值0，因为在没有用户首先请求的情况下，它不应该发出声音。</p><p id="4949" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们需要调用<code class="fe lg lh li lj b">audioEngine</code>上的<code class="fe lg lh li lj b">start</code>方法来初始化硬件I/O节点。这个函数可能会抛出一个错误，所以您需要使用try关键字处理该行，并将整个语句包装在do-catch块中。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lk ld l"/></div></figure><p id="cb92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然我们已经很好地封装了Synth的所有属性，我们将需要一个公共的访问器方法来设置Synth的信号。</p><pre class="km kn ko kp gt ll lj lm ln aw lo bi"><span id="8843" class="lp lq iq lj b gy lr ls l lt lu">// MARK:<strong class="lj ir"> Public Functions</strong></span><span id="337e" class="lp lq iq lj b gy lv ls l lt lu"><strong class="lj ir">public</strong> <strong class="lj ir">func</strong> setWaveformTo(<strong class="lj ir">_</strong> signal: <strong class="lj ir">@escaping</strong> Signal) {</span><span id="fafd" class="lp lq iq lj b gy lv ls l lt lu"><strong class="lj ir">    self</strong>.signal = signal</span><span id="4876" class="lp lq iq lj b gy lv ls l lt lu">}</span></pre><p id="9384" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了开始制作音频，我们需要制作一组符合<code class="fe lg lh li lj b">Signal</code>类型的闭包表达式。让我们首先创建一个名为<code class="fe lg lh li lj b">Oscillator</code>的swift文件。请随意将<code class="fe lg lh li lj b">Signal<strong class="jp ir"> </strong></code>的typealias移到这个文件中，因为它应该很合适。</p><p id="9175" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先创建一个名为<strong class="jp ir"> </strong> <code class="fe lg lh li lj b">Oscillator</code>的结构。给<code class="fe lg lh li lj b">Oscillator</code>添加两个静态浮点变量，分别叫做振幅和频率，分别给它们初始值1和440 (Concert A)。</p><pre class="km kn ko kp gt ll lj lm ln aw lo bi"><span id="95ef" class="lp lq iq lj b gy lr ls l lt lu"><strong class="lj ir">import</strong> Foundation</span><span id="29c5" class="lp lq iq lj b gy lv ls l lt lu"><strong class="lj ir">struct</strong> Oscillator {</span><span id="e9e4" class="lp lq iq lj b gy lv ls l lt lu"><strong class="lj ir">    static</strong> <strong class="lj ir">var</strong> amplitude: Float = 1</span><span id="3b7e" class="lp lq iq lj b gy lv ls l lt lu"><strong class="lj ir">    static</strong> <strong class="lj ir">var</strong> frequency: Float = 440</span><span id="dab1" class="lp lq iq lj b gy lv ls l lt lu">}</span></pre><p id="d816" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从构建正弦振荡器开始，因为它是最简单的。</p><p id="8055" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe lg lh li lj b">Oscillator</code>中，创建一个名为<code class="fe lg lh li lj b">sine</code>的常量静态闭包表达式，带有一个用于时间的Float参数和一个用于它将输出的样本的Float返回类型。在闭合块内，计算2 * pi * <code class="fe lg lh li lj b">Oscillator.frequency</code> * <code class="fe lg lh li lj b">time</code>的正弦。然后将输出乘以<code class="fe lg lh li lj b">Oscillator.amplitude</code>并返回结果。</p><p id="bab5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你学过三角学，你会知道正弦是时间的周期函数，周期等于(2 * pi)除以b，其中b是时间或x在被传递到函数之前要乘以的因子。在我们的例子中，b等于(2 * pi * <code class="fe lg lh li lj b">Oscillator.frequency</code>)。这意味着我们的正弦波的周期是(1 / <code class="fe lg lh li lj b">Oscillator.frequency</code>)。这非常有意义，因为我们的频率是以赫兹或每秒周期数为单位的。如果正弦波每秒有440个周期，则每个周期被分配1/440秒。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lk ld l"/></div></figure><p id="a729" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们要建立的下一个振荡器是三角波。这也将是一个常量静态闭包表达式，具有相同的参数。</p><p id="3a96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于三角波，我们把它分成三个部分:初始倾斜、转折点和后倾斜。我们首先通过用1除以<code class="fe lg lh li lj b">Oscillator.frequency</code>来计算三角波的周期。但是，因为标准库中没有内置三角形函数，所以我们必须计算当前样本相对于当前周期的位置。</p><p id="9e9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过将经过的总的<code class="fe lg lh li lj b">time</code>的浮点余数除以<code class="fe lg lh li lj b">period</code>来找到<code class="fe lg lh li lj b">currentTime</code>常数。例如，如果<code class="fe lg lh li lj b">time</code>当前等于17.5，而<code class="fe lg lh li lj b">period</code>是5，则17.5 / 5的余数将是2.5。</p><p id="668b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这些信息，我们可以创建一个<code class="fe lg lh li lj b">value</code>常量来保存当前周期的进度百分比。这个百分比是用<code class="fe lg lh li lj b">currentTime</code> (2.5)除以<code class="fe lg lh li lj b">period</code> (5)得到的。这表明我们正好完成了电流波形的50%。</p><p id="0398" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用<code class="fe lg lh li lj b">value</code>常数来计算<code class="fe lg lh li lj b">result</code>样本值。如果<code class="fe lg lh li lj b">value</code>小于0.25，我们在三角形的前四分之一，从0到1倾斜。出于这个原因，我们将<code class="fe lg lh li lj b">result</code>设置为等于电流<code class="fe lg lh li lj b">value</code>的4倍。如果<code class="fe lg lh li lj b">value</code>大于或等于0.25且小于0.75，波形从1下降到-1。<code class="fe lg lh li lj b">Result</code>将相等的值乘以4再减去2。我们从上一个if语句中知道(值* 4)在1处结束，因此我们将从(2–1 = 1)处开始，这是峰值。最后一条else语句的工作方式与前两条相似。最后一步是将<code class="fe lg lh li lj b">result</code> <strong class="jp ir"> </strong>转换回一个<code class="fe lg lh li lj b">Float</code>并乘以<code class="fe lg lh li lj b">Oscillator.amplitude</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lk ld l"/></div></figure></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><p id="ff9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来我们要构建的两个振荡器是锯齿波和方波。遵循与之前相同的约定，这两个都是静态闭包表达式。</p><p id="e031" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还将重复使用三角波中应用的相同数学方法来查找锯齿波和方波中每个样本的位置。在锯齿振荡器中，百分比值将简单地乘以2(0–2)。最后的<code class="fe lg lh li lj b">result</code>将是该值减1(-1–1)并乘以<code class="fe lg lh li lj b">Oscillator.amplitude</code>。</p><p id="c025" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在方波中，如果值<strong class="jp ir"> </strong>小于0.5，闭包返回负的<code class="fe lg lh li lj b">Oscillator.amplitude</code>。否则，它简单地返回<code class="fe lg lh li lj b">Oscillator.amplitude</code>。这种只有两种状态的限制产生了突然的高能跃迁，增加了一系列高次奇次谐波。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lk ld l"/></div></figure><p id="86ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们将创建一个<code class="fe lg lh li lj b">whiteNoise</code> <strong class="jp ir"> </strong>振荡器。这是迄今为止最容易编程和理解的方法，因为它只是随机的<code class="fe lg lh li lj b">Float</code>样本值。</p><p id="2ea9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着Swift 4.2的发布，像<code class="fe lg lh li lj b">Float</code>这样的原始数值类型有了一个新的静态方法，叫做random(in:)。有了这个新功能，我们可以简单地传入一个从-1到1的封闭范围(…)并乘以<code class="fe lg lh li lj b">Oscillator.amplitude</code>来获得样本。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lk ld l"/></div></figure><p id="00be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太棒了，我们成功了！</p><p id="6703" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在有一个完全用Swift构建的5波形振荡器。让我们回到<code class="fe lg lh li lj b">SynthViewController</code>，这样我们可以给它一个合适的用户界面。</p><p id="e6b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要一个<code class="fe lg lh li lj b">UISegmentedControl</code>在我们的波形之间切换。我用的方形图标可以在这里找到<a class="ae lw" href="https://drive.google.com/drive/folders/1Po35zw-zJwqVwSuzSNpqbc4xBha_19wv?usp=sharing" rel="noopener ugc nofollow" target="_blank">。我没有创建这些图标，所以在没有从NounProject上的</a><a class="ae lw" href="https://thenounproject.com/marcogaltarossa/" rel="noopener ugc nofollow" target="_blank">这个艺术家页面</a>购买之前，请不要将它们用于商业用途。</p><p id="33ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将添加的另一个组件是UILabel，用于显示产生的电流波形的频率和幅度。我们将惰性地初始化这些私有变量，这样我们可以在闭包表达式中访问self，如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lk ld l"/></div></figure><p id="f7c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以创建两个新的私有函数，名为<code class="fe lg lh li lj b">setUpView</code>和<code class="fe lg lh li lj b">setUpSubviews</code>。它们都将在我们的应用程序生命周期开始时在<code class="fe lg lh li lj b">viewDidLoad</code>函数中被调用。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lk ld l"/></div></figure><p id="6be4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们实现作为选择器添加到<code class="fe lg lh li lj b">waveformSelectorSegmentedControl</code>中的<code class="fe lg lh li lj b">updateOscillatorWaveform</code>函数。</p><p id="4c2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，为了在<code class="fe lg lh li lj b">UISegmentedControl</code>的索引值和振荡器类型之间建立接口，在Oscillator.swift文件中创建一个名为<code class="fe lg lh li lj b">Waveform</code>的<code class="fe lg lh li lj b">Int</code>类型的枚举。</p><p id="89ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后添加以下案例:<code class="fe lg lh li lj b">sine</code>、<code class="fe lg lh li lj b">triangle</code>、<code class="fe lg lh li lj b">sawtooth</code>、<code class="fe lg lh li lj b">square</code>、<code class="fe lg lh li lj b">whiteNoise</code>。它们应该完全按照<em class="lb">的顺序排列，</em>只要你完全按照我在<code class="fe lg lh li lj b">waveformSelectorSegmentedControl</code>声明中写的方式复制<code class="fe lg lh li lj b">images</code> <strong class="jp ir"> </strong>数组。</p><pre class="km kn ko kp gt ll lj lm ln aw lo bi"><span id="6a3c" class="lp lq iq lj b gy lr ls l lt lu"><strong class="lj ir">enum</strong> Waveform: Int {</span><span id="c276" class="lp lq iq lj b gy lv ls l lt lu"><strong class="lj ir">    case</strong> sine, triangle, sawtooth, square, whiteNoise</span><span id="cfa9" class="lp lq iq lj b gy lv ls l lt lu">}</span><span id="6def" class="lp lq iq lj b gy lv ls l lt lu"><strong class="lj ir">struct</strong> Oscillator {<br/>...</span></pre><p id="3a07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lg lh li lj b">updateOscillatorWaveform</code> <strong class="jp ir"> </strong>的实际实现会涉及到用<code class="fe lg lh li lj b">waveformSelectorSegmentedControl</code>的<code class="fe lg lh li lj b">selectedSegmentIndex</code> <strong class="jp ir"> </strong>属性调用<code class="fe lg lh li lj b">Waveform</code> <strong class="jp ir"> </strong>上的<code class="fe lg lh li lj b">rawValue</code>初始化器。</p><p id="537f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，可以用产生的<code class="fe lg lh li lj b">waveform</code>定义一个switch语句。对于五种情况中的每一种，用各自的<code class="fe lg lh li lj b">Oscillator</code>波形调用<code class="fe lg lh li lj b">Synth.shared.setWaveformTo</code>。</p><p id="468a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还应该快速实现一个<code class="fe lg lh li lj b">setPlaybackStateTo(state:)</code>函数来打开和关闭我们的synth。该函数将简单地接受一个名为<code class="fe lg lh li lj b">state</code>的布尔值，并使用三元运算符将<code class="fe lg lh li lj b">Synth.shared.volume</code>设置为0.5或0。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lk ld l"/></div></figure><p id="860f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们使用已经包含在<code class="fe lg lh li lj b">UIViewController</code>中的触摸相关方法，允许用户操纵振荡器的音高。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lk ld l"/></div></figure><p id="32fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！构建它，并在iOS 13设备或模拟器上运行应用程序来测试它。</p><p id="dc6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望您在学习如何在Swift中构建synths的过程中度过了愉快的时光。如果你有任何错误或者我犯了任何错误，请在下面留下你的评论。</p><p id="c70f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想下载最终的Xcode项目，你可以在Github <a class="ae lw" href="https://github.com/GrantJEmerson/SwiftSynth" rel="noopener ugc nofollow" target="_blank">这里</a>找到。此外，我在本教程中使用的许多代码都是在苹果的示例项目<a class="ae lw" href="https://developer.apple.com/documentation/avfoundation/audio_track_engineering/building_a_signal_generator" rel="noopener ugc nofollow" target="_blank">中找到的。如果你想了解更多关于AVAudioEngine的新内容，你可以在这里找到WWDC的视频</a><a class="ae lw" href="https://developer.apple.com/videos/play/wwdc2019/510/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="5f5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下次见！</p></div></div>    
</body>
</html>