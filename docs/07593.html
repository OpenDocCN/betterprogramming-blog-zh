<html>
<head>
<title>How to Design Software — Plugin Systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何设计软件——插件系统</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-design-software-plugins-d051ce1099b2?source=collection_archive---------0-----------------------#2021-01-31">https://betterprogramming.pub/how-to-design-software-plugins-d051ce1099b2?source=collection_archive---------0-----------------------#2021-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="304d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以聊天机器人为例，学习如何构建一个插件系统来允许其他人扩展你的程序的功能和模块化。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7348bf66756aa0a446295b3c2a707fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ij0wLGQy8JhEujHKijjGGg.png"/></div></div></figure><p id="3d8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我年轻的时候，有一台顶级的游戏电脑。我花了数千小时玩游戏，如团队要塞2，《我的世界》，激战，帝国时代。</p><p id="cc2a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我彻底探索了一个游戏之后，我最喜欢的活动之一就是练习<em class="lq">改装</em>。修改允许你创建或下载软件包，改变或增加软件的行为——新的关卡，纹理，甚至游戏机制！可能性是无限的。</p><p id="826c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我是一名软件开发人员，我对这些程序中有多少支持如此巨大的可扩展性有了更好的理解。</p><p id="ed62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">他们使用了一个叫做<em class="lq">插件</em>的概念。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="797b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">插件系统</h1><p id="3d56" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">插件允许你编写子程序，然后挂钩或附加到一个更大的程序。这些子程序然后运行，修改或增加运行程序的行为。</p><p id="a69e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了编写一个插件，程序本身必须被编写(或被破解)以支持插件。一旦这种能力存在，您就可以“即插即用”大量的功能。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="0034" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">概念</h1><p id="81fa" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">插件系统有许多形状和形式——为了说明设计，下面的基本概念可以帮助你思考:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/b54628f697f7a449f8d3a10c808b98d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BjK18_w7O6gW7rt0u7ySfQ.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">基本插件系统的概念组件</p></figure><h2 id="3816" class="na lz it bd ma nb nc dn me nd ne dp mi ld nf ng mk lh nh ni mm ll nj nk mo nl bi translated">该计划</h2><p id="cb18" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">第一部分是程序本身，也就是你试图增强或修改其行为的东西。这可能是像Skyrim这样的游戏，也可能是像Sketch这样的商业应用。它甚至可能是你自己的程序！</p><p id="c17e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不管它是什么，它提供了一些你想要改变的行为和能力。更重要的是，它不知道您想要进行的更改。</p><h2 id="7d2e" class="na lz it bd ma nb nc dn me nd ne dp mi ld nf ng mk lh nh ni mm ll nj nk mo nl bi translated">钩子</h2><p id="479e" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">你试图改变的程序中的某些东西必须运行它不知道的代码。否则，很难改变行为。</p><p id="603e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码运行的这个点被称为<em class="lq">钩子</em>。Rails的模型回调或Vue的组件生命周期钩子就是在野外使用的钩子的例子。</p><p id="308e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个简单的挂钩示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="585e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看<code class="fe no np nq nr b">onSaveHook</code>怎么没有行为。在这个例子中，预期这个行为将由扩展<code class="fe no np nq nr b">RecordSaver</code>的类填充，并在子类中实现新的行为。</p><h2 id="e66a" class="na lz it bd ma nb nc dn me nd ne dp mi ld nf ng mk lh nh ni mm ll nj nk mo nl bi translated">插件</h2><p id="9794" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">插件是其他人编写并“插入”以增强程序功能的代码。</p><p id="6ee1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以用如下功能扩展上面例子中的<code class="fe no np nq nr b">RecordSaver</code>类:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="8fcc" class="na lz it nr b gy nw nx l ny nz">class LoggedRecordSaver &lt; RecordSaver<br/>  def onSaveHook()<br/>    puts 'Saving record.'<br/>  end<br/>end</span></pre><p id="7ced" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在调用<code class="fe no np nq nr b">LoggedRecordSaver#save()</code>时，它会在控制台调用<code class="fe no np nq nr b">#writeToDisk()</code>后打印<code class="fe no np nq nr b">Saving record.</code>。这种行为增强是通过扩展<code class="fe no np nq nr b">RecordSaver</code>实现的——这是增强程序行为的一种基本方法。</p><p id="095a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还要注意，<code class="fe no np nq nr b">RecordSaver</code>对<code class="fe no np nq nr b">LoggedRecordSaver</code>一无所知:耦合是单向的。</p><h2 id="d193" class="na lz it bd ma nb nc dn me nd ne dp mi ld nf ng mk lh nh ni mm ll nj nk mo nl bi translated">装载机</h2><p id="b3d3" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">如果一个插件从来没有真正运行过，那么它是没有用的。需要加载插件来开始执行它的代码。</p><p id="db4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有很多技术可以实现这一点，有两种方法:</p><ul class=""><li id="a073" class="oa ob it kw b kx ky la lb ld oc lh od ll oe lp of og oh oi bi translated"><strong class="kw iu">插件驱动，</strong>插件知道如何访问程序和自注册。</li><li id="739e" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated"><strong class="kw iu">程序驱动</strong>，程序知道如何找到插件并加载它找到的插件。</li></ul><p id="a2c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在插件驱动的加载方法中，程序提供了一种方法，通过这种方法，插件可以向程序注册自己。在程序驱动的加载方法中，程序找到一个插件，比如通过加载一个名为<code class="fe no np nq nr b">*_plugin</code>的文件夹中的所有文件或者加载一个清单。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="93ec" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">使用插件编写的聊天机器人</h1><p id="1873" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">不久前，我花了一个周末的时间写了一个聊天机器人OneLine，它用自然语言告诉我双关语并给我发送提醒。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/c89735837b46d143fe791908afa9626c.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*-6hgMs98jCgJPUZ-vvksQg.png"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">OneLine，我写的一个聊天机器人，使用了插件方法</p></figure><p id="ab08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">方法很简单:接收一条消息，任意处理它，然后发送回一个响应。为了构建这一切，我构建了一个基本的插件系统，实现了这里提到的概念。</p><h2 id="c995" class="na lz it bd ma nb nc dn me nd ne dp mi ld nf ng mk lh nh ni mm ll nj nk mo nl bi translated">装载机</h2><p id="8570" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">OneLine拥有程序的一部分，即<code class="fe no np nq nr b">Core::Plugin</code>模块上静态方法的子集，定义一个实现来:</p><ul class=""><li id="632f" class="oa ob it kw b kx ky la lb ld oc lh od ll oe lp of og oh oi bi translated">加载一个<code class="fe no np nq nr b">plugin</code> ( <code class="fe no np nq nr b">#load</code>)</li><li id="af9a" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated">跟踪所有加载的<code class="fe no np nq nr b">plugins</code> ( <code class="fe no np nq nr b">@@plugins</code>)</li><li id="7108" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated">调用所有加载的<code class="fe no np nq nr b">plugins</code> ( <code class="fe no np nq nr b">#call_all</code>)</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c742" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，在这个例子中，加载器和钩子都被组合在一起。</p><p id="60f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">加载器</strong>是<code class="fe no np nq nr b">Plugin</code>实现可以调用的<code class="fe no np nq nr b">load</code>函数，让程序知道它。</p><p id="8f7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">钩子是一个非常明确的<code class="fe no np nq nr b">call_all</code>函数，当程序接收到一条消息时就会被调用。</p><h2 id="4f22" class="na lz it bd ma nb nc dn me nd ne dp mi ld nf ng mk lh nh ni mm ll nj nk mo nl bi translated">插件接口</h2><p id="9e50" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">它还定义了对插件实现的期望——所有<code class="fe no np nq nr b">plugins</code>都应该支持的行为。在这种情况下:</p><ul class=""><li id="34d3" class="oa ob it kw b kx ky la lb ld oc lh od ll oe lp of og oh oi bi translated">检查插件是否应该运行(<code class="fe no np nq nr b">#process?</code>)</li><li id="0e50" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated">将被调用来运行插件的方法(<code class="fe no np nq nr b">#process</code>)</li><li id="6148" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated">插件预期返回的标准化响应(<code class="fe no np nq nr b">#to_response</code>)</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a2f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数<code class="fe no np nq nr b">#process</code>由钩子调用(在收到消息时)。</p><h2 id="786f" class="na lz it bd ma nb nc dn me nd ne dp mi ld nf ng mk lh nh ni mm ll nj nk mo nl bi translated">插件实现</h2><p id="5abe" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">最后，插件实现解析和解释消息，并对其进行处理。我制作插件是为了:</p><ul class=""><li id="35f4" class="oa ob it kw b kx ky la lb ld oc lh od ll oe lp of og oh oi bi translated">给我讲个笑话(<code class="fe no np nq nr b">lib/oneline/jokes</code>)</li><li id="3dfc" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated">记录我的待办事项清单(<code class="fe no np nq nr b">lib/oneline/scheduler</code>)</li><li id="bebb" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated">…以及更多！</li></ul><p id="76ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是最简单的例子，一个告诉你当前时间的插件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="b482" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">就是这样！</h1><p id="c583" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">相当简单！以这种方式处理事情为其他人留下了可扩展性的空间，保持代码的不同部分分段和隔离，并允许我构建和支持扩展，例如支持web服务器或通过SMS的对话。</p><p id="0126" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然插件系统并不适合所有的场景，但在某些情况下它们非常有用。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1ab7" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">完整的源代码库</h1><p id="f8d8" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">请随意查看聊天机器人的完整源代码(特别是在<code class="fe no np nq nr b">lib/oneline</code>文件夹中):</p><div class="op oq gp gr or os"><a href="https://github.com/jgefroh/oneline" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">JGefroh/oneline</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">OneLine是一个个人助理聊天机器人，旨在简化我的生活。你是一个有很多重要事情的大忙人…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">github.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="1ff4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你喜欢这篇文章吗？在评论里告诉我，或者在<a class="ae ph" href="https://www.linkedin.com/in/jgefroh/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我！</p><p id="3324" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="lq">本文是我的</em> </strong> <a class="ae ph" href="https://medium.com/@jgefroh/list/how-to-design-software-03066fa9dcbf" rel="noopener"> <strong class="kw iu"> <em class="lq">如何设计软件</em> </strong> </a> <strong class="kw iu"> <em class="lq">系列的一部分。</em> </strong></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><div class="kj kk kl km gt os"><a href="https://jgefroh.medium.com/membership" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">通过我的推荐链接加入媒体-约瑟夫·格夫罗</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">jgefroh.medium.com</p></div></div><div class="pb l"><div class="pi l pd pe pf pb pg ks os"/></div></div></a></div></div></div>    
</body>
</html>