<html>
<head>
<title>Boost Performance With Asynchronous Queries in Rails 7</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rails 7中的异步查询提升了性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/boost-performance-with-asynchronous-queries-in-rails-7-edd52e34a3cc?source=collection_archive---------1-----------------------#2022-06-26">https://betterprogramming.pub/boost-performance-with-asynchronous-queries-in-rails-7-edd52e34a3cc?source=collection_archive---------1-----------------------#2022-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bf9c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看看最新框架版本中的新特性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dd0886cb845b77c5eaf5d25698bbaf60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nffFxN4nzdnlQAJdkePHAQ.png"/></div></div></figure><p id="12d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Rails由于其相对易用、优秀的文档和热情的社区支持而拥有坚实的追随者。</p><p id="d4f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，人们一直在寻找对Rails一些众所周知的缺点的改进。多年来，对Rails的一个普遍批评是速度慢/性能差。为了解决这个问题，Rails 7的发布引入了一种新的方法来支持异步查询。</p><h1 id="fe63" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">新来的孩子</h1><p id="35ea" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">查询以同步方式执行。采取以下措施:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="ffd4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这三个查询将按顺序进行。第一个查询是<code class="fe mk ml mm mn b">Book</code>模型。完成后，查询<code class="fe mk ml mm mn b">Movie</code>。然后进行<code class="fe mk ml mm mn b">Record</code>的查询。因此，可能会出现速度变慢的情况，因为在进入下一个查询之前必须完成每个查询。在处理特别大的数据集时，这会进一步影响性能。</p><p id="eb1f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决这个问题，Rails 7带来了一个新的ActiveRecord方法<code class="fe mk ml mm mn b">load_async</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7678" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的例子中，进行了同样的三个查询，但是通过使用<code class="fe mk ml mm mn b">load_async</code>，每个查询都是并发执行的。这三个查询在与一个查询几乎相同的时间内完成，从而提高了性能。欢迎使用Rails中的异步查询！</p><h1 id="1c56" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">设置</h1><p id="7f71" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">异步执行是Rails 7的一个新特性，但默认情况下并没有启用。要配置它，请转到您的环境配置文件，如<code class="fe mk ml mm mn b">config/environments/development.rb</code>，并放置以下内容:</p><pre class="kg kh ki kj gt mq mn mr ms aw mt bi"><span id="5424" class="mu lo iq mn b gy mv mw l mx my">config.active_record.async_query_executor = :global_thread_pool</span></pre><p id="5655" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mk ml mm mn b">:global_thread_pool</code>设置对数据库查询使用单个池。如果应用程序只有一个数据库或者一次只对一个数据库进行查询，这是非常理想的。如果应用程序使用多个数据库，则建议将设置更改为<code class="fe mk ml mm mn b">:multi_thread_pool</code>。</p><h1 id="adfd" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">过程</h1><p id="63d6" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">设置应用程序使用<code class="fe mk ml mm mn b">load_async</code>后，执行查询后检查日志。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/a2ccf553ac1722c320d1db77ede18fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*HeVi9NtcEEB-iCBIbtLJ3Q.png"/></div></figure><p id="f99c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">前缀为<code class="fe mk ml mm mn b">ASYNC</code>的两个日志行表示它们是与<code class="fe mk ml mm mn b">Book</code>同时执行的。完成的总时间大约是一秒钟。还不错！按顺序完成同样的查询至少需要三秒钟。</p><p id="6885" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么这是如何工作的呢？Ruby有线程，线程是执行进程的一种方式。默认情况下，进程在主线程中处理，这意味着程序必须等待一个进程完成执行，然后才能处理下一个进程。换句话说，你在Ruby程序中看到的标准顺序性能。</p><p id="8e85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在i/o绑定的应用程序中，这是一种利用外部资源(如数据库查询和API请求)的应用程序，Ruby有一个<code class="fe mk ml mm mn b">Thread</code>类，它为一个进程创建一个线程，并允许程序的其他部分继续并行运行，同时等待该进程完成。一旦线程进程完成执行，它就被加入到程序中。查看这个伟大的<a class="ae na" href="https://www.rubyguides.com/2015/07/ruby-threads/" rel="noopener ugc nofollow" target="_blank">指南</a>来学习更多关于Ruby线程的知识。</p><p id="b572" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">记住线程的概念，让我们回到<code class="fe mk ml mm mn b">load_async</code>。用<code class="fe mk ml mm mn b">load_async</code>进行的每个查询都会创建一个新线程，然后允许程序的下一部分在等待结果时执行。一旦查询完成，它就被连接回主线程，从而实现前面示例中看到的性能提升。</p><h1 id="78b2" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">一些警告</h1><p id="6f7f" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">有了显而易见的性能增强，您可能想知道是否可以把<code class="fe mk ml mm mn b">load_async</code>扔得到处都是，坐下来，享受一个超快的应用程序。不幸的是，答案是否定的。有几件事需要注意。</p><p id="d82a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，应该根据池的大小来考虑查询的数量。超过池大小会导致数据库连接错误。每个数据库对一次可以建立的连接数都有自己的限制，所以请确保您知道它们是什么，并相应地进行规划。可以在你的Rails应用程序的<code class="fe mk ml mm mn b">database.yml</code>文件中更改池大小的设置。</p><p id="47fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe mk ml mm mn b">load_async</code>要考虑的另一件事是，增加连接数会影响数据库内存，如果过载太多，实际上会降低查询时间。这可能会降低应用程序的速度，并否定使用<code class="fe mk ml mm mn b">load_async</code>的初衷。一定不要做得太多，并且要注意数据库一次处理的连接数。</p><h1 id="7aed" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">结论</h1><p id="108d" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Rails 7中添加的<code class="fe mk ml mm mn b">load_async</code>利用了Ruby线程模型来并行运行进程。如果使用得当，它可以提高频繁使用数据库和API查询的Rails应用程序的速度。这些改进和对Rails的持续支持是该框架仍然流行的原因之一。给<code class="fe mk ml mm mn b">load_async</code>一个尝试，在这里看看Rails 7 <a class="ae na" href="https://blog.appsignal.com/2021/12/15/whats-new-in-rails7.html" rel="noopener ugc nofollow" target="_blank">的其他一些新特性。</a></p></div></div>    
</body>
</html>