<html>
<head>
<title>Scalable Networking in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的可扩展网络</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/scalable-routing-in-swift-d584c9ff728b?source=collection_archive---------4-----------------------#2019-09-22">https://betterprogramming.pub/scalable-routing-in-swift-d584c9ff728b?source=collection_archive---------4-----------------------#2019-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a3b3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">用洒落的联合收割机</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/a95481eb85142f552b7c3407cbd21e3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PSU_8cZGSxcKJjlpsJpS9A.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@saulomohana?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">绍洛·莫哈纳</a>在<a class="ae kz" href="https://unsplash.com/s/photos/app?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7efa" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">自从Codables出现以来，我们已经逐渐接近一个内置于Foundation的完全类型化的网络解决方案。虽然我们的模型现在是安全的，但我们的请求本身通常仍然依赖于字符串和非常手动的参数，这使我们容易出现开发人员的错误。</p><p id="a3ff" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">老实说，即使是最优秀的人也会犯错。</p><p id="6e72" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在一个大型项目中，大量的时间可以花在调试这些错误上，这些时间可以更好地用在新功能上。为了降低这种风险，我们需要将路线数据转换成某种类型。</p><p id="91f8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我一直使用的概念是，路由器执行一个<code class="fe lw lx ly lz b">Route</code>，并将结果返回给需要它的服务或视图。以下将围绕这一点展开。</p><p id="a591" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">首先，我需要设定一些基本目标。这些是:</p><ul class=""><li id="fa4b" class="ma mb it lc b ld le lg lh lj mc ln md lr me lv mf mg mh mi bi translated">路由器唯一关心的应该是获取一个<code class="fe lw lx ly lz b">Route</code>并通过<code class="fe lw lx ly lz b">URLSession</code>执行它——这里我们不会使用任何pod。</li><li id="707d" class="ma mb it lc b ld mj lg mk lj ml ln mm lr mn lv mf mg mh mi bi translated">路由器应该能够取出传递给它的任何<strong class="lc iu"> R </strong> oute <strong class="lc iu"> </strong>，并且在没有任何额外逻辑的情况下执行。</li><li id="85c9" class="ma mb it lc b ld mj lg mk lj ml ln mm lr mn lv mf mg mh mi bi translated">路由应该包含路由器可能需要的任何信息。</li><li id="af36" class="ma mb it lc b ld mj lg mk lj ml ln mm lr mn lv mf mg mh mi bi translated">转换成代码应该是自动的和无缝的。</li><li id="e81c" class="ma mb it lc b ld mj lg mk lj ml ln mm lr mn lv mf mg mh mi bi translated">添加新路线一定很容易。</li><li id="2c63" class="ma mb it lc b ld mj lg mk lj ml ln mm lr mn lv mf mg mh mi bi translated">最后，调用路线的代码必须干净、易读，并且对使用这种方法的项目新开发人员有意义。我们不想要大量的入职时间。</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="f2d8" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">设计路由协议</h1><p id="b9cc" class="pw-post-body-paragraph la lb it lc b ld nn ju lf lg no jx li lj np ll lm ln nq lp lq lr nr lt lu lv im bi translated">API路由通常使用几个简单的数据位来执行。路径、查询和正文。app想要数据的那部分并不关心这个细节，它只知道自己想要的结果。</p><p id="9f5a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">无论是响应还是请求，正文都可以用代码来表达。有时，这些应该是空的，所以我们需要一个占位符来处理。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ns nt l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">基本路由协议。</p></figure><p id="6bbd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe lw lx ly lz b">method</code>、<code class="fe lw lx ly lz b">path</code>和auth需求是静态变量，因为它们将被定义一次，并且不会因路线的每个实例而改变。</p><p id="2323" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">至于实例变量，我们只需要一个可选的带有<code class="fe lw lx ly lz b">path</code>和<code class="fe lw lx ly lz b">query</code>参数的<code class="fe lw lx ly lz b">requestObject</code>。<code class="fe lw lx ly lz b">requestObject</code>是可选的，因为<code class="fe lw lx ly lz b">GET</code>请求不会有它们，所以我们允许它完全为空。我们这里没有<code class="fe lw lx ly lz b">responseObject</code>，因为我们希望路由器将它返回给我们。</p><p id="7872" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">是一个空的可编码对象，完全作为一个占位符，告诉路由器不要对该对象做任何事情，处理任何我们不想序列化的实例。</p><p id="5382" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有了这些信息，我们就有了创建请求所需的一切。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="0cb3" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">构建请求</h1><p id="b0e8" class="pw-post-body-paragraph la lb it lc b ld nn ju lf lg no jx li lj np ll lm ln nq lp lq lr nr lt lu lv im bi translated"><code class="fe lw lx ly lz b">toRequest</code>是允许路由器代码非常少的魔法。它处理将路由转换成<code class="fe lw lx ly lz b">URLRequest</code>实例的所有逻辑。我们可以将它的一个基本实现定义为<code class="fe lw lx ly lz b">Route</code>的扩展。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ns nt l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">从我们的路线生成请求。</p></figure><p id="172d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe lw lx ly lz b">toRequest</code>方法添加了我们的路径参数、查询项，并在需要时将主体序列化到JSON中。</p><p id="c4f4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您会注意到<code class="fe lw lx ly lz b">queryParameters</code>和<code class="fe lw lx ly lz b">pathParameters</code>在这个扩展中有一些默认的实现。这只是为了在我们不需要这些参数的地方保持路线最少。</p><p id="7dbd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一些路由可能需要改变这一点，比如在它们的主体中包含媒体而不是代码，但这仅仅意味着覆盖这个方法并添加一个特定的主体代码。</p><p id="fc0d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在我们已经看到了它是如何工作的，我们可以看一个从web获取特定待办事项的示例路由。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ns nt l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">提取待办事项的示例路径</p></figure><p id="5906" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们看一下这个例子，看看我们有什么。</p><ul class=""><li id="d2b3" class="ma mb it lc b ld le lg lh lj mc ln md lr me lv mf mg mh mi bi translated">我们没有请求体，所以我们将其设置为<code class="fe lw lx ly lz b">Empty</code>。</li><li id="ca49" class="ma mb it lc b ld mj lg mk lj ml ln mm lr mn lv mf mg mh mi bi translated">响应是一个单一的待办事项，所以我们将其设置为<code class="fe lw lx ly lz b">ResponseType</code>。</li><li id="679e" class="ma mb it lc b ld mj lg mk lj ml ln mm lr mn lv mf mg mh mi bi translated">我们的<code class="fe lw lx ly lz b">method</code>和<code class="fe lw lx ly lz b">path</code>被设置为静态变量，因为它们不会改变。</li><li id="ee9c" class="ma mb it lc b ld mj lg mk lj ml ln mm lr mn lv mf mg mh mi bi translated">默认的<code class="fe lw lx ly lz b">requestObject</code>需要一个可选的<code class="fe lw lx ly lz b">RequestObject</code>副本，在这里是空的，所以我们只有一个可选的<code class="fe lw lx ly lz b">Empty</code>。</li><li id="d5e9" class="ma mb it lc b ld mj lg mk lj ml ln mm lr mn lv mf mg mh mi bi translated">我们知道我们的查询参数总是空的，所以我们只是创建一个空数组。</li><li id="b59c" class="ma mb it lc b ld mj lg mk lj ml ln mm lr mn lv mf mg mh mi bi translated">我们拥有的唯一路径参数指定了我们正在寻找的具体待办事项，因此我们使用一个局部变量<code class="fe lw lx ly lz b">Todo</code>并从中获取ID。</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="32f1" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">执行路线</h1><p id="3c65" class="pw-post-body-paragraph la lb it lc b ld nn ju lf lg no jx li lj np ll lm ln nq lp lq lr nr lt lu lv im bi translated">所有的细节都被抽象出来，我们的路线也准备好了，我们需要实际执行它们。</p><p id="851c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在构造了一个<code class="fe lw lx ly lz b">GetTodoRoute</code>的实例后，我们只需将它传递给路由器。</p><p id="f5b4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">就是这样。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ns nt l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">TodoService</p></figure><p id="bb3d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你可能认为路由器代码有点乱，但是因为有了<code class="fe lw lx ly lz b">toRequest</code>方法，它实际上非常易读。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="470d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在返回发布者之前，路由器处理解码和映射任何潜在的错误。如果响应类型为空，我们有一个不同的<code class="fe lw lx ly lz b">performRequest</code>方法来映射错误。</p><p id="5811" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">链中的最后一点是真正想要<code class="fe lw lx ly lz b">Todo</code>的对象。这只是要求<code class="fe lw lx ly lz b">TodoService</code>得到一个待办事项，并等待响应。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="7aec" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">还有一些事情我没有考虑，比如增加认证重试，但是这将是一个很好的可扩展的设置。</p><p id="a7f4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在我当前的项目中有这样的网络已经导致了新路线的更快实施，留下了更多的时间来调试SwiftUI。<em class="nu"> <br/> </em>初始设置后节省的时间只会随着代码库的增加而增加。</p><p id="4f04" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">感谢阅读！</p></div></div>    
</body>
</html>