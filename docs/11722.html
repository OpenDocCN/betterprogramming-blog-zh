<html>
<head>
<title>Design an Auto-Scalable Architecture for Your Django Apps in AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为AWS中的Django应用程序设计一个可自动伸缩的架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/design-an-auto-scalable-architecture-for-your-django-apps-in-aws-850ca5ec63a1?source=collection_archive---------3-----------------------#2022-04-12">https://betterprogramming.pub/design-an-auto-scalable-architecture-for-your-django-apps-in-aws-850ca5ec63a1?source=collection_archive---------3-----------------------#2022-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5828" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用无服务器容器实现零服务器维护的弹性、性能和安全性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9645811f9177a094f9ad2ede5aa8cfe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKBjIkQeR31Vb6_MomQz6A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马克·瑟尼斯在<a class="ae kv" href="https://unsplash.com/s/photos/guide?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="cf6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你终于有了一个好到可以公开的工作版本。干得好！但是现在，您想知道如何在AWS中将Django应用程序投入生产，以及如何使它具有可伸缩性、弹性、高性能和安全性，同时优化成本并且不需要手动基础架构管理。这就是这篇文章的内容。</p><h1 id="b10c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">审查开发架构</h1><p id="fa93" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">开发中的Django应用程序的典型架构如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/9b5cc4c571c71e4b3009bde12912ea67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*dtmq6Ohq2GLnFqOzLvdVtA.png"/></div></figure><p id="6313" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们可以确定两个主要组成部分:</p><ul class=""><li id="167b" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">Django app:通常由<a class="ae kv" href="https://docs.djangoproject.com/en/4.0/ref/django-admin/#django-admin-runserver" rel="noopener ugc nofollow" target="_blank"> runserver </a>提供服务，它是与Django打包在一起的开发服务器。</li><li id="685c" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">数据库:Django支持多种数据库，例如PostgreSQL、MySQL和SQLite。</li></ul><p id="6147" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能想将相同的设置复制到服务器或虚拟机中，并让它在生产中运行，但是正如您将看到的，这种架构有一些缺陷:</p><h2 id="ff44" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">它是不可扩展的</h2><p id="a9f6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Runserver没有经过优化，也没有做好处理大量请求的准备，即使您用gunicorn这样的生产应用服务器来代替它，单个服务器可以处理的请求数量也会受到其硬件资源的限制。因此，一旦你开始收到越来越多的请求，系统最终会没有反应，请求将开始超时。</p><p id="4d71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">向服务器添加更多的资源，也就是垂直扩展，可以暂时解决这个问题，但是很快就会达到极限，并且会重复这个过程，直到无法添加更多的资源。您可以添加一个负载平衡器，然后添加更多的服务器，但是手动这样做可能会很慢而且很痛苦，如果您没有计划好，可能会导致停机。</p><h2 id="c03a" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">不是表演</strong></h2><p id="c9f2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Runserver没有针对性能进行优化。此外，静态文件和媒体由处理请求的同一进程提供服务，这会延迟请求处理并消耗更多资源。此外，如果您使用默认的SQLite DB，它只允许在任何给定时间进行一次写操作，这极大地限制了吞吐量。我不建议在生产中使用SQLite。</p><h2 id="c9fc" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">安全漏洞</strong></h2><p id="3c69" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Runserver运行在HTTP上而不是HTTPS上，这对于本地开发来说还可以，但是不适合生产。此外，如果数据库与Django应用程序运行在同一个主机上，并且主机暴露在互联网上，那么如果有人侵入服务器，他现在也可以攻击您的数据库。</p><h2 id="00f2" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">服务器维护很痛苦</strong></h2><p id="7173" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您需要手动监控和管理您的服务器和资源。如果服务器进入不健康状态或需要更多资源，这将需要手动干预，并可能导致停机。</p><h1 id="9bbb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在AWS中设计生产就绪的架构</h1><p id="e916" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，我们将使用几个AWS服务来设计新的生产架构，这些服务将帮助我们解决上述问题。</p><p id="24e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">先决条件:<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/dockerize-your-django-apps-428189407c69">将你的Django应用</a>归档。所选择的架构需要一个容器化的应用程序。</p><p id="c3bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来看一下有目的的架构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/3699f4e06300a41abb97bed3c0616e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s45oRtjjQZr2p4A89rxD2A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">你可以在<a class="ae kv" href="https://drive.google.com/file/d/1MsZhVcTErT9-wgBQVqcYQs4G-4dYflLc/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">这里</a>看到这个全尺寸的图表</p></figure><h2 id="ad4a" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">应用负载平衡器</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/2f03587d5d3486ca57ffef56b48f6925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*FSNeKYir3OAkOCi1mjltOw.png"/></div></figure><p id="15d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们添加了一个<a class="ae kv" href="https://aws.amazon.com/elasticloadbalancing/application-load-balancer/" rel="noopener ugc nofollow" target="_blank">应用负载平衡器</a> (ALB)来实现水平扩展和健康检查。现在，请求可以分布在几个实例之间，并且可以检测和替换不健康的实例。ALB还支持端口转发，因此您不需要nginx这样的中间代理，因为请求可以直接转发到端口8000上的应用程序。</p><p id="ae6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ALB还支持HTTPS和SSL/TLS证书，可以使用<a class="ae kv" href="https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html" rel="noopener ugc nofollow" target="_blank"> AWS证书管理器</a>添加这些证书。在这种情况下，TLS会话在负载平衡器处终止，然后流量通过HTTP转发到应用，但通过您的私有云网络转发到应用。</p><p id="22b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还会注意到，ALB部署在两个不同的<a class="ae kv" href="https://aws.amazon.com/about-aws/global-infrastructure/regions_az/" rel="noopener ugc nofollow" target="_blank">可用性区域</a> (AZs)中的两个公共子网中。处于公共子网中允许它接收来自互联网的请求，并且使用两个AZ确保即使一个AZ关闭它仍将工作。</p><h2 id="2d9f" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">弹性容器服务(ECS)和无服务器容器</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/7f31845b130acf5024550e63017f4ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*d7OsS6vIc3kZgQJeNcr-3w.png"/></div></figure><p id="910d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ECS允许在云中运行docker容器。我们用它来运行Django应用程序实例。ECS支持两种运行容器的方式:您可以在服务器内部运行容器(EC2 VM或on-premise ),也可以使用Fargate在无服务器模式下运行容器。</p><p id="7a54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用Fargate，因为我们不想管理服务器。这需要创建一个具有Fargate启动类型的<a class="ae kv" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/clusters.html" rel="noopener ugc nofollow" target="_blank"> ECS集群</a>和一个<a class="ae kv" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html" rel="noopener ugc nofollow" target="_blank"> ECS服务</a>，然后添加一个<a class="ae kv" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html" rel="noopener ugc nofollow" target="_blank">任务定义</a>，它指定将作为服务的一部分运行的容器。在这种情况下，我们需要为Django应用程序定义一个任务/容器。容器的图像取自docker注册表。</p><p id="6fd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，容器必须是无状态的，这样它们就可以随时被销毁和重新创建。这实现了ECS服务(以及一般的AWS)的最大特性之一:<a class="ae kv" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-auto-scaling.html" rel="noopener ugc nofollow" target="_blank">自动伸缩</a>。我们设置任务的最小、期望和最大数量，并使用<a class="ae kv" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/working_with_metrics.html" rel="noopener ugc nofollow" target="_blank"> CloudWatch指标</a>如平均CPU使用率(更高的CPU使用率=更高的流量)来根据需要自动扩展(添加更多实例)或扩展(删除实例)。</p><p id="d8de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最少拥有两个实例可以确保系统在一个实例关闭时仍能继续运行，而健康检查将允许自动检测失败的实例，并用新的健康实例替换它们。此外，将这两个实例放在两个不同的可用性区域(AZ)中，可以在一个AWS数据中心停机的情况下分散风险。</p><p id="abe2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们不要忘记安全性。我们将ECS任务放在私有子网中，这样它们就不会暴露在互联网上，并且只能接收来自负载平衡器的请求。</p><h2 id="cfa9" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">Aurora无服务器数据库</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/60840b742d2cb6e63c98e14f642e6acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*QraJrtePRhcmCC-kwb9z_Q.png"/></div></figure><p id="b280" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据库本质上是有状态的，因为它存储的数据必须是持久的。所以它不能在ECS/Fargate中作为无状态容器运行。但是我们不想为数据库管理服务器或虚拟机。</p><p id="ff3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，AWS有一个名为<a class="ae kv" href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html" rel="noopener ugc nofollow" target="_blank"> Aurora Serverles </a> s的托管服务，Aurora Serverless是一个完全托管的服务，用于支持PostgreSQL的关系数据库。无服务器意味着it <a class="ae kv" href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.how-it-works.html#aurora-serverless.how-it-works.auto-scaling" rel="noopener ugc nofollow" target="_blank">自动扩展</a>，并且不需要您提供或管理任何资源。</p><p id="f193" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与ECS服务类似，我们设置了最小和最大容量，它可以按需自动扩展。为了节省一些成本，您还可以启用<a class="ae kv" href="https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_ScalingConfiguration.html" rel="noopener ugc nofollow" target="_blank">自动暂停</a>功能，在闲置<code class="fe nu nv nw nx b">N</code>分钟(无连接)后将容量暂时缩减为零。这意味着数据库会关闭，直到收到新的连接请求。这对于生产前/准备环境尤其有用，但不太适合生产环境，因为唤醒时间可能需要一到两分钟。</p><p id="a21f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Aurora DB还支持自动备份作为灾难恢复策略。另外，Aurora DB的整体性能比普通PostgreSQL实例快三倍。</p><p id="6467" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还要注意，我们将数据库放在运行ECS服务的同一个私有子网中，因此可以从我们的Django应用程序访问数据库，它不会暴露在互联网上。</p><h2 id="f98f" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">代码管道和CI/CD管道</strong></h2><p id="874e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">CodePipeline 是一个持续集成/持续交付服务，允许软件发布过程自动化。管道由可以定制的阶段组成，因此它可以适应您正在使用的任何分支模型，例如<a class="ae kv" href="https://trunkbaseddevelopment.com/#scaled-trunk-based-development" rel="noopener ugc nofollow" target="_blank">基于主干的</a>、<a class="ae kv" href="https://docs.github.com/en/get-started/quickstart/github-flow" rel="noopener ugc nofollow" target="_blank"> GitHub流</a>、<a class="ae kv" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank"> GitFlow </a>或其他定制分支模型。</p><p id="24ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，这些将是使用经典GitHub流分支模型的阶段。</p><ul class=""><li id="ec7e" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">Source:当PR合并到主分支时，管道被触发(这是通过AWS CodeStar连接使用webhooks检测到的)。</li><li id="c9f9" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">构建和[测试]:docker映像由源代码构建，并保存在ECR存储库中，ECR存储库是AWS中的docker映像注册中心。如果自动测试在合并之前没有运行过，或者只是作为第二次检查，它们可以在这个阶段运行。这个阶段可以使用其他服务，如CodeBuild或S3桶来构建和存储工件。</li><li id="df2c" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">阶段:新映像被部署到一些预生产环境中，以进行更多的QA(例如，集成测试、端到端测试、UI测试)。在手动或自动批准后，它将进入生产阶段。</li><li id="4fe9" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">生产:部署新映像，更新ECS中的应用程序。<a class="ae kv" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-ecs.html" rel="noopener ugc nofollow" target="_blank">滚动更新</a>可用于避免停机。</li></ul><h2 id="854c" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">路由53作为DNS和(可选)作为域名注册商</strong></h2><p id="4482" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/Welcome.html" rel="noopener ugc nofollow" target="_blank"> Route53 </a>是DNS，我们在其中添加记录，将我们的域和子域指向AWS资源。例如，我们添加一条记录，将我们的主域指向我们的ALB。域名本身也可以通过Route53注册，也可以在一些第三方域名注册机构注册，比如NameCheap或GoDaddy。如果您使用的是第三方注册商，那么您必须将名称服务器(NS)记录更改为<a class="ae kv" href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/migrate-dns-domain-in-use.html#migrate-dns-change-name-servers-with-provider" rel="noopener ugc nofollow" target="_blank">使Route 53成为您的DNS </a>。</p><h2 id="075f" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">利用CloudFront服务静态资产</strong></h2><p id="f41d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">静态资产比如。js或者。css文件存储在<a class="ae kv" href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html" rel="noopener ugc nofollow" target="_blank"> S3 </a>桶中，并通过使用<a class="ae kv" href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html" rel="noopener ugc nofollow" target="_blank"> CloudFront </a>的内容分发网络(CDN)提供服务。这允许在靠近客户端的地方缓存文件，从而优化性能，同时减轻应用服务器的负担。您应该确保您的S3 bucket是私有的，并使用一个原始访问身份来只允许通过您的CloudFront发行版进行访问。</p><h2 id="439f" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">使用AWS Secrets Manager保护您的秘密安全</strong></h2><p id="d299" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您不希望将API键、数据库凭证或任何敏感信息提交到代码库中。您可以直接在任务定义中设置环境变量，但是有人可以使用AWS API读取它们的值。使用<a class="ae kv" href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html" rel="noopener ugc nofollow" target="_blank"> AWS Secrets Manager </a>数据被加密存储在云中，并在运行时注入。在JSON中，可以以纯文本或键值对的形式存储数据。我们用它来存储Django秘密和数据库凭证之类的东西。</p><h2 id="d8ff" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">通过VPC端点保持网络内部的流量</strong></h2><p id="42c6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当你使用S3或SQS等AWS服务时，默认行为是通过互联网访问它们。如果你的应用在私有网络的虚拟私有云(VPC)内的AWS中运行，那么需要一个<a class="ae kv" href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html" rel="noopener ugc nofollow" target="_blank"> NAT网关</a>来访问互联网上的任何资源。NAT GWs是按小时和GB计费的，它们会迅速增加您的账单。</p><p id="5aa2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，将流量保持在VPC内，可以提高安全性和性能，同时也可以降低一些成本。由于你的应用程序在AWS中，有一种方法可以从你的VPC访问这些AWS服务，而无需穿越互联网:<a class="ae kv" href="https://docs.aws.amazon.com/vpc/latest/privatelink/vpc-endpoints.html" rel="noopener ugc nofollow" target="_blank"> VPC端点</a> (fka专用链接)。您只需要在VPC级别为每个服务启用它们，然后对这些服务的任何调用都将在AWS网络内部进行路由。</p><p id="b13d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，使用VPC端点也有成本，但每小时的价格和数据处理是NAT GW价格的四分之一。</p><h1 id="62ba" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">高级架构模式</strong></h1><h2 id="8d0f" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">与队列和工人解耦</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/232b4b27e1f6166bd4abf8f0d751859c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NGor2qcDsFLQ1a-9WKTSIA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">你可以在这里得到这个全尺寸的图<a class="ae kv" href="https://drive.google.com/file/d/1r8eDUOzjiWLwNT3uH87PjQ4qounhtBtd/view?usp=sharing" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="5d73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种架构模式允许您通过添加队列和工人来分离短期请求和长期运行的任务。所有花费超过一秒钟的事情都可以被转换成一个任务，这个任务可以被排队等待在一个工作线程上异步执行。</p><h1 id="4905" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">为什么我可能需要这个？</strong></h1><h2 id="f27e" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">性能效率</strong></h2><p id="8aea" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您的应用程序实例可以处理有限数量的并发请求。所以您希望尽可能快地处理请求，以便能够在每个实例上每秒处理更多的请求。假设您有一些在请求处理期间同步执行的耗时代码。添加的时间越多，每秒可以处理的请求就越少。</p><p id="7798" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这还可能触发一个横向扩展事件，添加更多实例来支持更高的工作负载，这将不必要地增加基础架构成本。添加队列允许应用程序实例将这些耗时任务的执行委托给工作人员，并继续处理更多的请求。</p><h2 id="eb17" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">更好的可扩展性</strong></h2><p id="010b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您的主要应用程序实例和员工现在可以独立扩展。中间的队列还允许支持工作负载峰值，而不必如此频繁地向外扩展和向内扩展。工作人员可以根据队列中的消息数量等指标进行扩展。</p><h2 id="3c45" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">容错</strong></h2><p id="7f0e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">假设您调用一些外部API(第三方或您自己的另一个服务)。如果你同步进行，因为你的应用程序直接与它耦合，那么一旦外部API关闭，你的整个应用程序也会关闭。将API调用转移到异步任务中允许您将应用程序从外部服务中分离出来。该应用程序只会将任务排队，然后继续前进。</p><p id="5064" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个工人将在稍后选择任务并执行它。在API调用失败的情况下，可以用不同的策略重试任务，直到它最终成功或者直到您放弃。</p><h2 id="75e9" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">用芹菜实现工人</strong></h2><p id="0cad" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在python中灵活可靠地实现了分布式任务队列和工人。它负责繁重的工作，如消息传递、工人执行、断开连接和重新连接，它还带有一些很棒的功能，如采用不同策略的<a class="ae kv" href="https://docs.celeryproject.org/en/stable/userguide/tasks.html#retrying" rel="noopener ugc nofollow" target="_blank">任务重试</a>。它支持几个队列，<a class="ae kv" href="https://docs.celeryproject.org/en/stable/getting-started/backends-and-brokers/sqs.html#broker-sqs" rel="noopener ugc nofollow" target="_blank">亚马逊SQS是其中之一</a>，并且它自带了一个<a class="ae kv" href="https://docs.celeryproject.org/en/stable/django/first-steps-with-django.html" rel="noopener ugc nofollow" target="_blank"> Django集成</a>。</p><h2 id="cf96" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">使用亚马逊SQS实现队列</strong></h2><p id="f9a2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/welcome.html" rel="noopener ugc nofollow" target="_blank"> SQS </a>是一个完全托管的、高度可用的服务，在云中提供可靠的队列。您不需要提供资源或管理任何类型的服务器。对消息的数量没有任何限制，因此队列不会变满，消息存储在多个冗余可用性区域(az)中。</p><h2 id="283e" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">使用现代前端框架和面向服务的架构(SOA)</h2><p id="1b65" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您可能愿意将前端和后端分离，并使用一些现代前端框架，如React或Vue。我们将调整我们的架构来支持这一点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/0fe97ce3bd45ca894e8c2a01ad5a7363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GGwgMAbPo15PUdStNsZcVg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">你可以在这里得到这个全尺寸的图<a class="ae kv" href="https://drive.google.com/file/d/1SdkaPrkgdc_1dT0GtqZ0sXnBSHVn1-Lq/view?usp=sharing" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="a9b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，现在Django应用程序将实现一个REST API，作为与前端的通信接口。</p><h2 id="917b" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">后端</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/f869ff698fbe0e72dc7cd7e6be747b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6v-GC6zlhwmQajDyEBkVLA.png"/></div></div></figure><p id="772c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的Django应用程序现在实现了一个服务于REST API的后端web服务。Django模板层没有被使用，因为前端渲染现在移到了客户端。如果你选择这个架构，你可能想看一看<a class="ae kv" href="https://www.django-rest-framework.org/" rel="noopener ugc nofollow" target="_blank"> django-rest-framework </a>。</p><h2 id="0833" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">前端</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/10b5545b493ea6b7044dc177ac06ac61.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*DQkLr_vJHP6pSMbExaw23w.png"/></div></figure><p id="8804" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前端现在将单独开发和部署。同样，我们使用CodePipeline构建和部署前端应用程序。前端app一旦搭建好，就只是一组静态文件(html，js，css)。因此，我们可以将它存储在一个私有的S3桶中，通过CloudFront提供服务。前端的典型流水线可以具有以下阶段:</p><ul class=""><li id="8370" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">来源:在GitHub的前端repo中，当新的提交被推送到master时，管道被触发。</li><li id="0900" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">测试:自动测试在前进之前执行。</li><li id="e4b1" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">构建:构建react应用程序(yarn build ),并将包(静态文件)传递到下一阶段。</li><li id="5e81" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">阶段:新的捆绑包被部署到生产前环境中的S3桶中，以进行更多的QA(例如，端到端测试、UI测试)。在手动或自动批准后，它将进入生产阶段。</li><li id="50db" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">生产:新的包被部署到生产环境中的S3存储桶。然后更新CloudFront发行版，并使缓存失效，以强制其分发新版本的应用程序。</li></ul><h1 id="d325" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">下一步是什么？</h1><p id="29c2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">是时候部署了！在我的下一篇文章中，看看如何用CDK 在AWS中部署你的Django应用。</p><p id="1645" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>