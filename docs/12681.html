<html>
<head>
<title>Understanding the “Some” and “Any” Keywords in Swift 5.7</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Swift 5.7中的“一些”和“任何”关键字</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-the-some-and-any-keywords-in-swift-5-7-19d2cb52eae2?source=collection_archive---------2-----------------------#2022-06-22">https://betterprogramming.pub/understanding-the-some-and-any-keywords-in-swift-5-7-19d2cb52eae2?source=collection_archive---------2-----------------------#2022-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4135" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不再困惑！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/14b2a61f72af0f1bde9de2e04104cd41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EyGV26RP15bXyotibPaPLA.jpeg"/></div></div></figure><p id="147e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">some</code>和<code class="fe lq lr ls lt b">any</code>关键字在Swift中并不新鲜。在Swift 5.1中引入了<code class="fe lq lr ls lt b">some</code>关键字，而在Swift 5.6中引入了<code class="fe lq lr ls lt b">any</code>关键字。在Swift 5.7中，苹果对这两个关键词进行了另一项重大改进。我们现在可以在函数的参数位置使用这两个关键字了！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="2637" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一改进不仅使通用函数看起来更加简洁，而且还揭示了一些令人兴奋的在Swift中编写通用代码的新方法。剧透警告—我们现在可以告别以下错误消息了:</p><pre class="kj kk kl km gt lw lt lx ly aw lz bi"><span id="7fb3" class="ma mb it lt b gy mc md l me mf">protocol can only be used as a generic constraint because it has Self or associated type requirements</span></pre><p id="c95b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想了解更多？请继续阅读！</p><h1 id="f8fb" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">重要的事情先来</h1><p id="a23f" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">在进入细节之前，让我们定义一下我们将在本文中使用的协议。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="c6ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，我们将定义一个符合<code class="fe lq lr ls lt b">Vehicle</code>协议的<code class="fe lq lr ls lt b">Car</code>和<code class="fe lq lr ls lt b">Bus</code>结构，它们中的每一个都需要不同种类的燃料。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="39b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意<code class="fe lq lr ls lt b">fillGasTank(with:)</code>函数的<code class="fe lq lr ls lt b">Car</code>和<code class="fe lq lr ls lt b">Bus</code>的参数数据类型不一样，<code class="fe lq lr ls lt b">Car</code>需要<code class="fe lq lr ls lt b">Gasoline</code>而<code class="fe lq lr ls lt b">Bus</code>需要<code class="fe lq lr ls lt b">Diesel</code>。这就是为什么我们需要在我们的<code class="fe lq lr ls lt b">Vehicle</code>协议中定义一个名为<code class="fe lq lr ls lt b">FuelType</code>的关联类型。</p><p id="ef61" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然这样，我们就直接进入细节，好吗？</p><h1 id="7c86" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">理解“一些”关键词</h1><p id="006e" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">在Swift 5.1中引入了<code class="fe lq lr ls lt b">some</code>关键字。它与一个协议一起使用，创建一个不透明的类型，表示符合特定协议的东西。当用在函数的参数位置时，意味着函数接受某种符合特定协议的具体类型。</p><p id="c9b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个阶段，你可能会想，我们不是已经能够做到这一点了吗？</p><p id="0b89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，你是对的。在函数的参数位置使用<code class="fe lq lr ls lt b">some</code>关键字与在函数签名处使用尖括号或尾随<code class="fe lq lr ls lt b">where</code>子句完全相同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="03aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们在一个变量上使用<code class="fe lq lr ls lt b">some</code>关键字时，我们是在告诉编译器我们正在处理一个特定的具体类型，因此不透明类型的底层类型对于变量的范围必须是固定的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="f90a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">需要注意的一点是，编译器也禁止将同一具体类型的新实例赋给变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="0610" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记住这一点，我们在数组中使用它时必须遵循相同的规则。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="d154" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这同样适用于函数的底层返回类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="f220" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">some</code>关键词到此为止。让我们来看看<code class="fe lq lr ls lt b">any</code>关键字，看看它们之间有什么不同。</p><h1 id="4e1a" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">理解“任何”关键词</h1><p id="7153" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">在Swift 5.6中引入了<code class="fe lq lr ls lt b">any</code>关键字。它的引入是为了创造一种存在类型。在Swift 5.6中，当创建一个存在类型时，<code class="fe lq lr ls lt b">any</code>关键字不是强制性的，但是在Swift 5.7中，如果你没有这样做，你会得到一个编译错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="46fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如苹果工程师解释的那样，存在型就像一个盒子，里面装着符合特定协议的东西。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/f1ba9e5a59e20152cd7e88f370796ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H5JsrWmt_5TtnYb3"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">比较some和any关键字</p></figure><p id="77af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如上图所示，不透明类型和存在类型的主要区别是“盒子”“盒子”使我们能够在其中存储任何具体类型，只要底层类型符合指定的协议，从而允许我们做一些不透明类型不允许我们做的事情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="c46f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最好的部分是，在Swift 5.7中，我们现在可以使用<code class="fe lq lr ls lt b">any</code>关键字来定义相关类型的协议！这意味着使用带有关联类型的协议创建异构数组不再是一种限制！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="82b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">多酷啊。😃</p><p id="3e0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一改进不仅消除了“协议只能作为一般约束使用，因为它有自身或关联类型要求”的错误，而且还使在具有关联类型的协议上实现动态调度变得更加简单！但那将是另一天的一篇文章。</p><h1 id="bfae" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">“任何”关键字限制</h1><p id="3262" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">尽管看起来不错，但是使用<code class="fe lq lr ls lt b">any</code>关键字创建的存在类型仍然有其自身的局限性。一个主要的限制是我们不能使用<code class="fe lq lr ls lt b">==</code>操作符来比较存在类型的两个实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="2c28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你仔细想想，这实际上有点道理。如前所述，存在类型可以在其“盒子”中存储任何具体类型。对于编译器来说，存在类型只是一个“盒子”，它不知道盒子里面是什么。因此，当编译器不能保证“盒子”的内容具有相同的底层具体类型时，它不可能进行比较。</p><p id="2d8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您应该知道的另一个限制是，存在类型不如不透明类型(使用<code class="fe lq lr ls lt b">some</code>关键字创建)有效。<a class="ae nh" href="https://twitter.com/DonnyWals" rel="noopener ugc nofollow" target="_blank"> Donny Wals </a>有一篇很棒的<a class="ae nh" href="https://www.donnywals.com/what-is-the-any-keyword-in-swift/" rel="noopener ugc nofollow" target="_blank">文章</a>详细讨论了这一点，我强烈推荐你去看看。</p><p id="c831" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，即使苹果在<code class="fe lq lr ls lt b">any</code>关键字上做了很多改进，如果不透明类型可以完成工作，仍然建议使用<code class="fe lq lr ls lt b">some</code>关键字。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/3b032a815eb8cd042b51974682102c0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-MM2gLbG3N6Ss7DU"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">来源:<a class="ae nh" href="https://developer.apple.com/videos/play/wwdc2022-110354/?time=1726" rel="noopener ugc nofollow" target="_blank">Swift的新功能</a></p></figure><h1 id="a33d" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">包扎</h1><p id="c4f5" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">Swift 5.7中对<code class="fe lq lr ls lt b">any</code>和<code class="fe lq lr ls lt b">some</code>关键字的改进绝对是受欢迎的。一方面，它极大地改进了我们通用代码的语法和可读性。另一方面，它为我们以更有效的方式编写泛型代码开辟了新的途径。</p><p id="d5e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望这篇文章能让你更好地了解<code class="fe lq lr ls lt b">any</code>和<code class="fe lq lr ls lt b">some</code>关键词。请随时在Twitter上关注我，这样你就不会错过我即将发表的任何文章。</p><p id="14d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="3c8c" class="mg mb it bd mh mi nq mk ml mm nr mo mp jz ns ka mr kc nt kd mt kf nu kg mv mw bi translated">相关的WWDC会议</h1><ul class=""><li id="f226" class="nv nw it kw b kx mx la my ld nx lh ny ll nz lp oa ob oc od bi translated"><a class="ae nh" href="https://developer.apple.com/videos/play/wwdc2022-110354/?time=1726" rel="noopener ugc nofollow" target="_blank">Swift的新功能</a></li><li id="c79b" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated"><a class="ae nh" href="https://developer.apple.com/videos/play/wwdc2022/110352/" rel="noopener ugc nofollow" target="_blank">拥抱Swift仿制药</a></li><li id="5d05" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated"><a class="ae nh" href="https://developer.apple.com/videos/play/wwdc2022/110353" rel="noopener ugc nofollow" target="_blank">设计Swift中的协议接口</a></li></ul></div></div>    
</body>
</html>