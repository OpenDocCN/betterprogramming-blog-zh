<html>
<head>
<title>Handle Incoming Notifications in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iOS中处理传入通知</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/handle-incomming-notifications-in-ios-8b1a322bb5a9?source=collection_archive---------4-----------------------#2019-10-13">https://betterprogramming.pub/handle-incomming-notifications-in-ios-8b1a322bb5a9?source=collection_archive---------4-----------------------#2019-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b33b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在用户看到通知之前更改或丰富通知</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2d8360a68aadcc8f9b05a01aa4334e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-6HkwPcrwLUCEQ-mCnZ-Lg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供</p></figure><p id="5b5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如何在iOS中处理收到的推送通知？</p><p id="ef15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么我们先来说明一下需求。在我的特殊例子中，每次我在应用程序中收到通知时，我都需要进行一次HTTP调用(更具体地说，将消息发布到PubNub通道)。它让我的服务器在收到通知的第一时间知道。</p><p id="bdd4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这在iOS和Android中都是可能的。在iOS中，可以通过通知服务扩展目标来完成，我们可以通过File &gt; New &gt; Target将它添加到我们的项目中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lu"><img src="../Images/180302281272d0cdc97b2453a86cc31e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54JHhNFxm4NVLVjX_EHObA.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fa42" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">通知服务扩展</h1><p id="da7f" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">iOS中的通知服务扩展的主要目的是在操作系统显示通知之前，能够用更多的信息来更改或丰富通知。</p><p id="36b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">甚至允许响应通知下载内容或向服务器发出HTTP请求。</p><p id="4c4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，通知服务扩展仅在iOS 10及更高版本中可用，您需要使用XCode 8或更高版本来实现这一功能。</p><h2 id="175c" class="mz md it bd me na nb dn mi nc nd dp mm lh ne nf mo ll ng nh mq lp ni nj ms nk bi translated">扩展生命周期</h2><p id="1d22" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">使用通知服务扩展配置应用程序后，将针对每个通知执行以下过程:</p><ol class=""><li id="ed1a" class="nl nm it la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated">App收到通知。</li><li id="107c" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">系统创建一个扩展类的实例，并在后台启动它。</li><li id="85b4" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">您的扩展执行内容编辑和/或下载一些内容。</li><li id="b787" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">如果您的扩展执行工作的时间太长，它将被通知并立即终止。</li><li id="3b38" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">向用户显示通知。</li></ol><p id="5370" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，使用notification service扩展时，您只有有限的时间来执行必要的工作。这是由操作系统控制的，就像iOS中的其他后台任务一样。如果您的扩展花费的时间太长，或者在执行扩展时发生任何其他异常，那么它将被系统停止，并且通知将被发送，就像您根本没有扩展一样。</p><h2 id="b4ea" class="mz md it bd me na nb dn mi nc nd dp mm lh ne nf mo ll ng nh mq lp ni nj ms nk bi translated">密码</h2><p id="f783" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在将这个目标添加到您的项目中之后，将会在其中创建三个文件。</p><ul class=""><li id="6aaf" class="nl nm it la b lb lc le lf lh nn ll no lp np lt nz nr ns nt bi translated"><code class="fe oa ob oc od b">NotificationService.h</code></li><li id="37c2" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nz nr ns nt bi translated"><code class="fe oa ob oc od b">NotificationService.m</code></li><li id="43d7" class="nl nm it la b lb nu le nv lh nw ll nx lp ny lt nz nr ns nt bi translated"><code class="fe oa ob oc od b">Info.plist</code></li></ul><p id="4611" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你使用Swift，你将只有两个文件:<code class="fe oa ob oc od b">NotificationService.swift</code>和<code class="fe oa ob oc od b">Info.plist</code>。</p><p id="373b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以代码放入<code class="fe oa ob oc od b">NotificationService[.m]</code>。该类扩展了从<code class="fe oa ob oc od b">&lt;UserNotifications/UserNotifications.h&gt;</code>导入的<code class="fe oa ob oc od b">UNNotificationServiceExtension</code>。</p><p id="af1d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该类必须实现以下两个方法:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="1a81" class="mz md it od b gy oi oj l ok ol">- (<strong class="od iu">void</strong>)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(<strong class="od iu">void</strong> (^)(UNNotificationContent * <strong class="od iu">_Nonnull</strong>))contentHandler {<br/>   <strong class="od iu">self</strong>.contentHandler = contentHandler;<br/>   <strong class="od iu">self</strong>.bestAttemptContent = [request.content mutableCopy];</span><span id="0259" class="mz md it od b gy om oj l ok ol">   // change bestAttemptContent here ...</span><span id="28df" class="mz md it od b gy om oj l ok ol"><strong class="od iu">   self</strong>.contentHandler(<strong class="od iu">self</strong>.bestAttemptContent);<br/>}</span><span id="cc58" class="mz md it od b gy om oj l ok ol">- (<strong class="od iu">void</strong>)serviceExtensionTimeWillExpire {<br/>   // Called just before the extension will be terminated by the system.<br/>   // Use this as an opportunity to deliver your "best attempt" at modified content, otherwise the original push payload will be used.<br/> <strong class="od iu">  self</strong>.contentHandler(<strong class="od iu">self</strong>.bestAttemptContent);<br/>}</span></pre><p id="35c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">显然，第一个是完成您需要它执行的所有工作所需要的。</p><h2 id="8b42" class="mz md it bd me na nb dn mi nc nd dp mm lh ne nf mo ll ng nh mq lp ni nj ms nk bi translated">正确设置项目的扩展</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/f918d626dc32726c3f24c07973808693.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BvjV3L5BhRB3Vly404agnw.png"/></div></div></figure><p id="a2f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请确保将这些功能添加到您的目标中。应用程序目标和扩展都需要启用推送通知。而且，在app target上，也加入背景模式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/b52e1571c34f3df09936cdafe086cbad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gryXazi80T-CQo97oszBWg.png"/></div></div></figure><h2 id="1435" class="mz md it bd me na nb dn mi nc nd dp mm lh ne nf mo ll ng nh mq lp ni nj ms nk bi translated">扩展限制</h2><p id="a7e1" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">使用notification service扩展时，了解扩展的运行条件非常重要。</p><p id="17dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，你的扩展将只为那些被配置为向用户显示屏幕提示的通知而启动。这意味着任何静默通知都不会触发您的分机。</p><p id="18da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，传入的通知必须标记为具有可变内容。为此，将值为<code class="fe oa ob oc od b">1</code>的键<code class="fe oa ob oc od b">mutable-content</code>添加到<code class="fe oa ob oc od b">aps</code>字典中。</p><p id="1699" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一件需要了解的事情是如何在应用程序和扩展之间共享信息。正如你从上图中看到的，我已经在扩展中添加了应用程序组功能。应用程序也是如此。已定义的应用程序组必须具有相同的名称(例如<code class="fe oa ob oc od b">group.com.clubsmade.eventsapp</code>)。这使得使用<code class="fe oa ob oc od b">NSUserDefaults</code>共享信息变得很容易，如下所示:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="185f" class="mz md it od b gy oi oj l ok ol">NSUserDefaults *myDefaults = [[NSUserDefaults alloc] <strong class="od iu">initWithSuiteName:@"group.com.clubsmade.eventsapp"</strong>];<br/>[myDefaults setObject:<strong class="od iu">channelName</strong> forKey:@"channelName"];<br/>[myDefaults synchronize];</span></pre><p id="0ba8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面截取的代码中，我将一个频道名保存到用户默认值的共享实例中。您可以注意到，<code class="fe oa ob oc od b">NSUserDefaults</code>实例已经用套件名<em class="op">创建了。</em></p><p id="28ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我保存在我的用户默认值中的频道名称将在我的扩展中使用，以向PubNub频道发布一些消息。</p><p id="1fec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要从用户默认值中读取该信息，请使用以下代码片段:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="31b3" class="mz md it od b gy oi oj l ok ol">NSUserDefaults *defaultUserPreferences = [[NSUserDefaults alloc] <strong class="od iu">initWithSuiteName:@"group.com.clubsmade.eventsapp"</strong>];</span><span id="d0b7" class="mz md it od b gy om oj l ok ol">NSString *channelName = [defaultUserPreferences stringForKey:@"channelName"];</span></pre><p id="0e16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这么简单。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2dbd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="d0f3" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">通过iOS 10中新的<code class="fe oa ob oc od b">UNNotificationServiceExtension</code>类，你可以非常简单地为自己的应用实现通知服务扩展。无论您的用例是什么，这些API都允许您在通知显示给用户之前轻松地修改通知的内容，或者在有限的时间内执行其他操作。</p></div></div>    
</body>
</html>