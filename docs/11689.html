<html>
<head>
<title>A Simple Airflow Design Pattern — Build More Scalable Pipelines Using Python Fire</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单的气流设计模式—使用Python Fire构建更具可扩展性的管道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-simple-airflow-design-pattern-to-avoid-a-cardinal-sin-cebeafd19a99?source=collection_archive---------6-----------------------#2022-04-08">https://betterprogramming.pub/a-simple-airflow-design-pattern-to-avoid-a-cardinal-sin-cebeafd19a99?source=collection_archive---------6-----------------------#2022-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3905" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建强大的CLI</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a18fedb9777dc996be273d618c464ab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WlUfFdr8KsJi8GU-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@sadswim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊恩·杜利</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="8c4b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">为什么不应该使用Python运算符</h1><p id="6fd7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Airflow是一个无处不在的开源平台，用于以声明方式和编程方式定义复杂的工作流。重要的是，使用一个丰富的<a class="ae ky" href="https://airflow.apache.org/docs/apache-airflow/stable/howto/operator/index.html" rel="noopener ugc nofollow" target="_blank">操作符</a>生态系统，工作单元几乎可以在任何地方被分派和执行；这个生态系统包括Airflow的工人节点本身，如果你利用所有操作者中最卑微的，PythonOperator。</p><p id="7c73" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是一种应该避免的反模式，原因如下:任务相互竞争资源，会使集群资源匮乏；依赖关系必须安装在工作节点上，并且可能会发生冲突；并且所有代码都必须部署到Airflow，这使得很难为每个模型建立一个单一用途的部署管道。</p><p id="24de" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">将模型打包到Docker容器中听起来很棒，但是从DAG与这些容器进行接口，尤其是在有动态输入的情况下，是一件令人头疼的事情，并且需要一定程度的CLI编程。这也是数据科学家和工程师急于推出PythonOperator的原因之一:<em class="ms">从Python调用Python函数很容易；从命令行调用Python函数很难。</em></p><p id="8df3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我告诉你你可以鱼与熊掌兼得呢…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/6adb62113594eae3ac931f8ef4e517d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VlYa9T6gTLw2JmoGlWOhDQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。通过<a class="ae ky" href="https://www.kapwing.com/" rel="noopener ugc nofollow" target="_blank">https://www.kapwing.com/</a>生成</p></figure><h1 id="6d47" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">模式</h1><p id="d5da" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在深入到一个更具体的例子之前，我想在一个高层次上布局设计模式。</p><ol class=""><li id="df83" class="mu mv it lt b lu mn lx mo ma mw me mx mi my mm mz na nb nc bi translated">在一个单一用途的存储库中构建您的模型(或者至少是<code class="fe nd ne nf ng b">submodule</code>)。</li><li id="dc57" class="mu mv it lt b lu nh lx ni ma nj me nk mi nl mm mz na nb nc bi translated">在模型的主文件中实例化Fire(如下例)。</li><li id="609d" class="mu mv it lt b lu nh lx ni ma nj me nk mi nl mm mz na nb nc bi translated">在Airflow中，使用python-CLI并用您想要调用的任何类、方法和参数覆盖Docker入口点。</li></ol><h1 id="c33b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">不可缩放的DAG</h1><p id="97d1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们以一个简单的机器学习DAG为例，它有两个步骤。训练和推理任务都需要几个参数，这些参数可以由环境变量、运行时触发器或其他动态输入来配置。由于模型是用Python编写的，我们只需使用<code class="fe nd ne nf ng b">PythonOperator</code>调用这两个步骤。</p><p id="5520" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不是为了强调这一点，而是为了使上面指出的一般问题具体化:训练或得分任务可能会耗尽大量资源，使集群陷入饥饿状态；以及连接到特征和模型存储层的逻辑都必须与DAG紧密耦合，鼓励意大利面条式代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不可扩展的DAG利用Python运算符进行训练和评分</p></figure><h1 id="d68f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">在火中包裹模型代码</h1><p id="21a4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果我们试图以正确的方式做事，通过将模型容器化，并使用在一些计算服务(Kubernetes、AWS Batch等)上启动工作流的操作符。)，我们必须通过环境变量或CLI将这些运行时参数传递到容器中，并对该接口进行编程。任何工程师都不想花费时间来构建一个具有良好错误处理能力的健壮CLI。</p><p id="f6e3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">进入谷歌的<a class="ae ky" href="https://github.com/google/python-fire" rel="noopener ugc nofollow" target="_blank"> Python火了</a>。这个库将任何Python对象(读取函数、类等。)转换成一个直观的参数化CLI，并且给你一个更少的借口来打击你的气流工作者。下面的示例代码不包含关于如何从命令行与它交互的显式参考，但是(正如您在下一个DAG中看到的)您可以使用您想要的任何参数调用<code class="fe nd ne nf ng b">CustomerModel</code>类中的任何方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">面向对象的机器学习模型代码的框架</p></figure><h1 id="0a36" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">从气流DAG调用CLI</h1><p id="c8d6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了探究在Fire中包装建模代码的能力，让我们看一个DAG，它使用自动生成的CLI接口在Docker容器中启动模型。</p><p id="22b3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里的<code class="fe nd ne nf ng b">KubernetesPodOperator</code>只是任何可能运行<code class="fe nd ne nf ng b">my_model_image</code>中打包的模型代码的计算服务运营商的替身。</p><p id="f609" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">CLI允许DAG的两个任务调用不同的方法并以Python方式传递参数，因此您不必像调用Python函数那样深入考虑接口！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kubernetes吊舱中的气流DAG启动任务</p></figure></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="5ab1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通过为您的Python对象自动生成一个健壮的CLI，Python Fire显著降低了外包计算的障碍，并让Airflow做它最擅长的事情。</p></div></div>    
</body>
</html>