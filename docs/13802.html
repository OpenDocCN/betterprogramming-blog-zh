<html>
<head>
<title>Mutation Testing Example: How To Leverage Failure by Experimenting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">突变测试示例:如何通过实验利用失败</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mutation-testing-by-example-how-to-leverage-failure-by-experimenting-fc4f13aa39bd?source=collection_archive---------12-----------------------#2022-09-28">https://betterprogramming.pub/mutation-testing-by-example-how-to-leverage-failure-by-experimenting-fc4f13aa39bd?source=collection_archive---------12-----------------------#2022-09-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5cba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过快速失败学习代码的深度指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3df3f8dc88e7ca7766bca7d81c722136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7kI_KQ7MgymJz4Qt"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚历克斯·布纳季奇的照片</p></figure><p id="f187" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我的文章<a class="ae lu" href="https://medium.com/@alexbunardzic/hands-on-explanation-of-how-tdd-works-c009135dfc79" rel="noopener">TDD如何工作的实践解释</a>中，我展示了当一个可测量的测试可用时，迭代的力量来保证一个解决方案。在那篇文章中，一种迭代方法有助于确定如何实现计算给定数字平方根的代码。</p><p id="49be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我还演示了最有效的方法是找到一个可测量的目标或测试，然后开始用最佳猜测进行迭代。正如所料，对正确答案的第一次猜测很可能会失败，因此失败的猜测需要改进。精确的猜测必须根据可测量的目标或测试进行验证。根据结果，猜测要么被验证，要么必须进一步完善。</p><p id="2ab4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个模型中，学习如何达到解决方案的唯一方法是反复失败。这听起来违反直觉，但令人惊讶的是，这很有效。</p><p id="5da2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">跟随这一分析的脚步，本文研究了在构建包含一些依赖项的解决方案时使用DevOps方法的最佳方式。第一步是编写一个可能会失败的测试。</p><h1 id="cd83" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">依赖的问题在于你不能依赖它们</h1><p id="19c5" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">正如迈克尔·尼加德在<a class="ae lu" href="https://www.infoq.com/presentations/Architecture-Without-an-End-State/" rel="noopener ugc nofollow" target="_blank"> <em class="ms">没有结束状态</em> </a>的架构中风趣地表达的那样，依赖的问题是一个巨大的主题，最好留给另一篇文章来讨论。在这里，您将看到依赖关系可能给项目带来的潜在缺陷，以及如何利用测试驱动开发(TDD)来避免这些缺陷。</p><p id="70ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，提出一个现实生活中的挑战，然后看看如何使用TDD来解决它。</p><h1 id="7b54" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">谁把猫放出来了？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/0d91fa12428ae4398b5888ce86f0c4fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*6uIZJYJLXa_Dfc8K.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚历克斯·布纳季奇的照片</p></figure><p id="1c95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在敏捷开发环境中，通过定义期望的结果来开始构建解决方案是有帮助的。通常，期望的结果在<a class="ae lu" href="https://www.agilealliance.org/glossary/user-stories#q=~(infinite~false~filters~(postType~(~'page~'post~'aa_book~'aa_event_session~'aa_experience_report~'aa_glossary~'aa_research_paper~'aa_video)~tags~(~'user*20stories))~searchTerm~'~sort~false~sortDirection~'asc~page~1)" rel="noopener ugc nofollow" target="_blank">用户故事</a>中描述:</p><blockquote class="mu mv mw"><p id="840d" class="ky kz ms la b lb lc ju ld le lf jx lg mx li lj lk my lm ln lo mz lq lr ls lt im bi translated">使用我的家庭自动化系统</p><p id="4476" class="ky kz ms la b lb lc ju ld le lf jx lg mx li lj lk my lm ln lo mz lq lr ls lt im bi translated">我想控制猫什么时候可以出去</p><p id="45f8" class="ky kz ms la b lb lc ju ld le lf jx lg mx li lj lk my lm ln lo mz lq lr ls lt im bi translated">因为我想让猫安全过夜</p></blockquote><p id="ddd8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在您有了一个用户故事，您需要通过提供一些功能需求(也就是说，通过指定接受标准)来详细阐述它。从伪代码中描述的最简单的场景开始:</p><blockquote class="mu mv mw"><p id="c4de" class="ky kz ms la b lb lc ju ld le lf jx lg mx li lj lk my lm ln lo mz lq lr ls lt im bi translated">场景#1:夜间禁用猫陷阱门</p></blockquote><ul class=""><li id="481c" class="na nb it la b lb lc le lf lh nc ll nd lp ne lt nf ng nh ni bi translated">假设时钟检测到现在是晚上</li><li id="5324" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">当时钟通知HAS时</li><li id="708e" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">然后，禁用支持物联网(IoT)的猫陷阱门</li></ul><h1 id="8e67" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">分解系统</h1><p id="6153" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在您开始工作之前，您正在构建的系统(HAS)需要被分解——分解成它的依赖项。您必须做的第一件事是确定任何依赖关系(如果您幸运的话，您的系统没有依赖关系，这将使它易于构建，但这样它可能就不是一个非常有用的系统)。</p><p id="ecd9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从上面的简单场景中，您可以看到期望的业务结果(自动控制猫门)取决于对夜间的检测。这种依赖性取决于时钟。但是时钟不能确定现在是白天还是晚上。这取决于你提供的逻辑。</p><p id="309c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您正在构建的系统中的另一个依赖项是自动访问cat door并启用或禁用它的能力。这种依赖性很可能依赖于支持物联网的猫门提供的API。</p><h1 id="d3f0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">依赖关系管理快速失败</h1><p id="b381" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">为了满足一个依赖关系，我们将构建一个逻辑来确定当前时间是白天还是夜晚。本着TDD的精神，我们将从一个小的失败开始。</p><p id="9f9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于如何设置这个练习所需的开发环境和框架的详细说明，请参考我以前的文章。我们将重用相同的网络环境，并依赖于<a class="ae lu" href="https://xunit.net/" rel="noopener ugc nofollow" target="_blank">xUnit.net</a>框架。</p><p id="5e17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，创建一个名为HAS(表示“家庭自动化系统”)的新项目，并创建一个名为UnitTest1.cs的文件。在这个测试中，描述你的期望。例如，当系统运行时，如果时间是晚上7点，那么负责决定是白天还是夜间的组件将返回值“夜间”</p><p id="1b41" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是描述这种期望的测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c928" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">至此，您可能已经熟悉了测试的形状和形式。快速复习:通过给测试起一个描述性的名字来描述期望，在这个例子中为Given7pmReturnNighttime。然后，在测试主体中，创建一个名为expected的变量，并为其分配期望值(在本例中，值为“夜间”)。接下来，名为actual的变量被赋予实际值(在组件或服务处理一天中的时间后可用)。</p><p id="8024" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，它通过断言期望值和实际值相等来检查期望值是否满足。相等(预期，实际)。</p><p id="082f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以在上面的清单中看到一个名为<code class="fe nq nr ns nt b">dayOrNightUtility</code>的组件或服务。这个模块能够接收消息<code class="fe nq nr ns nt b">GetDayOrNight</code>，并且应该返回类型<code class="fe nq nr ns nt b">string</code>的值。</p><p id="6ea5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，在TDD的精神中，被描述的组件或服务还没有被构建(它仅仅是被描述为以后规定它)。构建它是由所描述的期望驱动的。</p><p id="a777" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe nq nr ns nt b">app</code>文件夹中创建一个新文件，命名为<code class="fe nq nr ns nt b">DayOrNightUtility.cs</code>。将以下C#代码添加到该文件并保存:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3620" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，转到命令行，将目录切换到<code class="fe nq nr ns nt b">unittests</code>文件夹，并运行测试:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="95e3" class="ny lw it nt b gy nz oa l ob oc">[Xunit.net 00:00:02.33] unittest.UnitTest1.Given7pmReturnNighttime [FAIL]<br/> Failed unittest.UnitTest1.Given7pmReturnNighttime<br/> [...]</span></pre><p id="929e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">恭喜你，你已经写出了第一个失败的测试。测试期望<code class="fe nq nr ns nt b">DayOrNightUtility</code>返回字符串值“Nighttime ”,但是它收到了字符串值“Undetermined”</p><h1 id="6d6a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">修复失败的测试</h1><p id="ca6a" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">修复失败测试的一种快速而又肮脏的方法是用值“夜间”替换值“未确定”,并保存更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6a7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在当我们运行测试时，它通过了:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="6c0d" class="ny lw it nt b gy nz oa l ob oc">Starting test execution, please wait...</span><span id="880c" class="ny lw it nt b gy od oa l ob oc">Total tests: 1. Passed: 1. Failed: 0. Skipped: 0.<br/> Test Run Successful.<br/> Test execution time: 2.6470 Seconds</span></pre><p id="77d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，硬编码的价值观基本上是欺骗，所以最好赋予<code class="fe nq nr ns nt b">DayOrNightUtility</code>一些智能。修改<code class="fe nq nr ns nt b">GetDayOrNight</code>方法以包含一些时间计算逻辑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="70d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该方法现在从系统中获取当前时间，并比较<code class="fe nq nr ns nt b">Hour</code>值以查看它是否小于上午7点。如果是，则逻辑将<code class="fe nq nr ns nt b">dayOrNight</code>字符串值从“白天”转换为“夜间”测试现在通过了。</p><h1 id="25e7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">白天呢？</h1><p id="2e0e" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">接下来，您需要描述当当前时间大于早上7点时会发生什么情况的预期。下面是名为<code class="fe nq nr ns nt b">Given7amReturnDaylight</code>的新测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f0fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新的测试现在失败了(值得重复——越早失败越好！):</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="2688" class="ny lw it nt b gy nz oa l ob oc">Starting test execution, please wait...<br/> [Xunit.net 00:00:01.23] unittest.UnitTest1.Given7amReturnDaylight [FAIL]<br/> Failed unittest.UnitTest1.Given7amReturnDaylight<br/> [...]</span></pre><p id="0d5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它期望收到字符串值<code class="fe nq nr ns nt b">“Daylight”</code>，但却收到了字符串值<code class="fe nq nr ns nt b">“Nighttime”</code>。</p><h1 id="8bcd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">分析失败的测试用例</h1><p id="fe37" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">经过更仔细的检查，我们的代码似乎陷入了困境。原来<code class="fe nq nr ns nt b">GetDayOrNight</code>方法的实现是不可测试的！</p><p id="9b02" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看一下我们面临的核心挑战:</p><blockquote class="mu mv mw"><p id="db58" class="ky kz ms la b lb lc ju ld le lf jx lg mx li lj lk my lm ln lo mz lq lr ls lt im bi translated"><em class="it"> 1。</em> <code class="fe nq nr ns nt b"><em class="it">GetDayOrNight</em></code> <em class="it">依靠隐藏输入。</em><br/><code class="fe nq nr ns nt b"><em class="it">dayOrNight</em></code>的值取决于隐藏输入(它从内置系统时钟中获取一天中的时间值)。</p><p id="9e84" class="ky kz ms la b lb lc ju ld le lf jx lg mx li lj lk my lm ln lo mz lq lr ls lt im bi translated"><em class="it"> 2。</em> <code class="fe nq nr ns nt b"><em class="it">GetDayOrNight</em></code> <em class="it">包含非确定性行为。</em> <br/>从系统时钟获得的时间值是不确定的。这取决于您运行代码的时间点，我们必须考虑这种不可预测性。</p><p id="05d6" class="ky kz ms la b lb lc ju ld le lf jx lg mx li lj lk my lm ln lo mz lq lr ls lt im bi translated"><em class="it"> 3。低质量的</em> <code class="fe nq nr ns nt b"><em class="it">GetDayOrNight</em></code> <em class="it"> API。</em> <br/>这个API与具体的数据源(系统<code class="fe nq nr ns nt b"><em class="it">DateTime</em></code>)紧密耦合。</p><p id="4497" class="ky kz ms la b lb lc ju ld le lf jx lg mx li lj lk my lm ln lo mz lq lr ls lt im bi translated"><em class="it"> 4。</em> <code class="fe nq nr ns nt b"><em class="it">GetDayOrNight</em></code> <em class="it">违反了单一责任原则。</em> <br/>你实现了一个同时消费信息和处理信息的方法。一个好的做法是，一个方法应该只负责执行一项任务。</p><p id="b05b" class="ky kz ms la b lb lc ju ld le lf jx lg mx li lj lk my lm ln lo mz lq lr ls lt im bi translated"><em class="it"> 5。</em> <code class="fe nq nr ns nt b"><em class="it">GetDayOrNight</em></code> <em class="it">有不止一个改变的理由。</em> <br/>可以想象一个场景，时间的内部来源可能会改变。同样，很容易想象处理逻辑会改变。这些不同的变化原因必须相互隔离。</p><p id="0cc5" class="ky kz ms la b lb lc ju ld le lf jx lg mx li lj lk my lm ln lo mz lq lr ls lt im bi translated">6。 <code class="fe nq nr ns nt b"><em class="it">GetDayOrNight</em></code> <em class="it">的API签名不足以理解它的行为。通过简单地查看一个API的签名，就能理解它会有什么样的行为，这是非常可取的。</em></p><p id="3257" class="ky kz ms la b lb lc ju ld le lf jx lg mx li lj lk my lm ln lo mz lq lr ls lt im bi translated">7。 <code class="fe nq nr ns nt b"><em class="it">GetDayOrNight</em></code> <em class="it">依赖于全局共享的可变状态。</em> <br/>要不惜一切代价避免共享的可变状态！</p><p id="7444" class="ky kz ms la b lb lc ju ld le lf jx lg mx li lj lk my lm ln lo mz lq lr ls lt im bi translated"><em class="it"> 8。</em> <code class="fe nq nr ns nt b"><em class="it">GetDayOrNight</em></code> <em class="it">方法的行为即使在读取源代码后也无法预测。那是一个可怕的命题。一旦系统可以运行，通过阅读源代码就可以很清楚地知道可以预测什么样的行为。</em></p></blockquote><h1 id="6299" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">失败背后的原则</h1><p id="24e5" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">每当你面临一个工程问题时，使用久经考验的分而治之的策略是明智的。在这种情况下，遵循关注点分离的原则是正确的。</p><blockquote class="mu mv mw"><p id="9303" class="ky kz ms la b lb lc ju ld le lf jx lg mx li lj lk my lm ln lo mz lq lr ls lt im bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">关注点分离</a> ( SoC)是一种设计原则，用于将计算机程序分成不同的部分，以便每个部分解决一个单独的关注点。关注点是影响计算机程序代码的一组信息。关注点可以像代码被优化的硬件的细节一样普遍，也可以像要实例化的类名一样具体。一个很好体现SoC的程序叫做模块化程序。</p></blockquote><p id="6534" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nq nr ns nt b">GetDayOrNight</code>方法应该只关心决定日期和时间值是指白天还是夜晚。它不应该关心寻找价值的来源。这个问题应该留给呼叫客户。</p><p id="fd06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您必须将获取当前时间的任务交给调用客户端。这种方法符合另一个有价值的工程原理——控制反转。马丁·福勒在<a class="ae lu" href="https://martinfowler.com/bliki/InversionOfControl.html" rel="noopener ugc nofollow" target="_blank">中详细探讨了这个概念，这里是</a>。</p><blockquote class="mu mv mw"><p id="7d80" class="ky kz ms la b lb lc ju ld le lf jx lg mx li lj lk my lm ln lo mz lq lr ls lt im bi translated">框架的一个重要特征是，用户定义的用于定制框架的方法通常会从框架内部调用，而不是从用户的应用程序代码调用。框架通常在协调和排序应用程序活动中扮演主程序的角色。这种控制反转赋予了框架作为可扩展骨架的能力。用户提供的方法为特定的应用定制框架中定义的通用算法。<em class="it">——</em><a class="ae lu" href="http://www.laputan.org/drc/drc.html" rel="noopener ugc nofollow" target="_blank"><em class="it">拉尔夫·约翰逊和布莱恩·富特</em> </a></p></blockquote><h1 id="176b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">重构测试用例</h1><p id="76bd" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">显然，我们需要重构代码。摆脱对内部时钟的依赖(系统实用程序<code class="fe nq nr ns nt b">DateTime</code>):</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="59f0" class="ny lw it nt b gy nz oa l ob oc">DateTime time = <a class="ae lu" href="http://www.google.com/search?q=new+msdn.microsoft.com" rel="noopener ugc nofollow" target="_blank">new</a> DateTime();</span></pre><p id="1379" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">删除上面的行(应该是文件中的第7行)。通过向<code class="fe nq nr ns nt b">GetDayOrNight</code>方法添加一个输入参数<code class="fe nq nr ns nt b">DateTime</code>时间来进一步重构您的代码。</p><p id="0c06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是重构后的类<code class="fe nq nr ns nt b">DayOrNightUtility.cs</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b847" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">重构代码需要改变测试。您需要为<code class="fe nq nr ns nt b">nightHour</code>和<code class="fe nq nr ns nt b">dayHour</code>准备值，并将这些值传递给<code class="fe nq nr ns nt b">GetDayOrNight</code>方法。以下是重构后的测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="8a64" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">经验教训</h1><p id="10b9" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在继续这个简单的场景之前，回顾一下本练习中的内容。</p><p id="5d8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过实现不可测试的代码，很容易无意中创建一个陷阱。从表面上看，这些代码似乎运行正常。然而，如果我们遵循测试驱动开发(TDD)实践——首先描述期望，然后才规定实现——它会立即揭示代码中的严重问题。</p><p id="b859" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这表明TDD是确保代码不会变得太乱的理想方法。TDD指出了问题领域，例如单一责任的缺失和隐藏输入的存在。此外，TDD有助于删除非确定性代码，并用行为确定的完全可测试的代码替换它。</p><p id="6bc9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，TDD有助于交付易于阅读的代码，因为实现的逻辑易于理解。</p><p id="e5aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们看看如何使用在这个练习中创建的逻辑来实现功能代码，以及进一步的测试如何使它变得更好。</p><h1 id="09cb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在夜间禁用猫陷阱门</h1><p id="b2c1" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">假设猫门是一个复杂的物联网(IoT)产品，它有一个IP地址，可以通过向其API发送请求来访问。为了简洁起见，本系列不探讨如何对物联网设备进行编程；相反，它模拟服务来保持对测试驱动开发(TDD)和突变测试的关注。</p><p id="8e80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从编写一个失败的测试开始:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="6c3c" class="ny lw it nt b gy nz oa l ob oc">[Fact]<br/>public void GivenNighttimeDisableTrapDoor() {<br/>   var expected = "Cat trap door disabled";<br/>   var timeOfDay = dayOrNightUtility.GetDayOrNight(nightHour);<br/>   var actual = catTrapDoor.Control(timeOfDay);<br/>   Assert.Equal(expected, actual);<br/>}</span></pre><p id="4e85" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这描述了一个全新的组件或服务(<code class="fe nq nr ns nt b">catTrapDoor</code>)。该组件(或服务)具有在给定当前时间的情况下控制活板门的能力。现在是时候实施<code class="fe nq nr ns nt b">catTrapDoor</code>了。</p><p id="7899" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要模拟这个服务，您必须首先使用接口描述它的功能。在app文件夹中新建一个文件，命名为<code class="fe nq nr ns nt b">ICatTrapDoor.cs</code>(按照惯例，一个接口名称以大写字母<code class="fe nq nr ns nt b">I</code>开头)。将以下代码添加到该文件中:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="3ab4" class="ny lw it nt b gy nz oa l ob oc">namespace app{<br/>   public interface ICatTrapDoor {<br/>       string Control(string dayOrNight);<br/>   }<br/>}</span></pre><p id="64b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此接口无法运行。它仅仅描述了您在构建<code class="fe nq nr ns nt b">CatTrapDoor</code>服务时的意图。接口是创建您正在使用的服务的抽象的好方法。在某种程度上，您可以将这个接口视为<code class="fe nq nr ns nt b">CatTrapDoor</code>服务的API。</p><p id="6fdd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要实现API，在app文件夹中创建一个新文件，并将其命名为<code class="fe nq nr ns nt b">FakeCatTrapDoor.cs</code>。将以下代码输入到类文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9ea0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个新的<code class="fe nq nr ns nt b">FakeCatTrapDoor</code>类实现了接口<code class="fe nq nr ns nt b">ICatTrapDoor</code>。它的方法<code class="fe nq nr ns nt b">Control</code>接受字符串值<code class="fe nq nr ns nt b">dayOrNight</code>，并检查传入的值是否是“Nighttime”如果是，它将<code class="fe nq nr ns nt b">trapDoorStatus</code>从“未确定”修改为“猫活板门禁用”,并将该值返回给调用客户端。</p><p id="de67" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么叫<code class="fe nq nr ns nt b">FakeCatTrapDoor</code>？因为这不是真正的猫活板门。假的只是帮助你找出处理逻辑。一旦你的逻辑无懈可击，假服务就被真正的服务取代了(这个话题留给集成测试这个学科)。</p><p id="2efb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着一切的实现，所有的测试在运行时都通过了:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="2b50" class="ny lw it nt b gy nz oa l ob oc">Starting test execution, please wait...</span><span id="e37d" class="ny lw it nt b gy od oa l ob oc">Total tests; 3. Passed: 3. failed: 0. Skipped: 0.<br/> Test Run Successful.<br/> Test execution time: 1.3913 Seconds</span></pre><h1 id="808a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在白天启用猫活板门</h1><p id="5b5e" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">是时候看看我们用户故事中的下一个场景了:</p><blockquote class="mu mv mw"><p id="b575" class="ky kz ms la b lb lc ju ld le lf jx lg mx li lj lk my lm ln lo mz lq lr ls lt im bi translated">场景#2:白天启用猫陷阱门</p></blockquote><ul class=""><li id="6cae" class="na nb it la b lb lc le lf lh nc ll nd lp ne lt nf ng nh ni bi translated">假设时钟检测到日光</li><li id="bbe9" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">当时钟通知HAS时</li><li id="843b" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">然后HAS启动猫活板门</li></ul><p id="7f65" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这应该很容易，只是第一个场景的另一面。首先，编写失败的测试。将以下测试添加到<code class="fe nq nr ns nt b">unittest </code>文件夹中的<code class="fe nq nr ns nt b"> UnitTest1.cs</code>文件中:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="f621" class="ny lw it nt b gy nz oa l ob oc">[Fact]<br/>public void GivenDaylightEnableTrapDoor() {<br/>   var expected = "Cat trap door enabled";<br/>   var timeOfDay = dayOrNightUtility.GetDayOrNight(dayHour);<br/>   var actual = catTrapDoor.Control(timeOfDay);<br/>   Assert.Equal(expected, actual);<br/>}</span></pre><p id="8cbc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当向<code class="fe nq nr ns nt b">catTrapDoor</code>服务发送“日光”状态时，您可能会收到“猫活板门已启用”的通知。当您运行测试时，您会看到您所期望的结果，它会像预期的那样失败:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="6cf1" class="ny lw it nt b gy nz oa l ob oc">Starting test execution, please wait...<br/> [Xunit unittest.UnitTest1.UnitTest1.GivenDaylightEnableTrapDoor [FAIL]<br/> Failed unittest.UnitTest1.UnitTest1.GivenDaylightEnableTrapDoor<br/> [...]</span></pre><p id="b942" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">测试预计会收到“猫活板门已启用”的通知，但却被告知猫活板门的状态为“未确定”爽；现在是修复这个小故障的时候了。</p><p id="4eb0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">给<code class="fe nq nr ns nt b">FakeCatTrapDoor</code>添加三行代码就可以了:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="d77b" class="ny lw it nt b gy nz oa l ob oc">if(dayOrNight == "Daylight") {<br/>   trapDoorStatus = "Cat trap door enabled";<br/>}</span></pre><p id="04b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">再次运行测试，所有测试都通过:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="d7b1" class="ny lw it nt b gy nz oa l ob oc">Starting test execution, please wait...</span><span id="366d" class="ny lw it nt b gy od oa l ob oc">Total tests: 4. Passed: 4. Failed: 0. Skipped: 0.<br/> Test Run Successful.<br/> Test execution time: 2.4888 Seconds</span></pre><p id="bc89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">厉害！一切看起来都很好。所有的测试都是绿色的；你有一个坚如磐石的解决方案。谢谢你，TDD！</p><h1 id="d758" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">没那么快！</h1><p id="ec9e" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">有经验的工程师不会相信这个解决方案是坚如磐石的。为什么？因为溶液还没有变异。</p><p id="9002" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然随着一个成功的控制猫门的示例物联网(IoT)应用程序，旅程似乎已经结束，但有经验的程序员知道解决方案需要突变测试。</p><h1 id="6514" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是突变检测？</h1><p id="e2fb" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">变异测试是这样一个过程:遍历每一行已实现的代码，对那一行进行变异，然后运行测试并检查变异是否超出了预期。如果没有，你就创造了一个幸存的变异体。</p><p id="5b20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸存的突变体总是一个令人担忧的问题，它指出了代码库中潜在的危险区域。一旦你抓到一个幸存的变异人，你必须杀死它。杀死幸存的变异体的唯一方法是创建额外的描述——描述你对函数或模块输出的期望的新测试。最终，您交付了一个精益的、不透气的解决方案，并保证您的代码库中没有令人讨厌的bug或缺陷。</p><p id="8441" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你让幸存的变种人四处游荡、繁衍、长寿、繁荣，那么你正在制造可怕的技术债务。另一方面，如果任何测试抱怨临时突变的代码行产生的输出与预期的输出不同，那么这个突变体就被杀死了。</p><h1 id="72b1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">安装Stryker</h1><p id="d83f" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">尝试突变测试的最快方法是利用专门的框架。这个例子使用了<a class="ae lu" href="https://stryker-mutator.io/" rel="noopener ugc nofollow" target="_blank"> Stryker </a>。</p><p id="4eb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要安装Stryker，请转到命令行并运行:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="b0f7" class="ny lw it nt b gy nz oa l ob oc">$ dotnet tool install -g dotnet-stryker</span></pre><p id="01dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要运行Stryker，请导航至<code class="fe nq nr ns nt b">unittest</code>文件夹并键入:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="a3d9" class="ny lw it nt b gy nz oa l ob oc">$ dotnet-stryker</span></pre><p id="6489" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是Stryker关于我们解决方案质量的报告:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="8c00" class="ny lw it nt b gy nz oa l ob oc">14 mutants have been created. Each mutant will now be tested, this could take a while.</span><span id="4e56" class="ny lw it nt b gy od oa l ob oc">Tests progress | 14/14 | 100% | ~0m 00s | <br/> Killed : 13<br/> Survived : 1<br/> Timeout : 0</span><span id="1d05" class="ny lw it nt b gy od oa l ob oc">All mutants have been tested, and your mutation score has been calculated <br/> - \app [13/14 (92.86%)]<br/> [...]</span></pre><p id="3925" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">报告称:</p><ul class=""><li id="aee2" class="na nb it la b lb lc le lf lh nc ll nd lp ne lt nf ng nh ni bi translated">史崔克创造了14个变异人</li><li id="6b5c" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">史崔克看到13名变种人被测试杀死</li><li id="0e09" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">史崔克看到一个变异人在测试中幸存下来</li><li id="8361" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">Stryker计算出现有代码库包含92.86%的符合预期的代码</li><li id="35a1" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">Stryker计算出7.14%的代码库包含不符合预期的代码</li></ul><p id="2f1f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总的来说，Stryker声称我们迄今为止构建的应用程序未能产生一个可靠的解决方案。</p><h1 id="5748" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">如何杀死一个变异人</h1><p id="d477" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">当软件开发人员遇到幸存的变种人时，他们通常会找到已实现的代码，并寻找修改它的方法。例如，在应用程序为卡特彼勒车门自动化的情况下，更改以下代码行:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="94f1" class="ny lw it nt b gy nz oa l ob oc">string trapDoorStatus = "Undetermined";</span></pre><p id="7f07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">收件人:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="38dd" class="ny lw it nt b gy nz oa l ob oc">string trapDoorStatus = "";</span></pre><p id="2293" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">再次运行史崔克。一个变种人活了下来:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="d108" class="ny lw it nt b gy nz oa l ob oc">All mutants have been tested, and your mutation score has been calculated<br/> - \app [13/14 (92.86%)]<br/> [...]<br/> [Survived] String mutation on line 4: '""' ==&gt; '"Stryker was here!"'<br/> [...]</span></pre><p id="7bcd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一次，你可以看到Stryker改变了生产线:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="d96a" class="ny lw it nt b gy nz oa l ob oc">string trapDoorStatus = "";</span></pre><p id="a356" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">变成:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="3e74" class="ny lw it nt b gy nz oa l ob oc">string trapDoorStatus = ""Stryker was here!";</span></pre><p id="8316" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是Stryker工作方式的一个很好的例子:它以一种聪明的方式改变每一行运输代码，以查看是否有我们尚未考虑的进一步测试案例。这迫使我们更深入地考虑我们的期望。</p><p id="446e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">被Stryker打败后，您可以尝试通过添加更多逻辑来改进实现的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7e11" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但再次运行Stryker后，你会看到这一尝试创造了一个新的突变体:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="ec4b" class="ny lw it nt b gy nz oa l ob oc">ll mutants have been tested, and your mutation score has been calculated<br/> - \app [13/15 (86.67%)]<br/> [...]<br/> [Survived] String mutation on line 4: '"Undetermined"' ==&gt; '""'<br/> [...]<br/> [Survived] String mutation on line 10: '"Undetermined"' ==&gt; '""'<br/> [...]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/3e7ea2c32419a26b8e36fd26900fb5e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/0*yjMaHrtfpUGkv36E.png"/></div></figure><p id="e855" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你不能通过修改实现的代码来摆脱这个困境。事实证明杀死幸存的变种人的唯一方法是描述额外的期望。你如何描述期望？通过编写测试。</p><p id="a30a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是时候添加一个新的测试了。由于幸存的突变体位于第4行，您意识到您没有用值“未确定”指定输出的期望值。</p><p id="25b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们添加一个新的测试:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="64db" class="ny lw it nt b gy nz oa l ob oc">[Fact]<br/>public void GivenIncorrectTimeOfDayReturnUndetermined() {<br/>   var expected = "Undetermined";<br/>   var actual = catTrapDoor.Control("Incorrect input");<br/>   Assert.Equal(expected, actual);<br/>}</span></pre><p id="af91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">修复成功了！现在所有的变种人都被杀死了:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="1887" class="ny lw it nt b gy nz oa l ob oc">All mutants have been tested, and your mutation score has been calculated<br/> - \app [14/14 (100%)]<br/> [Killed] [...]</span></pre><p id="8864" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您最终有了一个完整的解决方案，包括如果系统接收到不正确的输入值时的输出描述。</p><h1 id="bfbc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">突变测试拯救世界</h1><p id="bbe8" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">假设您决定过度设计一个解决方案，并将这个方法添加到<code class="fe nq nr ns nt b">FakeCatTrapDoor</code>:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="2eb2" class="ny lw it nt b gy nz oa l ob oc">private string getTrapDoorStatus(string dayOrNight) {<br/>   string status = "Everything okay";<br/>   if(dayOrNight != "Nighttime" || dayOrNight != "Daylight") {<br/>       status = "Undetermined";<br/>   }<br/>   return status;<br/>}</span></pre><p id="6f86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后替换第4行语句:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="79ee" class="ny lw it nt b gy nz oa l ob oc">string trapDoorStatus = "Undetermined";</span></pre><p id="9cb4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="be20" class="ny lw it nt b gy nz oa l ob oc">string trapDoorStatus = getTrapDoorStatus(dayOrNight);</span></pre><p id="ea1f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您运行测试时，一切都通过了:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="e0f7" class="ny lw it nt b gy nz oa l ob oc">Starting test execution, please wait...</span><span id="09ef" class="ny lw it nt b gy od oa l ob oc">Total tests: 5. Passed: 5. Failed: 0. Skipped: 0.<br/> Test Run Successful.<br/> Test execution time: 2.7191 Seconds</span></pre><p id="998e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">测试已顺利通过。TDD奏效了。但是把Stryker带到现场，突然画面看起来有点可怕:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="4ec2" class="ny lw it nt b gy nz oa l ob oc">All mutants have been tested, and your mutation score has been calculated<br/> - \app [14/20 (70%)]<br/> [...]</span></pre><p id="d02f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">史崔克创造了20个变种人；14名变种人被杀，6名变种人幸存。这将成功得分降低到70%。这意味着只有70%的代码能够满足描述的期望。另外30%的代码没有明确的原因，这使我们面临代码滥用的风险。</p><p id="c234" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，史赛克帮助对抗膨胀。它不鼓励使用不必要的和复杂的逻辑，因为正是在这些不必要的复杂逻辑的缝隙中滋生了错误和缺陷。</p><h1 id="aeee" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="fa4e" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">如您所见，突变测试确保没有不确定的事实会被检查。</p><p id="b100" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以把史崔克比作一位国际象棋大师，他正在想尽一切办法来赢得一场比赛。当史赛克不确定的时候，它在告诉你，赢还不是一个保证。我们记录的事实越多，我们的比赛就越深入，Stryker就越有可能获胜。在任何情况下，Stryker都有助于发现失败的情况，即使表面上一切都很好。</p><p id="92b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">恰当地设计代码总是一个好主意。您已经看到了TDD在这方面的帮助。当涉及到保持代码高度模块化时，TDD特别有用。然而，TDD本身并不足以交付完全符合预期的精益代码。</p><p id="c3c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">开发人员可以向已经实现的代码库添加代码，而无需首先描述预期。这将整个代码库置于风险之中。变异测试在捕捉常规测试驱动开发(TDD)节奏中的漏洞时特别有用。您需要改变每一行实现的代码，以确保没有一行代码是没有特定原因的。</p></div></div>    
</body>
</html>