<html>
<head>
<title>How To Create a Web Server With JSX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JSX创建Web服务器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-web-server-with-jsx-1b3da3704502?source=collection_archive---------14-----------------------#2022-01-13">https://betterprogramming.pub/how-to-create-a-web-server-with-jsx-1b3da3704502?source=collection_archive---------14-----------------------#2022-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="990d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们把纯JSX和Express结合起来。你不会相信开发者的体验</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8f0c231fb724fc8836ddc12ac4334626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S2QKx8FThBz3cdVY66Sd_w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">封面由<a class="ae ky" href="https://medium.com/@candurmuss" rel="noopener"> <strong class="bd kz">创作，作者</strong> </a> |背景由<a class="ae ky" href="https://dribbble.com/peterlundblad" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kz">彼得·伦德布拉德</strong> </a> <strong class="bd kz"> </strong>上<a class="ae ky" href="https://dribbble.com/" rel="noopener ugc nofollow" target="_blank">下</a>下<a class="ae ky" href="https://medium.com/@candurmuss" rel="noopener"> <strong class="bd kz">作者</strong> </a></p></figure><p id="f021" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">2013年，前端开发人员被这个名为React的新框架迷住了。因为与jQuery不同，它的目标不是简化DOM操作，而是将DOM引入JavaScript。使用一种叫做<a class="ae ky" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank"> JSX </a> (JavaScript XML)的技术，你可以用JavaScript编写HTML或者你的自定义标签。这允许开发人员以声明的方式编写客户端JavaScript代码。</p><p id="15ab" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这个故事中，我要做的是，通过在React中使用相同的逻辑，我将以声明的方式编写Express代码。是的，我将在我的后端代码中使用JSX，并从头开始创建一个web服务器。你可以在这里阅读更多关于快递<a class="ae ky" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="b03b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于这个任务，我需要一个解析器，这样我就可以转换JavaScript的JSX。这是神圣的巴别塔。它非常强大，几乎可以转换任何风格的JavaScript。从打字稿到ES6和JSX。</p><h1 id="3c03" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">JSX和巴别塔是如何工作的？</h1><p id="5b15" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">React的逻辑非常简单，这也是它如此受欢迎的原因。在React中，要在DOM中创建一个节点，必须用适当的参数反复调用<code class="fe mt mu mv mw b">React.createElement</code>函数，这些参数是组件名、属性和子组件。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="9283" class="nb lx it mw b gy nc nd l ne nf">React.createElement("h1", { id: "can" },"This is a header!")</span></pre><p id="ab5f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然而，由于每次创建一个组件时都会调用这个函数，所以React把它取出来，自己编写了它。</p><p id="74be" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所以，如果你写下面的JSX代码，Babel会把它转换成上面的JavaScript版本。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="e7a5" class="nb lx it mw b gy nc nd l ne nf">&lt;h1 id="can"&gt;This is a header!&lt;/h1&gt;</span></pre><p id="25c3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然而，巴别塔的使用并不仅限于对JSX做出反应。此外，它允许你根据自己的需要创建自己版本的JSX，带有自定义的编译指示。Pragma是Babel在解析JSX时使用的函数名。</p><p id="eefc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">例如，在React中，编译指令是<code class="fe mt mu mv mw b">React.createElement</code>。通过一个特殊的注释，你可以改变这一点，从而改变JSX的行为。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="7d97" class="nb lx it mw b gy nc nd l ne nf">/** @jsx customPragma */   =&gt; This is how to configure the pragma.</span><span id="1abd" class="nb lx it mw b gy ng nd l ne nf">function customPragma(Component, props) { ... }</span><span id="eb64" class="nb lx it mw b gy ng nd l ne nf">&lt;Element attr="can" /&gt;</span></pre><p id="190b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">上面的JSX将使用pragma <code class="fe mt mu mv mw b">customPragma</code>转换成本地JavaScript。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="f9ab" class="nb lx it mw b gy nc nd l ne nf">customPragma(Element, { attr: "can" })</span></pre><h1 id="aed6" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">整合JSX来表达</h1><p id="112f" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">这部分是事情变得有趣的地方。我将创建自己的pragma来处理Express代码，并以类似HTML的声明方式创建我的路线。</p><p id="47c4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">首先，我需要创建必要的组件，</p><ul class=""><li id="ea72" class="nh ni it lc b ld le lg lh lj nj ln nk lr nl lv nm nn no np bi translated">我们的应用程序的根。</li><li id="471c" class="nh ni it lc b ld nq lg nr lj ns ln nt lr nu lv nm nn no np bi translated"><code class="fe mt mu mv mw b">Router</code>:快车app的路由器。</li><li id="0b8d" class="nh ni it lc b ld nq lg nr lj ns ln nt lr nu lv nm nn no np bi translated"><code class="fe mt mu mv mw b">Get</code>、<code class="fe mt mu mv mw b">Post</code>、<code class="fe mt mu mv mw b">Delete</code>、<code class="fe mt mu mv mw b">Put</code>:动作/路线方法。</li></ul><p id="65f0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这些组件将是作为第一个参数传递给pragma的唯一字符串，因为所有的逻辑都将封装在pragma中。</p><p id="165e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所以我将简单地使用数组析构将组件分配给字符串。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="15e7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">既然已经创建了基本组件，我就可以创建pragma了。Pragma是一个普通函数，有两个显式参数<code class="fe mt mu mv mw b">Component</code>和<code class="fe mt mu mv mw b">props</code>。</p><p id="ce8c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">此外，如果您从pragma返回某些内容，这将是其父代的子代。在pragma中，基于传递的组件，我会用props调用适当的函数。</p><p id="0f31" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们开始实现<code class="fe mt mu mv mw b">App</code>组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="bfff" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在pragma体中，我将<code class="fe mt mu mv mw b">arguments</code>对象转换为一个数组，并获取第三个元素，即children。</p><p id="9108" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然后我在if块的主体里启动了app。下面，用一个for循环，我用从孩子那里得到的道具调用了孩子的方法，并返回了<code class="fe mt mu mv mw b">app</code>。</p><p id="4ae5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">正如我所说的，从pragma返回的将是其父代的子代。这意味着，要访问for循环中的方法(<code class="fe mt mu mv mw b">method</code>、<code class="fe mt mu mv mw b">path</code>、<code class="fe mt mu mv mw b">handler</code>)，我必须从子体中返回它们。</p><p id="88b3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因此，让我们来处理子组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="e30b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，根据传递的组件，我们返回一个方法、一个处理程序和一个到父组件的路径。因此，应用程序组件现在功能齐全。</p><p id="8b2c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">路由器的实现融合了App和Action组件。我将创建一个路由器，然后，我必须用来自其子节点的数据调用它。</p><p id="577b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">除此之外，我必须返回它的<code class="fe mt mu mv mw b">method</code>、<code class="fe mt mu mv mw b">path</code>和<code class="fe mt mu mv mw b">handler</code>，这是路由器本身，因为它将是<code class="fe mt mu mv mw b">App</code>组件的子组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="9405" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">就是这样！我们为Express应用程序创建了pragma。</p><h1 id="4cad" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">用JSX创建Web服务器</h1><p id="9f03" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">现在我们已经有了JSX的设置，用普通的方式来说，<a class="ae ky" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> <em class="nx"> REST </em> </a>比创建一个Express app要容易得多。</p><p id="752e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以像<em class="nx"> React路由器</em>一样定义路由，而不是以命令的方式声明路由。</p><p id="11f7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">应用程序的根应该是<code class="fe mt mu mv mw b">App</code>组件，因为我们没有从这个应用程序返回任何东西；因此，它不能是另一个组件的子组件。</p><p id="f7c7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">同样，因为我们不处理Action组件(pragma)中的任何子组件，所以这些组件不能获得任何子组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="5a29" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">创建适当的pragma后，创建Express应用程序就像做馅饼一样容易。您所要做的就是声明路由，类似于React路由器。</p><p id="aede" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果你想看完整的源代码，这里是我的<a class="ae ky" href="https://github.com/XenoverseUp/jsx-server" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://mailchi.mp/a45f8fb96cc9/subscribe"><div class="gh gi ny"><img src="../Images/9617ff4f7d33119c4d4e3d20c90708a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TtX3EIdGpUqGCOW6LtO42Q.png"/></div></a><p class="ku kv gj gh gi kw kx bd b be z dk translated">加入我的时事通讯，获取你的订户专属故事。</p></figure><div class="nz oa gp gr ob oc"><a href="https://mailchi.mp/a45f8fb96cc9/subscribe" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">订阅</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">嗨，我是Can。我通常写编程、技术、设计和艺术。在这里看到你，我想你喜欢我的…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">mailchi.mp</p></div></div><div class="ol l"><div class="om l on oo op ol oq ks oc"/></div></div></a></div><h1 id="6686" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="0278" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">恭喜你！现在，你知道JSX如何在幕后工作，并使用其机制来简化一个更复杂的任务。JSX的使用案例不限于React或这个明确的示例。</p><p id="90b0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在很多方面，实现pragma和使用JSX比您想象的要简单得多。如果你想到任何可以使用JSX简化的任务，请在评论区告诉我。</p></div></div>    
</body>
</html>