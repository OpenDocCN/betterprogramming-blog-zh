# Python 的匹配速度太慢(如果你不理解的话)

> 原文：<https://betterprogramming.pub/pythons-match-case-is-too-slow-if-you-don-t-understand-it-8e8d0cf927d>

## 了解结构模式匹配是如何工作的，在哪里使用它，以及应该用什么来代替

![](img/a1afc9c7906463b7156c218f839b13cb.png)

米歇尔·玛特隆在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

Python 的 3.10 版本带来了一个新的语法特性:结构模式匹配。这个特性允许简单的声明性条件处理，它应该用更简洁的语法替换 if-else 语句序列。

现在，如果你来自像 C 这样的编译语言，你可能会看到 Python 的 match-case 语句像 switch-case，只是名字不同而已。然而，尽管 C 编译器通常会生成一个类似智能[的查找表](https://en.wikipedia.org/wiki/Lookup_table)的结构来有效地处理各种情况，Python 的结构模式匹配却是相当低效的，尤其是在你使用不当的情况下。我们来看看为什么。

## Python 匹配案例语句示例

我相信大家都熟悉使用一系列 if-else 语句来检查条件并相应地改变程序行为:

使用 Python 3.10 的结构模式匹配，您可以编写如下代码:

这两个代码片段实现了完全相同的事情:它们根据你传入的名字来做事情。那么，它们有什么不同呢？

## 匹配用例与 if-else 性能指标评测

我现在将比较两个 Python 函数的性能，一个是使用结构化模式匹配实现的，另一个是作为 if-else 语句序列实现的。

If-else 语句序列

结构模式匹配

下面是负责基准测试的代码:

基准的代码

让我们来看看结果:

```
Average time for match_case:  0.004244441888295114 seconds
Average time for if_else:     0.004139213310554624 seconds
```

可以清楚地看到，两个函数用了相同的时间来执行。如果我告诉你它们在引擎盖下工作是一样的呢？

## 大小写匹配是如何工作的？

现在我们来看看 Python 的结构模式匹配到底是什么，以及它与 if-else 语句相比如何。对于这个分析，我们将使用[编译器资源管理器](https://godbolt.org/)，这是一个功能强大的网站，允许您轻松查看通过编译给定代码生成的汇编指令。

首先这里是一个简化的 if-else 序列和相对反汇编的 Python 字节码。如果您不熟悉汇编语言，请不要担心，因为我会根据需要解释说明。

简单的 if-else 序列

为 if-else 序列注释生成的汇编代码

正如您可能已经猜到的，一系列 if-else 语句编译成一系列比较。现在，让我们来看看匹配案例版本:

简单的大小写匹配语句

match-case 语句的注释汇编代码

如您所见，Python 的 match-case 语句只是一系列比较，就像 if-else 方法一样。这就是为什么当我们对这两种方法进行基准测试时，它们表现相同。

但是，您应该注意到 Python 的结构模式匹配不执行简单的对象比较，而是模式比较。由于这个原因，在处理 match-case 语句的情况时，不会调用`__eq__()`方法(负责处理`==`操作)。为了证明这一点，让我们用一个自定义对象运行这个简单的代码片段:

匹配情况副作用

现在，如果有效地调用了`__eq__()`方法，我们应该为每个被测试的案例在控制台上打印一些东西，但是我们没有，正如您从控制台输出中看到的:

```
$ python3 match_side_effects.pyfive
```

然而，如果我们用 if-else 序列执行相同类型的比较，我们将得到下面的输出，这意味着每次比较都会调用`__eq__()`方法:

If-else 副作用

以及相应的控制台输出:

```
$ python3 match_side_effects.py 

5 == 1
5 == 2
5 == 3
5 == 4
5 == 5
five
```

从我们目前所看到的来看，Python 的结构化模式匹配实际上是一系列不同名称和更好语法下的 if-else 语句。虽然 match-case 在您的工具箱中肯定有它的位置(我们将在后面讨论)，但是如果您正在寻找运行时性能，您可能想要一些不同的东西:这里有一种更快的方法。

## 查找表和哈希表

简单地说，查找表和哈希表是用于存储预先计算的值的数据结构，以便在运行时不必计算它们。假设你有一个允许进入某个房间的名字唯一的人的名单。您可以通过 if-else 序列检查是否允许某人进入:

虽然这种方法只在少数情况下适用，但随着允许人员列表的增长，检查每个可能的姓名会变得非常低效。

下面是使用哈希表(也称为字典)的方法:

为了更好地理解发生了什么，让我们来看看编译器资源管理器生成的汇编指令:

如您所见，与我们之前看到的 if-else 序列和 match-case 语句相比，条件检查部分要简单得多。现在让我们看看与顺序检查相比，哈希表有多快。

对于基准测试，我们将使用前面的代码片段(`if_names()`和`match_names()`)与通过散列表实现的相同逻辑进行比较:

基准测试代码与之前相同，只是我们添加了对`dict_names()`的测试:

现在让我们来看看结果:

```
Average time for match_case:  0.004383811901789159 seconds
Average time for if_else:     0.00433244610321708 seconds
Average time for dict_lookup: 0.0008352182921953499 seconds
```

我们有一个明显的赢家:哈希表比一系列的比较要快得多，大约 5.3 倍的性能。

## 何时使用结构模式匹配

到目前为止，我只对结构模式匹配持否定态度，说它很慢，只不过是一系列 if-else 语句。然而，它仍然应该在您的工具箱中占有它的位置，因为它实际上是一个模式匹配语句。

如果您想要检查一个有点复杂的模式，那么您不会有很多机会使用散列表或查找表，因为它们固有的不灵活性使得它们非常快。If-else 语句可以完成这项工作，但是代码很快就会变得一团糟。这就是你应该使用结构模式匹配的地方。这里有一个来自 [PEP-636](https://peps.python.org/pep-0636/) 的例子:

当你面对几个简单的条件时，你应该使用一个简单的 if-else 语句序列。

最后，如果您有大量可能被视为简单条件的情况，或者您需要运行时性能，那么您最好使用哈希表或查找表:

还要注意，查找表和哈希表不仅限于存储简单的值，它们还可以包含完整的函数或复杂的对象。

现在，如果你用 Python 编程，你的主要目标可能不是运行时性能，为此你应该选择编译语言。然而，显著的速度提升——记住基准测试中 5.3 倍的性能提升——不会有坏处。此外，了解您的工具、它们的优点和缺点总是好的，并且，一般来说，要知道您正在做什么。

## 结论

总而言之，结构化模式匹配是一个强大的语法特性，它允许简单的声明性条件分支。虽然它对于模式匹配(其最初目的)来说很方便，但一些开发人员将其误认为是一种高性能的类似查找表的工具，类似于 C 编译器优化 switch-case 语句的方式。

关键的一点是，你应该知道你的工具，以决定在每一个特定的情况下哪一个是最合适的。

> 生活中没有放之四海而皆准的方法。归根结底，就是使用正确的工具完成正确的工作。

我希望你喜欢这篇文章。如果你有什么要补充的，请在评论中分享你的想法。感谢阅读！

如果你有兴趣了解更多关于查找表和哈希表的知识，我建议你看看下面这个故事:

[](/get-rid-of-excessive-if-else-statements-with-lookup-and-hash-tables-c7dbed808996) [## 用查找表和哈希表去掉过多的 If-Else 语句

### 在所有专业代码库中使用的代码性能实践。通过这些简单的例子学习使用它们。

better 编程. pub](/get-rid-of-excessive-if-else-statements-with-lookup-and-hash-tables-c7dbed808996)