<html>
<head>
<title>Prototypes in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的原型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/prototypes-in-javascript-5bba2990e04b?source=collection_archive---------0-----------------------#2017-05-04">https://betterprogramming.pub/prototypes-in-javascript-5bba2990e04b?source=collection_archive---------0-----------------------#2017-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6b437220cc2fb42c78301926d03d2bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3fDiy_86uvPcoAfMIbgNQ.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@dlanor_s?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">德拉诺尔S </a>在<a class="ae kf" href="https://unsplash.com/search/photos/javascript-code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="dd18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将讨论什么是JavaScript中的原型，它们如何帮助JavaScript实现面向对象编程的概念。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="a4b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在之前的<a class="ae kf" href="https://medium.com/@happymishra66/create-objects-in-javascript-10924cfa9fc7" rel="noopener">文章</a>中，我们已经学习了用JavaScript创建对象的各种方法。在JavaScript中创建对象的方法之一是使用<code class="fe ll lm ln lo b">constructor</code>函数。</p><p id="f3c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">用构造函数创建对象的问题:</strong></p><p id="f440" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑下面的<code class="fe ll lm ln lo b">constructor</code>函数:</p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="2270" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们使用<code class="fe ll lm ln lo b">Human</code>构造函数创建对象<code class="fe ll lm ln lo b">person1</code>和<code class="fe ll lm ln lo b">person2</code>:</p><pre class="lp lq lr ls gt lv lo lw lx aw ly bi"><span id="6c00" class="lz ma it lo b gy mb mc l md me">var person1 = new Human("Virat", "Kohli");<br/>var person2 = new Human("Sachin", "Tendulkar");</span></pre><p id="af2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在执行上述代码时，JavaScript引擎将创建构造函数的两个副本，分别用于<code class="fe ll lm ln lo b">person1</code>和<code class="fe ll lm ln lo b">person2</code> <em class="mf">。</em></p><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mg"><img src="../Images/483ac34c29c0605547bf1c18c1b8a5f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ftgUPoTz5nSmGPwTjf7VA.png"/></div></div></figure><p id="ea97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也就是说，使用构造函数创建的每个对象都有自己的属性和方法副本。让函数<code class="fe ll lm ln lo b">fullName</code>的两个实例做同样的事情是没有意义的。为每个对象存储单独的函数实例会导致内存浪费。随着我们的前进，我们会看到我们如何解决这个问题。</p><p id="5d24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">原型</strong></p><p id="92ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当用JavaScript创建一个函数时，JavaScript引擎会向该函数添加一个<code class="fe ll lm ln lo b">prototype</code>属性。这个<code class="fe ll lm ln lo b">prototype</code>属性是一个默认情况下具有<code class="fe ll lm ln lo b">constructor</code>属性的对象(称为原型对象)。<code class="fe ll lm ln lo b">constructor</code>属性指回<code class="fe ll lm ln lo b">prototype</code> <em class="mf"> </em>对象为属性的函数。我们可以使用<code class="fe ll lm ln lo b">functionName.prototype</code>来访问函数的原型属性。</p><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/23e0a0a751ad1ef117cbae9d80ed5390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*15Qo3ab3NPkLfXpj5AncaQ.png"/></div></div></figure><p id="0132" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上图所示，<code class="fe ll lm ln lo b">Human</code> <em class="mf"> </em>构造函数有一个<code class="fe ll lm ln lo b">prototype</code>属性指向<code class="fe ll lm ln lo b">prototype</code> <em class="mf"> </em>对象。<code class="fe ll lm ln lo b">prototype</code> <em class="mf"> </em>对象有一个<code class="fe ll lm ln lo b">constructor</code>属性，指向<code class="fe ll lm ln lo b">Human</code> <em class="mf"> </em>构造函数<em class="mf"> </em>。让我们看下面的例子:</p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="lt lu l"/></div></figure><pre class="lp lq lr ls gt lv lo lw lx aw ly bi"><span id="7c92" class="lz ma it lo b gy mb mc l md me">console.log(person1);</span></pre><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mi"><img src="../Images/c777e66ff4d0ea24247d46e462b3feda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X_oNHEuvVlO6-YJ2ydIAWA.png"/></div></div></figure><p id="ad95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要访问<code class="fe ll lm ln lo b">Human</code>构造函数的prototype属性，使用以下语法:</p><pre class="lp lq lr ls gt lv lo lw lx aw ly bi"><span id="ac1f" class="lz ma it lo b gy mb mc l md me">console.log(Human.prototype)</span></pre><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mj"><img src="../Images/1a7e0144396e8c52464220ab6cc58511.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kh4nYJdSFj76DM576F_brg.png"/></div></div></figure><p id="7fa9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上图可以看出，函数的<em class="mf">原型</em>属性是一个对象(<em class="mf">原型</em>对象)，有两个属性:</p><ol class=""><li id="a42b" class="mk ml it ki b kj kk kn ko kr mm kv mn kz mo ld mp mq mr ms bi translated"><code class="fe ll lm ln lo b">constructor</code>属性指向<em class="mf">人类</em>函数本身</li><li id="f1cb" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated">属性:我们将在解释JavaScript中的<em class="mf">继承</em>时讨论这个问题</li></ol><p id="d6bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">使用构造函数创建一个对象</strong></p><p id="c58c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当用JavaScript创建一个对象时，JavaScript引擎会给新创建的对象添加一个名为<em class="mf"> dunder proto </em>的<code class="fe ll lm ln lo b">__proto__ </code>属性。<em class="mf"> dunder proto </em>或<code class="fe ll lm ln lo b">__proto__</code> <em class="mf"> </em>指向构造函数的原型对象。</p><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/346882a4ac1b6524c1cddba17dc1aebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*425LxRkFEldC5CJWyhZRBg.png"/></div></div></figure><p id="9376" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上图所示，使用人类构造函数创建的<code class="fe ll lm ln lo b">person1</code> <em class="mf"> </em>对象有一个<em class="mf"> dunder proto </em>或<code class="fe ll lm ln lo b">__proto__</code> <em class="mf"> </em>属性，该属性指向构造函数的原型对象。</p><pre class="lp lq lr ls gt lv lo lw lx aw ly bi"><span id="2799" class="lz ma it lo b gy mb mc l md me">//Create an object person1 using the Human constructor function<br/>var person1 = new Human("Virat", "Kohli");</span></pre><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/1064c5ce0c085710328148211fef72aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j4eUj1Ck_M93pijoX8S3Bw.png"/></div></div></figure><p id="7c23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上图可以看出，无论是<code class="fe ll lm ln lo b">person1’s</code> <em class="mf"> dunder proto还是</em> <code class="fe ll lm ln lo b">__proto__</code>属性和<code class="fe ll lm ln lo b">Human.prototype</code> <em class="mf"> </em>属性都是相等的。让我们使用<code class="fe ll lm ln lo b">===</code>操作符检查它们是否指向同一个位置</p><pre class="lp lq lr ls gt lv lo lw lx aw ly bi"><span id="ff9e" class="lz ma it lo b gy mb mc l md me">Human.prototype === person1.__proto__ //true</span></pre><p id="492d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这说明<code class="fe ll lm ln lo b">person1’s</code> <em class="mf"> dunder proto </em>属性和<code class="fe ll lm ln lo b">Human.prototype</code>指向同一个对象。</p><p id="5ebd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们使用<code class="fe ll lm ln lo b">Human</code>构造函数创建另一个对象<code class="fe ll lm ln lo b">person2</code></p><pre class="lp lq lr ls gt lv lo lw lx aw ly bi"><span id="2d25" class="lz ma it lo b gy mb mc l md me">var person2 = new Human("Sachin", "Tendulkar");<br/>console.log(person2);</span></pre><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/3e917a2dda9ab014084be4275b78875a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AdEkzrGot4Qt3c3fqooW4A.png"/></div></div></figure><p id="c768" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的控制台输出显示，即使是<code class="fe ll lm ln lo b"><em class="mf">person2’s</em></code> <em class="mf"> dunder proto </em>属性也等于<code class="fe ll lm ln lo b">Human.prototype</code>属性，并且它们指向同一个对象。</p><pre class="lp lq lr ls gt lv lo lw lx aw ly bi"><span id="4216" class="lz ma it lo b gy mb mc l md me">Human.prototype === person2.__proto__ //true</span><span id="b34d" class="lz ma it lo b gy nb mc l md me">person1.__proto__ === person2.__proto__ //true</span></pre><p id="7bb3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述语句证明了<code class="fe ll lm ln lo b">person1’s</code>和<code class="fe ll lm ln lo b">person2’s</code> dunder proto属性指向<code class="fe ll lm ln lo b">Human</code>构造函数的原型对象。</p><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/a6aa6cbe0a072658e1b32d192f603032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5qHhF8HTzZD2xdx3p-RLIQ.png"/></div></div></figure><p id="4d0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">构造函数的原型对象由使用构造函数创建的所有对象共享。</strong></p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="b0d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">原型对象</strong></p><p id="eb0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于原型对象是一个对象，我们可以将属性和方法附加到原型对象上。因此，使用构造函数创建的所有对象都可以共享这些属性和方法。</p><p id="679d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以使用点符号或方括号符号将新属性添加到构造函数的prototype属性中，如下所示:</p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="lt lu l"/></div></figure><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/0e4d432682fbd96d2f1530e1971145c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OgeV095EQiZ5hSZiRNN8zw.png"/></div></div></figure><p id="47da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ll lm ln lo b">name</code><em class="mf"/><code class="fe ll lm ln lo b">age</code><em class="mf"/>属性已经添加到<code class="fe ll lm ln lo b">Human</code>原型中</p><p id="78ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">例子</strong></p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="7d42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们来分析一下做<code class="fe ll lm ln lo b">console.log(person.name)</code>的时候发生了什么。让我们检查person对象是否有一个<code class="fe ll lm ln lo b">name</code>属性</p><pre class="lp lq lr ls gt lv lo lw lx aw ly bi"><span id="87ec" class="lz ma it lo b gy mb mc l md me">console.log(person1);</span></pre><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/ad2b39f5282a5c2690d04feac1dbd073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TrdhtLL9toNPQcmSgbFE7A.png"/></div></div></figure><p id="ecfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到<code class="fe ll lm ln lo b">person1</code> <em class="mf"> </em>对象是空的，除了它的<em class="mf"> dunder proto </em>属性之外，它没有任何属性。那么<code class="fe ll lm ln lo b">console.log(person.name)</code> <strong class="ki iu"> <em class="mf"> </em> </strong>是如何输出<code class="fe ll lm ln lo b">Ashwin</code>的呢？</p><p id="17e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们试图访问一个对象的属性时，JavaScript引擎首先试图找到该对象的属性，如果该属性存在于该对象上，它就输出它的值。但是，如果该属性不存在于对象上，则它会尝试在原型对象或对象的<em class="mf"> dunder proto </em>上查找该属性。如果找到该属性，则返回值，否则JavaScript引擎尝试在对象的<em class="mf"> dunder proto </em>上找到该属性。这个链继续下去，直到<em class="mf"> dunder proto </em>属性为<code class="fe ll lm ln lo b">null</code>为止。在这些情况下，输出将是<code class="fe ll lm ln lo b">undefined</code>。</p><p id="788d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，当调用<code class="fe ll lm ln lo b">person1.name </code>时，JavaScript引擎检查属性是否存在于<code class="fe ll lm ln lo b">person1</code> <em class="mf"> </em>对象上。在这种情况下，<code class="fe ll lm ln lo b">name</code>属性不在<code class="fe ll lm ln lo b">person1’s</code>对象上。所以，现在JavaScript引擎检查<code class="fe ll lm ln lo b">name</code> <em class="mf"> </em>属性是否存在于<em class="mf"> dunder proto </em>属性或<code class="fe ll lm ln lo b">person1’s</code>对象的原型上。在这种情况下，<code class="fe ll lm ln lo b">name</code> <em class="mf"> </em>属性位于<em class="mf"> dunder proto </em>属性或<code class="fe ll lm ln lo b">person1’s</code>对象的原型上。因此，输出被返回<code class="fe ll lm ln lo b">Ashwin</code>。</p><p id="e490" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们使用<code class="fe ll lm ln lo b">Person</code> <em class="mf"> </em>构造函数创建另一个对象<code class="fe ll lm ln lo b">person2</code> <em class="mf"> </em>。</p><pre class="lp lq lr ls gt lv lo lw lx aw ly bi"><span id="91e8" class="lz ma it lo b gy mb mc l md me">var person2 = new Person();<br/>//Access the name property using the person2 object<br/>console.log(person2.name)// Output: Ashwin</span></pre><p id="c55a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们在<code class="fe ll lm ln lo b">person1</code> <em class="mf"> </em>对象上定义一个属性<code class="fe ll lm ln lo b">name</code></p><pre class="lp lq lr ls gt lv lo lw lx aw ly bi"><span id="39f9" class="lz ma it lo b gy mb mc l md me">person1.name = "Anil"<br/>console.log(person1.name)//Output: Anil<br/>console.log(person2.name)//Output: Ashwin</span></pre><p id="0630" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里<code class="fe ll lm ln lo b">person1.name</code>输出“Anil”。如前所述，JavaScript引擎首先尝试查找对象本身的属性。在这种情况下，<code class="fe ll lm ln lo b">name </code>属性出现在对象<code class="fe ll lm ln lo b">person1</code>本身上，因此JavaScript引擎输出<code class="fe ll lm ln lo b">person1</code> <em class="mf">的<code class="fe ll lm ln lo b">name</code>属性的值。</em></p><p id="2938" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe ll lm ln lo b">person2</code>的情况下，name属性不存在于对象上。因此，输出<code class="fe ll lm ln lo b">person2’s</code>原型对象的属性<code class="fe ll lm ln lo b">name</code> <em class="mf">。</em></p><h1 id="b970" class="nf ma it bd ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob bi translated"><strong class="ak">原型的问题</strong></h1><p id="bb0e" class="pw-post-body-paragraph kg kh it ki b kj oc kl km kn od kp kq kr oe kt ku kv of kx ky kz og lb lc ld im bi translated">因为原型对象在所有使用构造函数创建的对象之间共享，所以它的属性和方法也在所有对象之间共享。如果一个<code class="fe ll lm ln lo b">object A</code>修改了原型的一个具有原始值的属性，其他对象不会受到影响，因为<code class="fe ll lm ln lo b">object A</code>会在它的对象上创建一个属性，如下所示。</p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="lt lu l"/></div></figure><blockquote class="oh oi oj"><p id="bb1b" class="kg kh mf ki b kj kk kl km kn ko kp kq ok ks kt ku ol kw kx ky om la lb lc ld im bi translated"><em class="it">在这里(第1行和第2行)，两个</em> <code class="fe ll lm ln lo b"><em class="it">person1</em></code> <em class="it">和</em> <code class="fe ll lm ln lo b"><em class="it">person2</em></code> <em class="it">都没有</em> <code class="fe ll lm ln lo b"><em class="it">name</em></code> <em class="it">属性，因此它们访问原型</em> <code class="fe ll lm ln lo b"><em class="it">name</em></code> <em class="it">属性，因此两者的输出相同。</em></p></blockquote><p id="fe64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当<code class="fe ll lm ln lo b">person1</code> <em class="mf"> </em>想要为<code class="fe ll lm ln lo b">name</code>属性设置不同的值时，它会在其对象上创建一个<code class="fe ll lm ln lo b">name</code> <em class="mf"> </em>属性。</p><h2 id="9526" class="lz ma it bd ng on oo dn nk op oq dp no kr or os ns kv ot ou nw kz ov ow oa ox bi translated">考虑另一个例子，当原型对象包含引用类型的属性时，显示原型的问题</h2><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="b8bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，<code class="fe ll lm ln lo b">person1</code> <em class="mf"> </em>和<code class="fe ll lm ln lo b">person2</code>指向原型对象的同一个<code class="fe ll lm ln lo b">friends'</code>数组。<code class="fe ll lm ln lo b">person1</code> <em class="mf"> </em>通过在数组中添加另一个字符串来修改<code class="fe ll lm ln lo b">friends</code> <em class="mf"> </em>属性。</p><p id="25dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于<code class="fe ll lm ln lo b">friends'</code> <em class="mf"> </em>数组存在于<code class="fe ll lm ln lo b">Person.prototype</code>上，而不存在于<code class="fe ll lm ln lo b">person1</code>上，所以<code class="fe ll lm ln lo b">person1</code>对象对<code class="fe ll lm ln lo b">friend’s</code>属性所做的更改也反映在<code class="fe ll lm ln lo b">person2.friends</code>上(指向同一个数组)。</p><p id="eaa7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果目的是让所有实例共享一个数组，那么这个结果是可以的。但在这里，情况并非如此。</p><h2 id="2a32" class="lz ma it bd ng on oo dn nk op oq dp no kr or os ns kv ot ou nw kz ov ow oa ox bi translated">组合构造器/原型</h2><p id="2c57" class="pw-post-body-paragraph kg kh it ki b kj oc kl km kn od kp kq kr oe kt ku kv of kx ky kz og lb lc ld im bi translated">为了解决原型的问题和构造函数的问题，我们可以将构造函数和函数结合起来。</p><ol class=""><li id="e71f" class="mk ml it ki b kj kk kn ko kr mm kv mn kz mo ld mp mq mr ms bi translated">构造函数的问题:每个对象都有自己的函数实例</li><li id="b778" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated">原型的问题:使用一个对象修改属性也会反映另一个对象</li></ol><p id="5d99" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决这两个问题，我们可以在构造函数中定义所有特定于对象的属性，并在原型中定义所有共享属性和方法，如下所示:</p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="1cf6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们希望每个对象都有自己的<code class="fe ll lm ln lo b">name</code>、<code class="fe ll lm ln lo b">age</code>、<em class="mf">、</em>和<code class="fe ll lm ln lo b">friends</code>、<em class="mf">、</em>属性。因此，我们使用<code class="fe ll lm ln lo b">this</code>在构造函数中定义了这些属性。但是，由于<code class="fe ll lm ln lo b">sayName</code> <em class="mf"> </em>是在原型对象上定义的，所以它将在所有对象之间共享。</p><p id="0a1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，<code class="fe ll lm ln lo b">person2</code>的<code class="fe ll lm ln lo b">friend’s</code> <em class="mf"> </em>属性并没有随着<code class="fe ll lm ln lo b">person1</code> <em class="mf">的<code class="fe ll lm ln lo b">friends'</code> <em class="mf"> </em>属性的改变而改变。</em></p><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oy"><img src="../Images/57aac2e8367eda5d43f45546d5bb771f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hu8YzhAHRAt50Vt5eY5BqQ.png"/></div></div></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="7e10" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你喜欢我的文章，觉得它们很有用，请给我买杯咖啡。谢谢！</p><figure class="lp lq lr ls gt ju gh gi paragraph-image"><a href="https://www.buymeacoffee.com/rupeshmishra"><div class="gh gi oz"><img src="../Images/637b13257747e3091732494f68bbc5b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*Dsn_5SMeGigAdCWUtaYcow.png"/></div></a></figure><p id="7909" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你也可以在medium和Twitter上关注我<a class="ae kf" href="https://twitter.com/happyrupesh123" rel="noopener ugc nofollow" target="_blank">@<strong class="ki iu">happy rupesh 123</strong>T3】</a></p><p id="0136" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">其他文章:</strong></p><ol class=""><li id="fdc1" class="mk ml it ki b kj kk kn ko kr mm kv mn kz mo ld mp mq mr ms bi translated"><a class="ae kf" href="https://blog.bitsrc.io/javascript-internals-javascript-engine-run-time-environment-settimeout-web-api-eeed263b1617" rel="noopener ugc nofollow" target="_blank"> JavaScript内部:JavaScript引擎，运行时环境&amp; setTimeout Web API </a></li><li id="b088" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://medium.com/free-code-camp/a-beginners-guide-to-getting-started-with-react-c7f34354279e" rel="noopener">ReactJS初学者指南</a></li><li id="81f0" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://medium.com/@amasand23/the-journey-of-javascript-from-downloading-scripts-to-execution-part-i-967cc1112b4f" rel="noopener">JavaScript之旅:从下载脚本到执行</a></li><li id="c85a" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://medium.com/free-code-camp/benefits-of-progressive-web-applications-pwas-and-how-to-build-one-a763e6424717" rel="noopener">为什么渐进式网络应用很棒，以及如何构建一个这样的应用</a></li><li id="cee5" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://hackernoon.com/lets-get-this-this-once-and-for-all-f59d76438d34" rel="noopener ugc nofollow" target="_blank">让我们一劳永逸地得到这个‘这个’</a></li><li id="d259" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://hackernoon.com/service-workers-62a7b14aa63a" rel="noopener ugc nofollow" target="_blank">服务人员</a></li><li id="0268" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://hackernoon.com/building-pokemon-app-to-evaluate-the-power-of-berries-service-worker-176d7c4e70e3" rel="noopener ugc nofollow" target="_blank">服务人员实现</a></li><li id="473e" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://medium.com/@happymishra66/execution-context-in-javascript-319dd72e8e2c" rel="noopener">JavaScript中的执行上下文</a></li><li id="dc13" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://blog.bitsrc.io/understanding-web-share-apis-d987ea3648ad" rel="noopener ugc nofollow" target="_blank">了解Web共享API</a></li><li id="7d1e" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://medium.com/@happymishra66/virtual-dom-in-reactjs-43a3fdb1d130" rel="noopener">ReactJS中的虚拟DOM</a></li><li id="5bf9" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://medium.com/@happymishra66/prototypes-in-javascript-5bba2990e04b" rel="noopener">JavaScript的原型</a></li><li id="f965" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://medium.com/@happymishra66/this-in-javascript-8e8d4cd3930" rel="noopener">JavaScript中的‘this’</a></li><li id="df6b" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://medium.com/@happymishra66/object-create-in-javascript-fa8674df6ed2" rel="noopener">JavaScript中的object . create</a></li><li id="0539" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://medium.com/@happymishra66/inheritance-in-javascript-21d2b82ffa6f" rel="noopener">JavaScript中的继承</a></li><li id="4399" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://medium.com/@happymishra66/create-objects-in-javascript-10924cfa9fc7" rel="noopener">用JavaScript创建对象</a></li><li id="398c" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://medium.com/@happymishra66/objects-in-javascript-2980a15e9e71" rel="noopener">JavaScript中的对象</a></li><li id="7929" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://medium.com/@happymishra66/zip-in-python-48cb4f70d013" rel="noopener">Python中的Zip</a></li><li id="46d9" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://medium.com/@happymishra66/decorators-in-python-8fd0dce93c08" rel="noopener">Python中的装修工</a></li><li id="7e36" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://medium.com/@happymishra66/concatenating-two-lists-in-python-3cf9051da17f" rel="noopener">在Python中连接两个列表</a></li><li id="3059" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://medium.com/@happymishra66/lambda-map-and-filter-in-python-4935f248593" rel="noopener">Python中的lambda，map，和filter</a></li><li id="6cdb" class="mk ml it ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae kf" href="https://medium.com/@happymishra66/list-comprehension-in-python-8895a785550b" rel="noopener">用Python列出理解</a></li></ol></div></div>    
</body>
</html>