<html>
<head>
<title>How To Use bcrypt for Hashing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用bcrypt进行哈希运算</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-bcrypt-for-hashing-8c5b6212a511?source=collection_archive---------7-----------------------#2019-09-09">https://betterprogramming.pub/how-to-use-bcrypt-for-hashing-8c5b6212a511?source=collection_archive---------7-----------------------#2019-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c80c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建一个应用程序来显示<code class="fe ki kj kk kl b">bcrypt</code>的密码哈希用法</h2></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/6303f9be67880448bd0b20bd68ceebb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gUvC82bvPSaY_dJE5dHE1w.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae lc" href="https://unsplash.com/@coinviewapp?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> CoinView App </a>在<a class="ae lc" href="https://unsplash.com/search/photos/app?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="68c7" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe ki kj kk kl b"><a class="ae lc" href="https://www.npmjs.com/package/bcrypt" rel="noopener ugc nofollow" target="_blank">bcrypt</a></code>是一个流行的文本哈希库。一个有用的应用是散列密码。我们只需传入我们的文本，然后我们得到一个散列，你想加盐多少次都可以。</p><p id="a2b6" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">一旦你用<code class="fe ki kj kk kl b">bcrypt</code>杂凑了一些东西，你就无法恢复现有的文本。它有一个<code class="fe ki kj kk kl b">compare</code>，所以你可以比较你的原始文本和散列版本，看看它们是否相同。这对于在应用程序中安全地存储密码非常方便。</p><p id="7f2c" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了展示<code class="fe ki kj kk kl b">bcrypt</code>的密码哈希用法，我们将创建一个允许用户添加、保存和更新密码的应用程序。有了这个计划，我们可以开始了。</p><p id="17b8" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">首先，我们创建前端和后端应用程序文件夹。每人做一个。然后，我们开始写后端的app。</p><p id="859d" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">首先，我们安装一些包并生成我们的<a class="ae lc" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>框架代码。我们运行<code class="fe ki kj kk kl b">npx express-generator</code>来生成代码。然后，我们必须安装一些软件包。</p><p id="a7af" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们通过运行<code class="fe ki kj kk kl b">npm i @babel/register express-jwt sequelize bcrypt sequelize-cli dotenv jsonwebtoken body-parser cors</code>来做到这一点。<code class="fe ki kj kk kl b">@babel/register</code>允许我们使用最新的JavaScript特性。</p><p id="a4a3" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe ki kj kk kl b">express-jwt</code>生成JWT，并对照秘密进行验证。对我们的密码进行哈希和加盐处理。是我们做CRUD的ORM。</p><p id="765a" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe ki kj kk kl b">cors</code>通过允许跨域通信，允许我们的Angular app与我们的后端进行通信。<code class="fe ki kj kk kl b">dotenv</code>允许我们在<code class="fe ki kj kk kl b">.env</code>文件中存储环境变量。<code class="fe ki kj kk kl b">body-parser</code>是Express解析JSON请求所需要的。</p><p id="da5e" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后，我们进行数据库迁移。首先，我们运行<code class="fe ki kj kk kl b">npx sequelize-cli init</code>来为我们的数据库生成用于对象映射的框架代码。然后，我们运行:</p><pre class="kn ko kp kq gt lz kl ma mb aw mc bi"><span id="492b" class="md me it kl b gy mf mg l mh mi">npx sequelize-cli model:generate --name User --attributes username:string, password:string, email:string</span></pre><p id="7913" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们进行另一次迁移，并输入:</p><pre class="kn ko kp kq gt lz kl ma mb aw mc bi"><span id="26fd" class="md me it kl b gy mf mg l mh mi">'use strict';</span><span id="1c05" class="md me it kl b gy mj mg l mh mi">module.exports = {<br/>  up: (queryInterface, Sequelize) =&gt; {<br/>    return Promise.all([<br/>      queryInterface.addConstraint(<br/>        "Users",<br/>        ["email"],<br/>        {<br/>          type: "unique",<br/>          name: 'emailUnique'<br/>        }),</span><span id="ae75" class="md me it kl b gy mj mg l mh mi">queryInterface.addConstraint(<br/>        "Users",<br/>        ["userName"],<br/>        {<br/>          type: "unique",<br/>          name: 'userNameUnique'<br/>        }),<br/>  },</span><span id="fa96" class="md me it kl b gy mj mg l mh mi">down: (queryInterface, Sequelize) =&gt; {<br/>    return Promise.all([<br/>      queryInterface.removeConstraint(<br/>        "Users",<br/>        'emailUnique'<br/>      ),</span><span id="bbb9" class="md me it kl b gy mj mg l mh mi">queryInterface.removeConstraint(<br/>        "Users",<br/>        'userNameUnique'<br/>      ),<br/>    ])<br/>  }<br/>};</span></pre><p id="b4b2" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这确保我们不会有两个相同用户名或电子邮件的条目。一旦我们运行<code class="fe ki kj kk kl b">npx sequelize-cli db:migrate</code>，它将创建<code class="fe ki kj kk kl b">User</code>模型，并将创建用户表。</p><p id="2db1" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后，我们写一些代码。首先，我们将以下内容放入<code class="fe ki kj kk kl b">app.js</code>:</p><pre class="kn ko kp kq gt lz kl ma mb aw mc bi"><span id="9278" class="md me it kl b gy mf mg l mh mi">require("<a class="ae lc" href="http://twitter.com/babel/register" rel="noopener ugc nofollow" target="_blank">@babel/register</a>");<br/>require("babel-polyfill");<br/>require('dotenv').config();<br/>const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const cors = require('cors');<br/>const user = require('./controllers/userController');<br/>const app = express();</span><span id="a4b4" class="md me it kl b gy mj mg l mh mi">app.use(cors())<br/>app.use(bodyParser.urlencoded({ extended: true }));<br/>app.use(bodyParser.json());</span><span id="af8c" class="md me it kl b gy mj mg l mh mi">app.use((req, res, next) =&gt; {<br/>  res.locals.session = req.session;<br/>  next();<br/>});</span><span id="90ee" class="md me it kl b gy mj mg l mh mi">app.use('/user', user);</span><span id="813f" class="md me it kl b gy mj mg l mh mi">app.get('*', (req, res) =&gt; {<br/>  res.redirect('/home');<br/>});</span><span id="853f" class="md me it kl b gy mj mg l mh mi">app.listen((process.env.PORT || 8080), () =&gt; {<br/>  console.log('App running on port 8080!');<br/>});</span></pre><p id="7e13" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们需要下面的代码来使用JavaScript的最新特性:</p><pre class="kn ko kp kq gt lz kl ma mb aw mc bi"><span id="2f52" class="md me it kl b gy mf mg l mh mi">require("<a class="ae lc" href="http://twitter.com/babel/register" rel="noopener ugc nofollow" target="_blank">@babel/register</a>");<br/>require("babel-polyfill");</span></pre><p id="fb69" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们需要这段代码来读取我们在<code class="fe ki kj kk kl b">.env</code>文件中的配置:</p><pre class="kn ko kp kq gt lz kl ma mb aw mc bi"><span id="9150" class="md me it kl b gy mf mg l mh mi">require('dotenv').config();</span></pre><p id="eac8" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这是切入点。我们将很快在<code class="fe ki kj kk kl b">controllers</code>文件夹中创建<code class="fe ki kj kk kl b">userController</code>。</p><p id="e743" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe ki kj kk kl b">app.use(‘/user’, user);</code>将任何以<code class="fe ki kj kk kl b">user</code>开头的URL路由到<code class="fe ki kj kk kl b">userController</code>文件。</p><p id="d5e3" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">接下来，我们添加<code class="fe ki kj kk kl b">userController.js</code>文件:</p><pre class="kn ko kp kq gt lz kl ma mb aw mc bi"><span id="23ad" class="md me it kl b gy mf mg l mh mi">const express = require('express');<br/>const bcrypt = require('bcrypt');<br/>const router = express.Router();<br/>const models = require('../models');<br/>const jwt = require('jsonwebtoken');<br/>import { saltRounds } from '../exports';<br/>import { authCheck } from '../middlewares/authCheck';</span><span id="a93c" class="md me it kl b gy mj mg l mh mi">router.post('/login', async (req, res) =&gt; {<br/>    const secret = process.env.JWT_SECRET;<br/>    const userName = req.body.userName;<br/>    const password = req.body.password;<br/>    if (!userName || !password) {<br/>        return res.send({<br/>            error: 'User name and password required'<br/>        })<br/>    }<br/>    const users = await models.User.findAll({<br/>        where: {<br/>            userName<br/>        }<br/>    })</span><span id="c438" class="md me it kl b gy mj mg l mh mi">const user = users[0];<br/>    if (!user) {<br/>        res.status(401);<br/>        return res.send({<br/>            error: 'Invalid username or password'<br/>        });<br/>    }</span><span id="1ebd" class="md me it kl b gy mj mg l mh mi">try {<br/>        const compareRes = await bcrypt.compare(password, user.hashedPassword);<br/>        if (compareRes) {<br/>            const token = jwt.sign(<br/>                {<br/>                    data: {<br/>                        userName,<br/>                        userId: user.id<br/>                    }<br/>                },<br/>                secret,<br/>                { expiresIn: 60 * 60 }<br/>            );<br/>            return res.send({ token });<br/>        }<br/>        else {<br/>            res.status(401);<br/>            return res.send({<br/>                error: 'Invalid username or password'<br/>            });<br/>        }<br/>    }<br/>    catch (ex) {<br/>        logger.error(ex);<br/>        res.status(401);<br/>        return res.send({<br/>            error: 'Invalid username or password'<br/>        });<br/>    }</span><span id="730e" class="md me it kl b gy mj mg l mh mi">});</span><span id="d248" class="md me it kl b gy mj mg l mh mi">router.post('/signup', async (req, res) =&gt; {<br/>    const userName = req.body.userName;<br/>    const email = req.body.email;<br/>    const password = req.body.password;<br/>    try {<br/>        const hashedPassword = await bcrypt.hash(password, saltRounds)<br/>        await models.User.create({<br/>            userName,<br/>            email,<br/>            hashedPassword<br/>        })<br/>        return res.send({ message: 'User created' });<br/>    }<br/>    catch (ex) {<br/>        logger.error(ex);<br/>        res.status(400);<br/>        return res.send({ error: ex });<br/>    }<br/>});</span><span id="72ac" class="md me it kl b gy mj mg l mh mi">router.put('/updateUser', authCheck, async (req, res) =&gt; {<br/>    const userName = req.body.userName;<br/>    const email = req.body.email;<br/>    const token = req.headers.authorization;<br/>    const decoded = jwt.verify(token, process.env.JWT_SECRET);<br/>    const userId = decoded.data.userId;<br/>    try {<br/>        await models.User.update({<br/>            userName,<br/>            email<br/>        }, {<br/>                where: {<br/>                    id: userId<br/>                }<br/>            })<br/>        return res.send({ message: 'User created' });<br/>    }<br/>    catch (ex) {<br/>        logger.error(ex);<br/>        res.status(400);<br/>        return res.send({ error: ex });<br/>    }</span><span id="6574" class="md me it kl b gy mj mg l mh mi">});</span><span id="f2da" class="md me it kl b gy mj mg l mh mi">router.put('/updatePassword', authCheck, async (req, res) =&gt; {<br/>    const token = req.headers.authorization;<br/>    const password = req.body.password;<br/>    const decoded = jwt.verify(token, process.env.JWT_SECRET);<br/>    const userId = decoded.data.userId;<br/>    try {<br/>        const hashedPassword = await bcrypt.hash(password, saltRounds)<br/>        await models.User.update({<br/>            hashedPassword<br/>        }, {<br/>                where: {<br/>                    id: userId<br/>                }<br/>            })<br/>        return res.send({ message: 'User created' });<br/>    }<br/>    catch (ex) {<br/>        logger.error(ex);<br/>        res.status(400);<br/>        return res.send({ error: ex });<br/>    }</span><span id="a26a" class="md me it kl b gy mj mg l mh mi">});</span><span id="6401" class="md me it kl b gy mj mg l mh mi">module.exports = router;</span></pre><p id="1651" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe ki kj kk kl b">login</code>路由搜索<code class="fe ki kj kk kl b">User</code>条目，如果找到，它将使用<code class="fe ki kj kk kl b">bcrypt</code>的<code class="fe ki kj kk kl b">compare </code>函数检查散列密码。如果两者都成功，就会生成一个JWT。</p><p id="ca00" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe ki kj kk kl b">signup</code> route获取用户名和密码的JSON负载并保存它。<strong class="lf iu">请注意</strong>在保存之前，会对密码进行哈希和加盐处理。密码不应以纯文本形式存储。</p><p id="7a5f" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">第一个是纯文本密码，第二个是salt轮数。<code class="fe ki kj kk kl b">bcrypt</code>完全支持承诺，这使得代码比使用回调干净得多。</p><p id="567d" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe ki kj kk kl b">hashedPassword</code>无法恢复，只能使用比较，使用<code class="fe ki kj kk kl b">bcrypt.compare</code>功能。</p><p id="8447" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe ki kj kk kl b">updatePassword</code>路由是经过认证的路由。它检查令牌，如果有效，它将通过从解码的令牌中搜索带有用户id的<code class="fe ki kj kk kl b">User</code>来继续保存用户的密码。</p><p id="65ea" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">接下来我们将添加<code class="fe ki kj kk kl b">authCheck</code>中间件。</p><p id="7ed5" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">创建一个<code class="fe ki kj kk kl b">middlewares</code>文件夹，并在里面创建<code class="fe ki kj kk kl b">authCheck.js</code>。</p><pre class="kn ko kp kq gt lz kl ma mb aw mc bi"><span id="4bfc" class="md me it kl b gy mf mg l mh mi">const jwt = require('jsonwebtoken');<br/>const secret = process.env.JWT_SECRET;</span><span id="2b04" class="md me it kl b gy mj mg l mh mi">export const authCheck = (req, res, next) =&gt; {<br/>    if (req.headers.authorization) {<br/>        const token = req.headers.authorization;<br/>        jwt.verify(token, secret, (err, decoded) =&gt; {<br/>            if (err) {<br/>                res.send(401);<br/>            }<br/>            else {<br/>                next();<br/>            }<br/>        });<br/>    }<br/>    else {<br/>        res.send(401);<br/>    }<br/>}</span></pre><p id="9a6f" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">您应该使用相同的<code class="fe ki kj kk kl b">process.env.JWT_SECRET</code>来生成和验证令牌。否则，验证将失败。这个秘密不应该在任何地方共享，也不应该签入版本控制。</p><p id="17f7" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这允许我们在经过身份验证的路由中检查身份验证，而无需重复代码。通过导入并引用它，我们将<code class="fe ki kj kk kl b">if</code>放在每个认证路由的URL和主路由代码之间。</p><p id="4453" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们用这个内容做一个后端app文件夹根目录的<code class="fe ki kj kk kl b">.env</code>文件。这不应该签入版本控制:</p><pre class="kn ko kp kq gt lz kl ma mb aw mc bi"><span id="8ca2" class="md me it kl b gy mf mg l mh mi">DB_HOST='localhost'<br/>DB_NAME='login-app'<br/>DB_USERNAME='db-username'<br/>DB_PASSWORD='db-password'<br/>JWT_SECRET='secret'</span></pre><p id="eff3" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">后端应用程序现在已经完成。现在我们可以使用前端应用程序、移动应用程序或任何HTTP客户端进行登录。</p></div></div>    
</body>
</html>