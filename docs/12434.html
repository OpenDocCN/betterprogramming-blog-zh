<html>
<head>
<title>Golang Type Assertion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang型断言</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/golang-type-assertion-d5517d81c366?source=collection_archive---------6-----------------------#2022-06-06">https://betterprogramming.pub/golang-type-assertion-d5517d81c366?source=collection_archive---------6-----------------------#2022-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="de3d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用接口来确定行为</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/247856218f934d46ec96da0cbe326faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uKath8YtyN-1rFyR3Ttq6A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7b6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Golang提供了一种检查接口值是否属于特定类型的简单方法。这被称为类型断言，它通常用于确保一个接口值满足另一个接口，或者用于找到接口的具体类型。</p><p id="1439" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">断言值是否属于特定类型的语法如下所示:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="c734" class="lz ma it lv b gy mb mc l md me">var age interface{}<br/>age = 20<br/>str := age.(string)</span></pre><p id="6454" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">变量<code class="fe mf mg mh lv b">age</code>是类型<code class="fe mf mg mh lv b">interface{}</code>的，这意味着它可以保存任何类型。赋给变量的具体类型是<code class="fe mf mg mh lv b">int</code>，但是在这个例子中，类型断言是针对<code class="fe mf mg mh lv b">string</code>类型的。这里的问题是接口的具体类型不是字符串，所以运行这个程序会产生运行时错误。</p><p id="549f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要解决这个问题，请使用“逗号，ok”习语，它允许检查接口类型而不会产生错误。</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="752e" class="lz ma it lv b gy mb mc l md me">str, ok := age.(string)</span></pre><p id="ba37" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果具体类型不是字符串，那么<code class="fe mf mg mh lv b">ok</code>变量将是<code class="fe mf mg mh lv b">false</code>，而<code class="fe mf mg mh lv b">str</code>变量将具有用于作出断言的类型的零值。在这种情况下，字符串的零值是一个空字符串。</p><p id="e656" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果具体类型是字符串，<code class="fe mf mg mh lv b">ok</code>变量将是<code class="fe mf mg mh lv b">true</code>，<code class="fe mf mg mh lv b">str</code>变量将具有指定类型的值。</p><p id="870b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个更详细的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="1fe6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，<code class="fe mf mg mh lv b">str</code>变量的类型是<code class="fe mf mg mh lv b">StringSelecter</code>，它是一个有两个方法<code class="fe mf mg mh lv b">String()</code>和<code class="fe mf mg mh lv b">Validate()</code>的接口。</p><p id="c552" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有一种叫做<code class="fe mf mg mh lv b">MyString</code>的类型，它的具体类型是a <code class="fe mf mg mh lv b">string</code>。这个类型有两个值接收器方法，<code class="fe mf mg mh lv b">String()</code>和<code class="fe mf mg mh lv b">Validate()</code>。由此推断该类型满足<code class="fe mf mg mh lv b">StringSelecter</code>接口。</p><p id="f0ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第12行，打印出<code class="fe mf mg mh lv b">str</code>变量的类型。</p><p id="90b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当调用函数<code class="fe mf mg mh lv b">typeAssert</code>时，有趣的部分就来了。这个函数将一个<code class="fe mf mg mh lv b">interface{}</code>作为它唯一的参数。该函数需要确保作为参数传入的值的具体类型满足<code class="fe mf mg mh lv b">fmt.Stringer</code>接口，这样它就可以安全地调用该类型的<code class="fe mf mg mh lv b">String()</code>方法。</p><p id="9d4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，它使用类型断言，使用“逗号，ok”语法。如果类型断言成功，该函数将对值调用<code class="fe mf mg mh lv b">String()</code>方法。</p><p id="09ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行上面的程序确实会输出第19行的打印语句，因为参数满足<code class="fe mf mg mh lv b">fmt.Stringer</code>接口。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="6636" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果程序也试图调用<code class="fe mf mg mh lv b">typeAssert</code>函数中的<code class="fe mf mg mh lv b">Validate()</code>方法，特别是在第19行之后，该怎么办？将出现以下运行时错误:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="2f86" class="lz ma it lv b gy mb mc l md me">stringer.Validate undefined (type fmt.Stringer has no field or method Validate)</span></pre><p id="b59a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是为什么呢？为了理解这一点，我们先来看看前面两个例子的区别。</p><p id="efb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第一个例子中，类型断言是针对一个具体的类型<code class="fe mf mg mh lv b">string</code>。在第二个例子中，类型断言是针对一个<code class="fe mf mg mh lv b">interface</code>类型的。</p><p id="aea8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据用于进行断言的类型，结果值会有所不同。</p><p id="9d8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果断言使用具体类型，并且断言成功，那么结果将是被断言的变量的值。</p><p id="2610" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果断言使用接口类型，并且断言成功，那么结果将是被断言的接口类型。</p><p id="d8fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前面的示例在调用<code class="fe mf mg mh lv b">Validate()</code>方法时失败，因为断言返回了一个接口类型<code class="fe mf mg mh lv b">fmt.Stringer</code>，而该接口没有实现<code class="fe mf mg mh lv b">Validate()</code>方法。</p><p id="b82b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果<code class="fe mf mg mh lv b">typeAssert</code>函数使用<code class="fe mf mg mh lv b">StringSelecter</code>接口，那么结果类型将具有可访问的<code class="fe mf mg mh lv b">String()</code>和<code class="fe mf mg mh lv b">Validate()</code>方法。</p><p id="d656" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接口类型断言的这一特性主要用于扩展接口值拥有的方法集，以及确定接口值的行为。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="75e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们检查Go源代码中的<code class="fe mf mg mh lv b">copyBuffer</code>函数，它使用类型断言来确定调用哪个方法来进行复制。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="44f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe mf mg mh lv b">io</code>包中的<code class="fe mf mg mh lv b">Copy</code>时使用该功能。</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="d79f" class="lz ma it lv b gy mb mc l md me">bytes, err := io.Copy(ioutil.Discard, resp.Body)</span></pre><p id="817b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的<code class="fe mf mg mh lv b">copyBuffer</code>函数使用类型断言来确定哪个方法可以用来执行复制操作。当源满足<code class="fe mf mg mh lv b">WriteTo</code>接口时，调用<code class="fe mf mg mh lv b">WriteTo</code>方法进行复制。当源满足<code class="fe mf mg mh lv b">ReaderFrom</code>接口时，调用<code class="fe mf mg mh lv b">ReadFrom</code>方法进行复制。否则，它会运行不同的策略来进行复制。</p><p id="adb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是从类型接口<code class="fe mf mg mh lv b">Reader</code>建立行为，并假设如果这两个接口中的任何一个被<code class="fe mf mg mh lv b">src</code>、然后是<code class="fe mf mg mh lv b">WriteTo</code>和<code class="fe mf mg mh lv b">ReadFrom</code>满足，方法就适合进行复制。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="0570" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有另一种做类型断言的方法，使用Golang中的<code class="fe mf mg mh lv b">switch</code>这篇文章中的<a class="ae mr" href="https://levelup.gitconnected.com/switch-statement-in-golang-explained-9cd3a85aa19d" rel="noopener ugc nofollow" target="_blank"> Switch语句解释了</a>，描述了如何做！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="ac55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您是Golang的新手，以下文章可能会有所帮助:</p><div class="ms mt gp gr mu mv"><a rel="noopener  ugc nofollow" target="_blank" href="/go-api-design-with-protocol-buffers-and-grpc-991838e4852b"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">使用协议缓冲区和gRPC的Go API设计</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">基于社交媒体应用的分步指南</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">better编程. pub</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ks mv"/></div></div></a></div></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="ddd0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢阅读这篇文章，并学到一些新东西。欢迎分享您的宝贵意见。</p></div></div>    
</body>
</html>