<html>
<head>
<title>2-Way Flow Using Jetpack Compose and Datastore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Jetpack合成和数据存储的双向流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/2-way-flow-using-jetpack-compose-and-datastore-36305301347d?source=collection_archive---------7-----------------------#2022-04-05">https://betterprogramming.pub/2-way-flow-using-jetpack-compose-and-datastore-36305301347d?source=collection_archive---------7-----------------------#2022-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7bea" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在你的Android项目中使用MVVM</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/257095284c8bca63f473efba7ee108e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E1il0hcnVlrL3DGQ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://unsplash.com/@zhipeng_ya?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">智鹏雅</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="2b20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我刚刚开始使用Jetpack Compose APIs和datastore，我发现它使用起来非常方便。</p><p id="96b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们制作一个简单的演示应用程序，其中我们将有双向(2路)数据流。</p><p id="e049" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用MVVM作为我们这个小项目的架构，使用Jetpack compose库和Datastore库。协同程序在这里是自然的一部分。开始吧！</p><p id="99b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们的演示应用程序的外观:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/ab750b470abd2aee05ce900f33a9c840.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*rIO_FjBkbMwwFE9su8Ex5Q.gif"/></div></figure><p id="2123" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的主要架构是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/3de0aade68de0491227388f132ec8812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*qgionVGqHf71gtHYsCV4QQ.png"/></div></figure><p id="06ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到我们的双向流是什么样子的。在左侧，我们有一个视图，在用户交互时数据被更改，然后<code class="fe lu lv lw lx b">ViewModel</code>将更改的数据转发到数据存储，新数据被保存在那里。</p><p id="d195" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦数据被持久化到<code class="fe lu lv lw lx b">Datastore</code>中，它就发出一个新的数据流，这个数据流被转发回视图，UI可以被更新。这是一个非常简单的解决方案，不需要用<code class="fe lu lv lw lx b">ViewModels</code>订阅/观察/绑定视图的样板代码。</p><p id="702f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">UI机会随着流数据上的每次发射而被触发。这是由每一次用户界面的改变和随之而来的<code class="fe lu lv lw lx b">Datastore</code>机会触发的。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="1684" class="mc md iq lx b gy me mf l mg mh">//Composable UI element that handles onTextChangeAction<br/>@Composable<br/>fun DataStorePlaygroundActivityComponent(<br/>  stringData: String,<br/>  keyboardController: SoftwareKeyboardController?,<br/>  onTextChangeAction: (dataString: String) -&gt; Unit<br/>) {<br/>  val textAnswerState = remember <strong class="lx ir">{<br/>    </strong><em class="mi">mutableStateOf</em>("")<br/>  <strong class="lx ir">}<br/>  </strong>JetPackPlaygroundAppTheme <strong class="lx ir">{</strong><em class="mi"><br/>    Surface</em>(color = MaterialTheme.colors.background) <strong class="lx ir">{<br/>      </strong>Column(Modifier.<em class="mi">fillMaxSize</em>()) <strong class="lx ir">{<br/>        </strong>Title("DataStore Playground")<br/>        Spacer(modifier = Modifier.<em class="mi">height</em>(16.<em class="mi">dp</em>))<br/>        NormalText("Data: $stringData")<br/>        Spacer(modifier = Modifier.<em class="mi">height</em>(32.<em class="mi">dp</em>))<br/>        TextFieldSingleLine(<br/>          textAnswerState,<br/>          "enter settings text",<br/>          keyboardController,<br/>          onTextChangeAction<br/>        )<br/>      <strong class="lx ir">}<br/>    }<br/>  }<br/></strong>}</span><span id="de28" class="mc md iq lx b gy mj mf l mg mh">//Activity|Fragment view setting the composable<br/>DataStorePlaygroundActivityComponent(<br/>  stringData,<br/>  LocalSoftwareKeyboardController.current<br/>) <strong class="lx ir">{ </strong>dataString <strong class="lx ir">-&gt;<br/>  </strong>dataStoreViewModel?.saveDefaultText(dataString)<br/><strong class="lx ir">}</strong></span><span id="ee72" class="mc md iq lx b gy mj mf l mg mh">//ViewModel interaction with the datastore.</span><span id="30d8" class="mc md iq lx b gy mj mf l mg mh"><em class="mi">viewModelScope</em>.<em class="mi">launch </em><strong class="lx ir">{<br/>  </strong>localDataStore.saveDefaultText(defaultText)<br/><strong class="lx ir">}</strong></span></pre><p id="c279" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面显示的代码展示了UI元素是如何放置的。我们定义了一个可组合元素<code class="fe lu lv lw lx b">DataStorePlaygroundActivityComponent</code>,其中保存的文本显示在文本视图上，还有一个在用户交互完成时调用的动作(TextField组件中文本的改变)。之后，<code class="fe lu lv lw lx b">ViewModel</code>只是将新值转发给数据存储。</p><p id="4344" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦新值保存在数据存储中，新值就会立即发出并传播到视图。以下是一些代码片段:</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="a57c" class="mc md iq lx b gy me mf l mg mh">//Flow data from the datastore<br/>override val customTextData: Flow&lt;String&gt;<br/>  get() = App.applicationContext().<em class="mi">dataStore</em>.data<br/>    .<em class="mi">map </em><strong class="lx ir">{ </strong>preferences <strong class="lx ir">-&gt;<br/>      </strong>preferences[customTextKey] ?: CUSTOM_TEXT_SETTINGS_DEFAULT_VALUE<br/>    <strong class="lx ir">}</strong></span><span id="2ecb" class="mc md iq lx b gy mj mf l mg mh"><strong class="lx ir">//</strong>Listening the the flow within the ViewModel<strong class="lx ir"><br/></strong>init {<br/>  <em class="mi">viewModelScope</em>.<em class="mi">launch </em><strong class="lx ir">{<br/>    </strong>localDataStore.customTextData.collect <strong class="lx ir">{ </strong>data <strong class="lx ir">-&gt;<br/>      </strong>mutableFlowData.value = LatestDataUiState.Success(data)<br/>    <strong class="lx ir">}<br/>  }<br/></strong>}<br/>//Data class for UI state<br/>sealed class LatestDataUiState {<br/>  data class Success(val tempString: String): LatestDataUiState()<br/>  data class Error(val exception: Throwable): LatestDataUiState()<br/>}</span><span id="bdc3" class="mc md iq lx b gy mj mf l mg mh">//View logic<br/><em class="mi">lifecycleScope</em>.<em class="mi">launch </em><strong class="lx ir">{<br/>  </strong>repeatOnLifecycle(Lifecycle.State.<em class="mi">STARTED</em>) <strong class="lx ir">{<br/>    </strong>dataStoreViewModel?.uiStateFlow?.collect <strong class="lx ir">{ </strong>uiState <strong class="lx ir">-&gt;<br/>      </strong><em class="mi">// New value received</em><br/>      when (uiState) {<br/>        is LatestDataUiState.Success -&gt; showSuccessUI(uiState.tempString)<br/>        is LatestDataUiState.Error -&gt; showErrorUI(uiState.exception)<br/>      }<br/>    <strong class="lx ir">}<br/>  }<br/>}</strong></span></pre><p id="7695" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面截取的代码显示了视图如何与数据流连接，以及当接收到新的UI数据时，如何进行重组。</p><p id="d3f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！与其他模式相比，代码确实很小。完整的代码可以在<a class="ae kv" href="https://github.com/kliment-jonceski/JetPackPlaygroundApp" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="a971" class="mc md iq lx b gy me mf l mg mh"><strong class="lx ir">Want to Connect?</strong></span><span id="c7b7" class="mc md iq lx b gy mj mf l mg mh">If you are interested I’ve developed a simple puzzle app using Jetpack components. Check it out <a class="ae kv" href="https://play.google.com/store/apps/details?id=joncheski.kliment.com.brainteasers" rel="noopener ugc nofollow" target="_blank">here</a>.</span></pre></div></div>    
</body>
</html>