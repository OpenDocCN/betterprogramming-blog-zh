<html>
<head>
<title>Build a Full-Stack App With React, GraphQL, MongoDB, and Apollo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React、GraphQL、MongoDB和Apollo构建一个全栈应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/full-stack-react-graphql-mongodb-apollo-building-an-app-cb1eb647c73a?source=collection_archive---------4-----------------------#2020-03-30">https://betterprogramming.pub/full-stack-react-graphql-mongodb-apollo-building-an-app-cb1eb647c73a?source=collection_archive---------4-----------------------#2020-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7990" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">自上而下创建全新应用的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5aff2012de38d7551ee0363a431cdc6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T-uNKo7M82NWrEcgx8qy9A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由Nikhil Kumar拍摄。</p></figure><p id="98c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我决定利用我的隔离时间写一篇关于用React、GraphQL、Apollo和MongoDB构建一个小而中肯的应用程序的文章。当我学习这个堆栈时，我必须从多个来源阅读，所以我将尝试将所有信息放在一个地方。</p><p id="0350" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们开始之前，我建议检查一下GraphQL和Apollo的用途，因为我们将直接使用它们。</p><p id="1dce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">但是为什么GraphQL会超过REST呢？好了，我们来谈谈GraphQL，因为这是我们故事中的主角。<br/>所以，脸书在2012年创建的GraphQL，在2015年开源。它是你的API的一种查询语言。与其他的不同，GraphQL使用单个端点负责接受查询。GraphQL有一些优点和缺点。</strong></p><p id="f9e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个主要的好处是，客户端能够从服务器上查询他们想要的确切数据，而不像REST那样，我们获得全部数据并对其进行提炼，只显示我们需要的数据。我们将在下面的例子中看到，我们只查询我们需要的东西。即只获取名而不获取姓。</p><p id="b43d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个好处是能够在一个请求中查询其他来源。例如，我们可以查询<em class="lu"> contacts </em>模式来获取联系人的姓名&amp; phone，以及<em class="lu"> country </em>模式来获取该联系人的国家名称。你可能会相信，这很神奇。</p><p id="d5fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">等等！GraphQL还有哪些更好的地方？<br/> </strong> GraphQL为它的所有查询返回200个HTTP状态代码，不管那个查询是否成功。尽管如果查询不成功，JSON将会有错误键和错误消息。有时执行错误处理变得很困难。<br/>另一个缺点是GraphQL的本地缓存不同于REST，在REST中，ewe有多个端点，它们可以利用本地HTTP缓存来避免预取资源。但是我们有阿波罗储藏室来帮忙。<br/>您一定会喜欢GraphQL的性能和优势，让我们一起探索吧。</p><p id="7cda" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在这个应用程序中建立两个部分:服务器和客户端。</p><p id="82e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在服务器端，我们将构建一个具有三个查询和一个GraphQL变体的GraphQL API，它将与我们托管的MongoDB数据库进行交互以实现持久性。在客户端，我们将利用React和Apollo与我们的GraphQL API和GraphQL查询进行交互。</p><p id="c2d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">开始开发吧。</p><p id="83ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我已经创建了一个文件夹(<code class="fe lv lw lx ly b">full-stack-react-apollo-graphql-mongodb</code>)，并在其中创建了另外两个文件夹(<code class="fe lv lw lx ly b">client</code>和<code class="fe lv lw lx ly b">server</code>)。<em class="lu"> </em>让我们先构建我们的后端。</p><p id="426b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">进入<code class="fe lv lw lx ly b">server</code>的目录并运行:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8f92" class="md me it ly b gy mf mg l mh mi">npm init -y</span></pre><p id="30bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着这个命令，你的<code class="fe lv lw lx ly b">package.json</code>准备好了。再创建一个名为<code class="fe lv lw lx ly b">app.js</code> <em class="lu">的文件。</em></p><p id="81eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设您已经在您的系统中设置了Node.js和MongoDB(我们使用托管的MongoDB mlab，但是您可以使用您的本地MongoDB ),让我们下载一些基本的包:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="07f9" class="md me it ly b gy mf mg l mh mi">npm install express express-graphql mongoose</span></pre><p id="a7c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不要忘记在您的开发依赖项中安装nodemon，并在您的<code class="fe lv lw lx ly b">package.json</code>中添加一个启动脚本:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="67ab" class="md me it ly b gy mf mg l mh mi">“scripts”: { <br/> “test”: “echo \”Error: no test specified\” &amp;&amp; exit 1",<br/> “start”: “nodemon app.js”<br/>}</span></pre><p id="7af6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们来设置您的MongoDB。我利用了mlab。以下是我的配置快照:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/c7b61e1bee65592142a0a2d8ea3c6fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U0YtrplwXCE8mxmq-j6WUw.png"/></div></div></figure><p id="9d56" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">打开<code class="fe lv lw lx ly b">app.js</code>(我用的是VS代码)，写下面的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/6352a458545106c0cb7162705a43dca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*zIkis0RkT0KNP92BIZRxUw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">必需的进口。</p></figure><p id="2160" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于连接MongoDB的连接字符串，我使用的是mlab。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/5831df577c7b2f6a150b7409ba9262c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*5V0GjuV5ol3BYJZfoQ17hA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用你在mlab的信用代替xxx。</p></figure><p id="e4c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创造<code class="fe lv lw lx ly b">Model</code>。<code class="fe lv lw lx ly b">app.js</code>中的这个模型应该符合你的MongoDB结构。在我的例子中，我创建了一个简单的<code class="fe lv lw lx ly b">PersonModel</code>，它有两个字段:<code class="fe lv lw lx ly b">firstName</code>和<code class="fe lv lw lx ly b">lastName</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/e28e97dee13f01e3641a865682254fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*hg2xe40do903RtbCemSN7Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">人物模型</p></figure><p id="5b47" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于这些模型对象字段，我们必须以GraphQL的方式定义它们的属性类型。还记得我们之前做的导入(<code class="fe lv lw lx ly b">GraphQLObjectType</code>)吗？我们正在利用这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/9813e12203013f5e774c8cd73b7416a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*Hv_ygW4gpNhex6-AyR-qHA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">人员类型</p></figure><p id="8032" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，没有什么是关键的——只有一些映射。现在我们将创建GraphQL查询和变异，它们只不过是GraphQL模式。</p><p id="2279" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们解码一个GraphQL查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/1d23051fba9def615327acf74d814668.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*i_IRGjHpFW3pkfv_PwebMA.png"/></div></figure><p id="1c4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，我还创建了两个查询。<code class="fe lv lw lx ly b">people</code>查询将从MongoDB表中返回所有人，另一个将按id返回人，第三个将按名字返回人:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/3b927254803961d3421933d034b89355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*eC0DgJ-gKQ2zyoBc7xOfGQ.png"/></div></figure><p id="921b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在是时候创建一个变异来在数据库中添加一个新记录了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/7783e135edf7127f1a0135c60ba199cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*UuUyACtwfhXGICooHbw9Nw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">突变。</p></figure><p id="032b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，端口细节(我们的应用程序将在那里运行):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/21fc02dc1b55c41c71af12d58c6c46ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*qcMdStj-sC8DHXMIxso3_Q.png"/></div></figure><p id="e685" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">转到终端并运行:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="543c" class="md me it ly b gy mf mg l mh mi">npm start</span></pre><p id="4f6c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">打开Chrome，输入“<a class="ae ms" href="http://localhost:3001/person" rel="noopener ugc nofollow" target="_blank">http://localhost:3001/person</a>”</p><p id="b45d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您将会看到GraphQL接口可以处理您的查询和变化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/b64d1e9e767684e0144f65ea0a0fbd71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BQ45lJe5NfyWdhjg9jiOew.png"/></div></div></figure><p id="c693" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">左侧面板显示查询，右侧面板显示输出。使用播放按钮播放您写的内容。</p><p id="a23b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">酷，让我们试试我们写的另一个查询:<code class="fe lv lw lx ly b">findById</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/7fddc4a713f64b6fe6d6539f4ff0522e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*reaW5xsHErgNRbsUOvEMEA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">findByID。</p></figure><p id="d2e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以自己试试第三个。</p><p id="17e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们来测试我们的突变:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/fc774a08ce80330c6d24668005cd5864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wQXD37ZQVaXdhmpEP_-d9Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">变化</p></figure><p id="3875" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意查询变量。</p><p id="ad2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">恭喜你！我们已经建立了我们的后端GraphQL API。</p><p id="65eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于客户端开发，创建新的React应用程序:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="417d" class="md me it ly b gy mf mg l mh mi">npx create-react-app client</span></pre><p id="a2f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是时候安装所需的软件包了:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="c947" class="md me it ly b gy mf mg l mh mi">npm install apollo-boost react-apollo</span></pre><p id="7549" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">打开您的客户端React项目<em class="lu"> </em>并在您的<code class="fe lv lw lx ly b">index.js</code>文件中编写以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/758d503caf9953200a3e59147ec84a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rC7nogU-uMymPKbbRFiaZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">index.js。</p></figure><p id="cf00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您已经熟悉React中的上下文API，您就会理解这个<code class="fe lv lw lx ly b">ApolloProvider</code>在做什么——就像Redux store一样包装您的组件。所以所有的子组件现在都可以访问数据了。在我的例子中，子组件很奇怪，但是你可以使用你的<code class="fe lv lw lx ly b">App.js/ts</code>组件。</p><p id="3052" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以基本上，我没有把我的父组件放在中间(<code class="fe lv lw lx ly b">App.js</code>)。我是直接掉子组件，<code class="fe lv lw lx ly b">GettingGraphQLData</code>。在上面的代码中，你可以看到我已经创建了一个对象<code class="fe lv lw lx ly b">ApolloClient</code>，它只有一个Uri。后来，<code class="fe lv lw lx ly b">ApolloProvider</code>正在包装app组件。</p><p id="9ff1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看组件里面有什么。你可能不相信这有多简单:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/753952436c25403c117fe771512478a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*eQ_sRE2mN8ymClw2iaCIYg.png"/></div></figure><p id="2ad1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是这个应用程序的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/fea84e600a135fc5482fbfa844b35627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*H8J7dXct2J6B8mDFf_oXBQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用程序的输出。</p></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="3431" class="nf me it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">结论</h1><p id="188e" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">概括来说，我们有:</p><ul class=""><li id="1c9c" class="ob oc it la b lb lc le lf lh od ll oe lp of lt og oh oi oj bi translated">开发了一个能够查询数据库并在数据库中添加记录的GraphQL API。</li><li id="0e5e" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated">利用了express-graphql软件包。</li><li id="932a" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated">利用Apollo客户端连接我们的前端应用程序，与我们的后端API进行交互。</li><li id="2a34" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated">还有更多。</li></ul><p id="6136" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您应该:</p><ul class=""><li id="750a" class="ob oc it la b lb lc le lf lh od ll oe lp of lt og oh oi oj bi translated">使用我们创建的其他查询在UI上显示数据。</li><li id="e3db" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated">尝试建立一个页面，利用突变来添加新记录。</li></ul><p id="bbf9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是<a class="ae ms" href="https://github.com/nikhilknoldus/fullstack-react-apollo-graphql-mongodb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>回购供参考。</p><p id="9639" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果这是你的第一次，我会说3-4天后再看一遍文章，然后练习。</p><p id="5792" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">呆在里面，注意安全。</p></div></div>    
</body>
</html>