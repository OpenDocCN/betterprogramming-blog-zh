<html>
<head>
<title>The Clean Architecture — Beginner’s Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">干净的建筑——初学者指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-clean-architecture-beginners-guide-e4b7058c1165?source=collection_archive---------0-----------------------#2022-01-04">https://betterprogramming.pub/the-clean-architecture-beginners-guide-e4b7058c1165?source=collection_archive---------0-----------------------#2022-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1731" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如用视觉图示所解释的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c63a9f155a5fefbd527116546b98a26c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X2vJLKG_C3AxLLJWy4YP0w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://undraw.co/" rel="noopener ugc nofollow" target="_blank"> Undraw </a></p></figure><p id="1b24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">干净架构</a>是罗伯特·c·马丁(鲍勃大叔)提出的系统架构指南，来源于许多架构指南，如六角形架构、洋葱架构等...这些年来。</p><p id="feb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是软件工程师在构建可伸缩、可测试和可维护的软件时遵循的准则之一。</p><h2 id="8f13" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">为什么我们需要架构师？</h2><p id="8c31" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">“软件架构的目标是最小化构建和维护所需系统所需的人力资源。”<em class="mq"> ―罗伯特·c·马丁，清洁建筑</em></p><h1 id="7e00" class="mr lt iq bd lu ms mt mu lx mv mw mx ma jw my jx md jz mz ka mg kc na kd mj nb bi translated">适当架构的优势</h1><ul class=""><li id="13c9" class="nc nd iq ky b kz ml lc mm lf ne lj nf ln ng lr nh ni nj nk bi translated">可试验的</li><li id="f2df" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">可维持的</li><li id="2718" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">易变的</li><li id="4e05" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">易于开发</li><li id="67da" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">易于部署</li><li id="1cfa" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">自主的</li></ul><h1 id="0dcf" class="mr lt iq bd lu ms mt mu lx mv mw mx ma jw my jx md jz mz ka mg kc na kd mj nb bi translated">干净的建筑</h1><p id="066a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这是罗伯特·马丁创作的干净建筑插图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/133b5e597e3f2e8ef760c1942375ecb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0u-ekVHFu7Om7Z-VTwFHvg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">罗伯特·c·马丁拍摄的图片</p></figure><p id="bd9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到图中有四层。蓝色层、绿色层、红色层和黄色层。</p><p id="6667" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个圆圈代表软件的不同区域。最外层是软件的最低级别，随着我们越深入，级别会越来越高。总的来说，当我们越深入，这个层就越不容易改变。</p><h1 id="4fff" class="mr lt iq bd lu ms mt mu lx mv mw mx ma jw my jx md jz mz ka mg kc na kd mj nb bi translated"><strong class="ak">依赖规则</strong></h1><p id="3fe3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">依赖规则声明源代码依赖只能指向内部。</p><p id="19ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着内圈的任何东西都不可能了解外圈的任何东西。也就是说，内圈不应该依赖外圈的任何东西。图中的黑色箭头显示了依赖规则。</p><p id="b27b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是使这个架构工作的重要规则。还有，这个很难理解。所以我会先打破这个规则，让你明白它会带来什么问题，然后解释，让我们看看如何跟上这个规则。所以请原谅我。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="99c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，这种循环表示可能会让许多人感到困惑。所以我们试着垂直表示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/c2ad810ffc12256d8c717f9228638c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:398/format:webp/1*COOl75XSL1xbo6Tv60D6qA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="8939" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里表示的颜色与干净的架构图中表示的颜色相同。</p><p id="ce0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住，箭头应该读作“依靠”。即<code class="fe nz oa ob oc b">Frameworks and Drivers</code>应该依赖<code class="fe nz oa ob oc b">Interface Adapters</code>，T1依赖<code class="fe nz oa ob oc b">Application Business Rules</code>，T1依赖<code class="fe nz oa ob oc b">Enterprise Business Rules</code>。</p><p id="d0ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">底层的任何东西都不应该依赖于顶层。</p><h2 id="4bec" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">框架和驱动因素</h2><p id="d8a8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">位于这一层的软件领域有</p><ul class=""><li id="a697" class="nc nd iq ky b kz la lc ld lf od lj oe ln of lr nh ni nj nk bi translated">用户界面</li><li id="7a46" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">数据库ˌ资料库</li><li id="51cd" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">外部接口(例如:本地平台API)</li><li id="409a" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">Web(例如:网络请求)</li><li id="fe56" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">设备(例如:打印机和扫描仪)</li></ul><h2 id="b265" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">接口适配器</h2><p id="0c4f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这一层适用</p><ul class=""><li id="9ace" class="nc nd iq ky b kz la lc ld lf od lj oe ln of lr nh ni nj nk bi translated"><code class="fe nz oa ob oc b">Presenters</code> (UI逻辑，状态)</li><li id="7f26" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><code class="fe nz oa ob oc b">Controllers</code>(保存由Web、设备或外部接口实现的应用程序所需方法的接口)</li><li id="acf9" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><code class="fe nz oa ob oc b">Gateways</code>(保存应用程序执行的每个CRUD操作的接口，由DB实现)</li></ul><h2 id="b6f7" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">应用程序业务规则</h2><p id="8284" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">不是核心业务规则，但对该特定应用程序至关重要的规则属于这一类。这一层持有<code class="fe nz oa ob oc b">Use Cases</code> <strong class="ky ir">。</strong>顾名思义，它应该提供应用的每一个用例。即它拥有应用程序提供的每一个功能。</p><p id="b4ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，这是决定特定用例调用哪个<code class="fe nz oa ob oc b">Controller</code> / <code class="fe nz oa ob oc b">Gateway</code>的层。有时我们需要来自不同模块的控制器。</p><p id="1449" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是不同模块协调的地方。例如，我们想为一个月内购买了x笔金额的用户提供折扣。</p><p id="d4aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们需要从<code class="fe nz oa ob oc b">purchase module</code>中获取用户这个月的消费金额，然后根据结果，我们需要在<code class="fe nz oa ob oc b">checkout module</code> <strong class="ky ir">中为用户应用折扣。</strong>此处<code class="fe nz oa ob oc b">applyDiscountUseCase</code> <strong class="ky ir"> </strong>调用采购模块的控制器获取数据，然后在结账模块中应用折扣。</p><h2 id="f7d8" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">企业业务规则</h2><p id="4e7e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这是保存核心业务规则或特定于领域的业务规则的层。此外，这一层是最不容易改变的。</p><p id="c72d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任何外层的变化都不会影响这一层。由于<code class="fe nz oa ob oc b">Business Rules</code>不会经常变化，所以这一层的变化非常罕见。这一层保存实体。</p><p id="b818" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实体可以是业务规则所必需的核心数据结构，也可以是包含业务逻辑的方法的对象。</p><p id="714b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如:银行应用中的计算<code class="fe nz oa ob oc b">Interest</code>模块，就是应该在这一层里面的核心业务逻辑。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="8286" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一个简单的例子来更好地理解这一点。</p><p id="29f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该示例演示了一个只有一个网络请求的简单应用程序。</p><p id="e0c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们如何构建一个应用程序，使用翻译API翻译用户给出的句子？让我们试着设计。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/fd5101e9b207f11400fcb09522edbeb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*FeKQ3LXeEcHp7pTsgrLrTA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="7bf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每一层都做一件特定的事情。看起来不错吧？让我们检查一下上面这个架构的依赖流，看看是否有什么地方出错了。</p><p id="4f8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还记得依赖规则吗？“依赖关系规则规定源代码依赖关系只能指向内部”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/6b04adfe3d8545502c01b94ae7ed7502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oIe_ao4ZNEdRJb9Y8KAk8w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="db6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">UI →演示者(✅不违反)</p><p id="cb47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">演示者→翻译用例(✅不违反)</p><p id="54c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">翻译用例→翻译控制器(违反❌)</p><p id="6872" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">转换控制器→网络(违反❌)</p><p id="e86b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是好像是对的吧？</p><p id="e3f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nz oa ob oc b">UI</code>向<code class="fe nz oa ob oc b">Presenter</code>请求数据，T1向<code class="fe nz oa ob oc b">Use Case</code>请求数据，而<code class="fe nz oa ob oc b">Controller</code>向<code class="fe nz oa ob oc b">Web</code>请求数据。</p><blockquote class="oi oj ok"><p id="75bc" class="kw kx mq ky b kz la jr lb lc ld ju le ol lg lh li om lk ll lm on lo lp lq lr ij bi translated">毕竟，在没有<code class="fe nz oa ob oc b"><em class="iq">Controller</em></code> <strong class="ky ir"> <em class="iq"> </em> </strong>依赖的情况下，我们怎么能指望<code class="fe nz oa ob oc b"><em class="iq">web</em></code>将一些数据扔给<strong class="ky ir"><em class="iq"/></strong><code class="fe nz oa ob oc b"><em class="iq">Controller</em></code><strong class="ky ir"><em class="iq"/></strong>？同样，我们怎么能指望<code class="fe nz oa ob oc b"><em class="iq">Use Case</em></code>从<code class="fe nz oa ob oc b"><em class="iq">Controller</em></code> <strong class="ky ir"> <em class="iq"> </em> </strong>中获得适当的数据而不依赖它呢？</p></blockquote><p id="7cf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是依赖规则严格地说依赖只能指向内部。总而言之，这是使架构工作的规则。</p><p id="9516" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了通过这条规则，我们需要将箭头反向。这可能吗？多态性<strong class="ky ir">来了。当我们在这里包含一些多态性时，神奇的事情发生了。</strong></p><p id="fe33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单地通过在这两层之间有一个<code class="fe nz oa ob oc b">Interface</code> <strong class="ky ir"> </strong>，我们可以颠倒依赖关系。这就是所谓的依赖性反转原则。</p><p id="ffb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在违反依赖规则的情况下实现依赖倒置原则。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/847b7957bde91129d1a205036c990a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dmvcsbA7-pYc8KTnBWc_7w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/c8fb0f0cae6ee9a0e78fbd3e229a400d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91OVFhAB6qsG8eibQN0xhQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="4776" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，流程变为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/610b55fc532b5415b568a4a808572455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*S-r2PJO1PnAsbtONpUwNsw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="ae04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们检查一下依赖流，看看是否有什么违反了它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/74e0f45c63ab7c40e92f5aa0070a6ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3So5c50RNeTEfcqQeIcnOQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="2d47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以看到，没有内层依赖于任何外层。相反，外层依赖于内层。</p><blockquote class="oi oj ok"><p id="0250" class="kw kx mq ky b kz la jr lb lc ld ju le ol lg lh li om lk ll lm on lo lp lq lr ij bi translated"><em class="iq">那么为什么外层要依赖于内层而不是相反呢？</em></p></blockquote><p id="66c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象你在一家酒店里。我们希望酒店提供我们想要的服务，而不是他们提供的服务，对吗？。这里发生了同样的事情，我们希望数据库提供应用程序需要的数据，而不是它拥有的数据。</p><p id="fba2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用程序订购它想要的数据，它不关心数据库或API如何准备数据。这样，应用程序不依赖于DB或API。如果我们将来需要/想要改变DB或API模式，我们可以简单地改变它。至于它给出了应用程序所要求的，应用程序甚至不知道DB或API中的变化。</p><p id="052b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，单向依赖关系规则将应用程序从死锁状态中拯救出来。即，想象在2层架构中，第一层依赖于第二层，第二层依赖于第一层。在这种情况下，如果我们需要更改第一层中的任何内容，就会破坏第二层。如果我们需要改变第二层中的任何东西，就会破坏第一层。这可以通过跟踪死锁状态来拒绝。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="fbf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是鲍勃大叔描述的干净的建筑。</p><p id="ec42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还没有看到如何跨边界移动数据以及如何处理错误。我们将在以后的文章中这样做。</p><p id="ccd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>