<html>
<head>
<title>Comparing Two Benchmarks in Go 1.18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较Go 1.18中的两个基准</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/comparing-two-benchmarks-in-go-1-18-e6161de3757?source=collection_archive---------8-----------------------#2022-05-18">https://betterprogramming.pub/comparing-two-benchmarks-in-go-1-18-e6161de3757?source=collection_archive---------8-----------------------#2022-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b22b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">今天，我们将看看一个工具，它允许我们通过控制台快速、轻松地比较基准</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1732d8977b03a3530cb771c3f64da061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iOMLtsWGsFKKSyI_ebOE0Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">地鼠是由埃贡·厄尔布尔画的。</p></figure><p id="c65c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你使用Go做过一些开发，你可能已经注意到测试一个函数和检查内存分配是多么容易。Golang为我们提供了使基准测试变得非常简单的工具和命令。但是在我们对一个函数进行基准测试之后，我们应该做什么呢？</p><p id="1128" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时比较新旧版本是必要的或有用的。例如，您编写了一个函数，进行了基准测试，发现它非常慢。你上网搜索，找到更好的解决方案。您实现它，并使用您的新逻辑再次运行基准测试。你觉得应该快一点，但是你不确定。</p><p id="68e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将你的新成绩与旧成绩进行比较该有多好！不幸的是，当我写这篇文章时，Golang还没有实现这样的特性。但是不用担心。今天，我将介绍一种方法来做到这一点。现在，我不说了。我们走吧。</p><blockquote class="ls lt lu"><p id="fcd6" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">这是我的新系列的第二篇文章。如果你对泛型感兴趣，你可能也会觉得第一篇文章很有趣:<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/how-to-write-generic-helper-functions-with-go-d47c52986016">如何用Go 1.18编写泛型助手函数</a></p></blockquote><p id="9ed7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地说明，我们实现了两个不同的函数来计算序列中的<code class="fe lz ma mb mc b">nth</code>斐波那契数。您可以在下面看到我们的第一个实现。</p><h1 id="5165" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">简单递归实现</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="fe93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个非常简单的方法。如果<code class="fe lz ma mb mc b">n</code>小于2，则返回<code class="fe lz ma mb mc b">n</code>。在另一种情况下，我们用<code class="fe lz ma mb mc b">n-1</code>和<code class="fe lz ma mb mc b">n-2</code>递归调用我们的函数。最后，我们返回两者相加的结果。</p><h1 id="24ec" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">简单迭代实现</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="dd8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的第二个实现中，如果小于2，我们直接返回<code class="fe lz ma mb mc b">n</code>。如果没有，我们循环<code class="fe lz ma mb mc b">n</code>次，并在每次迭代中对<code class="fe lz ma mb mc b">n-1 + n</code>的值求和。</p><h1 id="e9ee" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">递归与迭代方法</h1><p id="62e8" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">现在我们有两种不同的实现。检查哪一个性能更好的方法是对这两个函数进行基准测试。然后你把两个结果放在一起，比较它们，瞧，我们有一个赢家。但是，如果能通过控制台来比较它们，并准确地得到两个基准之间的差异，那该多好啊。</p><p id="5063" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几个月前，我偶然发现了一个可以做到这一点的包。叫做<a class="ae kv" href="https://pkg.go.dev/golang.org/x/perf/cmd/benchstat" rel="noopener ugc nofollow" target="_blank"> benchstat </a>，非常好用。我将向您展示如何在我们的两个实现中使用它。</p><h1 id="154a" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">通过Benchstat进行比较</h1><p id="c21e" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">首先，我们需要从我们的第一个和第二个实现中提取基准，并将它们保存到一个文件中。</p><h2 id="e345" class="nc me iq bd mf nd ne dn mj nf ng dp mn lf nh ni mp lj nj nk mr ln nl nm mt nn bi translated"><strong class="ak">递归方法</strong></h2><pre class="kg kh ki kj gt no mc np nq aw nr bi"><span id="6b92" class="nc me iq mc b gy ns nt l nu nv">go test -bench="BenchmarkFibonacci" -run=^# -count=5 | tee fibunacci_recursive.txt</span></pre><h2 id="88ff" class="nc me iq bd mf nd ne dn mj nf ng dp mn lf nh ni mp lj nj nk mr ln nl nm mt nn bi translated"><strong class="ak">迭代方法</strong></h2><pre class="kg kh ki kj gt no mc np nq aw nr bi"><span id="ff6c" class="nc me iq mc b gy ns nt l nu nv">go test -bench="BenchmarkFibonacci" -run=^# -count=5 | tee fibunacci_iterative.txt</span></pre><p id="06ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，确保您已经安装了benchstat。如果没有，请使用以下命令安装它:</p><pre class="kg kh ki kj gt no mc np nq aw nr bi"><span id="0ba3" class="nc me iq mc b gy ns nt l nu nv">go install golang.org/x/perf/cmd/benchstat@latest</span></pre><p id="d2c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们只需要从benchstat调用命令来比较这两个基准。</p><pre class="kg kh ki kj gt no mc np nq aw nr bi"><span id="6dbd" class="nc me iq mc b gy ns nt l nu nv">benchstat fibunacci_recursive.txt fibunacci_iterative.txt</span></pre><p id="6996" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，benchstat显示具有不同列的统计信息。在第一列中，您可以看到我们测试的函数名。第二列和第三列显示了两个文件的样本平均时间差和百分比偏差。最后一列叫做delta。这是benchstat显示两个基准之间性能变化百分比的地方。</p><p id="19d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面，你可以看到我们比较两种方法的结果。参数值越高，我们的递归变量每次操作花费的时间就越多。而我们的迭代实现几乎是均匀增长的。通过查看delta，我们可以直接比较这意味着什么。性能上的差异迅速增加。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/e4c47eb22874497a94bde44988817a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BX9_mCZYo0PECMEaAbmEIg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用benchstat比较两个基准的结果</p></figure><h1 id="4329" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">最后的想法</h1><p id="e827" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">基准测试可能非常有用，但也会产生大量数据。Benchstat可以帮助分析数据并得出正确的结论。如果你有什么要提的或者有问题，如果你能在评论里留下来，那就太好了。</p><p id="d4e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回头见。</p><p id="6496" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">附:这是我计划的新系列的第二篇文章。在接下来的几周里，我将看看各种通用的助手函数、有趣的基准和世界范围内有用的特性。</p></div></div>    
</body>
</html>