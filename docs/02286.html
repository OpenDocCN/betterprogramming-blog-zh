<html>
<head>
<title>Implementing a Queue in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript实现队列</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-a-queue-in-javascript-59b332c7ff0d?source=collection_archive---------4-----------------------#2019-11-19">https://betterprogramming.pub/implementing-a-queue-in-javascript-59b332c7ff0d?source=collection_archive---------4-----------------------#2019-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c0ff" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看看队列数据结构</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2c5b63dd333591f78293bf3f9842946b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I5TsZiZ71FklSky5AZxEaw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://unsplash.com/@levidjones?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Levi Jones </a>在UnSplash上拍摄</p></figure><p id="229a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">队列是一个列表，类似于真实世界中的队列。最先进入队列的人是最先从队列中移除的人。</p><p id="cfc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从技术上讲，这个过程叫做先进先出(FIFO)。首先插入的元素将首先从列表中删除</p><p id="6b01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">元素总是被添加到列表的末尾，并从列表的前面移除。</p><p id="25f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Queue</code>中的不同操作有:</p><ul class=""><li id="5d9f" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><code class="fe ls lt lu lv b">Enqueue</code> →向队列中添加一个元素</li><li id="01b2" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated"><code class="fe ls lt lu lv b">Dequeue</code> →从队列中删除一个元素</li></ul><p id="ba71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将要实施的操作:</p><ul class=""><li id="28dc" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">在队列末尾插入一个元素</li><li id="f945" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">从队列中删除前面的元素</li><li id="d111" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">获取前端元素</li><li id="4bf2" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">获取最后一个元素</li><li id="4733" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">检查队列是否为空</li><li id="5472" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">打印队列的元素</li><li id="bc8a" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">打印队列的长度</li></ul><p id="aede" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建一个<code class="fe ls lt lu lv b">Queue</code>类。</p><pre class="kg kh ki kj gt mk lv ml mm aw mn bi"><span id="2f07" class="mo mp iq lv b gy mq mr l ms mt">class Queue {<br/>   <br/>   constructor(){<br/>     <br/>     this.data = [];<br/>     this.rear = 0;<br/>     this.size = 10;</span><span id="5f47" class="mo mp iq lv b gy mu mr l ms mt">   }</span><span id="88ff" class="mo mp iq lv b gy mu mr l ms mt">}</span></pre><p id="b08d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">data</code> →是我们存储元素的列表</p><p id="6514" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">rear</code> →用于存储下一个元素的存储位置</p><p id="afb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">size</code> →一个队列可以拥有的最大元素数量</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="099a" class="nc mp iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">入队:在队列末尾插入一个元素</h1><p id="a66c" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">在向队列中插入一个元素后，我们需要将<code class="fe ls lt lu lv b">rear</code>值增加<code class="fe ls lt lu lv b">1</code>，这样<code class="fe ls lt lu lv b">rear</code>就指向下一个新元素将被插入的位置。</p><pre class="kg kh ki kj gt mk lv ml mm aw mn bi"><span id="c898" class="mo mp iq lv b gy mq mr l ms mt">enqueue(element) {</span><span id="2107" class="mo mp iq lv b gy mu mr l ms mt">     this.data[this.rear] = element;<br/>     this.rear = this.rear + 1;</span><span id="05c3" class="mo mp iq lv b gy mu mr l ms mt">}</span></pre><p id="07fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了上述情况，我们需要检查队列是否已满，以避免溢出。</p><pre class="kg kh ki kj gt mk lv ml mm aw mn bi"><span id="89fb" class="mo mp iq lv b gy mq mr l ms mt">enqueue(element) {<br/>   <br/>    if(this.rear &lt; this.size ) {</span><span id="f743" class="mo mp iq lv b gy mu mr l ms mt">          this.data[this.rear] = element;<br/>          this.rear = this.rear + 1;<br/>     }</span><span id="2faa" class="mo mp iq lv b gy mu mr l ms mt">}</span></pre></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="0c85" class="nc mp iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">Length:返回队列的长度</h1><p id="33c0" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">为了获得队列的长度，我们可以使用<code class="fe ls lt lu lv b">rear</code>属性。</p><pre class="kg kh ki kj gt mk lv ml mm aw mn bi"><span id="ac09" class="mo mp iq lv b gy mq mr l ms mt"> length() {<br/>    <br/><strong class="lv ir">     return this.rear;</strong></span><span id="0690" class="mo mp iq lv b gy mu mr l ms mt"> } </span></pre></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="d4c5" class="nc mp iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">IsEmpty:检查队列是否为空</h1><p id="1acf" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">如果<code class="fe ls lt lu lv b">rear</code>指向<code class="fe ls lt lu lv b">0</code>，那么我们可以说队列是<code class="fe ls lt lu lv b">empty</code>。因为<code class="fe ls lt lu lv b">rear</code>指向新元素将被放置的位置，如果<code class="fe ls lt lu lv b">rear</code>指向0，则队列中没有元素</p><pre class="kg kh ki kj gt mk lv ml mm aw mn bi"><span id="9b80" class="mo mp iq lv b gy mq mr l ms mt">isEmpty() {<br/>   <br/>    return this.rear === 0;</span><span id="a8a6" class="mo mp iq lv b gy mu mr l ms mt">}</span></pre></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="4f07" class="nc mp iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">GetFront:获取队列的前端元素</h1><p id="874c" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">除了获取前面的元素，这将检查队列是否为空。</p><pre class="kg kh ki kj gt mk lv ml mm aw mn bi"><span id="82fa" class="mo mp iq lv b gy mq mr l ms mt">getFront() {<br/>   <br/>    if(this.isEmpty() === false) {</span><span id="452f" class="mo mp iq lv b gy mu mr l ms mt">        return this.data[0];</span><span id="4475" class="mo mp iq lv b gy mu mr l ms mt">    }</span><span id="9157" class="mo mp iq lv b gy mu mr l ms mt">}</span></pre></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="c9ea" class="nc mp iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">GetLast:获取添加到队列中的最后一个元素</h1><p id="0d18" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">我们知道<code class="fe ls lt lu lv b">rear</code>值指向新的位置，下一个元素将被插入到队列中。因此，为了获得队列中的最后一个元素，我们可以将索引<code class="fe ls lt lu lv b">rear</code>减少<code class="fe ls lt lu lv b">1</code>。</p><pre class="kg kh ki kj gt mk lv ml mm aw mn bi"><span id="75c5" class="mo mp iq lv b gy mq mr l ms mt">getLast() {<br/>    <br/>     if(this.isEmpty() === false) {<br/>       <br/>          return this.data[ <strong class="lv ir">this.rear - 1</strong> ] ;<br/>     }</span><span id="8d3f" class="mo mp iq lv b gy mu mr l ms mt">}</span></pre></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="a915" class="nc mp iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">删除:从队列中删除前面的元素</h1><p id="9778" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">最先插入的元素是最先删除的元素。因此，我们可以删除前面的元素，并将<code class="fe ls lt lu lv b">rear</code>值减少<code class="fe ls lt lu lv b">1</code>，这样后面的元素将指向下一个正确插入的位置。</p><pre class="kg kh ki kj gt mk lv ml mm aw mn bi"><span id="ebdc" class="mo mp iq lv b gy mq mr l ms mt">dequeue() {<br/>   <br/>     if(this.isEmpty() === false) {<br/>          <br/>          <strong class="lv ir">this.rear = this.rear-1;</strong><br/><strong class="lv ir">          return this.data.shift();<br/>     }</strong></span><span id="7450" class="mo mp iq lv b gy mu mr l ms mt">}</span></pre></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="b9db" class="nc mp iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">打印队列的元素</h1><p id="a00d" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">我们可以打印从<code class="fe ls lt lu lv b">0</code>索引到<code class="fe ls lt lu lv b">queue</code>的<code class="fe ls lt lu lv b">rear-1</code>索引的队列元素。</p><pre class="kg kh ki kj gt mk lv ml mm aw mn bi"><span id="58cd" class="mo mp iq lv b gy mq mr l ms mt">print() {<br/>   <br/>   for(let i =0; i &lt; this.rear; i++) {<br/>      console.log(this.data[i]);<br/>    }</span><span id="6d61" class="mo mp iq lv b gy mu mr l ms mt">}</span></pre></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="0f77" class="nc mp iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">重置队列</h1><p id="7947" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">删除队列的所有元素，并将<code class="fe ls lt lu lv b">rear</code>设置为<code class="fe ls lt lu lv b">0</code>。</p><pre class="kg kh ki kj gt mk lv ml mm aw mn bi"><span id="0d11" class="mo mp iq lv b gy mq mr l ms mt">clear() {<br/>   this.data.length = 0;<br/>   this.rear = 0;</span><span id="8369" class="mo mp iq lv b gy mu mr l ms mt">}</span></pre></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="c148" class="nc mp iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">结束了</h1><p id="2e08" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">让我们把上面所有的代码结合在一起</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7257" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。我希望你喜欢这篇文章。</p></div></div>    
</body>
</html>