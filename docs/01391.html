<html>
<head>
<title>The Magic of Hoisting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提升的魔力</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/magic-of-hoisting-3fec34978fd8?source=collection_archive---------8-----------------------#2019-09-05">https://betterprogramming.pub/magic-of-hoisting-3fec34978fd8?source=collection_archive---------8-----------------------#2019-09-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7277" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索JavaScript中的范围</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/c8aac05d13d5af6f7c59b09a8dd9fd32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*RbMacHBAn9q1FVtRz5wBRA.png"/></div></figure><p id="17b9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="lm">提升</em>是一种JavaScript机制，JavaScript一编译完所有代码，使用<code class="fe ln lo lp lq b">var</code> <em class="lm"> </em>的变量声明就被提升/提升到其作用域的顶部(如果在函数内声明，则提升到其函数/局部作用域的顶部，如果在函数外声明，则提升到其全局作用域的顶部)。</p><p id="0a6f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">需要注意的一个关键点是提升只是移动了声明。作业留在原处。</p><p id="4890" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们举个例子来演示一下吊装的影响。</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="cb22" class="lv lw it lq b gy lx ly l lz ma">console.log(hoist);<br/>var hoist = 'This variable has been hoisted.';</span></pre><p id="a1cf" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">你认为输出会是什么？</p><ol class=""><li id="c866" class="mb mc it ks b kt ku kw kx kz md ld me lh mf ll mg mh mi mj bi translated"><code class="fe ln lo lp lq b">Uncaught ReferenceError: hoist is not defined</code></li><li id="a200" class="mb mc it ks b kt mk kw ml kz mm ld mn lh mo ll mg mh mi mj bi translated"><code class="fe ln lo lp lq b">This variable has been hoisted.</code></li><li id="db0d" class="mb mc it ks b kt mk kw ml kz mm ld mn lh mo ll mg mh mi mj bi translated"><code class="fe ln lo lp lq b">undefined</code></li></ol><p id="0c09" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">大多数人会选择第一个选项，但事实证明第三个选项是正确的，因为提升会将声明移动到顶部，而赋值则留在原处。</p><p id="d48b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">上述代码与以下代码相同:</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="4d5d" class="lv lw it lq b gy lx ly l lz ma">var hoist;<br/>console.log(hoist); // undefined<br/>hoist = 'This variable has been hoisted';</span></pre><p id="6e64" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们来看另一个例子，看看函数范围内的变量是如何提升的:</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="327e" class="lv lw it lq b gy lx ly l lz ma">function hoist() {<br/>  console.log(message);<br/>  var message = 'Hoisting is done.';<br/>}</span><span id="88ea" class="lv lw it lq b gy mp ly l lz ma">hoist();</span></pre><p id="cc0f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你猜对了<code class="fe ln lo lp lq b">undefined</code>，你就对了。</p><p id="22c3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">解释器是这样看待上面的代码的:</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="b6f1" class="lv lw it lq b gy lx ly l lz ma">function hoist() {<br/>  var message;<br/>  console.log(message); // undefined<br/>  message = 'Hoisting is done';<br/>}</span><span id="1bd1" class="lv lw it lq b gy mp ly l lz ma">hoist(); // undefined</span></pre><p id="88cc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">变量声明<code class="fe ln lo lp lq b">var message</code>，其作用域是函数<code class="fe ln lo lp lq b">hoist()</code>，被提升到函数的顶部。</p><p id="e783" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">正确的做法如下:</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="6603" class="lv lw it lq b gy lx ly l lz ma">function hoist() {<br/>  var message = 'This avoids the above pitfall.';<br/>  console.log(message);<br/>}</span><span id="c956" class="lv lw it lq b gy mp ly l lz ma">hoist(); // This avoids the above pitfall.</span></pre></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="a425" class="mx lw it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">提升功能</h1><p id="a735" class="pw-post-body-paragraph kq kr it ks b kt no ju kv kw np jx ky kz nq lb lc ld nr lf lg lh ns lj lk ll im bi translated">提升也移动了函数声明，但是这些声明位于最顶端，因此将位于所有变量声明之上。</p><p id="0c34" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你曾经想知道为什么你能在你的代码中写函数之前就调用它们，神奇的是通过提升实现的。</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="f125" class="lv lw it lq b gy lx ly l lz ma">hoisted(); // This function has been hoisted.</span><span id="a40d" class="lv lw it lq b gy mp ly l lz ma">function hoisted() {<br/>  console.log('This function has been hoisted');<br/>}</span></pre><p id="14f7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">但是，函数表达式不会被提升。</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="1a21" class="lv lw it lq b gy lx ly l lz ma">expression(); // TypeError: expression is not a function.</span><span id="f3fe" class="lv lw it lq b gy mp ly l lz ma">var expression = function() {<br/>  console.log('This function has been hoisted');<br/>}</span></pre><p id="d723" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们来看另一个例子:</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="6725" class="lv lw it lq b gy lx ly l lz ma">function foo() {<br/>  function bar() {<br/>    return 'bar1';<br/>  }</span><span id="afdf" class="lv lw it lq b gy mp ly l lz ma">  return bar();</span><span id="717e" class="lv lw it lq b gy mp ly l lz ma">  function bar() {<br/>    return 'bar2';<br/>  }<br/>}</span><span id="dade" class="lv lw it lq b gy mp ly l lz ma">foo();</span></pre><p id="f5c3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">猜测产量？</p><p id="ccd3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">输出是<code class="fe ln lo lp lq b">bar2</code>。<code class="fe ln lo lp lq b">foo</code>内的第一个函数将被提升。类似地，第二个函数声明也将被放在顶部。因为两个函数同名，所以第二个函数声明将替换第一个函数声明。因此，在执行时，将调用第二个函数<code class="fe ln lo lp lq b">bar</code>。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="f7ad" class="mx lw it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">但是let和const呢？</h1><p id="ac76" class="pw-post-body-paragraph kq kr it ks b kt no ju kv kw np jx ky kz nq lb lc ld nr lf lg lh ns lj lk ll im bi translated">它们也被吊起—事实上，<code class="fe ln lo lp lq b">var</code>、<code class="fe ln lo lp lq b">let</code>、<code class="fe ln lo lp lq b">const</code>、<code class="fe ln lo lp lq b">function</code>和<code class="fe ln lo lp lq b">class</code>申报被吊起。</p><h2 id="193d" class="lv lw it bd my nt nu dn nc nv nw dp ng kz nx ny ni ld nz oa nk lh ob oc nm od bi translated">让</h2><p id="c2d1" class="pw-post-body-paragraph kq kr it ks b kt no ju kv kw np jx ky kz nq lb lc ld nr lf lg lh ns lj lk ll im bi translated">用关键字<code class="fe ln lo lp lq b">let</code>声明的变量是块范围的，而不是函数范围的。这只是意味着变量的作用域被绑定到声明它的块，而不是声明它的函数。</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="e82e" class="lv lw it lq b gy lx ly l lz ma">console.log(hoist); // ReferenceError: hoist is not defined<br/>let hoist = 'This variable has been hoisted';</span></pre><p id="919d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">类似于关键字<code class="fe ln lo lp lq b">var</code>，我们期望日志的输出是<code class="fe ln lo lp lq b">undefined</code>。</p><p id="b30a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe ln lo lp lq b">var</code>和<code class="fe ln lo lp lq b">let</code>的实例可以在没有值的情况下初始化(如果你试图调用它，它将返回<code class="fe ln lo lp lq b">undefined</code>)。</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="148a" class="lv lw it lq b gy lx ly l lz ma">let hoist;<br/>console.log(hoist); // undefined<br/>hoist = 'This variable has been hoisted.';</span></pre><h2 id="da27" class="lv lw it bd my nt nu dn nc nv nw dp ng kz nx ny ni ld nz oa nk lh ob oc nm od bi translated">常数</h2><p id="acc5" class="pw-post-body-paragraph kq kr it ks b kt no ju kv kw np jx ky kz nq lb lc ld nr lf lg lh ns lj lk ll im bi translated"><code class="fe ln lo lp lq b">const</code>关键字是在es6中引入的，以允许不可变的变量。使用<code class="fe ln lo lp lq b">const</code>，就像使用<code class="fe ln lo lp lq b">let</code>一样，变量被提升到程序块的顶部。</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="469d" class="lv lw it lq b gy lx ly l lz ma">console.log(hoist); // ReferenceError: hoist is not defined<br/>const hoist = 'This variable has been hoisted';</span></pre><p id="082b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">但是与<code class="fe ln lo lp lq b">let</code>和<code class="fe ln lo lp lq b">var</code>不同，我们不能在没有值的情况下初始化<code class="fe ln lo lp lq b">const</code>。如果您尝试这样做，它将抛出一个<code class="fe ln lo lp lq b">Error</code>。</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="593a" class="lv lw it lq b gy lx ly l lz ma">const hoist;</span><span id="822c" class="lv lw it lq b gy mp ly l lz ma">console.log(hoist); <br/>// SyntaxError: Missing initializer in the const declaration;</span><span id="1575" class="lv lw it lq b gy mp ly l lz ma">hoist = 'This variable has been hoisted';</span></pre><p id="18bc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，<code class="fe ln lo lp lq b">const</code>和<code class="fe ln lo lp lq b">let</code>必须在使用前声明并初始化。</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="5baa" class="lv lw it lq b gy lx ly l lz ma">const foo = 'Hey, I'm foo!';<br/>console.log(foo); // Hey, I'm foo!</span><span id="6c42" class="lv lw it lq b gy mp ly l lz ma">let bar = 'Hey, I'm bar!';<br/>console.log(bar); // Hey, I'm bar!</span></pre></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="9890" class="mx lw it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">吊装等级</h1><h2 id="5553" class="lv lw it bd my nt nu dn nc nv nw dp ng kz nx ny ni ld nz oa nk lh ob oc nm od bi translated">类别声明</h2><p id="9a4f" class="pw-post-body-paragraph kq kr it ks b kt no ju kv kw np jx ky kz nq lb lc ld nr lf lg lh ns lj lk ll im bi translated">JavaScript类声明也被挂起。但是，在评估之前，它们保持未初始化状态。</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="a0db" class="lv lw it lq b gy lx ly l lz ma">var foo = new bar();<br/>foo.height = 100;<br/>foo.weight = 100;<br/>console.log(foo); // Guess the output?</span><span id="2988" class="lv lw it lq b gy mp ly l lz ma">class bar {<br/>  constructor(height, weight) {<br/>    this.height = height;<br/>    this.weight = weight;<br/>  }<br/>}</span></pre><p id="ff93" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你猜对了<code class="fe ln lo lp lq b">undefined</code>，这次你错了。输出为<code class="fe ln lo lp lq b">ReferenceError: foo is not defined</code>。为什么？<code class="fe ln lo lp lq b">bar</code>在声明之前被使用，这对于类变量是非法的。</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="4fcf" class="lv lw it lq b gy lx ly l lz ma">class bar {<br/>  constructor(height, weight) {<br/>    this.height = height;<br/>    this.weight = weight;<br/>  }<br/>}</span><span id="207e" class="lv lw it lq b gy mp ly l lz ma">var foo = new bar();<br/>foo.height = 100;<br/>foo.weight = 100;<br/>console.log(foo); // { height: 100, weight: 100 }</span></pre><h2 id="5a2e" class="lv lw it bd my nt nu dn nc nv nw dp ng kz nx ny ni ld nz oa nk lh ob oc nm od bi translated">类别表达式</h2><p id="a505" class="pw-post-body-paragraph kq kr it ks b kt no ju kv kw np jx ky kz nq lb lc ld nr lf lg lh ns lj lk ll im bi translated">类表达式不被提升。</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="5a30" class="lv lw it lq b gy lx ly l lz ma">var Square = new Polygon();<br/>Square.height = 10;<br/>Square.width = 10;<br/>console.log(Square); // TypeError: Polygon is not a constructor<br/><br/>var Polygon = class Polygon {<br/>  constructor(height, width) {<br/>    this.height = height;<br/>    this.width = width;<br/>  }<br/>};</span></pre><p id="a256" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">正确的做法是:</p><pre class="kj kk kl km gt lr lq ls lt aw lu bi"><span id="1e06" class="lv lw it lq b gy lx ly l lz ma">var Polygon = class Polygon {<br/>  constructor(height, width) {<br/>    this.height = height;<br/>    this.width = width;<br/>  }<br/>};<br/><br/>var Square = new Polygon();<br/>Square.height = 10;<br/>Square.width = 10;<br/>console.log(Square);</span></pre></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="4389" class="mx lw it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">结论</h1><p id="fbac" class="pw-post-body-paragraph kq kr it ks b kt no ju kv kw np jx ky kz nq lb lc ld nr lf lg lh ns lj lk ll im bi translated">我们应该养成习惯，在使用之前声明和初始化JavaScript变量、类和函数。</p><p id="4c8c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">参考:<a class="ae oe" href="https://scotch.io/tutorials/understanding-hoisting-in-javascript" rel="noopener ugc nofollow" target="_blank">https://scotch . io/tutorials/understanding-raising-in-JavaScript</a></p></div></div>    
</body>
</html>