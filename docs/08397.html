<html>
<head>
<title>5 Powerful Python and R Tricks for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家的5个强大的Python和R技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-powerful-python-and-r-tricks-for-data-scientists-e35dd9050750?source=collection_archive---------10-----------------------#2021-04-26">https://betterprogramming.pub/5-powerful-python-and-r-tricks-for-data-scientists-e35dd9050750?source=collection_archive---------10-----------------------#2021-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="49e7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">R和Python中有用的代码片段</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c85e25d17229991a1b195ae7dffc9cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0KJyeyV7JjY9GBxs"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@sunday_digital?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Nastuh Abootalebi </a>在<a class="ae ky" href="https://unsplash.com/s/photos/fridge?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><div class="kz la gp gr lb lc"><a href="https://jorgepit-14189.medium.com/membership" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">用我的推荐链接加入媒体-乔治皮皮斯</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">阅读乔治·皮皮斯(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">jorgepit-14189.medium.com</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq ks lc"/></div></div></a></div><p id="1b66" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们已经开始为数据科学家撰写一系列关于技巧和诀窍的文章(主要用Python和R语言)。如果您错过了前几期:</p><p id="b686" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">第一卷:</p><div class="kz la gp gr lb lc"><a rel="noopener  ugc nofollow" target="_blank" href="/10tips-and-tricks-for-data-scientists-vol-1-a870455325da"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">数据科学家的10个技巧和诀窍</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">R和Python中有用的代码片段</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">better编程. pub</p></div></div><div class="ll l"><div class="mn l ln lo lp ll lq ks lc"/></div></div></a></div><p id="f4bc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">第二卷:</p><div class="kz la gp gr lb lc"><a rel="noopener  ugc nofollow" target="_blank" href="/10-tips-and-tricks-for-data-scientists-vol-2-5640ccd1aa5e"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">数据科学家的10个惊人技巧和诀窍</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">一些更有用的R和Python代码片段</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">better编程. pub</p></div></div><div class="ll l"><div class="mo l ln lo lp ll lq ks lc"/></div></div></a></div><p id="bf81" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">第三卷:</p><div class="kz la gp gr lb lc"><a rel="noopener  ugc nofollow" target="_blank" href="/10-tips-and-tricks-for-data-scientists-part-3-52ffbddcba26"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">数据科学家会喜欢的10个真实世界的提示和技巧</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">Python、R等语言中一些更有用的代码片段</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">better编程. pub</p></div></div><div class="ll l"><div class="mp l ln lo lp ll lq ks lc"/></div></div></a></div><p id="7358" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">第4卷:</p><div class="kz la gp gr lb lc"><a rel="noopener  ugc nofollow" target="_blank" href="/10-tips-and-tricks-for-data-scientists-vol-4-76b0b732a94f"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">数据科学家的10个Python和R技巧</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">在Pandas中输入缺失值，用mode替换分类变量，等等</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">better编程. pub</p></div></div><div class="ll l"><div class="mq l ln lo lp ll lq ks lc"/></div></div></a></div><p id="1eff" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">第5卷:</p><div class="kz la gp gr lb lc"><a rel="noopener  ugc nofollow" target="_blank" href="/10-tips-and-tricks-for-data-scientists-vol-5-ef86aea08b6c"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">数据科学家的10个更多提示和技巧(第5卷)</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">对日常任务有用的代码片段</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">better编程. pub</p></div></div><div class="ll l"><div class="mr l ln lo lp ll lq ks lc"/></div></div></a></div></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="d6ef" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">计算机编程语言</h1><h2 id="3903" class="nr na it bd nb ns nt dn nf nu nv dp nj ma nw nx nl me ny nz nn mi oa ob np oc bi translated">1.如何从列表中获取模式</h2><p id="037a" class="pw-post-body-paragraph lr ls it lt b lu od ju lw lx oe jx lz ma of mc md me og mg mh mi oh mk ml mm im bi translated">假设我们有以下列表:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="1723" class="nr na it oj b gy on oo l op oq">mylist = [1,1,1,2,2,3,3]</span></pre><p id="a9ce" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">并且我们想要得到模式(即最频繁的元素)。我们可以使用下面的技巧，使用<code class="fe or os ot oj b">max</code>和λ键:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="10e6" class="nr na it oj b gy on oo l op oq">max(mylist, key = mylist.count)</span></pre><p id="e496" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们得到了<code class="fe or os ot oj b">1</code>,因为这是我们列表中的模式。如果在模式中有一个抽奖，并且您想要获得最小或最大数量，您可以按如下方式对列表进行排序:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="dc1e" class="nr na it oj b gy on oo l op oq">mylist = [1,1,1,2,2,3,3,3] max(sorted(mylist), key = mylist.count)</span></pre><p id="995e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们得到<code class="fe or os ot oj b">1</code>:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="49ae" class="nr na it oj b gy on oo l op oq">mylist = [1,1,1,2,2,3,3,3] </span><span id="8108" class="nr na it oj b gy ou oo l op oq">max(sorted(mylist, reverse=True), key = mylist.count)</span></pre><p id="49d0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们得到了<code class="fe or os ot oj b">3</code>。</p><p id="dd0a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在上面的例子中，我们有两种模式:<code class="fe or os ot oj b">1</code>和<code class="fe or os ot oj b">3</code>。通过添加<code class="fe or os ot oj b">sorted</code>函数，我们能够分别获得最小值和最大值。最后，这种方法也适用于字符串元素:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="cdcc" class="nr na it oj b gy on oo l op oq">mylist = ['a','a','b','b','b'] </span><span id="097b" class="nr na it oj b gy ou oo l op oq">max(mylist, key = mylist.count)</span></pre><p id="53b4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们得到了<code class="fe or os ot oj b">‘b’</code>。</p><h2 id="49dc" class="nr na it bd nb ns nt dn nf nu nv dp nj ma nw nx nl me ny nz nn mi oa ob np oc bi translated">2.如何禁用所有警告</h2><p id="8b22" class="pw-post-body-paragraph lr ls it lt b lu od ju lw lx oe jx lz ma of mc md me og mg mh mi oh mk ml mm im bi translated">通过运行以下代码块，可以禁用所有Python警告:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="acda" class="nr na it oj b gy on oo l op oq">import sys<br/>if not sys.warnoptions:<br/>    import warnings<br/>    warnings.simplefilter("ignore")</span></pre><h2 id="d322" class="nr na it bd nb ns nt dn nf nu nv dp nj ma nw nx nl me ny nz nn mi oa ob np oc bi translated">3.如何复制数据并粘贴到熊猫数据框中</h2><p id="5c26" class="pw-post-body-paragraph lr ls it lt b lu od ju lw lx oe jx lz ma of mc md me og mg mh mi oh mk ml mm im bi translated">首先，我们需要复制类似于<code class="fe or os ot oj b">DataFrame</code>的数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/dbc23f1572dfb65861c88bfcf53ac4a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/0*02tzdm1uvas6gQjD.png"/></div></figure><p id="1270" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">然后，运行以下命令:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="1c87" class="nr na it oj b gy on oo l op oq">import pandas as pd<br/>pd.read_clipboard()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/bf863bba92eb7edcbe879af9e10f2ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/0*WMiz-ByJyeKUbqcb.png"/></div></figure><h2 id="9d13" class="nr na it bd nb ns nt dn nf nu nv dp nj ma nw nx nl me ny nz nn mi oa ob np oc bi translated">4.如何将熊猫数据帧保存为图像</h2><p id="e9a9" class="pw-post-body-paragraph lr ls it lt b lu od ju lw lx oe jx lz ma of mc md me og mg mh mi oh mk ml mm im bi translated">您可以使用<a class="ae ky" href="https://pypi.org/project/dataframe-image/" rel="noopener ugc nofollow" target="_blank">数据帧-图像</a>库将熊猫<code class="fe or os ot oj b">DataFrames</code>保存为图像。然后你可以运行:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="407c" class="nr na it oj b gy on oo l op oq">import pandas as pd<br/>import dataframe_image as dfi<br/> <br/>df = pd.DataFrame({'A': [1,2,3,4],<br/>                   'B':['A','B','C','D']})<br/> <br/>dfi.export(df, 'dataframe.png')</span></pre><p id="9e88" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">运行上面的命令将创建一个PNG图像文件，其中的<code class="fe or os ot oj b">DataFrame</code>如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/b4be0f945e0fe61408a8ae434c1c2894.png" data-original-src="https://miro.medium.com/v2/resize:fit:146/format:webp/0*Y4NbCfrU774wlzwG.png"/></div></figure><h2 id="618c" class="nr na it bd nb ns nt dn nf nu nv dp nj ma nw nx nl me ny nz nn mi oa ob np oc bi translated">5.如何在熊猫应用中添加进度条</h2><p id="819f" class="pw-post-body-paragraph lr ls it lt b lu od ju lw lx oe jx lz ma of mc md me og mg mh mi oh mk ml mm im bi translated">当我们将一个函数应用到一个大的<code class="fe or os ot oj b">DataFrame</code>时，我们看不到函数的进度，也看不到对整个数据集应用该函数还需要多长时间的估计。我们可以通过使用tqdm库来解决这个问题。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="a5c2" class="nr na it oj b gy on oo l op oq">import pandas as pd<br/>import numpy as np<br/>from tqdm.notebook import tqdm<br/>tqdm.pandas()</span><span id="d18d" class="nr na it oj b gy ou oo l op oq">#dummy data<br/>df=pd.DataFrame({"Value":np.random.normal(size=1500000)})</span></pre><p id="cbaa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们对我们的数据应用一个简单的函数，但是不使用<code class="fe or os ot oj b">apply</code>，我们将使用<code class="fe or os ot oj b">progress_apply</code>函数:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="739c" class="nr na it oj b gy on oo l op oq">df['Value'].progress_apply(lambda x: x**2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/2579b59186a97cc0df24ed78feee19fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*ArMvi_Zr1sVNRyxC.gif"/></div></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="a8c7" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">稀有</h1><h2 id="0a76" class="nr na it bd nb ns nt dn nf nu nv dp nj ma nw nx nl me ny nz nn mi oa ob np oc bi translated">6.避免在大型数据集中使用apply()函数</h2><p id="116e" class="pw-post-body-paragraph lr ls it lt b lu od ju lw lx oe jx lz ma of mc md me og mg mh mi oh mk ml mm im bi translated">当我们处理大型数据集时，需要计算一些值，如<code class="fe or os ot oj b">row</code>/<code class="fe or os ot oj b">column min</code>/<code class="fe or os ot oj b">max</code>/<code class="fe or os ot oj b">rank</code>/<code class="fe or os ot oj b">mean</code>/等。，我们应该避免使用<code class="fe or os ot oj b">apply</code>函数，因为它需要很多时间。相反，我们可以使用<a class="ae ky" href="https://cran.r-project.org/web/packages/matrixStats/matrixStats.pdf" rel="noopener ugc nofollow" target="_blank"> matrixStats </a>包及其相应的函数。下面提供一些对比。</p><p id="e612" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">假设我们想从一个<code class="fe or os ot oj b">500 x 500</code>矩阵中得到每一行的最小值。让我们比较一下<code class="fe or os ot oj b">base</code>封装的<code class="fe or os ot oj b">apply</code>函数和<code class="fe or os ot oj b">matrixStats</code>封装的<code class="fe or os ot oj b">rowMins</code>函数的性能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="7b95" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们得到了:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="55d4" class="nr na it oj b gy on oo l op oq">Unit: milliseconds<br/>             expr      min         lq       mean    median        uq       max neval<br/> apply(x, 1, min) 981.6283 1034.98050 1078.04485 1065.4163 1107.9962 1327.9284   100<br/>       rowMins(x)  42.1838   43.80065   46.55752   45.2255   47.6249   81.3097   100</span></pre><p id="3dc2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">从上面的输出可以看出，<code class="fe or os ot oj b">apply</code>功能比<code class="fe or os ot oj b">rowMins</code>慢23倍。下面，我们代表小提琴的情节:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="aff1" class="nr na it oj b gy on oo l op oq">autoplot(tm)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/83615e9d0b90a66d9a20dad264f98feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bD3gNOQJHucVhSaj.png"/></div></div></figure><h2 id="e085" class="nr na it bd nb ns nt dn nf nu nv dp nj ma nw nx nl me ny nz nn mi oa ob np oc bi translated">7.读写文件的最快方法</h2><p id="8f72" class="pw-post-body-paragraph lr ls it lt b lu od ju lw lx oe jx lz ma of mc md me og mg mh mi oh mk ml mm im bi translated">当我们处理大型数据集时，我们需要编写<strong class="lt iu"> </strong>许多CSV文件，或者当我们必须读取<strong class="lt iu"> </strong>的CSV文件很大时，那么<code class="fe or os ot oj b">read</code>和<code class="fe or os ot oj b">write</code>命令的速度就很重要。我们将在以下情况下比较读写文件所需的时间。</p><p id="4c4a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了比较写入时间，我们将使用一个大约180MB的100万行10列的CSV文件。让我们创建样本数据框并将其写入硬盘。我们将从正态分布中生成1000万个观察值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/0fab0ae9fe80d2c1e879776b6fbebd82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MfDTJXEu-Bo9Ysbp.png"/></div></div></figure><p id="8c93" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">从运行时间可以看出，<code class="fe or os ot oj b">data.table</code>的<code class="fe or os ot oj b">fwrite</code>比基础包的<strong class="lt iu"> </strong> ~70倍，比<code class="fe or os ot oj b">readr</code>大约快7倍。</p><p id="a482" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们也比较一下使用<code class="fe or os ot oj b">microbenchmark</code>包的读取时间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/324a9941014dd2a1056b36bf3dba0d4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0DDYHOas3DmeI9h1.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/9aa2302079d9c9dec5f72c58b8d9612a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/0*pYsM9mNBCwQXZddu.png"/></div></figure><p id="e322" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">正如我们所见，<code class="fe or os ot oj b">data.table</code>封装的<code class="fe or os ot oj b">fread</code>比基本封装快40倍，比<code class="fe or os ot oj b">readr</code>封装的<code class="fe or os ot oj b">read_csv</code>快8.5倍。所以如果想快速读写文件，应该选择<code class="fe or os ot oj b">data.table</code>包。</p><h2 id="6116" class="nr na it bd nb ns nt dn nf nu nv dp nj ma nw nx nl me ny nz nn mi oa ob np oc bi translated">8.如何比较对象</h2><p id="9f63" class="pw-post-body-paragraph lr ls it lt b lu od ju lw lx oe jx lz ma of mc md me og mg mh mi oh mk ml mm im bi translated">2020年，Hadley Wickham构建了一个名为<a class="ae ky" href="https://cran.r-project.org/web/packages/waldo/waldo.pdf" rel="noopener ugc nofollow" target="_blank"> waldo </a>的新包，用于比较复杂的R对象，并使其易于检测关键差异。你可以在Tidyverse和GitHub上找到详细的例子。让我们通过用waldo比较R中的两个数据帧来提供一个简单的例子。</p><p id="da5b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们创建新的数据框:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="3525" class="nr na it oj b gy on oo l op oq">library(waldo)<br/> <br/> <br/>df1&lt;-data.frame(X=c(1,2,3), Y=c("a","b","c"), A=c(3,4,5))<br/>df2&lt;-data.frame(X=c(1,2,3,4), Y=c("A","b","c","d"), Z=c("k","l","m","n"), A=c("3","4","5","6"))</span></pre><p id="2949" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">df1:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="233f" class="nr na it oj b gy on oo l op oq">X Y A<br/>1 1 a 3<br/>2 2 b 4<br/>3 3 c 5</span></pre><p id="6b5a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">和df2:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="ba8d" class="nr na it oj b gy on oo l op oq">X Y Z A<br/>1 1 A k 3<br/>2 2 b l 4<br/>3 3 c m 5<br/>4 4 d n 6</span></pre><p id="fdf3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们来比较一下:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="51cd" class="nr na it oj b gy on oo l op oq">waldo::compare(df1,df2)</span></pre><p id="de1d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们得到了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/1ec52c0f0c47e6efcf69eab30df639a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OUE4oCr0cnzjemAM.png"/></div></div></figure><p id="8387" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">正如我们所看到的，它捕捉了所有的差异，输出是一种友好的格式，根据不同的颜色不同。更具体地说，它表明:</p><ul class=""><li id="2773" class="pf pg it lt b lu lv lx ly ma ph me pi mi pj mm pk pl pm pn bi translated">df1有三行，而df2有两行。</li><li id="8c13" class="pf pg it lt b lu po lx pp ma pq me pr mi ps mm pk pl pm pn bi translated">df2有一个额外的列名，它显示顺序中的不同之处。</li><li id="5e47" class="pf pg it lt b lu po lx pp ma pq me pr mi ps mm pk pl pm pn bi translated">它显示了行的名称和差异。</li><li id="c87d" class="pf pg it lt b lu po lx pp ma pq me pr mi ps mm pk pl pm pn bi translated">它比较每一列(X，Y，A，Z)。</li><li id="5262" class="pf pg it lt b lu po lx pp ma pq me pr mi ps mm pk pl pm pn bi translated">它检测到a列数据类型的不同，第一个是<em class="pt">双</em>，第二个是<em class="pt">字符</em>。</li><li id="21b9" class="pf pg it lt b lu po lx pp ma pq me pr mi ps mm pk pl pm pn bi translated">它返回有一个名为z的新列。</li></ul><h2 id="8bf3" class="nr na it bd nb ns nt dn nf nu nv dp nj ma nw nx nl me ny nz nn mi oa ob np oc bi translated">9.如何动态安装和加载软件包</h2><p id="0c57" class="pw-post-body-paragraph lr ls it lt b lu od ju lw lx oe jx lz ma of mc md me og mg mh mi oh mk ml mm im bi translated">当我们与其他人共享一个R脚本文件时，我们假设他们已经安装了所需的R包。然而，情况并非总是如此，因此，我强烈建议将这段代码添加到每个需要包的共享R脚本中。我们假设你的代码需要以下三个包:<code class="fe or os ot oj b">“readxl”</code>、<code class="fe or os ot oj b">“dplyr”</code>、<code class="fe or os ot oj b">“multcomp”</code>。</p><p id="4caa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下面的脚本检查这个包是否存在，如果不存在，它就安装它，最后把它加载到R:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div></figure><h2 id="8238" class="nr na it bd nb ns nt dn nf nu nv dp nj ma nw nx nl me ny nz nn mi oa ob np oc bi translated">10.如何将所有字符变量转换为因子</h2><p id="fb97" class="pw-post-body-paragraph lr ls it lt b lu od ju lw lx oe jx lz ma of mc md me og mg mh mi oh mk ml mm im bi translated">假设我们想要将所有字符变量转换为因子，并且我们正在处理一个包含许多列的大型数据框架。这意味着逐个转换它们是不实际的。因此，我们的方法是检测<code class="fe or os ot oj b">char</code> <strong class="lt iu"> </strong>变量并将它们转换成因子。</p><p id="1f2b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们提供一个玩具示例:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="0040" class="nr na it oj b gy on oo l op oq">df&lt;-data.frame(Gender = c("F", "F", "M","M","F"), <br/>               Score  = c(80, 70, 65, 85, 95),<br/>               Type = c("A","B","C","B","B"))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/66ed78515314a61b5253965217d53626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/0*9arnI_H_ChFzluWh.png"/></div></figure><p id="2ed9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以看到，<code class="fe or os ot oj b">Gender</code>和<code class="fe or os ot oj b">Type</code>是<code class="fe or os ot oj b">char</code>变量。让我们将它们转换成因子:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="9d18" class="nr na it oj b gy on oo l op oq">df[sapply(df, is.character)] &lt;- lapply(df[sapply(df, is.character)], as.factor)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/5ad1689a2235ebf7c392f240f768e281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KyAT0f9Q2kONic7D.png"/></div></div></figure><p id="6879" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如我们所见，我们成功地转换了它们。现在，你也可以<a class="ae ky" href="https://predictivehacks.com/rename-and-relevel-factors-in-r/" rel="noopener ugc nofollow" target="_blank">重命名和重新分级因子</a>。注意，我们可以反过来将因子转换成字符。一般来说，我们可以改变不同的数据类型。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="c28e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><em class="pt">原载于2021年4月26日https://predictivehacks.com</em><em class="pt">的</em> <a class="ae ky" href="https://predictivehacks.com/10-tips-and-tricks-for-data-scientists-vol-6/" rel="noopener ugc nofollow" target="_blank"> <em class="pt">。</em></a></p></div></div>    
</body>
</html>