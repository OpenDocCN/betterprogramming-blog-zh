<html>
<head>
<title>Common Mistakes in Declarations and Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中声明和函数的常见错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-best-practices-declarations-and-functions-a690689c106e?source=collection_archive---------20-----------------------#2020-04-09">https://betterprogramming.pub/javascript-best-practices-declarations-and-functions-a690689c106e?source=collection_archive---------20-----------------------#2020-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cc85" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JavaScript太宽容了，但这并不意味着你必须宽容</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3ec3997256b90e5b63e353bb9d0b17cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aAvh_H1NFQtNK66Z"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="9ba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="b8b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将看看在编写JavaScript代码时需要注意的一些最佳实践，包括在<code class="fe lv lw lx ly b">switch</code>语句中声明和在函数中返回内容。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="89dd" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">switch语句中没有case或default子句中的词法声明</h1><p id="ed5e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">以<code class="fe lv lw lx ly b">let</code>、<code class="fe lv lw lx ly b">const</code>、<code class="fe lv lw lx ly b">function</code>和<code class="fe lv lw lx ly b">class</code>开头的词法声明(如表达式)不应该出现在<code class="fe lv lw lx ly b">switch</code>块的<code class="fe lv lw lx ly b">case</code>或<code class="fe lv lw lx ly b">default</code>子句中，因为它们只有在被赋值时才会被初始化。</p><p id="4686" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只发生在未达到的<code class="fe lv lw lx ly b">case</code>中。因此，为了防止访问<code class="fe lv lw lx ly b">switch</code>块中未初始化的变量，我们应该包装<code class="fe lv lw lx ly b">case</code>和<code class="fe lv lw lx ly b">default</code>语句来创建一个块，这样它们就不能作为未初始化的变量在外部被访问。</p><p id="1bce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="96f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，因为<code class="fe lv lw lx ly b">foo</code>是2，所以<code class="fe lv lw lx ly b">case 2</code>块将会运行，这将会给我们带来“初始化前不能访问‘x’”的错误。</p><p id="cd63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止这种错误，我们应该将<code class="fe lv lw lx ly b">case</code>和<code class="fe lv lw lx ly b">default</code>语句块化，这样很明显我们不能访问块外的变量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c34e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在<code class="fe lv lw lx ly b">case</code>和<code class="fe lv lw lx ly b">default</code>语句中添加了花括号来创建块。我们将<code class="fe lv lw lx ly b">z</code>函数切换为函数表达式，因为函数表达式不应该在块内。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0fcb" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">不要在构造函数中返回值</h1><p id="f24c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果我们在块中返回值，可能是错误的。如果我们在构造函数中有一个<code class="fe lv lw lx ly b">return</code>语句，它将返回那个值而不是类实例。</p><p id="9c5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="77ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么<code class="fe lv lw lx ly b">foo</code>就是<code class="fe lv lw lx ly b">{foo: “bar”}</code>。即使我们将<code class="fe lv lw lx ly b">this.baz</code>设置为一个值，它也不会在<code class="fe lv lw lx ly b">foo</code>中显示出来。</p><p id="766c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能是一个错误，因为我们可能想获得<code class="fe lv lw lx ly b">Foo</code>实例，而不是作为<code class="fe lv lw lx ly b">foo</code>的值在构造函数中返回的对象。</p><p id="b8aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们应该写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="88c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们看到<code class="fe lv lw lx ly b">foo</code>的值是<code class="fe lv lw lx ly b">{baz: “baz”}</code>，正如我们所料。</p><p id="89c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们仍然可以使用<code class="fe lv lw lx ly b">return</code>进行如下流量控制:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bde4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">没有看起来像除法的正则表达式</h1><p id="41ab" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">看起来像除法的正则表达式是不明确的。看起来我们试图做除法，但实际上我们试图定义一个正则表达式。</p><p id="e877" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，不写:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="bcad" class="nj mh it ly b gy nk nl l nm nn">const regex = /=bar/;</span></pre><p id="817f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该写:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="fbca" class="nj mh it ly b gy nk nl l nm nn">const regex = /[=]bar/;</span></pre><p id="f46e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们做同样的事情，但是当我们实际定义一个正则表达式时，看起来不像是在做除法。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9a1e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">else块内没有返回</h1><p id="9006" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在<code class="fe lv lw lx ly b">else</code>模块中添加<code class="fe lv lw lx ly b">return</code>是多余的。这是因为如果上述<code class="fe lv lw lx ly b">if</code>块中的条件为<code class="fe lv lw lx ly b">false</code>，则<code class="fe lv lw lx ly b">else</code>块中的<code class="fe lv lw lx ly b">return</code>语句总是运行。</p><p id="d1a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0b79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使我们没有<code class="fe lv lw lx ly b">else</code>块，它也会运行。因此，我们不需要<code class="fe lv lw lx ly b">else</code>块。</p><p id="10cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以如下消除<code class="fe lv lw lx ly b">else</code>块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e60c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它做同样的事情，但是没有<code class="fe lv lw lx ly b">else</code>块。由于<code class="fe lv lw lx ly b">x</code>为<code class="fe lv lw lx ly b">false</code>，所以<code class="fe lv lw lx ly b">if</code>块不运行，而<code class="fe lv lw lx ly b">return 'bar'</code>运行。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f036" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="a9af" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">概括一下:</p><ul class=""><li id="fa2d" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">如果我们不将<code class="fe lv lw lx ly b">switch</code>中的声明转换成块，就可以在<code class="fe lv lw lx ly b">case</code>或<code class="fe lv lw lx ly b">default</code>语句之外访问它们，所以我们应该将<code class="fe lv lw lx ly b">case</code>和<code class="fe lv lw lx ly b">default</code>语句转换成块，以消除任何混淆。</li><li id="c7a1" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">在JavaScript类的<code class="fe lv lw lx ly b">constructor</code>中返回值将在<code class="fe lv lw lx ly b">return</code>语句中返回，而不是在类实例中。所以退东西很可能是个错误。</li><li id="75a0" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">应该改变看起来像除法的正则表达式，使它看起来不像除法，这样每个人都清楚这是正则表达式而不是除法。</li><li id="4fac" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">最后，<code class="fe lv lw lx ly b">else</code>块中的<code class="fe lv lw lx ly b">return</code>语句是多余的，因为如果上面的<code class="fe lv lw lx ly b">if</code>块中的条件是<code class="fe lv lw lx ly b">false</code>，那么<code class="fe lv lw lx ly b">return</code>语句将会运行。</li></ul></div></div>    
</body>
</html>