<html>
<head>
<title>Build a To-Do App Using React With Drag-and-Drop Functionality</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用带有拖放功能的React创建待办事项应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-to-do-app-using-react-with-drag-and-drop-functionality-954080ee9644?source=collection_archive---------2-----------------------#2021-08-25">https://betterprogramming.pub/build-a-to-do-app-using-react-with-drag-and-drop-functionality-954080ee9644?source=collection_archive---------2-----------------------#2021-08-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="06b9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在react应用程序中集成react-beautiful-dnd</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e4ec24dff2a22b13a868c340ff66897b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*21VBBno-8v55-iQL"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://unsplash.com/@anete_lusina" rel="noopener ugc nofollow" target="_blank">安内特Lūsiņa </a> on <a class="ae ky" href="http://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="0d44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">待办应用无处不在。它们帮助人们变得有条理，并记录他们一天中的任务。这些应用程序也很容易构建。正因为如此，大量的教程可以帮助你使用React库来构建它们。</p><p id="d2c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，更高级的待办事项应用程序允许您重新排列列表中的项目。这使得用户可以按照重要性来组织他们的任务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/f78e76c21233c54053d243079501bc32.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*DPybq06UJy9hrAmqpWuwwA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://codepen.io/florantara/pen/jjyJrZ" rel="noopener ugc nofollow" target="_blank">带React挂钩的拖放列表</a></p></figure><p id="e15e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要实现这一点，您需要做的是:</p><ul class=""><li id="35a0" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API" rel="noopener ugc nofollow" target="_blank"> HTML拖放API </a>使我们的列表可拖动。</li><li id="f818" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">检测用户何时拖动并显示适当的动画。</li><li id="23f0" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">检查用户是否已经停止拖动。如果是这样，也在这里显示一个动画。</li><li id="2b00" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">如果客户已经重新排列了他们的列表，将项目的位置更新到新的位置。</li></ul><p id="be3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，这不是一个小壮举。此外，<a class="ae ky" href="https://www.quirksmode.org/blog/archives/2009/09/the_html5_drag.html" rel="noopener ugc nofollow" target="_blank"> HTML的拖放也是不一致的</a>，因此让你的应用程序感觉很简单。</p><p id="cb29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<code class="fe mk ml mm mn b">react-beautiful-dnd</code>的用武之地。这是一个开源库，可以帮助开发人员在很短的时间内构建流畅的可拖动列表。此外，它有内置的动画，使拖动事件感觉更自然，几乎没有性能成本。</p><p id="ff60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然说了它的优点，那就开始吧！</p><p id="ff65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将构建一个具有拖放功能的待办事项列表项目。这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/e86abb55ef295411ac442dfcba42ab9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*OxZMpLjks-YaBKZL0yfFUA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">本文的结果</p></figure><h1 id="580f" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">项目设置</h1><h2 id="320a" class="ng mp it bd mq nh ni dn mu nj nk dp my li nl nm na lm nn no nc lq np nq ne nr bi translated">创建React存储库</h2><p id="eb58" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">要搭建React项目，请运行以下终端命令:</p><pre class="kj kk kl km gt nx mn ny nz aw oa bi"><span id="633c" class="ng mp it mn b gy ob oc l od oe">npx create-react-app todo-list-tutorial</span></pre><h2 id="f576" class="ng mp it bd mq nh ni dn mu nj nk dp my li nl nm na lm nn no nc lq np nq ne nr bi translated">安装依赖项</h2><p id="4fb7" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">对于我们的项目，我们需要以下模块:</p><ul class=""><li id="baaa" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><code class="fe mk ml mm mn b">react-beautiful-dnd</code>:我们节目的主旨。这个软件包将把我们枯燥的列表变成一个更好看的具有拖放功能的列表。</li><li id="8516" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe mk ml mm mn b">react-hook-form</code>:我们将使用一个表单来获取用户的输入。<code class="fe mk ml mm mn b">react-hook-form</code>包将帮助我们做到这一点。</li><li id="bc61" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe mk ml mm mn b">nanoid</code>:这个模块会给列表项分配id。</li></ul><p id="795b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要安装这些软件包，请运行以下终端命令:</p><pre class="kj kk kl km gt nx mn ny nz aw oa bi"><span id="bf2d" class="ng mp it mn b gy ob oc l od oe">npm i react-beautiful-dnd react-hook-form nanoid</span></pre><p id="327a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成这些后，就该构建我们的应用程序了。</p><h1 id="e2dc" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">构建我们的待办事项列表</h1><h2 id="6921" class="ng mp it bd mq nh ni dn mu nj nk dp my li nl nm na lm nn no nc lq np nq ne nr bi translated">创建上下文提供者</h2><p id="71b1" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">在本文中，我们将使用React钩子来存储待办事项列表的数据。因为我们希望在多个组件之间共享这个钩子，所以我们将使用<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/reacts-context-api-explained-baebcee39d2f"> React的上下文API </a>。这样可以防止React的道具钻问题。</p><p id="a25e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于支柱钻探的知识，<a class="ae ky" href="https://codeburst.io/react-anti-pattern-prop-drilling-54474d5236bd" rel="noopener" target="_blank">看看这篇由<a class="of og ep" href="https://medium.com/u/f3735d32c677?source=post_page-----954080ee9644--------------------------------" rel="noopener" target="_blank">约翰·塔克</a>写的文章</a>。</p><p id="4602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在项目目录的根目录下，创建一个名为<code class="fe mk ml mm mn b">MyContext.js</code>的文件。在这里，编写以下代码块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="cc3e" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">第4行:创建一个<code class="fe mk ml mm mn b">Context</code>对象。我们将使用它的<code class="fe mk ml mm mn b">Provider</code>组件在我们的React元素之间共享我们的<code class="fe mk ml mm mn b">data</code>钩子。</li><li id="dd61" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第8–10行:如果程序检测到<code class="fe mk ml mm mn b">data</code>的变化，输出其当前值。</li><li id="e352" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第12–14行:将<code class="fe mk ml mm mn b">data</code>和<code class="fe mk ml mm mn b">setData</code>钩子共享给<code class="fe mk ml mm mn b">DataList</code>组件的子组件。</li></ul><h2 id="a8eb" class="ng mp it bd mq nh ni dn mu nj nk dp my li nl nm na lm nn no nc lq np nq ne nr bi translated">向列表添加项目</h2><p id="a3c1" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">在本节中，我们将创建一个自定义组件，让用户可以向他们的列表中添加项目。</p><p id="ca41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，创建一个名为<code class="fe mk ml mm mn b">Form.js</code>的文件。这里，从编写以下代码开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="f268" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">线6:从<code class="fe mk ml mm mn b">MyContext.js</code>收回<code class="fe mk ml mm mn b">data</code>和<code class="fe mk ml mm mn b">setData</code>吊钩。</li><li id="b989" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第11行:当用户提交表单时，React将调用<code class="fe mk ml mm mn b">onSubmit</code>函数。这将向<code class="fe mk ml mm mn b">data</code>数组添加一个新项目。这里，我们捕获了<code class="fe mk ml mm mn b">name</code>字段的值。</li></ul><p id="a09a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们呈现这个组件的UI。在同一文件中追加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="bf74" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">第3行:将<code class="fe mk ml mm mn b">onSubmit</code>方法作为处理程序分配给我们的表单。</li><li id="b77b" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第6行:这个文本字段将捕获用户对<code class="fe mk ml mm mn b">name</code>属性的输入。</li></ul><p id="a091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们剩下的就是渲染它。转到<code class="fe mk ml mm mn b">App.js</code>，编辑<code class="fe mk ml mm mn b">return</code>块，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="a3be" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">第4行:我们的<code class="fe mk ml mm mn b">Form</code>组件是<code class="fe mk ml mm mn b">DataList</code>的子组件。这意味着<code class="fe mk ml mm mn b">Form</code>现在可以访问<code class="fe mk ml mm mn b">DataList</code>中的<code class="fe mk ml mm mn b">data</code>钩子。</li></ul><p id="b5ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/6796c41d9dd22a10b2e3fc503eeaf873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*wp0LwGZggkjvuKEbxHGdmg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="30b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，这意味着<code class="fe mk ml mm mn b">Form</code>正在毫无问题地更新<code class="fe mk ml mm mn b">data</code>！</p><h2 id="f596" class="ng mp it bd mq nh ni dn mu nj nk dp my li nl nm na lm nn no nc lq np nq ne nr bi translated">显示列表</h2><p id="3ec5" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">在本节中，我们将编写一个组件，将客户端的任务呈现到屏幕上。</p><p id="20e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，创建一个名为<code class="fe mk ml mm mn b">ToDoList.js</code>的文件，并编写以下启动代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="5ac0" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">第8行:<code class="fe mk ml mm mn b">deleteItem</code>方法接受一个<code class="fe mk ml mm mn b">id</code>参数。这将是我们要删除的任务的ID。</li><li id="0198" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第9行:使用<code class="fe mk ml mm mn b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">filter</a></code>方法删除选中的任务。</li></ul><p id="059a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二步，将这个片段添加到<code class="fe mk ml mm mn b">ToDoList.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="44cf" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">第4行:<code class="fe mk ml mm mn b">index</code>变量代表渲染项的当前索引。</li><li id="a5ae" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第9行:单击时，调用<code class="fe mk ml mm mn b">deleteItem</code>方法，并将ID作为参数发送。这将删除选定的项目。</li></ul><p id="ee68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩下的工作就是在屏幕上显示这个定制组件。为此，导航至<code class="fe mk ml mm mn b">App.js</code>并更改其<code class="fe mk ml mm mn b">return</code>块，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="81ff" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">第4行:<code class="fe mk ml mm mn b">DataList</code>现在是<code class="fe mk ml mm mn b">ToDoList</code>的父级。这意味着像<code class="fe mk ml mm mn b">Form</code>，<code class="fe mk ml mm mn b">ToDoList.js</code>也可以使用<code class="fe mk ml mm mn b">DataList's</code>共享钩子。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/1e2162e0a858c91eee5249aa5335a87e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*hwYh76VZaSTbFDQT_d-OwQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="49c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！我们现在已经建立了我们的待办事项应用程序。</p><p id="13bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文的下一部分，我们将通过添加拖放功能来扩展它。</p><h1 id="cd5a" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">实现拖放</h1><h2 id="e80c" class="ng mp it bd mq nh ni dn mu nj nk dp my li nl nm na lm nn no nc lq np nq ne nr bi translated">改变我们的ToDoList组件</h2><p id="426a" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">在本文的这一部分，我们将编写允许用户拖动列表项的代码。</p><p id="4940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到<code class="fe mk ml mm mn b">ToDoList.js</code>，像这样更换<code class="fe mk ml mm mn b">return</code>块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="e970" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码乍一看可能令人望而生畏，但是很容易理解。下面是细目分类:</p><ul class=""><li id="eae4" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">第3行和第33行:<code class="fe mk ml mm mn b">DragAndDropContext</code>组件告诉React我们的<code class="fe mk ml mm mn b">ToDoList</code>组件将启用拖动。</li><li id="88ad" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第4行和第32行:<code class="fe mk ml mm mn b">Droppable</code>指定用户可以将他们的项目放到<code class="fe mk ml mm mn b">ul</code>元素中。</li><li id="71ce" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第5行:<code class="fe mk ml mm mn b"><a class="ae ky" href="https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/droppable.md#1-provided-droppableprovided" rel="noopener ugc nofollow" target="_blank">provided</a></code> <a class="ae ky" href="https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/droppable.md#1-provided-droppableprovided" rel="noopener ugc nofollow" target="_blank">对象</a>包含用于样式和查找的道具。</li><li id="0a74" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第8行和第27行:<code class="fe mk ml mm mn b">Draggable</code>元素通知React用户可以拖动<code class="fe mk ml mm mn b">li</code>元素。</li><li id="97f7" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第20行:如果用户正在拖动元素，将<code class="fe mk ml mm mn b">className</code>属性更改为<code class="fe mk ml mm mn b">selected</code>。稍后我们将使用它来应用样式。</li><li id="b078" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第29行:<code class="fe mk ml mm mn b">placeholder</code>属性在列表中创建了一个空白区域。这样会让拖拽操作感觉很自然。</li></ul><p id="f595" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行代码。这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/b143d62f23f138a78f6b360e06aec397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*0ubPiWxiNoM_ugWhKdn8OQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="13bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们启用拖动功能所需要的一切！但是请注意，我们有一个小问题:即使我们重新排列项目，数组也会恢复到原来的顺序。我们将在下一节中解决这个问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/e94d6d749cd296f9c1a72320cd0e6f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*8tsvI2CQrk95fRuQaF9d0w.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">当前问题</p></figure><h2 id="46db" class="ng mp it bd mq nh ni dn mu nj nk dp my li nl nm na lm nn no nc lq np nq ne nr bi translated">任务顺序的持久性</h2><p id="b44f" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">为了缓解这个问题，我们可以使用<code class="fe mk ml mm mn b"><a class="ae ky" href="https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/responders.md#ondragend-required" rel="noopener ugc nofollow" target="_blank">onDragEnd</a></code> <a class="ae ky" href="https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/responders.md#ondragend-required" rel="noopener ugc nofollow" target="_blank">处理程序</a>。使用这个方法，我们将告诉<code class="fe mk ml mm mn b">react-beautiful-dnd</code>保存刷新的订单。</p><p id="6d1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到<code class="fe mk ml mm mn b">ToDoList.js</code>，添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="cc41" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">第1行:<code class="fe mk ml mm mn b">result</code>参数包含关于拖动事件的信息，比如源项及其目标位置。</li><li id="d8f8" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第7行:将我们的<code class="fe mk ml mm mn b">handleEnd</code>方法传递给<code class="fe mk ml mm mn b">onDragEnd</code> prop。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/8fea9bcc780fa69eb2aa856ac946e941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*U7RZ4fPc_IPtR1hc7TmghQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="9e96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们只关心<code class="fe mk ml mm mn b">source</code>和<code class="fe mk ml mm mn b">destination</code>对象。</p><p id="4589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，像这样改变<code class="fe mk ml mm mn b">handleEnd</code>处理器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="ebe0" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">第2行:将<code class="fe mk ml mm mn b">data</code>钩子转换成数组形式。</li><li id="59ad" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第3行:找到用户拖动的项目。这是源项目。</li><li id="287b" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第4行:将源项的位置更改为它的目标。</li><li id="aad8" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第5行:最后，将这个变异后的数组传递给<code class="fe mk ml mm mn b">data</code>钩子。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/437b5740ecfb01e9eebde93205f23bf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*y5ULMUSsy47FUaf7tOMyVg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="317d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是还有一个问题，如果用户拖动元素但是把它放回原来的位置怎么办？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/1ccc3f712a9a48cbd2c1383e43686eea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*Ja74NTtMOmSwdubl5Qcyfw.gif"/></div></figure><p id="b5e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照<code class="fe mk ml mm mn b">react-beautiful-dnd</code>的说法，这是一个<code class="fe mk ml mm mn b">CANCEL</code>事件。此外，由于<code class="fe mk ml mm mn b">destination</code>属性是<code class="fe mk ml mm mn b">null</code>，我们的程序崩溃了。</p><p id="b4f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止这个错误，将<code class="fe mk ml mm mn b">handleEnd</code>方法修改如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="f43c" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">第3行:检查<code class="fe mk ml mm mn b">destination</code>属性是否为空(发生了一个<code class="fe mk ml mm mn b">CANCEL</code>事件)。如果是，退出该功能。<br/>这将是代码的输出:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/4be079f48d7dae54b2ecc25231539a2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*jEXs-hrNrntTXGQ_vNTfhw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="e81e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧啊。我们有一个功能性的待办事项列表应用程序，具有拖放功能。请注意，我们需要最少的代码来实现这一点。</p><h2 id="3bfc" class="ng mp it bd mq nh ni dn mu nj nk dp my li nl nm na lm nn no nc lq np nq ne nr bi translated">应用样式</h2><p id="4b71" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">在指南的这一部分，我们将通过编写一些CSS代码来使我们的列表看起来更好。</p><p id="136c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的<code class="fe mk ml mm mn b">styles.css</code>文件中，添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="40b0" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">第5–8行:如果元素的类是<code class="fe mk ml mm mn b">not-selected</code>(用户没有拖动项目)，背景颜色将是蓝色。否则颜色会是红色。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/7d8afbc52b4aa6147040c1abbbb3ca5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*JI0qAVdw1FFgtKUxOd8j_Q.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="b4af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们完事了。我们的应用程序现在看起来不错！</p><h1 id="0855" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">额外资源</h1><p id="16e1" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated"><a class="ae ky" href="https://github.com/HussainArif12/dnd-tutorial/tree/main/" rel="noopener ugc nofollow" target="_blank">这里是这个项目</a>的GitHub库。</p><ul class=""><li id="4736" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae ky" href="https://blog.bitsrc.io/implement-better-drag-and-drop-in-your-react-app-beafc4451599" rel="noopener ugc nofollow" target="_blank">通过<a class="of og ep" href="https://medium.com/u/ae259dddfc25?source=post_page-----954080ee9644--------------------------------" rel="noopener" target="_blank"> Rajat S </a>在React应用</a>中实现更好的拖放</li><li id="1232" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=aYZRRyukuIw" rel="noopener ugc nofollow" target="_blank">如何使用React添加拖放功能</a></li><li id="797d" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=Vqa9NMzF3wc" rel="noopener ugc nofollow" target="_blank">构建一个漂亮的、可拖动的看板——log rocket</a></li></ul><h1 id="6f99" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">结论</h1><p id="a881" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">如果您想用拖放功能构建漂亮的列表，不用再找了。会非常适合你的兵工厂。它易于使用，并在引擎盖下进行了性能优化。这确保了你的应用保持可靠和快捷。</p><p id="fc29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢您的阅读！编码快乐！</p></div></div>    
</body>
</html>