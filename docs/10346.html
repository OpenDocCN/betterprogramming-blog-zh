<html>
<head>
<title>Determine the Contents of a Zip File Without Downloading It</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无需下载即可确定Zip文件的内容</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-know-zip-content-without-downloading-it-87a5b30be20a?source=collection_archive---------1-----------------------#2021-12-30">https://betterprogramming.pub/how-to-know-zip-content-without-downloading-it-87a5b30be20a?source=collection_archive---------1-----------------------#2021-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7755" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">下载之前有可能知道ZIP文件内容吗？只需52行代码，奇迹就能发生！🔮</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/84f5c4796d48eff81d7042b7c311c588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukyRBqKOSWUN4VScQ6PFPA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ZIP文件格式具有明确定义的结构(在<a class="ae kv" href="https://unsplash.com/@brlimaproj" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/photos/Z19vToWBDIc" rel="noopener ugc nofollow" target="_blank">图片</a></p></figure><p id="32f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们想象以下场景:</p><blockquote class="ls lt lu"><p id="7a65" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">不久前，你清理了笔记本电脑硬盘上的一些空间，并上传了三个大的ZIP文件到云端(每个都是8 GB)。现在你想看你最喜欢的电影，你知道它在上传的档案之一。但你正在度假，使用手机传输数据，所以你的连接速度很慢，当你超过10 GB的传输量时，你需要支付额外的费用。这三个文件分别叫做:<code class="fe lz ma mb mc b">backup1.zip</code>、<code class="fe lz ma mb mc b">backup2.zip</code>、<code class="fe lz ma mb mc b">backup3.zip</code>。你应该下载哪一个？</p></blockquote><p id="ed40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您对如何解决这样的问题感到好奇，并且想了解一些关于AWS、ZIP文件格式和HTTP请求的知识，请继续阅读！</p><h1 id="a5fc" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">亚马逊网络服务(AWS)</h1><p id="160f" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">无服务器是一项真正伟大的技术。它允许我们编写和部署可执行代码，而不必处理底层基础设施的所有问题。</p><p id="5cb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，您将学习如何利用AWS提供的两种无服务器服务:S3和Lambda。</p><ul class=""><li id="d1ff" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><strong class="ky ir">亚马逊</strong> <strong class="ky ir">简单存储服务</strong>(亚马逊S3)——一种为从任何地方检索任何数据而构建的对象存储服务，</li><li id="0580" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><strong class="ky ir"> AWS </strong> <strong class="ky ir"> Lambda </strong> —运行代码的事件驱动计算服务。</li></ul><p id="6ec1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两种服务都是无服务器的，这意味着你甚至不必考虑服务器或集群，因为一切都由AWS ☁️管理</p><h1 id="9883" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">HTTP头方法</h1><p id="ff7d" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我打赌你已经知道一些HTTP请求方法，比如:</p><ul class=""><li id="f97f" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">得到，</li><li id="7ccc" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">帖子，</li><li id="c7a6" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">放，</li><li id="0c23" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">删除。</li></ul><p id="c52c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是你听说过HTTP <code class="fe lz ma mb mc b">HEAD</code>方法吗？它的功能与<code class="fe lz ma mb mc b">GET</code>基本相同，但并没有真正下载数据。更具体地说，让我们看看<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD" rel="noopener ugc nofollow" target="_blank"> MDN Web文档</a>:</p><blockquote class="ls lt lu"><p id="f873" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">如果用HTTP <code class="fe lz ma mb mc b">GET</code>方法请求了<code class="fe lz ma mb mc b">HEAD</code>请求的URL，HTTP <code class="fe lz ma mb mc b">HEAD</code>方法请求返回的头。</p></blockquote><p id="d9c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，如果您执行一个<code class="fe lz ma mb mc b">HEAD</code>请求，您只会收到响应头。其中一个头是<code class="fe lz ma mb mc b">Content-Length</code>头，它指示消息体的大小。</p><h1 id="af1f" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">HTTP范围请求标头</h1><p id="5414" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">您已经了解了<code class="fe lz ma mb mc b">HEAD</code>请求方法，但是还有一些关于众所周知的<code class="fe lz ma mb mc b">GET</code>方法的新东西——一个<code class="fe lz ma mb mc b">Range</code> HTTP请求头。</p><p id="5b58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个请求头指示服务器应该返回的文档部分。例如，您可以发送一个带有标题<code class="fe lz ma mb mc b">Range: bytes=100–199</code>的<code class="fe lz ma mb mc b">GET</code>请求，并从给定的请求范围接收字节(在这种情况下，您将获得100个字节，从文件的第100个字节开始)。</p><h1 id="9a65" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">ZIP文件格式</h1><p id="5d15" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">ZIP是一种存档文件格式。<a class="ae kv" href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT" rel="noopener ugc nofollow" target="_blank">这里的</a>是一个全面的规范。ZIP文件格式。该规范非常专业——我读过，所以你不必看。</p><p id="4064" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就我们的目的而言，知道ZIP文件具有定义良好的结构就足够了。每个ZIP文件都由一个<code class="fe lz ma mb mc b">end of central directory record</code> (EOCD记录)正确识别。EOCD记录位于档案结构的末尾。ZIP文件还包含一个<code class="fe lz ma mb mc b">central directory entry</code> (CD条目)，它指定了归档中每个文件或目录的名称，以及关于条目的其他元数据，还有一个指向实际条目数据的偏移量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/9371f54066ed615eef0fc53580d7226e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mkE7M0D22y4r-ridA1GHhg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ZIP-64内部布局(<a class="ae kv" href="https://en.wikipedia.org/wiki/ZIP_(file_format)?oldformat=true" rel="noopener ugc nofollow" target="_blank">维基百科</a>)</p></figure><p id="0ff7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">标准的ZIP文件格式有4 GB的限制。如果一个文件的大小超过4 GB，它会以较新版本的ZIP文件格式存档— <code class="fe lz ma mb mc b">ZIP64</code>。在格式上有一些不同，对我们来说最重要的是额外的ZIP64 EOCD记录和定位器:</p><pre class="kg kh ki kj gt np mc nq nr aw ns bi"><span id="5e42" class="nt me iq mc b gy nu nv l nw nx">[local file header 1..n]<br/>[encryption header 1..n]<br/>[file data 1..n]<br/>[data descriptor 1..n]<br/>...<br/>[<strong class="mc ir">central directory</strong> header 1..n]<br/>[<strong class="mc ir">zip64</strong> end of central directory record]<br/>[<strong class="mc ir">zip64</strong> end of central directory locator] <br/>[<strong class="mc ir">end of central directory record</strong>]</span></pre><p id="56ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理解算法所需的理论终于结束了🎉</p><h1 id="0f3c" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated"><strong class="ak">算法</strong></h1><ol class=""><li id="2295" class="na nb iq ky b kz mv lc mw lf ny lj nz ln oa lr ob ng nh ni bi translated">首先，你需要知道文件的大小。它可以通过发送一个<code class="fe lz ma mb mc b">HEAD</code>请求并读取<code class="fe lz ma mb mc b">Content-Length</code>响应头来获得。</li><li id="5b05" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr ob ng nh ni bi translated">然后，您可以通过发送带有<code class="fe lz ma mb mc b">Range</code>请求头的<code class="fe lz ma mb mc b">GET</code>请求来获取EOCD记录。EOCD总是位于ZIP文件的末尾，有22个字节。</li><li id="bf4c" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr ob ng nh ni bi translated">从EOCD唱片公司你可以得到CD元数据。所需的信息是CD的大小和到其开始位置的偏移量。它们总是取12到20的字节。至于EOCD，你可以用指定的<code class="fe lz ma mb mc b">Range</code>发送一个<code class="fe lz ma mb mc b">GET</code>请求。不要忘记解析接收到的数据，因为根据规范<em class="lv">“所有值必须存储在小端字节中”</em>，但是您需要一个<code class="fe lz ma mb mc b">int</code>。</li></ol><pre class="kg kh ki kj gt np mc nq nr aw ns bi"><span id="f46d" class="nt me iq mc b gy nu nv l nw nx"><strong class="mc ir">Offset | Bytes | Description</strong><br/>12     | 4     | Size of central directory<br/>16     | 4     | Offset of start of CD, relative to start of archive</span></pre><p id="c8e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.有了CD元数据(它的开始和大小)，您可以获取CD本身。同样，这可以通过发送一个带有<code class="fe lz ma mb mc b">Range</code>请求头的<code class="fe lz ma mb mc b">GET</code>请求来完成。</p><p id="6166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">5.在倒数第二步中，您可以简单地读取字节流。CD和EOCD是一个接一个直接定位的，所以同时拥有它们允许读取字节块。</p><p id="1444" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">6.最后，还有最后一招。CD+EOCD字节可以作为ZIP文件打开。有了它，你可以做任何事情，例如，迭代文件列表中的文件并打印所有文件名。</p><h2 id="eda2" class="nt me iq bd mf oc od dn mj oe of dp mn lf og oh mp lj oi oj mr ln ok ol mt om bi translated">ZIP64</h2><p id="95bf" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">如前所述，ZIP和ZIP64的结构有点不同。对于后一种情况，算法看起来也是一样的。唯一的区别是你需要获取一个额外的ZIP64 EOCD记录和一个ZIP64 EOCD定位器。然后四个字节块(CD+EOCD64记录+EOCD64定位器+EOCD)可以被读取并作为ZIP文件打开。</p><pre class="kg kh ki kj gt np mc nq nr aw ns bi"><span id="69fa" class="nt me iq mc b gy nu nv l nw nx"><strong class="mc ir">Offset | Bytes | Description</strong><br/>40     | 8     | Size of central directory<br/>48     | 8     | Offset of start of CD, relative to start of archive</span></pre><h1 id="4b99" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">密码</h1><p id="d094" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">下面，您可以找到一个无需下载完整文件即可打印ZIP文件内容的代码的工作示例。</p><p id="3b28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下代码适用于位于S3存储桶中的文件。Lambda函数在S3事件通知时被调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="10c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打印完所有文件后，你可以找到你最喜欢的电影，只下载一个ZIP文件，100%确定你选择了正确的存档！</p><h1 id="c20f" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">摘要</h1><p id="6c90" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在本文中，我向您展示了在不下载的情况下列出ZIP文件内容的方法。通过使用HTTP请求方法和头，并了解ZIP文件格式结构，这是可能的。</p></div></div>    
</body>
</html>