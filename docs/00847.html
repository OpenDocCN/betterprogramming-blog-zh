<html>
<head>
<title>Functional JS from Α to Ω: forEach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从α到ω的泛函JS:forEach</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-js-from-%CE%B1-to-%CF%89-8dc0cfe1f4e1?source=collection_archive---------4-----------------------#2019-07-21">https://betterprogramming.pub/functional-js-from-%CE%B1-to-%CF%89-8dc0cfe1f4e1?source=collection_archive---------4-----------------------#2019-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1585" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">[α]使用forEach作为跳板来理解函数式编程</h2></div><blockquote class="ki"><p id="551b" class="kj kk it bd kl km kn ko kp kq kr ks dk translated">我们通过构建适当隐藏细节的抽象来控制复杂性。</p><p id="75f4" class="kj kk it bd kl km kt ku kv kw kx ks dk translated">–SICP，1979年</p></blockquote><figure class="kz la lb lc ld le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ky"><img src="../Images/c7ba18dd5490d0267c334e947ef502f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dc82B7asMgTeeRh8ReP2Mg.jpeg"/></div></div><p class="ll lm gj gh gi ln lo bd b be z dk translated">JR Korpa 在<a class="ae lp" href="https://unsplash.com/search/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&amp;source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的<a class="ae lp" href="https://unsplash.com/@korpa" rel="noopener ugc nofollow" target="_blank"/></p></figure><blockquote class="lq lr ls"><p id="d964" class="lt lu lv lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo ks im bi translated">我们JavaScript编码人员有机会实践一种支持函数式编程的多范例语言。</p><p id="807f" class="lt lu lv lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo ks im bi translated">你想学习那种力量吗？</p><p id="adb7" class="lt lu lv lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo ks im bi translated">让我们从24课开始，从α到ω，解决我们的日常问题。课程概述:<a class="ae lp" href="https://medium.com/better-programming/functional-js-from-%CE%B1-to-%CF%89-8dc0cfe1f4e1" rel="noopener"> α。forEach </a>，<a class="ae lp" href="https://medium.com/better-programming/functional-js-from-%CE%B1-to-%CF%89-map-9173adf7ea3" rel="noopener"> β。地图</a>，γ.滤镜。</p></blockquote></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="fdcd" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">简单的列表迭代</h1><p id="0e77" class="pw-post-body-paragraph lt lu it lw b lx no ju lz ma np jx mc nq nr mf mg ns nt mj mk nu nv mn mo ks im bi translated">考虑以下数据:字符串列表。</p><figure class="nw nx ny nz gt le"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="f095" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">JavaScript不是强类型的，所以大于<em class="lv"> langs </em>的集合可能会有问题。让我们假装关心，迭代它，并检查控制台，看看我们得到了什么。</p><p id="a8ed" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">从我们开始编程的第一天起，我们就学会了如何做到这一点。</p><figure class="nw nx ny nz gt le"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="12f7" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">对我们来说，它看起来像是非常易懂的代码。但真的是这样吗？</p><p id="aff2" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">这是一种<em class="lv">命令式</em> <strong class="lw iu"> </strong>方法，因为它描述了计算机应该如何迭代，而不是人类如何思考迭代。</p><p id="5f90" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">它不像一个<code class="fe oc od oe of b">if</code>和一个<code class="fe oc od oe of b">goto</code>结合在一起那么必要，但仍然如此。</p><p id="76ca" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">而且这段代码还包含其他几个固有的缺陷:</p><ul class=""><li id="f80f" class="og oh it lw b lx ly ma mb nq oi ns oj nu ok ks ol om on oo bi translated">它不可重用/不干燥(我们必须为每个类似的情况重写所有这些)。</li><li id="6e03" class="og oh it lw b lx op ma oq nq or ns os nu ot ks ol om on oo bi translated">不可分解，不可重组，因为它是一个程序代码块</li><li id="fe12" class="og oh it lw b lx op ma oq nq or ns os nu ot ks ol om on oo bi translated">不容易维护:错别字可以藏在这里，如果在循环过程中有什么东西改变了<em class="lv"> i </em>的值怎么办？这可能会导致错误。</li><li id="c4fc" class="og oh it lw b lx op ma oq nq or ns os nu ot ks ol om on oo bi translated">扩展性不好，因为嵌套的<code class="fe oc od oe of b">for</code>循环让程序员抓狂</li></ul></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="ad48" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">句法糖</h1><p id="9324" class="pw-post-body-paragraph lt lu it lw b lx no ju lz ma np jx mc nq nr mf mg ns nt mj mk nu nv mn mo ks im bi translated">感谢编码器友好的ES6，我们现在有一些语法上的好处来编写它，而不用声明一个额外的变量作为计数器。</p><figure class="nw nx ny nz gt le"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="26ea" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">好吧，这更像是<em class="lv">声明性的</em>:一个非程序员可能理解这段代码，只是从左到右阅读。</p><p id="19aa" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">可维护性和可伸缩性也有所提高……但仅限于较低的复杂程度。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="29ca" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">古老而珍贵</h1><p id="f5e5" class="pw-post-body-paragraph lt lu it lw b lx no ju lz ma np jx mc nq nr mf mg ns nt mj mk nu nv mn mo ks im bi translated">在ES6之前五年，JavaScript就已经指定了一个有用的工具:<code class="fe oc od oe of b">forEach</code>。</p><p id="1017" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated"><code class="fe oc od oe of b">forEach</code>不是本机控制结构，也不是保留关键字。这是一个数组方法，可以通过任何数组执行，甚至是空数组。</p><figure class="nw nx ny nz gt le"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="6a16" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">前面的例子会导致错误，因为<code class="fe oc od oe of b">forEach</code>有一个参数。</p><p id="e8f9" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">但不是简单随机的参数:它把一个函数作为参数。</p><figure class="nw nx ny nz gt le"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="d3bc" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">记住在JS中，函数是一等公民。</p><p id="1932" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">这并不意味着函数是特殊的——事实上，正相反。在JS中，函数就像所有其他的值(objects，或primitives boolean，number &amp; string):我们可以把它们放在变量中，组合它们，作为参数传递它们，返回它们，等等。(在Haskell中，甚至像<code class="fe oc od oe of b">+</code>这样的操作符也可以作为参数传递！)</p><p id="c37f" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated"><code class="fe oc od oe of b">forEach</code> <em class="lv"> </em>就是函数式程序员所说的<em class="lv">高阶函数</em>。也没什么复杂的；它只是一个负责运行或返回其他函数的函数。</p><figure class="nw nx ny nz gt le"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="c317" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">所以<code class="fe oc od oe of b">forEach</code> <em class="lv"> </em>不是魔法；它采用一个声明的函数(未执行！)，但署名如下:<code class="fe oc od oe of b">(any) -&gt; void</code>。它会将这个给定的函数连续应用到数组中的每个元素。</p><p id="5016" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">这个<code class="fe oc od oe of b">any</code> <em class="lv"> </em>参数代表在迭代中替换当前元素，而<code class="fe oc od oe of b">void</code> <em class="lv"> </em>告诉我们这个函数不应该返回任何东西。</p><figure class="nw nx ny nz gt le"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0079" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">前面的代码只是为数组中的每种语言弹出一个警告“hi <language>”。所以现在我们可以用我们所知道的来解决我们的问题。</language></p><figure class="nw nx ny nz gt le"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="7196" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">但是等等。</p><p id="7ee3" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated"><code class="fe oc od oe of b">console.log</code>是函数吗？是的。</p><p id="5004" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated"><code class="fe oc od oe of b">console.log</code> <em class="lv"> </em>有<code class="fe oc od oe of b">(any) -&gt; void</code>签名吗？算是吧。</p><p id="61df" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">那么两者之间有什么区别呢</p><figure class="nw nx ny nz gt le"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0f27" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">简单地说</p><figure class="nw nx ny nz gt le"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0716" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi">?</p><p id="2269" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">看不出任何区别:包裹功能只是噪音污染，所以…⁴</p><figure class="nw nx ny nz gt le"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="4b76" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">哦…是的…听起来很奇怪，但是…某种程度上更清楚。</p><p id="2e86" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">难道是… <strong class="lw iu">那个</strong>？我们现在在做真正的FP吗？</p><p id="e8f1" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">不是，只是这个“从A到ω”系列的#A。真实的FP世界是非常严格的，因为它倾向于只允许可证明的程序和受控的副作用。如果你想达到这个理想，你必须遵循一些规则。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="63cb" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">纯函数和不变性</h1><p id="6e21" class="pw-post-body-paragraph lt lu it lw b lx no ju lz ma np jx mc nq nr mf mg ns nt mj mk nu nv mn mo ks im bi translated">如果后面的都不明白，也不要慌。我们将一集一集地深入探讨这一切。试着熟悉一下内容就好了。</p><p id="6c8d" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">你还记得我们可以传递给<code class="fe oc od oe of b">forEach</code>方法的函数的签名吗？是一个不返回任何东西的函数(JS中所谓的“未定义”)，或者是类型化世界中的<code class="fe oc od oe of b">void</code> <em class="lv"> </em>。而<code class="fe oc od oe of b">forEach</code> <em class="lv"> </em>本身也是一个返回<code class="fe oc od oe of b">undefined</code> <em class="lv"> </em>的方法。</p><p id="0456" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">这是带有副作用的函数的明显症状。如果它没有返回任何东西，那么它应该在return语句之前，在其他地方做一些影响程序的事情。比如改变某个全局变量的值，或者改变数组本身。</p><p id="2ab7" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">总有一天我们会忘记的事情。而且肯定会导致bug。总之，它不受控制，而函数式程序员是控制狂。他们总是想知道自己在做什么，甚至想知道为什么。</p><p id="cf14" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated"><code class="fe oc od oe of b">forEach</code> <em class="lv"> </em>比<code class="fe oc od oe of b">for</code> <em class="lv"> … </em> <code class="fe oc od oe of b">of</code>更具组合性，因为它采用了自定义函数，但仍然深深地束缚在数组中。我们不能轻易地将<code class="fe oc od oe of b">forEach</code>本身传递给另一个函数。</p><p id="29e0" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">反正可组合性和可伸缩性也达不到。</p><p id="f7e8" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">所以我们已经知道，如果我们真的想进入FP的世界，我们必须定义我们自己的<code class="fe oc od oe of b">forEach</code>。</p><p id="ad98" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">让我们简单地从在一个全新的函数中隐藏实现细节开始:</p><figure class="nw nx ny nz gt le"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="e40f" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">但是…！这是绝对必要的！你骗了我们，叛徒！</p><p id="5e9a" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">Mmmh，我从没说过原生<code class="fe oc od oe of b">Array.prototype.forEach</code> JS方法是怎么实现的。</p><p id="6d0a" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">是的，也许我因疏忽而撒谎了。但是我们现在有了自己的<code class="fe oc od oe of b">forEach</code>，一旦它完全写好了，我们就再也不会钻研这个函数了。它将是有史以来最完美的<code class="fe oc od oe of b">forEach</code> <em class="lv"> </em>，我们将在30年内照原样使用它。函数只是隐藏命令性的细节，给我们一个声明性的工具。</p><p id="b3d3" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">没有人指望你忘记你在计算机科学中已经学过的所有知识，恰恰相反！</p><p id="f0ef" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">即便如此，也有一种不使用<code class="fe oc od oe of b">for</code>进行迭代的方法。这叫做递归，但那是以后的事，没有TCO它会导致新的问题。⁵</p><p id="0ae6" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">如果你想第一时间看到它，这里有一个例子。</p><figure class="nw nx ny nz gt le"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="b900" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">让我们完成我们的现实世界<code class="fe oc od oe of b">forEach</code>，做一个<em class="lv">纯函数</em>。我们稍后会发现它到底是什么。但是现在，只要记住一个纯粹的函数:</p><ul class=""><li id="d825" class="og oh it lw b lx ly ma mb nq oi ns oj nu ok ks ol om on oo bi translated">应该返回一些东西</li><li id="fe29" class="og oh it lw b lx op ma oq nq or ns os nu ot ks ol om on oo bi translated">不应修改其范围之外的任何内容，即使是作为arguments⁶给出的参考</li></ul><figure class="nw nx ny nz gt le"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="6909" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">哇哦。这个<code class="fe oc od oe of b">forEach</code>在我看来确实更好，用来发现和消灭副作用。</p><p id="864b" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">但是，它显然没有完全解决我们的可维护性/可伸缩性问题。</p><p id="7fd5" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">最近有个朋友想就FP争论一下。他了解关于纯功能需求的一切(控制、TDD、可重用性等。)，但他对不变性的要求感到遗憾。我来问一个问题:如果所有的函数都是纯函数，你的程序只由那些函数组成，你什么时候会面临任何可变性需求？从来没有。纯函数，又名<em class="lv">参照透明</em>，只是从另一个角度看，和不变性是同一个概念。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="9ce9" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">Currying</h1><p id="15a4" class="pw-post-body-paragraph lt lu it lw b lx no ju lz ma np jx mc nq nr mf mg ns nt mj mk nu nv mn mo ks im bi translated">所以让我们从FP世界调用另一个有用的工具:currying。</p><p id="081a" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">因为我们说过函数是一等公民(就像任何其他值一样)，所以我们知道函数可以返回一个函数，并将父变量值包含在其中。</p><figure class="nw nx ny nz gt le"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="5472" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">所以我们最终可以编写一个非常可重用和可组合的<code class="fe oc od oe of b">forEach</code>:</p><figure class="nw nx ny nz gt le"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="b96a" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">注意<code class="fe oc od oe of b">forEach</code> <em class="lv"> </em>参数的新顺序:</p><ul class=""><li id="928c" class="og oh it lw b lx ly ma mb nq oi ns oj nu ok ks ol om on oo bi translated"><code class="fe oc od oe of b">func</code>，这将部分适用</li><li id="1167" class="og oh it lw b lx op ma oq nq or ns os nu ot ks ol om on oo bi translated">然后是阵<code class="fe oc od oe of b">arr</code></li></ul><p id="6036" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">这种新秩序允许我们创造和重用<code class="fe oc od oe of b">logEach</code> <em class="lv"> </em>甚至<code class="fe oc od oe of b">doubleAndLogEach</code>。在未来，它将帮助我们用其他功能编写/管道<code class="fe oc od oe of b">forEach</code> <em class="lv"> </em>。</p><p id="4081" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">由于在JavaScript中，对象是通过reference⁶传递的，所以我们的<code class="fe oc od oe of b">forEach</code> <em class="lv"> </em>仍然有一个很大的缺陷:包含对象的数组仍然暴露在突变中。</p><p id="b148" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">JavaScript既不是静态的，也不是强类型的，所以我们可以不断地将不纯的函数甚至坏的数据类型传递给我们的<code class="fe oc od oe of b">forEach</code>(对于那个特殊的问题，使用类似于<a class="ae lp" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>或<a class="ae lp" href="https://elm-lang.org/" rel="noopener ugc nofollow" target="_blank"> Elm </a>的替代方法可能是唯一的选择)。</p><p id="0ce3" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">所以我们没有达到承诺的完美:你能在评论中提出你的完美<code class="fe oc od oe of b">forEach</code>吗？</p><p id="125c" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">最后一句话，只是为了让你生气。你可能在阅读这篇文章的时候已经发现了:<code class="fe oc od oe of b">forEach</code>的概念本身并不是面向FP的。在它自己的定义中确实暗示了副作用。这就是为什么我们的神圣三位一体不会包含<code class="fe oc od oe of b">forEach</code>，而只有<code class="fe oc od oe of b">map</code>、<code class="fe oc od oe of b">filter</code>、<strong class="lw iu">、</strong>和<code class="fe oc od oe of b">reduce</code>，这一点你会在接下来的文章中看到。</p><p id="7d2f" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">感谢您的宝贵时间！</p><p id="3972" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">[ ]:事实上，它可以选择接受第二个参数:一个用于<code class="fe oc od oe of b">this</code>的上下文值。</p><p id="1aac" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">【】:真正的更像<code class="fe oc od oe of b">(any, number, any[]) -&gt; void</code>，其中数字隐式为当前索引，其中<code class="fe oc od oe of b">any[]</code> <em class="lv"> </em>为调用数组。例如，如果您需要知道当前元素是否是数组中的最后一个元素，这些其他参数可能会很有用。</p><p id="78ee" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">[ ]:除了真正的<code class="fe oc od oe of b">console.log</code>签名接受无限数量的可选参数，用逗号分隔，然后返回false <code class="fe oc od oe of b">(any, …any[]) -&gt; false</code>。</p><p id="59b0" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">[⁴]:事实上，由于签名的不同，<em class="lv"> console.log </em>只会显示更多(参见[ ]和[ ]并跳到结论^^).</p><p id="e5a0" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">【⁵]:尾调用优化的先决条件是使用递归来代替<code class="fe oc od oe of b">for</code> <em class="lv"> </em>循环。使用递归，调用栈可能会增长太多，直到结束用例，而调用栈是有限的。JavaScript中不存在TCO(除了在Node 6中)，所以我们暂时被这些循环卡住了。</p><p id="7d82" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">[⁶]:在JavaScript中，对象(包括数组)总是通过引用共享，从不复制。如果你对此感到不确定，你必须花些时间去探索。</p></div></div>    
</body>
</html>