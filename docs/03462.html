<html>
<head>
<title>Code Smells in JavaScript Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript类中的代码味道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-code-smells-classes-93f15551fa9a?source=collection_archive---------15-----------------------#2020-02-11">https://betterprogramming.pub/javascript-code-smells-classes-93f15551fa9a?source=collection_archive---------15-----------------------#2020-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="52f9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何去掉无用的代码，让我们的代码结构更简单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/10c11fd47d0c973242bfb458899e1390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NL_x8LuaS_ptXIOv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@richtervet?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Rich Tervet </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="3b63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编程中，代码气味是一段代码的特征，表明可能有更深层次的问题。这是一种主观特征，用于通过查看代码来判断代码是否具有良好的质量。</p><p id="a547" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将看到一些JavaScript类的代码味道，包括懒惰的类，过度使用文字，太多的条件和循环，孤立的变量和常量，以及使用太多的变量而不是对象。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="481e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">懒惰或吃白食类</h1><p id="ee4a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">懒惰或吃白食的类是做得太少的类。如果它没什么用，可能就不应该添加，因为它基本上没什么用。</p><p id="d6cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该想办法把懒惰类中的东西放到有更多东西的地方。只有一两个方法的类可能没什么用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9970" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">文字的过度使用</h1><p id="f8c2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">过多地使用文字不是一个好主意，因为重复使用它们会带来更多出错的机会。这是因为当我们改变代码时，如果它们太多，我们必须改变它们中的每一个。</p><p id="f8c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文字应该外化到它们自己的文件和脚本中。尽可能将更多的动态数据存储在数据库中。如果需要，这使得本地化变得容易。</p><p id="6c81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们需要在代码中的多个位置放置Medium的URL，我们应该在URL中有一个常量，而不是在多个位置重复它。</p><p id="3dbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以与其说:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9332" class="ne md it na b gy nf ng l nh ni">const mediumRequest = fetch('<a class="ae ky" href="http://medium.com'" rel="noopener">http://medium.com'</a>);<br/>//...<br/>const mediumJsUrl = '<a class="ae ky" href="https://medium.com/topic/javascript" rel="noopener">https://medium.com/topic/javascript</a>';</span></pre><p id="fcd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该改为写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e7c2" class="ne md it na b gy nf ng l nh ni">const MEDIUM_URL = '<a class="ae ky" href="http://medium.com'" rel="noopener">http://medium.com'</a>;<br/>const mediumRequest = fetch(MEDIUM_URL)<br/>//.,.<br/>const mediumJsUrl = `${MEDIUM_URL}/topic/javascript`;</span></pre><p id="edb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样更好，因为我们没有在多个地方重复<code class="fe nj nk nl na b"><a class="ae ky" href="https://medium.com/topic/javascript" rel="noopener">https://medium.com</a></code>。做出改变变得更加容易。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="408c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">圈复杂度</h1><p id="2c46" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">圈复杂度意味着我们的代码中有太多的条件语句和循环。</p><p id="bed2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复杂性可能以不同的方式出现。循环和条件可能嵌套太深。两层以上的嵌套可能太多了，很难阅读。</p><p id="c8c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可能有太多没有嵌套的条件和循环。</p><p id="1ece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，不要写成这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="def5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该改为写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0a01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们消除了嵌套，将一些深度嵌套的代码移到了它自己的函数中。这增加了可读性，并且将代码分离到它自己的函数中使得测试更容易。</p><p id="2c87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，除了<code class="fe nj nk nl na b">return</code>之外，使用循环控制语句——如<code class="fe nj nk nl na b">continue</code>和<code class="fe nj nk nl na b">break</code>——有助于控制代码流，而不用在内部嵌套很多行的条件语句。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="977b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">孤立的变量或常量类</h1><p id="5788" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些类拥有一组属于其他地方的常量，而不是属于它们自己的类。</p><p id="e743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这需要改变，因为把它们放在不用的地方是没有意义的。对任何阅读代码的人来说都不直观。</p><p id="b7a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有一个包含以下变量的类，我们有以下几个类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="aa21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么<code class="fe nj nk nl na b">Color</code>类中的<code class="fe nj nk nl na b">'red'</code>更适合于<code class="fe nj nk nl na b">Apple</code>类，因为我们只将它用于<code class="fe nj nk nl na b">Apple</code>实例。</p><p id="e373" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8ecd" class="ne md it na b gy nf ng l nh ni">class Apple {<br/>  constructor() {<br/>    this.color = 'red';<br/>  }<br/>}</span></pre><p id="08e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也不用费心去上<code class="fe nj nk nl na b">Color</code>课。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/c73444315866d1488efbbf968e8e3fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ui3Mltcuzq_GefCJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@dianaspatariu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">戴安娜·斯帕塔留</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7876" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据块</h1><p id="9fea" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">数据块是指在程序的不同部分有太多的变量一起传递的情况。这意味着我们应该将这些组合成它们自己的对象，并一起传递它们。</p><p id="faef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有一堆变量，我们传递给一个函数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="80d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该重写它，这样所有的变量都在一个对象中，并改变函数的签名来接受这个对象。我们可以看到，有六个参数，太多了。在大多数情况下，对于一个函数来说，五个以上的参数可能太多了。</p><p id="e391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们必须写出所有的变量，它们是相关的，所以我们可以将它们分组到字段中，并引用整个对象，而不是单独引用每个变量。</p><p id="dfc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这降低了丢失变量引用的可能性，因为将变量分组到一个对象中意味着我们只需要处理一个变量，而不是六个。</p><p id="b8e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也重复了很多次<code class="fe nj nk nl na b">fruit</code>这个词。</p><p id="5ce6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过编写以下代码来消除所有的重复，并减少我们必须处理的变量和参数的数量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="da8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们只需要处理一个对象和参数，而不是几个变量和参数。这样看起来更舒服，也更有条理。此外，我们很难忘记引用代码中的一些变量，因为我们只需要处理一个变量。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cd4a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="656b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们不应该有做很少或孤立变量和常数的类。此外，太多的循环和条件——尤其是嵌套太深的情况——很难阅读和理解。</p><p id="0894" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有许多相互关联的变量，那么它们应该被分组到对象中，以便于引用和处理。</p></div></div>    
</body>
</html>