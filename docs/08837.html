<html>
<head>
<title>Observer Design Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的观察者设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/observer-design-pattern-in-javascript-c839ee49add4?source=collection_archive---------1-----------------------#2021-06-17">https://betterprogramming.pub/observer-design-pattern-in-javascript-c839ee49add4?source=collection_archive---------1-----------------------#2021-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f096" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于JavaScript中的观察者设计模式，您需要知道的一切</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/94c282497336f23bf823919b9bafb99a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FCBY2rcDIXzSU1uMq8c5lA.png"/></div></div></figure><p id="42cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在使用任何语言时，我们倾向于使用几种可重用的设计解决方案来解决常见的问题。在JavaScript中，我们也混合了定义良好的模式。</p><p id="2988" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">观察者模式就是其中之一。</p><p id="a33a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们将更多地了解JavaScript中的观察者设计模式，并用普通JavaScript实现一个小例子。</p><h1 id="ca5c" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">什么是观察者设计模式？</h1><p id="10c1" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">观察者模式遵循订阅模型，订阅者(通常称为<em class="mn">或<em class="mn">观察者</em>)订阅由发布者(通常称为<em class="mn">或</em> <em class="mn">主体</em>)处理的事件或动作，并在事件或动作发生时得到通知。</em></p><p id="9735" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">主体向所有观察者广播事件或动作的发生。</p><p id="beec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当观察者不再希望收到主题的变更通知时，它会取消订阅该主题，然后该主题会将其从订阅者列表中删除。</p><p id="a4aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">观察者设计模式与发布者/订阅者模式非常相似，只是发布者/订阅者模式也指定了它想要订阅的主题。例如，当检测键盘快捷键时，订阅者可以选择指定它希望在发布者/订阅者模型中收听的组合键。</p><h1 id="b664" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">观察者模式的实现</h1><p id="d0e8" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">作为观察者模式的一个例子，我们将实现一个简单的交互，其中多个元素监听屏幕上的鼠标位置并执行不同的动作。</p><p id="bf70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是我们互动的一个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/fada0f0644aa1474f0620074e2f77e18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YQgn_fI7CgJ9UHoqpsh2OA.gif"/></div></div></figure><p id="1bdd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们实现这个交互之前，让我们分析一下这个例子中鼠标位置改变时发生了什么。</p><ul class=""><li id="69a0" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated">右上角的文本框中的鼠标位置会立即更新。</li><li id="c07f" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated">延迟1秒后，圆圈跟随鼠标的轨迹。</li></ul><p id="8f34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从上面的描述中，我们看到多个组件需要关于同一事物的信息，但是行为不同。</p><p id="008a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从上面的例子中，我们发现<strong class="kw iu">主题</strong>监听窗口上的鼠标事件，并将其转发给任何想要它的人。上例中的<strong class="kw iu">圆圈和</strong>文本框是<strong class="kw iu">观察者</strong>。</p><p id="6ef2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，让我们现在就着手实施它。</p><h2 id="6905" class="nd lr it bd ls ne nf dn lw ng nh dp ma ld ni nj mc lh nk nl me ll nm nn mg no bi translated">第一步。实现一个MousePositionObservable类</h2><p id="7121" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">作为第一步，让我们继续实现<code class="fe np nq nr ns b">MousePositionObservable</code>类。这个类需要做以下事情:</p><ul class=""><li id="73c0" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated">保留一份观察员回电清单。</li><li id="6241" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated">公开一个<code class="fe np nq nr ns b">subscribe</code>方法，观察者将调用该方法来订阅变更。这个函数的返回值必须是一个函数，当这个函数被调用时，它会将<code class="fe np nq nr ns b">callback</code>从<code class="fe np nq nr ns b">subscriptions</code>的集合中移走。</li><li id="15a1" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated">监听<code class="fe np nq nr ns b">mouseMove</code>事件并触发所有订阅回调。</li></ul><p id="e223" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="dbcb" class="nd lr it bd ls ne nf dn lw ng nh dp ma ld ni nj mc lh nk nl me ll nm nn mg no bi translated">第二步。创建HTML元素</h2><p id="3ae9" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们现在为<code class="fe np nq nr ns b">circle</code>和<code class="fe np nq nr ns b">textMessageBox</code>创建HTML元素，并为它们添加样式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="d5cd" class="nd lr it bd ls ne nf dn lw ng nh dp ma ld ni nj mc lh nk nl me ll nm nn mg no bi translated">第三步。添加观察员</h2><p id="b5a0" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">最后一步是创建我们的<code class="fe np nq nr ns b">MousePositionObservable</code>类的一个实例，并向其中添加观察者。</p><p id="b14d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我们将调用类实例上的<code class="fe np nq nr ns b">subscribe</code>方法，并传递一个回调。</p><p id="596c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7a21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们向<code class="fe np nq nr ns b">MousePositionObservable</code>实例添加了两个订阅，每个订阅对应一个需要监听鼠标值的元素。</p><p id="4619" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe np nq nr ns b">circle</code>元素的订阅回调获取DOM元素的引用并更新其<code class="fe np nq nr ns b">tranform</code>属性。transform属性将在可能的情况下使用硬件加速，因此如果元素上还使用了任何动画或过渡，在位置顶部和左侧使用<code class="fe np nq nr ns b">translate()</code>将会看到性能优势。</p><p id="0077" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">元素的订阅回调通过使用属性更新它的HTML内容。</p><blockquote class="nv nw nx"><p id="66f7" class="ku kv mn kw b kx ky ju kz la lb jx lc ny le lf lg nz li lj lk oa lm ln lo lp im bi translated">注意:当您想要取消订阅侦听器时，您所要做的就是存储subscribe函数调用的返回值，并像调用函数一样调用它</p></blockquote><p id="9594" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是我们演示所需的全部内容。</p><p id="97ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在下面的代码栏中查看工作示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob nu l"/></div></figure><h1 id="83fd" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">观察者设计模式的优点和缺点</h1><p id="5efc" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">观察者设计模式为我们提供了以下好处:</p><ul class=""><li id="f246" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated">当我们想要对一个事件执行多个动作时，这是非常有用的。</li><li id="b288" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated">它提供了一种分离功能的方法，同时保持相关对象之间的一致性。</li></ul><p id="6f4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种模式的缺点源于它的优点:</p><ul class=""><li id="18b7" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated">由于观察者设计模式导致松散耦合的代码，有时很难保证应用程序的其他部分正常工作。例如，添加到主题的订阅可能有行为不正确的代码，但是发布者没有办法知道这一点。</li></ul><h1 id="0974" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">现实世界的应用</h1><p id="8c3d" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在从事web开发时，我们看到，<code class="fe np nq nr ns b">Redux</code>和<code class="fe np nq nr ns b">React Context</code>都是基于观察者设计模式的实现示例。</p><p id="dabe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在redux中，我们有一个<code class="fe np nq nr ns b">subscribe</code>方法，允许我们将观察者添加到充当主体的Redux状态中。当对存储进行任何更改时，订阅redux存储的任何人都会得到通知。</p><p id="33c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类似地，使用React Context，每当更新<code class="fe np nq nr ns b">ContextProvider</code>的值时，所有通过<code class="fe np nq nr ns b">useContext</code>钩子或者通过<code class="fe np nq nr ns b">Context.Consumer</code>订阅上下文的组件都用更新的上下文值重新呈现。</p><h1 id="9dd3" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">结论</h1><p id="7f32" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在本文中，我们介绍了观察者设计模式以及如何在我们的应用程序中使用它。我们还实现了一个基于这种模式的演示，并了解了使用这种方法设计交互的一些优点和缺点。</p><p id="5992" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">感谢您的阅读。</strong></p><p id="e292" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您对本文有任何问题或建议，请随时发表评论。</p></div></div>    
</body>
</html>