<html>
<head>
<title>VueJs: Server Side Render with Vue-Router</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">VueJs:使用Vue路由器的服务器端渲染</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/vuejs-server-side-render-with-vue-router-e73d51699873?source=collection_archive---------6-----------------------#2018-01-23">https://betterprogramming.pub/vuejs-server-side-render-with-vue-router-e73d51699873?source=collection_archive---------6-----------------------#2018-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a051" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过在返回页面之前渲染页面来提高应用程序的速度</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/abb2b96a63ad671f7a5efc66703e5f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XpExcSt-d8XdnkIT3bcutg.jpeg"/></div></div></figure><p id="2739" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章的目的是提供你可能需要的所有信息，以确定服务器端渲染(SSR)是否是你应该考虑的一种方法。我们还将通过一个基本(但不一定简单)的例子来说明如何通过<a class="ae ln" href="https://github.com/vuejs/vue-router" rel="noopener ugc nofollow" target="_blank"> vue-router </a>配置和使用SSR。</p><p id="6130" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我在安东尼·戈尔的博客中写了这篇文章的一个更短的、侧重于实现的版本(没有任何关于服务器端渲染的额外信息)。以防你只对实现感兴趣，我把链接留在这里:<a class="ae ln" href="https://vuejsdevelopers.com/2017/12/11/vue-ssr-router/" rel="noopener ugc nofollow" target="_blank"> Vue.js使用Vue路由器的服务器端渲染:分步指南</a></p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="11ea" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">什么时候应该考虑使用SSR？</h1><p id="3fb0" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">使用SSR有两个主要原因。</p><ul class=""><li id="74d6" class="mu mv iq kt b ku kv kx ky la mw le mx li my lm mz na nb nc bi translated">更好的SEO。当应用程序加载时，搜索引擎爬虫将看到完全呈现的页面，因为服务器是构建第一个加载页面的服务器。</li><li id="0841" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">更快获得内容。因为第一次呈现完全由服务器构建，所以从客户端获得完全呈现的页面要快得多。这提供了更好的用户体验，对于内容时间起着关键作用的应用程序来说非常重要。</li></ul><p id="29f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，如果SEO或获取内容的时间对你的应用程序至关重要，那么无论如何权衡，你都应该使用SSR。在任何其他情况下，都要三思而后行，确保你赢的比你输的多，因为这种交换并不便宜。如果你唯一关心的是提高SEO，还有其他技术可以考虑——比如预渲染。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="e8b1" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">权衡取舍</h1><p id="db1e" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">在选择使用SSR之前，您至少需要考虑三个主要问题。</p><ul class=""><li id="952c" class="mu mv iq kt b ku kv kx ky la mw le mx li my lm mz na nb nc bi translated">一些三方库可能需要一些操作才能在SSR应用程序中运行。</li><li id="c539" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">SSR需要一个Node.js服务器可以运行的环境。</li><li id="82b0" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">对于一个服务器来说，这将比只提供静态文件更昂贵，所以，如果你的应用程序有或预期有高流量，准备好处理高服务器负载。</li></ul></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="2f93" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">完整的基本实现</h1><p id="d1ec" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">在开始实际实现之前，您需要理解一些主要概念:</p><ul class=""><li id="d0e8" class="mu mv iq kt b ku kv kx ky la mw le mx li my lm mz na nb nc bi translated">SSR首先在服务器上为实际请求的路线创建一个完全加载的应用程序版本。一旦该页面呈现在客户端，客户端代码就获得所有权。</li><li id="4560" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">您的应用程序需要两个入口构建点——一个用于服务器，一个用于客户端。</li></ul><p id="1eff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">配置并不简单，目前网上关于使用<code class="fe ni nj nk nl b">vue-router</code>的SSR的信息非常少。</p><p id="7995" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，让我们希望下面的例子能给这个主题带来一些清晰。</p><h2 id="ab06" class="nm ly iq bd lz nn no dn md np nq dp mh la nr ns mj le nt nu ml li nv nw mn nx bi translated">属国</h2><p id="7cb7" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">让我们看一下我们必须安装的依赖项。</p><ul class=""><li id="f9e7" class="mu mv iq kt b ku kv kx ky la mw le mx li my lm mz na nb nc bi translated">我们将使用一个已经为<code class="fe ni nj nk nl b"> vueJs</code>应用配置了基本webpack构建的模板开始。我们还需要安装<code class="fe ni nj nk nl b">vue-cli</code>:</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/0918152319dd730c01ab8dfc5d99036f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*EUdFB8CO6eShxbwq0-5nUg.png"/></div></figure><p id="94ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们需要安装<code class="fe ni nj nk nl b">webpack-simple</code>模板的所有依赖项。到目前为止，没有任何东西与SSR相关—我们只是设置一个通用的vueJs环境。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/91e78e6b2b9ab8dcb9b65b848f13fa73.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*XDYaBbI1HRMazD0CAj_rAg.png"/></div></figure><ul class=""><li id="f840" class="mu mv iq kt b ku kv kx ky la mw le mx li my lm mz na nb nc bi translated">现在我们有了一个vueJs项目，可以开始添加SSR配置了。但是首先，我们需要添加三个依赖项，它们都与SSR相关。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/25706f8f63890e51abaf8190d6bc9e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R9sci8cIm4N5CZ0OSC5xYw.png"/></div></div></figure><ul class=""><li id="ce5b" class="mu mv iq kt b ku kv kx ky la mw le mx li my lm mz na nb nc bi translated"><code class="fe ni nj nk nl b">vue-server-render</code>:用于SSR的Vue库。</li><li id="3a16" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated"><code class="fe ni nj nk nl b">vue-router</code>:SPA的Vue图书馆。</li><li id="8068" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated"><code class="fe ni nj nk nl b">express</code>:我们需要一个NodeJS服务器运行。</li><li id="83d9" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated"><code class="fe ni nj nk nl b">webpack-merge</code>:我们将使用它来合并webpack配置。</li></ul><h2 id="6d03" class="nm ly iq bd lz nn no dn md np nq dp mh la nr ns mj le nt nu ml li nv nw mn nx bi translated">Webpack配置</h2><p id="bd40" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">我们将需要两个webpack配置——一个从客户机入口文件构建，另一个从服务器入口文件构建。</p><p id="7b6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于我们的基本webpack配置，我们将使用我们安装的模板附带的配置，除了我们将条目更改为<code class="fe ni nj nk nl b">entry-client.js</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/cc9d5a72a296738feeb6ab93897bd2fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*G2PJs5ZTv_8syJJXhov-sQ.png"/></div></figure><p id="6ab7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们添加服务器webpack配置:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/95ea97c56455bffed11b1c06a5401c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*ICyOTv7H2xwDv1yDCnUr5A.png"/></div></figure><p id="db6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里没有什么奇怪的，除了两件事:条目是<code class="fe ni nj nk nl b">entry-server.js</code>，对于输出，我们使用<code class="fe ni nj nk nl b">commonjs</code>作为库目标。</p><p id="85c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是webpack的配置。现在让我们看看在<code class="fe ni nj nk nl b">packages.json</code>中构建应用程序的脚本。</p><h2 id="60f0" class="nm ly iq bd lz nn no dn md np nq dp mh la nr ns mj le nt nu ml li nv nw mn nx bi translated">Packages.json构建脚本</h2><p id="027d" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">您可以根据需要进行更改，但是启动应用程序需要执行三个步骤:</p><ul class=""><li id="604c" class="mu mv iq kt b ku kv kx ky la mw le mx li my lm mz na nb nc bi translated">构建客户端条目</li><li id="a661" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">构建服务器入口</li><li id="7ff0" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">启动服务器</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/d038efee9e6b294c65271e3b7424bfb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XkfUnyJr6o9q-f9NxVSQlA.png"/></div></div></figure><p id="134e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在配置中，我们使用运行我们刚刚提到的三个步骤的<code class="fe ni nj nk nl b">start</code>脚本。但是如果需要的话，我们已经设置了脚本来分别运行它们。</p><h2 id="b14a" class="nm ly iq bd lz nn no dn md np nq dp mh la nr ns mj le nt nu ml li nv nw mn nx bi translated">文件夹结构</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/74736ad1d4cbd2f7488cbc63c118452d.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/1*rSPCc4UuskhBAlVqer255g.png"/></div></figure><ul class=""><li id="230a" class="mu mv iq kt b ku kv kx ky la mw le mx li my lm mz na nb nc bi translated"><code class="fe ni nj nk nl b">dist</code>文件夹是webpack在构建<code class="fe ni nj nk nl b">node_modules</code>时创建的(嗯，这个你懂的！).</li><li id="919d" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated"><code class="fe ni nj nk nl b">src</code>包含我们的Vue应用。在里面，您会发现服务器和客户机入口点、Vue <code class="fe ni nj nk nl b">main.js</code>文件、<code class="fe ni nj nk nl b">App</code>组件、组件文件夹(我们有<code class="fe ni nj nk nl b">home</code>和<code class="fe ni nj nk nl b">about</code>组件)、包含路由器配置的路由器文件夹，以及最后的资产文件夹。</li><li id="64ec" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated"><code class="fe ni nj nk nl b">.babelrc</code>、<code class="fe ni nj nk nl b">.gitignore</code>、<code class="fe ni nj nk nl b">packages.json </code>——你大概知道他们是什么。</li><li id="8ab3" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated"><code class="fe ni nj nk nl b">index.html</code>是我们应用程序的主要HTML。</li><li id="cb89" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated"><code class="fe ni nj nk nl b">server.js</code>是服务器配置和启动文件。</li><li id="4283" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">最后，我们已经讨论过的两种webpack配置。</li></ul><h2 id="dce5" class="nm ly iq bd lz nn no dn md np nq dp mh la nr ns mj le nt nu ml li nv nw mn nx bi translated">索引HTML</h2><p id="b59d" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">这是我们的主HTML文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/831c3f26cf85baab4d02e0487ae8fcb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGFNbFRdKFn_gA3UJUbNIw.png"/></div></div></figure><p id="dbb1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有几件事需要讨论:</p><ul class=""><li id="e384" class="mu mv iq kt b ku kv kx ky la mw le mx li my lm mz na nb nc bi translated">我在这个模板中添加了一些插值，以便稍后在服务器上填充这些数据。是我想展示的Vue服务器端渲染的一个功能。</li><li id="bcb4" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">我们的目标是从webpack生成的客户端捆绑包的结果<code class="fe ni nj nk nl b">build.js</code>。</li></ul><h2 id="7a33" class="nm ly iq bd lz nn no dn md np nq dp mh la nr ns mj le nt nu ml li nv nw mn nx bi translated">APP.vue组件</h2><p id="5e58" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">该组件是我们应用程序的根组件，它有几项职责:</p><ul class=""><li id="3f3f" class="mu mv iq kt b ku kv kx ky la mw le mx li my lm mz na nb nc bi translated">使用<code class="fe ni nj nk nl b">vue-router</code>链接的菜单配置。</li><li id="ecba" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">为要渲染的路线组件设置容器。</li><li id="3dfd" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">设置id为<code class="fe ni nj nk nl b">app</code>的元素，用于安装应用程序的客户端部分。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/26a45e89b16a11d51716d8ff290d5da7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*Usmn3KXVoz2mGvuPWkkCtw.png"/></div></figure><h2 id="5371" class="nm ly iq bd lz nn no dn md np nq dp mh la nr ns mj le nt nu ml li nv nw mn nx bi translated">路由器文件配置</h2><p id="4b6b" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">因为我们的应用程序将在服务器上启动，所以我们需要为每个服务器请求提供一个新的路由器实例。在路由器文件夹中，我们将有一个包含路由器配置的文件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/3be4542c7c7e4c765c4abc0e648d3b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*wxDzQX0mdMvhL4jm4i56dA.png"/></div></figure><p id="3c7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一下代码:</p><ul class=""><li id="64f5" class="mu mv iq kt b ku kv kx ky la mw le mx li my lm mz na nb nc bi translated">我们导入所有需要的依赖项。</li><li id="22c9" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">我们告诉Vue用<code class="fe ni nj nk nl b">vue-router</code>。</li><li id="013e" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">我们导出一个提供路由器配置新实例的函数。</li><li id="769f" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">我们在历史模式下用我们将要处理的两条路由的配置实例化路由器。</li></ul><h2 id="c1bd" class="nm ly iq bd lz nn no dn md np nq dp mh la nr ns mj le nt nu ml li nv nw mn nx bi translated">主Vue文件配置</h2><p id="f1ae" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">出于同样的原因，我们需要提供一个新的路由器实例，我们需要提供一个新的应用程序实例。这个文件负责启动路由器和根应用程序组件。</p><p id="876f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">服务器和客户机入口点都将使用这个文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/48249be9ec264f3c72516d2dafc53541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v5weEfYE3bikzG9Vf6h5fA.png"/></div></div></figure><p id="4cb0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一下代码:</p><ul class=""><li id="7647" class="mu mv iq kt b ku kv kx ky la mw le mx li my lm mz na nb nc bi translated">我们导入所有需要的依赖项。</li><li id="cbf7" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">我们导出一个函数，该函数提供了应用程序和路由器的新实例。</li><li id="d1ce" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">我们使用之前在“route.js”文件中看到的方法实例化路由器。</li><li id="1476" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">我们用路由器和呈现器创建一个新的应用程序实例，传递根应用程序组件。</li><li id="f36f" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">我们返回两个实例。</li></ul><h2 id="5241" class="nm ly iq bd lz nn no dn md np nq dp mh la nr ns mj le nt nu ml li nv nw mn nx bi translated">客户端入口点</h2><p id="6bba" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">这段代码非常简单。这是webpack客户端构建配置的条目文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/9e96475df9afd4df4d4e756eda9fcda7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*BQKXxHUGRdBi0WBaK0mnAw.png"/></div></figure><p id="2983" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一下代码:</p><p id="9770" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们导入所有需要的依赖项。</p><p id="7748" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们从<code class="fe ni nj nk nl b">main.js</code>文件创建应用程序，并保留<code class="fe ni nj nk nl b">app</code>实例。</p><p id="521d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在一个id设置为<code class="fe ni nj nk nl b">app</code>的节点中挂载<code class="fe ni nj nk nl b">app</code>。在本例中，包含该id的节点是<code class="fe ni nj nk nl b">App.vue</code>组件模板的根元素，如前所述。</p><h2 id="55d2" class="nm ly iq bd lz nn no dn md np nq dp mh la nr ns mj le nt nu ml li nv nw mn nx bi translated">服务器入口点</h2><p id="5f53" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">该文件是webpack服务器构建的入口点。构建的结果就是我们稍后配置服务器时的目标。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/39ba2d1117c2c845e5ebfbe8fd57c978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UGfGMKdCeRdYjdMmGuyuxQ.png"/></div></div></figure><p id="e7a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一下代码:</p><ul class=""><li id="098e" class="mu mv iq kt b ku kv kx ky la mw le mx li my lm mz na nb nc bi translated">我们导入所有需要的依赖项。</li><li id="80ce" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">我们导出一个接收上下文作为参数的函数。</li><li id="6ed2" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">这些函数返回一个承诺。</li><li id="3366" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">我们从' main.js` create app函数实例化app和路由器。</li><li id="51f0" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">我们从上下文中获取当前URL(这将由服务器提供)，以便将正确的URL推送到路由器。</li><li id="0da6" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">路由器准备就绪后，我们检查路由是否与上下文URL匹配。如果是，我们解决承诺并返回应用程序实例。如果不是，我们拒绝承诺。</li></ul><h2 id="4bb7" class="nm ly iq bd lz nn no dn md np nq dp mh la nr ns mj le nt nu ml li nv nw mn nx bi translated">配置和启动服务器</h2><p id="ab4b" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">我们几乎什么都准备好了。唯一缺少的是<code class="fe ni nj nk nl b">express</code>服务器的配置和启动:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/5c742b0402d2e9fc3d2af725c3bb3ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*-fgMLDoHanbdYlIFQdzYng.png"/></div></figure><p id="38ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">而你之前觉得太过分了！别担心，让我们深入研究代码，看看发生了什么:</p><ul class=""><li id="00b4" class="mu mv iq kt b ku kv kx ky la mw le mx li my lm mz na nb nc bi translated">我们正在导入<code class="fe ni nj nk nl b">express</code>来创建服务器，我们也正在导入一些节点js功能。</li><li id="bc76" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">我们导入了作为webpack服务器构建结果的服务器包。</li><li id="e775" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">我们导入<code class="fe ni nj nk nl b">vue-server-renderer</code>库并创建渲染，为模板提供<code class="fe ni nj nk nl b">index.html</code>位置。</li><li id="5d34" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">我们配置了<code class="fe ni nj nk nl b">express</code>路径。</li><li id="6e7e" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">我们启动服务器。</li><li id="db01" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">这个包是用webpack构建<code class="fe ni nj nk nl b">serve-entry.js</code>的结果，所以我们可以使用默认的函数来接收上下文作为URL的参数。因为这是一个我们设置了成功和错误回调的承诺。</li></ul><p id="029b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">成功回调会做很多事情，所以我们也来看看:</p><ul class=""><li id="82fd" class="mu mv iq kt b ku kv kx ky la mw le mx li my lm mz na nb nc bi translated">我们用将要在<code class="fe ni nj nk nl b">index.html</code>中插值的数据创建一个const(我们之前在这个HTML中看到了插值)。</li><li id="927a" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">我们调用接收应用程序的渲染器的render to string函数(由resolved promise返回)、我们刚刚创建的上下文(在索引中使用插值—这是可选的)，以及回调函数(如果一切正常)。</li><li id="23e8" class="mu mv iq kt b ku nd kx ne la nf le ng li nh lm mz na nb nc bi translated">呈现到字符串回调函数检查是否有任何错误。如果没有，它只是发送生成的HTML作为响应。</li></ul><p id="3b4f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们开始监听端口8080。</p><p id="efb7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如果您运行脚本“start ”,并在浏览器中打开“localhost:8080 ”,您将看到SSR和vue-router的工作情况。</p><p id="4c01" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">女士们先生们，就是这样！</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="fb6f" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">结论</h1><p id="4b19" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">我不认为我需要说，这是一个很大的配置，使事情的工作！然而，一旦它完成了，你就不需要经常去碰它。只要确定SSR是你需要的。</p><p id="1818" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我把Github项目留给你。</p></div></div>    
</body>
</html>