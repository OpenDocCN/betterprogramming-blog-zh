<html>
<head>
<title>Build a C GUI Application With LVGL and an SDL2 As the Backend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用LVGL和SDL2作为后端构建一个C GUI应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-c-gui-application-with-lvgl-and-a-sdl2-as-the-backend-85a07ee94a9f?source=collection_archive---------3-----------------------#2022-11-14">https://betterprogramming.pub/build-a-c-gui-application-with-lvgl-and-a-sdl2-as-the-backend-85a07ee94a9f?source=collection_archive---------3-----------------------#2022-11-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ad0a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为任何显示类型创建漂亮的用户界面</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/916d8dd9d5df30b66918a33e40ef1cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T-DamJ_Mm5M0EoP69gsSiw.png"/></div></div></figure><p id="5ccd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今天，我想谈谈小虚拟图形库，简称LVGL。这是一个最高质量的软件项目，近年来对我非常有用。</p><p id="e6ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总之，它的名字足够描述它了。这是一个用C语言编写的GUI库，旨在构建图形应用程序。问题是它是硬件不可知的；它不依赖于操作系统或特定的硬件(如显示器)来工作。它主要针对嵌入式设备——或者至少是高度专业化的接口——而不是一般的PC环境。</p><p id="76eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它无处不在的特性使得它可以毫不费力地移植到许多不同的平台上。然而，正如我很快将向您展示的，硬件不可知并不排除作为PC的常规UI框架工作的可能性——事实上，它比大多数其他库表现得更好。</p><p id="c397" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的教程是基于截止到写作日期的最后一个LVGL版本，8.3。</p><h1 id="4dc6" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">简单而美丽</h1><p id="2641" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">LVGL诞生于在许多平台上使用单一UI库的愿望。为了实现这一点，我们必须将GUI开发的每一个方面抽象出来，不可避免地与底层硬件联系在一起。</p><p id="42c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实证明，这并不多:对于LVGL应该呈现的每个监视器，开发人员必须实例化一个<code class="fe mn mo mp mq b">lv_disp_drv_t</code>实例。这是将库与屏幕上的实际像素联系起来的接口。除了RAM中需要一个明显的缓冲区之外，这个接口还需要一个函数指针来完成所有繁重的工作:</p><pre class="kj kk kl km gt mr mq ms bn mt mu bi"><span id="8888" class="mv lr it mq b be mw mx l my mz">void (*flush_cb)(struct _lv_disp_drv_t * disp_drv, const lv_area_t * area, lv_color_t * color_p);</span></pre><blockquote class="na nb nc"><p id="75df" class="ku kv nd kw b kx ky ju kz la lb jx lc ne le lf lg nf li lj lk ng lm ln lo lp im bi translated">注意:<code class="fe mn mo mp mq b"><em class="it">lv_disp_drv_t</em></code>结构包含许多其他可以初始化的函数指针，但没有一个是严格要求的。<br/>有用于性能监控的钩子和用于极限情况的可选快捷方式。</p></blockquote><p id="7ce4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个函数将被LVGL内部调用，以表示一个矩形<code class="fe mn mo mp mq b">area</code>将被绘制在屏幕上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/da38cccc5bdc53e69938ea120a5a6ba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*C63Pl-q_wcz4Zvo-gvoaLg.png"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">flush_cb回调充当硬件和库之间接口</p></figure><p id="5c20" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如何实现取决于开发人员。它可以将SPI连接上的数据发送到串行显示器；通过Linux framebuffer接口在HDMI监视器上写像素；将生成的图像转储到PNG文件中，甚至通过网络连接。</p><p id="4fb7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">库的其余部分完全不知道边界之外发生了什么，只满足于在提供的RAM缓冲区中绘制UI界面。</p><p id="5ca9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管非常简单，但这种方法非常有效。<br/>我一直和LVGL在几十个不同的目标上合作(分辨率、颜色格式、硬件、处理器架构，你能想到的)，同时用同样熟悉的API进行开发。</p><p id="eb7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">人们可以将LVGL描述为UI架构的前端部分。它提供了小部件、绘图例程和输入控制。</p><p id="cd97" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就其本身而言，它不起作用；它需要插入一个后端来在屏幕上显示图像。</p><p id="98b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了向您展示如何在不掌握特定硬件的情况下构建LVGL应用程序，我将针对SDL2后端，以便应用程序可以在任何具有窗口管理器的机器上呈现。</p><p id="4ab4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">即使最终结果在PC上运行，这也是任何嵌入式目标的指南。当然，还应该提供合适的显示驱动程序。</p><h1 id="465e" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">要求</h1><p id="0573" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">至少需要一个C编译器。我将使用gcc，但我不明白为什么clang不应该工作。</p><p id="910a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将使用<a class="ae nm" href="https://scons.org/" rel="noopener ugc nofollow" target="_blank"> SCons </a>来构建项目。这是一个优雅而有效的构建系统，我已经在这里广泛地称赞过它了。它可以作为软件包安装，也可以通过pip安装。</p><p id="f08e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于我们将使用SDL2后端，因此必须安装相应的库(在其开发形式中);它在每个发行版中都作为官方包提供。</p><p id="5e9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我使用git来管理LVGL和类似的源代码依赖项，但是只需下载源代码并将其复制到项目中就可以了。</p><p id="fcba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是开始的全部内容。</p><h1 id="74f9" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">该项目</h1><p id="3dd3" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我喜欢把我的C项目分成两个主文件夹:<code class="fe mn mo mp mq b">main</code>和<code class="fe mn mo mp mq b">components</code>(很大程度上受<a class="ae nm" href="https://github.com/espressif/esp-idf-template" rel="noopener ugc nofollow" target="_blank"> ESP-IDF项目</a>的启发)。</p><p id="62d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mn mo mp mq b">main</code>文件夹将包含我的代码，而在<code class="fe mn mo mp mq b">components</code>中，我将添加所有的外部库。</p><p id="719b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要包含LVGL，进入<code class="fe mn mo mp mq b">components</code>目录并运行以下命令:</p><pre class="kj kk kl km gt mr mq ms bn mt mu bi"><span id="1cc4" class="mv lr it mq b be mw mx l my mz">cd components<br/>git clone https://github.com/lvgl/lvgl.git<br/>git checkout --track origin/release/v8.3</span></pre><p id="450a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后一个命令确保我们使用的是库的8.3版本，这是撰写本文时最新的稳定版本。</p><p id="8d80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在使用LVGL之前，应该先进行配置；它通过一个简单的头文件来实现。</p><p id="a42f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在<code class="fe mn mo mp mq b">components/lvgl/lv_conf_template.h</code>中找到一个模板:你应该创建文件夹<code class="fe mn mo mp mq b">main/config</code>并复制到那里，重命名为<code class="fe mn mo mp mq b">lv_conf.h</code>。</p><pre class="kj kk kl km gt mr mq ms bn mt mu bi"><span id="5447" class="mv lr it mq b be mw mx l my mz">mkdir main/config<br/>cp components/lvgl/lv_conf_template.h main/config/lv_conf.h</span></pre><blockquote class="na nb nc"><p id="8779" class="ku kv nd kw b kx ky ju kz la lb jx lc ne le lf lg nf li lj lk ng lm ln lo lp im bi translated">注意:LVGL集成了一些特定的框架，这些框架也管理它与其他工具(例如KConfig)的配置。<br/>这里不是这种情况，所以我们将直接编辑头文件。</p></blockquote><p id="bd13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，必须通过在第15行手动更改预处理器保护来启用配置文件:</p><pre class="kj kk kl km gt mr mq ms bn mt mu bi"><span id="78a7" class="mv lr it mq b be mw mx l my mz">/**<br/> * @file lv_conf.h<br/> * Configuration file for v8.3.3<br/> */<br/>/*<br/> * Copy this file as `lv_conf.h`<br/> * 1. simply next to the `lvgl` folder<br/> * 2. or any other places and<br/> *    - define `LV_CONF_INCLUDE_SIMPLE`<br/> *    - add the path as include path<br/> */<br/>/* clang-format off */<br/>#if 0 /*Set it to "1" to enable content*/   // &lt;-- Change this 0 to 1<br/>#ifndef LV_CONF_H<br/>#define LV_CONF_H<br/>// ...</span></pre><p id="0235" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有许多配置选项，但在这个阶段，默认值已经足够好了。</p><p id="65e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它们中大多数的重要性很大程度上取决于目标的具体情况:例如，<code class="fe mn mo mp mq b">LV_COLOR_DEPTH</code>应该由LVGL正在使用的显示器的功能来设置。此处的错误值通常会导致屏幕上的输出混乱；然而，SDL几乎可以处理任何可用的格式，所以这与我们无关。</p><p id="aa8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一步是编写最少的初始化代码，并设置构建系统。创建包含以下内容的文件<code class="fe mn mo mp mq b">main/main.c</code>:</p><pre class="kj kk kl km gt mr mq ms bn mt mu bi"><span id="2f85" class="mv lr it mq b be mw mx l my mz">#include &lt;stdio.h&gt;<br/>#include &lt;unistd.h&gt;<br/>#include "lvgl.h"<br/></span></pre><pre class="nn mr mq no np aw nq bi"><span id="ec51" class="nr lr it mq b gy ns nt l nu mz">int main(void) {<br/>    // What oh, LVGL!<br/>    lv_init();<br/>    printf("Begin main loop\n");<br/>    for (;;) {<br/>        // Run LVGL engine<br/>        lv_tick_inc(1);<br/>        lv_timer_handler();<br/>        usleep(1000);<br/>    }<br/>    return 0;<br/>}</span></pre><p id="f6f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将是我们应用程序的起点和跳动的心脏。<br/>包含的内容很简单:<code class="fe mn mo mp mq b">stdio.h</code>在终端上打印内容，<code class="fe mn mo mp mq b">unistd.h</code>访问<code class="fe mn mo mp mq b">usleep</code>功能，当然还有<code class="fe mn mo mp mq b">lvgl.h</code>图形库。</p><p id="c03b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里只有两点有趣:</p><ol class=""><li id="c7f5" class="nv nw it kw b kx ky la lb ld nx lh ny ll nz lp oa ob oc od bi translated"><code class="fe mn mo mp mq b">lv_init()</code>初始化库。在做任何与LVGL相关的事情之前，必须调用它。</li><li id="0703" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated"><code class="fe mn mo mp mq b">lv_tick_inc(1)</code>和<code class="fe mn mo mp mq b">lv_timer_handler()</code>是LVGL实际工作的地方。</li></ol><p id="0121" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">后一个调用是运行绘图引擎和管理输入设备和周期性任务所需要的。在内心深处的某个地方，在某个时刻，<code class="fe mn mo mp mq b">flush_cb</code>回调将与实际屏幕交互。<br/>前者通知引擎已经过了一些时间单位——在本例中是一个单位。这隐含地计算毫秒数。</p><p id="087b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有点简单，但这已经可以被称为LVGL应用程序了。我们最终将添加一个SDL2驱动程序，但现在，让我们开始编译。</p><h1 id="1aec" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">建筑物</h1><p id="de16" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">如前所述，我在这个项目中使用SCons。下面是<code class="fe mn mo mp mq b">SConstruct</code>文件:</p><pre class="kj kk kl km gt mr mq ms bn mt mu bi"><span id="e87d" class="mv lr it mq b be mw mx l my mz">import os<br/>import multiprocessing<br/>from pathlib import Path<br/># Name of the application<br/>PROGRAM = "app"<br/># Project paths<br/>MAIN = "main"<br/>COMPONENTS = "components"<br/>CONFIG = f"{MAIN}/config"<br/>LVGL = f"{COMPONENTS}/lvgl"<br/># Compilation flags<br/>CFLAGS = ["-Wall", "-Wextra", "-g", "-O0", ]<br/>CPPPATH = [COMPONENTS, MAIN, LVGL, CONFIG]<br/>CPPDEFINES = ["LV_CONF_INCLUDE_SIMPLE"]<br/>def main():<br/>    # If not specified, guess how many threads the task can be split into<br/>    num_cpu = multiprocessing.cpu_count()<br/>    SetOption("num_jobs", num_cpu)<br/>    print("Running with -j {}".format(GetOption("num_jobs")))<br/>    env_options = {<br/>        "CPPPATH": CPPPATH,<br/>        "CPPDEFINES": CPPDEFINES,<br/>        "CCFLAGS": CFLAGS,<br/>    }<br/>    env = Environment(**env_options)<br/>    # Project sources<br/>    sources = [File(filename) for filename in Path(<br/>        f"{MAIN}").rglob("*.c")]  # application files<br/>    sources += [File(filename)<br/>                for filename in Path(f"{LVGL}/src").rglob("*.c")]  # LVGL<br/>    env.Program(PROGRAM, sources)<br/></span></pre><pre class="nn mr mq no np aw nq bi"><span id="67a1" class="nr lr it mq b gy ns nt l nu mz">main()</span></pre><p id="0fb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在文件的开头，我声明了一些有用的常量，比如程序名、每个主要组件的路径和一些编译标志。</p><p id="3114" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中，有两个非常重要:</p><ol class=""><li id="8c77" class="nv nw it kw b kx ky la lb ld nx lh ny ll nz lp oa ob oc od bi translated">LVGL源代码所在的文件夹应该包含在<code class="fe mn mo mp mq b">CPPPATH</code>中，以确保可以找到它的头文件。</li><li id="ade3" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">在整个项目中，宏<code class="fe mn mo mp mq b">LV_CONF_INCLUDE_SIMPLE</code>被定义。这是一个额外的配置位，告诉LVGL它可以在包含路径中找到文件<code class="fe mn mo mp mq b">lv_conf.h</code>。否则，它将寻找<code class="fe mn mo mp mq b">../../lv_conf.h</code>，这不是我们存储它的地方。</li></ol><p id="46cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mn mo mp mq b">main</code> python函数是定义建筑层次的地方。<br/>首先，我们告诉SCons应该运行多少个作业，这取决于处理器内核的数量:LVGL是一个中等大小的库，如果可能的话，我们应该利用并行编译。</p><p id="cb5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们使用所有先前定义的编译标志实例化一个构建环境。</p><p id="424d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，所有的。来自LVGL和我们的应用程序的c源文件应该收集在一个列表中，并指定为最终可执行文件的依赖项。<br/>为此，我利用了来自<code class="fe mn mo mp mq b">pathlib</code> Python库的<code class="fe mn mo mp mq b">Path</code>对象，它允许我递归搜索文件夹中所有匹配正则表达式的文件。</p><p id="745b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">目前，这个项目中只有两个文件夹有源代码:<code class="fe mn mo mp mq b">main</code>和<code class="fe mn mo mp mq b">components/lvgl/src</code>。</p><p id="fe22" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mn mo mp mq b">env.Program(PROGRAM, sources)</code>最终确定行动。运行<code class="fe mn mo mp mq b">scons</code>现在应该可以编译所有内容，并且可以执行结果<code class="fe mn mo mp mq b">app</code>。</p><p id="1073" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，这除了在终端上打印“Begin main loop”之外什么也没做，但是到目前为止，我们已经打下了基础。让我们添加一个窗口。</p><h1 id="5b97" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">硬件抽象</h1><p id="09a8" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">以下步骤将使该项目专门显示在SDL2窗口上。</p><p id="6944" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常，这需要一个小教程来理解它是如何工作的。幸运的是，这次有人已经为我们解决了这个棘手的问题。</p><p id="e5dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae nm" href="https://github.com/lvgl/lv_drivers" rel="noopener ugc nofollow" target="_blank"> lv_drivers </a>是针对很多常见的显示驱动为LVGL做的接口集合，其中，还有一个SDL2驱动。</p><p id="22ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用以下命令添加驱动程序库:</p><pre class="kj kk kl km gt mr mq ms bn mt mu bi"><span id="8cd1" class="mv lr it mq b be mw mx l my mz">cd components<br/>git clone https://github.com/lvgl/lv_drivers.git<br/>git checkout --track origin/release/v8.3</span></pre><p id="4c33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就像LVGL一样，驱动程序有一个8.3分支来与主库对齐，也像LVGL一样，有一个头文件来配置它。</p><p id="3e8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将<code class="fe mn mo mp mq b">components/lv_drivers/lv_drv_conf_template.h</code>复制到<code class="fe mn mo mp mq b">main/config/lv_drv_conf.h</code>，并通过将第11行的预处理器指令设置为1来启用它；通过在第89行执行同样的操作来启用SDL驱动程序:</p><pre class="kj kk kl km gt mr mq ms bn mt mu bi"><span id="ef8f" class="mv lr it mq b be mw mx l my mz">/**<br/> * @file lv_drv_conf.h<br/> * Configuration file for v8.3.0<br/> */<br/>/*<br/> * COPY THIS FILE AS lv_drv_conf.h<br/> */<br/>/* clang-format off */<br/>#if 0 /*Set it to "1" to enable the content*/   // &lt;-- Change this 0 to 1<br/>#ifndef LV_DRV_CONF_H<br/>#define LV_DRV_CONF_H<br/>// ...<br/>/* SDL based drivers for display, mouse, mousewheel and keyboard*/<br/>#ifndef USE_SDL<br/># define USE_SDL 0  // &lt;-- Change this 0 to 1<br/>#endif</span></pre><p id="f1d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们需要在编译过程中包含驱动程序库，这需要对<code class="fe mn mo mp mq b">SConstruct</code>做三个简单的添加。</p><p id="c08a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，为驱动程序的路径声明一个新变量，并将该变量添加到包含路径列表中:</p><pre class="kj kk kl km gt mr mq ms bn mt mu bi"><span id="415a" class="mv lr it mq b be mw mx l my mz">DRIVERS = f"{COMPONENTS}/lv_drivers"<br/># ...<br/>CPPPATH = [COMPONENTS, MAIN, LVGL, CONFIG, DRIVERS]</span></pre><p id="a933" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后在环境字典中添加一个新选项，将SDL2链接到应用程序:</p><pre class="kj kk kl km gt mr mq ms bn mt mu bi"><span id="c7a7" class="mv lr it mq b be mw mx l my mz">env_options = {<br/>    # Include the external environment to access DISPLAY and run the app as a target<br/>    "CPPPATH": CPPPATH,<br/>    "CPPDEFINES": CPPDEFINES,<br/>    "CCFLAGS": CFLAGS,<br/>    "LIBS" : ["-lSDL2"],<br/>}</span></pre><p id="0c1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果没有这一步，编译将会失败，出现几个错误，提到对<code class="fe mn mo mp mq b">SDL_</code>函数的未定义引用。</p><p id="2896" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，将另一轮源文件添加到<code class="fe mn mo mp mq b">sources</code>列表:</p><pre class="kj kk kl km gt mr mq ms bn mt mu bi"><span id="3b74" class="mv lr it mq b be mw mx l my mz">sources += [File(filename)<br/>            for filename in Path(DRIVERS).rglob("*.c")]  # Drivers</span></pre><p id="ead9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">烤饼到此为止。现在再次打开<code class="fe mn mo mp mq b">main.c</code>，为<code class="fe mn mo mp mq b">"sdl/sdl.h"</code>添加一个包含，并在<code class="fe mn mo mp mq b">lv_init()</code>之后立即调用<code class="fe mn mo mp mq b">sdl_init()</code>。</p><p id="4dff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的顺序很重要。由于<code class="fe mn mo mp mq b">sdl_init()</code>是SDL2的LVGL驱动的一部分，LVGL在调用之前必须已经初始化；否则将导致分段错误。</p><p id="fafb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，我们需要将SDL2驱动程序连接到LVGL绘图引擎。这是通过初始化显示器和输入设备来完成的。</p><pre class="kj kk kl km gt mr mq ms bn mt mu bi"><span id="67f7" class="mv lr it mq b be mw mx l my mz">#define BUFFER_SIZE (SDL_HOR_RES * SDL_VER_RES)<br/>    /*A static or global variable to store the buffers*/<br/>    static lv_disp_draw_buf_t disp_buf;<br/>/*Static or global buffer(s). The second buffer is optional*/<br/>    static lv_color_t *buf_1[BUFFER_SIZE] = {0};<br/>/*Initialize `disp_buf` with the buffer(s). With only one buffer use NULL instead buf_2 */<br/>    lv_disp_draw_buf_init(&amp;disp_buf, buf_1, NULL, BUFFER_SIZE);<br/>    static lv_disp_drv_t disp_drv;         /*A variable to hold the drivers. Must be static or global.*/<br/>    lv_disp_drv_init(&amp;disp_drv);           /*Basic initialization*/<br/>    disp_drv.draw_buf = &amp;disp_buf;         /*Set an initialized buffer*/<br/>    disp_drv.flush_cb = sdl_display_flush; /*Set a flush callback to draw to the display*/<br/>    disp_drv.hor_res  = SDL_HOR_RES;       /*Set the horizontal resolution in pixels*/<br/>    disp_drv.ver_res  = SDL_VER_RES;       /*Set the vertical resolution in pixels*/<br/>    lv_disp_t *disp = lv_disp_drv_register(&amp;disp_drv); /*Register the driver and save the created display objects*/<br/>    lv_theme_default_init(disp, lv_color_make(0x77, 0x44, 0xBB), lv_color_make(0x14, 0x14, 0x3C), 1, lv_font_default());</span></pre><p id="9685" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，显示器需要一个内存缓冲区来工作。现在，我使用一个和整个屏幕一样大的缓冲区，但是LVGL可以轻松地处理更小的部分。</p><p id="a0c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">显示驱动程序本身就是<code class="fe mn mo mp mq b">lv_disp_drv_t</code>结构，它被赋予三条重要信息:</p><ol class=""><li id="f4d3" class="nv nw it kw b kx ky la lb ld nx lh ny ll nz lp oa ob oc od bi translated">显示缓冲区应该工作。</li><li id="ae66" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">硬件抽象，即在屏幕上绘制的功能。</li><li id="d65b" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">屏幕的大小(水平和垂直分辨率)</li></ol><p id="5cb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这被注册为库的一个显示，并且一个默认的主题被分配给它。</p><blockquote class="na nb nc"><p id="a0dd" class="ku kv nd kw b kx ky ju kz la lb jx lc ne le lf lg nf li lj lk ng lm ln lo lp im bi translated">注意:通过初始化更多的<code class="fe mn mo mp mq b"><em class="it">lv_disp_drv_t</em></code>，LVGL有可能同时支持多个屏幕！唯一的限制是它们必须具有相同的色深。</p></blockquote><p id="25d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">LVGL还可以管理用户输入，通常是触摸屏；在这种情况下，我们谈论的是你的鼠标或触控板。</p><pre class="kj kk kl km gt mr mq ms bn mt mu bi"><span id="6f51" class="mv lr it mq b be mw mx l my mz">static lv_indev_drv_t indev_drv;<br/>    lv_indev_drv_init(&amp;indev_drv); /*Basic initialization*/<br/>    indev_drv.type    = LV_INDEV_TYPE_POINTER;<br/>    indev_drv.read_cb = sdl_mouse_read;<br/>    lv_indev_drv_register(&amp;indev_drv);</span></pre><p id="5366" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这段代码注册了一个输入设备，该设备由内部引擎用<code class="fe mn mo mp mq b">indev_drv.read_cb</code>轮询。</p><p id="816f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mn mo mp mq b">sdl_mouse_read</code>和<code class="fe mn mo mp mq b">sdl_display_flush</code>一样，都是由SDL2驱动程序提供的。</p><p id="d337" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意<code class="fe mn mo mp mq b">disp_buf</code>、<code class="fe mn mo mp mq b">buf_1</code>、<code class="fe mn mo mp mq b">disp_drv</code>、<code class="fe mn mo mp mq b">indev_drv</code>声明为<code class="fe mn mo mp mq b">static</code>；即使我们从正在处理的函数中返回，它们也应该在内存中保持持久，因为LVGL希望它们的内存是持久的。用<code class="fe mn mo mp mq b">malloc</code>或类似工具动态分配它们也可以。</p><p id="92a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再次编译并运行:现在你应该看到一个工作窗口——尽管是空的。这很正常，因为我们还没有用任何有意义的东西来填充它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/774a9075c758503a137160e307bd34ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*DIGA-oUY_VOsut8egoN1yQ.png"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">我们的LVGL窗口—目前</p></figure><p id="cb1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，一个简单的按钮就足够了。在所有初始化之后和主循环之前添加以下代码:</p><pre class="kj kk kl km gt mr mq ms bn mt mu bi"><span id="7225" class="mv lr it mq b be mw mx l my mz">lv_obj_t *btn = lv_btn_create(lv_scr_act());    // Create a new button on the current screen<br/>    lv_obj_t *lbl = lv_label_create(btn);           // Add a label to this button<br/>    lv_label_set_text(lbl, "Hello world!");<br/>    lv_obj_center(lbl);<br/>    lv_obj_center(btn);</span></pre><p id="489d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不打算深究LVGL API本身；<a class="ae nm" href="https://docs.lvgl.io/8.3/" rel="noopener ugc nofollow" target="_blank">有很好的文档说明</a>。我只想说，我正在创建一个包含标签的按钮，并把它放在屏幕的中央。</p><p id="4f07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后一次编译，运行，瞧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/e00fca10dfad49e691deee8a0827832c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*CwJFGsaCFguiqP5pH5jOmg.png"/></div></figure><h1 id="0a77" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">时间考虑</h1><p id="9a08" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在结束话题之前，我想更多地关注LVGL是如何处理时间的。</p><p id="6989" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个例子将库的时钟周期数每毫秒增加一，这在一定程度上是正确的。除了<code class="fe mn mo mp mq b">usleep</code>的延迟不精确之外，应用程序可能被其他任务占用超过1000微秒，这使得报告的运行时间更加不准确。</p><p id="4427" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这不是特别重要，因为LVGL所做的图形工作不会因为偶尔几毫秒的错误而受损，但我们是来学习的，所以让我们好好工作。</p><h2 id="487b" class="nr lr it bd ls ok ol dn lw om on dp ma ld oo op mc lh oq or me ll os ot mg ou bi translated">自定义时间</h2><p id="51db" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">一种选择是让LVGL直接绑定到系统时间，这样它就可以自主读取当前的滴答计数，而不是依赖于被调用的<code class="fe mn mo mp mq b">lv_tick_inc</code>。</p><p id="ae13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是通过<code class="fe mn mo mp mq b">LV_TICK_CUSTOM*</code>配置选项实现的。<br/>首先，我们需要一个单调的(即总是增长的)源来显示经过的毫秒数。</p><p id="d56d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建包含以下内容的文件<code class="fe mn mo mp mq b">main/utils/system_time.c</code>:</p><pre class="kj kk kl km gt mr mq ms bn mt mu bi"><span id="4a39" class="mv lr it mq b be mw mx l my mz">#include &lt;time.h&gt;<br/>#include &lt;sys/time.h&gt;<br/></span></pre><pre class="nn mr mq no np aw nq bi"><span id="80c2" class="nr lr it mq b gy ns nt l nu mz">unsigned long get_millis(void) {<br/>    unsigned long   now_ms;<br/>    struct timespec ts;<br/>    clock_gettime(CLOCK_MONOTONIC_RAW, &amp;ts);<br/>    now_ms = ts.tv_sec * 1000UL + ts.tv_nsec / 1000000UL;<br/>    return now_ms;<br/>}</span></pre><p id="87e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可能有其他方法可以得到类似的结果；我对这个最满意。<br/> <code class="fe mn mo mp mq b">get_millis</code>将返回机器开机后经过的毫秒数。</p><p id="de21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用forward声明添加一个相应的头文件，然后转到<code class="fe mn mo mp mq b">lv_conf.h</code>的第88行，编辑如下:</p><pre class="kj kk kl km gt mr mq ms bn mt mu bi"><span id="ab1a" class="mv lr it mq b be mw mx l my mz">/*Use a custom tick source that tells the elapsed time in milliseconds.<br/> *It removes the need to manually update the tick with `lv_tick_inc()`)*/<br/>#define LV_TICK_CUSTOM 1<br/>#if LV_TICK_CUSTOM<br/>    #define LV_TICK_CUSTOM_INCLUDE "utils/system_time.h"   /*Header for the system time function*/<br/>    #define LV_TICK_CUSTOM_SYS_TIME_EXPR (get_millis())    /*Expression evaluating to current system time in ms*/<br/>#endif   /*LV_TICK_CUSTOM*/</span></pre><p id="320d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在您可以删除对<code class="fe mn mo mp mq b">lv_tick_inc</code>的调用了，因为LVGL可以自己跟踪时间。</p><p id="56da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然很方便，但我不喜欢这种方法，因为它会导致我的应用程序挂起。</p><p id="fc25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">发生这种情况是因为我正在呈现一个包含大量动画的页面，即依赖于时间的绘图任务。</p><p id="d76c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想象一下，你的屏幕上有<code class="fe mn mo mp mq b">n</code>个动画物体，帧率为30 fps，也就是说大约每33 ms一帧。</p><p id="ce44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mn mo mp mq b">lv_timer_handler</code>调用在注册的任务上循环，其中有管理那些动画的任务。</p><p id="8aa9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它从动画1开始，处理绘图，并将其发送到屏幕上——这两项任务都很耗时。</p><p id="0882" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后它移动到第二个动画，第三个，等等。</p><p id="4af8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当它完成最后一个动画时，<code class="fe mn mo mp mq b">lv_timer_handler</code>应该会返回…除了自从第一个动画更新以来已经过了33毫秒，LVGL知道它应该渲染下一帧。</p><p id="216f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">循环重新开始，您的应用程序永远不会从<code class="fe mn mo mp mq b">lv_timer_handler</code>退出。</p><p id="41f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果出于动画对象之外的原因给LVGL的计时器增加了过多的负载，也会发生这种情况。</p><p id="744a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个有问题的情况，应该通过减少所述负载来解决；尽管如此，仍然希望应用程序更有弹性。</p><h2 id="7564" class="nr lr it bd ls ok ol dn lw om on dp ma ld oo op mc lh oq or me ll os ot mg ou bi translated">适当的时间跟踪</h2><p id="f1b1" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">另一个我更喜欢的选项是仍然直接输入节拍，但是精确计算自最后一次调用以来的运行时间。</p><pre class="kj kk kl km gt mr mq ms bn mt mu bi"><span id="1ef1" class="mv lr it mq b be mw mx l my mz">int main(int argc, char *argv[]) {<br/>    static unsigned long last_invoked = 0;<br/>    /* ... */<br/>    for (;;) {<br/>        // Run LVGL engine<br/>        if (last_invoked &gt; 0) {<br/>            lv_tick_inc(get_millis() - last_invoked);<br/>        }<br/>        last_invoked = get_millis();<br/>        lv_timer_handler();<br/>        usleep(1000);<br/>    }</span></pre><pre class="nn mr mq no np aw nq bi"><span id="8784" class="nr lr it mq b gy ns nt l nu mz">    return 0;<br/>}</span></pre><p id="af35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过取走时钟，我们确保即使在任务溢出的情况下,<code class="fe mn mo mp mq b">lv_timer_handler</code>也会返回。渲染过程会变慢，但不会挂起。</p><h1 id="dfa5" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">结论</h1><p id="0f04" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">这就是如何使用LVGL建立一个项目。正如介绍中所述，与特定显示器的接口可能会稍微复杂一点，但是<code class="fe mn mo mp mq b">lv_drivers</code>可能包含您正在使用的模型所需的代码——或者非常类似的代码。</p><p id="4cc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在这里找到最终收集的<a class="ae nm" href="https://github.com/Maldus512/lvgl_base_sdl_simulator" rel="noopener ugc nofollow" target="_blank">结果。</a></p><p id="a17f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了学习方法之外，在您的机器上而不是目标上工作还会带来其他好处。有可能在编译PC上至少运行嵌入式应用程序的UI部分，以减少代码-编译-调试周期的时间。</p><p id="3054" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">LVGL很棒。考虑将它用于您的下一个C项目——嵌入式或其他。</p></div></div>    
</body>
</html>