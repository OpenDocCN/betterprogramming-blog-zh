<html>
<head>
<title>How To Reduce Your App’s APK Size, Even If You Use Realm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何减少你的应用程序的APK大小，即使你使用Realm</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/when-using-realm-for-android-makes-your-app-heavy-93c56c0d1c98?source=collection_archive---------1-----------------------#2018-07-23">https://betterprogramming.pub/when-using-realm-for-android-makes-your-app-heavy-93c56c0d1c98?source=collection_archive---------1-----------------------#2018-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0b2f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">轻薄的应用程序意味着更快的下载速度，这意味着更快乐的用户</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d549cac557b2b2870d29ca34f31fab16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o0OU6qKqK8iSeXUMs_70Iw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自官网:<a class="ae kv" href="http://realm.io" rel="noopener ugc nofollow" target="_blank"> realm.io </a></p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="7392" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这篇文章是写给那些听说过或者一直在他们的Android应用中使用Realm Database的开发者的。</p><p id="9646" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是一个教程，旨在帮助你以一种比平常占用更少空间的方式设置你的Android项目。</p><p id="5b55" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这篇文章中，我将把我的应用程序<a class="ae kv" href="https://play.google.com/store/apps/details?id=bapspatil.silverscreener" rel="noopener ugc nofollow" target="_blank"> SilverScreener </a>作为一个案例研究。</p><p id="046d" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您可以在Github上找到源代码:</p><div class="lu lv gp gr lw lx"><a href="https://github.com/bapspatil/SilverScreener" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd ir gy z fp mc fr fs md fu fw ip bi translated">bapspatil/银屏</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">一个功能丰富的电影指南应用程序。</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">github.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml kp lx"/></div></div></a></div></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="3c63" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">王国之前的时代…</h1><p id="f34a" class="pw-post-body-paragraph ky kz iq la b lb nl jr ld le nm ju lg lh nn lj lk ll no ln lo lp np lr ls lt ij bi translated">让我们回到我在应用程序中实现一个普通、无聊的<a class="ae kv" href="https://developer.android.com/training/data-storage/sqlite" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir"> SQLite数据库</strong> </a>的时候。该应用的APK大小为<strong class="la ir"> 4MB </strong>。</p><p id="60e1" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">但是正如你们大多数人所知，编写SQLite数据库是非常无聊的，并且包含许多样板代码。改变数据库模式意味着在代码的其他部分也要做很多改变。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="34f1" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">进入，领域</h1><p id="862d" class="pw-post-body-paragraph ky kz iq la b lb nl jr ld le nm ju lg lh nn lj lk ll no ln lo lp np lr ls lt ij bi translated">当我第一次从Reddit上的某个人那里听说Realm时，我被它的设置和运行数据库的简单程度震惊了，它甚至附带了云同步功能！很容易对数据库模式进行修改，而不必修改我已经编写的大部分代码。</p><p id="ba8a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">执行CRUD操作非常简单快捷。领域代码的每一行都很容易阅读和理解，即使对新手来说也是如此。使用线程也很容易。数据库加密？只要多写两行代码就大功告成了！</p><p id="ff18" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当然，现在这篇文章既不是Realm的广告，也不是Realm的教程。所以让我们继续讨论使用Realm的问题。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="7f8c" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">境界怎么了？</h1><p id="3aae" class="pw-post-body-paragraph ky kz iq la b lb nl jr ld le nm ju lg lh nn lj lk ll no ln lo lp np lr ls lt ij bi translated">一旦我在我的应用程序中添加了Realm的依赖项，设置了Realm，并删除了所有SQLite代码，我的应用程序的APK大小从<strong class="la ir"> 4MB </strong>增加到了<strong class="la ir"> 12MB </strong>！现在，对于像我这样的简单应用程序，这种差异可能不是很多。但是，如果您的应用程序有一个包含许多实体的巨大数据库，会怎么样呢？增量会高得多。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/a74de62c5514957290ca41fcbe759a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m8bn8fhRH5KfWtm0nm_QyQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">SQLite与Realm: APK规模比较</p></figure></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="a231" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">原因</h1><p id="e536" class="pw-post-body-paragraph ky kz iq la b lb nl jr ld le nm ju lg lh nn lj lk ll no ln lo lp np lr ls lt ij bi translated">Android手机的处理器支持以下架构:</p><ul class=""><li id="b9f6" class="ns nt iq la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">x86</code></li><li id="7966" class="ns nt iq la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">x86_64</code></li><li id="c091" class="ns nt iq la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">armeabi-v7a</code></li><li id="26ab" class="ns nt iq la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">arm64-v8a</code></li><li id="2ce6" class="ns nt iq la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">armeabi</code>(已废弃)</li><li id="68c5" class="ns nt iq la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">mips</code>(过时)</li><li id="c725" class="ns nt iq la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">mips64</code>(已废弃)</li></ul><p id="d014" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当您构建应用程序的APK时，领域库会针对所有这些架构进行编译。这就是APK尺寸如此巨大的原因。</p><p id="938f" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Android Studio正在开发的APK拥有上述所有架构的<em class="nq">原生领域代码。但是你的用户的手机只需要一个应用程序，这个应用程序有他们处理器架构的本地代码。他们不需要为所有架构编译Realm的应用程序。那只会增加他们必须从Play Store下载的应用程序的大小。</em></p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="74ee" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">解决方案</h1><p id="f99c" class="pw-post-body-paragraph ky kz iq la b lb nl jr ld le nm ju lg lh nn lj lk ll no ln lo lp np lr ls lt ij bi translated">这可以通过两种方式实现:</p><ol class=""><li id="da99" class="ns nt iq la b lb lc le lf lh nu ll nv lp nw lt ok ny nz oa bi translated"><strong class="la ir"> ABI滤波器</strong>(不太有效)</li><li id="5f44" class="ns nt iq la b lb of le og lh oh ll oi lp oj lt ok ny nz oa bi translated"><strong class="la ir"> APK劈</strong>(更有效)</li></ol><p id="aad1" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了简洁起见，在本文中，我将只讨论APK分裂。这就是它的真正含义:</p><p id="8aaa" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><em class="nq"> APK拆分是为你的应用构建多个特定于每个架构的APK。</em></p><p id="53ff" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这可以在你的Android项目的app级<code class="fe ob oc od oe b">build.gradle</code>文件中完成。</p><p id="fc80" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">由于<code class="fe ob oc od oe b">armeabi</code>、<code class="fe ob oc od oe b">mips</code>和<code class="fe ob oc od oe b">mips64</code>架构现在已经过时，让我们专注于为<code class="fe ob oc od oe b">x86,</code>、<code class="fe ob oc od oe b">armeabi-v7a</code>和<code class="fe ob oc od oe b">arm64-v8a</code>架构构建单独的apk。</p><h2 id="b693" class="ol mu iq bd mv om on dn mz oo op dp nd lh oq or nf ll os ot nh lp ou ov nj ow bi translated">如果您正在为需要上传到Play Store的应用程序执行此操作:</h2><p id="79ce" class="pw-post-body-paragraph ky kz iq la b lb nl jr ld le nm ju lg lh nn lj lk ll no ln lo lp np lr ls lt ij bi translated">由于将生成多个apk，因此所有apk的版本代码需要不同，因为Google Play控制台不允许您上传具有相同版本代码的apk。</p><p id="fda1" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">因此，如果你的单个APK的当前版本代码是1，那么你的具有多个apk的应用的下一个版本不应该是2 ( <code class="fe ob oc od oe b">x86</code>)、3 ( <code class="fe ob oc od oe b">x86_64</code>)、4 ( <code class="fe ob oc od oe b">armeabi-v7a</code>)和5 ( <code class="fe ob oc od oe b">arm64-v8a</code>)。这是一种不好的做法，对你来说会更难管理。</p><p id="9ba8" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">相反，最好有一个巨大的十进制数，并为每个架构分配“代码”，如下所示:</p><ul class=""><li id="cbbb" class="ns nt iq la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">x86</code> : 0</li><li id="1186" class="ns nt iq la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">x86_64</code> : 1</li><li id="fb65" class="ns nt iq la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">armeabi-v7a</code> : 2</li><li id="2c9d" class="ns nt iq la b lb of le og lh oh ll oi lp oj lt nx ny nz oa bi translated"><code class="fe ob oc od oe b">arm64-v8a</code> : 3</li></ul><p id="afec" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">然后，您的应用程序的版本代码将看起来像2000 ( <code class="fe ob oc od oe b">x86</code>)、2001 ( <code class="fe ob oc od oe b">x86_64</code>)、2002( <code class="fe ob oc od oe b">armeabi-v7a</code>)和2003( <code class="fe ob oc od oe b">arm64-v8a</code>)，下一个版本代码将是3000、3001、3002和3003。你明白了。</p><h2 id="7dc5" class="ol mu iq bd mv om on dn mz oo op dp nd lh oq or nf ll os ot nh lp ou ov nj ow bi translated">现在，让我们进入实际部分，深入我们的应用程序级<code class="fe ob oc od oe b">build.gradle</code>文件:</h2><p id="3b50" class="pw-post-body-paragraph ky kz iq la b lb nl jr ld le nm ju lg lh nn lj lk ll no ln lo lp np lr ls lt ij bi translated">下面是您的应用程序级<code class="fe ob oc od oe b">build.gradle</code>文件，启用了APK分割应该是什么样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox kx l"/></div></figure><p id="1dcd" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在，生成您的新apk，您应该会看到单个的、特定于体系结构的apk的大小显著减小！</p><p id="055c" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您可以将生成的4个apk上传到Google Play控制台，因为它们都有不同的版本代码。</p><p id="0e1c" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">用户将只能从Play Store下载特定于他们手机架构的APK版本，这一切都是在幕后进行的，这要感谢Google Play控制台的魔力。</p><p id="c357" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">最精彩的部分？我的应用SilverScreener的APK大小现在是<strong class="la ir"> 3.1MB </strong>！</p><p id="a39a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">以下是APK拆分前后的对比:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/06be628be2b144bdf6a2cac70eb44dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KEYD-Y-h-NFm3nwubJzESw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">SQLite vs Realm vs带APK分裂的Realm:APK大小比较</p></figure></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="de88" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">外卖</h1><p id="9d37" class="pw-post-body-paragraph ky kz iq la b lb nl jr ld le nm ju lg lh nn lj lk ll no ln lo lp np lr ls lt ij bi translated">Realm是一个很棒的数据库，但它也是一个显著增加APK大小的数据库。</p><p id="bc53" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">继续，开始在你的应用程序中使用APK分裂，而不影响文件大小。</p></div></div>    
</body>
</html>