<html>
<head>
<title>Python Bool Type: What Goes On Under The Hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Bool类型:引擎盖下发生了什么</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/python-bool-type-what-goes-on-under-the-hood-260e42aea655?source=collection_archive---------15-----------------------#2021-02-01">https://betterprogramming.pub/python-bool-type-what-goes-on-under-the-hood-260e42aea655?source=collection_archive---------15-----------------------#2021-02-01</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="f873" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">超越真假对bool类型有更深入的理解</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/146810da9042ecfbbc1981476e9ba0bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v1rDS-FPwFXk4zMH"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@kyleunderscorehead?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯尔头</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="33c2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，您将对Python bool类型、其工作原理以及如何在您的Python应用程序中有效地使用它有一个全面的了解。让我们开始吧。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="6c5c" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">1.布尔类型</h1><p id="dfc8" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在Python中，<code class="fe na nb nc nd b">bool</code>数据类型用来表示布尔值— <code class="fe na nb nc nd b">True</code>和<code class="fe na nb nc nd b">False</code>。</p><p id="3186" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如你所知，在Python中一切都是对象。这意味着整数、浮点数、字符串、列表、元组等。都是它们各自类的对象。例如，整数是类<code class="fe na nb nc nd b">int</code>的对象，浮点是类<code class="fe na nb nc nd b">float</code>的对象，列表是类<code class="fe na nb nc nd b">list</code>的对象。</p><p id="9db7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样，布尔值<code class="fe na nb nc nd b">True</code>和<code class="fe na nb nc nd b">False</code>也是类<code class="fe na nb nc nd b">bool</code>的对象。内置的<code class="fe na nb nc nd b">type()</code>函数可以用来学习对象的数据类型。从下面的代码中可以看出，<code class="fe na nb nc nd b">True</code>和<code class="fe na nb nc nd b">False</code>是bool类型，表示类<code class="fe na nb nc nd b">bool</code>的对象。</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="4322" class="ni me iu nd b gz nj nk l nl nm">&gt;&gt;&gt; print(type(True))<br/><strong class="nd iv">&lt;class 'bool'&gt;</strong></span><span id="0c1c" class="ni me iu nd b gz nn nk l nl nm">&gt;&gt;&gt; print(type(False))<br/><strong class="nd iv">&lt;class 'bool'&gt;</strong></span></pre><p id="4da2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">比较值时，布尔值通常用于<code class="fe na nb nc nd b">if</code>和<code class="fe na nb nc nd b">while</code>语句中。</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="4380" class="ni me iu nd b gz nj nk l nl nm">&gt;&gt;&gt; 10 &gt; 100<br/><strong class="nd iv">False</strong></span><span id="174e" class="ni me iu nd b gz nn nk l nl nm">&gt;&gt;&gt; 10 == 10<br/><strong class="nd iv">True</strong></span><span id="8c59" class="ni me iu nd b gz nn nk l nl nm">&gt;&gt;&gt; x, y = 10, 11<br/>&gt;&gt;&gt; if x == y:<br/>...     print("x is equal to y")<br/>... else:<br/>...     print("x is not equal to y")<br/>...<br/><strong class="nd iv">x is not equal to y</strong></span></pre><p id="5d17" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">bool</code>类型是<code class="fe na nb nc nd b">int</code>的子类。因此，它展示了<code class="fe na nb nc nd b">int</code>的所有特性。换句话说，我们可以对布尔值进行数学运算和其他特殊运算。另外，请注意<code class="fe na nb nc nd b"><em class="no">True</em></code> <em class="no">和</em> <code class="fe na nb nc nd b"><em class="no">False</em></code> <em class="no">分别表现为整数1和0。</em></p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="3eff" class="ni me iu nd b gz nj nk l nl nm">&gt;&gt;&gt; int(True)<br/><strong class="nd iv">1</strong><br/>&gt;&gt;&gt; int(False)<br/><strong class="nd iv">0</strong></span><span id="c406" class="ni me iu nd b gz nn nk l nl nm">&gt;&gt;&gt; True == 1<br/><strong class="nd iv">True </strong><br/>&gt;&gt;&gt; False == 0<br/><strong class="nd iv">True</strong><br/>&gt;&gt;&gt; True &gt; 0<br/><strong class="nd iv">True</strong><br/>&gt;&gt;&gt; False &lt; 1<br/><strong class="nd iv">True</strong></span><span id="fb04" class="ni me iu nd b gz nn nk l nl nm">&gt;&gt;&gt; True + True + True<br/><strong class="nd iv">3</strong><br/>&gt;&gt;&gt; True + True + 1<br/><strong class="nd iv">3</strong><br/>&gt;&gt;&gt; True * 3 + False <br/><strong class="nd iv">3</strong><br/>&gt;&gt;&gt; False + False + 3<br/><strong class="nd iv">3</strong></span></pre><p id="6361" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">关于真值及其计算方式的知识对于理解bool类型及其运算至关重要。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="afc2" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">2.真值</h1><p id="a14c" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Python中的每个对象都有其真值。这些真值在计算布尔表达式时很有用。<em class="no">但问题是一个对象什么时候返回</em> <code class="fe na nb nc nd b"><em class="no">True</em></code> <em class="no">或者</em> <code class="fe na nb nc nd b"><em class="no">False</em></code> <em class="no">？</em></p><p id="ce83" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一般来说，所有非零数字和非空序列类型和集合都返回<code class="fe na nb nc nd b">True</code>。类似地，所有值为零的数字和空序列以及包括<code class="fe na nb nc nd b">None</code>在内的集合都返回<code class="fe na nb nc nd b">False</code>。</p><p id="6bd2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">简而言之，除了下面列出的几个返回<code class="fe na nb nc nd b">False</code>的对象之外，几乎所有的对象都返回<code class="fe na nb nc nd b">True</code>:</p><ul class=""><li id="9161" class="np nq iu lc b ld le lg lh lj nr ln ns lr nt lv nu nv nw nx bi translated"><code class="fe na nb nc nd b">None</code>和<code class="fe na nb nc nd b">False</code>。</li><li id="dcc3" class="np nq iu lc b ld ny lg nz lj oa ln ob lr oc lv nu nv nw nx bi translated">值为零的数字:<code class="fe na nb nc nd b">0</code> (int)、<code class="fe na nb nc nd b">0.0</code> (float)、<code class="fe na nb nc nd b">0j</code> (complex)、<code class="fe na nb nc nd b">Decimal(0)</code> (Decimal)、<code class="fe na nb nc nd b">Fraction(0,1)</code> (Fraction)。</li><li id="698e" class="np nq iu lc b ld ny lg nz lj oa ln ob lr oc lv nu nv nw nx bi translated">空序列类型和集合:<code class="fe na nb nc nd b">'’</code>(字符串)、<code class="fe na nb nc nd b">()</code>(元组)、<code class="fe na nb nc nd b">[]</code>(列表)、<code class="fe na nb nc nd b">{}</code>(字典)、<code class="fe na nb nc nd b">set()</code>(集合)、<code class="fe na nb nc nd b">range(0)</code>。</li><li id="f6f5" class="np nq iu lc b ld ny lg nz lj oa ln ob lr oc lv nu nv nw nx bi translated">实现<code class="fe na nb nc nd b">__bool__()</code>或<code class="fe na nb nc nd b">__len__()</code>的自定义类——返回<code class="fe na nb nc nd b">False</code>或<code class="fe na nb nc nd b">zero</code>的方法。</li></ul><h2 id="64ad" class="ni me iu bd mf od oe dn mj of og dp mn lj oh oi mp ln oj ok mr lr ol om mt on bi translated">内部是如何评估真值的？</h2><p id="7c9e" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">这是来自官方文档的定义</p><blockquote class="oo op oq"><p id="86b7" class="la lb no lc b ld le jv lf lg lh jy li or lk ll lm os lo lp lq ot ls lt lu lv in bi translated">一个对象返回<code class="fe na nb nc nd b">True</code>，除非它的类实现了返回<code class="fe na nb nc nd b">False</code>的<code class="fe na nb nc nd b">__bool__()</code>方法或返回零的<code class="fe na nb nc nd b">__len__()</code>方法。</p></blockquote><p id="5d8b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们试着用两个例子来理解这一点。</p><p id="03a0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">例1: </strong>这里，<code class="fe na nb nc nd b">x</code>是引用值10的整数对象。在执行<code class="fe na nb nc nd b">if x</code>的过程中，Python知道它必须评估<code class="fe na nb nc nd b">x</code>的真值。这里<code class="fe na nb nc nd b">x</code>是<code class="fe na nb nc nd b">int</code>类的对象，<code class="fe na nb nc nd b">int</code>类实现<code class="fe na nb nc nd b">__bool__()</code>方法。由于10是非零值，<code class="fe na nb nc nd b">__bool__() </code>返回<code class="fe na nb nc nd b">True</code>，并打印<code class="fe na nb nc nd b">'I am inside if'</code>。</p><p id="4cad" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="no">什么是__bool__()？</em> </strong>真值测试时调用的特殊方法或神奇函数之一。当调用内置函数<code class="fe na nb nc nd b">bool()</code>时，也会调用它。根据前面提到的规则，该方法返回<code class="fe na nb nc nd b">True</code>或<code class="fe na nb nc nd b">False</code>。</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="05ae" class="ni me iu nd b gz nj nk l nl nm">x = 10<br/>if x:<br/>    print('I am inside if')<br/>else:<br/>    print('I am inside else')</span></pre><p id="a870" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">例二:</strong>此处，<code class="fe na nb nc nd b">y</code>为空列表。在执行<code class="fe na nb nc nd b">if y</code>的过程中，Python会计算y的真值。这里<code class="fe na nb nc nd b">y</code>是<code class="fe na nb nc nd b">list</code>类的一个对象，<code class="fe na nb nc nd b">list</code>类实现<code class="fe na nb nc nd b">__len__()</code>方法。如前所述，对于空序列类型，如列表，<code class="fe na nb nc nd b">__len__()</code>，返回<code class="fe na nb nc nd b">False</code>并打印<code class="fe na nb nc nd b">'I am inside else'</code>。</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="5f6f" class="ni me iu nd b gz nj nk l nl nm">y = 10</span><span id="0797" class="ni me iu nd b gz nn nk l nl nm">if y:<br/>    print('I am inside if')<br/>else:<br/>    print('I am inside else')</span></pre><p id="93fd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="no">什么是__len__()？</em> </strong>这也是调用内置函数<code class="fe na nb nc nd b">len()</code>时调用的特殊方法或神奇函数之一。当对象是空序列类型或集合时，该方法返回<code class="fe na nb nc nd b">True</code>或<code class="fe na nb nc nd b">False</code>。</p><p id="c814" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，简而言之，在真值评估期间，首先在对象上调用<code class="fe na nb nc nd b">__bool__()</code>方法。如果没有定义<code class="fe na nb nc nd b">__bool__()</code>方法，则调用<code class="fe na nb nc nd b">__len__()</code>方法。如果没有为该类定义这两者，那么它将为其所有实例返回<code class="fe na nb nc nd b">True</code>。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="6cd8" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">3.bool()方法</h1><p id="07c1" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">bool方法<code class="fe na nb nc nd b">bool()</code>接受一个参数<code class="fe na nb nc nd b">x</code>并返回其真值<code class="fe na nb nc nd b"> True</code>或<code class="fe na nb nc nd b">False</code>。有些类实现了<code class="fe na nb nc nd b">__bool__()</code>，有些实现了<code class="fe na nb nc nd b">__len__()</code>。所以不用逐个检查，可以用<code class="fe na nb nc nd b">bool()</code>。当我们使用bool时，Python首先自动调用<code class="fe na nb nc nd b">__bool__()</code>方法。如果<code class="fe na nb nc nd b">__bool__()</code>未定义，则调用<code class="fe na nb nc nd b">__len__()</code>方法。如果没有为该类定义这两者，那么它将为其所有实例返回<code class="fe na nb nc nd b">True</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="6126" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">4.布尔运算符和优先级</h1><p id="b10b" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">布尔运算符有:<strong class="lc iv"/><code class="fe na nb nc nd b">and</code><code class="fe na nb nc nd b">or</code><code class="fe na nb nc nd b">not</code>。</p><p id="3d71" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">布尔运算符以及其他运算符的优先级如下所示。该列表按照优先级的升序排列，即优先级最低的在顶部，优先级最高的在底部。从列表中可以看出，布尔运算符的优先级如下:<code class="fe na nb nc nd b">not</code>、<code class="fe na nb nc nd b">and</code>、<code class="fe na nb nc nd b">or</code> ( <code class="fe na nb nc nd b">not</code>优先级较高，<code class="fe na nb nc nd b"> or</code>优先级最低)。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ow"><img src="../Images/71d2fdf4a82abe04e778db6e88006200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pw7zJ6Y_DmrN06RJs5XaWQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">来源:<a class="ae kz" href="https://docs.python.org/3/reference/expressions.html#operator-precedence" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/reference/expressions . html # operator-precedence</a></p></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="8ebb" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">5.短路</h1><p id="14af" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在Python中，布尔运算符<code class="fe na nb nc nd b">and</code>和<code class="fe na nb nc nd b">or</code>的工作方式不同，使用了一种叫做短路的技术。下表总结了<code class="fe na nb nc nd b">and</code>和<code class="fe na nb nc nd b">or</code>的短路操作符。注意，<code class="fe na nb nc nd b">or</code>操作符和许多其他操作符一样，返回<code class="fe na nb nc nd b">0</code>或<code class="fe na nb nc nd b">False</code>为假，返回<code class="fe na nb nc nd b">1</code>或<code class="fe na nb nc nd b">True</code>为真。</p><p id="3158" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="no">注意</em> <code class="fe na nb nc nd b"><em class="no">and</em></code> <em class="no">和</em> <code class="fe na nb nc nd b"><em class="no">or</em></code> <em class="no">运算符不返回</em> <code class="fe na nb nc nd b"><em class="no">True</em></code> <em class="no">或</em> <code class="fe na nb nc nd b"><em class="no">False</em></code> <em class="no">。而是两者都返回</em> <code class="fe na nb nc nd b"><em class="no">x</em></code> <em class="no">或者</em> <code class="fe na nb nc nd b"><em class="no">y</em></code> <em class="no">。这是短路。</em></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ox"><img src="../Images/336ac6d30c247d524e87c069344d56b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*beG9ZKADKL1NN3YJ2HX-VQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="30b2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看一些例子来更好地理解短路操作。如你所见，布尔运算符<code class="fe na nb nc nd b">and</code>和<code class="fe na nb nc nd b">or</code>不返回<code class="fe na nb nc nd b">True</code>或<code class="fe na nb nc nd b">False</code>。相反，它们都返回第一个操作数(x)或第二个操作数(y)。</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="9e41" class="ni me iu nd b gz nj nk l nl nm">&gt;&gt;&gt; x, y, z = 10, 20, 0<br/>&gt;&gt;&gt; not z<br/><strong class="nd iv">True</strong></span><span id="6c62" class="ni me iu nd b gz nn nk l nl nm">&gt;&gt;&gt; not x<br/><strong class="nd iv">False</strong></span><span id="20ed" class="ni me iu nd b gz nn nk l nl nm">&gt;&gt;&gt; x and y<br/><strong class="nd iv">20</strong></span><span id="f75e" class="ni me iu nd b gz nn nk l nl nm">&gt;&gt;&gt; x and z<br/><strong class="nd iv">0</strong></span><span id="b9d6" class="ni me iu nd b gz nn nk l nl nm">&gt;&gt;&gt; x or y<br/><strong class="nd iv">10</strong></span><span id="f170" class="ni me iu nd b gz nn nk l nl nm">&gt;&gt;&gt; x or z<br/><strong class="nd iv">10</strong></span></pre><h1 id="0cb3" class="md me iu bd mf mg oy mi mj mk oz mm mn ka pa kb mp kd pb ke mr kg pc kh mt mu bi translated">结论</h1><p id="9df2" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在本文中，您已经非常详细地了解了布尔运算符。您必须了解在python对象的真值测试过程中幕后发生了什么。您还学习了<code class="fe na nb nc nd b">bool()</code>方法、运算符优先级和短路操作。</p><h1 id="0024" class="md me iu bd mf mg oy mi mj mk oz mm mn ka pa kb mp kd pb ke mr kg pc kh mt mu bi translated">进一步阅读</h1><ul class=""><li id="0616" class="np nq iu lc b ld mv lg mw lj pd ln pe lr pf lv nu nv nw nx bi translated"><a class="ae kz" href="https://medium.com/towards-artificial-intelligence/6-interesting-facts-you-are-less-familiar-with-python-int-data-type-86ebb378a2e2" rel="noopener"> 6个有趣的事实你不太熟悉Python Int数据类型</a></li><li id="307e" class="np nq iu lc b ld ny lg nz lj oa ln ob lr oc lv nu nv nw nx bi translated"><a class="ae kz" href="https://medium.com/towards-artificial-intelligence/6-interesting-facts-you-are-less-familiar-with-python-float-data-type-ce118727016b" rel="noopener"> 6个有趣的事实你不太熟悉Python浮点数据类型</a></li><li id="e6e9" class="np nq iu lc b ld ny lg nz lj oa ln ob lr oc lv nu nv nw nx bi translated">W <a class="ae kz" href="https://medium.com/towards-artificial-intelligence/why-should-you-understand-decimal-data-type-as-a-python-developer-1bf078c97ab7" rel="noopener">作为一名Python开发者，你为什么应该理解十进制数据类型</a></li><li id="42d9" class="np nq iu lc b ld ny lg nz lj oa ln ob lr oc lv nu nv nw nx bi translated"><a class="ae kz" href="https://towardsdatascience.com/understanding-reference-counting-in-python-3894b71b5611" rel="noopener" target="_blank">理解Python中的引用计数</a></li><li id="cc8c" class="np nq iu lc b ld ny lg nz lj oa ln ob lr oc lv nu nv nw nx bi translated"><a class="ae kz" href="https://towardsdatascience.com/optimization-in-python-interning-805be5e9fd3e" rel="noopener" target="_blank">Python中的实习优化技术</a></li><li id="e778" class="np nq iu lc b ld ny lg nz lj oa ln ob lr oc lv nu nv nw nx bi translated"><a class="ae kz" href="https://levelup.gitconnected.com/optimization-in-python-peephole-e9dc84cc184d" rel="noopener ugc nofollow" target="_blank">Python中的窥视孔优化技术</a></li></ul><p id="3b42" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望你喜欢阅读这篇文章。如果你喜欢我的文章并想订阅Medium，你可以在这里这样做: </p><div class="pg ph gq gs pi pj"><a href="https://chetanambi.medium.com" rel="noopener follow" target="_blank"><div class="pk ab fp"><div class="pl ab pm cl cj pn"><h2 class="bd iv gz z fq po fs ft pp fv fx it bi translated">Chetan Ambi -介质</h2><div class="pq l"><h3 class="bd b gz z fq po fs ft pp fv fx dk translated">阅读Chetan Ambi在媒体上的文章。数据科学|机器学习| Python。参观https://pythonsimplified.com/…</h3></div><div class="pr l"><p class="bd b dl z fq po fs ft pp fv fx dk translated">chetanambi.medium.com</p></div></div><div class="ps l"><div class="pt l pu pv pw ps px kt pj"/></div></div></a></div></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="a273" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">参考</h1><p id="def0" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">[1].<a class="ae kz" href="https://docs.python.org/3/library/stdtypes.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/stdtypes.html</a></p><p id="ff8e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">[2].<a class="ae kz" href="https://www.python.org/dev/peps/pep-0285/" rel="noopener ugc nofollow" target="_blank">https://www.python.org/dev/peps/pep-0285/</a></p></div></div>    
</body>
</html>