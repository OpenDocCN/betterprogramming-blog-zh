<html>
<head>
<title>Implementing SwiftUI’s OnChange Modifier for iOS 13</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为iOS 13实现SwiftUI的OnChange修改器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-swiftui-onchange-support-for-ios13-577f9c086c9?source=collection_archive---------7-----------------------#2021-03-16">https://betterprogramming.pub/implementing-swiftui-onchange-support-for-ios13-577f9c086c9?source=collection_archive---------7-----------------------#2021-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cbcd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们为最新的SwiftUI特性添加向后兼容支持</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7d745c627f309da71c2978cb7a735133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MUs327C368bJVbAm"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Patrick Ward 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="d180" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着iOS 14的发布，SwiftUI获得了一些强大的新功能。但如果你仍然坚持支持iOS 13平台，那么这对你没有太大好处，不是吗？</p><p id="0883" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近需要在一个项目中使用<code class="fe ls lt lu lv b">onChange</code>视图修改器，但我很快意识到它在iOS 13部署目标上不受支持。下面是XCode给我的一个大错误:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/cfb07c79bee1cd43b39d6f8ab31f8426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fUSxgk7SxI3xzInB760rRw.png"/></div></div></figure><p id="79ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，iOS 13已经有了一个简单的变通方法。看看我下面做的这个<code class="fe ls lt lu lv b">Picker</code>，选出你最喜欢的水果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lx"><img src="../Images/5cfd2c7eda3a6f6be2d4d7927a52e5e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tr0Hgn1bWwIJIWxgHlbSQw.png"/></div></div></figure><p id="aa39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们想在选择的水果发生变化时打印到控制台。</p><p id="0e06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们如何实现这一目标？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ly"><img src="../Images/38d7bcec893c74dc0387f6947180ef91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6YSgNwNWkBSEUkypcTBHvw.png"/></div></div></figure><p id="3180" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们实际上可以使用<code class="fe ls lt lu lv b">onReceive</code>来监听给定的发布者，当然，你也可以使用早在iOS 13的<code class="fe ls lt lu lv b">onReceive</code>钩子。</p><p id="9684" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是要创建一个<code class="fe ls lt lu lv b">Publisher</code>来监听我们的<code class="fe ls lt lu lv b">selectedFruit</code>变量的变化，我们必须将它包装在一个<code class="fe ls lt lu lv b">Just</code>发布器中。<code class="fe ls lt lu lv b">Just</code>是<code class="fe ls lt lu lv b">Publisher</code>的内置类型，<em class="lz">只是</em>监听给定变量的变化。如果你愿意，你可以自己测试一下。你可以在这个<a class="ae kv" href="https://gist.github.com/zane-carter/ded575291e446e74b2870e6675c3a609" rel="noopener ugc nofollow" target="_blank">要点</a>中找到完整的代码。你可以在苹果开发者上阅读关于<code class="fe ls lt lu lv b">Just</code>出版商<a class="ae kv" href="https://developer.apple.com/documentation/combine/just" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="78ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lz">注意:</em> <code class="fe ls lt lu lv b"><em class="lz">Just</em></code> <em class="lz">需要</em> <code class="fe ls lt lu lv b"><em class="lz">Combine</em></code> <em class="lz">，所以一定要用</em> <code class="fe ls lt lu lv b"><em class="lz">import Combine</em></code> <em class="lz">。</em></p><p id="8898" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，这并不便于您跨平台实现。您仍然需要使用<code class="fe ls lt lu lv b">@available</code>语句在<code class="fe ls lt lu lv b">onReceive</code>和<code class="fe ls lt lu lv b">onChange</code>之间手动切换，或者只使用<code class="fe ls lt lu lv b">onReceive</code>修饰符。</p><p id="0f2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让事情变得简单一点，我做了一个定制的<code class="fe ls lt lu lv b">onChange</code>修改器，在iOS 13中使用这个<code class="fe ls lt lu lv b">onReceive</code>。但是如果你最终为iOS 14目标编译，你可以充分利用苹果自己的<code class="fe ls lt lu lv b">onChange</code>修改器。</p><p id="17ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面，你可以看到苹果的<code class="fe ls lt lu lv b">onChange</code>修饰符的定义，右击<code class="fe ls lt lu lv b">onChange</code>并选择<code class="fe ls lt lu lv b">Jump To Definition.</code>，如果你愿意，你可以自己在XCode中测试一下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ly"><img src="../Images/a8a7be5a4430416de74bdd3bf3f72569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFqpM8virdw2C-DQMgwF9A.png"/></div></div></figure><p id="ca8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所料，定义上方有一个<code class="fe ls lt lu lv b">@available</code>标签，指明这仅在iOS 14或更高版本上可用。我们将通过iOS 13和iOS 14的实现来做出自己的定义。为了避免混淆编译器，我们将稍微不同地命名我们的实现。我们新的向后兼容修饰符将被称为<code class="fe ls lt lu lv b">valueChanged</code>。</p><p id="8d1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决方案是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="f81f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在iOS 13+的任何项目中安全地使用这个新的<code class="fe ls lt lu lv b">valueChanged</code>修改器。一旦你结束了为iOS 14目标的编译，你可以确定你的项目已经利用了苹果的<code class="fe ls lt lu lv b">onChange</code>修改器。</p><p id="1c15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>