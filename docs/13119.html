<html>
<head>
<title>SwiftUI Managed Views</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI管理的视图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-managed-views-506e2d74368f?source=collection_archive---------2-----------------------#2022-07-31">https://betterprogramming.pub/swiftui-managed-views-506e2d74368f?source=collection_archive---------2-----------------------#2022-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="029a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何克服环境、环境对象和其他属性包装的一些限制。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/301eff1310ee20d5e798d81db7d195f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SdvpoUY5zJj2-LWLbS67gA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@charlesdeluvio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> charlesdeluvio </a>在<a class="ae ky" href="https://unsplash.com/s/photos/manager?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="26d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我之前写过一篇关于如何编写“可测试的”视图的文章。在那里，我展示了一些无需创建完整的视图模型就可以将逻辑和其他代码从视图体中分离出来的方法。</p><p id="9c25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是SwiftUI的<code class="fe lv lw lx ly b">Environment</code>和<code class="fe lv lw lx ly b">EnvironmentObject</code>属性包装器会使这种方法变得具有挑战性并且难以完成。在这篇文章中，我将说明这是为什么，然后演示几个解决问题的方法。</p><p id="db67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先看看我们想要完成什么。</p><h1 id="c93c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">可测试的视图</h1><p id="8e6a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">基本上，编写可测试的视图意味着将嵌入了条件业务逻辑的代码和格式如下…</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="02ab" class="na ma it ly b gy nb nc l nd ne">struct OrderDetailsListView: View {<br/>    var order: Order<br/>    var body: some View {<br/>        Form {<br/>            ForEach(order.items) { item in<br/>                 HStack {<br/>                     if item.quantity == 1 {<br/>                         Text(item.name)<br/>                     } else {<br/>                         Text("\(item.name) $(\(item.quantity, specifier: "%.2f") @ $\(item.price, specifier: "%.2f")")<br/>                     }<br/>                     Spacer()<br/>                     Text("$(\(item.total, specifier: "%.2f")")<br/>                 }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="9d3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变成类似这样的代码...</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="4cd4" class="na ma it ly b gy nb nc l nd ne">struct OrderDetailsListView: View {<br/>    let order: Order<br/>    var body: some View {<br/>       Form {<br/>           ForEach(order.items) { item in<br/>               OrderDetailsRowView(item: item)<br/>           }<br/>       }<br/>    }<br/>}</span><span id="0c8f" class="na ma it ly b gy nf nc l nd ne">struct OrderDetailsRowView: View {<br/>    var item: OrderItem<br/>    var body: some View {<br/>        HStack {<br/>            Text(itemDescription)<br/>            Spacer()<br/>            Text(itemTotal)<br/>        }<br/>    }<br/>    var itemDescription: String {<br/>        if item.quantity == 1 {<br/>            return item.name<br/>        } else {<br/>            return "\(item.name) (\(item.formattedQuantity) @ \(item.formattedPrice))"<br/>        }<br/>    }<br/>    var itemTotal: String {<br/>        item.formattedTotal<br/>    }<br/>}</span></pre><p id="47e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，这里有更多的代码，但是请注意列表视图和细节视图的视图体现在是多么的简单。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="b1a9" class="na ma it ly b gy nb nc l nd ne">    var body: some View {<br/>       Form {<br/>           ForEach(order.items) { item in<br/>               OrderDetailsRowView(item: item)<br/>           }<br/>       }<br/>    }</span><span id="c536" class="na ma it ly b gy nf nc l nd ne">    var body: some View {<br/>        HStack {<br/>            Text(itemDescription)<br/>            Spacer()<br/>            Text(itemTotal)<br/>        }<br/>    }</span></pre><p id="a8da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果他们访问的项目是正确的，那么根据定义，视图本身也必须是正确的。实际上没什么会出错的。</p><p id="e8da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，通过将项目描述和项目总代码分解成单独的、不同的、可见的变量，现在也可以实例化视图并<strong class="lb iu">测试<em class="ng"> </em> </strong>视图的逻辑。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="02c9" class="na ma it ly b gy nb nc l nd ne">func testOrderDetailsRowView() {</span><span id="4492" class="na ma it ly b gy nf nc l nd ne">    let view1 = OrderDetailsRowView(item: OrderItem.mock1)<br/>    XCTAssert(view1.itemDescription == "Soft Drink")<br/>    XCTAssert(view1.itemTotal == "$1.99")</span><span id="082f" class="na ma it ly b gy nf nc l nd ne">    let view2 = OrderDetailsRowView(item: OrderItem.mock2)<br/>    XCTAssert(view2.itemDescription == "Cheeseburger (2 @ $4.99)")<br/>    XCTAssert(view2.itemTotal == "$9.98")</span><span id="233d" class="na ma it ly b gy nf nc l nd ne">}</span></pre><p id="ae72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，这种事情通常是通过向视图添加一个视图模型，然后测试它来完成的。但是添加一个单独的视图模型来管理这两种情况是多余的，完全没有必要。</p><h1 id="57fe" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">环境变量</h1><p id="654c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">注意，<code class="fe lv lw lx ly b">OrderDetailsRowView</code>视图很容易创建和测试，因为它是用一个简单的结构作为参数初始化的。</p><p id="f1d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，当我想从其他地方获取信息时，会发生什么呢？比如说，环境？考虑:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="e2bd" class="na ma it ly b gy nb nc l nd ne">struct AccountsMenuItem: View {<br/>    @Environment(\.userAccounts) private var accounts<br/>    var body: some View {<br/>        if accounts.count == 0 {<br/>            NavigationMenuItem("Create Account!", icon: "person") {<br/>                NewAccountView()<br/>            }<br/>        } else {<br/>            NavigationMenuItem(manageName, icon: imageName) {<br/>                ManageAccountsView()<br/>            }<br/>         }<br/>    }<br/>    var manageName: String {<br/>        accounts.count &gt; 1 ? "Manage Accounts" : "Manage Account"<br/>    }<br/>    var imageName: String {<br/>        accounts.count &gt; 1 ? "person.2" : "person"<br/>    }<br/>}</span></pre><p id="c52f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我没有帐户，这个来自设置屏幕的视图将返回一个不同的导航项目来创建一个帐户，或者如果我有，返回一个项目来管理我的帐户。此外，显示的名称和图标都根据帐户数量而变化。</p><p id="5568" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可以很容易地在Xcode中预览<code class="fe lv lw lx ly b">AccountsMenuItem</code>视图，通过<code class="fe lv lw lx ly b">.environment</code>修改器提供不同的值。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="b6ed" class="na ma it ly b gy nb nc l nd ne">struct AccountsMenuItem_Previews: PreviewProvider {<br/>    static var previews: some View {<br/>        Group {<br/>            AccountsMenuItem()<br/>                .environment(\.userAccounts, [])<br/>            AccountsMenuItem()<br/>                .environment(\.userAccounts, Account.mockAccounts)<br/>        }<br/>    }<br/>}</span></pre><p id="4493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从预告片中，我可以相当肯定地说这是正确的。</p><p id="b1b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我想写和我最初的例子一样的单元测试呢？如果我想确保我的视图的逻辑在现在和将来都是正确的，也许是在别人改变了它之后，该怎么办？</p><p id="081d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是问题开始出现的地方。即使没有标记为private，我们也不能用参数实例化视图，因为<code class="fe lv lw lx ly b">Environment</code>属性包装器没有接受新默认值的初始化器。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="28d0" class="na ma it ly b gy nb nc l nd ne">let view = AccountsMenuItem(accounts: []) // FAILS</span></pre><p id="d317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也不能使用<code class="fe lv lw lx ly b">.environment(key, value)</code>属性。在SwiftUI之外不存在<code class="fe lv lw lx ly b">environment</code>栈，对我们的视图应用修饰符的结果会导致我们的视图被包装在一个<code class="fe lv lw lx ly b">ModifiedContent</code>结构中。我们再也看不到测试它们的变量了。</p><p id="0c06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也不能把它丢回<code class="fe lv lw lx ly b">AccountsMenuItem</code>。同样修改过的内容包装器也妨碍了这一点。</p><p id="0f13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以。我们被困住了吗？</p><h1 id="d416" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">环境诡计</h1><p id="7ef4" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如果您有自己的环境变量，那么您可以通过创建自己的<code class="fe lv lw lx ly b">EnvironmentKey</code>和默认值来实现。标准代码看起来像这样。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="e80a" class="na ma it ly b gy nb nc l nd ne">struct AccountsEnvironmentKey: EnvironmentKey {<br/>    static let defaultValue: [Account] = []<br/>}</span><span id="4d4d" class="na ma it ly b gy nf nc l nd ne">extension EnvironmentValues {<br/>    var userAccounts: [Account] {<br/>        get { self[AccountsEnvironmentKey.self] }<br/>        set { self[AccountsEnvironmentKey.self] = newValue }<br/>    }<br/>}</span></pre><p id="7736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决我们问题的“诀窍”是如下定义我们的密钥:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="4bde" class="na ma it ly b gy nb nc l nd ne">struct AccountsEnvironmentKey: EnvironmentKey {<br/>    static var defaultValue: [Account] = []<br/>}</span></pre><p id="280b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们所做的只是将<code class="fe lv lw lx ly b">defaultValue</code>从<code class="fe lv lw lx ly b">let</code>改为<code class="fe lv lw lx ly b">var</code>。一旦我们做到了这一点，我们就可以这样做…</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="049b" class="na ma it ly b gy nb nc l nd ne">func testSingleAccount() throws {<br/>    AccountsEnvironmentKey.defaultValue = [Account.mockSavings]<br/>    let view1 = AccountsMenuItem()<br/>    XCTAssert(view1.manageName == "Manage Account")<br/>    XCTAssert(view1.imageName == "person")<br/>}</span><span id="6d57" class="na ma it ly b gy nf nc l nd ne">func testMultipleAccounts() throws {<br/>    AccountsEnvironmentKey.defaultValue = Account.mockAccounts<br/>    let view2 = AccountsMenuItem()<br/>    XCTAssert(view2.manageName == "Manage Accounts")<br/>    XCTAssert(view2.imageName == "person.2")<br/>}</span></pre><p id="1f3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当以这种方式创建时，<code class="fe lv lw lx ly b">AccountsMenuItem</code>默认(抱歉)使用我们之前设置的<code class="fe lv lw lx ly b">defaultValue</code>。</p><p id="d817" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以嘲笑我们的观点并检验它们。</p><h1 id="4b8b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">啐</h1><p id="1e1b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如果你现在觉得“恶心”，我倾向于同意你的观点，但请记住几件事。</p><ol class=""><li id="086e" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">苹果把<code class="fe lv lw lx ly b">@Environment</code>标记为final或者没有提供一个能够接受新默认值的初始化器不是我的错。</li><li id="3168" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">我们只在测试期间接触到<code class="fe lv lw lx ly b">AccountsEnvironmentKey</code>。希望，任何在主应用程序中这样做的人在代码审查期间都会受到惩罚。</li><li id="4afb" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">另一个解决方案来了。</li></ol><p id="b686" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但至少现在你知道，如果需要的话，解决方案是可能的。</p><h1 id="482f" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">环境对象</h1><p id="c6af" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">那么环境对象呢？我们能在那里做同样的事情吗？</p><p id="46e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遗憾的是，我们不能(简短讨论，即)。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="646e" class="na ma it ly b gy nb nc l nd ne">struct AccountsMenuItem: View {<br/>    @EnvironmentObject var manager: AccountManager<br/>    var body: some View {<br/>        if isEmpty {<br/>            NavigationMenuItem("Create Account!", icon: "person") {<br/>                NewAccountView()<br/>            }<br/>        } else {<br/>            NavigationMenuItem(manageName, icon: imageName) {<br/>                ManageAccountsView()<br/>            }<br/>         }<br/>    }<br/>    var isEmpty: Bool {<br/>        manager.accounts.isEmpty<br/>    }<br/>    var hasMultipleAccounts: Bool {<br/>        manager.accounts.count &gt; 1<br/>    }<br/>    var manageName: String {<br/>        hasMultipleAccounts ? "Manage Accounts" : "Manage Account"<br/>    }<br/>    var imageName: String {<br/>        hasMultipleAccounts ? "person.2" : "person"<br/>    }<br/>}</span></pre><p id="a80c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<code class="fe lv lw lx ly b">Environment</code>一样，<code class="fe lv lw lx ly b">EnvironmentObject</code>属性包装器没有能够接受新默认值的初始化器；当我们测试时，我们没有环境；再次使用<code class="fe lv lw lx ly b">environmentObject</code>修饰符将视图紧密地包围在<code class="fe lv lw lx ly b">ModifiedContent</code>结构中。</p><p id="094a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那我们该怎么办？</p><h1 id="04c2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">托管视图</h1><p id="7913" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">这里的解决方案是创建我称之为“受管理的”视图。为此，我们进一步将视图组合成两个独立的视图。一种方法是从环境中提取所需的数据，然后将数据传递给实际显示数据的视图。</p><p id="1d2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">外部视图是经理。内部视图是托管的。</p><p id="819d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的视图管理器。同样，它的工作很简单。从环境中提取值，并将其传递给托管视图。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="4992" class="na ma it ly b gy nb nc l nd ne">struct AccountsMenuItem: View {<br/>    @EnvironmentObject private var manager: AccountManager<br/>    var body: some View {<br/>        ManagedAccountsMenuItem(accounts: manager.accounts)<br/>    }<br/>}</span></pre><p id="1be3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是托管视图。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="44d5" class="na ma it ly b gy nb nc l nd ne">struct ManagedAccountsMenuItem: View {<br/>    var accounts: [Account]<br/>    var body: some View {<br/>        if accounts.count == 0 {<br/>            NavigationMenuItem("Create Account!", icon: "person") {<br/>                NewAccountView()<br/>            }<br/>        } else {<br/>            NavigationMenuItem(manageName, icon: imageName) {<br/>                ManageAccountsView()<br/>            }<br/>         }<br/>    }<br/>    var manageName: String {<br/>        accounts.count &gt; 1 ? "Manage Accounts" : "Manage Account"<br/>    }<br/>    var imageName: String {<br/>        accounts.count &gt; 1 ? "person.2" : "person"<br/>    }<br/>}</span></pre><p id="1d10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，就像我们的第一个例子一样，<code class="fe lv lw lx ly b">ManagedAccountsMenuItem</code>现在采用了一个简单的值类型，很容易用我们希望的任何值进行实例化。</p><p id="1088" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们使用<em class="ng">那个</em>视图进行测试。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="a831" class="na ma it ly b gy nb nc l nd ne">func testSingleAccount() throws {<br/>    let accounts: [Account] = []<br/>    let view1 = ManagedAccountsMenuItem(accounts: accounts)<br/>    XCTAssert(view1.manageName == "Manage Account")<br/>    XCTAssert(view1.imageName == "person")<br/>}<br/>func testMultipleAccounts() throws {<br/>    let accounts = Account.mockAccounts<br/>    let view2 = ManagedAccountsMenuItem(accounts: accounts)<br/>    XCTAssert(view2.manageName == "Manage Accounts")<br/>    XCTAssert(view2.imageName == "person.2")<br/>}</span></pre><p id="5587" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，在管理器中没有什么可以测试的。它无法控制是否存在。它在那里只是为了交接。</p><p id="78e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们甚至可以使用相同的技巧来改进我们最初的、有点令人讨厌的解决方案。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="5f9e" class="na ma it ly b gy nb nc l nd ne">struct AccountsMenuItem: View {<br/>    @Environment(\.userAccounts) private var accounts<br/>    var body: some View {<br/>        ManagedAccountsMenuItem(accounts: accounts)<br/>    }<br/>}</span></pre><p id="26b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们在这里使用了与之前相同的<code class="fe lv lw lx ly b">ManagedAccountsMenuItem</code>视图。该视图不关心账户数据来自哪里，它只显示它被告知要显示的内容。</p><h1 id="3883" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">查看模型</h1><p id="b657" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">“但是，迈克尔”，你可能会问，“为什么不简单地使用一个视图模型，并完成它。”</p><p id="8b4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以。但是有一些反对这样做的理由；</p><ol class=""><li id="10e4" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">我们现在需要创建和管理一个相对重量级的<code class="fe lv lw lx ly b">ObservableObject</code>，并将其分配给视图。结构比堆上分配的对象更有性能。</li><li id="b3a7" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">我们现在必须弄清楚如何用我们可能需要的不同类型的数据构建<strong class="lb iu">视图模型</strong>的原型。我已经在另一篇文章中展示了如何做到这一点，但是这并不像看起来那么简单。</li><li id="d08b" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">我们当前的设计拥有来自SwiftUI环境的数据。要使用视图模型，我们需要弄清楚如何将数据从视图的环境或环境对象中获取到视图模型中。不用说，<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/swiftui-were-loading-we-re-loading-7d689fa8b0c7">那里也有问题</a>。</li><li id="e9ae" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">或者，我们需要完全跳过环境，自己想办法管理数据。话说回来，这可能不是一个选择。</li></ol><p id="724c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎所有上述情况都会导致额外的复杂情况和需要解决的问题。以我们写更多的代码结束。</p><h1 id="29d6" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">SwiftUI属性包装</h1><p id="d262" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">SwiftUI提供了用于管理核心数据的属性包装器，或者允许您从其他来源获取应用程序和用户信息。Google为Realm提供了方便的包装器，还有很多其他的。</p><p id="1971" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果您使用它们，您可能会遇到我在这里使用SwiftUI的环境属性包装器时遇到的许多相同的困难。</p><p id="e033" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，你现在知道一个解决方案。</p><p id="2898" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用所有这些属性包装器会导致其他架构问题。但这可能是另一篇文章，改天。</p><h1 id="8d93" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">体系结构</h1><p id="4b40" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在软件架构中有一个老笑话，关于任何问题都可以通过简单地添加另一层来解决。</p><p id="e577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样的情况也经常发生在SwiftUI中。只有在这里我可以说，几乎任何问题都可以通过将一个视图分解成更小的、组合良好的视图来解决。</p><p id="d4a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">苹果公司一直在重复这个话题，T2也是，我也是。SwiftUI视图不是视图，它们是轻量级的视图<em class="ng">定义</em>，在创建和使用它们的过程中几乎没有性能损失。</p><p id="39bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动手吧。</p><h1 id="c451" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">完成块</h1><p id="5c8f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">今天到此为止。</p><p id="c261" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为SwiftUI开发社区正在慢慢完善创建成功的SwiftUI应用程序所需的一些核心原则和设计模式。</p><p id="9f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是其中之一。</p><p id="c6f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往，如果你喜欢你所看到的，请按住“喜欢”按钮，并在下面留下你的问题或评论。</p></div></div>    
</body>
</html>