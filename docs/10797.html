<html>
<head>
<title>How To Build a CI/CD Pipeline for Kubernetes Stateful Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为Kubernetes有状态应用程序构建CI/CD管道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-ci-cd-pipeline-for-kubernetes-stateful-applications-aef6c8c5edc2?source=collection_archive---------19-----------------------#2022-01-27">https://betterprogramming.pub/how-to-build-a-ci-cd-pipeline-for-kubernetes-stateful-applications-aef6c8c5edc2?source=collection_archive---------19-----------------------#2022-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b00c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第1部分:让我们开始吧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/084f034c2869b10d0d36a37c62ae7fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HhWnphPYIBhLcaMz"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@mourimoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mourizal Zativa </a>拍摄的照片</p></figure><p id="475c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">这一系列的帖子将带您体验构建一个简单(但很酷)的有状态应用程序的实践，这个应用程序是为运行在Kubernetes上而设计的。第1部分搭建了舞台。</em></p><p id="e12e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">链接到</em> <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-a-ci-cd-pipeline-for-kubernetes-stateful-applications-2d6676713397?sk=dc1ddae00099f55160f1f0eb60587404"> <em class="lv">第二部分</em> </a> <em class="lv">和</em> <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-skaffold-with-docker-and-kustomize-to-build-a-pipeline-for-stateful-applications-running-c74ca0e1c13a?sk=0aa5ab54cdbdcf2cf5997900c062b961"> <em class="lv">第三部分</em> </a> <em class="lv">。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="8b2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Kubernetes中按需提供有状态的应用程序具有挑战性。有状态应用程序建立在数据库、消息总线或类似的将数据保存到磁盘的系统上。如果你认为，“嗯，几乎每个应用程序都是这样”，那么你是对的，但问题是，一般来说，后端并不在Kubernetes中。</p><p id="21b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它们的架构通常分布在不同的平台上。通常，前端组件已经位于Kubernetes中，可以按需供应、扩展和关闭，因为它通常是无状态的。同时，数据集可以以各种格式和形式托管:本地虚拟机、公共云中的PaaS服务、大数据平台，甚至是物理机。</p><p id="77ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本系列探讨了在开发运行在Kubernetes上的有状态应用程序和构建按需数据服务时的DevOps体验。你可能会问，为什么要在Kubernetes中运行所有组件。目标是让应用程序所有者利用原生Kubernetes的优势，加快关键业务应用程序的发布。</p><p id="0d59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把重点放在工具集上，该工具集使开发人员能够有效地浏览这些应用程序的开发生命周期。也就是说，我们将深入研究:</p><ul class=""><li id="ba1b" class="md me it lb b lc ld lf lg li mf lm mg lq mh lu mi mj mk ml bi translated">草泽</li><li id="e109" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">斯卡福德</li><li id="665d" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">Ondat持久卷</li><li id="de12" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">MongoDB数据库和副本集</li><li id="2703" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">MongoDB社区Kubernetes操作员</li><li id="29f3" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">皮蒙戈</li></ul><p id="8d58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这不是有状态应用程序的最DevOps设置，我就不知道DevOps意味着什么了😆。</p><h1 id="31fe" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">认识漫威应用程序</h1><p id="d727" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们将建立一个应用程序，显示随机选择的漫威字符卡，以展示Kubernetes的能力。我们的目标也是探索DevOps工具如何适应应用程序开发过程。希望这将比另一个“Hello World”应用程序有趣得多！应用程序架构如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/3dbd39a843776278c369b8a8f38b1a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RrMWKBROcaYB4Nh4LiK6Zw.jpeg"/></div></div></figure><p id="7545" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有代码:<a class="ae ky" href="https://github.com/vfiftyfive/FlaskMarvelApp" rel="noopener ugc nofollow" target="_blank">https://github.com/vfiftyfive/FlaskMarvelApp</a>。</p><p id="5d2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">FE(前端)组件是Python Flask应用程序。它的作用是为MongoDB数据库中的数据提供一个可视化层。它作为<code class="fe np nq nr ns b">Deployment</code>在库伯内特斯运行。</p><p id="5c5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">BE(后端)是一个MongoDB数据库，部署为一个3节点集群，由MongoDB社区Kubernetes操作员管理。从<code class="fe np nq nr ns b">StatefulSet</code>开始，它运行在Kubernetes中，这是需要将数据持久化到磁盘的应用程序的标准。</p><p id="ce0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如图所示，<code class="fe np nq nr ns b">StatefulSet</code>利用Kubernetes控制器，通过声明绑定到单个<code class="fe np nq nr ns b">PVCs</code>的持久卷(<code class="fe np nq nr ns b">PV</code>)来确保每个<code class="fe np nq nr ns b">Pod</code>能够访问自己的数据存储。有关<code class="fe np nq nr ns b">StatefulSets</code>及其用例的更多信息，您可以在Ondat网站或官方Kubernetes <a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank">文档</a>中查看<a class="ae ky" href="https://docs.ondat.io/docs/usecases/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="6a4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为应用程序部署的一部分，还提供了Kubernetes <code class="fe np nq nr ns b">Job</code>。它的作用是从可用的漫威API<a class="ae ky" href="https://developer.marvel.com/" rel="noopener ugc nofollow" target="_blank">获取漫威角色的信息，并将其存储在MongoDB数据库中。<code class="fe np nq nr ns b">Job</code>只在应用程序部署时运行一次。Kubernetes将调度<code class="fe np nq nr ns b">Pods</code>，直到任务成功完成(在有限的重试次数内)。<code class="fe np nq nr ns b">Pods</code>可能会失败，等待与数据库的连接建立，但一旦成功，就再也不会重新运行。然后，FE可以显示直接从数据库中检索的随机字符卡。</a></p><p id="af2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用包括FE +BE和用相关信息填充BE的数据初始化步骤。它可以使用由命令行工具动态生成的YAML清单部署在Kubernetes中，或者作为CI/CD管道部署。Kustomize是本文中我们用来生成清单的工具。它还可以更新与特定构建迭代相关的对象。使用Kustomize，您可以轻松地更新容器映像引用，或者对于我们的用例，使用新版本的Mongo部署应用程序，或者提供新的Ondat <code class="fe np nq nr ns b">StorageClass</code>。</p><h1 id="40ed" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">模板化和自动化所有的事情！</h1><p id="eabb" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">这一切都始于在不同的开发阶段迭代应用程序测试和部署的能力，例如在本地笔记本电脑上，在远程测试集群上，或者在试运行、用户验收测试(UAT)和生产阶段。Kustomize可以作为一个<code class="fe np nq nr ns b">kubectl</code>选项(<code class="fe np nq nr ns b">-k</code>)在生成应用程序清单时应用定制。该工具允许开发人员根据特定环境动态调整应用程序需求和上下文。然而，我们通常建议使用Kustomize作为一个单独的二进制文件，因为它更灵活并且总是最新的。</p><p id="6b51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kustomize的原理是通过指定您想要修改的基本清单中的元素来构建一个覆盖图。在本文中，我们将重点放在应用程序开发阶段，在这个阶段，我们在本地Kubernetes K3s集群中对应用程序进行编码和测试。在这个用例中，Kustomize需要两个文件夹，一个用于基本清单，一个用于<em class="lv"> Dev </em>覆盖:</p><pre class="kj kk kl km gt nt ns nu nv aw nw bi"><span id="fd10" class="nx ms it ns b gy ny nz l oa ob">base\<br/>    job.yaml<br/>    kustomization.yaml<br/>    marvel_deploy.yaml<br/>    marvel_svc.yaml<br/>    mongodbcommunity_cr.yaml<br/>    ondat_sc.yaml<br/>overlay\<br/>    dev\<br/>        job.yaml<br/>        kustomization.yaml<br/>        marvel_deploy.yaml<br/>        mongodbcommunity_cr.yaml<br/>        name_reference.yaml<br/>        ondat_sc.yaml</span></pre><p id="19a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些文件的内容可以在 这里访问<a class="ae ky" href="https://github.com/vfiftyfive/CFD12-Demo-Manifests" rel="noopener ugc nofollow" target="_blank"> <em class="lv">。您可以简单地使用<code class="fe np nq nr ns b">build</code>选项运行Kustomize来生成适当的Kubernetes清单。例如，要用<em class="lv"> dev </em>覆盖来修改基本清单，您可以运行<code class="fe np nq nr ns b">kustomize build overlay/dev</code>，假设您在“覆盖”目录的父文件夹中。输出是一组直接显示在终端上的清单，所以如果您想将结果保存为YAML，只需将输出重定向到一个文件。另一种选择是使用<code class="fe np nq nr ns b">kustomize build</code>的输出作为<code class="fe np nq nr ns b">kubectl apply</code>的输入，如下所示:</em></a></p><pre class="kj kk kl km gt nt ns nu nv aw nw bi"><span id="ed7a" class="nx ms it ns b gy ny nz l oa ob">kustomize build overlay/dev | kubectl apply -f -</span></pre><p id="30b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它会直接将对象部署到您的Kubernetes集群中。</p><h1 id="b3b4" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">对准移动部件</h1><p id="a012" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">当开发一个运行在Kubernetes上的应用程序时，您很早就会面临重复的任务。它们包括在提交新代码时构建新的容器映像，更新Kubernetes清单，以及将应用程序栈的新版本部署到Kubernetes测试集群中，以便可以执行测试。</p><p id="54b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的目标是提供一个管道来自动构建容器映像，相应地更新清单，并且一旦我们修改了源代码，<em class="lv">就会持续地</em>部署应用程序堆栈。工作流程如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/a820cab61d8017b03963e00fdbeb0120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FQ0LdwCOx-kJZhiTd8iQlg.png"/></div></div></figure><p id="d755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Skaffold就是让你做到这一点的工具之一。它是Google的一个开源项目，提供了一个CLI来管理CI/CD管道中各个阶段的应用程序的生命周期。它可以帮助您的应用程序的开发、构建和部署阶段。在我们的用例中，我们对早期开发阶段感兴趣。Skaffold的作用是，在执行<code class="fe np nq nr ns b">git commit</code>并使用Kustomize将代码部署到dev Kubernetes集群之前，每次代码保存到本地时，从FE Dockerfile文件构建一个新的映像。因此，您不需要向git存储库提交或推送代码来测试它。</p><p id="aaf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从FE <a class="ae ky" href="https://github.com/vfiftyfive/FlaskMarvelApp/blob/master/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>的内容开始。</p><pre class="kj kk kl km gt nt ns nu nv aw nw bi"><span id="cee4" class="nx ms it ns b gy ny nz l oa ob">FROM python:3.9<br/><br/>WORKDIR /code<br/><br/>COPY ./requirements.txt /code/requirements.txt<br/><br/>RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt<br/><br/>COPY ./app /code/app<br/><br/>CMD ["gunicorn", "--conf", "app/gunicorn_conf.py", "--bind", "0.0.0.0:80", "app.main:app"]</span></pre><p id="1fa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们执行非常标准的操作:</p><ul class=""><li id="1ff0" class="md me it lb b lc ld lf lg li mf lm mg lq mh lu mi mj mk ml bi translated">安装Flask应用程序所需的依赖项</li><li id="dfd6" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">将源代码复制到容器中</li><li id="f8e6" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">使用<code class="fe np nq nr ns b">gunicorn</code> WSGI运行web服务器(因为该应用程序不提供任何静态HTML页面，所以不需要<code class="fe np nq nr ns b">nginx</code>或其他HTTP服务器)。</li></ul><p id="cbc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ska fold<em class="lv">dev</em>模式允许您实时检测应用程序源代码中发生的任何变化，使用docker文件自动构建新的容器映像，并将其部署到dev Kubernetes集群。不需要通过webhook执行<code class="fe np nq nr ns b">git commit</code>或<code class="fe np nq nr ns b">git push</code>来触发这个过程。在这种模式下，Skaffold二进制文件作为一个检测代码变化的守护进程运行。Skaffold可以使用不同的工具部署应用程序组件。我们选择了Kustomize，但是Docker、kubectl和Helm也是可用的选项。类似地，Skaffold构建阶段可以利用Dockerfiles、<a class="ae ky" href="https://buildpacks.io/" rel="noopener ugc nofollow" target="_blank"> buildpacks </a>和<a class="ae ky" href="https://skaffold.dev/docs/pipeline-stages/builders/" rel="noopener ugc nofollow" target="_blank">文档</a>中提到的其他工具，以及定制脚本。</p><p id="700d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们使用基于ARM的架构进行开发，所以我们需要一个自定义脚本来执行Docker跨平台构建。这里的<a class="ae ky" href="https://github.com/GoogleContainerTools/skaffold/tree/main/examples/custom-buildx" rel="noopener ugc nofollow" target="_blank">给出了这样一个脚本的例子</a>。我们使用的<code class="fe np nq nr ns b">build.sh</code>脚本位于漫威应用<a class="ae ky" href="https://github.com/vfiftyfive/FlaskMarvelApp" rel="noopener ugc nofollow" target="_blank">库</a>的根目录下。它包含与示例中相同的代码。Skaffold利用这个脚本在构建阶段构建图像工件。然后，Kustomize动态生成Kubernetes清单，Skaffold将它们部署到集群中。</p><p id="c154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的机器运行在x86处理器上，您不需要任何定制脚本或额外的构建命令。但是不要担心，我们将详细研究每个组件！</p><p id="34b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一次，我们将通过完成建造这条管道所需的每一个步骤来弄脏我们的手。我们还将深入研究MongoDB操作符，并解释为什么需要它！</p></div></div>    
</body>
</html>