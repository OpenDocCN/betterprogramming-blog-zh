<html>
<head>
<title>Design Patterns: Adapter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式:适配器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/design-patterns-adapter-efb73c5090e6?source=collection_archive---------8-----------------------#2019-09-26">https://betterprogramming.pub/design-patterns-adapter-efb73c5090e6?source=collection_archive---------8-----------------------#2019-09-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="73e9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用龙珠Z理解适配器模式</h2></div><p id="f819" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">书中描述了23个经典的设计模式，<code class="fe le lf lg lh b">Design Patterns: Elements of Reusable Object-Oriented Software</code>。这些模式为软件开发中经常遇到的问题提供了解决方案。</p><p id="b143" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将描述适配器模式以及如何和何时应用它。</p><h1 id="9388" class="li lj it bd lk ll lm ln lo lp lq lr ls jz lt ka lu kc lv kd lw kf lx kg ly lz bi translated">适配器模式:基本思想</h1><blockquote class="ma mb mc"><p id="86cf" class="ki kj md kk b kl km ju kn ko kp jx kq me ks kt ku mf kw kx ky mg la lb lc ld im bi translated"><em class="it">一个</em> <strong class="kk iu"> <em class="it">适配器</em> </strong> <em class="it">允许两个不兼容的接口一起工作。这是适配器的真实定义。接口可能不兼容，但是内部功能应该适合需要。适配器设计模式通过将一个类的接口转换成客户机期望的接口，允许原本不兼容的类协同工作。</em></p></blockquote><p id="1208" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="md"> —维基百科</em></p><blockquote class="ma mb mc"><p id="fbd2" class="ki kj md kk b kl km ju kn ko kp jx kq me ks kt ku mf kw kx ky mg la lb lc ld im bi translated"><em class="it">将一个类的接口转换成客户期望的另一个接口。适配器允许类一起工作，否则由于不兼容的接口而无法工作。</em></p></blockquote><p id="4168" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="md"> —设计模式:可复用面向对象软件的要素</em></p><p id="79ce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种模式的主要特点是重用一个具有不同接口的类到另一个类或几个类。</p><p id="1d93" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种模式有两种版本:</p><ol class=""><li id="693b" class="mh mi it kk b kl km ko kp kr mj kv mk kz ml ld mm mn mo mp bi translated">在运行时，<code class="fe le lf lg lh b">object adapter</code>通过委托给一个<code class="fe le lf lg lh b">adaptee</code>对象来实现<code class="fe le lf lg lh b">target</code>接口。</li><li id="544a" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><code class="fe le lf lg lh b">class adapter</code>通过在编译时继承一个<code class="fe le lf lg lh b">adaptee</code>类来实现<code class="fe le lf lg lh b">target</code>接口。</li></ol><p id="8f40" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于多重继承不被包括Java在内的许多语言所支持，并且与许多问题相关联，所以我们没有展示使用类适配器模式的实现。</p><p id="3fb9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总而言之，对象适配器(AKA adapter)包含它所包装的类的一个实例。这个模式的UML图如下所示:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/af5b6b5b21b28ec3f14ec161245a124d.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*V6MnlboxEBSUvg-o.png"/></div></figure><p id="a584" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">Adapter</code>类包含<code class="fe le lf lg lh b">Adaptee</code>类。这意味着<code class="fe le lf lg lh b">Adaptee</code>类将被<code class="fe le lf lg lh b">Adapter</code>使用。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="7fb3" class="li lj it bd lk ll nk ln lo lp nl lr ls jz nm ka lu kc nn kd lw kf no kg ly lz bi translated">何时使用适配器模式</h1><ul class=""><li id="11d3" class="mh mi it kk b kl np ko nq kr nr kv ns kz nt ld nu mn mo mp bi translated">有一个类的接口与您需要的不匹配。</li><li id="93fb" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld nu mn mo mp bi translated">有几个子类，但是通过子类化每一个来适应它们的接口是不切实际的。</li></ul><p id="b456" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">适配器模式有几个优点:</p><ul class=""><li id="73e0" class="mh mi it kk b kl km ko kp kr mj kv mk kz ml ld nu mn mo mp bi translated">代码具有可重用性和灵活性。</li><li id="ac19" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld nu mn mo mp bi translated">干净的代码——因为客户端/上下文在每个具体的类中不使用不同的接口，并且可以使用多态性在不同的适配器之间交换。</li></ul><h1 id="2934" class="li lj it bd lk ll lm ln lo lp lq lr ls jz lt ka lu kc lv kd lw kf lx kg ly lz bi translated">示例1</h1><p id="4a81" class="pw-post-body-paragraph ki kj it kk b kl np ju kn ko nq jx kq kr nv kt ku kv nw kx ky kz nx lb lc ld im bi translated">让我们看看如何使用JavaScript/TypeScript实现这个模式。</p><p id="6802" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住——Javascript既缺少接口也缺少抽象类。因此，理解这种模式的最佳方式是使用示例和TypeScript。</p><p id="9201" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的例子中，我虚构了一个问题，其中有一个名为<code class="fe le lf lg lh b">Warrior</code>的抽象类定义了一个战士。战士有一组与问题无关的属性和一个叫做<code class="fe le lf lg lh b">attack</code>的方法。有一个战士类型的分类，例如<code class="fe le lf lg lh b">Saiyan</code>和<code class="fe le lf lg lh b">Namekian</code>，它们定义了<code class="fe le lf lg lh b">attack</code>方法的具体实现，但是一个新的类到达了系统<code class="fe le lf lg lh b">Android</code>，它不满足战士的接口，但是在内部以不同的方式实现了该方法。下面的UML图显示了我刚刚描述的场景。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/83b8d725ac659763de0a6744aaed89b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/0*T7vKOr9EHu_nbUbx.jpg"/></div></figure><p id="fcec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解决方案是使用一个由包含<code class="fe le lf lg lh b">Android</code>对象的类(<code class="fe le lf lg lh b">AndroidAdapter</code>)组成的适配器模式，并使用它使之与warrior的接口兼容。使用适配器模式的新UML图如下所示:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/4aa3aedaad6a750be9cac2abdb6ddc34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/0*u7fJxzRjlVjWG7Nb.jpg"/></div></figure><p id="2779" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与模型和接口相关的代码:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi oa"><img src="../Images/6d240a993b13da9c286248d452b44016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N3JE4JvXn2Y_ZCmN.png"/></div></div></figure><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi ca"><img src="../Images/e8d8f5177f4a9b4ed1bc60a2e756db56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5aMq3BGa-XwJ08bi.png"/></div></div></figure><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi ca"><img src="../Images/070baeee526ef7c6e520536475bb833a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*acY-xFKlohYGhGP3.png"/></div></div></figure><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi of"><img src="../Images/0136bdae804349b899e6229e689d8585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ROc8R0rN60MEtiW0.png"/></div></div></figure><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi og"><img src="../Images/a81066aaaec32c4cc01ae7108b051e3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*gYCHvWg6mr1ltZ6K.jpg"/></div></figure><p id="461f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，<code class="fe le lf lg lh b">Android</code>类没有实现warrior的接口。<code class="fe le lf lg lh b">AndroidAdapter</code>能不能这个问题。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi oh"><img src="../Images/d7de69fc683944dea909162206c370ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ieqEUMIg7saUhRnI.png"/></div></div></figure><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/abe272c9708ee7a959d3f0f68a616c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*utk4L444TUCGXnHG.jpg"/></div></figure><p id="b4c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，想要使用这三个类的客户端应该使用<code class="fe le lf lg lh b">AndroidAdapter</code>类，以及<code class="fe le lf lg lh b">Saiyan</code>和<code class="fe le lf lg lh b">Namekian</code>，正如您在这里看到的:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi oj"><img src="../Images/0dcb64989e9616f10a77bd473ca77626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YJ5L26EuZZA7V17_.png"/></div></div></figure><h1 id="bc7d" class="li lj it bd lk ll lm ln lo lp lq lr ls jz lt ka lu kc lv kd lw kf lx kg ly lz bi translated">示例2:几个种族想要使用JavaScript/TypeScript一起工作(Genki-dama)</h1><p id="7e21" class="pw-post-body-paragraph ki kj it kk b kl np ju kn ko nq jx kq kr nv kt ku kv nw kx ky kz nx lb lc ld im bi translated">适配器模式可以解决的另一个有趣的问题是，当有几个具有不同接口的类，但它们可以一起工作时。在下面的UML图中，您可以看到这种情况:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/3c0c7739d0e4c8e44916656c4827b7fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/0*rBeofZHTuRd7WPk1.jpg"/></div></figure><p id="c572" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，种族之间有不同的接口进行通信。具体来说，每个种族都有一种或几种分享权力的方法。比如人类有<code class="fe le lf lg lh b">sharedPower</code>，namekians有<code class="fe le lf lg lh b">getPower</code>。更复杂的是赛亚人，他们有两种分享权力的方法(<code class="fe le lf lg lh b">myPowerPart1</code>和<code class="fe le lf lg lh b">myPowerPart2</code>)。</p><p id="f116" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解决方案是几个种族使用适配器模式一起工作，正如您在下面的UML图中看到的。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi ol"><img src="../Images/f1e6fc786092c11a15673af2cadc6948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/0*4u4K41pNxHEoBIAR.jpg"/></div></div></figure><p id="7571" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个类都使用一个新的适配器类。这个适配器类包含原始对象和实现接口的方法。这个例子的代码非常简单:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi om"><img src="../Images/b38c4b08bcf2e4a2afacee0e5a74216e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oDl1kCg2UV2QgKF_.png"/></div></div></figure><p id="4c52" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们各自的适配器如下:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi on"><img src="../Images/b6ef416f8d7a4e1e4d988f6b366382fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3e9KYtpdDhD58OF3.png"/></div></div></figure><p id="b447" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，所有的物体都在贡献能量来对抗邪恶，成就伟大的力量！</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi oo"><img src="../Images/1df2a9fdcc2bd1d40da8b92f94d0967d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FxsPESfLLjSnxnJd.png"/></div></div></figure><p id="8dc5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在应用了适配器模式之后，我创建了两个NPM脚本来运行这里显示的两个示例。</p><p id="591c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">npm run example1</code><br/>T1】</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi op"><img src="../Images/543e832a203e855414af04a77877dabb.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/0*orsmkMK9KfdA9TL0"/></div></figure></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="2eba" class="li lj it bd lk ll nk ln lo lp nl lr ls jz nm ka lu kc nn kd lw kf no kg ly lz bi translated">结论</h1><p id="fc53" class="pw-post-body-paragraph ki kj it kk b kl np ju kn ko nq jx kq kr nv kt ku kv nw kx ky kz nx lb lc ld im bi translated">当您有可以一起工作但其接口不兼容的类时，适配器模式可以帮助您避免项目中的重复代码。在这个岗位上我们；我们看到了一个使用JavaScript/TypeScript语言的简单实现。</p><p id="9278" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最重要的事情不是实现我向你展示的模式，而是能够认识到这个特定模式可以解决的问题——知道你什么时候可以或者不可以实现这个模式。这一点至关重要，因为实现会因您使用的编程语言而异。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="1d96" class="li lj it bd lk ll nk ln lo lp nl lr ls jz nm ka lu kc nn kd lw kf no kg ly lz bi translated">更大的</h1><ul class=""><li id="af04" class="mh mi it kk b kl np ko nq kr nr kv ns kz nt ld nu mn mo mp bi translated">《设计模式:可重用面向对象软件的元素》，伽马、赫尔姆、约翰逊、&amp; Vlissides、艾迪森·卫斯理，1995 。</li><li id="2741" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld nu mn mo mp bi translated"><a class="ae oq" href="https://en.wikipedia.org/wiki/Adapter_pattern" rel="noopener ugc nofollow" target="_blank">适配器模式—维基百科</a>。</li><li id="9c1b" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld nu mn mo mp bi translated"><a class="ae oq" href="https://www.dofactory.com/javascript/adapter-design-pattern" rel="noopener ugc nofollow" target="_blank">https://www.dofactory.com/javascript/adapter-design-pattern</a></li><li id="0152" class="mh mi it kk b kl mq ko mr kr ms kv mt kz mu ld nu mn mo mp bi translated"><a class="ae oq" href="https://github.com/sohamkamani/javascript-design-patterns-for-humans#-adapter" rel="noopener ugc nofollow" target="_blank">https://github . com/sohamkamani/JavaScript-design-patterns-for-humans #-adapter</a></li></ul></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><ul class=""><li id="d77b" class="mh mi it kk b kl km ko kp kr mj kv mk kz ml ld nu mn mo mp bi translated">本帖的<strong class="kk iu"> GitHub </strong>分支为<a class="ae oq" href="https://github.com/Caballerog/blog/tree/master/adapter-pattern" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Caballerog/blog/tree/master/adapter-pattern</a></li></ul></div></div>    
</body>
</html>