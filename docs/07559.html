<html>
<head>
<title>TypeScript 4.1’s Advanced Mapped Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4.1的高级映射类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typescript-4-1s-advanced-mapped-types-eba9a2ba7a9?source=collection_archive---------5-----------------------#2021-01-27">https://betterprogramming.pub/typescript-4-1s-advanced-mapped-types-eba9a2ba7a9?source=collection_archive---------5-----------------------#2021-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9c12" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看递归条件类型、模板文字类型等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/40e10f2114c11c2c9917b15b85cda1f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*toNM4HjQSQgIjDAM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@tine999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tine ivani</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="48c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您曾经读过我的任何TypeScript文章，您就会知道我是映射类型的忠实粉丝。映射类型出现在TypeScript版本<code class="fe lv lw lx ly b">2.1</code>中，并且在每个版本中都有所改进。</p><p id="8b73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们是我一直以来最喜欢的功能，因为一旦你掌握了它们，它们很有趣，也很容易使用。如果你不知道什么是映射类型，我建议阅读我的前一篇文章，在那里我详细解释了它们。</p><p id="de7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探索在<code class="fe lv lw lx ly b">4.1</code>中引入的一些特性，以及如何将它们应用到映射类型中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="959b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">TypeScript 4.1</h1><p id="602b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><a class="ae ky" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/" rel="noopener ugc nofollow" target="_blank"> TypeScript 4.1 </a>最近发布了，里面有很多好东西。在本文中，我们将特别关注:</p><ul class=""><li id="95ff" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">递归条件类型</li><li id="3000" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">模板文字类型</li><li id="b2d2" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">映射类型中的键重新映射</li><li id="7acb" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">检查索引访问</li></ul><p id="7cc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将深入研究这些问题，看看我们能做些什么新的事情。</p><p id="b4d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我强烈推荐使用<a class="ae ky" href="https://www.typescriptlang.org/play" rel="noopener ugc nofollow" target="_blank"> TypeScript playground </a>来最好地理解这篇文章。您可以调整所有配置，甚至切换TypeScript版本。对于新手来说，这是一个必须使用的工具，因为它还会显示JS代码的输出。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="db13" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">简短的复习</h1><p id="807a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在了解新特性之前，让我们简单回顾一下。这将有助于我们在进入新领域之前热身。</p><p id="e2fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么是映射类型？</p><blockquote class="nr ns nt"><p id="81f4" class="kz la nu lb b lc ld ju le lf lg jx lh nv lj lk ll nw ln lo lp nx lr ls lt lu im bi translated">“当你不想重复自己的时候，有时候一种类型需要建立在另一种类型的基础上。</p><p id="4365" class="kz la nu lb b lc ld ju le lf lg jx lh nv lj lk ll nw ln lo lp nx lr ls lt lu im bi translated">映射类型建立在索引签名的语法之上，索引签名用于声明尚未提前声明的属性类型。”— <a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html" rel="noopener ugc nofollow" target="_blank">打字稿的文档</a></p></blockquote><p id="0c26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，映射类型允许您基于现有类型创建新类型。让我们以<code class="fe lv lw lx ly b">Readonly</code>实用程序类型为例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9948" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回顾一下<code class="fe lv lw lx ly b">Readonly</code>是如何工作的:</p><pre class="kj kk kl km gt oa ly ob oc aw od bi"><span id="56d1" class="oe mh it ly b gy of og l oh oi">type Readonly&lt;T&gt; = { readonly [P in keyof T]: T[P]; }</span></pre><p id="63d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只是为了热身，让我们创造出对面的<code class="fe lv lw lx ly b">Readonly</code>。我们称之为<code class="fe lv lw lx ly b">Writable</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><pre class="kj kk kl km gt oa ly ob oc aw od bi"><span id="c891" class="oe mh it ly b gy of og l oh oi">// Writeable&lt;Teacher&gt; will be equivalent to</span><span id="e66c" class="oe mh it ly b gy oj og l oh oi">interface WriteableTeacher {<br/>  name: string;<br/>  email: string;<br/>}</span><span id="00ab" class="oe mh it ly b gy oj og l oh oi">// 'readonly' modifier will be subtracted with the `-` modifider</span></pre><p id="6e37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nu">注意:注意</em> <code class="fe lv lw lx ly b"><em class="nu">-</em></code> <em class="nu">修饰符。在这个场景中，它被用来删除</em> <code class="fe lv lw lx ly b"><em class="nu">readonly</em></code> <em class="nu">修改器。它可以用来从</em> <code class="fe lv lw lx ly b"><em class="nu">?</em></code> <em class="nu">等属性中移除其他修改器。</em></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4c15" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">递归条件类型</h1><p id="54af" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">考虑上面的例子。假设我们感兴趣的是递归地将所有嵌套类的接口属性标记为<code class="fe lv lw lx ly b">readonly</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="473b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">4.1</code>之前，我们被允许一些基本的递归行为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b959" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">ReadonlyRecursive</code>对接口/类型的每个属性反复调用自己:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="888c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果不使用映射键，我们就不能使用递归行为。它只是局限于这种行为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="18f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着<code class="fe lv lw lx ly b">4.1</code>的发布，这现在可以像预期的那样工作了。为什么？TypeScript放宽了对递归条件类型的一些限制。他们现在让我们变得更有想象力:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b441" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这非常强大，但也有代价。这意味着当我们添加更多的递归检查时，我们的TypeScript编译器可能会变慢。如果你看到你的编译时间增加，这将是你的主要怀疑。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6b5c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">模板文字类型</h1><p id="bea3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在进入重映射键特性之前，我们必须检查模板文字类型。他们也在<code class="fe lv lw lx ly b">4.1</code>中被介绍。没有它们，重新映射功能就不可能实现。</p><p id="6d20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个特性允许我们在TypeScript中操作文字并改变它们的形状。TypeScript包含了一些内在的字符串操作类型来帮助字符串操作:<code class="fe lv lw lx ly b">Uppercase</code>、<code class="fe lv lw lx ly b">Lowercase</code>、<code class="fe lv lw lx ly b">Capitalize</code>和<code class="fe lv lw lx ly b">Uncapitalize</code>。你可以在文档中看到更详细的信息<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#capitalizestringtype" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6ad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有更多。您甚至可以将它们与模板文字一起使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a810" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的属性有多个值，它将生成所有可能组合的并集:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a1a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们结合多种类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="14e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在新的重新映射键中看到这个新特性是多么重要。</p><p id="8632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这里有一点不一致。表达式文字类型将总是解析为<code class="fe lv lw lx ly b">string</code>类型。这可能会造成不兼容，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7d38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">get${propertyName}</code>正在解析为与<code class="fe lv lw lx ly b">PropertyName</code>不兼容的<code class="fe lv lw lx ly b">string</code>类型。</p><p id="94d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是不要惊慌。这个问题已经解决了，即将进入TypeScript 4.2。由于这个特性是新的，所以没有其他的那么成熟。您可以在<a class="ae ky" href="https://github.com/microsoft/TypeScript/pull/41891" rel="noopener ugc nofollow" target="_blank">合并拉取请求</a>中查看更多信息。</p><p id="af97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在4.2发布之前，您可以使用这个简单的解决方法:</p><pre class="kj kk kl km gt oa ly ob oc aw od bi"><span id="dec1" class="oe mh it ly b gy of og l oh oi">const x = `get${propertyName}` as PropertyName;</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="66ad" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">重新映射类型</h1><p id="0e5c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这个功能只是前一个功能的自然演变。有了它，您可以将键和值重新映射到特定的模式。到目前为止，TypeScript只能用现有的键创建新的类型。现在，您可以创建新的密钥。</p><p id="eee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法非常简单，类似于JavaScript的<code class="fe lv lw lx ly b">import</code>重映射。这个是用<code class="fe lv lw lx ly b">as</code>子句完成的。</p><p id="fcbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个基本实体:</p><pre class="kj kk kl km gt oa ly ob oc aw od bi"><span id="ad03" class="oe mh it ly b gy of og l oh oi">type Person {<br/>  name: string;<br/>  surname: string;<br/>  email: string;<br/>}</span></pre><p id="f264" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为它创建一个名为Factory的不可变样式类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe lv lw lx ly b">as</code>子句在<code class="fe lv lw lx ly b">never</code>原语的帮助下移除<code class="fe lv lw lx ly b">keys</code>。由于<code class="fe lv lw lx ly b">Exclude</code>在引擎盖下使用<code class="fe lv lw lx ly b">never</code>，它也能完成这项工作。</p><pre class="kj kk kl km gt oa ly ob oc aw od bi"><span id="5cd6" class="oe mh it ly b gy of og l oh oi">type Exclude&lt;T, U&gt; = T extends U ? never : T</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="d388" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">映射类型将允许您仅基于泛型和模板文字操作来创建复杂的模式。这减少了样板文件，帮助我们以动态模式而不是特定的界面来思考。您可以创建自定义的最佳代码实践，并将其输入。</p><p id="154d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用最佳实践创建重新映射的映射类型，并使用它们来创建您的协定。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2f42" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">检查索引访问</h1><p id="e4da" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们简单介绍一下这个特性。乍一看，这似乎无关紧要，但它将使我们能够使映射类型更加安全。</p><p id="4578" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过启用<code class="fe lv lw lx ly b">--noUncheckedIndexedAccess</code>，默认情况下会变成<code class="fe lv lw lx ly b">off</code>，解析为索引签名的映射类型将会附加<code class="fe lv lw lx ly b">undefined</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="73d9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">包扎</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/df0b9ff51c4c57ffbdc80ba0fdfff075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f9UmPWE86XZTU-PS"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@napr0tiv?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瓦西里·科洛达</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="7629" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经看到这些新功能是多么的酷和有用。随着时间的推移，它们将成为真正的游戏规则改变者，因为它们将帮助我们编写更具表现力的界面。随着TypeScript变得更加灵活，我们可以减少代码库中样板文件的数量。</p><p id="5711" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript <code class="fe lv lw lx ly b">4.1</code>提供了更多好东西。我可能会在另一篇文章中更深入地探讨这些问题。本文只是展示了这个新版本对映射类型的影响。</p><p id="9d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想继续学习关于TypeScript的知识，可以看看下面我写的关于TypeScript的<code class="fe lv lw lx ly b">strict</code>模式的文章:</p><div class="ol om gp gr on oo"><a href="https://medium.com/better-programming/getting-strict-with-typescript-2e906b48c0a" rel="noopener follow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">对类型脚本越来越严格</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">使您的类型脚本代码更具可读性和类型安全</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">medium.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div><p id="7fbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将来会有更多的TypeScript内容出现。干杯！</p></div></div>    
</body>
</html>