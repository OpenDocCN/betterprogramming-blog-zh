<html>
<head>
<title>Avoiding Circular Dependency Issues in Nest.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免Nest.js中的循环依赖问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/nest-js-avoid-circular-dependency-issues-4f7577377acc?source=collection_archive---------3-----------------------#2022-01-19">https://betterprogramming.pub/nest-js-avoid-circular-dependency-issues-4f7577377acc?source=collection_archive---------3-----------------------#2022-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ca17" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">快速浏览progressive Node.js框架的循环依赖问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0f59157ccd302f98ebeed28387cd301b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mWazAexWx5lA5rzN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@tine999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tine ivani</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="94cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当两个类相互依赖时，就会出现循环依赖。</p><p id="4c5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如A类需要B类，B类也需要A类，模块之间，提供者之间的嵌套会产生循环依赖。虽然应该尽可能避免循环依赖，但你不能总是这样做。</p><p id="ac6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，Nest支持以两种方式解决提供者之间的循环依赖。在本章中，我们描述了使用前向引用作为一种技术，使用<code class="fe lv lw lx ly b">ModuleRef</code>类从DI容器中检索提供者实例作为另一种技术。</p><h1 id="62aa" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">我们的示例案例</h1><p id="cec1" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们有两个班<code class="fe lv lw lx ly b">UsersRepo</code>(在<code class="fe lv lw lx ly b">UsersModule</code>)和<code class="fe lv lw lx ly b">JwtService</code>(在<code class="fe lv lw lx ly b">AuthModule</code>申报的<code class="fe lv lw lx ly b">JwtModule</code>提供的<code class="fe lv lw lx ly b">AuthModule</code>)。两者相互依赖。</p><p id="1559" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">UsersModule</code>的<code class="fe lv lw lx ly b">UsersRepo</code>需要<code class="fe lv lw lx ly b">JwtService</code> ( <code class="fe lv lw lx ly b">JwtModule</code>)进行JWT验证和解码。在<code class="fe lv lw lx ly b">AuthModule</code>中对<code class="fe lv lw lx ly b">JwtModule</code>进行声明、配置和导出。因此，在<code class="fe lv lw lx ly b">UsersModule</code>中，我们可以(我们必须)以“正常”的方式导入它。</p><p id="1cdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe lv lw lx ly b">UsersModule</code>的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3b49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在<code class="fe lv lw lx ly b">UsersRepo</code>构造函数中以‘正常’的方式注入<code class="fe lv lw lx ly b">JwtService</code>:</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="8d88" class="nc ma it ly b gy nd ne l nf ng">import { JwtService } from ‘@nestjs/jwt’;<br/>. . .<br/>export class UsersRepo {<br/>constructor(private jwtService: JwtService), …)</span></pre><p id="1a13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<code class="fe lv lw lx ly b">AuthModule</code>的<code class="fe lv lw lx ly b">AuthService</code>需要UsersRepo进行用户登录/注册。<code class="fe lv lw lx ly b">UsersRepo</code>是<code class="fe lv lw lx ly b">UsersModule</code>导出的一个类(服务提供者)。我们可以(我们必须)使用<code class="fe lv lw lx ly b">forwardRef()</code>在<code class="fe lv lw lx ly b">AuthModule</code>进口它。</p><p id="ae8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">AuthModule</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="58f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们也可以在<code class="fe lv lw lx ly b">AuthService</code>中注入<code class="fe lv lw lx ly b">UsersRepo</code>，通过使用‘正常’的方式(注意这里的<code class="fe lv lw lx ly b">JwtService</code>用于创建和返回一个新的JWT):</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="0987" class="nc ma it ly b gy nd ne l nf ng">import { UsersRepo } from ‘src/dataObjects/users.repo’;<br/>import { JwtService } from ‘@nestjs/jwt’;<br/>. . .<br/>@Injectable()<br/>export class AuthService {<br/>constructor(private usersRepo: UsersRepo, private jwtService: JwtService) {}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/f03d49765acf7a7815f061747df8c8dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cl4PmGjslH8yRyxS4QESdw.jpeg"/></div></div></figure><h1 id="ed9f" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">再现循环相关性错误</h1><p id="c35d" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如果我们试图以“正常”的方式(<code class="fe lv lw lx ly b">imports: [UsersModule, …]</code>)导入它，我们将会得到循环依赖错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/1381fb6b9525238f410db3ddd78b7d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*maFCnwxi4kYr-CPezs2l6Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">循环依赖错误</p></figure><p id="271c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！感谢阅读和快乐编码！</p></div></div>    
</body>
</html>