<html>
<head>
<title>How To Test SwiftUI Views Smartly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何智能测试SwiftUI视图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-test-swiftui-views-smartly-6c6b13f9edb1?source=collection_archive---------1-----------------------#2021-11-05">https://betterprogramming.pub/how-to-test-swiftui-views-smartly-6c6b13f9edb1?source=collection_archive---------1-----------------------#2021-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ecec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">单元测试SwiftUI的行为和连接</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1623c40d3e7a8ba51516778102041227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VTIHLdAHWFFzl6Le"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@towfiqu999999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Towfiqu barbhuiya </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="de6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正确测试UI是很难实现的。UI是我们应用程序中最不稳定的部分:产品经理和他们的团队喜欢尝试它。由于技术因素也很难测试:不同的屏幕因素、方向和本地化。</p><p id="fe39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试整个UI也很昂贵:测试很难写，需要更多的时间来写，并且很容易因为产品的变化而失效。面对这些困难，不同于单元测试的策略诞生了:<a class="ae ky" href="https://github.com/pointfreeco/swift-snapshot-testing" rel="noopener ugc nofollow" target="_blank">快照测试</a>和<a class="ae ky" href="https://github.com/theappbusiness/TABTestKit" rel="noopener ugc nofollow" target="_blank">测试</a>。</p><p id="f216" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些策略是有效的，但仍然昂贵。它们非常适合自动化回归检查和用例测试，但是不适合支持开发周期。一个好的开发周期是快速的，只有单元测试能为我们提供这样的周期。</p><p id="c977" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天的文章中，我想探索一种以智能方式对SwiftUI视图进行单元测试的方法。我们首先需要理解在一个视图中进行测试有什么意义。其次，我们将讨论一个使这成为可能的工具。最后，我们将使用<a class="ae ky" href="https://www.agilealliance.org/glossary/tdd/" rel="noopener ugc nofollow" target="_blank">测试驱动开发</a> (TDD)方法实现一个简单的视图。</p><h1 id="cdb5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">考什么？</h1><p id="2fc0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">开发视图的一个主要目标是让逻辑远离视图。一个<code class="fe ms mt mu mv b">View</code>应该只包含表示代码:所有的业务逻辑应该被移到<code class="fe ms mt mu mv b">ViewModel</code>或者一个类似的组件中。</p><p id="31fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有两种行为我们必须放到视图中，即使它们是由<code class="fe ms mt mu mv b">ViewModel</code>控制的:</p><ol class=""><li id="7d6b" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">视图如何对视图模型中的变化做出反应。</li><li id="ed4d" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">视图何时调用视图模型的方法，以及它调用哪些方法。</li></ol><p id="7803" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，我们可以有一个完全测试过的完美的<code class="fe ms mt mu mv b">ViewModel</code>，但是我们想测试一下，当视图模型改变时，视图会相应地更新。</p><p id="6606" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，我们需要验证，例如，当用户与视图交互时，调用了正确的<code class="fe ms mt mu mv b">ViewModel</code>方法。否则，我们永远无法确定我们的应用程序是否如我们所愿。</p><h1 id="46a3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">如何测试呢？</h1><p id="5a25" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了在SwiftUI中实现这一点，我们可以利用一个名为<code class="fe ms mt mu mv b"><a class="ae ky" href="https://github.com/nalexn/ViewInspector" rel="noopener ugc nofollow" target="_blank">ViewInspector</a></code>的测试框架。<code class="fe ms mt mu mv b">ViewInspector</code>使用Swift反射扩展SwiftUI视图的基本行为:我们可以轻松地在视图层次结构中搜索特定视图并断言其状态。或者，我们可以调用它的一些方法。</p><h2 id="79e7" class="nk lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">安装框架</h2><p id="1416" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe ms mt mu mv b">ViewInspector</code>可作为标准Swift包下载并安装在项目中。不过，它的配置有点棘手，因为它是一个在引擎盖下使用<code class="fe ms mt mu mv b">XCTest</code>的框架。让我们通过所有的步骤将它安装到我们的项目中。</p><ul class=""><li id="8b82" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nw nc nd ne bi translated">创建新的iOS应用程序项目。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/ff1152c9f97b0c6f0f0b341f8ac7b83a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y8w84-DvNniL5UueR5Plww.png"/></div></div></figure><ul class=""><li id="3214" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nw nc nd ne bi translated">将其命名为<code class="fe ms mt mu mv b">SwiftUITesting</code>，并勾选<code class="fe ms mt mu mv b"><strong class="lb iu">Include Tests</strong></code>复选框。确保选择<code class="fe ms mt mu mv b"><strong class="lb iu">SwiftUI</strong></code> <strong class="lb iu"> </strong>作为<strong class="lb iu">界面</strong>:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/68b83e00858fda24e9221c6621762506.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nqE2Qq64PfvuuUyxEgGBaw.png"/></div></div></figure><ul class=""><li id="64f2" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nw nc nd ne bi translated">从项目中移除<code class="fe ms mt mu mv b">SwiftUITestingUITests</code>文件夹和目标。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/24a15d5931fe0e08054a63422b2743d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8pNd3EH7xh9HmeC8wFsGcQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">右键单击SwiftUITestingUITests，并选择Delete。对SwiftUITestingUITests目标执行相同的操作。</p></figure><ul class=""><li id="cbb1" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nw nc nd ne bi translated">使用<code class="fe ms mt mu mv b">Swift Package Manager</code>添加<code class="fe ms mt mu mv b">ViewInspector</code>框架</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/00661923dea3cf2591c73fb994b30efe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bWrhv_eIJGNN5EJU92chrA.png"/></div></div></figure><ul class=""><li id="1396" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nw nc nd ne bi translated">仅将其链接到测试。这是最棘手的部分。我们需要首先取消它与应用程序的链接，然后我们需要显式地将它添加到单元测试目标中。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/41be88ca8cbd99137b50f56bfcfea43e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wf2eauSrltVb2tulyusxiw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">第一步。通过单击底部的减号(-)按钮，从应用程序的框架、库和嵌入内容中删除ViewInspector。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/14647e1c9bbbe5355bde9efe765aa841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uCWgayHOY6JiJo2b-6-jGA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">第二步。将它添加到Build Phases选项卡中的Link Binary和单元测试目标的库。</p></figure><p id="c39e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们解决方案的工作设置:</p><ul class=""><li id="1725" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nw nc nd ne bi translated">如果我们忘记了第1步，应用程序将在启动时崩溃，因为它试图加载无法在运行的应用程序中加载的<code class="fe ms mt mu mv b">XCTest</code>框架。</li><li id="cf8f" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nw nc nd ne bi translated">如果我们忘记了步骤2，测试将不能导入<code class="fe ms mt mu mv b">ViewInspector</code>。</li></ul><h2 id="7ab8" class="nk lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">在一个简单的测试中尝试ViewInspector</h2><p id="ea76" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">正如<a class="ae ky" href="https://github.com/nalexn/ViewInspector/blob/master/guide.md#the-basics" rel="noopener ugc nofollow" target="_blank"> ViewInspector指南</a>所述，我们只需遵循4个简单步骤:</p><ol class=""><li id="3af5" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">在我们的测试文件中导入<code class="fe ms mt mu mv b">ViewInspector</code>。</li><li id="002f" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">使SwiftUI视图符合<code class="fe ms mt mu mv b">Inspectable</code>协议。这是<code class="fe ms mt mu mv b">ViewInspector</code>用来抓取SwiftUI视图层次结构的协议。我们可以在测试文件中这样做。</li><li id="5413" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">确保测试有<code class="fe ms mt mu mv b">throws</code>关键字。如果所有的<code class="fe ms mt mu mv b">ViewInspector</code>特性找不到我们想要的东西，它们就会抛出一个错误。</li><li id="1fa0" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">使用<code class="fe ms mt mu mv b">.inspect()</code>函数编写我们的测试。</li></ol><p id="4e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">ViewInspector</code>让我们断言视图的状态。让我们通过在<code class="fe ms mt mu mv b">SwiftUITestingTest.swift</code>文件中编写第一个测试来测试它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="307b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过在第3行添加<code class="fe ms mt mu mv b">import ViewInspector</code>语句，直接遵循从1到3的步骤；通过在第6行添加协议一致性；并通过在第9行向方法签名添加<code class="fe ms mt mu mv b">throws</code>关键字。</p><p id="8e6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第4步是最复杂的。首先，我们需要一个内容视图来处理。我们创建它并将它存储在<code class="fe ms mt mu mv b">sut</code>变量中。然后我们检查它，搜索带有标识符<code class="fe ms mt mu mv b">“hello”</code>的SwiftUI <code class="fe ms mt mu mv b">Text</code>。</p><p id="e891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，通过使用<code class="fe ms mt mu mv b">string()</code>方法，我们提取<code class="fe ms mt mu mv b">Text</code>内容。在最后一行，我们断言它的内容等于<code class="fe ms mt mu mv b">"Hello, world!"</code>。</p><p id="a5c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行这个测试，它将失败。该错误指出无法找到满足搜索条件的视图。这是因为没有带有<code class="fe ms mt mu mv b">"hello"</code>标识符的视图。要解决这个问题，打开<code class="fe ms mt mu mv b">ContentView.swift</code>文件并在<code class="fe ms mt mu mv b">.padding()</code>修改器前添加<code class="fe ms mt mu mv b">.id()</code>修改器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="448c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在运行测试(<code class="fe ms mt mu mv b">⌘+U</code>)，它将会通过。</p><h2 id="217f" class="nk lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">为什么使用标识符？</h2><p id="6a2a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当测试UI的行为时，我们不关心组件在哪里呈现或者它的风格是什么。我们对它的存在和行为感兴趣。</p><p id="f4a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标识符让我们对UI进行抽象。只要视图包含正确类型的组件，具有正确的标识符，并且以正确的方式运行，测试就会通过。</p><p id="6ccd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这为将来可能的UI更改准备了视图。此外，我们可以为我们的<code class="fe ms mt mu mv b">UITests</code>利用与<code class="fe ms mt mu mv b">AccessibilityIdentifiers</code>相同的标识符。</p><h1 id="548d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">TDD方法</h1><p id="7213" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们的项目已经正确配置好了，我们知道了<code class="fe ms mt mu mv b">ViewInspector</code>是如何工作的。让我们尝试用TDD方法来使用它。</p><p id="88b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用TDD开发时，我们遵循一个简单的3步流程:</p><ol class=""><li id="d21f" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">为我们想要达到的目标写一个测试。</li><li id="9898" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">编写通过测试所需的最少生产代码。</li><li id="3b45" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">重构代码以提高其质量。</li></ol><p id="ca96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们一遍又一遍地重复这些步骤，直到完成我们的功能。</p><h2 id="6b5c" class="nk lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">目标</h2><p id="5e9c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们想要实现的是一个非常简单的用户界面:它有一个开关来启用/禁用黑暗模式。启用黑暗模式时，会出现一个按钮。当它被点击时，一些逻辑被执行——目前我们不关心这个逻辑做什么。这是我们想要实现的gif:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/14a5ae026907b63d7c43b1fc4cf09900.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/1*mBdCvxAYLUUgTqjVR148Qw.gif"/></div></figure><p id="0bc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用程序显然是一个非常简单的测试应用程序，可以用来玩<code class="fe ms mt mu mv b">ViewInspector</code>库。</p><h2 id="9c35" class="nk lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">断言开关的存在</h2><p id="ab04" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们要编写的第一个测试检查视图是否包含切换。该开关有一个带<code class="fe ms mt mu mv b">"Dark Mode?"</code>文本的标签。让我们从去掉前面的<code class="fe ms mt mu mv b">testContentView</code>开始，用下面的替换它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="a9dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试遵循与前一个相同的步骤:我们创建<code class="fe ms mt mu mv b">ContentView</code>，我们找到一个具有所需id的视图，并检查标签的内容。</p><p id="19ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，测试甚至不会构建。<code class="fe ms mt mu mv b">ContentView.Identifiers</code>型还不存在。TDD中失败的构建与失败的测试具有相同的重要性:使构建通过是TDD过程的第二步。</p><p id="3a7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，让测试通过的第一步是:让我们添加标识符。我们用一些静态属性创建and <code class="fe ms mt mu mv b">enum</code>。通过这种方式，我们避免了生产代码和测试代码之间的错别字风险。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="6dd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在应用程序构建完成了。让我们按下<code class="fe ms mt mu mv b">⌘+U</code>看看测试失败。我们的任务是让它过去。让我们通过删除旧的<code class="fe ms mt mu mv b">ContentView</code>的<code class="fe ms mt mu mv b">body</code>代码并用以下代码替换它来实现这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="9f80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码在视图中引入了一个带有正确标签的<code class="fe ms mt mu mv b">Toggle</code>。绑定被设置为常假。记住，我们必须做最少的事情来通过测试，这个绑定就可以了。</p><p id="9160" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们将<code class="fe ms mt mu mv b">View</code>的id设置为正确的值，并添加一些填充以获得更好看的UI。</p><p id="6827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们按下<code class="fe ms mt mu mv b">⌘+U</code>看测试通过！</p><h2 id="f540" class="nk lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">测试开关是否可以改变状态</h2><p id="7a87" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下一步是让开关改变它的状态。让我们为此编写一个测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="df5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按下<code class="fe ms mt mu mv b">⌘+U</code>查看测试是否失败。</p><p id="e743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生产代码正在为<code class="fe ms mt mu mv b">Toggle</code>的<code class="fe ms mt mu mv b">isOn</code>属性使用一个<code class="fe ms mt mu mv b">.constant(false)</code>绑定。因为它是一个常量绑定，所以没有办法让切换改变状态。</p><p id="b820" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过测试的最少工作量是在<code class="fe ms mt mu mv b">ContentView</code>中添加一个<code class="fe ms mt mu mv b">@State</code>属性，并将这个变量绑定到<code class="fe ms mt mu mv b">isOn</code>属性。但是，我们知道我们想要使用MVVM架构，所以让我们直接采用这种方式。</p><p id="96a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用适当的<code class="fe ms mt mu mv b">@Published </code>属性创建一个<code class="fe ms mt mu mv b">ViewModel</code>，并将<code class="fe ms mt mu mv b">@StateObject</code>添加到<code class="fe ms mt mu mv b">ContentView</code>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="f213" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在<code class="fe ms mt mu mv b">ContentView</code>的<code class="fe ms mt mu mv b">init</code>已经改变，因为它需要传递一个<code class="fe ms mt mu mv b">ViewModel</code>给它。我们必须更新所有的通话地点。这些包括:</p><ol class=""><li id="483e" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">ContentView.swift</code>文件中的SwiftUI预览。</li><li id="1aa6" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe ms mt mu mv b">SwiftUITestingApp.swift</code>文件。</li><li id="691e" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">测试中的两条<code class="fe ms mt mu mv b">let sut = ContentView()</code>线。</li></ol><p id="52c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过将<code class="fe ms mt mu mv b">ContentView()</code>替换为<code class="fe ms mt mu mv b">ContentView(viewModel: .init())</code>来更新它们，以创建一个带有默认视图模型的<code class="fe ms mt mu mv b">ContentView</code>。测试将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="3915" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，只有第4行和第15行发生了变化。让我们用<code class="fe ms mt mu mv b">⌘+U</code>运行测试，看看它们是否通过。</p><p id="873b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Xcode现在会在状态栏中显示紫色警告:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/d13251afd288751298dfebb39489e16b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*os7yZyKTKBvBjYyWri7wDQ.png"/></div></div></figure><p id="d4f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个运行时警告:我们正在使用一个没有安装在任何层次结构中的视图。这是因为<code class="fe ms mt mu mv b">View</code>不包含在任何<code class="fe ms mt mu mv b">WindowGroup</code>中。这仅发生在测试环境中:在生产中，<code class="fe ms mt mu mv b">View</code>被正确安装在<code class="fe ms mt mu mv b">Window</code>中。有这样的警告是好的:在单元测试中，我们希望孤立地测试视图，而不是在<code class="fe ms mt mu mv b">Window Group</code>中。</p><h2 id="c6e4" class="nk lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">测试当开关打开时，添加按钮是否出现</h2><p id="8107" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下一个测试展示了如何断言视图在<code class="fe ms mt mu mv b">ViewModel</code>中的一些变化之后被更新。新的测试检查当开关打开时，我们有一个<code class="fe ms mt mu mv b">AddDetails</code> <code class="fe ms mt mu mv b">Button</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="593b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于标识符的原因，测试不会构建，所以让我们添加新的标识符。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="a427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在测试建立了，但是失败了。所以，让我们再一次让他们通过。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="4cf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们添加了一个<code class="fe ms mt mu mv b">VStack</code>和一个条件语句，以便仅在启用黑暗模式时添加一个<code class="fe ms mt mu mv b">Button</code>。注意<code class="fe ms mt mu mv b">action</code>闭包是空的:记住我们必须添加最少的代码来通过测试。</p><h2 id="2cb6" class="nk lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">测试按钮调用视图模型中的AddDetails方法</h2><p id="cec1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们想要实现的最后一个测试是，当点击按钮时，它调用<code class="fe ms mt mu mv b">ViewModel</code>的<code class="fe ms mt mu mv b">addDetails</code>方法。让我们为此添加一个测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="cf5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们被困住了。我们知道如何让按钮出现，以及如何点击它。然而，我们应该断言什么呢？我们没有办法检查是否调用了<code class="fe ms mt mu mv b">ViewModel</code>方法。</p><p id="ea12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个解决方案是为<code class="fe ms mt mu mv b">ViewModel</code>接口创建一个协议。然后我们可以改变<code class="fe ms mt mu mv b">ContentView</code>的<code class="fe ms mt mu mv b">viewModel</code>属性，这样它的类型就变成了协议。不幸的是，<code class="fe ms mt mu mv b">ObservableObject</code>协议有一个<code class="fe ms mt mu mv b">ObjectWillChangePublisher</code>关联类型。我们不能把它作为<code class="fe ms mt mu mv b">Type</code>使用，只能作为一个约束。</p><p id="c6d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个解决方案是创建<code class="fe ms mt mu mv b">ViewModel</code>的子类，在那里我们覆盖所需的方法。多亏了里斯科夫替换原则，我们可以用子类代替超类，系统的行为不会改变。</p><p id="bc49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建子类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="4cb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个子类遵循了我喜欢的编写测试doubles的方式:我们在每次调用<code class="fe ms mt mu mv b">addDetails()</code>方法时增加一个计数器，并且我们调用一个闭包来让测试定制行为。</p><p id="f1a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个子类，我们可以更新我们的测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="b7d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试不会建立。基类还没有任何<code class="fe ms mt mu mv b">addDetails()</code>方法。让我们添加它以使构建成功。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="f2f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在测试开始了，但是他们不会通过。为了让它们通过，我们需要在<code class="fe ms mt mu mv b">ContentView</code>中连接<code class="fe ms mt mu mv b">addDetails()</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="376c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，只有第10行发生了变化，与<code class="fe ms mt mu mv b">ViewModel</code>连接。如果我们现在按下<code class="fe ms mt mu mv b">⌘+U</code>，测试将最终通过。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h1 id="ac10" class="lv lw it bd lx ly on ma mb mc oo me mf jz op ka mh kc oq kd mj kf or kg ml mm bi translated">结论</h1><p id="8f9f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在今天的文章中，我们探讨了几个话题。首先，我们理解了在视图中进行测试的意义。</p><p id="287e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们探索将<code class="fe ms mt mu mv b">ViewInspector</code>作为编写单元测试的工具，并用它来配置我们的项目。我们只是通过这篇文章了解了图书馆的皮毛。<a class="ae ky" href="https://github.com/nalexn/ViewInspector/blob/master/guide.md#the-basics" rel="noopener ugc nofollow" target="_blank">在这里</a>，你可以找到这个库的完整指南和他们目前覆盖的<a class="ae ky" href="https://github.com/nalexn/ViewInspector/blob/master/readiness.md" rel="noopener ugc nofollow" target="_blank"> API表面</a>。</p><p id="1746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们使用TDD方法创建了一个样例应用程序，测试UI以及它如何与视图模型相连接。记住TDD总是遵循三个步骤:</p><ol class=""><li id="1354" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">写一个测试(失败)</li><li id="a677" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">编写最少的代码来使它通过</li><li id="f080" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">重构代码</li></ol><p id="5951" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在Github上上传了<a class="ae ky" href="https://gist.github.com/cipolleschi/ecb2efb60b73049c7c357d92f3ba726a" rel="noopener ugc nofollow" target="_blank">内容视图</a>及其<a class="ae ky" href="https://gist.github.com/cipolleschi/1611f55ecd4ceef5a2c1404fedac07b8" rel="noopener ugc nofollow" target="_blank">测试</a>的完整代码。</p><p id="f5a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以更进一步，添加更多的测试。例如，您应该测试如果切换已经打开会发生什么:按钮应该已经出现在屏幕上。</p><p id="9ff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请随意使用这段代码并测试TDD方法。你练习得越多，就越擅长。</p></div></div>    
</body>
</html>