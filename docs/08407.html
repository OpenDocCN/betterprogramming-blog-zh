<html>
<head>
<title>Lazy Loading in Angular — A Beginner’s Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular中的惰性加载—初学者指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lazy-loading-in-angular-a-beginners-guide-c09d09738d08?source=collection_archive---------6-----------------------#2021-04-27">https://betterprogramming.pub/lazy-loading-in-angular-a-beginners-guide-c09d09738d08?source=collection_archive---------6-----------------------#2021-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9770" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">改善网站的用户体验和搜索引擎优化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ffb6bf389ae289c7289d8ba48dfe3cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CbpgaTLNScQVIG-B"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Alexander Possingham 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="117f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">惰性加载是根据需要加载组件、模块或网站的其他资产的过程。因为Angular创建了一个SPA ( <a class="ae ky" href="https://en.wikipedia.org/wiki/Single-page_application" rel="noopener ugc nofollow" target="_blank">单页应用</a>)，所以它的所有组件都是一次性加载的。其次，许多不必要的库或模块也可能被加载。</p><p id="cea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一个小的应用程序来说，这是可以的。但是随着应用程序的增长，如果一次加载所有内容，加载时间会增加。惰性加载允许Angular在需要的时候加载组件和模块。</p><p id="a9ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解惰性加载是如何工作的，我们首先需要理解Angular的构造块:NgModules。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="78bc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是NgModules？</h1><p id="1b90" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">像RouterModule、BrowserModule和FormsModule这样的Angular库是NgModules。Angular Material是第三方库，也是NgModule的一种。NgModule由与特定领域相关或具有类似功能集的文件和代码组成。</p><p id="b37c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">典型的NgModule文件声明组件、指令、管道和服务。它还可以导入当前模块中需要的其他模块。</p><p id="9189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NgModules的一个重要优势是它们可以延迟加载。让我们来看看如何配置延迟加载。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d8da" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何创建NgModules</h1><p id="c555" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本教程中，我们将创建两个延迟加载的模块(模块A和模块B)。在主屏幕上，我们将有两个按钮来加载每个模块。</p><h2 id="352f" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">创建项目</h2><p id="c868" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通过执行以下命令，创建一个名为<em class="nl"> lazy-load-demo </em>的新Angular项目:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="2dea" class="mz md it nn b gy nr ns l nt nu">ng new lazy-load-demo --routing --style css<br/>code lazy-load-demo</span></pre><p id="42f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们正在创建一个带有路由的新项目。其次，我们向CSS提及样式表格式。第二个命令在VS代码中打开项目。</p><h2 id="77ed" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">根模块</h2><p id="cd8b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">默认情况下，根模块或应用模块在<code class="fe nv nw nx nn b"> /src/app</code>下创建。下面是创建的NgModule文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用程序模块文件</p></figure><p id="fffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们导入所有需要的模块和组件。</p><p id="2074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，<code class="fe nv nw nx nn b">@NgModule</code>装饰器声明<code class="fe nv nw nx nn b">AppModule</code>类是NgModule的一种类型。装饰者接受<code class="fe nv nw nx nn b">declarations</code>、<code class="fe nv nw nx nn b">imports</code>、<code class="fe nv nw nx nn b">providers</code>和<code class="fe nv nw nx nn b">bootstrap</code>、<em class="nl">。</em>以下是对它们的描述:</p><ul class=""><li id="372e" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated"><code class="fe nv nw nx nn b">declarations</code>:该模块中的组件。</li><li id="e7c1" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nv nw nx nn b">imports</code>:当前模块需要的模块。</li><li id="748a" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nv nw nx nn b">providers</code>:服务提供商(如有)。</li><li id="dbad" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nv nw nx nn b">bootstrap</code>:Angular创建的<em class="nl">根</em>组件，插入到<code class="fe nv nw nx nn b">index.html</code>宿主网页中。</li></ul><h2 id="4b1f" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">主屏幕</h2><p id="1461" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">主屏幕上有两个按钮:<em class="nl">加载模块A </em>和<em class="nl">加载模块B </em>。顾名思义，点击这些按钮将延迟加载每个模块。</p><p id="6be2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，请用以下内容替换您的<code class="fe nv nw nx nn b">app.component.html</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用程序组件HTML</p></figure><p id="0f39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们定义路线<em class="nl"> a </em>和<em class="nl"> b </em>的模块。</p><h2 id="cefa" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">惰性加载模块</h2><p id="a130" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了创建延迟加载模块，请执行以下命令:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="2cbe" class="mz md it nn b gy nr ns l nt nu">ng generate module modulea --route a --module app.module<br/>ng generate module moduleb --route b --module app.module</span></pre><p id="1d93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令将生成两个文件夹:<code class="fe nv nw nx nn b">modulea</code>和<code class="fe nv nw nx nn b">moduleb</code>。随后，每个文件夹将包含自己的<code class="fe nv nw nx nn b">module.ts</code>、<code class="fe nv nw nx nn b">routing.ts</code>和<code class="fe nv nw nx nn b">component</code>文件。</p><p id="b1d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您检查您的<code class="fe nv nw nx nn b">app-routing.module.ts</code>，您将看到以下路线代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用程序路线</p></figure><p id="3c6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着当路径<em class="nl"> a </em>或<em class="nl"> b </em>被访问时，它们各自的模块将被延迟加载。</p><p id="808d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nv nw nx nn b">ng serve</code>运行项目时，您会看到下面的屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/2a9dedfcce5ff142960897e262f7639e.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/0*wyZEaBA0E4BX7k4O"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">主屏幕</p></figure><p id="f021" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您点击<em class="nl">加载模块A </em>按钮时，您将进入页面<em class="nl"> a </em>。您的屏幕应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/eb7bd656e27a562617a751cce9cb27c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/0*AD82I0xDa0QkLbPh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">延迟加载模块A</p></figure><p id="0b4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会看到一个类似的屏幕，显示“moduleb works！”点击<em class="nl">加载模块B </em>时<strong class="lb iu"> <em class="nl"> </em> </strong>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bfc5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何验证延迟加载有效</h1><p id="3e22" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了验证文件是否已加载，请按F12打开开发人员工具。之后，访问网络选项卡。当您刷新页面时，它将显示一些被请求的文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/d8e5e7ce79ead058e3585f9820a21495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZyyhQpo4Sr5jILTwRonc3w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">网络选项卡</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/afbf0a89de1dd5022ee59368067b89ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:262/0*zyPoAiYBCiirBLlm"/></div></figure><p id="f788" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击清除按钮，清除你的请求列表，如上图所示。</p><p id="08e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你点击<em class="nl">加载模块A </em>时，你会看到对<code class="fe nv nw nx nn b">modulea-modulea-module.js</code>的请求，如下图所示。这验证了模块A <em class="nl"> </em>是延迟加载的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/b2105a202846d33bb89c75aa2de670d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/0*3IcbGWeu931WiAIn"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">延迟加载模块A</p></figure><p id="0455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，当你点击<em class="nl">加载模块B </em>时，<code class="fe nv nw nx nn b">moduleb-moduleb-module.js</code>文件被加载，验证模块B被延迟加载。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/f9c85dcfcc1900060fbf7d9c5be3fddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/0*hgWHSVfm-XD4Jmrt"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">延迟加载模块B</p></figure><p id="6097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当您尝试单击按钮时，它将不会再次加载这些JS文件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bbfa" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">NgModules的用例</h1><p id="8705" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如我们所见，创建惰性加载模块非常容易。它们有很多有用的使用案例，例如:</p><ul class=""><li id="1f94" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated">为登录前和登录后屏幕创建单独的模块。</li><li id="6e4c" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">对于电子商务网站，面向供应商和面向客户的屏幕可以属于不同的模块。您也可以创建一个单独的支付模块。</li><li id="6a94" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">通常会创建一个包含共享组件、指令或管道的单独的<code class="fe nv nw nx nn b">CommonModule</code>。像<em class="nl">复制代码</em>按钮这样的指令和像<em class="nl">投赞成票/反对票</em>这样的组件通常包含在一个公共模块中。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5031" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="151e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于较小的网站来说，一次加载所有模块可能没什么关系。但是随着站点的增长，根据需要加载独立的模块是很有帮助的。</p><p id="df0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过延迟加载，网站的加载时间可以大大减少。当你试图提高搜索引擎优化的排名时，这尤其有用。即使你不是，更短的加载时间意味着更好的用户体验。</p></div></div>    
</body>
</html>