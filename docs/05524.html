<html>
<head>
<title>Writing Efficient Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写高效的Django</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-efficient-django-a2af9102874?source=collection_archive---------10-----------------------#2020-07-15">https://betterprogramming.pub/writing-efficient-django-a2af9102874?source=collection_archive---------10-----------------------#2020-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="784c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用Django的视图、模型和查询来构建更好的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/483279e548479f6afc71abcb012cd348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pPmFyVUBB7A_ASLVWXV80A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">语法突出主题是<a class="ae ky" href="https://marketplace.visualstudio.com/items?itemName=VictoriaDrake.kabukicho" rel="noopener ugc nofollow" target="_blank">Kabukich</a>——VS代码，作者。</p></figure><p id="1351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢姜戈。这是一个经过深思熟虑的直观框架，我可以大声说出它的名字。你可以用它来快速启动一个<a class="ae ky" href="https://github.com/victoriadrake/react-in-django" rel="noopener ugc nofollow" target="_blank">周末规模的项目</a>，你还可以用它来大规模运行<a class="ae ky" href="https://applybyapi.com" rel="noopener ugc nofollow" target="_blank">成熟的生产应用</a>。这两件事我都做过，这些年来我发现了如何使用Django的一些特性来获得最大效率。这些是:</p><ul class=""><li id="f074" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="#class-based-versus-function-based-views" rel="noopener ugc nofollow">基于类和基于函数的视图</a></li><li id="a7e6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#django-models" rel="noopener ugc nofollow"> Django车型</a></li><li id="a9a7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#retrieving-objects-with-queries" rel="noopener ugc nofollow">用查询检索对象</a></li></ul><p id="cb63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这些工具如何让您创建一个易于构建和维护的高性能Django应用程序。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="fe3c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">基于类的视图与基于函数的视图</h1><p id="260c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">请记住，Django完全是Python。谈到视图，您有两种选择:<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/topics/http/views/" rel="noopener ugc nofollow" target="_blank">视图函数</a>(有时称为“基于函数的视图”)或<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/topics/class-based-views/" rel="noopener ugc nofollow" target="_blank">基于类的视图</a>。</p><p id="cc3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几年前当我第一次构建<a class="ae ky" href="https://applybyapi.com" rel="noopener ugc nofollow" target="_blank"> ApplyByAPI </a>时，它最初完全由基于函数的视图组成。这些提供了粒度控制，有利于实现复杂的逻辑；就像在Python函数中一样，您可以完全控制视图的行为(无论是好是坏)。控制越多，责任越大，基于功能的视图使用起来可能会有点乏味。您负责编写视图工作所需的所有方法——这允许您完全定制您的应用程序。</p><p id="37e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就ApplyByAPI而言，只有少数地方真正需要这种定制功能。在其他地方，基于函数的视图开始让我的生活变得更加艰难。为一般的操作(如在列表页面上显示数据)编写本质上是自定义的视图变得乏味、重复且容易出错。</p><p id="cf8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于基于函数的视图，您需要确定要实现哪些Django方法，以便处理请求并将数据传递给视图。编写单元测试可能需要一些工作。简而言之，基于功能的视图提供的粒度控制也需要一些粒度上的繁琐才能正确实现。</p><p id="8033" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我将大多数视图重构为基于类的视图时，我最终抑制了ApplyByAPI。这不是一个小工作量和重构，但当它完成时，我有一堆微小的看法，使一个巨大的差异。我是说，看看这个:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="bf0d" class="ns mr it no b gy nt nu l nv nw">class ApplicationsList(ListView):<br/>    model = Application<br/>    template_name = "applications.html"</span></pre><p id="501f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是三条线。我的开发人员人机工程学和我的生活变得简单多了。</p><p id="af66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能认为基于类的视图是模板，涵盖了任何应用程序需要的大部分功能。有用于显示事物列表的视图，用于详细查看事物，还有用于执行CRUD(创建、读取、更新、删除)操作的<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/class-based-views/generic-editing/" rel="noopener ugc nofollow" target="_blank">编辑视图</a>。因为实现这些通用视图只需要几行代码，所以我的应用程序逻辑变得非常简洁。这给了我更少的重复代码，更少出错的地方，以及更易于管理的应用程序。</p><p id="e264" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于类的视图实现和使用都很快。内置的基于类的通用视图可能需要较少的测试工作，因为您不需要为Django提供的基本视图编写测试。(Django自己做了测试；你的应用程序不需要仔细检查。)为了根据需要调整一个通用视图，您可以<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/topics/class-based-views/#subclassing-generic-views" rel="noopener ugc nofollow" target="_blank">子类化一个通用视图</a>并覆盖属性或方法。在我的例子中，由于我只需要为我添加的任何定制编写测试，我的测试文件变得非常短，运行它们所花费的时间和资源也是如此。</p><p id="dd00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您在基于函数的视图和基于类的视图之间权衡取舍时，请考虑视图需要的定制量，以及测试和维护它所必需的未来工作。如果逻辑是通用的，那么您也许可以用一个通用的基于类的视图立即投入运行。如果您需要足够的粒度，以至于重写基本视图的方法会使它过于复杂，那么考虑基于函数的视图。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="bca5" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">Django模型</h1><p id="4474" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><a class="ae ky" href="https://docs.djangoproject.com/en/3.0/topics/db/models/" rel="noopener ugc nofollow" target="_blank">模型</a>组织你的Django应用程序的中心概念，帮助它们变得灵活、健壮和易于使用。如果使用得当，模型是将你的数据整理成确定的事实来源的有力方法。</p><p id="2630" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和视图一样，Django提供了一些内置的模型类型，方便实现基本的认证，包括<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/contrib/auth/" rel="noopener ugc nofollow" target="_blank">用户</a>和<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/contrib/auth/" rel="noopener ugc nofollow" target="_blank">权限</a>模型。对于其他的事情，你可以通过<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/topics/db/models/#model-inheritance" rel="noopener ugc nofollow" target="_blank">从父模型类</a>继承来创建一个反映你的概念的模型。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="a828" class="ns mr it no b gy nt nu l nv nw">class StaffMember(models.Model):<br/>    user = models.OneToOneField(User, on_delete=models.CASCADE)<br/>    company = models.OneToOneField(Company, on_delete=models.CASCADE)<br/><br/>    def __str__(self):<br/>        return self.company.name + " - " + self.user.email</span></pre><p id="09af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你在Django中创建一个定制模型时，你继承了Django的模型类并利用了它的所有功能。您创建的每个模型通常都映射到一个数据库表。每个属性都是一个数据库字段。这使你能够创建人类可以更好理解的工作对象。</p><p id="d69d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过定义模型的字段，可以使模型对您有用。方便地提供了许多<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/models/fields/#model-field-types" rel="noopener ugc nofollow" target="_blank">内置字段类型</a>。这些帮助Django弄清楚数据类型、呈现表单时使用的HTML <a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/forms/widgets/" rel="noopener ugc nofollow" target="_blank">小部件</a>，甚至<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/forms/validation/" rel="noopener ugc nofollow" target="_blank">表单验证</a>需求。如果需要，您可以<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/howto/custom-model-fields/" rel="noopener ugc nofollow" target="_blank">编写自定义模型字段</a>。</p><p id="c5e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据库<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/topics/db/models/#relationships" rel="noopener ugc nofollow" target="_blank">关系</a>可以使用<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/models/fields/#django.db.models.ForeignKey" rel="noopener ugc nofollow" target="_blank">外键</a>字段(多对一)或<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/models/fields/#django.db.models.ManyToManyField" rel="noopener ugc nofollow" target="_blank">多对多字段</a>来定义(让你猜三次)。如果这些还不够，还有一个<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/models/fields/#django.db.models.OneToOneField" rel="noopener ugc nofollow" target="_blank">一对一字段</a>。总之，这些允许你定义你的模型之间的关系，其复杂程度只受你的想象力的限制。(取决于你的想象力，这可能是也可能不是优势。)</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="782d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">使用查询检索对象</h1><p id="36df" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">使用模型的管理器(默认为<code class="fe nx ny nz no b">objects</code>)来<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/topics/db/queries/#retrieving-objects" rel="noopener ugc nofollow" target="_blank">构建一个查询集</a>。这是数据库中对象的表示形式，您可以使用方法对其进行优化，以检索特定的子集。所有可用的方法都在<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/models/querysets/#django.db.models.query.QuerySet" rel="noopener ugc nofollow" target="_blank"> QuerySet API </a>中，并且可以链接在一起以获得更多乐趣。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="828c" class="ns mr it no b gy nt nu l nv nw">Post.objects.filter(<br/>    type="new"<br/>).exclude(<br/>    title__startswith="Blockchain"<br/>)</span></pre><p id="3419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些方法返回新的查询集，比如<code class="fe nx ny nz no b"><a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/models/querysets/#filter" rel="noopener ugc nofollow" target="_blank">filter()</a></code>或<code class="fe nx ny nz no b"><a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/models/querysets/#exclude" rel="noopener ugc nofollow" target="_blank">exclude()</a></code>。链接这些可以在不影响性能的情况下为您提供强大的查询，因为查询集在被评估之前不会从数据库<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/models/querysets/#when-querysets-are-evaluated" rel="noopener ugc nofollow" target="_blank">中获取。评估查询集的方法包括<code class="fe nx ny nz no b">get()</code>、<code class="fe nx ny nz no b"><a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/models/querysets/#count" rel="noopener ugc nofollow" target="_blank">count()</a></code>、<code class="fe nx ny nz no b">len()</code>、<code class="fe nx ny nz no b">list()</code>或<code class="fe nx ny nz no b">bool()</code>。</a></p><p id="7192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对QuerySet进行迭代也会对其进行计算，因此尽可能避免这样做，以提高查询性能。例如，如果您只想知道一个对象是否存在，您可以使用<code class="fe nx ny nz no b">exists()</code>来避免遍历数据库对象。</p><p id="c4c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您想要检索特定对象的情况下使用<code class="fe nx ny nz no b"><a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/models/querysets/#django.db.models.query.QuerySet.get" rel="noopener ugc nofollow" target="_blank">get()</a></code>。如果发生了意想不到的事情，这个方法会引发<code class="fe nx ny nz no b"><a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/exceptions/#django.core.exceptions.MultipleObjectsReturned" rel="noopener ugc nofollow" target="_blank">MultipleObjectsReturned</a></code>，如果发生了，会引发<code class="fe nx ny nz no b">DoesNotExist</code>异常。</p><p id="54a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想获得一个在用户请求的上下文中可能不存在的对象，请使用方便的<code class="fe nx ny nz no b"><a class="ae ky" href="https://docs.djangoproject.com/en/3.0/topics/http/shortcuts/#get-object-or-404" rel="noopener ugc nofollow" target="_blank">get_object_or_404()</a></code>或<code class="fe nx ny nz no b"><a class="ae ky" href="https://docs.djangoproject.com/en/3.0/topics/http/shortcuts/#get-list-or-404" rel="noopener ugc nofollow" target="_blank">get_list_or_404()</a></code>，它们会引发<code class="fe nx ny nz no b"><a class="ae ky" href="https://docs.djangoproject.com/en/3.0/topics/http/views/#django.http.Http404" rel="noopener ugc nofollow" target="_blank">Http404</a></code>而不是<code class="fe nx ny nz no b"><a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/models/instances/#django.db.models.Model.DoesNotExist" rel="noopener ugc nofollow" target="_blank">DoesNotExist</a></code>。这些有用的<a class="ae ky" href="https://docs.djangoproject.com/en/3.0/topics/http/shortcuts/" rel="noopener ugc nofollow" target="_blank">快捷方式</a>正好适合这个目的。要创建一个不存在的对象，还有一个方便的<code class="fe nx ny nz no b"><a class="ae ky" href="https://docs.djangoproject.com/en/3.0/ref/models/querysets/#get-or-create" rel="noopener ugc nofollow" target="_blank">get_or_create()</a></code>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="740d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">高效要素</h1><p id="64e3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">现在您已经掌握了构建高效Django应用程序的这三个基本工具——祝贺您！Django可以为您做的还有很多，请继续关注未来的文章。如果你打算在GitHub上构建，你可能想设置我的<a class="ae ky" href="https://github.com/victoriadrake/django-security-check" rel="noopener ugc nofollow" target="_blank">django-安全检查GitHub动作</a>。与此同时，您正在构建一个漂亮的软件项目。</p><p id="35a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多关于Django和建立一个伟大的技术团队的信息，请访问<a class="ae ky" href="https://victoria.dev/" rel="noopener ugc nofollow" target="_blank"> victoria.dev </a>或<a class="ae ky" href="https://victoria.dev/index.xml" rel="noopener ugc nofollow" target="_blank">通过RSS </a>订阅。</p></div></div>    
</body>
</html>