<html>
<head>
<title>Understanding the Observer Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解观察者设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-the-observer-design-pattern-f621b1d0b6c9?source=collection_archive---------2-----------------------#2021-01-22">https://betterprogramming.pub/understanding-the-observer-design-pattern-f621b1d0b6c9?source=collection_archive---------2-----------------------#2021-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e370" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对象之间的通知，无需轮询或等待</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/211189e36adbfdc3fbc9d11bc1b789d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3mH0kUcG0Qi1K0Sd"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@xokvictor?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Victor Xok </a>拍摄的照片。</p></figure><p id="ea73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原著<a class="ae ky" href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" rel="noopener ugc nofollow" target="_blank"> <em class="lv">设计模式:可复用面向对象软件的元素</em> </a>中描述了23种经典设计模式。这些模式为软件开发中经常出现的特定问题提供了解决方案。</p><p id="2ac2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将描述观察者模式是如何工作的，以及何时应该应用它。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5666" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">观察者:基本想法</h1><p id="1cfd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">维基百科为我们提供了如下定义:</p><blockquote class="na nb nc"><p id="3d5c" class="kz la lv lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">“观察者模式是一种<a class="ae ky" href="https://en.wikipedia.org/wiki/Design_pattern_(computer_science)" rel="noopener ugc nofollow" target="_blank">软件设计模式</a>，其中一个名为subject的<a class="ae ky" href="https://en.wikipedia.org/wiki/Object_(computer_science)#Objects_in_object-oriented_programming" rel="noopener ugc nofollow" target="_blank">对象</a>维护一个名为observer的依赖者列表，并自动通知它们任何状态变化，通常是通过调用它们的<a class="ae ky" href="https://en.wikipedia.org/wiki/Method_(computer_science)" rel="noopener ugc nofollow" target="_blank">方法</a>。”— <a class="ae ky" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="d630" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，原书提供的定义如下:</p><blockquote class="ng"><p id="1c10" class="nh ni it bd nj nk nl nm nn no np lu dk translated">定义对象之间的一对多依赖关系，以便当一个对象更改状态时，它的所有依赖对象都会得到通知并自动更新</p></blockquote><p id="0fcd" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">在许多情况下，我们需要与系统对象通信，而不需要在代码或通信机制级别耦合它们。如果我们有一组需要知道另一个对象(可观察的)状态的对象(观察者)，有不同的技术来实现它们之间的通信。最受欢迎的技术是:</p><ol class=""><li id="8ce5" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">忙碌等待—流程重复验证某个条件。在我们的例子中，它是一个观察者不断地检查可观察对象的状态是否已经改变。在某些情况下，这种策略可能是一种有效的解决方案，但对于我们的场景来说，它不是一种合适的解决方案，因为它意味着有几个进程(观察者)在不执行任何操作的情况下消耗资源，从而导致现有观察者数量的指数级性能下降。</li><li id="8892" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">轮询—在这种情况下，查询操作在两次操作之间的一个小时间窗口内执行。这是实现进程间同步的一种尝试。然而，我们可以再次体会到系统性能的下降。此外，根据每个查询之间的时间设置，信息可能会延迟，以至于可能是无效的，从而导致资源浪费。</li></ol><p id="0ba7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码展示了这些技术的实现。</p><ul class=""><li id="c5c8" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oj ob oc od bi translated">忙着等待:</li></ul><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="b42a" class="op me it ol b gy oq or l os ot">while(!condition){<br/>   // Query<br/>   if(isQueryValid) condition = true;<br/>}</span></pre><ul class=""><li id="ab61" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oj ob oc od bi translated">轮询:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="1ae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这不是本文的目标，但是理解这种设计模式的两种替代技术是一个好主意。因此，简而言之，主动等待和轮询技术之间的区别在于，前者始终执行查询操作，而后者有时不执行查询操作。</p><ul class=""><li id="d9f8" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oj ob oc od bi translated">忙着等待:</li></ul><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="63a8" class="op me it ol b gy oq or l os ot">while(resourceIsNotReady()){<br/>  //Do nothing<br/>}</span></pre><ul class=""><li id="ecad" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oj ob oc od bi translated">轮询:</li></ul><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="5ad0" class="op me it ol b gy oq or l os ot">while(resourceIsNotReady()){<br/>     Sleep(1000); // 1000 or anytime<br/> }</span></pre><p id="c885" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">观察者模式允许我们实现更高效、耦合性更低的代码，因为它避免了前面提到的问题。在代码可维护性方面，它还有其他优势。下面是这个模式的UML模式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/2d03a295607e98431230a5af6f148f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/1*Dk6aMlxBYXBPdFq4Ftxi2A.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">UML图来自《设计模式:可重用面向对象软件的元素》一书。</p></figure><p id="9267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是组成这种模式的类:</p><ul class=""><li id="8634" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oj ob oc od bi translated"><code class="fe ox oy oz ol b">Subject</code>是每个被观察类实现的接口。这个接口包含了<code class="fe ox oy oz ol b">attach</code>和<code class="fe ox oy oz ol b">detach</code>方法，允许我们在类中添加和移除观察者。它还包含一个<code class="fe ox oy oz ol b">notify</code>方法，负责通知所有观察者被观察对象发生了变化。此外，所有的<code class="fe ox oy oz ol b">subjects</code>都存储观察它们的对象的引用(<code class="fe ox oy oz ol b">observers</code>)。</li><li id="0b31" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oj ob oc od bi translated"><code class="fe ox oy oz ol b">Observer</code>是所有<code class="fe ox oy oz ol b">ConcreteObservers</code>实现的接口。在这个接口中，定义了<code class="fe ox oy oz ol b">update</code>方法，该方法包含每个观察者在收到来自<code class="fe ox oy oz ol b">Subject</code>的变更通知时要执行的业务逻辑。</li><li id="3dd3" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oj ob oc od bi translated"><code class="fe ox oy oz ol b">ConcreteSubject</code>是<code class="fe ox oy oz ol b">Subject</code>类的具体实现。<br/>该类定义了<code class="fe ox oy oz ol b">SubjectState</code>应用程序的状态，当发生变化时必须通知该状态。由于这个原因，访问器方法(<code class="fe ox oy oz ol b">getState</code>和<code class="fe ox oy oz ol b">setState</code>)通常被实现，因为它们操纵状态。这个类还负责在状态改变时向它的所有观察者发送通知。</li><li id="91a0" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oj ob oc od bi translated">是为每个具体的观察者建模的类。在这个类中，实现了属于<code class="fe ox oy oz ol b">Observer</code>接口的<code class="fe ox oy oz ol b">update</code>方法。它负责始终保持其状态，后者负责保持其状态与其正在观察的<code class="fe ox oy oz ol b">subject</code>对象一致。</li></ul><p id="b721" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今，有一个名为<a class="ae ky" href="https://en.wikipedia.org/wiki/ReactiveX" rel="noopener ugc nofollow" target="_blank"> Reactive Extensions或react vex</a>的库家族使得这种设计模式流行起来。反应式扩展利用了两种设计模式:</p><ol class=""><li id="e14f" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">观察者</li><li id="92f0" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><a class="ae ky" href="https://medium.com/better-programming/understanding-the-iterator-pattern-in-javascript-typescript-using-symbol-iterator-ab400d46b14a" rel="noopener">迭代器</a>。</li></ol><p id="752a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们还有一组使用函数式编程的操作人员。以下是一些最受欢迎的反应式延伸:</p><ul class=""><li id="77f1" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oj ob oc od bi translated">Java: <a class="ae ky" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a></li><li id="a0fc" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oj ob oc od bi translated">JavaScript: <a class="ae ky" href="https://github.com/ReactiveX/rxjs" rel="noopener ugc nofollow" target="_blank"> RxJS </a></li><li id="005e" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oj ob oc od bi translated">c#:<a class="ae ky" href="https://github.com/Reactive-Extensions/Rx.NET" rel="noopener ugc nofollow" target="_blank">Rx.NET</a></li><li id="3086" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oj ob oc od bi translated">C#(Unity): <a class="ae ky" href="https://github.com/neuecc/UniRx" rel="noopener ugc nofollow" target="_blank"> UniRx </a></li></ul><p id="85c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些实现中，类和方法的命名有所不同。以下名称是最常用的名称:</p><ol class=""><li id="afd4" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated"><code class="fe ox oy oz ol b">Subscriber</code>对应<code class="fe ox oy oz ol b">Observer</code>类。</li></ol><p id="0634" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<code class="fe ox oy oz ol b">ConcreteSubscribers</code>对应<code class="fe ox oy oz ol b">ConcreteObservers</code>类。</p><p id="eb16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.<code class="fe ox oy oz ol b">Subject</code>类保持不变。<code class="fe ox oy oz ol b">attach</code>和<code class="fe ox oy oz ol b">detach</code>方法被重命名为<code class="fe ox oy oz ol b">subscribe</code>和<code class="fe ox oy oz ol b">unsubscribe</code>。</p><p id="9040" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.<code class="fe ox oy oz ol b">ConcreteSubjects</code>类是具体的实现，如<code class="fe ox oy oz ol b">BehaviorSubject</code>、<code class="fe ox oy oz ol b">ReplaySubject</code>或<code class="fe ox oy oz ol b">AsyncSubject</code>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6606" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">观察者模式:沟通策略</h1><p id="7f0e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在观察者模式中<code class="fe ox oy oz ol b">Subjects</code>(可观察对象)和<code class="fe ox oy oz ol b">Observers</code>(观察者)之间有两种通信策略:</p><ul class=""><li id="6449" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oj ob oc od bi translated">拉取——在这个模型中，<code class="fe ox oy oz ol b">subject</code>向<code class="fe ox oy oz ol b">observer</code>发送最少的信息，它们负责查询以获得更多的细节。这个模型关注的是<code class="fe ox oy oz ol b">Subject</code>忽略了<code class="fe ox oy oz ol b">observer</code>这一事实。</li><li id="64c5" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oj ob oc od bi translated">推送——在这个模型中，<code class="fe ox oy oz ol b">subject</code>向<code class="fe ox oy oz ol b">observer</code>发送变更产生的最大量的信息，不管他们是否想要。在这个模型中，<code class="fe ox oy oz ol b">Subject</code>深入了解每个<code class="fe ox oy oz ol b">observers</code>的需求。</li></ul><p id="a946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管由于<code class="fe ox oy oz ol b">Subject</code>必须了解<code class="fe ox oy oz ol b">observer</code>的事实，似乎<em class="lv">先验地</em>认为<code class="fe ox oy oz ol b">push</code>通信技术不太容易重用，但情况并非总是如此。另一方面，基于<code class="fe ox oy oz ol b">pull</code>的通信技术可能效率低下，因为<code class="fe ox oy oz ol b">observer</code>必须在没有<code class="fe ox oy oz ol b">Subject</code>帮助的情况下计算出发生了什么变化。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c00b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">观察者模式:何时使用</h1><ol class=""><li id="685f" class="nv nw it lb b lc mv lf mw li pa lm pb lq pc lu oa ob oc od bi translated">系统对象之间存在一对多的依赖关系，因此当对象改变状态时，需要自动通知所有依赖对象。</li><li id="63a2" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">您不希望使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Busy_waiting" rel="noopener ugc nofollow" target="_blank">忙等待</a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Polling_(computer_science)" rel="noopener ugc nofollow" target="_blank">轮询</a>来更新观察者。</li><li id="4f8b" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">解耦<code class="fe ox oy oz ol b">Subject</code>对象(可观察对象)和<code class="fe ox oy oz ol b">Observers</code>(观察对象)之间的依赖关系，允许您遵守<em class="lv">开闭原则</em>。</li></ol></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0892" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">观察者模式:优点和缺点</h1><p id="cd9b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">观察者模式有许多优点，可以总结为以下几点:</p><ul class=""><li id="747f" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oj ob oc od bi translated">代码更易于维护，因为它在可观察的类和它们的依赖项(观察者)之间耦合更少。</li><li id="8150" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oj ob oc od bi translated">干净的代码。开闭原则得到保证，因为新的观测器(订户)可以在不破坏可观测对象中的现有代码的情况下被引入(反之亦然)。</li><li id="569a" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oj ob oc od bi translated">更干净的代码。遵守<em class="lv">单一责任原则(SRP) </em>,因为每个观察者的责任被转移到其<code class="fe ox oy oz ol b">update</code>方法，而不是在<code class="fe ox oy oz ol b">Observable</code>对象中拥有该业务逻辑。</li></ul><p id="cfff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:对象之间的关系可以在运行时建立，而不是在编译时。</p><p id="eaf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，观察者模式的主要缺点——像大多数设计模式一样——是增加了代码的复杂性和代码所需的类的数量。也就是说，在应用设计模式时，这个缺点是众所周知的，因为这是在代码中获得抽象的代价。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c6e4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">观察者模式示例</h1><p id="0d23" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">接下来，我们将举例说明观察者模式的两个例子:</p><ol class=""><li id="59aa" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">观察者模式的基本结构。在这个例子中，我们将把理论上的UML图转换成类型脚本代码，以识别模式中涉及的每个类。</li><li id="571e" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">一个拍卖系统，其中有一个对象(<code class="fe ox oy oz ol b">subject</code>)发出一个<code class="fe ox oy oz ol b">product</code>的<code class="fe ox oy oz ol b">price</code>中产生的变化(<code class="fe ox oy oz ol b">push</code>技术)，该变化被拍卖给所有对获得那个<code class="fe ox oy oz ol b">product</code>感兴趣的观察者(<code class="fe ox oy oz ol b">observer</code>)。每次<code class="fe ox oy oz ol b">product</code>拍卖的<code class="fe ox oy oz ol b">price</code>因为某个<code class="fe ox oy oz ol b">observador</code>提高了出价而提高时，都会通知给所有的观察者。</li></ol><p id="4e9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下示例将展示使用TypeScript实现这种模式。我们选择了TypeScript而不是JavaScript来实现这个实现。后者缺少接口或抽象类，因此实现接口和抽象类的责任将落在开发人员身上。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0f97" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">示例1:观察者模式的基本结构</h1><p id="115b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在第一个例子中，我们将把理论上的UML图转换成TypeScript来测试这种模式的潜力。这是要实现的图表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/6cddbaeff203d9bc2f13c67929c47471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*qNlF1YbirVKOjCaIGgihnQ.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">UML图来自《设计模式:可重用面向对象软件的元素》一书。</p></figure><p id="cb32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们要定义我们问题的接口(<code class="fe ox oy oz ol b">Subject</code>)。作为一个接口，所有必须在所有特定的<code class="fe ox oy oz ol b">Subject</code>中实现的方法都被定义。在我们这里，只有一个:<code class="fe ox oy oz ol b">ConcreteSubject</code>。<code class="fe ox oy oz ol b">Subject</code>接口定义了符合该模式所需的三种方法:<code class="fe ox oy oz ol b">attach</code>、<code class="fe ox oy oz ol b">detach</code>和<code class="fe ox oy oz ol b">notify</code>。<code class="fe ox oy oz ol b">attach</code>和<code class="fe ox oy oz ol b">detach</code>方法接收<code class="fe ox oy oz ol b">observer</code>作为将在<code class="fe ox oy oz ol b">Subject</code>数据结构中添加或删除的参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">科目</p></figure><p id="ad10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的问题中，我们需要多少就有多少。由于这个问题是观察者<em class="lv"> </em>模式的基本方案，我们只需要一个<code class="fe ox oy oz ol b">ConcreteSubject</code>。在第一个问题中，观察到的状态是类型为<code class="fe ox oy oz ol b">number</code>的<code class="fe ox oy oz ol b">state</code>属性。另一方面，所有的<code class="fe ox oy oz ol b">observers</code>都存储在一个名为<code class="fe ox oy oz ol b">observer</code>的数组中。<code class="fe ox oy oz ol b">attach</code>和<code class="fe ox oy oz ol b">detach</code>方法检查<code class="fe ox oy oz ol b">observer</code>之前是否在数据结构中，以将其添加或移除。最后，<code class="fe ox oy oz ol b">notify</code>方法负责调用所有正在观察<code class="fe ox oy oz ol b">Subject</code>的<code class="fe ox oy oz ol b">observers</code>方法。</p><p id="2f64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ox oy oz ol b">ConcreteSubject</code>类的对象执行一些与每个问题的特定业务逻辑相关的任务。在这个例子中，有一个名为<code class="fe ox oy oz ol b">operation</code>的方法负责修改<code class="fe ox oy oz ol b">state</code>并调用<code class="fe ox oy oz ol b">notify</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具体主体</p></figure><p id="e54b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个设计模式的另一部分是<code class="fe ox oy oz ol b">observer</code>。因此，让我们从定义<code class="fe ox oy oz ol b">Observer</code>接口开始，该接口只需要定义负责在每次通知<code class="fe ox oy oz ol b">observer</code>发生变化时执行的<code class="fe ox oy oz ol b">update</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">观察者</p></figure><p id="f905" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个实现这个接口的类必须在<code class="fe ox oy oz ol b">update</code>方法中包含它的业务逻辑。在本例中，定义了两个<code class="fe ox oy oz ol b">ConcreteObservers</code>。他们将根据<code class="fe ox oy oz ol b">Subject</code>的<code class="fe ox oy oz ol b">state</code>执行动作。下面的代码展示了两种不同类型的观察者的两个具体实现:<code class="fe ox oy oz ol b">ConcreteObserverA</code>和<code class="fe ox oy oz ol b">ConcreteObserverB</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">混凝土观测仪</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">混凝土观察员b</p></figure><p id="2350" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们定义利用这种模式的<code class="fe ox oy oz ol b">Client</code>或<code class="fe ox oy oz ol b">Context</code>类。在以下代码中，实现了模拟使用<code class="fe ox oy oz ol b">Subject</code>和<code class="fe ox oy oz ol b">Observer</code>的必要类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1da0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">示例2:使用观察者的拍卖</h1><p id="fd64" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在这个例子中，我们将使用Observer模式来模拟一个拍卖行，其中一组拍卖人(<code class="fe ox oy oz ol b">Auctioneer</code>)对不同的产品(<code class="fe ox oy oz ol b">product</code>)进行投标。拍卖由代理人指导(<code class="fe ox oy oz ol b">Agent</code>)。我们所有的拍卖人都需要在其中一人每次提高出价时得到通知，以便他们可以决定是继续出价还是退出。</p><p id="7b94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像我们在前面的例子中所做的一样，让我们先来看看UML图，它将帮助我们识别这个模式所包含的每个部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/5e8e7eeb492697adfdceee859cb55ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4EraBmYxYAQlQH_PRXb7VA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">观察者模式</p></figure><p id="1c1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">被拍卖的<code class="fe ox oy oz ol b">product</code>是<code class="fe ox oy oz ol b">Subject</code>的州，所有的<code class="fe ox oy oz ol b">observers</code>都在等待通知。因此，<code class="fe ox oy oz ol b">product</code>类由三个属性组成:<code class="fe ox oy oz ol b">price</code>、<code class="fe ox oy oz ol b">name</code>和<code class="fe ox oy oz ol b">auctionner</code>(被分配产品的拍卖人)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">产品</p></figure><p id="d686" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ox oy oz ol b">Agent</code>接口定义了管理<code class="fe ox oy oz ol b">Auctioneers</code>组的方法，并通知他们拍卖产品的出价已经改变。在这种情况下，<code class="fe ox oy oz ol b">attach</code>和<code class="fe ox oy oz ol b">detach</code>方法被重命名为<code class="fe ox oy oz ol b">subscribe</code>和<code class="fe ox oy oz ol b">unsubscribe</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代理人</p></figure><p id="aa8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ox oy oz ol b">Agent</code>接口的具体实现由<code class="fe ox oy oz ol b">ConcreteAgent</code>类完成。除了之前描述的三个方法(其行为与之前示例中呈现的行为非常相似)之外，还实现了<code class="fe ox oy oz ol b">bidUp</code>方法。在对拍卖人的出价进行一些检查后，它将该出价指定为有效，并将这一更改通知所有拍卖人。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="c255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个问题中，在<code class="fe ox oy oz ol b">AuctioneerA</code>、<code class="fe ox oy oz ol b">AuctioneerB</code>、<code class="fe ox oy oz ol b">AuctioneerC</code>和<code class="fe ox oy oz ol b">AuctioneerD</code>类中定义了四种不同类型的<code class="fe ox oy oz ol b">Auctioneer</code>。所有这些拍卖程序都实现了<code class="fe ox oy oz ol b">Auctioneer</code>接口，该接口定义了<code class="fe ox oy oz ol b">name</code>、<code class="fe ox oy oz ol b">MAX_LIMIT</code>和<code class="fe ox oy oz ol b">update</code>方法。<code class="fe ox oy oz ol b">MAX_LIMIT</code>属性定义了每种<code class="fe ox oy oz ol b">Auctioneer</code>可以出价的最大金额。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="313c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义了不同类型的<code class="fe ox oy oz ol b">Auctioneer</code>来说明在<code class="fe ox oy oz ol b">update</code>方法中接收到<code class="fe ox oy oz ol b">Agent</code>的通知时，每一个都有不同的行为。尽管如此，在这个例子中所修改的只是继续出价的概率和他们提高出价的金额。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">混凝土拍卖公司</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">混凝土拍卖商b</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">混凝土拍卖公司</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">混凝土拍卖商d</p></figure><p id="f1a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们展示一下利用观察者模式的<code class="fe ox oy oz ol b">Client</code>类。在这个例子中，用一个<code class="fe ox oy oz ol b">Agent</code>和四个<code class="fe ox oy oz ol b">Auctioneers</code>声明了一个拍卖行。两个不同的产品(<code class="fe ox oy oz ol b">diamond</code>和<code class="fe ox oy oz ol b">gem</code>)正在被拍卖。在第一次拍卖中，所有四个拍卖人都参与。在第二次拍卖中，<code class="fe ox oy oz ol b">D</code>级拍卖师退出，剩下三人参与。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户</p></figure><p id="f2ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我创建了两个<code class="fe ox oy oz ol b">npm scripts</code>，通过它们可以执行本文中的代码:</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="3108" class="op me it ol b gy oq or l os ot">npm run example1<br/>npm run example2</span></pre><p id="aa91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整代码见本<a class="ae ky" href="https://github.com/Caballerog/blog/tree/master/observer-pattern" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="184e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="57b0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Observer是一种设计模式，它允许你遵守开闭原则，因为新的<code class="fe ox oy oz ol b">Subject</code>和<code class="fe ox oy oz ol b">Observer</code>可以在不破坏现有代码的情况下创建。此外，它允许系统的两个参与者之间的通信，而不需要他们知道彼此。最后，在诸如繁忙等待和轮询等更基本的技术中出现的性能下降被克服。</p><p id="de93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种模式最重要的不是它的具体实现，而是能够认识到这种模式可以解决的问题以及何时可以应用它。具体的实现并不重要，因为它会根据所使用的编程语言而有所不同。</p></div></div>    
</body>
</html>