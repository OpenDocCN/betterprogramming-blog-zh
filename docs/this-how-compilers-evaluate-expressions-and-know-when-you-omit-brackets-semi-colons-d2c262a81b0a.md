# O(n)时间内解决平衡支架问题

> 原文：<https://betterprogramming.pub/this-how-compilers-evaluate-expressions-and-know-when-you-omit-brackets-semi-colons-d2c262a81b0a>

## 编译器如何知道你何时省略了括号和分号

![](img/a6f1641b3911955e40b2ad823c54688a.png)

Photo by [青 晨](https://unsplash.com/@jiangxulei1990?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/search/photos/balance?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

你猜怎么着？事实上，编译器不是能看穿你每一行代码的通灵生物。我要给你一些见解，每次你错配一对括号时，他们是如何准确地指出你的。

今天我们将解决一个关于平衡支架的问题。我将向您展示问题陈述和强力方法，并在我们深入研究解决方案之前给您一个提示:暂停一会儿，尝试思考这个问题。我总是鼓励人们自己尝试一些东西，因为你的好奇心将在你成为什么样的开发人员中扮演重要角色。

顺便说一下，如果你没有看过我的关于栈的教程，也没有任何关于栈的经验，或者你想复习一下，至少可以看看关于在 O(1)时间内解决最小栈问题的教程。

所以，继续吧？是啊！

# 平衡括号

括号有三种:[] {}()。给定一个字符串，检查字符串中的所有括号是否平衡。如果所有的开始和结束括号顺序正确，并且相互匹配，则字符串是平衡的。

以下是一些平衡琴弦:

*   **{}**
*   **(喂)【世界】**
*   **[({}{}{})([])]**

下面是一些不平衡的:

*   **(你好** —没有结尾 **)** 。
*   **([)]**——在 **()** 中 **[** 被不恰当地包围。
*   **)(** —有个结尾 **)** 前面没有 **(** )。

如果一行平衡，返回`true`，否则返回`false`。

## 例子

以下是三个测试案例:

*   `puts balanced_*brackets?(‘(hello)[world]’)*`

`*# => true*`

*   `*puts balanced_*brackets?(‘([)]’)`

`# => false`

`puts balanced_brackets?(‘[({}{}{})([])]’)`

`# => true`

提示:愿栈与你同在！我鼓励你在这一点上暂停一下，进行一点头脑风暴。

上主菜！

# 解决办法

我将要声明一些类和方法，但是为了避免重复，我不会在本教程中带你看每个类和方法是做什么的。如果你想对这些类和方法有更多的了解，可以看看我的关于最小堆栈问题的教程(如上所述)。

首先，因为堆栈是基于节点的，所以我们需要设置我们的节点类:

接下来，我们初始化堆栈:

接下来，我们请来了少校`pushFront`:

然后`popFront`它的对应物:

接下来，`topFront`:

最后，`is_empty?`:

现在，让我们来看看最吸引人的地方:我们如何确保一组括号是平衡的？去卡车那里！

我将把它分成三个部分:

*   初始化我们的堆栈
*   在我们的绳子上循环
*   返回`true`如果我们设法到达循环的终点

让我们看看在我们的循环中应该发生什么:

*   当堆栈为空时，我们希望将字符串中的第一个字符推送到堆栈中，这样我们就有了可以与后续字符进行比较的东西。(如果是括号，只推字符)。
*   如果一个字符是一个开括号，我们想把它推入堆栈。
*   如果一个字符是一个闭括号，我们要检查我们是否只是把它的前半部分放入堆栈，如果是，那么就有一个匹配。我们通过从堆栈中移除开始的一半来庆祝这场比赛。
*   如果我们得到一个闭括号，而不是把它的左半部分放入堆栈，那么我们就有一对不快乐的夫妇。循环应立即停止并返回`false`。
*   但是，假设我们有这样的东西`'[()'`。请注意，我们有一个左方括号，没有一个关闭它。接下来会发生什么？我们如何处理这种边缘情况？当循环结束时，我们只是检查堆栈是否为空。

注意:读了一些代码后，你可能会奇怪为什么我没有声明一个包含所有括号类型的数组，并使用像`.include?`这样的方法。好吧，简单的答案是像这样的方法实际上有 O(n)的时间复杂度。这意味着当你将它们嵌套在一个循环中时，你的复杂度从 O(n)变为 O(n)，这是性能差的同义词。

# **让我们写一些代码**

首先，解决空栈问题:

请注意，在比较当前索引的值和三种类型的开括号的值时，使用了布尔运算符。这是因为像这样的比较是常数时间操作 O(1 ),而不是像`.include?`这样的操作。

接下来，我们只需要推送一个带左括号的字符:

现在，我们需要处理三种不同类型的右括号的边界情况。为此，我使用了下面的 switch 语句:

每次我们遇到一个结束括号，我们使用`topFront`来查看我们在堆栈上推的最后一个括号。如果它与右括号匹配，我们弹出——移除堆栈顶部的内容，继续循环，直到到达字符串的末尾。

现在，还记得这个`'[()'`？我们仍然需要注意这一点，以防我们遇到一个值得尊敬的对手，他试图欺骗我们的程序。只需在您的`return true`语句前添加这一行:

`return false if s.first.next_node`

当我们到达字符串末尾时，它检查堆栈是否为空。如果不是，那么我们没有关闭我们应该关闭的所有括号。

# 结论

这就是了。这基本上是编译器如何获得他们的精神力量！众所周知，平衡括号是编译器执行的最重要的操作之一。

请务必在下面的回复中留下一些评论。我很想知道你的想法。

你可以在 [GitHub](https://github.com/Oluwadamilareolusakin/balancing-brackets) 上找到这个教程的代码。