<html>
<head>
<title>Domain-Driven Design Setup For Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振的领域驱动设计设置</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/domain-driven-design-setup-for-flutter-2d621f24f8b4?source=collection_archive---------4-----------------------#2022-01-30">https://betterprogramming.pub/domain-driven-design-setup-for-flutter-2d621f24f8b4?source=collection_archive---------4-----------------------#2022-01-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3a91" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在你的Flutter代码库中开始域驱动设计</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/601ee233bb3177e85d26bd1c8796a76f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*CrfXYpVtcGIeYoBOZq4R3A.png"/></div></figure><p id="662d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是颤振领域驱动设计的示例设置。我使用Flutter skeleton应用程序来简化事情。我们开始吧。</p><h1 id="1a28" class="lm ln it bd lo lp lq lr ls lt lu lv lw jz lx ka ly kc lz kd ma kf mb kg mc md bi translated"><strong class="ak">核心或域驱动设计</strong></h1><p id="f6ea" class="pw-post-body-paragraph kq kr it ks b kt me ju kv kw mf jx ky kz mg lb lc ld mh lf lg lh mi lj lk ll im bi translated">领域驱动设计的核心概念是使用值对象作为与组件和层通信的原子单位。这一次，我们将创建一个非常简单的值对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="3c69" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">你会注意到我们把它标记为不可变的，并且它使用了一个等价的mixin。所以当我们用它作为基类时，它也倾向于成为一个值对象:</p><p id="843b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，让我们实现它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="8ec6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在让我们把它扩展成一个<code class="fe ml mm mn mo b">Model</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="6af2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然后是<code class="fe ml mm mn mo b">SampleItemModel</code>实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="2d05" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在让我们看看如何测试它:</p><p id="8ab2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我使用mocktail进行模拟，但是<code class="fe ml mm mn mo b">mockito</code>也有相同的基本API，下面是模拟:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="a9d3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">而<code class="fe ml mm mn mo b">Model</code>嘲弄道:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="52af" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然后测试将会是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="41ee" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，记住，它是一个骨架应用程序，只有一个listview模型，没有用户输入。</p><p id="8013" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">此外，没有访问任何非本地API的逻辑。因此，剩下要添加的是一个数据源、一个单一用例以及列表视图模型。所以我们来补充一下。</p><h1 id="1e5e" class="lm ln it bd lo lp lq lr ls lt lu lv lw jz lx ka ly kc lz kd ma kf mb kg mc md bi translated"><strong class="ak">完成示例</strong></h1><p id="b756" class="pw-post-body-paragraph kq kr it ks b kt me ju kv kw mf jx ky kz mg lb lc ld mh lf lg lh mi lj lk ll im bi translated">让我们从实现列表视图模型开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="1fb1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">单元测试应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="0d30" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我们需要一个列表视图模型的数据源:</p><p id="2c8c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于数据源、存储库和用例的接口，我们使用了<code class="fe ml mm mn mo b">Dartz</code>包:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="5793" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，让我花点时间谈谈错误和异常。现在让我问一下，为什么我没有在这里使用异常？两个关键原因。</p><p id="d885" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第一，任何时候抛出一个错误，它都会给出堆栈跟踪。</p><p id="973f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第二，显然我们正在规划我们的领域层，这样我们就不会抛出应用程序停止异常。因此，我需要使用一个<code class="fe ml mm mn mo b">Error</code>类，而不是一个异常类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="b52f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，对数据源的单元测试是:</p><p id="0f38" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">嘲弄:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="5e79" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">和单元测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="9f5f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后我们有一个用例:</p><p id="2f47" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">界面:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="2d12" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">以及具体实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="3957" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">单元测试是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><h1 id="ad27" class="lm ln it bd lo lp lq lr ls lt lu lv lw jz lx ka ly kc lz kd ma kf mb kg mc md bi translated"><strong class="ak">前进</strong></h1><p id="a297" class="pw-post-body-paragraph kq kr it ks b kt me ju kv kw mf jx ky kz mg lb lc ld mh lf lg lh mi lj lk ll im bi translated">现在，我不再讨论如何连接视图模型，但是如果您遵循带有服务组件和控制器的设置视图的模式，那么添加它就有些容易了。但是缺少了什么呢？</p><p id="4de5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我保持简单，没有添加DDD的其他部分，即其余的值对象机制和事件调度。</p><p id="8c4d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">另一个值对象机制与将实体更改为<code class="fe ml mm mn mo b">ValueObject(Types)</code>以及设置验证器和其他集成有关。然后将其扩展到事件状态值对象，并为用例、数据源、repo和视图模型创建事件调度程序。</p><p id="690d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">简而言之，状态管理布线。相比之下，在Flutter中的Clean Arch中，通常只需使用BLoC或Redux连接视图模型进行状态管理。</p><h1 id="4b6b" class="lm ln it bd lo lp lq lr ls lt lu lv lw jz lx ka ly kc lz kd ma kf mb kg mc md bi translated"><strong class="ak">结论</strong></h1><p id="c427" class="pw-post-body-paragraph kq kr it ks b kt me ju kv kw mf jx ky kz mg lb lc ld mh lf lg lh mi lj lk ll im bi translated">这是领域驱动设计的一些核心。接下来是创建更复杂的值对象和事件调度。示例代码可在以下报告中找到:</p><div class="mp mq gp gr mr ms"><a href="https://github.com/fredgrott/equatable_ddd_modeling" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd iu gy z fp mx fr fs my fu fw is bi translated">GitHub-Fred grott/equatable _ ddd _ modeling:使用equatable和DDD的颤振演示项目</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">一个Flutter演示项目，展示了如何使用等价值对象作为接口和实现之间的粘合剂…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng ko ms"/></div></div></a></div><p id="dea2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我贡献的一些Flutter社区插件有:</p><ul class=""><li id="371e" class="nh ni it ks b kt ku kw kx kz nj ld nk lh nl ll nm nn no np bi translated"><a class="ae nq" href="https://pub.dev/packages/flutter_platform_widgets" rel="noopener ugc nofollow" target="_blank">Flutter _ platform _ widgets | Flutter包</a></li><li id="9ae6" class="nh ni it ks b kt nr kw ns kz nt ld nu lh nv ll nm nn no np bi translated"><a class="ae nq" href="https://pub.dev/packages/catcher" rel="noopener ugc nofollow" target="_blank">捕手|扑包</a></li></ul><pre class="kj kk kl km gt nw mo nx ny aw nz bi"><span id="203b" class="oa ln it mo b gy ob oc l od oe"><strong class="mo iu">Want to Connect?</strong></span><span id="12b4" class="oa ln it mo b gy of oc l od oe">Follow me on <a class="ae nq" href="https://twitter.com/fredgrott" rel="noopener ugc nofollow" target="_blank">Twitter</a>. You can also stay updated with my latest Flutter sprints available in this <a class="ae nq" href="https://github.com/fredgrott/fredgrott_in_depth_flutter" rel="noopener ugc nofollow" target="_blank">GitHub Repository</a>.</span></pre><h1 id="9cef" class="lm ln it bd lo lp lq lr ls lt lu lv lw jz lx ka ly kc lz kd ma kf mb kg mc md bi translated">资源</h1><p id="9c24" class="pw-post-body-paragraph kq kr it ks b kt me ju kv kw mf jx ky kz mg lb lc ld mh lf lg lh mi lj lk ll im bi translated">一些有用的资源(图书链接指向archive org免费pdf和图书借阅):</p><ul class=""><li id="0b70" class="nh ni it ks b kt ku kw kx kz nj ld nk lh nl ll nm nn no np bi translated"><a class="ae nq" href="https://m3.material.io/" rel="noopener ugc nofollow" target="_blank">材料设计3(材料你)规格</a></li><li id="2945" class="nh ni it ks b kt nr kw ns kz nt ld nu lh nv ll nm nn no np bi translated"><a class="ae nq" href="https://www.nngroup.com/" rel="noopener ugc nofollow" target="_blank">尼尔森诺曼集团</a>是UI设计领域最顶尖的研究小组之一。一些信息是付费的，但是仍然有一个很好的免费的基础来查看和使用。</li><li id="ffe9" class="nh ni it ks b kt nr kw ns kz nt ld nu lh nv ll nm nn no np bi translated"><a class="ae nq" href="https://archive.org/details/pdfy-9Bb1XUCNFvb5HrMP" rel="noopener ugc nofollow" target="_blank">唐纳德·诺曼的日常事物</a></li><li id="7b33" class="nh ni it ks b kt nr kw ns kz nt ld nu lh nv ll nm nn no np bi translated"><a class="ae nq" href="https://archive.org/details/usabilityenginee00jak_pv3" rel="noopener ugc nofollow" target="_blank">雅各布·尼尔森的可用性工程</a></li><li id="1961" class="nh ni it ks b kt nr kw ns kz nt ld nu lh nv ll nm nn no np bi translated">罗伯特·马丁的《洁净的拱门》的概要见此处的<a class="ae nq" href="https://gist.github.com/ygrenzinger/14812a56b9221c9feca0b3621518635b" rel="noopener ugc nofollow" target="_blank">要点。</a></li><li id="2d91" class="nh ni it ks b kt nr kw ns kz nt ld nu lh nv ll nm nn no np bi translated"><a class="ae nq" href="https://matfrs2.github.io/RS2/predavanja/literatura/Avram%20A,%20Marinescu%20F.%20-%20Domain%20Driven%20Design%20Quickly.pdf" rel="noopener ugc nofollow" target="_blank"> InfoQ领域驱动设计快速总结(PDF) </a></li><li id="03c3" class="nh ni it ks b kt nr kw ns kz nt ld nu lh nv ll nm nn no np bi translated">贝蒂·爱德华兹教授的掌握调色艺术的课程</li><li id="9f0e" class="nh ni it ks b kt nr kw ns kz nt ld nu lh nv ll nm nn no np bi translated"><a class="ae nq" href="https://github.com/scottt2/design-patterns-in-dart" rel="noopener ugc nofollow" target="_blank">斯科特的飞镖设计图案GitHub repo </a></li><li id="6a17" class="nh ni it ks b kt nr kw ns kz nt ld nu lh nv ll nm nn no np bi translated"><a class="ae nq" href="https://archive.org/details/GridSystemsInGraphicDesignJosefMullerBrockmann" rel="noopener ugc nofollow" target="_blank">约瑟夫·穆勒的平面设计网格系统</a></li><li id="ddfc" class="nh ni it ks b kt nr kw ns kz nt ld nu lh nv ll nm nn no np bi translated"><a class="ae nq" href="https://oa.letterformarchive.org/" rel="noopener ugc nofollow" target="_blank">字体存档</a></li><li id="56f1" class="nh ni it ks b kt nr kw ns kz nt ld nu lh nv ll nm nn no np bi translated">斯蒂芬·科尔解剖六个字母的字体(是的，这是斯蒂芬·科尔的网站，那里还有其他宝石)</li><li id="bb97" class="nh ni it ks b kt nr kw ns kz nt ld nu lh nv ll nm nn no np bi translated"><a class="ae nq" href="https://typedetail.com/" rel="noopener ugc nofollow" target="_blank">类型细节</a></li><li id="9081" class="nh ni it ks b kt nr kw ns kz nt ld nu lh nv ll nm nn no np bi translated"><a class="ae nq" href="https://archive.org/details/logodesignlogodesignlove" rel="noopener ugc nofollow" target="_blank">标志设计大卫·艾雷的爱情</a></li><li id="cfdf" class="nh ni it ks b kt nr kw ns kz nt ld nu lh nv ll nm nn no np bi translated"><a class="ae nq" href="https://designarchives.aiga.org/#/home" rel="noopener ugc nofollow" target="_blank"> AIGA设计档案馆</a></li><li id="c287" class="nh ni it ks b kt nr kw ns kz nt ld nu lh nv ll nm nn no np bi translated"><a class="ae nq" href="https://wisewords.blog/book-summaries/predatory-thinking-book-summary/" rel="noopener ugc nofollow" target="_blank">戴夫·特洛特的掠夺性思维概述:超越竞争的大师级人物</a></li><li id="9a89" class="nh ni it ks b kt nr kw ns kz nt ld nu lh nv ll nm nn no np bi translated"><a class="ae nq" href="https://github.com/hmemcpy/milewski-ctfp-pdf/releases/download/v1.3.0/category-theory-for-programmers.pdf" rel="noopener ugc nofollow" target="_blank"> Bartosz Milewski的PDF格式程序员范畴理论(即函数式编程和OOP类型理论)</a></li><li id="2910" class="nh ni it ks b kt nr kw ns kz nt ld nu lh nv ll nm nn no np bi translated"><a class="ae nq" href="https://www.logicmatters.net/categories/" rel="noopener ugc nofollow" target="_blank">分类讲义和书籍资源</a></li></ul></div></div>    
</body>
</html>