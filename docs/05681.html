<html>
<head>
<title>Context Managers in Python — Go Beyond “with open() as file”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的上下文管理器—超越“以open()作为文件”</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/context-managers-in-python-go-beyond-with-open-as-file-85a27e392114?source=collection_archive---------0-----------------------#2020-07-28">https://betterprogramming.pub/context-managers-in-python-go-beyond-with-open-as-file-85a27e392114?source=collection_archive---------0-----------------------#2020-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fd5a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你在别处用过with语句吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/433a964eb21b710b795a15dc3ad2b04b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9mYfVGcqoo9te-bM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@tma?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">天一马</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="117f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="3a68" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当我们在Python中处理文件时，最常见的操作可能就是使用内置的<code class="fe mn mo mp mq b">open()</code>函数。这创建了一个文件对象，它允许我们根据需要读写数据。当我们使用<code class="fe mn mo mp mq b">open()</code>函数时，我们几乎总是将该函数与<code class="fe mn mo mp mq b">with</code>语句一起使用，因为我们要么从<a class="ae ky" href="https://docs.python.org/3/library/functions.html#open" rel="noopener ugc nofollow" target="_blank">官方参考</a>的open函数中，要么从一些在线教程中学到了它的用法。基本形式如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">写文件</p></figure><p id="f211" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">通过运行上面的代码，您会看到在您当前的工作目录中已经创建了一个名为<code class="fe mn mo mp mq b">hello.txt</code>的文件。为了验证<code class="fe mn mo mp mq b">Hello World!</code>字符串已经被写入文件，我们可以打开文件来读取数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">读取文件</p></figure><p id="43a5" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">正如您在上面看到的，我们能够读取文件，通过指定读取模式使用<code class="fe mn mo mp mq b">open()</code>函数打开它(<code class="fe mn mo mp mq b">r</code>，与我们之前用于写入目的的<code class="fe mn mo mp mq b">w</code>相反)。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="b894" class="kz la it bd lb lc nf le lf lg ng li lj jz nh ka ll kc ni kd ln kf nj kg lp lq bi translated">自动关闭文件</h1><p id="26d0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们中的许多人可能知道当我们在这里打开一个文件时为什么要使用<code class="fe mn mo mp mq b">with</code>语句。对于不了解的人，请先看看下面这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">关闭的文件</p></figure><p id="200a" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">在上面的代码中，我们通过向文件追加额外的字符串来修改文件(注意，我们使用<code class="fe mn mo mp mq b">a</code>模式进行追加)。当我们完成了<code class="fe mn mo mp mq b">with</code>语句时，我们发现文件被关闭了，尽管我们没有显式地调用file对象上的<code class="fe mn mo mp mq b">close()</code>方法。这正是<code class="fe mn mo mp mq b">with</code>语句为我们做的——当我们退出<code class="fe mn mo mp mq b">with</code>语句时，它自动关闭文件。</p><p id="3c60" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">但你可能想知道为什么这是一件大事，它为我们关闭文件。考虑下面这个微不足道的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无法关闭文件的问题</p></figure><p id="1f3c" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">如图所示，我们首先通过添加一些新数据来修改文件。但是后来我们忘了在这个操作之后关闭文件。当我们再次读取该文件时，我们看不到我们认为已经做出的更改，这可能会导致我们的代码中出现意外的错误。如前所述，如果我们使用了with语句，Python将清除所有文件操作，自动为我们关闭文件。更重要的是，想象一下我们可以对文件进行更复杂的操作，一些操作可能涉及到异常，使程序停止运行。在这些可能的场景中，由于使用了<code class="fe mn mo mp mq b">with</code>语句，文件仍然有机会被安全地自动关闭。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="46a2" class="kz la it bd lb lc nf le lf lg ng li lj jz nh ka ll kc ni kd ln kf nj kg lp lq bi translated">上下文管理器</h1><p id="f547" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">从更广泛的意义上来说，用于文件打开的<code class="fe mn mo mp mq b">with</code>语句是使用上下文管理器的一个例子。</p><p id="5d59" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">什么是上下文管理器？它是一个Python对象，当您使用特定资源时，它会为您做家务。具体来说，上下文管理器<em class="nk">为你建立一个临时上下文，并在所有操作完成后析构该上下文。</em></p><p id="a74f" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">在文件打开操作方面，上下文管理器做什么可以用<code class="fe mn mo mp mq b">try</code> <em class="nk">、</em> <code class="fe mn mo mp mq b">except</code> <em class="nk">、</em>、<em class="nk"> </em> <code class="fe mn mo mp mq b">finally</code>语句来演示。考虑下面的伪代码作为<code class="fe mn mo mp mq b">with</code>语句的可能实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">try…except…finally语句</p></figure><p id="b864" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">如上所示，上下文管理器为您打开文件并创建一个文件对象，它将被进一步操作。当我们完成操作以及操作过程中出现的任何异常时，上下文管理器将为我们关闭文件。如上所示，因为文件是共享资源，这是您的责任(当然，在上下文管理器的帮助下使事情变得更容易)，所以当您完成操作时释放它们以便其他进程可以访问它们是很关键的。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="1e02" class="kz la it bd lb lc nf le lf lg ng li lj jz nh ka ll kc ni kd ln kf nj kg lp lq bi translated">线程管理的使用</h1><p id="9e7e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如前所述，当我们需要处理共享的东西时，最好使用<code class="fe mn mo mp mq b">with</code>语句。其中一种用途是在多线程项目中处理数据。您可能知道，当多线程访问同一个数据池时，事情会变得很混乱。类似我展示的数据附加文件操作的情况会更容易发生。一个操作是追加数据，而另一个操作是在另一个文件操作中读取旧数据。</p><p id="43e2" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">例如，一个线程试图向字典添加数据，而另一个线程试图迭代字典。很快一切都会脱离你的控制。为了解决这个问题，我们可以使用线程锁来帮助我们减少数据混乱。重要的是，因为我们希望以临时的方式完全控制资源，所以这是带有语句的<em class="nk">的最佳用例。让我们考虑下面的代码作为一个简单的例子。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="6aa0" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">如您所见，使用<code class="fe mn mo mp mq b">with</code>语句可以极大地提高代码的简洁性。更重要的是，它会在<code class="fe mn mo mp mq b">with</code>语句中操作完成时自动释放锁。如果不使用上下文管理器(即with语句)，我们将不得不小心地手动管理这些资源。如果我们忘记释放锁，我们的程序将会遇到意想不到的问题。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="04ea" class="kz la it bd lb lc nf le lf lg ng li lj jz nh ka ll kc ni kd ln kf nj kg lp lq bi translated">上下文管理协议</h1><p id="1866" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了自己管理一些资源，我们可以自己创建一个上下文管理器。一种方法是实现上下文管理协议的方法。你可以把它概念化为一个<a class="ae ky" href="https://medium.com/better-programming/what-are-duck-typing-and-monkey-patching-in-python-2f8e3d6b864f" rel="noopener">鸭子打字</a>——我们将简单地定义<code class="fe mn mo mp mq b">__enter__</code>和<code class="fe mn mo mp mq b">__exit__</code>魔法方法，而不像你在其他编程语言中可能做的那样正式地符合协议或实现接口。以下代码向您展示了我们如何做到这一点的概念证明:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0b35" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">如上所示，我们简单地定义了一个类，它实现了<code class="fe mn mo mp mq b">__enter__</code>和<code class="fe mn mo mp mq b">__exit__</code>方法，这将使这个类的实例能够为我们管理上下文。从语法角度来看，我们可以在带有语句的<em class="nk">中使用这个类，如第12行所示。打印文本清晰地向我们展示了这些操作是如何很好地协调的。具体来说，创建的实例(如第15行所示)将调用<code class="fe mn mo mp mq b">__enter__</code>方法(如第16行所示)来启动上下文，然后我们自己运行操作(如第17行所示)，最后，上下文管理器将通过调用<code class="fe mn mo mp mq b">__exit__</code>方法来退出管理。</em></p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h2 id="3572" class="nl la it bd lb nm nn dn lf no np dp lj ma nq nr ll me ns nt ln mi nu nv lp nw bi translated">contextlib模块</h2><p id="6cfc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您可能会发现，实现特殊的方法<code class="fe mn mo mp mq b">__enter__</code>和<code class="fe mn mo mp mq b">__exit__</code>来创建我们自己的上下文管理器有点乏味。有了标准Python库中的<a class="ae ky" href="https://docs.python.org/3/library/contextlib.html" rel="noopener ugc nofollow" target="_blank"> contextlib模块</a>，上下文管理就容易多了。对整个模块的全面回顾超出了本文的范围，我将只关注模块中创建上下文管理器的特定方法。但是在我们这样做之前，让我们后退一步，先回顾一下decorator，因为decorator技术在这里是相关的。</p><p id="d413" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">装饰器是修改其他功能的行为而不影响其核心功能的功能。换句话说，被修饰的函数会做它应该做的任何事情，但是修饰者给它添加了一些味道。我们可以考虑下面的例子来快速更新装饰概念:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">装饰者的基本形式</p></figure><p id="a6c3" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">对于decorators，您只需要创建一个接受另一个函数作为输入的函数。装饰是在装饰函数中定义的操作。在这种情况下，我们只是简单地在函数调用前后做记录。要使用装饰器，我们只需在装饰器函数名前面加上@符号。可以说，调用修饰函数(第15行)成功地导致了函数调用前后的额外日志记录。</p><p id="909e" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">有了对装饰者的基本理解，让我们看一个使用<code class="fe mn mo mp mq b">contextlib</code>模块来帮助我们管理上下文的例子，代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="fdb7" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">我们使用装饰器函数<code class="fe mn mo mp mq b">contextmanager</code>来装饰<code class="fe mn mo mp mq b">context_manager_example</code>函数。在函数体中，您可能会注意到一些不寻常的东西——<code class="fe mn mo mp mq b">yield</code>关键字。您可能在学习生成器时见过<code class="fe mn mo mp mq b">yield</code>关键字，生成器是一种迭代器，当它们被要求这样做时会呈现元素(称为惰性求值)。在这些用例中，产出意味着生产。你可以在我之前的文章中了解更多关于生成器的知识(这里<a class="ae ky" href="https://medium.com/swlh/generators-in-python-5-things-to-know-c76a1f60427a" rel="noopener">这里</a>那里<a class="ae ky" href="https://medium.com/better-programming/python-7-advanced-features-that-you-may-not-know-about-generators-574a65fd6e45" rel="noopener">那里</a>)。</p><p id="da3e" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">除了产生的意思，让步也可以表示让步，这正是在上下文管理修饰期间发生的。具体来说，一旦上下文管理器(修饰函数<code class="fe mn mo mp mq b">context_manager_example</code>)完成设置，它就会执行，从而允许with语句中的代码运行。操作完成后，它会重新获得控制权。重要的是，Python中的yield在Python中进行了特殊处理，这样我们就可以控制它，它将从它被产生的地方运行。这就是为什么跟在<code class="fe mn mo mp mq b">yield</code>关键字后面的<code class="fe mn mo mp mq b">print</code>函数只在with语句中的操作完成后被调用一次。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="868f" class="kz la it bd lb lc nf le lf lg ng li lj jz nh ka ll kc ni kd ln kf nj kg lp lq bi translated">外卖食品</h1><p id="0cfe" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们通过使用<code class="fe mn mo mp mq b">with</code>语句的文件操作的例子回顾了上下文管理器的概念。我们知道是上下文管理器通过关闭文件来帮助我们做家务。</p><p id="52ee" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">从更广泛的意义上来说，上下文管理器对于管理打算在您的程序或计算机中的其他程序内共享的资源非常有用。上下文管理器帮助我们负责任地管理这些共享资源的获取和释放。我们还回顾了如何覆盖<code class="fe mn mo mp mq b">__enter__</code>和<code class="fe mn mo mp mq b">__exit__</code>方法来创建定制的上下文管理器类。或者，我们可以利用<code class="fe mn mo mp mq b">contextlib</code>模块使用decorators创建上下文管理器。</p><p id="90b6" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">然而，正如你可能注意到的，有些事情我们没有涉及。例如，<code class="fe mn mo mp mq b">__exit__</code>方法的函数签名有其他我们没有实现的参数，比如异常处理。这些参数的全面实施应该是逐案评估的。如果有兴趣，可以参考一些比较现实的例子来学习更高级的知识，比如sqlite3模块中的事务管理。这里有一些快速参考。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="88d4" class="kz la it bd lb lc nf le lf lg ng li lj jz nh ka ll kc ni kd ln kf nj kg lp lq bi translated">参考</h1><ul class=""><li id="f8b9" class="nx ny it lt b lu lv lx ly ma nz me oa mi ob mm oc od oe of bi translated"><a class="ae ky" href="https://docs.python.org/3/library/sqlite3.html#using-the-connection-as-a-context-manager" rel="noopener ugc nofollow" target="_blank">在SQLite数据库操作中使用上下文管理</a></li><li id="9eaa" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated"><a class="ae ky" href="https://docs.python.org/3/library/contextlib.html" rel="noopener ugc nofollow" target="_blank">context lib模块官方文档</a></li><li id="9e3a" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated"><a class="ae ky" href="https://docs.python.org/3/library/threading.html#using-locks-conditions-and-semaphores-in-the-with-statement" rel="noopener ugc nofollow" target="_blank">穿线并锁紧</a></li><li id="0ea0" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated"><a class="ae ky" href="https://www.python.org/dev/peps/pep-0343/" rel="noopener ugc nofollow" target="_blank">PEP 343:【with】语句</a></li></ul></div></div>    
</body>
</html>