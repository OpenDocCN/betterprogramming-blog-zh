<html>
<head>
<title>How Bash Works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Bash如何工作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-bash-works-8424becc12f3?source=collection_archive---------5-----------------------#2020-03-06">https://betterprogramming.pub/how-bash-works-8424becc12f3?source=collection_archive---------5-----------------------#2020-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0111" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解shell脚本如何节省您的时间并减少错误</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a88aae3c1c7bb7439c6966aa44793498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-xpp2KcdlJCcFtpWv5MikQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">摄于<a class="ae ky" href="https://unsplash.com/s/photos/funny-cat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@kimtheris?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Sereja Ris </a>。</p></figure><p id="eb1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我为各种各样的应用程序重构了整个部署设置。这意味着一大堆Docker图像都必须灵活但稳定。一些web应用程序也需要以用户友好的方式重新启动，向具有不同技能水平的开发人员显示有用的错误消息。</p><p id="e6e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工作量很大，但我确实在<a class="ae ky" href="https://www.gnu.org/software/bash/" rel="noopener ugc nofollow" target="_blank"> Bash </a>脚本方面做得更好了。我很适合写这篇文章，因为在这个项目中，我写下了花费我调试时间的每一件奇怪的小事。</p><p id="98d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Bash是如此怪异，以至于一篇中型文章甚至不能容纳所有这些内容。对于每一部分，我都链接了一篇文章或教程来进行更详细的介绍。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="23a4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">你奶奶的编程语言</h1><div class="mu mv gp gr mw mx"><a href="https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">Bash (Unix shell)</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">GNU Bash或简称Bash是Brian Fox为GNU项目免费编写的Unix shell和命令语言…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">en.wikipedia.org</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl ks mx"/></div></div></a></div><p id="3a9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Bash由Brian Fox(这家伙是一个被低估的传奇人物)创建，于1989年发布，作为1976年发布的Bourne Shell的开源替代品。它的名字是英文的缩写。</p><p id="6aa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您习惯于编写几乎任何其他编程语言，Bash(以及一般的shell脚本)可能会非常不直观。语法是不可记忆的，变量是奇怪的，范围是一个狂野的旅程，控制流似乎永远不会做你认为它会做的事情。</p><p id="e8c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与CSS非常相似，当我了解了一些关于它的关键事情时，我不再害怕编写Bash脚本:它如何工作，它真正擅长什么，以及如何让它工作。我也遇到了很多我必须学会的愚蠢的小陷阱。</p><p id="2612" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你掌握了基础知识，Shell脚本是非常有趣的！没有什么比写一个运行first try的恶心的一行程序更让你觉得自己是一个黑客高手了。</p><p id="2e6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:我假设您事先了解一些编程和shell脚本。如果那不是你，<a class="ae ky" href="https://catonmat.net/bash-one-liners-explained-part-one" rel="noopener ugc nofollow" target="_blank">这里有一个开始</a>的好资源。我假设您至少知道如何使用终端和以下命令:<code class="fe nn no np nq b">ls</code>、<code class="fe nn no np nq b">cd</code>、<code class="fe nn no np nq b">pwd</code>、<code class="fe nn no np nq b">cat</code>、<code class="fe nn no np nq b">grep</code>，并且已经编写(或试图编写)了一两个脚本。</p><p id="38e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一句，既然这涉及到Linux和操作系统的东西，我有一个建议给住在这里的人:没关系(甚至鼓励！)如果我说错了请纠正我，只是请你礼貌一点。我确信我会从发表这篇文章中学到一些东西:这是我的目标。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6cde" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">版本</h1><div class="mu mv gp gr mw mx"><a href="https://stackoverflow.com/a/52860837/4718615" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">首选的Bash shebang是什么？</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">使用shebang行来调用适当的解释器不仅仅是为了BASH。你可以用它做任何…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">stackoverflow.com</p></div></div><div class="ng l"><div class="nr l ni nj nk ng nl ks mx"/></div></div></a></div><p id="f309" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今我们大多数人编写的shell脚本语言是Bash Mac和Linux在<code class="fe nn no np nq b">/bin/bash</code>中用于终端模拟器的版本。</p><p id="a9be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Debian (通过扩展，Ubuntu和Linux Mint)现在为系统使用一种不同的但是大部分兼容的shell脚本语言(<a class="ae ky" href="https://packages.debian.org/sid/dash" rel="noopener ugc nofollow" target="_blank">破折号</a>)。您也可能已经安装了<a class="ae ky" href="https://www.zsh.org/" rel="noopener ugc nofollow" target="_blank"> Zsh </a>作为您的主shell，它与您的相似但不同。</p><p id="9194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于所有这些微小的变化，最好将<code class="fe nn no np nq b">#!/bin/bash</code> <em class="nm"> </em>(或者您想要使用的任何特定的shell脚本语言)放在文件的顶部，以指定shell脚本应该使用它，而不是机器上的任何其他语言。</p><p id="65e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将使它更容易预测。例如，堆栈溢出回答通常会假设您使用的是这个版本。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8097" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">基础知识</h1><p id="0fa4" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">首先我们将复习一些基础知识。</p><p id="f258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">外壳脚本的核心是相互传递数据的文本流。它使用Unix哲学，即做好一件事，将小工具链接成大程序——就像工厂生产线上的小机器。每个工具按顺序输出到下一个。</p><div class="mu mv gp gr mw mx"><a href="https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">Unix哲学的基础</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">“Unix哲学”起源于Ken Thompson早期对如何设计一个小型但功能强大的操作系统的思考</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">homepage.cs.uri.edu</p></div></div></div></a></div><h2 id="a482" class="nx md it bd me ny nz dn mi oa ob dp mm li oc od mo lm oe of mq lq og oh ms oi bi translated">句法</h2><p id="0fd3" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">语法是宽松的，就像在语法不严格的语言中一样:如果你愿意，可以在行尾使用分号，缩进不是什么大问题。</p><p id="d749" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是个陷阱。语法很重要，而且非常具体。此外，Bash语法错误是最糟糕的。</p><p id="de9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正确使用空格和分号<strong class="lb iu">尤为重要</strong>。</p><p id="1270" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些可能会导致令人困惑的错误，比如当你忘记这些<code class="fe nn no np nq b">[]</code>中的空格时的<code class="fe nn no np nq b">"[grep isn’t a valid command"</code>，或者当你忘记这些<code class="fe nn no np nq b">{}</code>中的分号时的<code class="fe nn no np nq b">“Unexpected end of file”</code>。</p><p id="e653" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当声明一个变量时，在变量、等号和值之间加一个空格将意味着完全不同的东西。单引号和双引号之间有一个非常重要的区别。</p><p id="3712" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法错误总是听起来像逻辑错误，这使得发现拼写错误更加困难。</p><h2 id="de5f" class="nx md it bd me ny nz dn mi oa ob dp mm li oc od mo lm oe of mq lq og oh ms oi bi translated">结构</h2><p id="fdca" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">Shell脚本有控制流:if语句，while循环，for循环，case语句等。</p><p id="2bd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不同之处在于条件和范围。然而，因为它更适合单行和一次性脚本，所以不像在其他语言中那样经常使用。</p><p id="7bcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个使用控制流而没有任何<code class="fe nn no np nq b">if</code>语句的一行程序的例子:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="3ad7" class="nx md it nq b gy on oo l op oq">tac ~/error.log \<br/>| grep -m1 -E "Error|Running restart" \<br/>| grep -q "Error" \<br/>&amp;&amp; echo "Found error since last restart"</span></pre><p id="271f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(<code class="fe nn no np nq b">\</code>是行继续符，<code class="fe nn no np nq b">tac</code>类似于<code class="fe nn no np nq b">cat</code>，但向后输出文件。)</p><p id="8430" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它很难看，但是很有效，说明了shell脚本的优点和缺点。</p><p id="6384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Bash有可能非常简短，难以阅读。你可以用几行代码做很多事情，但是当事情发生时，很难找出原因。是福是祸。权力越大，搞砸一切的可能性就越大。</p><h2 id="b1c8" class="nx md it bd me ny nz dn mi oa ob dp mm li oc od mo lm oe of mq lq og oh ms oi bi translated">什么是溪流？什么是命令？</h2><p id="2c6d" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">每个命令都是一个做一件事的程序。例如，Grep搜索事物并返回行。一个查询进去，文件进去，行出来。</p><p id="7809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会想:“是的，很明显，所有的编程都是这样工作的，”但它比这要复杂一点，在这里理解起来特别重要。</p><p id="738f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些输入和输出以<em class="nm">文本流</em>的形式在命令间来回传递。这些溪流从三个地方流入流出:</p><ul class=""><li id="0cf0" class="or os it lb b lc ld lf lg li ot lm ou lq ov lu ow ox oy oz bi translated"><code class="fe nn no np nq b">stdin</code>:标准输入。</li><li id="826f" class="or os it lb b lc pa lf pb li pc lm pd lq pe lu ow ox oy oz bi translated"><code class="fe nn no np nq b">stdout</code>:标准输出。</li><li id="290c" class="or os it lb b lc pa lf pb li pc lm pd lq pe lu ow ox oy oz bi translated"><code class="fe nn no np nq b">stderr</code>:标准误差输出。</li></ul><div class="mu mv gp gr mw mx"><a href="https://catonmat.net/bash-one-liners-explained-part-three" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">Bash一行程序解释，第三部分:所有关于重定向</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">这是Bash一行程序解释系列文章的第三部分。在这一部分，我将教你所有关于…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">catonmat.net</p></div></div><div class="ng l"><div class="pf l ni nj nk ng nl ks mx"/></div></div></a></div><p id="f112" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个“流”,因为行是在命令/函数执行的不同点输出的，而不是像你想的那样都在最后输出。</p><p id="b51c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您使用类似于<code class="fe nn no np nq b">printf</code>和<code class="fe nn no np nq b">echo</code>的命令向<code class="fe nn no np nq b">stdout</code>发送文本。没有经验的shell脚本编写人员可能会认为这些只是用于调试的日志工具，就像Python或JavaScript一样。并非如此。</p><p id="f453" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">流使命令和函数能够串成一条代码流水线。说明这一点的一个好方法是解释函数是如何工作的。</p><h2 id="4ef3" class="nx md it bd me ny nz dn mi oa ob dp mm li oc od mo lm oe of mq lq og oh ms oi bi translated">功能</h2><p id="fbf2" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">我这样定义一个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div></figure><p id="86ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您使用<code class="fe nn no np nq b">$ hello</code>从终端运行它，您将得到:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="b533" class="nx md it nq b gy on oo l op oq">Hello World! <br/>Something <br/>some more stuff to print Something</span></pre><p id="c217" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">echo</code>和<code class="fe nn no np nq b">printf</code>都向<code class="fe nn no np nq b">stdout</code>发送文本流。如果您从像您的终端这样的交互式shell中运行我们的<code class="fe nn no np nq b">hello</code>功能，<code class="fe nn no np nq b">stdout</code>将打印到您的控制台。</p><p id="a575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过输入重定向来改变这一点，并且<em class="nm">将输出发送到一个文件或者作为另一个命令的输入。</em></p><p id="d4d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有点像常规脚本语言函数中的返回值，只不过你可以拥有任意多的返回值，而且它们不会结束函数。</p><p id="a2a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想结束这个函数，有几个命令可以完成。<code class="fe nn no np nq b">exit</code>和<code class="fe nn no np nq b">return</code>命令采用一个数字代码:<code class="fe nn no np nq b">0</code>表示成功，其他表示失败。<code class="fe nn no np nq b">return</code>将退出该功能，而<code class="fe nn no np nq b">exit</code>将退出外壳本身。</p><p id="ef2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">退出代码是无符号整数，这意味着如果您不幸选择256作为失败错误代码，您将度过一个有趣的调试下午。如果出于某种原因，你的脚本需要超过255种不同的失败方式，那么，你就不走运了。</p><h2 id="9cc9" class="nx md it bd me ny nz dn mi oa ob dp mm li oc od mo lm oe of mq lq og oh ms oi bi translated">流重定向</h2><p id="5fd5" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">这些是基本的。</p><div class="mu mv gp gr mw mx"><a href="https://developer.ibm.com/technologies/linux/tutorials/l-lpic1-103-4/" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">学习Linux，101:流、管道和重定向</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">如果你认为流和管道让一个Linux专家听起来像一个水管工，那么你有机会了解它们以及如何…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">developer.ibm.com</p></div></div><div class="ng l"><div class="pi l ni nj nk ng nl ks mx"/></div></div></a></div><ul class=""><li id="55cc" class="or os it lb b lc ld lf lg li ot lm ou lq ov lu ow ox oy oz bi translated"><code class="fe nn no np nq b">|</code>被称为管道，你用它来发送输出给其他命令。比如我们可以试试<code class="fe nn no np nq b">hello | grep 'Hello'</code>。这将把<code class="fe nn no np nq b">hello</code>的所有输出发送到<code class="fe nn no np nq b">grep</code>，后者将返回包含“Hello”的行。我最喜欢的管道的日常用法是<code class="fe nn no np nq b">history | grep ‘command’</code>,当我忘记了我之前输入的确切命令，但我知道它包含了某个单词。</li><li id="850d" class="or os it lb b lc pa lf pb li pc lm pd lq pe lu ow ox oy oz bi translated"><code class="fe nn no np nq b">&gt;</code>右边有一个文件将输出重定向并打印到一个文件而不是控制台。该文件将被<code class="fe nn no np nq b">&gt;</code>完全覆盖。比如<code class="fe nn no np nq b">logging_function &gt; tmp_error.log</code>。如果你喜欢Python，可能用过<code class="fe nn no np nq b">pip freeze &gt; requirements.txt</code>。</li><li id="f351" class="or os it lb b lc pa lf pb li pc lm pd lq pe lu ow ox oy oz bi translated"><code class="fe nn no np nq b">&gt;&gt;</code>类似于<code class="fe nn no np nq b">&gt;</code>,但是追加到一个文件，而不是完全替换其内容。例如，<code class="fe nn no np nq b">logging_function &gt;&gt; error.log</code>。</li><li id="a7f9" class="or os it lb b lc pa lf pb li pc lm pd lq pe lu ow ox oy oz bi translated"><code class="fe nn no np nq b">&lt;</code>是<code class="fe nn no np nq b">&gt;</code>的反义词。它将右边文件的内容发送给左边的命令。试试<code class="fe nn no np nq b">grep foo &lt; foo.txt</code>。</li></ul><p id="96dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">管道平行延伸。例如，以下内容将只运行一秒钟:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="2b0c" class="nx md it nq b gy on oo l op oq">sleep 1 | sleep 1 | sleep 1 | sleep 1 | sleep 1</span></pre><p id="83a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">管道成员不会让队列中的下一个命令等待它们完全完成。他们一边处理一边发送输出。</p><h2 id="c958" class="nx md it bd me ny nz dn mi oa ob dp mm li oc od mo lm oe of mq lq og oh ms oi bi translated">If语句</h2><p id="7a24" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">没有什么比Bash的<code class="fe nn no np nq b">if</code>陈述更能说明“微型工具”了，它实际上是风衣中的五个关键词。</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="b77a" class="nx md it nq b gy on oo l op oq">if <em class="nm">[ &lt;expression&gt; </em>]; then<br/><em class="nm">&lt;commands&gt;</em><br/>fi</span></pre><p id="1da1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意如何用<code class="fe nn no np nq b">fi</code>结束<code class="fe nn no np nq b">if</code>语句？</p><p id="3238" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于case语句也是如此；<code class="fe nn no np nq b">case … esac</code>。当我得知这一点时，我真的希望<code class="fe nn no np nq b">while</code>以<code class="fe nn no np nq b">elihw</code>结束，<code class="fe nn no np nq b">until</code>以<code class="fe nn no np nq b">litnu</code>结束，但不幸的是，这些都以<code class="fe nn no np nq b">done</code>结束。</p><p id="3119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">[</code>是一个命令，<code class="fe nn no np nq b">]</code>是一个参数，告诉它停止接受其他参数。<code class="fe nn no np nq b">Then</code>、<code class="fe nn no np nq b">else</code>、<code class="fe nn no np nq b">elif</code>、<code class="fe nn no np nq b">fi</code>都是关键词。</p><p id="58cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以这个错误为例:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="5e3a" class="nx md it nq b gy on oo l op oq">/bin/sh: 1: [: true: unexpected operator</span></pre><p id="ee68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能认为这个脚本遇到了一个流氓<code class="fe nn no np nq b">[</code>，抛出了一个语法错误。不是这样的！</p><p id="c308" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际发生的是<em class="nm">命令</em> <code class="fe nn no np nq b">[</code>得到了一个意外的参数:<code class="fe nn no np nq b">true</code>。这个错误实际上是因为我使用了<code class="fe nn no np nq b">==</code>而不是<code class="fe nn no np nq b">=</code>，而<code class="fe nn no np nq b">=</code>的计算结果是<code class="fe nn no np nq b">true</code>，因为它使用了一个奇怪版本的<code class="fe nn no np nq b">[</code>命令(这是一个为什么需要那个<code class="fe nn no np nq b">#!/bin/bash</code>的例子)。</p><h2 id="75a2" class="nx md it bd me ny nz dn mi oa ob dp mm li oc od mo lm oe of mq lq og oh ms oi bi translated"><strong class="ak">控制流程</strong></h2><p id="3e5e" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">我更喜欢只在特定情况下使用<code class="fe nn no np nq b">if</code>语句。一般来说，我更喜欢Bash的操作符:<code class="fe nn no np nq b">&amp;&amp;</code>和<code class="fe nn no np nq b">||</code>。</p><p id="1060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你把它们放在一个命令/函数之后，如果它返回0，<code class="fe nn no np nq b">&amp;&amp;</code>将运行它后面的东西，而<code class="fe nn no np nq b">||</code>不会。</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="433f" class="nx md it nq b gy on oo l op oq">$ will_return_0 &amp;&amp; echo "I will print"<br/>$ will_return_0 || echo "I will not print"</span><span id="8706" class="nx md it nq b gy pj oo l op oq">$ will_return_1 || echo "I will print"<br/>$ will_return_1 &amp;&amp; echo "I will not print"</span></pre><p id="6565" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以把它们链起来。运行这两个命令:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="8142" class="nx md it nq b gy on oo l op oq">$ /bin/true &amp;&amp; echo "I will print" || echo "I will not print"<br/>$ /bin/false &amp;&amp; echo "won't print" || echo "will print"</span></pre><p id="b6fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是要小心！顺序很重要，所以你必须先做<code class="fe nn no np nq b">&amp;&amp;</code>然后再做<code class="fe nn no np nq b">||</code>，否则就无法工作。这不会像你期望的那样:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="e95c" class="nx md it nq b gy on oo l op oq">/bin/false || echo "will print" &amp;&amp; echo "won't print"</span></pre><p id="7cfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不习惯阅读shell脚本，那么阅读它们会有点困难，但是它们也不会做任何奇怪的事情。If语句更适用于需要组合在一起的命令序列，在这种情况下，将它们作为一个函数是没有意义的。</p><p id="8425" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我也更喜欢这个命令:<code class="fe nn no np nq b">test</code>。这和没有误导语法的<code class="fe nn no np nq b">[</code>是一样的。不太熟悉的语法(我认为)更好，因为它向读者发出信号，他们可能不明白到底发生了什么。</p><p id="9993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从长远来看，这种选择会导致一些浪费时间的错误假设。这不是常见的最佳实践，只是我的看法。</p><h2 id="76b6" class="nx md it bd me ny nz dn mi oa ob dp mm li oc od mo lm oe of mq lq og oh ms oi bi translated">变量</h2><p id="25f4" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">Bash中的变量是<em class="nm"> wild </em>。它们的工作方式就好像您已经将它们的值放入脚本并运行它。</p><p id="816b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们不是类型化的(像int、string、arrays等),但是act anywhere对它们来说很方便:可以是字符串、命令、数字、几个数字等。如果你的“字符串”中有空格，它们甚至可以扩展成多个关键词。</p><p id="227a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能会导致一些疯狂的错误，这就是为什么你应该<em class="nm">永远不要</em>接受有风险的用户对shell脚本的输入(比如来自互联网)。如果你是一名web开发人员，并且知道<code class="fe nn no np nq b">eval</code>有多危险:每个shell脚本都是一个巨大的<code class="fe nn no np nq b">eval</code>语句。远程代码执行丰富！</p><p id="e358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，尝试在终端中键入以下行:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="2487" class="nx md it nq b gy on oo l op oq">$ MY_VAR="echo stuff"<br/>$ $MY_VAR</span></pre><p id="c4f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该看到它执行命令并向控制台回显“stuff”。这种行为会使更长的脚本充满错误和不可预测。例如，试试这个:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="f68c" class="nx md it nq b gy on oo l op oq">$ HELLO="hello world"<br/>$ test $HELLO = "hello world" &amp;&amp; echo yes</span></pre><p id="ce84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它抛出一个错误，因为Bash是这样读取的:<code class="fe nn no np nq b">test hello world = “hello world”</code>。这就是为什么一个重要的最佳实践是总是将变量放在<strong class="lb iu">双引号</strong>中。像这样:<code class="fe nn no np nq b">test “$HELLO” = “hello world”</code>或者<code class="fe nn no np nq b">[ "$HELLO" = “hello world” ]</code>。</p><p id="6014" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，不把双引号当作字符串分隔符可能会有所帮助。Bash不像其他语言那样对待字符串。引号有点像括号(但不是Bash括号)。那些是子壳)。</p><p id="b9e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Bash中单引号和双引号的区别很重要。大多数情况下，您会想要使用双引号。有什么区别？双引号会扩大变量，单引号从字面上理解。例如:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="ceae" class="nx md it nq b gy on oo l op oq">var=stuff<br/>echo $var<br/>echo "$var"<br/>echo '$var'</span></pre><p id="7d0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出将是:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="8bc7" class="nx md it nq b gy on oo l op oq">stuff<br/>stuff<br/>$var</span></pre><p id="ea70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量的另一个恼人或有用的地方(取决于你如何看待它)是它们从不抱怨未声明。您可以检查某个变量是否已经这样设置:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="b4df" class="nx md it nq b gy on oo l op oq">test <em class="nm">-z</em> <em class="nm">"</em>$empty" &amp;&amp; echo "variable is empty"</span></pre><p id="cd9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还可以在脚本中添加一个设置来公开未设置的变量:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="1b42" class="nx md it nq b gy on oo l op oq">set -o nounset</span></pre><p id="1dd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，变量对整个shell都是可用的，但是这是可以改变的。</p><h2 id="3c0d" class="nx md it bd me ny nz dn mi oa ob dp mm li oc od mo lm oe of mq lq og oh ms oi bi translated">范围</h2><p id="396f" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">理解范围对于最小化bug非常重要。</p><p id="2326" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个未被充分利用的特性是使用<code class="fe nn no np nq b">local</code>和<code class="fe nn no np nq b">readonly</code>变量。<code class="fe nn no np nq b">local</code>会将一个变量限制为一个函数，如果你试图重新设置它的话<code class="fe nn no np nq b">readonly</code>会抛出一个错误。你甚至可以将这些链接在一起，成为局部<code class="fe nn no np nq b">readonly</code>变量，或者全局<code class="fe nn no np nq b">readonly</code>变量。</p><p id="c6d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有全局变量应该是大写的。要使一个变量对整个shell可用，请使用<code class="fe nn no np nq b">export VAR="value"</code>。这里的大写是一种约定，表示变量是全局的<em class="nm">而不是</em>像在其他语言中一样是常量/不可变的。</p><h2 id="fb42" class="nx md it bd me ny nz dn mi oa ob dp mm li oc od mo lm oe of mq lq og oh ms oi bi translated">命令</h2><p id="8587" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">我最不喜欢Bash的一点是必须记住晦涩难懂的小命令。<code class="fe nn no np nq b">Sed</code>？<code class="fe nn no np nq b">Cat</code>？这些是什么意思？名字当然不会告诉我。伙计，页面很难解析，我当然不会记得所有东西应该按什么顺序排列。</p><p id="7f6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为在过去，每个角色都比现在贵得多。认为代码也应该是人类可读的想法也明显不是主流。</p><p id="f866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时候，寻找一个命令到底应该做什么的准确信息就像在一个巨大的图书馆里搜索布满灰尘的档案。图书馆员大多是自鸣得意的人，他们给你旧手册，上面有一句用维多利亚时代的英语写的相关句子。</p><p id="af45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，你偶尔会在Stack Overflow上遇到超级巫师，他们不介意分享他们辛苦获得的知识。向超级巫师呼喊。</p><h2 id="36bc" class="nx md it bd me ny nz dn mi oa ob dp mm li oc od mo lm oe of mq lq og oh ms oi bi translated">特殊变量</h2><p id="90a7" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">有时候，你会遇到奇怪的无意义的变量，比如<code class="fe nn no np nq b">$@</code>和<code class="fe nn no np nq b">$!</code>。你可以阅读它们的列表:</p><div class="mu mv gp gr mw mx"><a href="https://www.gnu.org/software/bash/manual/html_node/Special-Parameters.html" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">特殊参数(Bash参考手册)</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">3.4.2特殊参数shell对几个参数进行了特殊处理。这些参数只能被引用…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">www.gnu.org</p></div></div></div></a></div><p id="1a54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些对编写脚本和一行程序有用的是:<code class="fe nn no np nq b">$-</code>和<code class="fe nn no np nq b">$*</code>。</p><p id="b81b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两者都为命令/函数的运行提供了参数。<code class="fe nn no np nq b">$-</code>为您提供标志(小破折号修饰符)，而<code class="fe nn no np nq b"> $1–9</code>为您提供输入。例如:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="ceb0" class="nx md it nq b gy on oo l op oq">curl -s example.com</span></pre><p id="86cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的修饰符是<code class="fe nn no np nq b">-s</code>，输入是<code class="fe nn no np nq b">example.com</code>。</p><p id="77ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe nn no np nq b">$</code>获取输入关键词时，重要的是这样使用:<code class="fe nn no np nq b">${2}</code>、<code class="fe nn no np nq b">${25}</code>等。Bash不会理解<code class="fe nn no np nq b">$42</code>这种有两位数的东西。你也可以这样做:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="1f2e" class="nx md it nq b gy on oo l op oq">iterator=4<br/>echo ${$iterator}</span></pre><p id="156b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个更好的例子是<code class="fe nn no np nq b">$!!</code>，当它在终端中运行时，会扩展到最后一个命令。当你忘记用sudo运行一个命令时，试试<code class="fe nn no np nq b">sudo $!!</code>。</p><h2 id="cb4b" class="nx md it bd me ny nz dn mi oa ob dp mm li oc od mo lm oe of mq lq og oh ms oi bi translated">副壳和支架</h2><p id="c368" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">如果你看到这个:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="7f15" class="nx md it nq b gy on oo l op oq">while ( something ); do</span></pre><p id="1190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那些括号不是你想的那样。</p><p id="cb03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Bash中的括号实际上产生了<em class="nm">子外壳</em>。这意味着它们是同一个脚本的子流程。它们本质上是子外壳，可以获得父外壳的所有上下文(变量、函数等)，但不能修改父外壳的任何内容。</p><p id="5503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了保持头脑清醒，子shell是(在变量之后)第二重要的关于shell脚本的东西。它们会突然出现在你意想不到的地方，使你的程序更难预测。</p><p id="8d36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，他们做什么？</p><p id="00cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一些例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div></figure><p id="cddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将得到以下输出:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="31e2" class="nx md it nq b gy on oo l op oq">foo<br/>Inside the sub-shell<br/>foo<br/>bar<br/>Back in the main shell now<br/>foo</span></pre><p id="7ba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意变量是如何在子外壳的上下文中改变的，但在子外壳的外部<em class="nm">没有</em>。子壳的另一个优点是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div></figure><p id="9b57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将产生:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="1257" class="nx md it nq b gy on oo l op oq">We start out at root<br/>/home/username<br/>In the subshell<br/>/tmp<br/>Back in the main shell now<br/>/home/username</span></pre><p id="121a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在子外壳中使用<code class="fe nn no np nq b">exit</code>将只退出该子外壳，而不退出父脚本。</p><p id="873c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">括号不是产生子外壳的唯一方法。如果你像使用<code class="fe nn no np nq b">&amp;</code>或<code class="fe nn no np nq b">nohup</code>一样将一个进程放入后台，这些也会进入子外壳。</p><p id="de9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe nn no np nq b">./</code>运行的脚本运行在它们自己的shell中(不是终端的子shell ),而用<code class="fe nn no np nq b">source</code>运行的脚本运行起来就像你直接输入命令一样。</p><p id="063c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能期望<em class="nm">函数</em>在子外壳中运行，但是这些实际上更像是分组命令。</p><p id="39cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让您的函数在每次使用时都在子shell中运行，您实际上必须将整个函数包装在parens中。要让您的函数返回一个特定的退出代码，而不在子shell中运行或退出整个脚本，请使用<code class="fe nn no np nq b">return</code>而不是<code class="fe nn no np nq b">exit</code>。</p><h2 id="35cd" class="nx md it bd me ny nz dn mi oa ob dp mm li oc od mo lm oe of mq lq og oh ms oi bi translated">关注点分离</h2><p id="cede" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">有时你可能需要把你的脚本分成几个文件。<code class="fe nn no np nq b">source</code>就是你怎么做到的。</p><p id="1992" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">parent.sh</code>:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="934f" class="nx md it nq b gy on oo l op oq">!#/bin/bash<br/>source /path/to/script.sh</span></pre><p id="e193" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这基本上就好像你已经将<code class="fe nn no np nq b">script.sh</code>的全部内容输入到了<code class="fe nn no np nq b">parent.sh</code>中——所以，这有点像如果这不是Bash的话你会怎么想。但是要小心！如果您在父shell中设置了一个变量，内部脚本将可以访问它。</p><p id="669c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像使用库一样使用这个方法是一个更好的主意:导入可以在父脚本中使用的帮助函数。</p><p id="9642" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当心退出代码和将值传递给主脚本！这不是你想的那样。如果它在子shell之外，源文件中的<code class="fe nn no np nq b">exit</code>将不会退出内部脚本:它将退出整个脚本！</p><h2 id="a67e" class="nx md it bd me ny nz dn mi oa ob dp mm li oc od mo lm oe of mq lq og oh ms oi bi translated">错误处理</h2><p id="563a" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">我喜欢将分组的命令打包成一个函数，然后通过执行以下操作来处理失败的情况:</p><pre class="kj kk kl km gt oj nq ok ol aw om bi"><span id="2aac" class="nx md it nq b gy on oo l op oq">my_function || handle_error</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2cfb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="7446" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">感谢一路读到最后！</p><p id="9510" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有很多要写的，但这实际上是一篇中型文章的最大长度，所以请继续关注第2部分。</p></div></div>    
</body>
</html>