<html>
<head>
<title>I Built a Corona Virus App to Visualize Real-World Virus Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我构建了一个电晕病毒应用程序来可视化真实世界的病毒数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/coronavirus-app-working-with-real-world-data-175794f7f594?source=collection_archive---------17-----------------------#2020-02-13">https://betterprogramming.pub/coronavirus-app-working-with-real-world-data-175794f7f594?source=collection_archive---------17-----------------------#2020-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="408e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">虽然潜在的疫情的可能性很可怕，但我还是查看了数据，以了解实际情况</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/caac211a7b5af6f7a42bd319ad296a71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRDd4TPaVxePs3oMbYTK-w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://en.m.wikipedia.org/wiki/File:3D_medical_animation_corona_virus.jpg" rel="noopener ugc nofollow" target="_blank">https://en . m . Wikipedia . org/wiki/File:3D _ medical _ animation _ corona _ virus . jpg</a></p></figure><p id="f524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">世界被新的疫情威胁的可能性吓坏了。每一个主要的媒体都在集中报道情况有多糟糕。我决定看看数据，看看实际情况是怎样的。</p><p id="46f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我用Ruby on Rails为后端构建了一个应用程序，React为前端构建了一个应用程序来查看数据并与世界共享。该应用程序已经在<a class="ae ky" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank"> Heroku </a>和<a class="ae ky" href="https://www.netlify.com/" rel="noopener ugc nofollow" target="_blank"> Netlify </a>上运行；你可以通过这个链接查看<a class="ae ky" href="https://ecstatic-euler-32ae42.netlify.com" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="8cb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我构建应用程序的步骤。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ac48" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据源</h1><p id="35a2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于数据源，我使用了<a class="ae ky" href="https://www.kaggle.com/sudalairajkumar/novel-corona-virus-2019-dataset" rel="noopener ugc nofollow" target="_blank"> Kaggle数据集</a>。该数据集定期更新，因此我们可以看到最新的数据。</p><p id="73db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kaggle在。csv格式。最初，我下载了这个文件，并从中植入了数据库。我使用Rails“CSV”gem的内置功能来解析文件中的数据。</p><p id="7b35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解析之后，我得到了一个数组的数组，其中每个数组都代表。csv文件:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="18f9" class="ne md it na b gy nf ng l nh ni">parsed_data = CSV.parse(data_source)</span></pre><p id="4c3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个过程中，我意识到手动下载东西不是英雄之路，我开始直接和Kaggle API沟通。唯一的问题是Kaggle的所有API文档都是针对Python的。</p><p id="4813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我别无选择，只能用Ruby编写一个自定义方法来授权用户并从API获取数据。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7039" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">清理和分类数据</h1><p id="e2d6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我用<a class="ae ky" href="https://rubygems.org/gems/down/versions/1.1.0" rel="noopener ugc nofollow" target="_blank">down</a>gem下载数据。它返回给你一个大字符串，然后你可以使用上面描述的“CSV”gem把它解析成数组的数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d7c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">清理前的数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/a800a109273cb8de96df1d63f0028130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zGLclct_88vIOrniGrt_Zw.png"/></div></div></figure><p id="2f96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">清理后的数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c94e1c2f497aecd60f90d54131f928d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*GoGbUeuB2gMMqc04Lz7Ctg.png"/></div></figure><p id="fe99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是按照最后更新日期对数据进行排序，并提取最新的数据。</p><p id="cded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的第一种方法是按照“最后更新”列对数据进行排序。但是后来我意识到按“序列号”列排序要简单得多，因为每次向表中添加更新时，都会创建一个具有唯一编号的新行。</p><p id="5406" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现按“序列号”列排序，然后反转数组是一种将新鲜数据放在数组开头的方法。</p><p id="d3ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一种排序方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4499" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">数据库</strong></h1><p id="0540" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当数据被清理并准备好时，就该填充数据库了。</p><p id="0e50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的数据库中的关系非常简单，比如“国家<code class="fe nn no np na b">has_many</code>省份”每个省都有地理编码栏和确诊病例、死亡病例和恢复病例的数字。</p><p id="91e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该模式如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/f03ce8dbe3a6324743a78a393da08a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cpMwv7gDrwkq-DTLLcEUMA.png"/></div></div></figure><p id="313d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在插入数据的同时，我们还需要做一些清理工作。</p><p id="7831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在数据集中，中国既代表中国，也代表Mainland China。因此，我们需要将每个Mainland China转换为中国，以确保我们包括中国所有可能的位置，并将其合并在一个实例中。</p><p id="aca7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们知道指数3是国家的名称。要替换名字，我们需要这个条件:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ab19" class="ne md it na b gy nf ng l nh ni">if n[3] == 'Mainland China'<br/>   n[3] = 'China'<br/>end</span></pre><p id="0bde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们需要忽略0.0值和第一行的列描述:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7256" class="ne md it na b gy nf ng l nh ni">if n[3] == 'Country' || n[5] == '0.0'<br/>        nil<br/>else<br/>//continue iteration</span><span id="049b" class="ne md it na b gy nr ng l nh ni">end</span></pre><p id="3361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2020年2月10日上午，数据有了新的进展:载有受感染乘客的钻石公主号邮轮首次被加入数据集。</p><p id="5b9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将其添加到国家列表中，并将国名“其他”替换为船名:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ec28" class="ne md it na b gy nf ng l nh ni">if n[2] == 'Cruise Ship' || n[2] == 'Diamond Princess cruise ship'<br/>   n[3] = n[2]<br/>end</span></pre><p id="e47d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(由于某种原因，数据集中有两条关于同一艘船的不同名称的条目。我的应用程序使用了最近更新的号码。)</p><h2 id="75ac" class="ne md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated"><strong class="ak">在数据库中创建相关实例</strong></h2><p id="512a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，应用程序检查数据库中是否有国家。如果有，应用程序会检查数据库中是否有省份。如果有省份，app就进入下一次迭代。如果没有，应用程序会向Google Maps API发送一个搜索请求。</p><p id="542d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为响应，应用程序接收一个JSON对象。它解析JSON对象以提取位置的经度和纬度。之后，应用程序创建一个省的实例。</p><p id="f270" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果数据库中有一个国家，我们会检查所选的省份是否与该国家的相关省份相匹配。如果是，应用程序将进入下一个迭代。如果不存在匹配，应用程序会以与第一种情况相同的方式创建一个新实例。</p><p id="97e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是完整的播种代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2b92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2020年2月10日上午，我不得不再加一个条件，过滤掉游轮，手动在地图上为它设置坐标:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="df43" class="ne md it na b gy nf ng l nh ni">elsif n[2] == 'Cruise Ship' || n[2] == 'Diamond Princess cruise ship'</span><span id="8207" class="ne md it na b gy nr ng l nh ni">country.provinces.create(title: n[2], last_update: n[4], confirmed: n[5], deaths: n[6], recovered: n[7], latitude: 35.456817, longitude: 139.679733)</span></pre><p id="3b65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个由Rails呈现的JSON示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/2606731b518be386d4d734c79e863756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*1UId0qGX4W0LSV-LeYK2_w.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="918e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">前方E <strong class="ak">和第二</strong></h1><p id="ef92" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了呈现种子数据，我在前端使用React库。为了简化React中的状态管理，我使用了<a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>和钩子。</p><p id="d99f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看它在其中一个组件中是如何工作的。</p><h2 id="e623" class="ne md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated"><strong class="ak">获取数据</strong></h2><p id="5829" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我向后端发送一个GET请求，获取所有国家和相关省份的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="117d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二个<code class="fe nn no np na b">.then</code>里面，在promise <strong class="lb iu"> </strong>已经解析并且JSON对象可用之后，我调用<code class="fe nn no np na b">filterData()</code> <strong class="lb iu"> </strong>函数。此函数汇总了已确认、致命和已恢复病例的总数。</p><p id="6078" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它还根据确诊病例的数量对各国进行了排序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9928" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数完成工作后，应用程序会调度一个redux操作，并将排序后的数据插入Redux存储:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="e9ca" class="ne md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated"><strong class="ak">挂钩</strong></h2><p id="9cc2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">关于使用钩子的例子，让我们看看功能组件<code class="fe nn no np na b">RegionsByRecovered</code>。在这个组件中，我们应该有一个按已恢复案例降序排列的国家列表。</p><p id="9e56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们使用钩子函数<code class="fe nn no np na b">useSelector()</code>从商店中提取数据:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="91f7" class="ne md it na b gy nf ng l nh ni">const data = useSelector(state =&gt; state.countryByRecovered)</span></pre><p id="2af4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数将排序后的对象数组保存在名为<code class="fe nn no np na b">data</code>的变量中。现在，应用程序遍历这个数组来动态呈现DOM。为此，我们使用<code class="fe nn no np na b">map</code>功能:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9382" class="ne md it na b gy nf ng l nh ni">const renderDom = sortCountriesRecovered(data).map((country) =&gt; {<br/>    return &lt;div&gt;{country.country}: {country.recovered}&lt;/div&gt;<br/>  })</span></pre><p id="87b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们在DOM上呈现迭代的结果:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1b2b" class="ne md it na b gy nf ng l nh ni">return (<br/>    &lt;div&gt;<br/>      &lt;div&gt;&lt;p&gt;&lt;b&gt;By country&lt;/b&gt;&lt;/p&gt;&lt;/div&gt;<br/>      &lt;div&gt;&lt;p&gt;{renderDom}&lt;/p&gt;&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  )</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e3ae" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">地图</h1><p id="50ad" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了渲染地图，我使用了“<a class="ae ky" href="https://www.npmjs.com/package/google-map-react" rel="noopener ugc nofollow" target="_blank">Google-maps-react</a>”NPM包，它很容易使用。</p><p id="af36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了渲染地图，我使用了类组件，因为我需要这里的状态用于<code class="fe nn no np na b">InfoWindow</code>组件数据。我想在地图上呈现标记，并且我希望用户能够单击标记并查看特定位置的详细信息。</p><p id="5f7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们在一个导出语句中连接到商店:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ab5e" class="ne md it na b gy nf ng l nh ni">export default connect(mapStateToProps) (MapContainer)</span></pre><p id="f292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为地图将在类组件中呈现，我们将使用<code class="fe nn no np na b">mapStateToProps</code> <strong class="lb iu"> </strong>函数从存储中提取数据:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f77e" class="ne md it na b gy nf ng l nh ni">const mapStateToProps = state =&gt; {<br/>  return {<br/>    countries: state.countries,<br/>  }<br/>}</span></pre><p id="3b91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Google-maps-react提供了一些组件来轻松呈现地图:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1499" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有一张以中国为中心的空地图。下一步是渲染标记。因为我们有很多标记，所以让我们使用<code class="fe nn no np na b">map</code>来遍历数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6990" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们在<code class="fe nn no np na b">Map</code>组件中调用这个函数。对于每次迭代，我们发送关于每个位置细节的数据。此外，我们为每个标记附加了一个事件监听器(<code class="fe nn no np na b">onClick={this.onMarkerClick}</code>)。</p><p id="b132" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户点击标记时，点击触发功能<code class="fe nn no np na b">onMarkerClick</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4a28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数获取关于位置的数据，并将其设置为状态。</p><p id="3ed1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在<code class="fe nn no np na b">Map</code>中，我们呈现了<code class="fe nn no np na b">InfoWindow</code>组件。该组件连接到状态。最初，我们的州是一个空对象，但是当我们填充它时，<code class="fe nn no np na b">InfoWindow</code>出现在地图上。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/14d914846f963977f27b4aedab475f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FFqJ_dPF9P2nZIFx2eTTIA.png"/></div></div></figure><p id="5ae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看这些数据，该应用程序的任何用户现在都可以看到冠状病毒疫情的规模。数据也显示了世界是如何相互联系的。我们住在一个大村子里，没有“其他”人！</p><p id="8411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看<a class="ae ky" href="https://github.com/pavel-ilin/coronavirus-map" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上的源代码，查看<a class="ae ky" href="https://ecstatic-euler-32ae42.netlify.com" rel="noopener ugc nofollow" target="_blank"> live app </a>。感谢阅读！</p></div></div>    
</body>
</html>