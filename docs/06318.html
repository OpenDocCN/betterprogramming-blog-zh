<html>
<head>
<title>Advanced Programming in Kotlin (Part 5)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中的高级编程(第5部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/advanced-programming-in-kotlin-part-5-b674ce9e692f?source=collection_archive---------6-----------------------#2020-09-21">https://betterprogramming.pub/advanced-programming-in-kotlin-part-5-b674ce9e692f?source=collection_archive---------6-----------------------#2020-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8591" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你应该使用的更多Kotlin专属功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/49feaa131b88068a1a3104fe7661de1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*v4LXaVKgUORTM_BP565Q8g.jpeg"/></div></figure><p id="5aae" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">与Java不同，在Java中我们需要编写所有内容，Kotlin编译器理解代码并在幕后编写样板代码。除此之外，简单的语法和修改语言用法的能力使开发人员更有效率。</p><p id="a6e8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你在网上搜索，你会发现Kotlin解决Java的许多棘手问题的许多方法，以及Kotlin的特性如何使开发更有趣。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="310d" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">本系列的收获</h1><p id="49c0" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">这个关于Kotlin编程的系列始终关注如何有效地使用Kotlin的创造性功能，以及如何限制我们过度使用它们，从长远来看，这将导致无法预见的问题。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="21bd" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">1.检查“lateinit”变量是否已初始化</h1><p id="5696" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">在Kotlin中，我们可以使用<code class="fe mq mr ms mt b">var lateinit</code>声明变量，在这种情况下，系统不会给它们分配内存，直到它们至少被初始化一次。这种类型的功能提高了应用程序的性能。</p><p id="8efc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">另一方面，<code class="fe mq mr ms mt b">lateinit</code>变量不能使用Elvis ( <code class="fe mq mr ms mt b">?:</code>)操作符声明，这意味着这些变量不能为空。所以困扰我的问题是如何检查<code class="fe mq mr ms mt b">lateinit</code>变量或者对象初始化状态。事实证明这很简单。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="b3be" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">2.对大数字使用下划线</h1><p id="6997" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">在这个现代时代，如此多的开发人员像我一样从事电子商务应用程序的开发，我们每天都要处理大量的数据，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="288b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">价值很难理解吧？开发金融或股票应用程序的开发人员也将面临这种数字的模糊性。实际上，我们用逗号分隔千位，以便快速理解。同样，Kotlin有一个千位分隔符，但它是一个下划线。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">带分隔符的大数</p></figure></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="0fb6" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">3.<strong class="ak">take if’&amp;【take unless】</strong></h1><p id="9a4d" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">当你通过<code class="fe mq mr ms mt b">filter</code>、<code class="fe mq mr ms mt b">map</code>等扩展函数处理列表时，Kotlin提供了丰富的体验。这些都很棒，但是您知道我们可以在调用链中间使用<code class="fe mq mr ms mt b">takeif</code>和<code class="fe mq mr ms mt b">takeUnless</code>函数后跟<code class="fe mq mr ms mt b">let</code>来执行更多的条件吗？看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">takeif函数用法</p></figure></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="4ac2" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">4.用“also”调试</h1><p id="78f0" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">每个开发人员都有自己调试代码的风格。最近我遇到了一些代码片段，它们使用了<code class="fe mq mr ms mt b">also</code>关键字来调试值。我觉得它很酷，尤其是在我的工作岗位上，我经常处理<code class="fe mq mr ms mt b">sorting</code>、<code class="fe mq mr ms mt b">filter</code>和<code class="fe mq mr ms mt b">groupby</code>功能。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2cf1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们不再需要在执行的每一步都写一个新的块。这将为像我这样更多使用日志而不是断点的开发人员节省大量时间。看一下输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="c49f" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">5.嵌套函数</h1><p id="b578" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">我们可以在另一个函数中编写一个函数，类似于Python中的嵌套函数。嵌套函数的作用域是外部函数，只有外部函数可以包含嵌套函数。内部函数不受函数外部发生的任何事情的影响。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">嵌套函数</p></figure></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="5322" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">6.λ表达式</h1><p id="96cc" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">Lambda是函数的最简单形式，只有一行表达式(大多数情况下)。在Kotlin中，lambda函数用花括号<code class="fe mq mr ms mt b">{}</code>括起来。Lambda函数不像普通函数那样有<code class="fe mq mr ms mt b">fun</code>关键字或任何访问修饰符(public、private和protected)。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">Kotlin中的简单lambda函数</p></figure><p id="a76d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Kotlin中的lambda函数没有返回类型，但我们可以传递参数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">带参数的lambda表达式</p></figure></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="85b9" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">7.“中缀”函数</h1><p id="18de" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated"><code class="fe mq mr ms mt b">infix</code>符号允许我们快速调用单参数函数。为了创建一个<code class="fe mq mr ms mt b">infix</code>函数，需要两个参数。第一个参数是目标对象，而第二个参数是传递给函数的实际参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">Kotlin中的中缀函数</p></figure><p id="ade9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">创建<code class="fe mq mr ms mt b">infix</code>函数就像创建<code class="fe mq mr ms mt b">inline</code>函数一样。语法上唯一的区别是我们使用了<code class="fe mq mr ms mt b">infix</code>关键字而不是<code class="fe mq mr ms mt b">inline</code>。现在让我们看看如何调用<code class="fe mq mr ms mt b">infix</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">调用中缀函数</p></figure><p id="6834" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当我们在正确的地方使用<code class="fe mq mr ms mt b">infix</code>函数时，语法将比常规函数更加透明，可读性更强。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="e505" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">8.一个<em class="na">关联'</em></h1><p id="ae8a" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">Kotlin有大量与集合相关的有用的扩展函数，其中一些有扩展链接，如<code class="fe mq mr ms mt b">To</code>、<code class="fe mq mr ms mt b">With</code>和<code class="fe mq mr ms mt b">By</code>。<code class="fe mq mr ms mt b">associate</code>是集合上的扩展函数，有三个变体:<code class="fe mq mr ms mt b">associate</code>、<code class="fe mq mr ms mt b">associateTo</code>、<code class="fe mq mr ms mt b">associateBy</code>、<code class="fe mq mr ms mt b">associateWith</code>。</p><blockquote class="nb nc nd"><p id="423c" class="kq kr ne ks b kt ku ju kv kw kx jx ky nf la lb lc ng le lf lg nh li lj lk ll im bi translated"><em class="it">"返回一个</em> <a class="ae ni" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/index.html#kotlin.collections.Map" rel="noopener ugc nofollow" target="_blank"> <em class="it">映射</em> </a> <em class="it">，包含由</em> <a class="ae ni" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/associate.html#kotlin.collections$associate(kotlin.Array((kotlin.collections.associate.T)),%20kotlin.Function1((kotlin.collections.associate.T,%20kotlin.Pair((kotlin.collections.associate.K,%20kotlin.collections.associate.V)))))/transform" rel="noopener ugc nofollow" target="_blank"> <em class="it">变换</em> </a> <em class="it">函数提供的应用于给定数组元素的键值对。"— </em> <a class="ae ni" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/associate.html#kotlin.collections$associate(kotlin.Array((kotlin.collections.associate.T)),%20kotlin.Function1((kotlin.collections.associate.T,%20kotlin.Pair((kotlin.collections.associate.K,%20kotlin.collections.associate.V)))))/transform" rel="noopener ugc nofollow" target="_blank"> <em class="it">科特林文档</em> </a></p></blockquote><p id="1ca9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您还记得<code class="fe mq mr ms mt b">Pair</code>吗，在这里我们可以将两个值连接成键-值对。<code class="fe mq mr ms mt b">associate</code>与此类似，但这里我们操作的是<code class="fe mq mr ms mt b">ArrayList</code>中的值，而不是随机值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c0dd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">类似于<code class="fe mq mr ms mt b">associate</code>功能，<code class="fe mq mr ms mt b">associateTo</code>、<code class="fe mq mr ms mt b">associateBy</code>和<code class="fe mq mr ms mt b">associateWith</code>生成不同类型的地图，如上图所示。他们最终可能会做同样的事情，但是在几个用例中，他们都有自己有用的方式。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="720c" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">9.范围职能官方指南</h1><p id="6d98" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">范围和扩展非常复杂，是Kotlin中一些最强大的特性。我在本系列过去的文章中已经谈到了它们。但是几天前，我在droidcon网站上看到了Dmitry Sitnikov关于这些功能的演讲。</p><p id="08d1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在那次演讲中，我看到了关于何时使用哪个作用域函数的详细指南。自从我第一次看到这个列表，它就对我有意义，所以我想在这里与你分享:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/b38ed2f87cb89303e3bd1733e7794ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SKs92b7rp34Lv2CMhREQjg.jpeg"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">德米特里·西特尼科夫在droidcon上的讲话截图</p></figure><p id="1a4d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你读得清楚，这个列表对范围函数的正确使用是有意义的。</p><p id="f068" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">默认情况下，如果我们使用<code class="fe mq mr ms mt b">?</code>操作符，<code class="fe mq mr ms mt b">let</code>会返回一个非空的lambda函数，因此使用它将一个表达式作为一个值引入作用域是有意义的。</p><p id="e41a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">与<code class="fe mq mr ms mt b">let</code>不同，<code class="fe mq mr ms mt b">apply</code>返回一个作用域，我们可以在这个作用域中为它所应用的对象赋值。因此将其用于对象配置是有意义的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">应用用法</p></figure><p id="1c85" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">与<code class="fe mq mr ms mt b">apply</code>类似，<code class="fe mq mr ms mt b">run</code>也返回一个我们可以配置对象的作用域，除此之外，我们还可以执行对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">运行用法</p></figure><p id="56d8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，<code class="fe mq mr ms mt b">with</code>作用域函数被设计成在其上执行多个操作。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">随着使用</p></figure></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="a504" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">提高可读性</h1><p id="dd9f" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">在像Kotlin这样的语言中，我们有很多方法来做同样的事情。两个指标决定了结果:性能和可读性。许多开发人员关注性能，而忽略了可读性部分。</p><p id="cb30" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">随着您的产品的增长，您的团队也在增长，在这种情况下，使您的代码尽可能清晰易读是至关重要的。让我们看一个简单的例子，在这个例子中，我们调用一个类中的函数，该函数返回一个带有两个字段的对象，然后将这些值赋给视图。一种方法如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2f64" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">上面的代码使用了<code class="fe mq mr ms mt b">with</code>来完成这项工作。在实现代码的开发者看来，使用<code class="fe mq mr ms mt b">with</code>并没有错。但是其他队友看到代码的时候，因为不知道<code class="fe mq mr ms mt b">getAvangerTeams</code>的输出是什么，也不知道<code class="fe mq mr ms mt b">first</code>和<code class="fe mq mr ms mt b">second</code>是什么，所以没有意义。</p><p id="071e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了更清楚一点，我们可以使用<code class="fe mq mr ms mt b">let</code>来显式地将输出作为lambda中的参数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">用let简化</p></figure><p id="ba83" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用这种方法，团队的其他成员将清楚地知道将有两个输出，如果我们用适当的名称指定输出，这对他们来说将是有意义的。</p><p id="2192" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这更好，但还不够好。或者，坦率地说:这太Kotlin-y了。我认为没有必要使用lambda函数。我们可以在第一个语句中检索输出，并在下面的步骤中使用它们。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="12b8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">据我所知，它看起来更精确，可读性更好，即使对您团队中的新手来说也是如此。Kotlin拥有最强大的功能来做到这一点，但这并不意味着我们必须使用它们。有时候简单不如深挖。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="c2a9" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">奖金</h1><p id="dbb7" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">要了解更多关于Kotlin的信息，请阅读Kotlin高级编程系列的前几部分:</p><ul class=""><li id="e238" class="no np it ks b kt ku kw kx kz nq ld nr lh ns ll nt nu nv nw bi translated"><a class="ae ni" href="https://medium.com/better-programming/advanced-android-programming-with-kotlin-5e40b1be22bb" rel="noopener">使用Kotlin进行高级编程</a></li><li id="cec1" class="no np it ks b kt nx kw ny kz nz ld oa lh ob ll nt nu nv nw bi translated"><a class="ae ni" href="https://medium.com/android-dev-hacks/advanced-android-programming-with-kotlin-part-2-aae2a15258b0" rel="noopener">使用Kotlin进行高级编程(第二部分</a></li><li id="8cfc" class="no np it ks b kt nx kw ny kz nz ld oa lh ob ll nt nu nv nw bi translated"><a class="ae ni" href="https://medium.com/better-programming/advanced-programming-in-kotlin-2e01fbc39134" rel="noopener">使用Kotlin进行高级编程(第三部分</a></li><li id="8056" class="no np it ks b kt nx kw ny kz nz ld oa lh ob ll nt nu nv nw bi translated"><a class="ae ni" href="https://medium.com/better-programming/advanced-android-programing-in-kotlin-part-4-187b88fea048" rel="noopener">用Kotlin高级编程(第四部分</a></li></ul><p id="6941" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">要了解更多关于Kotlin协同例程和Kotlin的其他高级特性，请阅读以下文章:</p><ul class=""><li id="7ae8" class="no np it ks b kt ku kw kx kz nq ld nr lh ns ll nt nu nv nw bi translated"><a class="ae ni" href="https://medium.com/better-programming/kotlin-coroutines-from-basics-to-advanced-ad3eb1421006" rel="noopener">科特林协程，从基础到高级</a></li><li id="09cc" class="no np it ks b kt nx kw ny kz nz ld oa lh ob ll nt nu nv nw bi translated"><a class="ae ni" href="https://medium.com/better-programming/how-to-use-kotlin-sealed-classes-for-state-management-c1cfb81abc6a" rel="noopener">如何使用Kotlin密封类进行状态管理</a></li><li id="6e60" class="no np it ks b kt nx kw ny kz nz ld oa lh ob ll nt nu nv nw bi translated"><a class="ae ni" href="https://medium.com/better-programming/asynchronous-data-loading-with-new-kotlin-flow-233f85ae1d8b" rel="noopener">新Kotlin流的异步数据加载</a></li><li id="abe2" class="no np it ks b kt nx kw ny kz nz ld oa lh ob ll nt nu nv nw bi translated"><a class="ae ni" href="https://medium.com/better-programming/exploring-collections-and-sequences-in-kotlin-3a324ea08fb9" rel="noopener">探索Kotlin中的集合和序列</a></li><li id="935e" class="no np it ks b kt nx kw ny kz nz ld oa lh ob ll nt nu nv nw bi translated"><a class="ae ni" href="https://medium.com/better-programming/why-and-how-to-use-kotlins-native-serialization-library-c88c0f14f93d" rel="noopener">为什么以及如何使用Kotlin的原生序列化库</a></li><li id="fe54" class="no np it ks b kt nx kw ny kz nz ld oa lh ob ll nt nu nv nw bi translated"><a class="ae ni" href="https://medium.com/@sgkantamani/learn-how-to-combine-kotlin-flows-317849a71d3e" rel="noopener">了解如何组合Kotlin流</a></li></ul></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><p id="7086" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">目前就这些。我希望你学到了有用的东西——感谢阅读！</p></div></div>    
</body>
</html>