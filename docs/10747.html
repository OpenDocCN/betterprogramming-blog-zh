<html>
<head>
<title>Mastering TypeScript Enums</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握类型脚本枚举</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mastering-typescript-enums-e4fbd1c9dcdf?source=collection_archive---------12-----------------------#2022-01-25">https://betterprogramming.pub/mastering-typescript-enums-e4fbd1c9dcdf?source=collection_archive---------12-----------------------#2022-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a2fe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看一下TypeScript的基本特性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/578bf371fa9633305d3f8b73a920b0e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvPrJJNp6RTqDA8bZs-9TQ.png"/></div></div></figure><p id="043e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TypeScript枚举功能几乎从一开始就可用。这是大多数编程语言中常见的特性。然而，它在JavaScript中是缺乏的。是的，这里有一些模拟枚举的方法:</p><ul class=""><li id="bbb2" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">通过使用类</li><li id="fa57" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">通过使用符号</li><li id="432e" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">通过简单地使用键值对象</li></ul><p id="0162" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这些解决方案远非理想。它们降低了代码的可读性，并增加了一些开销。这是为数不多的TypeScript不仅仅是JavaScript的类型包装器的特性之一。</p><p id="2ca7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">枚举应该用在哪里？当一个变量只能有一小组可能的值时，这是一个非常适合的特性。通过使用枚举，我们得到了一个更友好的声明性名称，而不是必须在整个代码库中传播一个神奇的数字。</p><p id="6f98" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我看来，仅这个特性就足以证明将TypeScript作为项目技术堆栈的一部分是正确的。它将增加正确性，减少应用程序样板。</p><p id="788d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们将深入探讨enums特性以及如何最好地使用它们。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="b874" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">为什么我们需要枚举？</h1><p id="dedc" class="pw-post-body-paragraph ku kv it kw b kx nd ju kz la ne jx lc ld nf lf lg lh ng lj lk ll nh ln lo lp im bi translated">枚举的替代方法是使用联合。其中的陷阱是什么？如果值改变了，我们就必须改变代码中的每一处。</p><p id="f392" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">许多人反对枚举，因为这些常量值不可能改变。然而，如果他们真的这么做了，我们将不得不做一些手工工作，这一点也不酷。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8ab3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看枚举是如何用更简洁易读的语法解决这个问题的。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="49c3" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">类型脚本枚举基础</h1><p id="3517" class="pw-post-body-paragraph ku kv it kw b kx nd ju kz la ne jx lc ld nf lf lg lh ng lj lk ll nh ln lo lp im bi translated">它的语法非常简单。我们只需要使用关键字<code class="fe nk nl nm nn b">enum</code>并定义它可能的键和值。</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="e654" class="ns mm it nn b gy nt nu l nv nw"><strong class="nn iu">enum</strong> Status {<br/>  Success,<br/>  Failure<br/>}</span></pre><p id="5f65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们不为枚举指定任何值，Typescript将默认创建一个<code class="fe nk nl nm nn b">Numeric Enum</code>。它将为每个枚举键分配一个正的增量索引值。当我们希望每个属性有不同的值，而我们不关心这些值是什么时，这是很有用的。</p><p id="425b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一些例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="2cac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们在乎价值，我们可以定制它。在数字枚举中，没有关联值的键将继承增量行为。</p><p id="4084" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看另一个例子，我们只定制了一个值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="3bc7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，如果我们在一个属性上使用一个非数值，我们必须初始化所有其他的枚举键。为什么？因为它不再是一个数字枚举，TypeScript不知道将哪个值赋给其余的属性。</p><p id="01d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是以下代码失败的原因:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="699f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解决这个问题的方法是为每个条目添加一个值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e3dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以在枚举中组合多个值类型吗？是的，尽管它有一个奇怪的用例。没有正当的理由是不应该使用的。</p><p id="cb9f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下面的代码中，我们看到了如何混合字符串和数字:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="dd21" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">环境枚举</h1><p id="4886" class="pw-post-body-paragraph ku kv it kw b kx nd ju kz la ne jx lc ld nf lf lg lh ng lj lk ll nh ln lo lp im bi translated">TypeScript枚举支持环境功能声明。这意味着我们可以描述一个已经存在的枚举的形状。不会从该枚举生成JavaScript代码。</p><p id="1091" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们如何做到这一点？只要使用<code class="fe nk nl nm nn b">declare</code>关键词。</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="8c93" class="ns mm it nn b gy nt nu l nv nw">// ✅ ambient enum<br/><strong class="nn iu">declare</strong> enum Status {<br/>  Success,<br/>  Failure<br/>}</span><span id="ac9c" class="ns mm it nn b gy nx nu l nv nw">// ❌ will fail if enum is non existing<br/>console.log(Status.Failure);</span></pre><p id="2b36" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">⚠️:上面的代码看起来和以前的一些代码一模一样。行为大相径庭。它只是为现有的枚举创建类型。初始化它的值不会有任何效果。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="8175" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">计算枚举与常量枚举</h1><p id="2307" class="pw-post-body-paragraph ku kv it kw b kx nd ju kz la ne jx lc ld nf lf lg lh ng lj lk ll nh ln lo lp im bi translated">计算枚举是具有一些在运行时解析的值或从另一个值派生的值的枚举。有一个限制，它们只能建立在<code class="fe nk nl nm nn b">Numeric Enums</code>之上。这意味着返回值必须总是一个数字。</p><p id="3a5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="89e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码中，我们看到<code class="fe nk nl nm nn b">Success</code>和<code class="fe nk nl nm nn b">Failure</code>的值是在运行时决定的，而不是在编译时。</p><p id="185a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们要返回一个字符串，我们将得到以下错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="a832" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">⚠️:把常量值加到我们计算的枚举中是好的。只要是数字，就可以混合使用。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="90fb" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">收集</h1><p id="769a" class="pw-post-body-paragraph ku kv it kw b kx nd ju kz la ne jx lc ld nf lf lg lh ng lj lk ll nh ln lo lp im bi translated">基本的非环境枚举发出一些JavaScript代码。</p><p id="5346" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们检查一个枚举:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="d0e2" class="ns mm it nn b gy nt nu l nv nw">// ✅ works even though value types are different<strong class="nn iu"><br/>enum</strong> Status {<br/>  <strong class="nn iu">Success = 'success',<br/>  Failure = 1</strong><br/>}</span></pre><p id="ad8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编译TypeScript时，上面的代码片段将生成以下JavaScript代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/6ff34eaa658f3a038c5541aa9d0781a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*A05m4FgwT4vagbbTEp2B6w.png"/></div><p class="nz oa gj gh gi ob oc bd b be z dk translated">作者的说明</p></figure><p id="45e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于上面的枚举有一个对应的JavaScript，我们不能使用<code class="fe nk nl nm nn b">type</code>修饰符。该修饰符仅在导入TypeScript类型时保留。它向Typescript编译器提示，这些导入是特定于类型的，可以从JS输出中移除。</p><p id="00cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以下面的代码会失败:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="5a25" class="ns mm it nn b gy nt nu l nv nw">// ❌ fails, it is not purely a type<br/>import <strong class="nn iu">type</strong> { Status } from './utils';</span></pre><p id="8952" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们应该做的是:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="b304" class="ns mm it nn b gy nt nu l nv nw">// ✅ works<br/>import { Status } from './utils';</span></pre><p id="9e3b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果没有JavaScript代码，我们就不能在JavaScript代码中使用枚举中的值。但是，是不是所有的枚举都会生成一些JavaScript代码？不，常量不会产生任何开销。这使得它们很轻便，是使用枚举时的首选。</p><p id="9cf3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面就来了解一下那些。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="0b28" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">常数枚举</h1><p id="d83a" class="pw-post-body-paragraph ku kv it kw b kx nd ju kz la ne jx lc ld nf lf lg lh ng lj lk ll nh ln lo lp im bi translated">常规枚举工作得非常好。然而，如前所述，它们会产生少量额外的JavaScript成本。这不是我们可能不高兴的事情，TypeScript并不意味着向我们的包中添加代码。这个有解决办法吗？</p><p id="c772" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">是的，我们可以制作我们的清单<code class="fe nk nl nm nn b">const</code>。常量枚举不会输出任何JavaScript代码。我们能一直用这些吗？是的，但前提是我们用常量初始化枚举。这意味着我们将无法组合计算值和常量。</p><p id="a53a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于这些枚举没有添加任何额外的JavaScript代码，它们的值在编译时会发生什么？这些将被内联到我们编译的代码的输出中。</p><p id="320b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们用一些例子来看看它们的区别。</p><p id="3f37" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用常规枚举:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/c8478f98bcfcc70f138249b33bf6add6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F0lrBQXICTMF_knRgY1Rsw.png"/></div></div><p class="nz oa gj gh gi ob oc bd b be z dk translated">非常数枚举</p></figure><p id="af51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用常量枚举:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/dffd57b21cda25f1fe96c80ceb1aad22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Infhchzs0z7Z3EHdIx3I7Q.png"/></div></div><p class="nz oa gj gh gi ob oc bd b be z dk translated">常量枚举</p></figure><p id="9671" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意<code class="fe nk nl nm nn b">Status.Failure</code>值是如何被内联的<code class="fe nk nl nm nn b">0</code>并且添加了注释<code class="fe nk nl nm nn b">/* Success */</code>。由于我们的代码不生成任何JavaScript，我们可以利用<code class="fe nk nl nm nn b">type</code> TypeScript语法导入:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="c1aa" class="ns mm it nn b gy nt nu l nv nw">// ✅ works with const enums<br/>import <strong class="nn iu">type</strong> { Status } from './utils';</span></pre><p id="5aa6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">⚠️:通过使用<code class="fe nk nl nm nn b">const</code>,我们将运送更少的JavaScript代码，从而减少开销。然而，有一些陷阱要记住。使用<code class="fe nk nl nm nn b">ambient const enums</code>和消费/发布某些<code class="fe nk nl nm nn b">.d.ts</code>文件时会出现一些问题。为什么？正是因为枚举信息在编译时被移除。随着<code class="fe nk nl nm nn b">preseConstEnums</code>的修复:枚举信息将被保存在源代码中，并在运行时被删除。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="4dc4" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">枚举成员类型</h1><p id="9eaf" class="pw-post-body-paragraph ku kv it kw b kx nd ju kz la ne jx lc ld nf lf lg lh ng lj lk ll nh ln lo lp im bi translated">最后一个很酷的提示。枚举被用作类型，但是我们也可以将它们的枚举成员用作类型。请注意，并非所有枚举成员都可以充当类型。只有符合以下标准之一的人:</p><ul class=""><li id="6aaf" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">值是一个字符串</li><li id="b85d" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">值是数字</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ab5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意在上面的代码中，<code class="fe nk nl nm nn b">type</code>键将只取一个<code class="fe nk nl nm nn b">Status.Success</code>值。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="3bc9" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">包裹</h1><p id="28cc" class="pw-post-body-paragraph ku kv it kw b kx nd ju kz la ne jx lc ld nf lf lg lh ng lj lk ll nh ln lo lp im bi translated">我们已经深入研究了TypeScript枚举特性。我们现在可以理解在哪里以及如何使用它们。我们已经看到了使用数值型、计算型、常量型、环境型枚举的注意事项和奇怪之处。</p><p id="4a86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们知道它们权衡是什么，以及它们将如何影响我们的JavaScript生成的代码。它们提供了大量的清晰度，并提高了代码的可读性。这是一个有效的记忆功能，在进行工会歧视时非常有用。</p><p id="54ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据经验，常量应该是我们的第一个赌注。然而，挑战是不要滥用这个特性，只在正确的地方使用它。有时使用<code class="fe nk nl nm nn b">as const</code>功能可能就好了。</p><p id="d64f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="of">如果你喜欢你读到的，看看下面这个故事:</em></p><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/7-typescript-common-mistakes-to-avoid-581c30e514d6"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">要避免的7个打字稿常见错误</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">通过避免这些错误来改进您的TypeScript的代码库</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">better编程. pub</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ks oj"/></div></div></a></div></div></div>    
</body>
</html>