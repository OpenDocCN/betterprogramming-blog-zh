<html>
<head>
<title>Distributed Tracing in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust中的分布式跟踪</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/distributed-tracing-in-rust-b8eb2af3aff4?source=collection_archive---------15-----------------------#2022-09-12">https://betterprogramming.pub/distributed-tracing-in-rust-b8eb2af3aff4?source=collection_archive---------15-----------------------#2022-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ed7d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何用actix，rabbitmq (lapin)，tracing，opentelemetry实现多个服务之间的分布式跟踪。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6d9a8dc020bf800e93f311429cf5411b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*voQkdWTcHw2yIOJiYX_vXQ.png"/></div></div></figure><p id="1d5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是Rust中分布式跟踪的另一个例子。我在网上看到了多篇文章，但遗憾的是，没有一篇给我必要的提示，让分布式跟踪在我的环境中工作。</p><p id="1b77" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我想要实现的是获得一个完整的跟踪，从API请求到数据库，跨越通过AMQP通信的多个服务。</p><p id="a9bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文将指导您完成检测应用程序所需的每个步骤。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="55cc" class="ls lt iq lo b gy lu lv l lw lx"><strong class="lo ir">Table of Contents</strong></span><span id="bbbe" class="ls lt iq lo b gy ly lv l lw lx"><strong class="lo ir">- </strong><a class="ae lz" href="#644e" rel="noopener ugc nofollow">Instrumenting your application</a><br/>- <a class="ae lz" href="#1275" rel="noopener ugc nofollow">Propagating context</a><br/>- <a class="ae lz" href="#4415" rel="noopener ugc nofollow">Testing with Zipkin</a><br/>- <a class="ae lz" href="#2a84" rel="noopener ugc nofollow">Wrapping up</a></span></pre></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="644e" class="mh lt iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">检测您的应用程序</h1><p id="3cf1" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">首先，我们需要添加必要的依赖项来生成<a class="ae lz" href="https://opentelemetry.io/" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry </a>跟踪。我们需要:</p><ul class=""><li id="2f29" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm ni nj nk nl bi translated"><a class="ae lz" href="https://crates.io/crates/opentelemetry" rel="noopener ugc nofollow" target="_blank">open telemetry</a>:Rust open telemetry实现</li><li id="8450" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated"><a class="ae lz" href="https://crates.io/crates/tokio" rel="noopener ugc nofollow" target="_blank">tokio</a>:Rust的异步运行时</li><li id="6802" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated"><a class="ae lz" href="https://crates.io/crates/tracing" rel="noopener ugc nofollow" target="_blank">追踪</a>:应用级追踪铁锈</li><li id="c8e3" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated"><a class="ae lz" href="https://crates.io/crates/tracing-opentelemetry" rel="noopener ugc nofollow" target="_blank">跟踪-打开遥测</a>:打开遥测集成进行跟踪</li><li id="e7a6" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated"><a class="ae lz" href="https://crates.io/crates/tracing-subscriber" rel="noopener ugc nofollow" target="_blank">跟踪订户</a>:用于实现和组成“跟踪”订户的实用程序</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">添加必要的依赖项</p></figure><p id="ee97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们创建一个负责初始化订户及其不同层的函数。</p><p id="55b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">订户负责记录<code class="fe nx ny nz lo b">span</code>和<code class="fe nx ny nz lo b">events</code>。层是应用于跨度和事件的一种扩展。</p><p id="bd84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面我们初始化</p><ul class=""><li id="0ca8" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm ni nj nk nl bi translated">OpenTelemetry兼容的tracer，以Otel格式记录量程和轨迹。</li><li id="b1c3" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated">生成JSON格式跟踪的订户</li><li id="d05b" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated">基于提供的级别(跟踪、调试、信息、警告、错误)过滤跟踪的<code class="fe nx ny nz lo b">EnvFilter</code>层</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ce5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦完成，我们需要在每个异步函数上添加<code class="fe nx ny nz lo b">tracing::instrument</code>宏，以生成一个具有跨度的仪器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7386" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">把它插在一起，我们就有了这样的东西:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="1275" class="mh lt iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">传播语境</h1><p id="89c3" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">让我们稍微修改一下我们的<code class="fe nx ny nz lo b">configure_tracing</code>函数，以便添加一个<code class="fe nx ny nz lo b">TraceContextPropagator</code>作为全局文本_地图_传播器。</p><p id="9792" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">文本映射传播器负责跨流程边界注入和提取文本形式的值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">设置文本_地图_传播器</p></figure><p id="104f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了监控我们的Actix服务，我们需要添加一个<code class="fe nx ny nz lo b">TracingLogger</code>中间件来代替默认的<code class="fe nx ny nz lo b">Logger</code>。这个记录器将为服务收到的每个HTTP调用创建一个根服务跨度。如果上下文被正确发送，这些范围将自动与父范围相关联。</p><p id="2cd7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这需要一种新的依赖，<code class="fe nx ny nz lo b"><a class="ae lz" href="https://crates.io/crates/tracing-actix-web" rel="noopener ugc nofollow" target="_blank">tracing-actix-web</a></code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">TracingLogger中间件</p></figure><p id="4093" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了在服务之间传播上下文，我们需要请求中的当前传递上下文。</p><p id="396e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此，在客户端，我们实现了<code class="fe nx ny nz lo b">Injector</code>特征来将上下文传递给文本映射传播器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">AMQP注射器的实施</p></figure><p id="bb1d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在服务端，我们通过实现<code class="fe nx ny nz lo b">Extractor</code>特征从请求中检索上下文。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">AMQP提取器的实现</p></figure><p id="587f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，当向AMQP发布消息时，我们需要使用上面定义的<code class="fe nx ny nz lo b">Injector</code>来传播上下文。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">为AMQP交付注入背景</p></figure><p id="474b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在服务器端，当我们使用来自AMQP的消息时，我们使用<code class="fe nx ny nz lo b">Extractor</code>检索上下文。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">从AMQP交付中提取上下文</p></figure><p id="fa57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">迹线现在应该正确关联了！</p><p id="758b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nx ny nz lo b">Extractor</code>和<code class="fe nx ny nz lo b">Injector</code>对于服务间的上下文传播是强制性的。Actix的实现可以在网上找到，其他的也存在于<code class="fe nx ny nz lo b">Request</code>中，但是想法总是一样的。服务器将上下文作为标题中的文本发送，客户端尽快提取。然后，当前span从远程父span继承其父id。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="4415" class="mh lt iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">使用Zipkin进行测试</h1><p id="8bbf" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">但是我怎么能确定跟踪现在真的有效呢？</p><p id="3e4f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">查看stdout日志，我们可以看到服务之间的跟踪id匹配。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/1a8aec0ef2aa3c60eeac5f8b86d5674f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1GHkq1HjDamlOpGy7UXYJg.png"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">服务1和服务2之间的跟踪id相同</p></figure><p id="f88d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，很难看到和理解我们看到的数据。要查看跟踪信息，我们可以生成一个Zipkin实例，并将跟踪信息推送给它。</p><p id="059c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们需要将<code class="fe nx ny nz lo b">text_map_propagator</code>改为<code class="fe nx ny nz lo b">opentelemetry_zipkin::Propagator</code>。然后我们需要安装<code class="fe nx ny nz lo b">opentelemetry_zipkin</code>管线。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">设置Zipkin跟踪</p></figure><p id="0416" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如果我们看一下Zipkin(在<a class="ae lz" href="http://localhost:9411" rel="noopener ugc nofollow" target="_blank"> localhost:9411 </a>上)，我们可以看到我们的踪迹被正确地传播了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/50fbea18d5608a78f270e54cf591930b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vPCDvSPjn0RtNGf0exNvdw.png"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">Zipkin服务之间的分布式跟踪</p></figure></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><p id="7d10" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们看到了如何在rust中配置服务间的分布式跟踪。完整的例子，可以在GitHub库中找到源代码。</p><p id="0a16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这篇文章是有帮助的！</p></div></div>    
</body>
</html>