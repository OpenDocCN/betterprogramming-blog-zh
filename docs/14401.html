<html>
<head>
<title>DuckDB vs. Porto Buses — A Small Case for a New OLAP Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DuckDB vs. Porto Buses新OLAP发动机的一个小案例</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/duckdb-vs-porto-buses-a-small-case-for-a-new-olap-engine-1c04b898d293?source=collection_archive---------2-----------------------#2022-12-09">https://betterprogramming.pub/duckdb-vs-porto-buses-a-small-case-for-a-new-olap-engine-1c04b898d293?source=collection_archive---------2-----------------------#2022-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="54d6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在只有一些SQL知识的情况下使用DuckDB进行局部分析</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ae03ef388c5c4a2e7804e83ec036f0cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ku_3VfiAvlCUmY7Atya73g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自联合国西班牙语网站Daniel Seß ler的照片</p></figure><p id="1e96" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">近年来，一个新的数据库DuckDB越来越受欢迎。对于许多公司来说，红移等其他替代方案过于昂贵。在开源领域，Postgres关注的是交易，而不是数据分析。</p><p id="cb7c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Clickhouse有一个复杂的体系结构来处理与Redshift相同规模的数据。有没有可能像我们拥有Sqlite一样，拥有一个小而精简的数据库来进行分析？</p><p id="bd0d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">起初，我并不理解它的吸引力，但我决定拿它来测试一下。它可能会被证明对于快速分析和作为数据平台的替代物是很棒的。</p><h1 id="8917" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">鸭子…什么？</h1><p id="fed2" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">那么DuckDB是什么呢？如果我们进入他们的<a class="ae mo" href="https://duckdb.org/" rel="noopener ugc nofollow" target="_blank">页面</a>，我们会看到:</p><blockquote class="mp mq mr"><p id="cf20" class="kv kw ms kx b ky kz jr la lb lc ju ld mt lf lg lh mu lj lk ll mv ln lo lp lq ij bi translated">“DuckDB是一个进程内SQL OLAP数据库管理系统”。</p></blockquote><p id="aabd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">换句话说，这意味着我们可以只执行一个文件，导入数据，并分析它。我们不需要复杂的分布式系统，只要它运行在单台机器上(看你火花)。</p><p id="4721" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">文档显示它有内置的工具来读取CSV、Parquet和Postgres表。这看起来已经很有希望了，让我们来测试一下吧！</p><blockquote class="mp mq mr"><p id="22e1" class="kv kw ms kx b ky kz jr la lb lc ju ld mt lf lg lh mu lj lk ll mv ln lo lp lq ij bi translated"><strong class="kx ir">注</strong> : DuckDB可以在python内部运行，读写熊猫数据帧。这是它在Python社区如此受欢迎的特性之一！然而，为了保持专注，我将把它留给另一篇文章。</p></blockquote><h1 id="4c42" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">怎么安装？</h1><p id="fa14" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">对于本文，我正在用Macbook Pro M1进行测试，并将运行版本<code class="fe mw mx my mz b">0.6.0</code>。要安装它，您可以做如下:</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="1be1" class="ne ls iq mz b be nf ng l nh ni">wget https://github.com/duckdb/duckdb/releases/download/v0.6.0/duckdb_cli-osx-universal.zip unzip duckdb_cli-osx-universal.zip<br/><br/>unzip duckdb_cli-osx-universal.zip</span></pre><p id="54f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在可以通过调用可执行文件在终端上使用DuckDB。/duckdb。但是我们可以做得更好，用<code class="fe mw mx my mz b">brew install duckdb</code>让DB在系统范围内可用(需要<a class="ae mo" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">自制</a>)。</p><p id="0b7e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从任何控制台运行Duckdb，现在您将看到一个新的会话🙂。</p><h1 id="e359" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">让我们用一些本地数据来测试一下</h1><p id="1dd9" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">对于这个测试，我将利用这个机会分析我的本地公共汽车(葡萄牙🇵🇹).的Porto)的时间表幸运的是，市政会有一个开放的数据门户。搜索了一下，发现了一个<a class="ae mo" href="https://opendata.porto.digital/dataset/horarios-paragens-e-rotas-em-formato-gtfs-stcp" rel="noopener ugc nofollow" target="_blank">数据集</a>，正好是我们需要的(⚠️门户是葡萄牙语)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/b45cceeec6bd201d4662d6f45c0eb54b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Heb2moBnvKPCyhe35QOlw.png"/></div></div></figure><p id="7f7d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们通过单击“transfer”按钮继续传输它，或者您可以运行以下命令:</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="3a04" class="ne ls iq mz b be nf ng l nh ni">wget https://opendata.porto.digital/dataset/5275c986-592c-43f5-8f87-aabbd4e4f3a4/resource/1f845744-1962-4108-a20c-ac3357d0957b/download/gtfs-stcp.zip unzip gtfs-stcp.zip<br/>unzip gtfs-stcp.zip</span></pre><p id="1c9f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">zip包含9个文件:</p><ul class=""><li id="1062" class="nk nl iq kx b ky kz lb lc le nm li nn lm no lq np nq nr ns bi translated">routes.txt</li><li id="e743" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">calendar.txt</li><li id="d2a0" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">stops.txt</li><li id="beb5" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">trips.txt</li><li id="dd08" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">形状. txt</li><li id="a631" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">停止_时间. txt</li><li id="d860" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">calendar _ dates.txt</li><li id="a07c" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">agency.txt</li><li id="8c9f" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">transfers.txt</li></ul><p id="6d1c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然它们是文本文件，但打开后我们可以看到它们遵循CSV格式。这很好，因为DuckDB有一个本机函数<code class="fe mw mx my mz b">read_csv_auto</code>来读取这些文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/f7a1f287a04b5ce55c78913e0fcbebce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ncu1VS-w6kLW50pxc9UsXQ.png"/></div></div></figure><p id="236c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个很好的特性，但是我们不想每次运行查询时都导入文件。因此，下一步是为每个文件创建一个表:</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="6e38" class="ne ls iq mz b be nf ng l nh ni">create table routes as select * from read_csv_auto('routes.txt');<br/>create table calendar as select * from read_csv_auto('calendar.txt');<br/>create table stops as select * from read_csv_auto('stops.txt');<br/>create table trips as select * from read_csv_auto('trips.txt');<br/>create table shapes as select * from read_csv_auto('shapes.txt');<br/>create table stop_times as select * from read_csv_auto('stop_times.txt');<br/>create table calendar_dates as select * from read_csv_auto('calendar_dates.txt');<br/>create table transfers as select * from read_csv_auto('transfers.txt');<br/><br/>-- For some reason this file requires the additional parameter to detect the headers<br/>create table agency as select * from read_csv_auto('agency.txt' , header=True);</span></pre><p id="4002" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">运行这个命令后，您可以检查用<code class="fe mw mx my mz b">show tables</code>创建的表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/a066f6278ab9017166dfdf5925883976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EhngyV0Y7RNeSohR4RcxGg.png"/></div></div></figure><p id="561f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">整洁的🤌🏼但是…</p><p id="fad4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你关闭外壳或者电脑关机会发生什么？嗯，我们会很难过地失去一切。为了解决这个问题，DuckDB可以通过创建一个*来存储所有数据。duckdb文件(非常类似于SQLite的工作方式)。这意味着不允许有并发的写者(只有读者)。但是，对于我们的用例来说，这不是困扰我们的问题。</p><p id="f455" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，为了在测试中取得进展，我们将执行<code class="fe mw mx my mz b">.open main.duckdb</code>。此命令打开当前目录中的现有文件或创建一个新文件。从这一刻起，你所做的一切都将被永久保存。或者直到您删除该文件。否则硬盘会爆炸。无论什么先来，🧨.</p><p id="8f82" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这提醒我，如果您再次运行<code class="fe mw mx my mz b">show tables</code>，您将看到您创建的表不再存在😅。这是因为在我们运行<code class="fe mw mx my mz b">.open</code>之前，我们一直把所有东西都存储在内存中。您需要再次运行上面的命令。这样，当我们想返回这个数据库时，我们只需运行<code class="fe mw mx my mz b">duckdb main.duckdb</code>。</p><p id="7658" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简单干净，你说呢？</p><h1 id="e2d9" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">我们可以用DuckDB做什么？</h1><p id="480f" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">通过上面的步骤，我们可以继续分析我们的数据集。对于这个测试，我想出了两个问题:</p><ol class=""><li id="7ad9" class="nk nl iq kx b ky kz lb lc le nm li nn lm no lq oa nq nr ns bi translated">我们有多少条路线？每条路线有多少站？</li><li id="22b9" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq oa nq nr ns bi translated">公共汽车的频率是多少？</li></ol><p id="ed5d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要回答这些问题，我们应该首先检查我们的表的模式(对于本文，我手动绘制这个模式)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/2f94545b8bb5e35ab5b4bda1d3c82e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-dkHwbnrnlkYO4SUBVvUIg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据集的模式</p></figure><blockquote class="mp mq mr"><p id="24e6" class="kv kw ms kx b ky kz jr la lb lc ju ld mt lf lg lh mu lj lk ll mv ln lo lp lq ij bi translated">我们有多少条路线？每条路线有多少站？</p></blockquote><p id="813a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于第一个问题，我们可以用select语句检查路由表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/0971b86d7de325e0db87931d68e4fcd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gqJYJzFNupJJ7U7ecptxPg.png"/></div></div></figure><p id="1aba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第一列名为route_id，如果唯一的话，它将正确地指出我们有多少行。为此，我们运行两个查询:</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="d663" class="ne ls iq mz b be nf ng l nh ni">select count(*) from routes;<br/><br/>select count(distinct route_id) from routes;</span></pre><p id="e9bf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">两者都返回73，所以我们可以有把握地说，在波尔图有73条路由。但是我们每条线有几站？</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="1bbe" class="ne ls iq mz b be nf ng l nh ni">create table route_stops as<br/>with stops_routes as (<br/><br/>    select distinct (<br/>    routes.route_short_name,<br/>    stop_times.stop_id) as routes<br/>    from<br/>        trips<br/>    inner join routes<br/>        on trips.route_id = routes.route_id<br/>    inner join stop_times<br/>        on stop_times.trip_id = trips.trip_id<br/>)<br/>select<br/>    routes.route_short_name as routes_name,<br/>    count(routes.stop_id) as total<br/>from stops_routes<br/>group by routes_name<br/>order by total desc;<br/><br/>-- Linted with sqlfluff</span></pre><p id="f079" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们得到了一个漂亮的结果表。现在我们得到了一个漂亮的结果表。从该表中，我们了解到平均停留次数为70次。并且它可以少到21(路线<a class="ae mo" href="https://www.stcp.pt/pt/viajar/linhas/?linha=920" rel="noopener ugc nofollow" target="_blank"> 920 </a>和<a class="ae mo" href="https://www.stcp.pt/pt/viajar/linhas/?linha=910" rel="noopener ugc nofollow" target="_blank"> 910 </a>)到121(路线<a class="ae mo" href="https://www.stcp.pt/pt/viajar/linhas/?linha=508" rel="noopener ugc nofollow" target="_blank"> 508 </a>和<a class="ae mo" href="https://www.stcp.pt/pt/viajar/linhas/?linha=603" rel="noopener ugc nofollow" target="_blank"> 603 </a>)。所有这些都使用聚合函数avg、min和max。</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="d883" class="ne ls iq mz b be nf ng l nh ni">select avg(total) from route_stops;<br/>select min(total) from route_stops;<br/>select max(total) from route_stops;<br/><br/>-- To get exactly which routes have the fewer and most stops respectivelly<br/>select * from route_stops order by total asc limit 10;<br/>select * from route_stops order by total desc limit 10;</span></pre><blockquote class="mp mq mr"><p id="53c0" class="kv kw ms kx b ky kz jr la lb lc ju ld mt lf lg lh mu lj lk ll mv ln lo lp lq ij bi translated">公共汽车的频率是多少？</p></blockquote><p id="2b57" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要回答这个问题，我们可以看看trips表。</p><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="970f" class="ne ls iq mz b be nf ng l nh ni">select<br/>    route_id,<br/>    count(trip_id) as total<br/>from trips group by route_id order by total desc limit 10;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/2ba7ef7112d3b8f7570e9ee2cbf59dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*elBnTIiwAbROox7n1IKi2Q.png"/></div></div></figure><p id="6a4b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这一切都很好，但是如果我们按不同的时期分配旅行，那会更有用。为了简单起见，我们可以使用service_id来定义工作日的“类型”:</p><ul class=""><li id="5733" class="nk nl iq kx b ky kz lb lc le nm li nn lm no lq np nq nr ns bi translated">八月的周末</li><li id="24f0" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">DOMAGOST:八月的星期天</li><li id="2481" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">UTEIS:工作日</li><li id="8701" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">唐:星期天</li><li id="efaf" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">萨博:星期六</li><li id="87c8" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">SABVERAO:夏季的星期六</li><li id="8d17" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">冬至:夏季的星期天</li><li id="779d" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">UTEISVERAO:夏季的工作日</li></ul><pre class="kg kh ki kj gt na mz nb bn nc nd bi"><span id="182a" class="ne ls iq mz b be nf ng l nh ni">select<br/>    route_id,<br/>    service_id,<br/>    count(trip_id) as total<br/>from trips group by route_id, service_id order by total desc limit 10;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/cb5a92ad9e71e9b823a845d93a71eaf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*THNQsYR1HoYiILfVKSt2oA.png"/></div></div></figure><p id="1479" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们得到了更有趣的东西来分析。到目前为止，205号路线是工作日最频繁的路线。另一个值得注意的路线是<a class="ae mo" href="https://www.stcp.pt/pt/viajar/linhas/?linha=907" rel="noopener ugc nofollow" target="_blank"> 907 </a>。这是工作日第二常见的路线，但在周末，它从前20名中消失了。这表明它主要是工人的路线。</p><h1 id="7f89" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">结论</h1><p id="a638" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在这篇文章中，我试图展示我们如何在只有一些SQL知识的情况下使用DuckDB进行局部分析。但现在我想进一步测试。我希望在未来回答的一些问题是:</p><ul class=""><li id="faef" class="nk nl iq kx b ky kz lb lc le nm li nn lm no lq np nq nr ns bi translated">DuckDB + Jupyter笔记本的DevX是什么？</li><li id="2edb" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">操作S3数据有多容易？还有Postgres？</li><li id="5cfa" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">DuckDB + dbt有多稳定？</li><li id="51ad" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">我们能在数据平台中使用它吗？</li></ul></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><p id="196c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ms">最初发布于</em><a class="ae mo" href="https://blog-migsz1hey-jecabeda.vercel.app/2022/20221117-duckdb_transports/" rel="noopener ugc nofollow" target="_blank"><em class="ms">https://</em></a><em class="ms">cabeda . dev</em></p></div></div>    
</body>
</html>