# 如何反汇编 Python 代码并提高性能

> 原文：<https://betterprogramming.pub/how-to-disassemble-python-code-and-improve-it-for-performance-76255a0318d0>

## 用几行代码优化您的 Python 代码

![](img/03edcc733e904df377cec4f44e4621db.png)

Nathan Dumlao 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片。

编写工作代码是一回事。编写优化的工作代码是另一个例子。在某些情况下，你真的不想花时间优化。让你的十行代码完成 *0.001 秒*可能没什么用。

但是优化整个项目呢？我们必须承认，在生产环境中工作时，我们的代码需要尽可能地优化。只有在测试环境中，每 50-100 行花些时间来增强它，才有可能做到这一点。

此外，如果导致不明显延迟的代码在一个`for`或`while`循环中呢？这意味着每次执行`for`和`while`循环时，您都必须将延迟乘以，导致更大的延迟和内存消耗。

这就是为什么每个开发人员都应该尽快学会提高他们的代码性能。

在本文中，我将向您展示如何:

1.  反汇编您的 Python 代码。
2.  找到并替换可以优化的代码行和流程。

只需要再多几行代码来反汇编代码，以便对指令有一个很好的概述，并花几分钟时间来思考使用什么来提高性能。

# 反汇编您的 Python 代码

反汇编在优化的时候真的很有用。它给人的眼睛一个清晰的概述，许多指令用在你写的每一行代码中。

这一步为您提供了评估某个代码片段是否可以在性能方面得到增强所需的一切。

我们可以使用 Python 的`[dis](https://docs.python.org/3/library/dis.html)`模块反汇编我们的代码。

这就是反汇编一个简单函数的样子:

我们导入了`dis`模块，然后调用`dis()`方法反汇编`my_very_special_function`。记住不要包括圆括号。我们不调用这个函数。

这是我们的输出:

我们需要了解这个输出是什么:

*   第一列:代码中相应的行号
*   第二列:相应的字节索引
*   第三列:`opname`，操作的可读名称
*   第四列:指令的参数
*   第五列:指令的可读参数

请注意，根据功能的不同，可能会多两列。更深入的解释，参考[本栈溢出答案](https://stackoverflow.com/a/47529318/13532837)。

此外，我们可以反汇编类——不仅仅是函数。将该模块作为 CLI 参数(`-m dis`)调用也使您能够反汇编整个代码。

# 查找和替换可优化的流程

我们知道如何分解我们的函数和类。现在我们需要更深入地挖掘反汇编代码，并对其进行优化。

反汇编代码的关键点是查看在运行时执行了哪些指令以及有多少指令。这样，你就可以比较做同样事情的不同代码，看哪一个执行的指令最少。

*注意:在本文中，您将了解到更少的指令并不总是意味着更好的性能。*

## 字典与许多 if 和 elifs

举个例子，让我们用一个我之前文章里的小技巧，[Python 中 If-Elif 条件太多？使用字典代替](https://medium.com/p/5486299af27e?source=post_stats_page-------------------------------------)。在那里，我将讨论 Python 字典如何优化众多的`ifs`和`elifs`。现在，让我们看看在[文章](/too-many-if-elif-conditions-in-python-use-dictionaries-instead-5486299af27e?source=your_stories_page-------------------------------------)中讨论的两个实现之间的区别。

在这里，在第 42 行和第 46 行，我们正在分解这两个函数。一个用四个`ifs`和`elifs`，另一个用字典。你可以在我的上一篇文章中得到关于这个符号的深入解释。然后在第 48 行和第 52 行，我展示了这两个函数做同样的工作。

执行该文件时，我们得到以下输出:

您会看到字典模式需要的指令更少。例如，它不需要每次都加载以下内容:

*   与`u_in`比较的常数(`1,2,3,4`)
*   比较运算符(`==`)
*   全局函数(`say_hello`)

同样，如果我们测试两个函数的执行时间:

我们看到`dict_mode`总是获得较低的执行时间:

```
Hello 2
3.0994415283203125e-06 seconds
++++++++++++++++++++++++
Hello 2
2.6226043701171875e-06 seconds
```

但那是*而不是* 赢在哪里。事实上，使用`timeit`模块，我得到了一些奇怪的结果(记得用`import timeit`导入):

这样做，我们看到字典模式几乎总是优于`ifs`和`elifs`模式。

然而，当在更大范围内(例如`1000`)应用这个测试时，结果会有更多的变化。例如，在第一次执行中:

在第二次执行时:

正如您所看到的，拥有最少的指令并不总是意味着更好的时间性能。

有一个[很棒所以答案](https://stackoverflow.com/a/57004292/13532837)通过比较`+`运算符和`.__add__`方法证明了这一点。

因此，总是测试什么对你的程序更有效。例如，您可以通过使用`timeit`模块来完成此操作。

除了作为优化代码的一种简化方式，反汇编还可以让你更好地理解你写的每一行代码实际上发生了什么。例如，您可以了解列表理解是如何工作的，与典型的`for`循环相比有什么变化，但主要是为什么它们实际上更有性能:

注意`add_compr()`使用列表理解，而`add_for()`使用传统的`for`循环。执行脚本:

这是列表理解的实际分解:

你看到它没有加载 globals(list)，methods ( `append` method)，也不需要`n`，因此没有加载和存储。但是与传统的`append()` 方法相比，真正的优化主要在`LIST_APPEND`字节码中。

事实上，我们在 list comprehension 中的执行时间比在`for`循环中要低(记得之前通过`import time`导入时间模块):

输出是:

```
Using traditional for loop
5.9604644775390625e-06 secondsUsing list comprehensions
2.86102294921875e-06 seconds
```

同样，在我所有的测试中，对列表的理解总是更快。

如你所见，`dis`模块帮助你理解哪个版本的代码更快，但主要是*为什么*它更快。

# 结论

现在，您已经了解了如何反汇编 Python 代码，以及它为什么以及如何对以下方面有用:

*   优化您的代码。
*   对 Python 的工作原理有了更深入的理解。

我希望这是有帮助的，即使大多数中级-高级程序员可能已经知道这一点。还有，我用`dis`模块也有一段时间了，我觉得我对它很有了解。但是每个人都会犯错。如果你在这里发现了什么，请评论，我会尽力改正的。