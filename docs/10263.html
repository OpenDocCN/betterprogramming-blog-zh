<html>
<head>
<title>Android Unit Testing Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android单元测试基础</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/android-unit-testing-basics-3e7075a432a1?source=collection_archive---------0-----------------------#2021-12-19">https://betterprogramming.pub/android-unit-testing-basics-3e7075a432a1?source=collection_archive---------0-----------------------#2021-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e3e7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何开始用Android编写单元测试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7edb9ee8f1c4c250bab9351b569ce089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZoY5vjhybElCLZSDe5Kdag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9664" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在移动应用程序开发中，我们有许多正在发展的趋势，如MVVM、Jetpack、KMM(Kotlin Multiplatform)等。如今，测试是最重要也是最受欢迎的事情之一。测试已经成为开发中的一个关键因素。app测试有多种策略。在大部分的面试中，编写单元测试用例的知识已经成为必备。所以在这篇文章中，让我们看看什么是单元测试，以及编写本地单元测试用例的一些基础知识。</p><p id="1b09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于不可能在一篇文章中涵盖所有内容，我将写一系列关于测试的文章。如果你想跳到代码，请查看Github repo:<a class="ae lu" href="https://github.com/pavan5208/android_unit_tests" rel="noopener ugc nofollow" target="_blank">Android _ unit _ tests</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a479" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们需要写单元测试用例吗？</h1><p id="8afb" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">大多数情况下，答案是肯定的。由于我们有更快的开发周期来满足产品需求，我们在大多数情况下不在这个范围内，或者因为我们还没有开始而不采用它。然而，许多公司都在遵循编写单元测试的方法，以获得更好的代码质量，从而构建出优秀的产品。</p><p id="5fa4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">甚至编写单元测试有助于解决bug，另一方面，编写测试用例也有助于解决与我们可能没有意识到的现有代码更改相关的问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="528c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是单元测试？</h1><p id="d611" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">单元测试意味着通过小部分测试编写的代码。我们通常编写有类的程序，而且类中的逻辑被分成方法。单元是指一小段代码，可以是方法、类或组件。单元测试的目的是验证单个单元的逻辑。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1cce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何编写简单的单元测试</h1><p id="dd8c" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们使用<code class="fe mz na nb nc b">JUnit</code> <strong class="la iu"> <em class="nd"> </em> </strong>框架来编写简单的单元测试。让我们看看如何为验证给定电子邮件的方法编写一个简单的单元测试。首先，我们需要知道在哪里编写这些测试。</p><p id="9b57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们通常在Android Studio中使用一个项目结构</p><ul class=""><li id="b8fb" class="ne nf it la b lb lc le lf lh ng ll nh lp ni lt nj nk nl nm bi translated">用于写入应用程序逻辑的<strong class="la iu"> </strong> <code class="fe mz na nb nc b">main</code>文件夹。</li><li id="dd31" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated"><code class="fe mz na nb nc b">test</code> <strong class="la iu"> </strong>文件夹用于编写单元测试。</li><li id="c375" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated"><code class="fe mz na nb nc b">androidTest</code> <strong class="la iu"> </strong>文件夹用于编写集成或自动化测试，我们将在接下来的文章中讨论。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/2b4f5e586c00fd490612bf647ff2615d.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/1*Zj6sdDYPB8UHaLBtzBqW5A.png"/></div></figure><p id="c675" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们使用Android结构，可能会略有不同，但如上所述，我们使用不同的目录用于各自的目的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/8b887cc789ed35f877060d80cb291c41.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*H75-2079Dcs4DkZauUHVrg.png"/></div></figure><p id="d9f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，我们在一个应用程序中有登录流，我们将用户的电子邮件地址作为用户名。我们需要在使用API登录之前验证这封邮件。这是为了验证是否提供了正确的电子邮件id。为此，我们创建了一个名为<code class="fe mz na nb nc b">Validator</code>的类，我们在其中进行验证。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="43b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的<code class="fe mz na nb nc b">Validator</code>类有<code class="fe mz na nb nc b">validateEmail</code>方法，它接受输入并验证它，并根据验证结果提供布尔值。我们可以在活动、片段或视图模型中使用它来进行验证。让我们看看如何为它编写一个基本的单元测试用例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="0bfb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> @Test </strong>注释告诉JUnit它所附加的公共void方法<br/>可以作为测试用例运行。为了运行该方法，<br/> JUnit首先构造一个新的类实例，然后调用<br/>带注释的方法。测试抛出的任何异常都将被JUnit报告为失败。如果没有抛出异常，则认为测试<br/>已经成功。</p><p id="e739" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码片段中，我们使用Google的<code class="fe mz na nb nc b">Truth</code> <strong class="la iu"> </strong>库进行断言语句。由于我们已经完成了编写，现在我们需要执行测试并查看结果。因为这是一个简单的测试，所以不需要仿真器或Android设备，他们可以自己运行JVM。</p><p id="6cbf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过右键单击文件并选择Run ValidatorTest选项来运行测试，或者通过点击方法旁边的play按钮来执行特定的方法，或者点击类名旁边的play按钮来运行类中的所有测试</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/d94bf9b2ca6811babca049c74b71f24c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8zJhwf1G308qAxz_Lwm99g.png"/></div></div></figure><p id="c9e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，这是一个成功的案例，它显示测试通过了1。要获得这些，我们需要在模块级构建Gradle文件中有以下依赖项</p><pre class="kj kk kl km gt nx nc ny nz aw oa bi"><span id="2669" class="ob md it nc b gy oc od l oe of"><em class="nd">testImplementation '</em><strong class="nc iu">junit:junit</strong>:4.12'<br/>testImplementation 'com.google.<strong class="nc iu">truth:truth</strong>:1.1.3'</span></pre><p id="cd26" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在编写测试时，测试所有可能的情况总是同等重要的。在上面的案例中，我们需要测试成功和失败的案例。让我们通过添加错误的电子邮件案例来查看输出，该案例将返回false。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/2b0eaf970fa340897fd5f3f9aa01880b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uz9eap23ZQbpeQxv3W78Cg.png"/></div></div></figure><p id="0ab3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就这样，通过了两项测试…</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a81b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">让我们看看编写Android单元测试的实时用法</h1><p id="2a6a" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">让我们举一个日常工作中的常见例子，在Viewmodel中进行API调用，并根据获得的状态将数据发送到UI。例如，让我们继续上面的例子，我们有一个登录流程。输入凭证后，用户单击提交按钮，在这里我们调用<strong class="la iu">视图模型</strong>中的方法，提供给定的输入，从这里我们调用<strong class="la iu">存储库</strong>，在存储库实施中我们使用<strong class="la iu"> API服务</strong>来调用我们的API。</p><p id="beff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们使用模拟对象而不是真实的东西，那么为上述内容编写单元测试将会很简单。<strong class="la iu">嘲讽</strong>是模拟或创造不真实行为的过程。在单元测试中，模拟有助于隔离外部依赖，并创建预期事物的模拟行为。简而言之，提供虚拟或模拟的行为来测试逻辑。</p><p id="2a52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在登录流示例中，我们将首先测试ViewModel，然后测试Repo，最后测试APIService。当我们使用模仿的概念时，我们将事情解耦并独立测试它们。让我们看看如何做到这一点。</p><p id="cc9a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">查看Github repo<a class="ae lu" href="https://github.com/pavan5208/android_unit_tests" rel="noopener ugc nofollow" target="_blank">Android _ unit _ tests</a>的代码库。</p><h1 id="c1a4" class="mc md it bd me mf oh mh mi mj oi ml mm jz oj ka mo kc ok kd mq kf ol kg ms mt bi translated">步骤1:为<strong class="ak"> LoginViewModel </strong>编写测试</h1><p id="643b" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">让我们创建对应于<strong class="la iu"> </strong> LoginViewModel的类<code class="fe mz na nb nc b">LoginViewModelTest</code>。<code class="fe mz na nb nc b">LoginViewModel</code>类可能将用例或存储库作为构造参数，所以我们需要根据我们的使用来模拟各自的类。让我们假设它使用了一个存储库接口LoginRepo。LoginViewModel的简单版本如下所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="53f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们为上面的视图模型编写单元测试。</p><ol class=""><li id="67a3" class="ne nf it la b lb lc le lf lh ng ll nh lp ni lt om nk nl nm bi translated">加载状态验证测试用例</li><li id="dc22" class="ne nf it la b lb nn le no lh np ll nq lp nr lt om nk nl nm bi translated">API成功状态测试用例</li><li id="3c20" class="ne nf it la b lb nn le no lh np ll nq lp nr lt om nk nl nm bi translated">API错误状态测试用例</li></ol><p id="8ee3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了嘲弄LoginRepo我们有<code class="fe mz na nb nc b">Mockito</code> <strong class="la iu"> </strong>库。在模块构建Gradle文件中添加以下依赖项</p><pre class="kj kk kl km gt nx nc ny nz aw oa bi"><span id="eb4a" class="ob md it nc b gy oc od l oe of">testImplementation<strong class="nc iu"> 'org.mockito:mockito-core:2.28.2'<br/></strong>androidTestImplementation<strong class="nc iu"> 'org.mockito:mockito-android:2.24.5'</strong></span></pre><p id="eb0a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，我们需要用<code class="fe mz na nb nc b">@RunWith(JUnit4::class)</code> <strong class="la iu">来注释我们的类LoginViewModelTest <strong class="la iu"> </strong>。通过这个<strong class="la iu"> </strong> JUnit将调用它所引用的类来运行该类中的测试，而不是运行JUnit内置的runner。我们可以根据自己的需求定义任何定制的流道。</strong></p><p id="87ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看如何创建LoginRepo的模拟对象</p><pre class="kj kk kl km gt nx nc ny nz aw oa bi"><span id="017d" class="ob md it nc b gy oc od l oe of">val loginRepo = Mockito.mock(LoginRepo::class.<em class="nd">java</em>)</span></pre><p id="cab3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe mz na nb nc b">when()</code>和<code class="fe mz na nb nc b">thenReturn()</code>也可以根据条件使用Mockito。下面是一个简单的例子</p><pre class="kj kk kl km gt nx nc ny nz aw oa bi"><span id="5ed1" class="ob md it nc b gy oc od l oe of">Mockito.<strong class="nc iu">when</strong>(loginRepo.validateLoginDetails("test@test.com","123")).<strong class="nc iu">thenReturn</strong>(LoginResponse())</span></pre><p id="0f3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当调用<code class="fe mz na nb nc b">loginRepo</code>方法<code class="fe mz na nb nc b">validateLoginDetails</code>提供输入时，上面的表达式返回<code class="fe mz na nb nc b">LoginResponse</code>。</p><p id="5d57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在编写测试时，我们通常需要在测试运行前创建或执行一些东西，并在测试执行完成后清理它们。在某种程度上，它类似于视图模型的<code class="fe mz na nb nc b">init</code>和<code class="fe mz na nb nc b">onCleared</code>方法。我们使用注释<code class="fe mz na nb nc b">@Before</code>和<code class="fe mz na nb nc b">@After</code>和<strong class="la iu">来实现这一点。</strong></p><p id="a5c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的<code class="fe mz na nb nc b">LoginViewModelTest</code> <strong class="la iu"> </strong>合起来看起来会像下面这样</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="09c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们使用Kotlin协同程序时，我们可能需要添加与它们相关的测试依赖。</p><pre class="kj kk kl km gt nx nc ny nz aw oa bi"><span id="0066" class="ob md it nc b gy oc od l oe of">implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-test:1.5.0'</span></pre><p id="ad38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于完整的代码库，请查看Github repo<a class="ae lu" href="https://github.com/pavan5208/android_unit_tests" rel="noopener ugc nofollow" target="_blank">Android _ unit _ tests</a>。一旦你运行<code class="fe mz na nb nc b">LoginViewModelTest</code> <strong class="la iu"> </strong>我们可以看到所有的测试都通过了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="136c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">步骤2:为LoginRepo编写测试</h1><p id="845d" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated"><code class="fe mz na nb nc b">LoginRepo</code>只不过是一个拥有抽象方法<code class="fe mz na nb nc b">validateLoginDetails</code>的接口。</p><pre class="kj kk kl km gt nx nc ny nz aw oa bi"><span id="e8e8" class="ob md it nc b gy oc od l oe of">package com.sample<br/><br/>interface LoginRepo {<br/>     fun validateLoginDetails(username: String, pass: String): LoginResponse?<br/>}</span></pre><p id="cec9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个类<code class="fe mz na nb nc b">LoginRepoTest</code>,并做与上面类似的测试。因为我们在回购中只有一种方法，所以我们有两种可能的结果，即成功和失败状态。<code class="fe mz na nb nc b">LoginRepoTest</code>代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="51f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行<code class="fe mz na nb nc b">LoginRepoTest</code> <strong class="la iu"> </strong>会给出测试通过的结果。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="faeb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">步骤3:为LoginAPIService编写测试</h1><p id="b700" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们来看看<code class="fe mz na nb nc b">LoginAPIService</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="344f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了测试APIService，我们需要将模拟web服务器依赖项添加到模块级Gradle文件中:</p><pre class="kj kk kl km gt nx nc ny nz aw oa bi"><span id="39ef" class="ob md it nc b gy oc od l oe of">testImplementation 'com.squareup.okhttp3:<strong class="nc iu">mockwebserver</strong>:4.9.0'</span></pre><p id="f960" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要创建<code class="fe mz na nb nc b">MockWebServer</code>实例，并将其用于改型以获得预期的结果。在这里，我们将web服务器的响应数据设置为在方法调用时返回。让我们看看如何做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="5579" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们已经处理了成功状态，现在尝试写入失败状态，并通过运行它进行检查。</p><p id="aa2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您在执行代码片段时有任何问题，请查看Github repo上的完整代码库<a class="ae lu" href="https://github.com/pavan5208/android_unit_tests" rel="noopener ugc nofollow" target="_blank"> android_unit_tests </a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b1b1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="d4aa" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">总是为快乐和悲伤的流程编写测试。以上是单元测试的简单片段，我们可以做得更多。通过编写单元测试，我们可以提高构建质量。单元测试是测试的起点。还有很多我们可以做的，让我们在接下来的帖子里看看。</p><p id="84f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读…</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d11e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ul class=""><li id="d5ff" class="ne nf it la b lb mu le mv lh on ll oo lp op lt nj nk nl nm bi translated"><a class="ae lu" href="https://developer.android.com/training/testing/unit-testing" rel="noopener ugc nofollow" target="_blank">构建有效的单元测试</a></li><li id="1cf6" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated"><a class="ae lu" href="https://developer.android.com/codelabs/advanced-android-kotlin-training-testing-basics#0" rel="noopener ugc nofollow" target="_blank">测试基础知识</a></li></ul></div></div>    
</body>
</html>