<html>
<head>
<title>Dynamic Promise Chaining</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态承诺链</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dynamic-promise-chaining-af9c5cb87f2e?source=collection_archive---------3-----------------------#2019-08-13">https://betterprogramming.pub/dynamic-promise-chaining-af9c5cb87f2e?source=collection_archive---------3-----------------------#2019-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a445" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">递归和还原方法的演示和比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aa303960b5f855f6eef3a659b339e4bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Lv_ke7T9sIfh7WKM1-MhA.png"/></div></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="5a77" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">介绍</h1><p id="f6e2" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">现在许多开发者没有意识到承诺的全部魅力和它们提供的灵活性。在代码片段中，promise只是用来从远程数据源获取一些数据，这是很常见的事情，同样可以用简单的回调函数来实现。而它的目的要复杂和强大得多。</p><p id="dd32" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">在本指南中，我想分享我的知识，告诉你如何将承诺连锁化，什么更美味，如何动态地做，而不需要事先知道你应该执行多少连锁。</p><p id="81dd" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">我们都听说过所谓的回调地狱。这是发明Promise API的主要动机之一。</p><p id="5af9" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">承诺可以轻松应对这种情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/a469e65e73b96a71e097e42014434d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1rlNjMeVyQJhA0EdgJL1sw.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">经典承诺链</p></figure><p id="a15c" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">这种可预测的任务可以在几秒钟内解决。但是如果我们的任务不那么可预测呢？如果我们应该在承诺链中一个接一个地执行一些异步操作，而事先不知道有多少个，那该怎么办？换句话说，我们如何动态地建立一个承诺链？</p><p id="ec8e" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">我想展示两种方法来做到这一点。但首先，让我们创建一些工作的基础。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">模拟文件已经可以下载了</p></figure><p id="7a09" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">以及模仿文件下载过程的简单功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">在给定文件的<code class="fe nb nc nd ne b">downloadTime</code>之后解析的承诺</p></figure><p id="f0f6" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">考虑一下:出于某种原因，我们希望我们的模拟文件被一个接一个地下载(实际上这是一个常见的场景)。现在，我们知道正好有三个文件。正如我之前所说，处理静态数据将会非常容易。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="d4ee" class="nj lc it ne b gy nk nl l nm nn">const [file1,file2,file3] = mockFiles</span><span id="a8a4" class="nj lc it ne b gy no nl l nm nn">download(file1)<br/>.then(_ =&gt; download(file2))<br/>.then(_ =&gt; download(file3))</span></pre><p id="d0f9" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">这很简单，对吧？但是当事情变得动态和不可预测时，你需要挖掘得更深。如果我们有10个文件，1000个文件呢？让我们假设我们从外部来源接收指令，并且不知道有多少文件要下载。首先可以诱人的是使用<code class="fe nb nc nd ne b">Promise.all</code> API。</p><blockquote class="np nq nr"><p id="ad21" class="lt lu ns lv b lw mp ju ly lz mq jx mb nt mr me mf nu ms mi mj nv mt mm mn mo im bi translated">"<code class="fe nb nc nd ne b">Promise.all()</code>方法返回一个<code class="fe nb nc nd ne b"><a class="ae nw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">Promise</a></code>，当所有作为iterable传递的承诺都已解析时，该方法将解析。"— <a class="ae nw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">并行承诺处理</p></figure><p id="a80b" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">该函数接受挑战不依赖于文件数量。但这不是我们需要的。与我们的目的相反，它并行下载文件，而不是一步一步。如果您仔细观察了输出，您可能会注意到这个函数并不关心源数组中文件的顺序。它会尽快下载它们。这就是为什么我们看到的输出是关于<code class="fe nb nc nd ne b">file_1</code>，然后是<code class="fe nb nc nd ne b">file_3</code>，然后才是<code class="fe nb nc nd ne b">file_2</code>。这里的顺序是基于下载时间，而不是文件的顺序。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="109c" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">递归承诺链</h1><h2 id="b681" class="nj lc it bd ld nx ny dn lh nz oa dp ll mc ob oc ln mg od oe lp mk of og lr oh bi translated">递归</h2><blockquote class="np nq nr"><p id="da9b" class="lt lu ns lv b lw mp ju ly lz mq jx mb nt mr me mf nu ms mi mj nv mt mm mn mo im bi translated">递归:函数调用自身的行为。递归用于解决包含更小的子问题的问题。递归函数可以接收两个输入:基本情况(结束递归)或递归情况(继续递归)。”— <a class="ae nw" href="https://developer.mozilla.org/en-US/docs/Glossary/Recursion" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="0896" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">第一种方法是基于递归构建承诺链。它看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">递归承诺链</p></figure><p id="345c" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">我们已经可以看到预期的行为。不像<code class="fe nb nc nd ne b">parallelDownload</code>，这个功能坚持文件顺序，不管花多少时间都是一个接一个下载。</p><h2 id="a51a" class="nj lc it bd ld nx ny dn lh nz oa dp ll mc ob oc ln mg od oe lp mk of og lr oh bi translated"><strong class="ak">一些关键片段</strong></h2><ul class=""><li id="3368" class="oi oj it lv b lw lx lz ma mc ok mg ol mk om mo on oo op oq bi translated">我们执行<code class="fe nb nc nd ne b">files.shift()</code>,从而为进一步的调用准备数组，同时将当前文件保存在一个变量中以供正在进行的调用。</li><li id="72c3" class="oi oj it lv b lw or lz os mc ot mg ou mk ov mo on oo op oq bi translated"><code class="fe nb nc nd ne b">download(nextFile).then(_ =&gt; recursiveDownloadChain(files))</code>每次通话都会带来全新的承诺。如果文件存在(也就是说，我们的数组没有用完)，那么将使用一个已经变异的数组再次调用该函数。</li><li id="1ded" class="oi oj it lv b lw or lz os mc ot mg ou mk ov mo on oo op oq bi translated">当没有更多的文件时，我们提供一些端点<code class="fe nb nc nd ne b">Promise.reolve()</code>，它将作为最终标志被触发。事实上，当我们编写<code class="fe nb nc nd ne b">recursiveDownloadChain(files).then(....)</code>时，<code class="fe nb nc nd ne b">then</code>中的代码被这个<code class="fe nb nc nd ne b">Promise.resolve()</code>调用</li></ul></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="7b4a" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">还原承诺链</h1><h2 id="8688" class="nj lc it bd ld nx ny dn lh nz oa dp ll mc ob oc ln mg od oe lp mk of og lr oh bi translated">array . protocol . reduce</h2><blockquote class="np nq nr"><p id="c6e2" class="lt lu ns lv b lw mp ju ly lz mq jx mb nt mr me mf nu ms mi mj nv mt mm mn mo im bi translated">"<code class="fe nb nc nd ne b"><strong class="lv iu">reduce()</strong></code>方法对数组的每个元素执行一个<strong class="lv iu"> reducer </strong>函数(您提供的),产生一个输出值。"— <a class="ae nw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="31a8" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">第二种方法是使用reducer功能，在我看来这种方法更灵活，也更容易维护<em class="ns">。这就是:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">还原承诺链</p></figure><h2 id="3ed3" class="nj lc it bd ld nx ny dn lh nz oa dp ll mc ob oc ln mg od oe lp mk of og lr oh bi translated">一些关键片段</h2><ul class=""><li id="668b" class="oi oj it lv b lw lx lz ma mc ok mg ol mk om mo on oo op oq bi translated">我们传递了一个初始值<code class="fe nb nc nd ne b">Promise.resolve()</code>来用一个现有的promise对象初始化我们的链。所以我们现在能够在每次迭代中扩展它。</li><li id="e73e" class="oi oj it lv b lw or lz os mc ot mg ou mk ov mo on oo op oq bi translated"><code class="fe nb nc nd ne b">chain.then(_ =&gt; download(currentFile))</code>正在从每下一个<code class="fe nb nc nd ne b">currentFile</code>开始将我们的源数组缩减为一个承诺链。</li></ul></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="46b4" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">全球连锁</h1><p id="98b1" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">到目前为止，我们已经实现了三种下载方式:</p><ul class=""><li id="4f24" class="oi oj it lv b lw mp lz mq mc ow mg ox mk oy mo on oo op oq bi translated">并行下载<em class="ns"> </em> <code class="fe nb nc nd ne b">Promise.all</code></li><li id="0099" class="oi oj it lv b lw or lz os mc ot mg ou mk ov mo on oo op oq bi translated">reductiveChainDownload <code class="fe nb nc nd ne b">Array.prototype.reduce</code></li><li id="b2aa" class="oi oj it lv b lw or lz os mc ot mg ou mk ov mo on oo op oq bi translated">递归链下载<code class="fe nb nc nd ne b">Recursion</code></li></ul><p id="08ff" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">你知道吗？没有什么能阻止我们把它们捆绑在一个单一的全球链条中，只是为了好玩。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="64af" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">检查控制台中的输出，确信一切正常。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="37fd" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">结论</h1><p id="eb28" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">在大多数情况下，还原方法会胜出。特别是:</p><ul class=""><li id="628c" class="oi oj it lv b lw mp lz mq mc ow mg ox mk oy mo on oo op oq bi translated"><strong class="lv iu">写起来可读性更强，更容易理解，也更简短——递归承诺链有时甚至对有经验的开发人员来说也不清楚。</strong></li><li id="6de8" class="oi oj it lv b lw or lz os mc ot mg ou mk ov mo on oo op oq bi translated"><strong class="lv iu">更优化。</strong>尽管<code class="fe nb nc nd ne b">Arrat.prototype.reduce</code> <em class="ns"> </em>的算法没有这么简单，但它不会以任何方式影响调用堆栈，而递归方法会在每次下一次调用时填充调用堆栈，在极端情况下，它会导致内存超过性能。</li><li id="122f" class="oi oj it lv b lw or lz os mc ot mg ou mk ov mo on oo op oq bi translated">它可以用比递归多得多的方式来处理。在reductive方法中，您始终可以访问作为一个整体的源数组，以及文件的当前索引，这是由额外的参数(第三和第四个)提供的，我们在本指南中没有探讨。在递归中，你没有任何内置的提供者来实现这样的东西，你必须深入到闭包或类似的东西中，这将导致完全不可维护的代码。</li></ul><p id="e7bc" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">递归唯一值得一提的优点是:</p><ul class=""><li id="dc9d" class="oi oj it lv b lw mp lz mq mc ow mg ox mk oy mo on oo op oq bi translated"><strong class="lv iu">链接循环可以随时停止。</strong> —而<code class="fe nb nc nd ne b">Array.prototype.reduce</code>是牢不可破的，就像<code class="fe nb nc nd ne b">Array.prototype.forEach</code>和所有基于回调的数组方法一样。当然，我们可以用一些技巧来实现它，但那不是最好的做法，也不标准。</li></ul></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><p id="6ef5" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">感谢阅读。我很乐意在评论中更深入地讨论这个话题。</p></div></div>    
</body>
</html>