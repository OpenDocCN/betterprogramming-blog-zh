<html>
<head>
<title>Combine Publishers, Subscriptions, and Subscribers — Under the Hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将发布者、订阅者和订阅者结合在一起</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/combine-publishers-subscriptions-and-subscribers-implementations-under-the-hood-fe308fb9f7f6?source=collection_archive---------2-----------------------#2022-07-12">https://betterprogramming.pub/combine-publishers-subscriptions-and-subscribers-implementations-under-the-hood-fe308fb9f7f6?source=collection_archive---------2-----------------------#2022-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="607a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">带有实现示例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fee82cfef32d1f4aa7566d6ad78d3a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ipHbnKgQ1hqFSC6h.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="http://www.maestro.ind.br/a-importancia-das-engrenagens-em-sistemas-industriais/" rel="noopener ugc nofollow" target="_blank">http://www . maestro . ind . br/a-importancia-das-engrenagens-em-sistemas-industriais/</a></p></figure><p id="e964" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许你已经研究过苹果在WWDC19上发布的Combine native framework，并记住了如此庞大的出版商、订户和运营商名单。</p><p id="7f5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许您只知道第一个负责生成新的异步值，这些值应该更新第二个。好了，这就是它的组成！但是通常我们很多人都没有深入了解这些协议之间是如何通信的，有些人可能不知道它们是协议(啊哈！).</p><p id="073e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在本文中，我们将讨论如何通过实现这些协议来创建您的自定义发布者、订阅和订阅者，当发布者发出一些新值时，它的所有订阅都可以告诉订阅者，以便进行适当的处理(而不是，<code class="fe ls lt lu lv b">sink</code>和<code class="fe ls lt lu lv b">assign</code>根本不是唯一可用的订阅者)。</p><h1 id="6038" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">了解他们每个人</h1><p id="6f6a" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">首先，有必要了解这三个实体:<code class="fe ls lt lu lv b">Publisher</code>、<code class="fe ls lt lu lv b">Subscription</code>和<code class="fe ls lt lu lv b">Subscriber</code>之间的真实关系，以及主要是它们的接口契约由什么组成。</p><p id="6359" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Apple不建议您实现一个<code class="fe ls lt lu lv b">Publisher</code>类型，因为所有的本机和预定义类型都已经完成了正确的任务，以保持它们和它们的订户之间的完美同步，但是这篇文章旨在理解同步实际上是如何工作的，所以让我们继续！</p><h1 id="76be" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">1.出版者</h1><p id="3e29" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">publisher是一种符合<code class="fe ls lt lu lv b">Publisher</code>协议的类型，正如其名称所示，它的意思是发布值。它有两个泛型类型:一个是<code class="fe ls lt lu lv b">Output</code>，这是它应该向其<code class="fe ls lt lu lv b">subscribers</code>发出的值类型；另一个是<code class="fe ls lt lu lv b">Failure</code>类型，它从Swift <code class="fe ls lt lu lv b">Error</code>继承而来，旨在向订阅者传递订阅期间发生的一些错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="fbe3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，<code class="fe ls lt lu lv b">Publisher</code>由两个关联的类型和一个接收<code class="fe ls lt lu lv b">subscriber</code>作为参数的方法组成。当这个方法被调用时，自定义<code class="fe ls lt lu lv b">Publisher</code>必须创建一个<code class="fe ls lt lu lv b">Subscription</code>对象并将其发送给<code class="fe ls lt lu lv b">Subscriber</code>。</p><p id="6755" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单描述一下<code class="fe ls lt lu lv b">Publisher</code>的生命周期，它首先调用这个<code class="fe ls lt lu lv b">receive</code>方法，然后向<code class="fe ls lt lu lv b">subscriber</code>发送一个<code class="fe ls lt lu lv b">subscription</code>。<code class="fe ls lt lu lv b">publisher</code>保持异步发送值，然后它以两种排他的方式停止:结束或失败，这对应于<code class="fe ls lt lu lv b">Failure</code>泛型类型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/b6cfa2ebf750b8bba4ace1f7511dc4e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GCfM-1EyBKqHVsBn_TpyJQ.png"/></div></div></figure><h1 id="f0f3" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">2.签署</h1><p id="5ec4" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">组合开发人员对订阅对象了解并不多。关于这个协议，重要的是实现它的对象负责将一个<code class="fe ls lt lu lv b">subscriber</code>链接到<code class="fe ls lt lu lv b">publisher</code>。只要在内存中，<code class="fe ls lt lu lv b">subscriber</code>就会一直接收值。它只包含一种方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c94e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦<code class="fe ls lt lu lv b">subscriber</code>从<code class="fe ls lt lu lv b">publisher</code>接收到<code class="fe ls lt lu lv b">subscription</code>，就会调用<code class="fe ls lt lu lv b">request</code>方法，它负责确定<code class="fe ls lt lu lv b">subscriber</code>从<code class="fe ls lt lu lv b">publisher</code>请求多少个值，这由<code class="fe ls lt lu lv b">Demand</code>枚举定义。</p><p id="2c61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它可以是对应于没有值要接收的<code class="fe ls lt lu lv b">none</code>，定义订户请求<code class="fe ls lt lu lv b">value</code>次的<code class="fe ls lt lu lv b">max(value)</code>，或者是对应于只要<code class="fe ls lt lu lv b">subscription</code>存在就接收无穷大值的<code class="fe ls lt lu lv b">unlimited</code>(不从<code class="fe ls lt lu lv b">publisher</code>接收完成)。</p><p id="06c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要提醒您的是，真正链接<code class="fe ls lt lu lv b">publisher</code>和<code class="fe ls lt lu lv b">subscriber</code>的是<code class="fe ls lt lu lv b">Subscription</code>对象——它包含一个对<code class="fe ls lt lu lv b">subscriber</code>的引用以保持其最新，以及一个对与<code class="fe ls lt lu lv b">publisher</code>相关的对象的引用以通知它发送了一个新的输出值。</p><p id="0037" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管<code class="fe ls lt lu lv b">Subscription</code>在谈论合并时并不总是被提及，但我认为这是反应式编程中关于这个概念的最重要的实体。</p><p id="463c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于<code class="fe ls lt lu lv b">Subscription</code>协议继承自<code class="fe ls lt lu lv b">Cancellable</code>，默认情况下它有一个<code class="fe ls lt lu lv b">cancel</code>方法，负责取消到订户的链接。通常，它只是将订户属性设置为<code class="fe ls lt lu lv b">nil</code>。</p><p id="3e42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一件要说的重要事情是，从发布者接收值的方式确实取决于自定义<code class="fe ls lt lu lv b">subscription</code>，但是我们将在稍后实现时更深入地讨论这一点。</p><h2 id="8a8f" class="mw lx iq bd ly mx my dn mc mz na dp mg lf nb nc mi lj nd ne mk ln nf ng mm nh bi translated">3.订户</h2><p id="9e33" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">最后，我们有了<code class="fe ls lt lu lv b">Subscriber</code>，它是与<code class="fe ls lt lu lv b">publisher</code>生命周期保持同步的对象，并通过<code class="fe ls lt lu lv b">Subscription</code>请求对这些值的需求。真正处理来自<code class="fe ls lt lu lv b">publisher</code>的事件的是<code class="fe ls lt lu lv b">subscriber</code>，它有三种方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6a97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个<code class="fe ls lt lu lv b">receive</code>方法由<code class="fe ls lt lu lv b">Publisher</code>本身发送，包含一个<code class="fe ls lt lu lv b">Subscription</code>作为参数。幕后的想法是<code class="fe ls lt lu lv b">Subscriber</code>调用<code class="fe ls lt lu lv b">Subscription</code>上的<code class="fe ls lt lu lv b">request</code>方法，以便告诉它准备从<code class="fe ls lt lu lv b">Publisher</code>接收多少个值。在实现内部，<code class="fe ls lt lu lv b">subscriber</code>可以做任何其他额外的动作。</p><p id="45bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个<code class="fe ls lt lu lv b">receive</code>方法用于接收来自<code class="fe ls lt lu lv b">Publisher</code>的值并进行适当的处理。如您所见，它将一个<code class="fe ls lt lu lv b">Demand</code>类型返回给调用它的订阅，并且它将调整它实际需要的值的数量。值得一提的是，它并没有完全更新保持在<code class="fe ls lt lu lv b">Subscription</code>中的需求，而只是在现有需求的基础上增加了更多。</p><p id="6e39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一个<code class="fe ls lt lu lv b">receive</code>方法用于接收来自<code class="fe ls lt lu lv b">publisher</code>的完成事件，并处理完成事件或可能的输入故障。</p><p id="c662" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，为了使该过程有效，来自<code class="fe ls lt lu lv b">Subscriber</code>和<code class="fe ls lt lu lv b">Publisher</code>的通用类型<code class="fe ls lt lu lv b">Input</code>和<code class="fe ls lt lu lv b">Output</code>必须是相同的，即在收到的同一中发布的类型。</p><h1 id="a0d3" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">订阅生命周期</h1><p id="9972" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">通过满足这些协议，现在我们可以安全地理解<code class="fe ls lt lu lv b">publisher</code>和<code class="fe ls lt lu lv b">subscriber</code>之间的关系是如何建立的:</p><ol class=""><li id="beeb" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr nn no np nq bi translated">一个新的订阅者通过调用发布者的<code class="fe ls lt lu lv b">receive</code>方法，将订阅者作为一个参数传递，从而向发布者请求订阅</li><li id="aa12" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">发布者创建一个定制订阅，一个负责让订阅者与发布者保持同步的对象，并通过<code class="fe ls lt lu lv b">receive(Subscription)</code>方法将其发送给订阅者。</li><li id="b361" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">在<code class="fe ls lt lu lv b">receive(Subscription)</code>方法中，订阅者调用刚刚收到的<code class="fe ls lt lu lv b">Subscription</code>对象上的<code class="fe ls lt lu lv b">request</code>方法，建立它从发布者那里需要的真实需求。</li><li id="b48e" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">当接收到<code class="fe ls lt lu lv b">request</code>方法时，<code class="fe ls lt lu lv b">Subscription</code>对象拥有订阅者需要的<code class="fe ls lt lu lv b">Demand</code>，并且知道它必须从发布者那里接收多少个值</li><li id="3aa1" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">由于<code class="fe ls lt lu lv b">Subscription</code>有一些跟踪发布者发出的值的机制，它只需要通过<code class="fe ls lt lu lv b">receive(Input)</code>方法将它们发送给订阅者。</li><li id="3a04" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">当某个事件需要订阅完成时，<code class="fe ls lt lu lv b">Subscription</code>调用<code class="fe ls lt lu lv b">Subscriber</code>上的<code class="fe ls lt lu lv b">receive(Completion)</code>方法，流程结束。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/7fbc6257530c4165179c56b8c48d8627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*adIpAjFuMXe0TtD0KuwP_Q.png"/></div></div></figure><h1 id="12bc" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">创建我们自己的发布者、订阅者和订户</h1><p id="0699" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">为了理解这个强大的框架是如何工作的，我们将为一个类实现一个publisher，它只保存一个整数值，当它被改变时，我们告诉它的订阅者以便处理。说够了，我们开始吧。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="db04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们的<code class="fe ls lt lu lv b">HoldValue</code>自定义类，正如你所看到的，它仅仅意味着保存一个可能改变的整数值。现在我们需要一个<code class="fe ls lt lu lv b">publisher</code>来跟踪一些实例值的变化，并通过一个<code class="fe ls lt lu lv b">subscriber</code>来处理它。简单，不是吗？它甚至类似于在声明某个<code class="fe ls lt lu lv b">ObservableObject</code>类时由<code class="fe ls lt lu lv b">Published</code>属性包装器生成的<code class="fe ls lt lu lv b">publisher</code>。我们正在实现一个非常相似的案例。</p><h2 id="cc50" class="mw lx iq bd ly mx my dn mc mz na dp mg lf nb nc mi lj nd ne mk ln nf ng mm nh bi translated">实现我们的发布者</h2><p id="41cc" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">当我们的<code class="fe ls lt lu lv b">HoldValue</code>实例改变其内部属性时，我们需要一个<code class="fe ls lt lu lv b">publisher</code>来接收值，所以让我们用一个新的类来实现Combine的<code class="fe ls lt lu lv b">Publisher</code>协议:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="13a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了一个新的<code class="fe ls lt lu lv b">Publisher</code>类来定义我们需要的两个关联类型:一个<code class="fe ls lt lu lv b">Int</code>作为<code class="fe ls lt lu lv b">Output</code>，我们的发布者将把它发送给订阅者，一个<code class="fe ls lt lu lv b">Never</code>作为<code class="fe ls lt lu lv b">Failure</code>，因为我们的类永远不会以错误结束。如您所见，我们也在我们的<code class="fe ls lt lu lv b">publisher</code>中声明了一个<code class="fe ls lt lu lv b">HoldValue</code>实例作为属性。我们需要这个实例来跟踪发送给我们的<code class="fe ls lt lu lv b">subscriber</code>的事件。</p><p id="09e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我们需要某种机制来监听我们的<code class="fe ls lt lu lv b">HoldValue</code>对象，并且我们希望我们的发布者可供多个订阅者连接，我们将定义一组将更新多个监听器的完成:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="84a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了一组闭包来处理值的变化，每一个都对应于一个<code class="fe ls lt lu lv b">subscription</code>。注意，每次我们的值改变时，一个观察者遍历所有的处理程序并用我们的新值执行它们。这将很快变得非常重要。</p><h2 id="7a2c" class="mw lx iq bd ly mx my dn mc mz na dp mg lf nb nc mi lj nd ne mk ln nf ng mm nh bi translated">创建我们的订阅</h2><p id="a8e4" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">正如我们之前谈到的，<code class="fe ls lt lu lv b">Subscription</code>是关于Combine的最重要的实体，因为它在我们的发布者和订阅者之间保持联系。</p><p id="74a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当<code class="fe ls lt lu lv b">Subscription</code>作为中介时，订阅者保持更新。我们将创建一个定制的<code class="fe ls lt lu lv b">Subscription</code>类型，它将实现一些逻辑来满足订户的需求。为此，它必须有办法监听<code class="fe ls lt lu lv b">publisher</code>并将新的输出值发送到它负责的<code class="fe ls lt lu lv b">subscriber</code>以进行同步。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="88f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们<code class="fe ls lt lu lv b">HoldValuePublisher</code>的<code class="fe ls lt lu lv b">Subscription</code>型号。它接收一个负责发送值的<code class="fe ls lt lu lv b"><strong class="ky ir">subscriber</strong></code>和一个必须监听的<code class="fe ls lt lu lv b">HoldValue</code>类的实例。</p><p id="9303" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为它是一个<code class="fe ls lt lu lv b">Cancellable</code>类型，所以它实现了<code class="fe ls lt lu lv b">cancel</code>方法，该方法将切断订阅和订阅者之间的链接(然后是发布者)。它只是将订户分配给<code class="fe ls lt lu lv b">nil</code>。</p><p id="e294" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们想要跟踪<code class="fe ls lt lu lv b">HoldValue</code>的值，我们现在必须做的是给它添加一个新的闭包，它将处理我们之前看到的值的变化:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a421" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们的逻辑以如下方式工作:我们在我们的<code class="fe ls lt lu lv b">subscription</code>中设置我们的<code class="fe ls lt lu lv b">subscriber</code>引用，并且也设置对<code class="fe ls lt lu lv b">HoldValue</code>的引用。然后，我们向我们的<code class="fe ls lt lu lv b">HoldValue</code>实例添加一个新的闭包，它将通过<code class="fe ls lt lu lv b">receive(Input)</code>方法向订户发送一个新值。很简单，对吧？</p><p id="449b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在<code class="fe ls lt lu lv b">subscription</code>充当我们的<code class="fe ls lt lu lv b">publisher</code>和<code class="fe ls lt lu lv b">subscriber</code>之间的中介。但这并没有停止。我们仍然需要展示当一个新的订阅者连接到它时，发布者是如何建立<code class="fe ls lt lu lv b">subscription</code>的。</p><p id="becc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还记得<code class="fe ls lt lu lv b">Publisher</code>协议中的<code class="fe ls lt lu lv b">receive(Subscriber)</code>方法吗？这是我们合并管道的第一步，它实际上负责实例化<code class="fe ls lt lu lv b">Subscription</code>并发送给<code class="fe ls lt lu lv b">Subscriber</code>，因此创建了两个实体之间的链接:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0412" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当<code class="fe ls lt lu lv b">Publisher</code>收到一个新的<code class="fe ls lt lu lv b">subscriber</code>时，创建一个新的<code class="fe ls lt lu lv b">subscription</code>并发送给<code class="fe ls lt lu lv b">subscriber</code>处理。<code class="fe ls lt lu lv b">Subscription</code>接收<code class="fe ls lt lu lv b">Subscriber</code>本身和一个对<code class="fe ls lt lu lv b">Publisher</code>发布其值的类的引用(很抱歉这是多余的！).现在是<code class="fe ls lt lu lv b">subscriber</code>向<code class="fe ls lt lu lv b">subscription</code>提出要求的时候了。</p><h1 id="f1d0" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">处理需求</h1><p id="5ede" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">正如我们之前看到的，<code class="fe ls lt lu lv b">Subscription</code>有一个名为<code class="fe ls lt lu lv b">request</code>的方法接收一个<code class="fe ls lt lu lv b">Subscribers.Demand</code>，但我们还没有实现它。该方法负责接收<code class="fe ls lt lu lv b">Demand</code>对象，该对象内部包含我们的订阅者实际希望接收值的次数，我们的订阅据此做出一些逻辑来传递我们的订阅者所期望的内容。</p><p id="0248" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在实施之前，关于需求和我们的出版商生命周期，你必须知道一件事。需求完全与订阅者相关，而生命周期属于发布者，这意味着如果我们的订阅者由于缺乏需求而停止接收新的输入，它不一定会从订阅接收到完成事件。我们将进一步了解这一点，现在只需遵循代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a984" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">向我们的订阅类添加两个新属性，一个是<code class="fe ls lt lu lv b">counter</code>，它将记录我们的订户到目前为止已经收到了多少值，另一个是<code class="fe ls lt lu lv b">maximum</code>，它对应于我们的需求。</p><p id="3e23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的<code class="fe ls lt lu lv b">request</code>方法中，只需将我们输入的需求中的<code class="fe ls lt lu lv b">max</code>属性分配给<code class="fe ls lt lu lv b">HoldValue</code>订阅中的<code class="fe ls lt lu lv b">maximum</code>属性。</p><h2 id="39b1" class="mw lx iq bd ly mx my dn mc mz na dp mg lf nb nc mi lj nd ne mk ln nf ng mm nh bi translated">实施需求逻辑</h2><p id="1b0e" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">既然我们已经保存了想要发送给<code class="fe ls lt lu lv b">subscriber</code>的最大值，我们需要在<code class="fe ls lt lu lv b">subscription</code>中实现一些逻辑来满足这个需求。在初始化器内部，向<code class="fe ls lt lu lv b">HoldValue</code>实例添加一个新的处理程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5431" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们实现这个魔术:在我们新的<code class="fe ls lt lu lv b">holdValue</code>闭包内，检查<code class="fe ls lt lu lv b">maximum</code>值是否存在(不是<code class="fe ls lt lu lv b">nil</code>)，如果存在，检查我们的<code class="fe ls lt lu lv b">counter </code>是否小于<code class="fe ls lt lu lv b">maximum</code>。如果是，意味着我们给定的订户仍然能够接收新的输入，所以我们只需用来自<code class="fe ls lt lu lv b">HoldValue</code>的新整数调用<code class="fe ls lt lu lv b">receive(Input)</code>方法，自然地，递增<code class="fe ls lt lu lv b">counter</code>来更新我们的逻辑。如果<code class="fe ls lt lu lv b">counter</code>达到了我们的<code class="fe ls lt lu lv b">maximum</code>需求，在这种情况下，我们向我们的订户发送一个<code class="fe ls lt lu lv b">finished</code>完成事件并取消<code class="fe ls lt lu lv b">subscription</code>。</p><p id="383f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们甚至没有一个<code class="fe ls lt lu lv b">maximum</code>，由于一个<code class="fe ls lt lu lv b">unlimited</code>需求，我们只是让我们的订户无限期地接收价值。请注意，我们触发完成事件只是因为没有更多的值要发出，但是在其他发布器中，比如用<code class="fe ls lt lu lv b">Published</code>属性包装器创建的发布器，这根本不会发生。</p><p id="d85e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太棒了，现在我们的<code class="fe ls lt lu lv b">subscriber</code>可以接收需求，并在需要时向我们的订户发送值。到目前为止，我们实现了一个<code class="fe ls lt lu lv b">publisher</code>，它创建了一个<code class="fe ls lt lu lv b">subscription</code>，将其发送给订阅者，订阅者根据自己的需求请求新的值。</p><h1 id="2b41" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">实现我们的订户</h1><p id="a73b" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">最后但同样重要的是，我们将实现我们的订户类。正如我们之前所说的，<code class="fe ls lt lu lv b">subscriber</code>只负责处理新的输入值，完成事件，并请求它应该接收多少个事件。</p><p id="5cb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建一个新的自定义类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="cce6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们做了什么？</p><p id="9f13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们创建了一个新的<code class="fe ls lt lu lv b">HoldValueSubscriber</code>类型，将它的相关值定义为与发布者相同:一个<code class="fe ls lt lu lv b">Int</code>作为输入，一个<code class="fe ls lt lu lv b">Never</code>作为失败，因为它不期望任何错误。</p><p id="78b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看接口方法:</p><ol class=""><li id="ccce" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr nn no np nq bi translated"><code class="fe ls lt lu lv b">.receive(Subscription)</code>:正如我们之前看到的，它是从发布者端调用的，并通过传递一个需求对象向<code class="fe ls lt lu lv b">Subscription</code>发送一个新请求。因为它只需要三个值，所以我们在需求中最多设置三个值。最后，为了保持我们的订阅有效，它被保存在<code class="fe ls lt lu lv b">cancellables</code>集合中。</li><li id="f8d1" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated"><code class="fe ls lt lu lv b">receive(Input)</code>:这个方法是从订阅方调用的，它只是向订阅方发送一个新的输入值。我们通过打印值来处理这个问题。返回的需求是一个值，它增加了订阅类中的需求。由于我们不希望它增加，我们返回一个<code class="fe ls lt lu lv b">none</code>，它与<code class="fe ls lt lu lv b">max(0)</code>相同</li><li id="edb9" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated"><code class="fe ls lt lu lv b">receive(Completion)</code>:这个方法也是从订阅方调用的，它发送一个完成对象，通知我们的订阅方，订阅已经结束，我们的订阅已经完成。它只是打印完成事件</li></ol><h1 id="80d0" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">使发布者可以通过其原始类进行访问</h1><p id="29fd" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们创建了一个服务于<code class="fe ls lt lu lv b">HoldValue</code>类的发布者。这是我们真正想听的课。</p><p id="d9ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了像大多数联合发行商那样从<code class="fe ls lt lu lv b">HoldValue</code> origin类访问它，实现这个Swift扩展:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2307" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果您想进行订阅，只需从<code class="fe ls lt lu lv b">HoldValue</code>实例访问<code class="fe ls lt lu lv b">publisher</code>即可。</p><h1 id="4be4" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">测试我们的订阅</h1><p id="620c" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">现在我们已经创建了三个组合定制类型，让我们测试这个订阅:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3b06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在做什么？我们为<code class="fe ls lt lu lv b">HoldValue</code>创建了一个新的实例，一个新的<code class="fe ls lt lu lv b">HoldValue</code> <code class="fe ls lt lu lv b">subscriber</code>，并让它订阅我们的实例<code class="fe ls lt lu lv b">publisher</code>。这建立了我们之前看到的管道:<code class="fe ls lt lu lv b">publisher</code>在内部创建一个新的<code class="fe ls lt lu lv b">subscription</code>，将其发送给订户，订户向订阅请求一个需求，现在它准备好接收新的输入(来自<code class="fe ls lt lu lv b">publisher</code>的输出)。</p><p id="f326" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在遍历从0到9的整数，并将我们的<code class="fe ls lt lu lv b">holdValue</code>值更新到每个数字。当我们在订户中打印每个输入值时，请看一下控制台:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9daa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它按照要求接收三个值，之后，<code class="fe ls lt lu lv b">subscription</code>向<code class="fe ls lt lu lv b">subscriber</code>发送一个完成事件，该事件也被打印出来。</p><h1 id="9348" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="bf8a" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">现在，您完全理解了联合订阅的管道。您知道我们的<code class="fe ls lt lu lv b"><strong class="ky ir">publisher</strong></code>负责在被请求时向<code class="fe ls lt lu lv b"><strong class="ky ir">subscriber</strong></code>发送新的订阅，您知道我们的<code class="fe ls lt lu lv b"><strong class="ky ir">subscriber</strong></code>实际上定义了自己的需求，并且<code class="fe ls lt lu lv b"><strong class="ky ir">subscription</strong></code>实现了使<code class="fe ls lt lu lv b"><strong class="ky ir">subscriber</strong></code>接收完成的逻辑。</p><p id="9e7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们之前谈到的，Apple不建议我们实现发布者和订阅，因为逻辑错误可能会破坏发布者和订阅者之间的所有连接，这可能会导致意想不到的结果。</p><p id="5c73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是理解Combine框架如何工作是很重要的，我真的希望你喜欢这篇文章；)</p></div></div>    
</body>
</html>