<html>
<head>
<title>Benchmarking Command Line Tools Against a Custom Go Line Remover</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">根据自定义的Go Line Remover对命令行工具进行基准测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/benchmarking-command-line-tools-7d00ed4813cc?source=collection_archive---------12-----------------------#2022-08-23">https://betterprogramming.pub/benchmarking-command-line-tools-7d00ed4813cc?source=collection_archive---------12-----------------------#2022-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ab80" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">测试一个内置的文本过滤器违背了屡试不爽的grep</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/69858521dacd29dc13927dfa684186d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VGTegLiM1vnbN1OKypOYGw.jpeg"/></div></div></figure><p id="5fd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本系列的第四部分(也是最后一部分),我们将介绍如何针对grep中的一个等价命令对我们的自定义Go line remover进行基准测试。您可以在下面找到其他部分:</p><ul class=""><li id="9b76" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-a-text-filtering-log-simplifying-tool-in-go-b29d3067e092">第1部分:在Go中构建文本过滤工具</a></li><li id="3dc9" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://medium.com/@gourikabang1996/part-2-how-to-prepare-for-your-next-coding-interview-d048b188301e" rel="noopener">第2部分:添加正则表达式支持</a></li><li id="eabc" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/benchmarking-in-go-substrings-vs-regular-expressions-a84de7f0eb02">第3部分:在Go中对程序进行基准测试</a></li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="00af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在前三段中，我们在Go中构建了一个工具，可以从文件中删除匹配的行。然后我们添加了正则表达式支持，最后使用内置的Go基准测试比较了两种方法的性能。现在，我们想要测量它在grep中针对反向字符串匹配(<code class="fe mj mk ml mm b">-v</code>或<code class="fe mj mk ml mm b">--invert-match</code>)的性能。</p><p id="f75c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用<a class="ae lw" href="https://formulae.brew.sh/formula/hyperfine" rel="noopener ugc nofollow" target="_blank"> hyperfine </a>进行基准测试，因为它是一个排名很高的工具，也可以通过我的机器(苹果芯片的MacBook)的自制程序获得。还有各种其他工具(例如<a class="ae lw" href="https://formulae.brew.sh/formula/bench" rel="noopener ugc nofollow" target="_blank">工作台</a>)可能更适合您的需求和架构。</p><p id="e454" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将比较我们在第3部分中看到的相同的三个测试用例(如下所述),但是输入文本要大得多，以查看工具在需要做更多工作的情况下如何执行。</p><h1 id="8ba1" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">设置</h1><p id="c621" class="pw-post-body-paragraph kr ks iq kt b ku nf jr kw kx ng ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">公平的比较需要良好的设置。为此，我们将针对grep对Go工具进行基准测试，做三件事:</p><ul class=""><li id="f43e" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">将文件加载到grep</li><li id="aa60" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">在grep中进行反向匹配</li><li id="3c11" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated">将反向匹配的结果写入文件</li></ul><p id="5865" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用以下版本的grep:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="06eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Grep命令将采用以下格式:</p><p id="4669" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mj mk ml mm b">grep "&lt;pattern&gt;" &lt;filepath&gt; &gt; &lt;output filepath&gt;</code></p><p id="5ea5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Lineremover命令将采用以下格式:</p><p id="626e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mj mk ml mm b">./lineremover -file="path/to/file" -keys="keys if testing substring search" -pattern="pattern if testing regular expression search"</code></p><p id="7122" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以按照以下方式运行基准测试:</p><p id="636c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mj mk ml mm b">hyperfine '&lt;command to benchmark&gt;' --min-runs=10000</code></p><p id="30e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其中<code class="fe mj mk ml mm b">'&lt;command to benchmark&gt;'</code>将如上运行grep或lineremover。为了保持一致性，并确保我们有足够的数据进行推断，我们将使用hyperfine的<code class="fe mj mk ml mm b">--min-runs</code>选项来确保每个测试至少执行10，000次。我们还需要意识到在执行基准测试的机器上运行的是什么——如果它在一个测试期间相对于另一个测试变慢了，基准测试可以显示出来。考虑到这一点，我们将尽可能地让机器在测试中保持相同的状态，尽可能减少后台进程的运行。</p><p id="3471" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将测试来自<a class="ae lw" href="https://github.com/swayne275/lineremover" rel="noopener ugc nofollow" target="_blank">拆线器报告</a>的<code class="fe mj mk ml mm b">example/inputlong.txt</code>。这个文件本质上与<code class="fe mj mk ml mm b">example/input.txt</code>相同，但是重复了2048次，因此相对于实际的字符串搜索工作，程序开始/停止时间对我们的基准测试结果影响较小。</p><h1 id="9583" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">运行基准测试</h1><h2 id="bb28" class="nm mo iq bd mp nn no dn mt np nq dp mx la nr ns mz le nt nu nb li nv nw nd nx bi translated">基准匹配“你好”</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2382" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，对于grep，我们告诉hyperfine忽略错误(<code class="fe mj mk ml mm b">-i</code>)，因为grep会在不匹配的情况下给出一个非零退出代码(这是本测试所期望的)。</p><p id="42a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们可以看到grep在这个测试中快了很多——这是一种预期的结果，因为它是这个领域的标准，并且<a class="ae lw" href="https://www.google.com/search?client=safari&amp;rls=en&amp;q=when+was+grep+invented&amp;ie=UTF-8&amp;oe=UTF-8" rel="noopener ugc nofollow" target="_blank">自1974年</a>以来就一直存在。在<code class="fe mj mk ml mm b">lineremover</code>工具中，我们可以看到模式匹配也比子串搜索慢一些。运行之间也有相当多的变化。</p><h2 id="be8e" class="nm mo iq bd mp nn no dn mt np nq dp mx la nr ns mz le nt nu nb li nv nw nd nx bi translated">基准匹配“大”</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="66fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，我们看到grep是最慢的——这不是我所期望的！我们还可以看到，模式匹配比子串搜索略快，但这可能并不重要，而且变化也稍多。</p><h2 id="970d" class="nm mo iq bd mp nn no dn mt np nq dp mx la nr ns mz le nt nu nb li nv nw nd nx bi translated">基准匹配“大”、“亮”、“弯”、“亮”</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b42b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">随着查询变得越来越复杂，我们可以看到，与子串搜索相比，模式匹配的速度明显变慢了。这里我们再次看到，在模式匹配和子串搜索模式下，grep都明显比<code class="fe mj mk ml mm b">lineremover</code>慢。它也有更多的变化。又是一个意想不到的结果！</p><h1 id="acf5" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">包扎</h1><p id="ad96" class="pw-post-body-paragraph kr ks iq kt b ku nf jr kw kx ng ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">今天，我们学习了对两个命令行工具进行基准测试的机制，并设置了一些测试，这些测试可能合理地代表了这些工具在现实世界中的使用情况。然而，基准测试时真正有价值的工作是找出<em class="ny">要基准测试什么</em>，而不一定是如何运行测试。哪些测试会让你相信某个工具对你的工作负载来说更快<em class="ny">或者使用cas </em> e？这是设计测试时需要回答的最重要的问题。只有这样，我们才能设计一个环境来回答这个问题。</p><p id="f16e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就这个测试而言，它很有趣！这是我第一次使用超精细，所以这很酷。在这个工具中，我期望模式匹配比子串搜索慢，但是没有期望我们构建的Go工具在某些搜索条件下优于grep。我还不确定<em class="ny">为什么</em> grep变慢了，但一个猜测是读取输入文件和写入输出文件不如在Go中使用缓冲IO时优化了？我也认为可能是一些操作系统的东西(比如缓存)在起作用，但是我一个接一个地以不同的顺序运行测试，每次都得到相似的结果。如果你有想法，请告诉我！</p></div></div>    
</body>
</html>