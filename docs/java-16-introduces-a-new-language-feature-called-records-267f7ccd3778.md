# Java 记录的深入指南

> 原文：<https://betterprogramming.pub/java-16-introduces-a-new-language-feature-called-records-267f7ccd3778>

## Java 16 引入了一个新的语言特性，叫做**记录**。记录已经是 Java 14 和 15 的一部分，但仍在预览版中。

![](img/ba3deafa9be065de5281429e8b607d80.png)

照片由 [Shamsudeen Adedokun](https://unsplash.com/@shams_ad?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

# 什么是记录？

记录是定义不可变数据类的一种新型声明。

它被用来代替类，并允许避免创建`hashCode()`、`equals()`、`toString()`、getters 和 constructor 的常规仪式。

对于熟悉 Scala 的人来说——它类似于 case 类，对于熟悉 Project Lombok 的人来说，它非常类似于`@Data`注释。它允许使用紧凑的语法来提高开发人员的生产力！

这样一个简单的例子:

使用记录语法变成一行程序:

```
record Person(int age, int height) {}
```

而且是的，你不能避免结尾的花括号！

# 记录真的有必要吗？

由于我们长期以来习惯于创建数据类，我们大多数人习惯于利用最喜欢的 IDE 的全部功能来创建所有这些类，即使如果您知道所有的快捷方式，这并不困难，但它会大大降低可读性。

明显记录优势的总结:

*   自动生成的公共构造函数
*   私有不可变(即`final`)字段
*   自动生成的`hashCode()`、`equals()`和`toString()`
*   自动生成的 getter——对于上面的`Person`类示例，相应地应该是`age()`和`height()`。

尽管对任何现代 IDE 记录的完全支持似乎有点过时，但它们不仅大大增加了可读性，提高了开发人员的性能，而且更重要的是防止了添加新字段后的简单错误。对于 IDE 生成的方法，如`hashCode()`、`equals()`、`toString()`，我们必须手动更改它们或重新生成它们，以便包含新的字段。这就成了一个大难题。

在介绍了记录的基础知识之后，让我们来仔细看看更高级的用法。

# **建造师**

默认情况下，记录带有一个初始化所有字段的构造函数，称为规范构造函数。自定义行为可以通过使用紧凑的构造函数传递给此构造函数，如下例所示:

例如，紧凑构造函数可用于验证字段——只能抛出 ***未选中的*** 异常，而不能通过添加`throws`声明来声明 ***已选中的*** 异常。

也可以创建自定义构造函数，但是非规范构造函数总是必须委托给另一个构造函数。一个简单的例子如下:

因为 Java 要求调用`this()`作为第一条语句，所以被覆盖的构造函数的用例非常有限——传递默认值就是其中之一。

请记住，紧凑构造函数只是一种语法糖，您仍然可以使用旧的方式为所有字段指定构造函数:

我无法想象这种应用，但我想涵盖所有的目的，让事情变得非常清楚，什么是可能的，什么是不可能的:-)

# hashCode()，`equals()`和 toString()

我在开始时已经提到，现在自动生成`hashCode()`、`equals()`和`toString()`方法听起来没什么大不了的。使用 IDE 的全部功能应该会使这变得简单明了。

然而，首先必须实现这三种方法有几个缺点:

*   降低代码可读性——一个类的字段越多，方法就必须越长
*   代码容易出错——很容易遗漏某个字段，尤其是在重构和向类中添加新字段时。如果方法没有重新生成，字段将会丢失，并且可能会引入一个 bug。
*   代码审查很难——您曾经尝试过审查这些方法吗？你有没有一行一行地检查它们，确保没有遗漏任何一个字段？

当然，这些方法可以被覆盖，并且可以提供自定义行为，如下例所示:

# **不变性**

正如本文开头提到的——记录中的所有字段都是`final`,这意味着它们不能被修改。但是，可以在紧凑构造函数中修改字段:

但是你不能用`this`来引用它们，下面的代码也不会被编译:

因为记录一旦创建就不可改变，所以不能修改。

没有设置器，因为字段是最终的，所以不能创建设置器。

唯一的方法是创建一个新对象:

```
Person john = new Person(18, 178);
Person jack = new Person(john.age(), 180);
```

# **实例方法和字段**

记录允许带有自定义行为的实例方法，我非常鼓励实现带有行为的类。

紧凑构造函数中的验证是自定义行为的一个示例。

但是，最好通过实现实例方法来表达行为，如下例所示:

不允许记录定义之外的实例字段，以下代码将不起作用:

所有实例字段都必须在标题中指定为组件:

# **字段可见性**

记录有一个很大的缺点——每个字段都会创建一个公共 getter。

这当然是有意义的，因为我们在构造函数中提供了它们，但是它使得记录在一定程度上集中于数据而不是行为。

您没有将字段设为私有的选择，以下代码将无法编译:

```
record Person(private int age, int height) {}
```

为了比较——在 Scala case 中，类允许指定自定义的访问修饰符。

# **序列化**

记录非常适合序列化和反序列化。放弃对`serialVersionUUID` 的要求。

需要注意的是，记录的序列化不同于普通的可序列化或可外部化的对象。

记录的序列化不能被定制，任何特定于类的`writeObject`、`readObject`、`readObjectNoData`、`writeExternal`和`readExternal`方法在序列化和反序列化期间都将被忽略。

# **静态字段和方法**

类似地，Java 记录中的每个其他类都允许静态(类)方法和字段:

# **继承**

记录类是 Java 世界中的特殊公民。为了更好地理解它，让我们分析一下反汇编的`Person.java` 代码:

```
record Person(int age, int height) {}
```

运行后:

```
javap Person
```

您应该会看到以下输出:

记录类是`final`，所以它们不能被扩展。

记录也扩展了`java.lang.Record`，因为 Java 不允许多重继承，所以它们不能扩展任何类或抽象类。

实现接口是可能的:

我在之前的文章[中对 Java 17](/6-things-i-didnt-know-about-java-17-dccd36abaa06) 做了更深入的介绍。感谢阅读。