<html>
<head>
<title>Build a Netflix API Miner With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python构建网飞API挖掘器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-netflix-api-miner-with-python-162f74d4b0df?source=collection_archive---------5-----------------------#2021-05-05">https://betterprogramming.pub/build-a-netflix-api-miner-with-python-162f74d4b0df?source=collection_archive---------5-----------------------#2021-05-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="30d7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个命令行应用程序检索网飞显示信息</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ea719240fa45687e08d11605aec6b8ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gz6L4SOpTAoCZpxvZp1vzw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用来自<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/www.flaticon.com"> Flaticon </a>的<a class="ae ky" href="https://www.flaticon.com/authors/pixel-perfect" rel="noopener ugc nofollow" target="_blank"> Pixel perfect </a>、<a class="ae ky" href="https://smashicons.com/" rel="noopener ugc nofollow" target="_blank"> Smashicons </a>和<a class="ae ky" href="https://www.freepik.com" rel="noopener ugc nofollow" target="_blank"> Freepik </a>的资产创建</p></figure><p id="8c77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我目前正在开发一个Android应用程序，它可以随机选择一个在网飞上观看的节目。为此，我需要获得最新的演出信息。虽然网飞本身没有提供官方的公共API，但unogsNG提供了次好的东西，它同时提供了一个<a class="ae ky" href="http://unogs.com/" rel="noopener ugc nofollow" target="_blank">网站</a>和一个<a class="ae ky" href="https://rapidapi.com/unogs/api/unogsng/" rel="noopener ugc nofollow" target="_blank"> API服务</a>。</p><p id="d765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初的想法是，每当用户需要随机挑选节目时，就发出一个API请求。然而，当我了解到你每天只能收到100个免费请求，超过这个数量就要收费，我意识到我需要改变策略了。</p><p id="8f98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想到的是一个Python脚本，它在不超过每日配额的情况下连续查询API服务，然后休眠，直到配额被重置。重复这一过程，直到检索到所有的演出信息。然后，应用程序将使用本地存储的信息，而不是使用实时数据。</p><h1 id="34b2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">算法</h1><p id="fab0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了编写脚本，我需要准确理解API服务是如何运行的。以下是要点:</p><ul class=""><li id="c038" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">每天100个免费请求</li><li id="0a15" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">每个请求最多100个结果</li><li id="35bf" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">订阅API服务时重置每日配额</li><li id="a378" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">每个响应都包含一个标头，显示剩余的空闲请求数</li></ul><p id="2332" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些信息，算法可以如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/b2ee80edb3b7d434af6a2adc83a909b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aH4B4VrKKXLnzi8sbHrLkw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示矿工操作的流程图</p></figure><h1 id="7f8f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">组件和依赖关系</h1><p id="8832" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个程序可以分成三个部分。首先是主入口点，它涉及负责API请求、数据存储、使用监控等的逻辑。这里，我们将依赖于<a class="ae ky" href="https://github.com/psf/requests" rel="noopener ugc nofollow" target="_blank">请求</a>，一个简单的HTTP库，用于与API服务通信。</p><p id="7401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个组成部分涉及调度上述逻辑的执行。这实质上意味着设置配额重置时间，并在发出新的一批请求之前等待，或者如果用户将初始一批请求设置为在某个时间触发，则等待。为此，我们将依赖于<a class="ae ky" href="https://github.com/dbader/schedule" rel="noopener ugc nofollow" target="_blank"> schedule </a>，一个易于使用的作业调度库。</p><p id="737d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，最后一个组件涉及命令行界面(CLI)的逻辑，我们将通过它来执行程序。这里将使用Python的内置<a class="ae ky" href="https://docs.python.org/3/library/argparse.html" rel="noopener ugc nofollow" target="_blank"> argparse </a>库，因为它具有强大而简单的特性。在定义命令行参数时，这将给我们带来很大的灵活性。</p><h1 id="ac0e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Miner实现</h1><p id="9f80" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">说完这些，让我们首先来看看主入口点的代码，并浏览一遍。为了清楚起见，我把它分成了几个部分，但是整个文件可以在这里找到。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">导入、CLI初始化和全局变量</p></figure><p id="f514" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们来看看进口。或许除了<code class="fe nj nk nl nm b">_cli</code>之外，这些都很简单。<code class="fe nj nk nl nm b">_cli</code>是包含命令行界面逻辑的模块。我们通过在第<code class="fe nj nk nl nm b">9</code>行调用<code class="fe nj nk nl nm b">init_cli()</code>来初始化它，它返回一个包含我们为参数传递的值的对象。命令行界面接受三个可选参数:<code class="fe nj nk nl nm b">buffer</code>、<code class="fe nj nk nl nm b">offset</code>和<code class="fe nj nk nl nm b">exec_time</code>。</p><p id="1707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">buffer</code>允许我们从每日配额中指定未使用的请求数量。<code class="fe nj nk nl nm b">offset</code>允许我们指定从哪个索引开始检索结果。例如，偏移量100表示从第100个节目开始。然而，在大多数情况下，人们会从偏移量0开始，因此，这是默认值。最后，<code class="fe nj nk nl nm b">exec_time</code>是脚本应该实际开始运行的时间。命令行界面的代码将在后面的<a class="ae ky" href="#b056" rel="noopener ugc nofollow">中详细讨论。</a></p><p id="d49a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">remaining_quota</code>是我们跟踪剩余的空闲请求数量的地方。它被初始化为一个高于缓冲区的值，这样第一个请求就不会失败。在执行脚本之前，您需要确保至少还有一个自由请求。其原因将在<a class="ae ky" href="#8e2e" rel="noopener ugc nofollow">位</a>中变得清楚。</p><p id="37fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">done</code>向程序发出停止信号，如果满足终止条件，则设置为真。也就是说，如果请求失败或者没有更多数据可用。最后，<code class="fe nj nk nl nm b">data</code>存储收集的演出信息以及收集的演出总数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">API请求变量</p></figure><p id="6a71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们定义端点的URL、特定的查询和一些头。注意，你需要提供你自己的API密匙，一旦你注册了就可以使用。这里使用的查询很简单:只检索带有英文字幕的节目，并按添加的日期对结果进行排序。</p><p id="69e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在问题的实质来了。这是发出请求并存储其结果的地方，直到每日配额(考虑缓冲区)用尽。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">主要执行任务</p></figure><p id="7bf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次请求之前，我们都会检查我们是否仍在每日限额内。然后将当前偏移量附加到查询中，并发出请求。如果请求成功，我们用相应的响应头值更新剩余配额。</p><p id="cb7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不包含<code class="fe nj nk nl nm b">results</code>属性的响应是我们的线索，没有更多的结果要检索。因此，我们在第12行检查这一点，如果不是这样，我们在将偏移量增加100以准备下一个请求之前，将检索到的节目附加到<code class="fe nj nk nl nm b">data</code>。最后，更新显示计数，并将结果写入JSON文件。</p><p id="3c3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对<code class="fe nj nk nl nm b">global</code>关键字感到疑惑，例如第3行的<code class="fe nj nk nl nm b">global offset</code>，它用来向解释器发出信号，当我们给它赋值时，我们并没有创建一个新的名为<code class="fe nj nk nl nm b">offset</code>的局部变量，而是简单地给已经存在的同名全局变量赋值。</p><p id="8e2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得我说过在执行脚本之前需要确保至少还有一个自由请求吗？这是因为，正如您在上面所看到的，至少有一个请求总是被发出——不管您实际上是否还有空闲的请求。这有点像先有鸡还是先有蛋的情况:你需要一个请求来知道还有多少自由请求。当然，最好的做法是在执行脚本之前通过在线平台检查您的使用情况。但是，如果您忘记了这样做，并且在重置时间之前错误地再次运行了脚本，那么设置缓冲区就派上了用场，因为缓冲区更有可能使未使用的空闲请求仍然存在。</p><p id="5bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但并非最不重要的一点，我们来看看日程安排。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">任务计划程序</p></figure><p id="e589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先检查用户通过命令行指定的执行时间。<code class="fe nj nk nl nm b">now</code>将触发立即执行，并将安排脚本每天在开始时定义的默认时间唤醒。如果指定了一个特定的时间，而不是<code class="fe nj nk nl nm b">now</code>，任务将被安排在每天的那个时间，程序将一直休眠到那个时间。</p><p id="fee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第<code class="fe nj nk nl nm b">3</code>行上的检查是为了确保在第一次调用<code class="fe nj nk nl nm b">job()</code>期间，如果终止条件之一已经满足，则没有任务被调度。</p><p id="c14f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">while循环一直运行，直到满足终止条件。在它里面，在第<code class="fe nj nk nl nm b">12</code>行，直到下一个预定任务的时间被确定，程序一直休眠到那时。一旦达到该时间，剩余配额将被重置，任务将再次执行。</p><h1 id="b056" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">CLI实施</h1><p id="4078" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">与所有这些相比，命令行界面的代码相对简单。同样，为了清楚起见，我把它分成了两个部分，但是整个文件可以在<a class="ae ky" href="https://gist.github.com/osharaki/763b4c1b303b7d762c9fe6aff5bb56e7" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="b06d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先定义三个类型检查函数，每个函数对应一个命令行参数(CLAs)。这些函数根据我们定义的一些规则验证我们提供的参数，并在参数不符合时引发异常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">CLI类型函数</p></figure><p id="c1e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上到下，<code class="fe nj nk nl nm b">buffer_type</code>确保为缓冲区提供的值是一个介于0(即用尽所有可用请求)和100(即不发出任何请求)之间的整数。</p><p id="aab6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">time_type</code>确保提供的执行时间是一个字符串，其值为<code class="fe nj nk nl nm b">now</code>或24小时制的小时后跟分钟(即HH:mm)</p><p id="1c39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe nj nk nl nm b">offset_type</code>确保偏移量是100的非负倍数。</p><p id="c310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建参数，我们定义了<code class="fe nj nk nl nm b">init_cli()</code>，其中我们为每个CLA调用<code class="fe nj nk nl nm b">add_argument()</code>一次，每次传递适当的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">CLI参数</p></figure><p id="caf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">add_argument()</code>将CLA的名称作为第一个参数。这里我们分别用<code class="fe nj nk nl nm b">-b</code>、<code class="fe nj nk nl nm b">-t</code>和<code class="fe nj nk nl nm b">-o</code>表示缓冲区、执行时间和偏移量。</p><p id="500c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b"><a class="ae ky" href="https://docs.python.org/3/library/argparse.html#dest" rel="noopener ugc nofollow" target="_blank">dest</a></code>是代表<code class="fe nj nk nl nm b"><a class="ae ky" href="https://docs.python.org/3/library/argparse.html#argparse.Namespace" rel="noopener ugc nofollow" target="_blank">Namespace</a></code> <a class="ae ky" href="https://docs.python.org/3/library/argparse.html#argparse.Namespace" rel="noopener ugc nofollow" target="_blank">对象</a>中CLA的属性名，由<code class="fe nj nk nl nm b">parser.<a class="ae ky" href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.parse_args" rel="noopener ugc nofollow" target="_blank">parse_args()</a></code>返回。当我们访问这个类的时候，我们一开始就看到了这一点。比如<code class="fe nj nk nl nm b">args.offset</code>。这里，<code class="fe nj nk nl nm b">args</code>包含了<code class="fe nj nk nl nm b">Namespace</code>对象，<code class="fe nj nk nl nm b">offset</code>是通过<code class="fe nj nk nl nm b">dest="offset"</code>赋予属性的名称。</p><p id="997b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续，<code class="fe nj nk nl nm b"><a class="ae ky" href="https://docs.python.org/3/library/argparse.html#type" rel="noopener ugc nofollow" target="_blank">type</a></code>确定由指定类型指定的CLA的有效性。这种类型可以是内置类型或函数，也可以是用户定义的函数，就像我们程序中的情况一样。</p><p id="62eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们的类是可选的，如名字中的前导<code class="fe nj nk nl nm b">-</code>所示，例如<code class="fe nj nk nl nm b">-t</code>，我们利用<code class="fe nj nk nl nm b"><a class="ae ky" href="https://docs.python.org/3/library/argparse.html#default" rel="noopener ugc nofollow" target="_blank">default</a></code>为它们设置默认值，以防它们被省略。</p><p id="31ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nj nk nl nm b"><a class="ae ky" href="https://docs.python.org/3/library/argparse.html#help" rel="noopener ugc nofollow" target="_blank">help</a></code>中，我们提供了一个CLA的简要描述，该描述在程序使用<code class="fe nj nk nl nm b">-h</code>选项运行时显示。</p><p id="ab24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe nj nk nl nm b"><a class="ae ky" href="https://docs.python.org/3/library/argparse.html#metavar" rel="noopener ugc nofollow" target="_blank">metavar</a></code>允许我们为类指定简短的描述符或替代名称。这些然后被用来在帮助消息中引用单独的类。例如，如果没有为偏移量指定一个<code class="fe nj nk nl nm b">metavar</code>值，那么在程序生成的帮助消息中，它将被简单地称为<code class="fe nj nk nl nm b">[-t T]</code>。通过指定<code class="fe nj nk nl nm b">metavar="now|HH:mm"</code>，它被描述为<code class="fe nj nk nl nm b">[-t now|HH:mm]</code>。</p><p id="f3d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">综上所述，假设入口点被命名为<em class="nn"> unogs_miner.py </em>，程序现在可以运行，例如，使用:</p><p id="2b59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">python unogs_miner.py -t now -b 5 -o 500</code></p><h1 id="ef84" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结束语</h1><p id="6d81" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">事实证明，目前数据库中有近12，000个节目，这意味着需要120次请求(或每天100次请求，两天)才能检索到所有节目。我最初设计这个程序是为了不停地运行我的Raspberry Pi(它正在收集架子上的灰尘),直到检索到所有结果。可以理解的是，如果你没有树莓派，也不想让电脑连续运行两天，你可以这么做。</p><p id="6aee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需从代码中删除调度部分。现在，程序不是休眠，而是在达到每日限额时终止。重置配额后，您可以手动重新运行它。但是，您需要添加一条语句来跟踪最后到达的偏移量，并在下次运行脚本时将其作为参数传递，以便它从该点开始检索结果。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="e6ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢你留下来！一如既往，我很乐意听到你的想法，并回答你可能有的任何问题。</p><h1 id="5c13" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">资源</h1><ul class=""><li id="be0e" class="ms mt it lb b lc mn lf mo li nv lm nw lq nx lu mx my mz na bi translated"><a class="ae ky" href="https://realpython.com/python-requests/" rel="noopener ugc nofollow" target="_blank"> Python的请求库(指南)|真正的Python </a></li><li id="fc41" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://realpython.com/python-json/" rel="noopener ugc nofollow" target="_blank">在Python | Real Python中使用JSON数据</a></li><li id="6d2a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://docs.python.org/3/library/argparse.html" rel="noopener ugc nofollow" target="_blank"> argparse | Python文档</a></li><li id="6395" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://github.com/dbader/schedule" rel="noopener ugc nofollow" target="_blank">日程| GitHub </a></li><li id="5563" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://github.com/psf/requests" rel="noopener ugc nofollow" target="_blank">请求| GitHub </a></li></ul></div></div>    
</body>
</html>