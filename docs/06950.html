<html>
<head>
<title>Learn Solidity: Variables (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习可靠性:变量(第三部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-solidity-variables-part-3-3b02ca71cf06?source=collection_archive---------7-----------------------#2020-11-19">https://betterprogramming.pub/learn-solidity-variables-part-3-3b02ca71cf06?source=collection_archive---------7-----------------------#2020-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="821a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">引用类型，应该显式指定数据位置</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/11a8df45afa00c73e733f96f3b02dcc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WaPpl2kio-6mamEPg3hXWA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@jannerboy62?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">缺口缺口</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">缺口</a>上拍摄</p></figure><p id="98ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎阅读学习可靠性系列的另一篇文章。在<a class="ae kv" href="https://medium.com/better-programming/learn-solidity-variables-part-2-f3b842f5bfb8" rel="noopener">上一篇文章</a>中，我们已经看到了数据位置是如何工作的，以及何时可以使用三个位置:<code class="fe ls lt lu lv b">memory</code>、<code class="fe ls lt lu lv b">storage</code>和<code class="fe ls lt lu lv b">calldata</code>。</p><p id="728f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我们将继续我们学习固体变量的旅程。这一次我们将关注引用类型，正如我们在以前的文章中提到的，引用类型应该显式地指定数据位置。我们还将看到如何定义映射、枚举和常量。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="4cac" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">数组</h1><p id="71f5" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在<a class="ae kv" href="https://docs.soliditylang.org/en/v0.7.4/" rel="noopener ugc nofollow" target="_blank"> Solidity </a>中，我们有两种类型的数组:存储数组和内存数组。</p><h2 id="b863" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">存储阵列</h2><p id="8f99" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">这些数组被声明为状态变量，可以有固定或动态长度。</p><p id="1392" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">具有动态长度的存储数组可以调整大小，这意味着它们可以访问<code class="fe ls lt lu lv b">push()</code>和<code class="fe ls lt lu lv b">pop()</code>方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="1bc4" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">存储器阵列</h2><p id="c915" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">这些数组用<code class="fe ls lt lu lv b">memory</code>作为它们的数据位置来声明。它们也可以有固定或动态的长度，但是动态大小的内存数组不能调整大小(即不能调用<code class="fe ls lt lu lv b">push()</code>和<code class="fe ls lt lu lv b">pop()</code>方法)；数组的大小必须事先计算好。</p><p id="42bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用关键字<code class="fe ls lt lu lv b">new</code>声明动态大小的内存数组，如下所示:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="ca1d" class="na me iq lv b gy ns nt l nu nv">Type[] memory a = new Type[](size)</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4d5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里要提到的另一点是，当你使用内存数组时，你要写这样的东西:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="a4fe" class="na me iq lv b gy ns nt l nu nv">uint256[] memory array;<br/>array[0] = 1;</span></pre><p id="6888" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你不会得到任何警告，但是你会得到一个无效的操作码，因为根据内存中<a class="ae kv" href="https://solidity.readthedocs.io/en/v0.7.4/internals/layout_in_memory.html" rel="noopener ugc nofollow" target="_blank">布局的描述<code class="fe ls lt lu lv b">array</code>将指向零槽，这是不应该被写入的。请记住，在使用数组之前，一定要对其进行初始化，这样才能获得有效的地址。</a></p><h2 id="61c0" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">数组切片</h2><p id="ee26" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">数组切片只能与<code class="fe ls lt lu lv b">calldata</code>数组一起使用，并被写入<code class="fe ls lt lu lv b">x[start:end]</code>。切片的第一个元素是<code class="fe ls lt lu lv b">x[start]</code>，最后一个元素是<code class="fe ls lt lu lv b">x[end - 1]</code>。</p><p id="0abb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">start</code>和<code class="fe ls lt lu lv b">end</code>都是可选的:<code class="fe ls lt lu lv b">start</code>默认为<code class="fe ls lt lu lv b">0</code>，<code class="fe ls lt lu lv b">end</code>默认为数组的长度。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="875d" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">特殊的动态大小数组</h1><ol class=""><li id="0f71" class="nw nx iq ky b kz mv lc mw lf ny lj nz ln oa lr ob oc od oe bi translated"><code class="fe ls lt lu lv b">byte[]</code>或<code class="fe ls lt lu lv b">bytes</code></li></ol><p id="7b9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些数组可以保存任意长度的原始字节数据。两者的区别在于<code class="fe ls lt lu lv b">byte[]</code>遵循数组类型的规则，而在<a class="ae kv" href="https://solidity.readthedocs.io/en/v0.7.4/internals/layout_in_memory.html#layout-in-memory" rel="noopener ugc nofollow" target="_blank">这部分文档中提到过，</a>Solidity中内存数组的元素总是占据32字节的倍数。这意味着如果一个元素小于32字节的倍数，它将被填充到合适的大小。</p><p id="54fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">byte</code>数组的情况下，这将为每个元素浪费31个字节，而对于<code class="fe ls lt lu lv b">bytes</code>或<code class="fe ls lt lu lv b">string</code>则不是这样。我要提醒你的是，从内存中读取或写入一个字(32字节)要花费3 gas，这就是为什么推荐使用<code class="fe ls lt lu lv b">bytes</code>而不是<code class="fe ls lt lu lv b">byte[]</code>的原因。</p><p id="8f66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<code class="fe ls lt lu lv b">string</code></p><p id="fa2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">string</code>是UTF-8数据的动态数组。与其他语言相反，<code class="fe ls lt lu lv b">string</code> in Solidity不提供获取字符串长度或执行两个字符串的连接或比较的函数(需要使用库)。<br/>使用<code class="fe ls lt lu lv b">bytes(&lt;string&gt;)</code>可以将一个字符串转换成一个字节数组。这将返回字符串的UTF-8表示的低级字节。</p><p id="8007" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注</strong>:一个字符可以编码成多个字节，这意味着字节数组的长度不一定是字符串的长度。</p><h2 id="46f1" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">字符串文字</h2><p id="0e77" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">参见<a class="ae kv" href="https://solidity.readthedocs.io/en/v0.7.4/types.html#string-literals-and-types" rel="noopener ugc nofollow" target="_blank">本部分文档</a>。</p><h2 id="a24c" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">字符串对<code class="fe ls lt lu lv b">bytes</code></h2><p id="7310" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">文档中的大多数例子都使用了<code class="fe ls lt lu lv b">bytes32</code>而不是<code class="fe ls lt lu lv b">string</code>，而且他们也明确表示，如果字符串的字节数有限，就使用值类型<code class="fe ls lt lu lv b">bytes1</code>到<code class="fe ls lt lu lv b">bytes32</code>，因为这样更便宜。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="3192" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结构</h1><p id="6ee4" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">与C和C++一样，结构允许您定义自己的类型，如下所示:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="cca7" class="na me iq lv b gy ns nt l nu nv">struct Donation {<br/>      uint256 value;<br/>      uint256 date;<br/>}</span></pre><p id="ab8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦你定义了你的结构，你就可以开始把它作为一个状态变量或者在你的函数中使用。</p><p id="e87a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了初始化一个结构，我们有两种方法:</p><ul class=""><li id="828f" class="nw nx iq ky b kz la lc ld lf of lj og ln oh lr oi oc od oe bi translated">使用位置参数:</li></ul><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="0c93" class="na me iq lv b gy ns nt l nu nv">Donation donation = Donation(<br/>msg.value,<br/>block.timestamp<br/>);</span></pre><ul class=""><li id="a29c" class="nw nx iq ky b kz la lc ld lf of lj og ln oh lr oi oc od oe bi translated">使用关键字:</li></ul><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="dd15" class="na me iq lv b gy ns nt l nu nv">Donation donation = Donation({<br/>value : msg.value,<br/>date: block.timestamp<br/>});</span></pre><p id="2d46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二种方法将避免我们必须记住结构成员的顺序，因此它可能比第一种方法更有用。</p><p id="3a87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用点号访问结构的成员:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="3341" class="na me iq lv b gy ns nt l nu nv">uint256 donationDate = myDonation.date;</span></pre><blockquote class="oj ok ol"><p id="aa04" class="kw kx om ky b kz la jr lb lc ld ju le on lg lh li oo lk ll lm op lo lp lq lr ij bi translated">尽管结构本身可以是映射成员的值类型，也可以包含其类型的动态大小数组，但结构不可能包含其自身类型的成员。这种限制是必要的，因为结构的大小必须是有限的。— <a class="ae kv" href="https://solidity.readthedocs.io/en/v0.7.4/types.html#structs" rel="noopener ugc nofollow" target="_blank">坚固性文件</a></p></blockquote></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="b0cc" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">映射</h1><p id="2616" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">您可以将映射想象成一个巨大的键/值存储库，其中存在所有可能的键，并且任何值都可以用键一次性设置或检索。</p><p id="7fa9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">映射声明如下:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="4af8" class="na me iq lv b gy ns nt l nu nv">mapping( KeyType =&gt; ValueType) VariableName</span></pre><p id="7767" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">KeyType</code>可以是任何内置值类型(我们在<a class="ae kv" href="https://medium.com/better-programming/learn-solidity-variables-part-1-657fc27c2cc1" rel="noopener">第1部分</a>中看到的类型)、字节或字符串，或者任何契约或枚举类型。<code class="fe ls lt lu lv b">ValueType</code>可以是任何类型，包括映射、数组和结构。</p><p id="c308" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里要提到的一个重要的事情是，唯一允许映射变量的数据位置是<code class="fe ls lt lu lv b">storage</code>，这意味着您只能将它们声明为状态变量、存储指针或库函数的参数。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="1f09" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">枚举</h1><p id="950a" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">枚举将允许您在自定义类型下对相关值进行分组，如下例所示:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="8cd4" class="na me iq lv b gy ns nt l nu nv">enum Color { green , blue, red }</span></pre><p id="d25a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用以下语法访问<code class="fe ls lt lu lv b">enum</code>值:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="c425" class="na me iq lv b gy ns nt l nu nv">Color defaultColor = Color.green;</span></pre><p id="344f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:枚举也可以在文件级声明，在契约或库定义之外。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="8f54" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">常量和不可变状态变量</h1><p id="c52c" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">状态变量可以声明为<code class="fe ls lt lu lv b">constant</code>或<code class="fe ls lt lu lv b">immutable</code>。在这两种情况下，都不能在构造了协定之后修改变量。对于<code class="fe ls lt lu lv b">constant</code>变量，该值必须在编译时固定，而对于<code class="fe ls lt lu lv b">immutable</code>，它仍然可以在构造时赋值。</p><p id="18d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编译器不会为这些变量保留存储槽，每次出现都会被相应的值替换。</p><p id="9a4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">常量使用关键字<code class="fe ls lt lu lv b">constant</code>声明:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="bd9a" class="na me iq lv b gy ns nt l nu nv">uint256 constant maxParticipants = 10;</span></pre><p id="df6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于不可变的状态变量，使用关键字<code class="fe ls lt lu lv b">immutable</code>声明它们:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="4b39" class="na me iq lv b gy ns nt l nu nv">contract C {<br/>      address immutable owner = msg.sender;<br/>      uint256 immutable maxBalance;<br/>    <br/>      constructor(uint256 _maxBalance){<br/>           maxBalance = _maxbalance;<br/>      }<br/>}</span></pre><p id="6c6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在文档的<a class="ae kv" href="https://solidity.readthedocs.io/en/v0.7.4/contracts.html#constant" rel="noopener ugc nofollow" target="_blank">部分找到更多关于常量和不可变状态变量的细节。</a></p><p id="dddb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:也可以在文件级定义<code class="fe ls lt lu lv b">constant</code>变量。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="dde5" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">delete关键字</h1><p id="5ea9" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">最后我想补充的是<code class="fe ls lt lu lv b">delete</code>在坚固性上的使用。<br/>用于将变量设置为初始值，这意味着该语句<code class="fe ls lt lu lv b">delete a</code>将表现如下:</p><ul class=""><li id="2560" class="nw nx iq ky b kz la lc ld lf of lj og ln oh lr oi oc od oe bi translated">对于整数，相当于<code class="fe ls lt lu lv b">a = 0</code>。</li><li id="70ab" class="nw nx iq ky b kz oq lc or lf os lj ot ln ou lr oi oc od oe bi translated">对于数组，它分配一个长度为零的动态数组或一个相同长度的静态数组，所有元素都设置为初始值。</li><li id="fe4d" class="nw nx iq ky b kz oq lc or lf os lj ot ln ou lr oi oc od oe bi translated"><code class="fe ls lt lu lv b">delete a[x]</code>删除数组索引<code class="fe ls lt lu lv b">x</code>处的项目，保留所有其他元素和数组长度不变。这尤其意味着它会在数组中留下一个间隙。</li><li id="92a2" class="nw nx iq ky b kz oq lc or lf os lj ot ln ou lr oi oc od oe bi translated">对于结构，它分配一个所有成员都重置的结构。</li><li id="7ce3" class="nw nx iq ky b kz oq lc or lf os lj ot ln ou lr oi oc od oe bi translated"><code class="fe ls lt lu lv b">delete</code>对映射没有影响(因为映射的关键字可能是任意的，通常是未知的)。</li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="3c02" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">练习时间:简单的Crud</h1><p id="9b3e" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在本练习中，我们将创建一个用于管理用户的合同。</p><p id="1a15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是说明:</p><ul class=""><li id="647f" class="nw nx iq ky b kz la lc ld lf of lj og ln oh lr oi oc od oe bi translated">创建一个新文件并添加一个名为Crud的契约。</li><li id="855a" class="nw nx iq ky b kz oq lc or lf os lj ot ln ou lr oi oc od oe bi translated">创建一个名为User的结构，其中包含用户的id和名称。</li><li id="f926" class="nw nx iq ky b kz oq lc or lf os lj ot ln ou lr oi oc od oe bi translated">添加两个状态变量并将其公开:1)用户的动态数组，以及2)每次我们创建新用户时都会递增的id。</li></ul><p id="eee1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步是创建crud函数，但是因为我没有向您介绍Solidity函数，所以我将向您提供声明函数的语法。在下一篇文章中，我们将对它们进行详细的讨论:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="b397" class="na me iq lv b gy ns nt l nu nv">function function_name(&lt;param_type&gt; &lt;param_name&gt;) &lt;visibility&gt; &lt;state mutability&gt; [returns(&lt;return_type&gt;)]{ ... }</span></pre><p id="e7b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可见性可以是公共的、私有的、内部的、外部的。<br/>状态可变性可以是:查看、纯、应付。</p><p id="d710" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是您将创建的函数的描述。</p><h2 id="a39e" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">1.增加</h2><p id="ba74" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">可见性:公共<br/>状态可变性:空</p><p id="06d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数将用户名作为参数，创建一个具有新id的user实例(每次添加新用户时，id都会自动增加)，并将新创建的用户添加到数组中。</p><h2 id="3b6c" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">2.阅读</h2><p id="dec5" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">可见性:公共<br/>状态可变性:视图</p><p id="4a17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数获取要查找的用户id，如果找到则返回用户名，如果没有找到则返回事务(稍后将详细介绍异常处理)。</p><h2 id="eeff" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">3.更新</h2><p id="d9ec" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">可见性:公共<br/>状态可变性:空</p><p id="c2be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数将获取用户的id和一个新名称，如果找到相应的用户，则更新该用户，如果该用户不存在，则恢复交易。</p><h2 id="0aa0" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">4.破坏</h2><p id="555d" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">可见性:公共<br/>状态可变性:空</p><p id="99bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数获取要删除的用户的id，如果找到了就从数组中删除，如果用户不存在就恢复事务。</p><p id="baa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提示:因为最后三个函数都需要查找用户，所以您需要创建一个私有函数，该函数将获取用户的id，如果找到了，就返回它们在数组中的索引，以避免重复相同的代码。</p><p id="2b76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你完成后，你可以在GitHub 上找到解决方案<a class="ae kv" href="https://gist.github.com/wissalHaji/94c8a5f356cb6f8da02702cc58584bd9" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="1313" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们对变量的讨论到此结束。下一次我们将会看到函数以及如何在Solidity中使用它们，所以如果你想了解更多，请继续关注即将到来的文章。</p></div></div>    
</body>
</html>