<html>
<head>
<title>Get Started with TypeScript — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript入门—第2部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/get-started-with-typescript-part-2-46cbdd858f69?source=collection_archive---------6-----------------------#2019-07-24">https://betterprogramming.pub/get-started-with-typescript-part-2-46cbdd858f69?source=collection_archive---------6-----------------------#2019-07-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cf20" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">设置VS代码和使用基本类型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a4bca655bce9f9b21922b5e150090a71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yBhT-vsxko4tVSzc0kpzJg.jpeg"/></div></div></figure><p id="1eed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是正在进行的学习TypeScript系列的第二部分。如果你没有看过第一部分，<a class="ae lq" href="https://medium.com/better-programming/get-started-with-typescript-part-1-440d2ec9e59" rel="noopener">从这里开始</a>。我们将使用前一篇文章中讨论过的一些概念，所以您需要先熟悉这些概念。</p><p id="5f49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们之前讨论过TypeScript在问题发生之前通过在运行时之前在我们的代码编辑器中向我们显示我们的错误是多么有用。在本文中，我们将通过一些扩展和其他设置来设置VS代码，以实现这一点。</p><p id="3f54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还将看看一个还没有类型的应用程序——我们将添加我们自己的类型，开始应用我们的TypeScript知识。该应用程序是使用React构建的，但不要担心——你不需要成为React专家。我们不会关注React，而是关注如何向传入数据添加类型。</p><p id="09fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们开始吧。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="7c28" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">设置VS代码</h1><p id="737b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">如果你还没有安装VS代码，你可以通过访问<a class="ae lq" href="https://code.visualstudio.com/?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">微软官方下载页面</a>来安装。为你的操作系统安装<em class="mv">稳定版本</em>。</p><p id="6dcd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">VS代码支持现成的TypeScript，但是为了最大限度地利用TypeScript开发，您需要添加一些扩展来增强体验。</p><p id="de99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将在下面描述这些扩展，并提供Visual Studio Marketplace的链接来安装它们。或者，您也可以只在VS代码中搜索扩展名<strong class="kw iu"> </strong>。</p><p id="993a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">单击要重定向到下载页面的扩展名。</p><ul class=""><li id="8cd3" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">TSLint  —这个扩展将通过实时分析我们的类型脚本来帮助识别和标记代码中的错误。<strong class="kw iu"> <em class="mv">更新</em> </strong> : ESLint现在是TypeScript的官方linter。这个插件仍然支持最新的TypeScript，并且对于本教程的目的来说会工作得很好，但是建议迁移到ESLint。</li><li id="97af" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><a class="ae lq" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.typescript-javascript-grammar" rel="noopener ugc nofollow" target="_blank">最新的TypeScript和Javascript语法</a> —这有助于主题中的语法突出显示和VS代码内部使用的其他语言特性。</li><li id="d876" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><a class="ae lq" href="https://marketplace.visualstudio.com/items?itemName=usernamehw.errorlens" rel="noopener ugc nofollow" target="_blank"> Error Lens </a> — Error Lens与TSLint结合使用，向我们显示错误，尤其是打字错误，就在文件中引起问题的实际代码行旁边。<em class="mv">小心下载正确的版本</em> <strong class="kw iu"> </strong>，因为有两个扩展名名称相似。这个扩展是由一个叫亚历山大的人完成的。(是<em class="mv">不是</em>错误镜头:注意空格。)</li></ul><p id="e9c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然这三个扩展都是非常宝贵的，但在学习TypeScript时，误差透镜无疑是最重要的。为了说明它是如何工作的，我将使用我们在【TypeScript入门—第1部分中的例子中使用的一些代码。</p><p id="fa87" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下面的截图中应该很清楚，Error Lens向我们显示的错误与我们的问题窗口中的错误相同。但是，并不是所有错误镜头突出的问题都会出现在问题中。这也释放了您的底部窗口分区用于您的终端。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/4bec92f77d333487a6b5cd044e55fd6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NMnqVP456X2AfcH25ptG5A.png"/></div></div><p class="nl nm gj gh gi nn no bd b be z dk translated">Error Lens在与违规代码相同的行上突出显示错误。</p></figure><p id="9ae6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们深入研究TypeScript如何工作时，我们将更多地使用这个特性。它确实有助于快速找到错误，并在第一次就正确地编写代码，但这确实需要一点时间来适应。</p><p id="d88d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您在编码时发现这令人讨厌或打扰，请记住您也可以在问题窗口中看到这些错误。如果你不喜欢这个扩展，就禁用或卸载它。然而，我鼓励你在我们讨论添加类型的时候尝试一下，因为我发现它在我自己的编程中是一个非常有价值的工具。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="9237" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">艰难地编译打字稿</h1><p id="1792" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">默认情况下，TypeScript编译器要求您手动运行它。当我们进入下面的示例应用程序时，我们不会这样做，你可能也不会在现实世界中这样做。然而，对幕后发生的事情有一些了解是很重要的。</p><p id="f12a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来演示一下。在一个空文件夹中创建以下内容。注意文件扩展名<code class="fe np nq nr ns b">.ts</code>。</p><pre class="kj kk kl km gt nt ns nu nv aw nw bi"><span id="90ee" class="nx lz it ns b gy ny nz l oa ob">index.ts<br/>tsconfig.json</span></pre><p id="a093" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将以下代码放入您的<code class="fe np nq nr ns b">tsconfig.json</code>中。我们将更详细地讨论这个文件的确切用途:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div><p class="nl nm gj gh gi nn no bd b be z dk translated">tsconfig.json的最低要求。</p></figure><p id="06ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在你的<code class="fe np nq nr ns b">index.ts</code>中放置下面的代码。这只是几个变量和函数，返回一个组合这些变量的字符串。如果你读了前一篇文章，应该很清楚这些类型的用途。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div><p class="nl nm gj gh gi nn no bd b be z dk translated">用TypeScript编写的简单函数</p></figure><p id="79ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经有了一些类型脚本，我们可以运行编译器来构建我们的JavaScript文件。在VS代码中，按下<code class="fe np nq nr ns b">Cmd + Shift + b</code>，编译器会在底部的终端窗口中显示它正在运行。</p><p id="0c4e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您会注意到现在有了一个新的JavaScript文件，<code class="fe np nq nr ns b">index.js</code>，它包含了与我们的TypeScript文件非常相似的代码，但是没有类型。这个文件是由TypeScript编译器根据您的<code class="fe np nq nr ns b">index.ts</code>文件中的代码创建的。</p><p id="9f71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看起来似乎与TypeScript文件没有太大的不同。情况往往如此；代码可能看起来相对相同。然而，当您更深入地应用类型时，当编译成JavaScript时，TypeScript通常会创建更复杂的代码版本。这是为了加强你已经创建的类型，并最终得到比没有类型脚本更好的<em class="mv">JavaScript</em>。</p><p id="54f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然知道这是如何工作的很重要，但我在本文中的重点是<em class="mv">学习如何应用基本类型</em>，而不是TypeScript编译过程的后端如何工作。您可能想自己尝试一下，以便更加熟悉，但是您不需要了解更多关于手动使用编译器来使用TypeScript的知识。</p><h1 id="71de" class="ly lz it bd ma mb oe md me mf of mh mi jz og ka mk kc oh kd mm kf oi kg mo mp bi translated">以最简单的方式编译TypeScript</h1><p id="0b68" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">你可能会看到，如果我们不得不一直这样做，编译过程会多么低效。在编写TypeScript时，您几乎总是会使用框架或其他工具来完成这一过程。</p><p id="1a24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在编写vanilla TypeScript时使用package，它为我处理编译。关于包裹的入门指南，请看我的文章<a class="ae lq" href="https://medium.com/better-programming/parcel-js-easy-javascript-bundling-ecddac0783f7" rel="noopener">Parcel . js——简单的JavaScript捆绑</a>。我们的示例应用程序已经在使用Parcel，所以从现在开始我们不需要担心编译器。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="fdaf" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">下载示例应用程序</h1><p id="911e" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我已经模拟了一个示例应用程序的开始，我们将使用它来练习添加类型。现在就去下载吧。</p><p id="3de6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，如果您使用的是VS代码，您可以按<code class="fe np nq nr ns b">Ctrl + ~</code>打开终端并在那里运行命令来克隆repo，安装节点模块并将其作为我们的VS代码工作目录打开。</p><pre class="kj kk kl km gt nt ns nu nv aw nw bi"><span id="e465" class="nx lz it ns b gy ny nz l oa ob">git clone <a class="ae lq" href="https://github.com/methodbox/ts-rocket-example" rel="noopener ugc nofollow" target="_blank">https://github.com/methodbox/ts-rocket-example</a><br/>cd ts-rocket-example<br/>npm install<br/>code -r .</span></pre><p id="54d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我前面提到的，它内置在React中，但是如果您不熟悉React，也不用担心。我们将专注于向应用程序提供的数据中添加类型。我将在需要的地方给出React特定项目的高级概述，以便清楚我们正在做什么。你不需要任何反应知识来掌握这些概念。</p><p id="b4a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">顺便提一下，这个应用程序是使用我在文章<a class="ae lq" href="https://medium.com/better-programming/parcel-js-easy-javascript-bundling-ecddac0783f7" rel="noopener"> Parcel.js中介绍的相同步骤开始的——简单的JavaScript捆绑</a>。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="72a9" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">什么是tsconfig？</h1><p id="ffc4" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">一旦你下载了这个应用程序，你会看到一些文件，包括扩展名为<code class="fe np nq nr ns b">.tsx</code>的文件和一个名为<code class="fe np nq nr ns b">tsconfig.json</code>的文件，类似于我们之前创建的文件。<code class="fe np nq nr ns b">tsconfig</code>文件用来告诉VS代码的类型脚本解释器我们想如何使用类型脚本。它可以用来使我们的规则更严格或更宽松，指定我们在其中使用TypeScript的文件类型，甚至指定我们所针对的JavaScript的特定版本。这是TypeScript在您的项目中正确工作所需的<em class="mv">文件。</em></p><p id="3859" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我包含的文件可以与React一起工作，但是如果您使用的是，例如，像我们前面所做的那样，只使用TypeScript和<code class="fe np nq nr ns b">.ts</code>文件扩展名，则需要进行一些更改。当使用React的JSX HTML-in-JavaScript语法时，我们告诉TypeScript这就是我们正在做的事情。深入理解这一点并不重要，重要的是理解我们可以将该设置指定给TypeScript，这样它就知道发生了什么。</p><p id="e948" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想了解更多关于<code class="fe np nq nr ns b">tsconfig</code>的设置，看看微软的官方文档<a class="ae lq" href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="9a16" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">为状态创建新类型</h1><p id="8f69" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">先说一下<code class="fe np nq nr ns b">state</code>是怎么工作的。在VS代码里面，打开<code class="fe np nq nr ns b">RocketApp.tsx</code>文件，四处看看。我们将关注<code class="fe np nq nr ns b">state</code>属性对象，它位于<code class="fe np nq nr ns b">RocketApp class</code>内部。如果您没有经常使用React，状态可能不是一个非常熟悉的概念，但是，正如我所说的，您不需要了解React就能理解。</p><p id="fc45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你现在需要知道的关键事情是，当<code class="fe np nq nr ns b">state</code>发生变化时，我们的应用程序中显示的数据也会发生变化，因此React会相应地更新我们的网页(无需刷新)。</p><p id="5958" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们不会玩太多React <code class="fe np nq nr ns b">state</code>的魔法，但重要的是要知道，因为<code class="fe np nq nr ns b">state</code>正在管理我们的数据，我们知道这将在某个时候改变，同样重要的是要知道我们正在发送和接收正确的<code class="fe np nq nr ns b">type</code>数据。</p><p id="391e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们通过创建一个名为<code class="fe np nq nr ns b">State</code>的新类型来开始我们的输入过程。注意大写——这不是必需的，但这是<em class="mv">接受的惯例</em>,即新的、自定义的<code class="fe np nq nr ns b">type names</code>是<em class="mv">大写的</em>。</p><p id="a13b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我知道，我们应该把重点放在基本类型上，对吗？这正是我们要做的——我们将把一些基本类型分配给一个新类型<code class="fe np nq nr ns b">State</code>,这样我们就可以把这些类型分配给我们已经在<code class="fe np nq nr ns b">state</code>对象中找到的值。我们从这里开始，因为你经常会有一个装满数据的T4，你需要为这些数据赋值。</p><p id="18d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">打开文件<code class="fe np nq nr ns b">RocketApp.tsx</code>。在文件的顶部，注释的下面，添加一个状态类型，如下面的要点所示。现在，使用语法<code class="fe np nq nr ns b">type [type name] = {}</code>，它只是一个空对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="2ed3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的<code class="fe np nq nr ns b">RocketApp class</code>中，再看一下<code class="fe np nq nr ns b">state</code>属性。它有一堆<code class="fe np nq nr ns b">data</code>值，有些比较空，但是<em class="mv">都有我们可以赋值的类型</em> <strong class="kw iu"> </strong>。让我们首先将<code class="fe np nq nr ns b">state</code>的括号<code class="fe np nq nr ns b">{}</code>之间的所有内容复制到新的<code class="fe np nq nr ns b">type State</code>中。一定要以分号<em class="mv">结束每一行，因为这在定义类型时是必需的。</em></p><p id="83fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你的新<code class="fe np nq nr ns b">State</code>类型应该看起来像下面的要点。但是我们还没有完成——我们需要添加我们的类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="e12b" class="ly lz it bd ma mb oe md me mf of mh mi jz og ka mk kc oh kd mm kf oi kg mo mp bi translated">向我们的新状态类型添加类型</h1><p id="29c1" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">现在我们有很多类型属性，但是它们都没有类型。这在技术上是错误的类型脚本语法，但是我让你这么做的原因是考虑这些属性和与它们的类型相关的当前数据值。</p><p id="60ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们对此进行分解，只需查看值并考虑我们有哪些类型的数据，就应该很清楚要分配哪些类型。我们有一些空的<code class="fe np nq nr ns b">strings</code>，几个<code class="fe np nq nr ns b">false boolean</code>值，几个<code class="fe np nq nr ns b">numbers</code>和一个<code class="fe np nq nr ns b">Array</code>。</p><p id="8492" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尝试自行分配<code class="fe np nq nr ns b">types</code>。只需将你看到的值替换为类型的名称，并以分号结尾，就像这样:<code class="fe np nq nr ns b">appTitle: string;</code>。</p><p id="de03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我再给你一个关于<code class="fe np nq nr ns b">Array</code>的提示。TypeScript <code class="fe np nq nr ns b">Array</code>语法如下:<code class="fe np nq nr ns b">Array&lt;type&gt;</code>其中<code class="fe np nq nr ns b">type</code>是数组内容的实际类型。你也可以用<code class="fe np nq nr ns b">type[]</code>来表示那个<code class="fe np nq nr ns b">type</code>的数组，但是我更喜欢第一个，因为它清晰地显示出一个<code class="fe np nq nr ns b">Array</code>。在我们的例子中，我们的<code class="fe np nq nr ns b">ships</code>属性将保存船舶的<em class="mv">名称— </em>您希望在<code class="fe np nq nr ns b">Array&lt;type&gt;</code>中使用哪种类型？</p><p id="18c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完成后，将代码与下面的要点进行比较。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="77e0" class="ly lz it bd ma mb oe md me mf of mh mi jz og ka mk kc oh kd mm kf oi kg mo mp bi translated">使用你的新类型</h1><p id="b581" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">这里有另一种方法来检查你的答案。这就是VS代码真正展示威力的地方。回头向下看<code class="fe np nq nr ns b">RocketApp class</code>，再次将光标悬停在<code class="fe np nq nr ns b">state</code>属性上。VS代码实际上会<em class="mv">推断</em>类型是什么。它会向您展示代码中基本上所有的元素。推理并不总是正确的，但通常是正确的，如果您不确定如何继续，尝试开始输入代码是一个好方法。</p><p id="68ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这只是<em class="mv">推断</em>类型——我们实际上还没有将我们的类型绑定到<code class="fe np nq nr ns b">state</code>属性。为此，将您的新<code class="fe np nq nr ns b">State</code>类型分配给<code class="fe np nq nr ns b">state</code>属性，就像您将您的类型分配给<code class="fe np nq nr ns b">State</code>类型属性一样。</p><p id="c4a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还需要将<code class="fe np nq nr ns b">State</code>类型分配给该类。用单词<code class="fe np nq nr ns b">State</code>替换<code class="fe np nq nr ns b">React.Component</code>后的第二个空对象。我们不会详细讨论这个问题，因为我们今天只关注基本类型，但是现在只要注意这是你在使用<code class="fe np nq nr ns b">classes</code>时使用<code class="fe np nq nr ns b">types</code>的方式。</p><p id="deb3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你将<code class="fe np nq nr ns b">State</code>类型赋给你的<code class="fe np nq nr ns b">state</code>属性并更新了类类型后，你的代码应该看起来像这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="4d6b" class="ly lz it bd ma mb oe md me mf of mh mi jz og ka mk kc oh kd mm kf oi kg mo mp bi translated">引入一些数据</h1><p id="135e" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">让我们快速看一下我们的应用程序实际上做了什么，以及我们现在使用默认数据看到了什么。在您的终端中，使用<code class="fe np nq nr ns b">npm start</code>启动应用程序，它将在您的浏览器中打开。您可以按下“获取启动数据”按钮来查看应用程序的运行情况。我们得到了一个漂亮的图片，但没有太多其他的，因为我们有很多空值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/f3518029f1a71766f9a0e3d3daf5fd92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QjCfu5H6a0ovneWQggaczw.png"/></div></div></figure><p id="64ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了获取一些火箭发射任务数据，让我们从更新我们的<code class="fe np nq nr ns b">_getNewMission</code>方法开始。再次从您的<code class="fe np nq nr ns b">state</code>属性中复制值，但是这次将它们放在<code class="fe np nq nr ns b">this.setState</code>函数内的对象中。请注意，<code class="fe np nq nr ns b">launchImg, missionLogo, and isShowingMissionData</code>值已经存在；不要重复它们。</p><p id="4137" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完成后，<code class="fe np nq nr ns b">_getNewMission</code>方法应该与下面的代码相匹配。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="e6a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在项目中的<code class="fe np nq nr ns b">data</code>文件夹中包含了一个名为rockets的文件，该文件包含了<code class="fe np nq nr ns b">mission</code>对象，该对象又被导入到<code class="fe np nq nr ns b">RocketApp.tsx</code>的顶部。<code class="fe np nq nr ns b">mission</code>对象具有从<a class="ae lq" href="https://docs.spacexdata.com/?version=latest" rel="noopener ugc nofollow" target="_blank"> SpaceX API </a>中提取的实际数据。为了这个例子的简单，我们使用静态数据，但是你可以很容易地从一个活动的API中提取。</p><p id="a5bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">查看一下<code class="fe np nq nr ns b">mission.tsx</code>文件中的<code class="fe np nq nr ns b">data</code>文件夹。您将看到我已经创建了一个与我们的<code class="fe np nq nr ns b">State</code>类型相似的自定义<code class="fe np nq nr ns b">Mission type</code>。下面是<code class="fe np nq nr ns b">mission</code>对象，它又被分配给我们的<code class="fe np nq nr ns b">Mission type</code>。</p><p id="4457" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我会给你一个属性列表，我想让你分配给<code class="fe np nq nr ns b">_getNewMission</code>方法的<code class="fe np nq nr ns b">setState</code>函数，这里我们刚刚引入了<code class="fe np nq nr ns b">state</code>属性。继续并相应地更新<code class="fe np nq nr ns b">setState</code>函数中的对象。</p><p id="65ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mv">仔细考虑</em>每条数据的类型，它在<code class="fe np nq nr ns b">mission</code>对象中的表示方式，以及我们在应用程序中分配的<code class="fe np nq nr ns b">types</code>。我们已经设置了我们的类型，这意味着我们期望得到那种类型的数据，事实上——我们正在<em class="mv">要求</em>我们得到那种类型的数据。我们一会儿将对此进行实验。现在，试着在<code class="fe np nq nr ns b">RocketApp.tsx</code>文件旁边查看<code class="fe np nq nr ns b">data/mission.tsx</code>文件，看看我们分配的类型是否有意义。</p><p id="79ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mv">提示:</em>你可以通过点击顶部的文件标签来使用VS Code的“右分割”功能，并排查看两个文件。</p><p id="885b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据以下更新要点，使用这些值并替换当前在<code class="fe np nq nr ns b">setState</code>功能对象中使用的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="cf3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">保存后，您可以再次尝试点击“Get Launch Data”按钮，您将看到我们现在有了一些非常棒的发布数据。如果你点击按钮几次，图像将使用上面的<code class="fe np nq nr ns b">Math.floor</code>方法随机选择。</p><p id="24a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里要指出的另一个重要事实是，虽然我们并没有根据我们的<code class="fe np nq nr ns b">type</code>赋值将<code class="fe np nq nr ns b">strings</code>放入需要<code class="fe np nq nr ns b">strings</code>的值中，但是我们<em class="mv">将</em>放入评估这些类型的<code class="fe np nq nr ns b">expressions</code>。这在TypeScript中完全有效；聪明到明白<code class="fe np nq nr ns b">new Date(mission.launch_date_unix * 1000).toDateString()</code>函数会返回一个<code class="fe np nq nr ns b">string</code>。</p><h1 id="5de8" class="ly lz it bd ma mb oe md me mf of mh mi jz og ka mk kc oh kd mm kf oi kg mo mp bi translated">让我们打破一些东西</h1><p id="0d99" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">到目前为止，我们已经分配了我们的类型，一切都工作得天衣无缝，这很好，但没有展示TypeScript最强大的一面——在错误发生之前发现它们。</p><p id="24f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了演示这一点，让我们试着创建一个新变量来保存我们的<code class="fe np nq nr ns b">mission</code>对象中的一个值。我们将使用<code class="fe np nq nr ns b">mission_id</code>值。不用看，我可能会认为这是一个<code class="fe np nq nr ns b">string</code>。我碰巧知道任务ID通常是一个<em class="mv">字母数字</em>名称，所以我知道它是<em class="mv">而不是</em>一个<strong class="kw iu"> </strong> <code class="fe np nq nr ns b">number</code> <strong class="kw iu"> </strong>并且我知道它不是一个数组。所以字符串是一个很好的猜测——它只是碰巧是错的。</p><p id="ef2e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是不管怎样，让我们试着把它分配给一个类型为<code class="fe np nq nr ns b">string</code>的<code class="fe np nq nr ns b">const</code>。你会马上看到TypeScript发现了一些错误，我们的错误镜头扩展使这个<em class="mv">变得非常</em>明显。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/a7c412fe4260f0f161b73d61be2da458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KqtvxwJrfO7Ler5IebKlmA.png"/></div></div><p class="nl nm gj gh gi nn no bd b be z dk translated">Error Lens和VS Code正在施展他们的魔法来识别我们的打字错误。</p></figure><p id="0405" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您将鼠标悬停在我们在<code class="fe np nq nr ns b">setState</code>中分配的任何值上，它将向您显示我们之前看到的推断的<code class="fe np nq nr ns b">type</code>。在这种情况下，类型是一个<em class="mv">原语</em>(因为它是<code class="fe np nq nr ns b">Array</code>的基本类型)，正如我们在第1部分中讨论的。如果一个类型是原语，而不是自定义类型，你可以肯定VS代码是正确的。它告诉我将这个赋值为<code class="fe np nq nr ns b">string[]</code>或<code class="fe np nq nr ns b">Array&lt;string&gt;</code>。</p><p id="14f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我更正输入时，我看到错误已经清除。你可以删除这个变量，因为我们不会在这个例子之外使用它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/e2a4a581f6c10691c586e244d16d900b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IJDJHbWIue193kPbEd2-7g.png"/></div></div><p class="nl nm gj gh gi nn no bd b be z dk translated">我们的类型赋值现在匹配VS代码的推断类型。</p></figure><p id="8e90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我强烈建议您多试验一下这个特性——创建您自己的变量，并给它们赋值，然后给它们分配类型。试着产生错误并理解它们为什么会发生。</p><h1 id="3f44" class="ly lz it bd ma mb oe md me mf of mh mi jz og ka mk kc oh kd mm kf oi kg mo mp bi translated">继续打字，继续实验</h1><p id="105f" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">本教程的目标是向您介绍如何分配基本类型，了解如何确定分配给数据的正确类型，以及如何识别和纠正错误。</p><p id="14dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们才刚刚起步，但是你现在可以开始使用TypeScript了。尝试示例rocket应用程序，或者自己编写一些代码并尝试分配类型。创建一个具有不同类型属性的对象，并创建一个新的类型来分配它，然后对照VS代码显示的内容来检查它。</p><p id="21d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用VS代码来识别你的对象的类型并相应地分配它们，但是先不要偷看。</p><h1 id="887d" class="ly lz it bd ma mb oe md me mf of mh mi jz og ka mk kc oh kd mm kf oi kg mo mp bi translated">结论</h1><p id="eb48" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我无法在一篇文章中介绍关于TypeScript的所有知识，但是我希望这篇教程能够帮助您熟悉基本类型。</p><p id="d800" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将在下一部分继续这一旅程。在那之前，继续尝试使用TypeScript。</p></div></div>    
</body>
</html>