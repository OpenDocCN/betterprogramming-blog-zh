<html>
<head>
<title>JavaScript 101: The Array Reduce Method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 101:数组Reduce方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-101-the-array-reduce-method-a0c797f80372?source=collection_archive---------16-----------------------#2022-05-16">https://betterprogramming.pub/javascript-101-the-array-reduce-method-a0c797f80372?source=collection_archive---------16-----------------------#2022-05-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e55a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你曾经想知道的关于这种方法的一切，以及为什么你应该更经常地使用它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/29b22f7df084b301fe11278939f432df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3aYSXrTXAxHNdJMgnBL-zg.jpeg"/></div></div></figure><p id="8219" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript数组方法非常流行和有用。然而，由于某种原因，<code class="fe lq lr ls lt b">reduce</code>方法被落在了宣传列车的后面。人们不仅忽视它，而且还主动回避它。</p><p id="e7c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不管原因是什么，我已经把向您展示它有多棒以及最重要的是它有多容易使用作为我的使命。</p><p id="f42a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以让我们言归正传。</p><h1 id="8a7c" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">Reduce方法的目的是什么？</h1><p id="131f" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">该方法的目的是将回调函数应用于每个元素，但与<code class="fe lq lr ls lt b">map</code>或<code class="fe lq lr ls lt b">forEach</code>方法不同，它还跟踪该回调的最后返回值。最终，返回最后一个返回值。</p><p id="a944" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一种复杂的说法，这个方法以某种方式帮助你减少一个数组的元素。通常，这种方法用于将元素列表缩小到单个值，但这不一定是它的唯一用途。</p><p id="fac7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于<code class="fe lq lr ls lt b">reduce</code>有趣的一点是，你可以把它用作<code class="fe lq lr ls lt b">map</code>、<code class="fe lq lr ls lt b">filter</code>或任何你喜欢的方法。那为什么讨厌呢？大家来了解一下吧！</p><h1 id="9839" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">Reducer方法的语法</h1><p id="c0f0" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">从外面看，这是一个很简单的方法。它只需要两个参数:回调和初始值。</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="dd31" class="mv lv it lt b gy mw mx l my mz">array.reduce(callback, initialValue)</span></pre><p id="4325" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我认为真正复杂的部分是回调函数的签名。由于它有几个可选的参数，恐惧就产生了。</p><p id="6747" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一个参数回调需要以下属性:</p><ul class=""><li id="b2ab" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated"><code class="fe lq lr ls lt b">previousValue</code>:这是上一次回调执行的返回值，或者如果是第一个，则是传递给<code class="fe lq lr ls lt b">reduce</code>方法的第二个参数的内容(<code class="fe lq lr ls lt b">initialValue</code>)。</li><li id="47dd" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">这是你正在处理的数组的当前元素。</li><li id="41a0" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated"><code class="fe lq lr ls lt b">currentIndex</code>(可选):这个告诉你你在数组中的位置。如果你的逻辑在某种程度上依赖于元素的位置，这是很有用的。否则可以忽略。</li><li id="c617" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated"><code class="fe lq lr ls lt b">array </code>(可选):这是您正在处理的完整数组。除非你真的因为什么原因需要它，否则你可以忽略它。</li></ul><p id="44ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">reduce</code>的第二个参数<code class="fe lq lr ls lt b">initialValue</code>，是第一次调用回调函数时分配给<code class="fe lq lr ls lt b">previousValue</code>的值。</p><p id="057a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">仅此而已。看到了吗？一点都不恐怖！</p><h1 id="870e" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">现在，我们可以用Reduce方法做什么呢？</h1><p id="6117" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">有趣的事情开始了。用这种方法我们能做什么？</p><p id="af33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">答案是:“一切！”</p><p id="918c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我之前说过的，你可以把<code class="fe lq lr ls lt b">reduce</code>看作是你真正喜欢的所有其他方法的构建模块。</p><p id="dd84" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，考虑下面显示的<code class="fe lq lr ls lt b">map</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3719" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每一次迭代，我们都会得到一个新的数组，在那里我们会添加每个元素的double值。而初始值(<code class="fe lq lr ls lt b">reduce</code>的第二个参数)是空的新数组。</p><p id="1c9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那<code class="fe lq lr ls lt b">filter</code>的方法呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="48a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你现在开始明白规律了，对吧？回调函数的主体允许您做任何您想做的事情，因此您可以模仿任何其他方法。</p><p id="62c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，我只添加字符串，忽略数字。之后，我将返回当前的字符串列表，这样下一次迭代也可以这样做。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/c213d3d1d6c511cff44fb79260df44b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/0*GY46EHWCXBo91zP0.jpg"/></div></div></figure><p id="d098" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但这不是你来这里的原因。这很有趣，但是如果你想过滤一个列表，你可以使用<code class="fe lq lr ls lt b">filter</code>，如果你想转换每个元素，你可以使用<code class="fe lq lr ls lt b">map</code>。那么<code class="fe lq lr ls lt b">reduce</code>还能做什么呢？</p><h2 id="148a" class="mv lv it bd lw nr ns dn ma nt nu dp me ld nv nw mg lh nx ny mi ll nz oa mk ob bi translated"><code class="fe lq lr ls lt b">reduce</code>更具体的用途</h2><p id="7be6" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated"><code class="fe lq lr ls lt b">reduce</code>方法的另一个常见用例是将一组元素简化为一个元素。例如，在我的这个项目中，我使用了一种<a class="ae oc" href="https://deleteman.hashnode.dev/using-a-genetic-algorithm-to-find-your-users-ideal-theme" rel="noopener ugc nofollow" target="_blank">遗传算法来寻找最佳主题</a>，我必须通过将一系列距离相加来计算主题的总得分。我用这段代码解决了这个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1a12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">忽略实际问题；在某种程度上真实的场景中，这是对<code class="fe lq lr ls lt b">reduce</code>的一种非常有效的使用。我将复杂对象的可变长度列表简化为一个数字，即<code class="fe lq lr ls lt b">score</code>。为此，我从设置为0的<code class="fe lq lr ls lt b">score</code>开始，然后遍历列表，并将每个主题的当前值(该主题的距离)添加到累积分数中。</p><p id="365f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最终结果是所有距离相加。</p><p id="09c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，我可以在这里简单地使用<code class="fe lq lr ls lt b">forEach</code>,因为我在迭代完整的元素列表，但是<code class="fe lq lr ls lt b">reduce</code>为这些用例提供了非常简单的语法。</p><p id="5ea3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我发现的另一个有趣的用例是运行函数管道，每个函数都使用前一个函数的输出作为其输入，如下面的代码所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8335" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这个例子，我试图将函数管道引入一个更加实际和真实的场景。如果您做过后端开发，您可能会遇到类似的情况，您必须对您的“请求”运行一组验证和转换</p><p id="4967" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该逻辑可以被隔离到单独的函数(通常是单独的库)中，然后添加到一个列表中，它们可以在这样的管道中运行。</p><p id="5767" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个函数要么转换要么对前一个函数返回的对象执行某种验证。由于这是一个更真实的场景，所以当出现问题时，我们会抛出错误来打破循环。</p><p id="91cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者，我们可以找到一种方法来收集所有错误，然后最终决定是否继续请求。</p><p id="968b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是这里的要点是,<code class="fe lq lr ls lt b">reduce</code>方法让我们在一行代码中运行整个管道。那是强大的。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="19e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不会一直向你扔用例。现在，你可能明白没有真正的理由害怕这种方法，因为它背后没有黑魔法。</p><p id="6fde" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，如果你像我一样，你可能会有点失望。很像一个孩子，当他们被教导如何手指分裂的“把戏”工作。这里没有魔法，但是你的工具箱里增加了一个新的强大的工具，所以开心点吧。</p><p id="a468" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你对这个方法还有疑问吗？这些例子中有哪个对你来说没有意义吗？留下评论，我会尽力帮你看懂的！</p></div></div>    
</body>
</html>