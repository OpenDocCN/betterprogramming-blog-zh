<html>
<head>
<title>What’s New in Scala 3?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala 3有什么新特性？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-scala-3-586d69879253?source=collection_archive---------2-----------------------#2020-11-27">https://betterprogramming.pub/whats-new-in-scala-3-586d69879253?source=collection_archive---------2-----------------------#2020-11-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b15a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个新的编译器，创建应用程序，枚举，等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/75ebbfd4e85722215ae360e18b622782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bjsMusPSP1grdSpOzuMCgw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:miro.medium.com</p></figure><p id="1e48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自2004年首次发布以来，Scala经历了疯狂的增长，像<a class="ae ky" href="https://en.wikipedia.org/wiki/Scala_(programming_language)#Adoption" rel="noopener ugc nofollow" target="_blank">苹果、LinkedIn、Twitter和沃尔玛</a>这样的公司都是它的主要采用者。<a class="ae ky" href="https://insights.stackoverflow.com/survey/2020?_ga=2.265760399.1046029926.1605935537-2102088099.1605935537#work-salary-and-experience-by-language" rel="noopener ugc nofollow" target="_blank"> 2020 StackOverflow开发者调查</a>将Scala开发者列为行业中收入最高的类别之一。调查还将Scala排在软件工程师最喜爱的语言的第14位。随着Scala 3的发布，这种采用在未来肯定会增加，Scala 3被认为是在类型化设置中实现OOP和FP范例融合的全部潜力的一大步。随着新版本即将发布(2020年底)，让我们来看看这次设计革新背后的主要思想。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eede" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">一种基于点演算的语言</h1><p id="8d93" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="http://lampwww.epfl.ch/~amin/dot/fool.pdf" rel="noopener ugc nofollow" target="_blank">点演算</a>(依赖对象类型)是由Martin Odersky博士的团队开发的新演算。DOT通过统一类型成员的构造来规范Scala的类型系统，并通过提供交集和并集类型来简化最大下界和最小上界的计算。这将提供强大的类型操作能力，并在领域驱动的设计中开辟新的途径。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0db6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Dotty:新的Scala编译器</h1><p id="6c37" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了速度和正确性，新的编译器从头开始重写。这种语言经历了很多变化，经历了简化。</p><p id="cfca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scala 3代码现在编译成一种新的中间格式:<a class="ae ky" href="http://dotty.epfl.ch/docs/reference/metaprogramming/tasty-reflect.html" rel="noopener ugc nofollow" target="_blank"> TASTy </a>(类型化抽象语法树的简称)，可以用来生成JavaScript和不同版本的字节码。还有对美味语法树上反射的支持，这就是Scala 3中如何实现对宏<a class="ae ky" href="https://dotty.epfl.ch/docs/reference/metaprogramming/macros.html" rel="noopener ugc nofollow" target="_blank">的支持。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/0c602976c0a9eff94110e82db7934fb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*Tv7qxNcVjhhNNrZMFe5igw.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://image.slidesharecdn.com/scaladaysberlin-180517100049/95/preparing-for-scala-3-32-638.jpg?cb=1526551508" rel="noopener ugc nofollow" target="_blank"> SlideShare </a></p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6567" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">死去的东西</h1><p id="9924" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">几个不受欢迎和多余的功能已经被<a class="ae ky" href="https://dotty.epfl.ch/docs/reference/dropped-features/delayed-init.html" rel="noopener ugc nofollow" target="_blank">删除</a>，其中一些突出的功能是:</p><ul class=""><li id="d8bd" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><a class="ae ky" href="https://dotty.epfl.ch/docs/reference/dropped-features/type-projection.html" rel="noopener ugc nofollow" target="_blank">型投影</a></li><li id="c9ce" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://dotty.epfl.ch/docs/reference/dropped-features/existential-types.html" rel="noopener ugc nofollow" target="_blank">存在类型</a></li><li id="0cd8" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://dotty.epfl.ch/docs/reference/dropped-features/package-objects.html" rel="noopener ugc nofollow" target="_blank">包对象</a></li><li id="d499" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://dotty.epfl.ch/docs/reference/dropped-features/macros.html" rel="noopener ugc nofollow" target="_blank"> Scala 2宏</a></li></ul><p id="4acc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">采取这些步骤是为了让Scala更加用户友好，避免早期采用者因为这些特性的复杂性和缺陷而气馁。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ef50" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">新东西！</h1><p id="2801" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Scala 3中还引入了大量新特性，其中包括:</p><h2 id="44ba" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">顶级声明</h2><p id="c9d9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在任何东西都可以在顶层声明，包括类型、变量和函数。不再需要将事物打包在一个对象中。此外，现在可以使用<code class="fe oa ob oc od b">@main</code>注释将任何函数声明为Main方法，因此不需要扩展<code class="fe oa ob oc od b">App</code>特征。</p><p id="36d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看这段代码，它与Dotty编译器配合得非常好。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="18fe" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">创建应用程序</h2><p id="e839" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Scala 3引入了调用函数的第四种方式，称为<a class="ae ky" href="https://dotty.epfl.ch/docs/reference/other-new-features/creator-applications.html" rel="noopener ugc nofollow" target="_blank"> creator applications </a>，它允许你创建一个类型的实例，而不需要使用<code class="fe oa ob oc od b">new</code>关键字，也不需要编写<code class="fe oa ob oc od b">apply</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="617f" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">扩展方法</h2><p id="004c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://dotty.epfl.ch/docs/reference/contextual/extension-methods.html" rel="noopener ugc nofollow" target="_blank">扩展方法</a>允许我们向现有类型添加额外的功能，如果我们不能或不想修改类型，它们会派上用场。扩展可以应用于泛型类型，也可以是运算符。</p><p id="5d61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们自己尝试一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="5d72" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">列举</h2><p id="8d5a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后，Scala 3引入了对一级<a class="ae ky" href="https://dotty.epfl.ch/docs/reference/enums/enums.html" rel="noopener ugc nofollow" target="_blank">枚举</a>的支持。Scala 2有一种间接的方式通过case类和<code class="fe oa ob oc od b">Enumeration</code>类来支持这个特性，但是现在它最终以Java风格支持它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="3d7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，我们现在可以将用户定义的方法添加到<code class="fe oa ob oc od b">enum</code>定义中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2657" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">操纵类型的新方法！</h1><p id="9c26" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Scala 3通过让我们以更具描述性的方式定义类型，为我们提供了更丰富的描述数据的工具包。让我们看看一些新引入的类型。</p><h2 id="5cf4" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated"><a class="ae ky" href="https://dotty.epfl.ch/docs/reference/new-types/union-types.html" rel="noopener ugc nofollow" target="_blank">联合类型</a></h2><p id="9b3c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">类型现在可以被定义为其他类型的联合，它们不必共享一个公共基类。让我们用一个简单的用例来理解这一点:你必须购买一部新的智能手机，你选择它的原因可以是它的摄像头、处理器或操作系统。让我们看看如何在Scala 3中实现这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="9e2f" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated"><a class="ae ky" href="https://dotty.epfl.ch/docs/reference/new-types/intersection-types.html" rel="noopener ugc nofollow" target="_blank">路口类型</a></h2><p id="dd2b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Scala 3现在也有交集类型了。简单来说，如果我们把类型的并集看作是<code class="fe oa ob oc od b">A</code>或者<code class="fe oa ob oc od b">B</code>，那么交集可以看作是<code class="fe oa ob oc od b">A</code>和<code class="fe oa ob oc od b">B</code>。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="634b" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">文字类型</h2><p id="6912" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们现在可以将任何文字值定义为一个类型，它有一个单独的实例。简单地说，像<code class="fe oa ob oc od b">ABC</code>、<code class="fe oa ob oc od b">2.7</code>和<code class="fe oa ob oc od b">true</code>这样的文字值现在可以被视为一个类型。让我们用一个例子来理解这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="b75a" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated"><a class="ae ky" href="https://dotty.epfl.ch/docs/reference/other-new-features/opaques.html" rel="noopener ugc nofollow" target="_blank">不透明类型别名</a></h2><p id="7194" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Domain-driven_design#:~:text=Domain%2Ddriven%20design%20(DDD),should%20match%20the%20business%20domain." rel="noopener ugc nofollow" target="_blank">域驱动设计</a>时，这一点特别有用，我们经常需要定义新类型作为其他类型的包装器。例如，我们可以定义一个名为<code class="fe oa ob oc od b">ItemID</code>的类型，它实际上只是一个对<code class="fe oa ob oc od b">String</code>类型的包装，限制是第一个字符必须是大写的。</p><p id="8084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此使用包装器类型的问题是，当访问它们的字段或方法，或者组合这些类型时，我们会招致不必要的开销。如果我们的设计中有很多这样的实体，这些开销就会越来越大。</p><p id="de7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<code class="fe oa ob oc od b">opaque</code>型的用武之地。它允许我们将<code class="fe oa ob oc od b">ItemID</code>定义为一个<code class="fe oa ob oc od b">String</code>，并提供附加功能/限制(通过一个伴随对象)。因此，如果我们使用<code class="fe oa ob oc od b">opaque</code>类型对上述问题进行编码，我们可以这样编码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6395" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">隐含被给定和使用子句所取代</h2><p id="b8c3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">隐含是Scala中最强大的特性之一，允许代码抽象。它们是使用类型类的基本工具，也是库的中心点，就像<a class="ae ky" href="https://typelevel.org/cats/" rel="noopener ugc nofollow" target="_blank"> Cats </a>和<a class="ae ky" href="https://github.com/milessabin/shapeless" rel="noopener ugc nofollow" target="_blank"> shapeless </a>。但这也在大型代码库中引入了不必要的复杂性，因为很难跟踪编译器注入了什么。</p><p id="f6c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scala 3引入了<code class="fe oa ob oc od b">given instances</code>和<code class="fe oa ob oc od b">using clauses</code>来打破<code class="fe oa ob oc od b">implicit</code>关键字的统一模式，对代码中注入的内容给予了更多的控制。我们来看一个小例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8bde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这只是一个基本的例子，但我鼓励您查看上面链接的Scala 3文档，以获得更深入的理解。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="15b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最喜欢的语言Scala经历了重大的设计革新，在某种程度上，它可以被视为一种全新的语言。看到新的自由/开源软件项目出现将是令人兴奋的，如果你打算自己开始一个项目，我希望这篇文章能给你一个好的开端。</p><p id="c9e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这篇文章简要概述了我认为突出的变化，但它绝不是Scala 3中所有新事物的完整指南。我鼓励你去看一下<a class="ae ky" href="https://dotty.epfl.ch/docs/index.html" rel="noopener ugc nofollow" target="_blank">官方文件</a>以获得更好的整体理解。</p><p id="8a69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次见。再见。</p></div></div>    
</body>
</html>