<html>
<head>
<title>An Introduction to Python Generator Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python生成器函数简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-introduction-to-python-generator-functions-cd9662b1d797?source=collection_archive---------16-----------------------#2019-08-12">https://betterprogramming.pub/an-introduction-to-python-generator-functions-cd9662b1d797?source=collection_archive---------16-----------------------#2019-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3e1b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">分解生成器的机制并通过示例工作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/34b2ef9a94ef3ea764de7a5b7e8b4a4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yA1fxkE5WZwA9G-fNmXt1g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/search/photos/python-programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@hiteshchoudhary?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Hitesh Choudhary </a>拍摄的照片</p></figure><p id="4933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python的生成器函数为管理数据和计算资源提供了一个强大的机制，但是对于那些Python新手来说，它们不一定是直观的。在本文中，我将分解生成器的机制，同时也介绍一个我希望是激励性的例子:一个用于管理和流式传输S3文件资源的小类。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="205a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">简介和历史</h1><p id="552f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">鉴于开始使用Python并编写实际执行某些操作(例如，迭代一系列值，计算和/或打印这些值)的代码是多么容易，对于新的或不熟悉的Python程序员来说，这种语言可能不会理解这种概念，即<strong class="lb iu"> <em class="mz">拖延</em> </strong>或延迟计算。对于有编译语言(例如C++语言)工作背景的人来说，这种语言本身固有的松散性(或懒惰性)可能看起来很陌生。</p><p id="fec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数程序员都了解“<a class="ae ky" href="https://en.wikipedia.org/wiki/Lazy_evaluation" rel="noopener ugc nofollow" target="_blank">懒惰评估</a>”，并被教导编写代码来实现这种做法。但是Python对这种语言的本地支持(通过一个关键字简单而优雅地实现)引入了在其他编程语言中似乎很少见的功能和表达能力。毫不奇怪，<a class="ae ky" href="https://en.wikipedia.org/wiki/Lazy_evaluation#History" rel="noopener ugc nofollow" target="_blank">惰性求值作为一个概念被引入作为“lambda演算</a>”的一部分，Python——尽管不仅仅是一种函数式语言(如Lisp)——体现了这种函数式编程DNA。(<a class="ae ky" href="https://medium.com/p/python-function-decorators-a-brief-tutorial-78377046c253?source=email-659f5ed9a08e--writer.postDistributed&amp;sk=c0e4e77fb9cd0fed8795a0362e64d520" rel="noopener">我之前写过关于Python函数装饰器的文章</a>，而<a class="ae ky" href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" rel="noopener ugc nofollow" target="_blank"> Python对闭包的使用也是lambda演算的遗产的一部分</a>)。</p><p id="63a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">"<a class="ae ky" href="https://www.python.org/dev/peps/pep-0255/" rel="noopener ugc nofollow" target="_blank"> PEP 255 —简单生成器</a>"在2001年引入了生成器，将懒惰评估的一个稍微更间接的表达作为动机:</p><blockquote class="na nb nc"><p id="c987" class="kz la mz lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">当一个生产者函数需要维护所产生的值之间的状态时，大多数编程语言都不能提供令人愉快和有效的解决方案。</p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ac81" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">力学</h1><p id="abab" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Python生成器函数是一个强大的概念，但不同于<a class="ae ky" href="https://medium.com/p/python-function-decorators-a-brief-tutorial-78377046c253?source=email-659f5ed9a08e--writer.postDistributed&amp;sk=c0e4e77fb9cd0fed8795a0362e64d520" rel="noopener">函数装饰器</a>的精心搭建，它们是通过一个非常简单的机制实现或表达的——“yield”语句(yield是PEP 255下添加到Python的一个新关键字)。</p><p id="0599" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为及物动词，yield表示生产；作为不及物动词，它表示让步或放弃。这个词的两种意思都在Python的生成器函数中发挥了作用。</p><p id="bf4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传统上，当函数返回单个值、列表或字典形式的多个值或者用户定义的对象时，我们认为函数通过它们的返回语句产生结果。我们认为return语句是函数结束控制并将控制和结果交还给调用者的一种方式。在return语句之后，运行时环境(解释器)将给定函数的堆栈框架从调用堆栈中弹出，并且给定函数的“环境”将不复存在(直到下一次调用该函数)。</p><p id="a548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python的yield语句彻底改变了这种行为。让我们来看一个非常简单的生成器示例——用一些额外的代码来演示它的用法(代码取自iPython解释器交互会话):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="93fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数除了“产生”作为参数传递的值之外什么也不做。然而，像“普通”函数一样简单地调用该函数不会产生返回值。如果你愿意，可以用一个参数实例化生成器函数，并保存在变量<code class="fe ni nj nk nl b">g</code>中。现在，正如generator对象上的<code class="fe ni nj nk nl b">next()</code>调用所表明的，为了产生一个值，必须对生成器进行迭代。而且，一旦它产生了它的(单个)值，生成器就会被耗尽——对<code class="fe ni nj nk nl b">next()</code>的后续调用会导致抛出“StopIteration”异常。如果我们在一个<code class="fe ni nj nk nl b">for</code>循环中迭代这个生成器函数，<code class="fe ni nj nk nl b">for</code>中包含的底层迭代机制会优雅地处理<code class="fe ni nj nk nl b">StopIteration</code>异常。</p><p id="6a1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数Python文本使用循环语句介绍生成器，类似于以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a77f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我发现这可能会导致流程和控制转移的混乱。需要理解的是，当在<code class="fe ni nj nk nl b">for</code>循环中迭代时，生成器不会产生任何值，直到客户端请求它们。在<code class="fe ni nj nk nl b">for</code>循环中，Python正在调用从generator对象获得的迭代器上的<code class="fe ni nj nk nl b">next()</code>。也就是说，在for循环中，Python隐式地做了这样的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="30db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，<code class="fe ni nj nk nl b">next()</code>可以在生成器函数的迭代器上显式调用，在Python解释器控制台上手动强制迭代生成器函数会很有帮助。</p><p id="399f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图也有助于解释这些步骤。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/e9262494e8d3f416e7061071d8f824cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MCheVqjV9KPrSIsb_qzGwA.png"/></div></div></figure><p id="7f41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，和闭包一样，Python的生成器函数在连续调用中保持状态。或者，正如<a class="ae ky" href="https://www.python.org/dev/peps/pep-0255/" rel="noopener ugc nofollow" target="_blank"> PEP 255 </a>所说:</p><blockquote class="na nb nc"><p id="46fc" class="kz la mz lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">如果遇到yield语句，函数的状态被冻结，expression_list的值返回到。next()的调用方。我们所说的“冻结”是指保留所有局部状态，包括局部变量的当前绑定、指令指针和内部评估堆栈:保存了足够的信息，以便下次使用。调用next()时，该函数可以继续执行，就像yield语句只是另一个外部调用一样。</p></blockquote><p id="c13b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这样一个小而琐碎的例子，这种状态保留加上值的延迟生成很难概念化，所以我试图通过编写一个我认为可能有用的生成器函数来使它更具体。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2249" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用案例— S3</h1><p id="acd3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://aws.amazon.com/s3" rel="noopener ugc nofollow" target="_blank">亚马逊的S3 </a>存储服务提供了一种相当简单且可扩展的方式，以非层级结构远程存储数据。对S3的全面讨论超出了这篇文章的范围，但是在我有兴趣探索是否可以在生成器函数中封装一些有用的S3资源访问功能之前，我和S3一起工作过一段时间。</p><p id="1d35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://boto3.amazonaws.com/v1/documentation/api/latest/index.html" rel="noopener ugc nofollow" target="_blank"> boto3 </a> Python库提供API调用来访问S3会话、资源和文件对象。以前我曾使用过<code class="fe ni nj nk nl b">download_file()</code> API调用，但正如所料，这会将整个远程文件下载到当前的工作目录中。如果您在EC2实例上的Docker容器中运行Python脚本，那当然很好，但对于我目前的工作，我是在MacBook Air上运行脚本，我想找到一种方法来避免使用本地存储，同时仍然能够访问远程文件。</p><p id="93c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，boto3库允许通过对象API访问文件资源的“流主体”。这似乎是生成器函数的理想选择，因为文件对象应该只按需流式传输——也就是说，是延迟的。</p><p id="de6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，可以直接使用这些API调用并直接遍历文件流。但是我认为将访问文件流所需的所有S3内务处理打包可能更优雅。尽管生成器可以跨调用保存状态，但我的需求建议在一个类中组合一个生成器函数，来管理S3会话状态。因此，通过在我的类中重载<code class="fe ni nj nk nl b">__iter__</code>方法，我可以使我的类可迭代。这样，我可以让我的S3类表现得像Python标准库中的文件对象。</p><p id="05d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为这个类编写的代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="2e29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于它所提供的有限功能来说，这个类的代码无疑比必要的更加复杂。但是它提供了少量的异常处理，此外，还实现了<a class="ae ky" href="https://docs.python.org/3.7/reference/datamodel.html?highlight=statement#with-statement-context-managers" rel="noopener ugc nofollow" target="_blank"> Python的上下文管理</a>接口，因此该类可以像标准库的file对象一样使用。这消除了对更冗长的try/except块的需要。<code class="fe ni nj nk nl b">__exit__</code>函数利用了无偿的对象删除——这违背了我过去遵守类析构函数最佳实践的<code class="fe ni nj nk nl b">C++</code>习惯；但是它也明确了在对象清理时释放所有S3资源的意图——会话、资源和对象。boto3库似乎不支持<code class="fe ni nj nk nl b">close()</code>方法。</p><p id="3b2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在构造函数中完成必要的S3内务处理后，该类提供了一个很好的接口，用于通过<code class="fe ni nj nk nl b">__iter__</code>方法迭代文件流。客户端代码可能希望在对流进行迭代时实现额外的处理或逻辑。对他的小类的一个很好的增强是添加一个过滤谓词，这样如果用户知道他们只对数据的一个子集感兴趣，那么<code class="fe ni nj nk nl b">__iter__</code>方法就不需要发出一个大文件的每一行。在这里使用标准库的<code class="fe ni nj nk nl b">itertools.dropwhile</code>函数会很好。</p><p id="6d51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要的好处是S3FileReader类的客户端不需要担心S3的日常管理和维护，只需要表示感兴趣的资源。尽管该类在文件流上迭代，以便在<code class="fe ni nj nk nl b">__iter__</code>方法中产生行，但是控制迭代和数据产生的是该类的客户端。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8792" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="c15b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Python生成器函数在标准库中被广泛使用，它为程序员提供了一个强大的推迟计算的工具，节省了时间和空间。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ef26" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><p id="da40" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">David Beazley，Brian k . Jones,《Python食谱》,第三版，O'Reilly Media，2013年5月。</p><p id="a78b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="http://shop.oreilly.com/product/0636920032519.do" rel="noopener ugc nofollow" target="_blank">卢西亚诺·拉马尔霍，流畅的Python，奥莱利媒体，2015年8月</a></p><p id="71de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="http://shop.oreilly.com/product/0636920028154.do" rel="noopener ugc nofollow" target="_blank">马克·卢茨，学习Python，第五版，奥莱利媒体，2013年6月</a></p><div class="nn no gp gr np nq"><a href="https://www.python.org/dev/peps/pep-0255/" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">PEP 255 -简单发电机</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">Python编程语言的官方主页</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">www.python.org</p></div></div></div></a></div></div></div>    
</body>
</html>