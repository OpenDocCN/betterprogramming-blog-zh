<html>
<head>
<title>Why and How to Create an Impure Filter Pipe in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么以及如何创建一个角度不纯的过滤管</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-and-how-to-create-an-impure-filter-pipe-in-angular-a3916de5841f?source=collection_archive---------1-----------------------#2022-06-07">https://betterprogramming.pub/why-and-how-to-create-an-impure-filter-pipe-in-angular-a3916de5841f?source=collection_archive---------1-----------------------#2022-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="fa9e" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/@lorenzozar/list/angular-5496c492a185" rel="noopener">有角度的</a></h2><div class=""/><div class=""><h2 id="979b" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">了解为什么Angular不附带过滤和排序管道，以及如何创建自定义过滤管道</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/c620441c6c35b5dbac2b48ee06d07f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LJwRfSsvfI4tgPII"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@er1end?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Erlend Ekseth </a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="72b0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Angular为最常见的场景提供了几个内置管道。</p><p id="66ab" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最大的缺失之一是过滤管。Angular不提供内置过滤管有一个很好的理由。</p><h1 id="fe5b" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">为什么Angular不附带过滤管</h1><p id="41c4" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">用于过滤和排序列表的管道在Angular中不可用，即使AngularJS过去提供了<code class="fe my mz na nb b">filter</code>和<code class="fe my mz na nb b">orderBy</code>。</p><p id="4d3f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这不是一个错误。</p><p id="c672" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因为这种管道性能很差，并且禁止过度缩小，Angular没有提供开箱即用的管道。过滤成本很高。</p><p id="e39f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">即使计算能力每年都在增长，数据和信息也在不断增长！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/1fbb7b2c287cb302149f2dc8d693da1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ckq-d1TO1nYMQXSq"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">CPU。劳拉·奥克尔在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="1268" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">一般来说，过滤需要对应于对象属性的参数。然而，一些场景要求管道是不纯的，这意味着Angular实际上每次发生变化检测循环时都会调用不纯的管道。</p><p id="c082" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因此，筛选和排序成为成本高昂的操作，尤其是当数据量很大时。</p><p id="566c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当Angular每秒多次调用这些管道时，即使是中等大小的列表，用户体验也可能会受到严重影响。</p><h1 id="e0f6" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">如何创建一个纯过滤管道</h1><p id="8313" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">首先，我们来看看模板和类。</p><h2 id="d4e5" class="nd mc iq bd md ne nf dn mh ng nh dp ml lo ni nj mn ls nk nl mp lw nm nn mr iw bi translated">AppComponent和数据</h2><p id="f7e1" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在模板中，我们有一个input元素，它使用双向绑定将用户输入存储在一个名为<code class="fe my mz na nb b">filterBy</code>的属性中。记得导入<code class="fe my mz na nb b">AppModule</code>中的<code class="fe my mz na nb b">FormsModule</code>，在你的app中使用双向绑定。</p><p id="89e1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">下面，我们用<code class="fe my mz na nb b">NgFor</code>列出来自<code class="fe my mz na nb b">usersList</code>的一些用户的名字。代码如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">包括模板和类的AppComponent</p></figure><p id="f5dd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">用户列表<code class="fe my mz na nb b">usersList</code>是十个项目的数组，例如，用户。它存储在类中，你可以在<a class="ae le" href="https://jsonplaceholder.typicode.com/users" rel="noopener ugc nofollow" target="_blank"> jsonplaceholder </a>或者这个应用的StackBlitz中找到它。</p><p id="a0cf" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">每个用户都是一个具有多个属性的对象。为了我们的目的，知道属性之一是<code class="fe my mz na nb b">name</code>就足够了。</p><p id="620c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们想按名字过滤用户。</p><p id="42d2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">初始应用程序如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nq"><img src="../Images/c51a291d6b8ce7c01c2c9bc900f71b15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*teTkT9wNnX97duxhnanQxw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">使用过滤管的角度应用程序</p></figure><h1 id="750d" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">创建FilterPipe类</h1><p id="f04a" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">让我们从使用Angular CLI命令<code class="fe my mz na nb b">ng generate pipe filter</code>开始，其中<code class="fe my mz na nb b">filter</code>是将在模板绑定中使用的管道名称。</p><p id="5f9f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">作为旁注，你也可以使用<code class="fe my mz na nb b">ng g p pipe</code>。</p><p id="3d90" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Angular将负责创建一个文件，填充一些字段，并在<code class="fe my mz na nb b">app.module.ts</code>中正确导入。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="208c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在转换方法中，<code class="fe my mz na nb b">value</code>是模板中管道左侧的值，而<code class="fe my mz na nb b">args?</code>是可选参数，我们将使用它来过滤<code class="fe my mz na nb b">value</code>。</p><p id="bb6e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">要使用此过滤器，我们可以简单地将其添加到模板中，如下所示:</p><pre class="kp kq kr ks gt nr nb ns nt aw nu bi"><span id="1dde" class="nd mc iq nb b gy nv nw l nx ny">&lt;div *ngFor="let user of usersList | filter"&gt;</span></pre><p id="d051" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">自然什么都不会发生。但是，请注意，<code class="fe my mz na nb b">usersList</code>是通过管道的属性，并且与转换方法中的<code class="fe my mz na nb b">value</code>参数相关联。</p><h1 id="691b" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">向FilterPipe添加过滤代码</h1><p id="99e5" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我们现在将在FilterPipe的transform方法中工作。</p><h2 id="a16b" class="nd mc iq bd md ne nf dn mh ng nh dp ml lo ni nj mn ls nk nl mp lw nm nn mr iw bi translated"><strong class="ak">变换方法的争论</strong></h2><p id="a2bd" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">首先，我们用下面的代码更新转换方法的参数:</p><pre class="kp kq kr ks gt nr nb ns nt aw nu bi"><span id="e0f7" class="nd mc iq nb b gy nv nw l nx ny">transform(value: User[], filterString: string, property: string)</span></pre><p id="84e6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们在上面讨论过<code class="fe my mz na nb b">value</code>。值类型是形状类似于<code class="fe my mz na nb b">User</code>接口的对象数组。你可以在StackBlitz的<code class="fe my mz na nb b">model.ts</code>中看到。</p><p id="dee9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">第二个参数是字符串类型的<code class="fe my mz na nb b">filterString</code>。<code class="fe my mz na nb b">filterString</code>的值必须来自模板。因此，我们将向管道添加一个参数。参数将是用户输入的<code class="fe my mz na nb b">filterBy</code>，例如，用户想要用作过滤器的字符串。</p><p id="14e7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">第三个也是最后一个参数是<code class="fe my mz na nb b">property</code>。由于我们的用户对象包含几个属性，我们需要指定我们想要使用哪个属性。为了简单起见，我将把字符串<code class="fe my mz na nb b">name</code>硬编码为模板中过滤管道的第二个参数。</p><p id="eab6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是一个例子。通常，您不应该在代码中硬编码值。</p><p id="f263" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在模板中，管道变成:</p><pre class="kp kq kr ks gt nr nb ns nt aw nu bi"><span id="0e0c" class="nd mc iq nb b gy nv nw l nx ny">...<br/>&lt;div *ngFor="let user of usersList | filter: filterBy:'name'"&gt;<br/>  &lt;ul&gt;<br/>    &lt;li&gt;{{ user.name }}&lt;/li&gt;<br/>  &lt;/ul&gt;<br/>&lt;/div&gt;</span></pre><p id="f731" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">其中<code class="fe my mz na nb b">filter</code>是管道的名称，<code class="fe my mz na nb b">filterBy</code>是我们通过双向绑定从输入元素获得的属性，<code class="fe my mz na nb b">'name'</code>是用户对象中的硬编码属性。</p><p id="7629" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">根据您的需要，您需要的参数数量是可选的。</p><h2 id="cd2c" class="nd mc iq bd md ne nf dn mh ng nh dp ml lo ni nj mn ls nk nl mp lw nm nn mr iw bi translated"><strong class="ak">过滤逻辑中的</strong> <strong class="ak">变换方法</strong></h2><p id="b828" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">现在我们在transform方法内部工作。</p><p id="78e2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们首先添加一些代码，以便在没有过滤器时返回每个值。</p><pre class="kp kq kr ks gt nr nb ns nt aw nu bi"><span id="ff99" class="nd mc iq nb b gy nv nw l nx ny">if (value.length === 0 || !filterString) {<br/>  return value;<br/>}</span></pre><p id="2347" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">然后，我们添加基于用户字符串的过滤逻辑。</p><pre class="kp kq kr ks gt nr nb ns nt aw nu bi"><span id="2563" class="nd mc iq nb b gy nv nw l nx ny">let filteredUsers: User[] = [];</span><span id="b6c7" class="nd mc iq nb b gy nz nw l nx ny">for (let user of value) {</span><span id="e006" class="nd mc iq nb b gy nz nw l nx ny">  if (user[property].includes(filterString)) {<br/>    filteredUsers.push(user);<br/>  }</span><span id="93be" class="nd mc iq nb b gy nz nw l nx ny">}</span><span id="2c80" class="nd mc iq nb b gy nz nw l nx ny">return filteredUsers;</span></pre><p id="ffe7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">记住<code class="fe my mz na nb b">property</code>是硬编码的，它的意思是<code class="fe my mz na nb b">name</code>。<code class="fe my mz na nb b">value</code>是来自<code class="fe my mz na nb b">usersList</code>的用户列表，<code class="fe my mz na nb b">filterString</code>是一个人想要用作过滤器的字符串，例如<code class="fe my mz na nb b">filterBy</code>。</p><p id="a3f1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因此，您可以将这段代码理解为“对于来自<code class="fe my mz na nb b">userList</code>的每个用户，如果用户名包含<code class="fe my mz na nb b">filterBy</code>字符串，则将该用户添加到最终返回的<code class="fe my mz na nb b">filteredUsers</code>数组中”。</p><p id="86a3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是<code class="fe my mz na nb b">FilterPipe</code>到目前为止:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8c67" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">此时，管道允许我们很好地过滤名字。</p><p id="5695" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">注意，我添加了<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase" rel="noopener ugc nofollow" target="_blank"> JavaScript </a> <code class="fe my mz na nb b"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase" rel="noopener ugc nofollow" target="_blank">toLowerCase()</a></code> <a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase" rel="noopener ugc nofollow" target="_blank">方法</a>，这样过滤器就不区分大小写了。这当然是完全可选的。</p><p id="9e9c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">昂贵的过滤操作怎么办？</p><h1 id="f4c5" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">如何使过滤管不纯</h1><p id="7448" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">让我们更进一步。</p><p id="6164" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们添加一个简单的按钮，用下面的代码向<code class="fe my mz na nb b">usersList</code>添加一个新用户:</p><pre class="kp kq kr ks gt nr nb ns nt aw nu bi"><span id="beaa" class="nd mc iq nb b gy nv nw l nx ny">&lt;button (click)="onAddUser()"&gt;Add user&lt;/button&gt;</span></pre><p id="b291" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">该方法如下所示:</p><pre class="kp kq kr ks gt nr nb ns nt aw nu bi"><span id="2864" class="nd mc iq nb b gy nv nw l nx ny">onAddUser() {<br/>  this.usersList.push({<br/>    id: Math.floor(Math.random() * 10000),<br/>    name: 'Leanne Graham',<br/>    username: 'Bret',<br/>    ...<br/>  });<br/>}</span></pre><p id="c7e8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">每点击一次，就有一个用户被推到<code class="fe my mz na nb b">usersList</code>。</p><p id="3727" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">问题来了！</p><p id="1da5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果过滤符晓薇，然后点击按钮，用户被添加到<code class="fe my mz na nb b">usersList</code>中，但过滤后的列表不会显示。因此，您不会在已筛选的列表中看到新用户，即使您在删除筛选器后会看到他们。</p><p id="d4bf" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Angular不会在每次复合数组或对象改变时重新运行数据管道。</p><h2 id="4430" class="nd mc iq bd md ne nf dn mh ng nh dp ml lo ni nj mn ls nk nl mp lw nm nn mr iw bi translated">纯净和不纯净的管道</h2><p id="dd7d" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">更准确地说，我们需要谈论纯净和不纯净的管道。</p><p id="8b3a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当输入值有纯变化时，我们有一个纯管道。纯粹的变更可以是以下情况之一:</p><ul class=""><li id="c816" class="oa ob iq lh b li lj ll lm lo oc ls od lw oe ma of og oh oi bi translated">原始输入值的变化(<code class="fe my mz na nb b">String</code>、<code class="fe my mz na nb b">Number</code>、<code class="fe my mz na nb b">Boolean</code>、<code class="fe my mz na nb b">Symbol</code>)</li><li id="caeb" class="oa ob iq lh b li oj ll ok lo ol ls om lw on ma of og oh oi bi translated">对对象引用的更改(<code class="fe my mz na nb b">Date</code>、<code class="fe my mz na nb b">Array</code>、<code class="fe my mz na nb b">Function</code>、<code class="fe my mz na nb b">Object</code>)</li></ul><p id="7f9d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">纯管道使用纯函数。给定相同的输入，纯函数应该总是返回相同的输出。</p><p id="d50d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">默认情况下，管道是纯的，因为Angular忽略对象或数组内部的更改。因此，当我们添加到一个输入数组，或者更新一个输入对象属性时，它不会调用一个纯管道。</p><p id="ccf8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">正如您所猜测的，对象引用检查比深层差异检查更快。此外，当Angular跳过管道执行时，它也会跳过视图更新。</p><p id="3996" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">由于这个原因，当常规的变化检测策略很好时，纯管道是更可取的。</p><p id="311c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当我们需要深度检查时，就像在当前的例子中，我们需要使用不纯的管道。</p><p id="0b4f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">不纯管道在每个组件变化检测周期中运行。例如，它可以在每次击键或鼠标移动时运行。</p><p id="3117" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">正如你所猜测的，这将很快变得非常昂贵。</p><p id="3e1a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">话虽如此，实现不纯管道就像在<code class="fe my mz na nb b">Pipe</code>装饰器中声明<code class="fe my mz na nb b">pure: false</code>一样简单。</p><pre class="kp kq kr ks gt nr nb ns nt aw nu bi"><span id="16db" class="nd mc iq nb b gy nv nw l nx ny">@Pipe({<br/>  name: 'filter',<br/>  pure: false,<br/>})</span></pre><p id="de15" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通过将<code class="fe my mz na nb b">pure</code>属性添加到<code class="fe my mz na nb b">Pipe</code>装饰器中，我们强制<code class="fe my mz na nb b">FilterPipe</code>在每次数据改变时进行更新。</p><p id="8bce" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在管道内添加一个日志，以显示频率。</p><p id="894e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">使用不纯的管道可能会导致性能和激进的最小化问题。所以要小心使用，只在真正需要的时候使用。</p><p id="6a49" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在<a class="ae le" href="https://stackblitz.com/edit/angular-ivy-4oztra?file=src/app/filter.pipe.ts" rel="noopener ugc nofollow" target="_blank"> StackBlitz </a>上找到代码或者从<a class="ae le" href="https://github.com/lorenzojkrl/ng-filter-pipe" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上克隆应用。</p><h1 id="54e9" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">异步管道</h1><p id="f088" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">作为旁注，值得一提的是<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/go-reactive-with-angular-async-pipe-b290988f4000">异步管道</a>是不纯的。粗略地说，我们可以认为“当管道总是检查新的输入数据时，它就是不纯的。”</p><p id="c984" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">虽然Angular异步管道优化了更改检测，但它也消除了手动使用订阅和取消订阅的必要性。</p><p id="85eb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">此外，在Angular 中使用<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/rxjs-declarative-pattern-in-angular-cafba3983d21"> RxJS声明模式是一个好方法。</a></p></div></div>    
</body>
</html>