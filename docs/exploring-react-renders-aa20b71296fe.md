# 探索 React 渲染

> 原文：<https://betterprogramming.pub/exploring-react-renders-aa20b71296fe>

## 使用 memo、useCallback 和 useMemo 进行优化和性能改进

![](img/574a3f04183b2d89ce7c7d91162d3076.png)

照片由[费伦茨·阿尔马西](https://unsplash.com/@flowforfrank?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

在这篇博文中，我们将探讨如何使用 React 提供的一些功能，例如`memo`、`useCallback`和`useMemo`，优化 React 组件并避免不必要的渲染。这并不意味着是一篇介绍性的文章，因此，一些关于 React 的知识是一个先决条件。

# 介绍

React 在特定情况下触发 render 方法，例如状态修改和道具更改，但在编写特定代码时，它会在不同的场景中重新呈现组件。这些重新渲染是意料之外的，通常会被刚刚开始使用 React 的人忽略，了解这些重新渲染的原因以及如何避免这些重新渲染非常重要。我已经写过不同的重新渲染场景，它们可能会导致性能提升。

在这篇文章中，我们将看到如何在不同的场景中使用不同的方法来避免使用 React 时组件的重新渲染。

# 要理解的场景

## 传递道具

在 React 中，子组件可以从它们的父组件传递道具给它们，我们可以传递任意数量的值作为道具给子组件。因此，当作为 props 传递的值改变时，子组件重新呈现，并且它应该保持视图更新。但是如果我们没有传递一个道具或者传递的道具没有改变，那么在这种情况下子组件会重新呈现吗？

是的，会的，这可能会影响你在大规模应用程序中的性能。现在，让我们看看如何使用 React 提供的`memo`方法来优化它。这里有一个例子:

在上面的例子中，如果点击`Increment`按钮，它将导致状态更新，这将触发组件重新呈现。所以，`ParentComponent` 被重新渲染了，但是它的孩子呢？这里，我们有三个孩子在`ParentComponent`、`ChildComponent1`没有通过道具、`ChildComponent2`通过了道具会在`Increment`按钮点击时改变，而`ChildComponent3`通过了道具不会改变。因此，当按钮被点击时，所有的都被渲染，即使一个没有传递任何道具，另一个没有改变道具。当使用相对较大的组件或嵌套组件时，这可能会产生问题，并导致不必要的渲染。为了防止这种情况，React 有一个高阶分量，即`memo()`。

## 备忘录()

`memo()`创建 React 组件的记忆版本，每当新的渲染触发时，它会将传递给它的道具与以前的道具进行比较，如果相同，则跳过渲染，如果不同，则触发渲染。您可以在类组件和功能组件上使用它，但是您已经为基于类的组件使用定义了`PureComponent`，它基本上与类组件的`memo()`的目的相同。当使用`memo()`时，您仍然可以在您的组件上拥有状态和上下文，它们将按预期工作。

现在，让我们使用`memo()`用新组件替换前一个示例中的三个子组件:

现在，让我们在浏览器中检查控制台，您会注意到增量按钮的点击不再呈现`ChildComponent1`和`ChildComponent3`组件。这就是在将道具传递给组件时`memo()`方法派上用场的地方。

所以，现在我们知道了如何在将道具传递给时优化我们的代码，但是这足以涵盖所有的情况吗？

## 传递参考

在前面的代码片段中，我们将状态计数器值作为道具传递，我们知道值是不同类型的，并且它们的行为方式并不相同。例如，比较两个数字不同于比较两个对象，因为数字是通过它们的值来比较的，而对象是通过它们在内存中的引用来比较的。`5 === 5`返回真，但`{a: 5}==={a: 5}`返回假。

为了更好地理解，让我们看一个例子:

在上面的例子中，我们向第一个子组件`Child1`传递状态计数器，向第二个子组件`Child2`传递函数。这里我们使用了`memo()`特设(如上所述)来优化这个例子，并避免不必要的`Child2`重新渲染。现在，让我们点击`Increment`按钮，检查`Child2`组件是否正在重新渲染。重新渲染了吗？

是的，尽管使用了`memo()` HOC，它仍然在重新渲染，这不是我们所期望的。因此，让我们分解代码，并尝试理解是什么导致了这一点。

我们在`Child2`组件上使用了`memo()` HOC，所以我们有一个组件的内存化版本，只有当传递的属性改变时，它才会改变，但是传递的属性只是一个静态函数，那么它是如何改变的呢？每次重新渲染`Parent`组件时，它都会改变。当传递一个函数作为属性时，我们传递它的引用，因此每次重新渲染时，该函数在内存中的不同存储位置重新创建，即引用，因此`memo()`每次都获得新的引用进行比较，从而导致重新渲染。现在，我们知道了渲染的原因，我们如何解决这个问题呢？

注意:只有在使用函数组件时才会发生这种情况，因为类组件不会在每次渲染时重新创建定义在其中的函数，它只是调用其渲染方法。

React 团队意识到在功能组件中定义一个功能会导致这个问题。因此，他们想出了一个解决问题的办法，即`useCallback`挂钩。

## 使用回调挂钩

`useCallback`有点类似于`memo()` HOC。`useCallback`钩子创建了一个内存化版本的函数，其中存在一个依赖数组，只有当依赖数组中的任何值发生变化时，该函数才会被重新创建，因此，如果回调中使用的参数修改了返回的最终结果，那么它会将该参数添加到依赖数组中，如果该数组为空，则该函数不会再次被重新创建。

所以，让我们使用这个钩子并传递一个新的内存化函数来解决重新渲染的问题。这一次，我们应该忽略`memoizedFunction`函数，而对`Child2`组件使用`handleEvent`函数。

`const memoizedFunction = useCallback(handleEvent, [])`

现在，我们已经修复了使用`memo`和`useCallback`将引用作为道具传递时的重新渲染问题

## 使用上下文 API

当使用上下文时，我们必须小心我们作为值传递的内容，因为一个修改和`Provider`标签中组件的整个树结构都会重新呈现。因此，为了防止这种情况，建议在`Provider`标签下的所有组件上使用`memo`。这样你就可以避免未知的渲染来传播整个树。如果将函数作为上下文向下传递，一定要记得使用`useCallback`钩子，对于需要大量时间返回数据的函数，我们可以使用`useMemo`钩子。现在让我们看看`useMemo`钩子是做什么的。

## 使用备忘录挂钩

我们已经介绍了用于优化的`memo()` HOC 和`useCallback`钩子，现在让我们看看同样用于优化的`useMemo`钩子。`useMemo`钩子类似于`useCallback`钩子，两者遵循相同的内存化原则，唯一的区别是`useCallback`钩子内存化函数，而`useMemo`钩子内存化函数返回的数据。在某些情况下，您的实用函数会在相当长的时间内返回一个数据/一组数据，因此，您不希望每次重新渲染组件时都运行该函数。您只希望它在返回一组新数据时运行。这个钩子还接受两个参数，第一个是回调，第二个是依赖数组。让我们看一个例子:

在本例中，每次您单击`Increment`按钮并修改状态时，父组件都会重新呈现，并且`heavyComputationFunction` 函数也会在每次状态改变时重新创建并重新运行，同时返回相同的数据。这可能会对性能产生影响。只有当函数返回一个新值时，你才会希望它运行，这就是`useMemo`派上用场的地方。`useMemo`钩子接受一个回调和一个依赖数组，并存储第一次函数运行时返回的值，现在，如果依赖数组中的任何值发生变化，它将重新运行并重新计算。因此，在上面的例子中，只需将第 9 行替换为:

`const message = useMemo(heavyComputationFunction, []);`

现在，函数`heavyComputationFunction`不会在每次组件被重新渲染时被调用，因为该值被记忆了。

# 结论

祝贺您在文章中读到这里。但是如果你正在考虑在你的应用结构中使用`memo()`、`useCallback`和`useMemo`，不管是否需要，因为使用它们会让你的网络应用更快、更好，而且没有副作用…

我应该马上阻止你。

![](img/85854d2c58a8d1b480639112b99d94a7.png)

资料来源:giphy.com

到处使用这些方法将是一个可怕的想法。你应该始终考虑到，使用这些方法，记忆数据和比较，也需要时间和计算能力。有时候，在你的 web 应用程序开始感觉缓慢/迟缓之前，最好不要使用这些方法。这些方法很好，但也有副作用。如果你想知道更多关于它们的副作用和比较，这里有一个帖子值得一读:

[](https://kentcdodds.com/blog/usememo-and-usecallback) [## 何时使用备忘录和使用回拨

### 性能优化总是有代价的，但并不总是有好处的。让我们谈谈成本和…

kentcdodds.com](https://kentcdodds.com/blog/usememo-and-usecallback)