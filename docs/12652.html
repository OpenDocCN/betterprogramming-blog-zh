<html>
<head>
<title>Swift with SOLID Principles — improve with iterations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">遵循坚实原则的Swift通过迭代改进</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/refactor-with-solid-principles-a-swift-use-case-91bc448eb0ff?source=collection_archive---------8-----------------------#2022-06-20">https://betterprogramming.pub/refactor-with-solid-principles-a-swift-use-case-91bc448eb0ff?source=collection_archive---------8-----------------------#2022-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cc43" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们在Swift中构建一个虚拟的人力资源系统</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/82db21b74a5f3aa8018b87f9a97ae411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Hqn8F9cQRLXaB_4Vipjvg.png"/></div></div></figure><p id="206f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">软件术语中的坚实原则不仅仅是一个时髦词，而是可伸缩软件开发离不开的东西。</p><p id="49a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在软件的生命周期中，软件开发的大部分成本都花费在软件的维护上。因此，作为开发人员，我们希望构建一些不易碎但易于维护的东西。</p><p id="3201" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你第一次听说这些原则时，它们可能看起来很学术，但是在团队中花时间开发软件后，你会很快意识到它们的重要性。我们中的一些人可能甚至没有听说过这些原则，但可能已经以某种形式遵循其中的一些原则。</p><p id="5d15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我们将尝试构建一个虚构的人力资源系统，我们将像在现实世界中一样迭代其开发生命周期。每一次迭代都将通过实现一个坚实的原则来改进代码。完整的例子可以在这里找到<a class="ae ln" href="https://gist.github.com/mvemjsun/f207d90aead162b398fcaa02a6e5d5a8" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="92fb" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">怎么开始的</h1><p id="8214" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">一天，丽莎走进了春田科技公司。经理召集了团队，并宣布他们将建立一个内部人力资源系统，这将是一种管理公司人力资源流程的开创性方法。</p><p id="212b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">经理希望系统能够做到以下几点:</p><ul class=""><li id="1096" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">它应该能够存储和检索雇员的详细信息</li><li id="3a3c" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">它应该能够通过电子邮件发送工资单</li></ul><p id="44e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">丽莎在激动中支持自己去做这项工作，第二天她想出了下面的话:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="133a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Lisa将此提交给同行评审，她的同事提出了一个问题，她的代码<em class="nb">违反了单一责任</em>原则。</p><p id="f668" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Lisa构建的模块目前有两个利益相关者:维护员工的HR和生成工资单的Payroll。</p><p id="88ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想象一下，如果人力资源部想要改变工资单的生成方式(他们想要的不仅仅是通过电子邮件发送工资单，他们还想打印工资单并通过蜗牛邮件发送)。</p><p id="9f44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将意味着在目前的设计下，整个模块将需要重新编译，从而影响工资。同样，如果IT部门想要改变数据库的内部工作方式，整个模块将需要重新编译，这会影响人力资源！</p><h1 id="9b5b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">单一责任原则</h1><p id="1d49" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这一原则有几层含义，其中最突出的是:</p><blockquote class="nc nd ne"><p id="f8a2" class="kr ks nb kt b ku kv jr kw kx ky ju kz nf lb lc ld ng lf lg lh nh lj lk ll lm ij bi translated">一个函数或模块应该只有一个改变的理由。</p><p id="6c90" class="kr ks nb kt b ku kv jr kw kx ky ju kz nf lb lc ld ng lf lg lh nh lj lk ll lm ij bi translated">一个功能或模块应该只有一个利益相关者(例如:人力资源，工资等)。</p></blockquote><p id="0e5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">丽莎回到绘图板，想出了下面的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="21f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们已经可以看到代码现在好多了。<code class="fe ni nj nk nl b">EmployeeDatabase</code>和<code class="fe ni nj nk nl b">Payroll</code>的内部工作原理是从<code class="fe ni nj nk nl b">HRSystems</code>中提取出来的。</p><p id="57cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">需要对它们进行的任何更改都不会直接影响<code class="fe ni nj nk nl b">HRSystems</code>模块。</p><h1 id="f43f" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">开闭原则(OCP)</h1><p id="07f7" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这项原则规定:</p><blockquote class="nc nd ne"><p id="f5df" class="kr ks nb kt b ku kv jr kw kx ky ju kz nf lb lc ld ng lf lg lh nh lj lk ll lm ij bi translated">软件产品应该对扩展开放，但对修改关闭。</p></blockquote><p id="43b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当Lisa对她最后一轮重构感到满意时，她的老板走过来对她说，他希望Payroll模块能够打印工资单，并将其与生成的现有电子邮件一起发送给员工。</p><p id="0a78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以丽莎想出了以下的变化:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d855" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以看到，由于采用了SRP，我们能够在不影响<code class="fe ni nj nk nl b">HRSystems</code>模块的情况下修改<code class="fe ni nj nk nl b">Payroll</code>模块。<em class="nb">我们能够扩展</em> <code class="fe ni nj nk nl b"><em class="nb">HRSystem</em></code> <em class="nb">模块的功能，而不必直接修改它</em>。</p><h1 id="8853" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">利斯科夫替代原理</h1><p id="99ac" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">完成之前的更改后，Lisa的同事Moe对她的同行评审请求做出了评论，他从经理那里听说，他们希望能够更换到不同的数据库系统，以防与现有数据库供应商的谈判不尽如人意。</p><p id="440f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着Lisa将需要构建她的代码，以便与数据库无关的模块应该与数据库的任何更改和数据库层的实现隔离开来。</p><blockquote class="nc nd ne"><p id="e496" class="kr ks nb kt b ku kv jr kw kx ky ju kz nf lb lc ld ng lf lg lh nh lj lk ll lm ij bi translated">利斯科夫替代原理指出，如果有两个T类型的对象O1和U类型的O2，那么当U是T的类型时，根据O1定义的函数F在O1被O2替代时应该表现不变。</p></blockquote><p id="ea1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Lisa和Moe组合在一起，提出了以下重构代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="aec8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">丽莎和莫伊第一次介绍了一个<code class="fe ni nj nk nl b">Database</code>应该做的<code class="fe ni nj nk nl b">protocol</code>。</p><p id="db8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类似地，<code class="fe ni nj nk nl b">EmployeeDatabase</code>的任何引用都被它的抽象<code class="fe ni nj nk nl b">Database</code>所取代。我们已经使<code class="fe ni nj nk nl b">RelationalDatabase</code>和<code class="fe ni nj nk nl b">NoSQLDatabase</code>T17采用和<em class="nb">符合</em>协议。</p><p id="531d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这使我们能够用我们选择的数据库实现(RDBMS或NoSQL)初始化<code class="fe ni nj nk nl b">HRSystems</code>模块，而不影响系统行为。</p><p id="cf20" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们能够用RDBMS或NoSQL代替数据库，而不影响系统行为。</p><h1 id="c91a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">接口隔离原则(ISP)</h1><p id="3c92" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">该系统现在运行良好，仍有一些改进可以对<code class="fe ni nj nk nl b">HRSystems</code>模块进行，以满足ISP的要求。</p><p id="527c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个模块可能被那些只对“员工操作”感兴趣的人使用，同样，也可能有另一组人只对生成“工资单”感兴趣。</p><p id="888e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目前的情况是，如果任何员工操作需要更改，也会影响到工资操作，因为模块需要重新构建，反之亦然。</p><p id="0255" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了克服这个问题，我们将不得不从单个模块中组合出 <code class="fe ni nj nk nl b"><em class="nb">HRSystems</em></code> <em class="nb">模块。这些模块要么做<code class="fe ni nj nk nl b">EmployeeOperations</code>要么做<code class="fe ni nj nk nl b">PayrollOperations</code>。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9cec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在已经能够将员工操作和工资操作隔离到它们自己的模块中，这样它们中每一个的变化都不会直接影响<code class="fe ni nj nk nl b">HRSystems</code>模块(甚至模块本身也是解耦的)。</p><p id="1c2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这有助于满足ISP。<code class="fe ni nj nk nl b">HRSystems</code>模块由<code class="fe ni nj nk nl b">EmployeeOperations</code> &amp; <code class="fe ni nj nk nl b">PayrollOperations</code>组成。</p><p id="7d28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ni nj nk nl b">HRModuleBuilder</code>帮助我们构建一个<code class="fe ni nj nk nl b">HRSystems</code>模块，在运行时将雇员和工资模块注入其中。</p><h1 id="6bcd" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">依存倒置原则</h1><p id="b8f3" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">如果你一直坚持到现在，你会很高兴地知道我们已经满足了依赖倒置原则</p><p id="e21f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">源代码模块应该依赖抽象，而不是实现。<code class="fe ni nj nk nl b">HRSystem</code>模块只依赖于抽象类型(协议)<code class="fe ni nj nk nl b">EmployeeOperations</code>和<code class="fe ni nj nk nl b">PayrollOperations</code>，因此颠倒了我们本来会有的依赖关系。</p><p id="41c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类似地，<code class="fe ni nj nk nl b">EmployeeModule</code>和<code class="fe ni nj nk nl b">PayrollModule</code>依赖于<code class="fe ni nj nk nl b">Database</code>抽象，而不是实际的<code class="fe ni nj nk nl b">Database</code>实现。</p><p id="8caf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们画一个从一个模块到它的依赖关系的箭头，我们会看到反转。</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="b837" class="nq lp iq nl b gy nr ns l nt nu">HRSystems → EmployeeOperations ← EmployeeModule (inverted dependency)</span><span id="1bdb" class="nq lp iq nl b gy nv ns l nt nu">HRSystems → PayrollOperations ← PayrollModule (inverted dependency)</span></pre><h1 id="70ce" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结果呢</h1><p id="8dd0" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">下面是我们在实现了坚实的原则后最终得到的类关系图。完整的例子可以在<a class="ae ln" href="https://gist.github.com/mvemjsun/f207d90aead162b398fcaa02a6e5d5a8" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/70e84735bbfc040894bf8b51ec906a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*YZhRvpqlpnp9904Jot8Xtw.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">坚固的系统</p></figure><h2 id="138e" class="nq lp iq bd lq ob oc dn lu od oe dp ly la of og ma le oh oi mc li oj ok me ol bi translated">观察</h2><ul class=""><li id="1eaa" class="ml mm iq kt b ku mg kx mh la om le on li oo lm mq mr ms mt bi translated">该系统被分成多个模块，每个模块有一个单独的职责(SRP)。</li><li id="ce7e" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">像Emp，Pay &amp; DB这样的模块可以独立扩展而不影响其他模块(OCP)</li><li id="0431" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">这些模块依赖于数据库的抽象，因此它们可以用任何选择的实现(LSP)来实例化。</li><li id="3fed" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">HRSystems模块<em class="nb">由员工和薪资模块</em>组成，对其中任何一个模块的更改都可以独立完成，不会相互影响(ISP)。</li><li id="64ae" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">在系统中很好地使用了协议，因为模块依赖于<em class="nb">抽象，而不是实现</em>。HRSystems模块依赖于<code class="fe ni nj nk nl b">EmployeeOperations</code> &amp; <code class="fe ni nj nk nl b">PayrollOperations</code>。类似地<code class="fe ni nj nk nl b">EmployeeModule</code> &amp; <code class="fe ni nj nk nl b">PayrollModule</code>依赖于<code class="fe ni nj nk nl b">Database</code>，后者是数据库系统的抽象。这有助于实现依赖性反转(DI)。</li></ul><h1 id="281c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="7fbe" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">对于任何相当复杂的代码库来说，采用可靠的原则不是一种选择，而是一种必要。它允许我们</p><ul class=""><li id="039c" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">建立一个模块化的系统。</li><li id="6b9a" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">系统组件具有低耦合性。</li><li id="b339" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">单个模块变得易于理解和推理。</li><li id="3270" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">对系统一部分的改变不会轻易影响到其他部分(模块隔离)。</li><li id="1145" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">单个模块的单元测试变得更加容易(因为模块依赖于抽象而不是实现，所以能够将模拟实现注入到模块中)。</li><li id="08fb" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">可以放心地进行更改(因为在测试金字塔中，较低层次的代码比较高层次的代码耦合性更低，可测试性更强)。</li><li id="7c63" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">软件维护成本很高，所以我们希望能够拥有上述功能。</li></ul></div></div>    
</body>
</html>