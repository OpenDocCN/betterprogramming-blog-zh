<html>
<head>
<title>Master Bitwise Operations in 10 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10分钟掌握位运算</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/master-bitwise-operations-in-10-minutes-7842c65608d7?source=collection_archive---------9-----------------------#2020-03-18">https://betterprogramming.pub/master-bitwise-operations-in-10-minutes-7842c65608d7?source=collection_archive---------9-----------------------#2020-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8448" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">细节决定成败——如果你弄错了，你会得到不同的答案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c5a43152dbc4ee1038173316e09b2d3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6uCtBdtSHteBz6f-S8ubCg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@hope_house_press_leather_diary_studio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">希望之家出版社——皮革日记工作室</a>在<a class="ae ky" href="https://unsplash.com/s/photos/binary?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="806b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近开始学习c语言，这并不是因为我预见到雇主的需求会激增，也不是像我的一些朋友和同事所说的那样，因为我讨厌自己，而是因为这是提高你的计算机科学基础的一种可靠方法。回到基础(但不是一直回到基础)，迫使你面对你觉得编程最可怕的事情。</p><p id="c813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，这就是位运算——在你的机器中对单个位的直接操作。有了按位操作，你就像在二进制汤里溅水一样，几十年的抽象和语言发展让我们大多数人都忘记了它。</p><p id="1855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想感受一下你的计算机和你的程序实际上是如何工作的，位操作是一种方法。这并不直观，但也没有看起来那么可怕。</p><p id="bc33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为它看起来很吓人。</p><p id="aca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题来自Kernighan和Ritchie的重要著作《C编程语言》:</p><blockquote class="lv lw lx"><p id="7d67" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">编写一个函数<strong class="lb iu"> setbits(x，p，n，y) </strong>，返回<strong class="lb iu"> x </strong>，从位置<strong class="lb iu"> p </strong>开始的<strong class="lb iu"> n </strong>位设置为<strong class="lb iu"> y </strong>的最右边<strong class="lb iu"> n </strong>位，其余位保持不变。</p></blockquote><p id="4e8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这是一个令人困惑的问题，不要担心，因为下面的解决方案可以让一切变得清晰:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="952c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">啊，是的，当然。没想到那一点多傻啊。</p><p id="6b73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要让那串象形文字吓到你。到本文结束时，您将确切地知道如何分解它，理解每个部分，并可视化每个步骤的二进制转换。</p><p id="ed1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它假设您对二进制有足够的了解，能够接受一个位可以是0或1，您乐于从右向左阅读二进制，并且您理解十进制数是如何表示的。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="a77e" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">经营者</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/f0b57744d2323074b60ac406f0888cbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Izc4w1eS7mAT85_U_1TJZA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@swimstaralex?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚历山大·辛恩</a>在<a class="ae ky" href="https://unsplash.com/s/photos/binary?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ccbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的主角是按位运算符。让我们快速浏览一下。</p><h2 id="b8d2" class="ne mm it bd mn nf ng dn mr nh ni dp mv li nj nk mx lm nl nm mz lq nn no nb np bi translated">&amp;(按位与)</h2><p id="0d3f" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">不要试图将它与您可能熟悉的逻辑AND (&amp;&amp;)的定义联系起来，更简单的方法是记住这个定义:</p><blockquote class="lv lw lx"><p id="89c8" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">&amp;通过将两个操作数中任何不为1的位设置为0来组合操作数。</p></blockquote><p id="adfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，&amp;用于关闭位。</p><p id="51e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="1331" class="ne mm it nw b gy oa ob l oc od">x = 11111111<br/>y = 00000000<br/>x &amp; y<br/> =&gt; 00000000</span></pre><p id="14d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，<em class="ly"> x </em>由设置为1的8位组成(255的二进制表示)。<em class="ly"> y </em>由设置为0的8位组成。&amp;将<em class="ly">和</em>中任何不为1的位设置为0。因为<em class="ly"> y </em>没有1，所以一切都变成了0。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="3638" class="ne mm it nw b gy oa ob l oc od">x = 10101010<br/>y = 01010101<br/>x &amp; y<br/> =&gt; 00000000</span></pre><p id="13a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个版本中，<em class="ly"> x </em>和<em class="ly"> y </em>都有4位设置为1，但是这1位没有一个相互对齐。在每个位置，要么<em class="ly"> x </em>为1，要么<em class="ly"> y </em>为1，但不能同时为2。正如我们所知，&amp;将<em class="ly">两个操作数</em>中任何不为1的位设置为0。再一次，一切都变成了0。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="3357" class="ne mm it nw b gy oa ob l oc od">x = 00111100<br/>y = 00001111<br/>x &amp; y<br/> =&gt; 00001100</span></pre><p id="6a7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个更有意思。<em class="ly"> x </em>和<em class="ly"> y </em>都有4个1位，但是在两个地方都只有<em class="ly">都是</em> 1。因此，除了开始都是1的那两个地方，所有东西都被设置为0。</p><h2 id="46f5" class="ne mm it bd mn nf ng dn mr nh ni dp mv li nj nk mx lm nl nm mz lq nn no nb np bi translated">|(按位或)</h2><p id="22d9" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">忘记你所知道的逻辑OR (||)，接受这个新的定义:</p><blockquote class="lv lw lx"><p id="bf1d" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">|通过将操作数中任何一个为1的位设置为1来组合操作数。</p></blockquote><p id="b000" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得|的开开关变成了关开关。</p><p id="fc8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="92f5" class="ne mm it nw b gy oa ob l oc od">x = 11111111<br/>y = 00000000<br/>x | y<br/> =&gt; 11111111</span></pre><p id="ccf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ly"> y </em>全是0，但是因为|只需要在<em class="ly">或者</em>操作数中看到1，而<em class="ly"> x </em>全是1，所以输出也全是1。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="6216" class="ne mm it nw b gy oa ob l oc od">x = 10101010<br/>y = 01010101<br/>x | y<br/> =&gt; 11111111</span></pre><p id="332e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ly"> x </em>和<em class="ly"> y </em>中的1没有一个排成一行，但是因为<em class="ly">的每个位置</em>至少有一个1，所以返回值中的一切都是1。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="62af" class="ne mm it nw b gy oa ob l oc od">x = 00111100<br/>y = 00001111<br/>x | y<br/> =&gt; 00111111</span></pre><p id="51ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，除了最左边的两位，每个位置的<em class="ly"> x </em>和<em class="ly"> y </em>中至少有一个位置为1。因为那些都是0，所以它们保持为0。其他都是1。</p><h2 id="6c1c" class="ne mm it bd mn nf ng dn mr nh ni dp mv li nj nk mx lm nl nm mz lq nn no nb np bi translated">^(按位异或)</h2><p id="7c5e" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">按位异或在操作数具有不同位的每个位置设置1，如果它们相同则设置0。例如:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="0451" class="ne mm it nw b gy oa ob l oc od">x = 10101010<br/>y = 01010101<br/>x ^ y<br/> =&gt; 11111111</span></pre><p id="bc6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">x和y中的每一位都是不同的，所以输出中的每一位都是1。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="3458" class="ne mm it nw b gy oa ob l oc od">x = 11001100<br/>y = 11001100<br/>x ^ y<br/> =&gt; 00000000</span></pre><p id="dc6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，情况正好相反。每一位都是一样的，所以一切都被设置为0。</p><h2 id="5e38" class="ne mm it bd mn nf ng dn mr nh ni dp mv li nj nk mx lm nl nm mz lq nn no nb np bi translated">&lt;&lt; (left shift)</h2><p id="74d1" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">Left shift shunts bits to the left by the number of places you specify, filling the space created with 0-bits.</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="0ad7" class="ne mm it nw b gy oa ob l oc od">x = 00000011<br/>x &lt;&lt; 2<br/> =&gt; 00001100</span></pre><p id="70fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ly"> x </em>左移两个位置，导致两个新的0填充1留下的空间。</p><p id="4fb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为二进制的工作原理是，每一列代表2的连续幂(1，2，4，8，16…)，所以左移两个位置相当于乘以4。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="137b" class="ne mm it nw b gy oa ob l oc od">2 ^ 2 places = 4.</span></pre><p id="5997" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更大的移位对应于乘以2的更大幂次。</p><p id="bc39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个例子:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="457b" class="ne mm it nw b gy oa ob l oc od">x = 11111111<br/>x &lt;&lt; 4<br/> =&gt; 11110000 OR 111111110000</span></pre><p id="969d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于本教程的目的，当移动超过左端时，数据会丢失。实际上，数据是否丢失将取决于您使用的数据类型的容量。</p><p id="e515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子的开始，<em class="ly"> x </em>是一个1字节的数(8位== 1字节)。将它移位4个位置后，它占用12位，因此至少需要2字节的空间。</p><p id="2a47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果将该操作的结果赋给像C char这样的1字节数据类型，那么最左边的4个1将会丢失，从而产生1字节值11110000。像int这样较大的数据类型可以处理额外的位。</p><h2 id="1199" class="ne mm it bd mn nf ng dn mr nh ni dp mv li nj nk mx lm nl nm mz lq nn no nb np bi translated">&gt; &gt;(右移)</h2><p id="1547" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">左移的反义词。</p><p id="0f7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于右移，总是会有数据丢失。从右边掉下来的部分永远消失了。右移位左侧的空格用零填充。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="ac58" class="ne mm it nw b gy oa ob l oc od">x = 00110011<br/>x &gt;&gt; 2<br/> =&gt; 00001100</span></pre><p id="c55f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如左移相当于乘以4，右移相当于除以4(整数除法——没有小数点)。</p><h2 id="3e0a" class="ne mm it bd mn nf ng dn mr nh ni dp mv li nj nk mx lm nl nm mz lq nn no nb np bi translated">~(某人的补充)</h2><p id="5dd3" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">一的补码运算符只是反转二进制字中的每一位。1变成0，0变成1。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="87f3" class="ne mm it nw b gy oa ob l oc od">x = 00001111<br/>~x<br/> =&gt; 11110000</span></pre><p id="cc6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是非常有用的。你会经常看到符号~0，意思是“给我足够的1来填充所有可用空间”。正如我将要演示的，这被用来创建“屏蔽”，隔离二进制单词中要被删除、替换或移动的段。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="439f" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">二进制解题</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/2884363449c38b8554203a4a63177061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHvx69TopZ2KvP7o4EiMVw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cdr6934?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae ky" href="https://unsplash.com/s/photos/circuit?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="46e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们知道的足够多，可以开始解决我们的问题了:</p><blockquote class="lv lw lx"><p id="3f96" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">编写一个函数<strong class="lb iu"> setbits(x，p，n，y) </strong>返回<strong class="lb iu"> x </strong>，将从位置<strong class="lb iu"> p </strong>开始的<strong class="lb iu"> n </strong>位设置为<strong class="lb iu"> y </strong>的最右侧<strong class="lb iu"> n </strong>位，其余位保持不变。</p></blockquote><p id="4f28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，我们需要取一个二进制字，<em class="ly"> x </em>，用从<em class="ly"> y </em>开始的相同大小的二进制块替换位置<em class="ly"> p </em>处的<em class="ly"> n </em>宽的二进制块。</p><p id="de11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几点需要注意:首先，position <em class="ly"> p </em> = 0位于二进制字的右侧<em class="ly">处。其次，每当我使用“二进制单词”时，那只是意味着“一些二进制”——任何自包含的二进制代码。</em></p><p id="778c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来分解一下。</p><h2 id="8ddd" class="ne mm it bd mn nf ng dn mr nh ni dp mv li nj nk mx lm nl nm mz lq nn no nb np bi translated">面具</h2><blockquote class="lv lw lx"><p id="8c07" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">从位置<strong class="lb iu"> p </strong>开始的n个<strong class="lb iu">位</strong></p></blockquote><p id="763f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当您看到处理一系列<em class="ly"> n </em>位的位操作问题时，您可能想要使用<em class="ly">掩码</em>。</p><p id="90b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">掩码就是一大块长度与输入二进制数相同的1和0。输入中任何你想改变的都被设置为0，其他的都保持不变。这样，当您运行<code class="fe of og oh nw b">input &amp; mask</code>时，两者中为1的所有内容都将保持不变，并且输入的现有0将保持为0(因为虽然它们在掩码中为1，但它们在输入中不是1)，但是输入中与您在掩码中创建的0区域重叠的所有1都将被设置为0。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="da43" class="ne mm it nw b gy oa ob l oc od">mask  = 11100011<br/>input = 11010111<br/>input &amp; mask<br/>     =&gt; 11000011</span></pre><p id="5809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您已经在input中创建了一个0填充的区域，该区域可以设置为您想要的值，并且您已经完成了该操作，而没有更改关于input的任何其他内容。</p><h2 id="c79a" class="ne mm it bd mn nf ng dn mr nh ni dp mv li nj nk mx lm nl nm mz lq nn no nb np bi translated">为<em class="oi"> x </em>创建一个遮罩</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="c295" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了演示，我们将使用这些值:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="4179" class="ne mm it nw b gy oa ob l oc od">x = 10110101<br/>p = 5<br/>n = 3<br/>y = 01001111</span></pre><p id="e7b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们来解构一下这个表达式的左边。总是从一个棘手的问题开始，把它分解成最小的组成部分。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="45de" class="ne mm it nw b gy oa ob l oc od">~0 &lt;&lt; n</span></pre><p id="b7ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用英语来说，这表示“创建一个足够大的1的字段来填充我正在工作的空间，然后将它向左移动<em class="ly"> n </em>个位置。”当你左移时会发生什么？空出的位置用零填充。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="57da" class="ne mm it nw b gy oa ob l oc od">~0 &lt;&lt; 3         <br/>=&gt; 11111111 &lt;&lt; 3   <br/>=&gt; 11111000</span></pre><p id="e8c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们看到了这个:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="cf27" class="ne mm it nw b gy oa ob l oc od">~(~0 &lt;&lt; n)</span></pre><p id="b5e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">括号外的额外补码运算符表示“取(~0 &lt;&lt; n) and invert it again”.</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="c6c2" class="ne mm it nw b gy oa ob l oc od">~(11111000)<br/>=&gt; 00000111 </span></pre><p id="985f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Currently, our mask has an <em class="ly"> n </em>)的结果——与<em class="ly"> x </em>的开头对齐的1的宽度块。但是这样不好，因为我们需要一大块从位置<em class="ly"> p </em>开始的0！</p><p id="605b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当你需要在一个二进制单词中移动位置时，移位就是你的首选。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="d32e" class="ne mm it nw b gy oa ob l oc od">~(~0 &lt;&lt; n) &lt;&lt; (p + 1 - n)<br/>=&gt; 00000111 &lt;&lt; (p + 1 - n)<br/>=&gt; 00000111 &lt;&lt; (5 + 1 - 3)<br/>=&gt; 00000111 &lt;&lt; 3<br/>=&gt; 00111000</span></pre><p id="c80c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么(p + 1 -n)？所有的移动都是相对于该字的右侧，因此我们正在计算移动3位数据块的<em class="ly">端</em>(即右侧)必须移动的位数，以便它的起始位置位于位置<em class="ly"> p </em> = 5。</p><p id="a23d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们加1是因为位置是零索引的(我们从0开始计数)，但是大小<em class="ly"> n </em>不是。如果我们不加1，我们的掩码将会移位1位。</p><p id="66dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的掩码中的1现在与我们想要在<em class="ly"> x </em>中改变的位对齐。但是你想用蒙版<em class="ly">改变</em>的区域应该总是0。当您对输入和掩码应用按位AND时，输入中0区域内的所有内容都将被关闭。我们需要在表演前做最后一次翻转。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="5177" class="ne mm it nw b gy oa ob l oc od">~(~(~0 &lt;&lt; n) &lt;&lt; (p + 1 - n))<br/>=&gt; ~(00000111 &lt;&lt; 3)<br/>=&gt; ~(00111000)<br/>=&gt;   11000111</span></pre><p id="ad55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个完整的面具。当x和mask与&amp;组合时，掩码的0-区域将关闭x中任何相应的1，留下一个区域准备用<em class="ly"> y </em>的第一个<em class="ly"> n </em>位填充。</p><p id="4d6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们表达式的整个左侧解析为:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="55e3" class="ne mm it nw b gy oa ob l oc od">(x &amp; ~(~(~0 &lt;&lt; n) &lt;&lt; (p + 1 - n)))<br/>=&gt; x &amp; 11000111<br/>=&gt; 10110101 &amp; 11000111<br/>=&gt; 10000101</span></pre><p id="05cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<em class="ly"> x </em>和掩码中所有不为1的值现在都为零。其他一切都没变。</p><h2 id="af99" class="ne mm it bd mn nf ng dn mr nh ni dp mv li nj nk mx lm nl nm mz lq nn no nb np bi translated">从y中提取目标位</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="5e15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">挑战的下一部分是隔离“y的最右边的<em class="ly"> n </em>位”。让我们再一次深入到表达式左边最小的部分，并从那里开始构建，但这次要快一点。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="ed23" class="ne mm it nw b gy oa ob l oc od">~(~0 &lt;&lt; n)<br/>=&gt; ~(11111111 &lt; 3)<br/>=&gt; ~(11111000)<br/>=&gt; 00000111</span></pre><p id="b61d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们根据需要创建尽可能多的，用~0填充可用空间。然后我们左移3个位置，最后将其全部反转以创建一个掩码，当用&amp;应用于<em class="ly"> y </em>时，除了最右边的3位之外的所有内容都将被关闭。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="04af" class="ne mm it nw b gy oa ob l oc od">y &amp; ~(~0 &lt;&lt; n))<br/>=&gt; y &amp; 00000111<br/>=&gt; 01001111 &amp; 00000111<br/>=&gt; 00000111</span></pre><p id="67f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<em class="ly"> y </em>中的前3位一开始都是1，当与掩码组合时，它们都保持为1。其他的都是0。</p><p id="9c06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要移动这3位来对齐我们刚刚在<em class="ly"> x. </em>中创建的空的、填充了0的空间，正如你现在所知道的，这意味着移位。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="e1b2" class="ne mm it nw b gy oa ob l oc od">((y &amp; ~(~0 &lt;&lt; n)) &lt;&lt; (p + 1 - n))<br/>=&gt; 00000111 &lt;&lt; (5 + 1 - 3)<br/>=&gt; 00000111 &lt;&lt; 3<br/>=&gt; 00111000</span></pre><p id="7e06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常好。曾经是最右边的3位的<em class="ly"> y </em>现在与我们在<em class="ly"> x. </em>中创建的0填充的洞完全对齐</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="4b4e" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">合并侧面</h1><p id="cf7c" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">概括地说，我们为<em class="ly"> x </em>的位置<em class="ly"> p </em>处的3位创建了一个0的掩码，并使用&amp;将其与<em class="ly"> x </em>组合在一起，以创建一个3位0的区域。我们的左手边现在是10000101。</p><p id="aaaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们为最右边的3位<em class="ly"> y </em>创建了一个掩码，使用&amp;将其与<em class="ly"> y </em>组合，这样除了这3位之外的所有内容都被关闭。这个3位的块被左移，与我们在<em class="ly"> x. </em>中创建的空间完全对齐，我们右边的大小现在是00111000。</p><p id="d9a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了用右边的3位来填充左边的0位，我们需要按位“或”,它打开任何一个操作数为1的值。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="333b" class="ne mm it nw b gy oa ob l oc od">LHS | RHS<br/>=&gt; 10000101 | 00111000<br/>=&gt; 10111101</span></pre><p id="e7f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗒哒！</p><p id="adf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是了。解决任何按位运算问题的过程都是将其缩减到最小的部分，考虑您必须构建的掩码和需要移动的位置以解决每个部分，然后使用按位运算子&amp; and |将掩码和部分组合起来。</p><p id="bd25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个问题中我们没有使用按位异或(^)，但是<a class="ae ky" href="http://www.learntosolveit.com/cprogramming/Ex_2.7_invert.html" rel="noopener ugc nofollow" target="_blank">找到另一个</a>，尝试一下，有创意！就像二进制本身一样，涉及位运算的问题是一个深入到基础知识，然后从构建块逐步构建复杂解决方案的问题。</p><p id="a0ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，走出去，用计算机时代的问题给你的朋友留下深刻印象。</p></div></div>    
</body>
</html>