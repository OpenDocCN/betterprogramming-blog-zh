<html>
<head>
<title>Raspberry Pi GPIO — Using SPI to display arbitrary patterns on a MAX7219 Dot Matrix Display Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">raspberry Pi GPIO——使用SPI在MAX7219点阵显示模块上显示任意图案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/raspberry-pi-gpio-using-spi-to-display-arbitrary-patterns-on-a-max7219-dot-matrix-display-module-34a269f35c60?source=collection_archive---------9-----------------------#2022-04-26">https://betterprogramming.pub/raspberry-pi-gpio-using-spi-to-display-arbitrary-patterns-on-a-max7219-dot-matrix-display-module-34a269f35c60?source=collection_archive---------9-----------------------#2022-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5835" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何在Raspberry Pi上使用SPI外设</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3234194ed55a3027d16c9f863a4fcd5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JGB8U41I51ESkddsuPuxAw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:<a class="ae kv" href="https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.6_led_dot_matrix_c.html" rel="noopener ugc nofollow" target="_blank"> Sunfounder </a></p></figure><h1 id="8ded" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">概观</h1><p id="204a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这是探索在Raspberry Pi 上进行<a class="ae kv" href="https://youngkin.github.io/categories/gpio/" rel="noopener ugc nofollow" target="_blank"> GPIO编程的系列文章的第七篇。它描述了如何控制串行外设接口(SPI)外设，如</a><a class="ae kv" href="https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf" rel="noopener ugc nofollow" target="_blank"> MAX7219 LED点阵显示模块</a>。</p><p id="2062" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">阅读这篇文章有两种方法。第一种方法是跳过控制MAX7219的<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#controlling-the-max7219---direct-interaction-with-the-bcm2835" rel="noopener ugc nofollow" target="_blank">——与BCM2835的直接交互</a>部分，只关注本文的SPI和点阵显示方面。第二种方法还包括学习如何通过直接访问SPI寄存器集来控制SPI外设，而不是使用第三方库。这需要阅读控制MAX7219的<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#controlling-the-max7219---direct-interaction-with-the-bcm2835" rel="noopener ugc nofollow" target="_blank">——与BCM2835 </a>部分的直接交互。</p><p id="7b75" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果采用第二种方法，那么<a class="ae kv" href="https://youngkin.github.io/post/gpioprogramming/" rel="noopener ugc nofollow" target="_blank">Raspberry Pi GPIO——Broadcom BCM 2835 ARM外设编程简介</a>文章应被视为本文的先决条件。这篇文章介绍了直接控制连接到BCM2835的外设的关键技术，或者更一般地说，Raspberry Pi上的GPIO接口。这些关键概念包括:</p><ul class=""><li id="e48a" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">BCM2835输入/输出功能</li><li id="efa4" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">BCM2835寻址</li><li id="3d57" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">使用BCM2835寄存器</li></ul><p id="c694" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果你只对学习SPI感兴趣，而没有学习BCM2835编程的细节，那么第一种方法是最好的。</p><p id="13a9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">将涵盖以下主题:</p><ol class=""><li id="c4b7" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj nd mv mw mx bi translated"><strong class="lq ir">先决条件</strong> —描述本文所需的硬件和软件库。</li><li id="df1a" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated"><strong class="lq ir">串行外设接口(SPI)概述</strong> —介绍SPI协议和MAX7219点阵显示模块。</li><li id="9d87" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated"><strong class="lq ir">使用BCM2835板控制MAX7219点阵显示模块</strong> —提供控制MAX7219的详细信息，包括代码。它还包含一个小节，描述如何直接与BCM2835上的SPI寄存器集交互。</li><li id="d2f7" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated"><strong class="lq ir">总结</strong> —总结本文中涉及的重要概念。</li><li id="9969" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated"><strong class="lq ir">参考资料</strong> —提供了一个我认为有用的参考资料列表，以及一些在本文创作中使用的参考资料。</li></ol><h1 id="889c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">先决条件</h1><p id="fa67" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果你没有，你需要一个树莓派。我用了一个树莓派3B+与'伸展'或更高版本的Raspbian操作系统。下面引用的BCM2835库支持Raspberry Pi模型1到4。</p><p id="3de9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">接下来你需要一个<a class="ae kv" href="https://www.amazon.com/dp/B082KBF7MM/ref=sspa_dk_detail_4?psc=1&amp;pd_rd_i=B082KBF7MM&amp;pd_rd_w=1tGTV&amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;pd_rd_wg=fX8JB&amp;pf_rd_r=44DE0RS1E9FD42RBYC7R&amp;pd_rd_r=47cbdc7f-7834-455f-9429-ef74a438bd45&amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFVVkdZVUZRNUw3ODkmZW5jcnlwdGVkSWQ9QTA4MzI4MzYyU0VLNzBJM0cxRUVMJmVuY3J5cHRlZEFkSWQ9QTA0Mjk1NTMzSzNSWlNFUjU0NURBJndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==" rel="noopener ugc nofollow" target="_blank">试验板</a>，一些<a class="ae kv" href="https://www.amazon.com/dp/B08HZ26ZLF/ref=syn_sd_onsite_desktop_19?psc=1&amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUExRFpLWElCRjg1MUNMJmVuY3J5cHRlZElkPUEwMjMyMTE1M01aOFE3U1BQS09YSiZlbmNyeXB0ZWRBZElkPUEwODE5NTMxMktEMTlZRjEyQjBJNiZ3aWRnZXROYW1lPXNkX29uc2l0ZV9kZXNrdG9wJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==" rel="noopener ugc nofollow" target="_blank">跳线</a>，和一个<a class="ae kv" href="https://www.amazon.com/dp/B07VM6HXN5/ref=sspa_dk_detail_5?pf_rd_p=0c758152-61cd-452f-97a6-17f070f654b8&amp;pd_rd_wg=wF4pR&amp;pf_rd_r=8MBD40495EV7X8RR61NP&amp;pd_rd_w=A5eiC&amp;pd_rd_r=281b8d49-a176-4535-bc99-bd6108f5bc24&amp;s=toys-and-games&amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUE1NDJPSEtMOFRCWjImZW5jcnlwdGVkSWQ9QTA4MTEwODgyN0lZRFdWVkhIOFRaJmVuY3J5cHRlZEFkSWQ9QTA4NzU0NjYyQkE5UTNXTzM3SjIwJndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ&amp;th=1" rel="noopener ugc nofollow" target="_blank"> MAX7219点阵显示器</a>。您还应该考虑使用一个带有T型适配器的<a class="ae kv" href="https://www.amazon.com/dp/B082PRVRYR/ref=sspa_dk_detail_2?psc=1&amp;pd_rd_i=B082PRVRYR&amp;pd_rd_w=8mKhr&amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;pd_rd_wg=e9psa&amp;pf_rd_r=S09F37DF2G5FW8B8GX4B&amp;pd_rd_r=c065c120-e60b-45e9-b93b-f581f048cf46&amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFCMzhUQ09COFI2VlMmZW5jcnlwdGVkSWQ9QTA5NjU2ODUxRDkxNEYwSTYwV09KJmVuY3J5cHRlZEFkSWQ9QTAxOTg1MTUyRUhEUlc2VzQ2VDQ4JndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==" rel="noopener ugc nofollow" target="_blank"> 40引脚母对母，将GPIO输出连接到试验板上。您只能使用跳线，但适配器会使事情变得更容易，并有助于防止损坏Raspberry Pi上的GPIO引脚。如果您选择不购买带T型适配器的40针电缆，您需要购买</a><a class="ae kv" href="https://www.amazon.com/SinLoon-Breadboard-Arduino-Circuit-40-Pack/dp/B08M3QLL3Q/ref=pd_sbs_7/143-0445142-7950409?pd_rd_w=sVLrc&amp;pf_rd_p=8b76d7a7-ab83-4ddc-a92d-e3e33bfdbf03&amp;pf_rd_r=CDM5TGJT03VKF0ZFB577&amp;pd_rd_r=8e58fd82-8503-41cf-b8f2-c78eaeb78d25&amp;pd_rd_wg=tT1U0&amp;pd_rd_i=B08M3QLL3Q&amp;psc=1" rel="noopener ugc nofollow" target="_blank">公母跳线</a>。然而，一个树莓派的全套电子设备并不比这4个组件贵多少。我推荐购买<a class="ae kv" href="https://www.amazon.com/gp/product/B09BMVT4CB/ref=ppx_yo_dt_b_asin_title_o02_s00?ie=UTF8&amp;psc=1" rel="noopener ugc nofollow" target="_blank"> Sunfounder Raspberry Pi终极入门套装</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/27be36e989e42161cf0403c57d9e36cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*r2Jg7oGOPLPhTkMH.png"/></div></div></figure><p id="a76d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="nf">sun founder Ultimate Starter/Raphael套件</em></p><p id="48ef" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您需要一些基本的C编程知识，并且熟悉登录到Raspberry Pi终端，或者登录到一些操作系统版本附带的桌面GUI。根据您采用的方法，您可能需要将键盘和显示器连接到Raspberry Pi。我只是简单地进入Pi。您还需要熟悉如何使用像Vi或nano这样的编辑器。您需要对Linux命令行有基本的了解。</p><p id="5b88" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，您需要克隆或派生<a class="ae kv" href="https://github.com/youngkin/gpio" rel="noopener ugc nofollow" target="_blank">我的GPIO库</a>，因为它包含用于访问BCM2835上GPIO功能的底层库代码。正如在其他章节中提到的，这个库代码基于迈克·麦考利开发的<a class="ae kv" href="http://www.airspayce.com/mikem/bcm2835/index.html" rel="noopener ugc nofollow" target="_blank"> BCM2835 C库</a>。</p><h1 id="167e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">SPI(串行外设接口)概述</h1><p id="18f5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">SPI用于将数据串行发送到可以并行接受或要求数据的外设。这很有帮助，因为仅使用3个GPIO引脚就可以写入相对较大的一组并行输入，不包括电源(VCC)和接地(GND)引脚。如果不使用SPI，每个并行输入需要一个GPIO引脚。这很容易被禁止，因为引脚是有限的资源。让我们通过一个例子来看看这是如何工作的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/57bcc8477b8bb75663b6b22417df5bd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/0*v-uoijC1PM0c48SO.jpg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="nh">图片来源:作者</em></p></figure><p id="048d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上图显示的是MAX7219 LED点阵显示屏。它通常用于显示任意形状，如字母、数字和笑脸。除了MAX7219之外，SPI还可以用来控制各种外设来显示图像，从触摸屏接收输入，并与各种传感器进行交互。<a class="ae kv" href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface" rel="noopener ugc nofollow" target="_blank">维基百科有一篇很好的文章</a>更详细地描述了SPI。</p><p id="0598" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">MAX7219控制一个8×8的led矩阵。控制一个LED需要1个引脚，不包括电源或地。一个8×8的LED矩阵有64个LED。这个数字远远超过标准Raspberry Pis上可用的26或40个GPIO引脚。如下所述，利用SPI需要的GPIO引脚要少得多。</p><p id="bf7d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">MAX7219具有以下输入引脚:</p><ol class=""><li id="c52f" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj nd mv mw mx bi translated">DIN —这是串行数据输入引脚。</li><li id="1ed9" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated">CS —这通常称为片选(CS)或片使能(CE)引脚，有时也称为从机选择(SS)。</li><li id="2827" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated">CLK —此引脚连接到Raspberry Pi上的时钟引脚，用于同步Raspberry Pi和MAX7219之间的数据传输。</li></ol><p id="841d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">还有2个引脚不用于控制MAX7219。</p><ol class=""><li id="5762" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj nd mv mw mx bi translated">VCC——这是电源输入引脚。它连接到Raspberry Pi上的电源，通常是5伏电源。</li><li id="b334" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated">GND——这是接地引脚。它连接到Raspberry Pi的接地引脚。</li></ol><p id="2963" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从Raspberry Pi到MAX7219至少需要3个GPIO引脚，特别是DIN、CS和CLK引脚。Raspberry Pi只需使用这三个引脚，就能以经济高效的方式(按引脚方式)控制所有64个led。通常的方法是使用SPI专用的Raspberry Pi引脚来驱动DIN、CS和CLK引脚。这3个引脚被命名为:</p><ol class=""><li id="90b1" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj nd mv mw mx bi translated">(SPI)MOSI —这代表主机输出从机输入。MOSI引脚将连接到MAX7219 DIN引脚，用于向MAX7219(或任何SPI外设)发送串行数据信号。</li><li id="0d65" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated">(SPI)SCLK —这代表SPI时钟。此引脚将连接到MAX7219 CLK引脚。它用作同步BCM2835和MAX7219(或任何SPI外设)之间数据传输的时钟信号源。当MOSI引脚和SCLK引脚都被设为高电平时，数据传输就会发生。</li><li id="7633" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated">(SPI)CS或(SPI)CE——代表片选或片使能。无论哪种情况，将引脚设为低电平都会指示MAX7219接受数据，如前所述。</li></ol><blockquote class="ni nj nk"><p id="2f5d" class="lo lp nf lq b lr mk jr lt lu ml ju lw nl mm lz ma nm mn md me nn mo mh mi mj ij bi translated">我很不情愿地使用“主人”和“奴隶”这两个词。然而，我在SPI上阅读的所有文档中都使用了这些术语。为了避免混淆，我将继续使用它们。</p></blockquote><p id="c415" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Raspberry Pi的SPI功能可能需要多达5个GPIO引脚。这两个附加引脚是:</p><ol class=""><li id="546c" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj nd mv mw mx bi translated">(SPI)MISO —代表主机输入从机输出。此引脚允许MAX7219(或任何SPI外设)将数据发送回BCM2835。</li><li id="c40d" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated">(SPI)CS或(SPI)CE——这是第二个片选/片使能引脚。第二个CS/CE引脚允许BCM2835控制2个SPI外设。如上所述，当CS/CE引脚设为低电平时，SPI外设将接受来自BCM2835的数据。因此，通过将一个CS/CE引脚设为高电平，另一个设为低电平，我们可以控制哪个从机可以接收和发送数据。</li></ol><p id="e8c4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">文章<a class="ae kv" href="https://adikedia.com/2016/08/10/using-multiple-spi-slave-devices-with-wiringpi/" rel="noopener ugc nofollow" target="_blank">将多个SPI从器件与Raspberry Pi </a>配合使用提供了有关如何使用2个CE/CS引脚的更多信息。下图说明了如何利用2个CE/CS引脚:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/f188cbb30d33ae94cf46b2408f112248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/0*ey8BNroWU7kE9wOP.jpg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="nh">图片来源:BCM2835 ARM外设指南</em></p></figure><p id="bba2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在该原理图上方的图像中，您可能已经注意到MAX7219右侧的5个引脚。这些引脚将相应输入引脚上的信号输出到其他MAX7219s。这允许将两个以上的MAX7219s“链接”在一起，以创建更大的显示器，例如128个LED或256个LED显示器。这个过程称为菊花链。这可以通过将主SPI外设的输出引脚连接到链中下一个外设的相应输入引脚来实现。菊花链可用于在逻辑上更大的LED矩阵上显示多个字符，或创建滚动显示。这个<a class="ae kv" href="https://forum.arduino.cc/t/daisy-chaining-multiple-max7219-chips/3305" rel="noopener ugc nofollow" target="_blank"> Arduino论坛主题</a>提供了关于如何实现这一点的高级解释。<a class="ae kv" href="https://thesolaruniverse.wordpress.com/2016/05/10/news-ticker-with-three-max7219-8x8-dot-led-matrix-devices/" rel="noopener ugc nofollow" target="_blank">带有三个MAX7219 8×8点阵led设备的新闻报道</a>是我能找到的关于实现特定项目的最佳文章。然而，它描述了如何用Sketch(一种编写基于Python的代码片段的方法)来完成这一点，而不是c。在这两个来源之间，可能有足够的关于如何使用c来完成这一点的提示。</p><blockquote class="ni nj nk"><p id="5f98" class="lo lp nf lq b lr mk jr lt lu ml ju lw nl mm lz ma nm mn md me nn mo mh mi mj ij bi translated"><a class="ae kv" href="https://www.amazon.com/HiLetgo-MAX7219-Arduino-Microcontroller-Display/dp/B07FFV537V/ref=sr_1_9?crid=DWVTBTEX09G8&amp;keywords=8x64+led+matrix+module&amp;qid=1650744886&amp;sprefix=8x64+led+matrix+module%2Caps%2C117&amp;sr=8-9" rel="noopener ugc nofollow" target="_blank">可以购买大于8x8 </a>的LED矩阵模块，避免了手动菊花链连接多个器件。</p></blockquote><p id="82cf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">BCM2835的主SPI接口SPI0通过GPIO引脚7–11实现。引脚7和8是BCM2835上可用的2个CE/CS引脚。引脚9是MISO，10是MOSI，11是时钟(SPICLK/SCLK)。BCM2835有两个辅助SPI接口:SPI1(也称为AUX_SPI0)和SPI2(也称为AUX_SPI1)。根据BCM2835 ARM外设指南，SPI1位于引脚16–21，SPI2位于引脚35–39。这些辅助接口可通过AUX I/O功能获得。</p><p id="4f27" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下图显示了一个常用于将BCM2835 GPIO引脚连接到试验板的GPIO扩展板。这些引脚标有它们的GPIO引脚编号或它们支持的I/O功能(例如SPI)。注意:SPI引脚在电路板上的标签使用与上述相同的术语:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/cf3a89d9575f0184fcc6b1d113ac5aa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/0*7s_2SnecfjRJ2Kk8.jpg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:Sunfounder</p></figure><p id="de9f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">以下是显示发送到MAX7219点阵显示器的实际信号的时序图。这是来自<a class="ae kv" href="https://sigrok.org/wiki/PulseView" rel="noopener ugc nofollow" target="_blank"> PulseView/sigrok逻辑分析仪</a>应用程序的截图。我使用了一个便宜的<a class="ae kv" href="https://www.amazon.com/dp/B07K6HXDH1?psc=1&amp;ref=ppx_yo2ov_dt_b_product_details" rel="noopener ugc nofollow" target="_blank">逻辑分析仪设备</a>来捕捉PulseView中显示的信号。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/e5089cc8c0288801a3ec59d6bceda97d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NQPU7BLaba1vT71y.jpg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="nh">图片来源:作者</em></p></figure><p id="2295" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="nf">(为了更好地看到上面的图像，在一个单独的标签中打开它并放大)</em></p><p id="1594" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此图显示了字母“Y”的LED矩阵前3行的值。下面就来解读一下:</p><ol class=""><li id="71f2" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj nd mv mw mx bi translated">从左到右共有5行/线，分别标记为CS0、MOSI、SCLK、MAX7219/SPI MOSI位和MAX7219/SPI MOSI数据。上面三行是实际的数字信号。尖峰表示高信号。底部2行是对上述3行信号的SPI特定解码。MAX7219/SPI MOSI位显示与上述信号相关的位值，0(低)或1(高)。MAX7219/SPI MOSI数据代表上述位值的十六进制值。</li><li id="1acd" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated">CS0是片选线。这很难看到，但在图的最左边，它开始设置为高。垂直线出现的地方设置为低。这表示向连接到CS0的SPI外设的数据传输即将开始。当该信号设置为低电平时，会发生以下情况:</li><li id="39f0" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated">当CS0设为低电平时，SCLK线在高电平和低电平之间脉动16次。这是一个时序信号，当设为高电平时，指示SPI外设接受MOSI线上的当前值。</li><li id="c283" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated">对于SCLK的前7个脉冲，MOSI线被设置为低。就在第8个脉冲之前，MOSI线被设置为高。</li><li id="e524" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated">MAX7219/SPI MOSI位线显示了SCLK线和MOSI线组合的二进制解释。与SCLK线的前7个脉冲一致，MOSI线被解释为零(0)。第8位被解释为1。所以发送的8位二进制值是<code class="fe nq nr ns nt b">0000 0001</code>。</li><li id="3dae" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated">MAX7219/SPI MOSI数据线显示十六进制解释，即<code class="fe nq nr ns nt b">0x1</code>。</li></ol><p id="18dd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">CS0线路设置为低电平时发送的第二个8位是十六进制数<code class="fe nq nr ns nt b">0x41</code>的<code class="fe nq nr ns nt b">0100 0001</code>。</p><p id="9e78" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">MAX7219移位寄存器为16位宽。因此，每个数据传输由16位组成，这就是我们在上面的时序图中看到的。当CS0线路设为低电平时，传输16位。对于MAX7219，前8位是将要设置的寄存器的地址。用于填充该寄存器的值在接下来的8位中发送。因此，第一次数据传输将位于偏移量<code class="fe nq nr ns nt b">0x1</code>的寄存器设置为值<code class="fe nq nr ns nt b">0x41</code>。偏移量<code class="fe nq nr ns nt b">0x1</code>处的寄存器控制点阵模块的第一/顶行。请注意，每行有8个led。每个LED对应寄存器中二进制值的一位。那个值是<code class="fe nq nr ns nt b">0x41</code>，<code class="fe nq nr ns nt b">0100 0001</code>，会导致LED的第一行看起来是这样的(<code class="fe nq nr ns nt b">-</code> s为0，<code class="fe nq nr ns nt b">*</code> s为1):</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="9da2" class="ny kx iq nt b gy nz oa l ob oc">-*-----*</span></pre><p id="7034" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下一组8位是<code class="fe nq nr ns nt b">0000 0010</code>，相当于<code class="fe nq nr ns nt b">0x2</code>。因此，第2个8位中的值将被写入寄存器的偏移量<code class="fe nq nr ns nt b">0x2</code>，该偏移量对应于点阵显示器中第2行8个LEDS。接下来8位的二进制值是<code class="fe nq nr ns nt b">0010 0010</code>。目标寄存器将被设置为该值。传输后，LED矩阵的前两行看起来像这样:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="d957" class="ny kx iq nt b gy nz oa l ob oc">-*-----*<br/>--*---*-</span></pre><p id="ec39" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下一组16位具有值<code class="fe nq nr ns nt b">0000 0011</code>和<code class="fe nq nr ns nt b">0001 0100</code>。前8位是目标寄存器的地址。其遵循上述模式，指定目标寄存器位于对应于LED矩阵的第3行的偏移量<code class="fe nq nr ns nt b">0x3</code>。后8位写入寄存器后，LED矩阵将如下所示:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="010a" class="ny kx iq nt b gy nz oa l ob oc">-*-----*<br/>--*---*-<br/>---*-*--</span></pre><p id="c6fa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上图中未显示的下5组16位指定寄存器<code class="fe nq nr ns nt b">0x4</code>至<code class="fe nq nr ns nt b">0x7</code>，对应于LED矩阵的其余行。写入这些寄存器的值<code class="fe nq nr ns nt b">0000 1000</code>产生以下模式，代表字母“Y”。</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="f9a7" class="ny kx iq nt b gy nz oa l ob oc">-*-----*<br/>--*---*-<br/>---*-*--<br/>----*---<br/>----*---<br/>----*---<br/>----*---<br/>----*---</span></pre><p id="3567" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下一部分将提供关于SPI协议以及如何对MAX7219进行编程的更多细节。</p><h1 id="78bd" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">设置和代码</h1><p id="2432" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">下图说明了如何连接试验板，以配合MAX7219 LED点阵模块示例。如果你不熟悉试验板和试验板图，这个<a class="ae kv" href="https://www.sciencebuddies.org/science-fair-projects/references/how-to-use-a-breadboard" rel="noopener ugc nofollow" target="_blank">试验板教程</a>应该会有帮助。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2552f917023c121cb95c67873a65c54b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7f64P7s_-S9m3Xaz.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="nh">图片来源:Sunfounder </em></p></figure><p id="f9ac" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">黄线连接到Raspberry Pi的SPIMOSI引脚(GPIO引脚10)和MAX7219的DIN引脚。蓝线连接到Raspberry Pi的SPISCLK或SCLK (GPIO引脚11)和MAX7219的CLK引脚。绿线连接到Raspberry Pi上的SPICE0或CE0 (GPIO引脚8)和MAX7219上的CS引脚。红色和黑色电线分别连接到5伏电源/VCC和接地/GND。</p><p id="03d2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下一节将描述控制MAX7219的主程序。下一节描述使用BCM2835寄存器直接控制I/O功能的代码。</p><h1 id="ac5d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">控制MAX7219 —主程序</h1><p id="3f96" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我之前提到过，阅读这篇文章有两种方法。第一种方法是最简单的，只需要阅读这一部分。下一节<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#controlling-a-dot-matrix-display---interacting-with-the-bcm2835" rel="noopener ugc nofollow" target="_blank">控制点阵显示器——与BCM2835 </a>交互，更高级，可以跳过。</p><p id="d327" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">本节和下一节中的代码引用以<code class="fe nq nr ns nt b">bcm_</code>为前缀的函数。所有这些函数都取自Mike McCauley编写的<a class="ae kv" href="https://www.airspayce.com/mikem/bcm2835/index.html" rel="noopener ugc nofollow" target="_blank"> BCM2835 C库</a>，只做了很小的改动。当用这个代码使用这个库时，只需用<code class="fe nq nr ns nt b">bcm2835_</code>替换<code class="fe nq nr ns nt b">bcm_</code>的所有实例。创建了<code class="fe nq nr ns nt b">bcm_</code>函数，以便我可以添加解释性注释，并使BCM2835代码在本文中更容易访问。<code class="fe nq nr ns nt b">bcm_</code>功能将在下一节详细描述。</p><h2 id="da69" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">全局变量</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="8c30" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">第一个代码片段显示了如何创建一个字符显示在MAX7219点阵显示模块上。二维矩阵<code class="fe nq nr ns nt b">disp1</code>包含一组行<code class="fe nq nr ns nt b">NUM_CHARS</code>，每一行定义一个要显示的特定字符。矩阵中的每一列<code class="fe nq nr ns nt b">MATRIX_ROW</code>定义了在点阵显示模块中打开单个MAX7219 LED行中的哪些LED。MAX7219显示模块是一个8×8的led阵列。在上面的代码片段中，矩阵包含3行8列。<code class="fe nq nr ns nt b">disp1[0][0]</code>处的第一个单元包含十六进制值<code class="fe nq nr ns nt b">0x3C</code>。这定义了在显示模块的8行中的第一行打开哪些led。<code class="fe nq nr ns nt b">0x3C</code>翻译成<code class="fe nq nr ns nt b">0011 1100</code>。每个数字指定该行中的哪个LED将被打开。<code class="fe nq nr ns nt b">0x3C</code>指定打开8个LED行中第一行中间的4个LED。<code class="fe nq nr ns nt b">disp[0][1]</code>包含转换成二进制数<code class="fe nq nr ns nt b">0100 0010</code>的十六进制值<code class="fe nq nr ns nt b">0x42</code>，该二进制数指定8个LED行的第二行中的第二个和第七个LED将被打开。显示这两个单元格后，点阵显示将如下所示:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="934e" class="ny kx iq nt b gy nz oa l ob oc">--****--<br/>-*----*-</span></pre><p id="a75e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">带有<code class="fe nq nr ns nt b">-</code>的LED单元关闭，带有<code class="fe nq nr ns nt b">*</code>的单元打开。一旦显示了从<code class="fe nq nr ns nt b">disp1[0][0]</code>到<code class="fe nq nr ns nt b">disp1[0][7]</code>的所有8个单元，点阵模块上将显示以下字符，即零:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="40c7" class="ny kx iq nt b gy nz oa l ob oc">--****--<br/>-*----*-<br/>-*----*-<br/>-*----*-<br/>-*----*-<br/>-*----*-<br/>-*----*-<br/>--****--</span></pre><p id="1a3e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">其余的<code class="fe nq nr ns nt b">disp1</code>行定义了程序将显示的其余字符和形状。</p><p id="1aeb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">用于LED矩阵8x8 的<a class="ae kv" href="http://robojax.com/learn/arduino/8x8LED/" rel="noopener ugc nofollow" target="_blank"> Sprint生成器是一个工具，帮助生成使LED矩阵显示给定形状所需的十六进制数。</a></p><h2 id="bbb7" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">主()</h2><p id="333e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">下一个代码片段显示了<code class="fe nq nr ns nt b">main</code>函数的代码。每个重要的行将在代码片段下面解释。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="2cfa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第1行</strong>解释了GPIO管脚是硬编码的。这是因为程序正在使用<code class="fe nq nr ns nt b">SPIO</code>接口。另外两个接口<code class="fe nq nr ns nt b">SPI1</code>和<code class="fe nq nr ns nt b">SPI2</code>是辅助SPI接口。BCM2835臂外设指南第20页第2.3节规定如下:</p><blockquote class="ni nj nk"><p id="a0a3" class="lo lp nf lq b lr mk jr lt lu ml ju lw nl mm lz ma nm mn md me nn mo mh mi mj ij bi translated">两个通用SPI主机是辅助低吞吐量SPI接口。…通用SPI主机已经开发出来，甚至可以与最“非标准”的SPI设备配合使用。</p></blockquote><p id="5e6f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">言外之意，“次要”、“低吞吐量”和“非标准”似乎不是我们想要的属性。<a class="ae kv" href="https://www.airspayce.com/mikem/bcm2835/index.html" rel="noopener ugc nofollow" target="_blank"> BCM2835 </a>库是本文给出的代码的基础，它支持<code class="fe nq nr ns nt b">SPI0</code>作为主接口。有支持<code class="fe nq nr ns nt b">SPI1</code>接口的辅助功能，没有支持<code class="fe nq nr ns nt b">SPI2</code>的功能。鉴于这一切，我选择硬编码<code class="fe nq nr ns nt b">SPI0</code>接口。注意，BCM2835 ARM外设指南规定，当指定ALT0功能时，GPIO引脚7-11专用于<code class="fe nq nr ns nt b">SPI0</code>。</p><p id="1eb2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第3行</strong>定义了一个信号处理器，用于在应用程序被终止时提供优雅的关闭(例如，^C).</p><p id="41a8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第8行</strong>，调用<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_init" rel="noopener ugc nofollow" target="_blank"> bcm_init() </a>，初始化BCM2835。其中，它为I/O外设的地址空间找到合适的内存偏移量并映射<code class="fe nq nr ns nt b">/dev/mem</code>,以便可用于对I/O功能进行编程。<code class="fe nq nr ns nt b">bcm_init()</code>是一个低级功能，将在下一节<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#controlling-a-dot-matrix-display---interacting-with-the-bcm2835" rel="noopener ugc nofollow" target="_blank">控制点阵显示-与BCM2835 </a>交互中详细描述。</p><p id="b900" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第13行</strong>，<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#init_spi" rel="noopener ugc nofollow" target="_blank"> init_spi() </a>，初始化spi接口，包括将GPIO引脚上的I/O功能设置为ALT0(使能SPI0)。</p><p id="4996" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第14行</strong>、<code class="fe nq nr ns nt b">Delay_xms(50);</code>产生一个50毫秒的短暂延迟，给spi接口时间完成初始化。</p><p id="a2ab" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第15行</strong>，<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#init_max7219" rel="noopener ugc nofollow" target="_blank"> Init_MAX7219() </a>，初始化MAX7219显示模块。其中，它设置显示器的亮度。与BCM2835一样，其功能由一组寄存器控制。下面函数定义中的注释提供了关于它做什么的附加信息。</p><p id="9e48" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第18–37行</strong>是<code class="fe nq nr ns nt b">main</code>功能的核心。对于<code class="fe nq nr ns nt b">disp1</code>和<code class="fe nq nr ns nt b">scrollDisp</code>数组中的每一行，它将一整行的值写入显示模块，从而显示一个字符(例如<code class="fe nq nr ns nt b">0</code>)。<strong class="lq ir">第29-36行</strong>演示了如何创建一个简单的滚动显示。</p><p id="0e42" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">行40 ad 41 </strong>，<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_spi_end" rel="noopener ugc nofollow" target="_blank"> bcm_spi_end() </a>和<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_close" rel="noopener ugc nofollow" target="_blank"> bcm_close() </a>复位BCM2835 GPIO功能并释放资源(如<code class="fe nq nr ns nt b">/dev/mem</code>)。</p><h2 id="22c8" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">init_spi()</h2><p id="1be7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">该代码片段显示了SPI接口的初始化方式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="3721" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">线路4 </strong>，<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_spi_begin" rel="noopener ugc nofollow" target="_blank"> bcm_spi_begin() </a>，是另一个与BCM2835接口的低级功能。正如注释所述，它负责将GPIO引脚7–11设置为备用功能0，从而使能这些引脚的SPI0接口。这将在下一节中详细介绍。</p><p id="c6eb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第6行</strong>，<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_spi_setbitorder" rel="noopener ugc nofollow" target="_blank"> bcm_spi_setBitOrder() </a>，比较复杂，取决于你是否理解最高有效位和最低有效位排序(MSB和LSB)的概念。简单地说，二进制数中最重要的位是最左边的位。同样，二进制数中的最低有效位是最右边的位。在二进制数<code class="fe nq nr ns nt b">100</code>中，MSB是<code class="fe nq nr ns nt b">1</code>，LSB是<code class="fe nq nr ns nt b">0</code>。重要的是，当数据以串行方式传输时，位顺序指定首先发送哪个位。在MSB中，首先发送最高有效位。因此，将串行数据传输的接收端视为一个堆栈，MSB首先被推入堆栈。其余位从MSB转移到LSB。因此，如果数字<code class="fe nq nr ns nt b">100</code>按MSB顺序串行传输，它在接收端将被表示为<code class="fe nq nr ns nt b">001</code>。不同的器件需要MSB或LSB格式的数据。</p><p id="60b1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">了解与您交互的设备对于位顺序的期望是很重要的。BCM2835 SPI0需要MSB中的位。SPI1和SPI2可以接受AUXSPI0/1_CNTL0寄存器的位6中指定的MSB或LSB(详情参见<a class="ae kv" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank">BCM 2835 ARM外设指南</a>，第22–23页)。<code class="fe nq nr ns nt b">bcm_spi_setBitOrder()</code>允许指定MSB或LSB。然而，对于SPI数据传输，数据必须以MSB形式发送。因此，对于SPI，该功能基本上是无效的。有关数据如何传输到MAX7219的直观表示，请参见第5页底部的<a class="ae kv" href="https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf" rel="noopener ugc nofollow" target="_blank"> MAX7219数据手册</a>、<em class="nf">功能图</em>。在页面的最底部中间有一个图表，显示了数据如何通过<code class="fe nq nr ns nt b">DIN</code>引脚传输到MAX7219内部移位寄存器的位位置。在最后一个时钟脉冲(<code class="fe nq nr ns nt b">CLK</code>引脚)，LSB位于位偏移<code class="fe nq nr ns nt b">0</code>、<code class="fe nq nr ns nt b">D0</code>，MSB位于位偏移<code class="fe nq nr ns nt b">15</code>、<code class="fe nq nr ns nt b">D15</code>。如果你想看更完整的位排序示例，请参阅我的文章<a class="ae kv" href="http://youngkin.github.io/post/shiftregistersevensegdisplay/#what-is-a-shift-register-and-what-is-it-good-for" rel="noopener ugc nofollow" target="_blank">Raspberry Pi GPIO in Go and C——使用移位寄存器&amp; 7段显示</a>。它详细描述了如何结合移位寄存器使用位排序。如果您想了解更多关于强制BCM2835 SPI接口以LSB发送数据的信息，请参见此Google Groups主题<a class="ae kv" href="https://groups.google.com/g/bcm2835/c/9H6rDEKTru0?pli=1" rel="noopener ugc nofollow" target="_blank"> BCM2835 SPI通信- LSB优先</a>。</p><p id="fef3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第9行</strong>，<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_spi_setdatamode" rel="noopener ugc nofollow" target="_blank">BCM _ SPI _ set data mode(BCM _ SPI _ mode 0)</a>设置时钟极性和相位。如果你不明白这意味着什么，就接受这个设定，继续前进。在大多数情况下，这是默认设置。如果您想了解更多细节，请参见第149页的<a class="ae kv" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank">BCM 2835 ARM外设指南</a>，第10节— SPI，图10–3。</p><p id="c072" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第10行</strong>，<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_spi_setclockdivider" rel="noopener ugc nofollow" target="_blank">BCM _ spi _ setClockDivider(BCM _ SPI _ CLOCK _ DIVIDER _ 256)</a>设置SPI时钟的频率(Rasberry Pi上的SPISCLK、GPIO引脚11)。简而言之，Raspberry Pi的系统时钟除以该函数中的参数来设置SPI时钟的频率。在大多数情况下，256是一个很好的默认值。更多详细信息，请参见<a class="ae kv" href="https://github.com/youngkin/gpio/blob/main/ledblink/bcmfuncs.h" rel="noopener ugc nofollow" target="_blank"> bcmfuncs.h </a>或<a class="ae kv" href="https://www.airspayce.com/mikem/bcm2835/group__constants.html#gaf2e0ca069b8caef24602a02e8a00884e" rel="noopener ugc nofollow" target="_blank"> BCM2835 C库文档</a>。</p><p id="e645" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第12行</strong>，<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_gpio_fsel" rel="noopener ugc nofollow" target="_blank"> bcm_gpio_fsel() </a>将<code class="fe nq nr ns nt b">Max7219_pinCS</code>引脚SPICE0/gpio引脚8设置为GPIO输出功能。这允许程序将值(高或低)写入引脚。这是SPI片选/片使能引脚。此引脚指示MAX7219从Raspberry Pi接收数据。向MAX7219发送数据时，此引脚需要设为低电平。下面将更详细地描述<code class="fe nq nr ns nt b">bcm_gpio_fsel()</code>功能。</p><h2 id="584e" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">Init_MAX7219()</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="c63f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该代码片段初始化MAX7219显示模块。与BCM2835一样，MAX7219的功能也是通过一组寄存器来控制的。<strong class="lq ir">第3行到第9行</strong>将各种控制寄存器设置为不同的值。</p><p id="2553" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">以<strong class="lq ir">行1 </strong>为例，它将偏移量<code class="fe nq nr ns nt b">0x09</code>处的MAX7219寄存器设置为值<code class="fe nq nr ns nt b">0x00</code>。<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#write_max7219" rel="noopener ugc nofollow" target="_blank"> Write_Max7219() </a>中的第一个参数指定寄存器的地址偏移量。第二个参数指定要写入寄存器的值。寄存器及其失调在<a class="ae kv" href="https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf" rel="noopener ugc nofollow" target="_blank"> MAX7219数据表</a>、<em class="nf">表2中描述。第7页的寄存器地址映射</em>。<em class="nf">表1。第6页的串行数据格式</em>描述了数据在各寄存器中的布局。每个寄存器的长度为16位，如表1所示。共有14个控制寄存器。每个寄存器的名称在标题为<em class="nf">寄存器</em>的表2的第1列中给出。每个寄存器的偏移量在<em class="nf">十六进制代码</em>栏中给出。再次查看<code class="fe nq nr ns nt b">Write_Max7219()</code>、<code class="fe nq nr ns nt b">0x09</code>的第一个参数，我们可以看到该地址指向<em class="nf">解码模式</em>寄存器，该寄存器位于<em class="nf">十六进制代码</em>列中给出的偏移量<code class="fe nq nr ns nt b">0xX9</code>。与创建字符、符号或形状相关的各种LED行由寄存器<em class="nf">数字0 </em>至<em class="nf">数字7 </em>控制。表3、4、7、8和10给出了除<em class="nf"> Digitn </em>寄存器以外的各寄存器值的含义。<code class="fe nq nr ns nt b">Write_Max7219()</code>的第二个参数是<code class="fe nq nr ns nt b">0x00</code>。在表4中，我们看到这个值意味着没有为数字0-7设置解码。</p><p id="22e0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">以类似的方式，<strong class="lq ir">第4行到第9行</strong>将初始化剩余的寄存器，如注释中所述。</p><h2 id="202f" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">Write_Max7219()</h2><p id="26c9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nq nr ns nt b">Write_Max7219()</code>将数据<code class="fe nq nr ns nt b">dat1</code>写入位于地址<code class="fe nq nr ns nt b">address1</code>的寄存器。对MAX7219的写入一次只发生一个字节。写入的第一个字节是寄存器地址。第二个字节是数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="aae4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第1行</strong>，<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_gpio_write" rel="noopener ugc nofollow" target="_blank"> bcm_gpio_write() </a>使用常规gpio写方法将片选引脚<code class="fe nq nr ns nt b">Max7219_pinCS</code>设为低电平，以便MAX7219接受来自Raspberry Pi的数据。</p><p id="cd9a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第6行</strong>，<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#write_max7219_byte" rel="noopener ugc nofollow" target="_blank"> Write_Max7219_byte() </a>，向Max7219发送<code class="fe nq nr ns nt b">address1</code>参数。如<a class="ae kv" href="https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf" rel="noopener ugc nofollow" target="_blank"> MAX7219数据手册</a>、<em class="nf">功能图</em>所示，在第5页的底部，目标寄存器的地址将被写入位偏移8至11(如数据手册所述，位12至15将被忽略)。</p><p id="4a87" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第7行</strong>，<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#write_max7219_byte" rel="noopener ugc nofollow" target="_blank"> Write_Max7219_byte() </a>，向Max7219发送<code class="fe nq nr ns nt b">dat1</code>参数。<code class="fe nq nr ns nt b">dat1</code>位将被写入MAX7219移位寄存器中的最低有效位，偏移量0到7。</p><p id="1400" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">线8 </strong>，<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_gpio_write" rel="noopener ugc nofollow" target="_blank"> bcm_gpio_write() </a>，复位<code class="fe nq nr ns nt b">Max7219_pinCS</code>引脚回到高电平，表示数据传输结束，防止MAX7219接收数据。</p><h2 id="81b2" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">Write_Max7219_byte()</h2><p id="81e0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nq nr ns nt b">Write_Max7219_byte()</code>相当直白。它获取<code class="fe nq nr ns nt b">data</code>参数，并通过<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_spi_transfer" rel="noopener ugc nofollow" target="_blank"> bcm_spi_transfer() </a>调用将其发送给SPI外设vi。<code class="fe nq nr ns nt b">bcm_spi_transfer()</code>将在下文详细介绍。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><h1 id="755f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">控制MAX7219 —与BCM2835直接交互</h1><p id="ca32" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">本部分描述代码如何与GPIO外设交互并控制这些外设，特别是设置与BCM2835的SPI I/O功能相关的各种寄存器的值。设置寄存器值用于控制GPIO外设，读取寄存器值允许访问相关GPIO外设的当前状态。</p><p id="835f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">其中许多功能描述都是从<a class="ae kv" href="https://youngkin.github.io/post/gpioprogramming/" rel="noopener ugc nofollow" target="_blank">Raspberry Pi GPIO——Broadcom BCM 2835 ARM外设编程简介</a>文章中复制的。这样做是为了避免经常交叉引用该文章。</p><p id="ad0f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">包含该代码的文件的代码可以在<a class="ae kv" href="https://github.com/youngkin/gpio/blob/main/ledblink/bcmfuncs.c" rel="noopener ugc nofollow" target="_blank">gpio/led blink/BCM funcs . c</a>中找到。相关的头文件可以在<a class="ae kv" href="https://github.com/youngkin/gpio/blob/main/ledblink/bcmfuncs.h" rel="noopener ugc nofollow" target="_blank">gpio/led blink/BCM funcs . h</a>中找到。</p><h2 id="c7de" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">bcm_init()</h2><p id="08f7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在<em class="nf">Broadcom BCM2835 ARM外设编程简介</em>一文中，Raspberry Pi GPIO 部分的<a class="ae kv" href="https://youngkin.github.io/post/gpioprogramming/#registers" rel="noopener ugc nofollow" target="_blank">寄存器提到，BCM 2835外设上的所有操作都是通过操作与该类型外设相关的寄存器来完成的。<code class="fe nq nr ns nt b">bcm_init()</code>的目的是确定所有类型寄存器的地址偏移量，如GPIO、PWM、SPI等。以便可以控制它们的相关外围设备。</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="4d37" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个代码片段显示了<code class="fe nq nr ns nt b">bcm_init()</code>函数的开始。</p><p id="12f1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第10行</strong>打开<code class="fe nq nr ns nt b">BCM_RPI2_DT_FILENAME</code>。如注释所示，<code class="fe nq nr ns nt b">fopen()</code>调用中的<code class="fe nq nr ns nt b">rb</code>打开一个二进制文件进行读取。<code class="fe nq nr ns nt b">BCM_RPI2_DT_FILENAME</code>在相关的<code class="fe nq nr ns nt b">bcmfuncs.h</code>头文件中定义。它的值是<code class="fe nq nr ns nt b">/proc/device-tree/soc/ranges</code>。如<a class="ae kv" href="https://www.kernel.org/doc/html/latest/devicetree/usage-model.html" rel="noopener ugc nofollow" target="_blank"> Linux和设备树</a>中所述，</p><blockquote class="ni nj nk"><p id="5d89" class="lo lp nf lq b lr mk jr lt lu ml ju lw nl mm lz ma nm mn md me nn mo mh mi mj ij bi translated">操作系统使用设备树在运行时发现硬件的拓扑结构，从而支持大多数可用的硬件，而无需硬编码信息(假设驱动程序可用于所有设备)。</p></blockquote><p id="7fc1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">设备树保存的信息之一，对我们的目的很重要，是BCM2835的物理地址空间中I/O外设分区的位置和长度(详见<a class="ae kv" href="https://youngkin.github.io/post/gpioprogramming/#addressing" rel="noopener ugc nofollow" target="_blank">Broadcom BCM 2835 ARM外设编程简介-寻址</a>)。下面是树莓派3B+上<code class="fe nq nr ns nt b">/proc/device-tree/soc/ranges</code>内容的十六进制转储:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="6085" class="ny kx iq nt b gy nz oa l ob oc">pi@pi-node1:/ $ hexdump -C /proc/device-tree/soc/ranges<br/>00000000  7e 00 00 00 3f 00 00 00  01 00 00 00 40 00 00 00  |~...?.......@...|<br/>00000010  40 00 00 00 00 00 10 00                           |@.......|<br/>00000018</span></pre><p id="f115" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们将在下一个代码片段中引用它。根据<a class="ae kv" href="https://www.devicetree.org/specifications/" rel="noopener ugc nofollow" target="_blank">devicetree.org</a>，在<a class="ae kv" href="https://github.com/devicetree-org/devicetree-specification/releases/download/v0.4-rc1/devicetree-specification-v0.4-rc1.pdf" rel="noopener ugc nofollow" target="_blank">device tree规范</a>v 0.4-rc1中，<code class="fe nq nr ns nt b">soc/ranges</code>属性定义如下:</p><blockquote class="ni nj nk"><p id="fc8c" class="lo lp nf lq b lr mk jr lt lu ml ju lw nl mm lz ma nm mn md me nn mo mh mi mj ij bi translated">ranges属性提供了一种定义总线地址空间(子地址空间)和总线节点父地址空间(父地址空间)之间的映射或转换的方法。ranges属性的值的格式是任意数量的三元组(子总线地址、父总线地址、长度)</p></blockquote><p id="f451" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于I/O外设地址块，如<a class="ae kv" href="https://youngkin.github.io/post/gpioprogramming/#addressing" rel="noopener ugc nofollow" target="_blank">Broadcom BCM 2835 ARM外设编程简介—寻址</a>中所述，<em class="nf">“子总线地址”</em>指的是<em class="nf">“VC CPU总线地址”</em>内存空间中的<em class="nf">“I/O外设”</em>地址块。<em class="nf">“母总线地址”</em>是指<em class="nf">“ARM物理地址”</em>块中的<em class="nf">“I/O外设”</em>地址块。<em class="nf"/>的“长度”是指<em class="nf">【I/O外设】</em>地址块的实际长度。Raspberry Pi 3B+具有32位地址空间，因此三元组中的每个值都是32位或4个字节。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="18d0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下一段代码使用来自<code class="fe nq nr ns nt b">/proc/device-tree/soc/ranges</code>的数据找到I/O外设模块的<em class="nf">父总线地址</em>和<em class="nf">长度</em>。回想一下，父总线地址是三元组中的第二个条目，它也定义了子总线地址和长度。根据上面的十六进制转储，这里是三元组(数组单元0在最左边，数组单元11在最右边):</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="79f6" class="ny kx iq nt b gy nz oa l ob oc">7e 00 00 00 3f 00 00 00  01 00 00 00</span></pre><blockquote class="ni nj nk"><p id="affa" class="lo lp nf lq b lr mk jr lt lu ml ju lw nl mm lz ma nm mn md me nn mo mh mi mj ij bi translated">注意:在Raspberry Pi 4上，该命令的输出有些不同。它看起来更像这样:</p><p id="3e0a" class="lo lp nf lq b lr mk jr lt lu ml ju lw nl mm lz ma nm mn md me nn mo mh mi mj ij bi translated"><code class="fe nq nr ns nt b">pi@kubemaster:~ $ hexdump -C /proc/device-tree/soc/ranges</code></p><p id="66eb" class="lo lp nf lq b lr mk jr lt lu ml ju lw nl mm lz ma nm mn md me nn mo mh mi mj ij bi translated"><code class="fe nq nr ns nt b">00000000 7e 00 00 00 00 00 00 00 fe 00 00 00 01 80 00 00 |~……………|</code></p><p id="e1e0" class="lo lp nf lq b lr mk jr lt lu ml ju lw nl mm lz ma nm mn md me nn mo mh mi mj ij bi translated">在这个转储中，父总线地址的起始地址是偏移量8，值是<code class="fe nq nr ns nt b">fe 00 00 00</code>。对于树莓Pi 3，它在偏移量4处。在这两种情况下，地址的长度都是4字节或32位。I/O外设分区的长度从偏移量12开始，值为<code class="fe nq nr ns nt b">01 80 00 00</code>。虽然上面的代码片段没有反映出这种差异，但是完整函数的代码确实考虑到了这一点。</p></blockquote><p id="0caf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第1行到第4行</strong>将<em class="nf">母总线地址</em>、<code class="fe nq nr ns nt b">3f 00 00 00</code>的内容，即<code class="fe nq nr ns nt b">buf</code>偏移量4到7的字节，移入<code class="fe nq nr ns nt b">base_address</code>。<code class="fe nq nr ns nt b">3F</code>被移入<code class="fe nq nr ns nt b">base_address</code>的高位字节。剩余的<code class="fe nq nr ns nt b">buf</code>单元同样从左(最高有效字节)到右(最低有效字节)移位到<code class="fe nq nr ns nt b">base_address</code>。换档完成后，<code class="fe nq nr ns nt b">base_address</code>将被设置为<code class="fe nq nr ns nt b">0x3F000000</code>。回顾<a class="ae kv" href="https://youngkin.github.io/post/gpioprogramming/#addressing" rel="noopener ugc nofollow" target="_blank">Broadcom BCM 2835 ARM外设编程简介-寻址</a>中的图表，您会注意到<strong class="lq ir">与<em class="nf"> ARM物理地址</em>中的<em class="nf"> I/O外设</em>地址块中的<code class="fe nq nr ns nt b">0x20000000</code>的基址</strong>不匹配。这是因为寻址部分中的图表是针对Raspberry Pi 1的。这种偏移在Raspberry Pi型号2 &amp; 3中有所不同。在Raspberry Pi 4模型中又有所不同。</p><p id="b1dc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">继续，以与<code class="fe nq nr ns nt b">base_address</code>类似的方式，<strong class="lq ir">线6至9 </strong>通过从<code class="fe nq nr ns nt b">buf</code>偏移8至11移入<code class="fe nq nr ns nt b">peri-size</code>获得<em class="nf">长度</em>。对于树莓派3B+，<code class="fe nq nr ns nt b">0x01000000</code>是地址块的预期长度。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="e260" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下一个代码片段完成了从<code class="fe nq nr ns nt b">/proc/device-tree/soc/ranges</code>获取寻址信息。具体来说，它验证了<em class="nf">“子总线地址”</em>和<em class="nf">“父总线地址”</em>具有预期值。回想一下<em class="nf">“子总线地址”</em>是地址/长度三元组的第一个值，<code class="fe nq nr ns nt b">buf</code>偏移量0到3。第1行到第6行执行以下操作:</p><ol class=""><li id="cfa6" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj nd mv mw mx bi translated"><strong class="lq ir">第1行到第4行</strong>验证<code class="fe nq nr ns nt b">buf</code>的前4个字节，即<em class="nf">子总线地址</em>，是由<em class="nf">“VC CPU总线地址”</em>内存空间中的<em class="nf">“I/O外设”</em>地址块定义的<code class="fe nq nr ns nt b">0x7E000000</code>。我们在上面的十六进制转储中也看到了这一点，其中前32位的<em class="nf">子总线地址</em>包含值<code class="fe nq nr ns nt b">7e 00 00 00</code>。</li><li id="27e3" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated"><strong class="lq ir">第5行</strong>验证<em class="nf">父总线地址</em>，<code class="fe nq nr ns nt b">base_address</code>是否与Raspberry Pi模型1至4的预期基址之一相匹配。</li></ol><p id="8081" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第7行和第8行</strong>然后将<em class="nf"> I/O外设</em>地址块的基址和长度设置为将在程序其余部分使用的变量。这一行的重要之处在于，它将源变量转换为目标变量所期望的类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="7a4e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下一段代码将BCM2835的<em class="nf">“I/O外设”</em>地址块映射到<code class="fe nq nr ns nt b">/dev/mem</code>的<em class="nf">“ARM物理地址”</em>内存空间中，以便它可以安全地用于程序中。</p><p id="64c5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第1行</strong>首先检查运行程序的用户是否以<em class="nf"> root </em>身份运行(要么是<em class="nf"> root </em>用户，要么是<em class="nf"> sudo </em>)。否则，<code class="fe nq nr ns nt b">/dev/mem</code>装置不能使用。<code class="fe nq nr ns nt b">/dev/mem</code>提供对CPU内存的无限制访问。因为这显然是一件危险的事情，所以它的使用仅限于<em class="nf">根</em>。还有一个替代<code class="fe nq nr ns nt b">/dev/mem</code>，<code class="fe nq nr ns nt b">/dev/gpio</code>。这将在本节的后面部分显示。</p><p id="233a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">线4 </strong>打开<code class="fe nq nr ns nt b">/dev/mem</code>准备映射操作。<code class="fe nq nr ns nt b">O_SYNC</code>指定对<code class="fe nq nr ns nt b">/dev/mem</code>的写操作必须在任何写操作返回之前完成(即，写操作不被缓存)。</p><p id="a9d3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第13行</strong>在<em class="nf"> I/O外设</em>地址块的偏移量和长度<code class="fe nq nr ns nt b">bcm_peripherals_base</code>和<code class="fe nq nr ns nt b">bcm-peripherals_size</code>处将<code class="fe nq nr ns nt b">bcm_peripherals</code>变量分配给存储块。这种映射有效地限制了程序对物理存储器的<em class="nf"> I/O外设</em>地址块的访问。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="fbf2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下一段代码计算各种类型寄存器(例如GPIO、PWM、SPI等)的失调。每个偏移量都相对于<code class="fe nq nr ns nt b">bcm_peripherals</code>的值，它是前面代码片段中<code class="fe nq nr ns nt b">mapmem()</code>操作的结果。因此，要获得像GPIO寄存器组这样的寄存器组的地址，我们需要将<code class="fe nq nr ns nt b">BCM_GPIO_BASE</code>加到<code class="fe nq nr ns nt b">bcm_peripherals</code>基址上。但是您可能已经注意到，代码在将这些偏移量添加到<code class="fe nq nr ns nt b">bcm_peripherals</code>之前会将它们除以4。这些被指定为整数的偏移量，例如<code class="fe nq nr ns nt b">BCM_GPIO_BASE</code>，指向特定的字节地址，即在8位边界处。<code class="fe nq nr ns nt b">bcm_peripherals</code>被指定为<code class="fe nq nr ns nt b">uint32_t*</code>，一个指针。你不能天真地给指针加一个整数。您可能还记得，指针算法是基于相关变量的类型大小来操作指针变量的。对于<code class="fe nq nr ns nt b">unint32_t</code>，它们的大小是32位或4字节。向<code class="fe nq nr ns nt b">uint32_t</code>指针加1将导致该指针指向下一个<code class="fe nq nr ns nt b">uint32_t</code>，从当前位置开始4个字节。天真地将像<code class="fe nq nr ns nt b">BCM_GPIO_BASE</code>这样的偏移量添加到<code class="fe nq nr ns nt b">bcm_peripherals</code>会导致<code class="fe nq nr ns nt b">bcm_peripherals</code>指向内存中比当前位置晚4秒的位置，而不是我们想要的比当前位置晚1秒的位置。这就是为什么像<code class="fe nq nr ns nt b">BCM_GPIO_BASE</code>这样的每个寄存器类型偏移在加到<code class="fe nq nr ns nt b">bcm_peripherals</code>之前要除以4。</p><blockquote class="ni nj nk"><p id="28ca" class="lo lp nf lq b lr mk jr lt lu ml ju lw nl mm lz ma nm mn md me nn mo mh mi mj ij bi translated">如果你是C语言的新手，你可能不知道指针算法本身是危险的。很难确切知道指针运算的结果是指针将引用什么。指针可能是意外的类型或具有意外的值。这可能会导致难以调试的意外行为。在某些情况下，例如执行除法，指向包含零值的意外位置将导致程序突然结束(出现分段错误)。这很好，这样你就知道出了问题，甚至知道问题出在哪里。指针甚至可能指向程序地址空间之外，这可能导致系统崩溃。然而在我们的例子中，寄存器位置和相关类型是众所周知的，使用指针是相对安全的。也就是说，只要我们正确地执行指针算法…</p></blockquote><h2 id="60d0" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">bcm_spi_begin()</h2><p id="14d5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">初始化BCM2835上的SPI接口。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="ff7e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第2行</strong>定义了32位地址变量<code class="fe nq nr ns nt b">paddr</code>，它将包含我们将要操作的GPIO寄存器的地址。</p><p id="7482" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">行4 &amp; 5 </strong>验证SPI0寄存器偏移量是否在<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_init" rel="noopener ugc nofollow" target="_blank"> bcm_init() </a>中成功初始化。在调用<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_init" rel="noopener ugc nofollow" target="_blank"> bcm_init() </a>之前，所有寄存器组偏移量都被设置为值<code class="fe nq nr ns nt b">MAP_FAILED</code>，以防止程序在<code class="fe nq nr ns nt b">bcm_init()</code>未被调用或未成功完成时运行。</p><p id="23f0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第7行到第11行</strong>调用<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_gpio_fsel" rel="noopener ugc nofollow" target="_blank"> bcm_gpio_fsel() </a>来定义替代函数、<code class="fe nq nr ns nt b">BCM_GPIO_FSEL_ALT0</code>或替代函数零，用于设置<code class="fe nq nr ns nt b">BCM_GPIO_P1_*</code>变量引用的管脚的I/O功能。请注意，左边的注释指定了正在设置的SPI引脚，例如<code class="fe nq nr ns nt b">CE1</code>(片选/片使能)。当设置为备用功能0时，这些引脚执行SPI协议。</p><p id="a82b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第13行</strong>将<code class="fe nq nr ns nt b">paddr</code>设置为SPI0地址集的偏移量加上BCM2825 SPI主控制和状态寄存器(CS)的偏移量，如<a class="ae kv" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank">BCM 2835外设指南</a>第152页所述(在这种情况下使用缩写<em class="nf">“CS”</em>可能会造成混淆，但在这种情况下，这不是“芯片选择”偏移量)。注意<code class="fe nq nr ns nt b">BCM_SPI0_CS</code>偏移量除以4。原因已在上文<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_init" rel="noopener ugc nofollow" target="_blank"> bcm_init </a>部分的讨论中讨论过。</p><p id="d93c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第14行</strong>使用<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_peri_write" rel="noopener ugc nofollow" target="_blank"> bcm_peri_write() </a>函数向<code class="fe nq nr ns nt b">paddr</code>指向的SPI控制和状态(CS)寄存器写入0。根据BCM2835 ARM外设指南第155页，在此偏移量设置1字节域会将CS寄存器(控制和状态)中的片选域设置为0，表示片选引脚0。这与Raspberry Pi引脚<code class="fe nq nr ns nt b">BCM_GPIO_P1_24</code>、GPIO引脚8的规格相匹配，GPIO引脚8是<code class="fe nq nr ns nt b">CE0</code>引脚(芯片使能/芯片选择引脚0)。</p><p id="f937" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第17行</strong>如注释所示，使用<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_peri_write" rel="noopener ugc nofollow" target="_blank"> bcm_peri_write_nb() </a>清零发送和接收FIFOs。再次查看BCM2835 ARM外设指南的第155页，我们可以看到<em class="nf"> CS </em>寄存器中的<code class="fe nq nr ns nt b">CLEAR</code>域位于位偏移量4和5处。它给出了清除FIFOs的位值，每个位中的<code class="fe nq nr ns nt b">1</code>。<code class="fe nq nr ns nt b">BCM_SPI0_CS_CLEAR</code>指定的值为<code class="fe nq nr ns nt b">0x30</code>(参见<a class="ae kv" href="https://github.com/youngkin/gpio/blob/main/ledblink/bcmfuncs.h" rel="noopener ugc nofollow" target="_blank"> bcmfuncs.h文件</a>)。将它转换成二进制，我们得到了<code class="fe nq nr ns nt b">0011 0000</code>。位4和5确实被设置为1，因此这些位将在<code class="fe nq nr ns nt b">CS</code>寄存器中被设置。</p><h2 id="ebc0" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">bcm_spi_setBitOrder()</h2><p id="375f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nq nr ns nt b">bcm_spi_setBitOrder()</code>设置SPI接口的位顺序，MSB (1)或LSB (0)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="d8d6" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">bcm_spi_setDataMode()</h2><p id="3d32" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nq nr ns nt b">bcm_spi_setDataMode()</code>指定用于数据传输的时钟极性和相位。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="9a55" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第3行</strong>设置<code class="fe nq nr ns nt b">paddr</code>，SPI0控制和状态(CS)寄存器相对于SPI0寄存器组基址的存储器偏移量。回想一下<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_init" rel="noopener ugc nofollow" target="_blank"> bcm_init() </a>部分的第13行，寄存器偏移量需要除以4。</p><p id="9cbb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第5行</strong>调用<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_peri_set_bits" rel="noopener ugc nofollow" target="_blank"> bcm_peri_set_bits() </a>将SPI0 CS寄存器中的位设置为由<code class="fe nq nr ns nt b">mode</code>指定的位模式。极性和相位位分别是<code class="fe nq nr ns nt b">BCM_SPI0_CS_CPOL</code> ( <code class="fe nq nr ns nt b">0x8</code>)和<code class="fe nq nr ns nt b">BCM_SPI0_CS_CPHA</code> ( <code class="fe nq nr ns nt b">0x4</code>)掩码，用于确保仅设置SPI0 CS寄存器中的这些位。有关屏蔽工作原理的更多详情，请参见<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_gpio_fsel" rel="noopener ugc nofollow" target="_blank"> bcm_gpio_fsel()部分</a>第5行。</p><h2 id="6a17" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">bcm_spi_setClockDivider()</h2><p id="687e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nq nr ns nt b">bcm_spi_setClockDivider()</code>用于设置SPI时钟的频率(SCLK)。它通过将系统时钟频率除以<code class="fe nq nr ns nt b">divider</code>参数来实现这一点。更多详情参见<a class="ae kv" href="https://github.com/youngkin/gpio/blob/main/ledblink/bcmfuncs.h" rel="noopener ugc nofollow" target="_blank"> bcmfuncs.h </a>或<a class="ae kv" href="https://www.airspayce.com/mikem/bcm2835/group__constants.html#gaf2e0ca069b8caef24602a02e8a00884e" rel="noopener ugc nofollow" target="_blank"> BCM2835 C库文档</a>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="702e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第3行</strong>将<code class="fe nq nr ns nt b">paddr</code>设置为SPI时钟(<code class="fe nq nr ns nt b">BCM_SPI0_CLK</code>)寄存器相对于SPI0寄存器组基址的存储器偏移量。回想一下<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_init" rel="noopener ugc nofollow" target="_blank"> bcm_init() </a>部分的第13行，寄存器偏移量需要除以4。</p><p id="2e27" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第5行</strong>调用<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_peri_write" rel="noopener ugc nofollow" target="_blank"> bcm_peri_write() </a>设置分频器值。</p><h2 id="8107" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">bcm_gpio_fsel()</h2><p id="da1c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nq nr ns nt b">bcm_fsel</code>负责设置与给定管脚相关的I/O功能。总共有8种功能可用。其中一个定义了相关联的管脚将被设置为输入管脚，这意味着它将被读取。另一个函数将相关联的引脚定义为输出引脚，这意味着该引脚将被写入。其余6个被称为“备用功能”，并被赋予类似“备用功能0”的名称。为各种备用功能分配的I/O功能因各种GPIO引脚而异。例如，将BCM GPIO引脚17设置为备用功能4可将其I/O功能定义为SPI。它实际上将该引脚定义为SPI功能的一个特定子集，称为芯片使能或芯片选择，但这是后续文章的主题。回想一下，在上面的<code class="fe nq nr ns nt b">main()</code>中，该功能被设置为<code class="fe nq nr ns nt b">BCM_GPIO_FSEL_OUTP</code>，它将<code class="fe nq nr ns nt b">pin</code>定义为输出引脚。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="07d6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">尽管这个函数很短，但它还是有很多内容。</p><p id="7742" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第1行</strong>将函数定义为采用两个参数<code class="fe nq nr ns nt b">pin</code>和<code class="fe nq nr ns nt b">mode</code>。很明显<code class="fe nq nr ns nt b">pin</code>是要分配功能的引脚。<code class="fe nq nr ns nt b">mode</code>是与<code class="fe nq nr ns nt b">pin</code>关联的I/O功能。<code class="fe nq nr ns nt b">mode</code>实际上是分配给特定寄存器偏移量的位模式。位模式分配在第92页第6节<strong class="lq ir"> GPIO </strong>的<a class="ae kv" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank">BCM 2835 I/O外设数据表</a>中定义。模式定义如下:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="9b51" class="ny kx iq nt b gy nz oa l ob oc">000 = GPIO Pin X is an input<br/>001 = GPIO Pin X is an output<br/>100 = GPIO Pin X takes alternate function 0<br/>101 = GPIO Pin X takes alternate function 1<br/>110 = GPIO Pin X takes alternate function 2<br/>111 = GPIO Pin X takes alternate function 3<br/>011 = GPIO Pin X takes alternate function 4<br/>010 = GPIO Pin X takes alternate function 5</span></pre><p id="d0f9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要理解该函数的其余部分，还需要一些额外的背景知识。首先，<a class="ae kv" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank"> BCM2835 ARM外设指南</a>第91页第6节指出，共有54个GPIO引脚可通过功能选择寄存器(GPFSEL0-GPFSEL5)寻址。每个功能选择寄存器的长度为32位。由于上述每个功能选择模式都是3位长，每个功能选择寄存器可以指定10个引脚的I/O功能，剩余2位。每个寄存器10个引脚，总共54个引脚解释了为什么有6个功能选择寄存器，编号为0到5。下面的数学公式就是从这些信息中推导出来的。</p><p id="4f73" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第3行</strong>、<code class="fe nq nr ns nt b">volatile uint32_t* paddr = bcm_gpio + BCM_GPFSEL0/4 + (pin/10);</code>定义了将根据<code class="fe nq nr ns nt b">mode</code>设置的位的寄存器偏移量<code class="fe nq nr ns nt b">paddr</code>。<code class="fe nq nr ns nt b">BCM_GPFSEL0</code>是功能选择寄存器的基址偏移量，以字节为单位。下面是对这一行中执行的算法的解释。</p><ol class=""><li id="ef0b" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj nd mv mw mx bi translated">请注意，正在执行指针运算。回想一下，指针算法的结果是基于目标变量的类型的(参见上面的<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_init" rel="noopener ugc nofollow" target="_blank"> bcm_init() </a>一节)。由于<code class="fe nq nr ns nt b">uint32_t</code>的长度为4字节，因此<code class="fe nq nr ns nt b">BCM_GPFSEL0</code>需要除以4才能正确计算出来。于是<code class="fe nq nr ns nt b">... paddr = bcm_gpio + BCM_GPFSEL0/4 ...</code>。</li><li id="40b8" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated">还记得每个寄存器保存10个引脚的功能选择信息。对于给定的引脚，我们需要确定哪个功能选择寄存器(GPFSEL0至GPFSEL5)指定给定引脚的I/O功能。在C #中，产生分数的整数除法的结果将被向下舍入。因此，如果我们将引脚数除以10，<code class="fe nq nr ns nt b">(pin/10</code>，我们将得到正确功能选择寄存器的偏移。因此，引脚9将导致<code class="fe nq nr ns nt b">9/10</code>等于0，这意味着引脚9的功能选择位置在GPFSEL0中。同样，引脚17的<code class="fe nq nr ns nt b">17/10 = 1</code>功能选择寄存器是GPFSEL1。诸如此类。</li></ol><p id="2674" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">综上所述，等式<code class="fe nq nr ns nt b">paddr = bcm_gpio + BCM_GPFSEL0/4 + (pin/10)</code>得出适合给定<code class="fe nq nr ns nt b">pin</code>的功能选择寄存器偏移。对于引脚17，这将导致<code class="fe nq nr ns nt b">paddr</code>逻辑指向地址<code class="fe nq nr ns nt b">0x7E20 0004</code>处的GPFSEL1，<code class="fe nq nr ns nt b">7E</code>是总线地址，<code class="fe nq nr ns nt b">20004</code>是GPIO寄存器的偏移量加上GPFSEL1的偏移量，<code class="fe nq nr ns nt b">4</code>，从GPIO寄存器组开始。我说逻辑上是因为<code class="fe nq nr ns nt b">bcm_gpio</code>是从作为<code class="fe nq nr ns nt b">mmap()</code>操作结果返回的地址的偏移。<code class="fe nq nr ns nt b">mmap()</code>返回一个指向进程虚拟内存的指针，而<code class="fe nq nr ns nt b">0x7E20 0004</code>是BCM2835的<em class="nf"> VC CPU总线地址</em>空间中的一个地址。</p><p id="8699" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第4行</strong>，<code class="fe nq nr ns nt b">uint8_t shift = (pin % 10) * 3;</code>，计算给定引脚的功能选择值在功能选择寄存器中的位置。由于我们将使用位移位来设置引脚的功能选择值，因此该位置将成为<strong class="lq ir">位移位</strong>的位数，引脚的功能选择值在<code class="fe nq nr ns nt b">mode</code>参数中提供。为了进行计算，我们首先需要找到引脚的逻辑位置，即功能选择寄存器中的哪个3位单元(回想一下，每个功能选择值都是3位长)。对此的计算由<code class="fe nq nr ns nt b">shift = (pin % 10) ...</code>给出。用于销17 <code class="fe nq nr ns nt b">(17 % 10) = 7</code>。因此，引脚17的3位单元位于第7个3位偏移处。接下来，我们必须找到寄存器中的实际位偏移。由于每个功能选择值为3位长，每个引脚的边界是3的倍数，因此完成了<code class="fe nq nr ns nt b">shift = (pin % 10) * 3</code>的计算。对于引脚17，这导致<code class="fe nq nr ns nt b">(17%10)*3</code>等于<code class="fe nq nr ns nt b">7*3</code>，从而导致21的绝对位偏移。查阅第92页的<a class="ae kv" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank"> BCM2835 ARM外设指南第6节</a>，我们可以确认GPFSEL0寄存器中引脚17的偏移位于位21至23。</p><p id="9b9b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在我们来看<strong class="lq ir">第5行</strong>，<code class="fe nq nr ns nt b">uint32_t mask = BCM_GPIO_FSEL_MASK &lt;&lt; shift;</code>。当将位的子集设置为给定值时，我们希望保留周围位的值。使用掩模来实现这一点。掩码包含一个(或多个)位，该位位于目标值中我们要更改的位的位置。例如，在位模式<code class="fe nq nr ns nt b">0101 1111</code>中，如果我们想将位6的值从1设置为0，我们只需定义一个设置了1位的位序列。为了创建最通用的解决方案，我们只需设置最低有效位。由于我们只需要一个位组，我们将掩码定义为十六进制数<code class="fe nq nr ns nt b">0x1</code>，它指定了位模式<code class="fe nq nr ns nt b">0000 0001</code>。接下来，我们需要根据需要移动该位模式，以便将<code class="fe nq nr ns nt b">1</code>位移动到正确的位置。在我们的例子中，由于我们想要改变位6，我们将把掩码模式左移6位，例如<code class="fe nq nr ns nt b">newMask = 0000 0001 &lt;&lt; 6</code>。这导致<code class="fe nq nr ns nt b">newMask</code>等于<code class="fe nq nr ns nt b">0100 00000</code>，这就把<code class="fe nq nr ns nt b">1</code>位放到了我们想要的位置6。我们可以直接将掩码定义为<code class="fe nq nr ns nt b">0100 0000</code>，但这不会产生一个通用的解决方案，该方案适用于在任意位位置(如21-23位)设置位所需的任何掩码。</p><p id="2663" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如<code class="fe nq nr ns nt b">bcmfuncs.h</code>所示，<code class="fe nq nr ns nt b">BCM_GPIO_FSEL_MASK</code>的值为0x7或<code class="fe nq nr ns nt b">0000 0111</code>，这是因为每个GPIO功能选择模式的长度为3位。因此，对于屏蔽3位序列，这是一个有用的位模式。如果我们按照上面第4行的计算，将这个模式移位21的<strong class="lq ir">移位</strong>，我们将得到一个32位的模式，看起来像这样，<code class="fe nq nr ns nt b">0000 0000 1110 0000 0000 0000 0000 0000</code>。该掩码现在位于位位置21-23，这是GPFSEL1功能选择寄存器中引脚17的功能选择模式的位置。</p><p id="5d24" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">总之，<strong class="lq ir">行5 </strong>创建设置3位功能选择模式所需的屏蔽，如所提供的<code class="fe nq nr ns nt b">pin</code>参数中的<code class="fe nq nr ns nt b">mode</code>参数所指定。</p><p id="3435" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第6行</strong>，<code class="fe nq nr ns nt b">uint32_t value = mode &lt;&lt; shift;</code>创建新的3位值，该值将被放入GPFSEL1寄存器。回想一下，GPFSEL1是一个32位寄存器。为了使用诸如<code class="fe nq nr ns nt b">mode</code>的3位值在任意位置(例如，位21-23)设置3位序列，我们创建一个值掩码，将所需位置的位设置为所需值。与上面的掩码一样，最通用的解决方案规定这些位从最低有效位置开始设置。假设在我们的示例中，我们希望将引脚17设置为备用功能1。查看上面的位模式，我们可以看到备用功能1的3位值是<code class="fe nq nr ns nt b">101</code>。<code class="fe nq nr ns nt b">mode</code>参数将包含该值。为了将引脚17设置为备用功能1，我们需要将<code class="fe nq nr ns nt b">mode</code>的21位位模式向左移位。与第5行一样，第6行以一种通用的方式来做这件事，<code class="fe nq nr ns nt b">value = mode &lt;&lt; shift</code>。给定我们的值<code class="fe nq nr ns nt b">mode</code>和计算的值<code class="fe nq nr ns nt b">shift</code>，我们得到<code class="fe nq nr ns nt b">0000 0000 1010 0000 0000 0000 0000 0000</code>的32位<code class="fe nq nr ns nt b">value</code>。</p><p id="6178" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在我们有了计算GPFSEL1寄存器新值所需的4个变量，<code class="fe nq nr ns nt b">paddr</code>、<code class="fe nq nr ns nt b">mode</code>、<code class="fe nq nr ns nt b">mask</code>和<code class="fe nq nr ns nt b">value</code>。</p><p id="6f02" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第7行</strong>调用函数<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_peri_set_bits" rel="noopener ugc nofollow" target="_blank"> bcm_peri_set_bits() </a>完成本次操作。该操作在一个单独的函数中完成，因为还有其他寄存器值需要设置，我们将在后面看到。</p><h2 id="4c85" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">bcm_gpio_write()</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="0e33" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nq nr ns nt b">bcm_gpio_write()</code>将32位值写入指定的<code class="fe nq nr ns nt b">pin</code>。它使用了两个辅助函数，<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_gpio_set-and-bcm_gpio_clr" rel="noopener ugc nofollow" target="_blank"> bcm_gpio_set() </a>和<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_gpio_set-and-bcm_gpio_clr" rel="noopener ugc nofollow" target="_blank"> bcm_gpio_clr() </a>。参数<code class="fe nq nr ns nt b">on</code>用于指定<code class="fe nq nr ns nt b">pin</code>的值是否应该设置或清除。有一组4个GPIO寄存器:GPSET0和GPSET1，以及GPCLR0和GPCLR1，用于指定引脚的值是高还是低。高电平对应于GPSETn值为1。低电平对应于GPCLRn值1。</p><p id="b15b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当<code class="fe nq nr ns nt b">on</code>的值为<code class="fe nq nr ns nt b">1</code>时，与<code class="fe nq nr ns nt b">pin</code>的值相关的GPSETn寄存器被设置为1。如果<code class="fe nq nr ns nt b">on</code>被设置为<code class="fe nq nr ns nt b">0</code>，则与<code class="fe nq nr ns nt b">pin</code>的值相关联的GPCLRn寄存器被设置为1。这就产生了一个问题，如果GPSETn和GPCLRn位都设置为<code class="fe nq nr ns nt b">1</code>会怎么样？根据BCM2835 ARM外设指南，“<em class="nf"> …该位将根据最后一次设置/清除操作</em>进行设置。</p><p id="158b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">GPSETn和GPCLRn的值仅在引脚的I/O功能设置为输出时使用。这些寄存器中<code class="fe nq nr ns nt b">0</code>的值被忽略。回想一下，BCM2835允许为54个引脚指定GPIO功能(预期为40个)。由于每个引脚需要1位来指定是置位还是清零，因此总共需要54位。这解释了为什么设置和清除需要两个32位寄存器。</p><p id="063d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这些寄存器的使用在<a class="ae kv" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank"> BCM2835 ARM外设指南</a>第95页第6节中有进一步描述。</p><h2 id="0eff" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">bcm_peri_read()</h2><p id="d953" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nq nr ns nt b">bcm_peri_read()</code>将从<code class="fe nq nr ns nt b">paddr</code>开始读取32位，并将它们作为32位值返回给调用者。与<code class="fe nq nr ns nt b">bcm_fsel()</code>和<code class="fe nq nr ns nt b">bcm_peri_set_bits()</code>不同，这个功能相当简单。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="3c94" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第4行&amp;第6行</strong>同步对内存的访问，这样读取就不会被中断。</p><p id="d590" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第5行</strong>简单地将返回值<code class="fe nq nr ns nt b">ret</code>设置为位于<code class="fe nq nr ns nt b">paddr</code>的内容。</p><p id="92f9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个函数还有另一个版本叫做<code class="fe nq nr ns nt b">bcm_peri_read_nb()</code>。不同版本之间的区别在于<code class="fe nq nr ns nt b">nb</code>版本是非阻塞的，这意味着不使用<code class="fe nq nr ns nt b">__sync_synchoronize()</code>调用。</p><h2 id="b695" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">bcm_peri_write()</h2><p id="249e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nq nr ns nt b">bcm_peri_write()</code>将从<code class="fe nq nr ns nt b">paddr</code>开始的32位设置为<code class="fe nq nr ns nt b">value</code>中包含的值。像<code class="fe nq nr ns nt b">bcm_peri_read()</code>这个功能挺简单的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="2fe5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第3行和第5行</strong>同步访问(锁定)从<code class="fe nq nr ns nt b">paddr</code>开始的32位。</p><p id="0091" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第4行</strong>将位于<code class="fe nq nr ns nt b">paddr</code>的32位设置为<code class="fe nq nr ns nt b">value</code>。</p><p id="2b65" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个函数还有另一个版本，叫做<code class="fe nq nr ns nt b">bcm_peri_write_nb()</code>。不同版本的区别在于<code class="fe nq nr ns nt b">nb</code>版本是非阻塞的，这意味着不使用<code class="fe nq nr ns nt b">__sync_synchoronize()</code>调用。</p><h2 id="79a1" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">bcm_gpio_set()和bcm_gpio_clr()</h2><p id="7be9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nq nr ns nt b">bcm_gpio_set()</code>和<code class="fe nq nr ns nt b">bcm_gpio_clr()</code>在功能上是双胞胎。它们只在操作的寄存器上有所不同。<code class="fe nq nr ns nt b">*set()</code>作用于GPSETn寄存器，而<code class="fe nq nr ns nt b">*clr()</code>作用于GPCLRn寄存器。它们负责为所提供的<code class="fe nq nr ns nt b">pin</code>参数在适当的寄存器中设置适当的位偏移。本节将只描述<code class="fe nq nr ns nt b">bcm_gpio_set()</code>。除了在寄存器组上操作之外，它们的实现是相同的。事实上，通过添加另一个参数来指定起始偏移量，它们可以合并成一个函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="7043" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在<code class="fe nq nr ns nt b">bcm_gpio_set()</code> <strong class="lq ir">中，第3行</strong>计算目标寄存器的地址<code class="fe nq nr ns nt b">paddr</code>。<code class="fe nq nr ns nt b">bcm_gpio</code>是GPIO寄存器的起始偏移量。<code class="fe nq nr ns nt b">BCM_GPSET0</code>是置位和清零寄存器的起始偏移量。回想一下上面<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_init" rel="noopener ugc nofollow" target="_blank"> bcm_init() </a>部分的讨论，指针算法用于确定给定操作的内存偏移量。</p><p id="92be" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这就是为什么<code class="fe nq nr ns nt b">BCM_GPSET0</code>在这个操作中被4除。<code class="fe nq nr ns nt b">pin/32</code>用于计算哪个<code class="fe nq nr ns nt b">GP*n</code>寄存器将用于给定的<code class="fe nq nr ns nt b">pin</code>。回想一下，整数除法总是向下舍入。因此<code class="fe nq nr ns nt b">pin 17/32</code>的结果是<code class="fe nq nr ns nt b">0</code>，它指定将使用第一个<code class="fe nq nr ns nt b">GP*n</code>寄存器。与<a class="ae kv" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank">BCM 2835 ARM外设指南</a>第95和96页一致，这是正确寄存器内的正确偏移量。</p><p id="ad85" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第4行</strong>计算目标GPSETn/GPCLRn寄存器中置位/清零位的位位置。由于每个引脚仅使用一位，模数(<code class="fe nq nr ns nt b">%</code>)运算符将提供正确的位置。例如，引脚17的结果是17。这是GPSETn/GPCLRn寄存器中引脚17的位。</p><p id="4f32" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第5行</strong>然后使用<code class="fe nq nr ns nt b"><a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_peri_write" rel="noopener ugc nofollow" target="_blank">bcm_peri_write()</a></code>将<code class="fe nq nr ns nt b">1</code>、<code class="fe nq nr ns nt b">shift</code>位向左移位，以便写入正确寄存器中的正确偏移量。例如，对于引脚17，第4行<code class="fe nq nr ns nt b">17%32</code>、<code class="fe nq nr ns nt b">1</code>上的计算向左移动17位。</p><p id="84d7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您可能已经注意到，与<code class="fe nq nr ns nt b"><a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_gpio_fsel" rel="noopener ugc nofollow" target="_blank">bcm_gpio_fsel()</a></code>不同，没有使用掩码来保护指定寄存器中的其他位。我不确定为什么会这样。这很奇怪，因为这种方法会导致寄存器中的所有其他位被设置为零(0)。我在这里只是推测，但我猜这是因为这些寄存器中的零值被忽略，并且根据<a class="ae kv" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank"> BCM2835 ARM外设指南</a>，第95页，“<em class="nf"> …该位将根据最后的设置/清除操作</em>来设置。我认为这意味着当一个<code class="fe nq nr ns nt b">1</code>被写入适当的寄存器时，一个输出引脚的值将被设置，GPSETn的<code class="fe nq nr ns nt b">1</code>和GPCLRn的<code class="fe nq nr ns nt b">0</code>将被设置，并且随后对<code class="fe nq nr ns nt b">0</code>的更改将不会产生任何影响。然而，这只是一个有根据的猜测。</p><h2 id="680b" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">bcm_spi_transfer()</h2><p id="94ed" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nq nr ns nt b">bcm_spi_transfer()</code>向SPI0 FIFO寄存器的SPI0 FIFO位写入和读取一个字节。SPI传输是全双工的，这意味着数据可以写入SPI从机，也可以从SPI从机接收数据。</p><p id="0c68" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">有关CS和FIFO寄存器设置的更多详情，请参见<a class="ae kv" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank">BCM 2835 ARM外设指南</a>的第10节，从第153页开始。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="adc0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第3行</strong>定义了<code class="fe nq nr ns nt b">paddr</code>变量，它是SPI0 CS寄存器的偏移量。回想一下<code class="fe nq nr ns nt b"><a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_init" rel="noopener ugc nofollow" target="_blank">bcm_init()</a></code> <a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_init" rel="noopener ugc nofollow" target="_blank">部分</a>第13行，这些偏移需要除以4。</p><p id="103e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第4行</strong>定义了<code class="fe nq nr ns nt b">fifo</code>变量，它是SPI0 FIFO寄存器的偏移量。</p><p id="9253" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第7行</strong>使用<code class="fe nq nr ns nt b"><a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_peri_set_bits" rel="noopener ugc nofollow" target="_blank">bcm_peri_set_bits()</a></code>清除发送和接收FIFOs，为数据传输做准备。更多关于<code class="fe nq nr ns nt b">bcm_peri_set_bits()</code>的报道如下。</p><p id="e824" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第10行</strong>使用<code class="fe nq nr ns nt b"><a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_peri_set_bits" rel="noopener ugc nofollow" target="_blank">bcm_peri_set_bits()</a></code>来设置SPI0 CS寄存器中的<code class="fe nq nr ns nt b">TA</code>位。<code class="fe nq nr ns nt b">TA</code>位用于指示SPI传输有效。</p><p id="d243" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第13行</strong>暂停执行，直到FIFO寄存器可以接收数据。<code class="fe nq nr ns nt b">BCM_SPI0_CS_TXD</code>值是一个在第18位包含<code class="fe nq nr ns nt b">1</code>的掩码，这意味着如果“TX FIFO至少有1个字节的空间”，表达式将返回true。</p><p id="4156" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第17行</strong>写入FIFO寄存器，确保发送的字节按MSB顺序排列(详情见上文<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_correct_order" rel="noopener ugc nofollow" target="_blank"> bcm_correct_order() </a>)。它使用非阻塞/非同步版本的<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_peri_write" rel="noopener ugc nofollow" target="_blank"> bcm_peri_write </a>进行传输，但我不确定为什么。在我看来，阻塞/同步版本更安全，可以确保并发写入不会相互冲突。</p><p id="c30b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第20行</strong>等待SPI从机的传输完成。</p><p id="230e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第24行</strong>首先读取SPI从机，然后根据需要将输出转换为MSB顺序。</p><p id="1a55" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第27行</strong>清零<code class="fe nq nr ns nt b">TA</code>位，表示SPI传输完成。</p><p id="5db7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">线29 </strong>返回<strong class="lq ir">线24 </strong>上的读取结果。</p><h2 id="3313" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">bcm_correct_order()</h2><p id="6d78" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nq nr ns nt b">bcm_correct_order()</code>确保发送到SPI0的数据以MSB顺序排列。更多详情参见<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#init_spi" rel="noopener ugc nofollow" target="_blank"> bcm_init_spi </a>部分第6行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="8ec8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果在<em class="nf">行4 </em>上的检查显示字节顺序当前被设置为<code class="fe nq nr ns nt b">BCM_SPI_BIT_ORDER_LSBFIRST</code>，则<strong class="lq ir">行5 </strong>反转位顺序。根据<code class="fe nq nr ns nt b">bcm_byte_reverse_table</code>的评论:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="e218" class="ny kx iq nt b gy nz oa l ob oc">/* SPI bit order. BCM2835 SPI0 only supports MSBFIRST, so we instead <br/> * have a software based bit reversal, based on a contribution by Damiano Benedetti<br/> */</span></pre><p id="5a5a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这句话的重点是<em class="nf">“BCM 2835 SPI 0只支持msb first”</em>。另外两个SPI I/O功能<code class="fe nq nr ns nt b">SPI1</code>和<code class="fe nq nr ns nt b">SPI2</code>支持MSB和LSB。更多详情参见第23页<a class="ae kv" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank"> BCM2835 ARM外设指南</a>第<em class="nf"> 2.3.4 SPI寄存器详情</em>章节。具体来说，AUXSPI0/1_CNTL0寄存器的位6用于指定MSB或LSB - <em class="nf">“移出MS位优先”</em>和<em class="nf">(如果为1，则数据从MS位开始移出)。(位15或位11)。如果为0，则数据从LS位开始移出。</em>(位0)。BCM2835版本1.53中增加了对此的支持。更多详情请参见此<a class="ae kv" href="https://groups.google.com/g/bcm2835/c/bkCc8mzq7io/m/DtmVmOyqAQAJ" rel="noopener ugc nofollow" target="_blank"> BCM2835谷歌群组主题</a>。</p><h2 id="eaeb" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">bcm_peri_set_bits()</h2><p id="8548" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nq nr ns nt b">bcm_peri_set_bits()</code>在将<code class="fe nq nr ns nt b">mask</code>应用于提供的<code class="fe nq nr ns nt b">value</code>后，将更新值写入地址<code class="fe nq nr ns nt b">paddr</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="803c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第3行</strong>使用<code class="fe nq nr ns nt b"><a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_peri_read" rel="noopener ugc nofollow" target="_blank">bcm_peri_read()</a></code>从提供的地址<code class="fe nq nr ns nt b">paddr</code>读取当前值。</p><p id="dd54" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第4行</strong>根据<code class="fe nq nr ns nt b">value</code>和<code class="fe nq nr ns nt b">mask</code>计算新值<code class="fe nq nr ns nt b">v</code>，并写入<code class="fe nq nr ns nt b">paddr</code>。这里有一个例子来演示这个有点复杂的代码行是如何实现这一点的。这个过程类似于在<code class="fe nq nr ns nt b"><a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_gpio_fsel" rel="noopener ugc nofollow" target="_blank">bcm_gpio_fsel()</a></code>部分第5行解释的过程。它是以不同的方式实现的，因此有必要描述一下这个应用遮罩的替代过程。</p><p id="5be5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">先从下面说起:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="1ccc" class="ny kx iq nt b gy nz oa l ob oc">value = 0000 0100 <br/>mask  = 0000 1100</span></pre><p id="5f88" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nq nr ns nt b">mask</code>将位2和位3设置为<code class="fe nq nr ns nt b">11</code>。这指定这些是要复位的位(在本例中)。在过程结束时，这2位将被设置为与<code class="fe nq nr ns nt b">value</code>中指定的位相同的值，即<code class="fe nq nr ns nt b">01</code>。存储在<code class="fe nq nr ns nt b">paddr</code>的当前值的剩余位将保持不变。</p><p id="8d9e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在读取上面第3行<code class="fe nq nr ns nt b">paddr</code>的当前内容后，<code class="fe nq nr ns nt b">v</code>被设置为<code class="fe nq nr ns nt b">1100 1011</code>。由于上面的<code class="fe nq nr ns nt b">value</code>指定位2和3应设置为<code class="fe nq nr ns nt b">01</code>，写入<code class="fe nq nr ns nt b">paddr</code>的新值预计为<code class="fe nq nr ns nt b">1100 0111</code>。</p><p id="7a9e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在让我们逐步建立在<strong class="lq ir">行4 </strong>中执行的<code class="fe nq nr ns nt b">v</code>的最终值:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="3525" class="ny kx iq nt b gy nz oa l ob oc">~mask   = 1111 0011<br/>v       = 1100 1011<br/>v&amp;~mask = 1100 0011</span></pre><p id="b0c3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们首先取<code class="fe nq nr ns nt b">mask</code>、<code class="fe nq nr ns nt b">~mask</code>的补码，这样我们可以将位2和3重置为<code class="fe nq nr ns nt b">00</code>，同时保持原始值<code class="fe nq nr ns nt b">v</code>的剩余位不变。当我们计算<code class="fe nq nr ns nt b">v&amp;~mask</code>时，我们得到<code class="fe nq nr ns nt b">1100 0011</code>。这提供了期望的结果，除2 &amp; 3之外的所有位保持其当前值。</p><p id="eb3c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下一步，我们计算第2位和第3位的新值。</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="daa4" class="ny kx iq nt b gy nz oa l ob oc">value      = 0000 0100<br/>mask       = 1111 1100<br/>value&amp;mask = 0000 0100</span></pre><p id="f7ee" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果我们将这个值与<code class="fe nq nr ns nt b">v&amp;~mask</code>的结果进行<code class="fe nq nr ns nt b">|</code>(或)运算，我们将得到如下所示的最终结果</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="b16a" class="ny kx iq nt b gy nz oa l ob oc">v&amp;~mask                  = 1100 0011<br/>value&amp;mask               = 0000 0100<br/>(v&amp;~mask) | (value&amp;mask) = 1100 0111</span></pre><p id="f84e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此<strong class="lq ir">行4 </strong>中计算的最终值是<code class="fe nq nr ns nt b">1100 0111</code>，第2位和第3位已被设置为所需值，其余位保持不变。下面是寄存器的旧值和当前值的比较:</p><pre class="kg kh ki kj gt nu nt nv nw aw nx bi"><span id="849c" class="ny kx iq nt b gy nz oa l ob oc">original value = 1100 1011<br/>new value      = 1100 0111</span></pre><p id="05cb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第5行</strong>使用<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_peri_write" rel="noopener ugc nofollow" target="_blank"> bcm_peri_write() </a>简单地将新值<code class="fe nq nr ns nt b">v</code>写入<code class="fe nq nr ns nt b">paddr</code>。</p><h2 id="6ae9" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">bcm_spi_end()</h2><p id="3ea9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nq nr ns nt b">bcm_spi_end()</code>反转<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_init" rel="noopener ugc nofollow" target="_blank"> bcm_init() </a>的效果。它使用<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_gpio_fsel" rel="noopener ugc nofollow" target="_blank"> bcm_gpio_fsel() </a>将所有SPI0 GPIO引脚从SPI模式、<code class="fe nq nr ns nt b">BCM_GPIO_FSEL_ALT0</code>备用功能反转回输入模式、<code class="fe nq nr ns nt b">BCM_GPIO_FSEL_INPT</code>。在下面的代码中，引脚引用，例如<code class="fe nq nr ns nt b">BCM_GPIO_P1_26</code>，指的是交叉引用Raspberry Pi引脚号的<code class="fe nq nr ns nt b">#define</code>，例如<code class="fe nq nr ns nt b">26</code>到GPIO引脚号。例如，<code class="fe nq nr ns nt b">BCM_GPIO_P1_26</code>指的是Raspberry Pi引脚26，它映射到GPIO引脚7，即CE1引脚。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="d19b" class="ny kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">bcm_close()</h2><p id="e3c7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nq nr ns nt b">bcm_close</code>解除分配所有资源，并将所有GPIO偏移量重置为其原始值，本例中为<code class="fe nq nr ns nt b">MAP_FAILED</code>。关于<code class="fe nq nr ns nt b">MAP_FAILED</code>，该值防止对BCM2835外设寄存器进行任何操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="e035" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第3行</strong>释放<code class="fe nq nr ns nt b"><a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#bcm_init" rel="noopener ugc nofollow" target="_blank">bcm_init()</a></code>中<code class="fe nq nr ns nt b">mapmem()</code>操作预留的内存。</p><p id="94dd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第4–14行</strong>将所有寄存器偏移重置为默认设置。</p><h1 id="6b3f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">摘要</h1><p id="d45f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果您已经读到这里，特别是如果您已经阅读了关于直接与BCM2835交互的部分，那么恭喜您！这是一篇又长又详细的文章。我真的希望你发现它值得你投入时间和精力。</p><p id="9b5b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这篇文章涉及了相当多的领域。首先，它通过一个工作示例带您完成了遵循本文所需的物理设置。</p><p id="429a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">其次，它相当详细地概述了SPI协议。这包括:</p><ol class=""><li id="4c45" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj nd mv mw mx bi translated">SPI概述以及您可能使用它的方式和原因</li><li id="4651" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated">MAX7219 LED点阵显示模块的描述</li><li id="1312" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated">MAX7219中的物理引脚以及BCM2835上相应的GPIO引脚的描述</li><li id="ed81" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nd mv mw mx bi translated">说明信号工作原理的SPI时序图示例</li></ol><p id="a5a5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">第三，它引导您完成主程序，演示如何对MAX7219进行编程以显示一系列数字、字符和形状。这个主程序本身足以帮助您理解如何使用BCM2835 C库对SPI进行编程。</p><p id="a5e1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">第四，它详细描述了如何直接对BCM2835上与SPI协议相关的寄存器进行编程。</p><p id="c8d7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">就这些，感谢阅读！欢迎对本文提出评论和问题。</p><h1 id="738f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">参考</h1><ul class=""><li id="bf90" class="mp mq iq lq b lr ls lu lv lx oq mb or mf os mj mu mv mw mx bi translated"><a class="ae kv" href="https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.6_led_dot_matrix_c.html" rel="noopener ugc nofollow" target="_blank">sun founder LED点阵模块</a>是试验板图的来源，也是<a class="ae kv" href="https://youngkin.github.io/post/spidotmatrixmodule/#controlling-the-max7219---main-program" rel="noopener ugc nofollow" target="_blank"> main() </a>和支持功能的原始版本。</li><li id="4a22" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><a class="ae kv" href="https://pinout.xyz/" rel="noopener ugc nofollow" target="_blank"> Raspberry Pi GPIO引脚排列图</a>提供了物理板引脚编号的位置及其与相应的BCM/GPIO引脚编号和WiringPi引脚编号的映射。</li><li id="0d11" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">gpio存储库包含了这篇文章和其他文章的代码</li><li id="e393" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><a class="ae kv" href="https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up" rel="noopener ugc nofollow" target="_blank">如何从头开始设置新的树莓Pi</a></li><li id="5341" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><a class="ae kv" href="https://www.sciencebuddies.org/science-fair-projects/references/how-to-use-a-breadboard" rel="noopener ugc nofollow" target="_blank">如何使用试验板</a></li><li id="1df3" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><a class="ae kv" href="https://youngkin.github.io/categories/gpio/" rel="noopener ugc nofollow" target="_blank">树莓Pi上的GPIO编程3B+ </a>是我关于树莓Pi上的GPIO编程的文章的链接</li><li id="2c56" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><a class="ae kv" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank">BCM 2835臂外设指南</a>。</li><li id="664b" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface" rel="noopener ugc nofollow" target="_blank">维基百科串行外设接口</a>文章详细介绍了SPI协议。</li><li id="70a1" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><a class="ae kv" href="https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf" rel="noopener ugc nofollow" target="_blank">max 7219数据手册</a>描述了MAX7219 LED点阵显示器的底层细节，称为串行接口8位LED显示器驱动器。它包括关于寄存器的详细信息、它们的作用以及如何设置它们。</li><li id="5fc1" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">麦克·麦考利的T21图书馆</li><li id="3a4b" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">C <a class="ae kv" href="http://wiringpi.com/" rel="noopener ugc nofollow" target="_blank"> WiringPi </a>库和相关的<a class="ae kv" href="https://github.com/WiringPi/WiringPi" rel="noopener ugc nofollow" target="_blank"> GitHub库</a></li><li id="2802" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">Python <a class="ae kv" href="http://abyz.me.uk/rpi/pigpio/" rel="noopener ugc nofollow" target="_blank"> pgpio </a>库</li><li id="eb24" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">Python <a class="ae kv" href="https://pypi.org/project/RPi.GPIO/" rel="noopener ugc nofollow" target="_blank"> RPi。GPIO </a>库</li><li id="2656" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">Go <a class="ae kv" href="https://github.com/stianeikeland/go-rpio" rel="noopener ugc nofollow" target="_blank"> go-rpio </a></li><li id="fbfe" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><a class="ae kv" href="http://robojax.com/learn/arduino/8x8LED/" rel="noopener ugc nofollow" target="_blank">用于LED矩阵8x8的Sprite生成器</a>是一个在线工具，在LED矩阵上给定一个输入形状，它将输出显示该形状所需的十六进制数。</li></ul></div></div>    
</body>
</html>