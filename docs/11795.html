<html>
<head>
<title>From 30 to 11 Lines of Code: Rock Paper Scissors in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第30到11行代码:Python中的石头剪刀布</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/from-30-to-11-lines-of-code-rock-paper-scissors-in-python-5bfa4313a8a7?source=collection_archive---------5-----------------------#2022-04-18">https://betterprogramming.pub/from-30-to-11-lines-of-code-rock-paper-scissors-in-python-5bfa4313a8a7?source=collection_archive---------5-----------------------#2022-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="46b7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">重温流行的初学者游戏</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/75ee12b8abcda47398554af2bb7bb958.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mdazbC9QLpwGn8MXbtIMqA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由Mariet Jieopp为Getty Images提供(与Canva Pro许可一起使用)</p></figure><p id="21ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当你第一次学习编程时，你会寻找——或者，可能会被分配——强化基本概念的项目。但是，一旦你获得了更多的知识和经验，你多久会从一个高级程序员的角度重新审视那些初学者项目呢？</p><p id="5b31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我想这样做。我想重温一个常见的初学者项目——用Python实现游戏“石头剪子布”——用我在将近八年的Python编程经验中获得的知识。</p><h1 id="2434" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">“石头剪刀布”的规则</h1><p id="88dd" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在深入研究代码之前，让我们先概述一下“石头剪子布”是如何玩的。两名玩家每人选择三个项目中的一个:石头、布或剪刀。玩家同时向对方展示他们的选择，获胜者由以下规则决定:</p><ol class=""><li id="f7fa" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated">石头打败剪刀</li><li id="8d4b" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">剪刀打败了布</li><li id="14ee" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">纸打败了石头</li></ol><p id="96d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从小到大，我和我的朋友们用“石头剪刀布”解决各种各样的问题。在单人电子游戏中谁先开始玩？谁得到最后一罐汽水？谁要去收拾我们刚刚制造的烂摊子？重要的东西。</p><h1 id="3c38" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">要求</h1><p id="bef3" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">让我们列出实现的一些要求。与其构建一个完整的游戏，不如让我们专注于编写一个名为<code class="fe nf ng nh ni b">play()</code>的函数，它接受两个字符串参数——每个玩家选择的<code class="fe nf ng nh ni b">"rock"</code>、<code class="fe nf ng nh ni b">"paper"</code>或<code class="fe nf ng nh ni b">"scissors"</code>——并返回一个字符串，指示获胜者(例如<code class="fe nf ng nh ni b">"paper wins"</code>)或游戏结果是否相同(例如<code class="fe nf ng nh ni b">"tie"</code>)。</p><p id="c4b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一些关于如何调用<code class="fe nf ng nh ni b">play()</code>以及它返回什么的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2a65" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果两个参数中的一个或两个无效，意味着它们不是<code class="fe nf ng nh ni b">"rock"</code>、<code class="fe nf ng nh ni b">"paper"</code>或<code class="fe nf ng nh ni b">"scissors"</code>中的一个，那么<code class="fe nf ng nh ni b">play()</code>应该抛出某种异常。</p><p id="8c96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nf ng nh ni b">play()</code>也应该是<strong class="la iu">可换的</strong>。也就是说，<code class="fe nf ng nh ni b">play("rock", "paper")</code>应该返回和<code class="fe nf ng nh ni b">play("paper", "rock")</code>一样的东西。</p><h1 id="0688" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">“初学者”解决方案</h1><p id="b0d0" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">为了设置比较基准，考虑初学者如何实现<code class="fe nf ng nh ni b">play()</code>函数。如果这个初学者和我第一次学习编程时一样，他们可能会开始写下一大串<code class="fe nf ng nh ni b">if</code>语句:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="fe59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">严格来说，这段代码没有什么错。它运行无误，符合所有要求。这也类似于谷歌搜索“石头剪子布python”的一些高级实现</p><p id="b646" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，有经验的程序员会很快识别出许多代码气味。特别是，代码是重复的，并且有许多可能的执行路径。</p><h1 id="f2fe" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">高级解决方案#1</h1><p id="27ec" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">从更高级的角度来看，实现“石头剪刀布”的一种方法是利用Python的字典类型。字典可以根据游戏规则将项目映射到它们击败的项目。</p><p id="54aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们称这本字典为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="bea5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nf ng nh ni b">loses_to</code>提供了一个简单的API来确定哪个项目输给了另一个项目:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="165a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">字典有几个好处。您可以使用它来:</p><ol class=""><li id="fb11" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated">通过检查成员资格或发起<code class="fe nf ng nh ni b">KeyError</code>来验证所选项目</li><li id="6689" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">通过检查值是否输给相应的键来确定获胜者</li></ol><p id="835f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑到这一点，<code class="fe nf ng nh ni b">play()</code>函数可以写成如下形式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e29e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个版本中，<code class="fe nf ng nh ni b">play()</code>在试图访问一个无效键时利用了由<code class="fe nf ng nh ni b">loses_to</code>字典引发的内置<code class="fe nf ng nh ni b">KeyError</code>。这有效地验证了玩家的选择。因此，如果任何一个玩家选择了一个无效的物品——类似于<code class="fe nf ng nh ni b">"lizard"</code>或<code class="fe nf ng nh ni b">1234</code>——<code class="fe nf ng nh ni b">play()</code>会引发一个<code class="fe nf ng nh ni b">KeyError</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="497e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管<code class="fe nf ng nh ni b">KeyError</code>不像<code class="fe nf ng nh ni b">ValueError</code>那样有描述性消息，但它仍然完成了工作。</p><p id="6ab1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新的<code class="fe nf ng nh ni b">play()</code>功能比原来的简单多了。不需要处理一堆显式案例，只需要检查三个案例:</p><ol class=""><li id="37bc" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated"><code class="fe nf ng nh ni b">player2_choice</code>输给<code class="fe nf ng nh ni b">player1_choice</code></li><li id="bcce" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated"><code class="fe nf ng nh ni b">player1_choice</code>输给<code class="fe nf ng nh ni b">player2_choice</code></li><li id="03b1" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated"><code class="fe nf ng nh ni b">player1_choice</code>和<code class="fe nf ng nh ni b">player2_choice</code>相同</li></ol><p id="1e89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，还有第四种隐藏的情况，你几乎要眯着眼睛才能看到。这种情况发生在其他三种情况都不为真时，在这种情况下<code class="fe nf ng nh ni b">play()</code>返回一个<code class="fe nf ng nh ni b">None</code>值。</p><p id="b201" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是……这种情况真的会发生吗？实际上，不。它不能。根据游戏规则，如果玩家1不输给玩家2 <em class="nl">玩家2不输给玩家1</em>，那么两个玩家一定选择了相同的物品。</p><p id="0065" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换句话说，如果另外两个<code class="fe nf ng nh ni b">if</code>块都没有执行，我们可以从<code class="fe nf ng nh ni b">play()</code>中删除最后一个<code class="fe nf ng nh ni b">if</code>块，只删除<code class="fe nf ng nh ni b">return "tie"</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="cadc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经做了妥协。我们牺牲了清晰性——我认为与“初学者”版本相比，理解上述<code class="fe nf ng nh ni b">play()</code>功能如何工作需要更大的认知负荷——以便缩短功能并避免不可及的状态。结果，我们将30行初学者解决方案减少到只有11行代码。</p><h1 id="813d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">高级解决方案#2</h1><p id="8d06" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">前面的解决方案效果很好。它的可读性<em class="nl">和</em>比“初学者”的解决方案要短得多。但是不太灵活。也就是说，如果不重写一些逻辑，它就不能处理“石头剪刀布”的变体。</p><p id="e77c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，有一个叫做“石头剪刀布蜥蜴史波克”的变种，有一套更复杂的规则:</p><ol class=""><li id="a0f4" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated">石头打败剪刀和蜥蜴</li><li id="ffe7" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">纸打败了石头和斯波克</li><li id="909b" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">剪刀打败了纸和蜥蜴</li><li id="c9b5" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">蜥蜴打败了斯波克和纸</li><li id="5e49" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated">斯波克打败剪刀和石头</li></ol><p id="eb44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如何修改代码来处理这种变化？</p><p id="65b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，用Python集合替换<code class="fe nf ng nh ni b">loses_to</code>字典中的字符串值。每个集合包含输给相应键的所有项目。下面是这个版本的<code class="fe nf ng nh ni b">loses_to</code>使用原来的“石头剪刀布”规则的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="42f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么设置？因为我们只关心<em class="nl">什么</em>项输给了一个给定的键。我们不关心那些项目的<em class="nl">顺序</em>。</p><p id="542c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了让<code class="fe nf ng nh ni b">play()</code>处理新的<code class="fe nf ng nh ni b">loses_to</code>字典，您所要做的就是用<code class="fe nf ng nh ni b">in</code>替换<code class="fe nf ng nh ni b">==</code>,以使用成员检查来代替相等检查:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="65e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">花点时间运行这段代码，验证一切仍然正常。</p><p id="e253" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在用一个实现“石头剪刀布蜥蜴史波克”规则的字典替换<code class="fe nf ng nh ni b">loses_to</code>看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d231" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新的<code class="fe nf ng nh ni b">play()</code>函数完美地与这些新规则一起工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f3c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我看来，这是选择正确的数据结构的力量的一个很好的例子。通过使用集合来表示在<code class="fe nf ng nh ni b">loses_to</code>字典中输给一个键的所有条目，并用<code class="fe nf ng nh ni b">in</code>替换<code class="fe nf ng nh ni b">==</code>，您不必添加一行代码就可以得到一个更通用的解决方案。</p><h1 id="e7f9" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">高级解决方案#3</h1><p id="b07f" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">让我们后退一步，采取一种稍微不同的方法。我们将构建一个包含所有可能输入及其结果的表格，而不是在字典中查找条目来确定获胜者。</p><p id="5502" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您仍然需要一些东西来表示游戏规则，所以让我们从上一个解决方案的<code class="fe nf ng nh ni b">loses_to</code>格言开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7a56" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，编写一个函数<code class="fe nf ng nh ni b">build_results_table()</code>，它接受一个规则字典，比如<code class="fe nf ng nh ni b">loses_to</code>，并返回一个新的字典，将状态映射到结果。例如，下面是用<code class="fe nf ng nh ni b">loses_to</code>作为参数调用时<code class="fe nf ng nh ni b">build_results_table()</code>应该返回的内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2166" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得那里有什么不对劲，那你就对了。这本字典有两个错误:</p><ol class=""><li id="3f01" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated"><strong class="la iu">集像</strong> <code class="fe nf ng nh ni b"><strong class="la iu">{"rock", "rock"}</strong></code> <strong class="la iu">一样不能存在。</strong>集合不能有重复的元素。在真实场景中，这个场景看起来像<code class="fe nf ng nh ni b">{"rock"}</code>。你实际上不需要太担心这个。我用两个元素写了这些集合，以明确这些状态代表什么。</li><li id="142d" class="mr ms it la b lb na le nb lh nc ll nd lp ne lt mw mx my mz bi translated"><strong class="la iu">不能使用集合作为字典键</strong>。但是我们<em class="nl">希望</em>使用集合，因为它们自动为我们处理交换性。也就是说，<code class="fe nf ng nh ni b">{"rock", "paper"}</code>和<code class="fe nf ng nh ni b">{"paper", "rock"}</code>的值相等，因此在查找时应该返回相同的结果。</li></ol><p id="6b23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解决这个问题的方法是使用Python内置的<code class="fe nf ng nh ni b"><a class="ae nm" href="https://docs.python.org/3/library/stdtypes.html?highlight=frozenset#frozenset" rel="noopener ugc nofollow" target="_blank">frozenset</a></code> <a class="ae nm" href="https://docs.python.org/3/library/stdtypes.html?highlight=frozenset#frozenset" rel="noopener ugc nofollow" target="_blank">类型</a>。像集合一样，<code class="fe nf ng nh ni b">frozensets</code>支持成员检查，当且仅当两个集合有相同的成员时，它们与另一个<code class="fe nf ng nh ni b">set</code>或<code class="fe nf ng nh ni b">frozenset</code>比较相等。然而，与标准集不同的是，<code class="fe nf ng nh ni b">frozenset</code>实例是不可变的。因此，它们可以用作字典键。</p><p id="bf30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要实现<code class="fe nf ng nh ni b">build_results_table()</code>,您可以循环遍历<code class="fe nf ng nh ni b">loses_to</code>字典中的每个键，并为对应于该键的集合中的每个字符串值构建一个<code class="fe nf ng nh ni b">frozenset</code>实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d884" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这让你走了一半的路:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="bfa1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不过，导致平局的州没有包括在内。要添加这些，您需要为映射到字符串<code class="fe nf ng nh ni b">"tie"</code>的<code class="fe nf ng nh ni b">rules</code>字典中的每个键创建<code class="fe nf ng nh ni b">frozenset</code>实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="38bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在由<code class="fe nf ng nh ni b">build_results_table()</code>返回的值看起来是正确的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="39d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么要经历这么多麻烦？毕竟，<code class="fe nf ng nh ni b">build_results_table()</code>看起来比前一个解决方案中的<code class="fe nf ng nh ni b">play()</code>函数更复杂。</p><p id="4a53" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你没有错，但是我想指出这种模式可能非常有用。如果一个程序中可以存在有限数量的状态，通过预先计算所有这些状态的结果，有时可以看到速度的显著提高。对于像“石头剪子布”这样简单的事情来说，这可能有些矫枉过正，但是在有几十万甚至几百万个州的情况下，这可能会产生巨大的影响。</p><p id="382d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法有意义的一个真实场景是在强化学习应用中使用的<a class="ae nm" href="https://en.m.wikipedia.org/wiki/Q-learning" rel="noopener ugc nofollow" target="_blank"> Q-learning算法</a>。在该算法中，维护一个状态表(Q表),该表将每个状态映射到一些预定动作的一组概率。一旦一个代理被训练，它就可以根据观察到的状态的概率选择一个动作，然后相应地采取行动。</p><p id="b983" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，一个类似于由<code class="fe nf ng nh ni b">build_results_table()</code>生成的表被计算出来，然后存储在一个文件中。当程序运行时，预先计算的表被加载到内存中，然后由应用程序使用。</p><p id="cfbe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，现在您有了一个可以构建结果表的函数，将<code class="fe nf ng nh ni b">loses_to</code>的表分配给一个<code class="fe nf ng nh ni b">outcomes</code>变量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9ae7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在您可以编写一个<code class="fe nf ng nh ni b">play()</code>函数，根据传递给play的参数在<code class="fe nf ng nh ni b">outcomes</code>表中查找状态，然后返回结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="db68" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个版本的<code class="fe nf ng nh ni b">play()</code>简单得令人难以置信。就两行代码！如果你愿意，你甚至可以把它写成一行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2144" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我个人更喜欢双线版，而不是单线版。</p><p id="d8bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您的新<code class="fe nf ng nh ni b">play()</code>函数遵循游戏规则，并且是可交换的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9162" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nf ng nh ni b">play()</code>甚至在被无效选择调用时引发一个<code class="fe nf ng nh ni b">KeyError</code>,但是这个错误已经没有那么多帮助了，因为<code class="fe nf ng nh ni b">outcomes</code>字典的键已经设置好了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="eedf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，这个模糊的错误可能不是问题。在本文中，您只实现了<code class="fe nf ng nh ni b">play()</code>函数。在“石头剪子布”的真实实现中，您最有可能在将用户的选择传递给<code class="fe nf ng nh ni b">play()</code>之前捕获用户输入并验证它。</p><p id="2779" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，与以前的实现相比，这个实现快了多少呢？下面是一些计时结果，用来比较使用IPython的<code class="fe nf ng nh ni b">%timeit</code>神奇函数的各种实现的性能。<code class="fe nf ng nh ni b">play1()</code>是<a class="ae nm" href="#advanced-solution-2" rel="noopener ugc nofollow">高级解决方案#2 </a>部分的<code class="fe nf ng nh ni b">play()</code>版本，<code class="fe nf ng nh ni b">play2()</code>是当前版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2477" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，使用结果表的解决方案实际上比之前的实现慢<em class="nl"/>。这里的罪魁祸首是将函数参数转换成一个<code class="fe nf ng nh ni b">frozenset</code>的那一行。因此，尽管字典查找速度很快，并且构建一个将状态映射到结果的表可以潜在地提高性能，但是您需要小心避免昂贵的操作，这些操作可能最终会抵消您期望获得的任何收益。</p><h1 id="8c77" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="05df" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我写这篇文章是作为练习。我很好奇，既然我已经有了很多经验，我该如何对待一个像Python中的“石头剪刀布”这样的初学者项目。我希望你觉得有趣。如果你现在有任何灵感的暗示来重温你自己的一些初学者项目，那么我想我已经完成了我的工作！</p><p id="5c44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你确实重温了一些你自己的初学者项目，或者如果你过去曾经这样做过，请在评论中告诉我进展如何。你学到新东西了吗？你的新解决方案和你作为初学者写的有多大不同？</p><h1 id="2ccc" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">是什么激发了这篇文章？</h1><p id="23e0" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">朱莉娅圈子里的一个熟人<a class="ae nm" href="https://github.com/miguelraz" rel="noopener ugc nofollow" target="_blank">米格尔·拉兹·古斯曼·马塞多</a>向我推荐了由<a class="ae nm" href="https://giordano.github.io/aboutme/" rel="noopener ugc nofollow" target="_blank">摩西·佐丹奴</a>撰写的<a class="ae nm" href="https://giordano.github.io/blog/2017-11-03-rock-paper-scissors/" rel="noopener ugc nofollow" target="_blank">博客文章。Mosè利用Julia的</a><a class="ae nm" href="https://en.m.wikipedia.org/wiki/Multiple_dispatch" rel="noopener ugc nofollow" target="_blank">多重分派</a>范例，用不到十行代码编写了“石头剪刀布”:</p><div class="nn no gp gr np nq"><a href="https://giordano.github.io/blog/2017-11-03-rock-paper-scissors/" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">不到10行代码的石头剪刀布游戏</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">石头剪子布是一种流行的手游。然而，一些书呆子可能更喜欢在他们的电脑上玩这个游戏，而不是…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">giordano.github.io</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ks nq"/></div></div></a></div><p id="cdb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不会深入讨论Mosè代码如何工作的细节。Python甚至不支持开箱即用的多分派。(虽然你可以在<code class="fe nf ng nh ni b"><a class="ae nm" href="https://github.com/wesselb/plum" rel="noopener ugc nofollow" target="_blank">plum</a></code> <a class="ae nm" href="https://github.com/wesselb/plum" rel="noopener ugc nofollow" target="_blank">包</a>的帮助下使用它。)</p><p id="fa38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Mosè的文章让我的大脑运转起来，并鼓励我重温Python中的“石头剪刀布”,思考如何以不同的方式处理这个项目。</p><p id="cfc4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，当我研究这个解决方案时，我想起了很久以前我为Real Python写的一篇评论文章:</p><div class="nn no gp gr np nq"><a href="https://realpython.com/python-rock-paper-scissors/" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">制作你的第一个Python游戏:石头、剪子、布！-真正的蟒蛇</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">免费奖励:关于Python精通的5个想法，这是一个面向Python开发者的免费课程，向你展示了路线图和…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">realpython.com</p></div></div><div class="nz l"><div class="of l ob oc od nz oe ks nq"/></div></div></a></div><p id="a2de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实证明，我在这里“发明”的前两个解决方案与Real Python文章的作者Chris Wilkerson提出的解决方案相似。</p><p id="c8ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Chris的解决方案功能更全。它包括一个交互式游戏机制，甚至使用Python的<code class="fe nf ng nh ni b">Enum</code>类型来表示游戏物品。那一定也是我第一次听说“石头剪刀布蜥蜴史波克”的地方</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt on ni oo op aw oq bi"><span id="2e52" class="or lv it ni b gy os ot l ou ov">Stay up-to-date with all of my content, get early access to my courses, and get hand-picked content from around the Python and Julia communities straight to your inbox every Friday by signing up for my weekly <a class="ae nm" href="https://davidamos.dev/curious-about-code-newsletter/" rel="noopener ugc nofollow" target="_blank">Curious About Code newsletter</a>.</span></pre></div></div>    
</body>
</html>