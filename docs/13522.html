<html>
<head>
<title>Python List Comprehensions Are More Powerful Than You Might Think</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python列表理解比你想象的更强大</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/python-list-comprehensions-are-more-powerful-than-you-might-think-3363a90e5bb0?source=collection_archive---------0-----------------------#2022-09-05">https://betterprogramming.pub/python-list-comprehensions-are-more-powerful-than-you-might-think-3363a90e5bb0?source=collection_archive---------0-----------------------#2022-09-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6b60" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">借助这些未知的功能和技巧，写出更好的列表理解</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b25f44badc710af4aac92369c222c17c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TMuu8N0C9HMpQ0AC2N6QbQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@aedrian?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Aedrian </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a193" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python的列表理解(和生成器)是一个非常棒的特性，可以极大地简化您的代码。然而，大多数情况下，我们只使用它们来编写一个单独的<code class="fe lv lw lx ly b">for</code>循环，也许再加上一个<code class="fe lv lw lx ly b">if</code>条件，仅此而已。如果你开始研究一下，你会发现Python comprehensions还有很多你不知道的特性，但是你可以从它身上学到很多…</p><h1 id="157c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">多重条件句</h1><p id="47db" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们知道我们可以使用<code class="fe lv lw lx ly b">if</code>条件来过滤列表理解的结果，对于简单的理解，单个<code class="fe lv lw lx ly b">if</code>通常就足够了。但是，如果您想要一个嵌套的条件呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1c2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以使用“条件表达式”或通常所说的三元运算符来构建嵌套条件。这并不是一个很好的解决方案，所以你必须决定这几行节省下来的代码是否值得这个讨厌的一行程序。</p><p id="4790" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了使用复杂的条件句，也可以在一篇理解文章中叠加多个<code class="fe lv lw lx ly b">if</code>。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6ead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看上面展开的代码，这样写其实没多大意义，但是语法允许。</p><p id="e411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能希望使用它的一个原因是为了可读性，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="6b26" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">避免重复评估</h1><p id="0a0b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">假设你理解在条件函数和循环体中都调用了一个昂贵的函数。它可能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6feb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是低效的，因为它加倍了计算时间，但是我们能做什么呢？拯救的嵌套理解！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1ddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想强调的是，以上并不是双循环。在这个例子中，我们在list comprehension内部构建了一个生成器，由外部循环使用。如果您觉得这很难理解，那么另一种方法是使用walrus操作符。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c05a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里<code class="fe lv lw lx ly b">func</code>只被调用一次，创建一个局部变量<code class="fe lv lw lx ly b">y</code>，它可以在表达式的其他部分使用。</p><h1 id="b849" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">处理异常</h1><p id="0aed" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">尽管列表理解通常用于简单的任务——比如对列表中的每个元素调用一个函数——但是也有可能在理解中抛出异常的情况。然而，在列表理解中没有处理异常的本地方法，所以我们能做些什么呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="aad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一个处理函数来捕捉理解中的异常。这里我们创建一个函数<code class="fe lv lw lx ly b">catch</code>，它接受一个函数及其参数。如果在<code class="fe lv lw lx ly b">catch</code>中抛出异常，那么返回异常。</p><p id="9b84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到我们需要一个助手函数，这不是一个理想的解决方案，但这是我们能做的最好的了，因为试图为此引入语法的提案(<a class="ae ky" href="https://peps.python.org/pep-0463/" rel="noopener ugc nofollow" target="_blank"> PEP 463 </a>)被拒绝了。</p><h1 id="6e6e" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">打破循环</h1><p id="f112" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">列表理解的另一个限制是不能<code class="fe lv lw lx ly b">break</code>循环。虽然在本机上不可能，但我们可以实现一个小技巧来解决这个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5cfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的第一个例子使用了一个鲜为人知的<code class="fe lv lw lx ly b">iter</code>函数的特性/行为。一旦<code class="fe lv lw lx ly b">callable</code>函数值等于<code class="fe lv lw lx ly b">sentinel</code>值，<code class="fe lv lw lx ly b">iter(callable, sentinel)</code>返回一个“中断”迭代的迭代器。当内部<code class="fe lv lw lx ly b">iter</code>返回sentinel(示例中的<code class="fe lv lw lx ly b">4</code>)时，循环自动停止。</p><p id="96af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是很可读，所以你可以利用伟大的<code class="fe lv lw lx ly b">itertools</code>模块和<code class="fe lv lw lx ly b">takewhile</code>函数，如第二个例子所示。</p><p id="7e06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便提一下——如果你认为打破列表理解中的循环是可能的，那么你是正确的。在Python 3.5之前，你可以使用一个helper函数来提升列表理解中的<code class="fe lv lw lx ly b">StopIteration</code>，然而，这在<a class="ae ky" href="https://peps.python.org/pep-0479/#explanation-of-generators-iterators-and-stopiteration" rel="noopener ugc nofollow" target="_blank"> PEP 479 </a>中有所改变。</p><h1 id="4084" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">技巧(和黑客)</h1><p id="4da7" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在前面的章节中，我们已经看到了列表理解的一些晦涩的特性，这些特性在日常编码中可能非常有用，也可能不太有用。所以，现在让我们看看一些你可以马上使用的技巧(和小窍门)。</p><p id="9eb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然简单、普通的列表理解非常强大，但是当与库如<code class="fe lv lw lx ly b">itertools</code>(见上一节)或其扩展<code class="fe lv lw lx ly b">more-itertools</code>一起使用时，它们会变得更好。</p><p id="6526" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您需要查找连续的数字、日期、字母、布尔值或任何其他可排序的对象。你可以通过将<code class="fe lv lw lx ly b">more-itertools</code>中的<code class="fe lv lw lx ly b">consecutive_groups</code>与列表理解结合起来，很好地解决这个问题。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="81c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有一个日期列表，其中一些是连续的。我们使用日期的顺序值将日期传递给<code class="fe lv lw lx ly b">consecutive_groups</code>函数进行排序。然后，我们使用理解力将返回的组收集到一个列表中。</p><p id="3cec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中计算数字的累加和非常容易——你只需将一个列表传递给<code class="fe lv lw lx ly b">itertools.accumulate</code>,就可以得到累加和。但是，如果我们想消除这种积累呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4fc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">more_itertools.pairwise</code>的帮助下，这很简单！</p><p id="dc9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，new-ish walrus操作符可以与list comprehensions一起使用来创建一个局部变量。这在很多情况下都很有用。一种这样的情况是使用<code class="fe lv lw lx ly b">any()</code>和<code class="fe lv lw lx ly b">all()</code>功能:</p><p id="f50e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python的<code class="fe lv lw lx ly b">any()</code>和<code class="fe lv lw lx ly b">all()</code>函数可以验证某个iterable中的任意或全部值是否满足一定的条件。但是，如果您还想捕获导致<code class="fe lv lw lx ly b">any()</code>返回<code class="fe lv lw lx ly b">True</code>的值(所谓的“见证”)或导致<code class="fe lv lw lx ly b">all()</code>失败的值(所谓的“反例”)，该怎么办呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b0eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">any()</code>和<code class="fe lv lw lx ly b">all()</code>都使用短路来计算给定的表达式。这意味着他们一找到第一个“见证”或“反例”就停止评估。所以，用这一招，walrus操作符创建的变量总会给我们第一个“见证”/“反例”。</p><h1 id="9055" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结束语</h1><p id="9ce9" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">许多特性和技巧展示了列表理解的可能性和局限性。在我看来，学习这些复杂性是更好地理解特定语言特性的好方法，即使它在日常编码中并不真正有用。最重要的是，这很有趣。</p><p id="8864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，我希望你在这里学到一些东西，并意识到如果你决定在你的列表理解中使用复杂的条件句或循环中断，你的同事可能会讨厌你。</p><div class="my mz gp gr na nb"><a rel="noopener  ugc nofollow" target="_blank" href="/should-you-be-using-pythons-walrus-operator-yes-and-here-s-why-36297be16907"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd iu gy z fp ng fr fs nh fu fw is bi translated">你应该使用Python的Walrus操作符吗？(是的。原因如下)</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">Python有争议的赋值表达式——也称为walrus运算符——可以改进您的代码，现在是您…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">better编程. pub</p></div></div><div class="nk l"><div class="nl l nm nn no nk np ks nb"/></div></div></a></div><div class="my mz gp gr na nb"><a href="https://python.plainenglish.io/its-time-to-say-goodbye-to-these-obsolete-python-libraries-7c02aa77d84a" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd iu gy z fp ng fr fs nh fu fw is bi translated">是时候向这些过时的Python库说再见了</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">忘掉os.path、random、pytz、namedtuple等等，开始使用最新最棒的Python库吧。</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">python .平原英语. io</p></div></div><div class="nk l"><div class="nq l nm nn no nk np ks nb"/></div></div></a></div><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="4a78" class="nv ma it ly b gy nw nx l ny nz"><strong class="ly iu">Want to Connect?</strong></span><span id="b0c6" class="nv ma it ly b gy oa nx l ny nz">This article was originally posted at <a class="ae ky" href="https://martinheinz.dev/blog/80" rel="noopener ugc nofollow" target="_blank">martinheinz.dev</a>.</span></pre></div></div>    
</body>
</html>