<html>
<head>
<title>Simplifying the Binary Trees Data Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化二叉树数据结构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/simplifying-the-binary-trees-data-structure-8a08e640cc48?source=collection_archive---------10-----------------------#2021-03-17">https://betterprogramming.pub/simplifying-the-binary-trees-data-structure-8a08e640cc48?source=collection_archive---------10-----------------------#2021-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8100" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">成为编码二叉树的忍者</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/03ba51ae07a4b258ce96f0781267ca3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DKP-drt3_pPsaPaD"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@mayofi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马约菲</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="2aea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">树是一种重要的数据结构，因为它们提供了优于其他传统数据结构的主要优势。树结合了有序数组和链表的优点:</p><ul class=""><li id="429e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">有序数组的搜索速度很快，而链表的插入和删除速度很快。</li><li id="85c8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">但是在链表中搜索很慢，对于有序数组插入和删除也很慢。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/94f828edba8c2974c735d25d46f5932c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lixeVW2HAatXOua6wFa6AA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比较搜索和插入/删除操作-时间复杂度</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/4beeac9936f2295c9213887880b3d5b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kDVHaWxVz5VwFVfPdbyneg.png"/></div></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="5fef" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">二叉树</h1><p id="dc3f" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">如果一棵树的每个节点最多可以有<em class="np">个</em>个子节点，那么该树称为<em class="np">二叉树。</em></p><ul class=""><li id="7fd0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">二叉树在表示代数表达式和编译器解析语法方面非常有用。</li><li id="ed53" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它们也用于压缩算法，如霍夫曼编码树。</li></ul><h2 id="7a39" class="nq mt it bd mu nr ns dn my nt nu dp nc li nv nw ne lm nx ny ng lq nz oa ni ob bi translated">代码入门</h2><p id="722b" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">让我们从最简单的树节点开始。每个树节点都有自己的ID和一些数据。</p><p id="5340" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为它是一个二叉树，我们的节点可以保存对另外两个节点的引用，即<code class="fe oc od oe of b">left</code>和<code class="fe oc od oe of b">right</code>节点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">二叉树的节点类</p></figure><p id="b9e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看<code class="fe oc od oe of b">BinaryTree</code> <strong class="lb iu"> </strong>类。我们的二叉树只需要包含<code class="fe oc od oe of b">Root</code>节点，它的类型是<code class="fe oc od oe of b">Node</code>。</p><p id="ad05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以对您的树执行各种操作——我们一会儿将逐一查看它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">二叉树类—包含根节点和其他与树相关的方法</p></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="ece9" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">二叉树操作</h1><h2 id="c079" class="nq mt it bd mu nr ns dn my nt nu dp nc li nv nw ne lm nx ny ng lq nz oa ni ob bi translated">1.寻找节点</h2><p id="168b" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在一棵树中，我们只能直接访问根节点，所以我们的搜索算法将从那里开始。</p><p id="c543" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们检查我们想要查找的项目是在左子树中还是在右子树中。我们来看看简单的<a class="ae ky" href="https://gist.github.com/devDeejay/fd1e869e6e856257703fc26ec961c4fc" rel="noopener ugc nofollow" target="_blank">代码</a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/a5c0df6d3b5236ce0257077c78f10249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OnTpTbbyzfyoSEol978zTw.png"/></div></div></figure><p id="ce62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该搜索算法的时间复杂度为O(logN)。</p><h2 id="0b11" class="nq mt it bd mu nr ns dn my nt nu dp nc li nv nw ne lm nx ny ng lq nz oa ni ob bi translated">2.插入节点</h2><p id="4e35" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">要插入一个节点，我们首先要确定它应该被插入的位置，除非内存不足，否则这个位置总是可以找到的。</p><p id="7bd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从根节点开始，检查它是否存在。如果没有，我们的新节点将成为根节点——这是最简单的情况。</p><p id="aa53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的根节点存在，那么我们将检查我们的新节点数据应该放在根节点的左边还是右边。如果新数据少于根节点的数据，它将向左移动。否则，一切都会好的。我们重复这个过程，直到我们找到一个地方。</p><p id="17ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要在代码中保留对父节点的引用，这样我们就可以在正确的父节点插入子节点。</p><p id="6269" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们<a class="ae ky" href="https://gist.github.com/devDeejay/79db24202de25e30a683bcba3775d3ce" rel="noopener ugc nofollow" target="_blank">编码</a>它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/50f625a9bd6ba91cae8e984bf3d04ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSGvaQdITNhHW4bPjjzGBg.png"/></div></div></figure><p id="3452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要理解<em class="np">删除</em>，我们必须理解<em class="np">树的遍历。</em></p><h2 id="f9fb" class="nq mt it bd mu nr ns dn my nt nu dp nc li nv nw ne lm nx ny ng lq nz oa ni ob bi translated">3.遍历树</h2><p id="3f7e" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">遍历树意味着以指定的顺序访问节点。</p><p id="f399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">树的遍历并不是一个快速的过程，在很多算法中非常有用，我们稍后会了解到。</p><p id="cadc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有三种类型的树遍历:</p><p id="7ddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">顺序遍历/中缀符号</strong></p><p id="c42a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="np"> Inorder traversal </em>允许我们以升序访问我们的树，这意味着将从低到高访问节点。这显然意味着我们按以下顺序访问树:</p><ul class=""><li id="1577" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">处理左侧节点/子树</li><li id="fadb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">处理当前节点</li><li id="4998" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">处理右边的节点/子树</li></ul><p id="7376" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="np"> Process </em>可以表示任何东西，但是对于我们的目的，我们只是打印节点的数据。</p><p id="7648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码可以表示为一个简单的递归函数:</p><pre class="kj kk kl km gt ok of ol om aw on bi"><span id="6c63" class="nq mt it of b gy oo op l oq or">void <strong class="of iu">inorderTraversal</strong>(Node node) {<br/>    if(node != null) {<br/>        <strong class="of iu">inorderTraversal</strong>(node.leftNode);<br/>        System.<em class="np">out</em>.println(node.data);<br/>        <strong class="of iu">inorderTraversal</strong>(node.rightNode);<br/>    }<br/>}</span></pre><p id="711e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">前序遍历/前缀符号</strong></p><p id="32f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<em class="np">前序遍历中，</em>我们遵循这个顺序:</p><ul class=""><li id="18c5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">处理当前节点</li><li id="3372" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">处理左侧节点/子树</li><li id="1053" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">处理右边的节点/子树</li></ul><p id="9e35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码可以表示为一个简单的递归函数:</p><pre class="kj kk kl km gt ok of ol om aw on bi"><span id="5150" class="nq mt it of b gy oo op l oq or">void <strong class="of iu">preOrderTraversal</strong>(Node node) {<br/>    if(node != null) {<br/>        System.<em class="np">out</em>.println(node.data);<br/>        <strong class="of iu">preOrderTraversal</strong>(node.leftNode);<br/>        <strong class="of iu">preOrderTraversal</strong>(node.rightNode);<br/>    }<br/>}</span></pre><p id="589f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">后序遍历/后缀符号</strong></p><p id="cd7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<em class="np">后序遍历中，</em>我们遵循这个顺序:</p><ul class=""><li id="3e2c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">处理左侧节点/子树</li><li id="94b1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">处理右边的节点/子树</li><li id="ab43" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">处理当前节点</li></ul><p id="186a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码可以表示为一个简单的递归函数:</p><pre class="kj kk kl km gt ok of ol om aw on bi"><span id="f4af" class="nq mt it of b gy oo op l oq or">void postOrderTraversal(Node node) {<br/>    if(node != null) {<br/>        postOrderTraversal(node.leftNode);<br/>        postOrderTraversal(node.rightNode);<br/>        System.<em class="np">out</em>.println(node.data);<br/>    }<br/>}</span></pre><h2 id="c612" class="nq mt it bd mu nr ns dn my nt nu dp nc li nv nw ne lm nx ny ng lq nz oa ni ob bi translated">4.寻找最小和最大元素</h2><p id="2a85" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我相信您现在已经猜到了:在二叉查找树中，最左边的节点是最小值，最右边的节点是最大值。</p><pre class="kj kk kl km gt ok of ol om aw on bi"><span id="2a98" class="nq mt it of b gy oo op l oq or">Node <strong class="of iu">minimumElement</strong>() {<br/>    Node currentNode = rootNode;<br/>    Node lastNode = null;<br/><br/>    <strong class="of iu">// We traverse the left subtree<br/>    // Until we find a null at the left place<br/>    // Then we just return the last not-null node</strong><br/>    while(currentNode!=null) {<br/>        lastNode = currentNode;<br/>        currentNode = currentNode.leftNode;<br/>    }<br/>    return lastNode;<br/>}</span></pre><p id="b8ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，对于最大元素:</p><pre class="kj kk kl km gt ok of ol om aw on bi"><span id="c992" class="nq mt it of b gy oo op l oq or">Node <strong class="of iu">maxElement</strong>() {<br/>    Node currentNode = rootNode;<br/>    Node lastNode = null;<br/><br/>   <strong class="of iu"> // We traverse the right subtree<br/>    // Until we find a null at the right place<br/>    // Then we just return the last not-null node</strong><br/>    while(currentNode!=null) {<br/>        lastNode = currentNode;<br/>        currentNode = currentNode.rightNode;<br/>    }<br/>    return lastNode;<br/>}</span></pre><h2 id="d9d0" class="nq mt it bd mu nr ns dn my nt nu dp nc li nv nw ne lm nx ny ng lq nz oa ni ob bi translated">5.删除节点</h2><p id="c1ca" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">删除树节点是最复杂的操作。但我们会一起掌握它。</p><p id="d1cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们必须找到要删除的节点，然后我们有三种可能的情况:</p><ol class=""><li id="1d76" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu os mb mc md bi translated"><strong class="lb iu">要删除的节点没有子节点</strong></li></ol><p id="5014" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个简单的例子——我们可以简单地从它的父节点中删除它的引用，然后这个节点就会从树中被删除。</p><p id="2097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不担心删除节点，我们只是从树中删除它的引用。Java垃圾收集会处理未被引用的变量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/ec04b00afb0942fd327cdad967706fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V7ogPmx89gRaMovN9XHgfg.png"/></div></div></figure><p id="f903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<strong class="lb iu">要删除的节点有一个子节点</strong></p><p id="6e5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果要删除的节点只有一个子节点，该子节点将成为它的后继节点。我们只需要检查是左孩子还是右孩子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/06f0003c0de135d6408b3978ceb6623e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3gA4TSSl_x9VV8RpzTE89Q.png"/></div></div></figure><p id="88af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.<strong class="lb iu">要删除的节点有两个子节点</strong></p><p id="5eec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">真正的乐趣从这里开始。真的没那么复杂。</p><p id="e7ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要记住的简单规则是，要删除的节点应该由它的有序后继节点(下一个最大的节点)替换，因为它是一个二叉查找树。</p><p id="7b3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先转到要删除的节点的右边的子节点，然后我们向最左边的子节点移动，这将是我们的后继节点。简而言之，我们必须找到要删除的节点的右子树中的最小元素。</p><p id="4cd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们编写<code class="fe oc od oe of b">findSuccessor</code>方法的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/0201573aa5cf80aa6c2409cd34e76a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*38jN8-3qRaTVEGpFURPDog.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用笔和纸，用一棵假想的二叉树来做这个练习</p></figure><p id="a162" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们找到了后继者，我们就用它的后继者替换将要删除的节点，这取决于左右方向。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/d90515f87beb3bf3c6858b3c78968ccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*95uBsMMWEPkjIc3AIP5Pvw.png"/></div></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="a4a1" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">结论</h1><p id="f0d4" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">下面是删除方法的<a class="ae ky" href="https://gist.github.com/devDeejay/cfbb2ee5db7ed5d3f7cfb29d05122bce" rel="noopener ugc nofollow" target="_blank">完整代码。</a></p><p id="96e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个包含所有方法的<a class="ae ky" href="https://gist.github.com/devDeejay/8322a3ad7f938aeb986c4e255436ab9f" rel="noopener ugc nofollow" target="_blank">代码片段。</a></p><pre class="kj kk kl km gt ok of ol om aw on bi"><span id="ba7b" class="nq mt it of b gy oo op l oq or">Time Complexity:</span><span id="43e9" class="nq mt it of b gy ou op l oq or">Look Up - O(Log N)<br/>Insertion - O(Log N)<br/>Deletion - O(Log N)</span></pre><p id="715f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，你已经完成了所有重要的二叉树操作。一定要为自己走到这一步而感到自豪。我真的为你感到骄傲！</p><p id="3843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p><h1 id="67d1" class="ms mt it bd mu mv ov mx my mz ow nb nc jz ox ka ne kc oy kd ng kf oz kg ni nj bi translated">#奖励积分</h1><h2 id="2405" class="nq mt it bd mu nr ns dn my nt nu dp nc li nv nw ne lm nx ny ng lq nz oa ni ob bi translated">完美二叉树</h2><ul class=""><li id="de71" class="lv lw it lb b lc nk lf nl li pa lm pb lq pc lu ma mb mc md bi translated">每个节点恰好包含两个子节点，树是好的，直到所有节点都有子节点，我们才移动到下一级。</li><li id="7c71" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当我们移动到每一层时，节点的数量就会翻倍。</li><li id="387a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第n层的节点数=前几层的节点总数+ 1。</li></ul><pre class="kj kk kl km gt ok of ol om aw on bi"><span id="d50d" class="nq mt it of b gy oo op l oq or">The number of nodes at nth level will be = (2^n)</span><span id="e7c9" class="nq mt it of b gy ou op l oq or">The number of nodes in total when the height is ‘h’ = (2^h) - 1</span></pre><p id="daf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们一半的数据位于最后一个节点，因此在访问它们时，我们往往会跳过许多其他元素，这将我们的时间复杂度降低到O(log n)。</p><p id="f739" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果树是不平衡的，那么它将表现得像一个长链表，因此我们的树应该尽可能接近完美的二叉树，这样你就可以真正地拿走树的最佳性能。</p></div></div>    
</body>
</html>