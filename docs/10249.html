<html>
<head>
<title>Solidity for Swift Developers: File Structure and Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift开发人员的可靠性:文件结构和功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solidity-for-swift-developers-file-structure-and-functions-997fd6f8f8e7?source=collection_archive---------9-----------------------#2021-12-16">https://betterprogramming.pub/solidity-for-swift-developers-file-structure-and-functions-997fd6f8f8e7?source=collection_archive---------9-----------------------#2021-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5ce3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">开始使用Swift的可靠性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cf88bd0b4229620c54bd0a496bae022a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DatkvU4rgxQtRm5MgofeqA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@executium" rel="noopener ugc nofollow" target="_blank">行政</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="3883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Solidity是一种面向对象的语言，用于编写可以部署在区块链上的智能合约，例如以太坊。语法类似于Javascript，但另一方面，语义更接近C++。我们将从Swift开发人员的角度深入探讨Solidity语言结构和功能。</p><h1 id="1116" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">杂注和sfile扩展</h1><p id="5958" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我们进入Solidity语言结构之前，我们需要知道一个<code class="fe ms mt mu mv b">pragma</code>关键字是什么，它的意思是什么。</p><p id="be99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与Objective-C <code class="fe ms mt mu mv b">#pragma</code>和Swift <code class="fe ms mt mu mv b">MARK</code>不同，Solidity中的‘pragma’关键字描述了编译器应该使用的版本。请记住，它指示编译器检查版本是否匹配。它不打开或关闭任何语言功能。</p><p id="bd62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们想要告诉Solidity编译器我们想要使用0.8.x版本，我们可以这样启动源文件:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="5def" class="na lw it mv b gy nb nc l nd ne">pragma solidity ^0.8.0;</span></pre><p id="238f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用更大或更小的操作来描述版本间隔，这可能很方便。</p><p id="5f9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有其他使用<code class="fe ms mt mu mv b">pragma</code>关键字的方法，但这次我们不会深入探讨。</p><p id="85de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Solidity源文件以<code class="fe ms mt mu mv b">.sol</code>扩展名保存。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/ebe7bee02ec7f96d17229a2a69f702e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/0*txzNLV-QdxpMxdlo.png"/></div></figure><h1 id="c899" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">一切都始于一份合同</h1><p id="cd9e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Solidity语言中的合同类似于Swift中的类。契约包含状态变量、函数、函数修饰符、事件、错误、结构和枚举。这次我们只研究函数结构。</p><p id="34f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像类一样，我们需要给它命名并打开，用大括号结束。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="b15f" class="na lw it mv b gy nb nc l nd ne">contract HelloSwiftFromSolidity {</span><span id="d416" class="na lw it mv b gy ng nc l nd ne">}</span></pre><h1 id="4879" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">状态变量</h1><p id="997d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">状态变量是在<code class="fe ms mt mu mv b">contract</code>中声明的变量。请注意，这些信息在部署后会存储在区块链合同存储中。我们不需要担心getters和setters。Solidity编译器为我们生成。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="a034" class="na lw it mv b gy nb nc l nd ne">contract HelloSwiftFromSolidity {<br/>  string hello;<br/>}</span></pre><p id="65a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可以注意到，每个执行行都应该以分号<code class="fe ms mt mu mv b">;</code>结尾。对于Swift语言来说，情况并非如此。</p><h1 id="9471" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">功能</h1><p id="f73f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">函数可以在<code class="fe ms mt mu mv b">contract</code>内外声明，类似Swift。他们可以执行一段代码。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="e73d" class="na lw it mv b gy nb nc l nd ne">contract HelloSwiftFromSolidity {<br/>  // visibility = public because access from outside<br/>  string public hello = "Hello Swift";</span><span id="c4ef" class="na lw it mv b gy ng nc l nd ne">  // visibility = public because access from outside<br/>  // view = just view the data<br/>  function helloSwift() public view returns(string memory) {<br/>      return hello;<br/>  }<br/>}</span></pre><p id="4f98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发生了很多事，让我们把它分解一下。如果我们想从外部访问状态变量，我们需要将可见性类型设置为<code class="fe ms mt mu mv b">public</code>，并对函数进行同样的操作。在我们的例子中，函数返回一些东西，我们可以将它标记为<code class="fe ms mt mu mv b">view</code>。它返回一个存储在内存中的字符串，并在执行完成后被删除。</p><p id="5e20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以存储函数变量和返回数据的地方有:</p><ul class=""><li id="99f1" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated"><code class="fe ms mt mu mv b">memory</code> -变量的生存期被限制在函数范围内，不会保存在任何地方；</li><li id="c5fd" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe ms mt mu mv b">storage</code> -数据存储在区块链上的智能合约存储器中；</li><li id="add2" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe ms mt mu mv b">calldata</code> -数据存储在函数被调用的地方之外，我们将讨论更多的细节以及将来如何使用它。</li></ul><h1 id="a427" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">功能类型</h1><p id="e050" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Solidity中的函数可以执行指令，查看数据。当我们查看数据时，它可以是<code class="fe ms mt mu mv b">view</code>或<code class="fe ms mt mu mv b">pure</code>。这两者的区别在于纯函数既不修改也不读取状态变量。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="f31a" class="na lw it mv b gy nb nc l nd ne">function helloWorld() public pure returns(string memory) {<br/>  return "Hello World";<br/>}</span></pre><p id="7538" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们既不读取也不更改区块链上的任何内容，只是返回一些数据。</p><h1 id="e2ed" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="ccc1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Solidity是一种编写可以在区块链部署的智能合同的语言。目前最流行的是以太坊。从Swift开发人员的角度来看，语言在语法上非常相似，但在语义上非常不同。首先，每个执行行都应该以分号结尾。在可靠性方面，与Swift类等价的是可以包含状态变量、函数和其他结构的契约。</p><h1 id="7ebf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">链接</h1><ul class=""><li id="b960" class="nh ni it lb b lc mn lf mo li nv lm nw lq nx lu nm nn no np bi translated"><a class="ae ky" href="https://docs.soliditylang.org/en/v0.8.10/layout-of-source-files.html" rel="noopener ugc nofollow" target="_blank">实体源文件的布局</a></li><li id="4001" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" href="https://docs.soliditylang.org/en/v0.8.10/structure-of-a-contract.html" rel="noopener ugc nofollow" target="_blank">合同的结构</a></li><li id="7fea" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" href="https://ethereum.org/en/developers/" rel="noopener ugc nofollow" target="_blank">以太坊开发者资源</a></li></ul></div></div>    
</body>
</html>