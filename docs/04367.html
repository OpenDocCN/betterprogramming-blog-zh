<html>
<head>
<title>How to Get Started With a GraphQL, React, Apollo Client, and Apollo Server App (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何开始使用GraphQL、React、Apollo客户机和Apollo服务器应用程序(第1部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-get-started-with-a-graphql-react-apollo-client-and-apollo-server-app-403dab1a7801?source=collection_archive---------13-----------------------#2020-04-08">https://betterprogramming.pub/how-to-get-started-with-a-graphql-react-apollo-client-and-apollo-server-app-403dab1a7801?source=collection_archive---------13-----------------------#2020-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fe72" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建后端服务器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ea4ea31c9fa5409581866217b997a61b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EWbSBicMXxDob8g9WmidUA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae ky" href="https://unsplash.com/s/photos/app?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="9143" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个由两部分组成的系列。在第一部分中，我们将了解什么是GraphQL 以及它的一些优点。我们将使用GraphQL构建一个后端。</p><p id="e2d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二部分中，我们将学习使用<a class="ae ky" href="https://www.apollographql.com/docs/react/v3.0-beta" rel="noopener ugc nofollow" target="_blank"> Apollo Client </a>将GraphQL后端集成到React前端服务中。</p><p id="1825" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL已经存在了相当长的一段时间，我们经常认为GraphQL是一个复杂的东西，但实际上，GraphQL只是服务器和客户端之间如何通过HTTP交换数据的规范。</p><p id="97e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它本质上是API的查询语言，定义了可以从服务器获取什么数据。现在，这不同于你可能在标准API中使用的任何东西，在标准API中，你有一个特定的端点来获取特定的数据。</p><p id="5b23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在中型API的情况下，我们可能有一个名为<code class="fe lv lw lx ly b">/api/allarticles/:userId</code>的API，它返回特定用户的所有文章。</p><p id="6ef1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这种构建API的方式被称为REST APIs，我们使用这种技术构建API已经有一段时间了。在此之前，我们有SOAP，其中我们曾经有一个XML数据结构。</p><p id="d912" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让GraphQL与众不同的是它如何改进REST的思想。在REST的情况下，我们点击一个URL并获取一些数据。在GraphQL的情况下，我们可以明确地询问我们正在寻找什么，并且只获取我们想要构建特定页面的任何内容的特定子集。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="eeb9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">入门指南</h1><p id="7ad3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在，在这个简单的介绍之后，让我们开始演示吧。在这个演示中，我们将重点关注使用Apollo客户端构建一个小型React应用程序。Apollo Client是一个GraphQL客户端库，可用于所有主要的前端JavaScript框架。</p><p id="7609" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/" rel="noopener ugc nofollow" target="_blank"> Apollo服务器</a>来构建我们的后端。本教程的所有代码都可以在GitHub 上<a class="ae ky" href="https://github.com/thakursachin467/graphql-starter" rel="noopener ugc nofollow" target="_blank">获得。因此，让我们开始构建一个简单的应用程序。</a></p><p id="849f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个演示将着重于构建一个简单的应用程序，从前端的Apollo客户端开始，用React.js和Apollo Server构建一个轻量级的GraphQL后端。</p><p id="ab61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从建立一个简单的文件夹结构开始。为了简化本入门指南，我们将后端和前端放在同一个文件夹中。那么，我们开始吧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/f411f822e6d4a26e9156d3949bc84f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*192kZgLVZpzibBF0NV_KnQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基本项目设置命令</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/3b315ad0a9bbe779f6fd68f5981b41ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PXmHUcvlwMo83v36XcJbwQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基本文件夹结构</p></figure><p id="a3d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在设置了文件夹结构之后，我们将首先构建我们的后端，然后继续构建React前端来展示我们的数据。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b13d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">用Apollo GraphQL构建后端服务</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/db1630f9d7b7d320c297d634abb268e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dsTJZqU4-yTfut5wdZY8Eg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基本后端设置命令</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/30750cb548438fe8ba8e583738595ba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1JZx3jumziVWkJ00lLRqVA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们后端服务的文件夹结构</p></figure><p id="5f24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，既然我们已经完成了初始文件夹，让我们开始写一些代码，了解一些关于Apollo服务器的事情。让我们直接进入我们的<code class="fe lv lw lx ly b">index.js</code>文件，用基本的、最小的配置初始化我们的服务器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">索引. js</p></figure><p id="2d5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续下一步之前，让我们先分析一下到目前为止我们所写的12行代码，看看我们在做什么。大部分代码非常简单，除了我们看到的所谓的<code class="fe lv lw lx ly b">typeDefs</code>和<code class="fe lv lw lx ly b">resolvers</code>。让我们先来探究一下<code class="fe lv lw lx ly b">typeDefs</code>和<code class="fe lv lw lx ly b">resolvers</code>到底是什么。</p><p id="f75d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个GraphQL服务器都需要定义客户端可以访问的数据，并且可以通过模式来完成，这些模式存储在我们的<code class="fe lv lw lx ly b">typeDefs</code>文件中。</p><p id="3711" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个模式可以有三个根操作。这三个操作是<code class="fe lv lw lx ly b">Query</code>、<code class="fe lv lw lx ly b">Mutation</code>和<code class="fe lv lw lx ly b">subscription</code>。所有这些都有特定的目的。</p><p id="bc36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Query</code>通常用于获取数据库中已经存在的数据，<code class="fe lv lw lx ly b">Mutation</code>用于创建或更新任何数据，<code class="fe lv lw lx ly b">Subscription</code>用于监听GraphQL服务器生成的事件。</p><p id="4d54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">订阅依赖于使用发布和订阅原语来生成通知订阅的事件。</p><p id="047d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们完成了对<code class="fe lv lw lx ly b">Query</code>、<code class="fe lv lw lx ly b">Mutation</code>和<code class="fe lv lw lx ly b">Subscription</code>的基本介绍。类似地，<code class="fe lv lw lx ly b">resolver</code>本质上是一个函数或方法，它为模式中的一个字段解析一个值。</p><p id="2a9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们执行所有的任务来获取数据、创建数据、运行业务逻辑来解析客户端请求的字段。让我们来看一些例子，看看如何一起使用它们来创建我们的GraphQL服务器。</p><p id="c38b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们继续我们的示例应用程序。我个人更喜欢将我的<code class="fe lv lw lx ly b">resolvers</code>和<code class="fe lv lw lx ly b">typeDefs</code>分开，所以让我们为<code class="fe lv lw lx ly b">resolvers</code>和<code class="fe lv lw lx ly b">typeDefs</code>创建文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/dd572c9127725ed5a09f80878963e3ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*X79Dg9oDPYP8ICKCJ0XBJg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建typeDefs和解析程序文件</p></figure><p id="297c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建文件后，让我们看看我们的新文件夹结构，然后我们可以开始使用<code class="fe lv lw lx ly b">typeDefs</code>，因为<code class="fe lv lw lx ly b">typeDefs</code>本质上就像是我们客户端的接口，基于此，我们的客户端可以向服务器请求数据。</p><p id="7548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，让我们从创建第一个<code class="fe lv lw lx ly b">typeDefs</code>开始。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/83e0f4545f0c7f2736749fff6d87cc77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PPK5SJvQVNmZ1gWpOmeU6A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加typeDefs和resolvers文件后的新文件夹结构</p></figure><p id="e452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我前面所说的，<code class="fe lv lw lx ly b">typeDefs</code>是客户端连接到我们的后端服务并请求数据的方式。让我们看看如何定义它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">typeDefs.js</p></figure><p id="e7ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们定义了一个简单的<code class="fe lv lw lx ly b">Query</code>，它帮助我们从后端获取一些数据，在我们的例子中，它是<code class="fe lv lw lx ly b">sayHello</code>，它返回一种由<code class="fe lv lw lx ly b">sayHello</code>查询本身定义的<code class="fe lv lw lx ly b">String</code>。只需确保您对查询进行了命名，以便它们是自我声明的。</p><p id="050c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们的<code class="fe lv lw lx ly b">Query</code>名字清楚地表明了它将要做什么。由于我们已经定义了我们的<code class="fe lv lw lx ly b">typeDefs</code>，我们还必须针对这个查询定义我们的<code class="fe lv lw lx ly b">resolver</code>函数，它将实际解析或计算一个值。</p><p id="be57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL做到这一点的方法是将每个<code class="fe lv lw lx ly b">typeDefs</code>名称映射到每个<code class="fe lv lw lx ly b">resolver</code>函数名称。在我们的例子中，我们必须用相同的名称定义<code class="fe lv lw lx ly b">resolver</code>。所以，我们也这么做吧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">resolvers.js</p></figure><p id="7933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们在<code class="fe lv lw lx ly b">Query</code>中定义了<code class="fe lv lw lx ly b">sayHello</code>函数，它解析为某个值。在我们这里，<code class="fe lv lw lx ly b">hello random person</code>。只要确保您的<code class="fe lv lw lx ly b">resolver</code>函数和<code class="fe lv lw lx ly b">typeDefs</code>的返回类型匹配，否则您的查询将导致返回<code class="fe lv lw lx ly b">null</code>。</p><p id="a3be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，既然我们已经创建了我们的<code class="fe lv lw lx ly b">typeDefs</code>和<code class="fe lv lw lx ly b">resolvers</code>文件，我们只需要对我们的<code class="fe lv lw lx ly b">index.js</code>文件做一点修改，我们就可以开始了。我们必须将我们的<code class="fe lv lw lx ly b">resolvers</code>和<code class="fe lv lw lx ly b">typeDefs</code>文件导入到我们的<code class="fe lv lw lx ly b">index.js</code>文件中，并使用它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">索引. js</p></figure><p id="92aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经介绍完了，让我们构建一个简单的待办事项列表，开始使用GraphQL进行CRUD操作。</p><p id="c39d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在这里，我们将不使用数据库，我们将在后端服务中以<code class="fe lv lw lx ly b">json</code>对象的形式使用一个假数据库，我们可以操纵它来执行CRUD操作。因此，让我们创建我们的假JSON文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/916ba51f1b4447b253eed9a7175dbc36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*FADU-h1HZV5jUFYImbqm4g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建fake_data.js文件</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="3e03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将有三个突变来更新、创建和删除伪JSON文件中的数据，还有一个查询用于与数据交互和获取数据。</p><p id="da5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们创建第一个<code class="fe lv lw lx ly b">Query</code>来从我们的后端服务获取数据。姑且称之为<code class="fe lv lw lx ly b">fetchTasks</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="dde1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们定义了获取任务<code class="fe lv lw lx ly b">Query</code>，它的返回类型为<code class="fe lv lw lx ly b">Tasks</code>。现在，让我们为新添加的查询编写一个解析器函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9b8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的查询将总是返回第一个任务。在更新此行为之前，让我们先运行服务器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/8e25d3ea796b0393e64aa32956cc7fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*6KOFqJHGnwr5ooK_NASYhw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行我们的服务器</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/35dd7f3a9585fe0575000ced370b1b73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZ6GujWDpmMMZpS3uYLMug.png"/></div></div></figure><p id="aecf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们导航到<code class="fe lv lw lx ly b">http://localhost:4000/</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/3f1ed6385d5559ad1771bf5beb2ad5e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AR_W-6535PKBzE9mXn1YVw.png"/></div></div></figure><p id="550c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们导航到<a class="ae ky" href="http://localhost:4000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:4000/ </a>时，迎接我们的是这个GUI。这被称为GraphQL操场，我们可以在这里运行我们的查询。让我们运行我们的第一个<code class="fe lv lw lx ly b">Query</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/d26ba00a5530bf9ae3ab1d493f641fbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93gy2oDWpPPMugPZykpW0A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行我们的第一个查询</p></figure><p id="428e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行第一个查询后，我们看到了结果。它从我们的后端获取数据，这些数据在我们的伪JSON文件中。现在，让我们给我们的函数添加一些逻辑，并从我们的客户端接受一些数据作为过滤器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8acc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们已经定义了与数据交互的变异和查询。我们看到的一个新东西是数据类型前面的<code class="fe lv lw lx ly b">!</code>标记，这意味着这个字段是强制的，我们不能在后端执行查询或变异。</p><p id="ed2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为解析器添加一些逻辑，这样我们就可以与数据进行交互。解析器文件中的每个解析器函数都接收四个函数参数，并且几乎所有的GraphQL服务器都在解析器中接收这四个函数参数。</p><ul class=""><li id="c34a" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">root</code> —先前/父类型的结果。</li><li id="2e5d" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">args</code> —客户端向字段提供的参数。例如，在我们的<code class="fe lv lw lx ly b">typeDefs</code>中，我们有<code class="fe lv lw lx ly b">addTask(input:addTaskInput)</code>，所以在这种情况下<code class="fe lv lw lx ly b">args</code>将是<code class="fe lv lw lx ly b">{input:{name:"some name",completed:false}}</code>。</li><li id="2ff7" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">context</code> —提供给所有解析器的<code class="fe lv lw lx ly b">Mutable</code>对象。这基本上包含身份验证、授权状态以及在解析查询时应该考虑的任何其他内容。您可以访问您的<code class="fe lv lw lx ly b">request</code>对象，因此您可以应用任何中间件，并通过上下文向解析器提供该信息。</li><li id="553c" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">info</code> —与查询相关的特定于字段的信息。该参数仅在高级情况下使用，但它包含有关查询执行状态的信息，包括字段名、从根到字段的路径等。</li></ul><p id="dd1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们将主要关注<code class="fe lv lw lx ly b">args</code>来访问我们的客户或游乐场发送的字段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ac5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们刚刚添加了一些简单的逻辑来与我们的假数据库进行交互。现在让我们看看如何通过我们的操场进行互动。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/a347b3eb7487aaec778b2fa5ad2b66d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fUSELRuhRrPvUAV80eUGzQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GraphQL游乐场</p></figure><p id="fb34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里看到所有的突变和查询。让我们运行一些突变和查询，看看它是否有效。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/46e0f6198be967cfd35b7a845c1b3153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jzgY6mNWPO8aHpX0aKqydQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行addTask查询</p></figure><p id="4cc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经用最少的配置完成了服务器的构建。</p><p id="f2a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文的第二部分中，我们将使用React和Apollo Client来构建我们的前端客户端，并利用我们刚刚构建的API。</p></div></div>    
</body>
</html>