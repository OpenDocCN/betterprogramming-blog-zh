<html>
<head>
<title>Take Your Angular Apps to the Next Level (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让你的角度应用更上一层楼(第二部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/take-your-angular-apps-to-the-next-level-part-2-3cdec26e84d?source=collection_archive---------14-----------------------#2021-01-25">https://betterprogramming.pub/take-your-angular-apps-to-the-next-level-part-2-3cdec26e84d?source=collection_archive---------14-----------------------#2021-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6a73" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">定制有角度的素材主题，使用本地资源、拦截器和代理来构建优化的、可维护的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/271c63d707e7696e9dd1d847f0606c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ADqrGOiHMs1zgjD66EuhSA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e4e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从开始的<code class="fe lu lv lw lx b">ng new</code>命令开始，Angular包含了一个基本web应用的所有要素，从路由到状态管理。当然，当涉及到更高级的功能时，随着应用程序的增长，你开始需要这种功能，事情就变得不那么清楚了。在本指南中，我们将探索一些更小众的角度特征，当你需要它们时，它们会成为你的救命稻草。</p><p id="3d18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇文章基于第1部分中的一些概念，所以你可能想先阅读一下。</p><p id="ccac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">具体来说，我们将了解:</p><ul class=""><li id="3aff" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">定制材料主题颜色</li><li id="c33e" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">自定义材料图标</li><li id="460d" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">本地字体</li><li id="50e7" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">HTTP拦截器</li><li id="629d" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">代理配置</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0c0f" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">定制材料主题颜色</h1><p id="c50b" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">虽然Angular的官方材料组件库提供了一套很好的预定义主题颜色，但你迟早会发现自己需要使用非常特殊的颜色，也许是默认情况下不可用的品牌颜色。让我们看看如何为材质主题创建自定义调色板。</p><p id="3452" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如同第1部分的素材主题部分，我假设您使用SCSS，因此在<code class="fe lu lv lw lx b">styles.scss</code>中定义了一个主题。</p><p id="1d25" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们用深色、浅色和常规颜色来定义颜色:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f98c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">contrast</code>下的项目定义了每种颜色变体背景下的文本颜色。在上面的例子中，三种变体都相当暗，所以文本应该是白色的(<code class="fe lu lv lw lx b">#fff</code>)。</p><p id="208a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们定义一个调色板。与标准材料颜色不同，我们需要明确提及每一种变体。我将使用标准的<code class="fe lu lv lw lx b">mat-red</code>定义另一个调色板来显示不同之处:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="33c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！现在，您可以在主题中使用调板:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5e06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以在样式文件中的任意位置使用调色板中的单个颜色变体:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0a9d" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">自定义材料图标</h1><p id="896f" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">Google官方材料组件库的<code class="fe lu lv lw lx b"><a class="ae ly" href="https://material.angular.io/components/icon/overview" rel="noopener ugc nofollow" target="_blank">mat-icon</a></code>组件很棒；它让你用清晰的、经过测试的图标来代替文本，来呈现一个更紧凑、视觉上更吸引人的用户界面。不过，缺点是图标默认情况下不与应用程序打包在一起，而是从谷歌服务器远程加载。这在某些情况下会导致加载问题，比如当用户使用像<a class="ae ly" href="https://ublockorigin.com/" rel="noopener ugc nofollow" target="_blank"> uBlock Origin </a>这样的浏览器扩展时。除此之外，你只能看到谷歌的<a class="ae ly" href="https://material.io/resources/icons" rel="noopener ugc nofollow" target="_blank">图标列表</a>。幸运的是，我们可以使用自定义图标来解决这些问题。</p><p id="de56" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，确保您已经在<code class="fe lu lv lw lx b">app.module.ts</code>中导入了<code class="fe lu lv lw lx b">MatIconModule</code>。然后，将以下导入添加到<code class="fe lu lv lw lx b">app.component.ts</code>的顶部:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5a70" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后将这些添加到<code class="fe lu lv lw lx b">AppComponent</code>构造函数中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1635" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，将您的自定义图标(SVG格式)添加到<code class="fe lu lv lw lx b">assets</code>文件夹中。在这个例子中，我将使用一个名为<code class="fe lu lv lw lx b">cancel.svg</code>的文件。</p><p id="ea60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，将以下代码添加到<code class="fe lu lv lw lx b">AppComponent</code>的<code class="fe lu lv lw lx b">ngOnInit</code>函数中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="bd48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码告诉应用程序使用我们在<code class="fe lu lv lw lx b">assets</code>文件夹中的图标，并使它在<code class="fe lu lv lw lx b">cancel</code>名称下可用。它现在可以用于任何<code class="fe lu lv lw lx b">mat-icon</code>元素:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="a988" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">本地字体</h1><p id="11a7" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">这与上一节类似。本地存储的字体可能会占用空间，但你可以肯定它们永远不会加载失败，并且不太可能被用户扩展阻止。</p><p id="8fbd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就像我们处理自定义的<code class="fe lu lv lw lx b">mat-icon</code>一样，我们将本地字体添加到<code class="fe lu lv lw lx b">assets</code>文件夹中。从那里，我们将以下内容添加到<code class="fe lu lv lw lx b">styles.scss</code>。(我这里用的是Roboto字体。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="0c0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码非常简单。我们已经确定了字体的名称，并指定了它的位置，现在它可以在应用程序的任何地方使用。请注意，如果素材库使用自己的字体导入，这可能不起作用。您可以通过从<code class="fe lu lv lw lx b">index.html</code>中移除对<code class="fe lu lv lw lx b">fonts.googleapis.com</code>的所有引用以及<code class="fe lu lv lw lx b">class="mat-typography"</code>的任何实例来解决这个问题。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="02ba" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">HTTP拦截器</h1><p id="4e48" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">身份验证是web APIs的一个常见要求，一种常见的身份验证形式是JSON Web Token (JWT)。这些令牌需要随着每个请求从客户端发送到受保护的API端点。虽然JWT的细节超出了本文的范围，但是我们将研究如何使用HTTP拦截器来自动发送存储的JWT和HTTP请求，而不是为每个请求单独发送。</p><p id="919c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Angular HTTP拦截器就像它听起来的那样:一段代码，它查看应用程序发出的每个请求，并稍微修改它。首先，我们通过在<code class="fe lu lv lw lx b">app</code>目录中创建一个新的<code class="fe lu lv lw lx b">HttpInterceptor.ts</code>文件来创建拦截器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="748d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当发出请求时，就会调用<code class="fe lu lv lw lx b">intercept</code>函数。从那里，以某种方式检索JWT令牌(实际上，这可能来自不同的服务)。然后，使用<code class="fe lu lv lw lx b">req.clone</code>函数制作请求的副本，同时将JWT附加到该副本的头部。然后副本通过<code class="fe lu lv lw lx b">next.handle</code>功能传递到下一步。</p><p id="67ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然已经创建了拦截器，就需要对其进行配置，以便在应用程序范围内使用。在<code class="fe lu lv lw lx b">app.module.ts</code>文件中，创建以下导入(如果不存在的话):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="bccb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，将其添加到文件底部的providers数组中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2bb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完成—应用程序发出的所有HTTP请求现在都应该包含JWT！注意，这是HTTP拦截器的一个流行用例的演示；它们实际上可以用于对HTTP请求(或响应)的任何修改。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="70ca" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">代理配置</h1><p id="e8b3" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">假设您有一个服务于Angular客户端的后端API。在生产中，这两者都在同一个域中，但是在开发中，当然，Angular dev服务器单独运行(通常在端口4200上)以支持热重载和其他特性。这意味着如果客户端试图请求API端点，它会失败，并出现一个令人讨厌的<a class="ae ly" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors" rel="noopener ugc nofollow" target="_blank"> CORS </a>错误。有许多方法可以解决这个问题，但是对于Angular应用程序来说，最直接(也是最安全)的方法是使用代理配置文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/9613301bb4cc50ac2520c5fd4706bd7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*yH489d6XTMdQ99oc1HuaSw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">铬中的CORS误差</p></figure><p id="de74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个错误基本上是浏览器抱怨它不想向当前页面正在访问的域之外的域发出AJAX请求。虽然我不想赘述，但代理配置基本上解决了这个问题。</p><h2 id="6280" class="nu mv it bd mw nv nw dn na nx ny dp ne lh nz oa ng ll ob oc ni lp od oe nk of bi translated">设置</h2><p id="fbcb" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">我们需要做的就是首先创建文件，然后告诉Angular在运行<code class="fe lu lv lw lx b">ng serve</code>命令时使用它。</p><p id="54e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Angular项目的根目录下创建这个<code class="fe lu lv lw lx b">proxy.conf.json</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="cf3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们一行一行地检查这个文件。首先，我们定义了一个<code class="fe lu lv lw lx b">/api/*</code>端点，表明对<code class="fe lu lv lw lx b">/api</code>的任何HTTP请求都应该通过代理发送。接下来，我们使用<code class="fe lu lv lw lx b">target</code>属性来说明这些请求应该被定向到<code class="fe lu lv lw lx b">localhost:8080</code>，这是API被服务的地址。(当然，你应该根据你的情况改变这一点。)最后，<code class="fe lu lv lw lx b">"secure": false</code>简单地说就是不使用HTTPS。(反正<code class="fe lu lv lw lx b">localhost</code>上你大概用不着。)</p><p id="c123" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在代理配置文件已经准备好了，我们只需要确保它在<code class="fe lu lv lw lx b">ng serve</code>上运行。打开<code class="fe lu lv lw lx b">angular.json</code>文件，在JSON对象中导航，找到以下属性:<code class="fe lu lv lw lx b">projects</code>&gt;<code class="fe lu lv lw lx b">[your project name]</code>&gt;<code class="fe lu lv lw lx b">architect</code>&gt;<code class="fe lu lv lw lx b">serve</code>&gt;<code class="fe lu lv lw lx b">options</code>—它应该在一个典型的Angular项目的第72行附近。然后将该属性添加到<code class="fe lu lv lw lx b">options</code>对象中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="62d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请记住，我们仅将此应用于<code class="fe lu lv lw lx b">serve</code>命令，而不是<code class="fe lu lv lw lx b">build</code>命令，因为代理功能仅用于开发期间。如果您需要在生产中解决CORS问题，请在服务器端解决。</p><p id="e0f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！你应该不会再从Angular dev服务器收到对<code class="fe lu lv lw lx b">/api</code>的请求时出现CORS错误。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="4ad1" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="c608" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">我希望这个指南能帮助你把你的Angular应用程序提升到一个新的水平。感谢阅读！</p></div></div>    
</body>
</html>