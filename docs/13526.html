<html>
<head>
<title>How To Build a Serverless REST API With Java and Spring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Java和Spring构建无服务器REST API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-serverless-rest-api-with-java-and-spring-97e6beeccda9?source=collection_archive---------4-----------------------#2022-09-05">https://betterprogramming.pub/how-to-build-a-serverless-rest-api-with-java-and-spring-97e6beeccda9?source=collection_archive---------4-----------------------#2022-09-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="601f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Java、Spring和AWS SAM实现无服务器化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d959403502893c1701d0eedc0d9cc680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U1mEBP6Ew9l2VguHc3EFsg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者提供的图片</p></figure><p id="c3a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">继上一篇关于用TypeScript和NestJS 构建<a class="ae lu" href="https://blog.devgenius.io/how-to-build-a-serverless-rest-api-with-nestjs-and-dynamodb-7b58b5b59bf6" rel="noopener ugc nofollow" target="_blank">无服务器REST API的文章之后，我们现在将深入一些其他技术。在这个故事中，我们将使用AWS SAM、Java和Spring构建一个无服务器REST API。作为一个构建工具，我们选择了</a><a class="ae lu" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> Gradle </a>，它是自动化构建过程最快的工具，并且在Java领域受到ide的广泛支持。</p><blockquote class="lv lw lx"><p id="2fbb" class="ky kz ly la b lb lc ju ld le lf jx lg lz li lj lk ma lm ln lo mb lq lr ls lt im bi translated">不确定无服务器技术能提供什么？阅读<a class="ae lu" href="https://serverlesscorner.com/serverless-just-ship-the-code-c1214214a5f7" rel="noopener ugc nofollow" target="_blank">我以前的文章</a>无服务器技术如何帮助你更快地构建。</p></blockquote><p id="c3ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">API将在AWS Lambda上运行，并与API网关相关联(见下图)。这种无服务器架构允许您以按请求付费的定价模式运行服务，只需最少的操作维护。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/e9e626cd1e04d598daf2cfbd61b611cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*k14SURhMn9IyM8KxAvnKxQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无服务器架构</p></figure><p id="bbda" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们快速介绍一下所涉及的技术，让您更好地了解我们将在这里构建什么。</p><h1 id="7892" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">AWS SAM</h1><p id="7b95" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">AWS无服务器应用程序模型(AWS SAM)是AWS自己的技术，可以帮助您构建、测试和部署AWS Lambda功能。以前我使用无服务器框架，AWS SAM更适合用Java完成的Lambda函数。</p><blockquote class="lv lw lx"><p id="8f70" class="ky kz ly la b lb lc ju ld le lf jx lg lz li lj lk ma lm ln lo mb lq lr ls lt im bi translated">要使用AWS SAM在本地运行和测试您的Lambda，您还需要安装<a class="ae lu" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"> Docker </a>。</p></blockquote><h2 id="75d8" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">弹簧框架</h2><p id="207c" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">Spring框架是最流行的Java开源框架。它为web、数据库、集成等提供了许多模块。Spring允许开发者使用POJOs并隐藏了复杂性。开发人员使用Spring框架效率更高。Spring框架的核心是控制模式的反转。Spring IoC容器处理对象创建和依赖注入，允许类之间更松散的耦合，这提供了灵活性。</p><h2 id="3d98" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">格拉德勒</h2><p id="3a13" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">与Maven相比，Gradle是最快的Java构建工具，提高了您的工作效率。</p><h1 id="ccad" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">设计选择</h1><p id="bcc5" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">使用AWS Lambda构建REST API有很多方法。在这个故事中，我做了以下选择:</p><p id="b68e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">API网关Lambda代理集成——您通常会将API网关中的每个API请求映射到一个Lambda函数，代理集成允许您将所有API请求映射到一个Lambda函数。这种与API网关的分离减轻了您在API网关中管理API配置的负担，并加快了开发过程。在一个服务中捆绑相同领域的功能非常适合微服务架构。</p><p id="9b19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个额外的效果是，捆绑功能降低了“冷启动”的几率</p><p id="2749" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这确实需要您自己处理传入的请求。正如我们将看到的，Spring框架不费吹灰之力就能做到这一点。</p><h2 id="da2e" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">无服务器Java容器</h2><p id="6328" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">用Java实现AWS Lambda可以考虑多种框架，比如Spring Cloud。然而，我选择使用AWS实验室的“<a class="ae lu" href="https://github.com/awslabs/aws-serverless-java-container" rel="noopener ugc nofollow" target="_blank">无服务器Java容器</a>”框架。它由AWS维护，并在Lambda中提供一个运行Spring的非常薄的Java包装器。理:<a class="ae lu" href="https://serverlesscorner.com/5-ways-to-deal-with-cold-starts-dcbb8967edf9" rel="noopener ugc nofollow" target="_blank">少码，少冷启动</a>。</p><h1 id="a6a4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">让我们开始建造吧</h1><p id="bcf8" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">所以，现在我们知道了我们将使用的技术和我们前进的方向，让我们开始构建吧。我们将用Java和Spring构建一个在线图书馆服务作为运行在AWS Lambda上的REST API。</p><blockquote class="lv lw lx"><p id="e639" class="ky kz ly la b lb lc ju ld le lf jx lg lz li lj lk ma lm ln lo mb lq lr ls lt im bi translated"><em class="it">本文的完整项目可以在Github</em><a class="ae lu" href="https://github.com/cyberworkz/examples" rel="noopener ugc nofollow" target="_blank"><em class="it">https://github.com/cyberworkz/examples</em></a><em class="it">的</em> <code class="fe nm nn no np b"><em class="it">online-library-java</em></code> <em class="it">文件夹中找到。</em></p></blockquote><h2 id="f247" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">先决条件</h2><ol class=""><li id="8c3c" class="nq nr it la b lb mv le mw lh ns ll nt lp nu lt nv nw nx ny bi translated">AWS帐户——查看此<a class="ae lu" href="https://aws.plainenglish.io/get-your-serverless-api-in-the-cloud-77bd70b26788" rel="noopener ugc nofollow" target="_blank">故事</a>以获得设置帮助。</li><li id="5974" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">Java和Spring的基础知识</li></ol><h2 id="aa45" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">安装AWS SAM</h2><p id="b96d" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">AWS SAM CLI使您可以轻松创建和管理无服务器应用程序。使用以下<a class="ae lu" href="http://makes it easy for you to create and manage serverless applications" rel="noopener ugc nofollow" target="_blank">链接</a>将其安装到您的操作系统上。</p><h2 id="41fe" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">设置项目</h2><p id="efc8" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">现在SAM已经安装好了，我们将使用它来设置我们的无服务器项目。我们将使用预定义的模板立即投入使用。执行以下命令来生成项目:</p><pre class="kj kk kl km gt oe np of og aw oh bi"><span id="a0f5" class="na me it np b gy oi oj l ok ol">sam init --location gh:cyberworkz/sam-templates</span></pre><p id="359c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将使用代理模式生成一个Java Spring项目，并带有所有必需的依赖项。生成的项目有一个AWS SAM模板文件，该文件严格遵循AWS CloudFormation 的格式。<code class="fe nm nn no np b">template.yml</code>文件应该如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SAM模板文件</p></figure><p id="ee06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们讨论一下这个文件中最重要的参数。使用模板文件，您可以为您的Lambda定义以下参数:</p><ul class=""><li id="bad8" class="nq nr it la b lb lc le lf lh oo ll op lp oq lt or nw nx ny bi translated">运行时(java11)</li><li id="6366" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated">内存大小(512)</li><li id="b455" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated">CodeUri和处理程序类。</li></ul><p id="5bad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另外，请注意events部分，在这里我们定义了代理与API网关的集成方式。</p><pre class="kj kk kl km gt oe np of og aw oh bi"><span id="d277" class="na me it np b gy oi oj l ok ol">Events:        <br/>  Service:          <br/>    Type: Api <br/>    Properties:            <br/>      Path: /{proxy+}            <br/>      Method: any</span></pre><p id="fe24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nm nn no np b">CodeUri</code>参数定义了作为Lambda代码部署的java包。Gradle构建文件包含任务shadowJar，它将构建代码，包括依赖项中的所有类，以便它可以运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Gradle构建文件</p></figure><h1 id="e2aa" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">请求处理程序</h1><p id="37c2" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">现在我们已经建立了项目。我们将查看处理来自API网关的传入请求的代码。<code class="fe nm nn no np b">StreamLambdaHandler</code>类处理传入的请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">请求处理程序</p></figure><p id="2fb2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该类包含一个静态部分，它在初始化阶段被调用。使用它来建立与作为数据库的资源的连接。处理完请求后，这些资源会在下次调用时保留。</p><p id="f50d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nm nn no np b">handleRequest</code>方法将请求作为一个<code class="fe nm nn no np b">Inputstream</code>来处理，并返回一个<code class="fe nm nn no np b">OutputStream</code>作为响应。该方法代理对<code class="fe nm nn no np b">SpringLambdaContainer</code>的调用，使我们能够应用Spring框架魔法。</p><h2 id="626e" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">语境方法</h2><p id="7839" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated"><a class="ae lu" href="https://docs.aws.amazon.com/lambda/latest/dg/java-context.html" rel="noopener ugc nofollow" target="_blank">上下文对象</a>包含获取请求信息的钩子。有关上下文对象可以提供的内容，请参见以下列表。</p><ul class=""><li id="ca1b" class="nq nr it la b lb lc le lf lh oo ll op lp oq lt or nw nx ny bi translated"><code class="fe nm nn no np b">getRemainingTimeInMillis()</code>–返回执行超时前剩余的毫秒数。</li><li id="b640" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated"><code class="fe nm nn no np b">getFunctionName()</code>–返回Lambda函数的名称。</li><li id="f9d2" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated"><code class="fe nm nn no np b">getFunctionVersion()</code>–返回函数的<a class="ae lu" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html" rel="noopener ugc nofollow" target="_blank">版本</a>。</li><li id="e4bb" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated"><code class="fe nm nn no np b">getInvokedFunctionArn()</code>–返回用于调用该函数的亚马逊资源名称(ARN)。指示调用程序是否指定了版本号或别名。</li><li id="a448" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated"><code class="fe nm nn no np b">getMemoryLimitInMB()</code>–返回分配给该函数的内存量。</li><li id="b916" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated"><code class="fe nm nn no np b">getAwsRequestId()</code>–返回调用请求的标识符。</li><li id="a783" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated"><code class="fe nm nn no np b">getLogGroupName()</code>–返回函数的日志组。</li><li id="3f15" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated"><code class="fe nm nn no np b">getLogStreamName()</code>–返回函数实例的日志流。</li><li id="4d48" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated"><code class="fe nm nn no np b">getIdentity()</code>–(移动应用程序)返回授权请求的Amazon Cognito身份的信息。</li><li id="98b2" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated"><code class="fe nm nn no np b">getClientContext()</code>–(移动应用)返回客户端应用提供给Lambda的客户端上下文。</li><li id="344c" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated"><code class="fe nm nn no np b">getLogger()</code>–返回函数的<a class="ae lu" href="https://docs.aws.amazon.com/lambda/latest/dg/java-logging.html" rel="noopener ugc nofollow" target="_blank">记录器对象</a>。</li></ul><h2 id="47c0" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">API端点</h2><p id="d97d" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">现在，我们转向定义API端点。我们使用代理集成模式，其中API网关上的每个请求都被转发给Lambda代码。使用Spring MVC，我们可以使用注释非常容易地定义端点。参见下面的<code class="fe nm nn no np b">OnlineLibraryController.java</code>代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">OnlineLibraryController.java</p></figure><p id="9f25" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nm nn no np b">EnableWebMvc</code>注释表明您将使用注释来配置请求映射。<code class="fe nm nn no np b">RestController</code>注释表明该类是Spring框架中的托管组件，将在启动Spring容器时被初始化。</p><p id="90ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nm nn no np b">RequestMapping</code>注释说明了控制器类方法将被映射到的路径。<code class="fe nm nn no np b">GetMapping</code>注释是<code class="fe nm nn no np b">RequestMapping</code>的专门化，将方法映射到GET请求。注释<code class="fe nm nn no np b">GetMapping</code>的值添加到在类级别定义的<code class="fe nm nn no np b">RequestMapping</code>中，并且可以包含路径变量。本例中的URL <code class="fe nm nn no np b">/books/author/tolkien/jrr</code>被映射到<code class="fe nm nn no np b">getBooksByAuthor</code>方法。</p><p id="d844" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用于映射传入HTTP请求的一些其他重要注释是:</p><ul class=""><li id="0649" class="nq nr it la b lb lc le lf lh oo ll op lp oq lt or nw nx ny bi translated"><code class="fe nm nn no np b">PostMapping</code></li><li id="a89d" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated"><code class="fe nm nn no np b">PutMapping</code></li><li id="fae7" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated"><code class="fe nm nn no np b">PathVariable</code></li><li id="0753" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated"><code class="fe nm nn no np b">RequestParam</code></li><li id="4827" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated"><code class="fe nm nn no np b">Headers</code></li><li id="f03e" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated"><code class="fe nm nn no np b">RequestBody</code></li><li id="2e62" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated"><code class="fe nm nn no np b">ResponseBody</code></li></ul><p id="9810" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这演示了使用SpringMVC注释将请求映射到不同的方法是多么容易，并且节省了您在API网关中管理映射的工作量。</p><p id="13a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，这就结束了。我希望这对你的无服务器之旅有所帮助。同样，这个项目的代码可以在GitHub上找到。<a class="ae lu" href="https://github.com/cyberworkz/examples" rel="noopener ugc nofollow" target="_blank">https://github.com/cyberworkz/examples</a>在<code class="fe nm nn no np b">online-library-java</code>文件夹里。</p><p id="c2c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p><h1 id="1ac1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">海科·范德沙夫</h1><ul class=""><li id="3076" class="nq nr it la b lb mv le mw lh ns ll nt lp nu lt or nw nx ny bi translated"><strong class="la iu"> <em class="ly">如果你喜欢这个，请跟随Serverlesscorner.com上</em></strong><a class="ae lu" href="https://serverlesscorner.com/about" rel="noopener ugc nofollow" target="_blank"><strong class="la iu"><em class="ly"/></strong></a><strong class="la iu"><em class="ly">。</em> </strong></li><li id="9be5" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated"><strong class="la iu"> <em class="ly">爱情</em> </strong> ❤️ <strong class="la iu"> <em class="ly">阅读</em> </strong> <strong class="la iu"> <em class="ly">我的故事和其他关于媒？</em> </strong> <a class="ae lu" href="https://serverlesscorner.com/membership" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> <em class="ly">成为会员</em> </strong> </a> <strong class="la iu"> <em class="ly">如果你还不是会员。</em> </strong></li><li id="1ae1" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt or nw nx ny bi translated"><strong class="la iu"> <em class="ly">想阅读更多无服务器？报名参加我的</em> </strong> <a class="ae lu" href="https://serverlessconsulting.org/newsletter" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> <em class="ly">月刊</em> </strong> </a> <strong class="la iu"> <em class="ly">📬关于无服务器技术和使用案例的启发性和深刻的故事。</em> </strong></li></ul><h1 id="f514" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">参考</h1><ol class=""><li id="99f4" class="nq nr it la b lb mv le mw lh ns ll nt lp nu lt nv nw nx ny bi translated"><a class="ae lu" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/server less-application-model/latest/developer guide/what-is-Sam . html</a></li><li id="58c5" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/Inversion_of_control" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Inversion_of_control</a></li><li id="9634" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><a class="ae lu" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/API gateway/latest/developer guide/set-up-lambda-proxy-integrations . html</a></li></ol></div></div>    
</body>
</html>