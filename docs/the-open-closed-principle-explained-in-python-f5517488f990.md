# 用 Python 解释开闭原理

> 原文：<https://betterprogramming.pub/the-open-closed-principle-explained-in-python-f5517488f990>

## 固体原理 2/5

![](img/7e0f38869004ad0a0eac8bfed34a6af8.png)

照片由[丹尼尔·麦卡洛](https://unsplash.com/@d_mccullough?utm_source=ghost&utm_medium=referral&utm_campaign=api-credit) / [Unsplash](https://unsplash.com/?utm_source=ghost&utm_medium=referral&utm_campaign=api-credit)

这篇文章是关于[坚实](https://en.wikipedia.org/wiki/SOLID)原则系列文章的第二部分。你可以在这里找到第一个帖子。

软件的本质是不断变化的。软件从来都不是“完整的”。几乎总是有一些东西需要修复或改进。这是因为软件是为满足业务需求而构建的，而业务需求从来不会停滞不前。它只是一个封闭的企业，有停滞或不存在的需求。

所以问题自然出现了，我们如何构建适应变化并且仍然健壮的软件？

开闭原理是回答这个问题的一种方式。

开闭原则在某些方面与第一篇文章中解释的单一责任原则非常相似。
本质上，这一原则规定了以下内容:

> 软件组件(类和功能)应**打开**进行扩展，而**关闭**进行修改。

这个想法很简单。您的代码中特定类的业务逻辑不应更改。相反，如果必须实现一个额外的特性，代码应该被扩展而不是被修改。随着业务需求的增长和变化，这使得调试更容易，代码也更容易维护。想象一下，每次由于新的业务需求而改变代码时，都必须重写单元测试！

像往常一样，我们看一个例子来说明这一点，并把它带回家。

# 密码

假设我们有下面这段代码:

我们使用了与第一篇文章相同的主题，即汽车经销商。

新车在购买前需要进行实例化。可以使用`buy`功能购买汽车，也可以使用`buy_with_discount`功能以 20%的折扣购买。

提供给`buy_with_discount`函数的`cash`需要正好是汽车价格的 80%才能被购买。

我们可以运行代码，看到宝马以 80000 英镑的价格购买，享受 20%的折扣。

现在，让我们假设汽车经销商希望为经销商的忠实会员、VIP 人士或亲密的朋友和亲戚提供一些折扣。或者，我们可以假设经销商希望开展夏季销售活动，并提供 20%以上的折扣。

正如你所看到的,*业务需求*已经改变，需要对代码进行*变更。*

为了适应这个请求，我们可以简单地为`buy_with_discount`函数编写另一个 if 语句。类似于表示 30%的折扣:

```
if int(0.7*self.price) == int(cash):
        print("Buying {} with 30%% discount".format(self.name))
```

但是根据开闭原则，这是一个错误的方法。因为`Car`类的业务逻辑不应该改变。相反，它应该被延长。在 OOP(面向对象编程)中扩展功能的一种常见方式是使用多态性，也称为继承。

让我们看看如何使用 Python 中的继承来正确解决这个问题。

代码如下:

我们做的第一件事是通过创建一个`Discount`类将折扣业务逻辑与常规购买逻辑分开。然后我们定义`buy_with_discount`函数，它简单地打印汽车已经被购买。

这就是有趣的地方。

接下来，我们需要实现八折逻辑。但是记住，根据原则，我们不允许修改`Discount`类。我们唯一能做的就是延长它。我们如何扩展它？通过创建一个新类并让这个新类继承`Discount`类。

我们定义了一个新的类`Discount20`，并通过将`Discount`作为类定义中的一个参数来传递，使它继承自`Discount`类。`__init__`函数调用父类的`Discount` ) `__init__`方法，如`super()`命令所示。我们将`Discount`类的实例中的`self.discount`初始化为`20`。接下来，我们定义一个`buy_with_discount`函数，它使用我们之前在不正确的代码中使用的 if 条件来检查所提供的钱是否是原始值的 80%。如果是，我们通过调用父类的`buy_with_discount`函数发出一个购买订单。你看到我们是如何扩展原始的`Discount`类和其中的业务逻辑的吗？

酷的是，假设我们想提供 30%的折扣。我们如何实现这一点？

我们简单地创建了一个名为`Discount30`的新类，并重复代码，仅将值从`20`更改为`30`，将`0.8`更改为`0.7`。多棒啊

如果你已经做到了这一步，花点时间为自己的出色表现而感到自豪吧！

我们在初始化时在`if __name__`条件下调用这两个函数。

现在可以运行代码了，您将看到购买了两辆汽车。一个七折，一个八折！

# 包裹

这个帖子到此为止。希望你学到了一些有用的东西，可以应用到你的软件项目中。简而言之，我们研究了开闭原则，以及它如何有助于使代码更易于维护和测试。我们还看到了它如何提高代码的可读性和质量。

和往常一样，这个原则可能看起来没什么大不了的，因为我们在这篇文章中有一个小的测试例子。但是在拥有中型到大型代码库的组织中，尤其是在测试是开发过程的一部分的情况下，开闭原则真的是一个游戏改变者！

*原载于*[*https://haseebkamal.com*](https://haseebkamal.com/the-open-closed-principle-explained-with-a-python-example/)