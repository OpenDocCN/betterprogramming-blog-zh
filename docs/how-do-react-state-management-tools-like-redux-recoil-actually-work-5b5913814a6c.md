# 像 Redux，反冲这样的 React 状态管理工具实际上是如何工作的？

> 原文：<https://betterprogramming.pub/how-do-react-state-management-tools-like-redux-recoil-actually-work-5b5913814a6c>

## 在后台

![](img/353473e5227d74602081044bd4cd262f.png)

很久以来一直有一个问题，React **上下文 API**(React 支持的状态管理)与其他状态管理工具如 Redux 或反冲**在内部**有何不同。

如果你看一下这些工具的文档，你会发现一些共同点，那就是这些工具更适合具有频繁变化的全局状态的应用程序。

例如，Redux 和反冲不断地告诉他们的用户，如果您有一个包含少量组件的小应用程序，并且它们的状态不会频繁变化，那么您可能不需要使用我们的工具。

如您所知，Context API 在性能方面不是很好，原因很简单，当 Provider 中的任何状态发生变化时，Provider 下的所有子组件都将重新呈现。

这使得依赖上下文 API 作为状态管理是绝对苛刻的原因，损害了我们的应用程序性能。如果这是一个用例，比如静态的主题颜色，那么这将是上下文 API 的一个很好的用例。

每个 React 组件都会自动重新渲染，原因很简单，有三个。

*   当组件的状态发生变化时，即使该状态是从像`*useQuery()*`或`*useContext()*`这样的定制钩子中获取的。
*   当组件的特性发生变化时。
*   当父组件重新呈现时，它会强制所有子组件重新呈现，特别是如果子组件没有用`memo`函数包装的话。

不必要的重新渲染会影响应用程序的性能，并导致用户电池的损耗，这肯定是没有用户想要的。让我们详细了解为什么组件会被重新渲染，以及如何防止不必要的重新渲染来优化应用程序组件。

> Redux 和其他状态管理工具如反冲试图用 React 构建一个优化的**观察者系统**。

一些工具有不同的术语和不同的数据结构，如图形和集合上的反冲继电器，Redux 是更简单的面向对象的工具，具有更高级的复杂变异减少器。

# 可观测系统

如果我们把可观察性系统看作一幅大图，可观察性系统是一种设计模式，将状态和观察者(有些人称之为订户)作为回调，当状态发生变化时，系统会自动通知这些注册的观察者。

**观察者设计有三个主要组件:**实例的状态或数据，作为堆栈回调的注册订阅者/观察者，以及一个可以改变状态的 mutator，mutator 不仅改变状态，还试图在状态改变时通知所有注册订阅者/观察者。

它与发布/订阅系统完全不同，发布/订阅系统允许设计定义特定事件，您可以向订阅者发送自定义参数或包含您需要的值的不同事件。

我们将在下一章尝试实现观察者系统，并将其与 React 绑定。

# 建筑可观测系统

谈论理论是伟大的，但让我们谈谈实施。正如我们之前提到的，观察器有三个主要组件:状态、赋值函数和订阅者/观察器。

显然，订阅者是一个接收一个属性引用(新状态)的回调，所以观察者接口应该有这些我们需要变异、订阅和检索状态的基本方法。

观察者界面。

观察者的基本流程是这样的，

*   `getState()`方法只是返回我们的状态。
*   `mutate()`方法改变我们的状态(例如，通过输入提交新用户)，然后运行`notify()`通知所有注册用户回调并传递新状态。
*   `subscriber()`当状态发生变化时，您可以注册我们的订户或回拨收听。

我知道您肯定想知道如何将其与 React 绑定，以便与我们的 React 组件进行通信。我们将在下一章和那一章讨论这个问题。

观察者类。

# 具有 React 的绑定可观测系统

反冲试图将观察者系统和 React 绑定 API 合并在同一个库中，其他工具如 Redux 试图将概念 [Redux](https://github.com/reduxjs/redux#basic-example) 作为状态管理和观察者分离在一个包中，并将绑定 Redux 的 [React-redux](https://github.com/reduxjs/react-redux) 分离在不同的包中。

该提供者的`ObserverProvider`将观察者类实例传递给所有子组件。该提供者接受`initialState`属性，将初始状态注入到将被传递给观察者的`Provider`中。

观察者对环境做出反应。

这里的观察者实例注入了`useRef`来避免与 React 反应系统的任何交互。`useRef`当组件的值发生变化时，不会通知组件，即使 ref 值发生变化，也不会导致任何重新渲染。

观察者反应提供者。

## useMutate()

基本上，mutate 钩子`useMutate`充当我们状态的 setter 函数，从提供者那里检索观察者实例，并使用`mutate`方法将新的突变状态发送给观察者。

如果你注意到这里我们用`useCallback`包装了箭头函数，以避免每次被挂钩的组件重新渲染时重新创建一个新函数。

useMutate()挂钩。

## 使用选择器()

显然，选择器钩子`useSelector`为我们的观察者充当了一个 getter 函数，但是有一些不同。

尝试将观察者状态与钩子内部的 React 本地状态同步，这样就能够与被钩住的 React 组件进行通信和交互。

在第一行中，我们将 Observer 的初始状态注入 React 状态，然后订阅 Observer 以在状态发生变化时进行监听，并将订阅封装在`useEffect`中，以避免被挂钩的组件重新呈现时的任何撤销，最终检索 React 状态。

如果您尝试对最流行的 React 状态管理工具的工作方式进行逆向工程，您会看到它们的核心设计围绕着该设计模式，一些工具具有高级功能，如 Redux 中管理变异复杂性的 reducers 和反冲中的选择器图依赖。

**资源**

[观察者(refactoring . guru)](https://refactoring.guru/design-patterns/observer)
[**文章的完整代码**](https://codesandbox.io/s/observer-system-binded-react-eyniy0?file=/src/App.tsx)

```
**Want to Connect?**Twitter: [twitter.com/bouhuolia](http://twitter.com/bouhuolia)
Github: [github.com/abouolia](http://github.com/abouolia)
```