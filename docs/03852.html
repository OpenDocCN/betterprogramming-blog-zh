<html>
<head>
<title>Check if an Array Is Within a 2D Array Using JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript检查数组是否在2D数组中</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/check-if-an-array-is-within-a-2d-array-using-javascript-c534d96cb269?source=collection_archive---------9-----------------------#2020-03-09">https://betterprogramming.pub/check-if-an-array-is-within-a-2d-array-using-javascript-c534d96cb269?source=collection_archive---------9-----------------------#2020-03-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8027" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用算法解决引用传递问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/52379bea3de8da8265abbf144eb9710b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*67wJVZtzRlKvf3ao"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">劳拉·奥克尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="fdb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些时候，您可能遇到过比较数组的问题。由于按引用传递，我们不能简单地检查<code class="fe lv lw lx ly b">[1,2,3]</code>是否与<code class="fe lv lw lx ly b">[1,2,3]</code>相同。</p><p id="b9b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我试图解决一个Leetcode问题，目标是从一个给定的数组中得到所有的排列(可能的字符顺序)时，这对我来说是一个问题。我能够随机化我的数组，但是我不确定如何将它们放入另一个数组中一次，这是解决方案所要求的。</p><p id="8e82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论解决这一困境的方法。通过遍历一个数组并比较相同索引处元素的值，我们可以看到它们是否真正相同。我想出了一个解决办法。它可能会被优化，但它的工作方式对我来说很简单，我会在深入研究时回顾一下我构建它的基本原理。我还将回顾我为减少运行时间而做的一些优化。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9389" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">引用传递的问题是</h1><p id="21e1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在JavaScript中，引用传递会造成一个独特的问题。即使对象具有完全相同的值，它们也永远不会在传统意义上彼此相等(也就是看是否<code class="fe lv lw lx ly b">a===b / a==b</code>)。</p><p id="9ff1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为对象驻留在不同的内存地址中，这意味着除非一个对象是另一个对象的实例，否则它不会与另一个对象相等，即使它们拥有完全相同的值。</p><p id="6c3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请考虑以下情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b8d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管<code class="fe lv lw lx ly b">arr1</code>和<code class="fe lv lw lx ly b">arr2</code>看起来是同一个东西，但它们在内存中的地址是不同的。由于JavaScript的设置方式，几乎不可能打印出<em class="nf">数组在内存中的实际位置，但是这里需要注意的是它们位于不同的区域。</em></p><p id="83ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当我们使一个变量引用另一个变量时，那个副本引用内存中的同一个地址，这就是为什么<code class="fe lv lw lx ly b">arr1</code>与其副本相同。</p><p id="b509" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这并不能真正帮助我们比较内存地址不同的数组，这是通常的情况。那么，如何才能解决这个问题呢？</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f403" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用迭代顺序比较每个值</h1><p id="d38d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们必须采取更有条理的方法来进行数组比较。我们可以这样做的一个方法是检查给定索引处每个数组的值。我们将不得不在逐次逼近中确定它们的相同性。</p><p id="54e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个示例数组:</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="78f1" class="nk mh it ly b gy nl nm l nn no">let arr1 = [[3,2,1],[2,1,3],[1,2,3]]</span></pre><p id="55a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个要测试的数组，看看它是否包含在上面的2D数组中:</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="e055" class="nk mh it ly b gy nl nm l nn no">let test = [1,2,3]</span></pre><p id="010d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何测试<code class="fe lv lw lx ly b">[1,2,3]</code>是否在数组中？我们已经知道，我们不能简单地看是否<code class="fe lv lw lx ly b">[1,2,3] === [1,2,3]</code>，因为它总是假的，因为数组是按引用传递的。这意味着，即使数组中的值相同，它们也永远不会相等，因为它们位于不同的内存地址。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="86aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们这里有一个名为<code class="fe lv lw lx ly b">checker</code>的数组，用来记录给定索引处数组的值是否相同。每次比较这些值时，都会有一个布尔值传递给它。因此，如果<code class="fe lv lw lx ly b">checker</code>只包含<code class="fe lv lw lx ly b">true</code>，这意味着每个索引在两个数组中都有相同的值。</p><p id="8a22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以对于<code class="fe lv lw lx ly b">arr1</code>，我们比较<code class="fe lv lw lx ly b">[3,2,1]</code>和<code class="fe lv lw lx ly b">[1,2,3]</code>。首先，我们查看是否有<code class="fe lv lw lx ly b">3 === 1</code>，它没有，所以我们将<code class="fe lv lw lx ly b">false</code>推送给我们的检查器。现在，checker中还会出现什么已经不重要了，因为我们已经有了一个<code class="fe lv lw lx ly b">false</code>。重要提示:参考下面的重构部分，看看我们如何利用这个事实来优化我们的运行时。</p><p id="f846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在将数组中的每个索引与测试数组进行比较之后，我们评估<code class="fe lv lw lx ly b">checker</code>以查看它的所有检查是否都为真。如果是，我们知道数组有完全相同的值，可以通过返回<code class="fe lv lw lx ly b">true</code>退出函数。</p><p id="1bd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe lv lw lx ly b">checker</code>中有一个错误，我们知道数组中有一些索引没有相同的值。我们将<code class="fe lv lw lx ly b">i</code>加1，并继续移动到2D数组中的下一个数组。</p><p id="77a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，我们到达了2D数组中的<code class="fe lv lw lx ly b">[1,2,3]</code>。我们比较这些指数:</p><ul class=""><li id="6d55" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">因此我们将true推给我们的检查器。</li><li id="c978" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">因此我们将true推给我们的检查器。</li><li id="c091" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">因此我们将true推给我们的检查器。</li></ul><p id="2346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以看看<code class="fe lv lw lx ly b">checker</code>是否为真。确实如此，这意味着<code class="fe lv lw lx ly b">[1,2,3]</code>已经存在于数组中。厉害！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e209" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">重构我们的解决方案</h1><p id="7bdb" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">上面的解决方案是可行的，但是每次我们做比较时都要构建一个检查数组，这有点昂贵。当我们开始处理大型数组时，我们可能真的会增加它运行的时间！</p><p id="6b06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个真正简单的重构利用break关键字来逃离内部循环。我们也可以将<code class="fe lv lw lx ly b">checker</code>设置为一个布尔值，稍后再评估它的值。如果在任何时候我们从比较结果中得到<code class="fe lv lw lx ly b">false</code>，我们可以在重置<code class="fe lv lw lx ly b">checker</code>的值后停止内部循环的运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="af09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是大多数情况下将要发生的事情，因此我们可以在循环中花费更少的时间，并放弃进行一系列检查。我在本文前面说过，我们只关心在<code class="fe lv lw lx ly b">checker</code>数组中有一个<code class="fe lv lw lx ly b">false</code>的时候。我们仍然在利用这种逻辑，只是我们更加切题了。一旦我们遇到<code class="fe lv lw lx ly b">false</code>，我们就可以继续前进，因为我们已经确定这两个数组不是完美的匹配。</p><p id="598b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们退出内循环的速度要比之前的算法快得多。我们仍然在每次通过外部循环时检查<code class="fe lv lw lx ly b">checker</code>的值，如果为真，则提前终止。然而，这一次要快得多，因为我们只是看看它是真还是假，而不是我们以前做的迭代过程。</p><p id="08e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于向<code class="fe lv lw lx ly b">permutations</code>数组添加独特的东西来说是很棒的，因为随着<code class="fe lv lw lx ly b">permutations</code>数组的增长，我们将会得到很多<code class="fe lv lw lx ly b">true</code>的情况。通过确定一个数组已经在其中，我们可以更快地移动它来测试下一个数组是否在其中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9d94" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="0660" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">至此，我们已经讨论了一种比较数组的方法，通过遍历数组的内容来解决引用传递的问题。我们还提到了2D数组和重构方法，比如利用关键字<code class="fe lv lw lx ly b">break</code>和在循环过程中组合条件关键字和关键字<code class="fe lv lw lx ly b">return</code>。以此为指导，尝试一些你自己的练习。</p><p id="ae40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>