<html>
<head>
<title>The Basics of Android Unit Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android单元测试的基础</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/android-unit-testing-basics-78a04a66124a?source=collection_archive---------10-----------------------#2022-01-22">https://betterprogramming.pub/android-unit-testing-basics-78a04a66124a?source=collection_archive---------10-----------------------#2022-01-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fbde" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建无bug的Android应用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e3f2a9cd1e4183a75be4e756759d13d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iLrFaSTu2rH3wmsM"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@adrien?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿德里安</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="68fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下，我们想要建造一座房子，我们将需要许多不同职业的工人，他们每个人都做着自己的工作。例如，电工实施电气基础设施住宅，橱柜制造商设计和建造橱柜，等等。</p><p id="d381" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他们每个人都做了自己的工作(让我们称之为单元)，也确保它工作良好(测试)。将来，如果某些设备需要维护，我们将呼叫特定的专家来维护该设备，并确保其正常工作。</p><p id="e814" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在软件开发中，我们有相同的想法。我们有单元，每个单元做一些工作，我们需要确保这些单元工作良好(如预期)。所以单元测试在这里发挥了作用。</p><h1 id="7c0a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">什么是单元测试</strong></h1><p id="08ff" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">单元:单元是软件系统的一个可测试部分(oop语言中的一个类)。</p><p id="187e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试:验证该单元是否按预期工作。</p><p id="24d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，作为一个术语，单元测试就是验证每个单元都按预期工作。</p><p id="fa5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，一个Android项目包括:</p><ul class=""><li id="90ad" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><strong class="ky ir">单位:</strong>也就是我们平时写的生产代码，或者正常代码。</li><li id="f585" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><strong class="ky ir"> Test: </strong>测试那些单元的测试类。</li></ul><h1 id="e226" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">单元测试优势</strong></h1><blockquote class="nd ne nf"><p id="a13d" class="kw kx ng ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">"正是单元测试使我们的代码保持了灵活性、可维护性和可重用性."</p><p id="f4e4" class="kw kx ng ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">罗伯特·c·马丁，干净的代码:敏捷软件工艺手册</em> </strong></p></blockquote><p id="70ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">灵活易维护！<em class="ng"> </em>这是怎么回事？简单地说，我们可以更改产品代码，而不用担心更改会影响代码的其他部分。你会自信地改变。</p><p id="eba1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，当改变现有功能时，它将减少成本和错误。</p><p id="462a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可重用，当我们编写单元测试时，特别是如果我们使用<a class="ae kv" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank"> TDD(测试驱动开发)</a>，我们被迫保持我们的代码松散耦合，因此可重用。</p><p id="49df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，如果单元测试是干净的，它将是系统的非常好的文档。</p><p id="727a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你不认为在你的代码中开始使用单元测试是值得的吗？让我们举个例子。</p><h1 id="bd4a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">第一个单元测试示例</h1><p id="b757" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们有一个想要测试的计算器类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5ae6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我有意隐藏了实现，所以我们在编写它的测试时不会偏向它。</p><p id="25f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个非常简单的例子，在一个复杂的例子中，如果你在写单元测试之前看到生产代码的实现，你会发现你自己在单元测试中写bug是一个需求。</p><p id="931d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，在你写单元测试之前，不要去看实现。相反，您可以从方法的名称、参数和返回类型来预测方法的作用。</p><p id="c0a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们为Calculator创建一个测试类。我们可以通过右击您的<code class="fe nm nn no np b">class -&gt; Generate -&gt; Test</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/1f89f062feea05be965c803121efba37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VrPrZsWadDQoHcp7Zm8nFw.png"/></div></div></figure><p id="bfa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后选择<a class="ae kv" href="https://en.wikipedia.org/wiki/JUnit" rel="noopener ugc nofollow" target="_blank"> JUnit4 </a>。我们将使用它，因为它是最流行的版本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/4141bae15961d811b952b5635ba6c497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cNLFTnKGWyVBWKKYPHQwsA.png"/></div></div></figure><p id="1083" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在点击ok，选择测试包(不是<code class="fe nm nn no np b">androidTest</code>包)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/1c5a8c42e5056d7b53245bbf6bad26e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7z-SJK-jlPn4TcG0NYsWtg.png"/></div></div></figure><p id="12a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随后，Android Studio将生成一个<code class="fe nm nn no np b">CalculatorTest</code>作为空类。我们将使用JUnit库来测试我们的类。</p><p id="c8d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JUnit是Java编程语言的一个单元测试框架。</p><p id="1d1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里！我还添加了一些被覆盖的方法，我们稍后会解释。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><ul class=""><li id="59d2" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><code class="fe nm nn no np b">@Test</code>:表示以下方法为测试方法。</li><li id="2f67" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><code class="fe nm nn no np b">@Before</code>:每次测试前进行。</li><li id="23bd" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><code class="fe nm nn no np b">assertEquals</code>:检查预期结果与实际结果是否一致。如果是，则测试将通过，否则测试将失败。</li><li id="98b9" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><code class="fe nm nn no np b">sut</code>:代表被测系统，表示我们要测试的类。</li></ul><p id="5855" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，我们在<code class="fe nm nn no np b">setUp()</code>方法中初始化了我们想要的<code class="fe nm nn no np b">test (sut)</code>类。<br/>然后我们调用<code class="fe nm nn no np b">testAdd()</code>方法中的<code class="fe nm nn no np b">sut.add()</code>，并通过<code class="fe nm nn no np b">assertEquals()</code>方法取其结果(<code class="fe nm nn no np b">actual</code>)与期望值进行比较。</p><p id="7b48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们运行这个测试来看看结果。要运行测试，您可以如下图所示</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/df44782578f8981844d96800df44938c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-CI3az4nV_xadK1pOYLPQ.png"/></div></div></figure><p id="b6c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将仅对当前方法运行测试。此外，您可以点击类旁边的图标来运行类中的所有测试方法。</p><p id="2f93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/ee4903dff03a8c78cae1a08bb280dca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u1AFC3T8b9jOeaQCMGLUZw.png"/></div></div></figure><p id="0ad1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所看到的，预期结果与实际结果不同，这意味着我们的实现中有一个bug。现在让我们回到<code class="fe nm nn no np b">Calculator</code>类，看看它的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0d03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们可以简单地通过返回x + y来解决这个问题。</p><p id="1032" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以修复后的<code class="fe nm nn no np b">Calculator</code>类将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5898" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在修复错误后重新运行测试</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/82b84034999a2c0a85931f46ef24103f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CaNWlRD3_X89PmyVJbWYwQ.png"/></div></div></figure><p id="d76e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们的测试通过了。</p><p id="eb4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使我们的代码灵活、可维护和可重用，我们可以使用单元测试。这可能需要更多的时间和努力。但是这会节省我们以后的时间，也会给我们带来它所有的好处。</p></div></div>    
</body>
</html>