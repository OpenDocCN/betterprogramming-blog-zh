# 通过合成更好的 Swift 可编码模型

> 原文：<https://betterprogramming.pub/better-swift-codable-models-through-composition-a6b109b7e8c7>

![](img/8e8821dd8dbac830e2cb24998da9fa98.png)

Iker Urteaga 通过 Unsplash 拍摄的照片

想象一下，我们想要建立一个应用程序来跟踪书籍。我们正在构建的 API 为作者和书籍提供了 JSON，如下所示:

Swift 的`Codable`功能使我们能够快速创建匹配的模型:

多亏了`Codable`,这就是我们免费获得到类型安全模型的 JSON 映射所要做的一切！

然而，随着我们的进展，有几个微妙的问题可能会导致问题。`identifier` s 被定义为`String` s。这并没有*错*，但是它可能会导致这样一个场景:

这将会编译，尽管调用点*看起来*正确，但它永远不会返回任何东西，因为函数需要的是作者的标识符，而不是他们的名字。让我们看一个类型，我们可以用它来代替`String`来提高这里的类型安全性。

# 标识符

我们不能改变服务器向我们发送`String`的事实，但是我们可以使用包装器和幻影类型来改变这些字符串在本地的表示方式。

通常当我们定义一个类似于`Identifier<T>`的泛型类型时，我们也会在类型的其他地方使用那个`T`，类似于`let value: T`。然而，当`T`仅作为声明的一部分出现时，它被称为*幻象类型*。

那还有什么意义呢？如果我们不使用类型，为什么要让一些东西通用呢？嗯，我们实际上*在*使用类型，只是不是以通常的方式。让我们来看看:

更新我们的模型以使用这种新类型，它们变成:

我们的功能现在变成了:

我们现在已经不可能错误地通过一个`String`。我们*必须*提供一个`Identifier<Author>`来代替；否则，即使它们都在下面，它也不会编译。

这就是幻影类型如此有用的原因。在这种情况下，我们使用通用占位符将类型安全添加到普通的`String`中。我们现在不仅可以将`Identifier<T>`用于我们的`Book`和`Author`模型，还可以用于任何其他带有标识符的模型。

# 可编码支持

我们在`Identifier<T>`中引入了一个新问题。默认情况下，`Codable`使用与类型相同的结构。这意味着标识符的 JSON 表示应该是:

这是错误的:我们仍然希望 JSON 表示是一个`String`,这样它就可以与我们的 API 无缝协作。让我们按如下方式修复`Codable`行为:

现在，当我们在模型和 JSON 之间转换时，它将是一个常规的`String`，而不是一个嵌套的对象。

# 向 API 添加新数据

列出书籍和作者非常有效。现在是时候允许我们的用户提交新的条目了。唯一的问题是我们的 API 负责确定新数据的标识符，所以我们想发送包含所有内容的 JSON，除了对象标识符。

有两种不同的方法可以解决这个问题:

*   我们可以保持一个独立的模型，不包括`Identifier`。这将是乏味和脆弱的，但也许我们可以利用一个 codegen 解决方案来帮助？如果你还没有使用它，这是一个很大的依赖项。
*   我们可以提供一个伪标识符，并在将它发送给我们的 API 之前将其从 JSON 中移除。不过，这不是一个很好的解决方案——在产品代码中使用虚拟值似乎只是在乞求破坏和/或损坏东西。

既然我们今天正在创建新的类型，那么让我们来看看另一个可以用来解决这个问题的类型。

# 已识别

我们需要一种方法来定义我们的模型的两个版本:一个在数据向下发送时带有`Identifier`,另一个在数据向上发送时没有`Identifier`。

我们不能使用类型系统来删除属性……但是我们可以用它来为 T21 添加属性。

使用这个类型，我们可以从我们的模型中删除`identifier`属性:

然后我们可以定义我们需要的模型的两个版本。当我们从 API 接收书籍时，我们可以对每个实例使用`Identified<Book>`。当我们想添加一本新书时，我们可以简单地使用`Book`。

拥有像`Identified<T>`这样的类型给了我们想要的灵活性，而不需要维护并行模型或者在发送数据之前去掉不需要的值。

# 可编码支持

与`Identifier<T>`一样，`Identified<T>`的默认`Codable`行为会导致错误的 JSON:

我们需要修复`Codable`的行为，以便所有东西在 JSON 形式下仍然是扁平的:

`AnyCodingKey`类型用于允许我们动态解码数据的某些部分，而不需要所有新的类型:

# 结论

有很多方法可以给猫换肤，但是希望本文展示了一些有趣的方法，使用包装器类型和一些漂亮的 Swift 特性来解决一些常见问题。

还有很多可以改进这些类型的人体工程学的附加功能，例如:

*   `ExpressibleBy*`一致性
*   `String`以外的支持价值观

但是我将把这些留给读者作为练习。🤘

你可以在这里获取游乐场就绪代码[。](https://gist.github.com/IanKeen/788e2ce55e5c91257bc639efc5dbb1c1)

如果你有任何反馈，请在这个帖子上留言或回复。