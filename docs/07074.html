<html>
<head>
<title>The 4 Types of Memory Leaks in Node.js and How to Avoid Them (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中的4种内存泄漏类型以及如何避免它们(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-4-types-of-memory-leaks-in-node-js-and-how-to-avoid-them-part-2-f21fbda5c33b?source=collection_archive---------1-----------------------#2020-12-04">https://betterprogramming.pub/the-4-types-of-memory-leaks-in-node-js-and-how-to-avoid-them-part-2-f21fbda5c33b?source=collection_archive---------1-----------------------#2020-12-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="de25" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看看缓存和承诺中的内存泄漏</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6b2715e946bce185becad66456c367bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IfE8RTxDppOVAIUh"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@pawel_czerwinski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">paweczerwi324ski</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="bdd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正处于软件的黄金时代。我们什么都有工具。我们有制造工具的工具。我们将核心系统构建成高级产品。但是有一件事在所有级别上都是常见的:臭名昭著的内存泄漏。这并不总是代码中的错误；有时不理解运行时的行为也会导致这种情况。</p><p id="9a31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里讨论的运行时是Node.js。我已经在第一部分中写了其中的两个。在第2部分中，我们将探索另外两种类型。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="87d7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">4种类型的内存泄漏</h1><ul class=""><li id="3b2a" class="mr ms iq ky b kz mt lc mu lf mv lj mw ln mx lr my mz na nb bi translated">全球资源</li><li id="e520" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">关闭</li><li id="d011" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">贮藏</li><li id="384a" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">承诺</li></ul><p id="3502" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天我们将重点讨论缓存和承诺。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="2a2c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">贮藏</h1><p id="c8a9" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">缓存是Node中最常见的内存泄漏类型。我个人不喜欢磁盘缓存；我总是更喜欢专用的解决方案。但是由于这个问题让很多开发人员感到头疼，所以让我们通过一个简单的例子来看看缓存是如何导致内存泄漏的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="cec0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们运行以下代码:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="8812" class="nr ma iq nn b gy ns nt l nu nv">clinic doctor --on-port 'autocannon -w 300 -c 100 -d 30 localhost:3000' -- node server.js</span></pre><p id="f262" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于这个负载测试如何工作，请参考第1部分，但是基本上，我们使用<a class="ae kv" href="https://github.com/mcollina/autocannon" rel="noopener ugc nofollow" target="_blank">auto canon</a>进行负载测试，使用<a class="ae kv" href="https://clinicjs.org/" rel="noopener ugc nofollow" target="_blank"> Clinic.js </a>进行内存图分析。让我们看看我们得到了什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/9aca9aa70fd2c5618d036f561bae4107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1OQ5ukF7Lg8qpHYi3Yo2g.png"/></div></div></figure><p id="6ef6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">内存增长很快。让我们看看脚本中发生了什么。我们知道函数是JavaScript中的对象，我们利用它来存储缓存的值。我们在缓存中存储一个1KB的缓冲区对象，并使用随机数作为缓存的密钥。让我们进行一次堆转储来检查什么在泄漏。(第1部分解释了堆转储过程。)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/73870dae2795affd39f6e63205e45231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ULn3BHTr2uNoWXE_71wvxQ.png"/></div></div></figure><p id="de48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到所有的缓冲区对象都在内存和<code class="fe ny nz oa nn b">computeTerm</code>缓存中。缓存泄漏内存的原因是我们没有定期清除缓存。解决方法是在超时后释放内存。就这么办吧。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c1b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在一秒钟后清除缓存，即所有缓存对象在内存中停留一秒钟，我们可以访问它们，但在此之后，它们会被清除。我们使用一秒钟，因为我们的程序只会运行30秒钟，所以存储更多不会让我们显示解决方案的工作。这不是理想的解决方案，但它可以显示如何着手处理泄漏。让我们再次进行负载测试，并在临床报告中检查结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/59f52cc0dbf45b94ec7ac52dbde8ee19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-r12FIOefEr9xOZsEnjaQ.png"/></div></div></figure><p id="aadd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到内存增加了，但不是在我们释放缓存的时候。漂亮又漂亮！我们需要确保在一段时间后释放缓存，这样它就不会占用内存空间。</p><p id="ad29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过使用像LRU缓存这样更完整的缓存机制来改进这个解决方案。但是我们今天不去了。一个不在机器内存中存储缓存的更合适的健壮的解决方案是使用专用的缓存服务器，如<a class="ae kv" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>或<a class="ae kv" href="https://aws.amazon.com/memcached/" rel="noopener ugc nofollow" target="_blank"> Memcached </a>。我们将在后面的文章中探讨这一点。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="eef9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">承诺</h1><p id="3f17" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">承诺对未来有帮助。如果有一个函数在未来运行，一个承诺会给我们一个句柄，这样当它结束时，我们就可以对响应做一些事情，或者执行程序的其他部分。处理承诺时有一点很重要:</p><blockquote class="ob oc od"><p id="0c88" class="kw kx oe ky b kz la jr lb lc ld ju le of lg lh li og lk ll lm oh lo lp lq lr ij bi translated"><strong class="ky ir">承诺存储在内存中，直到被处理或拒绝后才被清除</strong></p></blockquote><p id="f31c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一个简单的场景，承诺可能需要更长的时间来解决，并留在记忆中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8807" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们有一个任务承诺，在一定的等待期后得到解决。我们向任务函数发送100毫秒到20秒之间的随机数，以解决承诺问题。对于每个请求，我们都会创建一个承诺，在100毫秒到20秒内得到解决。让我们对此进行负载测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/630d5f28c3acad3fe672c4e86be9a3bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2aKSvCzDQcNtO1pD9oWozQ.png"/></div></div></figure><p id="e2dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到记忆稳步增长。但是如果承诺在一段时间后被解决，为什么记忆会增加？因为承诺停留在记忆里。我们不能永远跑下去，等待承诺的解决。如果他们永远无法解决呢？让我们看看堆转储，以确认这是事实。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/fbb5d69e67b8ee5a13d55a1a531f34ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zyuLjRrk4MPdQ5bq7yBoGQ.png"/></div></div></figure><p id="2e7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在快照中清楚地看到，承诺就在记忆中。这个项目停止了，但是那些从未得到解决的承诺留在了记忆中。解决办法是限制承诺的执行时间以及之后的超时时间。此外，在生产中，我们应该跟踪这些承诺及其任务，以便可以重新启动它们。但在这里，让我们看看我们如何解决这个问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7181" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用的是<code class="fe ny nz oa nn b">Promise.race</code>，一个函数，如果一个数组中的任何承诺被解析，它就会拒绝未被解析的承诺。我们可以创建一个<code class="fe ny nz oa nn b">timeout</code>承诺，这是承诺允许运行的最长时间。这里是500毫秒，然后它会返回。让我们看看这是否能解决我们的记忆问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/0582691c6b5620dd6737cddea51752ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TjTLUj-OWTBSug5gExWn5g.png"/></div></div></figure><p id="7a20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到内存正在被分配，但是因为有一个超时，它在一定的持续时间后被释放。为长时间运行的任务提供超时功能并处理承诺拒绝总是好的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7dae" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="5f11" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们已经了解了缓存和承诺是如何泄漏内存的。在两个教程中，我们了解了Node中四种最常见的内存泄漏类型。这些例子当然很短，只显示了演示泄漏场景所需的部分。在现实世界中，漏洞隐藏在数百行代码中。但是，有一个坚实的理解可以帮助我们跟踪那些讨厌的泄漏，而不需要太多的挠头。</p><p id="f594" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">项目链接:<a class="ae kv" href="https://github.com/Joker666/nodejs-memory-leak" rel="noopener ugc nofollow" target="_blank">https://github.com/Joker666/nodejs-memory-leak</a></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ccb6" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">资源</h1><ul class=""><li id="c56b" class="mr ms iq ky b kz mt lc mu lf mv lj mw ln mx lr my mz na nb bi translated"><a class="ae kv" href="https://www.alxolr.com/articles/understanding-memory-leaks-in-node-js-part-1#promises" rel="noopener ugc nofollow" target="_blank">https://www . alxolr . com/articles/understanding-memory-leaks-in-node-js-part-1 # promises</a></li><li id="abd3" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><a class="ae kv" href="https://www.alxolr.com/articles/understanding-memory-leaks-in-node-js-part-2#cached-objects" rel="noopener ugc nofollow" target="_blank">https://www . alxolr . com/articles/understanding-memory-leaks-in-node-js-part-2 # cached-objects</a></li></ul></div></div>    
</body>
</html>