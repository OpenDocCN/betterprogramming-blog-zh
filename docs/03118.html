<html>
<head>
<title>Why We Stopped Using So-Called Best Practices in Our CI/CD Process</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我们在CI/CD流程中不再使用所谓的最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-we-stopped-using-so-called-best-practices-in-our-ci-cd-process-2ff09811f633?source=collection_archive---------16-----------------------#2020-01-21">https://betterprogramming.pub/why-we-stopped-using-so-called-best-practices-in-our-ci-cd-process-2ff09811f633?source=collection_archive---------16-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3ebf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">或者回避npm和否定Google Play流程的理由</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1b41497574a5f1f9b253893cbf773a12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ctHE_pU_3W2dWOFypEIqw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的Kano应用程序的截图</p></figure><h1 id="899c" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">序文</h1><p id="c545" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在<a class="ae mm" href="https://kalisio.com/" rel="noopener ugc nofollow" target="_blank"> Kalisio，</a>我们开发开源地理空间软件——也就是说，管理地理定位资产的软件，但比地理信息系统通常提供的方式更加友好和面向商业。我们已经建立了一个由各种工具和应用组成的强大生态系统，提供数十种web服务来交付我们的SaaS解决方案:</p><ul class=""><li id="bcf9" class="mn mo it ls b lt mp lw mq lz mr md ms mh mt ml mu mv mw mx bi translated"><a class="ae mm" href="https://kalisio.github.io/kaabah/" rel="noopener ugc nofollow" target="_blank"> Kaabah </a>，一个构建和运营Docker群基础设施的解决方案</li><li id="b513" class="mn mo it ls b lt my lw mz lz na md nb mh nc ml mu mv mw mx bi translated"><a class="ae mm" href="https://kalisio.github.io/kargo/" rel="noopener ugc nofollow" target="_blank"> Kargo </a>，一个基于Docker的部署地理空间服务的解决方案</li><li id="3875" class="mn mo it ls b lt my lw mz lz na md nb mh nc ml mu mv mw mx bi translated">一个极简的提取-转换-加载(ETL)工具</li><li id="ecd9" class="mn mo it ls b lt my lw mz lz na md nb mh nc ml mu mv mw mx bi translated">Weacast是一个收集、发布和利用天气预报数据的平台</li><li id="2df5" class="mn mo it ls b lt my lw mz lz na md nb mh nc ml mu mv mw mx bi translated"><a class="ae mm" href="https://kalisio.github.io/kdk/" rel="noopener ugc nofollow" target="_blank"> KDK </a>，一个简化构建地理空间网络应用的开发工具包</li><li id="4c64" class="mn mo it ls b lt my lw mz lz na md nb mh nc ml mu mv mw mx bi translated"><a class="ae mm" href="https://kalisio.github.io/kdk/api/kano/" rel="noopener ugc nofollow" target="_blank"> Kano </a>，2D/3D地图和天气预报数据浏览器</li><li id="1dc1" class="mn mo it ls b lt my lw mz lz na md nb mh nc ml mu mv mw mx bi translated"><a class="ae mm" href="https://aktnmap.com/" rel="noopener ugc nofollow" target="_blank"> Akt'n'Map </a>，一款管理赛场实时事件的应用</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/2ac8a415fb5a3dab75948eea0f690900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/0*q2v4CyX97Iw_ezB2.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们平台的高级视图</p></figure><p id="7c87" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">像<a class="ae mm" href="https://kalisio.github.io/kdk/api/kano/" rel="noopener ugc nofollow" target="_blank"> Kano </a>或<a class="ae mm" href="https://aktnmap.com/" rel="noopener ugc nofollow" target="_blank"> Akt'n'Map </a>这样的应用已经被开发为一组松散耦合的模块，使用<a class="ae mm" href="https://kalisio.github.io/kdk/" rel="noopener ugc nofollow" target="_blank"> KDK </a>来防止构建一个<a class="ae mm" href="http://whatis.techtarget.com/definition/monolithic-architecture" rel="noopener ugc nofollow" target="_blank">单片软件</a>，确保<a class="ae mm" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank"> s </a>关注点分离(SoC ),并简化维护，至少从源代码的角度来看是这样的。</p><p id="8821" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">此外，我们通过这些解决方案的不同实例(例如配置)来管理专用基础架构，以便能够同时运行我们自己的生产版本、测试版本和测试版本，以及为我们的一些客户定制的版本。因此，我们需要依赖一个可预测的和自动化的过程来发布我们的应用程序。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="9d6a" class="ky kz it bd la lb no ld le lf np lh li jz nq ka lk kc nr kd lm kf ns kg lo lp bi translated">CI/CD管道</h1><p id="bf09" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">持续集成和部署(CI/CD)管道的主要目的是创建/构建应用程序工件(web应用程序和移动应用程序包的Docker映像),并将它们部署到类似生产的环境中，以便使用/测试它们。</p><p id="918f" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">我们的CI/CD管道如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/329d42224e5defa90847b0cd6680216b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mZinOP-LKi1XEVsW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的CI/CD渠道</p></figure><p id="c830" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">每个阶段执行的不同操作如下:</p><ul class=""><li id="2abc" class="mn mo it ls b lt mp lw mq lz mr md ms mh mt ml mu mv mw mx bi translated"><strong class="ls iu">构建</strong>:检索源代码以创建Docker映像来运行web应用程序</li><li id="9ffe" class="mn mo it ls b lt my lw mz lz na md nb mh nc ml mu mv mw mx bi translated"><strong class="ls iu">测试</strong>:使用应用映像运行后端和前端测试</li><li id="4b40" class="mn mo it ls b lt my lw mz lz na md nb mh nc ml mu mv mw mx bi translated"><strong class="ls iu">部署</strong>:使用应用映像在目标基础设施上部署web应用</li><li id="39ca" class="mn mo it ls b lt my lw mz lz na md nb mh nc ml mu mv mw mx bi translated"><strong class="ls iu"> ANDROID </strong>:构建Android APK并将其部署到Google Play</li><li id="2601" class="mn mo it ls b lt my lw mz lz na md nb mh nc ml mu mv mw mx bi translated"><strong class="ls iu"> IOS </strong>:构建iOS IPA并将其部署到App Store Connect</li></ul><p id="88c6" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">到目前为止，一切顺利——这似乎很简单，不是吗？</p><p id="0058" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">然而，正如下文所解释的，我们很难让它在引擎盖下顺利工作。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="3d53" class="ky kz it bd la lb no ld le lf np lh li jz nq ka lk kc nr kd lm kf ns kg lo lp bi translated">当一些最佳实践被打破时</h1><h2 id="0e75" class="nu kz it bd la nv nw dn le nx ny dp li lz nz oa lk md ob oc lm mh od oe lo of bi translated">包管理器</h2><p id="5376" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><a class="ae mm" href="https://nodejs.org/en/knowledge/getting-started/npm/what-is-npm/" rel="noopener ugc nofollow" target="_blank"> npm </a>是用Node.js管理模块的事实上的解决方案。它很简单，对于独立的生产级模块非常有效。</p><p id="7171" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">然而，在开发过程中管理包时，它有一些缺点，特别是在大型生态系统中。</p><p id="baf2" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">首先，使用未发布的(例如，开发中的)包的过程与使用已发布的包的过程非常不同。虽然在第二种情况下，一个简单的<code class="fe og oh oi oj b">npm install</code>就足以获得完整的依赖关系树，但是在第一种情况下，您需要克隆当前正在开发的依赖关系树的所有存储库，并<a class="ae mm" href="https://docs.npmjs.com/cli/link" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="fd5a" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">第二，由于链接过程发生在Node.js安装的全局级别，所以在您的环境中不容易拥有同一个模块的多个版本。</p><p id="961a" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">最后，当你有一个很大的依赖树并发布深层模块时，你必须在所有依赖模块上执行升级操作，这可能是痛苦的。事实上，如果你想有可预测的版本。你必须依靠<a class="ae mm" href="https://docs.npmjs.com/files/package-locks" rel="noopener ugc nofollow" target="_blank">锁文件</a>。当处理大型代码库时，这意味着必须在几十个存储库之间进行更改。</p><p id="e608" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated"><strong class="ls iu">注意:</strong>由于<code class="fe og oh oi oj b">npm</code>管理链接模块的方式<a class="ae mm" href="http://codetunnel.io/npm-5-changes-to-npm-link/" rel="noopener ugc nofollow" target="_blank">发生了一些变化</a>，我们实际上更喜欢使用<a class="ae mm" href="https://yarnpkg.com/" rel="noopener ugc nofollow" target="_blank"> Yarn </a>作为包管理器，但这并不限制本分析的范围。</p><h2 id="5730" class="nu kz it bd la nv nw dn le nx ny dp li lz nz oa lk md ob oc lm mh od oe lo of bi translated">应用商店</h2><p id="1af7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">应用商店实际上是为本地应用而设计的，而不是基于网络的应用，在基于网络的应用中，前端(例如客户端)和后端(例如服务器)是物理分离的。</p><p id="3c0d" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">因此，发布应用的自然过程是将相同的应用捆绑包(例如，APK或IPA)从一个发布状态(例如，私有alpha发布)提升到下一个发布状态(例如，公共beta发布)。这意味着您不能根据发布状态更改包的默认配置。</p><p id="a1f3" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">由于您的客户端应用程序至少应该能够在不连接到您的服务器的情况下运行(在这种情况下，因为用户没有将浏览器指向正确的服务器URL)，例如，很自然地将目标服务器URL作为其配置的一部分。</p><p id="8b19" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">但是，如果您的不同版本有不同的端点，那么您必须依靠固定的第三方服务器来中继请求(不简单)或内置的GUI来允许用户更改目标服务器URL(容易出错，并且不是真正的用户友好)。更具挑战性的是，你在任何时候都只能安装一个版本的应用程序，因为所有这些应用程序都共享同一个应用程序ID。如果您的一些用户正在使用alpha版本，他们就不能再使用产品版本了。</p><h2 id="c079" class="nu kz it bd la nv nw dn le nx ny dp li lz nz oa lk md ob oc lm mh od oe lo of bi translated"><strong class="ak">敏感数据</strong></h2><p id="686d" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">由于应用程序依赖于第三方服务，其配置必须包括敏感数据，如API密钥、SSH凭证等。访问所需的服务。当然，如果您的存储库是公共的，这不应该被推到源代码控制之下。</p><p id="91d9" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">首先，您可以使用在构建文件或存储库设置中设置的<a class="ae mm" href="https://docs.travis-ci.com/user/environment-variables/" rel="noopener ugc nofollow" target="_blank">加密环境变量</a>。当您有很多环境变量时，它开始变得棘手和不灵活——因为改变一个值需要额外的操作来加密数据。</p><p id="a679" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">此外，当您对同一个应用程序有不同的配置时，比如alpha、beta和产品版本，这种方法就不太适用。您必须使用命名约定(例如，<code class="fe og oh oi oj b">VARIABLE_ALPHA</code>、<code class="fe og oh oi oj b">VARIABLE_BETA</code>、<code class="fe og oh oi oj b">VARIABLE_PROD</code>)为每个可用配置复制<strong class="ls iu">、</strong>个变量。</p><p id="9d7b" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">最后但并非最不重要的是，如果你的一些秘密不是环境变量而是文件，这是行不通的。在这种情况下，您可以创建一个包含所有安全文件的<code class="fe og oh oi oj b">secrets.tar</code>，并使用<a class="ae mm" href="https://kalisio.github.io/kdk/tools/cli.html#travis-cli" rel="noopener ugc nofollow" target="_blank"> Travis CLI </a>将加密到<code class="fe og oh oi oj b">secrets.tar.enc</code>。这个文件将在构建之前或任何你需要的时候被解密。</p><p id="5afe" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">然而，同样的限制也适用:您必须使用命名或路径约定为每个可用的配置复制每个文件，并且更改任何文件都需要额外的操作来加密数据。此外，您还需要为原始机密文件找到一个安全的数据存储。</p><h2 id="dcc9" class="nu kz it bd la nv nw dn le nx ny dp li lz nz oa lk md ob oc lm mh od oe lo of bi translated">前端和后端分离</h2><p id="8252" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这种概念上的划分已经演变为每个人的专门开发人员角色，这仍然是整个行业的规范。</p><p id="8a8d" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">在众多观点中，最荒谬的观点之一可能是后端的变化不会影响前端——反之亦然。只有在保持API向后兼容的情况下，这才是正确的。事实是我们开发功能，而功能既不是后端也不是前端。很多时候，功能都是。</p><p id="7c60" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">在这种情况下，工作量随着前端和后端的划分而增加，特别是如果您有很多模块。为了提交任何更改，需要进行两次同步提交，而不是一次。为了发布一个新特性，相同的过程被应用两次。当处理大型代码库时，这意味着必须在几十个存储库中进行更改和操作。</p><p id="80ba" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">团队可伸缩性也是分离的一个理由，但是当与一个小团队一起工作时(就像我们这样)，最好减少沟通不畅，促进应用程序的顺利开发。</p><p id="cf1d" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">最后但同样重要的是，我们的模块的某些部分是使用同构JavaScript编写的，它既运行在客户端又运行在服务器端，因此这种分离在这些部分上没有任何意义。</p><h2 id="a8d7" class="nu kz it bd la nv nw dn le nx ny dp li lz nz oa lk md ob oc lm mh od oe lo of bi translated"><strong class="ak">永远</strong></h2><p id="0ee7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">严格使用SemVer实际上需要一个公共API，这对于将库或模块集成到第三方应用程序中来说是很好的，但对于应用程序本身来说并非如此。</p><p id="9f49" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">在这种情况下，用户希望次要版本是向后兼容的，具有以前次要版本产生的数据，但在现有功能的工作流程中具有一些新功能或增强功能。主要版本可能会通过删除现有功能并定义新的数据格式来打破这种向后兼容性。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="f4e1" class="ky kz it bd la lb no ld le lf np lh li jz nq ka lk kc nr kd lm kf ns kg lo lp bi translated">我们如何通过定义自己的最佳实践来解决这个问题</h1><p id="6105" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">如果你稍微思考一下，我们已经有了一个经过验证的可靠的解决方案来管理我们代码的多个版本:Git分支。我们的想法是尽可能地坚持这个简单的概念，并相应地驱动我们的过程。</p><p id="9d71" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi ok translated"><span class="l ol om on bm oo op oq or os di"> 1 </span>根据当前Git分支的价值，我们的CI/CD实际上有三种不同的风格:</p><ul class=""><li id="0814" class="mn mo it ls b lt mp lw mq lz mr md ms mh mt ml mu mv mw mx bi translated"><strong class="ls iu">开发</strong>:为了部署当前开发/alpha版本，链接到我们代码的<em class="ot">主</em>分支</li><li id="ddd6" class="mn mo it ls b lt my lw mz lz na md nb mh nc ml mu mv mw mx bi translated"><strong class="ls iu">测试</strong>:为了部署当前的测试版本，链接到我们代码的<em class="ot">测试</em>分支</li><li id="9027" class="mn mo it ls b lt my lw mz lz na md nb mh nc ml mu mv mw mx bi translated"><strong class="ls iu"> prod </strong>:为了部署当前的生产版本，链接到我们代码的<em class="ot">测试</em>分支上的<em class="ot">版本标签</em></li></ul><p id="7a15" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">输出Docker图像工件使用预发布的SemVer表示法来标识产生它所使用的风格，例如1.0.0-dev或1.3.0-test。</p><p id="8470" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi ok translated"><span class="l ol om on bm oo op oq or os di"> 2 </span>我们已经构建了一个简单的<a class="ae mm" href="https://kalisio.github.io/kdk/tools/cli.html#kdk-cli" rel="noopener ugc nofollow" target="_blank"> CLI </a>，它基本上是开发基于KDK的应用程序时常用Git/npm/Yarn命令的多路复用器。</p><p id="6155" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">它允许我们使用一个命令轻松地克隆、安装、链接、解除链接和切换应用程序和所有相关模块上的分支。</p><p id="697c" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">CLI依赖于我们称之为<em class="ot">的工作空间文件</em>，它定义了应用程序和正在开发的模块之间的依赖树。我们的应用程序模板的一个非常简单的示例工作区可以在这里找到<a class="ae mm" href="https://github.com/kalisio/kdk/blob/master/workspaces/kapp.js" rel="noopener ugc nofollow" target="_blank"/>—您可以用几个命令创建一个新的工作环境:</p><pre class="kj kk kl km gt ou oj ov ow aw ox bi"><span id="3260" class="nu kz it oj b gy oy oz l pa pb">// Clone all required repositories with the target branch<br/>kdk your_workspace.js --clone your_branch<br/>// Install dependencies in all required modules<br/>kdk your_workspace.js --install<br/>// Link all required modules according to the dependency tree<br/>kdk your_workspace.js --link</span></pre><p id="86a9" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">这里的关键点是无论什么风格(开发、测试或生产)，我们都使用相同的过程。</p><p id="1b3e" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated"><strong class="ls iu">注意:</strong>在生产中，我们实际上克隆的是一个标签而不是一个分支，但是从Git的角度来看是一样的:一个特定的提交。</p><p id="d125" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi ok translated">我们已经在不同的手机商店为每种口味发布了不同的应用。我们使用<a class="ae mm" href="https://cordova.apache.org/" rel="noopener ugc nofollow" target="_blank"> Cordova </a>构建混合移动应用程序，每个应用程序只发布与相应风格相关的状态:</p><ul class=""><li id="8cca" class="mn mo it ls b lt mp lw mq lz mr md ms mh mt ml mu mv mw mx bi translated">用于开发的私有alpha版本</li><li id="9671" class="mn mo it ls b lt my lw mz lz na md nb mh nc ml mu mv mw mx bi translated">用于测试的公共测试版</li><li id="e7a7" class="mn mo it ls b lt my lw mz lz na md nb mh nc ml mu mv mw mx bi translated">产品的公共版本</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/933920e17beda91368a363a64f221c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*1arPEO_OSt29a0hmZBvy9A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们不同的<a class="ae mm" href="https://aktnmap.com/" rel="noopener ugc nofollow" target="_blank"> Akt'n'Map </a>应用</p></figure><p id="1876" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi ok translated"><span class="l ol om on bm oo op oq or os di"> 4 </span>我们使用一个名为<em class="ot">工作区</em>的私有GitHub存储库作为应用配置的安全存储后端。每个工作区都有每个风格(开发、测试、生产)的子文件夹，外加一个公共的<em class="ot"> </em>文件夹，包含所有风格共享的配置文件。</p><p id="d57b" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">为了避免复制太多的环境变量，我们还进行了合并。env文件包含在common和flavor子文件夹中，以便构建最终的环境。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/2788f371df884c60abb3b4a2c46e66cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*u6gT_LTvC5rcXzsDtwK5GQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用程序工作区示例</p></figure><p id="2a5c" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi ok translated"><span class="l ol om on bm oo op oq or os di"> 5 </span>在我们的模块中，我们将前端和后端代码放在一起，以便从用户的角度解决一组特定的功能特性(例如，档案管理、计费管理等)。).</p><p id="eb9a" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">由于最终的前端包实际上是在使用<a class="ae mm" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>构建应用程序时生成的，因此我们避免了在每个模块中管理前端构建配置的痛苦任务。</p><p id="8aa7" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">由于我们使用的是<a class="ae mm" href="https://quasar.dev/" rel="noopener ugc nofollow" target="_blank">Quasar</a>/<a class="ae mm" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank">vue . js</a>，我们只发布原始组件文件(例如*。vue ),然后由webpack处理，并在运行时在应用程序中动态加载<a class="ae mm" href="https://quasar.dev/quasar-cli/cli-documentation/lazy-loading" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="d541" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结论</h1><p id="0042" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们不想在这里说我们的解决方案比众所周知的方法更相关，但我们假装最佳实践仍然需要受到挑战，特别是在构建大型生态系统和复杂应用程序时。</p><p id="da6b" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">在这个方向上已经做了一些努力，但是显然没有放之四海而皆准的解决方案。例如，Google构建了<a class="ae mm" href="https://source.android.com/setup/develop/repo" rel="noopener ugc nofollow" target="_blank"> repo </a> CLI来简化在Android上开发时跨多个存储库的工作(类似于我们自己的CLI)。</p><p id="48e7" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">有了Git <a class="ae mm" href="https://medium.com/@porteneuve/mastering-git-submodules-34c65e940407" rel="noopener">子模块</a>，一个存储库可以利用来自其他存储库的代码，但是没有自动升级和对分支的支持(它只是一个指向子模块存储库的特定提交的指针)。</p><p id="3d82" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">Monorepo工具，如<a class="ae mm" href="https://github.com/lerna/lerna" rel="noopener ugc nofollow" target="_blank"> Lerna </a>，通过合并库来简化代码库的物理<strong class="ls iu"> </strong>结构，部分解决了这个问题。然而，你仍然需要通过升级和发布相同的软件包来管理你的代码库的逻辑<strong class="ls iu"> </strong>结构。类似地，<a class="ae mm" href="http://bit/" rel="noopener ugc nofollow" target="_blank">位</a>将构建块(例如，组件或库)从任何存储库中隔离出来，以便在任何存储库中使用，但是您仍然必须管理逻辑结构。</p><p id="0d14" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">我们知道我们没有找到完美的解决方案。然而，我们从自己的经验中吸取的主要教训如下:</p><p id="9672" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">无论您使用什么工具，如果您必须为每个逻辑组件执行单独的操作来发布您的应用程序，这将带来巨大的开销。</p><p id="6cd8" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">在我们的例子中，我们不需要执行特定的动作来发布，除了开发人员每天已经用Git执行的动作:提交、合并和标记分支。另一个好处是从基础设施到应用捆绑包的完全隔离的环境，这极大地简化了应用生命周期，并避免了开发相关问题对(预)生产的污染。当然，我们的方法也有缺点:</p><ul class=""><li id="eb6c" class="mn mo it ls b lt mp lw mq lz mr md ms mh mt ml mu mv mw mx bi translated">对发布不使用npm是违反直觉的，并且链接模块会导致生产中的重复依赖；</li><li id="0956" class="mn mo it ls b lt my lw mz lz na md nb mh nc ml mu mv mw mx bi translated">管理多个基础架构、应用程序等。使得配置部分更加复杂</li><li id="fb46" class="mn mo it ls b lt my lw mz lz na md nb mh nc ml mu mv mw mx bi translated">使用动态导入，将为每个组件文件创建块，即使有些块在最终的应用程序中没有使用</li><li id="5c49" class="mn mo it ls b lt my lw mz lz na md nb mh nc ml mu mv mw mx bi translated">如果没有模块中前端文件的构建过程，我们只能在应用程序级别执行前端测试</li></ul><p id="b6b7" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly lz ne mb mc md nf mf mg mh ng mj mk ml im bi translated">我们期待听到您的反馈和解决方案。</p></div></div>    
</body>
</html>