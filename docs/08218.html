<html>
<head>
<title>3 Seemingly Simple Python Features That Confuse Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3个看似简单的Python特性让初学者感到困惑</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-seemingly-simple-python-features-that-confuse-beginners-313575312dcf?source=collection_archive---------4-----------------------#2021-04-07">https://betterprogramming.pub/3-seemingly-simple-python-features-that-confuse-beginners-313575312dcf?source=collection_archive---------4-----------------------#2021-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a894" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们澄清一些Python的惯用用法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3bcff1a958b2322c32f6876036f42aa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aOCOuKsnKCONBz0g"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Juan Pablo Donadías 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="2076" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python已经成为许多初次学习编程的人的首选语言。鉴于Python在机器学习、数据处理和其他领域的广泛能力，许多具有不同语言背景的人可能会考虑转向Python。</p><p id="3680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python的设计非常简单。但是，有一些场景可能会让初学者感到困惑。在本文中，我想澄清一些令人困惑的Python特性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7334" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.逻辑运算符:与、或</h1><p id="8685" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们构造<code class="fe mz na nb nc b">if…else…</code>语句时，我们需要发送条件进行评估。当条件评估为<code class="fe mz na nb nc b">True</code>时，<code class="fe mz na nb nc b">if</code>程序块执行。当到达<code class="fe mz na nb nc b">False</code>时，<code class="fe mz na nb nc b">else</code>块执行。</p><p id="9317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果条件有几部分，我们需要使用逻辑运算符<code class="fe mz na nb nc b">and</code>和<code class="fe mz na nb nc b">or</code>来连接它们。我们知道，所有单个的片段必须是真的，才能使<code class="fe mz na nb nc b">and</code>条件为真，而任何单个的片段都可以是真的，才能使<code class="fe mz na nb nc b">or</code>条件为真。</p><p id="5156" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些组合条件可以直接求值，因此有些人可能会将它们用作三元表达式。考虑下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="aaa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个例子表明，评估值将是第一个非虚假对象。下面这个表达怎么样？</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="43e0" class="nj md it nc b gy nk nl l nm nn">empty_string = ""<br/>empty_list = []<br/>what = empty_string or empty_list</span></pre><p id="a59d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您运行这几行代码，您会发现<code class="fe mz na nb nc b">what</code>将是一个空列表。让我们把那个讨论留到以后。使用<code class="fe mz na nb nc b">and</code>逻辑运算符观察以下示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5cba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看这些例子，看看它们是否对你有意义。</p><p id="449d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，这些组合条件遵循<em class="no">短路规则</em>。对于<code class="fe mz na nb nc b">and</code>操作，它将寻找第一个错误值。如果它找到一个，评估就停止并返回falsy值，比如上面代码片段中的<code class="fe mz na nb nc b">text1</code>变量。但是，如果找不到，它将返回最后一项，如变量<code class="fe mz na nb nc b">number1</code>和<code class="fe mz na nb nc b">text2</code>所示。</p><p id="bfb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe mz na nb nc b">or</code>操作，它将寻找第一个真值。如果找到一个，计算停止并返回真值，如变量<code class="fe mz na nb nc b">number</code>和<code class="fe mz na nb nc b">text</code>所示。但是如果找不到，它仍然会返回最后一项，如变量<code class="fe mz na nb nc b">what</code>所示。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="791e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.赋值表达式</h1><p id="4d87" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Python和许多其他编程语言中，表达式和语句是截然不同的概念。通常，表达式表示一个计算结果为Python对象的值。我们可以在内置的<code class="fe mz na nb nc b">eval</code>方法中使用表达式来产生评估值。相比之下，语句执行的是动作，而不是Python对象。语句不能求值。</p><p id="3d03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">陈述的一种特殊形式是赋值。具体来说，当我们给一个变量赋值时，它是一个赋值语句，是一个动作。我们正在创建一个新的变量，它并没有计算出一个值。以下是一个微不足道的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无法评估陈述</p></figure><p id="9892" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 3.8中引入的赋值表达式特性允许特殊形式的赋值语句具有表达式的特征。本质上，我们可以将一个对象赋给一个变量(赋值组件)，同时，它求值为一个值(表达式组件)。这个特性涉及到一个新操作符<code class="fe mz na nb nc b">:=</code>的使用，这个操作符被一些人称为walrus操作符。请注意以下特征:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="89bd" class="nj md it nc b gy nk nl l nm nn">&gt;&gt;&gt; (numbers1 := [1, 2, 3])<br/>[1, 2, 3]<br/>&gt;&gt;&gt; eval("(numbers2 := [2, 3, 4])")<br/>[2, 3, 4]</span></pre><p id="f26b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这个例子没有实际意义，因为我们在顶层使用了赋值表达式，所以出于语法原因需要一对括号。我们将看到一个更实际的例子，不需要括号。</p><p id="407f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个数字列表，我们想计算保存到列表对象中的累积和。我们可以利用<code class="fe mz na nb nc b">itertools</code>模块中的<code class="fe mz na nb nc b">accumulate</code>函数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用accumulate计算累积和</p></figure><p id="0e60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有另一种利用赋值表达式的解决方案。考虑以下解决方案:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="8693" class="nj md it nc b gy nk nl l nm nn">&gt;&gt;&gt; total = 0<br/>&gt;&gt;&gt; [total := total + x for x in numbers]<br/>[1, 3, 6, 10]</span></pre><p id="30ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所知，在列表理解中，我们期望在关键字<code class="fe mz na nb nc b">for</code>之前有表达式。赋值语句不能放在那里。但是，赋值表达式是有效的。重要的是，这个表达式允许更新<code class="fe mz na nb nc b">total</code>变量，我们可以用它来获得累积和。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0431" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.上下文管理:使用</h1><p id="bf2b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当你研究别人的代码时，你可能会遇到下面的用法。本质上，当我们试图打开一个文件时，我们使用<code class="fe mz na nb nc b">with</code>语句，并在文件体中执行必要的操作。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="0d17" class="nj md it nc b gy nk nl l nm nn">with open("some_file.txt") as file:<br/>    text_data = file.read()</span></pre><p id="8f19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管每当您有与文件相关的操作时，您可能会做同样的事情，但您是否想过我们为什么要这样做？毕竟，它创造了一个额外的缩进层次，有点分散注意力。</p><p id="a221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个特性背后的总体概念被称为<em class="no">上下文管理</em>。这意味着该语句将创建一个上下文，您可以在其中访问托管资源。在这种情况下，它是一个文件。如果没有上下文管理，我们应该如何处理文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文件操作</p></figure><p id="c83e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，要处理一个文件，我们需要打开和关闭它。关闭文件很重要，因为如果在其他地方使用，更新可能不会保存到文件中。</p><p id="1322" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">with</code>语句旨在为我们处理这个样板文件。具体来说，文件在退出<code class="fe mz na nb nc b">with</code>语句后会自动关闭。请注意以下特征:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文件自动关闭</p></figure><p id="bb27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们退出<code class="fe mz na nb nc b">with</code>语句，打开的文件就会自动关闭。方便吧？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5d15" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="8c91" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们回顾了Python的三个特性，这些特性可能会让一些初学者感到困惑。我希望我已经澄清了它们。这里有一个快速回顾:</p><ol class=""><li id="f89e" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">当我们组合条件时，Python会进行一次短路评估。当你有一个<code class="fe mz na nb nc b">and</code>操作时，它将返回第一个falsy值或最后一项。当你有一个<code class="fe mz na nb nc b">or</code>操作时，它将返回第一个真值或最后一项。</li><li id="5804" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">表达式和语句是截然不同的。赋值语句不产生值。但是，赋值表达式在给变量赋值的同时也对值求值。</li><li id="0610" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">当我们需要管理特定的上下文时，我们应该使用<code class="fe mz na nb nc b">with</code>语句。最常见的情况是对文件进行操作。当我们退出上下文时，上下文管理器会自动关闭文件。</li></ol></div></div>    
</body>
</html>