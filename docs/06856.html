<html>
<head>
<title>Koin —A Kotlin Native Dependency Injection Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">koin——一个Kotlin本地依赖注入库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/koin-a-kotlin-native-dependency-injection-library-8e13b81bd48e?source=collection_archive---------9-----------------------#2020-11-11">https://betterprogramming.pub/koin-a-kotlin-native-dependency-injection-library-8e13b81bd48e?source=collection_archive---------9-----------------------#2020-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8e72" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何确定依赖关系的范围</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eb65e8f13abcac97d6c7c9325c1e5d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*scPMDhRet-mbBCw_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@pakata?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pakata Goh </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="0ff6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">这篇文章的要点</h1><p id="8fbe" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您将学习如何使用Koin模块来确定特定组件的依赖范围。您还将了解默认Koin范围以及如何使用自定义范围。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c641" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">介绍</h1><p id="5276" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">正如Android团队建议的那样，如果你的应用包含三个或更少的屏幕，你可以不使用DI。但是三屏以上的，总是推荐用DI。</p><p id="a640" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">在Android应用中实现DI的一种流行方式是通过Dagger框架。但是实现Dagger需要很深的学习曲线。最好的替代方案之一是Koin，它原生于科特林。</p><p id="679e" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">如果您使用过Dagger或任何DI库，您可能知道作用域的重要性。它使我们能够确定我们得到的是同一个依赖对象还是一个新的对象。它还有助于释放不必要的资源和释放内存。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="93b4" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">Koin中的范围</h1><p id="9657" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Koin中的作用域类似于Android中的作用域，比如将视图模型作用于特定的活动，并在该活动中膨胀的片段中使用它。</p><p id="784c" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">开箱即用，Koin有三种范围:</p><ul class=""><li id="d9bf" class="ne nf it lt b lu mz lx na ma ng me nh mi ni mm nj nk nl nm bi translated"><code class="fe nn no np nq b">single</code> : <strong class="lt iu"> </strong>创建一个在整个容器生命周期内持久的对象(类似于Singleton)。</li><li id="e192" class="ne nf it lt b lu nr lx ns ma nt me nu mi nv mm nj nk nl nm bi translated"><code class="fe nn no np nq b">factory</code>:每次创建一个新对象——容器中没有持久性(不能共享)。</li><li id="fb92" class="ne nf it lt b lu nr lx ns ma nt me nu mi nv mm nj nk nl nm bi translated"><code class="fe nn no np nq b">scoped</code>:创建一个持久绑定到相关作用域生存期的对象。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/093aa9c0b0a08d8ed63be0b53dd42f8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pmtj5uVo4DSnilj6WevexA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Single每次都返回相同的实例，而factory每次请求都返回新的实例。</p></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c20f" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">自定义范围</h1><p id="e841" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">单个和工厂是Koin模块生命周期中Koin的默认作用域。然而，在实时用例中，我们的需求并不相同。</p><p id="6421" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">通常，我们只需要特定时间范围的依赖关系。例如，在Android应用程序中，<code class="fe nn no np nq b">OnBoardRepository</code>仅在用户登机时需要。一旦用户登录，将它保存在内存中是一种资源浪费。</p><p id="a02d" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">为了在Koin中实现这种行为，我们可以使用scope API。在Koin模块中，我们可以创建一个<strong class="lt iu">字符串限定的作用域</strong>，并用唯一限定符声明作用域内部的依赖关系。让我们一步一步来:</p><h2 id="a4c3" class="nx la it bd lb ny nz dn lf oa ob dp lj ma oc od ll me oe of ln mi og oh lp oi bi translated">第一步</h2><p id="5440" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，创建一个模块，声明一个空的作用域并给它命名。在这种情况下，它是<code class="fe nn no np nq b">CustomeScope</code>，你可以根据你的要求来命名。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建自定义koin范围</p></figure><h2 id="8d32" class="nx la it bd lb ny nz dn lf oa ob dp lj ma oc od ll me oe of ln mi og oh lp oi bi translated">第二步</h2><p id="7c5c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下一步是根据需求使用single和factory声明必要的依赖关系。这里关键的一点是用唯一的限定符来命名它们。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自定义范围内的依赖项</p></figure><h2 id="064e" class="nx la it bd lb ny nz dn lf oa ob dp lj ma oc od ll me oe of ln mi og oh lp oi bi translated">第三步</h2><p id="b4c7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们已经完成了Koin模块的设置。在这一步中，我们需要从导入这些依赖项的地方创建范围。通常是在类似<code class="fe nn no np nq b">Activity</code>、<code class="fe nn no np nq b">Fragment</code>等安卓组件里。</p><p id="3059" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">要创建一个作用域，首先，我们需要获得Koin组件的现有实例，然后通过传递ScopeID和作用域名称来调用<code class="fe nn no np nq b">createScope</code>函数。看一看:</p><pre class="kj kk kl km gt ol nq om on aw oo bi"><span id="6a27" class="nx la it nq b gy op oq l or os">val stringQualifiedScope = getKoin().createScope(<br/>    "ScopeNameID", named("CustomeScope"))</span></pre><p id="1c84" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">通过给定<code class="fe nn no np nq b">CustomeScope</code>作为名称，Koin搜索我们在其模块中用这个名称声明的作用域。<code class="fe nn no np nq b">ScopeNameID</code>是一个ScopeID，我们可以用它来区分不同的范围。它在内部用作查找该范围的键(ID)。</p><p id="9d7f" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">如果您从多个Android组件访问或创建范围，建议使用<code class="fe nn no np nq b">getOrCreateScope</code>函数，而不是<code class="fe nn no np nq b">createScope</code>。没有必要解释，因为我们看到他们的名字就知道他们。</p><h2 id="9c68" class="nx la it bd lb ny nz dn lf oa ob dp lj ma oc od ll me oe of ln mi og oh lp oi bi translated">第四步</h2><p id="40b2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，在这一步中，我们必须创建一个我们想要使用的依赖项的实例。我们已经使用我们创建的范围完成了它。看一看:</p><pre class="kj kk kl km gt ol nq om on aw oo bi"><span id="4fc7" class="nx la it nq b gy op oq l or os">val sampleClass = stringQualifiedScope.get&lt;SampleClass&gt;(<br/>        qualifier = named("scopedName"))</span></pre><p id="4eb4" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated"><code class="fe nn no np nq b">scopedName</code>和<code class="fe nn no np nq b">factoryName</code>是我们在步骤2中在koin模块中声明的限定符。</p><h2 id="a97e" class="nx la it bd lb ny nz dn lf oa ob dp lj ma oc od ll me oe of ln mi og oh lp oi bi translated">第五步</h2><p id="c3e8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了处理使用<code class="fe nn no np nq b">stringQualifiedScope</code>创建的依赖关系，比如<code class="fe nn no np nq b">sampleclass</code>，我们需要调用<code class="fe nn no np nq b">close</code>函数。例如，如果您想在活动被销毁时处置在此范围下创建的依赖项，我们需要调用<code class="fe nn no np nq b">onDestroy</code>函数中的close。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">摧毁koin示波器</p></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="8a1f" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">Koin-Android</h1><p id="2539" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">上述将依赖关系限制在特定范围的方法是通用的，可以在Koin支持的任何平台上使用。但是现在，作为一个Android，我想把Koin作用域和lifecycle作用域混合起来，以尽量减少每次创建新活动时我必须做的工作。</p><p id="8b6f" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">为此，您需要导入Koin-Android库。在应用程序级build.gradle文件的“依赖项”节点下包含以下行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Koin-Android模块</p></figure><p id="de6c" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">现在，我们想要减少样板代码，比如关闭Android组件的<code class="fe nn no np nq b">onDestry</code>函数中的作用域。我们可以通过使用<code class="fe nn no np nq b">lifecyclescope</code>链接导入Koin依赖项来做到这一点。</p><p id="ced5" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">首先，我们需要在Koin模块中创建android组件的依赖范围。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">android活动的范围依赖性</p></figure><p id="7282" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">然后在活动中，我们需要使用一个<code class="fe nn no np nq b">lifecyclescope</code>注入依赖关系。看一看:</p><pre class="kj kk kl km gt ol nq om on aw oo bi"><span id="42b8" class="nx la it nq b gy op oq l or os">val sampleClass : SampleClass by <strong class="nq iu">lifecycleScope</strong>.inject()</span></pre><p id="d7ba" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">这样做的目的是，当活动被销毁时，它会关闭作用域，而不需要手动操作。看一下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="a897" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">这种方法将自动创建范围、鉴定和销毁它们。这看起来很简单，但是自动化重复工作是至关重要的，一旦应用程序开始增长，你就会意识到这一点。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5476" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">奖金</h1><ul class=""><li id="8990" class="ne nf it lt b lu lv lx ly ma ot me ou mi ov mm nj nk nl nm bi translated">要了解更多关于依赖注入的知识，请阅读:<a class="ae ky" href="https://medium.com/android-dev-hacks/koin-kotlin-native-dependency-injection-library-f1daddc1ef99" rel="noopener">“Koin-kot Lin原生依赖注入库”</a></li><li id="c1bc" class="ne nf it lt b lu nr lx ns ma nt me nu mi nv mm nj nk nl nm bi translated">要了解更多关于Kotlin的知识，请阅读Kotlin高级编程系列的前几部分:<a class="ae ky" href="https://medium.com/android-dev-hacks/advanced-android-programming-with-kotlin-part-2-aae2a15258b0" rel="noopener">kot Lin高级编程—第2部分</a></li><li id="a057" class="ne nf it lt b lu nr lx ns ma nt me nu mi nv mm nj nk nl nm bi translated">要了解更多关于Kotlin协同程序和Kotlin的其他高级特性，请阅读:<a class="ae ky" href="https://medium.com/@sgkantamani/learn-how-to-combine-kotlin-flows-317849a71d3e" rel="noopener">“了解如何组合Kotlin流</a>”</li></ul><p id="01fe" class="pw-post-body-paragraph lr ls it lt b lu mz ju lw lx na jx lz ma nb mc md me nc mg mh mi nd mk ml mm im bi translated">目前就这些。希望你学到了有用的东西，感谢阅读！</p></div></div>    
</body>
</html>