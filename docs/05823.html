<html>
<head>
<title>The Beginner’s Guide to Pydantic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pydantic初级指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-beginners-guide-to-pydantic-ba33b26cde89?source=collection_archive---------1-----------------------#2020-08-10">https://betterprogramming.pub/the-beginners-guide-to-pydantic-ba33b26cde89?source=collection_archive---------1-----------------------#2020-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="08cd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用于解析和验证数据的Python包</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7e0f015eef91ab4420bac9e168a36d31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vEmaWk7Y51RTThbAWvQ5cA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马克·巴宾在<a class="ae ky" href="https://unsplash.com/s/photos/filter?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7d60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天的主题是关于使用Python类型提示的数据验证和设置管理。我们将使用一个名为<code class="fe lv lw lx ly b">pydantic</code>的Python包，它在运行时强制执行类型提示。它提供用户友好的错误，允许您捕捉任何无效数据。根据<a class="ae ky" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank">官方文件</a>，Pydantic是</p><blockquote class="lz ma mb"><p id="50f8" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated">“…主要是一个解析库，而不是一个验证库。验证是达到目的的一种手段:构建一个符合所提供的类型和约束的模型。</p><p id="1020" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated">换句话说，pydantic保证输出模型的类型和约束，而不是输入数据。"</p></blockquote><p id="0ef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程分为三个部分:</p><ol class=""><li id="b6b0" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">设置</li><li id="dc2f" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">履行</li><li id="43db" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated">结论</li></ol><p id="d089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们继续下一部分，开始安装必要的模块。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="b2a2" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">1.设置</h1><p id="6a8c" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">强烈建议您在继续安装之前创建一个虚拟环境。</p><h2 id="1c6f" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">基本安装</h2><p id="b235" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">打开一个终端，运行下面的命令来安装<code class="fe lv lw lx ly b">pydantic</code></p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="be96" class="ny nc it ly b gy oo op l oq or">pip install pydantic</span></pre><h2 id="b678" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">升级现有包</h2><p id="3e08" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">如果您已经有了一个现有的软件包，并且想要升级它，请运行以下命令:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="ec67" class="ny nc it ly b gy oo op l oq or">pip install -U pydantic</span></pre><h2 id="e544" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">蟒蛇</h2><p id="93a8" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">对于Anaconda用户，您可以按如下方式安装它:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="1d3e" class="ny nc it ly b gy oo op l oq or">conda install pydantic -c conda-forge</span></pre><h2 id="654a" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">可选依赖项</h2><p id="2a41" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated"><code class="fe lv lw lx ly b">pydantic</code>根据您的需求提供以下可选依赖项:</p><ul class=""><li id="64bb" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">email-validator</code> —支持邮件验证。</li><li id="8051" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">typing-extensions</code> —支持使用Python 3.8之前的<code class="fe lv lw lx ly b">Literal</code>。</li><li id="d774" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">python-dotenv</code> —支持带设置的<code class="fe lv lw lx ly b">dotenv</code>文件。</li></ul><p id="e3c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以手动安装它们:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="82a6" class="ny nc it ly b gy oo op l oq or"># install email-validator<br/>pip install email-validator</span><span id="e955" class="ny nc it ly b gy ot op l oq or"># install typing-extensions<br/>pip install typing_extensions</span><span id="d948" class="ny nc it ly b gy ot op l oq or"># install python-dotenv<br/>pip install python-dotenv</span></pre><p id="7fbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或与<code class="fe lv lw lx ly b">pydantic</code>一起如下:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="16e1" class="ny nc it ly b gy oo op l oq or"># install email-validator<br/>pip install pydantic[email]</span><span id="e293" class="ny nc it ly b gy ot op l oq or"># install typing-extensions<br/>pip install pydantic[typing_extensions]</span><span id="cd67" class="ny nc it ly b gy ot op l oq or"># install python-dotenv<br/>pip install pydantic[dotenv]</span><span id="1a56" class="ny nc it ly b gy ot op l oq or"># install all dependencies<br/>pip install pydantic[email,typing_extensions,dotenv]</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="d8ea" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">2.履行</h1><p id="b6a2" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">在这一部分，我们将探索<code class="fe lv lw lx ly b">pydantic</code>中一些有用的功能。</p><p id="faca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">pydantic</code>中定义一个对象就像创建一个继承自<code class="fe lv lw lx ly b">BaseModel</code>的新类一样简单。当您从类中创建一个新的对象时，<code class="fe lv lw lx ly b">pydantic</code>保证结果模型实例的字段将符合模型上定义的字段类型。</p><h2 id="be8e" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">导入</h2><p id="2699" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">在Python文件的顶部添加以下导入声明。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="0fd4" class="ny nc it ly b gy oo op l oq or">from datetime import datetime<br/>from typing import List, Optional<br/>from pydantic import BaseModel</span></pre><h2 id="28ab" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">用户级</h2><p id="9459" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">如下声明一个继承了<code class="fe lv lw lx ly b">BaseModel</code>的新类:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="6595" class="ny nc it ly b gy oo op l oq or">class User(BaseModel):<br/>    id: int<br/>    username : str<br/>    password : str<br/>    confirm_password : str<br/>    alias = 'anonymous'<br/>    timestamp: Optional[datetime] = None<br/>    friends: List[int] = []</span></pre><p id="b159" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">pydantic</code>使用内置的类型提示语法来确定每个变量的数据类型。让我们一个一个地探究幕后发生了什么。</p><ul class=""><li id="c6d8" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">id</code> —一个整数变量代表一个ID。由于未提供默认值，因此该字段是必需的，并且必须在对象创建期间指定。如果可能，字符串、字节或浮点数将被强制转换为整数；否则，将引发异常。</li><li id="5840" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">username </code> —字符串变量代表用户名，是必需的。</li><li id="a235" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">password</code> —字符串变量代表密码，是必需的。</li><li id="aaaf" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">confirm_password</code> —字符串变量代表确认密码，是必需的。稍后它将用于数据验证。</li><li id="cff5" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">alias </code> —字符串变量代表别名。它不是必需的，如果在对象创建期间没有提供，它将被设置为匿名。</li><li id="821b" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">timestamp</code> —日期/时间字段，不是必需的。默认为无。<code class="fe lv lw lx ly b">pydantic </code>将处理unix时间戳int或表示日期/时间的字符串。</li><li id="e9ff" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">friends</code> —整数输入列表。</li></ul><h2 id="7540" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">对象实例化</h2><p id="473f" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">下一步是从<code class="fe lv lw lx ly b">User</code>类实例化一个新对象。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="428c" class="ny nc it ly b gy oo op l oq or">data = {'id': '1234', 'username': 'wai foong', 'password': 'Password123', 'confirm_password': 'Password123', 'timestamp': '2020-08-03 10:30', 'friends': [1, '2', b'3']}</span><span id="0f2c" class="ny nc it ly b gy ot op l oq or">user = User(**data)</span></pre><p id="99e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您打印出<code class="fe lv lw lx ly b">user</code>变量时，您应该得到以下输出。您可以注意到<code class="fe lv lw lx ly b">id</code>已经被自动转换为整数，即使输入是一个字符串。同样，字节被自动转换成整数，如<code class="fe lv lw lx ly b">friends</code>字段所示。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="ab6b" class="ny nc it ly b gy oo op l oq or">id=1234 username='wai foong' password='Password123' confirm_password='Password123' timestamp=datetime.datetime(2020, 8, 3, 10, 30) friends=[1, 2, 3] alias='anonymous'</span></pre><h2 id="c939" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">BaseModel下的方法和属性</h2><p id="c8ce" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">继承<code class="fe lv lw lx ly b">BaseModel</code>的类将有以下方法和属性:</p><ul class=""><li id="6a02" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">dict()</code> —返回模型字段和值的字典</li><li id="cecb" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">json()</code> —返回一个JSON字符串表示字典</li><li id="2dc0" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">copy()</code>-返回模型的深层副本</li><li id="0caa" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">parse_obj()</code> —如果对象不是字典，用于将任何对象加载到带有错误处理的模型中的实用程序</li><li id="aa7c" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">parse_raw()</code> —加载多种格式字符串的实用程序</li><li id="37bd" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">parse_field()</code> —类似于<code class="fe lv lw lx ly b">parse_raw()</code>，但用于文件</li><li id="e487" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">from_orm() </code> —将数据从任意类加载到模型中</li><li id="9d37" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">schema() </code> —返回将模型表示为JSON模式的字典</li><li id="3811" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">schema_json()</code> —返回<code class="fe lv lw lx ly b">schema()</code>的JSON字符串表示</li><li id="19c5" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">construct()</code> —创建模型而不运行验证的类方法</li><li id="9563" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">__fields_set__</code> —初始化模型实例时设置的字段名称集</li><li id="e127" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">__fields__</code> —模型领域词典</li><li id="bb62" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated"><code class="fe lv lw lx ly b">__config__ </code> —模型的配置类</li></ul><p id="d00e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将<code class="fe lv lw lx ly b">id</code>的输入改为一个字符串，如下所示:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="ee56" class="ny nc it ly b gy oo op l oq or">data = {'id': 'a random string', 'username': 'wai foong', 'password': 'Password123', 'confirm_password': 'Password123', 'timestamp': '2020-08-03 10:30', 'friends': [1, '2', b'3']}</span><span id="f1e3" class="ny nc it ly b gy ot op l oq or">user = User(**data)</span></pre><p id="376c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您运行代码时，应该会得到以下错误。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="cc8d" class="ny nc it ly b gy oo op l oq or">value is not a valid integer (type=type_error.integer)</span></pre><h2 id="c41e" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">验证错误</h2><p id="897e" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">为了更好地了解错误的详细信息，强烈建议将其包装在try-catch块中，如下所示:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="15ff" class="ny nc it ly b gy oo op l oq or">from pydantic import BaseModel, ValidationError</span><span id="24d6" class="ny nc it ly b gy ot op l oq or"># ... codes for User class</span><span id="1d33" class="ny nc it ly b gy ot op l oq or">data = {'id': 'a random string', 'username': 'wai foong', 'password': 'Password123', 'confirm_password': 'Password123', 'timestamp': '2020-08-03 10:30', 'friends': [1, '2', b'3']}</span><span id="073c" class="ny nc it ly b gy ot op l oq or">try:<br/>    user = User(**data)<br/>except ValidationError as e:<br/>    print(e.json())</span></pre><p id="c495" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将打印出以下JSON，这表明<code class="fe lv lw lx ly b">id</code>的输入不是有效的整数。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="bba0" class="ny nc it ly b gy oo op l oq or">[<br/>  {<br/>    "loc": [<br/>      "id"<br/>    ],<br/>    "msg": "value is not a valid integer",<br/>    "type": "type_error.integer"<br/>  }<br/>]</span></pre><h2 id="8a92" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">字段类型</h2><p id="0b06" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated"><code class="fe lv lw lx ly b">pydantic</code>为Python标准库中的大多数常见类型提供支持。完整列表如下:</p><ul class=""><li id="958d" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu os mm mn mo bi translated">弯曲件</li><li id="a6e6" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">（同Internationalorganizations）国际组织</li><li id="b980" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">漂浮物</li><li id="4230" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">潜艇用热中子反应堆（submarine thermal reactor的缩写）</li><li id="9a1e" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">字节</li><li id="deb1" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">目录</li><li id="5bdf" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">元组</li><li id="497b" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">词典</li><li id="d153" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">设置</li><li id="17a2" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">frozenset</li><li id="f37e" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">日期时间</li><li id="715c" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">日期时间</li><li id="463b" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">日期时间.日期时间</li><li id="67f3" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">日期时间.时间增量</li><li id="0c65" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">打字。任何的</li><li id="cdf8" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">打字。类型变量</li><li id="f802" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">打字。联盟</li><li id="8e10" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">打字。可选择的</li><li id="89dc" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">打字。目录</li><li id="c763" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">打字。元组</li><li id="f31e" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">打字。词典</li><li id="7dd0" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">打字。一组</li><li id="3932" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">打字。FrozenSet</li><li id="4f57" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">打字。顺序</li><li id="3ddc" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">打字。可迭代的</li><li id="183a" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">打字。类型</li><li id="b3df" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">打字。请求即付的</li><li id="ffae" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">打字。模式</li><li id="da37" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">IP地址。IPv6地址</li><li id="0698" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">IP地址。IP v4接口</li><li id="03fd" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">IP地址。IP v4网络</li><li id="bd54" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">IP地址。IPv6地址</li><li id="43c2" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">IP地址。IPv6接口</li><li id="4c49" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">IP地址。IPv6网络</li><li id="91a3" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">枚举。列举型别</li><li id="f06e" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">枚举。内部</li><li id="4c9f" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">十进制。小数</li><li id="312c" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">pathlib。小路</li><li id="5782" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">uuid。UUID</li><li id="4eef" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">字节大小</li></ul><h2 id="f54e" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">约束类型</h2><p id="61fd" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">您可以通过<code class="fe lv lw lx ly b">Constrained Types</code>执行自己的限制。让我们看看下面的例子:</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="2938" class="ny nc it ly b gy oo op l oq or">from pydantic import (<br/>    BaseModel,<br/>    NegativeInt,<br/>    PositiveInt,<br/>    conint,<br/>    conlist,<br/>    constr<br/>)</span><span id="ab96" class="ny nc it ly b gy ot op l oq or">class Model(BaseModel):<br/>    # minimum length of 2 and maximum length of 10<br/>    short_str: constr(min_length=2, max_length=10)</span><span id="f930" class="ny nc it ly b gy ot op l oq or">    # regex<br/>    regex_str: constr(regex=r'^apple (pie|tart|sandwich)$')</span><span id="3849" class="ny nc it ly b gy ot op l oq or">    # remove whitespace from string<br/>    strip_str: constr(strip_whitespace=True)<br/><br/>    # value must be greater than 1000 and less than 1024<br/>    big_int: conint(gt=1000, lt=1024)<br/>    <br/>    # value is multiple of 5<br/>    mod_int: conint(multiple_of=5)<br/>    <br/>    # must be a positive integer<br/>    pos_int: PositiveInt<br/>    <br/>    # must be a negative integer<br/>    neg_int: NegativeInt<br/><br/>    # list of integers that contains 1 to 4 items<br/>    short_list: conlist(int, min_items=1, max_items=4)</span></pre><h2 id="2ba2" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">严格类型</h2><p id="294e" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">如果您正在寻找通过验证的严格限制，当且仅当验证的值属于相应的类型或者是该类型的子类型时，您可以使用以下严格类型:</p><ul class=""><li id="6744" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu os mm mn mo bi translated">StrictStr</li><li id="564d" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">严格限制</li><li id="44ff" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">严格浮动</li><li id="d7d9" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu os mm mn mo bi translated">斯特里布尔</li></ul><p id="98c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子说明了在你继承的类中执行<code class="fe lv lw lx ly b">StrictBool</code>的正确方法。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="444b" class="ny nc it ly b gy oo op l oq or">from pydantic import BaseModel, StrictBool,</span><span id="0851" class="ny nc it ly b gy ot op l oq or">class StrictBoolModel(BaseModel):<br/>    strict_bool: StrictBool</span></pre><p id="5adb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字符串<code class="fe lv lw lx ly b">‘False’</code>将引发ValidationError，因为它只接受<code class="fe lv lw lx ly b">True</code>或<code class="fe lv lw lx ly b">False</code>作为输入。</p><h2 id="a133" class="ny nc it bd nd nz oa dn nh ob oc dp nl li od oe nn lm of og np lq oh oi nr oj bi translated">验证器</h2><p id="1e09" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">此外，您可以在继承的类中使用<code class="fe lv lw lx ly b">validator</code> decorator创建自己的定制验证器。让我们看看下面的例子，它确定<code class="fe lv lw lx ly b">id</code>是否是四位数，以及<code class="fe lv lw lx ly b">confirm_password</code>是否与<code class="fe lv lw lx ly b">password</code>字段匹配。</p><pre class="kj kk kl km gt ok ly ol om aw on bi"><span id="5ad4" class="ny nc it ly b gy oo op l oq or">from datetime import datetime<br/>from typing import List, Optional<br/>from pydantic import BaseModel, ValidationError, validator</span><span id="0201" class="ny nc it ly b gy ot op l oq or">class User(BaseModel):<br/>    id: int<br/>    username : str<br/>    password : str<br/>    confirm_password : str<br/>    alias = 'anonymous'<br/>    timestamp: Optional[datetime] = None<br/>    friends: List[int] = []</span><span id="602d" class="ny nc it ly b gy ot op l oq or">    @validator('id')<br/>    def id_must_be_4_digits(cls, v):<br/>        if len(str(v)) != 4:<br/>            raise ValueError('must be 4 digits')<br/>        return v</span><span id="81b9" class="ny nc it ly b gy ot op l oq or">    @validator('confirm_password')<br/>    def passwords_match(cls, v, values, **kwargs):<br/>        if 'password' in values and v != values['password']:<br/>            raise ValueError('passwords do not match')<br/>        return v</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="32c5" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">3.结论</h1><p id="935f" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">让我们回顾一下今天所学的内容。</p><p id="d253" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先详细解释了Pydantic，它有助于解析和验证数据。</p><p id="c343" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们创建了一个虚拟环境，并通过pip或conda安装了Pydantic。它还包括对基于我们的用例的三个附加依赖项的支持。</p><p id="b418" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装完成后，我们深入研究了软件包提供的基本功能。基本的构建块是创建一个继承自<code class="fe lv lw lx ly b">BaseModel</code>的新类。</p><p id="fdb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们了解到Pydantic提供了对Python标准库下大多数常见数据类型的支持。我们测试了<code class="fe lv lw lx ly b">Constrained Types</code>和<code class="fe lv lw lx ly b">Strict Types</code>，这有助于执行我们自己的自定义限制。</p><p id="1334" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，您摆弄了一下<code class="fe lv lw lx ly b">validator</code>装饰器，只允许为<code class="fe lv lw lx ly b">id</code>输入四位数，并且<code class="fe lv lw lx ly b">confirm_password</code>必须与<code class="fe lv lw lx ly b">password</code>字段匹配。</p><p id="513f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你阅读这篇文章。希望在下一篇文章中再见到你！</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="9b3e" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">参考</h1><ol class=""><li id="4a7e" class="mg mh it lb b lc nt lf nu li ou lm ov lq ow lu ml mm mn mo bi translated"><a class="ae ky" href="https://github.com/samuelcolvin/pydantic/" rel="noopener ugc nofollow" target="_blank"> Pydantic Github页面</a></li><li id="cca2" class="mg mh it lb b lc mp lf mq li mr lm ms lq mt lu ml mm mn mo bi translated"><a class="ae ky" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank"> Pydantic文档</a></li></ol></div></div>    
</body>
</html>