<html>
<head>
<title>Micro Frontends on Monorepo With Remote State Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Monorepo上的微前端具有远程状态管理功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/micro-frontends-on-monorepo-with-remote-state-management-c8b7c24bc411?source=collection_archive---------11-----------------------#2022-09-12">https://betterprogramming.pub/micro-frontends-on-monorepo-with-remote-state-management-c8b7c24bc411?source=collection_archive---------11-----------------------#2022-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b6f7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建独立前端项目的指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e2d574d78897dd53c092f1578f848e06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sm6TnZODWLAOx_Dt4dDdcg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">感谢图片来自<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">unsplash.com</a>的<a class="ae kv" href="https://unsplash.com/@charlesdeluvio" rel="noopener ugc nofollow" target="_blank"> charlesdeluvio </a></p></figure><p id="9d87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几乎每三个企业公司中就有一个需要花费大量精力来开发和支持的大型整体应用程序。许多团队和前端在开发过程中造成许多问题和混乱。连续第二年，代码结构化架构模式——微前端——越来越受欢迎。</p><p id="6e67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将看到微前端的所有方面，如结构、远程状态管理和模块联合插件的使用。</p><h1 id="9349" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么？</h1><ul class=""><li id="487b" class="mk ml iq ky b kz mm lc mn lf mo lj mp ln mq lr mr ms mt mu bi translated">对于新开发人员来说，非常沉重的可读代码和困难的入口点</li><li id="b85a" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">团队同步和他们之间在同一个项目中的混乱</li><li id="3b24" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">CI/CD和测试的漫长部署过程</li><li id="cdf6" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">团队之间职责划分混乱</li></ul><h1 id="5f3b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是微前端？</h1><p id="af91" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">微前端是独立的迷你服务，运行在不同的主机上，组合成一个系统，并通过网络进行通信。每个服务都有自己的主机地址。这种方法给予开发团队自主权。这就像不同的组件被浏览器中组合成一个应用程序的几个服务独立分开。</p><p id="8ca8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个独立的组件比一个整体项目更容易理解。几乎和微服务一样，但是前端有一个通用的<code class="fe nd ne nf ng b">event-loop</code>，一个通用的<code class="fe nd ne nf ng b">DOM</code>，<code class="fe nd ne nf ng b">events</code>，一个全局的<code class="fe nd ne nf ng b">window</code>对象。</p><h1 id="48c4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">模块联盟</h1><p id="fd8d" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这是Webpack 5中的功能插件，由<a class="ae kv" href="https://twitter.com/ScriptedAlchemy" rel="noopener ugc nofollow" target="_blank"> Zack Jackson </a>和<a class="ae kv" href="https://twitter.com/slightlycode" rel="noopener ugc nofollow" target="_blank"> Marais Rossouw </a>在<a class="ae kv" href="https://twitter.com/wsokra?lang=en" rel="noopener ugc nofollow" target="_blank"> Tobias Koppers </a>的协助下创建。<strong class="ky ir"> </strong>该插件允许你从主机异步连接共享微前端。模块加载直接发生在运行时。负载可以是静态的或动态的。模块联合可以共享公共依赖关系。例如，已加载的React将不会从其他<code class="fe nd ne nf ng b">webpack</code>应用程序中再次加载。</p><p id="5477" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模块可以独立地部署在不同的主机上，如果一个共享模块已经被修改，就没有必要重新构建主应用程序。通过这个特性，每个微前端可以是一个独立的部署库。</p><h1 id="32be" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">术语</h1><p id="bf9b" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">主机:这是用户，运行时第一个初始化的包<br/>远程:包，用于导入到主机模块<br/>暴露:可用于导入的输出模块<br/>共享:所有应用程序的通用模块</p><p id="d833" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模块联合的思想是<code class="fe nd ne nf ng b">remotes</code>有输出<code class="fe nd ne nf ng b">exposes</code>，微前端使用那些<code class="fe nd ne nf ng b">remotes</code>条目。在它们之间，共享范围内的模块的公共交换。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/263290c448c32827ff84c7e6594d359e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_agMpusXwLqrqXi3COfFCg.png"/></div></div></figure><p id="a037" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Share作用域提供了不加载某些模块两次的能力。当在DOM中打开浏览器时，一个主脚本与<code class="fe nd ne nf ng b">webpack</code>捆绑导入。这意味着如果放置了一些带有外部组件类名的样式，那么这些样式将会因为公共DOM而被应用。</p><h1 id="2478" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">应用</h1><p id="e674" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们将在monorepo中构建应用程序，它将有一个外部存储作为微前端应用程序、仪表板和标题。他们都将被<code class="fe nd ne nf ng b">host</code>应用消费掉。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/d6094ed9cc133c61b9f839edb96e8032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-gWxeF2oEX7E2sUY8zGyzg.png"/></div></div></figure><p id="8a08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nd ne nf ng b">host</code>将使用<code class="fe nd ne nf ng b">remote</code>配置来消耗<code class="fe nd ne nf ng b">store</code>、<code class="fe nd ne nf ng b">dashboard</code>和<code class="fe nd ne nf ng b">header</code>。那些将使用<code class="fe nd ne nf ng b">expose</code>配置的远程组件是“可消费的”</p><h1 id="6983" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">设置</h1><p id="e724" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">现在我们的任务是将所有微前端整合到一个存储库中。让我们运行<code class="fe nd ne nf ng b">mkdir micro-frontends-demo</code>并在文件夹内运行<code class="fe nd ne nf ng b">npm init -y</code>。在<code class="fe nd ne nf ng b">micro-frontends-demo</code>中创建另一个文件夹<code class="fe nd ne nf ng b">apps</code>，然后添加到<code class="fe nd ne nf ng b">package.json</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">mono包. json</p></figure><p id="8a4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为每个微前端创建四个微前端:<code class="fe nd ne nf ng b">host, header, dashboard </code>和<code class="fe nd ne nf ng b">store</code>在<code class="fe nd ne nf ng b">app</code>文件夹内，并使用<code class="fe nd ne nf ng b">npx create-mf-app</code>。对于这些问题，选择以下答案:</p><ol class=""><li id="608f" class="mk ml iq ky b kz la lc ld lf nl lj nm ln nn lr no ms mt mu bi translated">选择您的应用程序的名称:<code class="fe nd ne nf ng b">host</code>、<code class="fe nd ne nf ng b">header</code>、<code class="fe nd ne nf ng b">dashboard</code>、<code class="fe nd ne nf ng b">store</code>(每次运行<code class="fe nd ne nf ng b">npx create-mf-app</code>时)</li><li id="63b7" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr no ms mt mu bi translated">项目类型:<code class="fe nd ne nf ng b">Application</code></li><li id="2dd1" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr no ms mt mu bi translated">端口号:<code class="fe nd ne nf ng b">3000</code>、<code class="fe nd ne nf ng b">3001</code>、<code class="fe nd ne nf ng b">3002</code>、<code class="fe nd ne nf ng b">3003</code></li><li id="1790" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr no ms mt mu bi translated">框架:<code class="fe nd ne nf ng b">react</code></li><li id="d07d" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr no ms mt mu bi translated">语言:<code class="fe nd ne nf ng b">javascript</code></li><li id="9fb2" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr no ms mt mu bi translated">CSS: <code class="fe nd ne nf ng b">CSS</code></li></ol><p id="9f9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，您的文件夹结构应该如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文件夹结构</p></figure><p id="cb3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦你得到了一切，我们必须安装所有的软件包，只要我们有monorepo。你不需要在所有应用中单独安装它们。除了<code class="fe nd ne nf ng b">host</code>之外，每个微前端将具有几乎相同的结构。只有<code class="fe nd ne nf ng b">App.jsx</code>会导入我们的远程模块。所以，遥控器将会是:<code class="fe nd ne nf ng b">dashboard</code>、<code class="fe nd ne nf ng b">header</code>和<code class="fe nd ne nf ng b">store</code>。</p><p id="65eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个<code class="fe nd ne nf ng b">index.js</code>都有<code class="fe nd ne nf ng b">import(“./App”);</code>，异步加载应用程序需要等待<code class="fe nd ne nf ng b">webpack</code>来获取组件。每个<code class="fe nd ne nf ng b">micro-frontend</code>都将拥有与<code class="fe nd ne nf ng b">webpack.config.js</code>几乎相同的配置。我们的每个微前端将位于以下端口:</p><pre class="kg kh ki kj gt np ng nq nr aw ns bi"><span id="ace8" class="nt lt iq ng b gy nu nv l nw nx">host<!-- -->: <!-- -->3000<!-- --> <br/>header<!-- -->: <!-- -->3001<!-- --> <br/>dashboard<!-- -->: <!-- -->3002<br/>store<!-- -->: <!-- -->3003</span></pre><p id="6c4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们为<code class="fe nd ne nf ng b">webpack.config.js</code>中的<code class="fe nd ne nf ng b">ModuleFederationPlugin</code>添加额外的配置。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">网络包<code class="fe nd ne nf ng b">ModuleFederationPlugin configs for each micro-forntend</code></p></figure><p id="3282" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nd ne nf ng b">ModuleFederationPlugin</code>声明微前端:<br/> <code class="fe nd ne nf ng b">name</code>是我们微前端的区分。这对<code class="fe nd ne nf ng b">remotes</code>很重要，因为我们将在主机<code class="fe nd ne nf ng b">container</code>中使用这些名称。<br/> <code class="fe nd ne nf ng b">filename</code>编译后的文件类似于<code class="fe nd ne nf ng b">webpack</code>的输出。<br/> <code class="fe nd ne nf ng b">exposes</code>可用于其他微前端消费者的组件列表。</p><p id="88ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nd ne nf ng b">remotes</code>这是我们在主机上使用的联邦模块。它允许我们使用<code class="fe nd ne nf ng b">import(“header/Header”))<br/></code> shared:用于在加载组件之间共享模块。</p><h1 id="2699" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">成分</h1><p id="dc9d" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">是时候设置我们的组件了。让我们转到<code class="fe nd ne nf ng b">apps/header/src</code>并创建<code class="fe nd ne nf ng b">Header.jsx</code>，然后在那里添加一段简单的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">页眉</p></figure><p id="c777" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nd ne nf ng b">Header</code>中，我们将从<code class="fe nd ne nf ng b">store.count</code>中获取数据。现在让我们转到<code class="fe nd ne nf ng b">apps/dashboard/src</code>，创建<code class="fe nd ne nf ng b">Dashboard.jsx</code>，并添加以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">仪表盘</p></figure><p id="750d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nd ne nf ng b">dashboard</code>将使用来自<code class="fe nd ne nf ng b">props</code>的<code class="fe nd ne nf ng b">dispatch</code>来更新<code class="fe nd ne nf ng b">header</code>中的<code class="fe nd ne nf ng b">count</code>。记住，它们都将在不同的港口推出。<br/><code class="fe nd ne nf ng b">host</code>应用程序将包含以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">主机应用程序</p></figure><p id="0637" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们从模块联合插件配置中使用的那些导入，如下所示:</p><pre class="kg kh ki kj gt np ng nq nr aw ns bi"><span id="5bf1" class="nt lt iq ng b gy nu nv l nw nx">import { useStore, StoreProvider } from "store/store";<br/>import RemoteHeader from "header/Header";<br/>import RemoteDashboard from "dashboard/Dashboard";</span></pre><p id="05f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重要的是保持准确的命名，例如:<code class="fe nd ne nf ng b">header/Header</code>，因为从<code class="fe nd ne nf ng b">src</code>中暴露头部组件。<code class="fe nd ne nf ng b">App</code>仅用于演示微前端已经启动:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe nd ne nf ng b">ModuleFederationPlugin configs</code></p></figure><p id="92e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nd ne nf ng b">ErrorBoundary</code>有可能在<a class="ae kv" href="https://reactjs.org/docs/error-boundaries.html" rel="noopener ugc nofollow" target="_blank">的官方文件中找到</a>的反应。造型部分由你决定。我只是用边框组件突出显示了它。</p><p id="9f31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，为了便于说明，我们在<code class="fe nd ne nf ng b">header</code>、<code class="fe nd ne nf ng b">dashboard</code>中添加了我们的组件。虽然<code class="fe nd ne nf ng b">host</code>必须消耗所有这些，但在此之前，让我们创建最后一个微前端:一个外部<code class="fe nd ne nf ng b">store</code>。转到<code class="fe nd ne nf ng b">apps/store/src</code>并创建<code class="fe nd ne nf ng b">store.jsx</code>，在那里添加我们的上下文配置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">外部存储配置</p></figure><p id="7f26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在<code class="fe nd ne nf ng b">3003</code>端口运行商店，并在<code class="fe nd ne nf ng b">host</code>中使用微前端。动作和存储结果委托给<code class="fe nd ne nf ng b">Header</code>和<code class="fe nd ne nf ng b">Dashboard</code>。现在让我们在<code class="fe nd ne nf ng b">host</code>上把所有东西绑在一起。</p><h1 id="af3e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">一起跑</h1><p id="06f1" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">是时候一起运行所有四个微前端了。打开<code class="fe nd ne nf ng b"><a class="ae kv" href="http://localhost:3003/" rel="noopener ugc nofollow" target="_blank">http://localhost:3003</a></code>，可以看到有<code class="fe nd ne nf ng b">Name: store</code>。同样适用于<code class="fe nd ne nf ng b">Header</code>和<code class="fe nd ne nf ng b">Dashboard</code>。如何检查曝光模块？</p><p id="4b76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">点击<code class="fe nd ne nf ng b"><a class="ae kv" href="http://localhost:3002/remoteEntry.js" rel="noopener ugc nofollow" target="_blank">http://localhost:3002/remoteEntry.js</a></code>按钮，你就会得到清单。还记得<code class="fe nd ne nf ng b">ModuleFederationPlugin</code>中config的部分吗？</p><pre class="kg kh ki kj gt np ng nq nr aw ns bi"><span id="48ba" class="nt lt iq ng b gy nu nv l nw nx">filename: "remoteEntry.js",</span></pre><p id="abe2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nd ne nf ng b">Host</code>应用程序使用那些遥控器抓取那些组件:</p><pre class="kg kh ki kj gt np ng nq nr aw ns bi"><span id="1b08" class="nt lt iq ng b gy nu nv l nw nx">remotes: {<br/>  header: 'header@http://localhost:3001/remoteEntry.js',<br/>  dashboard: 'dashboard@http://localhost:3002/remoteEntry.js',<br/>  store: 'store@http://localhost:3003/remoteEntry.js',<br/>}</span></pre><p id="3a95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果您运行从<code class="fe nd ne nf ng b">3000</code>到<code class="fe nd ne nf ng b">3003</code>的所有端口，您将看到类似这样的内容(当然，这取决于样式)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/bf0f893e753dd0f357a4b523ab5a0d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*Or37n7hCHxYWdEQtPMdzIw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自微前端的远程存储</p></figure><p id="fd30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过点击“增量”或“减量”，您将从<code class="fe nd ne nf ng b">localhost:3003</code>中改变外部存储，该模块已经被异步加载。比如说，在Dashboard中，只有当您重新加载页面时，代码更改才会交付给<code class="fe nd ne nf ng b">host</code>，因为您需要再次加载导入。这就是了。</p><p id="22a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了节省时间，我在monorepo的每个项目中都使用了<code class="fe nd ne nf ng b">npx</code>和<code class="fe nd ne nf ng b">create-mf-app</code>。您可以单独创建每个项目，使用不同的React版本，并且只共享需要通用的模块。</p><h1 id="8ab6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="5b51" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">当然，设置需要一些时间，并且很容易在命名或配置文件中出错。但重要的是要明白，我们创建的每个组件都已经成为一个独立的前端项目。</p><h1 id="518d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资源</h1><ul class=""><li id="5bc7" class="mk ml iq ky b kz mm lc mn lf mo lj mp ln mq lr mr ms mt mu bi translated">GitHub库:<a class="ae kv" href="https://github.com/antonkalik/mfm-boilerplate/tree/main" rel="noopener ugc nofollow" target="_blank">https://github.com/antonkalik/mfm-boilerplate/tree/main</a></li><li id="34e6" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">模块联盟插件:<a class="ae kv" href="https://webpack.js.org/concepts/module-federation/" rel="noopener ugc nofollow" target="_blank">https://webpack.js.org/concepts/module-federation</a></li><li id="6690" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">创建模块联盟应用:<a class="ae kv" href="https://github.com/jherr/create-mf-app" rel="noopener ugc nofollow" target="_blank">https://github.com/jherr/create-mf-app</a></li></ul><pre class="kg kh ki kj gt np ng nq nr aw ns bi"><span id="ee30" class="nt lt iq ng b gy nu nv l nw nx"><strong class="ng ir">Want to Connect?</strong></span><span id="ab28" class="nt lt iq ng b gy nz nv l nw nx">I will be glad to be in touch through my <a class="ae kv" href="https://twitter.com/idedycom" rel="noopener ugc nofollow" target="_blank">Twitter</a>.</span><span id="9863" class="nt lt iq ng b gy nz nv l nw nx">It's always a pleasure to receive any suggestions and comments related to the topic. Feel free to ask any questions.</span></pre></div></div>    
</body>
</html>