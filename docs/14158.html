<html>
<head>
<title>How to Validate YAML Configs Using Pydantic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Pydantic验证YAML配置</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/validating-yaml-configs-made-easy-with-pydantic-594522612db5?source=collection_archive---------1-----------------------#2022-11-12">https://betterprogramming.pub/validating-yaml-configs-made-easy-with-pydantic-594522612db5?source=collection_archive---------1-----------------------#2022-11-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cfca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">验证YAML配置不再困难</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bb3bfc25852f4dea49f4daff14f62ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVoPRQcGqZrOPSYHHmnOBg.png"/></div></div></figure><p id="4e4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我最近构建了许多YAML配置，甚至构建了一些标准化的YAML配置，专门用于数据监控。</p><p id="5150" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我一直在纠结的一件事是如何验证YAML模式。我的第一次尝试是将<code class="fe lq lr ls lt b">pytest</code>中的一堆测试组合在一起。虽然这种方法有效，但是对于某些人来说，很难找到预期的模式是什么。</p><p id="d336" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，这不是非常可伸缩的，您必须为每个添加的新测试创建新的<code class="fe lq lr ls lt b">pytest</code>测试。这是行不通的。</p><h1 id="2b18" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">构建一个简单的Pydantic类</h1><p id="a816" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">我决定研究一下如何使用<a class="ae mr" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank"> Pydantic </a>来做到这一点。这篇文章是使用Pydantic来验证YAML配置的一个非常简单的方法。注意，有一个叫做<code class="fe lq lr ls lt b">pydantic-yaml</code>的python库，虽然它看起来很有用，但我发现它太抽象了。</p><p id="7504" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们首先从一个名为<code class="fe lq lr ls lt b">table_tests.yml</code>的YAML配置示例开始。其思想是您指定一个<code class="fe lq lr ls lt b">table_name</code>(即<code class="fe lq lr ls lt b">table_name_1</code>)，您想要为每个测试运行的测试被指定为<code class="fe lq lr ls lt b">test</code>键下的值。这基本上就是<a class="ae mr" href="https://docs.getdbt.com/reference/resource-properties/tests" rel="noopener ugc nofollow" target="_blank"> dbt测试</a>的工作方式。让我们从一个简单的例子开始，您只需要指定测试名称。测试不接受它们自己的任何参数</p><pre class="kj kk kl km gt ms lt mt bn mu mv bi"><span id="c6aa" class="mw lv it lt b be mx my l mz na">-- Example config where we run some tests on a table<br/>table_name_1:<br/>  tests:<br/>    &lt;example test 1&gt;<br/>    &lt;example test 2&gt;</span></pre><p id="7777" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在进入Pydantic。Pydantic是一个数据验证工具(扩展了Python的<code class="fe lq lr ls lt b">dataclass</code>库)。Pydantic背后的主要概念是明确陈述数据假设(通过模型和枚举)。</p><p id="f5dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们定义一个基本的Pydantic类</p><pre class="kj kk kl km gt ms lt mt bn mu mv bi"><span id="93aa" class="mw lv it lt b be mx my l mz na">from enum import Enum<br/>from pydantic import BaseModel, Field<br/>from typing import Dict, Any, List <br/><br/>class TestEnums(str, Enum):<br/>    count_number_rows = 'count_number_rows'<br/>    count_columns = 'count_columns'<br/><br/>class Tests(BaseModel):<br/>    test: List[TestEnums] = Field(..., description="Table tests to run")<br/><br/>class Config(BaseModel):<br/>    yaml_config: Dict[str, Tests]<br/><br/>Config(yaml_config={<br/>  'table_name': {'test': ['count_columns', 'count_number_rows']}<br/>})</span></pre><p id="3007" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将返回一个Pydantic模型</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/ae6dc893f635ee2d705d578833adf86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r2gI2fxtIA4psVeQHX-o8w.png"/></div></div></figure><p id="7218" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以看到，每个<code class="fe lq lr ls lt b">Test</code>现在都是一个<code class="fe lq lr ls lt b">enum</code>，枚举对我们可以通过的测试施加了约束。例如，让我们试着通过一个我们没有创建的测试<code class="fe lq lr ls lt b">count_non_null_rows</code></p><pre class="kj kk kl km gt ms lt mt bn mu mv bi"><span id="39d2" class="mw lv it lt b be mx my l mz na">Config(yaml_config={<br/>  'table_name': {'test': ['count_columns', 'count_non_null_rows']}<br/>})</span></pre><p id="ec42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这抛出了一个相对容易理解的错误:唯一有效的枚举成员(测试)是<code class="fe lq lr ls lt b">count_number_rows</code>和<code class="fe lq lr ls lt b">count_columns</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/677fac2262b041b5170d369f9a996069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JTWNhXt336dTXJQkEZgokQ.png"/></div></div></figure><h1 id="082d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">将Pydantic类应用于YAML配置</h1><p id="e059" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">我们现在有一个Pydantic类，让我们定义一个示例YAML配置。这有两个表，其中<code class="fe lq lr ls lt b">table_name_1</code>有两个测试，而<code class="fe lq lr ls lt b">table_name_2</code>有一个测试。</p><pre class="kj kk kl km gt ms lt mt bn mu mv bi"><span id="ba53" class="mw lv it lt b be mx my l mz na">table_name_1:<br/>    test:<br/>        - count_number_rows<br/>        - count_columns<br/>table_name_2:<br/>    test:<br/>        - count_number_rows</span></pre><p id="7b60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在需要定义一个简单的助手函数来导入这个yaml文件，我们使用了<code class="fe lq lr ls lt b">pyyaml</code>库。</p><pre class="kj kk kl km gt ms lt mt bn mu mv bi"><span id="9a24" class="mw lv it lt b be mx my l mz na">import yaml <br/><br/>def parse_from_yaml(path_to_yaml):<br/>    with open(path_to_yaml) as f:<br/>        config = yaml.safe_load(f)<br/><br/>    return(config)</span></pre><p id="ba7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样，我们现在可以初始化一个Pydantic类</p><pre class="kj kk kl km gt ms lt mt bn mu mv bi"><span id="421a" class="mw lv it lt b be mx my l mz na">## Initialize a Pydantic class from the yaml config<br/>Config(yaml_config=parse_from_yaml(parse_from_yaml(path_to_yaml_file)))</span></pre><p id="76c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">瞧，这是一个成功</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/45d58b2a7a88b4e6197db558044cbdac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fEQRGyZ6bod3IcWdbUqgMg.png"/></div></div></figure><p id="2e5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们来看看如果用户创建了一个包含无效测试的YAML文件会发生什么:</p><pre class="kj kk kl km gt ms lt mt bn mu mv bi"><span id="287c" class="mw lv it lt b be mx my l mz na">table_name_1:<br/>    test:<br/>        - count_number_rows<br/>        - count_columns<br/>table_name_2:<br/>    test:<br/>        - count_number_rows<br/>        - count_non_null_rows --this is not a valid test</span></pre><p id="2005" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行相同的命令:</p><pre class="kj kk kl km gt ms lt mt bn mu mv bi"><span id="acc0" class="mw lv it lt b be mx my l mz na">## Initialize a Pydantic class from the yaml config<br/>Config(yaml_config=parse_from_yaml(parse_from_yaml(path_to_yaml_file)))</span></pre><p id="6aa7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们得到同样的错误，这是一个无效的测试:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/e93ac1cc221dbe370a72125205d0b715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3XEMWSeewbD2LbgK7DF01g.png"/></div></div></figure><h1 id="8e0d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="35f5" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">这只是对Pydantic + YAML的一个基本介绍。通过为每个测试构建Pydantic模型，并使用它们自己的枚举，现在可以很容易地看到如何扩展它来验证强制的<code class="fe lq lr ls lt b">args</code>和可选的<code class="fe lq lr ls lt b">kwargs</code>。</p></div></div>    
</body>
</html>