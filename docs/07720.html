<html>
<head>
<title>Redux, Context, or Recoil: Which One Is Best for Your Modern Web App?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux、Context或反冲:哪一个最适合您的现代Web应用程序？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/redux-context-or-recoil-which-one-is-best-for-your-modern-web-app-db41be99b448?source=collection_archive---------2-----------------------#2021-02-12">https://betterprogramming.pub/redux-context-or-recoil-which-one-is-best-for-your-modern-web-app-db41be99b448?source=collection_archive---------2-----------------------#2021-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9cfa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">全球国家管理中三个竞争者的比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2a54c985fb5c86d89184f8738c1807ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Do_eAEGfGTTF6yAC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@goshua13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约书亚·阿拉贡</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="9d00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着全球国家管理的不断变化，很难知道该选择哪个选项。很长一段时间以来，Redux 一直是首选库，但是随着React本身内置了提供状态管理的<a class="ae ky" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a>，许多人已经宣布Redux已死。现在，随着脸书支持的早期项目<a class="ae ky" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>的发布，我们有了一个React专用的库，可以轻松地与React的最新功能集成。</p><p id="3b39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是哪个最适合你的项目呢？在本文中，我将为每个库集成一个简单的应用程序，并提供一些比较和观察。这些只是我的观点——我绝对没有把我的发现作为事实，最终每个人都会有个人偏好。但我会尽可能客观地展示一些关于性能的实证比较。</p><p id="911e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">TL；DR</strong>——你可以在这里看到最终的代码(每个集成在不同的分支中):<a class="ae ky" href="https://github.com/jogilvyt/redux-context-recoil" rel="noopener ugc nofollow" target="_blank">https://github.com/jogilvyt/redux-context-recoil</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cb1c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">应用程序</h1><p id="502a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我构建了一个简单的待办事项应用程序，它呈现了一个可以删除的项目列表和一个添加新项目的表单。它调用一个带有<code class="fe mz na nb nc b">setTimeout</code>的模拟API来获取结果，创建一个新项目，并从列表中删除一个项目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/34ad4f418f9b1446d1c653f01a56c966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9imOvqb2mmuZDhWN6IUQew.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基本待办事项应用程序</p></figure><p id="d261" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得性能的基线度量，我从根本没有全局状态管理开始。加载app时总共有三次渲染:加载屏幕的初始渲染用了<strong class="lb iu"> 5.3ms </strong>，项目加载后的重新渲染用了<strong class="lb iu"> 7ms </strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/cd15bc6d3a2a481e1f1f7d11c68b38ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YYyjFKSbQM6R342QY9Mg2A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">提取结果后进行渲染</p></figure><p id="d521" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常简单的应用程序，所以性能上的差异不会很大，而在更复杂的应用程序中，情况可能会有所不同。但是这应该让我们对每个库的性能含义有一个非常高层次的了解。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f0b9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在开始之前</h1><p id="3897" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于一个新项目，确保您使用正确的工具来完成工作总是很重要的——所以现在是问自己是否真的需要全局状态管理的好时机。许多简单的应用程序将运行得非常好，并且更容易维护，而不会引入外部库的所有开销，甚至不会引入上下文API。作为UI工程师，我们有点鲁莽地使用每一个闪亮的新工具的名声。不要落入陷阱——在努力集成之前，确保您确实需要一个全局状态管理系统。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b85d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Redux</h1><p id="bc7b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Redux可能是最成熟的全局状态管理工具。它是框架不可知的，这意味着它在整个前端世界都很流行，有一段时间，当你需要超越本地状态时，它确实是唯一的选择。然而，随着最近Context API的加入和新的challenger反冲，Redux还能在一个现代的React app中独领风骚吗？</p><h2 id="70f7" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">表演</h2><p id="12ed" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">先说性能。在初始加载时，只有两次渲染，而基线有三次渲染。但是，总的呈现时间稍长一些，呈现加载状态需要<strong class="lb iu">6毫秒</strong>，获取项目后呈现列表需要<strong class="lb iu">10.6毫秒</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/b5bba8191f4ed39c1e1de447814578b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QolhVTnrvYYubvoYFrJyHw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Redux:获取结果后进行渲染</p></figure><p id="0bff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加新项目后的重新渲染花费了<strong class="lb iu"> 2.9ms </strong>、<strong class="lb iu"> </strong>，删除一个项目后花费了<strong class="lb iu"> 2ms </strong>。总而言之，除了加载应用程序时的初始开销，性能还是相当不错的。</p><h2 id="49d4" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">开发者体验</h2><p id="9a8e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对我来说，这一直是Redux的一大缺点。总感觉需要很多样板文件来让它工作，并且当在一个应用中使用多个reducers时很容易陷入重复。在这个实例中，我们有一个store、一个reducer和三个actions，对于这样一个基本的东西来说，这看起来有很多代码。</p><p id="ce4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，Redux擅长于实施开发人员的最佳实践，为您提供了一个易于遵循的模式，这样您就不必在构建特性时做出太多关于实现的决定。我还喜欢它让你把API请求抽象成动作，这样一切都在一个地方处理。当您知道去哪里更新API调用时，比在组件中查找哪个组件发出请求要容易得多。</p><h2 id="7611" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">用户体验</h2><p id="8fac" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">用Redux管理加载和错误状态需要一些定制的实现。在我的例子中，我跟踪reducer中的一个全局<code class="fe mz na nb nc b">isLoading</code>变量，然后管理每个组件中添加和删除项目的加载状态。这是非常标准的东西，并不难构建，但它是反冲真正发挥作用的领域之一——稍后将详细介绍！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5d74" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">上下文API</h1><p id="ad3c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">新的上下文API是在16.3版本中引入的，旨在提供一种在组件之间共享状态的方式，而不必将其“提升”到一个公共父级。现在，它已被广泛用作存储全局状态的一种方式，尤其是对于更静态的数据，如用户信息或主题首选项。我们来看看它和Redux相比如何。</p><h2 id="21f8" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">表演</h2><p id="a004" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">据说上下文在性能方面不是很好，因为当状态在提供者中更新时，每个使用上下文的组件都将重新呈现，即使与该组件相关的状态没有改变。</p><p id="1f2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的应用程序，加载时有三个呈现:初始加载状态花费了<strong class="lb iu">5.9毫秒</strong>，在获取数据后有一个<strong class="lb iu">2.9毫秒</strong>呈现，最后，花费了<strong class="lb iu">7.6毫秒</strong>来呈现待办事项。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/0806cb327465abd588d7a1c637995aa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SgQ6U9TlS33djJxIlHUGsQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上下文:获取结果后的渲染</p></figure><p id="e1c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来与Redux的渲染时间非常相似。但是，当添加或删除一个项目时，时间会更长:添加一个项目后，<strong class="lb iu"> 4.9ms </strong>重新渲染，删除一个项目后，<strong class="lb iu"> 4.5ms </strong>(相比之下，Redux分别为<strong class="lb iu"> 2.9ms </strong>和<strong class="lb iu"> 2ms </strong>)。</p><h2 id="37b1" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">开发者体验</h2><p id="e6c2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对我来说，这是上下文API真正闪光的地方。它内置在React中，所以如果您发现自己需要全局状态管理，而不需要任何主要的架构更改或添加一个全新的库，可以将它增量地引入到项目中。我也很喜欢与hooks集成的简单性。在这个应用程序中，我创建了一个<code class="fe mz na nb nc b">useToDos</code>钩子，它将状态从上下文中分离出来，然后可以在任何使用它的组件中调用:</p><pre class="kj kk kl km gt nt nc nu nv aw nw bi"><span id="187b" class="nf md it nc b gy nx ny l nz oa">const { toDos } = useToDos();</span></pre><p id="71c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您甚至可以将它与React的<code class="fe mz na nb nc b">useReducer</code>钩子集成在一起，以管理复杂的状态。我发现这是一种非常有用的方法，可以管理具有大量子组件和复杂功能的组件的共享状态。</p><h2 id="2d96" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">用户体验</h2><p id="addc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">处理加载和错误状态的方式与Redux非常相似:我们需要编写一些自定义代码来处理每个加载状态，任何错误处理都需要围绕API调用本身来完成。这就是在Redux操作中使用API请求的用处。对于上下文，我们必须在调用API的任何地方添加错误处理，这意味着一些重复或重构。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="34d6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">报应</h1><p id="1bfb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">反冲是一个新的产品，自从去年宣布以来，它已经引起了一些轰动。它得到了脸书的支持，他的团队也维护React，它很好地集成了许多最新的React功能，如并发模式。它仍处于早期开发阶段，还不建议在生产应用程序中使用。但就其目前的雏形而言，它与我们拥有的其他选择相比如何？</p><h2 id="0995" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">表演</h2><p id="8ea7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">后坐力的初始载荷是三个选项中最慢的。总共有五次渲染，第一次花费了<strong class="lb iu">11.2毫秒</strong>，接下来是两次稍微快一点的重新渲染(<strong class="lb iu">1.1毫秒</strong>和<strong class="lb iu">0.2毫秒</strong>)，然后是一次<strong class="lb iu">5毫秒</strong>重新渲染，一旦待办事项被加载，接着是最后的<strong class="lb iu">1.9毫秒</strong>以将项目渲染到屏幕上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/c2f80a06bd5ba7d2ae4c13ec8bbc8df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r9fOzaNwtHnTxvrF2NoArA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">反冲:仅渲染加载屏幕就花了11.2毫秒</p></figure><p id="a3ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，添加和删除一个项目要快得多:添加一个项目后需要2.4毫秒<strong class="lb iu">重新渲染，删除一个项目后需要3.7毫秒</strong>。这似乎与Redux大体一致。</p><p id="0ea1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里还值得指出的是，反冲包的大小是<strong class="lb iu"> 45.1K </strong>(根据我的<a class="ae ky" href="https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost" rel="noopener ugc nofollow" target="_blank">导入成本</a> VS代码插件)，相比之下redux的大小是<strong class="lb iu"> 11.7K </strong>(合并了Redux和react-redux包)，对上下文没有任何影响，因为它是react的一部分。随着库工作的继续，这种情况可能会改变，但这是需要记住的事情。</p><h2 id="fd8d" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">开发者体验</h2><p id="8203" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">虽然这是我第一次使用反冲，但在了解了原子和选择器之后，我发现它很容易使用。我喜欢你如何在选择器中发出异步请求来初始化API请求的状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d8e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在组件中使用状态也非常容易。它的工作方式与<code class="fe mz na nb nc b">useState</code>类似:</p><pre class="kj kk kl km gt nt nc nu nv aw nw bi"><span id="cd38" class="nf md it nc b gy nx ny l nz oa">const [toDos, setToDos] = useRecoilState(toDosAtom);</span></pre><p id="22d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现一个有点令人困惑的地方是在添加或删除一个项目后更新状态。对于异步选择器，我认为能够有一个类似的setter函数来更新基于API请求响应的状态会很酷。这可能是后来添加的东西；现在，我只是在组件中进行API调用，并将状态设置为响应:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="9193" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">用户体验</h2><p id="3f8f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对我来说，这是反冲真正发光的地方。它集成了React的并发模式，允许您用<code class="fe mz na nb nc b">Suspense</code>处理加载状态，用<code class="fe mz na nb nc b">ErrorBoundary</code>处理错误。这意味着你可以用一种更加声明性的方式来构建你的应用。我能够将我的应用程序包装在一个带有后备的<code class="fe mz na nb nc b">Suspense</code>组件中，它会自然地呈现加载屏幕，直到API请求完成并且待办事项加载完毕。</p><p id="8592" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的一个副作用是，它确实会迫使您做出一些架构决策。可能很难将反冲集成到一个成熟的应用程序中，如果您偏爱以某种方式做事，您可能会在库的约束下努力工作。不过感觉肯定比Redux更React-y。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c92d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="6073" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Redux已经成为全球状态管理的领导者有一段时间了，它肯定不会很快消失。然而，背景和后坐力正在成为严重的竞争者，而且肯定感觉他们和React一起玩得更好。</p><p id="9062" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我倾向于将上下文用于较小的应用程序，在这些应用程序中，轻微的性能影响不会成为问题。至于更大的项目，反冲仍然感觉有一些初期问题，我肯定不会建议在生产应用程序中使用它。但是，假以时日，它似乎可以提供更好的开发人员体验，并最终提供更好的用户体验。看到反冲与React的新功能集成得如此之好令人兴奋，随着我们开始在应用程序中使用这些功能，我认为反冲将成为全局状态管理的自然选择。</p><p id="14ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读，如果您不确定哪个全局状态管理库适合您，我希望您会觉得这很有帮助。</p></div></div>    
</body>
</html>