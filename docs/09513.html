<html>
<head>
<title>Understanding Kotlin Coroutines for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者理解Kotlin协程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-kotlin-coroutines-for-beginners-a55813f8241c?source=collection_archive---------1-----------------------#2021-09-03">https://betterprogramming.pub/understanding-kotlin-coroutines-for-beginners-a55813f8241c?source=collection_archive---------1-----------------------#2021-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="35fd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这太简单了，以至于感觉像是在作弊</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/32df676cf3a569603d4f1726d596ae59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L2K8QeSWABkQuf81"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@adrien?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿德里安</a>拍摄于<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="1d83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经使用了异步回调，尤其是在Kotlin中编写异步代码。这里有一个场景，在网络请求完成后，您应该执行一些数据库查询。</p><p id="67b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将这样编写异步回调:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="425a" class="ma mb it lw b gy mc md l me mf">// Async callbacks<br/>networkRequest { result -&gt;</span><span id="f4bd" class="ma mb it lw b gy mg md l me mf">// Successful network request<br/>   databaseSave(result) { rows -&gt;</span><span id="3b5b" class="ma mb it lw b gy mg md l me mf">// Result saved</span><span id="793a" class="ma mb it lw b gy mg md l me mf">// If there are more dependent operations<br/>     // This nested code will only increase</span><span id="30cb" class="ma mb it lw b gy mg md l me mf">   }<br/>}</span></pre><p id="4237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们可以编写实际上异步执行的顺序代码会怎么样？</p><p id="c3e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在Android中，我们必须管理不同的线程，事情会变得更加复杂，因为我们必须担心线程间的通信，以从一些后台线程更新我们的主线程。</p><p id="f83d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RxJava确实有帮助，但还是有点复杂。协程在更大程度上简化了事情，使得管理不同的后台任务变得超级简单！</p><h1 id="ffa1" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">协同程序</h1><p id="ae0b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">协程不是线程。如果协程就像一个作业，那么您可以在同一个线程上独立运行多个作业。</p><p id="f703" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在协程内部调用<code class="fe nd ne nf lw b">Thread.sleep()</code>,它将停止整个线程和所有并行执行的协程。</p><p id="a0d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用协程程序，上面的代码块将如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3850" class="ma mb it lw b gy mc md l me mf">val result = networkRequest()<br/>// Successful network request</span><span id="1380" class="ma mb it lw b gy mg md l me mf">databaseSave(result)<br/>// Result saved</span></pre><p id="2b12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来可读性更好，更干净，也更容易管理。协同程序将帮助你用Kotlin简化很多异步代码。</p><h1 id="6b47" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">向您的Android项目添加协程</h1><p id="e400" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">你可以按照这里提到的<a class="ae ky" href="https://github.com/Kotlin/kotlinx.coroutines" rel="noopener ugc nofollow" target="_blank">的步骤</a>。</p><p id="6847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，我只需添加以下依赖项:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="32d6" class="ma mb it lw b gy mc md l me mf">implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.1'</span></pre><h1 id="b1a1" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">“暂停”关键字</h1><p id="b4aa" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当你在函数声明中添加<code class="fe nd ne nf lw b">suspend</code>关键字时。您声明了这个函数将被异步执行，并且它的执行也可以被暂时暂停。</p><p id="ff89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="bd60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的重要一点是，一个挂起函数可以从另一个挂起函数或协程中调用。</p><p id="0e53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你试图在按钮的<code class="fe nd ne nf lw b">onClick</code>监听器中调用这些模拟函数，你会得到一个错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/e7a442ea76d09c99af578e75a27f5b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4XcSfeWPXA5leuSQTu_YfA.png"/></div></div></figure><p id="428f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们看看如何启动我们的协程。</p><h1 id="7b7c" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">协程作用域</h1><p id="5f37" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">使用协程，您可以创建一批您想做的作业。你的工作可能有一定的背景/标准/范围。</p><ul class=""><li id="679d" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">如果一个作业失败，您可能希望取消其他作业。</li><li id="700b" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">您可能希望将一组作业组合在一起。</li></ul><p id="0860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有三种类型的协程:</p><ul class=""><li id="c464" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated"><strong class="lb iu"> Main — </strong>这个范围内的作业将在主线程上工作。</li><li id="e688" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu"> IO </strong> —这是一个后台线程，用于执行IO操作，如网络调用/从数据库读取。</li><li id="9ad3" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu">默认</strong> —这是为您可能希望在后台执行的繁重操作(如下载文件等)而设计的。</li></ul><p id="e6e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在<code class="fe nd ne nf lw b">onClick</code>函数中调用我们的协程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="89ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行它时，我们得到以下日志:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e4b5" class="ma mb it lw b gy mc md l me mf">D/DEEJAY: getMockDataFromAPI called<br/>D/DEEJAY: getMockDataFromAPI returning data<br/>D/DEEJAY: writeMockDataToDatabase called<br/>D/DEEJAY: Data saved in database Some cool data</span></pre><h2 id="bc86" class="ma mb it bd mi nx ny dn mm nz oa dp mq li ob oc ms lm od oe mu lq of og mw oh bi translated"><strong class="ak">体会到花冠的美？</strong></h2><p id="79ad" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们只是以同步的方式写了一些更易读的异步代码。</p><p id="33ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它变得更加美丽…</p><p id="bf9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，假设在异步代码执行之后，您想要更新UI。</p><h2 id="2bb3" class="ma mb it bd mi nx ny dn mm nz oa dp mq li ob oc ms lm od oe mu lq of og mw oh bi translated">你如何从你的协程中更新主线程？</h2><p id="da8c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果您的协程没有在主线程上执行，我们有两个选项可以通过执行以下操作在主线程上执行某些东西:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f4d1" class="ma mb it lw b gy mc md l me mf">// #1 You can update the main thread by doing from inside // of Coroutine or a Suspend Function:</span><span id="1b39" class="ma mb it lw b gy mg md l me mf">withContext(Main) {<br/>    textView.text = apiResponseData<br/>}<br/><br/>// #2 Or this too<br/>CoroutineScope(Main).launch {<br/>    textView.text = apiResponseData<br/>}</span></pre><ul class=""><li id="7c7b" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated"><code class="fe nd ne nf lw b">withContext(Main)</code> —暂时将当前协程的上下文/范围切换到<code class="fe nd ne nf lw b">Main</code>来完成您的工作，然后只有父协程将继续执行(父协程等待这个块被执行)。</li><li id="c12b" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><code class="fe nd ne nf lw b">CoroutineScope(Main).launch</code> —在父协程内创建并启动一个新的独立协程。父协程不会等待这个块被执行，而是继续独立执行。</li></ul><p id="d3b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这么简单！真的！</p><p id="3618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我强烈建议我的开发伙伴们继续前进，到处添加日志语句，用延迟值来了解更多关于我们的协程行为的信息。</p><h1 id="abb1" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">深入探究协程</h1><h2 id="a583" class="ma mb it bd mi nx ny dn mm nz oa dp mq li ob oc ms lm od oe mu lq of og mw oh bi translated">1.作业超时</h2><p id="c9f8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">比方说，当你试图下载一个文件，但服务器没有任何反应。你的应用程序应该在尝试十秒钟后让请求超时。</p><p id="f0fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建协同作业时，可以使用<code class="fe nd ne nf lw b">launch{}</code>或<code class="fe nd ne nf lw b">withTimeoutOrNull</code>。还有更多选择，但首先我们来看看<code class="fe nd ne nf lw b">withTimeoutOrNull</code>。</p><p id="e70c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试在代码中模拟下载作业:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="975e" class="ma mb it bd mi nx ny dn mm nz oa dp mq li ob oc ms lm od oe mu lq of og mw oh bi translated">2.取消工作</h2><p id="bec0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您可以为您的作业创建一个<code class="fe nd ne nf lw b">Job</code>实例。有一个<code class="fe nd ne nf lw b">CompletableJob</code>界面，您可以利用它来更好地控制您的工作执行。</p><p id="c1d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它看起来会像这样:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="22f5" class="ma mb it lw b gy mc md l me mf">private lateinit var job: CompletableJob</span></pre><p id="9bf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要初始化作业，您只需执行以下操作:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0e66" class="ma mb it lw b gy mc md l me mf">job = Job()</span></pre><p id="aa19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是事情变得更有趣的地方！</p><p id="9303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您创建了一个身份验证作业，该作业进行网络调用以对用户进行身份验证，该作业有多种可能失败的情况，您必须针对这些情况更新用户，例如:</p><ul class=""><li id="4f64" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">用户未注册</li><li id="74f8" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">无效的登录凭据</li><li id="f1e6" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">网络错误</li><li id="7fbe" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">服务器错误</li></ul><p id="04f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们按照传统的方式来做，代码会变得混乱，但是…</p><p id="2aa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个<code class="fe nd ne nf lw b">.invokeOnCompletion</code>方法，您可以在其中定义逻辑来处理您的作业完成所遵循的逻辑。</p><p id="c1e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在作业上调用方法，如下所示。它为您提供了<code class="fe nd ne nf lw b">it</code>的实例，这是一个可抛出的实例，您可以在作业执行失败时从作业内部抛出。</p><p id="f322" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当我们的作业遇到任何可能的异常时，将执行<code class="fe nd ne nf lw b">invokeOnCompletion</code>,并且可以从这里处理错误场景，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/dd4cc03264b634f670da0cb31a805a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*WsCSoyweD1tN0ecYT3atmg.png"/></div></figure><h2 id="0485" class="ma mb it bd mi nx ny dn mm nz oa dp mq li ob oc ms lm od oe mu lq of og mw oh bi translated">3.在范围内传递作业</h2><p id="d0a2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">要在后台线程中启动我们的作业，我们可以这样做:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0c77" class="ma mb it lw b gy mc md l me mf">CoroutineScope(IO).launch <strong class="lw iu">{ <br/>    </strong>// Async Logic<br/><strong class="lw iu">}</strong></span></pre><p id="ec19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你要清除整个范围，你会这样做</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="948c" class="ma mb it lw b gy mc md l me mf">CoroutineScope(IO).cancel()</span></pre><p id="3e0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将取消在协程的IO范围内运行的所有可能的作业。</p><p id="e1cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的方法是将您的作业传递给协程上下文，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8a10" class="ma mb it lw b gy mc md l me mf">// To create a scope just for your job<br/>CoroutineScope(IO + job).launch {}</span><span id="eb79" class="ma mb it lw b gy mg md l me mf">// To cancel the scope just for your job, now you can do:<br/>CoroutineScope(IO + job).cancel()</span></pre><h2 id="f7bc" class="ma mb it bd mi nx ny dn mm nz oa dp mq li ob oc ms lm od oe mu lq of og mw oh bi translated">4.执行并行作业</h2><p id="d106" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们创建两个作业:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4dc9" class="ma mb it lw b gy mc md l me mf">CoroutineScope(IO).launch <strong class="lw iu">{<br/>    </strong>val job1 = CoroutineScope(IO).launch <strong class="lw iu">{<br/>        </strong>// Job 1<br/>    <strong class="lw iu">}<br/><br/>    </strong>val job2 = CoroutineScope(IO).launch <strong class="lw iu">{<br/>        </strong>// Job 2<br/>    <strong class="lw iu">}<br/>}</strong></span></pre><p id="d8f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用上面的代码，我们的代码将启动<code class="fe nd ne nf lw b">job1</code>，而不是等待它完成，它将开始执行，然后<code class="fe nd ne nf lw b">job2</code>也将启动。</p><p id="5e02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想让您的作业按顺序执行，在这种情况下，<code class="fe nd ne nf lw b">job2</code>取决于<code class="fe nd ne nf lw b">job1</code>结果。你可以像这样使用<code class="fe nd ne nf lw b">.join()</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="cc16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并行作业的另一种工作方式是使用<code class="fe nd ne nf lw b">Deferred</code>类型。让我用下面的代码快速演示一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nd ne nf lw b">Deferred</code>类型的好处是结果值实际上存储在<code class="fe nd ne nf lw b">job3</code>和<code class="fe nd ne nf lw b">job4</code>变量中。</p><p id="870e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而<code class="fe nd ne nf lw b">job1</code>和<code class="fe nd ne nf lw b">job2</code>保存对协程的引用，其中值被卡住。因此，哪一种是最干净的解决方案取决于您的编码风格。</p><p id="d322" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果您需要协程之外的结果，那么应该选择<code class="fe nd ne nf lw b">Deferred async and await</code>模式。</p><h2 id="a473" class="ma mb it bd mi nx ny dn mm nz oa dp mq li ob oc ms lm od oe mu lq of og mw oh bi translated">5.阻塞线程中的其他作业协同作业</h2><p id="85a1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果您想独占运行一个作业，并想确保没有其他作业被执行，您可以使用<code class="fe nd ne nf lw b">runBlocking {}</code>。让我们看看下面的代码是如何做到的:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fd1e" class="ma mb it lw b gy mc md l me mf">CoroutineScope(Main).launch <strong class="lw iu">{   <br/>    </strong>runBlocking <strong class="lw iu">{ <br/>        </strong>// Until this block gets executed<br/>        // No other jobs would be executed<br/>        // On this scope of current coroutine<br/>    <strong class="lw iu">}<br/>}</strong></span></pre><h2 id="bfd6" class="ma mb it bd mi nx ny dn mm nz oa dp mq li ob oc ms lm od oe mu lq of og mw oh bi translated">6.全球范围</h2><p id="4f3a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有一个定义全局范围的选项。对于只有一份独立工作的简单情况来说，这很好。</p><p id="775d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在这种情况下，你在处理依赖的作业，你会将它们嵌套在不同的作用域中，并且会应用你编写代码的方式来维护它们之间的同步。</p><p id="0bf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你正常启动两个工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您使用全局范围创建作业，它将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="e1e6" class="ma mb it bd mi nx ny dn mm nz oa dp mq li ob oc ms lm od oe mu lq of og mw oh bi translated">7.异常处理</h2><p id="5f60" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如何处理子作业中的异常？只需执行以下操作:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f6cf" class="ma mb it lw b gy mc md l me mf">// 1. Create an exception Handler<br/>val coroutineExceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable -&gt; <br/>    // This will just throw the exception here if not handled<br/>}</span><span id="7625" class="ma mb it lw b gy mg md l me mf">// 2. In parent job's launch(), pass the handler<br/>val parentJob = CoroutineScope(IO).launch(coroutineExceptionHandler) { <br/>    // Child jobs here<br/>}</span></pre><p id="1b1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有多个正在运行的作业，并且其中一个作业引发了异常，那么如果您不处理该异常，该作业以及其他正在运行的作业将被取消。</p><p id="eff7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您处理异常，那么其他作业和父作业将成功完成。</p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><p id="cf25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协程还有更多的内容，但是我将在后面提供更多的信息和更实际的例子。</p><p id="bf72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读和时间。</p><p id="55ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>