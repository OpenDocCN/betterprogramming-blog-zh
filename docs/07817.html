<html>
<head>
<title>Routing and Data Fetching in Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js中的路由和数据获取</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/routing-and-data-fetching-in-next-js-aa3c7f3e2481?source=collection_archive---------1-----------------------#2021-02-23">https://betterprogramming.pub/routing-and-data-fetching-in-next-js-aa3c7f3e2481?source=collection_archive---------1-----------------------#2021-02-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="87ae" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基于文件的路由器和动态路由使用指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/865ffdede527a351a3b35c47970b64c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GSQ8LfR9AkzObc22"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马特·邓肯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="b12c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将涵盖:</p><ul class=""><li id="0ee0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如何渲染不同路线上的特定组件？</li><li id="2a88" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">静态生成和服务器端生成的区别。</li><li id="b60e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">用<code class="fe mj mk ml mm b">getStaticProps</code>提取数据。</li><li id="cbd0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">用<code class="fe mj mk ml mm b">getStaticPaths</code>获取数据并动态生成路线。</li><li id="d68a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">通过<code class="fe mj mk ml mm b">getServerSideProps</code>获取服务器端的API数据。</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="9c6f" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">介绍</h1><p id="0b77" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">有一天，一个客户雇佣你在React为他们建一个网站。这些是他们的要求:</p><ul class=""><li id="8717" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">不应该是传统的单页web app。相反，该网站应该有单独的页面，将在各自的路线上呈现。</li><li id="3281" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">因为网站应该是静态的，所以性能是最重要的。</li></ul><p id="684e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“没问题，”你告诉他们。“我之前已经用过<a class="ae ky" href="https://medium.com/better-programming/react-routers-explained-ff89153a6405" rel="noopener"> React路由器</a>。这项工作将毫不费力。”但是，既然是静态网站，你希望网站的性能暴涨。"我如何建立一个高性能的网站？"你扪心自问。</p><p id="8c2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过一番研究，你发现有一个框架叫做<a class="ae ky" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>。</p><h2 id="3721" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">什么是Next.js，应该在什么时候使用？</h2><p id="6cc4" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Next.js的诞生导致许多开发人员从plain React跳槽到Next.js。当然，肯定有什么东西使它与众不同，对吗？</p><p id="aedc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对此，我的回答是肯定的。根据这篇<a class="ae ky" href="https://www.notion.so/NextJS-217a86d17f094fcb8b5fec13b383a6c9#e70d0cb76421435d8d18f6db3273505c" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>的帖子，这个库利用了一个易于使用的路由系统，允许程序员在特定的路由上显示特定的组件。此外，它还支持服务器端渲染。这种方法允许加载时间随时间分布，从而提高性能。此外，根据<a class="ae ky" href="https://www.youtube.com/watch?v=rtgbaKBhdkk" rel="noopener ugc nofollow" target="_blank">Lee Robinson</a>(next . js的撰稿人)的说法，这项技术可以让你在每页的基础上灵活地使用服务器端或客户端渲染。</p><p id="c526" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能想知道，“那么为什么不在React路由器中使用普通React呢？没有必要学习另一个框架。”对此，我的回答是，简单来说，如果你的应用变得更大更复杂，性能就会退居二线。如果你的应用程序运行缓慢，没有人会想使用它。Next.js通过缩减JavaScript、缓存构建和其他技术来确保最大的响应能力，从而解决了这个问题。</p><p id="b4e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，它使路由更容易，并确保您的静态网站的最高性能。</p><p id="1c25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们把脚弄湿。作为第一步，我们将学习简单的基于文件的路由。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="7be2" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">基于文件的路由</h1><h2 id="c824" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">设置</h2><p id="0282" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">要初始化项目，请运行以下终端命令:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/32e56e398b6029cc3f66810e3e15795b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ob1_PQabA68ONt7oP94jcg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">终端命令写入</p></figure><p id="d12c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导航到项目的<code class="fe mj mk ml mm b">/pages</code>目录。在那里，找到<code class="fe mj mk ml mm b">index.js</code>文件。在<code class="fe mj mk ml mm b">/pages/index.js</code>中，找到<code class="fe mj mk ml mm b">Home</code>组件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/25db90d0a9f4f51137fce4f0f087714f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZl9d3F5fghr1UYaB-KfPQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在/pages/index.js中查找的代码</p></figure><p id="bb7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将其替换为以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/73eaf543e03bb7c985588c01aea95707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JSv9ChBB_eykju53bMic4w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在/pages/index.js中替换的代码</p></figure><p id="c1c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用以下命令运行代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/3fcf0d6d4336fdb256424c760b7e8377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zw2vXMVP498MXOv5Fwl46g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行代码的终端命令</p></figure><p id="c5e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要查看输出，请转到<code class="fe mj mk ml mm b">localhost:3000</code>。这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/c2553eaadf79c9a8ac0779aa22d56699.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*Yo3tuu6v-m1pFFW_2UzrCw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="7f16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，让我们继续为我们的应用程序创建简单的页面。</p><h2 id="37e6" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">创建页面</h2><p id="3e2a" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Next.js中的每个页面都由一个React组件驱动。为了创建页面组件，Next.js依赖于<code class="fe mj mk ml mm b">/pages</code>目录。此外，这些页面与其文件名相关联。例如:</p><ul class=""><li id="acbc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">当你转到<code class="fe mj mk ml mm b">/about</code>路径时，<code class="fe mj mk ml mm b">pages/about.js</code>中的组件被渲染。</li><li id="f1b7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">同样，如果您转到<code class="fe mj mk ml mm b">/contact</code>路径，Next.js会呈现位于<code class="fe mj mk ml mm b">pages/contact.js</code>中的组件。</li><li id="0e69" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">此外，如果导航到<code class="fe mj mk ml mm b">/todo/helloworld.js</code>，浏览器中将显示<code class="fe mj mk ml mm b">pages/todo/helloworld.js</code>中的组件。</li><li id="9296" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当你转到<code class="fe mj mk ml mm b">/</code>(根)目录时，<code class="fe mj mk ml mm b">pages/index.js</code>中的组件被渲染。</li><li id="ecfe" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果转到<code class="fe mj mk ml mm b">/todo</code>，将显示<code class="fe mj mk ml mm b">todo/index.js</code>中的React组件。</li></ul><p id="21cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="og">注:</em> <code class="fe mj mk ml mm b"><em class="og">index.js</em></code> <em class="og">文件是此规则的例外。</em></p><p id="f687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经讨论了这个概念的工作原理，现在让我们用代码实现它。</p><p id="13aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的<code class="fe mj mk ml mm b">/pages</code>目录中，创建一个名为<code class="fe mj mk ml mm b">about.js</code>的文件。在那里，编写以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/4f544965aa304947876f6c9cb1b360a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gS7YkqbwYB_J9Ov-2AbqRg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要写入/pages/about.js的代码</p></figure><ul class=""><li id="e8a8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第1行:创建<code class="fe mj mk ml mm b">About</code>组件，然后导出它，以便它可以在项目中使用。</li></ul><p id="cea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行代码。这将是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/49e45f66196dbcaeae47b6f586f2996b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/1*1DcG6TytVX0UPeuxp74AUg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="187e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们的代码有效！当我们导航到<code class="fe mj mk ml mm b">/about</code>目录时，<code class="fe mj mk ml mm b">pages/about.js</code>组件被呈现到页面上。</p><p id="2eb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，我们甚至可以编写代码在应用程序中实现子路由。为此，在<code class="fe mj mk ml mm b">/pages</code>目录中创建一个名为<code class="fe mj mk ml mm b">contact</code>的文件夹。在<code class="fe mj mk ml mm b">contact</code>目录中，创建一个名为<code class="fe mj mk ml mm b">index.js</code>的文件。在<code class="fe mj mk ml mm b">/pages/contact/index.js</code>文件中，编写以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/39ad6e9fb37f4c1848294b685a185862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N6H0fEV7_YY7q7YlHf1o-A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要写入/pages/contact/index.js的代码</p></figure><p id="7f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们在<code class="fe mj mk ml mm b">/pages/contact</code>目录中创建另一个名为<code class="fe mj mk ml mm b">helloworld.js</code>的组件。在<code class="fe mj mk ml mm b">/pages/contact/helloworld.js</code>中，编写下面这段代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/5abbd72a8cfa3f8107e25fb586c69ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CDVOZEB9bKUjHDc7WuiqFQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在pages/contact/helloworld.js中编写的代码</p></figure><p id="c2e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行代码。这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/3acd718c20342c2bb57754da11c1dd86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/1*_nWOa-Qzv-0Dmiljo923nQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="cefe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们的代码有效！当用户导航到<code class="fe mj mk ml mm b">/contact</code>路线时，渲染<code class="fe mj mk ml mm b">contact/index.js</code>文件。但是，当客户端转到<code class="fe mj mk ml mm b">/contact/helloworld</code>路径时，<code class="fe mj mk ml mm b">ContactHello</code>组件会显示自己。</p><p id="4281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从我们需要编写的代码量来看，显然Next.js让开发人员在我们的项目中编写路由代码变得非常容易。</p><p id="e1a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将学习动态路由的基础知识。</p><h2 id="7e91" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">动态路由</h2><p id="2615" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">让我们假设你的网站上有一个各种人的联系信息的目录。在这种情况下，您可能希望用<code class="fe mj mk ml mm b">/contact/{id}</code>格式对您的路线进行编码，其中<code class="fe mj mk ml mm b">{id}</code>是包含列表中特定人员的ID的参数。例如:</p><ul class=""><li id="dc37" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">contact/1</code>显示列表中第一个联系人的信息。</li><li id="72b5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">以类似的方式，<code class="fe mj mk ml mm b">contact/2</code>给我们第二次联系的数据，等等。</li></ul><p id="4ea8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们该怎么做呢？一个可能的解决方案是让我们的<code class="fe mj mk ml mm b">/pages</code>目录具有以下文件结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/4c8d412acac3222feb0f5bbdd76a80cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*QWL4xQL9qSyYSV31FUWGEA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">处理三个联系人项目</p></figure><p id="f6e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，那可能有用。但是，如果我们有数百个联系人项目呢？这将使得为更多的联系人编写更多的代码变得极其乏味和耗时。幸运的是，Next.js已经有了这样的系统。</p><p id="07fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的<code class="fe mj mk ml mm b">pages/contact</code>文件夹中，创建一个名为<code class="fe mj mk ml mm b">[id].js</code>的文件。这个<code class="fe mj mk ml mm b">[id].js</code>文件将在用户导航到<code class="fe mj mk ml mm b">/contact/{id}</code>路线时呈现，其中<code class="fe mj mk ml mm b">{id}</code>是一个参数。</p><p id="53b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mj mk ml mm b">/pages/contact/[id].js</code>中，编写以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/8e9c435358a9decd18ae2c966e414689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zbh0WK_yN1jZB2qLnMZZVQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要写入/pages/contact/[id]的代码。射流研究…</p></figure><p id="9a85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在运行代码。这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/72db58970f909dc450ed3ef539bda039.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/1*_B_4tQ-YQcEcrW48ze7p-g.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="a2a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，当我们导航到<code class="fe mj mk ml mm b">/contact/{id}</code>页面时，我们的组件被渲染。这意味着我们的代码有效！</p><p id="52de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，还有一个问题:我们如何提取<code class="fe mj mk ml mm b">{id}</code>参数？这就是<code class="fe mj mk ml mm b">useRouter</code>挂钩的用武之地。</p><h2 id="fb52" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">用户外部挂钩</h2><p id="36f3" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe mj mk ml mm b">useRouter</code>钩子本质上告诉我们关于URL的信息(例如，用户当前所在的路线或参数)。在本文中，我们将只关注参数。</p><p id="728c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mj mk ml mm b">/pages/contact/[id].js</code>中，找到下面这段代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/038275ab46fac806dce7c45e38da3f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*btRLoEXNMckyzDwGo5QaZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在/pages/contact/[id]中查找的代码。射流研究…</p></figure><p id="c150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在将其替换为以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/d45a49a32ed5b28e2b2cf4d01e6917d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XvRMyp6ZiMNDBU7o009q9Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用in /pages/contact/[id]替换的代码。射流研究…</p></figure><ul class=""><li id="1818" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第1行:导入<code class="fe mj mk ml mm b">useRouter</code>挂钩。</li><li id="e660" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第3行:创建一个<code class="fe mj mk ml mm b">useRouter</code>实例，它将为我们提供关于当前路线中有哪些参数的数据。</li><li id="a879" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第4行:使用<a class="ae ky" href="https://www.javatpoint.com/es6-object-destructuring" rel="noopener ugc nofollow" target="_blank">对象析构</a>从位于<code class="fe mj mk ml mm b">useRouter</code>实例中的<code class="fe mj mk ml mm b">query</code>对象中提取<code class="fe mj mk ml mm b">id</code>参数。</li></ul><p id="f85a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在剩下的就是显示ID了。在<code class="fe mj mk ml mm b">/pages/contact/[id].js</code>中，找到你的<code class="fe mj mk ml mm b">return</code>块:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/30b8ec535a2b3cdffed1b0c794ac5d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L0-V8Op38k8KIu69AJP0PQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在/pages/contact/[id]中查找的代码。射流研究…</p></figure><p id="666d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在像这样替换它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/b402a4d984a619f4623efa72c6a75afa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iXv9hrCJlufnVABCqztaXg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用in /pages/contact/[id]替换的代码。射流研究…</p></figure><ul class=""><li id="74ea" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第3行:显示当前的<code class="fe mj mk ml mm b">id</code>参数。</li></ul><p id="1060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行代码。这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/d766477d6c32f094cdebe12847e191fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/1*fQ2FW9SKIRHnheL-FOqIPA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="3229" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！我们的代码有效。如您所见，我们的页面显示了当前的<code class="fe mj mk ml mm b">id</code>参数。</p><p id="8f38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在已经完成了这一部分。在本文的下一部分，我们将学习如何通过Next.js框架从API获取数据。</p><p id="c5f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，<code class="fe mj mk ml mm b">/pages/contact/[id].js</code>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="04ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/HussainArif12/next-file-routing" rel="noopener ugc nofollow" target="_blank"> <em class="og">本节GitHub回购</em> </a></p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c217" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">从外部API获取数据</h1><h2 id="7d87" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">设置</h2><p id="1a69" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">这个过程与上一节类似。然而，我们的存储库的名称被设置为<code class="fe mj mk ml mm b">next-api-fetch</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/7338cc0dbb9f8c5d7b098155ccfb9bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFP1B9BZTljGHd9CUBARCA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">初始化repo的终端命令</p></figure><p id="63d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，我们将首先了解服务器端生成和静态生成的区别。</p><h2 id="d107" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">静态侧发电</h2><p id="dc43" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">假设您正在从<a class="ae ky" href="https://jsonplaceholder.typicode.com/todos" rel="noopener ugc nofollow" target="_blank">待办事项API </a>获取数据，并显示所有项目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/2b35390a613adbed9e802845060ee8cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/0*PjjNNJ093Dzx6dJT"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">待办事项API中的项目列表</p></figure><p id="ade1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您告诉Next.js构建这个页面时，JavaScript代码被编译并转换成HTML，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/ea8c1f20cc938dc0ce01a12dc8195952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QsfsrGyk3zwr_URRLhlouQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">转换的HTML代码</p></figure><p id="9d72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些HTML代码是提供给用户的，而不是在每次请求时都呈现JavaScript。因此，渲染过程很快。</p><p id="2f68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，由于这个待办事项API中的项目是静态的(它们不会很快改变)，静态生成是一个很好的用例。</p><p id="1f69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们了解一下服务器端生成。</p><h2 id="67cc" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">服务器端生成</h2><p id="95c7" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">作为一个例子，让我们使用这个<a class="ae ky" href="https://www.thesportsdb.com/api.php" rel="noopener ugc nofollow" target="_blank">体育API </a>来获取实况足球比赛的比分。在这里，数据是实时变化的。因此，Next.js缓存这段代码的结果是没有意义的，因为它会在用户每次刷新页面时发生变化。</p><p id="9543" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，服务器端生成非常合适。</p><p id="7a25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，对于不经常变化的数据使用静态生成，而对于经常变化的数据使用后者。</p><p id="2280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经了解了生成的方法，让我们了解一下<code class="fe mj mk ml mm b">getStaticProps</code>方法。</p><h2 id="8143" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">使用getStaticProps提取</h2><p id="7b0d" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">顾名思义，<code class="fe mj mk ml mm b">getStaticProps</code>方法使用静态端生成。我们将使用<a class="ae ky" href="https://jsonplaceholder.typicode.com/todos" rel="noopener ugc nofollow" target="_blank">待办事项API </a>。</p><p id="f04e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mj mk ml mm b">pages/index.js</code>中，在文件末尾写下以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><ul class=""><li id="11db" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第1行:导出<code class="fe mj mk ml mm b">getStaticProps</code>函数。</li><li id="8c36" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第2行:在To-Dos API上执行一个<code class="fe mj mk ml mm b">fetch</code>函数，并将原始数据存储到<code class="fe mj mk ml mm b">res</code>变量中。</li><li id="98ea" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第3行:将原始数据转换成JSON并存储到<code class="fe mj mk ml mm b">todos</code>变量中。</li><li id="c836" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第5行:将转换后的数据作为道具发送。</li></ul><p id="af86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在已经将提取的数据导出为道具。最后一步是显示它。</p><p id="a14b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mj mk ml mm b">/pages/index.js</code>中，找到下面这段代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/9c42fe6434dcd85b48851a0269a707d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d_zIn4yJTPPA9PdQbN1rzg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在/pages/index.js中查找的代码</p></figure><p id="6a08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用下面的代码片段替换它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/2a9ab9924755eb4c1aeb4c10c9278009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gD4f9Q-fX2bcEO8KRd5vcg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在/pages/index.js中替换的代码</p></figure><ul class=""><li id="f6c2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第1行:引入作为道具从<code class="fe mj mk ml mm b">getStaticProps</code>方法接收的<code class="fe mj mk ml mm b">todos</code>对象。</li><li id="dedb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第4行:在数组上使用<code class="fe mj mk ml mm b">map</code>方法，显示每一项的<code class="fe mj mk ml mm b">title</code>字段。</li></ul><p id="27db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行代码。这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/3c2fc8f6004550f3b64cc6ce1d13b2d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*HKvNn-B3KnUbj4pA5OC4eQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="3185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们的代码有效！我们能够在页面上显示所有的项目。</p><p id="041b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe mj mk ml mm b">pages/index.js</code>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="e460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个理想的世界中，我们希望我们的每一个项目将我们带到一个单独的页面，在那里显示它的其余属性。为了实现这一目标，我们可以这样做:</p><ul class=""><li id="cdaa" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用一个<code class="fe mj mk ml mm b"><a class="ae ky" href="https://nextjs.org/docs/api-reference/next/link" rel="noopener ugc nofollow" target="_blank">Link</a></code>组件，以便每个项目都是“可点击的”</li><li id="a995" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当一个项目被点击时，它会把我们带到另一个带有<code class="fe mj mk ml mm b">/todo/{id}</code>路径的页面，其中<code class="fe mj mk ml mm b">id</code>是待办事项列表项目的ID。</li><li id="22e6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在<code class="fe mj mk ml mm b">/todo/{id}</code>页面，对ID字段为<code class="fe mj mk ml mm b">{id}</code>的待办事项执行<code class="fe mj mk ml mm b">fetch</code>请求。</li><li id="1f91" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在<code class="fe mj mk ml mm b">/todo/{id}</code>页面上显示该项目的所有字段。</li></ul><p id="13d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们用代码实现它。在<code class="fe mj mk ml mm b">/pages/index.js</code>中，首先将<code class="fe mj mk ml mm b">Link</code>导入到您的项目中，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/bb045f8022a3f284657358ec715c1998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FMMqjDQSG-M2MVvDx8k8gQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要写入/pages/index.js的代码</p></figure><p id="385b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在同一个文件中找到下面这段代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/3087b27c64955deefb84d0709dedeb60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VHPe2rxViVkMRJM3Aw-E_w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在/pages/index.js中查找的代码</p></figure><p id="0e48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样改变它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/1e25bc3c6de65ff2a724f2da83228716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dGFVhCgoX5ETeQ5QTERAlA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在/pages/index.js中替换的代码</p></figure><ul class=""><li id="116d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第4行:使用<code class="fe mj mk ml mm b">Link</code>组件将用户重定向到<code class="fe mj mk ml mm b">/todo</code>路线以及作为参数的<code class="fe mj mk ml mm b">id</code>字段。Next.js中的<code class="fe mj mk ml mm b">Link</code>元素类似于<code class="fe mj mk ml mm b">a</code>标签。</li><li id="b5ff" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第5行:显示该项目的<code class="fe mj mk ml mm b">title</code>字段。</li></ul><p id="1a15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行代码。这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/299fbcda6192aa790e5febeb583beed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/1*f42tbplkB0iJR2hUSr5t6w.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="d589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们的代码有效！我们的项目会将我们重定向到适当的位置。然而，当我们点击这些项目中的任何一个时，我们会遇到一个错误。这是因为我们还没有处理这些路线。</p><p id="f953" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩下的就是实现动态路由，多亏了Next.js框架，这简直是小菜一碟。在下一节中，我们将通过<code class="fe mj mk ml mm b">getServerSideProps()</code>函数应用嵌套和动态路由。</p><h2 id="9248" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">使用getServerSideProps提取</h2><p id="5ad7" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe mj mk ml mm b">getServerSideProps</code>函数使用服务器端生成来获取数据。这是因为我们希望在请求时获取我们选择的待办事项。</p><p id="f077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的<code class="fe mj mk ml mm b">/pages</code>目录中，创建一个名为<code class="fe mj mk ml mm b">/todo</code>的文件夹。在<code class="fe mj mk ml mm b">/pages/todo</code>文件夹中，创建一个名为<code class="fe mj mk ml mm b">[id].js</code>的文件。</p><p id="628f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mj mk ml mm b">/pages/todo/[id].js</code>中，编写下面这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><ul class=""><li id="d9f5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第1行:接收从<code class="fe mj mk ml mm b">getServerSideProps</code>函数中作为道具接收的<code class="fe mj mk ml mm b">todo</code>对象。</li><li id="13b9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第4-6行:显示<code class="fe mj mk ml mm b">todo</code>对象的属性。如果<code class="fe mj mk ml mm b">completed</code>字段为<code class="fe mj mk ml mm b">true</code>，则应勾选复选框。</li><li id="071a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第11行:导出<code class="fe mj mk ml mm b">getServerSideProps</code>方法。该函数中的<code class="fe mj mk ml mm b">context</code>参数包含关于URL和其他属性的信息，您可以在文档中了解更多关于<a class="ae ky" href="https://nextjs.org/docs/basic-features/data-fetching" rel="noopener ugc nofollow" target="_blank">的信息。</a></li><li id="3ab9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第12行:获取关于特定待办事项的数据。我们可以通过使用包含URL参数值的<code class="fe mj mk ml mm b">context.params</code>对象来做到这一点。这里，我们正在访问<code class="fe mj mk ml mm b">id</code>参数的值。</li><li id="46b3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第19行:将提取的数据导出为道具。</li></ul><p id="764f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行代码。这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/4f75534f17296e11f016611845f445e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/1*KS4oe028x-92EKVdRkE4Bw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="2d76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！如您所见，我们的代码是有效的。我们能够点击任何项目，这给我们提供了关于特定待办事项的进一步信息。</p><p id="9c89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将学习<code class="fe mj mk ml mm b">getStaticPaths</code>功能。</p><h2 id="6b4d" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">使用getStaticPaths生成路径</h2><p id="5f1d" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">虽然我们的网站功能如预期，但仍有一个问题:如果用户试图导航到一个不存在的待办事项怎么办？比如他们想去<code class="fe mj mk ml mm b">localhost:3000/todo/4300</code>怎么办？显然，在我们的例子中，没有带有<code class="fe mj mk ml mm b">4300</code>的<code class="fe mj mk ml mm b">id</code>的项目。在这种情况下，我们想要抛出一个<code class="fe mj mk ml mm b">404: Page not found</code>错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/f1bbfe05fb08f3726b6fa7600116390b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*b7PeIMiJGXCWd47zOLZznA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们想在这里抛出一个错误。</p></figure><p id="40d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们需要告诉Next.js应该呈现什么路径。这就是<code class="fe mj mk ml mm b">getStaticPaths</code>的用武之地。该功能使用静态侧生成，并与<code class="fe mj mk ml mm b">getStaticProps</code>方法配合使用。</p><p id="ebfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mj mk ml mm b">/pages/todo/[id].js</code>中，找到下面这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="e5b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe mj mk ml mm b">getServerSideProps</code>功能重命名为<code class="fe mj mk ml mm b">getStaticProps</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="dc9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为最后一步，在<code class="fe mj mk ml mm b">pages/todo/[id].js</code>的末尾编写以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><ul class=""><li id="e537" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第1行:导出<code class="fe mj mk ml mm b">getStaticPaths</code>函数。</li><li id="268c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第5行:创建一个包含API中所有待办事项的<code class="fe mj mk ml mm b">id</code>字段的<code class="fe mj mk ml mm b">paths</code>数组。</li><li id="2bca" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第9行:返回<code class="fe mj mk ml mm b">paths</code>对象。这实际上告诉Next.js将呈现什么路径。</li><li id="88c3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第10行:<code class="fe mj mk ml mm b">fallback</code>标志告诉Next.js如果用户转到一个不支持的路径(例如，如果他们试图用<code class="fe mj mk ml mm b">4300</code>的<code class="fe mj mk ml mm b">id</code>获取一个待办事项，即使它并不存在)时抛出一个错误。</li></ul><p id="320d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行代码。这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/6eb30cf9f8eba998c249d773bf0353cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/1*txjRCNo7oUvN0YhgioJIBw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="d949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们的代码输出和以前一样。</p><p id="6347" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是试着去<code class="fe mj mk ml mm b">localhost:3000/todo/250</code>。由于没有带有<code class="fe mj mk ml mm b">250</code>的<code class="fe mj mk ml mm b">id</code>的项目，现在会抛出一个错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/13954d704e26503f3203f748d16937d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*QBZVGdMjXl_EVv9cR7o_oA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在不支持的页面上引发错误</p></figure><p id="7b21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！如您所见，我们的代码是有效的。</p><p id="a724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们甚至可以通过<code class="fe mj mk ml mm b">getStaticPaths</code>功能减少生成路径的数量。转到<code class="fe mj mk ml mm b">/pages/todo/[id].js</code>并找到以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="5bd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样改变它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><ul class=""><li id="734b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第7行:只会生成两条静态路径。否则，将抛出一个<code class="fe mj mk ml mm b">404: Page not found</code>错误。</li></ul><p id="f8c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行代码。这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/77e02d9c7bd8e3ffbdc814e6d952a7b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/1*P4Ld27r3JwSQ9X7gsI7JHA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="650a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！如你所见，我们成功了。只生成了两条动态路径。</p><p id="75a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe mj mk ml mm b">/pages/todo/[id].js</code>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="5333" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/HussainArif12/nextjs-data-fetching" rel="noopener ugc nofollow" target="_blank"> <em class="og">本节GitHub回购</em> </a></p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5011" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">延伸阅读和GitHub Repos</h1><h2 id="18af" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">GitHub仓库</h2><ul class=""><li id="bf17" class="lv lw it lb b lc nm lf nn li os lm ot lq ou lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/HussainArif12/next-file-routing" rel="noopener ugc nofollow" target="_blank">基于文件路由的回购</a></li><li id="53bf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/HussainArif12/nextjs-data-fetching" rel="noopener ugc nofollow" target="_blank">数据取数回购</a></li></ul><h2 id="9139" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">更多资源</h2><ul class=""><li id="d3f5" class="lv lw it lb b lc nm lf nn li os lm ot lq ou lu ma mb mc md bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=zktJ8-k0JDc&amp;list=PL4cUxeGkcC9g9gP2onazU5-2M-AzA8eBw&amp;index=2" rel="noopener ugc nofollow" target="_blank"> Next.js —网络忍者的页面和路线</a></li><li id="b3ef" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=zueyEdRZQlk&amp;list=PL4cUxeGkcC9g9gP2onazU5-2M-AzA8eBw&amp;index=10" rel="noopener ugc nofollow" target="_blank"> Next.js —网忍者getStaticProps</a></li><li id="908c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://nextjs.org/docs/basic-features/data-fetching" rel="noopener ugc nofollow" target="_blank">next . js—官方文档中的数据获取</a></li><li id="8ecd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://youtu.be/mTz0GXj8NN0?t=1876" rel="noopener ugc nofollow" target="_blank"> Next.js通过Traversy媒体获取数据</a></li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="caa8" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="27c7" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Next.js已经成为博客框架市场的顶级竞争者，这是理所当然的。它不仅允许我们构建高性能和可伸缩的React应用程序，而且它还实现了路由，对开发人员来说没有任何麻烦。难怪它在<a class="ae ky" href="https://youtu.be/VfGW0Qiy2I0?t=1724" rel="noopener ugc nofollow" target="_blank"> Traversy Media的视频</a>中被描述为2021年要学习的惊人框架。</p><p id="9f3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在学习本教程的过程中遇到任何困难，请解构并使用代码示例，以便您可以完全掌握主题。谢谢你坚持到最后！</p><p id="4140" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一篇文章:<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/build-your-personal-blog-with-next-js-and-strapi-e092bf11d3db">用Next.js和Strapi </a> <br/>创建你的个人博客上一篇文章:<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/create-amazing-animations-in-react-using-framer-motion-34c803f60c6f">在React With Framer Motion中创建动画</a></p></div></div>    
</body>
</html>