<html>
<head>
<title>Meta-Programming in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的元编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/meta-programming-in-python-7fb94c8c7152?source=collection_archive---------9-----------------------#2019-10-15">https://betterprogramming.pub/meta-programming-in-python-7fb94c8c7152?source=collection_archive---------9-----------------------#2019-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7454" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于装饰者和元类的简短教程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/f2ed47522be8d3b6d549ecf66156c47d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*jsgLaIkhgF7SzQS1FWIPug.jpeg"/></div></figure><p id="4534" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最近，我遇到了一个非常有趣的概念，那就是Python 中的<em class="lj">元编程。我想在这篇文章中分享我在这个话题上的发现。我希望这能帮助你理解这一点，因为他们说这是一个棘手的问题。</em></p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="9341" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">什么是元编程？</h1><p id="2683" class="pw-post-body-paragraph kn ko iq kp b kq mj jr ks kt mk ju kv kw ml ky kz la mm lc ld le mn lg lh li ij bi translated">所以，用一句话来说:“元编程是一种编写操纵代码的代码的行为。”</p><p id="d0b1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">等等，什么？是的，你没看错。操纵代码的代码。听起来是不是很迷人，很强大？嗯，事实上是的。</p><p id="5c78" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在Python的上下文中，元编程可以表述为:“元编程是一种构建函数和类的行为，这些函数和类可以通过修改、包装现有代码或生成代码来操纵代码。”</p><p id="0591" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Python中的元编程可以通过以下方式实现:</p><ol class=""><li id="eda1" class="mo mp iq kp b kq kr kt ku kw mq la mr le ms li mt mu mv mw bi translated">装修工</li><li id="27cd" class="mo mp iq kp b kq mx kt my kw mz la na le nb li mt mu mv mw bi translated">元类</li></ol><p id="438d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们一个一个地熟悉它们。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="8e96" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">装修工</h1><p id="bc01" class="pw-post-body-paragraph kn ko iq kp b kq mj jr ks kt mk ju kv kw ml ky kz la mm lc ld le mn lg lh li ij bi translated">装饰器是一种向现有函数添加新功能而不修改其原始结构的方法。</p><p id="ba27" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">例如，我们有三个函数:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="ecfc" class="nh ls iq nd b gy ni nj l nk nl">def add(x, y):<br/>    return x + y    <br/><br/>def sub(x, y):<br/>    return x - y<br/>    <br/>def mul(x, y):<br/>    return x * y</span></pre><p id="65d3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在我们需要在调用函数时打印出函数名和参数值。这应该适用于上述所有三个功能。</p><p id="ea2e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">本地方法是向所有三个函数添加打印/日志语句。但是这听起来像是非常重复的工作，我们还需要修改每个函数体。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="717a" class="nh ls iq nd b gy ni nj l nk nl">def add(x, y):<br/>    print("add is called with parameter {0},{1}".format(x,y))<br/>    return x + y    <br/><br/>def sub(x, y):<br/>    print("sub is called with parameter {0},{1}".format(x,y))<br/>    return x - y<br/>    <br/>def mul(x, y):<br/>    print("mul is called with parameter {0},{1}".format(x,y))<br/>    return x * y    <br/><br/>print(add(5,3))<br/>print(sub(5,3))<br/>print(mul(5,3))<br/><br/>*********************** output *********************<br/><br/>add is called with parameter 5, 3<br/>8<br/>sub is called with parameter 5, 3<br/>2<br/>mul is called with parameter 5, 3<br/>15</span></pre><p id="244d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们能做得更好吗？我们当然可以，因为感谢上帝，我们是程序员，而程序员是聪明的。我们可以通过编写一个装饰函数并且不修改任何现有的函数体来实现这一点。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="237c" class="nh ls iq nd b gy ni nj l nk nl">def my_decorator(func):<br/>    def wrapper_function(*args):<br/>        print("{0} is called with parameter {1}".format(func.__name__, args))<br/>        return func(*args)<br/>    return wrapper_function<br/><br/>@my_decorator<br/>def add(x, y):<br/>    return x + y<br/>    <br/>@my_decorator<br/>def sub(x, y):<br/>    return x - y<br/><br/>@my_decorator    <br/>def mul(x, y):<br/>    return x * y <br/><br/>*********************** output *********************<br/><br/>add is called with parameter (5, 3)<br/>8<br/>sub is called with parameter (5, 3)<br/>2<br/>mul is called with parameter (5, 3)<br/>15</span></pre><p id="d37a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">答对了。在上面的代码片段中，<code class="fe nm nn no nd b">my_decorator</code>是一个装饰函数。我们用<code class="fe nm nn no nd b">@my_decorator</code>修饰了所有三个函数，并且没有修改现有的函数体来添加打印功能。</p><p id="5c93" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">所以，基本上，decorators是高阶函数，它将一个函数作为参数，并返回另一个函数。这里，<code class="fe nm nn no nd b">my_decorator</code>将一个函数作为参数并返回结果<code class="fe nm nn no nd b">wrapper_function</code>，其中<code class="fe nm nn no nd b">wrapper_function</code>将我们的打印功能添加到<code class="fe nm nn no nd b">func</code>。</p><p id="470d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">装饰者还有更多，但这是对Python中装饰者的简要介绍。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="aefd" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">元类</h1><p id="1a42" class="pw-post-body-paragraph kn ko iq kp b kq mj jr ks kt mk ju kv kw ml ky kz la mm lc ld le mn lg lh li ij bi translated">现在我们已经看到了装饰者，他们是为了装饰功能。但是元编程不仅仅是装饰器，比如<em class="lj">元类</em>。</p><p id="c28a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">元类是特殊类型的类，而不是Python中的普通类。普通类定义自己实例的行为，元类定义普通类及其实例的行为。</p><p id="17f9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">元类可以在普通类中增加或减少方法或字段。Python有一个特殊的类，<code class="fe nm nn no nd b">type</code>类，默认情况下是一个元类。所有自定义类型类必须从<code class="fe nm nn no nd b">type</code>类继承。</p><p id="8b92" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">例如，如果我们有一个类<code class="fe nm nn no nd b">Calc</code>，有三个类方法，我们想为一个类中的所有方法提供调试功能，那么我们可以使用一个元类来实现这个目的。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="650d" class="nh ls iq nd b gy ni nj l nk nl">class Calc():<br/>    def add(self, x, y):<br/>        return x + y<br/>    <br/>    def sub(self, x, y):<br/>        return x - y<br/>    <br/>    def mul(self, x, y):<br/>        return x * y</span></pre><p id="81be" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先，我们需要创建一个具有调试功能的元类<code class="fe nm nn no nd b">MetaClassDebug</code>，并让<code class="fe nm nn no nd b">Calc</code>类继承<code class="fe nm nn no nd b">MetaClassDebug</code>。</p><p id="824c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">并且，当我们从<code class="fe nm nn no nd b">Calc</code>类中调用任何方法时，它将被我们的<code class="fe nm nn no nd b">debug_function</code>调用。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="f95f" class="nh ls iq nd b gy ni nj l nk nl">def debug_function(func):<br/><br/>    def wrapper(*args, **kwargs):<br/>        print("{0} is called with parameter {1}".format(func.__qualname__, args[1:]))<br/>        return func(*args, **kwargs)<br/>    <br/>    return wrapper<br/><br/><br/>def debug_all_methods(cls):<br/><br/>    for key, val in vars(cls).items():<br/>        if callable(val):<br/>            setattr(cls, key, debug_function(val))<br/>    return cls<br/><br/><br/>class MetaClassDebug(type):<br/><br/>    def __new__(cls, clsname, bases, clsdict):<br/>        obj = super().__new__(cls, clsname, bases, clsdict)<br/>        obj = debug_all_methods(obj)<br/>        return obj<br/><br/><br/>class Calc(metaclass=MetaClassDebug):<br/>    def add(self, x, y):<br/>        return x + y<br/><br/>    def sub(self, x, y):<br/>        return x - y<br/><br/>    def mul(self, x, y):<br/>        return x * y<br/><br/><br/>calc = Calc()<br/>print(calc.add(2, 3))<br/>print(calc.sub(2, 3))<br/>print(calc.mul(2, 3))<br/><br/><br/>**************** output ****************<br/><br/>Calc.add is called with parameter (2, 3)<br/>5<br/>Calc.sub is called with parameter (2, 3)<br/>-1<br/>Calc.mul is called with parameter (2, 3)<br/>6</span></pre><p id="04af" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">答对了。在上面的代码片段中，我们创建了一个元类<code class="fe nm nn no nd b">MetaClassDebug</code>并编写了一个<em class="lj">新的</em>方法，该方法负责创建类的一个实例，并将我们的装饰函数<code class="fe nm nn no nd b">debug_function</code>应用于对象(实例)，该对象将为继承<code class="fe nm nn no nd b">MetaClassDebug</code>的每个类创建。</p><p id="a437" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe nm nn no nd b">Calc</code>继承自<code class="fe nm nn no nd b">MetaClassDebug</code>，因此每个方法都被<code class="fe nm nn no nd b">debug_all_methods</code>中的<code class="fe nm nn no nd b">debug_function</code>修饰过。</p><p id="72a7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这样，我们可以向类中的所有方法添加新的行为，还可以使用元类控制类的实例创建。我们可以用元类完成很多事情，比如给类添加一个方法或字段，从类中移除一个方法或字段，等等。</p><p id="fb2a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我想让你快速浏览一下Python中的元编程，所以我不能在这篇文章中涵盖所有的内容。</p><p id="bbbe" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我希望这篇文章已经帮助您熟悉了元编程的概念。欢迎批评！</p></div></div>    
</body>
</html>