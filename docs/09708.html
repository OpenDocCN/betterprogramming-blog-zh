<html>
<head>
<title>How to Automatically Unsubscribe Multiple Observables in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Angular中自动退订多个可观测量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unsubscribing-multiple-observables-in-angular-46c9c4833ffc?source=collection_archive---------2-----------------------#2021-09-30">https://betterprogramming.pub/unsubscribing-multiple-observables-in-angular-46c9c4833ffc?source=collection_archive---------2-----------------------#2021-09-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bf40" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们使用异步管道和RxJS操作符的力量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a1eccaa0d42b6e1c359ec23449edd7ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xrs5X2NR0GhMMEfZ34LbmA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4088055" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/suju-foto-165106/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4088055" rel="noopener ugc nofollow" target="_blank"> suju-foto </a>的图片</p></figure><p id="6756" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">angular中有很多方法可以取消订阅observables，比如使用异步管道<code class="fe lv lw lx ly b">|</code>、<code class="fe lv lw lx ly b">unsubscribe</code>、<code class="fe lv lw lx ly b">take</code>和first操作符。</p><p id="56ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我通常会尽可能默认使用异步管道，这样我就不用担心退订了。但是有些情况下你不能使用异步管道，你必须<code class="fe lv lw lx ly b">unsubscribe</code> <em class="lz"> </em>观察。</p><p id="2c4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果我们有多个可观测量，我们将从那里<code class="fe lv lw lx ly b">unsubscribe</code>呢？</p><p id="f59d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以很容易地取消订阅这些可观的，但这将是很多样板或重复的代码。</p><p id="3278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们可以通过使用声明性的方法来最小化代码重复，例如<code class="fe lv lw lx ly b">takeUntil</code>和<code class="fe lv lw lx ly b">ReplaySubject</code>。</p><p id="1162" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们深入我们的例子:</p><h1 id="3c99" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">我们的Web应用程序示例</h1><p id="a3fe" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><em class="lz">注意，我们可以在我们的web应用程序示例中直接使用异步管道。类似于我之前</em> <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/4-useful-reactive-programming-implementations-5b17d6fe53d3"> <em class="lz">博文</em> </a> <em class="lz">中的</em> <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/4-useful-reactive-programming-implementations-5b17d6fe53d3#ec67"> <em class="lz"> Rest API例子</em> </a> <em class="lz">。我在这里用subscribe作为例子来说明这篇博文的观点。</em></p><p id="2731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个带有两个GitHub搜索框的web应用程序，一个用于搜索存储库，另一个用于搜索用户。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/83d107b1b4ac9d268ab01225b150111e.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*gA3m1HHieEs4LUVkqMnXcg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者提供的示例web应用程序的屏幕截图。</p></figure><p id="a2fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">搜索结果将显示在搜索框下方。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/f7609c501e448dcdb45b690f9196f7ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*WseHud8u_BM96QJ4zUQ_cg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者提供的示例web应用程序的屏幕截图。</p></figure><p id="bd02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在任何搜索框中输入文本后，我们的web应用程序将调用GitHub搜索API。要做到这一点，我们需要<code class="fe lv lw lx ly b">subscribe</code>到我们的<code class="fe lv lw lx ly b">formControl</code> s <em class="lz"> </em> <code class="fe lv lw lx ly b">valueChanges</code> <em class="lz"> </em>可观测。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者在GitHub上的源代码示例。</p></figure><p id="8bc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">行<code class="fe lv lw lx ly b">this.searchSubject$.next(searchString)</code>“发出”信号调用GitHub搜索API。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的源代码示例。</p></figure><p id="8314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的结果将在模板中呈现。</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="a170" class="nf mb it ly b gy ng nh l ni nj">&lt;div *ngFor="let result of results$ | async"&gt;<br/>  &lt;div&gt;<br/>    &lt;a [href]="result.html_url" target="_blank"&gt;{{<br/>      result.name || result.login<br/>    }}&lt;/a&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="378c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面给出了<code class="fe lv lw lx ly b">GitHubService</code> <em class="lz"> </em>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者在GitHub上的源代码示例。</p></figure><p id="8fd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们知道了我们的示例web应用程序是什么，让我们深入研究如何取消订阅<code class="fe lv lw lx ly b">valueChanges</code> <em class="lz"> </em>可观察对象。</p><h1 id="8189" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">取消订阅每个可观察对象</h1><p id="0cf9" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我们将首先把我们的可观察对象分配到一个<code class="fe lv lw lx ly b">Subscription</code>属性中。然后我们将使用那个<code class="fe lv lw lx ly b">Subscription</code>属性取消订阅。</p><p id="4f9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是我们的<code class="fe lv lw lx ly b">Class</code>酒店，拥有可观的:</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="ad3c" class="nf mb it ly b gy ng nh l ni nj">searchReposSub: Subscription;<br/>searchUsers: Subscription;</span></pre><p id="87f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">ngOnInit</code>方法中初始化<code class="fe lv lw lx ly b">valueChanges</code>订阅。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者在GitHub上的源代码示例。</p></figure><p id="a3a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe lv lw lx ly b">ngOnDestroy</code>单独取消订阅观察:</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="bcbf" class="nf mb it ly b gy ng nh l ni nj">ngOnDestroy() {<br/>    this.searchReposSub.unsubscribe();<br/>    this.searchUsersSub.unsubscribe();<br/>}</span></pre><p id="0da4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者我们也可以使用一个<code class="fe lv lw lx ly b">Subscription</code> <em class="lz"> </em>数组取消订阅每个可观察对象:</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="b4e1" class="nf mb it ly b gy ng nh l ni nj">subscriptions: Subscription[];</span></pre><p id="5b99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将订阅的观察值推入<code class="fe lv lw lx ly b">subscriptions</code>数组属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者在GitHub上的源代码示例。</p></figure><p id="cb68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在<code class="fe lv lw lx ly b">ngOnDestroy</code> <em class="lz"> </em>方法中迭代每个订阅来取消订阅:</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="d769" class="nf mb it ly b gy ng nh l ni nj">this.subscriptions.forEach((subscription) =&gt; {<br/>   subscription.unsubscribe();<br/>});</span></pre><p id="9035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在StackBlitz中运行取消订阅示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者在StackBlitz上运行代码示例。</p></figure><p id="dbda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个属性数组中跟踪我们的订阅比在多个属性中跟踪要简单得多。</p><p id="ffc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，与使用订阅数组相比，我更喜欢另一种方法——使用<code class="fe lv lw lx ly b">takeUntil</code>管道。</p><h1 id="16ad" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">使用<em class="nl">取消订阅，直到</em>和<code class="fe lv lw lx ly b">ReplaySubject</code></h1><p id="dfb8" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">这是一种更具声明性的方法。如果我们利用了<code class="fe lv lw lx ly b">takeUntil</code>管道和<code class="fe lv lw lx ly b">ReplaySubject</code>T34】，我们就不必跟踪类属性中的订阅。</p><p id="74b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从声明我们的<code class="fe lv lw lx ly b">ReplaySubject</code>属性开始:</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="9169" class="nf mb it ly b gy ng nh l ni nj">private destroyed$: ReplaySubject&lt;boolean&gt; = new ReplaySubject(1);</span></pre><p id="0631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">ReplaySubject(n)</code>缓存可观察源发出的先前<code class="fe lv lw lx ly b">n</code>值。所以我们可以使用我们的<code class="fe lv lw lx ly b">destroyed$</code> <em class="lz"> </em> <code class="fe lv lw lx ly b">ReplaySubject</code>在<code class="fe lv lw lx ly b">ngOnDestroy()</code>中发出一个<code class="fe lv lw lx ly b">unsubscribe</code> <em class="lz"> </em>调用。</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="bedf" class="nf mb it ly b gy ng nh l ni nj">ngOnDestroy() {<br/>    this.destroyed$.next(true);<br/>    this.destroyed$.unsubscribe();<br/>}</span></pre><p id="81cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的订阅将使用<code class="fe lv lw lx ly b">takeUntil</code>操作符。</p><p id="cea7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe lv lw lx ly b">ngOnInit</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者在GitHub上的源代码示例。</p></figure><p id="ee9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">takeUntil(this.destroyed$)</code> <em class="lz"> </em>会一直发出我们源可观察的值，直到<code class="fe lv lw lx ly b">destroyed$</code> <em class="lz"> </em>可观察发出一个值。这里可观测的源头是<em class="lz"> </em> <code class="fe lv lw lx ly b">this.searchReposFormControl.valueChanges</code>。</p><p id="7df5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在StackBlitz中运行<code class="fe lv lw lx ly b">takeUntil</code>示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者在StackBlitz上运行代码示例。</p></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="6d5a" class="ma mb it bd mc md nt mf mg mh nu mj mk jz nv ka mm kc nw kd mo kf nx kg mq mr bi translated">结论</h1><p id="9d8d" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">尽可能避免手动<code class="fe lv lw lx ly b">unsubscribe</code>。这可以通过使用异步管道<code class="fe lv lw lx ly b">|</code>或任何其他RxJS操作符(如<code class="fe lv lw lx ly b">take</code>和<code class="fe lv lw lx ly b">first</code> <em class="lz"> </em>)来实现，这些操作符将自动取消订阅您的观察对象。</p><p id="5e6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你除了使用<code class="fe lv lw lx ly b">unsubscribe</code>别无选择，就像上面的例子一样。然后用<code class="fe lv lw lx ly b">ReplaySubject</code> <em class="lz">和</em>的方法进行<code class="fe lv lw lx ly b">takeUntil</code>。使用这种方法，您不必跟踪您的订阅。你只需要申报你的<code class="fe lv lw lx ly b">ReplaySubject</code>财产。然后用那个属性去<code class="fe lv lw lx ly b">unsubscribe</code> <em class="lz">。</em></p><div class="ny nz gp gr oa ob"><a href="https://blog.ardy.me/membership" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">通过我的推荐链接加入媒体</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">阅读Ardy Gallego Dedase(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">blog.ardy.me</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div></div></div>    
</body>
</html>