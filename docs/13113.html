<html>
<head>
<title>Debugging From the Other Direction Using JMXTerm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JMXTerm从另一个方向调试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/debugging-from-the-other-direction-using-jmxterm-27039fd646d5?source=collection_archive---------11-----------------------#2022-07-29">https://betterprogramming.pub/debugging-from-the-other-direction-using-jmxterm-27039fd646d5?source=collection_archive---------11-----------------------#2022-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="869a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">本系列的第3部分探索了更多调试项目的工具</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ee3eb4c5b71fc0fab65f4ebbb5b0f849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KhHFAEHPI7Hczd-d2jd78w.jpeg"/></div></div></figure><p id="c3c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当跟踪一个bug时，我们需要采取类似于钳子的双管齐下的方法，从两侧包裹bug模块，并挤压以找到有问题的部分。到目前为止，我们讨论了非常低级的工具。有些可用于调试系统级服务。今天，我们将讨论堆栈的另一面，但仍然是一个非常先进的管理工具。要理解这一点，你需要了解我们所处的领域。</p><p id="05ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为开发人员，我们处理代码和应用程序。部署是针对运营/开发人员的，他们的工具通常对我们来说是陌生的。并不是说他们有不好的工具。相反，他们有惊人的工具。但它们通常是为大规模设计的。当您需要管理数以千计的服务器时，您需要一种方法来控制所有这些服务器。为此，我们需要一套不同的工具。</p><p id="92d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">管理工具让我们穿越机器的云，并管理在其上运行的应用程序。我们不需要前者，但后者是对开发者非常有用的强大工具。一些标准实现了应用程序管理，Java引入了JMX来封装它们的差异。JMX让应用程序和JDK本身暴露信息和功能，供外部工具操作。</p><p id="7b62" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个显著的特性，它为运行时环境中的动态操作提供了信息和调优杠杆。激活JMX超出了本教程的范围，所以我不会讲太多细节，但是你可以在这篇甲骨文文章<a class="ae ln" href="https://docs.oracle.com/javadb/10.10.1.2/adminguide/radminjmxenabledisable.html" rel="noopener ugc nofollow" target="_blank">这里</a>查看一些基础知识。一旦运行完毕，我们就可以使用可视化工具进行调试，但是我将主要关注命令行工具。这很重要，因为我可以从控制台直接在生产服务器上使用一些工具。</p><h1 id="95db" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">JMX是如何工作的？</h1><p id="8136" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">JMX公开了管理“bean”(mbean)。这些是代表应用程序中控制点的对象。您的应用程序可以发布自己的beans，这允许您公开运行时监控和配置的功能。这非常酷，因为您可以导出管理员可以直接连接到仪表板(APM、Prometheus、Grafana等)的信息。)并将其用于决策。</p><p id="dd96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您的服务器有多个并发连接的用户，您可以在JMX公开该号码，并且由于DevOps的一些连接，它可以出现在公司仪表板中。在您这方面，大多数工作都会公开一个感兴趣的值的getter。您还可以公开诸如“清除用户”等操作。操作是可以在JMX bean上调用的方法。</p><p id="e731" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Spring还支持通过actuator将许多服务器细节公开为管理beans。这是一个非常酷的功能。你可以在这里了解更多。它揭示了关于应用程序的非常深入的指标，并帮助您直接进入“生产就绪”状态！</p><h1 id="3e2a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">JMXTerm基础知识</h1><p id="cfbf" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">通常，人们通过web界面工具或专用管理工具来控制和读取JMX。如果你能接触到它们中的任何一个，我建议你挑选一个并使用它们，因为它会工作得很好。我在一些公司用过其中的一些，实际上在某些情况下我更喜欢它们。我也喜欢使用IntelliJ/IDEA Ultimates对Actuator的支持，这是一个非常强大的可视化工具。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/a6595bd751a08c1b56915226348643cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IXLfY2j14NlDupuy6RbFQg.png"/></div></div></figure><p id="4760" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样强大，但不包括可视化方面。从这个意义上来说，当我们需要快速了解服务器上可能陌生的东西时，这非常方便。它对于从服务器内部获得高层次的洞察力也非常有用。我们可以从<a class="ae ln" href="https://docs.cyclopsgroup.org/jmxterm" rel="noopener ugc nofollow" target="_blank">这里</a>下载<code class="fe mm mn mo mp b">JMXTerm</code>开始。</p><p id="a73f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下载完成后，我们可以使用以下命令将其连接到服务器:</p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="f873" class="mu lp iq mp b gy mv mw l mx my">java -jar ~/Downloads/jmxterm-1.0.2-uber.jar --url localhost:30002</span></pre><p id="4f5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您应该根据您的连接更新主机名/端口。连接后，我们可以使用提示符列出JMX域:</p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="6658" class="mu lp iq mp b gy mv mw l mx my">$&gt;domains<br/>#following domains are available<br/>JMImplementation<br/>com.sun.management<br/>java.lang<br/>java.nio<br/>java.util.logging<br/>javax.cache<br/>jdk.management.jfr</span></pre><p id="36da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们可以选择一个特定的领域进行探索。这就是可视化工具的优势所在，因为它可以为您提供更快的层次导航和快速的信息评估。在这种情况下，我只想设置日志记录级别。下面是如何做到这一点:</p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="b65e" class="mu lp iq mp b gy mv mw l mx my">$&gt;domain java.util.logging<br/>#domain is set to java.util.logging</span></pre><p id="1de8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以通过列出域中的beans来遵循这一点。然后选择我们希望使用的bean，因为在这个特定的域中只有一个bean。代码如下:</p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="dc7a" class="mu lp iq mp b gy mv mw l mx my">$&gt;beans<br/>#domain = java.util.logging:<br/>java.util.logging:type=Logging<br/>$&gt;bean java.util.logging:type=Logging<br/>#bean is set to java.util.logging:type=Logging</span></pre><p id="f0aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我能用这颗豆子做什么？为此，我们使用info命令列出bean的操作和属性:</p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="e7bd" class="mu lp iq mp b gy mv mw l mx my">$&gt;info<br/>#mbean = java.util.logging:type=Logging<br/>#class name = sun.management.ManagementFactoryHelper$PlatformLoggingImpl<br/># attributes<br/>  %0   - LoggerNames ([Ljava.lang.String;, r)<br/>  %1   - ObjectName (javax.management.ObjectName, r)<br/># operations<br/>  %0   - java.lang.String getLoggerLevel(java.lang.String p0)<br/>  %1   - java.lang.String getParentLoggerName(java.lang.String p0)<br/>  %2   - void setLoggerLevel(java.lang.String p0,java.lang.String p1)<br/>#there's no notifications</span></pre><p id="6867" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦我有了这些，我就可以检查当前的日志级别。因为我们没有显式地设置它，所以没有设置它，并且使用了全局缺省值。方法如下:</p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="db96" class="mu lp iq mp b gy mv mw l mx my">$&gt;run getLoggerLevel "org.apache.tomcat.websocket.WsWebSocketContainer"<br/>#calling operation getLoggerLevel of mbean java.util.logging:type=Logging with params [org.apache.tomcat.websocket.WsWebSocketContainer]<br/>#operation returns:</span></pre><p id="6d7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我可以显式地将它设置为<code class="fe mm mn mo mp b">INFO</code>，然后使用下面的代码再次获取它来验证操作是否按预期工作:</p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="68b7" class="mu lp iq mp b gy mv mw l mx my">$&gt;run setLoggerLevel org.apache.tomcat.websocket.WsWebSocketContainer INFO<br/>#calling operation setLoggerLevel of mbean java.util.logging:type=Logging with params [org.apache.tomcat.websocket.WsWebSocketContainer, INFO]<br/>#operation returns: <br/>null<br/>$&gt;run getLoggerLevel "org.apache.tomcat.websocket.WsWebSocketContainer"<br/>#calling operation getLoggerLevel of mbean java.util.logging:type=Logging with params [org.apache.tomcat.websocket.WsWebSocketContainer]<br/>#operation returns: <br/>INFO</span></pre><p id="bccf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这只是冰山一角。我们可以得到很多东西，比如spring设置，内部VM信息等等。在此示例中，我可以使用以下代码直接从控制台查询虚拟机信息:</p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="44f4" class="mu lp iq mp b gy mv mw l mx my">$&gt;domain com.sun.management<br/>#domain is set to com.sun.management<br/>$&gt;beans<br/>#domain = com.sun.management:<br/>com.sun.management:type=DiagnosticCommand<br/>com.sun.management:type=HotSpotDiagnostic<br/>$&gt;bean com.sun.management:type=HotSpotDiagnostic<br/>#bean is set to com.sun.management:type=HotSpotDiagnostic<br/>$&gt;info<br/>#mbean = com.sun.management:type=HotSpotDiagnostic<br/>#class name = com.sun.management.internal.HotSpotDiagnostic<br/># attributes<br/>  %0   - DiagnosticOptions ([Ljavax.management.openmbean.CompositeData;, r)<br/>  %1   - ObjectName (javax.management.ObjectName, r)<br/># operations<br/>  %0   - void dumpHeap(java.lang.String p0,boolean p1)<br/>  %1   - javax.management.openmbean.CompositeData getVMOption(java.lang.String p0)<br/>  %2   - void setVMOption(java.lang.String p0,java.lang.String p1)<br/>#there's no notifications</span></pre><h1 id="d8e4" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="b990" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">JMX是一个非凡的工具，我们通常用它来连接管理控制台。这是值得注意的，你应该为你的项目导出JMX设置。话虽如此，您可以通过将JMX作为调试过程的一部分来更进一步。</p><p id="267b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">服务器应用程序在没有用户界面的情况下运行，或者有深度的用户界面分离。JMX通常可以作为一种用户界面甚至命令行界面，就像<code class="fe mm mn mo mp b">JMXTerm</code>中的情况一样。在这些情况下，我们可以触发调试情况，或者在管理UI中观察调试会话的结果。</p></div></div>    
</body>
</html>