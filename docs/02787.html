<html>
<head>
<title>Persist Business Logic With Swift Combine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Swift Combine保持业务逻辑</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/persist-business-logic-with-swift-combine-519efb3a7e37?source=collection_archive---------0-----------------------#2019-12-31">https://betterprogramming.pub/persist-business-logic-with-swift-combine-519efb3a7e37?source=collection_archive---------0-----------------------#2019-12-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fe24" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数据驱动联合收割机</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/40f05e90c8f7c9f82218cb9ea83f50d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*Uv9Iz4dsRdz4gXOuU7PFgQ.png"/></div></figure><p id="d592" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在之前的<a class="ae lm" href="https://medium.com/flawless-app-stories/visualize-combine-magic-with-swiftui-part-5-2783adddbd1d" rel="noopener">系列</a>中，我们成功地在SwiftUI的基础上搭建了这个平台，在这里你可以自由地观察流经Combine <a class="ae lm" href="https://developer.apple.com/documentation/combine/publisher" rel="noopener ugc nofollow" target="_blank"> publisher </a>的值序列。</p><p id="5f61" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们还创建了一些例子，展示了一些默认的组合操作符，它们能够改变和转换序列中的值，比如<code class="fe ln lo lp lq b"><a class="ae lm" href="https://developer.apple.com/documentation/combine/publishers/filter" rel="noopener ugc nofollow" target="_blank">filter</a></code>、<code class="fe ln lo lp lq b"> <a class="ae lm" href="https://developer.apple.com/documentation/combine/publishers/map" rel="noopener ugc nofollow" target="_blank">map</a></code>、<code class="fe ln lo lp lq b"><a class="ae lm" href="https://developer.apple.com/documentation/combine/publishers/drop" rel="noopener ugc nofollow" target="_blank">drop</a></code>、<a class="ae lm" href="https://developer.apple.com/documentation/combine/publishers/drop" rel="noopener ugc nofollow" target="_blank">、</a>和<code class="fe ln lo lp lq b"><a class="ae lm" href="https://developer.apple.com/documentation/combine/publishers/scan" rel="noopener ugc nofollow" target="_blank">scan</a></code>。此外，我们引入了更多的运算符来连接(<code class="fe ln lo lp lq b"><a class="ae lm" href="https://developer.apple.com/documentation/combine/publishers/zip" rel="noopener ugc nofollow" target="_blank">Zip</a></code>和<code class="fe ln lo lp lq b"><a class="ae lm" href="https://developer.apple.com/documentation/combine/publishers/combinelatest" rel="noopener ugc nofollow" target="_blank">CombineLatest</a></code>)或统一(<code class="fe ln lo lp lq b"><a class="ae lm" href="https://developer.apple.com/documentation/combine/publishers/merge" rel="noopener ugc nofollow" target="_blank">Merge</a></code>和<code class="fe ln lo lp lq b"><a class="ae lm" href="https://developer.apple.com/documentation/combine/publisher/3204685-append" rel="noopener ugc nofollow" target="_blank">Append</a></code>)序列。</p><p id="1b0b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这一点上，你们中的一些人可能有点厌倦了为每个例子管理或维护这么多代码(至少我是这样)。看教程文件夹下的这个<a class="ae lm" href="https://github.com/kevinjohnason/combine-magic-swiftui" rel="noopener ugc nofollow" target="_blank">combine-magic-swift ui</a>repo里有多少？每个例子都是SwiftUI视图。每一个简单地向<code class="fe ln lo lp lq b">StreamView</code>提供一个或几个发布者，当点击订阅按钮时<code class="fe ln lo lp lq b">StreamView</code>订阅发布者。</p><p id="1228" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，我应该能够在应用程序的启动和重用<code class="fe ln lo lp lq b">StreamView</code>上以编程方式生成一个发布者列表，如下面的截图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/4597d6f0e642356bfafaa07ab32fe461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*7Zowx4zGA2T8KkKEyzChiQ.png"/></div></figure><p id="9073" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然而，这种解决方案的问题是当有许多发布者要创建时的可伸缩性。</p><p id="5316" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我对这个问题的解决方案是我必须设法坚持这些出版商。如果我能以某种方式序列化这些发布者，我就能持久化它们。如果我设法持久化它们，我不仅能够在不改变代码的情况下修改它们，还能够与其他支持<a class="ae lm" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank">合并</a>的设备共享它们。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="f7ea" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">保持和转移组合运算符</h1><p id="065e" class="pw-post-body-paragraph kq kr it ks b kt mr ju kv kw ms jx ky kz mt lb lc ld mu lf lg lh mv lj lk ll im bi translated">现在，让我们更具体地回顾一下我们的目标。由于我们有一个<code class="fe ln lo lp lq b">Publisher</code>格式的流和操作符列表，我们希望能够将它们保存在任何类型的存储中——比如硬盘或数据库。</p><p id="872f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">显然，我们还需要能够将存储的数据转换回发布者，但是此外，我们希望能够与运营商从一个地方到另一个地方共享、传输和分发这些发布者。</p><p id="2437" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一旦我们建立了这种结构，你可能已经想到了，在一个分布式环境中，一个集中的服务可以开始为一群客户端驱动计算逻辑。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/40f05e90c8f7c9f82218cb9ea83f50d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*Uv9Iz4dsRdz4gXOuU7PFgQ.png"/></div></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="9df9" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">可编码结构</h1><p id="41bf" class="pw-post-body-paragraph kq kr it ks b kt mr ju kv kw ms jx ky kz mt lb lc ld mu lf lg lh mv lj lk ll im bi translated">我们该怎么做？我们从设计一个可序列化和反序列化的结构开始。Swift的<code class="fe ln lo lp lq b"><a class="ae lm" href="https://developer.apple.com/documentation/swift/codable" rel="noopener ugc nofollow" target="_blank">Codable</a></code> <em class="mw"> </em>协议允许我们通过<code class="fe ln lo lp lq b">JSONEncoder</code>和<code class="fe ln lo lp lq b">JSONDecoder</code>做到这一点。此外，该结构需要正确地表示流中最小值单元的数据和行为，直到复杂的操作符链。</p><p id="e45b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在我们继续之前，为了理解我们将要创建的结构需要哪些组件，让我们回顾一下我们从之前的<a class="ae lm" href="https://medium.com/flawless-app-stories/visualize-combine-magic-with-swiftui-part-5-2783adddbd1d" rel="noopener">系列</a>中构建的基本流程。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="e102" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">数字流</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/d848f7ec365e8684b61626899070d3d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*hYBhcSAs2L11eH-mPNhubA.gif"/></div></figure><p id="58bc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是最简单的流程；然而，如果你深入观察，你会发现这不仅仅是一个简单的数组序列。每个圆形框都有自己的延迟操作符，用于驱动应该发出的实际时间。Combine中的每个值看起来像:</p><pre class="kj kk kl km gt mx lq my mz aw na bi"><span id="593a" class="nb ma it lq b gy nc nd l ne nf">Just(value).delay(for: .seconds(1), scheduler: DispatchQueue.main)</span></pre><p id="99e2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">整个事情看起来像:</p><pre class="kj kk kl km gt mx lq my mz aw na bi"><span id="22e2" class="nb ma it lq b gy nc nd l ne nf">let val1 = Just(1).delay(for: .seconds(1), scheduler:   DispatchQueue.main)<br/>let val2 = Just(2).delay(for: .seconds(1), scheduler: DispatchQueue.main)<br/>let val3 = ....<br/>let val4 = ....</span><span id="7103" class="nb ma it lq b gy ng nd l ne nf">let publisher = val1.append(val2).append(val3).append(val4)</span></pre><p id="d52a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">每个值延迟一秒钟，下一个值附加相同的<code class="fe ln lo lp lq b">delay</code>操作符。</p><p id="34b9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，我们从观察中了解到两件事。</p><ol class=""><li id="98be" class="nh ni it ks b kt ku kw kx kz nj ld nk lh nl ll nm nn no np bi translated">流不是结构中最小的单元。流值为。</li><li id="3a2c" class="nh ni it ks b kt nq kw nr kz ns ld nt lh nu ll nm nn no np bi translated">每个流值都可以有无限的操作符，这些操作符控制发出值的内容和时间。</li></ol></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="8f45" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">创建您的流项目</h1><p id="4096" class="pw-post-body-paragraph kq kr it ks b kt mr ju kv kw ms jx ky kz mt lb lc ld mu lf lg lh mv lj lk ll im bi translated">由于流值和它的操作符是最小的单元，所以让我们从创建它的结构开始。姑且称之为<code class="fe ln lo lp lq b">StreamItem</code>。</p><pre class="kj kk kl km gt mx lq my mz aw na bi"><span id="a464" class="nb ma it lq b gy nc nd l ne nf"><strong class="lq iu">struct</strong> StreamItem&lt;T: Codable&gt;: Codable {</span><span id="41b9" class="nb ma it lq b gy ng nd l ne nf"><strong class="lq iu">  let</strong> value: T</span><span id="54bc" class="nb ma it lq b gy ng nd l ne nf"><strong class="lq iu">  var</strong> operators: [Operator]</span><span id="d3a4" class="nb ma it lq b gy ng nd l ne nf">}</span></pre><p id="e57e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe ln lo lp lq b">StreamItem</code>包含一个流值和一个运算符数组。按照我们的要求，我们希望能够持久化结构中的一切，这样<code class="fe ln lo lp lq b">value</code>和<code class="fe ln lo lp lq b">StreamItem</code>都符合<code class="fe ln lo lp lq b">Codable</code>协议。</p><p id="fa08" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">流值需要是泛型的，以便容纳任何类型的值。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="c2f9" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">创建您的流模型</h1><p id="5ab3" class="pw-post-body-paragraph kq kr it ks b kt mr ju kv kw ms jx ky kz mt lb lc ld mu lf lg lh mv lj lk ll im bi translated">我们稍后将讨论操作符的结构。让我们把一个<code class="fe ln lo lp lq b">StreamItem</code>数组放在一起作为<code class="fe ln lo lp lq b">StreamModel</code>。</p><pre class="kj kk kl km gt mx lq my mz aw na bi"><span id="9907" class="nb ma it lq b gy nc nd l ne nf"><strong class="lq iu">struct</strong> StreamModel&lt;T: Codable&gt;: Codable, Identifiable {</span><span id="5db0" class="nb ma it lq b gy ng nd l ne nf"><strong class="lq iu">  var</strong> id: UUID</span><span id="8541" class="nb ma it lq b gy ng nd l ne nf"><strong class="lq iu">  var</strong> name: String?</span><span id="bb0a" class="nb ma it lq b gy ng nd l ne nf"><strong class="lq iu">  var</strong> description: String?</span><span id="5e4a" class="nb ma it lq b gy ng nd l ne nf"><strong class="lq iu">  var</strong> stream: [StreamItem&lt;T&gt;]</span><span id="0da1" class="nb ma it lq b gy ng nd l ne nf">}</span></pre><p id="51ab" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe ln lo lp lq b">StreamModel</code>保存一个<code class="fe ln lo lp lq b">StreamItem</code>的数组。<code class="fe ln lo lp lq b">StreamModel</code>还具有ID、名称和描述属性，用于识别和描述目的。同样，<code class="fe ln lo lp lq b">StreamModel</code>中的所有东西都必须是<code class="fe ln lo lp lq b">Codable</code>才能持久和分发。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="afe1" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">创建操作员结构</h1><p id="c712" class="pw-post-body-paragraph kq kr it ks b kt mr ju kv kw ms jx ky kz mt lb lc ld mu lf lg lh mv lj lk ll im bi translated">如前所述，<code class="fe ln lo lp lq b">delay</code>操作员可以改变<code class="fe ln lo lp lq b">StreamItem</code>的发射时间。</p><pre class="kj kk kl km gt mx lq my mz aw na bi"><span id="706a" class="nb ma it lq b gy nc nd l ne nf"><strong class="lq iu">enum</strong> Operator {<br/>  <strong class="lq iu">case</strong> delay(seconds: Double)<br/>}</span></pre><p id="5371" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们将<code class="fe ln lo lp lq b">delay</code>操作符视为带有一个关联值的<code class="fe ln lo lp lq b">enum</code>，以保持延迟时间。</p><p id="67db" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当然，运算符<code class="fe ln lo lp lq b">enum</code>还需要符合<code class="fe ln lo lp lq b">Codable</code> <em class="mw">、</em>，其中包括对下划线关联值的编码和解码。请参见下面的完整实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="1eec" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，我们有一个很好的结构来表示这个串行流，它以第二个延迟间隔从<code class="fe ln lo lp lq b">1</code>到<code class="fe ln lo lp lq b">4</code>发出值。</p><pre class="kj kk kl km gt mx lq my mz aw na bi"><span id="e602" class="nb ma it lq b gy nc nd l ne nf"><strong class="lq iu">let</strong> streamA = (1...4).map { StreamItem(value: $0,</span><span id="c2f6" class="nb ma it lq b gy ng nd l ne nf">operators: [.delay(seconds: 1)]) }</span><span id="4929" class="nb ma it lq b gy ng nd l ne nf"><strong class="lq iu">let</strong> serialStreamA = StreamModel(id: UUID(), name: "Serial Stream A",</span><span id="db86" class="nb ma it lq b gy ng nd l ne nf">description: <strong class="lq iu">nil</strong>, stream: streamA)</span></pre></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="62a7" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">将StreamModel转换为Publisher</h1><p id="32ee" class="pw-post-body-paragraph kq kr it ks b kt mr ju kv kw ms jx ky kz mt lb lc ld mu lf lg lh mv lj lk ll im bi translated">现在我们已经构建了一个流实例；然而，如果我们不将其转换为<em class="mw"> </em>发行商，那么到目前为止的一切都将毫无意义。让我们试一试。</p><p id="59cf" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，每个操作符模型链接到一个实际的组合操作符，该操作符应该添加到给定的发布者并返回被操作的发布者。</p><pre class="kj kk kl km gt mx lq my mz aw na bi"><span id="f67d" class="nb ma it lq b gy nc nd l ne nf"><strong class="lq iu">extension</strong> Operator {</span><span id="15cc" class="nb ma it lq b gy ng nd l ne nf"><strong class="lq iu">func</strong> applyPublisher&lt;T&gt;(<strong class="lq iu">_</strong> publisher: AnyPublisher&lt;T, Never&gt;) -&gt; AnyPublisher&lt;T, Never&gt; {</span><span id="3a06" class="nb ma it lq b gy ng nd l ne nf"><strong class="lq iu">  switch</strong> <strong class="lq iu">self</strong> {<br/><strong class="lq iu">    case</strong> .delay(<strong class="lq iu">let</strong> seconds):<br/><strong class="lq iu">    return</strong> publisher.delay(for: .seconds(seconds), scheduler: DispatchQueue.main).eraseToAnyPublisher()<br/>  }<br/> }<br/>}</span></pre><p id="274f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">目前只有一种类型的运营商，<code class="fe ln lo lp lq b">delay</code>。我们将继续添加更多内容。</p><p id="a48e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我们可以开始为每个<code class="fe ln lo lp lq b">StreamItem</code>申请出版商了。</p><pre class="kj kk kl km gt mx lq my mz aw na bi"><span id="b52e" class="nb ma it lq b gy nc nd l ne nf"><strong class="lq iu">extension</strong> StreamItem {</span><span id="0e7c" class="nb ma it lq b gy ng nd l ne nf"><strong class="lq iu">  func</strong> toPublisher() -&gt; AnyPublisher&lt;T, Never&gt; {</span><span id="a37f" class="nb ma it lq b gy ng nd l ne nf"><strong class="lq iu">    var</strong> publisher: AnyPublisher&lt;T, Never&gt; =<br/>                   <strong class="lq iu">Just</strong>(value).eraseToAnyPublisher()</span><span id="5a2a" class="nb ma it lq b gy ng nd l ne nf"><strong class="lq iu">    self</strong>.operators.forEach {<br/>       publisher = $0.<strong class="lq iu">applyPublisher</strong>(publisher)<br/>    }</span><span id="1d06" class="nb ma it lq b gy ng nd l ne nf">  <strong class="lq iu">  return</strong> publisher<br/> }</span><span id="fe55" class="nb ma it lq b gy ng nd l ne nf">}</span></pre><p id="207e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们从一个<code class="fe ln lo lp lq b"><a class="ae lm" href="https://developer.apple.com/documentation/combine/just" rel="noopener ugc nofollow" target="_blank">Just</a></code>值开始，用<code class="fe ln lo lp lq b"><a class="ae lm" href="https://developer.apple.com/documentation/combine/just/3333471-erasetoanypublisher" rel="noopener ugc nofollow" target="_blank">eraseToAnyPublisher</a> </code>方法将其一般化，然后应用来自所有相关操作符的发布者。</p><p id="495c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在<code class="fe ln lo lp lq b">StreamModel</code>层面上，这就是我们如何获得整个流的发布者。</p><pre class="kj kk kl km gt mx lq my mz aw na bi"><span id="ba02" class="nb ma it lq b gy nc nd l ne nf"><strong class="lq iu">extension</strong> StreamModel {</span><span id="38e7" class="nb ma it lq b gy ng nd l ne nf"><strong class="lq iu">  func</strong> toPublisher() -&gt; AnyPublisher&lt;T, Never&gt; {</span><span id="a838" class="nb ma it lq b gy ng nd l ne nf"><strong class="lq iu">    let</strong> intervalPublishers = <br/>         <strong class="lq iu">self</strong>.stream.map { $0.toPublisher() }</span><span id="97ad" class="nb ma it lq b gy ng nd l ne nf"><strong class="lq iu">    var</strong> publisher: AnyPublisher&lt;T, Never&gt;?</span><span id="b1a4" class="nb ma it lq b gy ng nd l ne nf"><strong class="lq iu">    for</strong> intervalPublisher <strong class="lq iu">in</strong> intervalPublishers {</span><span id="fba5" class="nb ma it lq b gy ng nd l ne nf"><strong class="lq iu">      if</strong> publisher == <strong class="lq iu">nil</strong> {<br/>        publisher = intervalPublisher<br/><strong class="lq iu">        continue<br/>      </strong>}</span><span id="1995" class="nb ma it lq b gy ng nd l ne nf">      publisher = <br/>         publisher?.append(intervalPublisher).eraseToAnyPublisher()</span><span id="4c4f" class="nb ma it lq b gy ng nd l ne nf">    }<br/><strong class="lq iu">    return</strong> publisher ?? Empty().eraseToAnyPublisher()<br/>  }<br/>}</span></pre><p id="f685" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您猜对了:我们使用<code class="fe ln lo lp lq b"><a class="ae lm" href="https://developer.apple.com/documentation/combine/publisher/3204684-append" rel="noopener ugc nofollow" target="_blank">append</a></code>方法将发布者连接在一起。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="be8c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">可视化流，编辑，并再次可视化</h1><p id="3a05" class="pw-post-body-paragraph kq kr it ks b kt mr ju kv kw ms jx ky kz mt lb lc ld mu lf lg lh mv lj lk ll im bi translated">现在，我们可以简单地解码发布者并提供和构建流视图<em class="mw"> </em>(参见我们在<a class="ae lm" href="https://medium.com/@kevinminority/visualize-combine-magic-with-swiftui-part-4-6d0c5678f89e" rel="noopener">之前的系列文章</a><em class="mw">中是如何做的)。</em>最后但同样重要的是，我们现在可以简单地编辑<code class="fe ln lo lp lq b">StreamModel</code>，添加更多具有新值的<code class="fe ln lo lp lq b">StreamItem</code>，甚至可以通过互联网与其他设备共享这个模型。</p><p id="a5de" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">请看下面的演示。我们现在能够在不改变代码的情况下改变流。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/fa005b854e0cd3b047cad2419efd0802.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/1*dBpAfPXsSmzkEVMYU_Nswg.gif"/></div></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="e2c2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">下一章:序列化/反序列化过滤器和映射操作符</h1><p id="e5ba" class="pw-post-body-paragraph kq kr it ks b kt mr ju kv kw ms jx ky kz mt lb lc ld mu lf lg lh mv lj lk ll im bi translated">在下一篇文章中，我们将在<code class="fe ln lo lp lq b">enum</code>操作符中添加更多的操作符，并开始在流级别上应用它们。</p><div class="ny nz gp gr oa ob"><a href="https://medium.com/better-programming/persist-filtering-logics-with-swift-combine-6c3594be77cc" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">通过快速组合保持过滤逻辑</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">数据驱动联合收割机(下)</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">medium.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op ko ob"/></div></div></a></div><p id="8961" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">直到下一次，你可以在这个<a class="ae lm" href="https://github.com/kevinjohnason/combine-magic-swiftui" rel="noopener ugc nofollow" target="_blank">combine-magic-swi fui repo</a>的combine-playground文件夹下找到源代码。</p></div></div>    
</body>
</html>