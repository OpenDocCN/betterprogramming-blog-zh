<html>
<head>
<title>SwiftUI Baggage: Using UIKit in a Reactive World</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI包:在反应式世界中使用UIKit</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-baggage-using-uikit-in-a-reactive-world-45fd0eb64e62?source=collection_archive---------11-----------------------#2019-10-30">https://betterprogramming.pub/swiftui-baggage-using-uikit-in-a-reactive-world-45fd0eb64e62?source=collection_archive---------11-----------------------#2019-10-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e4f7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">UIKit是你无法摆脱的前任，但你可以让它工作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ee488ac20a0f9f02285855725a09772c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_QVzSvN8mgoTkpveukneUg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">尼克·舒利亚欣在<a class="ae ky" href="https://unsplash.com/s/photos/sad?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="1189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">围绕SwiftUI的炒作和兴奋令人敬畏。在<a class="ae ky" href="https://twitter.com/search?q=%23swiftui&amp;src=typed_query" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae ky" href="https://www.reddit.com/r/swift/" rel="noopener ugc nofollow" target="_blank">子Reddits </a>、播客、<a class="ae ky" href="https://stackoverflow.com/questions/tagged/swiftui" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>，当然，就在<a class="ae ky" href="https://medium.com/search?q=swiftui" rel="noopener">媒体</a>上，一切都在热烈讨论。是的，虽然有很多理由可能坚持现在就发布SwiftUI应用程序，但毫无疑问，iOS社区已经开始在他们的一些项目中采用它。</p><p id="4d4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使所有的宣传、刺激、项目和100天的SwiftUI马拉松都在进行，房间里仍然有一头大象。它的名字叫UIKit。</p><p id="9060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI还是年轻新鲜的(从字面上理解就是刚生产一个多月)。虽然有证据表明苹果正在他们平台的最新版本中使用SwiftUI，但这并不意味着他们已经覆盖了所有版本。这不应该是一种期望，也不应该很快成为现实。更不用说我们已经了解和喜爱的所有开源框架、pods和软件包，它们可能永远不会离开它们的UIKit身份。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9709" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">可代表的:不完全是装的</h1><p id="8763" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">与SwiftUI一起发布的还有一个苹果提供的解决方案。<code class="fe mz na nb nc b">UIViewRepresentable</code>和<code class="fe mz na nb nc b">UIViewControllerRepresentable</code>是为将UIKit元素包装在<code class="fe mz na nb nc b">View</code>中而设置的协议，以及在您的元素和SwiftUI代码之间设置交互的存根。</p><p id="26e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着你的<code class="fe mz na nb nc b">UIView</code>是一个真实的<code class="fe mz na nb nc b">UIView</code>，它存在于一个真实的SwiftUI <code class="fe mz na nb nc b">View</code>中。然而(不要政治化)，代表和直接的面对面交流是不一样的。尤其是当代表性的模型(或者，在这种情况下，协议)被制作成“一刀切”时。</p><p id="76cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过一个简单的例子来理解我的意思。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="515a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">LinkPresentation:调整大小很重要</h1><p id="4baa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/LinkPresentation" rel="noopener ugc nofollow" target="_blank"> LinkPresentation </a>是iOS 13中devs的新功能，它开放了苹果在消息中用于链接预览的内容。<code class="fe mz na nb nc b">LPLinkView</code>是一个<code class="fe mz na nb nc b">UIView</code>，这有几个原因。首先，它使现有项目可以使用它(即使是iOS 13+)。第二，在SwiftUI出现之前，它显然已经存在于消息中了，所以这里并不是重新发明轮子。</p><p id="eda9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没问题！我们就用<code class="fe mz na nb nc b">UIViewRepresentable</code>把它包起来:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ba37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，对吗？完成，故事结束，拜拜。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/737d3e78a07d403cecb4025bb2396c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*a6X3mbxSwXEIdWBJ0-3XZA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">呃…就这样？</p></figure><p id="3bb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">错了！</strong>那是，可惜，<em class="ng">不是</em>它。虽然我们的UIView可能在<code class="fe mz na nb nc b">makeUIView</code>协议中处理获取完成(或者，甚至<code class="fe mz na nb nc b">updateUIView</code>)，但是没有任何东西告诉SwiftUI我们想要重绘或调整大小，即使我们在UIKit中调用了一个。因为SwiftUI依赖于状态，所以我们需要使用一个<code class="fe mz na nb nc b">State</code>属性来触发重绘。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="12e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将看到LinkPresentation的辉煌之处:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/f2bf9f1d2f0ef699fb562140322d42ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*KaEsVfPA76-n9s2Nnh_PHQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这还差不多…但是我不喜欢我们是怎么走到这一步的</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6fe5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">感觉不对，但我知道这是对的</h1><p id="e5fe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这其实是SwiftUI和UIKit之间最好的解决方案…尽管感觉不对。原因是因为我在两个世界之间挣扎，我被迫意识到继续前进意味着放手。</p><p id="4ef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更具体地说，我的大脑的旧UIKit版本正在寻找一个协议，在那里我可以手动调用我的<code class="fe mz na nb nc b">Representable</code>的刷新，就像我在<code class="fe mz na nb nc b">ViewController</code>中一样。但是，真的，我需要接受这是一个<code class="fe mz na nb nc b">View</code>并且需要被如此对待。</p><p id="b7e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设<code class="fe mz na nb nc b">LinkPresentation</code>被实现为SwiftUI <code class="fe mz na nb nc b">View</code>。我想象我们将把<code class="fe mz na nb nc b">LPLinkMetadata</code>包装成一个<code class="fe mz na nb nc b">State</code>属性。这样，当我们的fetch回调设置这个<code class="fe mz na nb nc b">State</code>时，它就作为我们的redraw触发器。我们本质上是在SwiftUI中使用绑定。在一个反应式框架中，我们为我们的UI设置了一个反应。</p><p id="27c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实是，通过将一个<code class="fe mz na nb nc b">State</code>属性附加到我们的<code class="fe mz na nb nc b">Representative</code>上，这实际上是正确表示UIView的必要的最后一步。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="928b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不能退出U(IKit)</h1><p id="bf98" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">UIKit永远不会消失。好了，我说了。经验丰富的开发人员可以松一口气，新手可以尽情地发泄。</p><p id="7c87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我见过现在生产中还在使用xib的app。然后是用UIKit编写的极其复杂和令人印象深刻的UIViews(如代码，而不是故事板)。最后，已经有大量的UI包/包被编写出来，并且来源于外界。</p><p id="d7f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，随着时间的推移，将会有新的应用程序，新的软件包，以及那些将处理转换。但是任何认为SwiftUI将会把UIKit从App Store中彻底清除的人都非常兴奋。我明白了，我<em class="ng">爱</em> SwiftUI。我想更爱它。我们只需要给它时间成长。</p></div></div>    
</body>
</html>