<html>
<head>
<title>Applying the Open-Closed Principle To Write Clean React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用开闭原则编写干净的React组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/applying-the-open-closed-principle-to-write-clean-react-components-4e4514963e40?source=collection_archive---------4-----------------------#2021-04-01">https://betterprogramming.pub/applying-the-open-closed-principle-to-write-clean-react-components-4e4514963e40?source=collection_archive---------4-----------------------#2021-04-01</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="251a" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">看看实际应用中的可靠原则</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/49f75ab233635a4236f3f89702a776c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fDnTFxp5F7UVFu5ZrL0s2g.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">来自<a class="ae kz" href="https://www.pexels.com/photo/black-camera-accessory-lot-1476316/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的免费创意素材。</p></figure><p id="f369" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">坚实是一套原则。它们主要是为关心代码质量和可维护性的软件专业人员提供的指南。</p><p id="c5a2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">React本质上不是面向对象的，但是这些原则背后的主要思想可能是有帮助的。在本文中，我将尝试演示如何应用这些原则来编写更好的代码。</p><p id="abfb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-apply-solid-principles-to-clean-your-code-in-react-cdfd5e0a9cea">之前的一篇文章</a>中，我们谈到了单一责任原则。今天，我们将讨论固体的第二个原理:开闭原理。</p><h1 id="8230" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">本系列的其他文章</h1><ol class=""><li id="cb0c" class="mo mp iu lc b ld mq lg mr lj ms ln mt lr mu lv mv mw mx my bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-apply-solid-principles-to-clean-your-code-in-react-cdfd5e0a9cea">单一责任原则</a></li><li id="92ab" class="mo mp iu lc b ld mz lg na lj nb ln nc lr nd lv mv mw mx my bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/applying-the-liskov-substitution-principle-in-react-3a0614a42a08">利斯科夫替代原理</a></li><li id="be8b" class="mo mp iu lc b ld mz lg na lj nb ln nc lr nd lv mv mw mx my bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-apply-interface-segregation-principle-in-reactjs-fadf77113c5d">界面分离原理</a></li><li id="46f6" class="mo mp iu lc b ld mz lg na lj nb ln nc lr nd lv mv mw mx my bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/apply-the-dependency-inversion-principle-in-react-c20a0afc3d64">依存倒置原则</a></li></ol></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><h1 id="34aa" class="lw lx iu bd ly lz nl mb mc md nm mf mg ka nn kb mi kd no ke mk kg np kh mm mn bi translated">开闭原理是什么？</h1><p id="f21c" class="pw-post-body-paragraph la lb iu lc b ld mq jv lf lg mr jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">根据索本·让桑在Stackify 上的说法:</p><blockquote class="nt nu nv"><p id="8b2a" class="la lb nw lc b ld le jv lf lg lh jy li nx lk ll lm ny lo lp lq nz ls lt lu lv in bi translated">罗伯特·c·马丁认为这个原则是“面向对象设计最重要的原则”但他不是第一个定义它的人。Bertrand Meyer在1988年他的书《面向对象软件构造》中写到了这一点。他把开/关原理解释为:</p><p id="4a59" class="la lb nw lc b ld le jv lf lg lh jy li nx lk ll lm ny lo lp lq nz ls lt lu lv in bi translated">软件实体(类、模块、函数等。)应该对扩展开放，但对修改关闭。"</p></blockquote><p id="8584" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个原则告诉你以这样一种方式编写代码，你将能够在不改变现有代码的情况下添加额外的功能。</p><p id="6813" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看看在哪里可以应用这个原则。</p></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><h1 id="ea58" class="lw lx iu bd ly lz nl mb mc md nm mf mg ka nn kb mi kd no ke mk kg np kh mm mn bi translated">让我们从一个例子开始</h1><p id="997b" class="pw-post-body-paragraph la lb iu lc b ld mq jv lf lg mr jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">假设我们有一个<code class="fe oa ob oc od b">User</code>组件，我们在其中传递用户的详细信息，这个类的主要目的是显示特定用户的详细信息。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oe of l"/></div></figure><p id="5697" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是足够简单的开始。但是我们的生活并不那么简单。几天后，我们的经理告诉我们，在我们的系统中有三种类型的用户:<code class="fe oa ob oc od b">SuperAdmin</code>、<code class="fe oa ob oc od b">Admin</code>等。</p><p id="1c4f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">并且它们中的每一个都将具有不同的信息和功能。</p></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><h1 id="e403" class="lw lx iu bd ly lz nl mb mc md nm mf mg ka nn kb mi kd no ke mk kg np kh mm mn bi translated">糟糕的解决方案</h1><p id="e533" class="pw-post-body-paragraph la lb iu lc b ld mq jv lf lg mr jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">第一个显而易见的解决方案是在我们的组件中包含一个条件，并根据不同的用户类型呈现不同的信息。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oe of l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">User.js</p></figure><p id="5744" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你看出这里有什么问题了吗？</p><p id="fc97" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，我们的代码现在很乱。</p><p id="e939" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">其次，如果我们需要另一类用户呢？然后，我们需要进入<code class="fe oa ob oc od b">User.js</code>，为该特定类型的用户添加另一个条件。</p><p id="e3cf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这显然违反了开闭原则，因为我们不允许修改<code class="fe oa ob oc od b">User</code>组件中的代码。</p></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><h1 id="7368" class="lw lx iu bd ly lz nl mb mc md nm mf mg ka nn kb mi kd no ke mk kg np kh mm mn bi translated">有什么解决办法？</h1><p id="9d8e" class="pw-post-body-paragraph la lb iu lc b ld mq jv lf lg mr jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">好了，我们可以在这个场景中应用两种主要技术:</p><ol class=""><li id="f0ef" class="mo mp iu lc b ld le lg lh lj og ln oh lr oi lv mv mw mx my bi translated">高阶分量</li><li id="27f5" class="mo mp iu lc b ld mz lg na lj nb ln nc lr nd lv mv mw mx my bi translated">成分组成</li></ol><p id="65e4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">尽可能走第二条路会更好，但是在某些情况下，使用特设是必要的。</p><p id="35b3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们将使用脸书推荐的技术，称为<a class="ae kz" href="https://reactjs.org/docs/composition-vs-inheritance.html" rel="noopener ugc nofollow" target="_blank">组件组合</a>。</p></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><h1 id="eafc" class="lw lx iu bd ly lz nl mb mc md nm mf mg ka nn kb mi kd no ke mk kg np kh mm mn bi translated">让我们创建单独的用户组件</h1><p id="3d0e" class="pw-post-body-paragraph la lb iu lc b ld mq jv lf lg mr jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">现在我们需要设计我们的代码，这样我们就不需要在<code class="fe oa ob oc od b">User.js</code>组件中添加条件。让我们为<code class="fe oa ob oc od b">SuperAdmin</code>创建一个单独的组件:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oe of l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">SuperAdmin.js</p></figure><p id="2f5f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">类似的，另一个给<code class="fe oa ob oc od b">Admin</code>用户的:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oe of l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">管理员. js</p></figure><p id="995a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们的App.js文件变成了</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oe of l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">App.js</p></figure><p id="d91e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们可以根据需要创建任意多的用户类型。我们针对特定用户的逻辑被封装，我们不需要重新访问代码进行任何额外的修改。</p><p id="494b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有些人可能会认为我们增加了不必要的文件数量。<br/>当然，您现在可以保持原样，但是随着应用程序复杂性的增加，您肯定会感到痛苦。</p></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><h1 id="dffe" class="lw lx iu bd ly lz nl mb mc md nm mf mg ka nn kb mi kd no ke mk kg np kh mm mn bi translated">警告</h1><p id="c306" class="pw-post-body-paragraph la lb iu lc b ld mq jv lf lg mr jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">坚实是一套原则。它们不是强制要求你在每种情况下都应用。作为一名经验丰富的开发人员，您应该在代码长度和可读性之间找到一个良好的平衡。</p><p id="37a1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">不要过分纠结于这些原则。事实上，有一个著名的短语可以解释这些场景:</p><blockquote class="oj"><p id="3bd2" class="ok ol iu bd om on oo op oq or os lv dk translated">“固体太多了。”</p></blockquote><p id="10ec" class="pw-post-body-paragraph la lb iu lc b ld ot jv lf lg ou jy li lj ov ll lm ln ow lp lq lr ox lt lu lv in bi translated">所以知道这些原则是好的，但是你得保持平衡。对于一两个额外的字段，你可能不需要这些组合，但是从长远来看，将它们分开肯定会有帮助。</p></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><h1 id="19a1" class="lw lx iu bd ly lz nl mb mc md nm mf mg ka nn kb mi kd no ke mk kg np kh mm mn bi translated">结论</h1><p id="0c98" class="pw-post-body-paragraph la lb iu lc b ld mq jv lf lg mr jy li lj nq ll lm ln nr lp lq lr ns lt lu lv in bi translated">了解这些原则会让你走得更远，因为归根结底，一段好的代码才是最重要的，做事没有单一的方式。</p><p id="4a09" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">祝您愉快！</p><p id="a04c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">固体的第三个原理(利斯科夫替代原理)在这里<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/applying-the-liskov-substitution-principle-in-react-3a0614a42a08">讨论</a></p><div class="oy oz gq gs pa pb"><a rel="noopener  ugc nofollow" target="_blank" href="/applying-the-liskov-substitution-principle-in-react-3a0614a42a08"><div class="pc ab fp"><div class="pd ab pe cl cj pf"><h2 class="bd iv gz z fq pg fs ft ph fv fx it bi translated">里斯科夫替代原理在React中的应用</h2><div class="pi l"><h3 class="bd b gz z fq pg fs ft ph fv fx dk translated">看看实际应用中的可靠原则</h3></div><div class="pj l"><p class="bd b dl z fq pg fs ft ph fv fx dk translated">better编程. pub</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp kt pb"/></div></div></a></div><p id="5c1f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">有什么话要说？通过</strong> <a class="ae kz" href="https://www.linkedin.com/in/56faisal/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv"> LinkedIn </strong> </a>与我联系</p><h1 id="383e" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">资源</h1><ul class=""><li id="b1c5" class="mo mp iu lc b ld mq lg mr lj ms ln mt lr mu lv pq mw mx my bi translated"><a class="ae kz" href="https://stackify.com/solid-design-open-closed-principle/" rel="noopener ugc nofollow" target="_blank">https://stackify.com/solid-design-open-closed-principle/</a></li></ul></div></div>    
</body>
</html>