<html>
<head>
<title>Trying Out the Promise.allSettled Combinator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">尝试承诺。allSettled Combinator</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/trying-out-the-promise-allsettled-combinator-8aec45edd676?source=collection_archive---------7-----------------------#2020-05-05">https://betterprogramming.pub/trying-out-the-promise-allsettled-combinator-8aec45edd676?source=collection_archive---------7-----------------------#2020-05-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1ea6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在解决所有潜在承诺后，返回承诺</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d495cb6e0cb996ecfb4aa14c65178534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IiS9aRq6p51MBkhA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pankaj Patel </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="be31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您是否曾经遇到过这样的场景:您必须发出多个请求并执行一个操作，而所有这些请求都得到满足？或者您可能想检查有多少请求被解决，有多少被拒绝？</p><p id="4476" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大多数情况下，您会使用<code class="fe lv lw lx ly b">Promise.all</code>，<strong class="lb iu"> </strong>这是一个强大的组合器，在处理带有承诺的多个请求时非常有用。但是使用这个组合器也有一些缺点。为了解释这意味着什么，让我们看一下图1:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/d2f9668b8b92c19bf6ea28422cb85bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1fNh5sQdtTmvJNIw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1</p></figure><p id="e750" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设在URL的数组中有一些API端点，并且已经向所有这些端点发送了请求。如果您使用的是<code class="fe lv lw lx ly b">Promise.all</code>，甚至有一个请求被拒绝，那么就会出现短路，剩下的请求就会丢失。您也将无法跟踪其余的请求，因为代码块将落入try-catch语句的catch情况中。</p><p id="6c42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这些情况，<strong class="lb iu"> </strong>贾森·威廉姆斯(BBC)、罗伯特·帕梅利(彭博)和冠军马蒂亚斯·拜恩斯(谷歌)提出了一个新的承诺组合子，被称为<code class="fe lv lw lx ly b">Promise.allSettled</code>。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="60c4" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">到底什么是Promise.allSettled？</strong></h1><p id="1776" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/tc39/proposal-promise-allSettled" rel="noopener ugc nofollow" target="_blank">Promise.allSettled</a></code>是一个新的组合子，将于今年加入JavaScript。目前，该提案处于完成状态。</p><p id="f0c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Promise.allSettled()</code>返回一个承诺，该承诺在所有给定承诺被解决或拒绝后解决，并带有一个描述每个承诺结果的对象数组。</p><h2 id="80e2" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">用例#1</h2><p id="45fc" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">让我们修改下面给出的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/46124c7717b2627ab0ff78a82304e44d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jSZ_yvWlS6Z4pBfJ"/></div></div></figure><p id="b634" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经将请求数组传递给了<code class="fe lv lw lx ly b">Promise.allSettled</code>并调用了<code class="fe lv lw lx ly b">finally()</code>。这种实现完全没有短路。流动永远不会因为拒绝而停止。因此，不需要编写try-catch语句和额外的检查。看起来很酷，对吧？那我们为什么不看看另一个用例呢！</p><h2 id="b4a3" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated"><strong class="ak">用例2 </strong></h2><p id="c839" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如果我们必须跟踪哪些请求被满足，哪些请求被拒绝，那该怎么办？传统上，我们会在一个helper函数的帮助下完成它，该函数接受一个承诺，并将其状态返回到已完成或已拒绝。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/a3ec47692733aea53a488c4f6c38df4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z2bErakcwpSmCksR"/></div></div></figure><p id="ebc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你浏览一下上面的例子，你会发现我们已经创建了一个名为<code class="fe lv lw lx ly b">reflect</code>的助手函数。这个函数将一个承诺作为参数，并在return语句中调用它。如果承诺被成功解决，那么它将落入<code class="fe lv lw lx ly b">.then()</code>块的第一个回调函数中，这就是所谓的<code class="fe lv lw lx ly b">onFulfilled</code>。使用这个，我们从<code class="fe lv lw lx ly b">onFulfilled</code>回调函数返回状态为fulfilled的已履行值。如果承诺被拒绝，那么它将陷入第二个回调函数，这就是所谓的<code class="fe lv lw lx ly b">onRejected</code>。在这里，我们返回错误和从回调中拒绝的状态。</p><p id="30a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将把<code class="fe lv lw lx ly b">reflect</code>作为回调函数传递给<code class="fe lv lw lx ly b">promises.map()</code>，然后它将映射所有承诺并返回所有结果的数组。为了检查成功的承诺，我们在状态的帮助下过滤结果。<code class="fe lv lw lx ly b">successfulPromises</code>数组将包含所有完成的请求。如你所见，这是一个很大的工作量。</p><p id="0725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看<code class="fe lv lw lx ly b">Promise.allSettled</code>如何简化这一过程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/209b569ec1a3c00564f247115a7d289c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SbirWAsWhTqZf8DN"/></div></div></figure><p id="f68a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，您可以感觉到传统方法与使用<code class="fe lv lw lx ly b">Promise.allSettled</code>的区别。没有必要编写自己的实现。</p><p id="84a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Promise.allSettled</code>将映射承诺并返回一个包含所有结果的数组——满足或拒绝。我们可以像在传统方法中一样过滤请求。所有这些都是干净的、可读的、更易于维护的。</p><p id="4ef8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想使用这个惊人的组合，那么你可以从这些惊人的资源中使用它:</p><ul class=""><li id="c121" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><a class="ae ky" href="https://www.npmjs.com/package/promise.allsettled" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/promise.allsettled</a></li><li id="87ae" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae ky" href="https://www.npmjs.com/package/q" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/q</a></li><li id="c242" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae ky" href="https://www.npmjs.com/package/rsvp" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/rsvp</a></li><li id="7dc6" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae ky" href="http://bluebirdjs.com/docs/api/reflect.html" rel="noopener ugc nofollow" target="_blank">http://bluebirdjs.com/docs/api/reflect.html</a></li><li id="b4c8" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae ky" href="https://www.npmjs.com/package/promise-settle" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/promise-settle</a></li><li id="5913" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae ky" href="https://github.com/cujojs/when/blob/master/docs/api.md#whensettle" rel="noopener ugc nofollow" target="_blank">https://github . com/cujojs/when/blob/master/docs/API . MD # when settle</a></li><li id="c33c" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae ky" href="https://www.npmjs.com/package/es2015-promise.allsettled" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/es2015-promise.allsettled</a></li><li id="30cc" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">https://www.npmjs.com/package/promise-all-settled<a class="ae ky" href="https://www.npmjs.com/package/promise-all-settled" rel="noopener ugc nofollow" target="_blank"/></li><li id="9788" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">【https://www.npmjs.com/package/maybe T4】</li></ul></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="66b3" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">底线</strong></h1><p id="ab3a" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">您可以感受到这个神奇的组合器的力量，它使处理多个请求变得简单而安全。如果您现在想使用它，那么本文提供了一个很酷的实现。在那之前，让我们就等着这个惊人的特性被添加到JavaScript的世界中吧！</p></div></div>    
</body>
</html>