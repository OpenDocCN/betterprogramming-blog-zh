<html>
<head>
<title>Unit Testing and Why You Should Be Doing It</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试以及为什么你应该这样做</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unit-testing-and-why-you-should-be-doing-it-ab61407c53ce?source=collection_archive---------6-----------------------#2019-09-30">https://betterprogramming.pub/unit-testing-and-why-you-should-be-doing-it-ab61407c53ce?source=collection_archive---------6-----------------------#2019-09-30</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="1c20" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">你能称你的代码为“好”的唯一方法是它是否经过了充分的单元测试</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/7d6d68533bddfe050c8add313ab1017e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P9zPx284oUrMyJVL"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kz" href="https://unsplash.com/@emilep?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">émile Perron</a>拍摄的照片</p></figure><blockquote class="la lb lc"><p id="9ac4" class="ld le lf lg b lh li jv lj lk ll jy lm ln lo lp lq lr ls lt lu lv lw lx ly lz in bi translated">我是在建议100%的测试覆盖率吗？不，我要求它。你写的每一行代码都应该被测试。句号。</p><p id="3d41" class="ld le lf lg b lh li jv lj lk ll jy lm ln lo lp lq lr ls lt lu lv lw lx ly lz in bi translated">我不希望管理层强制要求100%的测试覆盖率。我希望你的良心把它作为一个荣誉问题。<br/> <br/>怎么样:如果你有100%的把握，你可以随时放心地野蛮重构。</p></blockquote><p id="a4b6" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">我从鲍伯·马丁叔叔和他的一些追随者在推特上的对话中引用了上面的话。</p><p id="8a51" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">他非常热衷于代码覆盖和单元测试。我们可能都不像Bob叔叔那样严格，但是我们都应该对单元测试有一点热情。</p><p id="e995" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">这种热情应该源于编写好代码的愿望。我要说明的是，你能称你的代码为“好”的唯一方法是它是否经过了充分的单元测试。</p><p id="7349" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">如果你编写和交付的代码没有经过完全的单元测试，你应该会觉得自己像是赤身裸体地走在街上。你应该感到暴露，好像每个人都在看着你。</p><p id="cd76" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">你应该坚信，除非你的代码完全被单元测试覆盖，否则你的代码会失败得很惨。</p></div><div class="ab cl md me hy mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="in io ip iq ir"><h1 id="78ef" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">什么是单元测试</h1><p id="d146" class="pw-post-body-paragraph ld le iu lg b lh nc jv lj lk nd jy lm ma ne lp lq mb nf lt lu mc ng lx ly lz in bi translated">单元测试是对代码的测试，以确保它执行它应该执行的任务。它在尽可能低的级别测试代码——类的单个方法。</p><p id="cf16" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">这是编写干净、可维护的代码的关键。如果你专注于编写易于测试的代码，你最终会得到易于维护的解耦的、干净的、高质量的代码。不喜欢什么？</p><p id="e9d8" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">但是，当涉及到单元测试时，有时会有关于术语定义的问题。例如，到底什么是“单位”？“嘲讽”是什么意思？我如何知道我是否真的在进行单元测试？</p><p id="6d75" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">本文将介绍这些术语的含义。</p></div><div class="ab cl md me hy mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="in io ip iq ir"><h1 id="fc88" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">什么是单位？</h1><p id="6c1b" class="pw-post-body-paragraph ld le iu lg b lh nc jv lj lk nd jy lm ma ne lp lq mb nf lt lu mc ng lx ly lz in bi translated">当讨论单元测试时，首先出现的问题是，什么是单元？不知道单元是什么，就不能进行单元测试。</p><p id="2cf5" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">当谈到单元测试时，我把单元看作是任何可以独立测试的离散的代码模块。它可以像一个独立的例程一样简单，但通常是一个单独的类及其方法。</p><p id="9568" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">在许多现代语言中，类是主要的、独立的代码实体，因此是代码的基本构造块。它们是数据结构，当一起使用时，形成一个系统。</p><p id="34d1" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">在单元测试的世界里，这个类通常被称为测试中的<em class="lf">类</em> (CUT)或者测试中的<em class="lf">系统</em> (SUT)。</p><p id="8688" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">您将看到这些术语被广泛使用——强烈建议您使用CUT作为被测试类的变量名。</p><p id="2ca7" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">定义:一个单元是任何可以被孤立测试的代码实体，通常是一个类。</p></div><div class="ab cl md me hy mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="in io ip iq ir"><h1 id="435a" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">我在做单元测试吗？</h1><p id="41c6" class="pw-post-body-paragraph ld le iu lg b lh nc jv lj lk nd jy lm ma ne lp lq mb nf lt lu mc ng lx ly lz in bi translated">因此，当你进行单元测试时，你通常是在测试类(为了讨论的方便，这将是下文的假设)。</p><p id="b067" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">但是要注意的关键是，当对一个类进行单元测试时，你是在对给定的类进行单元测试，而且只对给定的类进行单元测试。单元测试总是在隔离中完成的——也就是说，被测试的类需要与任何其他类或任何其他系统完全隔离。</p><p id="73aa" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">如果你正在测试一个类，并且你需要一些外部实体，那么你就不再是单元测试了。一个类只有当它的依赖项可以是并且是“伪造的”时才是“可测试的”,从而在没有任何真正的外部依赖项的情况下被测试。</p><p id="743f" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">因此，如果您正在运行您认为是单元测试的东西，并且该测试需要访问数据库、文件系统或任何其他外部系统，那么您已经停止了单元测试，并且已经开始了集成测试。</p><p id="b41d" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">有一点我想明确一下。做集成测试没什么丢人的。集成测试真的很重要，应该做。单元测试框架通常是进行集成测试的一个非常好的方法。</p><p id="8116" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">我不想给你留下这样的印象，因为集成不是单元测试，你不应该这样做——恰恰相反。然而，这是一个重要的区别。</p><p id="00ba" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">这里的要点是认识到什么是单元测试，并在打算编写单元测试时努力编写它们。无论如何，要写集成测试，但是不要写集成测试来代替单元测试。</p><p id="4160" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">这么想吧。每个单元测试框架都创建一个测试可执行文件。如果您不能在您母亲的计算机上的一个只读目录中成功地运行测试可执行文件，那么您就不再是单元测试了。</p><p id="759a" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">定义:单元测试是孤立地测试一个类的行为，完全脱离它的任何实际依赖。</p><p id="1210" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">定义:集成测试是测试单个类及其一个或多个实际外部依赖的行为。</p></div><div class="ab cl md me hy mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="in io ip iq ir"><h1 id="49b0" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">什么是隔离框架？</h1><p id="85f8" class="pw-post-body-paragraph ld le iu lg b lh nc jv lj lk nd jy lm ma ne lp lq mb nf lt lu mc ng lx ly lz in bi translated">通常，开发人员使用术语<em class="lf">模仿框架</em>来描述提供虚假服务以允许类被隔离测试的代码。</p><p id="e49f" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">然而，正如我们将在下面看到的,<em class="lf"> mock </em>是一种特殊的伪类，还有存根。因此，使用术语<em class="lf">隔离框架</em>而不是<em class="lf">模仿框架</em>可能更准确。</p><p id="f24a" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">一个有用的隔离框架将允许容易地创建两种类型的假货——模仿和存根。</p><p id="0697" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">Fakes允许您通过提供依赖项的实现来单独测试一个类，而不需要真正的依赖项。</p><p id="c396" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">定义:一个隔离框架是一个代码的集合，它使得伪造变得容易。</p><p id="fbb3" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">定义:假类是任何提供足够的功能来假装它是被测试类所需要的依赖项的类。假货有两种:存根和仿制品。</p><p id="8938" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">如果你想深入了解这个东西，我强烈推荐你阅读<a class="ae kz" href="https://www.amazon.com/Art-Unit-Testing-examples/dp/1617290890" rel="noopener ugc nofollow" target="_blank"> <em class="lf">《单元测试的艺术:示例》。罗伊·奥舍洛夫著</em> </a>网。或者，你可以在<a class="ae kz" href="http://hanselminutes.com/169/the-art-of-unit-testing-with-roy-osherove" rel="noopener ugc nofollow" target="_blank"> Hanselminutes </a>播客中听听Roy和Scott Hanselman的对话。</p><p id="847e" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">如果你想成为超级极客，就去买一本杰拉德·梅萨罗什写的《xUnit测试模式:重构测试代码》。</p><p id="5aa0" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">这本厚重的书是单元测试的杰作，概述了测试和测试模式的完整分类。它不适合胆小的人，但是，如果你读了那本书，你会知道所有该知道的事情，甚至更多。</p></div><div class="ab cl md me hy mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="in io ip iq ir"><h1 id="f2cf" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">存根</h1><p id="c4b4" class="pw-post-body-paragraph ld le iu lg b lh nc jv lj lk nd jy lm ma ne lp lq mb nf lt lu mc ng lx ly lz in bi translated">stub是一个绝对最小化的类，它看起来是被测试类的一个实际依赖项。它不提供测试所需的任何功能，除了实现给定的接口或继承给定的基类。</p><p id="5e4f" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">当CUT调用它时，存根通常什么也不做。存根完全是测试CUT的外围设备，其存在纯粹是为了使CUT能够运行。</p><p id="b7ce" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">一个典型的例子是提供日志服务的存根。CUT可能需要实现，比如说，<code class="fe nh ni nj nk b">ILogger</code>接口来执行，但是没有一个测试关心日志记录。</p><p id="1945" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">你明确地不希望切割记录任何东西。因此，存根通过实现接口假装是日志记录服务，但是该实现实际上什么也不做。它的实现方法可能为空。</p><p id="8613" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">此外，虽然存根可能会返回数据以使CUT满意并运行，但它绝不会采取任何会导致测试失败的操作。如果是这样，那么它就不再是一个存根，而是一个模拟。</p><p id="9c8e" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">定义:存根是一个对测试的通过或失败没有影响的赝品，它的存在纯粹是为了让测试运行。</p></div><div class="ab cl md me hy mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="in io ip iq ir"><h1 id="ca0f" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">嘲弄</h1><p id="b0d0" class="pw-post-body-paragraph ld le iu lg b lh nc jv lj lk nd jy lm ma ne lp lq mb nf lt lu mc ng lx ly lz in bi translated">模拟有点复杂。Mocks做了stubs所做的事情，因为它们提供了CUT所需的依赖项的假实现。</p><p id="3eaa" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">然而，它们通过记录自身和切口之间的相互作用而不仅仅是一个存根。mock记录了与CUT的所有交互并报告回来，如果CUT行为正确，则通过测试，如果不正确，则测试失败。</p><p id="aee6" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">因此，决定测试是否通过的是模拟，而不是切割本身。</p><p id="f1f1" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">这里有一个例子。</p><p id="cc45" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">假设您有一个名为<code class="fe nh ni nj nk b">WidgetProcessor</code>的类。它有两个依赖项，一个<code class="fe nh ni nj nk b">ILogger</code>和一个<code class="fe nh ni nj nk b">IVerifier</code>。为了测试<code class="fe nh ni nj nk b">WidgetProcessor</code>，您需要伪造这两个依赖项。</p><p id="ec49" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">然而，为了测试<code class="fe nh ni nj nk b">WidgetProcessor</code>，你需要做两个测试——一个测试你存根<code class="fe nh ni nj nk b">ILogger</code>并测试与<code class="fe nh ni nj nk b">IVerifier</code>的交互，另一个测试你存根<code class="fe nh ni nj nk b">IVerifier</code>并测试与<code class="fe nh ni nj nk b">ILogger</code>的交互。</p><p id="92fb" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">两者都需要假货，但是在每种情况下，您都要为一个提供一个存根类，为另一个提供一个模拟类。</p><p id="26db" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">让我们更仔细地看看第一个场景，这里我们剔除了<code class="fe nh ni nj nk b">ILogger</code>，并对<code class="fe nh ni nj nk b">IVerifier</code>使用了一个mock。我们讨论过的存根。你要么写一个空的<code class="fe nh ni nj nk b">ILogger</code>实现，要么用一个隔离框架实现接口什么都不做。</p><p id="e870" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">然而，<code class="fe nh ni nj nk b">IVerifier</code>的假变得更有趣了——它需要一个模拟类。假设验证小部件的过程需要两步。首先，处理器需要查看小部件是否在系统中，如果在，处理器需要检查小部件的配置是否正确。</p><p id="7889" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">因此，如果您正在测试<code class="fe nh ni nj nk b">WidgetProcessor</code>，您需要运行一个测试来检查<code class="fe nh ni nj nk b">WidgetProcessor</code>是否进行了第二次调用，如果它从第一次调用中获得了<code class="fe nh ni nj nk b">True</code>的话。</p><p id="764a" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">这个测试需要模拟类做两件事。首先，它需要从第一次调用返回<code class="fe nh ni nj nk b">True</code>,然后它需要跟踪是否进行了最终的配置调用。</p><p id="755c" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">然后，模拟类的工作就是提供通过/失败信息。如果在第一次调用之后进行的第二次调用返回<code class="fe nh ni nj nk b">True</code>，则测试通过；否则，测试失败。</p><p id="e4a8" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">这就是这个假类成为mock的原因:mock本身包含需要检查通过/失败标准的信息。</p><p id="b102" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">定义:mock是一种假的东西，它跟踪被测试类的行为，并根据该行为通过或失败测试。</p><p id="130c" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">大多数隔离框架都有能力对模拟类内部发生的事情进行广泛而复杂的跟踪。</p><p id="673b" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">例如，模拟不仅可以判断给定方法是否被调用，还可以跟踪给定方法被调用的次数以及传递给这些调用的参数。</p><p id="a6f5" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">他们可以决定某样东西是否被不该叫的叫了出来，或者某样东西没有被应该叫的叫出来。作为测试设置的一部分，如果事件和参数的确切序列没有按计划执行，您可以准确地告诉mock会发生什么以及会失败。</p><p id="4148" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">存根的构建和使用相对简单，但是模拟可能会变得相当复杂。</p><p id="343a" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">但是，这里的要点是孤立地测试你的类；您希望您的部门能够在没有任何外部、真实、外部依赖的情况下履行其职责。</p><p id="8833" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">因此，最后一个定义是:</p><p id="f399" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">定义<strong class="lg iv"> : </strong>单元测试是对一个单独的代码实体的测试，当它与它的依赖项完全隔离时。</p></div><div class="ab cl md me hy mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="in io ip iq ir"><h1 id="b732" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">为什么要进行单元测试？</h1><p id="932f" class="pw-post-body-paragraph ld le iu lg b lh nc jv lj lk nd jy lm ma ne lp lq mb nf lt lu mc ng lx ly lz in bi translated">我发现做单元测试有很多阻力。许多开发人员似乎认为这是浪费时间，或者仅仅是在截止日期前延迟项目的完成。他们觉得自己从中得不到任何好处。</p><p id="0377" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">我完全不同意。原因如下。</p><h2 id="6570" class="nl ml iu bd mm nm nn dn mq no np dp mu ma nq nr mw mb ns nt my mc nu nv na nw bi translated">单元测试会发现错误</h2><p id="4e1f" class="pw-post-body-paragraph ld le iu lg b lh nc jv lj lk nd jy lm ma ne lp lq mb nf lt lu mc ng lx ly lz in bi translated">无论您是进行测试驱动开发并首先编写测试，还是在开发过程中编写测试，或者在代码编写后很久才编写测试，单元测试都会发现bug。</p><p id="1f3e" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">当您编写一整套测试来定义一个给定类的预期行为时，该类中任何不按预期行为的行为都会暴露出来。</p><h2 id="ff59" class="nl ml iu bd mm nm nn dn mq no np dp mu ma nq nr mw mb ns nt my mc nu nv na nw bi translated">单元测试会让错误远离</h2><p id="71ab" class="pw-post-body-paragraph ld le iu lg b lh nc jv lj lk nd jy lm ma ne lp lq mb nf lt lu mc ng lx ly lz in bi translated">一套完整而彻底的单元测试将有助于确保任何潜移默化到你的代码中的错误将被立即发现。</p><p id="eb17" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">做出一个引入bug的更改，您的测试可以在您下一次运行测试时揭示它。如果您发现了一个在单元测试套件范围之外的bug，您可以为它编写一个测试来确保bug不再出现。</p><h2 id="c98c" class="nl ml iu bd mm nm nn dn mq no np dp mu ma nq nr mw mb ns nt my mc nu nv na nw bi translated">单元测试节省时间</h2><p id="c79e" class="pw-post-body-paragraph ld le iu lg b lh nc jv lj lk nd jy lm ma ne lp lq mb nf lt lu mc ng lx ly lz in bi translated">单元测试是否节省时间是单元测试中最有争议的概念。大多数开发人员认为编写单元测试花费的时间比节省的时间多。我不这样认为——事实上，我持相反的观点。</p><p id="53d2" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">编写单元测试有助于确保您的代码从一开始就按设计运行。单元测试定义了你的代码应该做什么，这样你就不会花时间去写那些不应该做的事情。</p><p id="1b72" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">每一个单元测试都变成了一个回归测试，确保在你开发的时候事情继续按照设计的那样工作。它们有助于确保后续的更改不会破坏事物。</p><p id="0d0f" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">它们有助于确保你第一次写的东西是正确的。所有这些好处在短期和长期都可以节省时间。</p><p id="f54c" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">如果你想一想，你已经在编写代码的时候测试了你的代码。也许你写一个简单的控制台应用程序。至少，你可以编译并看到它运行。</p><p id="9050" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">没有人会签入他们不相信有效的代码，你必须做一些事情让你自己相信它是有效的。花时间编写单元测试，你将会用一套回归测试来解耦工作编码。</p><h2 id="cade" class="nl ml iu bd mm nm nn dn mq no np dp mu ma nq nr mw mb ns nt my mc nu nv na nw bi translated">单元测试让人安心</h2><p id="b1d5" class="pw-post-body-paragraph ld le iu lg b lh nc jv lj lk nd jy lm ma ne lp lq mb nf lt lu mc ng lx ly lz in bi translated">拥有一套完整、完整、彻底的测试来覆盖代码的全部功能可能很难实现，但是拥有它会让你安心。</p><p id="ed05" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">您可以运行所有这些测试，并知道您的代码按预期工作。您可以重构和更改代码，知道如果您破坏了任何东西，您会马上知道。</p><p id="1a30" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">知道你的代码的状态，知道它能工作，知道你能无所畏惧地更新和改进它，这是一件非常好的事情。</p><p id="5fe0" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">所有代码都会老化，但是你可以防止你的代码真正成为遗留代码。有几种方法来定义遗留代码，但一种方法是:“你害怕接触的代码。”如果你的代码有单元测试，它很难成为遗留代码。</p><p id="8161" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">我们很多人都有害怕接触的代码块，但是有了单元测试，你就不会有那种代码了。单元测试消除了触摸代码的恐惧。</p><p id="ae27" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">在《有效使用遗留代码 的<a class="ae kz" href="https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052" rel="noopener ugc nofollow" target="_blank"> <em class="lf">一书中，Michael Feathers甚至将遗留代码定义为任何没有单元测试的代码。想要避免您的代码成为遗留代码吗？为它编写单元测试。</em></a></p><h2 id="59d5" class="nl ml iu bd mm nm nn dn mq no np dp mu ma nq nr mw mb ns nt my mc nu nv na nw bi translated">单元测试记录了一个类的正确使用</h2><p id="013d" class="pw-post-body-paragraph ld le iu lg b lh nc jv lj lk nd jy lm ma ne lp lq mb nf lt lu mc ng lx ly lz in bi translated">单元测试的好处之一是您的测试可以为后续开发人员定义应该如何使用该类。</p><p id="3de3" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">实际上，单元测试变成了代码如何工作、它应该做什么以及使用被测试代码的正确方式的简单例子。代码的消费者可以从单元测试中找到让代码做它应该做的事情的正确方法的信息。</p></div><div class="ab cl md me hy mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="in io ip iq ir"><h1 id="5fe5" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">结论</h1><p id="8d2d" class="pw-post-body-paragraph ld le iu lg b lh nc jv lj lk nd jy lm ma ne lp lq mb nf lt lu mc ng lx ly lz in bi translated">好吧，如果这些都不能说服你去做单元测试，我不知道还有什么能说服你。</p><p id="12a6" class="pw-post-body-paragraph ld le iu lg b lh li jv lj lk ll jy lm ma lo lp lq mb ls lt lu mc lw lx ly lz in bi translated">我希望读完这篇文章后，你会对什么是单元测试以及为什么你应该这样做有一个更好的了解。我认为你很难找到后悔花时间编写单元测试的人。因此，如果你没有编写单元测试，考虑马上开始。</p></div></div>    
</body>
</html>