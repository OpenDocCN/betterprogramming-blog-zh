<html>
<head>
<title>Convert a PWA Into a Flutter App Using WebViews</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用WebViews将PWA转换为Flutter应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/convert-a-pwa-into-a-flutter-app-using-webviews-387060548a37?source=collection_archive---------2-----------------------#2022-12-06">https://betterprogramming.pub/convert-a-pwa-into-a-flutter-app-using-webviews-387060548a37?source=collection_archive---------2-----------------------#2022-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0c3e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何使用Flutter的InAppWebView 6插件将PWA转换为Flutter应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a2f6e94b23b647cbc9d059dbbf393ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R2yKmdvL8E2l8u2i"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@olafval?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奥拉夫瓦尔</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3ee5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将使用最新版本6的<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/pichillilorenzo/flutter_inappwebview" rel="noopener ugc nofollow" target="_blank">flutter_inappwebview</a></code>插件，将一个<a class="ae kv" href="https://web.dev/progressive-web-apps/" rel="noopener ugc nofollow" target="_blank"> PWA (Progressive Web App) </a>转换为一个适用于Android和iOS的Flutter移动应用。</p><h1 id="86c3" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">什么是渐进式网络应用？</h1><p id="7772" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">渐进式web应用程序是一个术语，指的是像常规网页一样开发和加载的Web应用程序，但当在移动设备上使用时，其行为类似于本机应用程序。</p><p id="2536" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们是用现代API构建和增强的，以提供增强的功能、可靠性和可安装性，同时用单个代码库在任何地方、任何设备上访问任何人。渐进式web应用程序利用新Web的这种活力以及服务工作者和manifest等技术来提供类似本机应用程序的用户体验，即使用户离线也能工作。</p><p id="c6fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开发人员可以在线发布web应用程序，确保它满足基线安装要求，并且用户可以将应用程序添加到他们的主屏幕上。将应用程序发布到苹果应用商店或Google Play等数字分发系统是可选的。</p><h1 id="426b" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">什么是混合应用？</h1><p id="1d63" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">混合应用程序是结合了本地应用程序和web应用程序功能的应用程序。它们在一个容器中运行，在这里是一个<code class="fe ls lt lu lv b">WebView</code>。</p><p id="3812" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们可以通过应用商店获得，可以访问本机API和手机的硬件组件，并安装在您的设备上，就像本机应用程序一样。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="3b94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不会解释pwa、本机应用程序和混合应用程序之间的优缺点，因为这超出了本文的范围。你已经可以在网上搜索了。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="296a" class="lw lx iq bd ly lz na mb mc md nb mf mg jw nc jx mi jz nd ka mk kc ne kd mm mn bi translated">如何将PWA转换为Flutter App</h1><p id="315d" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">作为一个pwa的例子，我们将使用<a class="ae kv" href="https://mdn.github.io/pwa-examples/js13kpwa/" rel="noopener ugc nofollow" target="_blank">https://mdn.github.io/pwa-examples/js13kpwa/</a>(GitHub repo:<a class="ae kv" href="https://github.com/mdn/pwa-examples/blob/master/js13kpwa" rel="noopener ugc nofollow" target="_blank">js13k PWA</a>)，这是一个全功能的PWA，支持离线。</p><p id="4c48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/mdn/pwa-examples/blob/master/js13kpwa" rel="noopener ugc nofollow" target="_blank"> js13kpwa </a>是提交给js13kGames 2017竞赛的A帧参赛作品列表，用作关于渐进式Web应用的MDN文章的示例。js13kPWA具有应用程序外壳结构，与服务人员离线工作，由于清单文件和添加到主屏幕功能而可安装，并可通过使用通知和推送来重新参与。</p><p id="6a54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，对于这个用例，我们将在JavaScript和Flutter/Dart之间添加一个简单的双向通信。</p><h2 id="bc25" class="nf lx iq bd ly ng nh dn mc ni nj dp mg lf nk nl mi lj nm nn mk ln no np mm nq bi translated">服务人员</h2><p id="c02c" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">服务人员是PWA的基本组成部分。它们支持快速加载(不考虑网络)、离线访问、推送通知和其他功能。</p><p id="2b94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查<a class="ae kv" href="https://caniuse.com/serviceworkers" rel="noopener ugc nofollow" target="_blank">https://caniuse.com/serviceworkers</a>基于WebView/浏览器版本的JavaScript Service Worker API可用性。</p><p id="4294" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从“Android 5–6 . x WebView:Chromium 107”开始在Android上提供服务人员，从iOS 14.0+开始在iOS上提供服务人员。</p><p id="f347" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在iOS上，启用服务工作者API需要使用应用程序绑定的域进行额外设置(阅读<a class="ae kv" href="https://webkit.org/blog/10882/app-bound-domains/" rel="noopener ugc nofollow" target="_blank"> WebKit —应用程序绑定的域</a>文章了解更多详细信息)。</p><p id="5cd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用程序绑定的域功能通过限制应用程序可以利用强大的API在应用程序内浏览期间跟踪用户的域来保护用户隐私。</p><p id="ef96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用<code class="fe ls lt lu lv b">Info.plist</code>键<code class="fe ls lt lu lv b">WKAppBoundDomains</code>指定多达十个“应用绑定”域。</p><p id="6a89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们需要将PWA的域添加到其中。否则，服务工作器API将无法工作。对于我们的用例，我们需要添加<code class="fe ls lt lu lv b">mdn.github.io</code>域。下面是一个<code class="fe ls lt lu lv b">ios/Runner/Info.plist</code>文件的例子:</p><pre class="kg kh ki kj gt nr lv ns bn nt nu bi"><span id="e810" class="nv lx iq lv b be nw nx l ny nz">&lt;dict&gt;<br/>  &lt;!-- ... --&gt;<br/>  &lt;key&gt;WKAppBoundDomains&lt;/key&gt;<br/>  &lt;array&gt;<br/>    &lt;string&gt;mdn.github.io&lt;/string&gt;<br/>  &lt;/array&gt;<br/>  &lt;!-- ... --&gt;<br/>&lt;/dict&gt;</span></pre><h2 id="c61a" class="nf lx iq bd ly ng nh dn mc ni nj dp mg lf nk nl mi lj nm nn mk ln no np mm nq bi translated">互联网网络检测</h2><p id="5f20" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">检测用户的手机是否连接到互联网对于<code class="fe ls lt lu lv b">WebView</code>从缓存中加载PWA而不是在线请求资源是很重要的。</p><p id="32f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了检查是否有有效的连接，即蜂窝网络或Wi-Fi，我们将使用<code class="fe ls lt lu lv b"><a class="ae kv" href="https://pub.dev/packages/connectivity_plus" rel="noopener ugc nofollow" target="_blank">connectivity_plus</a></code>插件。相反，为了测试网络是否连接到互联网，我们可以尝试查找主机的地址，例如<a class="ae kv" href="https://example.com/" rel="noopener ugc nofollow" target="_blank">https://example.com/</a>。</p><p id="4152" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是完整的代码检测:</p><pre class="kg kh ki kj gt nr lv ns bn nt nu bi"><span id="2670" class="nv lx iq lv b be nw nx l ny nz">Future&lt;bool&gt; isNetworkAvailable() async {<br/>  // check if there is a valid network connection<br/>  final connectivityResult = await Connectivity().checkConnectivity();<br/>  if (connectivityResult != ConnectivityResult.mobile &amp;&amp;<br/>      connectivityResult != ConnectivityResult.wifi) {<br/>    return false;<br/>  }<br/><br/>  // check if the network is really connected to Internet<br/>  try {<br/>    final result = await InternetAddress.lookup('example.com');<br/>    if (result.isEmpty || result[0].rawAddress.isEmpty) {<br/>      return false;<br/>    }<br/>  } on SocketException catch (_) {<br/>    return false;<br/>  }<br/><br/>  return true;<br/>}</span></pre><h2 id="fae1" class="nf lx iq bd ly ng nh dn mc ni nj dp mg lf nk nl mi lj nm nn mk ln no np mm nq bi translated">InAppWebView基本设置</h2><p id="4b82" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">为了使<code class="fe ls lt lu lv b">InAppWebView</code>正常工作，我们需要设置一些基本设置:</p><pre class="kg kh ki kj gt nr lv ns bn nt nu bi"><span id="3011" class="nv lx iq lv b be nw nx l ny nz">InAppWebViewSettings(<br/>    // enable opening windows support<br/>    supportMultipleWindows: true,<br/>    javaScriptCanOpenWindowsAutomatically: true,<br/><br/>    // useful for identifying traffic, e.g. in Google Analytics.<br/>    applicationNameForUserAgent: 'My PWA App Name',<br/>    // Override the User Agent, otherwise some external APIs, such as Google and Facebook logins, will not work<br/>    // because they recognize the default WebView User Agent.<br/>    userAgent:<br/>        'Mozilla/5.0 (Linux; Android 13) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.5304.105 Mobile Safari/537.36',<br/><br/>    disableDefaultErrorPage: true,<br/><br/>    // enable iOS service worker feature limited to defined App Bound Domains<br/>    limitsNavigationsToAppBoundDomains: true<br/>);</span></pre><p id="f47f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据你的需要改变它。</p><p id="4576" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，我们启用了对多个窗口的支持，以防我们想要打开弹出<code class="fe ls lt lu lv b">WebView</code>窗口。</p><p id="0afb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在某些情况下，您可能还需要将用户代理覆盖为不同于默认值的值，以便能够使用一些外部API，例如Google和脸书登录。否则，它们将无法工作，因为它们识别并阻止默认的<code class="fe ls lt lu lv b">WebView</code>用户代理。</p><p id="95bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，您必须将<code class="fe ls lt lu lv b">limitsNavigationsToAppBoundDomains</code>设置设置为<code class="fe ls lt lu lv b">true</code>在iOS上启用服务工作者API。</p><h2 id="1521" class="nf lx iq bd ly ng nh dn mc ni nj dp mg lf nk nl mi lj nm nn mk ln no np mm nq bi translated">HTTP(非HTTPS)支持</h2><p id="9d64" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">从Android 9 (API级别28)开始，默认情况下禁用明文支持:</p><ul class=""><li id="cb22" class="oa ob iq ky b kz la lc ld lf oc lj od ln oe lr of og oh oi bi translated">查看官方<a class="ae kv" href="https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted" rel="noopener ugc nofollow" target="_blank">网络安全配置—“选择退出明文流量”</a>部分。</li><li id="7384" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated">另外，请检查此StackOverflow问题答案:<a class="ae kv" href="https://stackoverflow.com/a/50834600/4637638" rel="noopener ugc nofollow" target="_blank">明文HTTP流量是不允许的</a>。</li></ul><p id="894d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在iOS上，你需要禁用<a class="ae kv" href="https://developer.apple.com/documentation/security/preventing_insecure_network_connections" rel="noopener ugc nofollow" target="_blank">苹果运输安全</a> (ATS)功能。有两种选择:</p><ul class=""><li id="54d1" class="oa ob iq ky b kz la lc ld lf oc lj od ln oe lr of og oh oi bi translated">仅禁用特定域的ATS(<a class="ae kv" href="https://developer.apple.com/documentation/bundleresources/information_property_list/nsapptransportsecurity/nsexceptiondomains" rel="noopener ugc nofollow" target="_blank">官方维基</a>):(将以下代码添加到您的<code class="fe ls lt lu lv b">Info.plist</code>文件中)</li></ul><pre class="kg kh ki kj gt nr lv ns bn nt nu bi"><span id="c820" class="nv lx iq lv b be nw nx l ny nz">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;<br/>&lt;dict&gt;<br/>  &lt;key&gt;NSExceptionDomains&lt;/key&gt;<br/>  &lt;dict&gt;<br/>    &lt;key&gt;www.yourserver.com&lt;/key&gt;<br/>    &lt;dict&gt;<br/>      &lt;!-- add this key to enable subdomains such as sub.yourserver.com --&gt;<br/>      &lt;key&gt;NSIncludesSubdomains&lt;/key&gt;<br/>      &lt;true/&gt;<br/>      &lt;!-- add this key to allow standard HTTP requests, thus negating the ATS --&gt;<br/>      &lt;key&gt;NSTemporaryExceptionAllowsInsecureHTTPLoads&lt;/key&gt;<br/>      &lt;true/&gt;<br/>      &lt;!-- add this key to specify the minimum TLS version to accept --&gt;<br/>      &lt;key&gt;NSTemporaryExceptionMinimumTLSVersion&lt;/key&gt;<br/>      &lt;string&gt;TLSv1.1&lt;/string&gt;<br/>    &lt;/dict&gt;<br/>  &lt;/dict&gt;<br/>&lt;/dict&gt;</span></pre><ul class=""><li id="b8cc" class="oa ob iq ky b kz la lc ld lf oc lj od ln oe lr of og oh oi bi translated">彻底禁用ATS ( <a class="ae kv" href="https://developer.apple.com/documentation/bundleresources/information_property_list/nsapptransportsecurity/nsallowsarbitraryloads" rel="noopener ugc nofollow" target="_blank">官方维基</a>)。将以下代码添加到您的<code class="fe ls lt lu lv b">Info.plist</code>文件中:</li></ul><pre class="kg kh ki kj gt nr lv ns bn nt nu bi"><span id="841e" class="nv lx iq lv b be nw nx l ny nz">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;<br/>&lt;dict&gt;<br/>  &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;&lt;true/&gt;<br/>&lt;/dict&gt;</span></pre><p id="a881" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其他有用的<code class="fe ls lt lu lv b">Info.plist</code>属性有:</p><ul class=""><li id="64c4" class="oa ob iq ky b kz la lc ld lf oc lj od ln oe lr of og oh oi bi translated"><code class="fe ls lt lu lv b">NSAllowsLocalNetworking</code>:布尔值，表示是否允许加载本地资源(<a class="ae kv" href="https://developer.apple.com/documentation/bundleresources/information_property_list/nsapptransportsecurity/nsallowslocalnetworking" rel="noopener ugc nofollow" target="_blank">官方wiki </a>)</li><li id="985f" class="oa ob iq ky b kz oj lc ok lf ol lj om ln on lr of og oh oi bi translated"><code class="fe ls lt lu lv b">NSAllowsArbitraryLoadsInWebContent</code>:一个布尔值，指示是否对来自web视图的请求禁用所有应用传输安全限制(<a class="ae kv" href="https://developer.apple.com/documentation/bundleresources/information_property_list/nsapptransportsecurity/nsallowsarbitraryloadsinwebcontent" rel="noopener ugc nofollow" target="_blank">官方维基</a>)</li></ul><h1 id="4fa2" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">WidgetsBindingObserver</h1><p id="9c70" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">此外，我们将为Android使用<code class="fe ls lt lu lv b">WidgetsBindingObserver</code>,这有助于了解系统何时将应用程序置于后台或将应用程序返回前台。</p><p id="7061" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了它，我们可以停止和恢复JavaScript执行以及任何可以安全暂停的处理，比如视频、音频和动画。</p><p id="9e60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是<code class="fe ls lt lu lv b">didChangeAppLifecycleState</code>的一个简单实现:</p><pre class="kg kh ki kj gt nr lv ns bn nt nu bi"><span id="7af7" class="nv lx iq lv b be nw nx l ny nz">@override<br/>void didChangeAppLifecycleState(AppLifecycleState state) {<br/>  if (!kIsWeb) {<br/>    if (webViewController != null &amp;&amp;<br/>        defaultTargetPlatform == TargetPlatform.android) {<br/>      if (state == AppLifecycleState.paused) {<br/>        pauseAll();<br/>      } else {<br/>        resumeAll();<br/>      }<br/>    }<br/>  }<br/>}<br/><br/>void pauseAll() {<br/>  if (defaultTargetPlatform == TargetPlatform.android) {<br/>    webViewController?.pause();<br/>  }<br/>  webViewController?.pauseTimers();<br/>}<br/><br/>void resumeAll() {<br/>  if (defaultTargetPlatform == TargetPlatform.android) {<br/>    webViewController?.resume();<br/>  }<br/>  webViewController?.resumeTimers();<br/>}</span></pre><h1 id="3fea" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">WillPopScope</h1><p id="6a65" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">为了检测Android后退按钮的点击，我们将主要的<code class="fe ls lt lu lv b">Scaffold</code>窗口小部件应用程序包装到一个<code class="fe ls lt lu lv b">WillPopScope</code>窗口小部件中，并实现<code class="fe ls lt lu lv b">onWillPop</code>方法以返回到<code class="fe ls lt lu lv b">WebView</code>的历史中。</p><p id="bfd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个实现示例:</p><pre class="kg kh ki kj gt nr lv ns bn nt nu bi"><span id="d431" class="nv lx iq lv b be nw nx l ny nz">@override<br/>Widget build(BuildContext context) {<br/>  return WillPopScope(<br/>    onWillPop: () async {<br/>      // detect Android back button click<br/>      final controller = webViewController;<br/>      if (controller != null) {<br/>        if (await controller.canGoBack()) {<br/>          controller.goBack();<br/>          return false;<br/>        }<br/>      }<br/>      return true;<br/>    },<br/>    child: Scaffold(<br/>        appBar: AppBar(<br/>          // remove the toolbar<br/>          toolbarHeight: 0,<br/>        ),<br/>        body: // ...<br/>    ),<br/>  );<br/>}</span></pre><h1 id="cad3" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">WebView PWA包装</h1><p id="a509" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在将PWA URL加载到<code class="fe ls lt lu lv b">InAppWebView</code>包装器之前，我们使用之前定义的实用程序检查互联网连接是否可用，并且，基于此，我们需要为Android和iOS设置缓存模式和策略，如下所示:</p><pre class="kg kh ki kj gt nr lv ns bn nt nu bi"><span id="8efe" class="nv lx iq lv b be nw nx l ny nz">// Android-only<br/>final cacheMode = networkAvailable<br/>    ? CacheMode.LOAD_DEFAULT<br/>    : CacheMode.LOAD_CACHE_ELSE_NETWORK;<br/><br/>// iOS-only<br/>final cachePolicy = networkAvailable<br/>    ? URLRequestCachePolicy.USE_PROTOCOL_CACHE_POLICY<br/>    : URLRequestCachePolicy.RETURN_CACHE_DATA_ELSE_LOAD;</span></pre><p id="fa0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">cacheMode</code>将在<code class="fe ls lt lu lv b">initialSettings</code>属性中使用，<code class="fe ls lt lu lv b">cachePolicy</code>将在<code class="fe ls lt lu lv b">initialUrlRequest</code>属性的<code class="fe ls lt lu lv b">URLRequest</code>中使用。</p><p id="bc17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果互联网连接不可用，这个逻辑允许我们加载缓存的数据。</p><p id="4a85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了将导航仅限于PWA主机，我们实现了<code class="fe ls lt lu lv b">shouldOverrideUrlLoading</code>方法来检查主框架的特定HTTP请求是否与PWA主机不匹配，因此我们将使用<code class="fe ls lt lu lv b"><a class="ae kv" href="https://pub.dev/packages/url_launcher" rel="noopener ugc nofollow" target="_blank">url_launcher</a></code>插件在第三方应用程序中打开该请求:</p><pre class="kg kh ki kj gt nr lv ns bn nt nu bi"><span id="bda5" class="nv lx iq lv b be nw nx l ny nz">shouldOverrideUrlLoading:<br/>    (controller, navigationAction) async {<br/>  // restrict navigation to target host, open external links in 3rd party apps<br/>  final uri = navigationAction.request.url;<br/>  if (uri != null &amp;&amp;<br/>      navigationAction.isForMainFrame &amp;&amp;<br/>      uri.host != kPwaHost &amp;&amp;<br/>      await canLaunchUrl(uri)) {<br/>    launchUrl(uri);<br/>    return NavigationActionPolicy.CANCEL;<br/>  }<br/>  return NavigationActionPolicy.ALLOW;<br/>},</span></pre><p id="f4f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了检测PWA第一次安装是否正确，我们实施了<code class="fe ls lt lu lv b">onLoadStop</code> <code class="fe ls lt lu lv b">WebView</code>方法来检查互联网连接的可用性以及PWA是否已经安装:</p><pre class="kg kh ki kj gt nr lv ns bn nt nu bi"><span id="1962" class="nv lx iq lv b be nw nx l ny nz">onLoadStop: (controller, url) async {<br/>  if (await isNetworkAvailable() &amp;&amp; !(await isPWAInstalled())) {<br/>    // if network is available and this is the first time<br/>    setPWAInstalled();<br/>  }<br/>},</span></pre><p id="3a50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b"><a class="ae kv" href="https://pub.dev/packages/shared_preferences" rel="noopener ugc nofollow" target="_blank">shared_preferences</a></code>插件获取并保存PWA安装状态，可以如下实现两个实用程序<code class="fe ls lt lu lv b">isPWAInstalled</code>和<code class="fe ls lt lu lv b">setPWAInstalled</code>:</p><pre class="kg kh ki kj gt nr lv ns bn nt nu bi"><span id="ab20" class="nv lx iq lv b be nw nx l ny nz">Future&lt;bool&gt; isPWAInstalled() async {<br/>  final prefs = await SharedPreferences.getInstance();<br/>  return prefs.getBool('isInstalled') ?? false;<br/>}<br/><br/>void setPWAInstalled({bool installed = true}) async {<br/>  final prefs = await SharedPreferences.getInstance();<br/>  await prefs.setBool('isInstalled', installed);<br/>}</span></pre><p id="fa35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些实用程序都允许我们检测PWA的网络可用性和安装状态，以便我们可以实现自定义错误页面，如下所示:</p><pre class="kg kh ki kj gt nr lv ns bn nt nu bi"><span id="0a76" class="nv lx iq lv b be nw nx l ny nz">onReceivedError: (controller, request, error) async {<br/>  final isForMainFrame = request.isForMainFrame ?? true;<br/>  if (isForMainFrame &amp;&amp; !(await isNetworkAvailable())) {<br/>    if (!(await isPWAInstalled())) {<br/>      await controller.loadData(<br/>          data: kHTMLErrorPageNotInstalled);<br/>    }<br/>  }<br/>},</span></pre><p id="f34a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中<code class="fe ls lt lu lv b">kHTMLErrorPageNotInstalled</code>是包含自定义HTML的字符串。</p><p id="f620" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果需要支持<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API" rel="noopener ugc nofollow" target="_blank"> Web通知JavaScript API </a>，很遗憾，Android原生的WebView和iOS原生的WKWebView都不支持那个特性，必须自己实现！对于示例实现，您可以查看<a class="ae kv" href="https://github.com/pichillilorenzo/flutter_inappwebview_examples/tree/main/web_notification" rel="noopener ugc nofollow" target="_blank"> Web通知项目示例</a>。它使用一个<code class="fe ls lt lu lv b"><a class="ae kv" href="https://inappwebview.dev/docs/webview/javascript/user-scripts" rel="noopener ugc nofollow" target="_blank">UserScript</a></code>在网页启动时注入定制的JavaScript代码来实现web通知API。</p><p id="f42f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注入的JavaScript代码试图为<code class="fe ls lt lu lv b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Notification" rel="noopener ugc nofollow" target="_blank">Notification</a></code>窗口对象创建一个“polyfill ”,并使用<a class="ae kv" href="https://inappwebview.dev/docs/webview/javascript/communication#JavaScript-Handlers" rel="noopener ugc nofollow" target="_blank"> JavaScript处理程序</a>与Flutter/Dart端进行通信，以管理和实现相应的通知UI，例如，当您向<code class="fe ls lt lu lv b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Notification/requestPermission" rel="noopener ugc nofollow" target="_blank">Notification.requestPermission()</a></code>请求权限或想要显示通知时。</p><p id="a9de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，如果你需要支持摄像头和麦克风的使用(例如，一个WebRTC应用程序)，你需要实现<code class="fe ls lt lu lv b">onPermissionRequest</code>事件，并使用<code class="fe ls lt lu lv b"><a class="ae kv" href="https://pub.dev/packages/permission_handler" rel="noopener ugc nofollow" target="_blank">permission_handler</a></code>插件请求许可。更多详情，请访问<a class="ae kv" href="https://inappwebview.dev/docs/web-rtc" rel="noopener ugc nofollow" target="_blank">官方WebRTC指南</a>和<a class="ae kv" href="https://github.com/pichillilorenzo/flutter_inappwebview_examples/tree/main/webrtc" rel="noopener ugc nofollow" target="_blank"> WebRTC项目示例</a>。</p><p id="d2d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要管理使用JavaScript ( <code class="fe ls lt lu lv b">window.open()</code>)或通过链接中的目标属性(如<code class="fe ls lt lu lv b">target="_blank"</code>)打开新窗口的请求，我们必须实现<code class="fe ls lt lu lv b">onCreateWindow</code>事件并返回<code class="fe ls lt lu lv b">true</code>以声明我们正在处理请求。这里有一个简单的例子:</p><pre class="kg kh ki kj gt nr lv ns bn nt nu bi"><span id="bc31" class="nv lx iq lv b be nw nx l ny nz">onCreateWindow: (controller, createWindowAction) async {<br/>  showDialog(<br/>    context: context,<br/>    builder: (context) {<br/>      final popupWebViewSettings =<br/>          sharedSettings.copy();<br/>      popupWebViewSettings.supportMultipleWindows =<br/>          false;<br/>      popupWebViewSettings<br/>              .javaScriptCanOpenWindowsAutomatically =<br/>          false;<br/><br/>      return WebViewPopup(<br/>          createWindowAction: createWindowAction,<br/>          popupWebViewSettings: popupWebViewSettings);<br/>    },<br/>  );<br/>  return true;<br/>},</span></pre><p id="4fab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">WebViewPopup</code>是<code class="fe ls lt lu lv b">AlertDialog</code>小部件中的另一个<code class="fe ls lt lu lv b">InAppWebView</code>实例，它接受<code class="fe ls lt lu lv b">createWindowAction</code>的输入以获得用于新<code class="fe ls lt lu lv b">WebView</code>的<code class="fe ls lt lu lv b">windowId</code>。<code class="fe ls lt lu lv b">windowId</code>是一个在本机端使用的标识符，用来获得Flutter必须显示的正确的<code class="fe ls lt lu lv b">WebView</code>引用。WebView弹出窗口还将实现<code class="fe ls lt lu lv b">onCloseWindow</code>来监听何时应该关闭弹出窗口并将其从窗口小部件树中删除:</p><pre class="kg kh ki kj gt nr lv ns bn nt nu bi"><span id="e0e5" class="nv lx iq lv b be nw nx l ny nz">onCloseWindow: (controller) {<br/>  Navigator.pop(context);<br/>},</span></pre><p id="5e8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查看<a class="ae kv" href="https://github.com/pichillilorenzo/flutter_inappwebview_examples/tree/main/popup_window" rel="noopener ugc nofollow" target="_blank">弹出窗口项目示例</a>中的示例实现。</p><p id="30a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实现JavaScript和Flutter/Dart端之间的双向通信，我们将使用<a class="ae kv" href="https://inappwebview.dev/docs/webview/javascript/communication#JavaScript-Handlers" rel="noopener ugc nofollow" target="_blank"> JavaScript处理程序</a>特性。</p><p id="72d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们的用例，我们希望监听id为<code class="fe ls lt lu lv b">notifications</code>的“请求虚拟通知”按钮HTML元素上的点击，并显示一个由JavaScript生成的随机文本的<code class="fe ls lt lu lv b">SnackBar</code>。</p><p id="c7d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们创建一个简单的<a class="ae kv" href="https://inappwebview.dev/docs/webview/javascript/user-scripts" rel="noopener ugc nofollow" target="_blank">用户脚本</a>，并在页面加载后注入它:</p><pre class="kg kh ki kj gt nr lv ns bn nt nu bi"><span id="630d" class="nv lx iq lv b be nw nx l ny nz">initialUserScripts: UnmodifiableListView&lt;UserScript&gt;([<br/>  UserScript(<br/>      source: """<br/>      document.getElementById('notifications').addEventListener('click', function(event) {<br/>        var randomText = Math.random().toString(36).slice(2, 7);<br/>        window.flutter_inappwebview.callHandler('requestDummyNotification', randomText);<br/>      });<br/>      """,<br/>      injectionTime:<br/>          UserScriptInjectionTime.AT_DOCUMENT_END)<br/>]),</span></pre><p id="1faf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们在创建了<code class="fe ls lt lu lv b">WebView</code>实例之后添加相应的JavaScript处理程序:</p><pre class="kg kh ki kj gt nr lv ns bn nt nu bi"><span id="2ee1" class="nv lx iq lv b be nw nx l ny nz">onWebViewCreated: (controller) {<br/>  webViewController = controller;<br/><br/>  controller.addJavaScriptHandler(<br/>    handlerName: 'requestDummyNotification',<br/>    callback: (arguments) {<br/>      final String randomText =<br/>          arguments.isNotEmpty ? arguments[0] : '';<br/>      ScaffoldMessenger.of(context).showSnackBar(<br/>          SnackBar(content: Text(randomText)));<br/>    },<br/>  );<br/>},</span></pre><p id="ea75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/cd248482ad77f8a1bc8eeb0ff0a4f298.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*2t9L1UObcsrKYRRmKTGngw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Android示例结果。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/9771d646fe1f89ebe9990a5ed25f3846.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*ICiUmH2pjITByEDwMhIPzg.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">iOS示例结果。</p></figure><p id="8bec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的代码项目示例可从<a class="ae kv" href="https://github.com/pichillilorenzo/flutter_inappwebview_examples/tree/main/pwa_to_flutter_app" rel="noopener ugc nofollow" target="_blank">https://github . com/pichillilorenzo/flutter _ inappwebview _ examples/tree/main/pwa _ to _ flutter _ app</a>获得</p><p id="7414" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天就到这里吧！</p><p id="f311" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你在用这个插件吗？通过<a class="ae kv" href="https://inappwebview.dev/submit-app/" rel="noopener ugc nofollow" target="_blank">提交应用</a>页面提交您的应用，并按照说明进行操作。查看<a class="ae kv" href="https://inappwebview.dev/showcase/" rel="noopener ugc nofollow" target="_blank"> Showcase </a>页面，看看谁已经在使用它了！</p><p id="e7dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oq">本项目遵循</em> <a class="ae kv" href="https://github.com/all-contributors/all-contributors" rel="noopener ugc nofollow" target="_blank"> <em class="oq">全供稿</em> </a> <em class="oq">规范(</em> <a class="ae kv" href="https://github.com/pichillilorenzo/flutter_inappwebview#contributors-" rel="noopener ugc nofollow" target="_blank"> <em class="oq">供稿</em> </a> <em class="oq">)。我想感谢所有以任何方式支持这个项目的人。非常感谢你们所有人！</em>💙</p></div></div>    
</body>
</html>