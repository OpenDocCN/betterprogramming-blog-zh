<html>
<head>
<title>How to Test Kafka Streams Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何测试Kafka流应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/testing-kafka-streams-applications-1c5cb14c5376?source=collection_archive---------2-----------------------#2020-03-16">https://betterprogramming.pub/testing-kafka-streams-applications-1c5cb14c5376?source=collection_archive---------2-----------------------#2020-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="08b5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过测试验证拓扑</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/04a3e550b0733a1c8798c1c1b67c5766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HUGw0slo0jFjWo20GQOoUw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@korpa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> JR Korpa </a>在<a class="ae kv" href="https://unsplash.com/collections/1136512/%E2%98%85-%E2%80%94-textures-%2F-colors?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0885" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“Kafka Streams”系列的前几篇博文介绍了DSL API中的<code class="fe ls lt lu lv b"><a class="ae kv" href="https://medium.com/better-programming/learn-stream-processing-with-kafka-streams-stateless-operations-2111080e6c53" rel="noopener">Stateless</a></code>和<code class="fe ls lt lu lv b"><a class="ae kv" href="https://medium.com/@abhishek1987/how-to-use-stateful-operations-in-kafka-streams-1cff4da41329" rel="noopener">Stateful</a></code>操作。在这篇博客中，我们将探索几个例子来演示如何使用测试工具来验证基于Kafka Streams DSL API的拓扑。</p><p id="2d29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kafka Streams提供测试实用程序来为您的流处理管道执行单元测试，而无需依赖外部或嵌入式Kafka集群。除了测试之外，这些实用程序也是研究各种API特性的很好的学习工具。</p><p id="c283" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从测试相关API的高级概述开始</p><p id="0f37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lw">代码是</em> <a class="ae kv" href="https://github.com/abhirockzz/kafka-streams-apis/tree/master/testing" rel="noopener ugc nofollow" target="_blank"> <em class="lw">可在GitHub </em> </a> <em class="lw">上获得，测试可以通过克隆回购后跟</em> <code class="fe ls lt lu lv b"><em class="lw">mvn test</em></code> <em class="lw">来执行。</em></p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="7f78" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">关键概念</h1><p id="077c" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">最初，<code class="fe ls lt lu lv b"><a class="ae kv" href="https://kafka.apache.org/24/javadoc/org/apache/kafka/streams/test/package-frame.html" rel="noopener ugc nofollow" target="_blank">org.apache.kafka.streams.test</a></code>包中有几个类。它们现在已被弃用，取而代之的是以下类:</p><h2 id="b891" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lf ng nh mq lj ni nj ms ln nk nl mu nm bi translated"><code class="fe ls lt lu lv b">TestInputTopic</code></h2><p id="8efa" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated"><code class="fe ls lt lu lv b">TestInputTopic</code>的一个实例表示一个输入主题，您可以使用<code class="fe ls lt lu lv b">pipeInput</code>方法(及其重载版本)向它发送记录。使用<code class="fe ls lt lu lv b">TopologyTestDriver</code>创建<code class="fe ls lt lu lv b">TestInputTopic</code>实例(如下所述),并在需要时使用定制的序列化器。然后，您可以发送键值对，一次只发送一个值，或者批量发送(使用<code class="fe ls lt lu lv b">List</code>)。</p><h2 id="34c3" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lf ng nh mq lj ni nj ms ln nk nl mu nm bi translated"><code class="fe ls lt lu lv b">TestOutputTopic</code></h2><p id="419b" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated"><code class="fe ls lt lu lv b">TestOutputTopic</code>是发送-接收等式的另一半，与a <code class="fe ls lt lu lv b">TestInputTopic</code>互补。您可以使用它从拓扑操作写入的输出主题中读取记录。它的方法包括读取记录(键-值对)、只读取值、查询大小(尚未使用的当前记录的数量)等。</p><h2 id="f603" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lf ng nh mq lj ni nj ms ln nk nl mu nm bi translated"><code class="fe ls lt lu lv b">TopologyTestDriver</code></h2><p id="edf5" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated"><code class="fe ls lt lu lv b">TopologyTestDriver</code>包含对<code class="fe ls lt lu lv b">Topology</code>的引用以及与您的Kafka Streams应用程序相关的配置。如前所述，它用于创建<code class="fe ls lt lu lv b">TestInputTopic</code>、<code class="fe ls lt lu lv b">TestOutputTopic</code>的实例，提供对状态存储的访问等。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="2851" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">高层流动</h1><p id="151a" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">如果您使用的是<code class="fe ls lt lu lv b">Maven</code>，您可以将测试工具作为一个依赖项包含进来。</p><pre class="kg kh ki kj gt nn lv no np aw nq bi"><span id="0d68" class="nb mf iq lv b gy nr ns l nt nu">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;<br/>  &lt;artifactId&gt;kafka-streams-test-utils&lt;/artifactId&gt;<br/>  &lt;version&gt;2.4.0&lt;/version&gt;<br/>  &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</span></pre><p id="5def" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将(很可能)使用<code class="fe ls lt lu lv b">JUnit</code>和<code class="fe ls lt lu lv b">hamcrest</code>来编写匹配规则。</p><pre class="kg kh ki kj gt nn lv no np aw nq bi"><span id="d11e" class="nb mf iq lv b gy nr ns l nt nu">&lt;dependency&gt;<br/>  &lt;groupId&gt;junit&lt;/groupId&gt;<br/>  &lt;artifactId&gt;junit&lt;/artifactId&gt;<br/>  &lt;version&gt;4.12&lt;/version&gt;<br/>  &lt;scope&gt;test&lt;/scope&gt;<br/> &lt;/dependency&gt;<br/> &lt;dependency&gt;<br/>  &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;<br/>  &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;<br/>  &lt;version&gt;1.3&lt;/version&gt;<br/>  &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</span></pre><p id="8445" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个测试用例可能的样子(类似于你如何用<code class="fe ls lt lu lv b">JUnit</code>等对任何Java代码进行单元测试)。):</p><ul class=""><li id="24b6" class="nv nw iq ky b kz la lc ld lf nx lj ny ln nz lr oa ob oc od bi translated">使用<code class="fe ls lt lu lv b">@BeforeClass</code>注释方法设置全局状态(如果有)。</li><li id="53f9" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated">使用<code class="fe ls lt lu lv b">@Before</code>带注释的方法为每个测试运行设置状态——这是您通常创建<code class="fe ls lt lu lv b">TopologyTestDriver</code>等的地方。</li><li id="d4fb" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated"><code class="fe ls lt lu lv b">@Test</code>验证<code class="fe ls lt lu lv b">Topology</code>的方法。</li><li id="4ab3" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated"><code class="fe ls lt lu lv b">@After</code>(和/或<code class="fe ls lt lu lv b">@AfterClass</code>)拆除任何状态(无论是全局状态还是其他状态)的方法。</li></ul><p id="6dd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请确保调用<code class="fe ls lt lu lv b">TopologyTestDriver.close()</code>来清理拓扑中的处理器及其相关状态。否则，由于状态不一致，可能会导致测试失败</p><p id="b02d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在您已经了解了概念和基本设置，让我们看几个具体的例子。我们将从无状态操作开始。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="b595" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">测试无状态操作</h1><h2 id="70c8" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lf ng nh mq lj ni nj ms ln nk nl mu nm bi translated"><code class="fe ls lt lu lv b">Filter</code></h2><p id="a3b4" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">这里是<code class="fe ls lt lu lv b">Topology</code>,它使用过滤方法只允许长度大于5的值。</p><pre class="kg kh ki kj gt nn lv no np aw nq bi"><span id="e2eb" class="nb mf iq lv b gy nr ns l nt nu">StreamsBuilder builder = new StreamsBuilder();<br/>KStream&lt;String, String&gt; stream = builder.stream(INPUT_TOPIC);<br/>        <br/>stream.filter((k, v) -&gt; v.length() &gt; 5).to(OUTPUT_TOPIC);</span></pre><p id="69d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是相应的测试:</p><pre class="kg kh ki kj gt nn lv no np aw nq bi"><span id="8f6d" class="nb mf iq lv b gy nr ns l nt nu">    @Test<br/>    public void shouldIncludeValueWithLengthGreaterThanFive() {</span><span id="8c0c" class="nb mf iq lv b gy oj ns l nt nu">        topology = App.retainWordsLongerThan5Letters();<br/>        td = new TopologyTestDriver(topology, config);</span><span id="769c" class="nb mf iq lv b gy oj ns l nt nu">        inputTopic = td.createInputTopic(App.INPUT_TOPIC, Serdes.String().serializer(), Serdes.String().serializer());<br/>        outputTopic = td.createOutputTopic(App.OUTPUT_TOPIC, Serdes.String().deserializer(), Serdes.String().deserializer());</span><span id="0a86" class="nb mf iq lv b gy oj ns l nt nu">        assertThat(outputTopic.isEmpty(), is(true));</span><span id="4797" class="nb mf iq lv b gy oj ns l nt nu">        inputTopic.pipeInput("key1", "barrrrr");<br/>        assertThat(outputTopic.readValue(), equalTo("barrrrr"));<br/>        assertThat(outputTopic.isEmpty(), is(true));</span><span id="775e" class="nb mf iq lv b gy oj ns l nt nu">        inputTopic.pipeInput("key2", "bar");<br/>        assertThat(outputTopic.isEmpty(), is(true));<br/>    }</span></pre><p id="0382" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先选择我们想要测试的<code class="fe ls lt lu lv b">Topology</code>，创建<code class="fe ls lt lu lv b">TopologyTestDriver</code>实例以及<code class="fe ls lt lu lv b">TestInputTopic</code>和<code class="fe ls lt lu lv b">TestOutputTopic</code>对象。</p><p id="cb6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们在发送任何数据之前确认输出主题是否为空— <code class="fe ls lt lu lv b">assertThat(outputTopic.isEmpty(), is(true));</code></p><p id="0807" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在可以使用<code class="fe ls lt lu lv b">inputTopic.pipeInput("key1", "barrrrr");</code>将数据/记录发送到输入主题。这是一个同步过程，触发<code class="fe ls lt lu lv b">Topology</code>，在这种情况下，T1执行<code class="fe ls lt lu lv b">filter</code>操作，并将其推送到输出主题，因为值长度超过5。我们使用<code class="fe ls lt lu lv b">assertThat(outputTopic.readValue(), equalTo("barrrrr"));</code>进行确认，并再次检查输出主题是否为空。</p><p id="7f6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们发送值<code class="fe ls lt lu lv b">bar</code>，并确认它没有被发送到输出主题，因为它的长度小于5。</p><h2 id="66be" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lf ng nh mq lj ni nj ms ln nk nl mu nm bi translated">平面地图</h2><p id="f91e" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">正如本系列的第一部分(无状态操作)所解释的，这里有一个<code class="fe ls lt lu lv b">flatMap</code>操作:</p><pre class="kg kh ki kj gt nn lv no np aw nq bi"><span id="6ed3" class="nb mf iq lv b gy nr ns l nt nu">StreamsBuilder builder = new StreamsBuilder();<br/>KStream&lt;String, String&gt; stream = builder.stream(INPUT_TOPIC);</span><span id="1566" class="nb mf iq lv b gy oj ns l nt nu">stream.flatMap(new KeyValueMapper&lt;String, String, Iterable&lt;? extends KeyValue&lt;? extends String, ? extends String&gt;&gt;&gt;() {<br/>            @Override<br/>            public Iterable&lt;? extends KeyValue&lt;? extends String, ? extends String&gt;&gt; apply(String k, String csv) {<br/>                String[] values = csv.split(",");<br/>                return Arrays.asList(values)<br/>                        .stream()<br/>                        .map(value -&gt; new KeyValue&lt;&gt;(k, value))<br/>                        .collect(Collectors.toList());<br/>            }<br/>        }).to(OUTPUT_TOPIC);</span></pre><p id="44c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，流中的每个记录都得到<code class="fe ls lt lu lv b">flatMap</code> ped，这样每个CSV(逗号分隔)值首先被拆分成它的组成部分，并且为CSV字符串的每个部分创建一个<code class="fe ls lt lu lv b">KeyValue</code>对。</p><p id="98c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要测试这一点:</p><pre class="kg kh ki kj gt nn lv no np aw nq bi"><span id="5f4a" class="nb mf iq lv b gy nr ns l nt nu">topology = App.flatMap();<br/>        td = new TopologyTestDriver(topology, config);</span><span id="7f51" class="nb mf iq lv b gy oj ns l nt nu">        inputTopic = td.createInputTopic(App.INPUT_TOPIC, Serdes.String().serializer(), Serdes.String().serializer());<br/>        outputTopic = td.createOutputTopic(App.OUTPUT_TOPIC, Serdes.String().deserializer(), Serdes.String().deserializer());</span><span id="6ae4" class="nb mf iq lv b gy oj ns l nt nu">        inputTopic.pipeInput("random", "foo,bar,baz");<br/>        inputTopic.pipeInput("hello", "world,universe");<br/>        inputTopic.pipeInput("hi", "there");</span><span id="5007" class="nb mf iq lv b gy oj ns l nt nu">        assertThat(outputTopic.getQueueSize(), equalTo(6L));</span><span id="6677" class="nb mf iq lv b gy oj ns l nt nu">        assertThat(outputTopic.readKeyValue(), equalTo(new KeyValue&lt;&gt;("random", "foo")));<br/>        assertThat(outputTopic.readKeyValue(), equalTo(new KeyValue&lt;&gt;("random", "bar")));<br/>        assertThat(outputTopic.readKeyValue(), equalTo(new KeyValue&lt;&gt;("random", "baz")));</span><span id="aa95" class="nb mf iq lv b gy oj ns l nt nu">        assertThat(outputTopic.readKeyValue(), equalTo(new KeyValue&lt;&gt;("hello", "world")));<br/>        assertThat(outputTopic.readKeyValue(), equalTo(new KeyValue&lt;&gt;("hello", "universe")));</span><span id="9bcc" class="nb mf iq lv b gy oj ns l nt nu">        assertThat(outputTopic.readKeyValue(), equalTo(new KeyValue&lt;&gt;("hi", "there")));</span><span id="cf64" class="nb mf iq lv b gy oj ns l nt nu">assertThat(outputTopic.isEmpty(), is(true));</span></pre><p id="90c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像往常一样，我们设置所需的测试工具类，并将输入记录推送到输入主题。例如，键<code class="fe ls lt lu lv b">random</code>及其逗号分隔值<code class="fe ls lt lu lv b">foo,bar,baz</code>将被拆分成单独的键值对，即它们将导致三个记录被推送到输出表。这同样适用于其他输入记录。</p><p id="1d13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们确认输出主题<code class="fe ls lt lu lv b">assertThat(outputTopic.getQueueSize(), equalTo(6L));</code>中的记录数量，并验证每个键值对以确认<code class="fe ls lt lu lv b">flatMap</code>行为。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="a11e" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">有状态操作呢？</h1><h2 id="be48" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lf ng nh mq lj ni nj ms ln nk nl mu nm bi translated">没有状态存储的有状态操作</h2><p id="c061" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">下面是一个拓扑示例，它使用<code class="fe ls lt lu lv b">groupByKey</code>后跟<code class="fe ls lt lu lv b">count</code>，并将结果存储在输出主题中:</p><pre class="kg kh ki kj gt nn lv no np aw nq bi"><span id="400e" class="nb mf iq lv b gy nr ns l nt nu">StreamsBuilder builder = new StreamsBuilder();<br/>KStream&lt;String, String&gt; stream = builder.stream(INPUT_TOPIC);</span><span id="1ccc" class="nb mf iq lv b gy oj ns l nt nu">stream.groupByKey()<br/>      .count()<br/>      .toStream()<br/>      .to(OUTPUT_TOPIC);</span></pre><p id="59d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试有状态操作和无状态操作没有太大的不同。</p><pre class="kg kh ki kj gt nn lv no np aw nq bi"><span id="ff93" class="nb mf iq lv b gy nr ns l nt nu">topology = App.count();<br/>        td = new TopologyTestDriver(topology, config);</span><span id="8077" class="nb mf iq lv b gy oj ns l nt nu">        inputTopic = td.createInputTopic(App.INPUT_TOPIC, Serdes.String().serializer(), Serdes.String().serializer());<br/>        TestOutputTopic&lt;String, Long&gt; ot = td.createOutputTopic(App.OUTPUT_TOPIC, Serdes.String().deserializer(), Serdes.Long().deserializer());</span><span id="3bee" class="nb mf iq lv b gy oj ns l nt nu">        inputTopic.pipeInput("key1", "value1");<br/>        inputTopic.pipeInput("key1", "value2");<br/>        inputTopic.pipeInput("key2", "value3");<br/>        inputTopic.pipeInput("key3", "value4");<br/>        inputTopic.pipeInput("key2", "value5");</span><span id="0690" class="nb mf iq lv b gy oj ns l nt nu">        assertThat(ot.readKeyValue(), equalTo(new KeyValue&lt;String, Long&gt;("key1", 1L)));<br/>        assertThat(ot.readKeyValue(), equalTo(new KeyValue&lt;String, Long&gt;("key1", 2L)));<br/>        assertThat(ot.readKeyValue(), equalTo(new KeyValue&lt;String, Long&gt;("key2", 1L)));<br/>        assertThat(ot.readKeyValue(), equalTo(new KeyValue&lt;String, Long&gt;("key3", 1L)));<br/>        assertThat(ot.readKeyValue(), equalTo(new KeyValue&lt;String, Long&gt;("key2", 2L)));</span></pre><p id="16d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单个记录被发送到输入主题和输出主题，然后计数被验证。不出所料，按键<code class="fe ls lt lu lv b">key1</code>、<code class="fe ls lt lu lv b">key2</code>和<code class="fe ls lt lu lv b">key3</code>的计数分别为2、2、1。</p><h2 id="ce6d" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lf ng nh mq lj ni nj ms ln nk nl mu nm bi translated">具有状态存储的有状态操作</h2><p id="8278" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">当拓扑由状态存储组成时，事情变得有趣起来。在本例中，不是将计数发送到输出主题，而是使用中间状态存储(这可以通过交互式查询来查询):</p><pre class="kg kh ki kj gt nn lv no np aw nq bi"><span id="65ae" class="nb mf iq lv b gy nr ns l nt nu">StreamsBuilder builder = new StreamsBuilder();<br/>        KStream&lt;String, String&gt; stream = builder.stream(INPUT_TOPIC);</span><span id="4fd8" class="nb mf iq lv b gy oj ns l nt nu">stream.groupByKey().count(Materialized.as("count-store"));</span></pre><p id="7145" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TopologyTestDriver通过<code class="fe ls lt lu lv b">getKeyValueStore</code>提供对状态存储(<code class="fe ls lt lu lv b">KeyValueStore</code>)的访问。在每个记录发送到输入主题后，验证状态存储计数，例如<code class="fe ls lt lu lv b">assertThat(countStore.get("key1"), equalTo(1L));</code>:</p><pre class="kg kh ki kj gt nn lv no np aw nq bi"><span id="2723" class="nb mf iq lv b gy nr ns l nt nu">topology = App.countWithStateStore();<br/>td = new TopologyTestDriver(topology, config);</span><span id="c314" class="nb mf iq lv b gy oj ns l nt nu">inputTopic = td.createInputTopic(App.INPUT_TOPIC, Serdes.String().serializer(), Serdes.String().serializer());<br/>        <br/>KeyValueStore&lt;String, Long&gt; countStore = td.getKeyValueStore("count-store");</span><span id="fe79" class="nb mf iq lv b gy oj ns l nt nu">inputTopic.pipeInput("key1", "value1");        assertThat(countStore.get("key1"), equalTo(1L));</span><span id="4b46" class="nb mf iq lv b gy oj ns l nt nu">inputTopic.pipeInput("key1", "value2");<br/>assertThat(countStore.get("key1"), equalTo(2L));</span><span id="d3e7" class="nb mf iq lv b gy oj ns l nt nu">inputTopic.pipeInput("key2", "value3");<br/>assertThat(countStore.get("key2"), equalTo(1L));</span><span id="c38e" class="nb mf iq lv b gy oj ns l nt nu">inputTopic.pipeInput("key3", "value4");<br/>assertThat(countStore.get("key3"), equalTo(1L));</span><span id="0f57" class="nb mf iq lv b gy oj ns l nt nu">inputTopic.pipeInput("key2", "value5");<br/>assertThat(countStore.get("key2"), equalTo(2L));</span></pre><p id="23de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，在我们的测试中，我们已经在每个测试方法中创建了<code class="fe ls lt lu lv b">Topology</code>、<code class="fe ls lt lu lv b">TopologyTestDriver</code>、<code class="fe ls lt lu lv b">TestInputTopic</code>和<code class="fe ls lt lu lv b">TestOutputTopic</code>。这只是因为我们在测试不同的拓扑结构。如果您使用一堆测试用例作为单个JUnit类的一部分来测试单个的<code class="fe ls lt lu lv b">Topology</code>，那么您可以非常容易地将它转移到用<code class="fe ls lt lu lv b">@Before</code>注释的setup方法，这样它就可以在每个测试用例开始之前自动运行。</p><p id="b850" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">暂时就这样吧！这是一个简短但有希望对测试基于Kafka Streams的处理管道有用的介绍。</p><p id="5f48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>