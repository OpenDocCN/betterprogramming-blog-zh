<html>
<head>
<title>Implementing a Generic Repository Pattern Using NestJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NestJS实现通用存储库模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-a-generic-repository-pattern-using-nestjs-fb4db1b61cce?source=collection_archive---------0-----------------------#2022-01-27">https://betterprogramming.pub/implementing-a-generic-repository-pattern-using-nestjs-fb4db1b61cce?source=collection_archive---------0-----------------------#2022-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d0a4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通用存储库——NestJS和Mongoose实现</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/15c53415d5b56d816ea17f10370ed0c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cU-3yxNtumZKI0zI"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@eswaran_arulkumar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃斯瓦兰·阿鲁科马尔</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><blockquote class="kw kx ky"><p id="308b" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">存储库是封装了访问数据源所需的逻辑的类或组件。它们集中了常见的数据访问功能，提供了更好的可维护性，并将用于访问数据库的基础设施或技术从域模型层中分离出来。— <a class="ae kv" href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design" rel="noopener ugc nofollow" target="_blank">设计基础设施持久层</a></p></blockquote><p id="7d04" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">抽象我们的数据访问层将把我们的应用程序业务逻辑从实现细节中分离出来，比如mongo db/sql数据访问代码。</p><p id="c1ad" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">诸如DB框架变更这样的框架变更不应该影响我们的核心服务，它们应该对我们的业务逻辑代码透明。</p><p id="5b62" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们的服务应该只依赖于抽象，而不是实现。数据服务也是如此。</p><p id="b94f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">例如，我们有一个书店微服务。我们有一个“添加新书”用例，在这个用例中，我们使用图书存储库来添加新书。我们不关心具体的数据库实现，也不想被任何数据库所束缚。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lz"><img src="../Images/41aeec331c354f921fd3fbe80dd8e742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BdPsuoRoBdfbTHWgVFElHQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">依赖抽象</p></figure><p id="e65b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">你可以在这个<a class="ae kv" href="https://github.com/royib/clean-architecture-nestJS" rel="noopener ugc nofollow" target="_blank">报告</a>中找到所有带有完整示例的代码</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><p id="2f43" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们的<code class="fe mh mi mj mk b">Author</code>、<code class="fe mh mi mj mk b">Genre</code>和<code class="fe mh mi mj mk b">Book</code>实体是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="7513" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">抽象</h1><p id="326a" class="pw-post-body-paragraph kz la iq lc b ld nf jr lf lg ng ju li lw nh ll lm lx ni lp lq ly nj lt lu lv ij bi translated">首先，让我们创建我们的抽象:</p><p id="1e50" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe mh mi mj mk b">AbstractRepository</code>类的代码如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><ul class=""><li id="06d1" class="nk nl iq lc b ld le lg lh lw nm lx nn ly no lv np nq nr ns bi translated">您可以根据需要添加任意多的功能。</li><li id="b8f0" class="nk nl iq lc b ld nt lg nu lw nv lx nw ly nx lv np nq nr ns bi translated"><code class="fe mh mi mj mk b">T</code>代表各个实体</li></ul><p id="4cb2" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe mh mi mj mk b">AbstractDataServices</code>类的代码如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><ul class=""><li id="363d" class="nk nl iq lc b ld le lg lh lw nm lx nn ly no lv np nq nr ns bi translated">我们公开3个存储库，每个业务实体一个。</li><li id="1955" class="nk nl iq lc b ld nt lg nu lw nv lx nw ly nx lv np nq nr ns bi translated">每个存储库公开了所有通用的存储库功能</li></ul><p id="770a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这些是我们的抽象，我们的业务服务可以与它们一起工作，而无需任何实现。</p><p id="5d11" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在是时候添加一个实现了，在本文中，我们将使用mongoose实现我们的数据服务。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="edb5" class="mn mo iq bd mp mq ny ms mt mu nz mw mx jw oa jx mz jz ob ka nb kc oc kd nd ne bi translated">MongoDb实现</h1><p id="aefa" class="pw-post-body-paragraph kz la iq lc b ld nf jr lf lg ng ju li lw nh ll lm lx ni lp lq ly nj lt lu lv ij bi translated">我们的MongoDB实现将被包装在一个模块中，我们将只公开抽象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/8b241301fcdb4f045bc3abffba307150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*3dRG_vvViQ8zx6Epc9y4Fg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">抽象实现</p></figure><p id="4479" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们需要实施:</p><ul class=""><li id="41c0" class="nk nl iq lc b ld le lg lh lw nm lx nn ly no lv np nq nr ns bi translated">Mongo模型—具有所有mongo规范</li><li id="48b4" class="nk nl iq lc b ld nt lg nu lw nv lx nw ly nx lv np nq nr ns bi translated">我们的通用存储库——连接到mongo</li><li id="290b" class="nk nl iq lc b ld nt lg nu lw nv lx nw ly nx lv np nq nr ns bi translated">数据服务——公开我们的mongo库</li></ul><h2 id="a70f" class="oe mo iq bd mp of og dn mt oh oi dp mx lw oj ok mz lx ol om nb ly on oo nd op bi translated">模型</h2><p id="eb5e" class="pw-post-body-paragraph kz la iq lc b ld nf jr lf lg ng ju li lw nh ll lm lx ni lp lq ly nj lt lu lv ij bi translated">首先，让我们创建我们的实体，它们将用猫鼬装饰者来装饰</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="a032" class="oe mo iq bd mp of og dn mt oh oi dp mx lw oj ok mz lx ol om nb ly on oo nd op bi translated">Mongo通用存储库</h2><p id="03ba" class="pw-post-body-paragraph kz la iq lc b ld nf jr lf lg ng ju li lw nh ll lm lx ni lp lq ly nj lt lu lv ij bi translated">让我们实现我们的mongo通用存储库</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><ul class=""><li id="fbcf" class="nk nl iq lc b ld le lg lh lw nm lx nn ly no lv np nq nr ns bi translated">简单的mongo实现。</li><li id="dc76" class="nk nl iq lc b ld nt lg nu lw nv lx nw ly nx lv np nq nr ns bi translated">将使我们能够用连接的实体填充我们的模型</li></ul><h2 id="6fdf" class="oe mo iq bd mp of og dn mt oh oi dp mx lw oj ok mz lx ol om nb ly on oo nd op bi translated">Mongo数据服务</h2><p id="5bca" class="pw-post-body-paragraph kz la iq lc b ld nf jr lf lg ng ju li lw nh ll lm lx ni lp lq ly nj lt lu lv ij bi translated">在这里，我们需要创建我们的存储库，并向我们的消费者公开它们</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="ea0c" class="oe mo iq bd mp of og dn mt oh oi dp mx lw oj ok mz lx ol om nb ly on oo nd op bi translated">Mongo数据服务模块</h2><p id="2c0a" class="pw-post-body-paragraph kz la iq lc b ld nf jr lf lg ng ju li lw nh ll lm lx ni lp lq ly nj lt lu lv ij bi translated">在本模块中，我们将:</p><ul class=""><li id="8c64" class="nk nl iq lc b ld le lg lh lw nm lx nn ly no lv np nq nr ns bi translated">将连接添加到MongoDB</li><li id="16a6" class="nk nl iq lc b ld nt lg nu lw nv lx nw ly nx lv np nq nr ns bi translated">告诉我们的DI引擎在每次一个类请求<code class="fe mh mi mj mk b">IDataServices</code>时创建<code class="fe mh mi mj mk b">MongoDataServices</code></li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="e3bd" class="oe mo iq bd mp of og dn mt oh oi dp mx lw oj ok mz lx ol om nb ly on oo nd op bi translated">主数据服务模块</h2><p id="896b" class="pw-post-body-paragraph kz la iq lc b ld nf jr lf lg ng ju li lw nh ll lm lx ni lp lq ly nj lt lu lv ij bi translated">这个模块不是必须的，但是我喜欢创建它，因为它隐藏了我们主模块的任何特定实现</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="6a0c" class="oe mo iq bd mp of og dn mt oh oi dp mx lw oj ok mz lx ol om nb ly on oo nd op bi translated">将模块插入我们的主应用程序</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><ul class=""><li id="1d11" class="nk nl iq lc b ld le lg lh lw nm lx nn ly no lv np nq nr ns bi translated">使用我们早期创建的<code class="fe mh mi mj mk b">DataServiceModule</code>，我们在这里看不到任何mongo实现的东西，我们只是添加了<code class="fe mh mi mj mk b">DataServiceModule</code>。</li></ul><h2 id="d6cb" class="oe mo iq bd mp of og dn mt oh oi dp mx lw oj ok mz lx ol om nb ly on oo nd op bi translated">让我们带这位美女去兜风吧</h2><p id="3976" class="pw-post-body-paragraph kz la iq lc b ld nf jr lf lg ng ju li lw nh ll lm lx ni lp lq ly nj lt lu lv ij bi translated">现在让我们在应用程序中使用我们闪亮的新数据服务。</p><p id="c6e4" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">例如，让我们在图书服务中使用它来获取图书并将新书添加到我们的数据库中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><ul class=""><li id="67f4" class="nk nl iq lc b ld le lg lh lw nm lx nn ly no lv np nq nr ns bi translated">我们将<code class="fe mh mi mj mk b">IDataServices</code>注入到我们的服务中</li><li id="dba3" class="nk nl iq lc b ld nt lg nu lw nv lx nw ly nx lv np nq nr ns bi translated">我们的用例逻辑不依赖于任何数据库实现，只依赖于抽象。</li><li id="045b" class="nk nl iq lc b ld nt lg nu lw nv lx nw ly nx lv np nq nr ns bi translated">改变我们的数据库提供者根本不会影响我们的用例代码。</li></ul><p id="ead3" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">假设我们想更换我们的数据库提供商，我们需要做的就是:</p><ul class=""><li id="5909" class="nk nl iq lc b ld le lg lh lw nm lx nn ly no lv np nq nr ns bi translated">创建一个新的数据库模块，包括:<code class="fe mh mi mj mk b">GenericRepository</code>、<code class="fe mh mi mj mk b">DataServices</code></li><li id="873d" class="nk nl iq lc b ld nt lg nu lw nv lx nw ly nx lv np nq nr ns bi translated">消耗<code class="fe mh mi mj mk b"><a class="ae kv" href="https://github.com/royib/clean-architecture-nestJS/blob/main/src/services/data-services/data-services.module.ts" rel="noopener ugc nofollow" target="_blank">DataServicesModule</a></code>中的新模块</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="fd4e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">就这样，我们的应用程序没有其他变化。你老板会高兴的:)</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><p id="3c99" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">存储库模式是将应用程序从外部数据库框架中分离出来的一个很好的方式，通用存储库减少了实现它所需编写的代码量。</p><h1 id="81fa" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">后续步骤</h1><p id="5b70" class="pw-post-body-paragraph kz la iq lc b ld nf jr lf lg ng ju li lw nh ll lm lx ni lp lq ly nj lt lu lv ij bi translated">您可以在我写的一篇关于这个主题的文章中阅读更多关于在您的NestJs应用程序中实现一个干净的架构的内容——<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/clean-node-js-architecture-with-nestjs-and-typescript-34b9398d790f">Clean node . js Architecture——使用NestJs和TypeScript </a></p></div></div>    
</body>
</html>