<html>
<head>
<title>Strato DynDNS Controller for Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes的斯特拉托DynDNS控制器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/strato-dyndns-controller-for-kubernetes-9a59ae426c5b?source=collection_archive---------3-----------------------#2022-11-27">https://betterprogramming.pub/strato-dyndns-controller-for-kubernetes-9a59ae426c5b?source=collection_archive---------3-----------------------#2022-11-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3fd5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">K8S控制器来更新STRATO服务器上的域名DNS记录</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/94c0713a781f8e2bf4b540cd03a34add.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a16AcT0Mjct9PiJ0sj43UQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">“总是DNS…”阿什利·威利斯的作品<a class="ae kv" href="https://twitter.com/ashleymcnamara" rel="noopener ugc nofollow" target="_blank">@阿什利·麦克纳马拉</a></p></figure><h1 id="36e0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="a41a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">几年来，我逐渐将家庭实验室的工作负载从虚拟机转移到Docker容器，最终，在Kubernetes中，我在寻找一个有效的解决方案，来保持我的域的DNS记录与我的ISP分配的动态IP地址同步。</p><p id="9e81" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我用了<a class="ae kv" href="https://www.directupdate.net" rel="noopener ugc nofollow" target="_blank"> DirectUpdate </a>很长一段时间，虽然它花费了大约25欧元，确实物有所值，但它也有一个缺点:它只能在Windows上运行，而且浪费这么多资源只是为了一个简单的DynDNS-updater客户端是一种过度的杀戮。因此，我开始寻找其他解决方案，如Cloudflare、DigitalOcean、No-IP DynDNS等。但是我仍然不满意。我很无聊地在不同的仪表板、提供商和面板之间跳跃，以定期查看我的域名的DNS记录，所以我确保我的反向代理和我的Kubernetes入口没有遇到麻烦。我决定我需要自己的解决方案(为什么不呢？)必须满足三个标准:</p><ol class=""><li id="37b9" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">这不应该花我一分钱</li><li id="a65c" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">它应该与Kubernetes集成，所以我不需要从仪表板跳到仪表板</li><li id="b122" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">它应该是完全自主的、自我修复的和周期性的</li></ol><p id="4e31" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">满足所有这些标准的显而易见的解决方案是使用定制的CRDs来定制Kubernetes控制器，还有比Kubebuilder更好的工具吗？Kubebuilder是一个使用<a class="ae kv" href="https://kubernetes.io/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions" rel="noopener ugc nofollow" target="_blank">定制资源定义(CRDs) </a>构建Kubernetes APIs的框架。它为我们做所有繁重的工作，构建项目结构，搭建编码、构建和部署我们的工件所需的基本组件。</p><div class="nd ne gp gr nf ng"><a href="https://github.com/kubernetes-sigs/kubebuilder" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">GitHub-Kubernetes-sigs/kube builder:用于使用CRDs构建Kubernetes APIs的Kubebuilder - SDK</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">Kubebuilder是一个使用自定义资源定义(CRD)构建Kubernetes APIs的框架。类似于web…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">github.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu kp ng"/></div></div></a></div><p id="ac7e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">简而言之，这个故事非常简单，主要由两部分组成:通过将工件表示为定制资源定义(CRD)来扩展Kubernetes控制平面，并创建一个定制控制器，该控制器定期或通过响应CRs上的更改，尝试调整这些CRs的实际观察状态，以便与所需状态相匹配。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/85ae7a5a4fd769d739d51d8d949e4fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*ePYHDc_yUHtgG-dACHOXPQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们在Kubernetes中的解决方案的简单架构图(CRDs、秘密、控制器)</p></figure><p id="8c03" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在我们的例子中，这转化为一个CRD，它将被称为域，实际上是一个域(或子域)的表示，您希望在<a class="ae kv" href="https://www.strato.de" rel="noopener ugc nofollow" target="_blank"> STRATO </a>上定期更新它的DNS记录；以及一个定制控制器，它接管协调CRs状态和将IP变化传播到STRATO DynDNS端点的Sisyphean任务。</p><p id="5bc3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此外，我们将需要一个秘密，但它的作用纯粹是辅助性的，因为它只作为对STRATO DynDNS端点发出请求所需的凭证的保管者。</p><blockquote class="nw nx ny"><p id="fe8d" class="lo lp nz lq b lr mk jr lt lu ml ju lw oa mm lz ma ob mn md me oc mo mh mi mj ij bi translated">为什么首先选择STRATO？因为这是我注册所有域名的地方。</p><p id="ff19" class="lo lp nz lq b lr mk jr lt lu ml ju lw oa mm lz ma ob mn md me oc mo mh mi mj ij bi translated">斯特拉托公司是一家德国互联网托管服务提供商，总部设在柏林。它是联合互联网公司的子公司，于2016年从德国电信公司收购了它。斯特拉托主要在德国、荷兰、西班牙、法国、英国和瑞典开展业务，为200多万客户提供服务。</p></blockquote><p id="387e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">本文不是关于使用Kubebuilder创建定制控制器的入门文章。如果你是这个话题的新手，可以参考官方的Kubebuilder书籍或者看看赖的这篇非常好的文章:</p><div class="nd ne gp gr nf ng"><a href="https://medium.com/swlh/kubernetes-operator-for-beginners-what-why-how-21b23f0cb9b1" rel="noopener follow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">面向初学者的Kubernetes运算符—什么、为什么、如何</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">解释基本知识和方法，使用Kubebuilder从头构建一个操作符</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">medium.com</p></div></div><div class="np l"><div class="of l nr ns nt np nu kp ng"/></div></div></a></div><p id="3dbb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">抛开这些不谈，现在让我们来剖析代码！</p><h1 id="29e5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">自定义资源定义(CRD)</h1><p id="8c43" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe og oh oi oj b">Domain</code>由两个属性组成(主要是——什么是<code class="fe og oh oi oj b">TypeMeta</code>和<code class="fe og oh oi oj b">ObjectMeta</code>你可以在Kubebuilder的书中找到它)，我们在前面已经简单讨论过了。<code class="fe og oh oi oj b">Spec</code>、<code class="fe og oh oi oj b">DomainSpec</code>类型是期望状态，而<code class="fe og oh oi oj b">Status</code>、<code class="fe og oh oi oj b">DomainStatus</code>类型是我们的<code class="fe og oh oi oj b">Domain</code>客户资源(CR)在任何给定时刻的实际(观察)状态。</p><p id="b407" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果你注意到，这个结构是用一堆以<code class="fe og oh oi oj b">+kubebuilder:printcolumn</code>为前缀的属性来修饰的，它们决定了当我们查询一个对象或该<code class="fe og oh oi oj b">Kind</code>的对象列表时，将显示哪些列。</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="6ada" class="oo kx iq oj b be op oq l or os">kubectl get domains --all-namespaces</span></pre><p id="f95b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">每列的值可以从期望状态(<code class="fe og oh oi oj b">.spec.XXX</code>)或观察状态(<code class="fe og oh oi oj b">.status.XXX</code>)中导出。</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="0ec7" class="oo kx iq oj b be op oq l or os">// Domain is the Schema for the domains API<br/>// +kubebuilder:printcolumn:name="Fqdn",type=string,JSONPath=`.spec.fqdn`<br/>// +kubebuilder:printcolumn:name="IP Address",type=string,JSONPath=`.status.ipAddress`<br/>// +kubebuilder:printcolumn:name="Mode",type=string,JSONPath=`.status.mode`<br/>// +kubebuilder:printcolumn:name="Successful",type=boolean,JSONPath=`.status.lastResult`<br/>// +kubebuilder:printcolumn:name="Last Run",type=string,JSONPath=`.status.lastLoop`<br/>// +kubebuilder:printcolumn:name="Enabled",type=boolean,JSONPath=`.spec.enabled`<br/>type Domain struct {<br/> metav1.TypeMeta   `json:",inline"`<br/> metav1.ObjectMeta `json:"metadata,omitempty"`<br/><br/> Spec   DomainSpec   `json:"spec,omitempty"`<br/> Status DomainStatus `json:"status,omitempty"`<br/>}</span></pre><p id="e68b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">期望的状态<code class="fe og oh oi oj b">DomainSpec</code>有五个属性。<code class="fe og oh oi oj b">Fqdn</code>这是您想要跟踪的域名或子域的完全限定名称。<code class="fe og oh oi oj b">IpAddress</code>是可选的，如果它被设置，那么我们隐式地强制手动模式，当它为空时，我们的控制器将发现由我们的ISP分配给我们的当前IP地址(动态模式)。是不需要进一步解释的事情。<code class="fe og oh oi oj b">IntervalInMinutes</code>正在定义两个连续协调循环之间的间隔，<code class="fe og oh oi oj b">Password</code>是对<code class="fe og oh oi oj b">Secret</code>资源的引用，该资源将保存我们的斯特拉托动态域名系统服务的密码。</p><p id="ae87" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这些属性也可以用强制或规定对象的各种行为方面的属性来修饰。例如，我们通过正则表达式对<code class="fe og oh oi oj b">Fqdn</code>进行验证，从而确保它是一个有效的域名，对<code class="fe og oh oi oj b">IpAddress</code>来说，它是一个有效的IPv4地址。对于<code class="fe og oh oi oj b">IntervalInMinutes</code>,我们希望确保其频率不超过五分钟，在缺席的情况下，这将是部署时自动分配的默认值。</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="61d4" class="oo kx iq oj b be op oq l or os">// DomainSpec defines the desired state of Domain<br/>type DomainSpec struct {<br/> // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster<br/> // Important: Run "make" to regenerate code after modifying this file<br/><br/> // +kubebuilder:validation:Required<br/> // +kubebuilder:validation:Pattern:=`^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])(\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9]))*$`<br/> Fqdn string `json:"fqdn"`<br/><br/> // +optional<br/> // +kubebuilder:validation:Required<br/> // +kubebuilder:validation:Pattern:=`^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}$`<br/> IpAddress *string `json:"ipAddress,omitempty"`<br/><br/> // +optional<br/> // +kubebuilder:default:=true<br/> // +kubebuilder:validation:Type=boolean<br/> Enabled bool `json:"enabled,omitempty"`<br/><br/> // +optional<br/> // +kubebuilder:default=5<br/> // +kubebuilder:validation:Minimum=5<br/> IntervalInMinutes *int32 `json:"interval,omitempty"`<br/><br/> Password *v1.SecretReference `json:"password"`<br/>}</span></pre><p id="f86f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">观察到的状态<code class="fe og oh oi oj b">DomainStatus</code>，要简单得多。在每个协调循环中，基于协调的输出(<code class="fe og oh oi oj b">IpAddress</code>在STRATO记录中更新的IP，<code class="fe og oh oi oj b">LastReconciliationLoop</code>最后一次更新尝试发生的时间和<code class="fe og oh oi oj b">LastReconciliationResult</code>最后一次尝试是否成功)或者基于在该循环中处理的当前期望状态(<code class="fe og oh oi oj b">Enabled</code>或<code class="fe og oh oi oj b">Mode</code>)来计算它们的值。</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="5ac2" class="oo kx iq oj b be op oq l or os">// DomainStatus defines the observed state of Domain<br/>type DomainStatus struct {<br/> // INSERT ADDITIONAL STATUS FIELD - define observed state of cluster<br/> // Important: Run "make" to regenerate code after modifying this file<br/> Enabled                  bool         `json:"enabled,omitempty"`<br/> IpAddress                string       `json:"ipAddress,omitempty"`<br/> Mode                     string       `json:"mode,omitempty"`<br/> LastReconciliationLoop   *metav1.Time `json:"lastLoop,omitempty"`<br/> LastReconciliationResult *bool        `json:"lastResult,omitempty"`<br/>}</span></pre><p id="02a6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当我们完成这些结构的编码后，您可以在<code class="fe og oh oi oj b">/api/v1alpha1/domain_types.go</code>下找到它们，然后我们可以用Kubebuilder更新我们项目的其余部分，并将它们作为CRD安装到我们的开发集群中。</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="5f44" class="oo kx iq oj b be op oq l or os">make manifests<br/>make install</span></pre><p id="6506" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">制作清单将会基于我们之前在<code class="fe og oh oi oj b">/config/samples</code>中编写的结构创建一些样本YAML文件。</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="d76c" class="oo kx iq oj b be op oq l or os">apiVersion: dyndns.contrib.strato.com/v1alpha1<br/>kind: Domain<br/>metadata:<br/>  name: www-example-de<br/>spec:<br/>  fqdn: "www.example.de"<br/>  enabled: true<br/>  interval: 5<br/>  password:<br/>    name: strato-dyndns-password</span></pre><p id="5492" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">更改这些值，使它们指向您的域或子域。</p><h1 id="c730" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">秘密</h1><p id="f5d9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">清单不会为<code class="fe og oh oi oj b">Secret</code>创造一个脚手架——它不是CRD，而是Kubernetes的核心资源。我们必须自己创造它。STRATO DynDNS端点需要一个<code class="fe og oh oi oj b">username</code>和一个<code class="fe og oh oi oj b">password</code>，其中<code class="fe og oh oi oj b">username</code>始终是域或子域本身，<code class="fe og oh oi oj b">password</code>是您激活该(子)域的DynDNS时创建的密码或您的STRATO客户帐户的DynDNS主密码。您可以选择使用哪一个，但是在进行<code class="fe og oh oi oj b">Secret</code>的YAML之前，我们需要将这个密码编码为base64:</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="92c4" class="oo kx iq oj b be op oq l or os">echo -n "password" | base64</span></pre><p id="0f13" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在<code class="fe og oh oi oj b">/config/samples</code>下创建一个空的YAML文件，将您在<code class="fe og oh oi oj b">Domain</code> YAML中使用的<code class="fe og oh oi oj b">password.name</code>声明为<code class="fe og oh oi oj b">name</code>，将您刚刚生成的密码的编码值声明为<code class="fe og oh oi oj b">data.password</code>。</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="a84f" class="oo kx iq oj b be op oq l or os">apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: strato-dyndns-password<br/>type: Opaque<br/>data:<br/>  password: cGFzc3dvcmQ=</span></pre><p id="c03f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">将两个YAMLs都部署到集群中:</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="256b" class="oo kx iq oj b be op oq l or os">kubectl apply -f config/samples </span></pre><p id="80d9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果一切正常，您可以看到一个<code class="fe og oh oi oj b">www-example-de</code>(如果您请求获得<code class="fe og oh oi oj b">domains</code>)，如果您请求集群中的<code class="fe og oh oi oj b">secrets</code>，则可以看到strato-dyndns-password:</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="fad8" class="oo kx iq oj b be op oq l or os">kubectl get domains --all-namespaces<br/>kubectl get secrets --all-namespaces</span></pre><h1 id="7b78" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">定制控制器</h1><p id="5a99" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如前所述，向您解释定制控制器是如何工作的超出了本文的范围，所以我将坚持这个控制器是如何工作的。如果对你来说这是一个新的话题，做好准备。</p><p id="b22f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，我们希望确保我们的控制器有足够的权限来监视或更新各种资源。当然，我们希望对<code class="fe og oh oi oj b">Domains</code>拥有完全的控制权，但是我们还希望能够获取和观察<code class="fe og oh oi oj b">Secrets</code>并创建或更新Kubernetes <code class="fe og oh oi oj b">Events</code>。我们通过<code class="fe og oh oi oj b">+kubebuilder:rbac</code>属性对此进行管理。</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="fa8a" class="oo kx iq oj b be op oq l or os">//+kubebuilder:rbac:groups=dyndns.contrib.strato.com,resources=domains,verbs=get;list;watch;create;update;patch;delete<br/>//+kubebuilder:rbac:groups=dyndns.contrib.strato.com,resources=domains/status,verbs=get;update;patch<br/>//+kubebuilder:rbac:groups=dyndns.contrib.strato.com,resources=domains/finalizers,verbs=update<br/>//+kubebuilder:rbac:groups="",resources=events,verbs=create;patch<br/>//+kubebuilder:rbac:groups="",resources=secrets,verbs=get;list;watch;</span></pre><p id="edb8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当您发出<code class="fe og oh oi oj b">make manifests</code>命令时，一堆YAML文件，以及其他文件，将基于这些属性在<code class="fe og oh oi oj b">/config/rbac</code>下创建。</p><p id="084a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们的协调循环流程很简单。获取<code class="fe og oh oi oj b">Domain</code>，如果失败，永久终止循环，不再排队。</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="715b" class="oo kx iq oj b be op oq l or os">var domain dyndnsv1alpha1.Domain<br/> if err := r.Get(ctx, req.NamespacedName, &amp;domain); err != nil {<br/>  if apierrors.IsNotFound(err) {<br/>   logger.Error(err, "finding Domain failed")<br/>   return ctrl.Result{}, nil<br/>  }<br/><br/>  logger.Error(err, "fetching Domain failed")<br/>  return ctrl.Result{}, err<br/> }</span></pre><p id="177e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">检查所需状态(<code class="fe og oh oi oj b">.Spec.Enabled</code>)，如果未启用，则相应更新Kubernetes ( <code class="fe og oh oi oj b">.Status.Enabled</code>)中CR的状态，如果启用为假，则永久退出对账循环。</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="944b" class="oo kx iq oj b be op oq l or os">// update status and break reconciliation loop if is not enabled<br/> if !domain.Spec.Enabled {<br/>  domainCopy.Status.Enabled = domain.Spec.Enabled<br/>  // update the status of the CR<br/>  if err := r.Status().Update(ctx, &amp;domainCopy); err != nil {<br/>   logger.Error(err, "updating status failed") //<br/><br/>   requeueAfterUpdateStatusFailure := time.Now().Add(time.Second * time.Duration(15))<br/>   return ctrl.Result{RequeueAfter: time.Until(requeueAfterUpdateStatusFailure)}, err<br/>  }<br/><br/>  return ctrl.Result{}, nil<br/> }</span></pre><p id="171e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">确保有一个可接受的间隔，并决定所需的状态是否指示我们以手动或动态模式进行。</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="3562" class="oo kx iq oj b be op oq l or os">// define interval between reconciliation loops<br/> interval := defaultIntervalInMinutes<br/> if domain.Spec.IntervalInMinutes != nil {<br/>  interval = *domain.Spec.IntervalInMinutes<br/> }<br/><br/> // change mode to manual in presence of an explicit ip address in specs<br/> if domain.Spec.IpAddress != nil {<br/>  mode = Manual<br/> }</span></pre><p id="d6c6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果协调循环在定义的时间间隔之前开始(可能是YAML文件中的外部变化或内部Kubernetes事件)，请确保跳过这一轮，等待下一次计划的执行。</p><blockquote class="nw nx ny"><p id="3786" class="lo lp nz lq b lr mk jr lt lu ml ju lw oa mm lz ma ob mn md me oc mo mh mi mj ij bi translated">否则，我们可能会对STRATO造成频繁请求的溢出，我们不希望这样做，因为我们会触及Kubernetes或STRATO本身的速率限制器，而您最不希望的事情就是由于滥用他们的API而被搁置一段时间。</p></blockquote><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="43cf" class="oo kx iq oj b be op oq l or os">// is reconciliation loop started too soon because of an external event?<br/> if domain.Status.LastReconciliationLoop != nil &amp;&amp; mode == Dynamic {<br/>  if time.Since(domain.Status.LastReconciliationLoop.Time) &lt; (time.Minute*time.Duration(interval)) &amp;&amp; wasSuccess {<br/>   sinceLastRunDuration := time.Since(domain.Status.LastReconciliationLoop.Time)<br/>   intervalDuration := time.Minute * time.Duration(interval)<br/>   requeueAfter := intervalDuration - sinceLastRunDuration<br/><br/>   logger.Info("skipped turn", "sinceLastRun", sinceLastRunDuration, "requeueAfter", requeueAfter)<br/>   return ctrl.Result{RequeueAfter: time.Until(time.Now().Add(requeueAfter))}, nil<br/>  }<br/> }</span></pre><p id="4235" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果模式是<code class="fe og oh oi oj b">Manual</code>，我们的IP地址是在期望状态(<code class="fe og oh oi oj b">.Spec.IpAddress</code>)中定义的地址。否则，我们会发现我们的外部IP地址，即ISP分配给路由器的地址。</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="9fe5" class="oo kx iq oj b be op oq l or os">currentIpAddress := domain.Status.IpAddress<br/> var newIpAddress *string<br/><br/> switch mode {<br/> case Dynamic:<br/>  externalIpAddress, err := r.getExternalIpAddress()<br/>  if err != nil {<br/>   logger.Error(err, "retrieving external ip failed")<br/>   r.Recorder.Eventf(instance, v1core.EventTypeWarning, "RetrieveExternalIpFailed", err.Error())<br/><br/>   success = false<br/>  } else {<br/>   newIpAddress = externalIpAddress<br/>  }<br/> case Manual:<br/>  newIpAddress = domain.Spec.IpAddress<br/> }</span></pre><p id="84a9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果我们的IP地址的新的期望状态与观察到的状态匹配，什么也不要做——记住，友好地对待，不要无缘无故地滥用他们的端点。如果没有，获取<code class="fe og oh oi oj b">Secret</code>并检索您的<code class="fe og oh oi oj b">password</code>，将所需的更改传播到STRATO DNS服务器。</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="4b1a" class="oo kx iq oj b be op oq l or os">// proceed to update Strato DynDNS only if a valid IP address was found<br/> if newIpAddress != nil {<br/>  // if last reconciliation loop was successful and there is no ip change skip the loop<br/>  if *newIpAddress == currentIpAddress &amp;&amp; wasSuccess {<br/>   logger.Info("updating dyndns skipped, ip is up-to-date", "ipAddress", currentIpAddress, "mode", mode.String())<br/>   r.Recorder.Event(instance, v1core.EventTypeNormal, "DynDnsUpdateSkipped", "updating skipped, ip is up-to-date")<br/>  } else {<br/>   logger.Info("updating dyndns", "ipAddress", newIpAddress, "mode", mode.String())<br/><br/>   passwordRef := domain.Spec.Password<br/>   objectKey := client.ObjectKey{<br/>    Namespace: req.Namespace,<br/>    Name:      passwordRef.Name,<br/>   }<br/><br/>   var secret v1core.Secret<br/>   if err := r.Get(ctx, objectKey, &amp;secret); err != nil {<br/>    if apierrors.IsNotFound(err) {<br/>     logger.Error(err, "finding Secret failed")<br/>     return ctrl.Result{}, nil<br/>    }<br/><br/>    logger.Error(err, "fetching Secret failed")<br/>    return ctrl.Result{}, err<br/>   }<br/><br/>   password := string(secret.Data["password"])<br/>   if err := r.updateDns(domain.Spec.Fqdn, domain.Spec.Fqdn, password, *newIpAddress); err != nil {<br/>    logger.Error(err, "updating dyndns failed")<br/>    r.Recorder.Eventf(instance, v1core.EventTypeWarning, "DynDnsUpdateFailed", err.Error())<br/><br/>    success = false<br/>   } else {<br/>    logger.Info("updating dyndns completed")<br/>    r.Recorder.Eventf(instance, v1core.EventTypeNormal, "DynDnsUpdateCompleted", "updating dyndns completed")<br/><br/>    success = true<br/>   }<br/>  }<br/> }</span></pre><p id="41d4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">更新STRATO DynDNS非常简单。你需要发出一个<code class="fe og oh oi oj b">GET</code>请求去做，看起来像这样:</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="fcd9" class="oo kx iq oj b be op oq l or os"> https://%s:%s@dyndns.strato.com/nic/update?hostname=%s&amp;myip=%s</span></pre><p id="d300" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">前两个参数分别是<code class="fe og oh oi oj b">username</code>和<code class="fe og oh oi oj b">password</code>，<code class="fe og oh oi oj b">hostname</code>是你的(子)域名，<code class="fe og oh oi oj b">myip </code>是你要更新DNS记录的新IP地址。</p><p id="d874" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，我们更新了CR的状态，并重新安排了以下内容:</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="2aa3" class="oo kx iq oj b be op oq l or os">// update the status of the CR no matter what, but assign a new IP address in the status<br/> // only when Strato DynDNS update was successful<br/> if success {<br/>  domainCopy.Status.IpAddress = *newIpAddress<br/> }<br/><br/> domainCopy.Status.LastReconciliationLoop = &amp;v1meta.Time{Time: time.Now()}<br/> domainCopy.Status.LastReconciliationResult = &amp;success<br/> domainCopy.Status.Enabled = domain.Spec.Enabled<br/> domainCopy.Status.Mode = mode.String()<br/><br/> // update the status of the CR<br/> if err := r.Status().Update(ctx, &amp;domainCopy); err != nil {<br/>  logger.Error(err, "updating status failed") //<br/><br/>  requeueAfterUpdateStatusFailure := time.Now().Add(time.Second * time.Duration(15))<br/>  return ctrl.Result{RequeueAfter: time.Until(requeueAfterUpdateStatusFailure)}, err<br/> }<br/><br/> // if Mode is Manual, and we updated DynDNS with success, then we don't requeue, and we will rely only on<br/> // events that will be triggered externally from YAML updates of the CR<br/> if mode == Manual &amp;&amp; success {<br/>  return ctrl.Result{}, nil<br/> }<br/><br/> requeueAfter := time.Now().Add(time.Minute * time.Duration(interval))<br/><br/> logger.Info("requeue", "nextRun", fmt.Sprintf("%s", requeueAfter.Local().Format(time.RFC822)))<br/> logger.V(10).Info("finished dyndns update")<br/><br/> return ctrl.Result{RequeueAfter: time.Until(requeueAfter)}, nil</span></pre><p id="cb26" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，我们准备尝试我们的控制器(在外部，不将它部署到集群):</p><pre class="kg kh ki kj gt ok oj ol bn om on bi"><span id="dea8" class="oo kx iq oj b be op oq l or os">make run</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/dc297ad4d9940beadb47daf4f381d82e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XsRleCSS4vy-cMSybDvnzg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">为我们的域更新STRATO DynDNS成功！</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/01ac76ea8788c809ed1625d2db2e1cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oRwzb6n0qejX4CinrQs9Lw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在协调和更新后，通过K9S对我们的领域进行“kubectl描述…”</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/768f7986ff192dc1fef9f35dddc18684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4-IokDi-C4oUtudAD-t-eQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">K9S中的“kubectl get domains—all-namespaces”命令</p></figure><h1 id="3e3f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">摘要</h1><p id="d15b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">您可以在GitHub中找到完整的源代码，以及如何将其构建为容器并部署到您的集群的说明:</p><div class="nd ne gp gr nf ng"><a href="https://github.com/akyriako/strato-dyndns" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">斯特拉托动态域名系统控制器更新你的域名系统记录…</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">斯特拉托动态域名系统控制器在STRATO AG上更新你的域名系统记录。自定义控制器正在观察域CRs…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">github.com</p></div></div><div class="np l"><div class="ow l nr ns nt np nu kp ng"/></div></div></a></div><p id="b1dd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">试用这个控制器，并在你认为合适的时候随意分叉和扩展它，或者在下面的评论或Github上留下你的反馈。直到下一次…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/beaec24c7793538e6e3b85a4b2e08236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oi6ztR-o5D6Voak9OZZTqQ.jpeg"/></div></div></figure></div></div>    
</body>
</html>