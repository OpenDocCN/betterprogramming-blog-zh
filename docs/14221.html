<html>
<head>
<title>Rust, Lambda, and DynamoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust、Lambda和DynamoDB</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rust-lambda-and-dynamodb-bea841d47cca?source=collection_archive---------1-----------------------#2022-11-18">https://betterprogramming.pub/rust-lambda-and-dynamodb-bea841d47cca?source=collection_archive---------1-----------------------#2022-11-18</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="14bb" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">Rust中AWS Lambda函数的实现，它写入DynamoDB。所有这些都是通过Terraform部署的，还有一个Rust HTTP客户端！</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/e73c8e3d721cbe2bfd6cc4438d182fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ZUEm_XDzWR0JbFrQ32ScA.png"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">生锈在起作用</p></figure><p id="6590" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">作为我学习Rust开发的旅程的一部分，我开发了一个托管在AWS上的Lambda服务，该服务写入DynamoDB数据库和一个相关的Rust HTTP客户端。除了Rust，我还使用Terraform来管理AWS资源的部署。本文是我在运行于Raspberry Pi上的无线恒温器应用程序上写的第四篇文章。你可以在这里找到其他的:<a class="ae ls" href="https://medium.com/@mikehentges65/raspberry-pi-wireless-thermostat-in-rust-45a5d35196cf" rel="noopener"> Raspberry Pi无线恒温器——在Rust中</a> , <a class="ae ls" href="https://medium.com/@mikehentges65/rust-cross-compiling-made-easy-e30fcb233fef" rel="noopener"> Rust交叉编译变得容易</a>，以及<a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/easy-multi-threaded-shared-memory-in-rust-57344e9e8b97">在Rust中实现多线程共享内存</a>。所有源代码都可以在<a class="ae ls" href="https://github.com/mikehentges/thermostat-pi" rel="noopener ugc nofollow" target="_blank">我的GitHub库</a>获得。</p><p id="82b4" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们将在本文中讨论以下内容:</p><ol class=""><li id="9cbd" class="lt lu ir ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">将一个JSON API定义为两个相关项目共享的一个单独的机箱。</li><li id="5de9" class="lt lu ir ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">使用AWS Rust SDK在Rust中编写一个AWS Lambda函数，该函数接受一个带有JSON有效负载数据的HTTP POST，并将数据写入DynamoDB数据库。</li><li id="461c" class="lt lu ir ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">使用Terraform来定义和构建数据库、lambda函数以及将所有部分组合在一起所需的权限胶水。</li><li id="1955" class="lt lu ir ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">使用AWS CLI部署Lambda应用程序可执行更新。</li><li id="2dfc" class="lt lu ir ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">编写一个Rust HTTP客户端，将数据发送给我们的Lambda函数。</li></ol><p id="001a" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我假设您的系统上安装了<a class="ae ls" href="https://aws.amazon.com/cli/" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a>、<a class="ae ls" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>和<a class="ae ls" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> Rust </a>，并且您的AWS帐户已经设置好并连接到CLI。这有点麻烦，但是在每个系统的文档中很容易理解。</p><p id="6691" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我的应用程序的用例是跟踪我的Raspberry Pi恒温器应用程序的状态并记录历史。在Raspberry Pi上运行的Rust应用程序会将信息推送到云数据库。利用云数据库中的活动数据，可以通过检查数据来监控应用程序的健康状况，从而避免打开防火墙让外部观察者进入。我还获得了一个历史数据源，稍后我可以在UI上绘制它。</p><p id="e98a" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我选择了AWS 上的<a class="ae ls" href="https://aws.amazon.com/dynamodb/" rel="noopener ugc nofollow" target="_blank"> DynamoDB作为数据库平台。我的数据需求很容易放入DynamoDB的免费层，DynamoDB是推送物联网时间序列数据的有效位置。我没有将Pi应用程序直接连接到Dynamo数据库，而是选择了一个基于HTTP的服务层作为Raspberry PI和AWS之间的接口。我发现HTTP服务比直接的数据库连接更有弹性——HTTP的无状态特性使它能够在网络中断时自我纠正。将数据推送到数据库对于Lambda函数来说是一项出色的工作——随着AWS最近发布Rust SDK，我利用这个机会将Lambda函数构建成一个Rust应用程序。下面这张图片展示了我们将要研究的各个部分是如何组合在一起的:</a></p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj mh"><img src="../Images/9fe170842901067c912c0cb88019a7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*tiTMKJF4fkGnKHFd_vtSRw.png"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">我们的建筑</p></figure><p id="43fa" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">该应用程序有三个主要部分。首先，主应用程序是thermostat_pi，它是创建我们移动到数据库的数据的客户机。这个项目下是Lambda函数项目，名为push_temp。最后，temp_data项目包含数据传输API的定义。这三个项目都在GitHub上的<code class="fe mi mj mk ml b">thermostat_pi</code>应用程序下。</p><p id="3a7c" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在<code class="fe mi mj mk ml b">temp_data</code>中，我从Rust struct开始，它保存了恒温器应用程序的数据，并启用了JSON表示的<code class="fe mi mj mk ml b">serde</code>:</p><pre class="kh ki kj kk gu mm ml mn bn mo mp bi"><span id="0dd6" class="mq mr ir ml b be ms mt l mu mv">//temp-data/src/lib.rs<br/>use serde::Deserialize;<br/>use serde::Serialize;<br/><br/>#[derive(Debug, Serialize, Deserialize)]<br/>pub struct TempData {<br/> pub record_date: String,<br/> pub thermostat_on: bool,<br/> pub temperature: f32,<br/> pub thermostat_value: u16,<br/>}</span></pre><p id="9972" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我在一个单独的Rust crate中创建了它，以便它可以与Pi应用程序和lambda函数项目共享——确保两者始终同步。<code class="fe mi mj mk ml b">temp-data Cargo.toml</code>看起来是这样的:</p><pre class="kh ki kj kk gu mm ml mn bn mo mp bi"><span id="c512" class="mq mr ir ml b be ms mt l mu mv">[package]<br/>name = "temp-data"<br/>version = "0.1.0"<br/>edition = "2021"<br/>license = "MIT"<br/><br/>[dependencies]<br/>serde = {version = "1", features = ["derive"]}</span></pre><p id="b420" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">然后我定义了一个相应的DynamoDB数据库来保存这些信息。我为时序数据选择了一个分区键“day ”,这样就可以检索一天的数据，而不用扫描整个表。我还为日期/时间创建了一个排序关键字。当我想设置一个警报或绘制历史数据时，这个键结构将允许对数据进行有效的读取访问。我没有太多使用DynamoDB的经验，所以可能有更有效的方法来解决这个问题——但是我已经有了适合我的方法。下面是我们完成后DynamoDB表的样子:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj mw"><img src="../Images/e600b06292548cc3fcc94c82e96c446a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*qDwq6zApoFqFqbspTekYEg.png"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">迪纳摩中的样本数据</p></figure><p id="5af0" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><code class="fe mi mj mk ml b">Record_Day</code>和<code class="fe mi mj mk ml b">Record_Date</code>键是DynamoDB的字符串。<code class="fe mi mj mk ml b">Record_Date</code>格式是RFC3339，Rust标准时间包支持。它创建一个字符串，该字符串可以通过字母排序正确地对时间值进行排序。</p><p id="0734" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">接下来，我们构建lambda函数来接收传入的请求，并将其存储在DynamoDB表中。我的主项目的<code class="fe mi mj mk ml b">push-temp</code>目录(GitHub链接)就是它所在的地方。推送温度<code class="fe mi mj mk ml b">Cargo.toml</code>包含这些条目:</p><pre class="kh ki kj kk gu mm ml mn bn mo mp bi"><span id="bd5d" class="mq mr ir ml b be ms mt l mu mv">[package]<br/>name = "push_temp"<br/>version = "0.1.0"<br/>edition = "2021"<br/>license = "MIT OR Apache-2.0"<br/><br/>[dependencies]<br/>aws-config = "0.51.0"<br/>aws-sdk-dynamodb = "0.21.0"<br/>log = "0.4.14"<br/>serde = {version = "1", features = ["derive"]}<br/>tokio = "1.16.1"<br/>tracing-subscriber = { version = "0.3", features = ["env-filter"] }<br/>lambda_http = "0.7"<br/>serde_json = "1.0.78"<br/><br/># Our package that defines the struct of the incoming request<br/>temp-data = { path="../temp-data" }</span></pre><p id="b441" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们正在使用<a class="ae ls" href="https://docs.aws.amazon.com/sdk-for-rust/" rel="noopener ugc nofollow" target="_blank"> AWS SDK来处理Rust </a>。我将lambda函数的所有Rust代码放在main.rs文件中。首先，有一些样板文件来导入我们的消息结构，定义我们的响应类型，并设置Lambda环境:</p><pre class="kh ki kj kk gu mm ml mn bn mo mp bi"><span id="7cdc" class="mq mr ir ml b be ms mt l mu mv">//push-temp/src/main.rs<br/>use aws_sdk_dynamodb::model::AttributeValue;<br/>use aws_sdk_dynamodb::Client;<br/>use lambda_http::{lambda_runtime::Error, service_fn, IntoResponse, Request};<br/><br/>extern crate temp_data;<br/>use temp_data::TempData;<br/><br/>use log::{debug, error};<br/>use serde::Serialize;<br/><br/>#[derive(Debug, Serialize)]<br/>struct SuccessResponse {<br/> pub body: String,<br/>}<br/><br/>#[derive(Debug, Serialize)]<br/>struct FailureResponse {<br/> pub body: String,<br/>}<br/><br/>// Implement Display for the Failure response so that we can then implement Error.<br/>impl std::fmt::Display for FailureResponse {<br/> fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {<br/> write!(f, "{}", self.body)<br/> }<br/>}<br/><br/>impl std::error::Error for FailureResponse {}</span></pre><p id="484d" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><code class="fe mi mj mk ml b">main()</code>函数为输入事件注册一个事件处理程序；我们的处理函数被命名为<code class="fe mi mj mk ml b">my_handler</code>:</p><pre class="kh ki kj kk gu mm ml mn bn mo mp bi"><span id="cd9e" class="mq mr ir ml b be ms mt l mu mv">//push-temp/src/main.rs (continued)<br/>#[tokio::main]<br/>async fn main() -&gt; Result&lt;(), Error&gt; {<br/> tracing_subscriber::fmt::init();<br/> debug!("logger has been set up");<br/> lambda_http::run(service_fn(my_handler)).await?;<br/> Ok(())<br/>}</span></pre><p id="8241" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们的<code class="fe mi mj mk ml b">my_handler()</code>函数将在传入请求到达时运行。我们的<code class="fe mi mj mk ml b">my_handler()</code>函数需要做几件事。首先，它从请求中获取传入的JSON，并将其解析为我们的结构<code class="fe mi mj mk ml b">request_struct</code>。注意，如果JSON解析失败，此时会返回一个错误值。</p><pre class="kh ki kj kk gu mm ml mn bn mo mp bi"><span id="1ab9" class="mq mr ir ml b be ms mt l mu mv">//push-temp/src/main.rs (continued)<br/>async fn my_handler(request: Request) -&gt; Result&lt;impl IntoResponse, Error&gt; {<br/>  debug!("handling a request, Request is: {:?}", request);<br/>  let request_json = match request.body() {<br/>    lambda_http::Body::Text(json_string) =&gt; json_string,<br/>    _ =&gt; "",<br/>  };<br/>  debug!("Request JSON is : {:?}", request_json);<br/>  let request_struct: TempData = serde_json::from_str(request_json)?;</span></pre><p id="c392" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">接下来，我们需要将这个结构推到DynamoDB表中。我选择将每个数据元素分离到它自己的DynamoDB属性中，而不是直接存储JSON。我们做了一些小的数据格式化，将日期作为一个单独的属性提取出来，用作我们的分区键。其余的结构值转换成Dynamo DB API的属性值。我们的错误处理对最终用户隐藏了特定于DynamoDB的错误消息，作为一个实现细节。</p><pre class="kh ki kj kk gu mm ml mn bn mo mp bi"><span id="de3b" class="mq mr ir ml b be ms mt l mu mv">//push-temp/src/main.rs (continued)<br/><br/>// set up as a DynamoDB client<br/>let config = aws_config::load_from_env().await;<br/>let client = Client::new(&amp;config);<br/><br/>// build the values that are stored in the DB<br/>let record_date_av = AttributeValue::S(request_struct.record_date.clone());<br/>let thermostat_on_av = AttributeValue::S(request_struct.thermostat_on.to_string());<br/>let temperature_av = AttributeValue::N(request_struct.temperature.to_string());<br/>let thermostat_value_av = AttributeValue::N(request_struct.thermostat_value.to_string());<br/>let record_day_av: AttributeValue = AttributeValue::S(request_struct.record_date[..10].to_string());<br/><br/>// Store our data in the DB<br/>let _resp = client<br/>  .put_item()<br/>  .table_name("Shop_Thermostat")<br/>  .item("Record_Day", record_day_av)<br/>  .item("Record_Date", record_date_av)<br/>  .item("Thermostat_On", thermostat_on_av)<br/>  .item("Temperature", temperature_av)<br/>  .item("Thermostat_Value", thermostat_value_av)<br/>  .send()<br/>  .await<br/>  .map_err(|err| {<br/>    error!("failed to put item in Shop_Thermostat, error: {}", err);<br/>    FailureResponse {<br/>      body: "The lambda encountered an error and your message was not saved".to_owned(),<br/>    }<br/>  })?;<br/>debug! {<br/> "Successfully stored item {:?}", &amp;request_struct<br/> }<br/>Ok("the lambda was successful".to_string())<br/>}</span></pre><p id="4969" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">为了将我们的自定义Lambda函数部署到AWS，我们需要创建一个名为“bootstrap”的可执行文件。我们需要Rust通过交叉编译到x86_64-unknown-linux-musl目标来构建我们的可执行文件——这是Lambda运行时所需要的。我喜欢使用<a class="ae ls" href="https://github.com/casey/just" rel="noopener ugc nofollow" target="_blank">和</a>作为命令运行器，并为构建创建了一个简单的<code class="fe mi mj mk ml b">justfile</code>，它运行我们需要的两个命令，以在本地目录中生成名为“bootstrap”的可执行文件。我使用<a class="ae ls" href="https://github.com/cross-rs/cross" rel="noopener ugc nofollow" target="_blank"> cross工具</a> (cargo install cross)，它为交叉编译环境下拉一个Docker容器。如果您不想使用本地docker容器，<a class="ae ls" href="https://docs.aws.amazon.com/sdk-for-rust/latest/dg/lambda.html" rel="noopener ugc nofollow" target="_blank"> AWS SDK </a>记录了cross的替代方法。最后，我们将生成的可执行文件复制到神奇的文件名“bootstrap”中，并将其存储在我们的项目根目录中。</p><pre class="kh ki kj kk gu mm ml mn bn mo mp bi"><span id="b958" class="mq mr ir ml b be ms mt l mu mv">#push-temp/justfile<br/>build: <br/> cross build - release - target x86_64-unknown-linux-musl<br/> cp target/x86_64-unknown-linux-musl/release/push_temp bootstrap</span></pre><p id="c76d" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们可以通过压缩引导文件并通过AWS web界面上传来手动部署我们的Lambda函数。但是AWS的其他部分需要绕过Lambda函数才能正常工作。我们需要为Lambda函数设置将数据插入DynamoDB表的权限，以及执行Lambda函数本身的权限。</p><p id="93ca" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">最近，AWS发布了一种创建<a class="ae ls" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-urls.html" rel="noopener ugc nofollow" target="_blank"> Lambda函数URL </a>的方法——一个直接连接到Lambda函数的HTTPS端点。对于像我们这样的简单用例，Lambda函数URL允许更简单的设置，并避免了创建API网关端点。如果API网关端点对您来说很重要，我建议您阅读<a class="ae ls" href="https://medium.com/aws-tip/crud-operations-with-rust-on-aws-lambda-part-2-bd1feae2554b" rel="noopener">这篇文章</a>，其中包括所需的额外步骤。我的方法是上述方法的简化版本。</p><p id="ac0c" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们可以使用AWS控制台来创建我们的Lambda函数、函数URL和dynamo db——但是它不太具有可重复性。相反，让我们使用Terraform来定义我们需要的可重复过程的各个部分。它也给了我们一个干净的方法，当我们想删除所有东西的时候。我将Terraform配置分成一组文件，用于我们部署的每个部分，所有文件都位于<code class="fe mi mj mk ml b">push_temp</code>机箱的根目录下。首先，<code class="fe mi mj mk ml b">variables.tf</code>文件将定义我们需要的几个共享值:</p><pre class="kh ki kj kk gu mm ml mn bn mo mp bi"><span id="d6fc" class="mq mr ir ml b be ms mt l mu mv">#push-temp/variables.tf<br/><br/># Input variable definitions, adjust for your needs<br/>variable "aws_region" {<br/>  description = "AWS region for all resources."<br/>  type = string<br/>  default = "us-east-2"<br/>}<br/><br/>variable "push_temp_bin_path" {<br/>  description = "The binary path for the lambda."<br/>  type = string<br/>  default = "./bootstrap"<br/>}</span></pre><p id="e464" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">然后，一个<code class="fe mi mj mk ml b">main.tf</code>文件建立了我们的环境:</p><pre class="kh ki kj kk gu mm ml mn bn mo mp bi"><span id="d1ff" class="mq mr ir ml b be ms mt l mu mv">#push-temp/main.tf<br/><br/>terraform {<br/>  required_providers {<br/>    aws = {<br/>      source = "hashicorp/aws"<br/>      version = "~&gt; 4.0"<br/>    }<br/>    archive = {<br/>      source = "hashicorp/archive"<br/>      version = "~&gt; 2.2.0"<br/>    }<br/>  }<br/><br/>  required_version = "~&gt; 1.0"<br/>}<br/><br/>provider "aws" {<br/>  region = var.aws_region<br/>}<br/><br/>data "aws_caller_identity" "current" {}</span></pre><p id="3a36" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">现在，我们可以设置需要部署的每个资源。首先，我们创建DynamoDB表。注意，我们将使用的两列定义为键，其余的在我们插入数据时动态创建。我们的键是字符串，所以我们使用type = "S "来定义它们。我们以尽可能低的资源使用率初始化该表，因为我们有一个小的Raspberry Pi向我们发送数据。</p><pre class="kh ki kj kk gu mm ml mn bn mo mp bi"><span id="19b5" class="mq mr ir ml b be ms mt l mu mv">#push-temp/dynamo.tf<br/><br/># aws_dynamodb_table.shop-thermostat-table:<br/>resource "aws_dynamodb_table" "shop-thermostat-table" {<br/>  hash_key = "Record_Day"<br/>  name = "Shop_Thermostat"<br/>  range_key = "Record_Date"<br/>  billing_mode = "PAY_PER_REQUEST"<br/>  read_capacity = 0<br/>  write_capacity = 0<br/>  <br/>  attribute {<br/>    name = "Record_Day"<br/>    type = "S"<br/>  }<br/><br/>  attribute {<br/>    name = "Record_Date"<br/>    type = "S"<br/>  }<br/>}</span></pre><p id="c5d5" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">接下来，我们可以定义我们的lambda函数。我们需要提供。我们的可执行文件到Terraform的zip文件，用于设置Lambda函数的初始部署。我不想使用Terraform在每次应用程序更改时部署我们的可执行文件——terra form不是CI/CD工具。但是我们需要一些东西来创造这个功能。因此，在成功创建所有资源之后，我们将使用不同的方法来部署应用程序更新。</p><p id="d757" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们还设置了一个Lambda函数URL作为公共可达端点。</p><pre class="kh ki kj kk gu mm ml mn bn mo mp bi"><span id="0e1a" class="mq mr ir ml b be ms mt l mu mv">#push-temp/lambdas.tf<br/><br/># Here we grab the compiled executable and use the archive_file package<br/># to convert it into the .zip file we need.<br/>data "archive_file" "push_temp_lambda_archive" {<br/>  type = "zip"<br/>  source_file = var.push_temp_bin_path<br/>  output_path = "bootstrap.zip"<br/>}<br/><br/># Here we set up an IAM role for our Lambda function<br/>resource "aws_iam_role" "push_temp_lambda_execution_role" {<br/>  assume_role_policy = &lt;&lt;EOF<br/>  {<br/>    "Version": "2012–10–17",<br/>    "Statement": [<br/>    {<br/>      "Action": "sts:AssumeRole",<br/>      "Principal": {<br/>        "Service": "lambda.amazonaws.com"<br/>      },<br/>      "Effect": "Allow",<br/>      "Sid": ""<br/>    }<br/>  ]<br/>}<br/>EOF<br/>}<br/><br/># Here we attach a permission to execute a lambda function to our role<br/>resource "aws_iam_role_policy_attachment" "push_temp_lambda_execution_policy" {<br/>  role = aws_iam_role.push_temp_lambda_execution_role.name<br/>  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"<br/>}<br/><br/># Here is the definition of our lambda function <br/>resource "aws_lambda_function" "push_temp_lambda" {<br/>  function_name = "PushTemp"<br/>  source_code_hash = data.archive_file.push_temp_lambda_archive.output_base64sha256<br/>  filename = data.archive_file.push_temp_lambda_archive.output_path<br/>  handler = "func"<br/>  runtime = "provided"<br/>  <br/>  # here we enable debug logging for our Rust run-time environment. We would change<br/>  # this to something less verbose for production.<br/> environment {<br/>   variables = {<br/>     "RUST_LOG" = "debug"<br/>   }<br/> }<br/> <br/> #This attaches the role defined above to this lambda function<br/> role = aws_iam_role.push_temp_lambda_execution_role.arn<br/>}<br/><br/>// Add lambda -&gt; DynamoDB policies to the lambda execution role<br/>resource "aws_iam_role_policy" "write_db_policy" {<br/>  name = "lambda_write_db_policy"<br/>  role = aws_iam_role.push_temp_lambda_execution_role.name<br/>  policy = &lt;&lt;EOF<br/>{<br/>  "Version": "2012–10–17",<br/>  "Statement": [<br/>   {<br/>     "Sid": "",<br/>     "Action": [<br/>       "dynamodb:PutItem"<br/>     ],<br/>     "Effect": "Allow",<br/>     "Resource": "arn:aws:dynamodb: :${var.aws_region}::${data.aws_caller_identity.current.account_id}:table/Shop_Thermostat"<br/>   }<br/> ]<br/>}<br/>EOF<br/>}<br/><br/>// The Lambda Function URL that allows direct access to our function<br/>resource "aws_lambda_function_url" "push_temp_function" {<br/>   function_name = aws_lambda_function.push_temp_lambda.function_name<br/>   authorization_type = "NONE"<br/>}</span></pre><p id="53f3" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">最后，我们创建一个输出文件，这样我们就可以获得调用函数的API端点:</p><pre class="kh ki kj kk gu mm ml mn bn mo mp bi"><span id="a76c" class="mq mr ir ml b be ms mt l mu mv">#push-temp/output.tf<br/><br/># Output value definitions<br/>output "invoke_url" {<br/>  value = aws_lambda_function_url.push_temp_function.function_url<br/>}</span></pre><p id="f4c0" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">咻，都做完了！一个“terraform init &amp; terraform apply”将创建所有的东西，上传我们新编译的函数，并为测试做好准备！</p><p id="4d5f" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我们可以通过curl调用外部端点，用terraform在apply上输出的值替换下面的<endpoint>。</endpoint></p><pre class="kh ki kj kk gu mm ml mn bn mo mp bi"><span id="6c84" class="mq mr ir ml b be ms mt l mu mv">curl -X POST https://&lt;endpoint&gt;.lambda-url.us-east-2.on.aws/ \<br/>-H 'Content-Type: application/json' \<br/>-d '{"record_date":"2022–02–03T13:22:22","thermostat_on":true,"temperature":"65","thermostat_value":"64"}'</span></pre><p id="8b74" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">您可以使用DynamoDB控制台查看数据库中的新记录:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj mw"><img src="../Images/b4358e5da76c812854126aea0b6775d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*rtot0Iugu4s8oeVigsbkKw.png"/></div></figure><p id="860d" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">为了在初始部署后对代码进行应用程序更新，我在justfile中为部署更新的应用程序所需的命令创建了一个部署目标。这些命令依赖于为Lambda函数所在的相同区域安装和配置的AWS CLI。</p><pre class="kh ki kj kk gu mm ml mn bn mo mp bi"><span id="a056" class="mq mr ir ml b be ms mt l mu mv">#push-temp/justfile (continued)<br/>deploy: build<br/>  cp target/x86_64-unknown-linux-musl/release/push_temp bootstrap<br/>  zip bootstrap.zip bootstrap<br/>  aws lambda update-function-code - function-name PushTemp - zip-file fileb://./bootstrap.zip</span></pre><p id="f9e9" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">既然我们有了一个可以接受带有JSON数据的HTTP Post并在DynamoDB中持久化它的工作后端，我们就可以创建一个Rust前端来发送这个请求。我们在主应用程序中的<code class="fe mi mj mk ml b">Cargo.toml</code>再次引用了我们共享的TempData crate，这样我们就可以使用共享的struct。</p><pre class="kh ki kj kk gu mm ml mn bn mo mp bi"><span id="38b9" class="mq mr ir ml b be ms mt l mu mv">[dependencies]<br/>temp-data = { path="temp-data" }</span></pre><p id="1ad6" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我创建了一个函数<code class="fe mi mj mk ml b">store_temp_data()</code>,每当Rust应用程序中有新数据时就使用它。我传入数据和端点URL，它们在其他地方的运行时配置中。我将<code class="fe mi mj mk ml b">reqwest</code>箱用于基本的HTTP客户端。我们的函数从初始化客户端和构建我们前面看到的请求结构TempData开始。我们还获取当前时间，并将其转换为RFC3339格式。</p><pre class="kh ki kj kk gu mm ml mn bn mo mp bi"><span id="20c9" class="mq mr ir ml b be ms mt l mu mv">//thermostat-pi/src/send_temp.rs<br/><br/>use reqwest;<br/>use reqwest::Error;<br/>use time::format_description::well_known::Rfc3339;<br/>use time::macros::offset;<br/>use time::OffsetDateTime;<br/><br/>extern crate temp_data;<br/>use temp_data::TempData;<br/><br/>pub async fn store_temp_data(<br/>  thermostat_on: bool, <br/>  current_temp: f32,<br/>  thermostat_value: i16,<br/>  aws_url: &amp;str,<br/>) -&gt; Result&lt;(), Error&gt; {<br/>  let client = reqwest::Client::new();<br/>  <br/>  // Get the current time, offset to my timezone<br/>  let now = OffsetDateTime::now_utc().to_offset(offset!(-6));<br/>  let now = now.format(&amp;Rfc3339).unwrap();<br/><br/>  let body = TempData {<br/>    record_date: now,<br/>    thermostat_on: thermostat_on,<br/>    temperature: current_temp<br/>    thermostat_value: thermostat_value<br/>  };</span></pre><p id="e778" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">接下来，我们将请求发送到端点，沿途将其序列化为JSON，并处理响应。我选择记录错误并在出错时返回OK，因为这对于我们的应用程序来说是一个不重要的函数。</p><pre class="kh ki kj kk gu mm ml mn bn mo mp bi"><span id="c989" class="mq mr ir ml b be ms mt l mu mv">//thermostat-pi/src/send_temp.rs (continued) <br/><br/>  let response = client<br/>    .post(aws_url)<br/>    .json(&amp;body)<br/>    .send()<br/>    .await;<br/><br/>  match response {<br/>    Ok(r) =&gt; {<br/>      tracing::debug!("response: {:?}", r);<br/>    }<br/>    Err(e) =&gt; {<br/>      tracing::error!("Error sending to AWS, {}", e);<br/>    }<br/>  }<br/><br/>  Ok(())<br/>}</span></pre><p id="fe57" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">就是这样！对于我们要完成的五件事，以下是我们的要点:</p><ol class=""><li id="2619" class="lt lu ir ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">我们在一个单独的目录中定义了TempData结构，它有自己的<code class="fe mi mj mk ml b">Cargo.toml</code>，为我们的客户端和服务器应用程序之间的API提供了一个公共的可引用结构。利用struct在客户机和服务器之间定义一个基于JSON的接口，并使用<code class="fe mi mj mk ml b">serde</code>在两端序列化和反序列化我们的TempData结构，在我们的项目中设置和保持同步是很简单的。</li><li id="233e" class="lt lu ir ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">AWS Rust SDK为Rust提供了易于使用的Lambda定义和DynamoDB访问接口。Rust以其速度和低内存占用为Lambda提供了一个很好的执行环境。</li><li id="2363" class="lt lu ir ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">Terraform可以很好地构建我们需要的所有AWS组件，并设置将所有组件粘合在一起所需的权限。</li><li id="9590" class="lt lu ir ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">使用AWS CLI是按需更新Lambda可执行文件的简单方法。</li><li id="c4ba" class="lt lu ir ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><code class="fe mi mj mk ml b">reqwest</code> crate为我们提供了一种为客户端应用程序发送HTTP请求的简单方法。</li></ol><p id="742b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">我希望这对你的生锈之旅有用！如果你有什么改进的想法，请在评论中反馈。</p></div></div>    
</body>
</html>