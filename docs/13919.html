<html>
<head>
<title>Jetpack Compose Pagination</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack撰写分页</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/jetpack-compose-pagination-287ea6e782e3?source=collection_archive---------0-----------------------#2022-10-14">https://betterprogramming.pub/jetpack-compose-pagination-287ea6e782e3?source=collection_archive---------0-----------------------#2022-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="861a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Jetpack Compose中的Paging 3库实现分页</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/36baf5675e197be5931203c0a5113924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EOAERgm_Z6G2l6u7j9xPfA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">本图中使用的Jetpack Compose徽标是由谷歌创建的官方徽标<a class="ae kv" href="https://android-developers.googleblog.com/2020/08/announcing-jetpack-compose-alpha.html" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="edaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从服务器获取一长串数据是一项非常昂贵的操作。需要的时间太长，内存太大。在这些情况下，后端会将列表分成页面。这就是所谓的分页。</p><p id="7e1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们都熟悉<code class="fe ls lt lu lv b">androidx.paging</code>图书馆。最新版本是<code class="fe ls lt lu lv b">Paging 3</code>。我将向你展示如何使用Jetpack Compose中的<code class="fe ls lt lu lv b">Paging 3</code>库。</p><blockquote class="lw lx ly"><p id="8fb8" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">"分页库帮助您从本地存储或通过网络加载和显示较大数据集中的数据页。这种方法允许您的应用程序更有效地使用网络带宽和系统资源。</p><p id="0c6a" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">分页库的组件旨在适应推荐的Android应用程序架构，与其他Jetpack组件干净地集成，并提供一流的Kotlin支持。“根据<a class="ae kv" href="https://developer.android.com/topic/libraries/architecture/paging/v3-overview" rel="noopener ugc nofollow" target="_blank">分页官方文档</a></p></blockquote><p id="6d8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从添加依赖项开始:</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="ad7e" class="mh mi iq lv b gy mj mk l ml mm">implementation "androidx.paging:paging-compose:1.0.0-alpha16"</span></pre><p id="f3d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>检查是否有此依赖关系的更新版本。</p><p id="5296" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要一些数据来展示分页。为此，我们将使用美味的API。在<a class="ae kv" href="https://rapidapi.com/apidojo/api/tasty/" rel="noopener ugc nofollow" target="_blank">这个链接</a>，你可以找到我们将要使用的API。</p><p id="8930" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了分页库之外，我正在使用Hilt、retrieve、OkHttp、Moshi、Coil和伴奏者的占位符。确保添加所有这些库。我的GitHub repo的链接会在文章末尾。</p><p id="6b90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们需要实现的第一件事是一个组件，它将成为我们的数据源。根据我们加载数据的位置，我们可以在这里扩展两种类型的数据源:</p><ul class=""><li id="9a47" class="mn mo iq ky b kz la lc ld lf mp lj mq ln mr lr ms mt mu mv bi translated"><code class="fe ls lt lu lv b">RemoteMediator&lt;Key : Any, Value : Any&gt;</code> —用于将数据从远程数据源增量加载到本地数据源。</li><li id="f27c" class="mn mo iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><code class="fe ls lt lu lv b">PagingSource&lt;Key: Any, Value: Any&gt;</code> —它定义了数据源以及如何从该数据源中检索数据。它可以从任何单一来源加载数据，包括网络和本地数据库。</li></ul><p id="3f9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，为了获取你想在UI中显示的数据，你将使用<code class="fe ls lt lu lv b">PagingSource</code>，如果你想从网络上增量加载数据到本地数据库，你将使用<code class="fe ls lt lu lv b">RemoteMediator</code>。</p><p id="ebc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将使用<code class="fe ls lt lu lv b">PagingSource</code>。如果你想了解更多关于<code class="fe ls lt lu lv b">RemoteMediator</code>的信息，看看这个上的<a class="ae kv" href="https://developer.android.com/reference/kotlin/androidx/paging/RemoteMediator" rel="noopener ugc nofollow" target="_blank">。下面是我们实现的<code class="fe ls lt lu lv b">PagingSource</code>:</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="af85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通过将<code class="fe ls lt lu lv b">Int</code>作为<code class="fe ls lt lu lv b">key</code>的一种类型，将<code class="fe ls lt lu lv b">RecipeModel</code>作为<code class="fe ls lt lu lv b">value</code>的一种类型来扩展<code class="fe ls lt lu lv b">PagingSource</code>。<code class="fe ls lt lu lv b">RecipeModel</code>就是我们从这个来源载入的东西。</p><p id="9611" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要实现两个函数，<code class="fe ls lt lu lv b">getRefreshKey</code>和<code class="fe ls lt lu lv b">load</code>。以下是需要它们的原因:</p><ul class=""><li id="4b71" class="mn mo iq ky b kz la lc ld lf mp lj mq ln mr lr ms mt mu mv bi translated"><code class="fe ls lt lu lv b">getRefreshKey</code> —由于此<code class="fe ls lt lu lv b">PagingSource</code>失效，为下一个<code class="fe ls lt lu lv b">PagingSource</code>提供一个用于初始加载的密钥。密钥通过<code class="fe ls lt lu lv b">LoadParams.key</code>提供给负载。函数的参数<code class="fe ls lt lu lv b">state: PagingState&lt;Key, Value&gt;</code>是获取数据的当前状态，它包括加载的数据页(<code class="fe ls lt lu lv b">pages: List&lt;Page&lt;Key, Value&gt;&gt;</code>)、列表中最近访问的索引(<code class="fe ls lt lu lv b">anchorPosition: Int?</code>)和初始化<code class="fe ls lt lu lv b">PagingData</code>流时给出的范围(<code class="fe ls lt lu lv b">config: PagingConfig</code>，我们将在后面详细讨论)。</li><li id="cf73" class="mn mo iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><code class="fe ls lt lu lv b">load</code> —从数据库或网络触发数据的异步加载。函数的参数<code class="fe ls lt lu lv b">params: LoadParams&lt;Key&gt;</code>是加载请求的参数，它包含请求加载的项目数量(<code class="fe ls lt lu lv b">loadSize: Int</code>)，如果占位符被启用(<code class="fe ls lt lu lv b">placeholdersEnabled: Boolean</code>)，以及要加载页面的键(<code class="fe ls lt lu lv b">key: Int</code>，在<code class="fe ls lt lu lv b">getRefreshKey</code>函数中解释)。这个函数的结果是一个密封的类<code class="fe ls lt lu lv b">LoadResult&lt;Key, Value&gt;</code>。</li></ul><p id="d348" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">LoadParams</code>是一个密封类，它有三个子类:</p><ul class=""><li id="c52c" class="mn mo iq ky b kz la lc ld lf mp lj mq ln mr lr ms mt mu mv bi translated"><code class="fe ls lt lu lv b">Refresh</code> —代表初始加载请求</li><li id="49d6" class="mn mo iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><code class="fe ls lt lu lv b">Append</code> —将附加到列表末尾的加载请求</li><li id="8dd0" class="mn mo iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><code class="fe ls lt lu lv b">Prepend</code> —加载请求，该请求将被添加到列表的开头</li></ul><p id="a634" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过检查参数的实际类型，我们可以确定请求的类型。</p><p id="68db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也有三个子类。它们是这样的:</p><ul class=""><li id="b122" class="mn mo iq ky b kz la lc ld lf mp lj mq ln mr lr ms mt mu mv bi translated"><code class="fe ls lt lu lv b">Error</code> —表示错误结果</li><li id="1280" class="mn mo iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><code class="fe ls lt lu lv b">Invalid</code> —代表无效结果</li><li id="327b" class="mn mo iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><code class="fe ls lt lu lv b">Page</code> —代表成功的结果</li></ul><p id="07ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意我们是如何实现这些功能的。在<code class="fe ls lt lu lv b">getRefreshKey</code>中，我们只是返回列表中最近访问的索引。在<code class="fe ls lt lu lv b">load</code>中，我们调用存储库函数从API获取数据，并根据占位符是否启用返回结果。</p><p id="201a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当占位符被启用时，我们将在加载的数据之后有空元素的<code class="fe ls lt lu lv b">itemsAfter</code>计数，在加载的数据之前有空元素的<code class="fe ls lt lu lv b">itemsBefore</code>计数。稍后，我们可以使用这些元素来显示占位符。如果没有启用，我们就不会有任何空元素。</p><p id="6f3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们将有一个最大的<code class="fe ls lt lu lv b">loadedSize</code>的占位符后，最小数量的项目留下来加载。API中的元素总数，所以对于一些不同的API，这个逻辑可能会有所不同。</p><p id="3257" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们实现我们的<code class="fe ls lt lu lv b">MainViewModel</code>。下面是代码的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ad00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的<code class="fe ls lt lu lv b">ViewModel</code>中，我们创建了一个<code class="fe ls lt lu lv b">PagingData</code>流。<code class="fe ls lt lu lv b">Pager</code>是<code class="fe ls lt lu lv b">PagingData</code>的反应流的构造器。构造函数接受三个参数:</p><ul class=""><li id="858f" class="mn mo iq ky b kz la lc ld lf mp lj mq ln mr lr ms mt mu mv bi translated"><code class="fe ls lt lu lv b">config: PagingConfig</code>—<code class="fe ls lt lu lv b">Paging</code>的配置。接受一个强制参数和几个可选参数。一个强制参数是<code class="fe ls lt lu lv b">pageSize: Int</code>，它是从<code class="fe ls lt lu lv b">PagingSource</code>一次加载的项目数量。一些有趣的可选参数是<code class="fe ls lt lu lv b">enablePlaceholders: Boolean</code>和<code class="fe ls lt lu lv b">jumpThreshold: Int</code></li><li id="378c" class="mn mo iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><code class="fe ls lt lu lv b">initialKey: Key</code>—<code class="fe ls lt lu lv b">PagingSource</code>的初始密钥</li><li id="3a82" class="mn mo iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><code class="fe ls lt lu lv b">pagingSourceFactory: () -&gt; PagingSource&lt;Key, Value&gt;</code> —应该创建并返回<code class="fe ls lt lu lv b">PagingSource</code>实例的lambda工厂。</li></ul><p id="f889" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Pager</code>多了一个有四个参数的构造函数。前三个是一样的，第四个参数是<code class="fe ls lt lu lv b">remoteMediator: RemoteMediator&lt;Key, Value&gt;?</code>，我们前面解释过了。</p><p id="ee0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b">.flow</code>，我们创建一个<code class="fe ls lt lu lv b">PagingData</code>流，使用<code class="fe ls lt lu lv b">.cachedIn</code>，我们缓存<code class="fe ls lt lu lv b">PagingData</code>，这样来自这个流的任何下游集合将共享同一个<code class="fe ls lt lu lv b">PagingData</code>。</p><p id="b96b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来就是打造一个<code class="fe ls lt lu lv b">MainScreen</code>。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="b5ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们使用<code class="fe ls lt lu lv b">collectAsLazyPagingItems</code>从<code class="fe ls lt lu lv b">PagingData</code>的流中收集值，并创建一个<code class="fe ls lt lu lv b">LazyPagingItems</code>的实例。<code class="fe ls lt lu lv b">LazyPagingItems</code>负责从<code class="fe ls lt lu lv b">PagingData</code>的流程中访问数据。有了这个实例，我们可以访问加载状态、触发刷新、获取项目计数、重试会导致<code class="fe ls lt lu lv b">LoadState.Error</code>的失败加载请求，等等。</p><p id="d1d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">LazyPagingItems</code>实例中，我们可以访问<code class="fe ls lt lu lv b">loadState: CombinedLoadStates</code>，它代表<code class="fe ls lt lu lv b">refresh</code>、<code class="fe ls lt lu lv b">prepend</code>和<code class="fe ls lt lu lv b">append</code>的负载状态。<code class="fe ls lt lu lv b">LoadState</code>是一个<code class="fe ls lt lu lv b">PagedList</code>负载的状态；可以是<code class="fe ls lt lu lv b">NotLoading</code>、<code class="fe ls lt lu lv b">Loading</code>、<code class="fe ls lt lu lv b">Error</code>。<code class="fe ls lt lu lv b">NotLoading</code>有一个字段<code class="fe ls lt lu lv b">endOfPaginationReached: Boolean</code>，而<code class="fe ls lt lu lv b">Error</code>有<code class="fe ls lt lu lv b">error: Throwable</code>。</p><p id="9b98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查这些状态，我们可以选择是否应该显示一个加载微调，一个错误消息，或者什么都不做。</p><p id="47c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe ls lt lu lv b">items</code> composable，我们传递<code class="fe ls lt lu lv b">LazyPagingItems</code>，对于每一行，我们调用<code class="fe ls lt lu lv b">RecipesRow</code> composable。</p><p id="f158" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">RecipesRow</code>是一张包含图片、姓名和评分的卡片。如果当前的<code class="fe ls lt lu lv b">recipeModel</code>为空，这意味着它是一个占位符，将是我们传递给<code class="fe ls lt lu lv b">placeholder</code>修改器的检查。如果你对<code class="fe ls lt lu lv b">Accompanist’s placeholder</code>不熟悉，或者你想提醒自己，看一看<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/jetpack-compose-swipe-to-refresh-1d93775970e8">我以前的一篇文章</a>因为我在这里不会解释那个。</p><p id="62e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文到此为止。我希望你学到了新的东西，而且很有趣。如果你有任何疑问，请随时提问。</p><p id="4425" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">源代码可以在<a class="ae kv" href="https://github.com/Giga99/MediumRepos" rel="noopener ugc nofollow" target="_blank">我的GitHub repo </a>中找到。</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="d08d" class="mh mi iq lv b gy mj mk l ml mm"><strong class="lv ir">Want to Connect?</strong></span><span id="16b1" class="mh mi iq lv b gy nd mk l ml mm"><a class="ae kv" href="https://github.com/Giga99" rel="noopener ugc nofollow" target="_blank">GitHub</a><br/><a class="ae kv" href="https://www.linkedin.com/in/igor-stevanovic/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><a class="ae kv" href="https://twitter.com/igor_s1999" rel="noopener ugc nofollow" target="_blank"><br/>Twitter</a><br/><a class="ae kv" href="https://giga99.github.io/portfolio-website/" rel="noopener ugc nofollow" target="_blank">Portfolio website</a></span></pre><p id="7785" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想了解更多关于Jetpack Compose的信息，请阅读以下文章:</p><ul class=""><li id="0885" class="mn mo iq ky b kz la lc ld lf mp lj mq ln mr lr ms mt mu mv bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/implement-horizontal-and-vertical-viewpager-in-jetpack-compose-a7a91f2ac746">在Jetpack Compose中实现水平和垂直view pager</a></li><li id="3152" class="mn mo iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><a class="ae kv" href="https://medium.com/better-programming/build-a-camera-android-app-in-jetpack-compose-using-camerax-4d5dfbfbe8ec" rel="noopener">使用CameraX在Jetpack Compose中构建一个相机安卓应用</a></li><li id="2a03" class="mn mo iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/jetpack-compose-swipe-to-refresh-1d93775970e8"> Jetpack撰写刷卡刷新</a></li></ul><h1 id="4a79" class="ne mi iq bd nf ng nh ni nj nk nl nm nn jw no jx np jz nq ka nr kc ns kd nt nu bi translated">资源</h1><p id="10f9" class="pw-post-body-paragraph kw kx iq ky b kz nv jr lb lc nw ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated"><a class="ae kv" href="https://developer.android.com/topic/libraries/architecture/paging/v3-overview" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/topic/libraries/architecture/paging/v3-概述</a></p><p id="57e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://developer.android.com/reference/kotlin/androidx/paging/Pager" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/reference/kot Lin/Android x/paging/Pager</a></p><p id="ff1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://developer.android.com/reference/kotlin/androidx/paging/PagingSource" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/reference/kot Lin/Android x/paging/paging source</a></p><p id="b3a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://developer.android.com/reference/kotlin/androidx/paging/RemoteMediator" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/reference/kot Lin/Android x/paging/remote mediator</a></p></div></div>    
</body>
</html>