<html>
<head>
<title>Implementing a Page Overlay Loader With Angular CDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用角度CDK实现页面覆盖加载器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-a-global-overlay-loader-with-angular-e31ab4665cb1?source=collection_archive---------5-----------------------#2022-04-28">https://betterprogramming.pub/implementing-a-global-overlay-loader-with-angular-e31ab4665cb1?source=collection_archive---------5-----------------------#2022-04-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9194" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为你的页面添加一个加载器，对UX友好</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ca20a69296d05705d7691ad3506ac424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9QHbm23Gw-VmMe6J.gif"/></div></div></figure><p id="cfbc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在大多数web应用程序中，数据是从服务器加载的。它可以是图像、视频、纯文本或任何其他类型的数据。在检索该信息时，用户需要被告知一个视觉指示器。</p><p id="27b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是为什么这篇文章是关于在整个页面的顶部添加一个组件，通知用户并防止加载过程中的交互。</p><h1 id="0b5e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">创建要加载的组件</h1><p id="987f" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们将重复使用来自<a class="ae mk" href="https://material.angular.io/components/table/overview" rel="noopener ugc nofollow" target="_blank">角形材料</a>的桌子作为示例。</p><p id="44d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">克隆组件后，让我们使用这个函数模拟一些网络延迟。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a05d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以用5000毫秒调用这个函数，现在我们有了一个添加加载程序的借口🤓</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/2bd8a5e27ad9cbcbc847e867ded61737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*i8lHKBuIRTWO_8GxPCKmjQ.gif"/></div></div></figure><h1 id="59e7" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">创建加载器服务</h1><p id="dba3" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们的方法包括使用<a class="ae mk" href="https://material.angular.io/cdk/overlay/overview" rel="noopener ugc nofollow" target="_blank">角度材质覆盖</a>在整个页面的顶部添加一个组件。</p><p id="c30c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，让我们创建负责显示加载程序的<code class="fe mo mp mq mr b">LoaderComponent</code>。我们将使用来自<a class="ae mk" href="https://loading.io/css/" rel="noopener ugc nofollow" target="_blank"> loading.io </a>的加载器作为例子。</p><p id="73a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了将<code class="fe mo mp mq mr b">LoaderComponent</code>显示为覆盖图，我们首先需要注入角度材质覆盖服务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="f407" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们<strong class="kt ir">通过使用覆盖服务创建一个覆盖图</strong>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="0204" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可以使用<code class="fe mo mp mq mr b">positionStrategy</code>属性定制覆盖图，将组件放置在页面的中央。此外，<code class="fe mo mp mq mr b">hasBackdrop</code>可用于添加灰色背景，防止用户在加载时进行交互。</p><p id="7099" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们需要使用下面的方法将<code class="fe mo mp mq mr b">LoaderComponent</code>附加到覆盖层上，或者从覆盖层上分离。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a5b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们可以在服务中封装代码，使逻辑更容易重用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="c4b9" class="ms lo iq bd lp mt mu dn lt mv mw dp lx la mx my lz le mz na mb li nb nc md nd bi translated">使用加载器服务</h2><p id="fe42" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">就像我们对覆盖服务所做的那样，让我们将<code class="fe mo mp mq mr b">LoaderService</code>注入到要加载的组件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="ef75" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们调用方法<code class="fe mo mp mq mr b">showLoader</code>，然后我们订阅请求，最后，一旦收到响应，我们<code class="fe mo mp mq mr b">hideLoader</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="145d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">塔达姆🎉</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/46606c465cd49aaf4d9beba42280f8d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0vr06t3dWH7OVWXnuxef1A.gif"/></div></div></figure><h1 id="f8c0" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">通过反应式界面改善我们的服务</h1><p id="263f" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">既然加载器已经可以工作了，是时候改进代码了。(至少)有两个方面需要改进。首先，我们需要在所有要加载的组件中实现显示/隐藏逻辑。这可能会导致在加载时创建更多组件时出现许多样板代码。</p><p id="3061" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二个是建议尽可能少的手动订阅Observable。关于这个话题的更多信息，我建议阅读Angular中的文章<a class="ae mk" href="https://indepth.dev/posts/1279/rxjs-in-angular-when-to-subscribe-rarely" rel="noopener ugc nofollow" target="_blank"> RxJS:何时订阅？(很少)</a>来自迈克尔·洛顿。</p><p id="6e2b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决第一个问题，我们将创建一个负责显示/隐藏逻辑的<a class="ae mk" href="https://rxjs.dev/guide/operators" rel="noopener ugc nofollow" target="_blank"> RxJs操作符</a>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="3aa3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以应用我们的操作符，并删除组件中的<code class="fe mo mp mq mr b">showLoader</code>和<code class="fe mo mp mq mr b">hideLoader</code>的使用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="d0ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们将使用<a class="ae mk" href="https://angular.io/api/common/AsyncPipe#asyncpipe" rel="noopener ugc nofollow" target="_blank">异步管道</a>来移除手动订阅。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="11bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们用赋值替换订阅。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="b90d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">下一步是什么</h1><p id="4ee1" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们刚刚完成了页面加载器的构建。这对于让用户等待和阻止与其他组件的交互非常有帮助。然而，阻止用户与其他组件交互可能有点令人沮丧。这就是为什么我建议阅读关于将页面加载器转换成组件加载器的下一篇文章。</p><div class="ne nf gp gr ng nh"><a href="https://medium.com/@lambda_dev/implementing-a-component-overlay-loader-with-angular-cdk-21c071f53b30" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">用角度CDK实现组件覆盖加载器</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">向您的组件添加加载程序，成为UX友好型</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kp nh"/></div></div></a></div><p id="22f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">否则，如果你不想在你的应用程序中维护这个逻辑，我们构建了<a class="ae mk" href="https://github.com/Silvere112/ngx-load" rel="noopener ugc nofollow" target="_blank"> ngx-load </a>，一个为你做这项工作的库。</p><pre class="kg kh ki kj gt nw mr nx ny aw nz bi"><span id="e752" class="ms lo iq mr b gy oa ob l oc od">You can also connect with me <a class="ae mk" href="https://twitter.com/lambda_dev" rel="noopener ugc nofollow" target="_blank">Twitter</a> to read more about Angular!</span></pre></div></div>    
</body>
</html>