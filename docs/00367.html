<html>
<head>
<title>How to Create an Audio Unit Extension from Scratch in Xcode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Xcode中从头开始创建音频单元扩展</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-audio-unit-extension-from-scratch-77abee79d12?source=collection_archive---------0-----------------------#2019-05-04">https://betterprogramming.pub/create-audio-unit-extension-from-scratch-77abee79d12?source=collection_archive---------0-----------------------#2019-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fe54" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">循序渐进的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/299bd4188ff46eed6195735e712ee9da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NdBiHIETR0i2I2gRMuamyA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/photos/kuUM2M1Mvhg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> chuttersnap </a>在<a class="ae ky" href="https://unsplash.com/search/photos/speakers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f465" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于音频单元扩展的资源并不多。有一个苹果的样本项目，一些信息，WWDC谈到它:</p><p id="08f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2015/508/" rel="noopener ugc nofollow" target="_blank">https://developer.apple.com/videos/play/wwdc2015/508/</a></p><p id="b810" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于Audio Unit V3的基本思想是，默认情况下，它作为独立的进程(扩展服务进程)运行，并使用IPC(进程间通信)与主机应用程序通信。这种方法有优点也有缺点(它更安全，但是它增加了开销，每次调用大约40u秒，这在处理非常低的延迟时可能会有问题)。</p><p id="9eac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更容易开发，并且在OS X上IPC开销太高的情况下，如果主机和音频单元都指定了该选项，则有一个在进程中运行音频单元的选项。我将使用这种方法，并在后面展示如何去做。</p><p id="df83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的插件只会改变音量(当然，在现实生活中你不需要一个AU插件——让我们保持简单！).</p><p id="adcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将拥有<strong class="lb iu">主机应用、扩展和框架</strong>。该框架将包含音频单元代码。有了这个框架，我们就能够将它与扩展和我们的主机应用程序链接起来，以便在开发过程中轻松调试(扩展主二进制文件不能加载到另一个进程中)。</p><p id="f010" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们首先创建宿主应用程序。这也将是扩展的包含应用程序。</p><h2 id="8170" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">创建一个新的macOS CocoaApp。叫它AUHost吧。</h2><p id="aab9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">将音频文件拖到项目中。(我使用的是一个名为“z.wav”的文件。)</p><p id="a055" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mt mu mv mw b">AUHost</code>组中，创建<code class="fe mt mu mv mw b">AudioPlayer.swift.</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ac09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe mt mu mv mw b">ViewController.swift</code>更新如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8e87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保您可以听到正在播放的文件！</p><h2 id="951c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">现在，让我们创建扩展。</strong></h2><p id="e474" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">转到文件新建/目标，选择音频单元扩展，更新产品名称(即“VolumePlugin”)、子类型代码(使用“Demo”)。和制造商代码(也使用“演示”)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/ffb665dcbdf673713d347ec6abe0cef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*n3laPUk-_iwmz5MfksubLA.jpeg"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/12f72e40bf9b6c293fbe57c5fb5dfeb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jkM2zDoAvm0SlogcO-9VUg.jpeg"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/46b4876a04860222d35d7033f6bdeaca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eWJS0gQeBan1P_vi8bgOlw.jpeg"/></div></div></figure><p id="a5a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在创建一个共享框架，我们将音频单元插件文件放在这里。</p><p id="0673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到文件/新建/目标…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/4d7d52876e39db6cdce0da7ac8eb44ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vGCytsPzuxkqA2CmrLSefw.jpeg"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/f8da4b32fa5c9a1b2261fcf1d3d1fe68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NaBwemlI4_puRMAORTl_rQ.jpeg"/></div></div></figure><p id="79f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们重构扩展和框架之前的项目结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/7edbb886257eb05f9f1cea554659df85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*rGEb1sSI27dGhspJk0RueA.jpeg"/></div></figure><p id="c923" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们使用进程内加载，我们需要将所有扩展的代码移动到框架中，并更新扩展的<code class="fe mt mu mv mw b">Info.plist</code>。</p><p id="5225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将文件从<code class="fe mt mu mv mw b">VolumePlugin</code>移动到<code class="fe mt mu mv mw b">AUFramework</code>中，并根据需要通过更新其目标成员来链接它们。</p><p id="32e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">AudioUnitViewController.xib</code>应该像这样把外延和框架都联系起来:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/4b00c71278123b30622d550d7a7389e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*R2c_AatWNKJl_NojszqQAg.jpeg"/></div></figure><p id="043b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要公开<code class="fe mt mu mv mw b">VolumePluginAudioUnit.h</code>，以便能够在我们的<code class="fe mt mu mv mw b">AudioViewController.swift</code>中和框架外使用它。为此，将其目标成员设置为<code class="fe mt mu mv mw b">AUFramework</code>并将其公开，然后将其导入到<code class="fe mt mu mv mw b">AUFramework.h</code>中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/cd308e4027b886d2b7dbddf9a078b2af.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*CJdt1DcQ06CYq7UJJUcVdA.png"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更新了“雨伞”公共头，暴露了框架并包括插件头。</p></figure><p id="6bc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">移除桥接头，它是在extension内部创建的，因为不能在框架内部使用桥接头。</p><p id="0b83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重构后的项目结构如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/b965b82a6aa405059bacda52fa723866.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*P13HYh_uOZIHiP92Wm7hzQ.jpeg"/></div></figure><p id="d2b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该项目应该像以前一样构建并播放音频文件。</p><p id="9707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们将在主机内部以进程内方式运行插件，所以我们需要通过添加键<code class="fe mt mu mv mw b">AudioComponentBundle</code>来更新audio unit的<code class="fe mt mu mv mw b">Info.plist</code>，键的值被设置为<code class="fe mt mu mv mw b">NSExtensionAttributes</code>字典中的框架包标识符。</p><p id="6731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mt mu mv mw b">VolumePlugin</code>内部，打开内部的<code class="fe mt mu mv mw b">Info.plist</code>作为源，并添加:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c9ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经正式准备好开始开发音频单元插件了:)</p><h2 id="9421" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">更新au host/view controller . swift</strong></h2><p id="ac97" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在故事板中添加自定义视图，并使用<code class="fe mt mu mv mw b">auContainer: NSView!</code>将其与视图控制器连接</p><p id="737e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先将音频单元视图控制器添加到主机应用程序视图控制器。</p><p id="c1b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mt mu mv mw b">AUHost/ViewController.swift</code>中导入<code class="fe mt mu mv mw b">AUFramework</code>并添加音频单元视图控制器属性和创建函数，这将加载音频单元视图。更新后的<code class="fe mt mu mv mw b">AUHost/ViewController.</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用的是<code class="fe mt mu mv mw b">VolumePlugin.appex</code>，这是我们的插件扩展。</p><p id="b384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行app你应该看到“你的AudioUnit UI在这里！”从<code class="fe mt mu mv mw b">AudioUnitViewController.xib</code>开始。</p><h2 id="9599" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">更新au framework/audiuonitviewcontroller . swift</strong></h2><p id="ea77" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在更新<code class="fe mt mu mv mw b">AUFrameworkViewController</code>。在<code class="fe mt mu mv mw b">AudioUnitViewController.xib</code>中创建一个水平滑块，在<code class="fe mt mu mv mw b">AudioUnitViewController.swift</code>中创建相应的动作。确保将最大值<strong class="lb iu">从100改为1 </strong>。你不会想弄坏你的扬声器的。</p><p id="021b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe mt mu mv mw b">var audioUnit: AudioUnit?</code>更改为<code class="fe mt mu mv mw b">var audioUnit: VolumePluginAudioUnit?</code>并将其公开，这样我们就可以从框架外部(从AUHost)访问它，并添加类型为<code class="fe mt mu mv mw b">AUParameter.</code>的可选属性<code class="fe mt mu mv mw b">volumeParam</code></p><p id="fc56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe mt mu mv mw b">AudioUnitViewController.xib</code>，添加水平滑块；用<code class="fe mt mu mv mw b">AudioUnitViewController.swift</code>连接。</p><p id="73fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个函数<code class="fe mt mu mv mw b">connectWithAU()</code>，在其中我们将从<code class="fe mt mu mv mw b">VolumePluginAudioUnit</code>连接<code class="fe mt mu mv mw b">volumeParam</code>到<code class="fe mt mu mv mw b">AUParameter</code>。我们需要使用参数标识符作为键(为了简单起见，我不改变默认的<code class="fe mt mu mv mw b">param1 </code>标识符)。</p><p id="e9c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新后的<code class="fe mt mu mv mw b">AudioUnitViewController.swift</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="6d50" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">更新au framework volumepluginaudiounit . m</strong></h2><p id="b920" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这将比以前的更新需要更多的工作。</p><p id="d1b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要手动将<code class="fe mt mu mv mw b">AVFoundation</code>添加到我们的<code class="fe mt mu mv mw b">AUFramework</code>中，否则我们会得到如下链接器错误:</p><pre class="kj kk kl km gt nh mw ni nj aw nk bi"><span id="7611" class="lv lw it mw b gy nl nm l nn no">ndefined symbols for architecture x86_64: "_OBJC_CLASS_$_AVAudioFormat", referenced from:</span><span id="ec57" class="lv lw it mw b gy np nm l nn no">objc-class-ref in VolumePluginAudioUnit.o "_OBJC_CLASS_$_AVAudioPCMBuffer", referenced from:</span><span id="7cfe" class="lv lw it mw b gy np nm l nn no">objc-class-ref in VolumePluginAudioUnit.o<br/>ld: symbol(s) not found for architecture x86_64</span><span id="a221" class="lv lw it mw b gy np nm l nn no">clang: error: linker command failed with exit code 1 (use -v to see invocation)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/51272623fd10337d21584f4a96682a2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-YyvGdBsVEEfPEvDSWRy-Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为AUFramework目标手动添加AVFoundation.framework</p></figure><p id="cf30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe mt mu mv mw b">VolumePluginAudioUnit.m</code>重命名为<code class="fe mt mu mv mw b">VolumePluginAudioUnit.mm</code>(以便能够使用C++)。</p><p id="d942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建C++ struct <code class="fe mt mu mv mw b">Buffer</code>(在<code class="fe mt mu mv mw b">Buffer.hpp</code>内部)，它将保存音频样本并将其添加为实例<code class="fe mt mu mv mw b">variable_buffer</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="3384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内部<code class="fe mt mu mv mw b">VolumePluginAudioUnit.mm</code>导入<code class="fe mt mu mv mw b">Buffer</code>:</p><pre class="kj kk kl km gt nh mw ni nj aw nk bi"><span id="80eb" class="lv lw it mw b gy nl nm l nn no">#import "Buffer.hpp"</span></pre><p id="aa3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并为<code class="fe mt mu mv mw b">AUAudioUnitBus</code>和<code class="fe mt mu mv mw b">AUAudioUnitBusArray</code>输入输出总线和输入输出总线阵列添加属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mt mu mv mw b">initWithComponentDescription</code>内部初始化<code class="fe mt mu mv mw b">Buffer</code>，输入和输出总线。模板有注释和函数，我们基本上需要用我们创建的属性替换它们。例如，已经有了带有块的<code class="fe mt mu mv mw b">_parameterTree.implementValueObserver</code>，在块中我们得到由音频单元<code class="fe mt mu mv mw b">parameterTree</code>传递的值(或者从主机视图控制器连接，或者默认从插件的视图控制器连接)。在我们的例子中，它包含滑块值。因此，让我们使用这个值来更新卷:</p><pre class="kj kk kl km gt nh mw ni nj aw nk bi"><span id="4f81" class="lv lw it mw b gy nl nm l nn no"><strong class="mw iu">__block</strong> Buffer *buffer = &amp;_buffer;</span><span id="5231" class="lv lw it mw b gy np nm l nn no">_parameterTree.implementorValueObserver = ^(AUParameter *param, AUValue value) {</span><span id="f184" class="lv lw it mw b gy np nm l nn no">buffer-&gt;volume = value;</span><span id="496d" class="lv lw it mw b gy np nm l nn no">};</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更新了函数initWithComponentDescription</p></figure><p id="4de9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一次更新<code class="fe mt mu mv mw b">AUAudioUnit</code>覆盖，简单地返回输入和输出总线数组。</p><pre class="kj kk kl km gt nh mw ni nj aw nk bi"><span id="bc2c" class="lv lw it mw b gy nl nm l nn no">- (AUAudioUnitBusArray *)inputBusses {</span><span id="d6ad" class="lv lw it mw b gy np nm l nn no"><strong class="mw iu">return</strong> _inputBusArray;</span><span id="662c" class="lv lw it mw b gy np nm l nn no">}</span><span id="722a" class="lv lw it mw b gy np nm l nn no">- (AUAudioUnitBusArray *)outputBusses {</span><span id="75db" class="lv lw it mw b gy np nm l nn no"><strong class="mw iu">return</strong> _outputBusArray;</span><span id="8f2c" class="lv lw it mw b gy np nm l nn no">}</span></pre><p id="aea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mt mu mv mw b">allocateRenderResourcesAndReturnError</code>函数中更新我们的<code class="fe mt mu mv mw b">Buffer</code>结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f42c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后更新<code class="fe mt mu mv mw b">internalRenderBlock</code>功能。这是我们实时处理音频样本的地方。根据缓冲区的大小，我们正在处理大量的数据，所以几乎是实时的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="2295" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">回到AUHost </strong></h2><p id="506d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">更新<code class="fe mt mu mv mw b">AudioPlayer.swift</code>通过我们的音频插件处理音频。添加两个属性:<code class="fe mt mu mv mw b">audioUnit: AUAudioUnit?</code>和<code class="fe mt mu mv mw b">audioUnitNode: AVAudioUnit?</code>以及函数<code class="fe mt mu mv mw b">selectAudioUnitWithComponentDescription</code>。</p><p id="29ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从功能<code class="fe mt mu mv mw b">startPlaying()</code>中，移除连接的引擎:</p><pre class="kj kk kl km gt nh mw ni nj aw nk bi"><span id="5ed7" class="lv lw it mw b gy nl nm l nn no"><em class="nr">engine.connect(playerNode, to: engine.mainMixerNode, format: file.processingFormat)</em></span></pre><p id="1661" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将在音频单元连接/断开时完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">AudioPlayer.swift的最终更新</p></figure><p id="6a73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，更新<code class="fe mt mu mv mw b">AUHost/ViewController.swift</code>将音频单元插件连接到音频播放器。我们需要将开始时使用的组件子类型和组件制造商转换为4字节代码(与<code class="fe mt mu mv mw b">Info.plist</code>中相同)。我在用<a class="ae ky" href="https://codebeautify.org/string-hex-converter" rel="noopener ugc nofollow" target="_blank">https://codebeautify.org/string-hex-converter</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1fec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mt mu mv mw b">audioPlayer.play()</code>之前在<code class="fe mt mu mv mw b">viewDidLoad()</code>内部调用这个函数。</p><p id="aaee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">差不多了！如果我们继续使用沙盒，<code class="fe mt mu mv mw b">AVAudioUnit.instantiate</code>我们需要禁用<code class="fe mt mu mv mw b">AUHost app AUHost.entitlements.</code>的沙盒，错误是:</p><blockquote class="ns nt nu"><p id="6757" class="kz la nr lb b lc ld ju le lf lg jx lh nv lj lk ll nw ln lo lp nx lr ls lt lu im bi translated">NSOSStatusErrorDomain代码=-3000 "invalidComponentID "</p></blockquote><p id="7743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关闭沙盒后(对扩展保持“沙盒打开”)，可能需要清理构建文件夹。在我的情况下，我不得不在Xcode中重新打开项目。</p><p id="c7df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在WWDC谈论Audio Unit V3组件时，他们提到需要添加应用程序间音频，但这仅适用于iOS。如果我们这样做，OS X应用程序将立即被系统杀死，Xcode只会告诉我们运行完毕，没有任何错误。在系统控制台内部，该错误是由于使用了受限的授权。</p><p id="db18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在GarageBand中测试我们的插件吧！</p><p id="dab0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">音频单元V3与旧的方式不同。组件是为了在你的系统中注册它，你只需运行一次容器应用程序(它包含你的扩展。</strong>(appex)。我不知道为什么，但我注意到，有时在Xcode中运行你的项目就足够了，或者从DerivedData文件夹中运行它，但有时你需要将你的项目存档- &gt; Distribute - &gt; copy。应用程序并运行应用程序。</p><p id="64a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们这样做，打开GarageBand选择我们的插件，它不工作:(</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/38a300ea212936de745ba635328ec906.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*MpYz3cTGpxHfBQQ9AZReSQ.png"/></div></figure><p id="b23d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该插件已注册，我们可以验证运行:</p><pre class="kj kk kl km gt nh mw ni nj aw nk bi"><span id="17ee" class="lv lw it mw b gy nl nm l nn no">$ pluginkit -mv | grep bora</span><span id="d517" class="lv lw it mw b gy np nm l nn no">!    co.borama.AUHost.VolumePlugin(1.0) FBCF4FEC-E388-40BC-8731-91F06A835EAD 2019-09-26 01:37:13 +0000 /Users/michal/Desktop/AUHost 2019-09-26 03-36-24/AUHost.app/Contents/PlugIns/VolumePlugin.appex</span></pre><p id="2be0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当我们跑步时:</p><pre class="kj kk kl km gt nh mw ni nj aw nk bi"><span id="0ea7" class="lv lw it mw b gy nl nm l nn no">auval -a</span></pre><p id="5720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到<strong class="lb iu">无法打开组件:4099 </strong>错误。</p><p id="5191" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们打开我们的容器应用程序并检查我们的扩展:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/9d9e46badaceb2ec698c516e4514ab1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BMOLATTngjefY3i9lHsHRg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/4772aed289636cc8f53046769566f93e.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*1K49uAWZgL5w4PAcTzzfMw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扩展没有二进制…</p></figure><p id="33bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">扩展不包含二进制，我们需要修复它！</p><p id="66b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">我们需要向我们的扩展目标添加一个伪源文件，因为扩展二进制文件需要被创建、加载并与框架包链接。</strong></p><p id="4347" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个objective-c文件并在其中添加一个函数:</p><pre class="kj kk kl km gt nh mw ni nj aw nk bi"><span id="eb2c" class="lv lw it mw b gy nl nm l nn no"><strong class="mw iu">void</strong> dummy() {}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/7569cf46693947cf02b8d04a732fd33f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a8DUcBgfqlL9JHy-wV8KTQ.png"/></div></div></figure><p id="dd94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在扩展将包含二进制文件，所以让我们再次运行auval -a！</p><p id="b730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这次我们有<strong class="lb iu">无法打开组件:4097 </strong>错误。</p><p id="6d78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题出在我们扩展的. plist上，Xcode为我们创建扩展的时候，把NSExtensionPrincipalClass设置为:</p><pre class="kj kk kl km gt nh mw ni nj aw nk bi"><span id="50f3" class="lv lw it mw b gy nl nm l nn no">$(PRODUCT_MODULE_NAME).AudioUnitViewController</span></pre><p id="706e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们把我们的主体类移到了框架内部。我们需要将属性更改为:</p><pre class="kj kk kl km gt nh mw ni nj aw nk bi"><span id="d5e7" class="lv lw it mw b gy nl nm l nn no">AUFramework.AudioUnitViewController</span></pre><p id="d188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是AudioUnitViewController现在所在的位置。</p><p id="3104" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存档、复制和运行容器应用程序。再次运行auval -a！这次没有抱怨。重启GarageBand，载入插件。它似乎可以工作，但是当我们点击它的时候，它没有显示我们可爱的用户界面:(</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/6de3c90f164894a7791a6084f20c59d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*XlZ2aS7gI64GMCC6kokRLQ.png"/></div></figure><p id="78a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要返回到AUFramework中的AudioUnitViewController.swift，并添加不带参数的初始值设定项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ef58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次存档-分发-复制app，运行容器App。重新打开GarageBand。加载一些可爱的音频，添加VolumePlugin，打开就可以了！</p><p id="96b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">消除此警告的最后一次小更新:</p><pre class="kj kk kl km gt nh mw ni nj aw nk bi"><span id="13eb" class="lv lw it mw b gy nl nm l nn no">dyld: warning, LC_RPATH @executable_path/../Frameworks in /Users/...../AUFramework.framework/AUFramework being ignored in restricted program because of @executable_path</span></pre><p id="4c6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要在构建设置/链接中将AUFramework安装路径从默认的“@executable_path”更改为“@loader_path”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/9b70b568ae13b7fb1a196bc3e31470cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G9v_HcoUFejBlT0zYmK6LA.png"/></div></div></figure><p id="8438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">现在真的是这样了！</strong></p><p id="295b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一点，最好放很多NSLogs，给它们添加你的标签，并保持控制台打开，过滤你的标签。</p><p id="0c9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样为了清理(有时是必要的)auval，您可以运行auval -v x x x。</p><p id="611d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在推特上关注我:<a class="ae ky" href="https://twitter.com/boramaapps" rel="noopener ugc nofollow" target="_blank">https://twitter.com/boramaapps</a></p><p id="1b9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看我的ios / android应用:<a class="ae ky" href="https://borama.co" rel="noopener ugc nofollow" target="_blank">https://borama.co</a></p><h2 id="2031" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">资源</h2><ul class=""><li id="137e" class="oe of it lb b lc mo lf mp li og lm oh lq oi lu oj ok ol om bi translated"><a class="ae ky" href="https://github.com/standinga/AUHost" rel="noopener ugc nofollow" target="_blank">完整项目的GitHub链接</a></li><li id="6d5d" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2015/508/" rel="noopener ugc nofollow" target="_blank">苹果公司关于音频单元扩展的WWDC讲座</a></li></ul></div></div>    
</body>
</html>