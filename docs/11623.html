<html>
<head>
<title>10 Cool Tips for Writing Robust Bash Scripts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写健壮的Bash脚本的10个好技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-cool-tips-for-writing-robust-bash-scripts-7333531ca5fb?source=collection_archive---------12-----------------------#2022-04-04">https://betterprogramming.pub/10-cool-tips-for-writing-robust-bash-scripts-7333531ca5fb?source=collection_archive---------12-----------------------#2022-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8fe2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">工作多年后，我收集了一些有用的建议和模板，我总是在我的项目中重用它们来编写稳定、可移植和可读的Bash脚本</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/855438644ed5679c2763f8824db67297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i90d0u-p6NnhPT9sd-cNFw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯蒂安·斯特兰德在<a class="ae ky" href="https://unsplash.com/s/photos/type?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="064a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您是在运行Linux、macOS甚至Windows的本地计算机上实现自动化，还是远程实现自动化，比如构建过程、cron作业和docker构建，大多数开发人员都需要脚本。然而，有时发现脚本失败或脚本失败的地方并不简单。因此，在脚本中集成健壮性至关重要。通常，脚本需要从一个系统、用户、容器移动到另一个位置，然后突然失败。</p><p id="9b6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当谈到脚本时，我们应该区分两种用例:</p><ol class=""><li id="7322" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">操作系统的交互式命令行界面(称为REPL-读取-评估-打印-循环)。参见[1]。</li><li id="b017" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">用于编译、部署、更新或做其他事情的自动化脚本。</li></ol><p id="3715" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于交互式REPL，我推荐zsh和<a class="ae ky" href="https://github.com/ohmyzsh/ohmyzsh" rel="noopener ugc nofollow" target="_blank"> oh-my-zsh </a>配置框架。对于自动化，我推荐使用Bash，因为它可以在许多不同的系统上运行，甚至可以在容器中运行。本文主要关注后一种用例。</p><p id="d2b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以使用以下bash变体——Windows<a class="ae ky" href="https://gitforwindows.org/" rel="noopener ugc nofollow" target="_blank">git-Bash</a>,它有效地使用了<a class="ae ky" href="https://www.msys2.org/" rel="noopener ugc nofollow" target="_blank"> MSYS2 </a>的一部分——MAC OS集成Bash(注意:它通常是一个古老的版本),或者使用<a class="ae ky" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">自制软件</a>进行更好的更新。所有的Linux变种通常都配有Bash，或者可以简单地安装。</p><h1 id="331b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">提示#1:使用稳定的东西</h1><p id="8160" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">Shebang是以<code class="fe ng nh ni nj b">#!</code>开头的脚本文件中的第一行，调用解释器读取它以知道调用哪个可执行文件。许多shell脚本使用shebang头<code class="fe ng nh ni nj b">#!/bin/sh</code>。但是要小心:<code class="fe ng nh ni nj b">/bin/sh</code>可能是指向POSIX shell、Bash或Dash或其他shell的符号链接。这取决于当前的系统外壳。因此，将自己的脚本依赖于<code class="fe ng nh ni nj b">/bin/sh</code>并不是一个好主意；如果你不是系统的一部分！所以把<code class="fe ng nh ni nj b">#!/bin/bash</code>放在你文件的开头。然而，一些系统在<code class="fe ng nh ni nj b">/usr/bin/bash</code>中有Bash，上面的shebang将不工作。另一种可能是使用<code class="fe ng nh ni nj b">/usr/bin/env</code>工具，它根据当前搜索<code class="fe ng nh ni nj b">$PATH</code>搜索一个二进制文件并返回第一个匹配。那么shebang就是<code class="fe ng nh ni nj b">#!/usr/bin/env bash</code>。有一场关于这样做是否是个好主意的激烈讨论。如果你写系统脚本，那么在shebang行写解释器的绝对路径，不要使用<code class="fe ng nh ni nj b">env</code>命令。</p><h1 id="81a1" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">技巧2:让脚本可重定位</h1><p id="6b43" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">通常，您会将脚本与其他文件和其他相关脚本放在一个文件夹结构中。我希望脚本使用<strong class="lb iu">相对路径</strong>来找到相对于自己路径的依赖数据。因此，找出当前脚本的路径至关重要。第一种可能是使用<code class="fe ng nh ni nj b">readlink</code>实用程序:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="6fb7" class="no mk it nj b gy np nq l nr ns">SCRIPT_PATH=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")</span></pre><p id="2c38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">-f</code>开关将路径规范化并遵循符号链接。</p><p id="2182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，macOS没有支持<code class="fe ng nh ni nj b">-f</code>开关的gnu兼容的<code class="fe ng nh ni nj b">readlink</code>工具，您可以使用下面的解决方法(您可以在所有系统上使用它):</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="6c46" class="no mk it nj b gy np nq l nr ns">SCRIPT_PATH="$(cd "$( dirname "${BASH_SOURCE[0]}" )" &amp;&amp; pwd -P)"</span></pre><p id="bd57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，你可以在macOS上安装带有<a class="ae ky" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">自制软件</a>的<code class="fe ng nh ni nj b">coreutils</code>。但是接下来您需要在您的<code class="fe ng nh ni nj b">~/.profile</code>中添加别名来将<code class="fe ng nh ni nj b">readlink</code>、<code class="fe ng nh ni nj b">id</code>、<code class="fe ng nh ni nj b">uname</code>、<code class="fe ng nh ni nj b">env</code>映射到相应的<code class="fe ng nh ni nj b">greadlink</code>、<code class="fe ng nh ni nj b">gid</code>、<code class="fe ng nh ni nj b">guname</code>和<code class="fe ng nh ni nj b">genv</code>工具，如下所示:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="d69b" class="no mk it nj b gy np nq l nr ns"># install with 'brew install coreutils'<br/>if which greadlink &gt; /dev/null ; then<br/>    echo "Installing coreutils aliases"<br/>    alias readlink=greadlink<br/>    alias id=gid<br/>    alias uname=guname<br/>    alias env=genv<br/>fi</span></pre><p id="971a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个真正的<a class="ae ky" href="https://stackoverflow.com/questions/1055671/how-can-i-get-the-behavior-of-gnus-readlink-f-on-a-mac" rel="noopener ugc nofollow" target="_blank">硬栈溢出讨论</a>，有许多疯狂的解决方法，使用a.o. Python脚本和C程序来解决这个问题。然而，我会在这部分推荐自制或系统中立的解决方案。</p><h1 id="3f9d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">技巧3:检查错误</h1><p id="0f8d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当一个命令有一个非零的退出代码，并且在此之后将执行更多的命令时，可能会发生不好的事情！错误检查总是必不可少的。你想知道你的cron工作失败了吗！</p><h2 id="d8b4" class="no mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">出错时中止</h2><p id="b068" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">为此，激活选项<code class="fe ng nh ni nj b">set -o errexit</code>(相当于<code class="fe ng nh ni nj b">set -e</code>)。这种模式在命令失败时退出Bash脚本，并且不使用<code class="fe ng nh ni nj b">if</code>语句进行显式检查。</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="d17f" class="no mk it nj b gy np nq l nr ns">set -o errexit<br/>ls /not/existent # --&gt; exits the script with an error code</span><span id="1e8f" class="no mk it nj b gy oe nq l nr ns">set -o errexit<br/># does not abort<br/>if ls /not/existent ; then<br/>    echo "exists"<br/>else<br/>    echo "does not exist"<br/>fi</span></pre><h2 id="e230" class="no mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">显示错误位置</h2><p id="f26b" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">但是现在我们只知道脚本失败是因为它的返回代码。然而，找出失败的原因是很好的。因此，我们安装了一个陷阱处理程序来显示当前行:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="807b" class="no mk it nj b gy np nq l nr ns">#!/usr/bin/env bash<br/>set -o errexit<br/>set -o nounset<br/>SCRIPT_PATH="$(cd "$( dirname "${BASH_SOURCE[0]}" )" &amp;&amp; pwd -P)"<br/>function die() {<br/>  echo "ERROR $? IN ${BASH_SOURCE[0]} AT LINE ${BASH_LINENO[0]}" 1&gt;&amp;2<br/>  exit 1<br/>}<br/>trap die ERR</span></pre><h2 id="5f6f" class="no mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">在Bash中创建一个堆栈转储</h2><p id="fd7a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">除此之外，您甚至可以为Bash创建一个堆栈转储。如果创建更复杂的函数层次结构，这可能会很有趣。</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="9dec" class="no mk it nj b gy np nq l nr ns">function log_stack()<br/>{<br/>     local i=0<br/>     local FRAMES=${#BASH_LINENO[@]}<br/>     # FRAMES-2 skips main, the last one in arrays<br/>     for ((i=FRAMES-2; i&gt;=0; i--)); do<br/>         echo "  File \"${BASH_SOURCE[i+1]}\", line ${BASH_LINENO[i]}, in ${FUNCNAME[i+1]}"<br/>         # Grab the source code of the line<br/>         #sed -n "${BASH_LINENO[i]}{s/^/    /;p}" "${BASH_SOURCE[i+1]}"<br/>     done<br/>     return 0<br/>}</span></pre><p id="bff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将对<code class="fe ng nh ni nj b">log_stack()</code>函数的调用添加到<code class="fe ng nh ni nj b">die()</code>函数中，如下所示:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="6da1" class="no mk it nj b gy np nq l nr ns">function die() {<br/>    echo "ERROR $? IN ${BASH_SOURCE[0]} AT LINE ${BASH_LINENO[0]}" 1&gt;&amp;2<br/>    log_stack<br/>    exit 1<br/>}</span></pre><h1 id="32cd" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">技巧4:检查未定义的变量</h1><p id="9407" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当使用未定义的变量时，可能会发生灾难。为此，您可以激活<code class="fe ng nh ni nj b">set -o nounset</code>选项。每当您使用一个未定义的变量时，脚本都会以一个错误结束。有时您想使用环境变量作为脚本的输入。如果变量丢失，你肯定不喜欢失败。为了指定一个<strong class="lb iu">默认值</strong>，可以使用以下语法:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="f4a9" class="no mk it nj b gy np nq l nr ns">set -o nounset<br/><br/># here we set VERBOSE to "0" if it is not defined!<br/>VERBOSE="${VERBOSE:-0}"<br/><br/>if [[ "$VERBOSE" = "1" ]] ; then<br/>    echo "Oh verbose is on!"<br/>fi</span></pre><h1 id="2cc8" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">技巧5:逃生路径</h1><p id="7de7" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">脚本中的一个问题通常是传递包含空格的参数和路径。因此，我建议—始终使用<code class="fe ng nh ni nj b">"</code>转义路径，如:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="4562" class="no mk it nj b gy np nq l nr ns">inputFile="$1"<br/>ls "$inputFile"</span></pre><p id="53c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有一个<code class="fe ng nh ni nj b">rm -rf</code>命令，不逃避争论可能是绝对危险的。观察<code class="fe ng nh ni nj b">rm -rf "/ my /file"</code>和<code class="fe ng nh ni nj b">rm -rf / my /file</code>。后者将删除系统中的所有内容，而前者将从<code class="fe ng nh ni nj b">my</code>目录中删除<code class="fe ng nh ni nj b">file</code>。</p><h1 id="bd92" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">技巧6:使用Bash数组进行更清晰的调用</h1><p id="c710" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">对于具有许多参数的更复杂的命令，我建议使用Bash数组来组合多个选项，如下面的docker示例所示:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="926f" class="no mk it nj b gy np nq l nr ns">set -o errexit<br/>set -o nounset<br/>SCRIPT_PATH="$(cd "$( dirname "${BASH_SOURCE[0]}" )" &amp;&amp; pwd -P)"<br/>version="$(git -C "$SCRIPT_PATH" describe --tags --always)"<br/>version="${version#v}"<br/>commit="$(git -C "$SCRIPT_PATH" rev-parse HEAD)"<br/>container="my-app"<br/><br/>## HERE we create an array of options<br/>opts=()<br/>opts+=(--tag "$container":latest)<br/>opts+=(--tag "$container":"$version")<br/>opts+=(--build-arg VERSION="$version")<br/>opts+=(--build-arg COMMIT="$commit")<br/>opts+=(--file "$SCRIPT_PATH/${container}/Dockerfile")<br/>docker build "${opts[@]}" .</span></pre><p id="7bba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:对docker的调用需要对opts数组进行转义<code class="fe ng nh ni nj b">"${opts[@]}"</code>。</p><h1 id="e6b7" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">技巧7:激活健壮的Globbing</h1><p id="1625" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当for循环迭代一个空的globbing表达式时，循环和整个脚本都会因出错而中止。为了使它更加健壮，您可以激活<strong class="lb iu"> null globbing </strong>。那么当表达式为空时，for循环将<strong class="lb iu">而不是</strong>被执行(在这种情况下<code class="fe ng nh ni nj b">/tmp</code>中不存在txt文件)。</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="bf08" class="no mk it nj b gy np nq l nr ns">shopt -s nullglob<br/>for f in /tmp/*.txt ; do<br/>    echo "$f"<br/>done</span></pre><h1 id="4c77" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">技巧8:解析命令行参数</h1><p id="3e2c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">对于Bash脚本中命令行的简单解析，我推荐以下结构。</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="4987" class="no mk it nj b gy np nq l nr ns">function usage() {<br/>cat &lt;&lt;EOF<br/>Usage $0 OPTIONS<br/>Options:<br/>    --version=N  sets the version<br/>    -d           start in daemon mode<br/>    --help, -h   this help<br/>EOF<br/>}<br/><br/># parse arguments<br/>version=""<br/>daemon=0<br/>args=()<br/>while [[ $# -gt 0 ]] ; do<br/>    case "$1" in<br/>    -v=*|--version=*)<br/>        version="${1#*=}"<br/>        ;;<br/><br/>    -d|--daemon)<br/>        daemon=1<br/>        ;;<br/><br/>    -h|--help)<br/>        usage<br/>        exit 0<br/>        ;;<br/>    --)<br/>        # forward all arguments after `--` to the command<br/>        shift<br/>        args+=("${@}")<br/>        break<br/>        ;;<br/>    *)<br/>        echo "ERROR: unknown option $1"<br/>        exit 1<br/>        ;;<br/>    esac<br/>    shift<br/>done<br/># OK do here something with "${args[@]}"</span></pre><h1 id="cb36" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">技巧9:使用字符串函数</h1><p id="2311" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在进入<code class="fe ng nh ni nj b">awk</code>或<code class="fe ng nh ni nj b">tr</code>之前，您可以使用Bash进行现成的简单字符串处理。一个不太为人所知的特性是大写和小写语法。###大写和小写使用<code class="fe ng nh ni nj b">^</code>字符您可以将变量<code class="fe ng nh ni nj b">x</code>的第一个字母大写，就像<code class="fe ng nh ni nj b">${x^}</code>一样，使用<code class="fe ng nh ni nj b">^^</code>所有字符都是大写的<code class="fe ng nh ni nj b">${x^^}</code>，使用<code class="fe ng nh ni nj b">,</code>和<code class="fe ng nh ni nj b">,,</code>小写也是一样(所以不要忘记Bash在使用时是直观和漂亮的)。</p><p id="6092" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">小写转换</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="9f9d" class="no mk it nj b gy np nq l nr ns">x="HELLO"<br/>echo ${x,,}<br/># result: hello</span></pre><p id="c042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大写转换</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="5f19" class="no mk it nj b gy np nq l nr ns">x="hello"<br/>echo ${x^^}<br/># result: HELLO</span></pre><div class="of og gp gr oh oi"><a href="https://linuxhint.com/bash_lowercase_uppercase_strings/" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">Bash小写和大写字符串</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">通过使用Bash 4的新特性，可以更容易地转换字符串的大小写。'^'符号用于转换…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">linuxhint.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div><h1 id="5861" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">提示#10:使用ShellCheck</h1><p id="01a8" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">显然，使用<a class="ae ky" href="https://www.shellcheck.net/" rel="noopener ugc nofollow" target="_blank"> ShellCheck </a>工具可以避免很多问题，该工具可以集成到您喜欢的IDE中，例如Visual Studio代码。</p><p id="87bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这里提供了一个创建bash脚本的小模板:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="71d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有用。</p><h2 id="6706" class="no mk it bd ml nt nu dn mp nv nw dp mt li nx ny mv lm nz oa mx lq ob oc mz od bi translated">推荐阅读</h2><p id="4ea5" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">[1] A. Müller，“您应该学习使用命令行的原因”，2022年3月10日。<a class="ae ky" href="https://medium.com/@jumpingkiwi/reasons-why-you-should-learn-to-use-the-command-line-91823128c0ad" rel="noopener">https://medium . com/@ jumping kiwi/reasons-why-you-should-learn-to-use-the-command-line-91823128 c0ad</a>(2022年04月02日访问)。</p><p id="8db6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">【迪伦】<a class="ae ky" href="https://github.com/dylanaraps/pure-bash-bible" rel="noopener ugc nofollow" target="_blank"> <em class="oz">纯粹痛击圣经</em> </a>。2022.</p><p id="c0c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我正在编写bash脚本，我为什么要关心POSIX呢？— Unix &amp; Linux堆栈交换</p></div></div>    
</body>
</html>