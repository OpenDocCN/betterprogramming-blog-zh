<html>
<head>
<title>How To Recursively Parse API Responses Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Python递归解析API响应</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-recursively-parse-api-responses-using-python-126824426b18?source=collection_archive---------3-----------------------#2021-05-14">https://betterprogramming.pub/how-to-recursively-parse-api-responses-using-python-126824426b18?source=collection_archive---------3-----------------------#2021-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c4d7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">轻松解析复杂的响应</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6c8f2f936620af2ee421d19ebe401ae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7asYTdl-I9PX7syC"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@ricardoviana?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ricardo Viana </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="a0bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">API响应应该是可预测的。有时你不得不与一个不可预测的API交互，要么是因为它的设计很差，要么是因为你使用了一个没有文档记录的(和不受支持的)API。我已经处理了这两个问题，所以在这篇文章中，我将与你分享我所面临的障碍以及我是如何跨越它们的。在这两种情况下，我都使用了Python中的递归函数。当你不能预测你需要多少层嵌套时，你不能使用嵌套循环！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c48f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">递归的快速回顾</h1><p id="1569" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">对于那些不熟悉用Python编写递归函数的人，这里有一个原则的快速回顾。如果你从未看过递归，我鼓励你看看这些更长更全面的教程:<a class="ae kv" href="https://realpython.com/python-thinking-recursively/" rel="noopener ugc nofollow" target="_blank">用Python递归思考</a>和<a class="ae kv" href="https://towardsdatascience.com/finding-a-recursive-solution-184784b0aea0" rel="noopener" target="_blank">递归编程</a>。</p><p id="2be8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每种语言中最常被滥用的递归例子是计算一个数的阶乘。对于Python开发人员来说，这是一个愚蠢的例子，因为Python在其数学库中包含了一个阶乘函数，其性能超过了任何用Python原生编写的函数。但是阶乘函数很简单，很容易理解:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="121f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编写递归函数有两个重要的设计原则:</p><ol class=""><li id="4fe1" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated">每个递归函数都需要一个基本情况，即<strong class="ky ir">结束</strong>递归。阶乘函数的基本情况是当<em class="nh"> n </em>等于零时。零阶乘的值是已知的，没有理由继续下去。</li><li id="a39f" class="my mz iq ky b kz ni lc nj lf nk lj nl ln nm lr nd ne nf ng bi translated">每一个递归调用(当一个函数调用它自己时)应该操作它被给定的数据的一个子集。换句话说，递归的目的是将一个问题分成更小的子问题。上面显示的阶乘函数使用<em class="nh"> n-1 </em>执行递归调用，因此每次调用函数时参数都会变小。</li></ol><p id="98a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们检查另一个简单的递归函数。如何使用递归来颠倒字符串中字符的顺序？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5ba9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，上面的代码符合我们的两个设计原则。它有一个基本情况(当字符串为空时停止调用自己)，并通过每次递归调用(一次一个字符)减少问题的大小。如果我尝试<code class="fe nn no np nq b">reverse("howdy")</code>，那么第一次通过函数将产生:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="63ec" class="nv ma iq nq b gy nw nx l ny nz">return reverse("owdy") + "h"</span></pre><p id="0710" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python仍然必须在返回响应之前解析递归调用<code class="fe nn no np nq b">reverse("owdy")</code>。递归调用将产生:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="68fc" class="nv ma iq nq b gy nw nx l ny nz">return reverse("wdy") + "o"</span></pre><p id="e9b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将第二个结果代入第一个结果将得到:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="149c" class="nv ma iq nq b gy nw nx l ny nz">return (reverse("wdy") + "o") + "h"</span></pre><p id="4919" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">三次递归之后，我有:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="4e53" class="nv ma iq nq b gy nw nx l ny nz">return (reverse("") + "y") + "d" + "w" + "o" + "h"</span></pre><p id="e4c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面最后一个递归调用将由基本case处理，它生成第一个return语句:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="d40e" class="nv ma iq nq b gy nw nx l ny nz">return "" + "y" + "d" + "w" + "o" + "h"</span></pre><p id="80f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这当然以字符串<code class="fe nn no np nq b">ydwoh</code>的形式返回。</p><p id="7f86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的两个例子都可以很容易地用Python <code class="fe nn no np nq b">for</code>循环替换，但是很快你就会发现循环无法解决的问题。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="62bc" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">一些API响应的问题</h1><p id="db52" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">大多数API响应可以相对容易地解析。响应通常是一组键值对或一列元素，需要一个简单的<code class="fe nn no np nq b">for</code>循环甚至一个命令来解析。例如，下面是我从一个在线平台检索我的用户详细信息时，来自一个API的示例(截断)响应:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="8dac" class="nv ma iq nq b gy nw nx l ny nz">{<br/>    "user": {<br/>        "id": "66132462474839909048",<br/>        "name": "Doron Chosnek",<br/>        "email": "doron@example.com",<br/>        "avatar_url": "https://cdn.example.io/users/f8439545.png",<br/>        "created_at": "2018-10-17T08:55:37.827Z",<br/>        "updated_at": "2021-02-15T23:55:11.270Z",<br/>        "accessed_at": "2021-02-08T17:26:07.395Z"<br/>    .<br/>    .<br/>    .</span></pre><p id="5f84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我可以通过以下方式轻松检索我的用户ID:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="2299" class="nv ma iq nq b gy nw nx l ny nz">id = response["user"]["id]</span></pre><p id="9943" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果响应是一个列表，那还是很容易的:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="8947" class="nv ma iq nq b gy nw nx l ny nz">for user in response:<br/>    if user["email"] == 'doron@example.com':<br/>        id = user["id"]</span></pre><p id="b9c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果事情总是这么简单，你就不会读这篇文章了！让我们来看看我遇到的两个案例，然后我将向您展示我是如何通过一些递归来克服这两个问题的。</p><h2 id="58a0" class="nv ma iq bd mb oa ob dn mf oc od dp mj lf oe of ml lj og oh mn ln oi oj mp ok bi translated">反应不一致的情况</h2><p id="e19e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">韦氏词典字典API就是一个提供不一致结果的例子。从响应中提取单词的定义很容易，但是单词的例句(即“请在句子中使用它”)是通过关键字“t”来定位的，并且可以对一个单词嵌套9层深度，对另一个单词嵌套12层深度。不可能用这种差异和不一致性来编写嵌套循环。</p><p id="3f1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能不相信我，所以我在这里包括了通过韦氏词典API查找单词<em class="nh">辞职</em>的回复。我需要找到的答案在这个回答的第72行。没有必要研究这个非常长的片段；请注意第72行上的键的位置，以及其后过多的方括号和花括号。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f296" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来是不是很混乱？检索那个例句看起来很难编码吗？递归相对容易。只需要九行Python代码就可以找到那个讨厌的键，不管它在JSON有效负载中的什么位置。对于上面显示的有效载荷，这个函数递归地调用自己58次！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="fa77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码是一个简单的条件(if)语句:</p><ol class=""><li id="8d39" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated">如果参数<code class="fe nn no np nq b">d</code>是一个Python字典，那么进一步检查该字典的所有键。如果<code class="fe nn no np nq b">d</code>包含被寻找的键，则立即返回该值(两种基本情况之一)。如果不是，那么递归地检查每个键值对。从技术上讲，每个值都被递归地检查。记住，每个值可以代表另一个字典或另一个列表(嵌套)。</li><li id="8cb6" class="my mz iq ky b kz ni lc nj lf nk lj nl ln nm lr nd ne nf ng bi translated">如果参数<code class="fe nn no np nq b">d</code>是一个列表，那么进一步检查列表中的每个成员。记住列表<code class="fe nn no np nq b">d</code>的每个成员都可以是另一个列表或另一个字典(嵌套)。</li><li id="8044" class="my mz iq ky b kz ni lc nj lf nk lj nl ln nm lr nd ne nf ng bi translated">如果参数<code class="fe nn no np nq b">d</code>既不是字典也不是列表，那么它不能被进一步细分，也不是我们要找的，所以函数返回一个空字符串。这是该功能的两个基本情况之一。</li></ol><p id="380a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数受益于这样一个事实，即空字符串可以连接无限次，但仍然会产生一个空字符串。在检查JSON结构中的每个元素时，对于任何不匹配所需键的结构，该函数只返回一个空字符串。该函数的第5行和第7行可能类似于:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="5d8c" class="nv ma iq nq b gy nw nx l ny nz">return "".join([ "", "", "", "", "", "example sentence", "", "" ])</span></pre><p id="d9d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，上面会将许多空字符串与实际期望的结果连接起来，并简化为字符串<code class="fe nn no np nq b">example sentence</code>。</p><p id="5bd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了清楚起见，第5行和第7行使用Python<strong class="ky ir">list comprehension</strong>递归调用函数<code class="fe nn no np nq b">json_find</code>来处理更小的数据集。Python string <code class="fe nn no np nq b">join</code>方法使用指定的字符串(本例中为空字符串)作为分隔符，将列表中的所有元素组合成一个字符串。</p><p id="96a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一个例子。如果我用下面的JSON有效负载和<code class="fe nn no np nq b">key=“four”</code>调用函数，它应该返回一个空字符串，因为在JSON中没有找到这个键。</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="1c65" class="nv ma iq nq b gy nw nx l ny nz">{<br/>    "one": "1",<br/>    "two": "2",<br/>    "three": "3"<br/>}</span></pre><p id="88c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python将其视为一个字典<code class="fe nn no np nq b">isinstance(d,dict)</code>，然后将使用list comprehension来构建一个递归调用列表，查看字典中的值。</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="0573" class="nv ma iq nq b gy nw nx l ny nz">return "".join([ json_find(d[k],key) for k in d.keys() ])</span></pre><p id="8a0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以上扩展到这一点:</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="5086" class="nv ma iq nq b gy nw nx l ny nz">return "".join( [json_find("1","four"), json_find("2","four"),<br/>    json_find("3","four")] )</span></pre><p id="7991" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面三个递归调用的每一个都将返回<code class="fe nn no np nq b">""</code>，因为参数既不是列表也不是字典(这是我们的第二个基本情况)。当Python将递归调用中的所有这些空字符串连接起来时，最终结果是一个空字符串！</p><h2 id="eb49" class="nv ma iq bd mb oa ob dn mf oc od dp mj lf oe of ml lj og oh mn ln oi oj mp ok bi translated">无证API的案例</h2><p id="b506" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我不能责怪特斯拉“寻找二手车”API的作者，因为它不是一个公共API。我厌倦了在他们的二手车搜索器上点击所有的复选框和下拉框，所以我挖掘了他们的HTML并找出了如何检索我需要的数据。它非常有效——持续了大约十天。他们改变了他们的API响应格式！当然，他们可以这么做，因为这个API不是为像我这样的流氓设计的。</p><p id="9b1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Tesla API首先通过添加一个值为空字符串的字段<code class="fe nn no np nq b">""</code>来破坏我的代码。我在<a class="ae kv" href="https://aws.amazon.com/dynamodb/" rel="noopener ugc nofollow" target="_blank"> AWS DynamoDB </a>中保存响应，DynamoDB不支持空字符串。没问题。我添加了几行代码来检查该字段是否为空字符串，并对其进行更正。问题解决了——大约五天。出现了一辆汽车，它有一个值为空字符串的不同字段。看一下这个截断的示例，注意<code class="fe nn no np nq b">long_name</code>的空字符串。</p><pre class="kg kh ki kj gt nr nq ns nt aw nu bi"><span id="4682" class="nv ma iq nq b gy nw nx l ny nz">{<br/>    "code": "$PMNG",<br/>    "name": "Midnight Silver Metallic Paint",<br/>    "long_name": "",<br/>    "description": "Midnight Silver Metallic"<br/>},<br/>{<br/>    "code": "$WTAS",<br/>    "name": "19\" Silver Slipstream Wheels",<br/>    "long_name": "",<br/>    "description": "Standard with Goodyear Eagle RS-A2 high performance all-season tires."<br/>},</span></pre><p id="ee0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，我需要一种解决方案，能够搜索整个JSON结构，并将每个空字符串转换为有效的字符串。我收到的一个回复有200多个空字符串！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6ace" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与我之前介绍的解决方案一样，这个Python函数遵循递归函数的基本设计原则。上面的代码是一个简单的条件(if)语句:</p><ol class=""><li id="7fc1" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated">如果参数<code class="fe nn no np nq b">d</code>是一个Python字典，为字典中的每个键值对递归调用<code class="fe nn no np nq b">remove_empty_string</code>。记住，每个键值可以代表另一个字典或另一个列表(嵌套)。</li><li id="65ce" class="my mz iq ky b kz ni lc nj lf nk lj nl ln nm lr nd ne nf ng bi translated">如果参数<code class="fe nn no np nq b">d</code>是一个列表，递归调用列表中每个成员的<code class="fe nn no np nq b">remove_empty_string</code>。记住列表<code class="fe nn no np nq b">d</code>的每个成员可以是另一个列表或另一个字典(嵌套)。</li><li id="f158" class="my mz iq ky b kz ni lc nj lf nk lj nl ln nm lr nd ne nf ng bi translated">如果参数<code class="fe nn no np nq b">d</code>既不是字典也不是列表，那么代码已经到达了函数的基本情况。如果<code class="fe nn no np nq b">d</code>是一个空字符串，函数返回一个长度为1的字符串<code class="fe nn no np nq b">" "</code>。如果<code class="fe nn no np nq b">d</code>不是空字符串，则函数返回<code class="fe nn no np nq b">d</code>不变。</li></ol><p id="a228" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个11行的递归函数查看JSON结构中的每个值，不管它的复杂度和嵌套级别。这是一个非常通用的工具。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ce4d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">递归还是不递归</h1><p id="0834" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在本文中，我说明了我提出的解决方案是必要的，因为您不能总是预测API响应的结构。这是否意味着递归函数是本文提出的问题的唯一解决方案？在上面提到的两种情况下，还有另一种解决方案:将JSON结构转换为字符串，并使用regex来查找模式(在韦氏词典API的情况下)或替换模式(在Tesla API的情况下)。这些都是我不喜欢的有效解决方案，因为它们不够优雅。</p><p id="36ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">递归函数可能很难编写和测试。对于其他人来说，阅读和理解你的代码绝对是一个挑战。但是一个编写良好的递归函数可能是解决问题的一种优雅而有效的方式。有时候，这可能是解决问题的唯一方法。递归是每个程序员都应该知道如何使用的工具。</p></div></div>    
</body>
</html>