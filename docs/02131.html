<html>
<head>
<title>The Complete Guide to the Singleton Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单体设计模式完全指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-complete-guide-to-the-singleton-design-pattern-dd0e7a5a4dc?source=collection_archive---------5-----------------------#2019-11-08">https://betterprogramming.pub/the-complete-guide-to-the-singleton-design-pattern-dd0e7a5a4dc?source=collection_archive---------5-----------------------#2019-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0a11" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将类的实例化限制为单个实例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f4e11996f74010fa202d226377de8c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RwqfLajxgYRlirKD7u0Lw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@golfarisa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Arisa Chattasa </a>在<a class="ae ky" href="https://unsplash.com/s/photos/one?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3ae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原著《设计模式:可重用面向对象软件的元素》中描述了23种经典的设计模式。这些模式为软件开发中经常出现的特定问题提供了解决方案。</p><p id="6ac6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将描述单例模式，以及如何和何时应用它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2467" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">单例模式:基本思想</h1><blockquote class="mu mv mw"><p id="b969" class="kz la mx lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated">在软件工程中，单例模式是一种软件设计模式，它将一个类的实例化限制为一个“单个”实例。当只需要一个对象来协调整个系统的动作时，这很有用。这个术语来源于独生子女的数学概念。—维基百科</p><p id="a1b7" class="kz la mx lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated">"确保一个类只有一个实例，并提供一个全局的访问点."—设计模式:可重用面向对象软件的元素</p></blockquote><p id="9277" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种模式的主要特点是每个类中只有一个对象被实例化。此外，还为类创建了一个入口点，通常使用一个访问器方法，比如<code class="fe nb nc nd ne b">getInstance</code>。</p><p id="60ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，对象适配器(又名singleton)包含它所包装的类的一个实例。这个模式的UML图如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/c4cb1ec406ad1183e62350a44fb96449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sO27CKj4z6e4stiN.png"/></div></div></figure><p id="bab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">Singleton</code>类是一个单独的类，它有一个名为<code class="fe nb nc nd ne b">uniqueInstance</code>的属性，用来存储<code class="fe nb nc nd ne b">Singleton</code>类的一个实例。类构造函数是私有的，你只能通过一个访问器方法访问实例，这个方法可能是<code class="fe nb nc nd ne b">getInstance</code>。</p><p id="1c97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">访问器方法负责在存在单个实例的情况下返回该实例，或者在尚未实例化该实例的情况下实例化该实例。</p><p id="58f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下列情况下，应该使用单例模式:</p><ul class=""><li id="1a0e" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">一个类必须有一个实例，并且这个类必须可以被客户端从它们知道的访问点访问。</li><li id="74b0" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">singleton类可以通过继承来扩展，客户端必须能够使用扩展的类，而无需对其进行任何更改。</li></ul><p id="4fdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单例模式有几个优点，总结如下:</p><ul class=""><li id="c761" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">您可以严格控制客户端访问单例实例的方式和时间。您可以控制访问，因为singleton类封装了它的实例。</li><li id="4847" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">当我们需要限制从一个类创建的实例的数量以节省系统资源时，这是很有用的。</li><li id="3d52" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">单例模式是对全局变量的改进，因为它避免了用只存储单例实例的全局变量污染名称空间。</li><li id="986d" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">代码更容易使用、理解和测试，因为单例简化了代码。</li></ul><p id="a79d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我现在将向您展示如何使用JavaScript/TypeScript实现这种模式。在我们的例子中，我虚构了一个问题，其中有一个名为<code class="fe nb nc nd ne b">DatabaseConnection</code>的类定义了两个属性:<code class="fe nb nc nd ne b">configuration</code>和<code class="fe nb nc nd ne b">getUniqueIdentificator</code>。这个类是到我们数据库的连接。<code class="fe nb nc nd ne b">DatabaseConnection</code>由多个客户端使用(<code class="fe nb nc nd ne b">client1</code>和<code class="fe nb nc nd ne b">client2</code>)。下面的UML图显示了我刚刚描述的场景。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/ea7ccbcacc1eea79228249c20ad4e937.png" data-original-src="https://miro.medium.com/v2/resize:fit:76/0*ig8bblFfuXauuca4"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/f3dcecf0a49cd21f17336639c7bf4e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S88TVQi_mOqiOj9Q.png"/></div></div></figure><p id="9292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">client</code>代码如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/ac929d21fb1ab5b8251f183d350bec23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EkzUzXL5btBWJ0kF.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/3bb1efd711d4be8952ae7c53facc77fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1WjNbx5crYIakk8Y.png"/></div></div></figure><p id="2bc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个客户端创建一个到数据库的新连接，并请求每个连接的唯一标识符。这种体系结构的一个主要后果是使用了过多的资源。</p><p id="b2a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">DatabaseConnection</code>类如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/a7685e01b47812a15a64cedbda0c29c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JHslBDHobj0lCrtc.png"/></div></div></figure><p id="616f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前面的类中，可以看到数据库配置中只有一个私有属性可用，唯一标识符是使用公共属性访问的。</p><p id="0645" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，该交互的示例代码如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/5489b77c21465b1fb047bf5b31f94e30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cV98rF3C_0fNtR0s.png"/></div></div></figure><p id="3158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获得的结果如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/518740f7ede737501449f2fe250a57dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MUYAdYvkVgS644n8.png"/></div></div></figure><p id="9cd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，当数据库的每个实例执行的任务完全相同时，它们都有唯一的标识符(因为它们是不同的实例)。事实上，最聪明的方法是用一个实例来建立连接。</p><p id="e291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案是使用单例模式，它只创建该类的一个实例。使用适配器模式的新UML图如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/8123f71a3a7e1d9316852491070d7f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/0*UcSlZ3AspyDcTrxD.jpg"/></div></figure><p id="8e01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe nb nc nd ne b">DatabaseConnection</code>相关的代码如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/f1a4ead20dd6692d59a2f1a03e7ba2b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UJx8cQ3uesqdku26.png"/></div></div></figure><p id="455b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对实例的唯一访问点是使用<code class="fe nb nc nd ne b">getDatabaseConnection</code>静态方法，它将在实例不存在的情况下创建一个新实例，或者它将获得它。通过这种方式，客户端稍加修改即可使用该实例，而不是创建自己的实例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/71a75f0dac30698168d9ac637055a3dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mKTtFPGfHLKhSc45.png"/></div></div></figure><p id="99c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在程序执行过程中进行这些修改后的结果如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/4546f51b28775243d08f250cb2688fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qrnNuKpk8mgRG4kf.png"/></div></div></figure><p id="81b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经创建了两个npm脚本，在应用了singleton模式后，它们运行这里显示的两个例子。</p><p id="b02a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">npm run example1-problem</code> <br/> <code class="fe nb nc nd ne b">npm run example1-singleton-solution1</code></p><p id="928f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用单例模式解决的另一个有趣的例子是当有几个类必须是单例的时候。比如蜘蛛侠、蝙蝠侠等一组英雄都是单身。在下面的UML图中，您可以看到这种情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/d269396ccab146a49ccfee2f659934b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/0*i9gq7LvJvVXkUz7o.jpeg"/></div></figure><p id="b1aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与客户端相关的代码如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/3e3fefea31145f5cce099f2722d7f8ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PduFwqanND-w__3H.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/83058f3fc520e95310a0d27ea775e7ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*A_gVWN5oRrT-O141.png"/></div></div></figure><p id="9838" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将创造我们的英雄，这将是独一无二的。首先，我们将为它们各自包含的信息定义一个公共接口:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/1311f09c46b7881919569a23c2533041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7GxYdosiSB5YdjzI.png"/></div></div></figure><p id="9fef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的英雄是独一无二的，但是有着共同的属性和方法。为此，我们定义了一个名为<code class="fe nb nc nd ne b">HeroBase</code>的父类，它包含了<code class="fe nb nc nd ne b">Spiderman</code>和<code class="fe nb nc nd ne b">Batman</code>的共同特征。这个类如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/e3523c2b1fec9303c64bddc326567f82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wBiSbFBG869eQyWa.png"/></div></div></figure><p id="9251" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">蝙蝠侠和蜘蛛侠都在他们的构造中实现了单例模式，并存储了对每个类的唯一对象的引用(我们的英雄！).这些类别如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/a84cd073933c86a7eeaa9b420cc55dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9rHSpItIWgGFV-bC.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/a0a558d7b27fb871fbf81e3f087d2399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aBUsJtTXPRqw6nK2.png"/></div></div></figure><p id="585f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，该交互的示例代码如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/7935c4bbee7af88ff935abc0597d8179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eLesW_PP2OzKhjkK.png"/></div></div></figure><p id="7ba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获得的结果如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/ccebe15921dcace322452e493c72d09a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4kRoGbVfnSgdxEy8.png"/></div></div></figure><p id="ad41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经创建了一个npm脚本，它在应用了singleton模式后运行这里显示的示例。</p><p id="292e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">npm run example2-singleton-solution1</code></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1697" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="9aad" class="pw-post-body-paragraph kz la it lb b lc oj ju le lf ok jx lh li ol lk ll lm om lo lp lq on ls lt lu im bi translated">单例模式可以避免项目的复杂性，因为您可以在客户熟知的单点上严格控制类的实例化。此外，这是一种节省系统资源的模式，因为不用实例化一组执行相同任务的类，而是使用该类的单个实例。然而，这种模式名声很差，甚至被认为是反模式，因为它创建了可以从代码的任何地方访问和更改的全局变量。</p><p id="eb24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的事情不是实现我向你展示的模式，而是认识到这个特定模式可以解决的问题，并且知道你什么时候可以或者不可以实现它。这一点至关重要，因为实现会因您使用的编程语言而异。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ad9f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ul class=""><li id="c3c5" class="ng nh it lb b lc oj lf ok li oo lm op lq oq lu nl nm nn no bi translated"><a class="ae ky" href="https://www.amazon.com/Design-Patterns-Object-Oriented-professional-computing/dp/0201633612" rel="noopener ugc nofollow" target="_blank">《设计模式:可重用面向对象软件的元素》，伽马、赫尔姆、约翰逊、&amp;弗利塞德斯、艾迪森·韦斯利，1995 </a></li><li id="1f88" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank">单例模式——维基百科</a></li><li id="956f" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://www.dofactory.com/javascript/singleton-design-pattern" rel="noopener ugc nofollow" target="_blank">https://www . do factory . com/JavaScript/singleton-design-pattern</a></li><li id="7853" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://github.com/sohamkamani/javascript-design-patterns-for-humans#-singleton" rel="noopener ugc nofollow" target="_blank">https://github . com/sohamkamani/JavaScript-design-patterns-for-humans #-singleton</a></li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><ul class=""><li id="2173" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">这个帖子的GitHub分支是<a class="ae ky" href="https://github.com/Caballerog/blog/tree/master/singleton-pattern" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Caballerog/blog/tree/master/singleton-pattern</a></li></ul></div></div>    
</body>
</html>