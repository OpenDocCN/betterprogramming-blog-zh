<html>
<head>
<title>Making Sense of == vs. === in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中== vs. ===的意义</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/making-sense-of-vs-in-javascript-f9dbbc6352e3?source=collection_archive---------11-----------------------#2019-09-02">https://betterprogramming.pub/making-sense-of-vs-in-javascript-f9dbbc6352e3?source=collection_archive---------11-----------------------#2019-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="72b7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">双倍等于(==)测试标准相等，三倍等于(===)测试严格相等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6deef681e44927816b7921b426d7d99e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zlXbfRFBTdngzc7R"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@unitasphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">查尔斯“鸭子”尤纳斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="dc74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">平等应该是平等的吧？JavaScript的三重等于比较总是让我困惑。大多数语言都有<code class="fe lv lw lx ly b">==</code>而没有<code class="fe lv lw lx ly b">===</code>。</p><p id="e4b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，两倍等于和三倍等于的区别如下:</p><blockquote class="lz"><p id="14e6" class="ma mb it bd mc md me mf mg mh mi lu dk translated">"如果操作数必须具有特定的类型和值，或者如果操作数的确切类型很重要，请使用[= = = =]严格相等运算符。</p><p id="4118" class="ma mb it bd mc md me mf mg mh mi lu dk translated">否则，使用标准的等式操作符<em class="mj"> [==] </em>，它允许你比较两个操作数的同一性，即使它们不是同一类型。”— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="c318" class="pw-post-body-paragraph kz la it lb b lc mk ju le lf ml jx lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">我理解的关键是了解“类型强制”——这是普通JavaScript中一个奇怪的概念，普通JavaScript是一种动态类型语言。</p><p id="a975" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发生类型强制是因为JavaScript试图抵抗编程错误，例如比较数字和字符串。</p><p id="bc14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="mp mq ep" href="https://medium.com/u/e9031892baf5?source=post_page-----f9dbbc6352e3--------------------------------" rel="noopener" target="_blank">布兰登·莫雷利</a>这样解释类型强制:</p><blockquote class="lz"><p id="b968" class="ma mb it bd mc md me mf mg mh mi lu dk translated">“当在JavaScript中使用double equals时，我们测试的是<strong class="ak">松散相等。</strong>双等号也执行<em class="mj"> </em> <strong class="ak">式强制</strong>。</p><p id="d740" class="ma mb it bd mc md me mf mg mh mi lu dk translated">类型强制意味着只有在尝试将两个值转换成公共类型之后<strong class="ak">才会比较它们。"</strong></p></blockquote><p id="6e69" class="pw-post-body-paragraph kz la it lb b lc mk ju le lf ml jx lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">换句话说，由于类型强制，这些值将与<code class="fe lv lw lx ly b">==</code>进行比较，但是字符串永远不会与<code class="fe lv lw lx ly b">===</code>相等。</p><p id="ef56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="7cee" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">真理的意义:JavaScript中的虚假和真实</h1><p id="9697" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">在JavaScript中，有<a class="ae ky" href="https://codeburst.io/javascript-showdown-vs-7be792be15b5" rel="noopener" target="_blank">六个falsy值</a> : <strong class="lb iu"> </strong> <code class="fe lv lw lx ly b">false</code>、<code class="fe lv lw lx ly b">0</code>(零)、<code class="fe lv lw lx ly b">""</code>(空字符串)、<code class="fe lv lw lx ly b">null</code>、<code class="fe lv lw lx ly b">undefined</code>、<code class="fe lv lw lx ly b">NaN</code>(不是一个数字)。</p><p id="d4c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">布兰登·莫雷利解释了虚假价值观的工作原理:</p><blockquote class="lz"><p id="0018" class="ma mb it bd mc md me mf mg mh mi lu dk translated">将<code class="fe lv lw lx ly b">false</code>、<code class="fe lv lw lx ly b">0</code>和<code class="fe lv lw lx ly b">""</code>与松散等式(==)进行比较将得到等式。<code class="fe lv lw lx ly b">null</code>和<code class="fe lv lw lx ly b">undefined</code>只等于自己。不等同于任何东西(甚至不等同于它本身！)."— <a class="ae ky" href="https://codeburst.io/javascript-showdown-vs-7be792be15b5" rel="noopener" target="_blank"> <strong class="ak"> JavaScript对决:== vs. === </strong> </a></p></blockquote><figure class="nx ny nz oa ob kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="5f66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，根据MDN网络文档<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy" rel="noopener ugc nofollow" target="_blank">的说法，其他一切都是真实的:</a></p><blockquote class="lz"><p id="0544" class="ma mb it bd mc md me mf mg mh mi lu dk translated">在JavaScript中，<strong class="ak">真值</strong>是在布尔上下文中遇到时被视为<code class="fe lv lw lx ly b"><em class="mj">true</em></code>的值。除非定义为<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy" rel="noopener ugc nofollow" target="_blank"> falsy </a>(即<code class="fe lv lw lx ly b"><em class="mj">false</em></code>、<code class="fe lv lw lx ly b"><em class="mj">0</em></code>、<code class="fe lv lw lx ly b"><em class="mj">""</em></code>、<code class="fe lv lw lx ly b"><em class="mj">null</em></code>、<code class="fe lv lw lx ly b"><em class="mj">undefined</em></code>和<code class="fe lv lw lx ly b"><em class="mj">NaN</em></code>除外)，否则所有值均为真值。</p></blockquote></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="587a" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">引擎盖下的一瞥:它在ECMAScript中是如何工作的</h1><p id="de05" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">对于那些好奇的人，这里是JavaScript使用的精确算法:</p><h2 id="10f9" class="oc nb it bd nc od oe dn ng of og dp nk li oh oi nm lm oj ok no lq ol om nq on bi translated">严格相等运算符</h2><p id="92eb" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">严格相等运算符(<code class="fe lv lw lx ly b">===</code>和<code class="fe lv lw lx ly b">!==</code>)使用<a class="ae ky" href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.6" rel="noopener ugc nofollow" target="_blank">严格相等比较算法</a>来比较两个操作数:</p><blockquote class="oo op oq"><p id="09d8" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated"><a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.6" rel="noopener ugc nofollow" target="_blank"> 11.9.6 </a>严格相等比较算法</p><p id="fc05" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">比较x === y，其中x和y是值，产生<strong class="lb iu">真</strong>或<strong class="lb iu">假</strong>。这种比较按如下方式进行:</p><p id="ed5f" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">1.如果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> x </em>)与<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> y </em>)不同，则返回<strong class="lb iu">假</strong>。</p><p id="1292" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">2.如果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> x </em>)未定义，则返回<strong class="lb iu">真</strong>。</p><p id="c73e" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">3.如果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> x </em>)为空，则返回<strong class="lb iu">真</strong>。</p><p id="7d19" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">4.如果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> x </em>)是数字，则</p><p id="6d4e" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">→ a .如果<em class="it"> x </em>为<strong class="lb iu"> NaN </strong>，则返回<strong class="lb iu"> false </strong>。</p><p id="187a" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">→ b .如果<em class="it"> y </em>为<strong class="lb iu"> NaN </strong>，则返回<strong class="lb iu"> false </strong>。</p><p id="faac" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">→ c .如果<em class="it"> x </em>与<em class="it"> y </em>的数值相同，则返回<strong class="lb iu"> true </strong>。</p><p id="bdb1" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">→ d .如果<em class="it"> x </em>为<strong class="lb iu"> +0 </strong>且<em class="it"> y </em>为<strong class="lb iu">-0</strong>，则返回<strong class="lb iu">真</strong>。</p><p id="0587" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">→ e .如果<em class="it"> x </em>为<strong class="lb iu">-0</strong>且<em class="it"> y </em>为<strong class="lb iu"> +0 </strong>，则返回<strong class="lb iu">真</strong>。</p><p id="f231" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">→ f .返回<strong class="lb iu">假</strong>。</p><p id="8807" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">5.如果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank"> Type </a> ( <em class="it"> x </em>)是字符串，那么如果<em class="it"> x </em>和<em class="it"> y </em>是完全相同的字符序列(长度相同，对应位置的字符相同)，则返回<strong class="lb iu">true</strong>；否则，返回<strong class="lb iu">假</strong>。</p><p id="2cbd" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">6.如果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> x </em>)为布尔值，如果<em class="it"> x </em>和<em class="it"> y </em>都为<strong class="lb iu">真</strong>或都为<strong class="lb iu">假</strong>，则返回<strong class="lb iu">真</strong>；否则，返回<strong class="lb iu">假</strong>。</p><p id="0fbc" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">7.如果<em class="it"> x </em>和<em class="it"> y </em>引用同一个对象，则返回<strong class="lb iu"> true </strong>。否则，返回<strong class="lb iu">假</strong>。</p><p id="6944" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">注意——该算法不同于<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.12" rel="noopener ugc nofollow" target="_blank">同值算法(9.12) </a>对有符号零和nan的处理。</p></blockquote><h2 id="5474" class="oc nb it bd nc od oe dn ng of og dp nk li oh oi nm lm oj ok no lq ol om nq on bi translated">标准等式运算符</h2><p id="e300" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">标准相等运算符(<code class="fe lv lw lx ly b">==</code>和<code class="fe lv lw lx ly b">!=</code>)使用<a class="ae ky" href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3" rel="noopener ugc nofollow" target="_blank">抽象相等比较算法</a>来比较两个操作数:</p><blockquote class="oo op oq"><p id="52be" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated"><a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3" rel="noopener ugc nofollow" target="_blank"> 11.9.3 </a>抽象等式比较算法</p><p id="0498" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">比较x == y，其中x和y是值，产生真值<strong class="lb iu">或假值<strong class="lb iu"/>。这种比较按如下方式进行:</strong></p><p id="51bd" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">1.如果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> x </em>)与<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> y </em>)相同，则</p><p id="4619" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">→ a .如果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> x </em>)未定义，则返回<strong class="lb iu">真</strong>。</p><p id="f2d2" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">→ b .如果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> x </em>)为空，则返回<strong class="lb iu">真</strong>。</p><p id="acd2" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">→ c .如果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> x </em>)是数字，则</p><p id="f9c9" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">→ →一、如果<em class="it"> x </em>为<strong class="lb iu"> NaN </strong>，则返回<strong class="lb iu"> false </strong>。</p><p id="65f8" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">→ →二。如果<em class="it"> y </em>为<strong class="lb iu"> NaN </strong>，则返回<strong class="lb iu"> false </strong>。</p><p id="8d9f" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">→ →三。如果<em class="it"> x </em>与<em class="it"> y </em>的数值相同，则返回<strong class="lb iu"> true </strong>。</p><p id="48be" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">→ →四。如果<em class="it"> x </em>为<strong class="lb iu"> +0 </strong>且<em class="it"> y </em>为<strong class="lb iu">-0</strong>，则返回<strong class="lb iu">真</strong>。</p><p id="38b7" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">→ → v .如果<em class="it"> x </em>为<strong class="lb iu">-0</strong>且<em class="it"> y </em>为<strong class="lb iu"> +0 </strong>，则返回<strong class="lb iu">真</strong>。</p><p id="2848" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">→ →六。返回<strong class="lb iu">假</strong>。</p><p id="4a9c" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">→ d .如果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> x </em>)是字符串，那么如果<em class="it"> x </em>和<em class="it"> y </em>是完全相同的字符序列(长度相同，对应位置的字符相同)，则返回<strong class="lb iu">真</strong>。否则，返回<strong class="lb iu">假</strong>。</p><p id="52fc" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">→ e .如果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> x </em>)为布尔值，如果<em class="it"> x </em>和<em class="it"> y </em>都为<strong class="lb iu">真</strong>或都为<strong class="lb iu">假</strong>，则返回<strong class="lb iu">真</strong>。否则，返回<strong class="lb iu">假</strong>。</p><p id="00ff" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">→ f .如果<em class="it"> x </em>和<em class="it"> y </em>引用同一个对象，则返回<strong class="lb iu"> true </strong>。否则，返回<strong class="lb iu">假</strong>。</p><p id="7cbe" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">2.如果<em class="it"> x </em>为<strong class="lb iu">空</strong>且<em class="it"> y </em>为<strong class="lb iu">未定义</strong>，则返回<strong class="lb iu">真</strong>。</p><p id="4561" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">3.如果<em class="it"> x </em>为<strong class="lb iu">未定义</strong>且<em class="it"> y </em>为<strong class="lb iu">空</strong>，则返回<strong class="lb iu">真</strong>。</p><p id="0fdb" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">4.如果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank"> Type </a> ( <em class="it"> x </em>)是Number，<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank"> Type </a> ( <em class="it"> y </em>)是String，则返回比较结果<em class="it">x</em>= =<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.3" rel="noopener ugc nofollow" target="_blank">to Number</a>(<em class="it">y</em>)。</p><p id="96d3" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">5.如果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank"> Type </a> ( <em class="it"> x </em>)是String，<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank"> Type </a> ( <em class="it"> y </em>)是Number，返回比较结果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.3" rel="noopener ugc nofollow" target="_blank">到Number</a>(<em class="it">x</em>)= =<em class="it">y</em>。</p><p id="adf6" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">6.如果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> x </em>)为布尔值，则将比较结果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.3" rel="noopener ugc nofollow" target="_blank">返回给number</a>(<em class="it">x</em>)=<em class="it">y</em>。</p><p id="4204" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">7.如果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> y </em>)为布尔值，则返回比较结果<em class="it">x</em>= =<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.3" rel="noopener ugc nofollow" target="_blank">to number</a>(<em class="it">y</em>)。</p><p id="c479" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">8.如果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> x </em>)为字符串或数字，且<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> y </em>)为对象，则返回比较结果<em class="it">x</em>= =<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.1" rel="noopener ugc nofollow" target="_blank">top primitive</a>(<em class="it">y</em>)。</p><p id="b0ec" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">9.如果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> x </em>)是对象，<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-8" rel="noopener ugc nofollow" target="_blank">类型</a> ( <em class="it"> y </em>)是字符串或数字，则返回比较结果<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.1" rel="noopener ugc nofollow" target="_blank">to primitive</a>(<em class="it">x</em>)=<em class="it">y</em>。</p><p id="5a76" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">10.返回<strong class="lb iu">假</strong>。</p><p id="0ad3" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">注1——根据上述平等定义:</p><p id="c684" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">可以通过<code class="fe lv lw lx ly b">"" + a == "" + b</code>强制进行字符串比较。</p><p id="511a" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">可以通过<code class="fe lv lw lx ly b">+a == +b</code>强制进行数值比较。</p><p id="394d" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">布尔比较可以由:<code class="fe lv lw lx ly b">!a == !b</code>强制。</p><p id="cc5d" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">注释2-等式运算符保持以下不变量:</p><p id="88ed" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">A != B</code>相当于<code class="fe lv lw lx ly b">!(A == B)</code>。</p><p id="0bf0" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">A == B</code>等同于<code class="fe lv lw lx ly b">B == A</code>，除了<code class="fe lv lw lx ly b">A</code>和<code class="fe lv lw lx ly b">B</code>的求值顺序不同。</p><p id="9dfc" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">注3:等式运算符并不总是可传递的。例如，可能有两个不同的String对象，每个表示相同的字符串值；每个字符串对象都被<code class="fe lv lw lx ly b">==</code>操作符视为等于字符串值，但是两个字符串对象并不相等。例如:</p><p id="c904" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">new String("a") == "a"</code>和<code class="fe lv lw lx ly b">"a" == new String("a")</code>都是<strong class="lb iu">真</strong>。</p><p id="705d" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">new String("a") == new String("a")</code>为<strong class="lb iu">假</strong>。</p><p id="141d" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">注4:字符串比较对代码单元值序列使用简单的相等测试。没有尝试使用Unicode规范中定义的更复杂、面向语义的字符或字符串相等性和排序顺序的定义。因此，根据Unicode标准在规范上相等的字符串值可能会被测试为不相等。实际上，该算法假设两个字符串都已经是规范化的形式。</p></blockquote></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="a71a" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">结论</h1><p id="cb5b" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">一般来说，我更喜欢使用<code class="fe lv lw lx ly b">===</code>和<code class="fe lv lw lx ly b">!==</code>，除非我有充分的理由使用<code class="fe lv lw lx ly b">== </code>或<code class="fe lv lw lx ly b">!=</code>，比如在空支票的情况下。</p><p id="5acb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在检查null时，知道null和undefined与<code class="fe lv lw lx ly b">==</code>相等是很有用的。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="21c8" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">附加阅读</h1><ul class=""><li id="364b" class="ov ow it lb b lc ns lf nt li ox lm oy lq oz lu pa pb pc pd bi translated"><a class="ae ky" href="https://bytearcher.com/contact/" rel="noopener ugc nofollow" target="_blank">Panu pitkmki</a>对比<a class="ae ky" href="https://bytearcher.com/articles/equality-comparison-operator-javascript/" rel="noopener ugc nofollow" target="_blank">bytearcher.com</a>本文中的<code class="fe lv lw lx ly b">==</code>和<code class="fe lv lw lx ly b">===</code>:</li></ul><div class="pe pf gp gr pg ph"><a href="https://bytearcher.com/articles/equality-comparison-operator-javascript/" rel="noopener  ugc nofollow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">JavaScript中应该使用===还是==相等比较运算符？</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">您知道在JavaScript中有两种不同的等式比较操作符:===和==操作符，或者三元……</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">bytearcher.com</p></div></div><div class="pq l"><div class="pr l ps pt pu pq pv ks ph"/></div></div></a></div><ul class=""><li id="cc37" class="ov ow it lb b lc ld lf lg li pw lm px lq py lu pa pb pc pd bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy" rel="noopener ugc nofollow" target="_blank"> MDN web文档</a>解释<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy" rel="noopener ugc nofollow" target="_blank">真实</a>、<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy" rel="noopener ugc nofollow" target="_blank">虚假</a>、<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Type_Conversion" rel="noopener ugc nofollow" target="_blank">类型强制</a>和<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Boolean" rel="noopener ugc nofollow" target="_blank">布尔</a>:</li></ul><div class="pe pf gp gr pg ph"><a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy" rel="noopener  ugc nofollow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">真理</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">在JavaScript中，真值是在布尔上下文中遇到时被认为是真的值。所有值都是…</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">developer.mozilla.org</p></div></div><div class="pq l"><div class="pz l ps pt pu pq pv ks ph"/></div></div></a></div><ul class=""><li id="69c7" class="ov ow it lb b lc ld lf lg li pw lm px lq py lu pa pb pc pd bi translated">根据Basarat Ali Syed的优秀免费书籍<a class="ae ky" href="https://basarat.gitbooks.io/typescript/docs/javascript/equality.html" rel="noopener ugc nofollow" target="_blank"><em class="or">TypeScript Deep Dive</em></a>，<code class="fe lv lw lx ly b">==</code>和<code class="fe lv lw lx ly b">===</code>在JavaScript和TypeScript中的工作方式相同:</li></ul><div class="pe pf gp gr pg ph"><a href="https://basarat.gitbooks.io/typescript/docs/javascript/equality.html" rel="noopener  ugc nofollow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">平等</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">JavaScript中需要注意的一点是==和===之间的区别。随着JavaScript试图变得有弹性…</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">basarat.gitbooks.i</p></div></div></div></a></div></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="78d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">德里克·奥斯汀博士是《职业编程:如何在6个月内成为一名成功的6位数程序员 》一书的作者，该书现已在亚马逊上架。</p></div></div>    
</body>
</html>