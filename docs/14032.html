<html>
<head>
<title>How to Fetch Files From GitHub in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript从GitHub获取文件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-fetch-files-from-github-in-javascript-e0ed2c72aeb4?source=collection_archive---------0-----------------------#2022-10-28">https://betterprogramming.pub/how-to-fetch-files-from-github-in-javascript-e0ed2c72aeb4?source=collection_archive---------0-----------------------#2022-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1d7c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用GitHub API克服CORS</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/da1416b486891f16f50e26bfd39fb4d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7HsDH6EerRk8Wx6L"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@yancymin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">扬西·敏</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="c239" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">背景</h1><p id="5903" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们经常希望在web应用程序中使用来自GitHub的公共托管文件。这可以是任何东西，从小的数据或配置文件，到用于测试的几行代码。虽然我们可以使用<code class="fe mn mo mp mq b">curl</code>或<code class="fe mn mo mp mq b">wget</code>等工具在本地下载文件的副本，但由于不匹配<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank">跨源资源共享(CORS) </a>身份验证，浏览器不会出现这种情况。</p><p id="2b48" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">正是因为这个原因，我们利用了GitHub API。</p><h1 id="6568" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">收集有关文件的信息</h1><p id="c325" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们首先获取关于我们感兴趣的回购和文件的信息。例如，如果我们对中型API存储库自述文件感兴趣，我们可以从URL开始:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="9ef9" class="na la it mq b gy nb nc l nd ne"><a class="ae ky" href="https://github.com/Medium/medium-api-docs/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">https://github.com/<strong class="mq iu">Medium</strong>/<strong class="mq iu">medium-api-docs</strong>/blob/master/<strong class="mq iu">README.md</strong></a></span></pre><p id="8fe6" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">然后，我们需要提取三条关键信息:</p><ul class=""><li id="fb7c" class="nf ng it lt b lu mr lx ms ma nh me ni mi nj mm nk nl nm nn bi translated">地主</li><li id="f8e4" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">仓库</li><li id="58a5" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">我们感兴趣的文件的相对路径</li></ul><p id="add9" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">在这种情况下，所有者是<code class="fe mn mo mp mq b">Medium</code>，存储库是<code class="fe mn mo mp mq b">medium-api-docs</code>，文件路径是<code class="fe mn mo mp mq b">README.md</code>。</p><h1 id="2a39" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">获取文件SHA密钥</h1><p id="d369" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们有了信息，我们可以将这些变量代入API调用:</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="7751" class="na la it mq b gy nb nc l nd ne">https://api.github.com/repos/<strong class="mq iu">&lt;owner&gt;</strong>/<strong class="mq iu">&lt;repo&gt;</strong>/contents/<strong class="mq iu">&lt;path&gt;</strong></span></pre><p id="8894" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">这个函数将返回一个JSON对象，包含关于我们的文件和存储库的信息。我们最感兴趣的是文件的<strong class="lt iu"> SHA-1散列</strong>指纹。</p><p id="a387" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">GitHub将存储库文件存储为blobs(二进制大对象),我们将使用SHA密钥来访问其中的数据。</p><h1 id="5b6d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">提取斑点</h1><p id="f54d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们有了<code class="fe mn mo mp mq b">sha</code>键，我们向GitHub API发送另一个调用，请求blob内容。</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="62d9" class="na la it mq b gy nb nc l nd ne">https://api.github.com/repos/<strong class="mq iu">&lt;user&gt;</strong>/<strong class="mq iu">&lt;repo&gt;</strong>/git/blobs/<strong class="mq iu">&lt;sha&gt;</strong></span></pre><p id="2883" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">这会返回一个包含内容字段的JSON对象。内容是base64编码的，需要用JavaScript <code class="fe mn mo mp mq b">atob</code>函数解码。</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="a7fc" class="na la it mq b gy nb nc l nd ne">blob = fetch(bloburl).then (d =&gt; d.json ())</span></pre><p id="f5af" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">如果我们正在读取一个JSON文件，我们也可以使用<code class="fe mn mo mp mq b">JSON.parse</code>将其转换成脚本中的一个对象。</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="121f" class="na la it mq b gy nb nc l nd ne">data = blob.then (d =&gt; JSON.parse (atob (d.content)));</span></pre></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="ce4e" class="kz la it bd lb lc oa le lf lg ob li lj jz oc ka ll kc od kd ln kf oe kg lp lq bi translated">把所有的放在一起</h1><p id="99bf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，随着时间的推移，我们很可能需要使用这段代码，我们可以将它转换成一个函数，并用我们的库加载它。下面显示了一个示例版本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="621e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">这就是你的GitHub JSON文件，它是你前端代码的一部分。</p><p id="3b1d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">感谢阅读。</p></div></div>    
</body>
</html>