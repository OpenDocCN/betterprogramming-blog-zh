<html>
<head>
<title>Services in systemd: In-Depth Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">systemd中的服务:深入教程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/services-in-systemd-in-depth-tutorial-7e47c485edbf?source=collection_archive---------11-----------------------#2020-06-22">https://betterprogramming.pub/services-in-systemd-in-depth-tutorial-7e47c485edbf?source=collection_archive---------11-----------------------#2020-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="98f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">驾驭你从未知晓的力量</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/8b3162b92f3cea463922f43c894d26c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*n5VxnDllO7Eh87CV.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片来源:<a class="ae le" href="https://www.freedesktop.org/wiki/Software/systemd/" rel="noopener ugc nofollow" target="_blank">freedesktop.org</a></p></figure><p id="19c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">systemd是将Linux系统结合在一起的粘合剂。systemd是构建块的集合，它处理服务、进程、日志记录、网络连接，甚至认证。在本文中，我将向您展示如何使用systemd中的服务。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="b4a5" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><code class="fe mk ml mm mn b">systemd</code>到底是什么？</h1><p id="ed5f" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">systemd是一套计算机程序，旨在管理和连接系统的不同部分。它被设计为SystemV和LSB风格的启动脚本的替代品，这两种脚本自20世纪80年代以来一直很流行。systemd由以下组件组成:</p><ul class=""><li id="0a59" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated"><code class="fe mk ml mm mn b">systemd</code> —系统和服务经理</li><li id="ac12" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><code class="fe mk ml mm mn b">systemctl</code> —与<code class="fe mk ml mm mn b">systemd</code>交互的命令行工具</li><li id="b862" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><code class="fe mk ml mm mn b">journald</code> —统一的日志框架</li><li id="7891" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><code class="fe mk ml mm mn b">logind</code> —处理用户登录和席位的守护程序</li><li id="7acd" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><code class="fe mk ml mm mn b">resolved</code>、<code class="fe mk ml mm mn b">timesyncd</code>和<code class="fe mk ml mm mn b">networkd </code> —负责网络连接、域名解析和与互联网资源同步时间</li></ul><p id="5128" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是对systemd体系结构的一个非常高层次的概述，但它目前适合我们。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="e449" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">管理现有服务</h1><p id="108f" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">服务本质上是一个在后台运行并由<code class="fe mk ml mm mn b">systemd</code>管理/供应的流程。您希望作为服务运行的东西包括各种服务器(HTTP、SSH、FTP)、同步实用程序(<a class="ae le" href="https://syncthing.net/" rel="noopener ugc nofollow" target="_blank"> Syncthing </a>、<code class="fe mk ml mm mn b">rsync</code>)、虚拟化管理程序(<a class="ae le" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>、<a class="ae le" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> K8s </a>)等等。让我们首先通过运行以下命令列出系统上所有可用的服务:</p><pre class="kp kq kr ks gt nh mn ni nj aw nk bi"><span id="640b" class="nl ln it mn b gy nm nn l no np">$ systemctl</span></pre><p id="053d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您将看到一个如下所示的表格:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/324b822db0091d9d98d71138d6e5973e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/0*15ugAwfmfefCuXok"/></div></figure><p id="cbb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，这个命令将列出设备、挂载点、名称空间和服务，这是我们感兴趣的。向下滚动以查看服务部分(您会注意到所有内容都有一个<code class="fe mk ml mm mn b">.service</code>扩展名):</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/97ef67dd9a4f9d7227aed55a58b6e7db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*u_z3xruFCZCpVaZK"/></div></figure><p id="29a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该表的结构如下:</p><ul class=""><li id="7e81" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated">服务的名称(匹配<code class="fe mk ml mm mn b">.service</code>配置文件的名称)。</li><li id="f3ff" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">服务的当前状态。<code class="fe mk ml mm mn b">loaded</code>表示<code class="fe mk ml mm mn b">systemd</code>知道了，<code class="fe mk ml mm mn b">active</code>表示<code class="fe mk ml mm mn b">systemd</code>运行成功。</li><li id="d5fb" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">流程的当前状态。表示流程是<code class="fe mk ml mm mn b">running</code>还是<code class="fe mk ml mm mn b">exited</code>。注意，<code class="fe mk ml mm mn b">active</code>服务可以是<code class="fe mk ml mm mn b">exited</code>。例如，一个动作必须在启动时发生，然后进程返回。这项服务仍然被认为是<code class="fe mk ml mm mn b">active</code>。</li><li id="2808" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">描述</li></ul><p id="0913" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想查看特定服务的更多详细信息，请使用以下命令:</p><pre class="kp kq kr ks gt nh mn ni nj aw nk bi"><span id="f6f6" class="nl ln it mn b gy nm nn l no np">$ systemctl status SERVICE_NAME</span></pre><p id="c23b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，在我的系统上运行<code class="fe mk ml mm mn b">systemctl status dbus</code>会产生如下结果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/c13e00c7566c84b2c03b360455f1efd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*ycUmW-7Me5FSXQx7"/></div></figure><p id="a9fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个命令将告诉您比前一个命令更多的信息:例如，正常运行时间、到<code class="fe mk ml mm mn b">.service</code>文件的路径、进程名及其<code class="fe mk ml mm mn b">PID</code>。虽然这很有帮助，但<code class="fe mk ml mm mn b">status</code>通常用于对服务进行故障诊断。比如我有一个服务<code class="fe mk ml mm mn b">syncthing-discosrv</code>有问题。在上面运行相同的命令会告诉我:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/15a8ef7875b358649a09b09d1e7900f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*RbWd-V2auOSWMsMv"/></div></figure><p id="374a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以注意到日志被方便地打印在最后。这精确地告诉我当<code class="fe mk ml mm mn b">systemd</code>试图启动这个服务时发生了什么错误，现在我可以很容易地修复它。</p><p id="fdd2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，最有趣的命令…要启动/停止服务，请使用以下命令:</p><pre class="kp kq kr ks gt nh mn ni nj aw nk bi"><span id="f5a5" class="nl ln it mn b gy nm nn l no np">$ systemctl start/stop SERVICE_NAME</span></pre><p id="38f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，您可以启用或禁用这些服务。启用意味着它将在启动时运行:</p><pre class="kp kq kr ks gt nh mn ni nj aw nk bi"><span id="7f6d" class="nl ln it mn b gy nm nn l no np">$ systemctl enable/disable SERVICE_NAME</span></pre><p id="9f9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，到了有趣的部分。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="87c7" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">创建自己的服务</h1><p id="a5c9" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">如果systemd不允许您创建自己的服务，它将不会非常有用。谢天谢地，这很容易做到。让我们从最基本的例子开始:在引导时运行一个<code class="fe mk ml mm mn b">bash</code>脚本。假设您有一个位于<code class="fe mk ml mm mn b">/usr/bin/runme.sh</code>的脚本，它执行某种清理。现在，要在引导时运行它，您需要创建一个<code class="fe mk ml mm mn b">unit</code>文件。</p><p id="06f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe mk ml mm mn b">/etc/systemd/system/runme.service</code>中创建:</p><pre class="kp kq kr ks gt nh mn ni nj aw nk bi"><span id="6113" class="nl ln it mn b gy nm nn l no np">[Unit] <br/>Description=Cleaning service </span><span id="e84c" class="nl ln it mn b gy ns nn l no np">[Service] <br/>Type=simple ExecStart=/bin/bash /usr/bin/runme.sh </span><span id="dd60" class="nl ln it mn b gy ns nn l no np">[Install] <br/>WantedBy=multi-user.target</span></pre><p id="84c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这应该很简单。<code class="fe mk ml mm mn b">Description</code>设置描述(如本文前面所见)。<code class="fe mk ml mm mn b">Type</code>设置我们服务的类型，如果服务产生多个流程，也可以是<code class="fe mk ml mm mn b">forking</code>。<code class="fe mk ml mm mn b">ExecStart</code>是用于运行服务的实际命令。最后，<code class="fe mk ml mm mn b">WantedBy</code>指定这个服务应该何时运行。<code class="fe mk ml mm mn b">multi-user</code>表示系统定期启动，这是你大部分时间想要的。请注意，如果您以单用户模式(恢复)启动，此服务将不会运行(这可能是您想要的，也可能不是)。现在，要启用此服务:</p><pre class="kp kq kr ks gt nh mn ni nj aw nk bi"><span id="3c8b" class="nl ln it mn b gy nm nn l no np">$ systemctl enable runme <br/>$ systemctl status runme </span><span id="a6d3" class="nl ln it mn b gy ns nn l no np">// .... ENABLED .....</span></pre><p id="a073" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您愿意，也可以立即运行一次:</p><pre class="kp kq kr ks gt nh mn ni nj aw nk bi"><span id="9947" class="nl ln it mn b gy nm nn l no np">$ systemctl start runme</span></pre><p id="96c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们考虑一个稍微复杂一点的例子。假设您有一个Python脚本(位于<code class="fe mk ml mm mn b">/etc/scripts/server.py</code>)，它必须在启动时运行，但是在网络建立之后。此外，您希望它在崩溃时重启，但不要太频繁。如果这听起来像是您的情况，请在您的服务文件中使用如下内容:</p><pre class="kp kq kr ks gt nh mn ni nj aw nk bi"><span id="7e57" class="nl ln it mn b gy nm nn l no np">[Unit] <br/>Description=My awesome service <br/>After=network.target </span><span id="6b96" class="nl ln it mn b gy ns nn l no np">[Service] <br/>type=Simple <br/>User=username <br/>Restart=on-failure <br/>RestartSec=1 <br/>StartLimitBurst=5 <br/>StartLimitIntervalSec=10 <br/>StartLimitAction=reboot <br/>ExecStart=/bin/python /etc/scripts/server.py </span><span id="3655" class="nl ln it mn b gy ns nn l no np">[Install] <br/>WantedBy=multi-user.target</span></pre><p id="49f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有很多新的选择。<code class="fe mk ml mm mn b">After</code>指令指定了该服务对<code class="fe mk ml mm mn b">network</code>目标的依赖性，后者初始化网络连接。稍后，我们将运行脚本的<code class="fe mk ml mm mn b">User</code>指定为<code class="fe mk ml mm mn b">username</code>。现在，有五个选项来控制我们服务的弹性。</p><p id="3915" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mk ml mm mn b">Restart</code>指定何时重新启动服务。<code class="fe mk ml mm mn b">RestartSec</code>不会让<code class="fe mk ml mm mn b">systemd</code>每秒重启一次以上。<code class="fe mk ml mm mn b">StartLimitBurst</code>和<code class="fe mk ml mm mn b">StartLimitIntervalSec</code>说服务在10秒间隔内最多可以重启5次。最后，<code class="fe mk ml mm mn b">StartLimitAction</code>要求重启系统，如果在所有这些重启之后服务仍然失败。显然，如果您的机器上有许多重要的服务，这是不可取的。设置完成后，您可以像其他服务一样启用和启动该服务。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="253b" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结束语</h1><p id="ab1e" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">感谢您的阅读，希望您喜欢这篇文章。请告诉我你对systemd的看法——我听说那里有很多争议。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="e6e8" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">资源</h1><ul class=""><li id="7188" class="mt mu it js b jt mo jx mp kb nt kf nu kj nv kn my mz na nb bi translated"><a class="ae le" href="https://www.freedesktop.org/software/systemd/man/" rel="noopener ugc nofollow" target="_blank"> systemd手册</a></li><li id="17fb" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><a class="ae le" href="https://wiki.archlinux.org/index.php/systemd#Service_types" rel="noopener ugc nofollow" target="_blank">archi wiki上的系统d</a></li><li id="ec6d" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><a class="ae le" href="https://levelup.gitconnected.com/user-management-in-linux-explained-825b8a518abc" rel="noopener ugc nofollow" target="_blank">Linux中的用户管理</a></li></ul></div></div>    
</body>
</html>