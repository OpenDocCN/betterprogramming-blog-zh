<html>
<head>
<title>Encapsulation in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的封装</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/encapsulation-in-python-d76212d52478?source=collection_archive---------5-----------------------#2020-03-18">https://betterprogramming.pub/encapsulation-in-python-d76212d52478?source=collection_archive---------5-----------------------#2020-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3f27" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何降低系统的复杂性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ccf28e51d86ec43cde0ddee278a3d5e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9lerEAnOcVTB__Op49LcFw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">unsplash.com图片鸣谢<a class="ae ky" href="https://unsplash.com/@dtopkin1" rel="noopener ugc nofollow" target="_blank"> @dtopkin1 </a></p></figure><p id="ff9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">封装是面向对象编程的一个重要方面。</p><p id="d443" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用简单的话来解释封装:信息隐藏。这意味着界定内部接口并从外部世界进行归因。</p><p id="64df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">信息隐藏的好处是降低系统的复杂性和增加鲁棒性。为什么？因为封装限制了不同软件组件的相互依赖性。</p><p id="fce5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们创建了一个模块。我们的用户只能通过公共API与我们交互；他们不关心这个模块的内部。即使内部实现的细节发生了变化，用户的代码也不需要相应的改变。</p><p id="57cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现封装，我们需要学习如何定义和使用私有属性和私有函数。</p><p id="b04c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论到此为止，我们来谈谈如何在Python中实现这一点。</p><p id="aa13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python是一种解释型编程语言，实现了<em class="lv">弱封装</em>。弱封装意味着它是按照约定执行的，而不是由语言强制执行的。所以，和Java或者C++还是有一些区别的。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0535" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">受保护的属性和方法</h1><p id="1ff5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果你读过一些Python代码，你总会发现一些属性名带有前缀下划线。让我们写一个简单的<code class="fe na nb nc nd b">Class</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="866a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出将是:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="ec5e" class="nk me it nd b gy nl nm l nn no">hello<br/>hello_again<br/>new name<br/>called _protected_print</span></pre><p id="e49a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从结果来看，带有前缀下划线的属性或方法的行为与普通属性或方法相同。那么，为什么我们需要为属性添加前缀下划线呢？</p><p id="4465" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前缀下划线是对开发人员的警告:请小心这个属性或方法，不要在声明的<code class="fe na nb nc nd b">Class</code>之外使用它！</p><p id="b139" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">pylint</code>会报告这种不良代码气味:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ca"><img src="../Images/f3cfaef8d0d071abb101f9c665a50421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2gxCT-QeOIVIMzWH.png"/></div></div></figure><p id="d13b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前缀分数的另一个好处是，它避免了在定义的模块之外的内部函数的通配符导入。让我们来看看这段代码:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="a549" class="nk me it nd b gy nl nm l nn no"># foo module: foo.py<br/>def func_a():<br/>    print("func_a called!")</span><span id="da70" class="nk me it nd b gy np nm l nn no">def _func_b():<br/>    print("_func_b called!")</span></pre><p id="2d2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，如果我们在代码的另一部分使用通配符导入:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="f783" class="nk me it nd b gy nl nm l nn no">from foo import *</span><span id="f543" class="nk me it nd b gy np nm l nn no">func_a()<br/>_func_b()</span></pre><p id="569c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们会遇到一个错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/9ba18b444caa51342f94a685b5e7dc46.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*ZhZGfwkCmW3wh1QbQ-wW8g.png"/></div></figure><p id="df9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一下，<a class="ae ky" href="http://pep8.org/#imports" rel="noopener ugc nofollow" target="_blank">通配符导入</a>是Python中的另一个不好的味道，我们应该在实践中避免这种情况。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9fd2" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">私有属性和方法</h1><p id="d2bf" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在传统的OOP语言中，为什么私有属性和方法不能被派生的<code class="fe na nb nc nd b">Class</code>访问？因为它在信息隐藏方面很有用。</p><p id="437a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们声明了一个名为<code class="fe na nb nc nd b">mood</code>的属性，但是在派生的<code class="fe na nb nc nd b">Class</code>中，我们重新声明了另一个名为<code class="fe na nb nc nd b">mood</code>的属性。这覆盖了父<code class="fe na nb nc nd b">Class</code>中的前一个，并且可能会在代码中引入一个bug。</p><p id="42bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何使用Python中的私有属性呢？</p><p id="562d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是在属性或方法中添加双前缀下划线。让我们运行这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出将是:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="cf59" class="nk me it nd b gy nl nm l nn no">public value in Base<br/>private value in Base<br/>derived protected</span></pre><p id="ff63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从一个派生的对象中调用<code class="fe na nb nc nd b">public</code>函数，这将调用<code class="fe na nb nc nd b">Base</code>类中的<code class="fe na nb nc nd b">public</code>函数。</p><p id="63a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:因为<code class="fe na nb nc nd b">__private</code>是一个私有方法，只有对象本身可以使用它，私有方法没有命名冲突。</p><p id="45b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们添加另一行代码:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="2cc7" class="nk me it nd b gy nl nm l nn no">d.__private()</span></pre><p id="836c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将触发另一个错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/87568c59e22f35418106e189bb7d6030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LqYDy-HKB57rU7cG.png"/></div></div></figure><p id="d1a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么？让我们打印该对象的所有方法，并找出是否有名为<code class="fe na nb nc nd b">_Base__private</code>的方法。运行代码片段:</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="4721" class="nk me it nd b gy nl nm l nn no">print dir(d)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/2ffe3d58b84417cbad786e47f8302e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Gj1F3YwUXA0q-9B6.png"/></div></div></figure><p id="7602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这被称为Python解释器应用的<code class="fe na nb nc nd b">name mangling</code>。因为名字中添加了前缀名称<code class="fe na nb nc nd b">Class</code>，私有方法被小心地保护起来，以免在派生类中被重写。</p><p id="c491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，这意味着我们可以使用<code class="fe na nb nc nd b">d._Base__private</code>来调用私有函数。记住，不是强制的！</p><p id="29eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>