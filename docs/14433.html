<html>
<head>
<title>Testing a SwiftUI + Combine iOS App Using Clean Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Clean架构测试SwiftUI + Combine iOS应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/testing-a-swiftui-combine-ios-app-using-clean-architecture-f7dee1ba5342?source=collection_archive---------8-----------------------#2022-12-14">https://betterprogramming.pub/testing-a-swiftui-combine-ios-app-using-clean-architecture-f7dee1ba5342?source=collection_archive---------8-----------------------#2022-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f817" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">清洁测试iOS应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0381c783578dc5c3b799b772ad19fba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CKzDklFn81AeaO9E"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/es/@lazizli?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拉拉·阿兹利</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="4cf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是正在进行的文章列表的第二部分。我强烈推荐在继续之前阅读《T21》的第一部分。</p><h1 id="cddb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基本原则</h1><p id="eb86" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">使用clean架构测试用SwiftUI和Combine构建的iOS应用程序可以在几个步骤中完成。首先，您需要为您的应用程序创建测试用例。这可以通过使用Xcode附带的<code class="fe mp mq mr ms b">XCTest</code>框架来完成。</p><p id="bfb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦您创建了您的测试用例，您就可以使用<code class="fe mp mq mr ms b">AnyPublisher</code>类型来测试您的应用程序的输出。<code class="fe mp mq mr ms b">AnyPublisher</code>类型是一个可以产生任何类型输出的发布器，所以你可以用它来测试你的应用程序的<code class="fe mp mq mr ms b">Publisher</code>的输出</p><p id="9a18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要测试产生<code class="fe mp mq mr ms b">String</code>值的<code class="fe mp mq mr ms b">Publisher</code>，可以使用<code class="fe mp mq mr ms b">XCTAssertEqual</code>方法将发布者的输出与预期输出进行比较。例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3800" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，通过使用<code class="fe mp mq mr ms b">sink</code>方法订阅来测试<code class="fe mp mq mr ms b">publisher</code>。当发布者产生一个值时，调用<code class="fe mp mq mr ms b">receiveValue</code>闭包，并使用<code class="fe mp mq mr ms b">XCTAssertEqual</code>方法将输出与<code class="fe mp mq mr ms b">expectedOutput</code>进行比较。如果输出与预期输出不匹配，测试将失败。</p><p id="b5a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用这种方法来测试任何产生<code class="fe mp mq mr ms b">String</code>值的<code class="fe mp mq mr ms b">Publisher</code>，并使用<code class="fe mp mq mr ms b">Error</code>类型发出完成或失败的信号。这是确保应用程序正常运行并产生预期输出的有效方法。</p><h2 id="7039" class="mv lt iq bd lu mw mx dn ly my mz dp mc lf na nb me lj nc nd mg ln ne nf mi ng bi translated">概述</h2><p id="2045" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是我们在构建清洁建筑中的最后一个结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c8ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要测试这个应用程序，您可以使用以下方法:</p><ol class=""><li id="6316" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">为领域层中的类编写单元测试，包括<code class="fe mp mq mr ms b">MyViewModel</code>类。这些测试不应该依赖于表示层或数据访问层中的类，应该验证<code class="fe mp mq mr ms b">MyViewModel</code>类的业务逻辑和数据操作是否正常工作。</li><li id="2573" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">为表示层和领域层中的类编写集成测试。这些测试应该创建<code class="fe mp mq mr ms b">MyView</code>和<code class="fe mp mq mr ms b">MyViewModel</code>类的实例，并验证它们能够正确地协同工作，以显示从数据访问层获取的数据。</li><li id="ad88" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">为数据访问层中的类编写集成测试。这些测试应该创建<code class="fe mp mq mr ms b">DataFetcher</code>协议实现的实例(比如<code class="fe mp mq mr ms b">NetworkDataFetcher</code>和<code class="fe mp mq mr ms b">DatabaseDataFetcher</code>，并验证它们可以正确地从网络或本地数据库获取数据。</li></ol><h1 id="b4f8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">测试</h1><p id="0fce" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">前面的每一个测试都应该单独运行和编写，以便它们可以独立于其他测试运行和验证。这将确保应用程序的不同层被单独和彻底地测试，并且任何改变或添加都不会破坏现有的测试。</p><h2 id="cc9f" class="mv lt iq bd lu mw mx dn ly my mz dp mc lf na nb me lj nc nd mg ln ne nf mi ng bi translated">视图模型</h2><p id="1078" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">例如，<code class="fe mp mq mr ms b">MyViewModel</code>类的单元测试可能如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="832b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前面的代码示例中，创建了测试用例来测试<code class="fe mp mq mr ms b">MyViewModel</code>类的功能。<code class="fe mp mq mr ms b">MyViewModel</code>类负责从<code class="fe mp mq mr ms b">DataFetcher</code>获取数据，并将其提供给视图。</p><p id="dabd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">MyViewModelTests</code>类是<code class="fe mp mq mr ms b">XCTestCase</code>的子类，包含一个名为<code class="fe mp mq mr ms b">testFetchData</code>的测试方法。该方法用于测试<code class="fe mp mq mr ms b">MyViewModel</code>类的<code class="fe mp mq mr ms b">fetchData</code>方法。</p><p id="cb7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">testFetchData</code>方法创建一个<code class="fe mp mq mr ms b">MockDataFetcher</code>实例，并使用它来初始化一个<code class="fe mp mq mr ms b">MyViewModel</code>实例。<code class="fe mp mq mr ms b">MockDataFetcher</code>是一个模拟对象，在测试中用来代替真实的<code class="fe mp mq mr ms b">DataFetcher</code>。<code class="fe mp mq mr ms b">MockDataFetcher</code>有一个<code class="fe mp mq mr ms b">fetchDataResult</code>属性，用于模拟<code class="fe mp mq mr ms b">fetchData</code>方法的输出。</p><p id="ed41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，<code class="fe mp mq mr ms b">testFetchData</code>方法将<code class="fe mp mq mr ms b">MockDataFetcher</code>的<code class="fe mp mq mr ms b">fetchDataResult</code>属性设置为一个特定值，并在<code class="fe mp mq mr ms b">MyViewModel</code>实例上调用<code class="fe mp mq mr ms b">fetchData</code>方法。这模拟了<code class="fe mp mq mr ms b">DataFetcher</code>成功获取数据并将其返回给<code class="fe mp mq mr ms b">MyViewModel</code>的场景。</p><p id="b639" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在调用<code class="fe mp mq mr ms b">fetchData</code>方法后，<code class="fe mp mq mr ms b">testFetchData</code>方法使用<code class="fe mp mq mr ms b">XCTAssertEqual</code>方法将<code class="fe mp mq mr ms b">MyViewModel</code>的<code class="fe mp mq mr ms b">data</code>属性与期望值进行比较。如果<code class="fe mp mq mr ms b">data</code>属性与预期值不匹配，测试将失败。</p><p id="874e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">testFetchData</code>方法也使用一个<code class="fe mp mq mr ms b">XCTestExpectation</code>来等待测试结束。这是必要的，因为<code class="fe mp mq mr ms b">fetchData</code>方法是异步的，测试在完成输出检查之前必须等待。</p><p id="3a3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这种方式，测试用例确保<code class="fe mp mq mr ms b">MyViewModel</code>可以正确地从<code class="fe mp mq mr ms b">DataFetcher</code>获取数据，并使其对视图可用。这有助于确保应用程序正常运行并产生预期的输出。</p><h2 id="f3ec" class="mv lt iq bd lu mw mx dn ly my mz dp mc lf na nb me lj nc nd mg ln ne nf mi ng bi translated">视图-视图模型</h2><p id="6ca6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">类似地，<code class="fe mp mq mr ms b">MyView</code>和<code class="fe mp mq mr ms b">MyViewModel</code>类的集成测试可能如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2931" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定义了一个<code class="fe mp mq mr ms b">MockDataFetcher</code>类，这是一个<code class="fe mp mq mr ms b">DataFetcher</code>类的模拟实现。这个模拟类有一个名为<code class="fe mp mq mr ms b">fetchDataResult</code>的属性，用于模拟<code class="fe mp mq mr ms b">fetchData()</code>操作的结果。</p><p id="238d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">MockDataFetcher</code>类的<code class="fe mp mq mr ms b">fetchData()</code>方法被定义为返回一个<code class="fe mp mq mr ms b">AnyPublisher&lt;String, Error&gt;</code>实例。这意味着调用者可以订阅发布者并异步处理<code class="fe mp mq mr ms b">fetchData()</code>操作的结果。</p><p id="b3c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在测试用例中，<code class="fe mp mq mr ms b">fetchDataResult</code>被设置为一个字符串值，并且在一个<code class="fe mp mq mr ms b">MyViewModel</code>实例上调用<code class="fe mp mq mr ms b">fetchData()</code>方法。测试用例中没有直接处理产生的<code class="fe mp mq mr ms b">AnyPublisher&lt;String, Error&gt;</code>实例，但是预计被测试的<code class="fe mp mq mr ms b">MyView</code>实例将订阅发布者并处理<code class="fe mp mq mr ms b">fetchData()</code>操作的结果。</p><p id="5e69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，测试用例检查<code class="fe mp mq mr ms b">MyView</code>实例中的标签是否具有预期的文本，这表明<code class="fe mp mq mr ms b">fetchData()</code>操作成功，并且<code class="fe mp mq mr ms b">MyView</code>实例能够正确处理操作的结果。</p><h1 id="a3fe" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="a6f3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这两篇文章的主要目的是分离层。</p><p id="0984" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用clean architecture和SwiftUI分离各层并进行合并，请遵循以下步骤:</p><ol class=""><li id="432b" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">确定应用程序中的不同层，例如表示层、域层和数据访问层。</li><li id="5e10" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">您可以对每个识别的层使用SPM。例如，为表示层创建一个“表示”包，为域层创建一个“域”包，为数据访问层创建一个“数据访问”包。</li><li id="a0a9" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">将必要的框架导入到每个包中，比如SwiftUI和Combine用于表示层，Core Data或Realm用于数据访问层。</li><li id="01c6" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">遵循干净的架构原则，定义每个包的必要类型、协议和类。例如，在领域层定义视图模型、模型和用例，在表示层定义视图和视图控制器。</li><li id="b630" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">通过将必要的包相互导入来设置包之间的依赖关系。例如，表示层可能依赖于领域层，而领域层可能依赖于数据访问层。</li><li id="dc5a" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">测试应用程序以确保各层正确分离，并且正确设置了依赖关系。</li><li id="6e45" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">随着应用程序的增长和发展，不断重构和改进架构。</li></ol><p id="0803" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>