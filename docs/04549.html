<html>
<head>
<title>JavaScript Best Practices: Useless Code, Comparisons, and Eval</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践:无用代码、比较和评估</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-best-practices-useless-code-comparisons-and-eval-5c34287dbf16?source=collection_archive---------27-----------------------#2020-04-20">https://betterprogramming.pub/javascript-best-practices-useless-code-comparisons-and-eval-5c34287dbf16?source=collection_archive---------27-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7796" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们清理我们的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7288b1748ca001700c6c8ce05c1b69ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k6UchEauDgHIIKm8"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@creativegangsters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾莉·史密斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9a3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="2340" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将了解一些JavaScript的最佳实践，包括避免空函数和析构、空比较、避免无用的<code class="fe lv lw lx ly b">bind</code>和避免<code class="fe lv lw lx ly b">eval</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ff43" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">不要写空函数</h1><p id="59a4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">空函数没有用，我们也不知道它们是不是故意的。这意味着我们至少应该写一个评论，让人们知道这是不是故意的。</p><p id="1766" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也适用于不返回任何内容的箭头函数回调，因为它们看起来类似于一个空对象。</p><p id="b9ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们应该避免:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="1dec" class="nh mh it ly b gy ni nj l nk nl">function foo() {}<br/>arr.map(() =&gt; {});<br/>arr.map(() =&gt; ({}));</span></pre><p id="c673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们应该写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="eb56" class="nh mh it ly b gy ni nj l nk nl">function foo() {<br/>  // do nothing<br/>}</span></pre><p id="e45c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="64c9" class="nh mh it ly b gy ni nj l nk nl">arr.map(() =&gt; {}); // returns nothing</span></pre><p id="47cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9329" class="nh mh it ly b gy ni nj l nk nl">arr.map(() =&gt; ({})); // returns empty object</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="269f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">空析构模式</h1><p id="1e57" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">空的析构模式也没有用，所以创建它们没有意义。例如，下面的内容是没有用的:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="084b" class="nh mh it ly b gy ni nj l nk nl">const {a: {}} = foo;</span></pre><p id="9245" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它也可能被误认为将<code class="fe lv lw lx ly b">a</code>设置为空对象作为默认值，如下所示:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="09fe" class="nh mh it ly b gy ni nj l nk nl">const {a = {}} = foo;</span></pre><p id="cbd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该避免在代码中使用空的析构模式。如果有的话，我们可以也应该把它们去掉。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="972e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">与==的空值比较</h1><p id="3ca9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">null</code>与<code class="fe lv lw lx ly b">==</code>或<code class="fe lv lw lx ly b">!=</code>的比较也会将我们正在比较的操作数与其他值进行比较。因此，如果我们比较下面代码中的<code class="fe lv lw lx ly b">foo</code>和<code class="fe lv lw lx ly b">null</code>，下面也是<code class="fe lv lw lx ly b">true</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="1086" class="nh mh it ly b gy ni nj l nk nl">let foo = undefined;<br/>foo == null;</span></pre><p id="372b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到<code class="fe lv lw lx ly b">foo == null</code>返回<code class="fe lv lw lx ly b">true</code>，这可能不是我们想要的。同样，如果我们对<code class="fe lv lw lx ly b">!=</code>进行如下比较:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ad4d" class="nh mh it ly b gy ni nj l nk nl">let foo = undefined;<br/>foo != null;</span></pre><p id="6c38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到<code class="fe lv lw lx ly b">foo != null</code>是<code class="fe lv lw lx ly b">false</code>，尽管<code class="fe lv lw lx ly b">foo</code>是<code class="fe lv lw lx ly b">undefined</code>。因此，我们应该使用<code class="fe lv lw lx ly b">===</code>和<code class="fe lv lw lx ly b">!==</code>来检查<code class="fe lv lw lx ly b">null</code>，如下所示:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7423" class="nh mh it ly b gy ni nj l nk nl">let foo = undefined;<br/>foo === null;</span></pre><p id="e09f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c062" class="nh mh it ly b gy ni nj l nk nl">let foo = undefined;<br/>foo !== null;</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b7d8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">永远不要使用eval()</h1><p id="c7e8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们传入一个带有JavaScript代码的字符串并运行它。这很危险，因为它可能会让任何人运行不是我们编写的JavaScript代码。它会使我们的程序面临几种注入攻击。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="199b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">没有本地对象的扩展</h1><p id="e3ee" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在JavaScript中，我们可以用自己的方法扩展任何本地对象。然而，这并不是一个好主意，因为它可能会以我们意想不到的方式破坏其他使用本机对象的代码。</p><p id="59df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有以下内容:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="609e" class="nh mh it ly b gy ni nj l nk nl">Object.prototype.foo = 55;</span><span id="aaea" class="nh mh it ly b gy nm nj l nk nl">const obj = {<br/>  a: 1,<br/>  b: 2<br/>};</span><span id="7e0f" class="nh mh it ly b gy nm nj l nk nl">for (const id in obj) {<br/>  console.log(id);<br/>}</span></pre><p id="354f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到除了<code class="fe lv lw lx ly b">a</code>和<code class="fe lv lw lx ly b">b</code>之外还记录了<code class="fe lv lw lx ly b">foo</code>，因为<code class="fe lv lw lx ly b">for...in</code>循环遍历了当前对象和对象原型链中的所有可枚举属性。</p><p id="16bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于JavaScript默认扩展了JavaScript <code class="fe lv lw lx ly b">Object</code>对象，<code class="fe lv lw lx ly b">for...in</code>循环也将遍历<code class="fe lv lw lx ly b">Object</code>原型中的可枚举属性。</p><p id="dbb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们不应该扩展本机对象，因为它可能会做一些我们不希望其他代码做的事情。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1cab" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">没有不必要的函数绑定</h1><p id="b094" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">bind</code>方法是一个函数的方法，在传统函数内部改变<code class="fe lv lw lx ly b">this</code>的值。所以，如果我们的函数不引用<code class="fe lv lw lx ly b">this</code>，那么我们就不需要在它上面调用<code class="fe lv lw lx ly b">bind</code>来改变<code class="fe lv lw lx ly b">this</code>的值。</p><p id="7093" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，以下函数使用<code class="fe lv lw lx ly b">bind</code>是有目的的:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ef5c" class="nh mh it ly b gy ni nj l nk nl">function getName() {<br/>  return this.name;<br/>}<br/>const name = getName.bind({<br/>  name: "foo"<br/>});<br/>console.log(name());</span></pre><p id="1e19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们有了<code class="fe lv lw lx ly b">getName</code>函数，然后我们对它调用了<code class="fe lv lw lx ly b">bind</code>来将<code class="fe lv lw lx ly b">this</code>的值更改为<code class="fe lv lw lx ly b">{ name: “foo” }</code>。然后当我们在最后一行中调用<code class="fe lv lw lx ly b">name</code>时，我们看到返回<code class="fe lv lw lx ly b">this.name</code>，它应该是<code class="fe lv lw lx ly b">'foo'</code>，因为我们将<code class="fe lv lw lx ly b">this</code>的值更改为对象。</p><p id="39f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6c08" class="nh mh it ly b gy ni nj l nk nl">function getName() {<br/>  return 'foo';<br/>}<br/>const name = getName.bind({<br/>  name: "foo"<br/>});<br/>console.log(name());</span></pre><p id="9bcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么对<code class="fe lv lw lx ly b">bind</code>的调用是无用的，因为<code class="fe lv lw lx ly b">getName</code>没有引用<code class="fe lv lw lx ly b">this</code>。所以，如果我们的函数不引用<code class="fe lv lw lx ly b">this</code>，那么我们就不需要在它上面调用<code class="fe lv lw lx ly b">bind</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f3c2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="d95d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">比较<code class="fe lv lw lx ly b">null</code>和<code class="fe lv lw lx ly b">==</code>没有太大用处，因为像<code class="fe lv lw lx ly b">undefined == null</code>这样的表达式也会因为类型强制而返回<code class="fe lv lw lx ly b">true</code>。为了确保攻击者无法运行恶意代码，不应调用<code class="fe lv lw lx ly b">eval</code>。</p><p id="0a26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在函数中不引用<code class="fe lv lw lx ly b">this</code>，那么<code class="fe lv lw lx ly b">bind</code>是没有用的，所以如果我们调用它，我们应该确保我们的函数中有<code class="fe lv lw lx ly b">this</code>。像空函数和析构模式这样的东西是没有用的，所以应该避免。</p></div></div>    
</body>
</html>