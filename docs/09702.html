<html>
<head>
<title>How To Create a View Pager in Swift 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Swift 5中创建视图页面</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-view-pager-in-swift-5-b8f35a03d968?source=collection_archive---------1-----------------------#2021-09-29">https://betterprogramming.pub/how-to-create-a-view-pager-in-swift-5-b8f35a03d968?source=collection_archive---------1-----------------------#2021-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6424" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你不需要一个第三方库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/93aa192a3c9a9fd3545e3b667738ec4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CH8woMwGacF6yiM7"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sapiton?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米恰伊尔·萨皮顿</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d69d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将学习如何设计和实现一个视图分页器——一个许多应用程序都使用的UI元素。在本教程结束时，我们将会看到以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/7322ec3af7e15713b4fb91b9c38751a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*33e0epr5QzH3vnQ1hgsC1g.gif"/></div></div></figure><p id="77e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将使其可重用和可组合，以便您可以在顶部使用或不使用选项卡式视图。</p><p id="5de9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该项目的源代码可以在文章的底部找到。</p><h1 id="82de" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">我们开始吧</h1><p id="6d25" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果我们将<code class="fe mt mu mv mw b">ViewPager</code>组件分解成更小的部分，我们会看到它由两部分组成:顶部的标签视图和下面的分页视图。理想情况下，我们要么同时使用这两个元素，要么只涉及分页视图组件。为此，我们将有三个主要类别:</p><ul class=""><li id="7003" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated"><code class="fe mt mu mv mw b">ViewPager</code>:将<code class="fe mt mu mv mw b">TabbedView</code>和<code class="fe mt mu mv mw b">PagedView</code>结合在一起，使它们一起工作</li><li id="a0c8" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe mt mu mv mw b">TabbedView</code>:顶部元素，一次只允许选择一个标签。</li><li id="3936" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe mt mu mv mw b">PagedView</code>:底部元素，有“页面”，我们可以滚动。</li></ul><h1 id="31bc" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">页面视图</h1><p id="4688" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们从创建一个简单的<code class="fe mt mu mv mw b">UIView</code>子类及其委托协议开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="b952" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稍后，当用户从一个页面滚动到另一个页面时，我们将使用<code class="fe mt mu mv mw b">PagedViewDelegate</code>向其他类发送通知。</p><p id="d0c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在后台，<code class="fe mt mu mv mw b">PagedView</code>将使用<code class="fe mt mu mv mw b">UICollectionView</code>实现分页。因此，让我们创建<code class="fe mt mu mv mw b">collectionView</code>属性，并遵循<code class="fe mt mu mv mw b">UICollectionViewDelegateFlowLayout</code>和<code class="fe mt mu mv mw b">UICollectionViewDataSource</code>协议:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="fda0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们准备做以下工作:</p><ol class=""><li id="6c16" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nn nd ne nf bi translated">在<code class="fe mt mu mv mw b">numbersOfItemsInSection</code>方法中，我们将返回<code class="fe mt mu mv mw b">PagedView</code>中的总页数。</li><li id="ed81" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">在<code class="fe mt mu mv mw b">cellForItemAt</code>方法中，我们将返回一个代表特定页面的<code class="fe mt mu mv mw b">UICollectionViewCell</code>。</li><li id="577d" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated"><code class="fe mt mu mv mw b">sizeForItemAt</code>方法允许我们设置每个页面的大小。页面将覆盖所有可用空间。</li><li id="9f36" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">我们不需要页面之间的间距，所以我们在<code class="fe mt mu mv mw b">minimumLineSpacingForSectionAt</code>布局委托方法中返回0。</li></ol><p id="617e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要实现实际的<code class="fe mt mu mv mw b">UICollectionView</code>并将其添加到视图层次结构中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一步一步，我们实现了这一目标:</p><ol class=""><li id="146d" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nn nd ne nf bi translated">用水平滚动方向初始化一个<code class="fe mt mu mv mw b">UICollectionViewFlowLayout</code>。</li><li id="bc0c" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">隐藏集合视图的水平滚动指示器并启用分页。</li><li id="9e2b" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">链接集合视图的委托和数据源。</li><li id="4798" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">将<code class="fe mt mu mv mw b">translatesAutoresizingMaskIntoConstraints</code>设置为<code class="fe mt mu mv mw b">false</code>，因为我们正在以编程方式创建UI。</li><li id="17ae" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">在<code class="fe mt mu mv mw b">setupUI()</code>方法中，我们将<code class="fe mt mu mv mw b">collectionView</code>添加到屏幕上，并使其覆盖所有可用空间。我们也不要忘记在初始化器中调用这个方法。</li></ol><p id="9d56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们开始实现代表每个页面的<code class="fe mt mu mv mw b">PageCollectionViewCell</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><ol class=""><li id="00be" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nn nd ne nf bi translated">我们创建了一个代表页面内容的<code class="fe mt mu mv mw b">view</code>属性。</li><li id="22af" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">我们让<code class="fe mt mu mv mw b">view</code>填充整个单元格。</li></ol><p id="a952" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们更新<code class="fe mt mu mv mw b">PagedView.swift</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c801" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们调整了以下内容:</p><ol class=""><li id="a6c5" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nn nd ne nf bi translated">将<code class="fe mt mu mv mw b">pages</code>参数添加到初始化程序中。</li><li id="be5d" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">创建<code class="fe mt mu mv mw b">pages</code>属性。设置后，重新加载集合视图。</li><li id="899c" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">在集合视图中注册先前创建的<code class="fe mt mu mv mw b">PageCollectionViewCell</code>。</li><li id="15d3" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">返回<code class="fe mt mu mv mw b">numberOfItemsInSection</code>数据源方法中<code class="fe mt mu mv mw b">pages</code>的计数。另外，初始化一个<code class="fe mt mu mv mw b">PageCollectionViewCell</code>，给它提供一个页面，在<code class="fe mt mu mv mw b">cellForItemAt</code>数据源方法内部返回。</li></ol><p id="43d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们几乎完成了<code class="fe mt mu mv mw b">PagedView</code>组件。剩下的就是添加一个动作来以编程方式移动页面，并在页面移动时通知其委托。我们将通过添加<code class="fe mt mu mv mw b">moveToPage(at index:)</code>和<code class="fe mt mu mv mw b">scrollViewDidEndDecelerating</code>方法来实现这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><ol class=""><li id="a522" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nn nd ne nf bi translated">当调用<code class="fe mt mu mv mw b">moveToPage(at index:)</code>时，我们将集合视图滚动到目标页面。</li><li id="cfa3" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">一旦用户完成了页面滚动，获取页面索引并通知<code class="fe mt mu mv mw b">PagedView</code>的代理。如前所述，代理可以是另一个视图或视图控制器。当我们想单独使用<code class="fe mt mu mv mw b">PagedView</code>时，我们通常会让视图控制器成为代理。当使用一个尚未创建的包含<code class="fe mt mu mv mw b">PagedView</code>和标签视图的<code class="fe mt mu mv mw b">ViewPager</code>时，<code class="fe mt mu mv mw b">ViewPager</code>将作为<code class="fe mt mu mv mw b">PagedView</code>的代理。</li></ol><p id="0c0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成<code class="fe mt mu mv mw b">PagedView</code>后，现在我们可以开始创建<code class="fe mt mu mv mw b">TabbedView</code>组件，它包含选项卡，一次只能选择一个选项卡:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/f3f0e4bdc287b49df8eb2bd4b0f1b94d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*ZEAJp8BMHJxhWSo6mPLCrg.png"/></div></figure><h1 id="32fe" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">选项卡视图</h1><p id="a0bc" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们首先创建一个<code class="fe mt mu mv mw b">UIView</code>子类，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="17ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们实现了以下目标:</p><ol class=""><li id="657b" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nn nd ne nf bi translated">我们添加了<code class="fe mt mu mv mw b">TabbedViewDelegate</code>来在用户选择特定选项卡时发送通知。</li><li id="d35d" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">枚举<code class="fe mt mu mv mw b">SizeConfiguration</code>可以指定标签的大小，或者让它们填满可用空间。当我们提供一个<code class="fe mt mu mv mw b">.fillEqually</code> <code class="fe mt mu mv mw b">SizeConfiguration</code>时，UI会是这样的:</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/98761828e68fd651712afb0df999db9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*E22ynlWwntKm1PEkDF3HqQ.png"/></div></figure><p id="df33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.在初始化器中，我们设置了<code class="fe mt mu mv mw b">sizeConfiguration</code>属性并启动了<code class="fe mt mu mv mw b">setupUI()</code>方法。</p><p id="3b78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.属性将帮助我们跟踪所选择的选项卡。</p><p id="8f25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.就像我们在<code class="fe mt mu mv mw b">PagedView</code>中做的一样，这里我们创建一个水平<code class="fe mt mu mv mw b">UICollectionView</code>。</p><p id="8d3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">6.<code class="fe mt mu mv mw b">setupUI()</code>方法将集合视图放在屏幕上，并使其填满可用空间。</p><p id="079d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个任务是实现一个代表选项卡的<code class="fe mt mu mv mw b">UICollectionViewCell</code>。让我们创建一个新的<code class="fe mt mu mv mw b">TabCollectionViewCell</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">步骤如下:</p><ol class=""><li id="0c1f" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nn nd ne nf bi translated">创建每个选项卡都需要符合的<code class="fe mt mu mv mw b">TabItemProtocol</code>。当我们想要使用TabbedView时，我们必须为每个选项卡提供自定义视图。这个自定义视图需要实现<code class="fe mt mu mv mw b">TabItemProtocol</code>的<code class="fe mt mu mv mw b">onSelected()</code>和<code class="fe mt mu mv mw b">onNotSelected()</code>方法。</li><li id="ae4f" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">一旦设置了视图属性，我们就启动<code class="fe mt mu mv mw b">setupUI()</code>方法。</li><li id="2223" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">我们添加了一种为每个选项卡设置insets的方法。一旦设置了<code class="fe mt mu mv mw b">contentInsets</code>属性，所有约束都会相应地更新。</li><li id="be67" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated"><code class="fe mt mu mv mw b">setupUI()</code>方法将先前定义的<code class="fe mt mu mv mw b">view</code>属性添加到屏幕上，并激活其约束。</li></ol><p id="27fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！现在我们需要通过实现<code class="fe mt mu mv mw b">UICollectionViewDataSource</code>、<code class="fe mt mu mv mw b">UICollectionViewDelegate</code>和<code class="fe mt mu mv mw b">UICollectionViewDelegateFlowLayout</code>协议来更新<code class="fe mt mu mv mw b">TabbedView.swift</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变化如下:</p><ol class=""><li id="b400" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nn nd ne nf bi translated">我们在初始化器中添加一个<code class="fe mt mu mv mw b">[TabItemProtocol]</code>参数来设置标签。</li><li id="91ea" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">一旦设置了选项卡，我们就重新加载集合视图的数据，并根据<code class="fe mt mu mv mw b">curentlySelectedIndex</code>属性选择一个选项卡。默认情况下，它等于0，因此选择第一个选项卡。</li><li id="bd90" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">我们在集合视图中注册了<code class="fe mt mu mv mw b">TabCollectionViewCell</code>。</li><li id="2d43" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated"><code class="fe mt mu mv mw b">moveToTab(at index:)</code>允许我们以编程方式选择一个期望的选项卡，并相应地更新状态。</li><li id="1cf9" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">在布局的委托的<code class="fe mt mu mv mw b">sizeForItemAt</code>方法中，我们查看提供的<code class="fe mt mu mv mw b">sizeConfiguration</code>属性并设置每个选项卡的大小。</li><li id="b67f" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated"><code class="fe mt mu mv mw b">minimumLineSpacingForSectionAt</code>方法用于在我们需要的时候在每个标签之间放置间距。像以前一样，我们查看<code class="fe mt mu mv mw b">sizeConfiguration</code>属性并返回必要的值。默认情况下，<code class="fe mt mu mv mw b">spacing</code>等于0。</li><li id="fb7a" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">在<code class="fe mt mu mv mw b">numberOfItemsInSection</code>方法中，我们简单地返回标签的数量。</li><li id="011f" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">我们为每个<code class="fe mt mu mv mw b">TabCollectionViewCell</code>提供了一个表示选项卡的视图。</li><li id="27ae" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">最后，我们通过<code class="fe mt mu mv mw b">moveToTab(at index:)</code>方法调整状态变量来对选项卡上的点击做出反应。我们还通知代理用户移动到了特定的选项卡。</li></ol><p id="a185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经完成了<code class="fe mt mu mv mw b">TabbedView</code>的实现。现在我们只需要让<code class="fe mt mu mv mw b">PagedView</code>和<code class="fe mt mu mv mw b">TabbedView</code>一起工作。为此，我们创建了一个新的类— <code class="fe mt mu mv mw b">ViewPager</code>。</p><h1 id="fcee" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">查看寻呼机</h1><p id="73fb" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这个类看起来很简单，它的任务是让<code class="fe mt mu mv mw b">PagedView</code>和<code class="fe mt mu mv mw b">TabbedView</code>一起工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><ol class=""><li id="bbca" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nn nd ne nf bi translated">我们提供了一个<code class="fe mt mu mv mw b">TabbedView.SizeConfiguration</code>参数来为选项卡式视图注入大小配置。</li><li id="0da5" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">在<code class="fe mt mu mv mw b">tabbedView</code>属性中，我们传递注入的大小配置。</li><li id="742e" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated"><code class="fe mt mu mv mw b">setupUI()</code>方法将<code class="fe mt mu mv mw b">TabbedView</code>放在上面，将<code class="fe mt mu mv mw b">PagedView</code>放在下面。</li><li id="2858" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">我们还遵循<code class="fe mt mu mv mw b">TabbedViewDelegate</code>和<code class="fe mt mu mv mw b">PagedViewDelegate</code>来接收任一组件被滚动时的通知。当用户选择一个选项卡时，我们以编程方式将<code class="fe mt mu mv mw b">PagedView</code>移动到必要的页面。同样，当用户滚动页面时，我们选择相应的选项卡。</li></ol><p id="3ad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！我们终于创造了一个可重复使用的<code class="fe mt mu mv mw b">ViewPager</code>。现在是时候在视图控制器中使用它了。</p><h1 id="ead7" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">用法示例</h1><p id="ad1e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们从一个空的<code class="fe mt mu mv mw b">UIViewController</code>开始，上面显示一个“ViewPager”标题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a441" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们创建一个<code class="fe mt mu mv mw b">ViewPager</code>并将其添加到屏幕上，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><ol class=""><li id="23dc" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nn nd ne nf bi translated">我们用一个<code class="fe mt mu mv mw b">.fillEqually</code>大小的配置初始化一个<code class="fe mt mu mv mw b">ViewPager</code>。</li><li id="0d91" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">接下来，我们创建三个不同颜色的视图。它们代表我们的页面。</li><li id="b0c7" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">我们添加了三个标签，标题分别为“第一”、“第二”和“第三”。我们还为视图页面提供了以前创建的页面。</li><li id="43c0" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nn nd ne nf bi translated">我们把<code class="fe mt mu mv mw b">ViewPager</code>放在屏幕上，让它填充70%的可用高度。</li></ol><p id="aac6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们构建并运行该应用程序，我们将会看到我们想要实现的目标:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/59c400f3a8df6abc8db8a06424f1a0e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/1*xKmVwayRgKTLUHHcsWBOew.gif"/></div></figure><h1 id="ac81" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">资源</h1><p id="4284" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">源代码可在<a class="ae ky" href="https://github.com/zafarivaev/uikit-viewpager" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><h1 id="a0e3" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">包扎</h1><p id="b5df" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">希望这篇教程对你有用，感谢阅读！</p></div></div>    
</body>
</html>