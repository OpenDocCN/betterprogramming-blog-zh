<html>
<head>
<title>How to Use Retrofit for Networking in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Android中使用网络改造</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-retrofit-for-networking-in-android-for-beginners-ef6bae5ef113?source=collection_archive---------5-----------------------#2021-08-12">https://betterprogramming.pub/how-to-use-retrofit-for-networking-in-android-for-beginners-ef6bae5ef113?source=collection_archive---------5-----------------------#2021-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9764" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">拨打网络电话从未如此简单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ec91cec1575ccabdb44b3d2cb29ef30a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iVA-4BwG95CxyXup"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ltoinel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ludovic Toinel </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="41dd" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">1.添加依赖项</h1><p id="ba69" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在您项目的<code class="fe mn mo mp mq b">build.gradle</code></p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="a034" class="mv la it mq b gy mw mx l my mz">implementation 'com.squareup.retrofit2:retrofit:2.9.0'<br/>implementation 'com.squareup.retrofit2:converter-gson:2.9.0'<br/>implementation 'com.google.code.gson:gson:2.8.7'</span></pre><p id="b844" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">另外，一定要在您的<code class="fe mn mo mp mq b">manifest.xml</code>中添加<code class="fe mn mo mp mq b">INTERNET</code>权限</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="3d8d" class="mv la it mq b gy mw mx l my mz">&lt;uses-permission android:name="android.permission.INTERNET"/&gt;</span></pre><h1 id="8dbe" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">2.入门指南</h1><p id="0737" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于我们的教程，我们将使用这个特定的<a class="ae ky" href="https://jsonplaceholder.typicode.com/posts" rel="noopener ugc nofollow" target="_blank">端点</a>。打开链接，观察它的JSON响应。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/69ff8b5e8b7559044587cca71e6d78cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZjVuqijz2Ajk8b0Im_qqIw.png"/></div></div></figure><p id="8ee3" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">如果你看一看它，你会发现它是一个POST JSON对象的数组。</p><h1 id="3f12" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">3.创建模型</h1><p id="d62d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">创建我们试图在应用程序中使用的数据模型总是一个很好的实践，所以让我们开始吧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="2fdc" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">4.创建网络存储库</h1><ul class=""><li id="950b" class="ni nj it lt b lu lv lx ly ma nk me nl mi nm mm nn no np nq bi translated">在项目结构中创建一个名为“网络”的包。</li><li id="babe" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">在其中创建一个新的Java接口，并给它命名为<code class="fe mn mo mp mq b">JsonPlaceHolderAPI</code>，这是我们试图使用的API的名称。</li><li id="a98d" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">根据端点的数量，创建不同的方法。对我们来说，我们只是在消费GET Posts端点。所以我们将为它创建一个方法。</li></ul><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="68f4" class="mv la it mq b gy mw mx l my mz">public interface JsonPlaceholderAPI {</span><span id="73c5" class="mv la it mq b gy nw mx l my mz">@GET("posts")<br/>    Call&lt;List&lt;Post&gt;&gt; getPosts();</span><span id="4af3" class="mv la it mq b gy nw mx l my mz">}</span></pre><ul class=""><li id="13f2" class="ni nj it lt b lu na lx nb ma nx me ny mi nz mm nn no np nq bi translated">注意我们在<code class="fe mn mo mp mq b">@GET("posts")</code>中提到了端点后缀，这样改型将知道什么是端点。</li><li id="e276" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">我们还提到了我们期望从这个端点返回的数据类型。</li><li id="5cbf" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">创建好界面后，让我们继续下一步。</li></ul><h1 id="4e20" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">5.提出网络改造要求</h1><p id="941e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><em class="oa">对于本教程，我们主要将逻辑放在活动中，但是在现实世界的项目中，您可以将它放在UI文件之外，放在一个视图模型中，您可以在那里保存UI的业务逻辑。</em></p><p id="f48e" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">我们将使用的导入如下:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="cb70" class="mv la it mq b gy mw mx l my mz">import retrofit2.Call;<br/>import retrofit2.Callback;<br/>import retrofit2.Response;<br/>import retrofit2.Retrofit;<br/>import retrofit2.converter.gson.GsonConverterFactory;</span></pre><ol class=""><li id="1eb6" class="ni nj it lt b lu na lx nb ma nx me ny mi nz mm ob no np nq bi translated"><strong class="lt iu">让我们初始化改造。</strong></li></ol><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="b8d2" class="mv la it mq b gy mw mx l my mz">Retrofit retrofit = new Retrofit.Builder()<br/>        .baseUrl("https://jsonplaceholder.typicode.com/")<br/>        .addConverterFactory(GsonConverterFactory.<em class="oa">create</em>())<br/>        .build();</span></pre><p id="9f20" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">请注意，我们传递的是基本URL，而不是完整的URL，因为接口会负责为所需的端点添加后缀。</p><p id="ffe3" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated"><strong class="lt iu"> 2。现在，让我们使用我们的网络接口。</strong></p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="fe87" class="mv la it mq b gy mw mx l my mz">// We can't do this, guess Why? Hint: Interface<br/>JsonPlaceholderAPI jsonPlaceholderAPI = new JsonPlaceholderAPI();</span><span id="4097" class="mv la it mq b gy nw mx l my mz">// Retrofit will actually do that for you<br/>JsonPlaceholderAPI jsonPlaceholderAPI = retrofit.create(JsonPlaceholderAPI.class);</span><span id="fdc2" class="mv la it mq b gy nw mx l my mz">// Create the Retrofit Call using the interface method<br/>Call&lt;List&lt;Post&gt;&gt; apiCall = jsonPlaceholderAPI.getPosts();</span></pre><p id="94c5" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated"><strong class="lt iu"> 3。现在我们必须最终执行我们的调用。</strong></p><p id="2125" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">我们可以做<code class="fe mn mo mp mq b">apiCall.execute();</code>，但是它会在我们的主UI线程上执行我们的调用，阻塞我们的UI。</p><p id="ab17" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">所以我们应该在后台线程上调用execute，为此我们必须从后台线程管理线程和更新UI。</p><p id="bb87" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">不要担心，翻新已经为你提供了保障。使用如下所示的<code class="fe mn mo mp mq b">.enqueue()</code>操作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="ef0a" class="kz la it bd lb lc oj le lf lg ok li lj jz ol ka ll kc om kd ln kf on kg lp lq bi translated">结论</h1><p id="3d8f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果一切顺利，您的应用程序应该能够进行网络呼叫并无缝更新UI。</p><p id="0c8a" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">感谢阅读！</p></div></div>    
</body>
</html>