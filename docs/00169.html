<html>
<head>
<title>How to Build a Real-Time Chat Application in Node.Js Using Express, Mongoose, and Socket.Io</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Node中构建实时聊天应用程序？Js使用Express、Mongoose和Socket。木卫一</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/simple-chat-application-in-node-js-using-express-mongoose-and-socket-io-ee62d94f5804?source=collection_archive---------0-----------------------#2018-07-30">https://betterprogramming.pub/simple-chat-application-in-node-js-using-express-mongoose-and-socket-io-ee62d94f5804?source=collection_archive---------0-----------------------#2018-07-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0ee4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建您自己的自定义聊天应用程序的详细演练</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ad3e24f5dea96783f8bdc89dfb30b1a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c4mV8Ppc8oe42XVQHfsjQw.png"/></div></div></figure><p id="7d78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本教程中，我们将使用Node.js平台构建一个<strong class="kw iu">实时聊天应用程序</strong>，该应用程序无需任何页面刷新即可向接收者发送和显示消息。我们将使用JavaScript framework Express.js以及Mongoose和Socket.io库来实现这一点。</p><p id="15e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在开始之前，让我们快速浏览一下Node.js的基础知识</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="abc2" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak"> Node.js </strong></h1><p id="314f" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated"><a class="ae mu" href="https://en.wikipedia.org/wiki/Node.js" rel="noopener ugc nofollow" target="_blank"> Node.js </a>是一个开源、跨平台的JavaScript运行时环境，在浏览器之外执行JavaScript代码。使用Node最重要的好处是我们可以将JavaScript同时作为前端和后端语言使用。</p><p id="8a55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我们所知，JavaScript主要用于客户端脚本，其中脚本嵌入在网页的HTML中，并由用户web浏览器中的JavaScript引擎在客户端运行。</p><p id="52be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Node.js允许开发人员使用JavaScript编写命令行工具和服务器端脚本，即在页面被发送到用户的web浏览器之前，在服务器端运行脚本来生成动态网页内容。</p><p id="d3da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管Node是单线程的，但在使用异步函数时，它仍然更快。例如，在从磁盘读取文件或等待HTTP请求完成时，Node可以处理其他事情。异步行为可以使用回调来实现。此外，JavaScript可以很好地处理JSON和非SQL数据库。</p><p id="9790" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在这里下载节点<a class="ae mu" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="9bde" class="mv ly it bd lz mw mx dn md my mz dp mh ld na nb mj lh nc nd ml ll ne nf mn ng bi translated"><strong class="ak"> NPM模块</strong></h2><p id="c403" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">Node.js允许在应用程序中包含库的模块。这些模块可以是用户定义的模块，也可以是第三方模块。</p><p id="b180" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以使用以下命令安装第三方模块:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="adc4" class="mv ly it ni b gy nm nn l no np">npm install module_name</span></pre><p id="9f78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并且可以使用<strong class="kw iu"> require() </strong>函数使用已安装的模块:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="1015" class="mv ly it ni b gy nm nn l no np">var module = require(‘module_name’)</span></pre><p id="551c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在节点应用程序中，我们将使用package.json文件来维护模块版本。此文件可以通过以下命令创建:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="14e7" class="mv ly it ni b gy nm nn l no np">npm init</span></pre><p id="8fd5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">软件包必须按如下方式安装:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="aae0" class="mv ly it ni b gy nm nn l no np">npm install -s module_name</span></pre><p id="0f46" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有许多框架可以作为模块添加到我们的节点应用程序中。这些将根据需要进一步解释。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="9b70" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak">构建简单的聊天应用</strong></h1><p id="69c6" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">我们的应用程序必须允许多个用户一起聊天。消息应该在不刷新页面的情况下更新。为了简单起见，我们将避免认证。</p><p id="71a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以从创建一个新的项目目录并移入其中开始。然后，我们可以使用以下命令启动我们的项目:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="f016" class="mv ly it ni b gy nm nn l no np">npm init</span></pre><p id="f3ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将提示我们输入项目的详细信息。</p><p id="c7ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此后，将创建一个package.json文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="fe77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的应用程序目录现在已经设置好了。</p><p id="187c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要创建的第一件事是服务器。为了实现这一点，我们将使用一个名为<strong class="kw iu"> Express的框架。</strong></p><h2 id="821b" class="mv ly it bd lz mw mx dn md my mz dp mh ld na nb mj lh nc nd ml ll ne nf mn ng bi translated"><strong class="ak">快递. js </strong></h2><p id="ab8b" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">Express.js，或简称为Express，是Node.js的web应用框架。Express <a class="ae mu" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank">为web和移动应用</a>提供了一组强大的功能，以及一个基本web应用功能的薄层，而不会模糊Node.js的功能。</p><p id="18f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用以下命令安装Express.js:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="29da" class="mv ly it ni b gy nm nn l no np">npm install -s express</span></pre><p id="c36b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在package.json文件中，将添加一个新行:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="316f" class="mv ly it ni b gy nm nn l no np">dependencies”: {<br/> “express”: “⁴.16.3”<br/> }</span></pre><p id="109c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将创建一个<strong class="kw iu"> server.js </strong>文件。</p><p id="7d6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个文件中，我们需要require Express并从Express的一个实例中创建一个对变量的引用。HTML、CSS或JavaScript等静态内容可以使用Express.js提供:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="b6e3" class="mv ly it ni b gy nm nn l no np">var express = require(‘express’);</span><span id="b998" class="mv ly it ni b gy ns nn l no np">var app = express();</span></pre><p id="9a6e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用代码开始监听端口:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="c990" class="mv ly it ni b gy nm nn l no np">var server = app.listen(3000, () =&gt; {<br/> console.log(‘server is running on port’, server.address().port);<br/>});</span></pre><p id="30dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们需要创建一个HTML文件，index.html，显示我们的用户界面。我已经添加了bootstrap和JQuery CDN。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c972" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，空的<em class="nt"> &lt;脚本&gt;&lt;/脚本&gt; </em>标签将是我们编写客户端JavaScript代码的地方。</p><p id="4e69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了告诉Express，我们将使用一个静态文件。我们将在<strong class="kw iu"> server.js: </strong>中添加新的一行</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="babc" class="mv ly it ni b gy nm nn l no np">app.use(express.static(__dirname));</span></pre><p id="4971" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用以下命令运行server.js:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="b0b0" class="mv ly it ni b gy nm nn l no np">node ./server.js</span></pre><p id="319c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者使用一个名为<strong class="kw iu"> nodemon，</strong>的包，以便自动检测代码中所做的更改。使用以下命令下载nodemon:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="7d67" class="mv ly it ni b gy nm nn l no np">npm install -g nodemon</span></pre><p id="bbc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">g代表全局，因此它在所有项目中都是可访问的。</p><p id="2be9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用以下命令运行代码:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="3739" class="mv ly it ni b gy nm nn l no np">nodemon ./server.js</span></pre><p id="82d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您转到localhost:3000，我们可以看到索引文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/61c62d26782753c0a7842fe0b082617b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VW53x1q4U8JBkTDJ4rfLYA.png"/></div></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">index.html</p></figure><p id="31f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们的服务器已经启动并运行，我们需要创建我们的数据库。对于这个应用程序，我们将有一个非SQL数据库，并将使用<strong class="kw iu"> MongoDB </strong>，这是我在<a class="ae mu" href="https://mlab.com/" rel="noopener ugc nofollow" target="_blank"><em class="nt">mlab.com</em></a>设置的。我们的数据库将包含一个名为messages的集合，包含字段name和message <strong class="kw iu">。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/626155c7d32be88586d87aad21a607b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_m54iNWbWdcZ8RfRkZ6CyA.png"/></div></div></figure><p id="4a86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了将这个数据库连接到应用程序，我们将使用另一个名为<strong class="kw iu">mongose</strong>的包。</p><h2 id="1b19" class="mv ly it bd lz mw mx dn md my mz dp mh ld na nb mj lh nc nd ml ll ne nf mn ng bi translated"><strong class="ak">猫鼬</strong></h2><p id="05ed" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">Mongoose是一个MongoDB对象建模工具，设计用于在异步环境中工作。可以使用以下命令安装Mongoose:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="1da4" class="mv ly it ni b gy nm nn l no np">npm install -s mongoose</span></pre><p id="202f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在server.js中，我们需要Mongoose:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="bf0f" class="mv ly it ni b gy nm nn l no np">var mongoose = require(‘mongoose’);</span></pre><p id="1744" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将分配一个变量，mlab数据库的URL:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="5a5b" class="mv ly it ni b gy nm nn l no np">var dbUrl = ‘mongodb://username:pass@ds257981.mlab.com:57981/simple-chat’</span></pre><p id="2aeb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Mongoose将使用连接方法连接到mlab数据库:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="11f7" class="mv ly it ni b gy nm nn l no np">mongoose.connect(dbUrl , (err) =&gt; { <br/>   console.log(‘mongodb connected’,err);<br/>})</span></pre><p id="e758" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将把我们的消息模型定义为:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="07f6" class="mv ly it ni b gy nm nn l no np">var Message = mongoose.model(‘Message’,{ name : String, message : String})</span></pre><p id="182f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在可以实现聊天逻辑，但在此之前，还需要添加一个包。</p><h2 id="afea" class="mv ly it bd lz mw mx dn md my mz dp mh ld na nb mj lh nc nd ml ll ne nf mn ng bi translated"><strong class="ak">主体解析器</strong></h2><p id="bc21" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">Body-Parser提取传入请求流的整个主体部分，并在req.body上公开它。</p><p id="0f63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用以下命令安装它:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="3a6d" class="mv ly it ni b gy nm nn l no np">npm install -s body-parser</span></pre><p id="d529" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将以下代码添加到<strong class="kw iu"> server.js: </strong></p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="c06c" class="mv ly it ni b gy nm nn l no np">var bodyParser = require(‘body-parser’)<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({extended: false}))</span></pre><h2 id="b22e" class="mv ly it bd lz mw mx dn md my mz dp mh ld na nb mj lh nc nd ml ll ne nf mn ng bi translated"><strong class="ak">路由</strong></h2><p id="b4e5" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">路由是指应用程序的端点(URIs)如何响应客户端请求。使用与HTTP方法对应的Express app对象的方法定义路由:app.get()处理get请求，app.post()处理post请求。</p><p id="d56d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些路由方法<a class="ae mu" href="https://expressjs.com/en/guide/routing.html" rel="noopener ugc nofollow" target="_blank">指定了一个回调函数</a>(有时称为“处理函数”)，当应用程序接收到对指定路由(端点)和HTTP方法的请求时调用这个函数。换句话说，应用程序“监听”与指定的路由和方法匹配的请求，当它检测到匹配时，它调用指定的回调函数。</p><p id="201b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们需要为我们的聊天创建两条消息路径。</p><p id="dae9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">server.js内部:</p><ul class=""><li id="1c02" class="oa ob it kw b kx ky la lb ld oc lh od ll oe lp of og oh oi bi translated"><strong class="kw iu"> Get </strong>将从数据库中获取所有消息:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><ul class=""><li id="0006" class="oa ob it kw b kx ky la lb ld oc lh od ll oe lp of og oh oi bi translated"><strong class="kw iu"> Post </strong>将用户创建的新消息发布到数据库:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0474" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了将这些路由连接到前端，我们需要在index.html的客户端脚本标记中添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="4e41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，sendMessage用于调用消息的post路由，并保存用户发送的消息。当用户单击“发送”按钮时，会创建该消息。</p><p id="b4d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类似地，<strong class="kw iu"> getMessage </strong>用于调用消息的get路由。这将获得保存在数据库中的所有消息，并将被追加到messages div中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/fc8e1c523b5bff539ceae1300bf4e6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pxh-SiljJf1JY4KwXEf4Fg.png"/></div></div></figure><p id="7ea2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在唯一的问题是客户端没有办法知道服务器是否更新了。因此，每次我们发布消息时，我们都需要刷新页面来查看新消息。</p><p id="da1a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了解决这个问题，我们可以添加一个推送通知系统，从服务器向客户端发送消息。在Node.js中我们使用socket.io。</p><h2 id="d36c" class="mv ly it bd lz mw mx dn md my mz dp mh ld na nb mj lh nc nd ml ll ne nf mn ng bi translated"><strong class="ak"> Socket.io </strong></h2><p id="02d5" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">插座。IO是一个用于实时web应用程序的JavaScript库。<a class="ae mu" href="https://www.tutorialspoint.com/socket.io/socket.io_overview.htm" rel="noopener ugc nofollow" target="_blank">它支持web客户端和服务器之间的实时双向通信</a>，由两部分组成:在浏览器中运行的客户端库和Node.js的服务器端库。Socket.io支持基于事件的实时双向通信。</p><p id="f465" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要安装socket.io:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="f8c1" class="mv ly it ni b gy nm nn l no np">npm install -s socket.io</span></pre><p id="aa85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还需要一个HTTP包来让Socket.io工作:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="9317" class="mv ly it ni b gy nm nn l no np">npm install -s http</span></pre><p id="85de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将以下代码添加到server.js中:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="835a" class="mv ly it ni b gy nm nn l no np">var http = require(‘http’).Server(app);<br/>var io = require(‘socket.io’)(http);</span></pre><p id="eeb3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并创建一个连接:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="842d" class="mv ly it ni b gy nm nn l no np">io.on(‘connection’, () =&gt;{<br/> console.log(‘a user is connected’)<br/>})</span></pre><p id="55f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在index.html的<strong class="kw iu">、</strong>中添加以下标记:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="dd37" class="mv ly it ni b gy nm nn l no np">&lt;script src=”/socket.io/socket.io.js”&gt;&lt;/script&gt;</span></pre><p id="a742" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，当在server.js中创建消息时，我们需要创建一个发出动作。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="1414" class="mv ly it ni b gy nm nn l no np">app.post('/messages', (req, res) =&gt; {<br/>  var message = new Message(req.body);<br/>  message.save((err) =&gt;{<br/>    if(err)<br/>      sendStatus(500);<br/>    <strong class="ni iu">io.emit('message', req.body);</strong><br/>    res.sendStatus(200);<br/>  })<br/>})</span></pre><p id="dce9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并在客户端脚本标签中的【index.html】、<strong class="kw iu">、</strong>中添加以下代码:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="a3b2" class="mv ly it ni b gy nm nn l no np">var socket = io();</span><span id="f8d9" class="mv ly it ni b gy ns nn l no np">socket.on(‘message’, addMessages)</span></pre><p id="a410" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以每次发布消息时，服务器都会更新message div中的消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/f95cf97d09a07223cd6813ddbb9d0ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9mXhm02mDZTIMxmcGnPZWg.png"/></div></div></figure><p id="6ff2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太好了！</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="81d9" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">结论</h1><p id="5361" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">我们在Node.js中创建了一个非常基本的消息应用程序，还有很多改进的空间。我希望这有助于理解一些基本概念。完成的代码可以在<a class="ae mu" href="https://github.com/amkurian/simple-chat" rel="noopener ugc nofollow" target="_blank">https://github.com/amkurian/simple-chat</a>中找到。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">server.js</p></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="02e1" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">链接和参考</h1><div class="oj ok gp gr ol om"><a href="https://socket.io/" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">插座。超正析象管(Image Orthicon)</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">插座。IO 2.0在这里以最快和最可靠的实时引擎为特色~/Projects/tweets/index . js var IO =…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">socket.io</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ks om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://expressjs.com/" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">Express - Node.js web应用程序框架</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">Express是一个最小且灵活的Node.js web应用程序框架，它为web和…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">expressjs.com</p></div></div></div></a></div><p id="d6d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">http://mongoosejs.com/<a class="ae mu" href="http://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>