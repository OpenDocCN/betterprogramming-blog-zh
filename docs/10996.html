<html>
<head>
<title>How to Build User Notifications With AWS WebSockets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用AWS WebSockets构建用户通知</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-user-notifications-with-aws-websockets-93b1b16b8af4?source=collection_archive---------11-----------------------#2022-02-09">https://betterprogramming.pub/how-to-build-user-notifications-with-aws-websockets-93b1b16b8af4?source=collection_archive---------11-----------------------#2022-02-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cb07" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当长时间运行的任务完成时发送通知是异步软件成功的关键。通过WebSockets，我们可以在几分钟内将它添加到我们的工作流程中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2ae38624c52c19856de5981c499282c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rYOKQKFOkn32FJlQA9GwYA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/s/photos/notification?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@prateekkatyal?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Prateek Katyal </a>拍摄</p></figure><p id="039b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你登录像脸书这样的网站时，你首先会看哪里？你的提要的顶部？故事横幅？</p><p id="a7cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大概不会。</p><p id="c998" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的眼睛直接看工具栏，看看是否有一个红色的小徽章显示你的通知或新朋友的请求。我们没办法，我们喜欢通知。</p><p id="5ac1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到的每一个小通知都会在我们的大脑中发出一个信号，给我们一种满足感。老实说，我们对通知上瘾了。那么，还有什么比用我们的WebSocket来实现更好的呢？</p><p id="b7ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您一直在关注，这是WebSockets介绍系列的第四部分。每一部分都建立在前一部分的基础上，所以如果你现在加入我们，我强烈推荐阅读前三部分。</p><ul class=""><li id="2727" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-aws-websockets-8b336a92c379">第一部分——构建一个WebSocket </a></li><li id="da99" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/using-authoriser-for-aws-websockets-caf7a0441c8e">第二部分——保护您的网络插座</a></li><li id="c0f8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/aws-websockets-writing-documentation-using-async-api-spec-6c4ccc77f20">第三部分—使用异步API规范的文档</a></li></ul><p id="1f47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们将扩展我们已经构建的内容来创建<strong class="lb iu">用户通知</strong>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="aec7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">部署到云</h1><p id="1e91" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">就像前面三个部分一样，工作都是提前完成的。要部署添加用户通知的更新，请在本地机器上的repo 的根目录下的终端中运行以下命令。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="1130" class="ns mr it no b gy nt nu l nv nw">git fetch <br/>git checkout part-four <br/>npm run deploy</span></pre><p id="aa16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将检验演练的这一部分，并将其部署到AWS。支持用户通知的更新包括:</p><ul class=""><li id="52d8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">一个lambda函数，用于搜索和发布特定的用户连接</li><li id="156a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html" rel="noopener ugc nofollow" target="_blank">死信队列(dlq)</a>事件传递/处理失败</li><li id="a4b4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html" rel="noopener ugc nofollow" target="_blank"> CloudWatch警报</a>用于在出现故障时发出通知</li><li id="8e96" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">对异步API规范的更新，定义了新的输入和输出事件</li></ul><p id="2b57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，在现有的基础上增加用户通知很容易。我们的数据结构允许特定用户 <a class="ae ky" href="https://docs.aws.amazon.com/prescriptive-guidance/latest/dynamodb-data-modeling/step3.html" rel="noopener ugc nofollow" target="_blank">访问模式</a>的<em class="nx"> give me connections，所以修改很简单。</em></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="652b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">查找用户连接</h1><p id="ae7e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">利用我们在上一篇文章中构建的web socket<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/using-authoriser-for-aws-websockets-caf7a0441c8e">，我们向<em class="nx"> $connect </em>端点添加了一个lambda authorizer，它将连接用户的<code class="fe ny nz oa no b">userId</code>保存到数据库中。</a></p><p id="2f14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用这些信息来查找用户打开的连接，以便向他们发送推送通知。当一个新的<code class="fe ny nz oa no b">Send User Push Notification</code> EventBridge事件进来时，我们可以在数据库中查询那个<code class="fe ny nz oa no b">userId</code>的所有连接，并向它们发送一条消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/b35f5ab86a513d9bc2b94f7c9db101db.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/0*HP5GjCwbzRzs1rEb.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oc">使用连接详情接收推送通知</em></p></figure><p id="43fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的数据模型中，我们将用户id作为<code class="fe ny nz oa no b">pk</code>保存在我们的<code class="fe ny nz oa no b">GSI</code>中，这样我们就能够只对传入事件中提供的用户id运行查询。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="c141" class="ns mr it no b gy nt nu l nv nw">{ <br/>  "pk": "&lt;connectionId&gt;", <br/>  "sk": "connection#", <br/>  "GSI1PK": "&lt;userId&gt;", <br/>  "GSI1SK": "user#", <br/>  "ipAddress": "&lt;connecting ip address&gt;", <br/>  "connectedAt": "&lt;epoch connected at time&gt;", <br/>  "ttl": "&lt;time to live before connection is removed&gt;" <br/>}</span></pre><p id="cbd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html" rel="noopener ugc nofollow" target="_blank">全局二级索引(GSI) </a>允许我们查询数据库中具有<code class="fe ny nz oa no b">userId</code>的<code class="fe ny nz oa no b">GSI1PK</code>的所有记录。这允许我们获得到WebSocket的连接，这样我们就可以传递来自事件的消息。<a class="ae ky" href="https://github.com/allenheltondev/serverless-websockets/blob/part-four/lambdas/create-user-notification/index.js#L39" rel="noopener ugc nofollow" target="_blank">参见λ函数</a>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d627" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">用户通知的类型</h1><p id="d701" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们可以通过WebSocket连接实现两种不同类型的用户通知:<strong class="lb iu">可操作</strong>和<strong class="lb iu">反馈</strong>通知。就用户体验而言，每个通知都有其独特的用途。</p><h2 id="625d" class="ns mr it bd ms od oe dn mw of og dp na li oh oi nc lm oj ok ne lq ol om ng on bi translated">可操作的通知</h2><p id="dbec" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果我们在脸书点击一个通知，它什么也不做，它可能不会有这样的上瘾效果。但是如果你点击它，你被带到某个地方去执行一个动作，那么通知就有了价值。</p><p id="d3c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过WebSocket发送给用户的推送通知包含两条数据:</p><ul class=""><li id="c3b2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">向用户显示的<strong class="lb iu">消息</strong></li><li id="a4ad" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">用户可以跟随一个<strong class="lb iu">回调</strong>来执行一个动作</li></ul><p id="4e45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该消息将通知用户发生了一些事情，回调将让他们做一些事情。以这个事件为例:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="56ea" class="ns mr it no b gy nt nu l nv nw">{ <br/>  "message": "The XYZ report has finished processing and is ready for review.", <br/>"callback": "https://www.gopherholesunlimited.com/jobs/736ajdff7/results" <br/>}</span></pre><p id="b221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过此消息，用户可以看到他们请求的报告已经完成处理。当他们转到<code class="fe ny nz oa no b">callback</code> url时，他们会看到与该消息相关的结果。</p><h2 id="6871" class="ns mr it bd ms od oe dn mw of og dp na li oh oi nc lm oj ok ne lq ol om ng on bi translated">反馈通知</h2><p id="6b6a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">另一方面，反馈通知提供状态更新。他们不会在用户界面的通知图标旁边添加一个红色的小徽章。</p><p id="d8cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在等待一个长时间运行的流程，一个<em class="nx">反馈通知</em>会向您提供关于它在流程中的位置的更新。一个例子是上传的完成百分比或一条消息，说明作业正在做什么。如果我们使用报告示例，反馈用户通知应该如下所示:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="5874" class="ns mr it no b gy nt nu l nv nw">{ <br/>  "message": "Calculating average time between status changes..." <br/>}</span></pre><p id="e19d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意这个通知中没有<code class="fe ny nz oa no b">callback</code>。它只提供信息，不提供任何操作。</p><blockquote class="oo"><p id="70fe" class="op oq it bd or os ot ou ov ow ox lu dk translated"><em class="oc">反馈通知的目的是向最终用户保证系统正在做一些事情。</em></p></blockquote><p id="4bf7" class="pw-post-body-paragraph kz la it lb b lc oy ju le lf oz jx lh li pa lk ll lm pb lo lp lq pc ls lt lu im bi translated">提醒用户后台正在发生一些事情总是一个好主意，这样他们就不会认为有什么地方出错了。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="fa65" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">推送通知的错误处理</h1><p id="f008" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当涉及到错误处理时，事件驱动架构(EDA)是出了名的困难。由于我们使用无服务器服务，我们加倍了对增强可观察性的需求。</p><p id="8c00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了帮助跟踪WebSocket的状态，我们实现了死信队列，这样当出现问题时，我们可以在一个位置丢弃事件。在我们的WebSocket中，我们会遇到两种类型的问题:</p><ol class=""><li id="3e52" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu pd mb mc md bi translated">事件传递失败</li><li id="b9ec" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu pd mb mc md bi translated">事件处理失败</li></ol><p id="eb7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">当EventBridge无法将事件放入我们的SQS队列时，或者当事件无法从SQS传输到处理lambda时，会发生事件交付失败</strong>。这可能是由于系统中断或配置不当造成的。不管根本原因是什么，我们都会把它送到DLQ进行监控和分类。一旦它进入DLQ，我们就可以调查系统中发生了什么，并尝试修复它。</p><p id="a545" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了向DLQ发送一个事件交付失败，我们<a class="ae ky" href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-rule-dlq.html" rel="noopener ugc nofollow" target="_blank">更新我们的EventBridge规则</a>来定位交付失败的队列。</p><p id="57e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">事件处理失败</strong>发生在我们的代码中。我们要么在代码中有一个bug，事件没有我们期望的数据，要么可能我们在代码中调用的服务已经被抑制或者正在经历一个失败。我们再一次将这些错误推给DLQ，这样我们就不必在出现问题时立即做好准备。</p><p id="7463" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将事件处理失败发送到DLQ，我们利用<a class="ae ky" href="https://aws.amazon.com/blogs/compute/introducing-aws-lambda-destinations/" rel="noopener ugc nofollow" target="_blank">λ目的地</a>来路由失败事件。</p><h2 id="954b" class="ns mr it bd ms od oe dn mw of og dp na li oh oi nc lm oj ok ne lq ol om ng on bi translated">如何知道何时出现错误</h2><p id="2df5" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">向DLQ发送错误是一回事，但是您如何知道什么时候需要您的注意呢？</p><p id="94d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了知道什么时候出了问题，我们实现了一个监视DLQ的CloudWatch警报。每当DLQ中有1+项时，SNS主题就会触发，并通知相关方系统出现故障。</p><p id="d8a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦死信队列中的所有项目被清除，警报将关闭，并继续关注下一个事件。</p><h2 id="4f70" class="ns mr it bd ms od oe dn mw of og dp na li oh oi nc lm oj ok ne lq ol om ng on bi translated">如何处理DLQ中的错误</h2><p id="8f25" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当DLQ出现错误时，有两种选择:<em class="nx">手动操作</em>和<em class="nx">自动重试</em>。当您习惯于对事件驱动的错误进行故障排除时，可以考虑专门从手动操作开始。在尝试自动化之前，找出解决它们的模式。</p><p id="6509" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦确定了可以重试的错误以及如何修复它们，就应该开始围绕这个过程构建基础设施。乐高团队<a class="ae ky" href="https://youtu.be/HcbnrJdNBRI?t=365" rel="noopener ugc nofollow" target="_blank">有一个令人难以置信的视频</a>展示了他们如何在系统中自动重试事件交付失败。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="e502" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="b97c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">用户通知在任何系统中都很重要。保持终端用户的参与是产品保持的关键部分。如果应用程序在任何长时间运行的过程中默默失败(或成功)，用户将被要求探索应用程序以发现正在发生的事情。</p><p id="4fe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用WebSocket API，添加这些类型的通知很容易。现在就看你自己在app里实现了。您可以将它们作为工作流的一部分包含在您的<a class="ae ky" href="https://aws.amazon.com/step-functions/?step-functions.sort-by=item.additionalFields.postDateTime&amp;step-functions.sort-order=desc" rel="noopener ugc nofollow" target="_blank"> AWS步骤函数</a>中，或者在异步lambda函数完成时将它们作为目标。</p><p id="10cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的WebSocket系列中，接下来是一个如何将我们构建的内容整合到现有应用程序中的示例。我们已经构建了WebSocket，现在是我们使用它的时候了。</p><p id="cae2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我鼓励您将这个堆栈部署到您的AWS帐户中，并尝试使用它。此时，我们已经构建了一个生产就绪的WebSocket微服务。所以把它拿出来，开始使用吧！</p><p id="9c9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>