<html>
<head>
<title>React v18: useRef — What, When and Why?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React v18: useRef —什么，什么时候，为什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-v18-demystifying-useref-forwardref-and-useimperativehandle-feec2fc5b2f6?source=collection_archive---------3-----------------------#2022-07-19">https://betterprogramming.pub/react-v18-demystifying-useref-forwardref-and-useimperativehandle-feec2fc5b2f6?source=collection_archive---------3-----------------------#2022-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="271e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第1部分:驯服React的必要之恶— <strong class="ak"> useRef </strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b5fc7f75fb8d883652e78915eb65284a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*urTMJMt_SUkUi8XFDZAzMQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">React useRef、forwardRef和useImperativeHandle</p></figure><p id="489d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">值和引用的概念对任何程序员来说都不陌生。顾名思义，值是数据在某个时间点的简单快照。为了唤起你对后者的记忆，引用是指向一些数据的指针，这些数据可能会随着时间的推移而改变，但引用本身保持不变。把它想象成一个房子的地址；地址总是保持不变，尽管房子可能会随着时间的推移翻新成一个新的。</p><p id="e9c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">React高度推荐从UI = function(state)的角度来思考。这种简化可能可以处理99%我们习惯于用传统的基于DOM的范例做的事情，但是最后的1%需要一些管道。</p><p id="5ecf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">React团队以引用的形式为这种情况留下了一个出口。依我看，refs是一个必要的恶魔，它帮助我们解决React本身由于其数据驱动的设计理念而无法提供解决方案的问题。</p><p id="ed7e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为refs很难理解。我们将分别讨论标题中提到的三个方面。对于第1部分，我们将了解什么是React引用，以及如何使用最基本的useRef钩子。在接下来的部分，我们将讨论更复杂的例子和用例。</p><h1 id="602c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated"><strong class="ak"> useRef </strong></h1><p id="f37f" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">从使用React提供的<code class="fe mo mp mq mr b">useRef</code>钩子的最基本实现开始。让我们考虑这样一种情况，它不需要花哨的DOM闩锁，只需要一个简单的数字来引用React的状态系统之外的内容。我们的应用程序将是一个超级简单的计数器应用程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">组件在更新包含在React状态中的数据时重新呈现。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/e578a566e513cc42d6d85043b72996ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tuuGb7QC2TVEXNwe4tDEHw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">组件在更新包含在React状态中的数据时重新呈现。</p></figure><p id="199b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从控制台日志中推断出我们的组件对num值的每一次更改都要重新呈现，这并不是什么复杂的科学，在复杂的生产应用程序中，这可能是一场噩梦。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="ae75" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们尝试将ref引入图片，看看它的表现如何。我们将在这里引入一个数字，它不应该在重新渲染之间改变，而且，如果它的值改变，也不应该导致重新渲染。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">React refs跨组件重新呈现器保存数据，并且在更新时不会导致重新呈现。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/a7e4df84c1d8c329d138d302f55780a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A5o_zRUjKGA94SuvuXkTmQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">React refs跨组件重新渲染保存数据，并且在更新时不会导致重新渲染。</p></figure><p id="b09e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我们从这个例子中看到的，我们的应用程序可以保留存储在ref变量中的随机值，即使组件由于单击increment按钮而重新呈现。从这个实验中得到的关键是，引用的值在这里是独立于组件生命周期的。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="4572" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看一个更实际的例子，在这个例子中，我们将看到实际应用中使用的基准电压源。在本例中，我们有一个HTML输入元素，我们想看看它是否为空。如果是，那么我们在那里放一些随机值。</p><p id="5ab5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">React相信单向受控组件策略，即输入应该与某个状态相关联，并且我们在输入中看到的内容应该仅通过链接状态的变化来生成。在我们的案例中，没有任何州与此相关联。我们也不想像过去的学校方式一样，用<code class="fe mo mp mq mr b">id</code>和<code class="fe mo mp mq mr b">document.getElementById</code>开始，从而大发雷霆。</p><p id="dc9f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以做的是使用一个引用作为指向这个DOM元素的指针，并在reactor中控制它的值。让我们看看下面的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Refs帮助我们连接到页面上的任何DOM元素，并以官方方式与它们交互。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/cdb043d0efae6d42d2e3868388c273ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4jtCtuKToWhBA4jspdu-ug.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Refs帮助我们控制页面上的任何DOM元素，并在反应方式之外与它交互。</p></figure><p id="46e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从上面的演示中，我们可以看到输入是第一次自己填充的，而且也没有直接访问真正的DOM API。我们的<code class="fe mo mp mq mr b">inputRef</code>充当了一个指向输入DOM元素的指针，使用它我们可以直接管理它的属性，绕过反应的状态系统。</p><p id="349f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通常不鼓励使用refs管理表单，因为它会扼杀使用像reactor这样的状态驱动库的全部理由。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="e29e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看更适合使用反应参考文献的东西。想象一下，我们加载了一个表单，我们希望自动将焦点转移到一个输入字段，以获得UX核仁巧克力饼分数。我们可以以上述应用程序为例，使用refs将输入字段集中在load上。这是一个很受欢迎的功能，可以形成负载，你知道从哪里开始。在黄金时代，这也可以打开你的移动键盘，但现在因为安全和用户偏好而被屏蔽了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用反应参考聚焦输入字段。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/3afb56377b6c5d4c0c84a3a66a43dbd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*edJOV8FJjC9zS34N3rEuBg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用反应参考聚焦输入字段。</p></figure><h1 id="ad6b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">黑暗面</h1><p id="122e" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">如果这样强大的东西呈现给程序员，他们怎么能不滥用它呢？但是，仅仅因为我们有大量的降落伞，并不意味着每天都是跳伞日。ref用于需要直接dom的情况，如上面的示例。第一个反例也可以通过使用<code class="fe mo mp mq mr b">useMemo</code>钩子缓存来处理。</p><p id="0191" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">React警告我们不要在虚拟DOM系统中直接访问DOM。最大的问题是可预测性。如果某个东西没有正确通知reactor就直接更改了DOM元素，那么reactor中的单向数据模型将不会响应。</p><p id="8262" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的例子中，如果我们做一个小的超时触发，将直接改变数据，我们将失去对我们为受控改变定义的其他组件的通知。我们可以看到，在ref更改值后，下部段落标记中的消息没有更新。</p><div class="kg kh ki kj gt ab cb"><figure class="ne kk nf ng nh ni nj paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/a953d8a19056c9c1e9b840031c14d783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*JnOysx6wAx5wxwVEWM25_Q.png"/></div></figure><figure class="ne kk nf ng nh ni nj paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/3880a80474d78789904002348dcf54cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*OGuCqKG1qmE3NL4TNKwE2w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk nk di nl nm translated">通过使用ref在2秒的超时时间内直接更新的值破坏了我们的应用程序。</p></figure></div><h1 id="2ef2" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">结论</h1><p id="65fd" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我们已经看了足够多的例子来理解裁判如何帮助我们，以及我们应该注意什么。在下一部分中，我们将研究一些更复杂的用例，对于需要跨组件通信并将引用传递给其他组件的大型应用程序来说，这些用例可能会很方便。</p><blockquote class="nn"><p id="bfe1" class="no np iq bd nq nr ns nt nu nv nw lq dk translated">第二部分在这里:<a class="ae nx" href="https://medium.com/p/89cce42b3309" rel="noopener">https://medium.com/p/89cce42b3309</a></p></blockquote></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt ny mr nz oa aw ob bi"><span id="0e47" class="oc ls iq mr b gy od oe l of og"><strong class="mr ir">Want To Connect?</strong></span><span id="4d73" class="oc ls iq mr b gy oh oe l of og">LinkedIn: <a class="ae nx" href="https://www.linkedin.com/in/sameerkumar1612/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/sameerkumar1612</a></span></pre></div></div>    
</body>
</html>