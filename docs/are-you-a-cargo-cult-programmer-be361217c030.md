# 你是一个货物邪教程序员吗？

> 原文：<https://betterprogramming.pub/are-you-a-cargo-cult-programmer-be361217c030>

## 许多程序员都是这样，但是你可以学着与众不同

![](img/d3e9d75abd5e193e5dfd4a4933a9cf23.png)

货物崇拜—[https://www.iamag.co/short-movie-cargo-cult/](https://www.iamag.co/short-movie-cargo-cult/)

# 什么是货物崇拜

这要追溯到二战时期。作为战争努力的一部分，盟军必须在战略要地建立供应基地。其中一些地方是从未接触过 20 世纪技术创新的偏远岛屿。这意味着飞机、吉普车，尤其是从飞机上跳伞的货箱都像魔术一样。

自然，生活在这些岛屿上的土著部落欣喜若狂。谁不喜欢魔法和免费食物？

这个问题始于二战结束之时(不是你每天都能听到的一个短语)。

部队走了，食物停止了从天而降。部落领袖们一定会聚在一起想办法让魔法复活。他们的解决方案？

重现伴随上述神奇事件的场景。毕竟世界上是有因果的。

可悲的是，这并没有奏效。显然，建造竹飞机不会让食物从天而降。

费曼的这句名言很好地概括了这个概念:

> “在[南海](https://en.wikipedia.org/wiki/South_Seas)里，有一个货物崇拜者。在战争期间，他们看到飞机带着许多好材料着陆，他们希望同样的事情现在也能发生。所以，他们安排模仿跑道之类的东西，在跑道边上生火，做一个木制小屋给一个人坐，在他的头上有两个木制的东西像耳机，竹条伸出来像天线——他是控制器——他们等待飞机着陆。
> 
> 他们做的一切都是对的。形式很完美。它看起来和以前一模一样。但是不管用。没有飞机降落。所以，我称这些东西为货物邪教科学，因为它们遵循所有明显的规则和科学调查的形式，但它们遗漏了一些基本的东西，因为飞机没有着陆。”—理查德·费曼

# 货物邪教编程

那么，我们的历史课结束了。唯一的问题是——历史往往会重演。我当然非常希望我们不是在 WWIII 的边缘，但是货物崇拜已经传播得很远很广，甚至进入了软件工程的领域。

## 什么是货物邪教编程？

简而言之，就是做事不真正理解为什么。
我敢肯定你曾经偶然发现过这样的案例，甚至亲自参与其中。我们来讨论一些常见的例子。

## 可怕的复制粘贴

在您职业生涯的某个阶段，您可能会复制粘贴别人的代码。我知道我做到了。我不打算讨论剽窃，所以让我们假设代码本来就是免费共享的。

实际上，从某种意义上说，每次你使用一个库，你就“复制粘贴”了它的代码，并把它作为你的代码库的一部分。这仍然会导致麻烦，但这被认为是合法的。图书馆应该被其他人使用。设计它的工程师们努力使它易于使用，并且尽可能没有错误。

当您从一些堆栈溢出答案或代码库中的其他部分复制粘贴时，问题就出现了——根本不知道代码实际上在做什么。对那个人有效，为什么对你无效呢？

这是货物崇拜的想法。您正在处理场景(代码看起来相似)，而没有真正理解根本原因(它在特定的上下文中是如何使用的)。

假设你设法完成了任务。代码起作用了，你得到了奖品(货物)，但后来情况变了。一个新的请求出现了，所以你需要修改你并不真正理解的代码。然后你会想到——飞机是用竹子做的。你的代码不是真的。

# 在 OOP 中滥用继承

第一次了解遗传，似乎很神奇。

用不到一行代码，您就可以获得父类的几乎所有属性和功能。不要让我从多态性开始，那是不可思议的。他们在学校唯一没有教你的是继承引入了非常紧密的耦合。

每当你从一个类继承时，你就在它的具体实现上创建了一个非常强的依赖。更糟糕的是，*你的*类的每个用户对基类都有一个传递依赖。这意味着，如果有人更改了基类，甚至可能属于您无法控制的库，您的代码可能会中断。这意味着每一个依赖于你的班级的班级也可能会放假，这可不是一件容易的事，尤其是如果它发生在你工作周的周末。

因此，在引入继承之前，需要仔细考虑。您需要考虑继承的利与弊，并弄清楚您的特定用例是否真的需要继承。通常情况下，[你应该更喜欢构图](https://en.wikipedia.org/wiki/Composition_over_inheritance)。在这种背景下，我推荐阅读[这个非常有趣的讨论，从鲍勃大叔本人的回答](https://www.quora.com/Why-is-inheritance-bad-in-Java/answer/Robert-Martin-9)开始。

# 盲目遵循“最佳实践”

我要举的最后一个例子更具体一些。这与复制粘贴代码有关，但更难以捉摸。这是关于使用你不完全理解的代码/注释，因为这是“最佳实践”

一个很好的例子是在使用 Spring 的应用程序中随意使用事务性注释。

它似乎神奇地解决了一些 bug，所以人们认为(有些人甚至直截了当地声称)一直使用它是最佳实践。

棘手的是，90%的情况下，他们都是对的。
bug 解决，货物不断从空中跳伞。

每个人都很高兴，直到事情发生了变化，一个生产缺陷出现了。看看下面这个鬼祟的例子:

```
@Transactional
public void changeName(long id, String name) {
  User user = userRepository.getById(id);
  user.setName(name);
  if (StringUtils.isNotEmpty(name)) {
    userRepository.save(user);
  }
}// All rights reserved to [this fantastic article](https://codete.com/blog/5-common-spring-transactional-pitfalls)
```

眼尖的工程师能看出这里面有猫腻。为什么在验证之前设置名称？

然而，匆忙的代码审查者可能会忽略这一点，如果他们不熟悉事务性注释，他们可能会认为没有造成伤害。

然后，您开始看到一条又一条用户名为空的记录。糟糕，一定是哪里出错了，这是网络攻击吗？

不，这只是我们钟爱的事务注释在做它的工作。

您看，这个注释还有另一个被忽略的副作用——在其作用域中声明的每个实体都处于托管状态。因此，您在这个范围内所做的每一个更改都会自动保存到数据库中，即使没有显式调用“save”

在这种情况下，这意味着无论验证是否成功，您都要保存记录。

# 如何避免货物邪教编程

*   看看引擎盖下面。这需要时间，有时可能会觉得毫无意义，但最终，它会帮你节省数周的时间来对抗那些不可理喻的错误。
*   质疑“最佳实践”大部分大概都是有道理的。但是通过询问他们，你有机会了解他们最初为什么会出现，这会让你成为一个更好的工程师。
*   努力深入理解事物。这听起来可能微不足道，但我们经常满足于浅薄的知识。我们混淆了知道某事和知道某事的名称。

其中一些可能看起来是微不足道的常识。但是记住，常识并不总是惯例。

注意你的工作，花更多的时间学习你的工艺的复杂性。你会很高兴你做了。