<html>
<head>
<title>7 Lesser-Known Python Tips to Write Elegant Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写优雅代码的7个鲜为人知的Python技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-lesser-known-python-tips-to-write-elegant-code-fa06476e3959?source=collection_archive---------14-----------------------#2022-01-27">https://betterprogramming.pub/7-lesser-known-python-tips-to-write-elegant-code-fa06476e3959?source=collection_archive---------14-----------------------#2022-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0ed2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过利用Python的内置函数和模块，发现用Python编写干净、优雅和可读的代码的有用技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/895371bf6a8679d248758f1d0ad085bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Nhy_fHHyh8FreAGN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="aa8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我参加了一个Python编程训练营，组织者是<a class="ae ky" href="https://twitter.com/mathsppblog" rel="noopener ugc nofollow" target="_blank">mathspp博客</a>的作者Rodrigo giro serro。这个训练营使用<a class="ae ky" href="https://adventofcode.com/2021/about" rel="noopener ugc nofollow" target="_blank"> Advent of Code </a>平台，这是一个很酷的编程活动，每年12月1日至25日举行。每天，网站都会发布两个新的谜题来解答。</p><p id="033a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，这是一次很棒的学习经历。我不仅从组织者那里学到了很多技巧，也从新兵训练营的同伴那里学到了很多。非常强调最大化使用Python的内置函数和模块，以及编写干净优雅的代码。</p><p id="02c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是我记录我学到的这些新技巧的方式，也是我努力与你分享的方式。它们极大地提高了我的Python编程技能，我希望它们也能以同样的方式帮助你。你准备好了吗？让我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9381" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">目录</h1><ol class=""><li id="a0cc" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated"><a class="ae ky" href="#664e" rel="noopener ugc nofollow">被低估的</a> <code class="fe nf ng nh ni b"><a class="ae ky" href="#664e" rel="noopener ugc nofollow">enumerate()</a></code></li><li id="696f" class="mu mv it lb b lc nj lf nk li nl lm nm lq nn lu nb nc nd ne bi translated"><a class="ae ky" href="#10db" rel="noopener ugc nofollow"/><code class="fe nf ng nh ni b"><a class="ae ky" href="#10db" rel="noopener ugc nofollow">int()</a></code><a class="ae ky" href="#10db" rel="noopener ugc nofollow">功能比你想象的</a>更有用</li><li id="add9" class="mu mv it lb b lc nj lf nk li nl lm nm lq nn lu nb nc nd ne bi translated"><a class="ae ky" href="#8f12" rel="noopener ugc nofollow">让我们断言</a> <code class="fe nf ng nh ni b"><a class="ae ky" href="#8f12" rel="noopener ugc nofollow">assert</a></code>声明！</li><li id="fa50" class="mu mv it lb b lc nj lf nk li nl lm nm lq nn lu nb nc nd ne bi translated"><a class="ae ky" href="#bb2a" rel="noopener ugc nofollow">拆箱和装箱——操作员</a> <code class="fe nf ng nh ni b"><a class="ae ky" href="#bb2a" rel="noopener ugc nofollow">*</a></code> <a class="ae ky" href="#bb2a" rel="noopener ugc nofollow">的权力</a></li><li id="9711" class="mu mv it lb b lc nj lf nk li nl lm nm lq nn lu nb nc nd ne bi translated"><a class="ae ky" href="#564c" rel="noopener ugc nofollow">从字典中检索值？考虑用</a> <code class="fe nf ng nh ni b"><a class="ae ky" href="#564c" rel="noopener ugc nofollow">.get()</a></code> <a class="ae ky" href="#564c" rel="noopener ugc nofollow">代替</a></li><li id="3f6d" class="mu mv it lb b lc nj lf nk li nl lm nm lq nn lu nb nc nd ne bi translated"><code class="fe nf ng nh ni b"><a class="ae ky" href="#fa3b" rel="noopener ugc nofollow">defaultdict</a></code> <a class="ae ky" href="#fa3b" rel="noopener ugc nofollow"> —用默认值创建字典</a></li><li id="6f27" class="mu mv it lb b lc nj lf nk li nl lm nm lq nn lu nb nc nd ne bi translated"><a class="ae ky" href="#f39b" rel="noopener ugc nofollow">用</a> <code class="fe nf ng nh ni b"><a class="ae ky" href="#f39b" rel="noopener ugc nofollow">sorted</a>()</code>任意排序</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="664e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.被低估的<code class="fe nf ng nh ni b">enumerate()</code></h1><p id="542e" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">遍历列表、元组或字符串等可迭代对象是非常常见的。我们中的一些人可能会做这样的事情:</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="7f3c" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; lst = ["a", "b", "c", "d"]<br/>&gt;&gt;&gt; for idx in range(len(lst)):<br/>...     print(f"Index: {idx} --&gt; Element: {lst[idx]}")</span><span id="3371" class="nv md it ni b gy oa nx l ny nz">Index: 0 --&gt; Element: a<br/>Index: 1 --&gt; Element: b<br/>Index: 2 --&gt; Element: c<br/>Index: 3 --&gt; Element: d</span></pre><p id="1791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们只是浏览列表，计算其长度范围是多余的。相反，我们可以使用<code class="fe nf ng nh ni b">enumerate()</code>，这是一个内置函数，就是为了这个目的。<code class="fe nf ng nh ni b">enumerate()</code>函数返回一个枚举对象，该对象包含一个iterable对象的索引和元素对。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="dff1" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; enumerate(lst)<br/>&lt;enumerate at 0x1dde1211e80&gt;</span></pre><p id="e643" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你把它绕在<code class="fe nf ng nh ni b">list()</code>上，你就能看到它们:</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="9f0c" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; list(enumerate(lst))<br/>[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]</span></pre><p id="9bdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nf ng nh ni b">enumerate()</code>，先前的代码可以重写为:</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="2257" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; lst = ["a", "b", "c", "d"]<br/>&gt;&gt;&gt; for idx, item in enumerate(lst):<br/>...     print(f"Index: {idx} --&gt; Element: {item}")</span><span id="d8d4" class="nv md it ni b gy oa nx l ny nz">Index: 0 --&gt; Element: a<br/>Index: 1 --&gt; Element: b<br/>Index: 2 --&gt; Element: c<br/>Index: 3 --&gt; Element: d</span></pre><p id="7239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您希望起始索引为1，而不是0。您可以使用可选的<code class="fe nf ng nh ni b">start</code>参数来指定:</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="39a8" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; lst = ["a", "b", "c", "d"]<br/>&gt;&gt;&gt; for idx, item in enumerate(lst, start=1):<br/>...     print(f"Index: {idx} --&gt; Element: {item}")</span><span id="e2bf" class="nv md it ni b gy oa nx l ny nz">Index: 1 --&gt; Element: a<br/>Index: 2 --&gt; Element: b<br/>Index: 3 --&gt; Element: c<br/>Index: 4 --&gt; Element: d</span></pre><h1 id="10db" class="mc md it bd me mf ob mh mi mj oc ml mm jz od ka mo kc oe kd mq kf of kg ms mt bi translated">2.int()函数比您想象的更有用</h1><p id="5a83" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">您可能已经使用过<code class="fe nf ng nh ni b">int()</code>函数将字符串或浮点数转换成整数。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="8471" class="nv md it ni b gy nw nx l ny nz"># Converting a string into an integer<br/>&gt;&gt;&gt; var = "5"<br/>&gt;&gt;&gt; print(int(var))<br/>&gt;&gt;&gt; print(type(int(var)))</span><span id="609b" class="nv md it ni b gy oa nx l ny nz">5<br/>&lt;class 'int'&gt;</span></pre><p id="719c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于字符串，它必须是整数的有效字符串表示，否则将引发错误。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="77b3" class="nv md it ni b gy nw nx l ny nz"># Converting a string into an integer<br/>&gt;&gt;&gt; var = "5.4321"<br/>&gt;&gt;&gt; print(int(var))<br/>&gt;&gt;&gt; print(type(int(var)))</span><span id="f063" class="nv md it ni b gy oa nx l ny nz"><strong class="ni iu">ValueError</strong>: invalid literal for int() with base 10: '5.4321'</span></pre><p id="d163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，当将整数的字符串表示转换成整数时，<code class="fe nf ng nh ni b">int()</code>函数允许出现空格。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="ec82" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; int("5\n") == int("   5  ") == int("\t\n 5 \n\t ") == 5</span><span id="7025" class="nv md it ni b gy oa nx l ny nz">True</span></pre><p id="0673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于浮点数，<code class="fe nf ng nh ni b">int()</code>函数会截断小数。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="6f7e" class="nv md it ni b gy nw nx l ny nz"># Converting a float into an integer<br/>&gt;&gt;&gt; var = 5.4321<br/>&gt;&gt;&gt; print(int(var))<br/>&gt;&gt;&gt; print(type(int(var)))</span><span id="935c" class="nv md it ni b gy oa nx l ny nz">5<br/>&lt;class 'int'&gt;</span></pre><p id="13ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了字符串和浮点数，您知道<code class="fe nf ng nh ni b">int()</code>还可以用来将二进制数解析为整数吗？我们只需要指定<code class="fe nf ng nh ni b">base=2</code>参数。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="8d7f" class="nv md it ni b gy nw nx l ny nz"># Converting binary numbers into an integer<br/>&gt;&gt;&gt; print(int("1000", base=2))<br/>&gt;&gt;&gt; print(int("111110100", base=2))</span><span id="8e81" class="nv md it ni b gy oa nx l ny nz">8<br/>500</span></pre><h1 id="8f12" class="mc md it bd me mf ob mh mi mj oc ml mm jz od ka mo kc oe kd mq kf of kg ms mt bi translated">3.让我们断言断言语句！</h1><p id="f6a9" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe nf ng nh ni b">assert</code>语句是<strong class="lb iu">一个布尔表达式，用于检查条件是否为真</strong>。条件在关键字<code class="fe nf ng nh ni b">assert</code>之后。如果条件为真，则什么都不会发生，程序转到下一行代码。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="e31b" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; x = "Hello, World!"<br/>&gt;&gt;&gt; assert x == "Hello, World!"<br/>&gt;&gt;&gt; print(x)</span><span id="84ee" class="nv md it ni b gy oa nx l ny nz">Hello, World!</span></pre><p id="c92c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果条件为假，代码将停止并触发一个错误。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="ec04" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; x = "Hello, World!"<br/>&gt;&gt;&gt; assert x == "Hi, World!"<br/>&gt;&gt;&gt; print(x)</span><span id="9afd" class="nv md it ni b gy oa nx l ny nz">AssertionError: </span></pre><p id="6597" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以在条件后指定自定义错误消息:</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="5509" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; x = "Hello, World!"<br/>&gt;&gt;&gt; assert x == "Hi, World!", "Uh oh, the condition is not met!"<br/>&gt;&gt;&gt; print(x)</span><span id="ca20" class="nv md it ni b gy oa nx l ny nz">AssertionError: Uh oh, the condition is not met!</span></pre><p id="8281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，一般的语法是这样的:</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="cf79" class="nv md it ni b gy nw nx l ny nz">assert &lt;insert condition&gt;, &lt;insert optional error message&gt;</span></pre><p id="248c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为只要条件不满足，程序就会停止，<code class="fe nf ng nh ni b">assert</code>语句是一个很好的调试工具——用来查看代码的哪些部分失败了以及失败的原因。例如，您可以使用它来检查函数中特定输入的数据类型或值，或者检查给定某些固定输入的函数的输出值。</p><h1 id="bb2a" class="mc md it bd me mf ob mh mi mj oc ml mm jz od ka mo kc oe kd mq kf of kg ms mt bi translated">4.拆包和打包——运营商的力量</h1><p id="4464" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在Python中，解包和打包是有用且方便的特性。您可以在赋值运算符右侧对存储在元组、字符串和列表等可迭代对象中的值进行解包，然后将它们赋给赋值运算符左侧的变量。变量将根据它们在iterable中的相对位置被赋值。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="451c" class="nv md it ni b gy nw nx l ny nz"># Unpacking a tuple<br/>&gt;&gt;&gt; a, b, c = (1, 2, 3)<br/>&gt;&gt;&gt; print(a)<br/>&gt;&gt;&gt; print(b)<br/>&gt;&gt;&gt; print(c)</span><span id="4d61" class="nv md it ni b gy oa nx l ny nz">1<br/>2<br/>3</span><span id="2111" class="nv md it ni b gy oa nx l ny nz"># Unpacking a string<br/>&gt;&gt;&gt; a, b, c = "123"<br/>&gt;&gt;&gt; print(a)<br/>&gt;&gt;&gt; print(b)<br/>&gt;&gt;&gt; print(c)</span><span id="25b2" class="nv md it ni b gy oa nx l ny nz">1<br/>2<br/>3</span><span id="ecc9" class="nv md it ni b gy oa nx l ny nz"># Unpacking list<br/>&gt;&gt;&gt; a, b, c = [1, 2, 3]<br/>&gt;&gt;&gt; print(a)<br/>&gt;&gt;&gt; print(b)<br/>&gt;&gt;&gt; print(c)</span><span id="96b8" class="nv md it ni b gy oa nx l ny nz">1<br/>2<br/>3</span></pre><p id="4676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，打包使用了<code class="fe nf ng nh ni b">*</code>操作符，它允许您在一个变量中打包多个值。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="e1f2" class="nv md it ni b gy nw nx l ny nz"># Packing with a tuple<br/>&gt;&gt;&gt; a, *b = (1, 2, 3)<br/>&gt;&gt;&gt; print(a)<br/>&gt;&gt;&gt; print(b)</span><span id="b807" class="nv md it ni b gy oa nx l ny nz">1<br/>[2, 3]</span><span id="d718" class="nv md it ni b gy oa nx l ny nz"># Packing with a string<br/>&gt;&gt;&gt; *a, b = "123"<br/>&gt;&gt;&gt; print(a)<br/>&gt;&gt;&gt; print(b)</span><span id="9dee" class="nv md it ni b gy oa nx l ny nz">['1', '2']<br/>3</span><span id="ffcf" class="nv md it ni b gy oa nx l ny nz"># Packing with list<br/>&gt;&gt;&gt; a, b, *c = [1, 2, 3]<br/>&gt;&gt;&gt; print(a)<br/>&gt;&gt;&gt; print(b)<br/>&gt;&gt;&gt; print(c)</span><span id="5fd3" class="nv md it ni b gy oa nx l ny nz">1<br/>2<br/>[3]</span></pre><p id="8c38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了元组、列表和字符串，打包和解包也适用于生成器对象、集合和字典。当你想在变量之间交换值或者同时进行多个赋值时，这是一个方便的工具。它使你的代码更具可读性。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="b7c7" class="nv md it ni b gy nw nx l ny nz"># Swapping values between variables<br/>&gt;&gt;&gt; a = 1<br/>&gt;&gt;&gt; b = 2<br/>&gt;&gt;&gt; a, b = b, a<br/>&gt;&gt;&gt; print(a)<br/>&gt;&gt;&gt; print(b)</span><span id="5304" class="nv md it ni b gy oa nx l ny nz">2<br/>1</span><span id="fa0a" class="nv md it ni b gy oa nx l ny nz"># Parallel assignment of multiple values using unpacking<br/>&gt;&gt;&gt; first_name, last_name, gender = ["Jane", "Doe", "Female"]<br/>&gt;&gt;&gt; print(first_name)<br/>&gt;&gt;&gt; print(last_name)<br/>&gt;&gt;&gt; print(gender)</span><span id="7b73" class="nv md it ni b gy oa nx l ny nz">Jane<br/>Doe<br/>Female</span><span id="807f" class="nv md it ni b gy oa nx l ny nz"># Parallel assignment of multiple values using packing<br/>&gt;&gt;&gt; *full_name, gender = ["Jane", "Doe", "Female"]<br/>&gt;&gt;&gt; print(full_name)<br/>&gt;&gt;&gt; print(gender)</span><span id="9eb9" class="nv md it ni b gy oa nx l ny nz">['Jane', 'Doe']<br/>Female</span></pre><p id="5235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有兴趣了解更多，这里有一篇关于打包和解包的解释很好的文章。</p><h1 id="564c" class="mc md it bd me mf ob mh mi mj oc ml mm jz od ka mo kc oe kd mq kf of kg ms mt bi translated">5.从字典中检索值？考虑使用。请改为get()。</h1><p id="2ecc" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">假设您有一个将键映射到其对应值的字典。在下面的例子中，为了在<code class="fe nf ng nh ni b">num_to_words</code>字典中检索一个关键字的英文单词，您可能会尝试使用方括号。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="eecf" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; num_to_words = {1: 'one', 2: 'two', 3: 'three'}<br/>&gt;&gt;&gt; print(num_to_words[2])</span><span id="4cd5" class="nv md it ni b gy oa nx l ny nz">two</span></pre><p id="0235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想检索一个不在<code class="fe nf ng nh ni b">num_to_words</code>字典中的关键字的英语单词，该怎么办？是的，你猜对了——它触发了一个错误！</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="ed80" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; num_to_words = {1: 'one', 2: 'two', 3: 'three'}<br/>&gt;&gt;&gt; print(num_to_words[4])</span><span id="13dd" class="nv md it ni b gy oa nx l ny nz">KeyError: 4</span></pre><p id="0c9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与方括号相比，<code class="fe nf ng nh ni b">.get()</code>方法可能是一个更稳健、更实用的选择。<code class="fe nf ng nh ni b">.get()</code>方法返回字典中存在的键值，这与使用方括号没有什么不同。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="8faa" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; num_to_words = {1: 'one', 2: 'two', 3: 'three'}<br/>&gt;&gt;&gt; print(num_to_words.get(2))</span><span id="3d52" class="nv md it ni b gy oa nx l ny nz">two</span></pre><p id="9f3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在字典中查询不存在的键值时，<code class="fe nf ng nh ni b">.get()</code>的好处变得显而易见。默认情况下，它不会触发一个<code class="fe nf ng nh ni b">KeyError</code>并中断您的代码，而是返回值<code class="fe nf ng nh ni b">None</code>并保持您的代码运行。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="2c16" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; num_to_words = {1: 'one', 2: 'two', 3: 'three'}<br/>&gt;&gt;&gt; print(num_to_words.get(4))</span><span id="9769" class="nv md it ni b gy oa nx l ny nz">None</span></pre><p id="3e4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh ni b">.get()</code>的美妙之处在于，当找不到键时，您甚至可以指定一个自定义值来返回。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="793c" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; num_to_words = {1: 'one', 2: 'two', 3: 'three'}<br/>&gt;&gt;&gt; print(num_to_words.get(4, "Uh oh... key is not found!"))</span><span id="931c" class="nv md it ni b gy oa nx l ny nz">Uh oh... key is not found!</span></pre><p id="e4ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh ni b">.get()</code>有用的一个用例是用字典中相应的值替换列表中的值。在下面的例子中，我们想使用<code class="fe nf ng nh ni b">num_to_words</code>字典将<code class="fe nf ng nh ni b">num_list</code>的每个元素替换为相应的英语单词。如果使用方括号，代码会中断，因为字典的键中没有<code class="fe nf ng nh ni b">4</code>。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="de2c" class="nv md it ni b gy nw nx l ny nz"># Using square brackets<br/>&gt;&gt;&gt; num_to_words = {1: 'one', 2: 'two', 3: 'three'}<br/>&gt;&gt;&gt; num_list = [1, 2, 3, 4, 5, 6]<br/>&gt;&gt;&gt; word_list = [num_to_words[num] for num in num_list]<br/>&gt;&gt;&gt; print(word_list)</span><span id="1963" class="nv md it ni b gy oa nx l ny nz">KeyError: 4</span></pre><p id="f62b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果我们使用<code class="fe nf ng nh ni b">.get()</code>方法，代码就能工作。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="5c27" class="nv md it ni b gy nw nx l ny nz"># Using .get() method with default value of None<br/>&gt;&gt;&gt; num_to_words = {1: 'one', 2: 'two', 3: 'three'}<br/>&gt;&gt;&gt; num_list = [1, 2, 3, 4, 5, 6]<br/>&gt;&gt;&gt; word_list = [num_to_words.get(num) for num in num_list]<br/>&gt;&gt;&gt; print(word_list)</span><span id="d9be" class="nv md it ni b gy oa nx l ny nz">['one', 'two', 'three', None, None, None]</span></pre><p id="2916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许，对于不存在的键，<code class="fe nf ng nh ni b">.get()</code>返回<code class="fe nf ng nh ni b">None</code>还是不太理想。我们可以指定<code class="fe nf ng nh ni b">.get()</code>方法的第二个参数，这样，如果在<code class="fe nf ng nh ni b">num_to_words</code>字典中找不到它，它就返回键本身。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="6c27" class="nv md it ni b gy nw nx l ny nz"># Using .get() method with customised default value<br/>&gt;&gt;&gt; num_to_words = {1: 'one', 2: 'two', 3: 'three'}<br/>&gt;&gt;&gt; num_list = [1, 2, 3, 4, 5, 6]<br/>&gt;&gt;&gt; word_list = [num_to_words.get(num, num) for num in num_list]<br/>&gt;&gt;&gt; print(word_list)</span><span id="2c9c" class="nv md it ni b gy oa nx l ny nz">['one', 'two', 'three', 4, 5, 6]</span></pre><p id="a640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">话虽如此，<code class="fe nf ng nh ni b">.get()</code>未必是所有情况下最理想的选择。例如，您有时可能希望您的代码故意触发一个错误，以便您可以通过异常显式地处理它。在这种情况下，<code class="fe nf ng nh ni b">[]</code>可能是首选。</p><h1 id="fa3b" class="mc md it bd me mf ob mh mi mj oc ml mm jz od ka mo kc oe kd mq kf of kg ms mt bi translated">6.defaultdict使用默认值创建词典</h1><p id="5354" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">另一种避免查询字典中不存在的关键字而导致<code class="fe nf ng nh ni b">KeyError</code>的方法是使用内置<code class="fe nf ng nh ni b">collections</code>模块中的<code class="fe nf ng nh ni b">defaultdict</code>。</p><p id="2ab6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nf ng nh ni b">defaultdict</code>，您可以指定一个“默认值工厂”，一个为任何不存在的键返回我们想要的默认值的函数。这里，当初始化一个<code class="fe nf ng nh ni b">defaultdict</code>对象时，我们使用一个<code class="fe nf ng nh ni b">lambda</code>函数来做这件事。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="ede6" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; num_to_words_dd = defaultdict(lambda: "Uh oh... key is not found in `defaultdict`!")<br/>&gt;&gt;&gt; num_to_words_dd[1] = 'one'<br/>&gt;&gt;&gt; num_to_words_dd[2] = 'two'<br/>&gt;&gt;&gt; num_to_words_dd[3] = 'three'<br/>&gt;&gt;&gt; print(num_to_words_dd)</span><span id="8705" class="nv md it ni b gy oa nx l ny nz">defaultdict(&lt;function &lt;lambda&gt; at 0x000001DDE3B589D0&gt;, {1: 'one', 2: 'two', 3: 'three'})</span></pre><p id="dd87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在<code class="fe nf ng nh ni b">defaultdict</code>对象中查询存在的键时，它与普通的字典对象没有什么不同。为了说明<code class="fe nf ng nh ni b">defaultdict</code>如何工作，下面的代码片段使用方括号，而不是<code class="fe nf ng nh ni b">.get()</code>方法。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="1fa1" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; num_to_words_dd[2]</span><span id="6b9e" class="nv md it ni b gy oa nx l ny nz">'two'</span></pre><p id="35e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果查询一个不存在的键，将返回默认值。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="0cbe" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; num_to_words_dd[5]</span><span id="bca3" class="nv md it ni b gy oa nx l ny nz">'Uh oh... key is not found in `defaultdict`!'</span></pre><p id="7ab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以使用<code class="fe nf ng nh ni b">int</code>或<code class="fe nf ng nh ni b">list</code>关键字初始化<code class="fe nf ng nh ni b">defaultdict</code>。如果用<code class="fe nf ng nh ni b">int</code>初始化，则创建一个默认值为0的<code class="fe nf ng nh ni b">defaultdict</code>对象。当您查询一个不存在的键时，它返回0。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="518b" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; counter = defaultdict(int)<br/>&gt;&gt;&gt; lst = [0, 1, 2, 2, 3, 1, 1, 0]<br/>&gt;&gt;&gt; for num in lst:<br/>...     counter[num] += 1<br/>&gt;&gt;&gt; print(counter[0]) # Key that exists<br/>&gt;&gt;&gt; print(counter[5]) # Key that does not exist</span><span id="51ed" class="nv md it ni b gy oa nx l ny nz">2<br/>0</span></pre><p id="60f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，如果你用<code class="fe nf ng nh ni b">list</code>初始化它，那么默认情况下用一个空列表创建一个<code class="fe nf ng nh ni b">defaultdict</code>对象，查询一个不存在的键返回<code class="fe nf ng nh ni b">[]</code>。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="92f5" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; country_list = [('AU','Australia'), ('CN','China'), <br/>...                 ('FR','France'), ('SG', 'Singapore'), <br/>...                 ('US', 'United States'), ('PT', 'Portugal')]<br/>&gt;&gt;&gt; country_dict = defaultdict(list)<br/>&gt;&gt;&gt; for code, country in country_list:<br/>...     country_dict[code].append(country)<br/>&gt;&gt;&gt; print(country_dict['AU']) # Key that exists<br/>&gt;&gt;&gt; print(country_dict['BX']) # Key that does not exist</span><span id="e429" class="nv md it ni b gy oa nx l ny nz">['Australia']<br/>[]</span></pre><p id="1045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，无论何时需要创建一个字典，并且每个元素的值都需要有一个特定的默认值时，<code class="fe nf ng nh ni b">defaultdict</code>都是一个很好的选择。</p><h1 id="f39b" class="mc md it bd me mf ob mh mi mj oc ml mm jz od ka mo kc oe kd mq kf of kg ms mt bi translated">7.用s<strong class="ak">sorted</strong>()按你想要的方式排序</h1><p id="968d" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">如果你想对一个iterable进行排序，比如一个列表、一个字符串或者一个元组，你可以使用<code class="fe nf ng nh ni b">sorted()</code>函数。它以排序的方式返回一个包含原始元素的列表，而不改变原始序列。</p><p id="0a53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于字符串，它返回一个字符列表，首先按标点符号或空格排序，然后按字母顺序按大写字母和小写字母排序。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="29fa" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; sorted("Hello, World!")</span><span id="848e" class="nv md it ni b gy oa nx l ny nz">[' ', '!', ',', 'H', 'W', 'd', 'e', 'l', 'l', 'l', 'o', 'o', 'r']</span></pre><p id="dd7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于数字列表，它返回一个按升序排序的序列。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="800b" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; sorted([5, 2, 4, 1, 3])</span><span id="bcd1" class="nv md it ni b gy oa nx l ny nz">[1, 2, 3, 4, 5]</span></pre><p id="e2ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于字符串列表，它返回一个根据前几个字符按字母顺序排序的序列:</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="23fe" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; fruits = ["apple", "watermelon", "pear", <br/>...           "banana", "grapes", "rockmelon"]<br/>&gt;&gt;&gt; sorted(fruits)</span><span id="9968" class="nv md it ni b gy oa nx l ny nz">['apple', 'banana', 'grapes', 'honeydew', 'pear', 'watermelon']</span></pre><p id="49f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以通过在<code class="fe nf ng nh ni b">sorted()</code>功能中将<code class="fe nf ng nh ni b">reverse</code>指定为<code class="fe nf ng nh ni b">True</code>来颠倒顺序。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="49b3" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; sorted(fruits, reverse=True)</span><span id="5d1d" class="nv md it ni b gy oa nx l ny nz">['watermelon', 'pear', 'honeydew', 'grapes', 'banana', 'apple']</span></pre><p id="47cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你还知道你可以定制你想要的排序方式吗？您可以指定一个函数，并将其分配给<code class="fe nf ng nh ni b">sorted</code>函数中的<code class="fe nf ng nh ni b">key</code>参数。例如，如果您想按照每个单词的长度对<code class="fe nf ng nh ni b">fruits</code>列表进行升序排序，您可以这样做:</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="1a89" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; sorted(fruits, key=len)</span><span id="8d22" class="nv md it ni b gy oa nx l ny nz">['pear', 'apple', 'banana', 'grapes', 'honeydew', 'watermelon']</span></pre><p id="4799" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，如果您想根据每个单词中字母“n”的数量对水果进行排序，您可以指定一个<code class="fe nf ng nh ni b">lambda</code>函数，如下所示:</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="9c6f" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; sorted(fruits, key=lambda x: x.count('n'))</span><span id="42ba" class="nv md it ni b gy oa nx l ny nz">['apple', 'pear', 'grapes', 'watermelon', 'honeydew', 'banana']</span></pre><p id="147b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以通过引用另一个iterable来进行排序。在下面的例子中，我们根据<code class="fe nf ng nh ni b">prices</code>字典对水果进行价格递增排序。</p><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="4c12" class="nv md it ni b gy nw nx l ny nz">&gt;&gt;&gt; prices = {"apple": 1.4, "watermelon": 4, "pear": 1.2, <br/>...           "banana": 2.3, "grapes": 3.5, "honeydew": 2.6}<br/>&gt;&gt;&gt; sorted(fruits, key=lambda x: prices.get(x))</span><span id="a889" class="nv md it ni b gy oa nx l ny nz">['pear', 'apple', 'banana', 'honeydew', 'grapes', 'watermelon']</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="c1a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧！暂时就这样了。谢谢你远道而来。我希望你已经学会了简单的技巧来编写优雅的代码，并最大限度地利用Python中鲜为人知的内置函数和模块。</p><p id="26f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于其中的一些技巧，我只触及了皮毛；它们可以各自独立成篇。因此，我强烈建议您查看更多相关资源以了解更多信息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><blockquote class="og oh oi"><p id="a35d" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">走之前……</em></strong></p><p id="8e16" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">如果这篇文章有价值，并且你希望支持我作为一个作家，请考虑注册一个中级会员。一个月5美元，费用直接支持我和其他你读其文章的作家。作为会员，你可以无限制地阅读媒体上发表的故事。如果你使用<a class="ae ky" href="https://zeyalt.medium.com/membership" rel="noopener">这个链接</a>注册，我将获得一小笔佣金。如果你希望在我发布时得到通知，也可以随时加入我的<a class="ae ky" href="https://zeyalt.medium.com/subscribe" rel="noopener">电子邮件列表</a>。</p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="5ee7" class="nv md it bd me on oo dn mi op oq dp mm li or os mo lm ot ou mq lq ov ow ms ox bi translated"><strong class="ak">参考文献</strong></h2><ol class=""><li id="00cc" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated">Python问题解决训练营2021，Rodrigo giro serro</li><li id="e6e6" class="mu mv it lb b lc nj lf nk li nl lm nm lq nn lu nb nc nd ne bi translated">列举我，Pydon，2021年4月6日，Rodrigo giro serro</li><li id="07fc" class="mu mv it lb b lc nj lf nk li nl lm nm lq nn lu nb nc nd ne bi translated">Python中的解包:超越并行赋值，2021年9月19日，Leodanis Pozo Ramos</li></ol><pre class="kj kk kl km gt nr ni ns nt aw nu bi"><span id="21f7" class="nv md it ni b gy nw nx l ny nz"><strong class="ni iu">Want to Connect?</strong></span><span id="2f37" class="nv md it ni b gy oa nx l ny nz">Reach out to me via <a class="ae ky" href="https://www.linkedin.com/in/zeyalt/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a> or <a class="ae ky" href="https://twitter.com/zeyalt_" rel="noopener ugc nofollow" target="_blank">Twitter</a>.</span></pre></div></div>    
</body>
</html>