<html>
<head>
<title>SharedFlow Consumer Sensitive in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林的共享流量消费者敏感度</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sharedflow-consumer-sensitive-in-kotlin-724069fd4358?source=collection_archive---------7-----------------------#2022-11-03">https://betterprogramming.pub/sharedflow-consumer-sensitive-in-kotlin-724069fd4358?source=collection_archive---------7-----------------------#2022-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6391" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用FileObserver示例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/45ef63b2048468cf1dbdaa7891d97437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MbF4BQSBWeJOiWFs"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@andirieger?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安迪·里格尔</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2cbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时，我们需要将资源建模为一个<code class="fe ls lt lu lv b">SharedFlow</code>,以便在良好的Kotlin支持下消费变更。</p><p id="c6a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，一个使用<code class="fe ls lt lu lv b"><a class="ae kv" href="https://developer.android.com/reference/android/os/FileObserver.html" rel="noopener ugc nofollow" target="_blank">FileObserver</a></code>获取文件中所有更改的流，或者订阅一个web提要来获取新闻和更新UI的流。在所有这些情况下，我们需要一种方法来打开和关闭这种资源，以避免不必要的电池或网络消耗(移动设备用户讨厌这样)。</p><p id="4d6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在想象一下，如果有可能知道有多少流量收集器处于活动状态，以及它们何时发生变化。<code class="fe ls lt lu lv b">MutableSharedFlow</code>的<code class="fe ls lt lu lv b"><a class="ae kv" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-shared-flow/subscription-count.html" rel="noopener ugc nofollow" target="_blank">subscriptionCount</a></code>正是我们所需要的！</p><p id="d4b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我创建了一个助手函数来收集<code class="fe ls lt lu lv b">subscriptionCount</code>，并触发与有无收集相关的回调。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c7ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe ls lt lu lv b">onActive</code>仅在第一次运行或者<code class="fe ls lt lu lv b">onInactive</code>在<a class="ae kv" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/" rel="noopener ugc nofollow" target="_blank">启动或</a>完成时运行。在另一种情况下，只有在已经调用了<code class="fe ls lt lu lv b">onActive</code>的情况下，才会调用<code class="fe ls lt lu lv b">onInactive</code>。他们的测试确保同一事件不会被连续调用两次。</p><p id="2fb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，请注意，在事件启动之前，最后一个事件的作业会被取消。这是一种性能优化，但需要仔细观察。如果你需要执行一些不应该被取消的重要事情，请在一个单独的<a class="ae kv" href="https://kotlinlang.org/docs/cancellation-and-timeouts.html#run-non-cancellable-block" rel="noopener ugc nofollow" target="_blank">(不可取消)协程上下文</a>中运行。</p><p id="107a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用一个名为<code class="fe ls lt lu lv b">FlowBinder</code>的接口来概括<code class="fe ls lt lu lv b">listenerSubscribers</code>方法，以监听这些事件并做一些有趣的事情。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="b7d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到上面提到的<code class="fe ls lt lu lv b">FileObserver</code>。每次没有检测到消费者，就调用方法<code class="fe ls lt lu lv b">onInactive</code>，需要停止观察文件的变化。在另一种情况下，当检测到第一个消费者时，方法<code class="fe ls lt lu lv b">onActive</code>被调用，我们需要开始监视文件事件。让我们看看代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="dfc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，这可以用在如下的<code class="fe ls lt lu lv b">ViewModel</code>中，它可以通过这些文件事件执行一些业务逻辑:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><h1 id="3c09" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">结论</h1><p id="0858" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated"><code class="fe ls lt lu lv b">FileObserver</code>只是<code class="fe ls lt lu lv b">FlowBinder</code>所能做的一个例子。</p><p id="d4ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请随意分享它的其他用例。</p></div></div>    
</body>
</html>