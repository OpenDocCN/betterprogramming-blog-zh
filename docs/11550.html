<html>
<head>
<title>Make Beautifully Resilient JavaScript Apps With Progressive Enhancement</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用渐进的增强制作漂亮的有弹性的JavaScript应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/make-beautifully-resilient-javascript-apps-with-progressive-enhancement-d537c50ee4ed?source=collection_archive---------11-----------------------#2022-03-29">https://betterprogramming.pub/make-beautifully-resilient-javascript-apps-with-progressive-enhancement-d537c50ee4ed?source=collection_archive---------11-----------------------#2022-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8758" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">忽视渐进式改进可能会伤害你的转换。本文将向您展示如何在您的应用程序中构建弹性。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c5e101b23aeda1d3ae070e438da82e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mfBtNSpudhT0LF0k.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="3774" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我已经详细谈过了<a class="ae lu" href="https://en.wikipedia.org/wiki/Progressive_enhancement" rel="noopener ugc nofollow" target="_blank">渐进增强</a>的好处和优点。我今天不会花太多时间来解释它，但它可以归结为:至少为尽可能多的用户提供工作体验，并为那些浏览器和设备支持这些增强功能的用户(jazz hands)增添趣味。</p><p id="2f40" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对我来说，点头附和很容易，但实际上我们总是失败。这并不奇怪。毕竟，作为创作者，利用最新技术创造新颖、引人入胜的体验是很诱人的。没有以前的经验，很难知道我们需要注意哪些怪癖。</p><h1 id="e795" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">有什么问题？</h1><p id="4b20" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">为了描绘一幅更真实的画面，让我们来看一个我处理过的现实生活中的例子。</p><p id="8217" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不久前，我在一个看起来非常有趣的网站上，我想，“是啊，我为什么不注册呢？”。我点击了“注册”按钮，你知道发生了什么吗？没什么。</p><p id="f80b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很自然地，我又点击了五次，然后打开我的开发工具，在JavaScript控制台中看到了一大块红色文本。</p><p id="1c11" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该网站使用<a class="ae lu" href="https://sentry.io/" rel="noopener ugc nofollow" target="_blank">哨兵</a>的错误跟踪脚本来捕捉任何JavaScript错误(聪明的想法)。问题是，我使用的浏览器扩展阻止了第三方追踪器。网站上的JavaScript依赖于Sentry的代码。当它被封锁时，一切都爆炸了，我无法注册服务(大概是最重要的事情)。</p><p id="ddd5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然解决方案可能是更加小心地管理JavaScript依赖关系，但这个故事强调了一个错过的实践渐进式增强的机会。</p><p id="dce9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我看到应用程序失败的最普遍的情况；依靠<a class="ae lu" href="https://austingil.com/category/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>在浏览器和服务器之间来回发送数据(通常称为JSON)。</p><p id="524d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，页面上的一个<code class="fe ms mt mu mv b">&lt;button&gt;</code>，当它被点击时，用<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取API </a>触发HTTP请求。它可能看起来像这样:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="c072" class="na lw it mv b gy nb nc l nd ne">document.querySelector('button').addEventListener('click', () =&gt; {<br/>  fetch('https://someapi.com', {<br/>    method: 'POST',<br/>    body: someBodyData<br/>  })<br/>})</span></pre><p id="d6fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这带来了优雅而有效的用户体验。他们点击一个按钮，数据就飞向母船。</p><p id="783c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是完全依赖JavaScript发送这些数据有一个问题。用户浏览器中的JavaScript可能不适用于您的应用程序。</p><p id="face" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每当我提到这一点，回答总是:</p><blockquote class="nf ng nh"><p id="b02e" class="ky kz ni la b lb lc ju ld le lf jx lg nj li lj lk nk lm ln lo nl lq lr ls lt im bi translated"><em class="it">谁把JavaScript关了！？</em></p></blockquote><p id="f8fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这完全没有抓住重点。是的，有些用户实际上可能会禁用JavaScript，但我并不太担心他们。他们知道他们报名参加的是什么。</p><p id="9859" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管如此，JavaScript可能会给其他用户带来问题(见<a class="ae lu" href="https://kryogenix.org/code/browser/everyonehasjs.html" rel="noopener ugc nofollow" target="_blank">每个人都有JavaScript，对吗？</a>)。以下是它可能失败的几种方式:</p><ul class=""><li id="00ad" class="nm nn it la b lb lc le lf lh no ll np lp nq lt nr ns nt nu bi translated">用户可能禁用了JavaScript。</li><li id="ddde" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">浏览器可能无法识别JavaScript语法(可能是旧的(浏览器，而不是用户))。</li><li id="a5b3" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">浏览器扩展阻止脚本运行(</li><li id="ac51" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">用户可能有一个超时的慢速连接(移动数据)。</li><li id="abe3" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">用户可能有间歇性连接(在火车上)。</li><li id="a5c6" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">该设备可能位于防火墙后面。</li></ul><p id="92f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这并不是JavaScript可能失败的全部原因，但是如果其中任何一种情况发生，您就可以和这种美妙的用户体验说再见了。用户可能会看到一个按钮，但它不会做任何事情。</p><p id="1db2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换句话说，如果您的应用程序只能使用JavaScript，那么在很多情况下它都不能工作。你不仅是在伤害你的用户，还可能对你的目标产生负面影响。</p><p id="33b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么如果我们不使用JavaScript呢？</p><p id="968c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">几十年来，HTML已经能够使用和发送HTTP请求，但是我将只关注<code class="fe ms mt mu mv b">&lt;form&gt;</code>。这里有一个非常简单的例子:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="3e63" class="na lw it mv b gy nb nc l nd ne">&lt;form&gt;<br/>  &lt;label for="input-id"&gt;Label&lt;label&gt;<br/>  &lt;input id="input-id" name="key" /&gt;<br/>  &lt;button type="submit"&gt;Submit&lt;/button&gt;<br/>&lt;/form&gt;</span></pre><p id="c8f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您在浏览器中打开这个HTML，您会看到一个熟悉的input元素，标签为“label ”,后面跟着一个“Submit”按钮。单击该按钮会将浏览器重新加载到表单所在的URL，但是会将输入中的名称和值作为查询字符串附加到URL(从技术上讲，这是导航，而不是重新加载)。</p><p id="28af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还可以通过提供属性将数据发送到不同的URL，并通过将属性设置为“POST”在请求正文中发送数据。</p><p id="61f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很靠谱，但是用户体验meh。浏览器导航到目标URL，导致整个页面刷新。有效果，但是不太性感。</p><p id="2811" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们都已经习惯了在浏览器不刷新的情况下进行交互。所以要求人们回到只使用<code class="fe ms mt mu mv b">&lt;form&gt;</code>进行HTTP请求是不可能的。</p><h1 id="ea55" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">有什么解决办法？</h1><p id="5cd0" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">好消息是我们不必在HTML和JavaScript之间做出选择。我们两个都可以用！</p><p id="5a31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们构建一个披萨订购表单。提交后，我们希望将请求正文中的数据发送到URL“https://API . pizza . com”。在请求正文中，我们将包括姓名、电子邮件地址和首选浇头。</p><h1 id="48c5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">从HTML开始</h1><p id="be39" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这将是最直接的部分。毕竟，几十年来事情就是这样运作的，所以我们不需要做任何手势来让它运作。它只是工作。这就是HTML的妙处。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="d577" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们告诉表单将数据发送到哪里，并使用POST方法。然后在表单内部，每个输入都有自己的和一个属性。</p><p id="51c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">标签对于可访问性是必需的，并且通过属性和输入的属性与它们各自的输入相关联。</p><p id="c614" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于功能原因，<code class="fe ms mt mu mv b">name</code>属性是必需的。它告诉表单如何引用该数据。一些输入也共享同一个<code class="fe ms mt mu mv b">name</code>，这一点很重要，因为它允许同一个数据属性有多个值。</p><p id="29d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了做我们想做的事情(发送数据到一个URL)之外，使用HTML表单也给了我们一些内置在浏览器中的优势。依靠辅助技术，浏览器可以向用户传递重要的语义/可访问性信息，我们甚至可以免费获得<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation" rel="noopener ugc nofollow" target="_blank">客户端表单验证</a>。</p><p id="8161" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它不是最好的验证工具，但是用户下载它不需要任何费用。我们还可以逐步增强验证体验，但这超出了本文的范围。</p><h1 id="a531" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">用JavaScript匹配特性奇偶校验(有点棘手)</h1><p id="bdb6" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">接下来，我们将使用JavaScript为<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/submit_event" rel="noopener ugc nofollow" target="_blank">“提交”事件</a>附加一个事件监听器。在事件处理程序中，我们可以阻止正常的HTML submit事件运行，并用JavaScript替换相同的功能。</p><p id="d493" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">棘手的部分是确保用JavaScript发出的<strong class="la iu">请求和用HTML </strong>发出的请求一样。所以浏览器决定了我们需要用JavaScript重新构建什么，以保持特性的对等性。换句话说，我们不想以使其他事情变得更糟为代价来使一些事情变得更好。</p><p id="67ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们一步一步地分解它。为了给表单附加一个事件处理程序，我们需要一个表单<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/Node" rel="noopener ugc nofollow" target="_blank"> DOM节点</a>。为此我们可以使用<code class="fe ms mt mu mv b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector" rel="noopener ugc nofollow" target="_blank">document.querySelector</a></code>。一旦我们有了DOM节点，我们就可以用<code class="fe ms mt mu mv b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" rel="noopener ugc nofollow" target="_blank">node.addEventListener()</a></code>附加事件处理程序。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="0f45" class="na lw it mv b gy nb nc l nd ne">document.querySelector('form').addEventListener('submit', (event) =&gt; {<br/>  // Event handler goes in here<br/>}</span></pre><p id="1565" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们想使用<code class="fe ms mt mu mv b">fetch</code> API发出HTTP请求。为此，我们需要知道URL、数据和可选的请求方法。对于GET请求，我们可以发送URL中的所有数据。对于POST请求，我们需要传递一个具有<code class="fe ms mt mu mv b">method</code>和<code class="fe ms mt mu mv b">body</code>属性的对象。</p><p id="04f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">方便的是，如果HTML处理得当，我们可以得到我们需要的所有信息。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="8f96" class="na lw it mv b gy nb nc l nd ne">const form = event.target;<br/>const url = new URL(form.action || window.location.href);<br/>const formData = new FormData(form);<br/>const options = {<br/>  method: form.method,<br/>};</span></pre><ul class=""><li id="46b7" class="nm nn it la b lb lc le lf lh no ll np lp nq lt nr ns nt nu bi translated"><code class="fe ms mt mu mv b">&lt;form&gt;</code> DOM节点可作为事件的。</li><li id="206b" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">URL来自于<code class="fe ms mt mu mv b">form.action</code>属性。如果没有定义，默认的HTML行为是使用当前的URL。所以我们可以默认为<code class="fe ms mt mu mv b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/location" rel="noopener ugc nofollow" target="_blank">window.location</a>.href</code>。稍后，我们将使用一个URL对象来进行简单的修改。</li><li id="71ce" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">API使得从任何形式捕获数据变得容易(只要输入具有<code class="fe ms mt mu mv b">name</code>属性)。</li><li id="3c43" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">请求方法可从<code class="fe ms mt mu mv b">form.method</code>属性获得。默认为<code class="fe ms mt mu mv b">'get'</code>。我们将它存储在一个对象中，以便于传递给<code class="fe ms mt mu mv b">fetch</code>调用。</li></ul><p id="e1f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们需要确定如何实际发送数据。如果请求应该使用POST方法，我们希望在<code class="fe ms mt mu mv b">fetch</code>的options对象中为请求添加一个“body”。否则，我们希望将URL中的数据作为查询字符串发送。</p><p id="773b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这比听起来要复杂，因为在POST请求中，我们不能只分配一个<code class="fe ms mt mu mv b">FormData</code>对象作为请求体。这样做实际上会将请求的<code class="fe ms mt mu mv b">Content-Type</code>头修改为<code class="fe ms mt mu mv b">'multipart/form-data'</code>，这可能会破坏您的HTTP请求(稍后会详细介绍)。</p><p id="83f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，网络平台还有另一个方便的工具<code class="fe ms mt mu mv b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" rel="noopener ugc nofollow" target="_blank">URLSearchParams</a></code>(老实说，这可能是这场秀的明星)。我们可以使用一个<code class="fe ms mt mu mv b">URLSearchParams</code>对象作为请求体，而不需要修改头部。我们还可以用它来构造GET请求的查询字符串。得心应手！</p><p id="042d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好的，更多代码…</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="4c2e" class="na lw it mv b gy nb nc l nd ne">if (options.method === 'post') {<br/>  options.body = form.enctype === 'multipart/form-data' ? formData : new URLSearchParams(formData);<br/>} else {<br/>  url.search = new URLSearchParams(formData);<br/>}</span></pre><ul class=""><li id="39a1" class="nm nn it la b lb lc le lf lh no ll np lp nq lt nr ns nt nu bi translated">对于POST请求，我们将在请求体中发送数据。</li><li id="880e" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">如果表单显式地将设置为<code class="fe ms mt mu mv b">'multipart/form-data'</code>，那么在主体中使用<code class="fe ms mt mu mv b">FormData</code>是安全的。</li><li id="8d30" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">否则，我们可以退回到<code class="fe ms mt mu mv b">URLSearchParams</code>。</li><li id="6127" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">对于GET请求，我们将在带有<code class="fe ms mt mu mv b">URLSearchParams</code>对象的请求URL中发送数据。</li></ul><p id="3cf7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，我们需要特别小心不要修改默认的浏览器行为，尤其是在请求体周围。HTML表单可以通过分配属性来修改<code class="fe ms mt mu mv b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type" rel="noopener ugc nofollow" target="_blank">Content-Type</a></code>请求头。默认的是<code class="fe ms mt mu mv b">'application/x-www-form-urlencoded'</code>，但是如果你需要在一个表单中发送文件，你必须使用<code class="fe ms mt mu mv b">'multipart/form-data'</code>。</p><p id="1539" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这很重要，因为许多后端框架默认不支持<code class="fe ms mt mu mv b">'multipart/form-data'</code>。因此，除非您正在发送文件，否则最好坚持使用默认设置。</p><p id="2831" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">进入最后冲刺阶段。</p><p id="76d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经有了所有需要的数据和配置。最后一部分是执行<code class="fe ms mt mu mv b">fetch</code>的请求。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="dc12" class="na lw it mv b gy nb nc l nd ne">fetch(url, options)<br/>event.preventDefault();</span></pre><ul class=""><li id="86d5" class="nm nn it la b lb lc le lf lh no ll np lp nq lt nr ns nt nu bi translated">有了上面定义的URL和选项，我们可以将它们传递给<code class="fe ms mt mu mv b">fetch</code> API。</li><li id="c79d" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">执行<code class="fe ms mt mu mv b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault" rel="noopener ugc nofollow" target="_blank">event.preventDefault</a></code>方法来防止HTML <code class="fe ms mt mu mv b">&lt;form&gt;</code>也提交和重新加载页面。</li></ul><p id="6c02" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能看过其他教程，想知道为什么我们要等到最后一刻才调用<code class="fe ms mt mu mv b">preventDefault</code>方法。即使这样也是一个谨慎的考虑。</p><p id="0602" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑在我们的事件处理程序中可能隐藏了一个JavaScript错误。如果我们在第一行调用了<code class="fe ms mt mu mv b">preventDefault</code>，并且错误发生在我们的<code class="fe ms mt mu mv b">fetch</code>调用之前，那么脚本将会中断，HTTP请求将永远不会被发送。通过等到前面所有的JavaScript都执行完，我们可以确保在阻止“提交”事件之前没有错误。或者，在出现错误的情况下，浏览器仍然会退回到以传统方式提交表单的默认行为。</p><p id="1fd9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完整的脚本可能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="ba56" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑到花了多少心思和精力，这有点乏味。但我想这是一件好事，因为这意味着只需一点JavaScript，我们就可以增加更好的用户体验。因为HTML以声明的方式提供了JavaScript需要的所有信息，所以这种改进无需任何修改就可以应用于所有表单。</p><p id="7cd5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们在启用JavaScript时给用户更好的体验，在禁用JavaScript或出现问题时给用户最小的工作体验。</p><p id="44d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">渐进增强FTW！！！</strong></p><p id="32fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(我们也可以在客户端验证上做同样的事情，但是要做到正确有点复杂)</p><p id="f0df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是我们还没有完成。到目前为止，我们只讨论了数据<strong class="la iu">发送</strong>的部分，但是数据<strong class="la iu">接收</strong>的部分呢？</p><h1 id="c45a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">服务器上的功能改进</h1><p id="97c0" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">如果我们所做的只是向服务器发送数据，我们可以就此收工，但在大多数情况下，我们希望向用户显示一些更新。要么是页面上的一些数据发生了变化，要么是我们想通知用户他们的请求成功了。</p><p id="85cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在纯HTML的世界里，浏览器要么导航到一个新页面，要么导航到同一个URL。无论哪种方式，导航事件都会在服务器上重新构建HTML，并将其作为响应发送回用户。所以显示应用程序的更新状态非常容易。</p><p id="8899" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用JavaScript，我们无法获得整个页面重新呈现的好处。从技术上来说，浏览器仍然可以用页面的HTML来响应，我们可以使用JavaScript来重新绘制页面，或者我们甚至可以手动触发页面重载，但这又有什么意义呢？</p><p id="fab2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用JSON响应要常见得多(也更可取)。但这也带来了自身的困境。如果我们用JSON响应，默认的HTML表单提交将重新加载页面，并向用户显示一堆废话。</p><p id="4b48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们可以用HTML响应HTML请求，用JSON响应JavaScript请求，会怎么样？</p><p id="1647" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">嗯，我们可以！</strong></p><p id="99c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当一个HTTP请求从客户机发送到服务器时，会有一些附加数据跟着一起发送，而开发人员或用户不需要做任何事情。这个数据的一部分是<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" rel="noopener ugc nofollow" target="_blank"> HTTP头</a>。</p><p id="2b0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最酷的是，在大多数现代浏览器中，有一个名为<code class="fe ms mt mu mv b"><a class="ae lu" href="https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header" rel="noopener ugc nofollow" target="_blank">Sec-Fetch-Mode</a></code>的头，它告诉服务器<code class="fe ms mt mu mv b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/Request/mode" rel="noopener ugc nofollow" target="_blank">Request.mode</a></code>。有趣的是，对于用JavaScript发出的请求，该值被设置为<code class="fe ms mt mu mv b">cors</code>，而对于用HTML发出的请求，该值为<code class="fe ms mt mu mv b">navigate</code>。</p><p id="d8b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">坏消息是IE 11或Safari 不支持它<a class="ae lu" href="https://caniuse.com/mdn-http_headers_sec-fetch-mode" rel="noopener ugc nofollow" target="_blank">。嘘！</a></p><p id="9e06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好消息是，我们仍然可以通过让JavaScript开发人员多做一点工作来检测响应类型。</p><p id="4370" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们创建一个<code class="fe ms mt mu mv b">fetch</code>请求时，第二个<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/fetch#parameters" rel="noopener ugc nofollow" target="_blank">参数</a>是一个配置对象。在配置内部，我们可以定制请求头。不幸的是，我们不能在这里自定义<code class="fe ms mt mu mv b">Sec-Fetch-Mode</code>头(浏览器不允许这样做)，但是我们<strong class="la iu">可以</strong>设置<code class="fe ms mt mu mv b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept" rel="noopener ugc nofollow" target="_blank">Accept</a></code> <a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept" rel="noopener ugc nofollow" target="_blank">头</a>。</p><p id="4e75" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个方便的小标题让我们明确地告诉服务器我们想要什么样的响应。默认值是<code class="fe ms mt mu mv b">*/*</code>(喜欢，随便哥们)，但是我们可以设置成<code class="fe ms mt mu mv b">application/json</code> (JSON拜托！).我们需要手动将它添加到每个请求中，这有点烦人，但我认为这是值得的。</p><p id="dbcd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是我们新的<code class="fe ms mt mu mv b">fetch</code>请求可能的样子:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="be5e" class="na lw it mv b gy nb nc l nd ne">fetch(url, {<br/>  method: requestMethod,<br/>  body: bodyData,<br/>  headers: new Headers({ 'application/json' })<br/>})</span></pre><p id="a80a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一个参数仍然只是URL。对于POST请求，第二个(init)参数应该已经存在，所以我们只需要添加或修改<code class="fe ms mt mu mv b">headers</code>属性。对于GET请求，第二个参数可能还没有定义，所以我们可能需要在<code class="fe ms mt mu mv b">headers</code>属性中包含它。请注意，虽然我在这里使用了构造函数，但是您也可以使用常规对象。</p><p id="bc33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您在应用程序中发出大量的HTTP请求，手动将这些请求添加到每个请求中可能会过时。因此，我建议使用一个包装器或<a class="ae lu" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank"> curried函数</a>来自动完成fetch。</p><p id="b287" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此时，请求正在发送服务器需要的所有数据。现在，服务器需要处理请求并决定如何响应。对于JSON响应，我将把它留给您。对于HTML响应，我们可以返回相同的页面，或者简单地用一个<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections" rel="noopener ugc nofollow" target="_blank">重定向</a>来响应。</p><p id="da82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以根据用户请求和应用程序逻辑来确定将用户重定向到哪里。或者，如果您只想将用户重定向回他们来的地方，我们还有一个HTTP头可以使用:。<code class="fe ms mt mu mv b">Referer</code>头包含发出请求的URL，由浏览器自动设置，不能被JavaScript修改，并且可用于所有请求。各方面都很完美。</p><p id="8962" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">示例时间！</p><p id="5286" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我使用的是<a class="ae lu" href="https://www.fastify.io/" rel="noopener ugc nofollow" target="_blank"> fastify </a>，但是这些概念应该适用于任何语言或框架:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><ul class=""><li id="c4b9" class="nm nn it la b lb lc le lf lh no ll np lp nq lt nr ns nt nu bi translated">创建接受GET或POST请求的服务器路由</li><li id="fd6e" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">我跳过了辛辣的商业逻辑，但那应该在你的回应之前(显然)</li><li id="1aaa" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">抓住<code class="fe ms mt mu mv b">Accept</code>、<code class="fe ms mt mu mv b">Sec-Fetch-Mode</code>和<code class="fe ms mt mu mv b">Referer</code>标题</li><li id="f554" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">确定响应是否应该是JSON。如果是，用JSON响应。注意，早期的<code class="fe ms mt mu mv b">return</code>会阻止其余的执行。</li><li id="c966" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">否则，要么用HTML响应，重定向到新的URL，要么重定向回请求的来源。在这种情况下，我做了后者。</li><li id="caab" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">注意，请求处理器必须接受<code class="fe ms mt mu mv b">urlencoded</code>数据(HTML默认编码)。它可以有选择地接受JSON，但是如果你只接受JSON，那么有效负载就很难用JavaScript创建，因此支持HTML就变得毫无意义。</li></ul><p id="ae8e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我的测试中，这真的很好，如果你愿意，你甚至可以创建一个插件(或<a class="ae lu" href="https://en.wikipedia.org/wiki/Middleware" rel="noopener ugc nofollow" target="_blank">中间件</a>)来将这个逻辑添加到每条路由中。这样就不用每次都手动添加了。</p><p id="63eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有这些的一个缺点(也许您已经发现了)是，如果目标是支持HTML表单，您只能支持GET和POST请求方法。</p><p id="35ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这令人失望，因为PUT、PATCH和DELETE是处理<a class="ae lu" href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" rel="noopener ugc nofollow" target="_blank"> CRUD操作</a>的非常方便的方法。好消息是，只要对URL模式稍加修改，我们就可以完成同样的事情，<strong class="la iu">几乎和</strong>一样好。</p><p id="5efc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是使用我们想要的任何方法的API的样子:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="9e07" class="na lw it mv b gy nb nc l nd ne">server.post('/api/kitten', create);<br/>server.get('/api/kitten', readCollection);<br/>server.get('/api/kitten/:id', readSingle);<br/>server.patch('/api/kitten/:id', updateSingle);<br/>server.delete('/api/kitten/:id', deleteSingle);</span></pre><p id="8847" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是只使用GET和POST方法的同一个API:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="2e65" class="na lw it mv b gy nb nc l nd ne">server.post('/api/kitten', create);<br/>server.get('/api/kitten/', readCollection);<br/>server.get('/api/kitten/:id', readSingle);<br/>server.post('/api/kitten/:id/update', updateSingle);<br/>server.post('/api/kitten/:id/delete', deleteSingle);</span></pre><ul class=""><li id="a3e0" class="nm nn it la b lb lc le lf lh no ll np lp nq lt nr ns nt nu bi translated">GET和POST路线不会改变。</li><li id="02ec" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">修补和删除路由成为POST。</li><li id="9f49" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">我们将“方法”/更新和/删除附加到它们各自的路由中。</li></ul><p id="2d55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我承认我不喜欢这种权衡，但这是一个小烦恼，我想我会活下来。毕竟，这些好处(正如你希望看到的)是如此值得。</p><h1 id="2237" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">从这个例子中可以看出</h1><p id="9db5" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这只是应用于HTTP请求的渐进增强的一个例子，但我认为这是一个重要的例子。以下是我认为你应该记住的一些事情:</p><ul class=""><li id="dcee" class="nm nn it la b lb lc le lf lh no ll np lp nq lt nr ns nt nu bi translated">表单只能发送GET和POST请求。如果不指定属性，它们默认发送GET请求到当前URL。</li><li id="fe31" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">默认情况下，数据作为URL编码的字符串(<code class="fe ms mt mu mv b">text=hello&amp;number=1</code>)发送到服务器，除非您更改<code class="fe ms mt mu mv b">enctype</code>。对于GET请求，它放在请求URL中。对于POST请求，它放在请求正文中。</li><li id="ec19" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">多个输入可以具有相同的名称，并且表单数据的同一数据属性可以有多个值。</li><li id="796a" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">当您提交表单时，大多数文本样式的输入将以空字符串的形式发送数据。也有一些例外。</li><li id="012d" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated"><code class="fe ms mt mu mv b">checkbox</code>和<code class="fe ms mt mu mv b">radio</code>的默认值为“开”，即使未选中。如果未选中，则不包含数据。</li><li id="6656" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated"><code class="fe ms mt mu mv b">range</code>的默认值为‘50’。</li><li id="70b0" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated"><code class="fe ms mt mu mv b">select</code>的默认值是第一次选择的<code class="fe ms mt mu mv b">&lt;option&gt;</code>的值。如果选项没有值，将使用标记的内容。您可以通过省略禁用所有选项来避免发送默认数据。</li><li id="be91" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">默认情况下,<code class="fe ms mt mu mv b">file</code>输入发送文件名。要将实际的文件作为二进制数据发送，请求的<code class="fe ms mt mu mv b">Content-Type</code>必须是<code class="fe ms mt mu mv b"><strong class="la iu">multipart/form-data</strong></code>，您可以用<code class="fe ms mt mu mv b">enctype</code>属性来设置它。</li><li id="5f5d" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated"><code class="fe ms mt mu mv b">color</code>输入的默认值为<code class="fe ms mt mu mv b">'#000000'</code>。</li><li id="3470" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">对于JavaScript提交来说，<code class="fe ms mt mu mv b">FormData</code>和<code class="fe ms mt mu mv b">URLSearchParams</code>是牛逼的。两者都可以在请求体中使用，但是使用<code class="fe ms mt mu mv b">FormData</code>会将默认的<code class="fe ms mt mu mv b">Content-Type</code>更改为<code class="fe ms mt mu mv b">multipart/form-data</code>。</li><li id="1499" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">要在您的请求中包含额外的数据，您可以使用和输入“隐藏”的<code class="fe ms mt mu mv b">name</code>、<code class="fe ms mt mu mv b">value</code>和<code class="fe ms mt mu mv b">type</code>。</li></ul><p id="cdf9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将我们所学的应用到第一个例子中，一个点击时发送数据的按钮，我们可以更可靠地完成同样的事情，只需稍微修改一下HTML:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="e2cd" class="na lw it mv b gy nb nc l nd ne">&lt;form action="https://someapi.com" method="POST"&gt;<br/>  &lt;input type="hidden" name="data-key" value="data-value"&gt;<br/>  &lt;button&gt;Send data&lt;/button&gt;<br/>&lt;/form&gt;</span></pre><p id="c551" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">再加上我们的JavaScript表单提交者，我们将拥有一个现代的用户体验，如果页面遇到一些JavaScript问题，它仍然可以工作。</p><h1 id="3aac" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">主要警告</h1><p id="c3b4" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">没有一个解决方案是完美的，如果我说我上面推荐的没有缺陷，那是不诚实的。事实上，有一个非常大的。</p><p id="10a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">依靠HTML表单构造数据意味着不能使用嵌套对象。</p><p id="5029" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的意思是，也许您可以创建名称中带有点或括号符号的输入(<code class="fe ms mt mu mv b">&lt;input name="user.first-name"&gt; &lt;input name="user.last-name"&gt;</code>)，然后在服务器上执行一些逻辑来构造一个嵌套对象。但是我自己没有做过，我也不确信这是值得的，所以我不会试图说服你。无论如何，如果您从一开始就考虑平面数据模型，这应该不是问题。</p><p id="4a3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于嵌套对象是不可能的，这也意味着您不能进行GraphQL查询。</p><p id="21c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在客户机和服务器上使用过GraphQL之后，不管有没有库，我都会说它超级酷，很有创新性，但我不喜欢它。对于大多数项目来说，它增加了更多的复杂性，并且成本超过了收益。</p><p id="6ef6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，很少有项目中有足够多的数据和HTTP请求围绕着GraphQL运行是有意义的。对于那些案子来说，是值得的。</p><p id="b01b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(希望我没有让自己变成一个完全有偏见的傻瓜)</p><h1 id="4d3d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">一万美元的问题</h1><p id="2146" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">说明我的情况后，我将向你提出这个问题。如果您有一个只能使用JavaScript的结帐表单，那么是否值得重写，以便在JavaScript失败时返回到HTML？嗯，看情况，对吧？</p><p id="40c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您的公司通过这个表单赚了100万美元，而这个表单由于JavaScript问题有1%的几率失败，那么这个修复就值1万美元。</p><p id="c099" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么是1%？<a class="ae lu" href="https://gds.blog.gov.uk/2013/10/21/how-many-people-are-missing-out-on-javascript-enhancement/" rel="noopener ugc nofollow" target="_blank">根据GOV.uk </a>的研究，1%的用户无法使用JavaScript。这是所有的用户(或页面浏览量)，而不仅仅是那些在旧手机上使用过时浏览器的人。有一个很好的解释者叫做<a class="ae lu" href="https://kryogenix.org/code/browser/why-availability/" rel="noopener ugc nofollow" target="_blank">为什么可用性很重要</a>，他解释了更多细节，但是现在我跑题了。</p><p id="457e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回到最初的问题，10，000美元足够让你对那个表格做一些改变吗？对我来说是这样，这个决定是基于一个处理100万美元的表单。对一家公司来说，这实际上并不是太多的收入，大多数有表格的网站通常不止一个。</p><h1 id="3895" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结束语</h1><p id="4ade" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我在HTML和JavaScript中使用了相同的HTTP请求的例子来说明这个概念，但是需要指出的是，并不是所有的渐进式增强都是零和游戏。</p><p id="a23b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它不总是工作或被打破。有时是关于工作出色或工作一般。有时它与安全性、性能、可访问性或设计有关。无论场景或技术如何，渐进增强都是关于在构建时考虑弹性回退。</p><p id="aaef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新的浏览器提供了许多精彩的功能，但最重要的是，从适合大多数用户的东西开始，并为支持它的人提供增强的体验。以CSS为例，你可以咨询<a class="ae lu" href="https://caniuse.com/" rel="noopener ugc nofollow" target="_blank">caniuse.com</a>来检查浏览器兼容性，为旧浏览器编写样式，并在检测该特性的at规则中添加现代增强功能。</p><p id="f4dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我想用这句话来结束我的演讲。</p><blockquote class="nf ng nh"><p id="665e" class="ky kz ni la b lb lc ju ld le lf jx lg nj li lj lk nk lm ln lo nl lq lr ls lt im bi translated"><em class="it">这个代码是向前和向后兼容的。浏览器成为常青树，JavaScript被迫向后兼容web的遗产是一个巨大的特性…许多开发团队浪费了很多时间来保持他们已经拥有的功能，因为他们在追逐依赖更新。这种技术是向前和向后兼容的，不会增加您的时间投资。编写一次，永远运行是JS的一个非常独特的特性，这是许多‘现代’框架所没有的。</em></p><p id="e2e8" class="ky kz ni la b lb lc ju ld le lf jx lg nj li lj lk nk lm ln lo nl lq lr ls lt im bi translated"><a class="ae lu" href="https://brian.io/" rel="noopener ugc nofollow" target="_blank">T5【布莱恩勒鲁】T6</a></p></blockquote><p id="b41a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我很喜欢这篇文章，并想看看我创作的更多类似的东西，下面是一些例子:</p><p id="b41c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是我发现的一些特别有趣的资源:</p><p id="82f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[更新:我列出了JavaScript可能失败的原因，其中包括网络条件。接下来，我将介绍一个逐渐增强的表单提交示例。值得一提的是，JS可能失败的原因列表是一个很好的常识，但是如果由于网络条件而出错，HTML表单也有可能失败。]</p><p id="3220" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">非常感谢您的阅读。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="617d" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu">Want to Connect?</strong></span><span id="a401" class="na lw it mv b gy oc nc l nd ne">You can also <a class="ae lu" href="https://austingil.com/newsletter/" rel="noopener ugc nofollow" target="_blank">sign up for my newsletter</a> or <a class="ae lu" href="https://twitter.com/heyAustinGil" rel="noopener ugc nofollow" target="_blank">follow me on Twitter</a> if you want to know when new articles are published.</span><span id="2ac7" class="na lw it mv b gy oc nc l nd ne"><em class="ni">Originally published on </em><a class="ae lu" href="https://austingil.com/resilient-applications-progressive-enhancement/" rel="noopener ugc nofollow" target="_blank"><em class="ni">austingil.com</em></a><em class="ni">.</em></span></pre></div></div>    
</body>
</html>