<html>
<head>
<title>A Response to “Stop Using If-Else Statements”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对“停止使用If-Else语句”的回应</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/response-to-stop-using-if-else-statements-c3d4c64c69af?source=collection_archive---------0-----------------------#2022-12-31">https://betterprogramming.pub/response-to-stop-using-if-else-statements-c3d4c64c69af?source=collection_archive---------0-----------------------#2022-12-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="93a0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们提炼一下所说的话</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8b4988bcc0c48f71220ecd9e7b095ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*70AIET1ybLBzNDdu29ZozQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者</p></figure><p id="3a7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文回应<a class="lu lv ep" href="https://medium.com/u/7c7a43b3d9de?source=post_page-----c3d4c64c69af--------------------------------" rel="noopener" target="_blank"> Nicklas Millard的</a>帖子<a class="ae lw" href="https://medium.com/swlh/stop-using-if-else-statements-f4d2323e6e4" rel="noopener">停止使用If-Else语句</a>。然而，当我浏览评论时，你可以清楚地看到人们将这篇文章视为点击诱饵。我知道为什么。就连尼可拉斯自己也说他已经好几年没写过If-Else语句了(在评论里)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/4f45ee80af0e0ea1248686cfd52c59e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*8nH7sm9UjlOsE1FHYJ1SyQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自停止使用If-Else语句的注释</p></figure><p id="3dbf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">问题是，我实际上原则上同意他的意见。在大多数情况下，语句很难维护，尤其是随着系统的发展。然而，在快速和肮脏的实用程序中，我认为使用状态对象的开销是多余的。</p><p id="c725" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但我想我要做的是澄清其他场景<code class="fe ly lz ma mb b">if-else</code>语句可以删除。Nicklas在他的文章中只涉及了一个用例，基于状态的<code class="fe ly lz ma mb b"> if-else</code>声明。还有其他场景需要记住。</p><h1 id="f444" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">案例1:基于状态</h1><p id="3faa" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我推荐看他的文章<a class="ae lw" href="https://medium.com/swlh/stop-using-if-else-statements-f4d2323e6e4" rel="noopener">这里</a>看他的例子。他解释得很好。然而，作为一个快速概览，这里有一个基于状态的<code class="fe ly lz ma mb b">if-else</code>设置，我们可能希望使用状态模式进行转换，</p><pre class="kj kk kl km gt mz mb na bn nb nc bi"><span id="9837" class="nd md it mb b be ne nf l ng nh">public class Order<br/>{<br/>  public string State { get; set; } = "new";<br/><br/>  // All other properties, methods, etc.<br/>}<br/><br/>public void AdvanceOrder(Order order)<br/>{<br/>  if (order.State == "new")<br/>  {<br/>    // TODO: Validate New Order<br/>    order.State = "received";<br/>  } else if (order.State == "received")<br/>  {<br/>    // TODO: Send to Warehouse Team<br/>    order.State = "processing";<br/>  } else if (order.State == "processing")<br/>  {<br/>    // TODO: Send Shipped Email to Customer<br/>    order.State = "shipped";<br/>  } else if (order.State == "complete")<br/>  {<br/>    // TODO: Update Order Information and Send Received Email to Customer<br/>    order.State = "complete";<br/>  } else if (order.State == "cancelled")<br/>  {<br/>    throw new OrderCancelledException("...");<br/>  }<br/><br/>  SaveOrder(order);<br/>}<br/><br/>public void CancelOrder(Order order)<br/>{<br/>  order.state = "cancel";<br/>  SaveOrder(order);<br/>}</span></pre><p id="41fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个虚构的例子没有任何主要的分支逻辑，可以很快地重新组织成一个状态机。界面可能看起来像这样，</p><pre class="kj kk kl km gt mz mb na bn nb nc bi"><span id="803d" class="nd md it mb b be ne nf l ng nh">public interface IOrderState<br/>{<br/>  // Used for database storage and showing the state to an API / User<br/>  string DisplayName { get; }<br/><br/>  IOrderState AdvanceOrder(Order order);<br/>  IOrderState CancelOrder(Order order);<br/>}</span></pre><p id="5fc3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从这里，我们实现状态，</p><pre class="kj kk kl km gt mz mb na bn nb nc bi"><span id="9685" class="nd md it mb b be ne nf l ng nh">public sealed class NewState : IOrderState<br/>{<br/>  public string DisplayName =&gt; "new";<br/>  public IOrderState AdvanceOrder(Order order) =&gt; new ReceivedState();<br/>  public IOrderState CancelOrder(Order order) =&gt; new CancelledState();<br/>}<br/><br/>public sealed class ReceivedState : IOrderState<br/>{<br/>  public string DisplayName =&gt; "received";<br/>  public IOrderState AdvanceOrder(Order order) =&gt; new ProcessingState();<br/>  public IOrderState CancelOrder(Order order) =&gt; new CancelledState();<br/>}<br/><br/>public sealed class ProcessingState : IOrderState<br/>{<br/>  public string DisplayName =&gt; "processing";<br/>  public IOrderState AdvanceOrder(Order order) =&gt; new ShippedState();<br/>  public IOrderState CancelOrder(Order order) =&gt; new CancelledState();   <br/>}<br/><br/>public sealed class ShippedState : IOrderState<br/>{<br/>  public string DisplayName =&gt; "shipped";<br/>  public IOrderState AdvanceOrder(Order order) =&gt; new CompletedState();<br/>  public IOrderState CancelOrder(Order order)<br/>    =&gt; new AlreadyShippedException("...");<br/>}<br/><br/>public sealed class CompletedState : IOrderState<br/>{<br/>  public string DisplayName =&gt; "shipped";<br/>  public IOrderState AdvanceOrder(Order order) <br/>    =&gt; throw new AlreadyCompletedException("...");<br/>  public IOrderState CancelOrder(Order order)<br/>    =&gt; throw new AlreadyCompletedException("...");<br/>}<br/><br/>public sealed class CancelledState : IOrderState<br/>{<br/>  public string DisplayName =&gt; "cancelled";<br/>  public IOrderState AdvanceOrder(Order order) <br/>    =&gt; throw new OrderCancelledException("...");<br/>  public IOrderState CancelOrder(Order order)<br/>    =&gt; throw new OrderCancelledException("...");<br/>}</span></pre><p id="baa8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">做这件事一点也不复杂，而且可以非常快。最后一部分是订单对象本身，</p><pre class="kj kk kl km gt mz mb na bn nb nc bi"><span id="4aad" class="nd md it mb b be ne nf l ng nh">public class Order<br/>{<br/>  public IOrderState State { get; private set; } = new NewState();<br/>  // All other properties of the order<br/><br/>  public void AdvanceOrder()<br/>    =&gt; State = State.AdvanceOrder(this);<br/>  public void CancelOrder()<br/>    =&gt; State = State.CancelOrder(this);<br/>}</span></pre><p id="49a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有哒哒！我们有一个简单的状态机。</p><p id="d786" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些类型的系统可能是有用的，尽管我很少发现自己以上面显示的方式实现它们。相反，我更喜欢构建工作流系统。我写了一篇名为<a class="ae lw" href="https://medium.com/dev-genius/advanced-c-custom-workflow-engine-a52ba44bb2c4" rel="noopener">高级c#——定制工作流引擎</a>的文章来讨论这个问题。</p><h1 id="299a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">案例#2:前置/后置条件和早期回报</h1><p id="2485" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我发现可以删除if-else语句的第二种情况是在函数的基本条件检查中。让我们以此为例，</p><pre class="kj kk kl km gt mz mb na bn nb nc bi"><span id="d6c1" class="nd md it mb b be ne nf l ng nh">protected void ValidateRequest(Model request, ICollection&lt;string&gt; validationErrors)<br/>{<br/>  if (request != null)<br/>  {<br/>    if (string.IsNullOrWhiteSpace(request.Name))<br/>      validationErrors.PropertyRequired(nameof(request.Name));<br/>    if (string.IsNullOrWhiteSpace(request.Description))<br/>      validationErrors.PropertyRequired(nameof(request.Description));<br/>  } else {<br/>    validationErrors.ArgumentRequired(nameof(Model));<br/>  }<br/>}</span></pre><p id="ba3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我已经在调用主函数之前分离出了我的验证。然而，我使用否定形式来检查请求(不等于<code class="fe ly lz ma mb b">!=</code>)。如果我们把这个倒过来，提前返回，我们可以让它看起来更干净一点，</p><pre class="kj kk kl km gt mz mb na bn nb nc bi"><span id="afe3" class="nd md it mb b be ne nf l ng nh">protected void ValidateRequest(Model request, ICollection&lt;string&gt; validationErrors)<br/>{<br/>  if (request == null)<br/>  {<br/>    validationErrors.ArgumentRequired(nameof(Model));<br/>    return;<br/>  }<br/><br/>  if (string.IsNullOrWhiteSpace(request.Name))<br/>    validationErrors.PropertyRequired(nameof(request.Name));<br/>  if (string.IsNullOrWhiteSpace(request.Description))<br/>    validationErrors.PropertyRequired(nameof(request.Description));<br/>}</span></pre><p id="a421" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码是这样的。我们根本没有删除<code class="fe ly lz ma mb b">else</code>逻辑。我们只是在语法上改变了它。<code class="fe ly lz ma mb b">return;</code>是我们替换<code class="fe ly lz ma mb b">else</code>关键词的方式。如果我们删除了<code class="fe ly lz ma mb b">return</code>，我们将不得不把<code class="fe ly lz ma mb b">else</code>添加回代码中。这就是所谓的“提前归还”</p><p id="fb6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有些人有一个规则，条件句应该总是积极或消极的形式。例如，有些人觉得<code class="fe ly lz ma mb b">if (!string.IsNullOrEmpty(value)) { }</code>可读性较差。然而，对于早期回报，你真的不能被这种哲学所束缚。它会碍事的。</p><p id="e22c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，上面的代码显示了一个先决条件的例子。然而，这当然适用于后置条件或函数的任何其他内部状态。当你能从函数中返回的时候，就去做吧！这样，你就避免了<code class="fe ly lz ma mb b">else</code>语句。</p><h1 id="d145" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">案例3:对象类型化</h1><p id="a804" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我看到的第三个主要用例是对象类型化的概念，其中使用一个<code class="fe ly lz ma mb b">string</code>或枚举来选择某种逻辑。</p><p id="1017" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们想要播种锦标赛算法。我们可以有这样的代码，</p><pre class="kj kk kl km gt mz mb na bn nb nc bi"><span id="d9ce" class="nd md it mb b be ne nf l ng nh">public class Tournament {<br/>  // ... All other Tournament Code ...<br/><br/>  public async Task&lt;IEnumerable&lt;SeedResult&gt;&gt; SeedAsync()<br/>  {<br/>    if (tournament.SeedAlgorithm == "ordered")<br/>    {<br/>      // TODO: Run Ordered Algorithm<br/>      return results;<br/>    } else if (tournament.SeedAlgorithm == "random")<br/>    {<br/>      // TODO: Run Random Algorithm<br/>      return results;<br/>    } else if (tournament.SeedAlgorithm == "total-score")<br/>    {<br/>      // TODO: Run Total Score Algorithm<br/>      return results;<br/>    } else {<br/>      throw new InvalidAlgorithmException("...");<br/>    }<br/>  }<br/>}</span></pre><p id="273d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每次添加另一个算法时，都必须更新这个方法。但老实说，可能没什么大不了的。这种方法的真正问题是当您在代码中的多个地方使用<code class="fe ly lz ma mb b">Tournament.SeedAlgorithm</code>时。也许有一个点，你检查算法类型，以执行一些逻辑。但是，根据算法的不同，用户界面可能会有一些限制。现在你有了在多个地方“播种”的逻辑。当你添加另一个算法时，你必须绝对肯定你在代码中捕获了所有的实例。</p><p id="b756" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是最糟糕的。</p><p id="4134" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是的，ide允许我们快速找到所有的引用。但是这对非加载的程序集没有帮助。所以你总是在冒险。</p><p id="e9b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相反，我们应该创建一个服务类型来处理这些场景。让我们来看一个例子，</p><pre class="kj kk kl km gt mz mb na bn nb nc bi"><span id="5688" class="nd md it mb b be ne nf l ng nh">public interface ISeedAlgorithm<br/>{<br/>  string Name { get; }<br/>  bool IsVisibleToUser { get; }<br/><br/>  Task&lt;IEnumerable&lt;SeedResult&gt;&gt; RunAsync(Tournament tournament);<br/>}</span></pre><p id="3a82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从这里开始，我们实施几次，</p><pre class="kj kk kl km gt mz mb na bn nb nc bi"><span id="3bbf" class="nd md it mb b be ne nf l ng nh">public class OrderedSeedAlgorithm : ISeedAlgorithm<br/>{<br/>  public string Name =&gt; "ordered";<br/>  public bool IsVisibleToUser =&gt; false;<br/>  public async Task&lt;IEnumerable&lt;SeedResult&gt;&gt; RunAsync(Tournament tournament)<br/>  {<br/>    // TODO: Run Algorithm<br/>    return results;<br/>  }<br/>}<br/><br/>public class RandomSeedAlgorithm : ISeedAlgorithm<br/>{<br/>  public string Name =&gt; "random";<br/>  public bool IsVisibleToUser =&gt; true;<br/>  public async Task&lt;IEnumerable&lt;SeedResult&gt;&gt; RunAsync(Tournament tournament)<br/>  {<br/>    // TODO: Run Algorithm<br/>    return results;<br/>  }<br/>}<br/><br/>public class TotalScoreSeedAlgorithm : ISeedAlgorithm<br/>{<br/>  public string Name =&gt; "total-score";<br/>  public bool IsVisibleToUser =&gt; false;<br/>  public async Task&lt;IEnumerable&lt;SeedResult&gt;&gt; RunAsync(Tournament tournament)<br/>  {<br/>    // TODO: Run Algorithm<br/>    return results;<br/>  }<br/>}</span></pre><p id="51a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在你有了一套独立的算法。</p><p id="6d23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，就其本身而言，这在短期内不会带来太多好处。然而，从长期维护的角度来看，我们可以发现许多好处，</p><ol class=""><li id="b3b4" class="ni nj it la b lb lc le lf lh nk ll nl lp nm lt nn no np nq bi translated">我们可以使用依赖注入(DI)容器将这些算法提供给其他需要它们的类。</li><li id="ba1d" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">我们可以将算法可能需要的任意数量的依赖注入到这些类中，而不会污染使用<code class="fe ly lz ma mb b">if-else</code>逻辑的单个类。</li><li id="40ba" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">我们可以通过实现接口并将其添加到您的DI容器注册中心来快速添加新算法。</li></ol><p id="bf9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总的来说，对于大多数用例来说，这是一个更好的设计。</p><h1 id="b46f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">案例4:算法</h1><p id="1d00" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">最后一个要讨论的用例是算法，特别是不允许提前退出或对象分离的算法。例如，我最近有一个案例，我正在为一个锦标赛设置回合，在那里“再见”回合是可能的。它看起来像这样，</p><pre class="kj kk kl km gt mz mb na bn nb nc bi"><span id="3f64" class="nd md it mb b be ne nf l ng nh">for(int iMatch = 0; iMatch &lt; len; iMatch++)<br/>{<br/>    var p1 = top[iMatch];<br/>    var p2 = bottom[iMatch];<br/><br/>    // ... other code ...<br/><br/>    // This is a bye for a participant<br/>    if (p1 == -1)<br/>    {<br/>      isBye = true;<br/>      matchName = $"{participants[p2].Name} Bye";<br/>      assignments = new[] { new MatchStationAssignment { Participant = new Reference&lt;Participant&gt; { Id = participants[p2].Id, DisplayName = participants[p2].Name }, Seat = 2 } };<br/>      results = new[] { new IndividualMatchResult { Assignment = assignments[0], Result = MatchResult.DefaultWin } };<br/>    } else if (p2 == -1)<br/>    {<br/>      isBye = true;<br/>      matchName = $"{participants[p1].Name} Bye";<br/>      assignments = new[] { new MatchStationAssignment { Participant = new Reference&lt;Participant&gt; { Id = participants[p1].Id, DisplayName = participants[p1].Name }, Seat = 1 } };<br/>      results = new[] { new IndividualMatchResult { Assignment = assignments[0], Result = MatchResult.DefaultWin } };<br/>    } else<br/>    {<br/>      matchName = $"{participants[p1].Name} vs. {participants[p2].Name}";<br/>      assignments = new[]<br/>      {<br/>          new MatchStationAssignment { Participant = new Reference&lt;Participant&gt; { Id = participants[p1].Id, DisplayName = participants[p1].Name }, Seat = 1 },<br/>          new MatchStationAssignment { Participant = new Reference&lt;Participant&gt; { Id = participants[p2].Id, DisplayName = participants[p2].Name }, Seat = 2 }<br/>      };<br/>    }<br/><br/>    // ... other code ...<br/>}</span></pre><p id="6c50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果不深入了解这段代码做了什么，如果没有else语句，很难将它分解出来。这主要是由于围绕这个<code class="fe ly lz ma mb b">if-else</code>设置运行的“其他代码”。如果我花时间的话，我确信我能找到一些聪明的方法来做到这一点，但是老实说，可读性会很差。</p><p id="59b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我欢迎任何建议:)</p><h1 id="d6ee" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="de6e" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated"><code class="fe ly lz ma mb b">if-else</code>逻辑的现实和我们上面所做的重新配置，是逻辑仍然存在。打开Visio或图表。IO，或者你使用的任何工具，并开始规划你的逻辑。它会一直在那里。我们推出这些产品有两个原因，</p><ol class=""><li id="ed8f" class="ni nj it la b lb lc le lf lh nk ll nl lp nm lt nn no np nq bi translated"><strong class="la iu">可读性</strong>:我的观点是，尽早从一个例程中退出，然后确信我的对象是好的，这使得编程变得容易得多。此外，将所有代码放在一个地方，将它们分成不同的类，使得查找细节变得更加简单。</li><li id="e582" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">可维护性:必须在代码库中搜索枚举的所有用例是很痛苦的。最重要的是，不得不改变测试过的代码，总是让我紧张。相反，增加新的课程而不去管旧的，总是给我温暖和模糊。</li></ol><p id="e751" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但关键是，逻辑是存在的。我们只是试图从这两个角度做得更好一点。</p><p id="edce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总的来说，我同意尼可拉斯的观点。我们应该尽我们所能避免<code class="fe ly lz ma mb b">if-else</code>的设置。然而，绝对会有你不应该这样做的情况(比如情况#4)。这只会让事情变得更糟(除非有人给我看更好的东西)。对于任何编程原则，我们都不能独断专行。你最终会被证明是错的。</p><p id="e84c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望这篇文章有助于澄清一些事情！总的来说，我很欣赏Nicklas的文章，并相信他在编码实践中有坚实的策略。我只是想帮助那些在这个话题上寻找更多深度的人。</p><p id="64f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下次见！</p></div></div>    
</body>
</html>