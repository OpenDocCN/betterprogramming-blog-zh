<html>
<head>
<title>Views and Controls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">视图和控件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-views-and-controls-the-swift-2-documentation-youve-been-waiting-for-dfa32cba24f3?source=collection_archive---------2-----------------------#2020-08-04">https://betterprogramming.pub/swiftui-views-and-controls-the-swift-2-documentation-youve-been-waiting-for-dfa32cba24f3?source=collection_archive---------2-----------------------#2020-08-04</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="e731" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph">您期待已久的完整SwiftUI 2文档</h2><div class=""/><div class=""><h2 id="0d4d" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">针对iOS 14、iPadOS 14、WatchOS 7和MacOS Big Sur进行了更新</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/b6c94ca79c2134b4d571840b7a6f6f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQV9kCQ6PS4uHMlVtSsdVA.jpeg"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">来自<a class="ae li" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3084706" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae li" href="https://pixabay.com/users/fietzfotos-6795508/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3084706" rel="noopener ugc nofollow" target="_blank"> Albrecht Fietz </a>的一些视图和控件的照片</p></figure><p id="4d16" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在2020年初，我写了一篇名为<a class="ae li" href="https://medium.com/better-programming/the-complete-swiftui-documentation-youve-been-waiting-for-fdfe7241add9" rel="noopener">的长文，这是你一直在等待的完整SwiftUI文档</a>。</p><p id="29d0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是我分享我在试图填补苹果公司提供的不充分文档所留下的空白时所学到的东西的方式。虽然我的帖子似乎帮助了很多人，但我也是晚了半年才写的。</p><p id="7f96" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在苹果2020开发者大会已经结束，SwiftUI被赋予了一些新的功能，所以希望这次更新能让我的文档比以往任何时候都更有帮助。</p><p id="8ffc" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这将作为一个系列发布，每个帖子一章。</p><p id="e263" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这些章节的名称与苹果SwiftUI文档中的章节名称相对应。</p><p id="d68e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你担心的是这个问题，我可以保证没有一个会像这个一样长。</p><ul class=""><li id="aa11" class="mf mg iu ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated"><strong class="ll je">视图和控件</strong></li><li id="b26a" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">应用程序结构和行为</li><li id="e8fd" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><a class="ae li" href="https://medium.com/better-programming/view-layout-and-presentation-in-swiftui-705b7d81f03" rel="noopener">查看布局和演示文稿</a></li><li id="840f" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">绘画和动画</li><li id="62ae" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">框架集成</li><li id="faae" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">状态和数据流</li><li id="29f4" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">手势</li><li id="6d51" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">试映</li></ul><p id="710f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你发现任何错误或你认为我应该更详细介绍的主题，我鼓励你在下面的回复中或在我的Twitter个人资料上联系我。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><pre class="kt ku kv kw gu na nb nc nd aw ne bi"><span id="8da0" class="nf ng iu nb b gz nh ni l nj nk"><a class="ae li" href="#d1ca" rel="noopener ugc nofollow"><strong class="nb je">The View Protocol</strong></a><strong class="nb je"> </strong></span><span id="499e" class="nf ng iu nb b gz nl ni l nj nk"><a class="ae li" href="#b8ad" rel="noopener ugc nofollow"><strong class="nb je">@ViewBuilder</strong></a></span><span id="f354" class="nf ng iu nb b gz nl ni l nj nk"><a class="ae li" href="#6dd3" rel="noopener ugc nofollow"><strong class="nb je">New and Updated Views</strong></a><strong class="nb je"><br/></strong><a class="ae li" href="#cbc2" rel="noopener ugc nofollow">ColorPicker (NEW in 2.0)</a><br/><a class="ae li" href="#f14e" rel="noopener ugc nofollow">SpriteView (NEW in 2.0)</a><br/><a class="ae li" href="#9a99" rel="noopener ugc nofollow">TextEditor (NEW in 2.0)</a><br/><a class="ae li" href="#6f4b" rel="noopener ugc nofollow">SignInWithAppleButton (NEW in 2.0)</a><br/><a class="ae li" href="#be5d" rel="noopener ugc nofollow">ProgressView (NEW in 2.0)</a><br/><a class="ae li" href="#4b62" rel="noopener ugc nofollow">GaugeView (NEW in 2.0)</a><br/><a class="ae li" href="#c0e9" rel="noopener ugc nofollow">Label (NEW in 2.0)</a><br/><a class="ae li" href="#f1be" rel="noopener ugc nofollow">Link (NEW in 2.0)</a><br/><a class="ae li" href="#29e5" rel="noopener ugc nofollow">Menu (NEW in 2.0)</a><br/><a class="ae li" href="#6b9b" rel="noopener ugc nofollow">MenuButton (Deprecated in 2.0)</a><br/><a class="ae li" href="#ab2f" rel="noopener ugc nofollow">Text (Updated in 2.0)</a><br/><a class="ae li" href="#fd7f" rel="noopener ugc nofollow">Image (Updated in 2.0)</a><br/><a class="ae li" href="#4777" rel="noopener ugc nofollow">Button (Updated in 2.0)</a><br/><a class="ae li" href="#ec57" rel="noopener ugc nofollow">PasteButton (Updated in 2.0)</a><br/><a class="ae li" href="#e003" rel="noopener ugc nofollow">Toggle (Updated in 2.0)</a><br/><a class="ae li" href="#9756" rel="noopener ugc nofollow">DatePicker (Updated in 2.0)</a></span><span id="ed2e" class="nf ng iu nb b gz nl ni l nj nk"><a class="ae li" href="#6299" rel="noopener ugc nofollow"><strong class="nb je">New and Updated View Modifiers</strong></a><strong class="nb je"><br/></strong><a class="ae li" href="#7abe" rel="noopener ugc nofollow">.matchedGeometryEffect (NEW in 2.0)</a><br/><a class="ae li" href="#7260" rel="noopener ugc nofollow">.help (NEW in 2.0)</a><br/><a class="ae li" href="#5f0d" rel="noopener ugc nofollow">.accessibility(inputLabels:) (NEW in 2.0)</a><br/><a class="ae li" href="#5c8f" rel="noopener ugc nofollow">.accessibility(selectionIdentifier:) (Deprecated in 2.0)</a><br/><a class="ae li" href="#6d05" rel="noopener ugc nofollow">.scaleEffect (Updated in 2.0)</a><br/><a class="ae li" href="#dd49" rel="noopener ugc nofollow">.imageScale (NEW in 2.0)</a><br/><a class="ae li" href="#0437" rel="noopener ugc nofollow">.accentColor (Updated in 2.0)</a><br/><a class="ae li" href="#81c1" rel="noopener ugc nofollow">.preferredColorScheme (Updated in 2.0)</a><br/><a class="ae li" href="#b1dd" rel="noopener ugc nofollow">.textContentType (NEW in 2.0)</a><br/><a class="ae li" href="#bad9" rel="noopener ugc nofollow">.listItemTint (NEW in 2.0)</a><br/><a class="ae li" href="#b512" rel="noopener ugc nofollow">.listRowPlatterColor (Deprecated in 2.0)</a><br/><a class="ae li" href="#e007" rel="noopener ugc nofollow">.onLongPressGesture (Updated in 2.0)</a><br/><a class="ae li" href="#08ac" rel="noopener ugc nofollow">.onOpenURL (NEW in 2.0)</a><br/><a class="ae li" href="#280a" rel="noopener ugc nofollow">.onPasteCommand (NEW in 2.0)</a><br/><a class="ae li" href="#1470" rel="noopener ugc nofollow">.onDrag and .onDrop (Updated in 2.0)</a><br/><a class="ae li" href="#b6af" rel="noopener ugc nofollow">.onChange (NEW in 2.0)</a><br/><a class="ae li" href="#5b40" rel="noopener ugc nofollow">.keyboardShortcut (NEW in 2.0)</a><br/><a class="ae li" href="#1f71" rel="noopener ugc nofollow">.focusedValue and @FocusedBinding (NEW in 2.0)</a><br/><a class="ae li" href="#a82b" rel="noopener ugc nofollow">.prefersDefaultFocus and .focusScope (NEW in 2.0)</a><br/><a class="ae li" href="#08cf" rel="noopener ugc nofollow">.fullScreenCover (NEW in 2.0)</a><br/><a class="ae li" href="#b221" rel="noopener ugc nofollow">.defaultAppStorage (NEW in 2.0)</a><br/><a class="ae li" href="#faa0" rel="noopener ugc nofollow">.appStoreOverlay (NEW in 2.0)</a><br/><a class="ae li" href="#afd7" rel="noopener ugc nofollow">.toolbar (NEW in 2.0)</a><strong class="nb je"><br/></strong><a class="ae li" href="#4d25" rel="noopener ugc nofollow">.previewContext (NEW in 2.0)</a><br/>.<a class="ae li" href="#1a89" rel="noopener ugc nofollow">userActivity, .onContinueUserActivity (NEW in 2.0)</a><strong class="nb je"><br/></strong><a class="ae li" href="#062a" rel="noopener ugc nofollow">.tabItem (Updated in 2.0)</a><br/><a class="ae li" href="#fbb3" rel="noopener ugc nofollow">.contextMenu (Updated in 2.0)</a><br/><a class="ae li" href="#db72" rel="noopener ugc nofollow">.navigationTitle and .navigationSubtitle (NEW in 2.0)</a><strong class="nb je"><br/></strong><a class="ae li" href="#d253" rel="noopener ugc nofollow">.navigationViewStyle (Updated in 2.0)</a><br/><a class="ae li" href="#2177" rel="noopener ugc nofollow">.navigationBarTitle (Deprecated in 2.0)</a><br/><a class="ae li" href="#3065" rel="noopener ugc nofollow">.navigationBarItems (Deprecated in 2.0)</a></span><span id="3c48" class="nf ng iu nb b gz nl ni l nj nk"><a class="ae li" href="#83f1" rel="noopener ugc nofollow"><strong class="nb je">Styles on iOS, iPadOS, Mac Catalyst and tvOS (NEW in 2.0)</strong></a></span><span id="d3e5" class="nf ng iu nb b gz nl ni l nj nk"><a class="ae li" href="#1b48" rel="noopener ugc nofollow"><strong class="nb je">Styles Only on macOS (NEW in 2.0)</strong></a></span><span id="d5c7" class="nf ng iu nb b gz nl ni l nj nk"><a class="ae li" href="#cc13" rel="noopener ugc nofollow"><strong class="nb je">Next Steps</strong></a></span></pre></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="d1ca" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">查看协议</h1><p id="6bc8" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">如果您还不知道，SwiftUI使用<code class="fe oi oj ok nb b">View</code>协议来创建可重用的界面元素。视图是值类型，这意味着它们使用一个<code class="fe oi oj ok nb b">Struct</code>而不是一个<code class="fe oi oj ok nb b">Class</code>定义。</p><p id="4b05" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这实际上意味着什么呢？</p><p id="c737" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">结构不允许继承。尽管你的结构符合<code class="fe oi oj ok nb b">View</code>协议，但是它们并没有继承苹果提供的一个叫做<code class="fe oi oj ok nb b">View</code>的基类。</p><p id="0175" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这使得它与<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/uikit/uiview" rel="noopener ugc nofollow" target="_blank">UIView</a></code>不同，UIKit中的几乎所有东西都继承自<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/uikit/uiview" rel="noopener ugc nofollow" target="_blank">UIView</a></code>。一个<code class="fe oi oj ok nb b">UIView</code>如果不被分配一个框架并作为一个<code class="fe oi oj ok nb b">UIViewController</code>子类的子视图被添加，基本上是看不到的。</p><p id="df53" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你创建一个新的Xcode项目，它使用SwiftUI而不是Storyboard作为其用户界面的基础，你会自动得到一个SwiftUI <code class="fe oi oj ok nb b">View</code>的例子，叫做<code class="fe oi oj ok nb b">ContentView</code>。</p><p id="0f17" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">您会注意到在<code class="fe oi oj ok nb b">ContentView</code>结构中，有一个名为body的变量。这是<code class="fe oi oj ok nb b">View</code>协议的唯一要求，它使用了对于Swift 5.1来说全新的<code class="fe oi oj ok nb b">some</code>关键字。</p><p id="6398" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你可以依靠一个<a class="ae li" href="https://stackoverflow.com/questions/56433665/what-is-the-some-keyword-in-swiftui" rel="noopener ugc nofollow" target="_blank">堆栈溢出线程</a>来解释这个关键字的意思，比我更好:</p><blockquote class="ol om on"><p id="0ce7" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated">你可以把它看作是一个“反向”通用占位符。与调用者满足的常规泛型占位符不同……不透明结果类型是实现满足的隐式泛型占位符……从中得出的主要结论是，返回<code class="fe oi oj ok nb b"><em class="iu">some P</em></code>的函数是一个返回符合<code class="fe oi oj ok nb b"><em class="iu">P</em></code>的特定单一具体类型的值的函数。</p></blockquote></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="b8ad" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">@ViewBuilder</h1><p id="8c2a" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">这是一种函数生成器，允许您从多个视图中构造一个视图。如果你在你的视图体上添加这个属性，用cmd键点击它，然后选择跳转到定义，你会看到很多有趣的东西。也许最重要的部分是:</p><pre class="kt ku kv kw gu na nb nc nd aw ne bi"><span id="5395" class="nf ng iu nb b gz nh ni l nj nk">public static func buildBlock&lt;C0, C1, C2, C3, C4, C5, C6, C7, C8, C9&gt;(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8, _ c9: C9) -&gt; TupleView&lt;(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9)&gt; where C0 : View, C1 : View, C2 : View, C3 : View, C4 : View, C5 : View, C6 : View, C7 : View, C8 : View, C9 : View</span></pre><p id="e332" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是当您将十个视图放入一个<code class="fe oi oj ok nb b">VStack</code>中以垂直布局时运行的函数。事实上，没有一个构建块可以包含11个视图，这就是你不能无限期地向<code class="fe oi oj ok nb b">VStack</code>添加子元素的原因。在本文档的视图布局和表示章节中会有更多的内容，但是我提到它是有特殊原因的。</p><p id="c077" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je">在Xcode 12中，body属性假设为</strong> <code class="fe oi oj ok nb b"><strong class="ll je">@ViewBuilder</strong></code> <strong class="ll je">。</strong></p><p id="e967" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">为什么这很重要？现在你可以直接在你的身体属性中放置多达十个视图作为孩子。以前，这只能通过将您的视图放在一个<code class="fe oi oj ok nb b">Group</code>中来实现，这是一种获得<code class="fe oi oj ok nb b">@ViewBuilder</code>的好处而没有<code class="fe oi oj ok nb b">VStack</code>、<code class="fe oi oj ok nb b">HStack</code>或<code class="fe oi oj ok nb b">ZStack</code>的布局含义的方法。在SwiftUI的新版本中，这不再是必要的，因此<code class="fe oi oj ok nb b">Group</code>的使用将变得更加小众。</p><p id="9960" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你可能仍然应该把你的视图放在一个<code class="fe oi oj ok nb b">VStack</code>或者<code class="fe oi oj ok nb b">HStack</code>中，因为当你使用它的时候，把它们直接放在一个body属性中是不明确的。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="6dd3" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">视图修改器</h1><p id="8636" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">在我们深入研究2020年的新视图之前，让我们复习一下什么是视图修改器。它们将在新视图旁边显示，所以等到以后再解释它们是什么是没有意义的。</p><p id="11d6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">符合ViewModifier协议的结构可以修改所有视图。该协议只需要一个名为body (content: Content)的函数来返回一个通用视图。因为不能直接创建视图，所以我们传递给ViewModifier的类型是未知的，直到调用该修饰符。内容充当该具体类型的代理。与任何视图的主体一样，返回类型是从实现中推断出来的。</p><p id="168c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">让我们来看一个自定义修改器的例子，这样您就可以看到在这些修改器的表面下发生了什么:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="48bb" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如您所见，添加<code class="fe oi oj ok nb b">.modifier(YourModifier())</code>来调用ViewModifier是可能的，但是使用<code class="fe oi oj ok nb b">View</code>扩展并给出一个干净的调用点更有意义。</p><p id="5045" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">第一种方法<code class="fe oi oj ok nb b">blue(_:)</code>，本质上做<code class="fe oi oj ok nb b">.modifier(YourModifier())</code>做的事情。通过构造<code class="fe oi oj ok nb b">ModifiedContent</code>，我们以一个应用了修饰符的<code class="fe oi oj ok nb b">View</code>结束。但是我们可以通过调用我们的<code class="fe oi oj ok nb b">View</code>上的实例方法<code class="fe oi oj ok nb b">.modifier(YourModifier())</code>来获得相同的结果，从而使这变得不那么复杂。</p><p id="7071" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">第二个方法，<code class="fe oi oj ok nb b">b(_:)</code>，消除了每次我们需要时调用<code class="fe oi oj ok nb b">.modifier(YourModifier())</code>的需要。这是标准修饰符的样子，它减少了我们的<code class="fe oi oj ok nb b">View</code>中的代码量。</p><p id="3df4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">显然<code class="fe oi oj ok nb b">b(_:)</code>对于一个属性、方法或者<code class="fe oi oj ok nb b">ViewModifier</code>来说是一个非常糟糕的名字，但是我让标识符逐渐变短以表明哪一个是最简单的。</p><p id="895f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">首先，我们将看到2020年所有全新的视图，然后是今年更新的2019年视图。</p><p id="aea4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然后，我们将在最后看到哪些视图修改器是新的或更新的。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="cbc2" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">2.0中的新功能:颜色选择器</h1><p id="9a7e" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">从来没有为iOS开发者提供颜色选择器。我以前使用过第三方的，但是依赖性导致依赖其他开发人员来确保与所有未来项目和部署目标的兼容性。在WWDC之前的最后几周，我终于决定在SwiftUI中创建我能想到的每一种颜色选择器控件。这将允许我从这些控件的快速包中<a class="ae li" href="https://github.com/sturdysturge/SwiftUIColourPickerMaker" rel="noopener ugc nofollow" target="_blank">创建颜色选择器，并为任何项目制作颜色选择器。</a></p><p id="c782" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然后WWDC出现了，现在我们有了iOS 14的ColorPicker。这个新的控件看起来非常强大，并且有一些功能，比如可以让你从任何地方选择颜色的滴管。你甚至可以使用滴管从颜色选择器的用户界面中选择颜色，所以很明显这是一个强大的新功能，我们可以免费获得。但据我所知，新的颜色选择器有一套非常严格的控制，不能改变。除非官方文档还没有更新，否则似乎没有办法改变ColorPicker所提供的功能，比如将其限制为只有一个画布、一个调色板或滑块。</p><p id="309f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">相反，这三个选项由用户使用分段选取器来选择。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="194b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">为了获得一些有用的截图和动画gif，看看ColorPicker在你的应用中会是什么样子，请查看<a class="ae li" href="https://medium.com/swlh/using-a-colorpicker-with-swiftui-affc9e8e6093" rel="noopener">使用带有SwiftUI </a>的ColorPicker。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="f14e" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">2.0中的新功能:SpriteView</h1><p id="4f23" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">SpriteKit是苹果制作2D游戏的框架。精灵是用来代表玩家、敌人和投射物等的小位图。因为在一个游戏中，你可能会在屏幕上同时出现很多精灵，所以使用那些考虑到性能的工具是有意义的。现在可以创建一个SwiftUI视图来显示来自SpriteKit的<code class="fe oi oj ok nb b">SKScene</code>,允许你创建一个游戏，然后把这个游戏放到任何你想放SwiftUI视图的地方。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj ou"><img src="../Images/508e359f2e5b74bf2cf30b505b1bfbe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*c23NzLFX-LLbzZSepgEudA.jpeg"/></div></figure><p id="c920" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在我的例子中，我有一个简单的方形精灵，它向来自右边的敌人发射射弹。如果他们一直向左，你就失去了一条命。如果你拿下其中一个，你的分数就会增加。</p><p id="cf96" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">让我们先来看看SwiftUI，它需要一个稍后我们将创建的SpriteKit场景。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="2187" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们有一个名为<code class="fe oi oj ok nb b">GameModel</code>的<code class="fe oi oj ok nb b">ObservableObject</code>来存储我们的数据，还有一个显示我们游戏的<code class="fe oi oj ok nb b">ContentView</code>结构。在一个<code class="fe oi oj ok nb b">VStack</code>的顶部，我们正在显示<code class="fe oi oj ok nb b">HUDView</code>，它告诉我们当前的分数是多少，我们有多少条生命，以及之前记录的最高分数是多少。当我们的生命耗尽时，重启按钮就会出现。这只是改变了<code class="fe oi oj ok nb b">GameModel</code>对象中的一个<code class="fe oi oj ok nb b">@Published </code>属性，我们正在用<code class="fe oi oj ok nb b">ContentView</code>中新的<code class="fe oi oj ok nb b">.onChange</code>修改器观察这个属性。</p><p id="78fe" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">本质上，我们是说当<code class="fe oi oj ok nb b">restartGame</code>为真时，我们想给我们的<code class="fe oi oj ok nb b">GameScene</code>发送一条消息，它应该从开始就解除暂停并重新加载游戏。</p><p id="f81c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">高分是使用<code class="fe oi oj ok nb b">@AppStorage</code>属性包装器记录的，它以一种方便的方式将数据保存到<code class="fe oi oj ok nb b">UserDefaults</code>。我将在本文档的另一章中提供更多关于新属性包装器的信息，但重要的是，使用此包装器的属性会被永久保存，并且可以在下次加载应用程序时轻松调用。当玩家失去生命时，还有一个游戏结束状态，需要玩家点击重启按钮才能再次开始游戏。这将重置分数，移除敌人，并像游戏开始时一样重新开始繁殖敌人。</p><p id="32ed" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">以下是SpriteKit代码:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="916b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">不要太担心游戏的逻辑，因为这是一个用Swift编写的SpriteKit游戏。如果你不太了解SpriteKit，很明显我也不了解，有很多教程可以帮助你入门。</p><p id="91e3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">关于<code class="fe oi oj ok nb b">SpriteView</code>需要知道的重要一点是，它让你可以轻松地将2D游戏嵌入到SwiftUI中。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="9a99" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">2.0中的新功能:文本编辑器</h1><p id="d584" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">在WWDC 2020之前，我们只能用<code class="fe oi oj ok nb b">TextField</code>或<code class="fe oi oj ok nb b">SecureTextField</code>在iOS中处理文本编辑。这些基本上是相同的文本字段，只有<code class="fe oi oj ok nb b">SecureTextField</code>会像任何密码字段一样，通过用黑色圆圈替换字符来掩盖您正在键入的内容。这些文本字段之间的重要相似之处在于它们只允许单行。这意味着多行编辑的唯一选择是使用<code class="fe oi oj ok nb b">UIViewRepresentable</code>从UIKit转换<code class="fe oi oj ok nb b">UITextView</code>:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="e7e6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这相对复杂，但也允许更多的属性。<code class="fe oi oj ok nb b">UITextView</code>允许对<code class="fe oi oj ok nb b">dataDetectorTypes</code>进行更改，这将从键入的文本创建可点击的URL。使用<code class="fe oi oj ok nb b">clearsOnInsertion</code>可以用新文本替换当前文本，并且我们可以通过调用<code class="fe oi oj ok nb b">scrollRangeToVisible</code>滚动到指定的字符串可见。有关更多信息，请查看<a class="ae li" href="https://developer.apple.com/documentation/uikit/uitextview" rel="noopener ugc nofollow" target="_blank"> UITextView文档</a>。</p><p id="3adf" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">虽然我们无法访问这些属性，但新的<code class="fe oi oj ok nb b">TextEditor</code>是对<code class="fe oi oj ok nb b">TextField</code>的重大升级。</p><p id="cfdb" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们现在可以创建一条多线<code class="fe oi oj ok nb b">TextEditor</code>，就像创建一条单线<code class="fe oi oj ok nb b">TextField</code>一样简单。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="701a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">凡是能适用于<code class="fe oi oj ok nb b">Text</code>的，都可以适用于<code class="fe oi oj ok nb b">TextEditor</code>。当我尝试使用<a class="ae li" href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-use-dynamic-type-with-a-custom-font" rel="noopener ugc nofollow" target="_blank">新的动态类型语法</a>和自定义字体时，文本似乎没有根据<code class="fe oi oj ok nb b">TextStyle</code>进行缩放。这可能是第一个测试版的一个错误，或者是我做的方式有问题。无论哪种方式，我对TextEditor的功能所能做的最好的例子就是允许用一个<code class="fe oi oj ok nb b">Stepper</code>来改变字体大小，用一个<code class="fe oi oj ok nb b">Picker</code>来改变字体粗细。一个<code class="fe oi oj ok nb b">ColorPicker</code>可用于选择前景(字体)颜色，但要注意背景目前似乎不起作用。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="917b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">TextEditor</code>似乎有一个<code class="fe oi oj ok nb b">systemBackground </code>颜色的不透明背景，给它添加一个背景只是在它后面放一个背景。</p><p id="ac03" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">您的背景将完全不可见。</p><p id="32a2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">有一个变通办法，这可能是我们目前能做的全部:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ov ot l"/></div></figure><p id="6ac4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">不过，TextEditor确实支持边框，如下图所示。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ow"><img src="../Images/20d94344f8f40d81370d7405753a8499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHdDOUx-UwJCPIW41kun4w.png"/></div></div></figure></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="6f4b" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">2.0中的新功能:SignInWithAppleButton</h1><p id="3420" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">在iOS 13中引入了登录苹果，作为一种无需提供电子邮件和密码即可安全登录应用程序的方式。使用Apple登录使用生物特征来鉴定您是Apple ID的所有者，然后向应用程序发送自动生成的转发地址和密码。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ox"><img src="../Images/51db50e38d09737b404fb7e25ccf0003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4qqezsI6-4Fv98npdpU1bQ.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">这个新按钮简化了在你的应用中使用苹果登录的过程</p></figure><p id="42bf" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">以下示例以约束允许的最大尺寸显示<code class="fe oi oj ok nb b">SignInWthAppleButton</code>(宽度≤ 375)。你没听错:这个观点是有约束的。看起来苹果只是把现有的<a class="ae li" href="https://developer.apple.com/documentation/authenticationservices/asauthorizationappleidbutton" rel="noopener ugc nofollow" target="_blank">包装成了<code class="fe oi oj ok nb b">UIViewRepresentable</code>中的ASAuthorizationAppleIDButton</a>，这正是我们去年让按钮进入SwiftUI所需要做的。但是如果你看到在iOS 13 中<a class="ae li" href="https://medium.com/better-programming/swiftui-sign-in-with-apple-c1e70ccb2a71" rel="noopener">实现苹果登录需要哪些步骤，我们就免去了在协调器中设置委托协议的额外任务。</a></p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="4fb2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我的版本借鉴了苹果的例子，将认证结果输出到应用程序中的<code class="fe oi oj ok nb b">Text</code>并打印出来。第一次尝试时，您可能会注意到登录按钮没有任何作用；这当然是我的经历。</p><p id="ae9b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">第二次点击应该会显示预期的输出。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="be5d" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">进度视图(2.0中的新功能)</h1><p id="0da8" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated"><a class="ae li" href="https://developer.apple.com/documentation/uikit/uiactivityindicatorview" rel="noopener ugc nofollow" target="_blank">UIActivityIndicatorView</a>是一个UIKit控件，允许您显示不确定加载状态的微调器。如果不将它包装在UIViewRepresentable中，我们无法直接使用它，但是现在我们有了一个等效的！构造不带任何参数的ProgressView会导致它显示一个微调器，但向它传递一个进度值会允许它显示为一个水平进度条。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj oy"><img src="../Images/896b05da8053c68b815a401873668738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dbrNqHlBaOw5KC-vlsaEnw.png"/></div></div></figure><p id="479a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">进度条形式类似于<a class="ae li" href="https://developer.apple.com/documentation/uikit/uiprogressview" rel="noopener ugc nofollow" target="_blank"> UIProgressView </a>，在加载网页时经常与<code class="fe oi oj ok nb b">WKWebView</code>结合使用。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="d811" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">您可能会注意到，中间的例子有一个名称、一个值和一个总参数。通常这将导致<code class="fe oi oj ok nb b">ProgressView</code>显示为一个水平进度条，就像下面的例子。然而，你会注意到我已经应用了<code class="fe oi oj ok nb b">.progressViewStyle</code>修改器，将它传递给<code class="fe oi oj ok nb b">CircularProgressViewStyle</code>，使其具有与默认<code class="fe oi oj ok nb b">accentColor</code>相匹配的色调。结果不是一个进度条，而是一个蓝色的圆形微调器。</p><p id="5df8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这说明了一个事实，即当应用一个样式时,“下载”标签被保留，而<code class="fe oi oj ok nb b">ProgressView</code>必须变成圆形，这抵消了自动行为。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="4b62" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">仪表视图(2.0中的新功能)</h1><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj oz"><img src="../Images/29889e6560b7647923b0c6ed47782021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*QRICmqp7AuMW5PVYk-W65A.png"/></div></figure><p id="e5d4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">GaugeView</code>是唯一一款专属于WatchOS 7的新<code class="fe oi oj ok nb b">View</code>。这是一个相对简单的指示器，用于显示数值在标尺上的位置。在我下面的例子中，我还添加了一个<code class="fe oi oj ok nb b">Slider</code>，用于改变<code class="fe oi oj ok nb b">Gauge</code>显示的值。这看起来有点奇怪，因为滑块实际上在它自己的蓝色条上显示当前值。设计仪表的样式非常困难。默认的仪表样式，也称为<code class="fe oi oj ok nb b">LinearGaugeStyle</code>，使用<code class="fe oi oj ok nb b">Color.primary</code>作为其前景色，使用<code class="fe oi oj ok nb b">.foregroundColor</code>或<code class="fe oi oj ok nb b">.accentColor</code>修饰符不会改变这一点。同样的，<code class="fe oi oj ok nb b">CircularGaugeStyle</code>用的是<code class="fe oi oj ok nb b">Color.gray</code>，这个不能改。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="1adf" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">指示仪表上当前值的拇指或圆圈看起来像一个面具，至少在<code class="fe oi oj ok nb b">LinearGaugeStyle</code>的情况下是这样。添加<code class="fe oi oj ok nb b">.background(Color.blue)</code>改变圆的颜色。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="c0e9" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">标签(2.0中的新功能)</h1><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="596f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是一个相对简单的方法，将苹果现在更大的免费图标的SF符号集合中的一个符号与一些提供更大上下文的文本相结合。在我的例子中，我用一个<code class="fe oi oj ok nb b">HStack</code>来比较一个<code class="fe oi oj ok nb b">Label</code>和等价的。在第一个Xcode 12测试版中有一个错误，导致了<code class="fe oi oj ok nb b">Label</code>的<code class="fe oi oj ok nb b">Image</code>与文本不对齐，但现在这个错误已经被修复了。<code class="fe oi oj ok nb b">.labelStyle</code>有两个选项，一个只显示<code class="fe oi oj ok nb b">Text</code>，一个只显示<code class="fe oi oj ok nb b">Image</code>。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="f1be" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">链接(2.0中的新功能)</h1><p id="0fd1" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">我一直认为在iOS应用中不能使用超链接有点可惜。当然，您可以创建一个带有蓝色文本的按钮来打开一个URL，但是这需要的代码比您每次想写的代码都要多。在这个例子中，我使用的是方便的初始化器<code class="fe oi oj ok nb b">Button</code>，它只接受一个标题字符串(或本地化的字符串密钥)，因为这是我能得到的最小的原始形式的代码。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="e5e0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在iOS 14中，我们现在有了<code class="fe oi oj ok nb b">Link</code>，它替我们做了上面<code class="fe oi oj ok nb b">Button</code>的动作部分。我不喜欢<a class="ae li" href="https://developer.apple.com/documentation/swiftui/link" rel="noopener ugc nofollow" target="_blank">苹果的文档</a>用“！”不安全地打开一个网址运算符，因为这是一种极其糟糕的做法，我很惊讶他们会在代码示例中鼓励这种做法。当然，他们可能知道这个特定的网址已经成功创建，因为他们链接到了example.com/TOS.html，这是一个由IANA互联网号码分配机构所有的网站，它将网址转换成IP地址。</p><p id="8840" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">但是，如果你把URL字符串的有效性留给你的人类确定性，你迟早会犯错误。</p><p id="1217" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">任何应用程序在不安全地打开一个可选的时候意外地发现零，都会立即崩溃。</p><p id="986f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这就是为什么我上面的例子比苹果的例子多花了几行，但它做得很安全。在SwiftUI的第一个版本中，由于缺少可选绑定(<code class="fe oi oj ok nb b">if let</code>或<code class="fe oi oj ok nb b">guard let</code>)，这个例子受到了阻碍，因为我只能将我的URL与nil进行比较，以确保它存在。当这种比较确认URL不为空时，这仍然不意味着我可以在<code class="fe oi oj ok nb b">Button</code>中使用它而不用先打开它。这就是为什么在<code class="fe oi oj ok nb b">Button</code>动作中有一个稍微令人困惑的额外步骤，它可选地绑定URL以确保它不为零。</p><p id="dc21" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我本可以将<code class="fe oi oj ok nb b">assertionFailure</code>放在else语句中的<code class="fe oi oj ok nb b">Button</code>动作中的<code class="fe oi oj ok nb b">if let</code>之后，但是为了与我的<code class="fe oi oj ok nb b">Link</code>示例保持一致，我想添加<code class="fe oi oj ok nb b">EmptyView</code>。不需要包含<code class="fe oi oj ok nb b">EmptyView</code>的else语句，因为当if条件为假时，<code class="fe oi oj ok nb b">ViewBuilder</code>闭包的唯一占用者周围的任何if语句都将返回<code class="fe oi oj ok nb b">EmptyView</code>。但是我想明确地说明如果我们的URL为零会发生什么。用户将什么也看不到，但是在调试模式下将为开发人员触发一个断言。</p><p id="578c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这将使我们意识到URL是空的，但不会导致最终用户崩溃。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="b1b9" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在SwiftUI支持if let，我可以直接创建像URL这样的属性，并创建使用这些数据的视图。和以前一样，只有在可以创建URL时才会显示链接，但是我们不需要进行多次检查来确保这一点。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="29e5" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">菜单(2.0中的新功能)</h1><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pa"><img src="../Images/077f3e2bb2a7c92e5bd058f5246d2257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*81ErCLjp4h5KGlklk8zt7Q.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">默认样式是BorderedButtonMenuStyle</p></figure><p id="375d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">MenuButton</code>已被<code class="fe oi oj ok nb b">Menu</code>取代。最初的是一个下拉菜单，替换的并没有太大的不同。新名字增加的主要内容是清晰，因为我们正在谈论一个菜单和里面的项目，所以称它为按钮没有多大意义。<code class="fe oi oj ok nb b">Menu</code>有几种不同的款式可供选择。默认样式是<code class="fe oi oj ok nb b">BorderedButtonMenuStyle</code>，这就是为什么右边的<code class="fe oi oj ok nb b">DefaultButtonMenuStyle</code>看起来一样，而中间的<code class="fe oi oj ok nb b">BorderlessButtonMenuStyle</code>看起来不一样。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="edf5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">除了新的样式之外，它删除了任何关于它是一个“下拉”菜单的事实，唯一的变化是<code class="fe oi oj ok nb b">MenuButton</code>被称为<code class="fe oi oj ok nb b">Menu</code>并且<code class="fe oi oj ok nb b">.menuButtonStyle</code>修饰符现在被称为<code class="fe oi oj ok nb b">.menuStyle</code>。</p><p id="a259" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在第一个测试版中<code class="fe oi oj ok nb b">Menu</code>只在macOS上可用，就像它取代的控件一样。</p><p id="df8c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">不过<a class="ae li" href="https://medium.com/@luca.jon/swiftui-contextmenu-and-menu-for-ios-e01f90e525f6" rel="noopener"> beta 3也在iOS上增加了对菜单的支持</a>。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="6b9b" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">MenuButton(在2.0中已弃用)</h1><p id="10f9" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">参见上面的<code class="fe oi oj ok nb b">Menu</code>，它取代了<code class="fe oi oj ok nb b">MenuButton</code>，但具有许多相同的功能。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="ab2f" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">文本(在2.0中更新)</h1><p id="d61b" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">文本可能是创建视图最简单的构件。在大多数情况下，您将传递一个<code class="fe oi oj ok nb b">String</code>来创建它，这将是它显示的内容。该文档的原始版本包含了创建它的所有其他方法，包括从本地化、ObservableObjects和子字符串。这些可以在这个例子的底部找到，但我们在2020年也有许多新的初始化器，它们包括在这个例子的顶部。</p><p id="cd99" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">第一个非常令人兴奋，因为它可以接受任何通用对象和从<code class="fe oi oj ok nb b">Formatter</code>继承的任何类。这可以是Apple提供的任何一种<code class="fe oi oj ok nb b">Formatter</code>类型，或者，在我的例子中，是您专门为自己的自定义类型创建的<code class="fe oi oj ok nb b">Formatter</code>。我不太确定<code class="fe oi oj ok nb b">Formatter</code>是如何实现的，所以我只是随意地将该对象绑定到我的自定义类的一个实例，并在所有其他情况下返回nil。</p><p id="d44e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">注意，带有<code class="fe oi oj ok nb b">LocalizedStringKey</code>、<code class="fe oi oj ok nb b">tableName</code>、<code class="fe oi oj ok nb b">bundle</code>和<code class="fe oi oj ok nb b">comment</code>的文件需要一个使用<code class="fe oi oj ok nb b">.strings</code>文件扩展名的单独文件。正如在<a class="ae li" href="https://developer.apple.com/documentation/swiftui/text/3065754-init" rel="noopener ugc nofollow" target="_blank">苹果关于这个初始化器</a>的文档中提到的，唯一需要的参数是键的字符串。我给出了一个详细的例子，主要是为了让您了解这些其他参数需要什么。</p><p id="89a6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">tableName</code>的默认值是<code class="fe oi oj ok nb b">Localizable</code>，这是字符串文件的标准名称。我特意将我的命名为<code class="fe oi oj ok nb b">Local</code>,以说明为什么我需要这个参数。默认情况下，这个包是主包，所以在这种情况下传递<code class="fe oi oj ok nb b">Bundle.main</code>是多余的。注释应该给出上下文信息，但是在这个例子中，我只给了它字符串<code class="fe oi oj ok nb b">Comment</code>。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="6080" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">Text</code>现在可以使用插值包含一个<code class="fe oi oj ok nb b">Image</code>，或者表示一个<code class="fe oi oj ok nb b">Date</code>。新增三种字体:<code class="fe oi oj ok nb b">caption2</code>、<code class="fe oi oj ok nb b">title2</code>和<code class="fe oi oj ok nb b">title3</code>。这些都是作为<a class="ae li" href="https://developer.apple.com/documentation/uikit/uifont/textstyle" rel="noopener ugc nofollow" target="_blank"> UIFont </a>的一部分提供的，所以它们出现在SwiftUI上也就不足为奇了。新的修饰符允许您选择文本是大写还是小写，以及是使用等宽还是衬线设计。</p><p id="66a5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我还没有包括使用动态类型的新方法，使您的自定义字体像系统样式一样容易访问。为此，我将使用Swift的动态类型指南链接到<a class="ae li" href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-use-dynamic-type-with-a-custom-font" rel="noopener ugc nofollow" target="_blank"> Hacking，因为我只会重复那里说过的话。</a></p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="fd7f" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">图像(在2.0中更新)</h1><p id="50c3" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">SF Symbols 2支持在Mac应用程序中使用。试图使用<code class="fe oi oj ok nb b">Image(systemNamed:)</code>在Xcode 11中使用SF符号会导致错误“外来参数标签‘system named:‘in call’”。这意味着你不能在任何本地Mac应用程序中使用SF符号，甚至不能在Catalyst应用程序中使用，因为macOS无法显示它们。据推测，在macOS Catalina上运行的SF Symbols Mac应用程序使用PNG作为符号的缩略图，因为它们不可能一直使用<code class="fe oi oj ok nb b">Image(systemNamed:)</code>。</p><p id="adb7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">无论如何，从Xcode 12和macOS 11 Big Sur开始，你将不会收到那些警告，并且可以在原生macOS和Mac Catalyst应用中使用<code class="fe oi oj ok nb b">Image(systemNamed:)</code>。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="4777" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">按钮(在2.0中更新)</h1><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pb"><img src="../Images/ec999a5bdea4ca104fc0986a0d3cf709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w-63vQcQCw26f6d_mnvPnw.png"/></div></div></figure><p id="faf0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在tvOS上有一个<code class="fe oi oj ok nb b">CardButtonStyle</code>选项，它制作了一个较小的按钮，颜色不太明显。上面的例子显示了一个没有任何风格的<code class="fe oi oj ok nb b">Button</code>，所以它采用了<code class="fe oi oj ok nb b">DefaultButtonStyle</code>，所以你可以看到不同之处。新的<code class="fe oi oj ok nb b">Button</code>更加微妙，可以用于不太重要的选项，而不是那些被赋予更明亮颜色的选项。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="0f81" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我必须给<code class="fe oi oj ok nb b">CardButtonStyle</code> <code class="fe oi oj ok nb b">Button</code>添加填充，因为出于某种原因它没有填充。这可能会在以后的测试版中改变，因为我只在Xcode 12 beta 2上测试过。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="ec57" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">粘贴按钮(在2.0中更新)</h1><p id="076a" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">此控件允许您在MacOS上粘贴信息，但在iOS上不可用。它可以采用各种数据类型，这些数据类型被表示为UTIs。引用苹果的文档，“统一类型标识符声明了从其他应用程序加载、保存或打开资源的通用类型。”在Xcode 11中，当创建一个<code class="fe oi oj ok nb b">PasteButton</code>时，有必要在一个数组中提供这些字符串。</p><p id="04e4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我在示例中包含了一个函数，可以让您查找任何类型的UTI字符串，这可能会在实现这个按钮时对您有所帮助。</p><p id="ab7f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在我们有了一个名为<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/uniformtypeidentifiers/uttype" rel="noopener ugc nofollow" target="_blank">UTType</a></code>的新结构，这使得创建您想要支持的类型变得更加容易。你可以给这个结构的初始化器传递一个在Xcode 11中有效的字符串，或者你可以使用提供的众多系统声明类型<a class="ae li" href="https://developer.apple.com/documentation/uniformtypeidentifiers/uttype/system_declared_types" rel="noopener ugc nofollow" target="_blank">中的一个。</a></p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="b849" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">接受字符串的初始化器返回一个可选的，所以如果你使用它，你必须确保你使用的字符串是正确的。我在我的例子中使用了<code class="fe oi oj ok nb b">UTType.text</code>，但是我在下面包含了一个从字符串手动构造它的例子。请注意，不建议使用感叹号强制展开可选的。我只是想说明从系统声明的类型中得到的<code class="fe oi oj ok nb b">UTType</code>不是nil，所以从字符串中构造的等价类型也不是nil。</p><p id="6f55" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">一旦决定了需要什么类型的标识符，就需要处理从<code class="fe oi oj ok nb b">NSItemProvider</code>中获得的数据。我的例子只粘贴了数组中的第一项，但希望它能清楚地说明如何处理其他数据类型和多项。</p><p id="1e0e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">以下是符合<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/foundation/nsitemproviderwriting" rel="noopener ugc nofollow" target="_blank">NSItemProviderWriting</a></code>的类型列表，因此可以用<code class="fe oi oj ok nb b">PasteButton</code>粘贴:</p><ul class=""><li id="f583" class="mf mg iu ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/contacts/cncontact" rel="noopener ugc nofollow" target="_blank">CNContact</a></code></li><li id="a07b" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/contacts/cnmutablecontact" rel="noopener ugc nofollow" target="_blank">CNMutableContact</a></code></li><li id="b37a" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/corespotlight/cslocalizedstring" rel="noopener ugc nofollow" target="_blank">CSLocalizedString</a></code></li><li id="82b0" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/mapkit/mkmapitem" rel="noopener ugc nofollow" target="_blank">MKMapItem</a></code></li><li id="7d9d" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/foundation/nsattributedstring" rel="noopener ugc nofollow" target="_blank">NSAttributedString</a></code></li><li id="dce6" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/foundation/nsmutablestring" rel="noopener ugc nofollow" target="_blank">NSMutableString</a></code></li><li id="8db9" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/foundation/nsstring" rel="noopener ugc nofollow" target="_blank">NSString</a></code></li><li id="a891" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/uikit/nstextstorage" rel="noopener ugc nofollow" target="_blank">NSTextStorage</a></code></li><li id="c99a" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/foundation/nsurl" rel="noopener ugc nofollow" target="_blank">NSURL</a></code></li><li id="0d22" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/foundation/nsuseractivity" rel="noopener ugc nofollow" target="_blank">NSUserActivity</a></code></li><li id="7591" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/uikit/uicolor" rel="noopener ugc nofollow" target="_blank">UIColor</a></code></li><li id="6df2" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/uikit/uiimage" rel="noopener ugc nofollow" target="_blank">UIImage</a></code></li></ul><p id="3958" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">您还可以使用自己的自定义类型来符合该协议，从而允许您粘贴自定义类型的数据。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="e003" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">切换(在2.0中更新)</h1><p id="12b5" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">iOS上的默认样式SwitchToggleStyle现在允许我们选择一种仅当切换绑定的布尔值为真时才显示的色调颜色。iOS和iPadOS上的默认切换色调是绿色，而Mac Catalyst上的默认切换色调是蓝色。在原生Mac应用程序中使用带有色调颜色选项的新SwitchToggleStyle当前会显示我们预期的开关，但色调颜色仍然是默认的蓝色。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="5bb5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">最上面的<code class="fe oi oj ok nb b">Toggle</code>，我加的时候没有加<code class="fe oi oj ok nb b">ToggleStyle</code>做对比，显示的是macOS默认的<code class="fe oi oj ok nb b">CheckboxToggleStyle</code>。这是一个复选框，打开时会显示勾号，并且没有色调选项。我给这个开关添加了一个<code class="fe oi oj ok nb b">accentColor</code>修饰符，这表明当用户没有在他们的系统偏好设置的常规部分的高亮颜色下拉菜单中选择‘强调颜色’时，macOS实际上允许改变开关色调。</p><p id="e1f4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这可以用来改变<code class="fe oi oj ok nb b">Toggle</code>的任何一种风格；我只是没有给第二个添加<code class="fe oi oj ok nb b">accentColor</code>修改器来显示带有淡色的<code class="fe oi oj ok nb b">SwitchToggleStyle</code>没有效果。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="9756" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">日期选择器(在2.0中更新)</h1><p id="2c25" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">现在<code class="fe oi oj ok nb b">DatePicker</code>有两个新款式，叫做<code class="fe oi oj ok nb b">GraphicalDatePickerStyle</code>和<code class="fe oi oj ok nb b">CompactDatePickerStyle</code>。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pc"><img src="../Images/b2f98a63136f2bb095d2de8bae7fbaaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_CyAAnSfo6E7wb14ukGkXg.png"/></div></div></figure><p id="6193" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你可能会注意到右边macOS上的<code class="fe oi oj ok nb b">GraphicalDatePickerStyle</code>版本比左边iOS、iPadOS和Mac Catalyst共享的版本小得多。当我允许最小高度为400时，我只能让<code class="fe oi oj ok nb b">DatePicker</code>正确显示。少一点的话,<code class="fe oi oj ok nb b">DatePicker</code>就会截取一些文本——特别是用来设置时间的部分。</p><p id="e366" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这导致宽度按比例缩放，这意味着在像iPhone 8这样的小设备上，<code class="fe oi oj ok nb b">DatePicker</code>超过了屏幕宽度。也许这将在未来的测试版中得到解决，因为我使用的是Xcode 12 beta 2。不幸的是，在iOS、iPadOS和Mac Catalyst上可用但不是原生macOS应用程序的WheelDatePickerStyle似乎仍然具有最小宽度，这使得它在小屏幕上的标签空间非常小。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="799c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">CompactDatePickerStyle</code>现在是iOS、iPadOS和Mac Catalyst上的默认。这实际上是一个显示当前值的按钮，当点击按钮时，会显示一个类似于<code class="fe oi oj ok nb b">GraphicalDatePickerStyle</code>的小日历。这使您可以非常紧凑地显示当前日期，而无需一直显示整个日历。</p><p id="7e19" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我的示例在<code class="fe oi oj ok nb b">WheelDatePickerStyle</code>示例周围有条件编译标志<code class="fe oi oj ok nb b">#if os(iOS) || targetEnvironment(macCatalyst)</code>。</p><p id="ea28" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这意味着无论你为什么平台构建它，你都会看到该平台支持的所有<code class="fe oi oj ok nb b">DatePicker</code>变体。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="6299" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">2.0中新增和更新的视图修改器</h1><h1 id="7abe" class="nm ng iu bd nn no pd nq nr ns pe nu nv kj pf kk nx km pg kn nz kp ph kq ob oc bi translated">。matchedGeometryEffect(2.0中的新功能)</h1><p id="34d3" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">从名字就可以看出，<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/securefield/matchedgeometryeffect(id:in:properties:anchor:issource:)?changes=latest_minor" rel="noopener ugc nofollow" target="_blank">.matchedGeometryEffect</a>t</code>是一种动画效果，可以改变大小和位置。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pi"><img src="../Images/6c1d67d48754214c3c1dd9d66f847bd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/1*SpUgTRu3hU7h7hvVQzM7pQ.gif"/></div></figure><p id="35dd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">像<a class="ae li" href="https://sarunw.com/posts/a-first-look-at-matchedgeometryeffect/#what-is-matchedgeometryeffect-for%3F" rel="noopener ugc nofollow" target="_blank">萨润的例子</a>，我用了一个<code class="fe oi oj ok nb b">Text</code>和一个<code class="fe oi oj ok nb b">Shape</code>，但是我的是一个<code class="fe oi oj ok nb b">Circle</code>而不是一个<code class="fe oi oj ok nb b">RoundedRectangle</code> ( <em class="oo">完全</em>不同)。我认为在各种配置中放置两个视图会很有趣，而不是在bool的基础上从一个<code class="fe oi oj ok nb b">VStack</code>变成一个<code class="fe oi oj ok nb b">HStack</code>。这些配置是相对于<code class="fe oi oj ok nb b">TextPosition</code>枚举的，您可以猜测它的值是什么意思。这些值是左、中、右、上和下。当<code class="fe oi oj ok nb b">Text</code>位于中间时，<code class="fe oi oj ok nb b">Circle</code>通过降低其不透明度进行调整，从而更容易看到在<code class="fe oi oj ok nb b">ZStack</code>中层叠在它上面的文本。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="14d5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我的例子相对简单，所以请查看以下更好的来源:</p><ul class=""><li id="4210" class="mf mg iu ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated"><a class="ae li" href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-synchronize-animations-from-one-view-to-another-with-matchedgeometryeffect" rel="noopener ugc nofollow" target="_blank">用Swift进行黑客攻击:matchedGeometryEffect() </a></li><li id="5bc0" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><a class="ae li" href="https://swiftui-lab.com/matchedgeometryeffect-part2/" rel="noopener ugc nofollow" target="_blank"> SwiftUI实验室MatchedGeometryEffect第1部分</a> &amp; <a class="ae li" href="https://swiftui-lab.com/matchedgeometryeffect-part2/" rel="noopener ugc nofollow" target="_blank">第2部分</a></li><li id="d713" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/fruta_building_a_feature-rich_app_with_swiftui" rel="noopener ugc nofollow" target="_blank">苹果的Fruta样本app代码</a></li></ul></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="7260" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。帮助(2.0中的新功能)</h1><p id="660b" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">可访问性修饰符。“帮助”提供了MacOS中的工具提示以及在MacOS和iOS上都有效的辅助功能提示。我的例子展示了这个新的修饰符实际上是如何覆盖先前应用的任何可访问性提示的，反之亦然。当我在iOS上运行这个时，VoiceOver将第一个文本读为“标签1，帮助1”，因为帮助修饰符是在提示后添加的。第二个文本读作“标签2，提示2”，因为该提示是在help修饰符之后添加的。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="0ac3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这种行为在MacOS上是类似的，除了显示帮助文本的工具提示，而不管帮助是否被可访问性提示覆盖。换句话说，虽然第二段文字仍然被VoiceOver读为“标签2，提示2”，但是鼠标悬停在上面仍然显示“帮助2”。</p><p id="3cbd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在Mac Catalyst中，似乎既不读取帮助修饰符也不读取可访问性提示。</p><p id="4960" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">Catalyst中似乎也没有帮助的工具提示功能。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="5f0d" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。可访问性(输入标签:)(2.0中的新功能)</h1><p id="b3ea" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">输入标签由语音控制(不是VoiceOver)和全键盘访问使用。当启用语音控制时，说出“点击输入”等命令将按下此<code class="fe oi oj ok nb b">Button</code>。这为您的UI元素提供了一系列不同的标签，VoiceOver看不到这些标签。</p><p id="16f8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">换句话说，它们是人们口头描述按钮的方式。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="5c8f" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。可访问性(selectionIdentifier:)(在2.0中已弃用)</h1><p id="d7c5" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">该标识符先前被<code class="fe oi oj ok nb b">Picker</code>用来识别当前选择。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="6d05" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。scaleEffect(在2.0中更新)</h1><p id="7d0e" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">这不是新的，但是一个原始的修改器已经被修复了。在Xcode 11中，。scaleEffect(x: 2)导致Y缩放为零。在Xcode 12中，默认参数都是1，这意味着您可以保持其中一个不变，并缩放其中一个，而无需同时设置两个参数。</p><p id="8b23" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">打电话。Xcode 11中的scaleEffect()将整个视图缩放为零！</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="5789" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在Xcode的每个版本中试试上面的例子，你就会明白我的意思了。</p><p id="7610" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在Xcode 11中，两个矩形都是不可见的，而在Xcode 12中，它们显示为一个正方形和一个矩形。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="dd49" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。imageScale(2.0中的新功能)</h1><p id="e172" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui" rel="noopener ugc nofollow" target="_blank">imageScale</a></code>似乎只适用于符号。我尝试过将图像文件的名称传递到图像的初始化器中，但是<code class="fe oi oj ok nb b">imageScale</code>似乎不起作用。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="e132" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然而，它将在<code class="fe oi oj ok nb b">Label</code>上工作，它也有一个初始化器，为所提供的SF符号之一取一个系统名。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="0437" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。重音颜色(在2.0中更新)</h1><p id="d349" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">下面的第一个例子在iOS 13、macOS Catalyst 13、tvOS 13和watchOS 6上是可能的。唯一不支持它的平台是macOS，但这在2020年发生了变化。用一个<code class="fe oi oj ok nb b">Button</code>来改变字体颜色，这在以前的平台上是不可能的。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="b984" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在我的第二个例子中，我使用了<code class="fe oi oj ok nb b">foregroundColor</code>来改变Mac上<code class="fe oi oj ok nb b">Button</code>的字体颜色。这是可行的，但在Xcode 12中不再需要。</p><p id="a319" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在我们可以使用<code class="fe oi oj ok nb b">accentColor</code>来改变所有平台上的字体颜色，这允许我使用接受字符串的<code class="fe oi oj ok nb b">Button</code>版本，并且不需要我创建<code class="fe oi oj ok nb b">Text</code>。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="81c1" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。preferredColorScheme(在2.0中更新)</h1><p id="483d" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">现有的<code class="fe oi oj ok nb b">colorScheme(_ colorScheme: <a class="ae li" href="https://developer.apple.com/documentation/swiftui/colorscheme" rel="noopener ugc nofollow" target="_blank">ColorScheme</a>)</code>修饰符现在在苹果操作系统的当前版本中被弃用。此修改器的目的是覆盖单个视图及其子视图的系统配色方案，而<code class="fe oi oj ok nb b">preferredColorScheme</code>用于覆盖整个演示文稿的配色方案。这是指显示视图的弹出窗口或窗口。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="0c1d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">虽然这个修饰符不是新的，但是2020年新增加的是这个参数现在是可选的。为了说明这一点，我的例子包含了一个开关，它可以改变纸张是否应该是深色的。用<code class="fe oi oj ok nb b">colorScheme</code>，不可能有三进制表达式<code class="fe oi oj ok nb b">sheetIsDark ? .dark : nil</code>，但现在我们可以用<code class="fe oi oj ok nb b">preferredColorScheme</code>。</p><p id="528e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">preferredColorScheme</code>只适用于演示文稿，而不是每个单独的视图，这似乎是一个缺点，但我不知道为什么你想只对一个视图应用配色方案。</p><p id="f3b2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你要么希望你的应用程序的屏幕使用系统配色方案，要么你想用你自己的覆盖它。</p><p id="f6b1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你想让不同的视图表现出不同的配色方案，你可以改变它们的配色方案。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="b1dd" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。text content type(2.0中的新功能)</h1><p id="153c" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">这个修饰符告诉设备当用户输入时什么样的建议是有用的。</p><p id="57c2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">您可能会注意到，与其他平台相比，这个修改器在Mac上采用了不同的类型。Mac不仅不能使用任何UITextContentType声明，而且还被限制使用NSTextContentType，该类型目前只有三个选项。当我试用它们时，我看不出它们在MacBook Touch Bar上提供的建议有什么不同，但也许我在某种程度上做错了。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="5057" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我注意到没有用户名和密码的建议，这可能是不必要的。</p><p id="4002" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我没有时间一一介绍它们，也没有时间注意它们的复杂性，但是我提供了它们的一个数组，这样我的代码示例就不会太长。</p><p id="7dac" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">看看你能找到什么不同，然后告诉我！</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="bad9" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。listItemTint(2.0中的新功能)</h1><p id="1c0a" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">根据平台的不同，更改列表项的色调会有不同的效果。引用苹果关于新<code class="fe oi oj ok nb b">.listItemTint</code>修改器的官方文档:</p><blockquote class="ol om on"><p id="d488" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated">包含列表的样式将适当地应用该色调。watchOS使用浅色作为其背景拼盘外观。iOS和macOS上的边栏将淡色应用到它们的<code class="fe oi oj ok nb b">ItemLabel</code>图标，否则默认使用强调色。</p></blockquote><p id="ddb7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在寻找一种叫做<code class="fe oi oj ok nb b">ItemLabel</code>的东西后，我意识到这似乎并不存在。然而，<code class="fe oi oj ok nb b">List</code>中的任何项目都可以是<code class="fe oi oj ok nb b">Label</code>，所以我尝试了一下，它成功了。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pj"><img src="../Images/b945248a9dbf1ae1e5c87d7ac5de8692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dIZAmA35f64t_HSBOevDbQ.png"/></div></div></figure><p id="2132" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我不知道他们为什么指定“iOS和macOS上的侧边栏”，因为它似乎对任何<code class="fe oi oj ok nb b">List</code>都通用，而且iOS没有侧边栏。</p><p id="f3d7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">那是iPadOS，完全<em class="oo">不一样！</em></p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="0c89" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">watchOS使用浅色作为背景是一个巨大的差异。<code class="fe oi oj ok nb b">Label</code>图标完全不着色，着色用于任何项目，而不仅仅是<code class="fe oi oj ok nb b">Label</code>。<code class="fe oi oj ok nb b">.listItemTint</code>修饰符可以直接采用一种颜色，但它也可以采用一种叫做<code class="fe oi oj ok nb b">ListItemTint</code>(带有一个大写字母)的结构。您可以给它一个<code class="fe oi oj ok nb b">.preferred</code>变体，它可以被父类覆盖，或者给它一个<code class="fe oi oj ok nb b">.fixed</code>变体，它不能。在iOS上，<code class="fe oi oj ok nb b">ListItemTint</code>的<code class="fe oi oj ok nb b">.monochrome</code>样式使图标变成灰色，而在watchOS上，它使列表项的背景变成黑色。在iOS上，你会注意到<code class="fe oi oj ok nb b">.accentColor</code>和<code class="fe oi oj ok nb b">Color.blue</code>的变化是一样的，而在watchOS上，重音颜色是灰色而不是蓝色。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="b512" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。listRowPlatterColor(在2.0中已弃用)</h1><p id="65bc" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">上面新的<code class="fe oi oj ok nb b">.listItemTint</code>修改器取代了<code class="fe oi oj ok nb b">.listRowPlatterColor</code>。</p><p id="b7fc" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这个不赞成使用的修饰符只在WatchOS上可用，而且只有一种颜色。有了<code class="fe oi oj ok nb b">.listItemTint</code>，你可以使用<code class="fe oi oj ok nb b">ListItemTint</code>，所以你不仅仅局限于一种颜色。新的修改器也覆盖了旧的，所以即使在<code class="fe oi oj ok nb b">.listItemTint</code>之后使用<code class="fe oi oj ok nb b">.listRowPlatterColor</code>，也会使用传递给<code class="fe oi oj ok nb b">.listRowPlatterColor</code>的颜色。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="e007" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。onLongPressGesture(在2.0中更新)</h1><p id="faf3" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">现在可以使用SwiftUI向tvOS上的视图添加长按手势。</p><p id="d0ad" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你需要能够给你的视图添加焦点，所以我使用了<code class="fe oi oj ok nb b">focusable()</code>修改器。你可以在没有参数的情况下使用这个修饰符，但是我使用了一个闭包来改变我的自定义按钮的颜色，当它们有焦点时显示出来。如果我不这样做，在任何给定的时间都不会有哪个按钮被选中的指示。我使用了一个枚举来包含四种按钮状态:未聚焦、聚焦、按下和按下。没有必要为按下状态设置一个闭包，但是我这样做是为了说明在长按达到其最小持续时间之前，您可以运行代码。默认的持续时间是0.5秒，所以如果您也增加这个持续时间，您可能只需要对UI进行更改。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="c1ca" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这个代码从2019年开始可以在任何平台上工作，但从2020年开始只能在tvOS 14.0上工作。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="08ac" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。onOpenURL(2.0中的新功能)</h1><p id="0434" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">这个修饰符与打开网站的URL无关。这些网址只能由你的应用程序打开，而且只能由你的应用程序打开。</p><p id="8570" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">onOpenURL</code>修饰符适用于使用新SwiftUI应用生命周期的SwiftUI应用，该生命周期不使用AppDelegate或SceneDelegate。如果你的项目中有这些文件，你可能无法让这个修改器工作，就像我一样。创建项目时，确保选择“SwiftUI App”作为生命周期选项，而不是“UIKit App Delegate”。</p><p id="6612" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">要为您的应用程序创建一个独特的URL方案，请选择您的项目设置的“信息”标签，无论它是用于iOS还是macOS目标。无需更改屏幕顶部的自定义目标属性，您会看到屏幕底部已经有一个URL类型部分。打开它并单击“+”按钮将允许您为您的应用程序创建一个新的URL方案，前提是它是唯一的，并且不能与用户设备上的任何其他应用程序相同。为了这个例子的目的，我称它为<code class="fe oi oj ok nb b">my-scheme</code>，但是你可以选择任何东西。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pk"><img src="../Images/c033f1b6edb2306686a132ecd8439e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3O_zYFAj4DaKUgOVmimDfQ.png"/></div></div></figure><p id="0a61" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">标识符字段是可选的，但是您可能想要使用它，因为URL类型在没有它的菜单中被简单地称为<em class="oo">无标题</em>。</p><p id="356d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在我们已经有了一个URL方案，我们可以用代码来完成剩下的工作。在下面的例子中，我添加了使用文本字段来改变打开的链接的功能。您设置的URL方案需要在ContentView结构中设置为常量。如果你像我一样使用我的方案，你不需要做任何事情。我扩展了URL、字符和字符串，以便过滤来自文本字段的输入。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="cc3a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">因为URL中允许的字符被设置为一个名为<code class="fe oi oj ok nb b">allowedCharacters</code>的常量，所以我们可以确定添加到TextField中的任何文本都可以成功创建一个URL。如果创建的URL除了非法字符什么都没有，这段代码会把它们全部过滤掉，留给我们一个空字符串。这是代码可能失败的一种方式，因为URL不能用空字符串创建。幸运的是，我们是单独应用URL方案的，URL只能用这个方案来构造，其他什么都没有，所以在这种情况下，空字符串是可以的。</p><p id="d9e9" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">无论您是否键入URL，显示“Open”的链接都会打开该URL，onOpenURL修饰符会将该URL添加到一个列表中。因为我们是在打开这些网址的应用程序中进行这项工作，所以我们实际上并不去任何地方。如果您想要查看链接实际执行的操作，请尝试输入以您在Safari中设定的URL方案开头的URL。这将询问您是否要打开应用程序中的URL，然后您将被带回到应用程序。</p><p id="2630" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果一切正常，您在Safari中输入的URL也应该被添加到已打开的URL列表中。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="280a" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。onPasteCommand(2.0中的新功能)</h1><p id="33f2" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">这个花了很长时间才弄明白。<a class="ae li" href="https://developer.apple.com/documentation/swiftui/text/onpastecommand(of:perform:)-6gha3" rel="noopener ugc nofollow" target="_blank">onPasteCommand</a>的官方文档称修饰符增加了“一个响应系统粘贴命令的动作”但是不要认为你给它的闭包会在你粘贴到一个<code class="fe oi oj ok nb b">TextField</code>时运行。修改器似乎只对SwiftUI视图有效，而不是像TextField那样用<code class="fe oi oj ok nb b">UIViewRepresentable</code>包装UIKit控件。</p><p id="3203" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">但是如果它不是一个<code class="fe oi oj ok nb b">TextField</code>，你怎么允许一个视图接受粘贴呢？毕竟，在没有文本字段的情况下尝试这样做会导致错误声音，并且默认菜单栏中的编辑&gt;粘贴选项是灰色的。答案就在<a class="ae li" href="https://asciiwwdc.com/2019/sessions/231" rel="noopener ugc nofollow" target="_blank">WWDC 2019</a>第231届会议的一份文字记录中，当时发布了该修改件的原始版本:</p><blockquote class="ol om on"><p id="a081" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated">然而，我想指出一些真正使onPaste不同于onDrop的东西。第一部分是闭包里没有位置参数。这是了解这里到底发生了什么的关键。当你拖放时，用户通过光标或触摸位置直接定位哪个视图应该接受拖放，但是粘贴命令更加间接。用户要么从菜单中选择粘贴，要么使用键盘快捷键或iOS中的新手势。<strong class="ll je">我们解决粘贴命令应该指向哪个视图这一问题的方法是使用焦点系统。</strong></p></blockquote><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pl"><img src="../Images/afcbd6bbe017ca3b86d0b160b4afe0ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tf3IndTQDvkav15w0oRnDA.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">您必须在macOS系统偏好设置中启用键盘导航选项，此功能才能工作</p></figure><p id="1a8e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你点击onPasteCommand 的官方文档中的链接<a class="ae li" href="https://developer.apple.com/documentation/swiftui/text/onpastecommand(of:perform:)-6gha3" rel="noopener ugc nofollow" target="_blank">，你会注意到其中完全没有提到对焦系统。那么什么是焦点系统呢？SwiftUI的聚焦指南</a>很好地解释了这一点，所以我只总结一下与这个修饰符相关的重要部分。如上面截图的左窗口所示，<strong class="ll je"> focus需要macOS上的系统偏好设置中的设置，该设置允许您使用标签按钮</strong>在可聚焦的项目之间导航。</p><p id="224f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在您已经启用了它，我的代码示例应该可以工作了。</p><p id="d336" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">本质上，我们在顶部有一个<code class="fe oi oj ok nb b">Text</code>，当应用程序运行时，它会自动获得焦点。假设您在系统偏好设置&gt;常规中选择了默认的“多色”强调色，您会注意到它被蓝色轮廓包围。如果您选择了不同的强调颜色，则<code class="fe oi oj ok nb b">Text</code>将以该颜色显示。现在，当您从菜单栏中选择Edit &gt; Copy，或者按下等效的cmd+C组合键时，我们运行一个闭包来复制到剪贴板。</p><p id="50fe" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这对于使用<code class="fe oi oj ok nb b">onPasteCommand</code>并不是绝对必要的，但是这是控制粘贴板中数据的统一类型标识符的一种更简单的方法。2020年的<code class="fe oi oj ok nb b">onPasteCommand</code>与2019年的原版的主要区别在于<code class="fe oi oj ok nb b">UTType</code>结构的存在。2019年，闭包将接受的类型以类似“public.utf8-plain-text”的字符串形式给出。</p><p id="f41f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这使得在键入字符串时出现人为错误的可能性很高，并且也不容易找到什么字符串适用于您想要的类型。</p><p id="09c4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">有了<code class="fe oi oj ok nb b">UTType</code>结构，我们有了大量的常量，这些常量可能涵盖了你可能想要粘贴的任何内容。您也可以遵循<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/uniformtypeidentifiers/uttypecontent" rel="noopener ugc nofollow" target="_blank">UTTypeContent</a></code>和/或<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/uniformtypeidentifiers/uttypedata" rel="noopener ugc nofollow" target="_blank">UTTypeData</a></code>协议来创建自己的协议。如果您想看的话，我已经包含了一个常量，它显示了所有提供的数据类型的数组。在<code class="fe oi oj ok nb b">onCopyCommand</code>闭包中，您可能会注意到我们正在将想要复制的字符串转换为<code class="fe oi oj ok nb b">NSString</code>。</p><p id="744c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">以下是符合<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/foundation/nsitemproviderwriting" rel="noopener ugc nofollow" target="_blank">NSItemProviderWriting</a></code>的类型列表，因此可以用<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/foundation/nsitemprovider" rel="noopener ugc nofollow" target="_blank">NSItemProvider</a></code>粘贴:</p><ul class=""><li id="c1b5" class="mf mg iu ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/contacts/cncontact" rel="noopener ugc nofollow" target="_blank">CNContact</a></code></li><li id="0ea6" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/contacts/cnmutablecontact" rel="noopener ugc nofollow" target="_blank">CNMutableContact</a></code></li><li id="fed0" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/corespotlight/cslocalizedstring" rel="noopener ugc nofollow" target="_blank">CSLocalizedString</a></code></li><li id="41ea" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/mapkit/mkmapitem" rel="noopener ugc nofollow" target="_blank">MKMapItem</a></code></li><li id="d3c1" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/foundation/nsattributedstring" rel="noopener ugc nofollow" target="_blank">NSAttributedString</a></code></li><li id="0c1e" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/foundation/nsmutablestring" rel="noopener ugc nofollow" target="_blank">NSMutableString</a></code></li><li id="30ee" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/foundation/nsstring" rel="noopener ugc nofollow" target="_blank">NSString</a></code></li><li id="297b" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/uikit/nstextstorage" rel="noopener ugc nofollow" target="_blank">NSTextStorage</a></code></li><li id="1f78" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/foundation/nsurl" rel="noopener ugc nofollow" target="_blank">NSURL</a></code></li><li id="0b9c" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/foundation/nsuseractivity" rel="noopener ugc nofollow" target="_blank">NSUserActivity</a></code></li><li id="41e4" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/uikit/uicolor" rel="noopener ugc nofollow" target="_blank">UIColor</a></code></li><li id="8e6f" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/uikit/uiimage" rel="noopener ugc nofollow" target="_blank">UIImage</a></code></li></ul><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="9683" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当第一个文本有焦点时，一旦你复制了，你可以按tab键将焦点循环到下一个<code class="fe oi oj ok nb b">Text</code>。当这个<code class="fe oi oj ok nb b">Text</code>被突出显示时，粘贴运行<code class="fe oi oj ok nb b">onPasteCommand</code>闭包，它接收一个<code class="fe oi oj ok nb b">NSItemProvider</code>实例的数组。要将最新条目的数据转换回字符串，我们首先需要加载条目的数据表示，并将其转换成字符串。然后我们使用一个绑定到下面的<code class="fe oi oj ok nb b">Text</code>显示的字符串，这样我们可以立即看到操作是成功的。</p><p id="dd23" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我还包括了一个<code class="fe oi oj ok nb b">PasteButton</code>的例子，这样你就可以看到<code class="fe oi oj ok nb b">onPasteCommand</code>是多么的相似。</p><p id="d4a2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">闭包采用完全相同的UTType实例数组，尽管参数被标记为<code class="fe oi oj ok nb b">supportedContentTypes</code>。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="1470" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。翁德拉格和。onDrop(在2.0中更新)</h1><p id="3f4f" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">下面的两个视图互不了解。它们不共享一个可观测的对象。最上面的一个不会传递一个<code class="fe oi oj ok nb b">Binding&lt;String&gt;</code>给最下面的一个，也不会传递一个常量给它的初始化器。它们之间唯一的联系是顶部应用了一个提供<code class="fe oi oj ok nb b">UTType.utf8PlainText</code>种类数据的<code class="fe oi oj ok nb b">.onDrag</code>修饰符，底部应用了一个期望<code class="fe oi oj ok nb b">UTType.utf8PlainText</code>的<code class="fe oi oj ok nb b">.onDrop</code>修饰符。</p><p id="83a4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">有关UTType的更多信息，请参见上面的<code class="fe oi oj ok nb b">.onPasteCommand</code>。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pm"><img src="../Images/a3372cb19ff7018f39bc184b09a47f30.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/1*OJqWniJPHaKW_1zX1g7hug.gif"/></div></figure><p id="7a3a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">TextField</code>用于生成一个字符串，这个字符串是唯一的，只有一个视图知道。一旦生成，它将显示为带有圆角的橙色矩形。这个橙色的形状被赋予了一个<code class="fe oi oj ok nb b">.onDrag</code>修饰符，该修饰符为底层数据提供了一个<code class="fe oi oj ok nb b">NSItemProvider</code>，该数据已经被转换为<code class="fe oi oj ok nb b">NSString</code>，因为这个类符合<code class="fe oi oj ok nb b">NSItemProviderWriting</code>协议。</p><p id="b5b7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">提供某种类型的<code class="fe oi oj ok nb b">NSItemProvider</code>是你的视图变得可拖动所需要做的，但是你必须有一个地方放下它以便拖动是有用的。</p><p id="7530" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这就是<code class="fe oi oj ok nb b">.onDrop</code>的用武之地。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="d5a5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在<code class="fe oi oj ok nb b">DragView</code>中，我们有一个类似的<code class="fe oi oj ok nb b">TextWithBackground</code>，由于它有一个清晰的背景并且没有文本，所以最初被隐藏了。</p><p id="0d67" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">与<code class="fe oi oj ok nb b">.onDrag</code>不同，<code class="fe oi oj ok nb b">.onDrop</code>需要一个符合DropDelegate协议的委托。与某些委托类型不同，DropDelegate可以是一个结构，而不必是一个类。这个协议唯一的强制性要求是它有一个名为<code class="fe oi oj ok nb b">performDrop</code>的函数，这个函数确实像它听起来的那样。您尝试读取数据，如果成功，则返回true以确认发生了拖动。如果任何一点有错误，就返回false。</p><p id="de84" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是我的代码中唯一稍微复杂的部分，但是它与上面的<code class="fe oi oj ok nb b">PasteButton</code>和<code class="fe oi oj ok nb b">.onPasteCommand</code>中使用的代码有很多相似之处。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="b6af" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。onChange(2.0中的新功能)</h1><p id="6156" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">SwiftUI最初版本的一个恼人之处是缺少<a class="ae li" href="https://www.hackingwithswift.com/sixty/7/3/property-observers" rel="noopener ugc nofollow" target="_blank">属性观察者</a>。使用类似于<code class="fe oi oj ok nb b">didSet</code>的东西的唯一方法是在<code class="fe oi oj ok nb b">ObservableObject</code>类中使用它，它允许您在每次属性值改变时运行闭包。由于这些是常规的Swift类，它们不能使用<a class="ae li" href="https://www.hackingwithswift.com/books/ios-swiftui/why-state-only-works-with-structs" rel="noopener ugc nofollow" target="_blank"/><code class="fe oi oj ok nb b"><a class="ae li" href="https://www.hackingwithswift.com/books/ios-swiftui/why-state-only-works-with-structs" rel="noopener ugc nofollow" target="_blank">@State</a></code><a class="ae li" href="https://www.hackingwithswift.com/books/ios-swiftui/why-state-only-works-with-structs" rel="noopener ugc nofollow" target="_blank">属性包装器，该包装器只对结构</a>有效。但是他们可以像我们期望的那样使用属性观察器，甚至可以在标记为<code class="fe oi oj ok nb b">@Published</code>的属性上使用，因此可以从SwiftUI访问。</p><p id="19bb" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">因为结构是值类型，而<code class="fe oi oj ok nb b">self</code>是不可变的，所以当发生变化时，结构需要完全重新创建。在<code class="fe oi oj ok nb b">@State</code>的情况下，属性已经被观察到。对该属性的更改会导致结构被完全重新创建，因为它不能被改变。</p><p id="4246" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">引用 <code class="fe oi oj ok nb b"><a class="ae li" href="https://www.hackingwithswift.com/books/ios-swiftui/why-state-only-works-with-structs" rel="noopener ugc nofollow" target="_blank">@State</a></code> <a class="ae li" href="https://www.hackingwithswift.com/books/ios-swiftui/why-state-only-works-with-structs" rel="noopener ugc nofollow" target="_blank">属性包装器</a>的官方文档:</p><blockquote class="ol om on"><p id="412c" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated">一个<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/state" rel="noopener ugc nofollow" target="_blank">State</a></code>实例不是值本身；这是一种读写值的方法。要访问一个状态的底层值，使用它的变量名，这将返回<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/state/wrappedvalue" rel="noopener ugc nofollow" target="_blank">wrappedValue</a></code>属性值。</p></blockquote><p id="e8b0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">因此，你的结构中的属性实际上并不是你所认为的值——它是一个包装器，实际上把它保存在一个完全独立和不可见的结构中。这就是为什么包装器的文档将它声明为<code class="fe oi oj ok nb b">@propertyWrapper struct State&lt;Value&gt;</code>，因为它不仅修改了属性的行为，还将它存储在其他地方。这就是为什么试图使用<code class="fe oi oj ok nb b">didSet</code>属性观察者不起作用的原因:属性包装器的实例永远不会改变，只有它的wrappedValue属性会改变。</p><p id="66f3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">那么我们如何在这些变化的基础上做任何事情呢？</p><p id="2c4d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在SwiftUI存在的第一年，在<code class="fe oi oj ok nb b">ObservableObject</code>中使用属性包装器几乎是唯一的方法。在2020年，我们有一个新的修饰符叫做<code class="fe oi oj ok nb b">.onChange</code>，当<code class="fe oi oj ok nb b">@State</code>属性的值改变时，它允许你的结构中的任何视图运行闭包。如果一个<code class="fe oi oj ok nb b">TextField</code>有一个<code class="fe oi oj ok nb b">Binding&lt;String&gt;</code>，当字符串改变时，它可以使用修饰符来运行代码。但是观察变化的视图不需要直接的<code class="fe oi oj ok nb b">Binding</code>来对变化作出反应，并且布局的另一部分中的<code class="fe oi oj ok nb b">Button</code>的<code class="fe oi oj ok nb b">.onChange</code>修饰符不会或多或少地使用这种能力。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="d2b9" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">为了让事情变得更有趣，我的例子使用了一个<code class="fe oi oj ok nb b">Binding</code>而不是一个<code class="fe oi oj ok nb b">State</code>作为属性供<code class="fe oi oj ok nb b">onChange</code>观察。<code class="fe oi oj ok nb b">.onChange</code>观察的值实际上可以是任何符合<code class="fe oi oj ok nb b">Equatable</code>的类型。为了更好地了解Equatable影响SwiftUI视图的所有方式，请查看SwiftUI实验室关于EquatableView的教程。注意不包含<code class="fe oi oj ok nb b">.onChange</code>修饰符的<code class="fe oi oj ok nb b">ContentView</code>仍然受到其子<code class="fe oi oj ok nb b">OnChangeView</code>修饰符中逻辑的影响。</p><p id="3d26" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">例如，<code class="fe oi oj ok nb b">ContentView</code>中的<code class="fe oi oj ok nb b">TextField</code>在<code class="fe oi oj ok nb b">OnChangeView</code>中的<code class="fe oi oj ok nb b">Toggle</code>关闭时被清空，尽管它没有<code class="fe oi oj ok nb b">Binding</code>来控制或者甚至不知道它的存在。</p><p id="82dd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这可能是这个新修改器最强大的功能之一，因为它允许层次结构中任何地方的视图判断情况，并要求其他地方的视图也应该根据它所关心的属性重新绘制。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="5b40" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。键盘快捷方式(2.0中的新功能)</h1><p id="2f6a" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">引用苹果公司的文档。键盘快捷键:</p><blockquote class="ol om on"><p id="7948" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated">当控件位于最前面的窗口或场景中的任何位置，或者位于macOS主菜单中的任何位置时，按下控件的快捷键相当于与控件直接交互以执行其主要操作。</p></blockquote><p id="a94e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">下面是两个<code class="fe oi oj ok nb b">Button</code>和相关键盘快捷键的例子。第一个按钮的键是<code class="fe oi oj ok nb b">.upArrow</code>，但是没有指定修饰符。你可能认为这意味着按下向上箭头将执行<code class="fe oi oj ok nb b">Button</code>的动作，但那将是错误的。命令按钮是默认的修饰键，所以这个<code class="fe oi oj ok nb b">Button</code>实际上需要按下Cmd + Up组合键。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="da67" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">第二个按钮确实显式地声明了一个修饰符，允许它使用shift键而不是command。如果你读过上面的<code class="fe oi oj ok nb b">onPasteCommand</code>修饰符，你会发现在macOS上有一个系统偏好选项，可以用tab键在可聚焦的项目中导航。如果启用该选项，您会发现默认情况下顶部的<code class="fe oi oj ok nb b">Button</code>会高亮显示。Tab将焦点移到第二个按钮，Shift + Tab将焦点移回第一个按钮。</p><p id="160d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">无论哪个<code class="fe oi oj ok nb b">Button</code>被聚焦，你设置的键盘快捷键依然有效。</p><p id="0c7a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这也许是这些快捷键最有用的方面，因为尽管空格键将执行当前聚焦的<code class="fe oi oj ok nb b">Button</code>的功能，它们仍然继续工作。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="1f71" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。focusedValue和@ focused binding(2.0中的新功能)</h1><p id="c8e3" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">这是一种在视图之间传递数据的新方法。我们没有使用<code class="fe oi oj ok nb b">ObservableObject</code>，而是使用<code class="fe oi oj ok nb b">FocusedValueKey</code>来保存数据。</p><p id="ddc3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在下面的例子中，<code class="fe oi oj ok nb b">DisplayTextView</code>能够显示您输入到<code class="fe oi oj ok nb b">TextFieldView</code>中的文本，尽管绑定&lt;字符串&gt;或字符串常量没有在视图之间传递。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="5d4c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这里的神奇之处在于底部的结构和扩展。</p><p id="189c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">FocusedValueKey</code>协议要求一致性结构对于它们存储的值有一个<code class="fe oi oj ok nb b">typealias</code>。</p><p id="d19d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">一旦有了为键定义了<code class="fe oi oj ok nb b">typealias</code>的结构，就需要为该值定义一个getter和setter。这个对<code class="fe oi oj ok nb b">FocusedValue</code>的扩展将<code class="fe oi oj ok nb b">\.text</code>定义为我们将用来读写值的键。注意，getter和setter都使用<code class="fe oi oj ok nb b">FocusedTextKey</code>类型作为<code class="fe oi oj ok nb b">FocusedValues</code>的下标。现在我们只需要在<code class="fe oi oj ok nb b">TextFieldView</code>中写一个值给key，然后我们需要在<code class="fe oi oj ok nb b">DisplayTextView</code>中从中读取。</p><p id="c958" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">TextField</code>上的<code class="fe oi oj ok nb b">.focusedValue(\.text, $text)</code>修改器将值保存到键中。</p><p id="731c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">DisplayTextView</code>中的<code class="fe oi oj ok nb b">@FocusedBinding(\.text) var text: String?</code>属性为其订阅相关值的变化。请注意，它是可选的，因为不必设置该值。正如苹果官方文档所说，“与<code class="fe oi oj ok nb b">EnvironmentKey</code>不同，<code class="fe oi oj ok nb b">FocusedValuesHostKey</code>没有默认值要求，因为一个键的默认值始终是<code class="fe oi oj ok nb b">nil</code>。”我假设最初的名字是<code class="fe oi oj ok nb b">FocusedValuesHostKey</code>，因为文档中仍然提到了它，尽管它已经不存在了。</p><p id="d77e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">换句话说，你可以设置一个键，而不用给它一个值，你的代码仍然会运行。</p><p id="a8d9" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当你设置一个值时，你需要像我一样使用nil合并操作符来展开它。?'。</p><p id="3051" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你可能会问的下一个问题是为什么需要这些值。毕竟，它们似乎是全球性的，至少在单一窗口的背景下是如此。我们不希望将所有数据都放在这个范围内，拥有大量数据可能会使调试变得困难。<a class="ae li" href="https://developer.apple.com/forums/thread/651748" rel="noopener ugc nofollow" target="_blank">苹果开发者论坛上的一个更复杂的例子展示了一个有趣的用例。当Mac应用程序有单独的命令时，例如本例中的Shift、Cmd + D，您可能仍然希望访问应用程序中的数据，尽管这些命令在<code class="fe oi oj ok nb b">WindowGroup</code>范围内。</a></p><p id="6f2f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在你可以了！</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="a82b" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。首选DefaultFocus和。聚焦镜(2.0中的新功能)</h1><p id="a5db" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">在tvOS 14和watchOS 7上，我们现在有能力声明默认情况下我们想要聚焦的用户界面元素。在tvOS上，这很重要，因为按下Siri遥控器的触摸表面会执行带有焦点的<code class="fe oi oj ok nb b">Button</code>的动作。在watchOS上，聚焦元素通过移动数字表冠来控制。</p><p id="e60f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在<code class="fe oi oj ok nb b">VStack</code>中，默认情况下俯视图总是会获得焦点，除非我们采取措施防止这种行为。</p><p id="e297" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">为此，我们需要定义可以覆盖焦点系统的范围。声明一个焦点范围需要一个<code class="fe oi oj ok nb b">@Namespace</code>，这个主题在上面的<code class="fe oi oj ok nb b">.matchedGeometryEffect</code>部分有更多的细节。重要的是我用我的财产给了一个<code class="fe oi oj ok nb b">Namespace.ID</code>，我也叫它<code class="fe oi oj ok nb b">namespace</code>。我将它传递给了VStack上的<code class="fe oi oj ok nb b">.focusScope</code>修改器，现在我们有了自己的作用域。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="4b59" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我需要做的另一件事是在底部的<code class="fe oi oj ok nb b">Button</code>上使用<code class="fe oi oj ok nb b">.prefersDefaultFocus</code>修饰符，传递给它名称空间。</p><p id="4441" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在底部的<code class="fe oi oj ok nb b">Button</code>将被默认聚焦，尽管它不在<code class="fe oi oj ok nb b">VStack</code>的顶部。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="08cf" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。全屏覆盖(2.0中的新功能)</h1><p id="224c" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">与<code class="fe oi oj ok nb b">.sheet</code>不同的是，<code class="fe oi oj ok nb b">.fullScreenCover</code>修改器呈现一个覆盖整个屏幕的模态视图，你可能不会对此感到惊讶。我举了一个例子，它允许你无限地创建表单和全屏封面，因为这向你展示了关于它们如何工作的重要信息。可以滑动表单来消除它，但全屏幕封面不能。一个视图可以允许两种模态，并且模态本身在任何一种情况下都可以是相同的。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="dcca" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我已经在模态中提供了<code class="fe oi oj ok nb b">@Environment(\.presentationMode)</code>属性，由于没有滑动解除，全屏盖无法解除。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="b221" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。defaultAppStorage(2.0中的新功能)</h1><p id="0737" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">这个修饰符<code class="fe oi oj ok nb b">.defaultAppStorage</code>改变了整个视图的<code class="fe oi oj ok nb b">@AppStorage</code>属性保存到什么<code class="fe oi oj ok nb b">UserDefaults</code>。如果你不熟悉<code class="fe oi oj ok nb b">@AppStorage</code>或<code class="fe oi oj ok nb b">UserDefaults</code>，这是一种保存简单信息的方式，在用户退出应用程序后仍然存在。<code class="fe oi oj ok nb b">@AppStorage</code>属性包装器将不会在这里具体介绍，但它将作为我的文档的修订版的状态和数据流章节的一部分介绍。</p><p id="2d19" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">引用Axel Kee的帖子<a class="ae li" href="https://fluffy.es/persist-data/" rel="noopener ugc nofollow" target="_blank">何时使用用户默认值、钥匙串或核心数据</a>:</p><blockquote class="ol om on"><p id="4098" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated">之前，我们已经解释过UserDefaults将数据保存到plist中。使用<a class="ae li" href="https://macroplant.com/iexplorer" rel="noopener ugc nofollow" target="_blank"> iExplorer </a>等应用程序，用户可以访问他们iPhone的Library/Preferences文件夹，并轻松读取/修改UserDefaults plist数据(例如:将“boughtProVersion”的布尔值从false更改为true，或者更改硬币的数量)。<strong class="ll je">永远不要在UserDefaults </strong>中存储用于检查用户是否购买了应用内购买的布尔值！用户可以很容易地改变它(无需越狱)，并免费获得你的好东西！😬</p><p id="e11d" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated">除了应用内购买状态之外，出于同样的原因，您也不应该在UserDefaults中存储用户密码/ API密钥。</p></blockquote><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="faa0" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。app store overlay(2.0中的新功能)</h1><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ow"><img src="../Images/569bc6c5ea09128139572e0f4a620e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NENzvb1-PqqsCfoB8m0NDQ.jpeg"/></div></div></figure><p id="edc2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">为了推荐一个自己或者别人做的app，需要知道10位的App ID。如果你拥有该应用，这相对容易，因为你会在App Store Connect的应用信息部分找到它。然而，如果你不知道一个应用程序的应用程序ID，请前往<a class="ae li" href="https://linkmaker.itunes.apple.com/en-gb" rel="noopener ugc nofollow" target="_blank"> iTunes Link Maker </a>并搜索它，确保将媒体类型更改为Apps，这样你就不会只是获得一堆音乐。无论你选择什么应用程序，都会给你一个直接链接，链接以一个数字结尾，后面跟着一个查询。</p><p id="765e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">10位数代码位于字母“id”和问号“？”之间。</p><p id="b383" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">例如，苹果开发者应用有链接:<br/><a class="ae li" href="https://apps.apple.com/us/app/apple-developer/id640199958?mt=8" rel="noopener ugc nofollow" target="_blank">https://apps.apple.com/us/app/apple-developer/id<strong class="ll je">640199958</strong>？mt=8 </a></p><p id="70ce" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">因此App ID为<strong class="ll je"> 640199958。</strong></p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="5506" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在这一节的开始有一个我的例子的截图。我添加了一个<code class="fe oi oj ok nb b">TextField</code>，您可以在其中键入或粘贴应用ID，一个<code class="fe oi oj ok nb b">Button</code>用于切换应用商店覆盖图的外观，还有一个切换按钮用于更改位置。</p><p id="e33d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">一个应用商店覆盖只有两个位置:<code class="fe oi oj ok nb b">.bottom</code>和<code class="fe oi oj ok nb b">.bottomRaised</code>，因此这个开关的名字叫做“凸起”。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="afd7" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。工具栏(2.0中的新功能)</h1><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="9937" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">使用<code class="fe oi oj ok nb b">ToolBarItem</code>可以在所有平台上轻松创建工具栏。这些可以是<code class="fe oi oj ok nb b">Button</code>或任何视图。</p><p id="4706" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">就放置ToolBarItem而言，有许多选项。</p><p id="c128" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我将引用Majid的精彩帖子<a class="ae li" href="https://swiftwithmajid.com/2020/07/15/mastering-toolbars-in-swiftui/" rel="noopener ugc nofollow" target="_blank">在SwiftUI </a>中掌握工具栏，而不是重述他所说的话:</p><blockquote class="ol om on"><p id="bb79" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated"><em class="iu">自动</em> —该项目被放置在默认部分，根据当前平台的不同而不同。</p><p id="ac05" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated"><em class="iu">主要操作</em> —该项目代表一个主要操作。通常情况下，SwiftUI会将这个项目放在iOS上的导航栏中，或者放在watchOS上其他视图的顶部。</p><p id="0800" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated">有一些放置选项，我们只能在模态视图显示的工具栏中使用。</p><p id="f1df" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated"><em class="iu"> confirmationAction </em> —该项表示一个模态接口的确认动作。您可以在工作表中使用它来确认保存操作。</p><p id="d464" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated"><em class="iu"> cancellationAction </em> —该项表示一个模态接口的取消操作。</p><p id="c8a8" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated"><em class="iu"> destructiveAction </em> —该项表示一个模态接口的破坏性操作。您可以在删除一些数据的模态屏幕中使用它。</p><p id="6b71" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated">还有许多特定于平台的放置选项。</p><p id="5ec1" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated"><em class="iu">底部工具栏</em> —该项目被放置在底部工具栏中。它仅在iOS上可用。</p><p id="f7e3" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated"><em class="iu">导航栏前导</em> —该项目被放置在导航栏的前导区域。仅在iOS和macOS上可用。</p><p id="002e" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated"><em class="iu">导航栏training</em>—该项目被放置在导航栏的尾部区域。仅在iOS和macOS上可用。</p></blockquote></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="4d25" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。预览上下文(2.0中的新功能)</h1><p id="8c13" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">当您想预览一个可以用新的WidgetKit框架制作的小部件时，您遇到了一个问题。可能适用于其他SwiftUI视图的预览在设备上显示全屏应用程序，或者如果您选择<code class="fe oi oj ok nb b">.previewLayout(.fixed(width: 300, height: 300))</code>，则显示自定义大小和形状。</p><p id="8b60" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们不再需要手动选择一个尺寸来匹配部件的外观，我们现在有了一个新的修改器，允许我们从部件的三个尺寸中进行选择。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pn"><img src="../Images/993b520043224a6f70306fa65ee6cd16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZmTzbsw-fUzZOz4Km_xmdg.png"/></div></div></figure><p id="83f7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">据我所知，这些是<code class="fe oi oj ok nb b">.previewContext</code>的唯一选择:</p><ul class=""><li id="9bae" class="mf mg iu ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated"><code class="fe oi oj ok nb b">.previewContext(WidgetPreviewContext(family: .systemSmall))</code></li><li id="8f6f" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b">.previewContext(WidgetPreviewContext(family: .systemMedium))</code></li><li id="df14" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b">.previewContext(WidgetPreviewContext(family: .systemLarge))</code></li></ul><p id="3c6b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如你所见，我们需要初始化<code class="fe oi oj ok nb b">WidgetPreviewContext</code>，这符合<code class="fe oi oj ok nb b">PreviewContext</code>协议。我们传入一个<code class="fe oi oj ok nb b">WidgetFamily</code>枚举的实例，这提供了预览所需的配置。我决定用我的例子制作一个普通视图，而不是制作一个完整的小部件。我这样做是因为这需要更少的代码，同时也是为了表明previewContext可以适用于任何视图。</p><p id="b2e4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我制作了一个包含实际小部件的例子，如果你想看代码的话。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="7e6b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我上面的例子使用了一个<code class="fe oi oj ok nb b">Date</code>扩展来获取时间字符串。这没有太多的理由，但是在一个真正的小部件中，你需要在你的<code class="fe oi oj ok nb b">TimelineEntry</code>结构中有一个<code class="fe oi oj ok nb b">Date </code>对象。视图的其余部分使用环境变量<code class="fe oi oj ok nb b">\.widgetFamily</code>来访问我们传递给<code class="fe oi oj ok nb b">WidgetPreviewContext</code>的值。我可以根据这个值为<code class="fe oi oj ok nb b">backgroundColor</code>和<code class="fe oi oj ok nb b">text</code>使用计算出的属性，所以在每种情况下，视图最终完全不同。</p><p id="bc02" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当我在Xcode 12 beta 2上尝试时，我无法在body属性中使用switch语句。当我这样做时，即使我在switch语句的每种情况下都有基于计算属性的相同视图，我也会得到每个预览的“中等”颜色和文本，即使它们都显示为不同大小的小部件。当你读到这篇文章时，这个问题可能已经解决了。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ov ot l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">在我发现PreviewContext的用途之前，我已经指出在文档中很少能找到有用的信息，我仍然不知道它是如何工作的</p></figure><p id="33ac" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你想自己做<code class="fe oi oj ok nb b">PreviewContext</code>呢？我尽了最大努力，但由于苹果<code class="fe oi oj ok nb b">WidgetPreviewContext</code>实现的不可访问性，这有点困难。该协议要求您允许来自符合<code class="fe oi oj ok nb b">PreviewContextKey</code>的结构实例的下标，并且您返回一个与该键结构中的<code class="fe oi oj ok nb b">typealias</code>匹配的值。该类型实际上可以是任何类型，因为它没有任何类型的协议要求或限制。</p><p id="3454" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当我试图制作自己的PreviewContext时，我希望能够将小部件做得太大。小部件有一个最大尺寸，所以我认为尝试将它们显示得比以前更大会很有趣。为此，我使用了一个enum，就像<code class="fe oi oj ok nb b">WidgetFamily</code>一样。枚举有一个名为<code class="fe oi oj ok nb b">size</code>的计算属性，这将用于定义我的小部件预览的大小。不使用下标，我决定只做一个新版本的<code class="fe oi oj ok nb b">previewContext</code>修饰符。</p><p id="f3e5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">毕竟，我们无法知道最初的修改器实际上是如何工作的。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="55e2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我的自定义版本<code class="fe oi oj ok nb b">.previewContext</code>可以选择绑定传递给它的自定义值，将其转换为my <code class="fe oi oj ok nb b">LargePreviewContext</code>类型。当这成功时，我从存储在那里的自定义枚举案例中获取预览的大小，并返回具有该大小和形状的自定义预览的视图。如果可选绑定失败，我只需使用previewContext的常规版本。</p><p id="7921" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你可能会注意到，我底部的<code class="fe oi oj ok nb b">PreviewProvider</code>同时使用了两种<code class="fe oi oj ok nb b">previewContext</code>。使用系统版本，我的自定义<code class="fe oi oj ok nb b">PreviewContext</code>完全被忽略。使用我的自定义版本，它是成功的。这是我试图复制这些协议的基本原理。苹果可能没有在这些结构中存储任何尺寸信息，因为访问内部的<code class="fe oi oj ok nb b">WidgetFamily</code> enum case可能会为系统提供足够的信息来提供来自其他地方的尺寸。</p><p id="3178" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然而，它在表面下工作，<code class="fe oi oj ok nb b">.previewContext</code>是一个神秘的新功能，可能会导致未来更多的定制预览的方式。</p><p id="f05f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你想出了更好的方法来利用它，让我知道！</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="1a89" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。用户活动和。onContinueUserActivity(2.0中的新功能)</h1><p id="4429" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">既然我们可以让<a class="ae li" href="https://medium.com/better-programming/swiftuis-new-app-lifecycle-and-replacements-for-appdelegate-and-scenedelegate-in-ios-14-c9cf4a2367a9" rel="noopener">在没有应用委托</a>的情况下制作SwiftUI应用，我们需要能够添加通常会有的功能。也就是说，假设我们没有采取步骤<a class="ae li" href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-add-an-appdelegate-to-a-swiftui-app" rel="noopener ugc nofollow" target="_blank">向SwiftUI应用</a>添加应用委托。<code class="fe oi oj ok nb b">.onOpenURL</code>修饰符是另一个闭包的例子，它在应用程序恢复时采取行动。</p><p id="40c3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我发现<code class="fe oi oj ok nb b">.onContinueUserActivity</code>的主要用途是从Spotlight搜索中打开应用程序。下面的示例创建了一个显示10个UUIDs的列表。这些唯一标识符将用于在每个项目变得可搜索时识别它们。当应用程序启动时，UUIDs被生成并保存到<code class="fe oi oj ok nb b">UserDefaults</code>。</p><p id="3bfe" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">仅当点击<code class="fe oi oj ok nb b">List</code>中的<code class="fe oi oj ok nb b">Button</code>时，UUID才会被索引，创建一个<code class="fe oi oj ok nb b">CSSearchableItem</code>并为其分配一个<code class="fe oi oj ok nb b">CSSearchableIndex</code>。</p><p id="ab8e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果此功能打印“保存成功”，则您选择的UUID已被编入索引。</p><p id="e895" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我发现很难让我的UUIDs出现在搜索中，但这可能是因为我没有添加搜索词。为此，使用您的<code class="fe oi oj ok nb b">CSSearchableItemAttributeSet</code>的<code class="fe oi oj ok nb b">keywords</code>属性，它只是一个可选的字符串数组。尽管没有这样做，我还是通过搜索我的应用程序的名称找到了我的UUIDs。虽然应用程序本身会出现，但您也会看到一个在应用程序内搜索的选项，显示为搜索结果，您的应用程序名称旁边有一个放大镜图标。</p><p id="c0b7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">点击这个应该可以调出你已经索引的UUIDs。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="5a99" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当你点击一个已被索引的项目时，应用程序将会打开。如果没有应用程序委托，我们如何知道当它出现时该做什么？<code class="fe oi oj ok nb b">.onContinueUserActivity</code>修饰符就是这么做的，它给出了一个函数，当任何搜索活动打开应用程序时，这个函数就会运行。但是我不需要传递函数，因为我可以很容易地使用尾随闭包来代替。重要的是我可以选择绑定商品的ID，这样我就可以确定我有一个UUID。</p><p id="534f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我将UUID设置为一个<code class="fe oi oj ok nb b">State</code>属性，并呈现一个显示该数据的警报供您查看。UUID应该与您在搜索中选择的项目描述相匹配。</p><p id="da4c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我提供了一个空的<code class="fe oi oj ok nb b">.onContinueUserActivity</code>版本的实现，用一个字符串代替<code class="fe oi oj ok nb b">activityType</code>，尽管我无法让它工作。</p><p id="6a66" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oi oj ok nb b">.userActivity</code>修改器“广告”一个<code class="fe oi oj ok nb b">NSUserActivity.</code>你可以看到当UUID改变时这个更新。在我的例子中，我发现在这里打印更改之前有大约30秒的长时间延迟。这是当你的活动，无论是什么，将可用于移交，如果实现的话。</p><p id="eb87" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在任何情况下，了解这些修饰词的重要一点是，它们与非连续性、移交和聚光灯搜索相关。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="062a" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。tabItem(在2.0中更新)</h1><p id="71ae" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">这个就不多说了，我就贴个苹果的例子，在顶部加个<code class="fe oi oj ok nb b">@available</code>属性。</p><p id="696b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">注意到什么了吗？</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="c92a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">对于WatchOS来说，<code class="fe oi oj ok nb b">TabView</code>以及允许您在标签栏上创建代表该页面的图标的修饰符<code class="fe oi oj ok nb b">.tabItem</code>都是新的。虽然它去年在Mac、iOS、iPadOS和tvOS上可用，但它今年才刚刚出现在手表上。你可能会问，它可能采取什么形式？它类似于UIKit的<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/uikit/uipageviewcontroller" rel="noopener ugc nofollow" target="_blank">UIPageViewController</a></code>,每一页都要求你从一页水平滑动到另一页。虽然<code class="fe oi oj ok nb b">.tabItem</code>修饰符存在，但是苹果示例中的<code class="fe oi oj ok nb b">Text</code>和<code class="fe oi oj ok nb b">Image</code>都是不可见的。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj po"><img src="../Images/f87b1c59e2e90c981de30ab736cc4b31.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/1*qcwPtFt4fUOZDGvC21BZ3w.gif"/></div></figure><p id="aa21" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">相反，我们得到的是点，这与<code class="fe oi oj ok nb b">UIPageViewController</code>利用<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/uikit/uipagecontrol" rel="noopener ugc nofollow" target="_blank">UIPageControl</a></code>的方式非常相似，苹果将其描述为“一系列水平的点，每个点对应于应用程序文档或其他数据模型实体中的一个页面。”</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="fbb3" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。上下文菜单(在2.0中更新)</h1><p id="143a" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">和上面的<code class="fe oi oj ok nb b">.tabItem</code>一样，<code class="fe oi oj ok nb b">.contextMenu</code>去年是新的，但今年已经来到了一个新的平台，和上面的<code class="fe oi oj ok nb b">.tabItem</code>一样，我使用了苹果的一个例子。这一次我付出了更多的努力，因为为tvOS改编他们的例子实际上需要制作<code class="fe oi oj ok nb b">Text</code>和<code class="fe oi oj ok nb b">.focusable</code>，这在这篇文章的前面有详细的介绍。一旦视图可以成为屏幕上的焦点元素，它也可以接收长按手势。如果它有一个<code class="fe oi oj ok nb b">.contextMenu </code>修饰符，这将显示您提供给它的选项列表。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pp"><img src="../Images/3f85173dd7df936f7f1c1ae6ceec92d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*4zt1pgMWLtEL5YA2XQ0MDw.gif"/></div></div></figure><p id="f089" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">事实上，我能够使用一个<code class="fe oi oj ok nb b">Text</code>意味着你不需要一个<code class="fe oi oj ok nb b">Button</code>来做到这一点，但是正如我所说的，你使用的视图必须使用<code class="fe oi oj ok nb b">.focusable()</code>修饰符才能工作。</p><p id="85e8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我是这样做的。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="db72" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。导航标题和。导航子标题(2.0中的新功能)</h1><p id="d184" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">这次我做不出比苹果官方文档更好的了:</p><blockquote class="ol om on"><p id="d7bb" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated">视图的导航标题用于直观地显示界面的当前导航状态。在iOS和watchOS上，当在导航视图内部导航到某个视图时，该视图的标题会显示在导航栏中。在iPadOS上，主要目的地的导航标题在应用程序切换器中反映为窗口标题。类似地，在macOS上，主要目的地的标题被用作标题栏、窗口菜单和Mission Control中的窗口标题。</p></blockquote><p id="4d6e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是苹果官方的导航文档Subtitle :</p><blockquote class="ol om on"><p id="9a45" class="lj lk oo ll b lm ln ke lo lp lq kh lr op lt lu lv oq lx ly lz or mb mc md me in bi translated">视图的导航副标题用于在导航标题旁边提供额外的上下文信息。在macOS上，主要目的地的字幕与标题栏中的导航标题一起显示。</p></blockquote><p id="346a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我的例子用一个<code class="fe oi oj ok nb b">Picker</code>遍历了<code class="fe oi oj ok nb b">navigationBarTitleDisplayMode</code>的选项，所以你可以看到它们的样子。我把这个例子限制在iOS上，因为<code class="fe oi oj ok nb b">NavigationBarItem.TitleDisplayMode</code>选项与macOS兼容。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="d253" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。navigationViewStyle(在2.0中更新)</h1><p id="8bf3" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">WatchOS现在有能力使用<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/text/navigationviewstyle(_:)" rel="noopener ugc nofollow" target="_blank">.navigationViewStyle</a></code>，但似乎唯一提供的价值是<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/stacknavigationviewstyle" rel="noopener ugc nofollow" target="_blank">StackNavigationViewStyle</a></code>。任何平台上唯一的另一个选项是<code class="fe oi oj ok nb b"><a class="ae li" href="https://developer.apple.com/documentation/swiftui/doublecolumnnavigationviewstyle" rel="noopener ugc nofollow" target="_blank">DoubleColumnNavigationViewStyle</a></code>，你可以打赌这不会很快出现在WatchOS上！</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="2177" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">。navigationBarTitle(在2.0中已弃用)</h1><p id="5e98" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">事实上，macOS上没有导航栏，这也是更通用的<code class="fe oi oj ok nb b">.navigationTitle</code>正在取代<code class="fe oi oj ok nb b">.navigationBarTitle</code>的原因之一。并不是所有出现<code class="fe oi oj ok nb b">.navigationBarTitle</code>的文档页面都显示它已被弃用，但是<code class="fe oi oj ok nb b">Text</code>的页面显示它已被弃用。看起来可能会有错误，即使它应该被弃用，却没有被弃用。例如，它目前在Mac Catalyst 13.0上不被弃用，但如果它在iOS 13.0上被弃用，这似乎没有什么意义。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="3065" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated"><code class="fe oi oj ok nb b">.navigationBarItems (Deprecated in 2.0)</code></h1><p id="6bb2" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">要将<code class="fe oi oj ok nb b">Button</code>添加到导航栏的开头或结尾位置，请使用带有<code class="fe oi oj ok nb b">ToolbarItem(placement: .navigationBarLeading)</code>和/或<code class="fe oi oj ok nb b">ToolbarItem(placement: .navigationBarTrailing)</code>的工具栏。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="83f1" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">iOS、iPadOS、Mac Catalyst和tvOS上的样式(2.0中的新功能)</h1><p id="c032" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">这里有一个两者都用的例子。标签样式和。indexViewStyle是2020年的新功能，在macOS上不可用:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="f9d1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">以下是<code class="fe oi oj ok nb b">PageIndexViewStyle</code>的选项，这是目前唯一可以传给<code class="fe oi oj ok nb b">.indexViewStyle</code>的东西:</p><ul class=""><li id="2a9f" class="mf mg iu ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated"><code class="fe oi oj ok nb b">.automatic</code>:后台使用平台默认</li><li id="60ad" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b">.interactive</code>:只有在与索引视图交互时才显示背景</li><li id="c9ab" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b">.always</code>:背景总是显示在页面索引视图的后面</li><li id="e117" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><code class="fe oi oj ok nb b">.never</code>:页面索引视图后面不显示背景</li></ul></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="1b48" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">仅macOS上的样式(2.0中的新功能)</h1><p id="b270" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">我不能让他们工作，但他们在这里！这些样式与呈现的窗口有关，所以我只能假设它是你呈现在视图前面的窗口。<code class="fe oi oj ok nb b">.groupBoxStyle</code>修改器是新的，但是我们只能和<code class="fe oi oj ok nb b">DefaultGroupBoxStyle</code>一起使用，除非我们自己定制。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="os ot l"/></div></figure><p id="fb55" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这些的名字至少足够清楚，即使我不能给出一个可行的例子，你也能大致想象它们是做什么的。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="cc13" class="nm ng iu bd nn no np nq nr ns nt nu nv kj nw kk nx km ny kn nz kp oa kq ob oc bi translated">后续步骤</h1><p id="025c" class="pw-post-body-paragraph lj lk iu ll b lm od ke lo lp oe kh lr ls of lu lv lw og ly lz ma oh mc md me in bi translated">在我写这篇文章的时候，SwiftUI才一岁，而且已经有了大量的资源。如果没有以下网站，我的写作是不可能的:</p><ul class=""><li id="5a25" class="mf mg iu ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated"><a class="ae li" href="https://www.hackingwithswift.com" rel="noopener ugc nofollow" target="_blank">利用Swift进行黑客攻击</a></li><li id="4f21" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><a class="ae li" href="https://swiftui-lab.com" rel="noopener ugc nofollow" target="_blank"> Swift UI实验室</a></li><li id="f468" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><a class="ae li" href="https://swiftwithmajid.com" rel="noopener ugc nofollow" target="_blank">带Majid的Swift】</a></li><li id="2c11" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><a class="ae li" href="https://wwdcbysundell.com" rel="noopener ugc nofollow" target="_blank"> WWDC by Sundell </a></li><li id="05eb" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><a class="ae li" href="https://www.swiftbysundell.com" rel="noopener ugc nofollow" target="_blank">雨燕by Sundell </a></li><li id="9861" class="mf mg iu ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated"><a class="ae li" href="https://lostmoa.com/blog" rel="noopener ugc nofollow" target="_blank"> LOSTMOA博客</a></li></ul><p id="7ed3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你有很棒的资源可以与社区分享，请告诉我，我会很乐意把它添加到这个列表中。</p><p id="6b45" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">正如我在帖子开头所说的，如果你对某个主题有更详细的要求，或者如果你认为我犯了一个错误，请在下面的回复中告诉我。</p><p id="0aa5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">感谢阅读！</p></div></div>    
</body>
</html>