<html>
<head>
<title>How to Incrementally Migrate From Vue.js 2 to React 18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从Vue.js 2增量迁移到React 18</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-incrementally-migrate-from-vue-js-2-to-react-18-part-1-setup-be2cd04458f0?source=collection_archive---------0-----------------------#2022-08-31">https://betterprogramming.pub/how-to-incrementally-migrate-from-vue-js-2-to-react-18-part-1-setup-be2cd04458f0?source=collection_archive---------0-----------------------#2022-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="45df" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第1部分—设置</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c569f061e3d075a15e10f3a51a5a5e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kcgdlmbz6RSfbvQqlAisCg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/photos/5fNmWej4tAA" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="cddb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着<a class="ae kv" href="https://v2.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js 2 </a>将于2023年底寿终正寝，我相信大多数使用<a class="ae kv" href="https://v2.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js 2 </a>的工程师/开发者正在寻找其他选项的迁移路径。显而易见的选择是升级到<a class="ae kv" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js 3 </a>然而，由于该框架尚未被社区广泛采用，一些主要的库，如<a class="ae kv" href="https://v4.apollo.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue Apollo </a>已经在Alpha中使用了3年，还有一些库根本没有创建一个<a class="ae kv" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js 3 </a>兼容版本，所以您可能想要寻找一个使用更广泛的库；喜欢<a class="ae kv" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">反应</a>。</p><p id="48eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与所有迁移一样，它们可能是一项艰巨的任务，在我看来，开始迁移时有三个主要选项:</p><ol class=""><li id="b5d5" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">创建一个全新的绿地应用程序，并将流量路由到相关的应用程序。</li><li id="0045" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用微前端架构。使用像Webpack模块联合或Web组件这样的工具。</li><li id="e47e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">通过在可能的情况下挂载React，在现有应用程序中增量迁移组件。</li></ol><p id="acd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我相信大多数工程师会转向绿地应用，但是当您需要确保新功能和错误修复继续推出时，有时间专门将现有和新功能迁移到绿地应用，同时维护现有应用可能会成为影响客户和产品团队最后期限的问题。选项2增加了迁移的复杂性，并且有与选项1相似的缺点。</p><p id="abf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到这些，我将演示选项3——通过在可能的地方挂载React，在现有应用程序中增量地迁移组件。起初，这个想法听起来可能很糟糕，但是我相信，在本文结束时，您将会看到，这实际上是实现安全迁移的最低风险和最简单的选择，同时还能维护和添加新功能。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="abe4" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">步骤1:安装React并设置您的应用程序目录:</h1><p id="4a4d" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">首先在应用程序目录中安装React和React DOM</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="d9b6" class="np mo iq nl b gy nq nr l ns nt">npm i react react-dom</span></pre><p id="2579" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的<code class="fe nu nv nw nl b">src</code>目录中创建一个新文件夹。(我用<code class="fe nu nv nw nl b">react-migration</code>)。然后运行<code class="fe nu nv nw nl b">cd react-migration</code>和<code class="fe nu nv nw nl b">npm init</code>来创建一个新的package.json。最后，运行<code class="fe nu nv nw nl b">npm i @types/react -D</code>来添加React类型模块。</p><p id="c18c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要在这个目录下添加一个<code class="fe nu nv nw nl b">tsconfig.json</code>文件运行<code class="fe nu nv nw nl b">npx tsc --init</code>。打开新创建的<code class="fe nu nv nw nl b">tsconfig.json</code>文件:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="e10c" class="np mo iq nl b gy nq nr l ns nt">// Change<br/>"jsx": "preserve",<br/>// to<br/>"jsx": "react",</span></pre><p id="482a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你正在使用纱线或PNPM，然后相应地更新命令。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="993f" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">步骤2:创建您的第一个React组件</h1><p id="db43" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">对于本教程，我将创建一个超级基本的<code class="fe nu nv nw nl b">HelloWorld.tsx</code>组件，它需要一些道具来演示<code class="fe nu nv nw nl b">Vue</code>和<code class="fe nu nv nw nl b">React</code>之间的通信。<br/>组件设置如下:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="aa09" class="np mo iq nl b gy nq nr l ns nt">import React from "react";</span><span id="a77e" class="np mo iq nl b gy nx nr l ns nt">type HelloWorldProps = {<br/> title: string;<br/> respondFunction: () =&gt; void;<br/>};</span><span id="0aa7" class="np mo iq nl b gy nx nr l ns nt">export function HelloWorld({ title, respondFunction }: HelloWorldProps) {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h2&gt;Hello World Example&lt;/h2&gt;<br/>       {title}<br/>      &lt;br /&gt;<br/>      &lt;button onClick={() =&gt; respondFunction()}&gt;Respond&lt;/button&gt;        <br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="7eca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该组件需要两个必需的道具:<code class="fe nu nv nw nl b">title</code>和<code class="fe nu nv nw nl b">respondFunction</code>。这些都会从Vue传过来反应。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="d99c" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">步骤3:创建一个Vue组件来挂载React</h1><p id="b92d" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">接下来，我们想要创建一个Vue组件，它将允许我们向它传递任意数量的道具，并且将React装载到应用程序中。</p><p id="ac7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里可以看到这个<code class="fe nu nv nw nl b">ReactWrapper.vue</code>组件:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="9943" class="np mo iq nl b gy nq nr l ns nt">&lt;template&gt;<br/>   &lt;div ref="container" /&gt; <br/>&lt;/template&gt;  </span><span id="5903" class="np mo iq nl b gy nx nr l ns nt">&lt;script&gt; <br/>import { createElement } from "react"; <br/>import { createRoot } from "react-dom/client";  <br/>export default {<br/>   inheritAttrs: false,<br/>   props: {<br/>     component: {<br/>       type: Function,<br/>       required: true,<br/>     },<br/>   },<br/>   data() {<br/>     return {<br/>       reactRoot: null,<br/>     };<br/>   },<br/>   methods: {<br/>     updateReactComponent() {<br/>       this.reactRoot.render(createElement(this.component, this.$attrs));<br/>     },<br/>   },<br/>   mounted() {<br/>     this.reactRoot = createRoot(this.$refs.container);     <br/>     this.updateReactComponent();<br/>   },<br/>   destroyed() {<br/>     this.reactRoot.unmount();<br/>   },<br/>   watch: {<br/>     $attrs: {<br/>       deep: true,<br/>       handler() {<br/>         this.updateReactComponent();<br/>       },<br/>     },<br/>   },<br/> };<br/> &lt;/script&gt;</span></pre><p id="0f22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了快速分析这里发生的事情，我们创建了一个React根，并将其分配给容器ref。</p><p id="70c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经设置了<code class="fe nu nv nw nl b">inheritAttrs: false,</code>,这样属性就不只是放在容器ref上，然后我们在渲染组件时将<code class="fe nu nv nw nl b">$attrs</code>作为道具传递。我们还观察<code class="fe nu nv nw nl b">$attrs</code>并在它们改变时重新渲染组件。</p><p id="36be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，当组件为<code class="fe nu nv nw nl b">destroyed</code>时，我们<code class="fe nu nv nw nl b">unmount</code>确保我们清理了React应用程序。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="edd9" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">第四步:添加带有<code class="fe nu nv nw nl b">React</code>组件和所需道具的<code class="fe nu nv nw nl b">ReactWrapper</code>组件。</h1><p id="5913" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们可以全局注册这个组件，这样它就可以在整个Vue应用程序中使用，或者只是将它导入到我们想要安装它的组件中。</p><p id="9fc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要在全球范围内安装，打开<code class="fe nu nv nw nl b">main.ts</code>并添加:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="291a" class="np mo iq nl b gy nq nr l ns nt">import ReactWrapper from "@/components/ReactWrapper.vue";</span><span id="b4ec" class="np mo iq nl b gy nx nr l ns nt">Vue.component("ReactWrapper", ReactWrapper);</span></pre><p id="6e04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要将其本地导入组件:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="f012" class="np mo iq nl b gy nq nr l ns nt">import ReactWrapper from "./ReactWrapper.vue"</span><span id="7fea" class="np mo iq nl b gy nx nr l ns nt">...</span><span id="900a" class="np mo iq nl b gy nx nr l ns nt">components: {<br/>   ReactWrapper,<br/>},</span></pre><p id="b416" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们想要导入<code class="fe nu nv nw nl b">HelloWorld.tsx</code>组件，并通过在计算属性中返回它来将其公开给模板:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="58a1" class="np mo iq nl b gy nq nr l ns nt">import { HelloWorld } from "../react-migration/src/components/HelloWorld";</span><span id="3b9f" class="np mo iq nl b gy nx nr l ns nt">...</span><span id="f41d" class="np mo iq nl b gy nx nr l ns nt">computed: {<br/>   HelloWorldComponent() {<br/>     return HelloWorld;<br/>   },   <br/>},</span></pre><p id="d243" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们可以添加组件并得到结果文件:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="ddf8" class="np mo iq nl b gy nq nr l ns nt">&lt;template&gt;<br/>   &lt;div&gt;<br/>     &lt;h1&gt;{{ msg }}&lt;/h1&gt;<br/>     &lt;p&gt;<br/>       For a guide and recipes on how to configure / customize this project,&lt;br /&gt;<br/>       check out the<br/>       &lt;a href="<a class="ae kv" href="https://cli.vuejs.org" rel="noopener ugc nofollow" target="_blank">https://cli.vuejs.org</a>" target="_blank" rel="noopener"&gt;vue-cli documentation&lt;/a&gt;.<br/>     &lt;/p&gt;<br/>     &lt;hr /&gt;<br/>      &lt;div&gt;<br/>      <strong class="nl ir"> &lt;react-wrapper<br/>         :component="HelloWorldComponent"<br/>         title="Well Hello there"<br/>         :respondFunction="respondFunction"<br/>       /&gt;</strong><br/>     &lt;/div&gt;<br/>   &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="2ba0" class="np mo iq nl b gy nx nr l ns nt">&lt;script lang="ts"&gt;<br/> import Vue from "vue";<br/><strong class="nl ir"> import { HelloWorld } from "../react-migration/src/components/HelloWorld";</strong><br/> export default Vue.extend({<br/>   name: "HelloWorld",<br/>   props: {<br/>     msg: String,<br/>   },<br/>   computed: {<br/>   <strong class="nl ir">  HelloWorldComponent() {<br/>       return HelloWorld;<br/>     },</strong><br/>   },<br/>   methods: {<br/><strong class="nl ir">     respondFunction() {<br/>       alert("We have responded");<br/>     },</strong><br/>   },<br/> });<br/>&lt;/script&gt;</span></pre><p id="512f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，让我们启动应用程序看看我们有什么。在应用程序目录中运行:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="baba" class="np mo iq nl b gy nq nr l ns nt">npm run serve</span></pre><p id="c84c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并访问终端中提供的链接。您现在应该会看到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/df7dd26c7d1823e65094839e6d8637c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QFPcdlrpJ7cEJxM8Sziv2w.png"/></div></div></figure><p id="b018" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到组件的上半部分是标准入门<code class="fe nu nv nw nl b">HelloWorld.vue</code>组件，在其中，我们可以看到我们的<code class="fe nu nv nw nl b">React</code> <code class="fe nu nv nw nl b">HelloWorld.tsx</code>组件加载，包括标题道具。让我们单击按钮，检查它是否触发了我们传递的Vue函数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/f1e93240e36a6684298e73051588d305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ekeiO4dcqmdDAiXv-k-8Q.png"/></div></div></figure><p id="82c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太好了，我们启动了Vue功能，打开了一个浏览器警告窗口。我们现在在Vue中运行React没有任何问题，这也允许我们使用props在两者之间进行通信。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="8781" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">双向通信</h1><p id="69f8" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">如上所述，当使用道具来激发事件时，两者之间的交流确实很容易，但是如果你的应用程序是大规模的，那么道具训练真的会成为你的一个大问题。这时，您将需要开始考虑利用浏览器事件来触发和侦听，或者设置一个全局状态。选择理想的全局状态可能很棘手，因为您需要它能够兼容Vue和React。</p><p id="30ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将在另一篇文章中讨论这个问题，以及如何让像<a class="ae kv" href="https://github.com/pmndrs/valtio" rel="noopener ugc nofollow" target="_blank"> Valtio </a>这样的普通库与Vue 2一起工作。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="01b3" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">问题</h1><ul class=""><li id="8dca" class="ls lt iq ky b kz nf lc ng lf nz lj oa ln ob lr oc ly lz ma bi translated">如果你正在使用<code class="fe nu nv nw nl b">REST</code>，那么更新你的查询将会像从React而不是Vue中更新一样简单。如果你有一个你最喜欢的HTTP客户端的定制实例，比如Axios ，那么最好在一个可以导入并在React和Vue中使用的文件中初始化singleton。</li><li id="7f76" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr oc ly lz ma bi translated"><strong class="ky ir"> GraphQL </strong> — <strong class="ky ir"> </strong>如果您正在使用<a class="ae kv" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> Apollo </a>您可能会发现您的Vue应用程序在一个旧版本的库上，您需要为React创建一个新的设置。我将在另一篇文章中讨论这个问题。</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="9644" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">结论</h1><p id="e7d3" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我确信有些人在阅读这篇文章时会想:<em class="od">“你确定吗？这可能是不必要的缓慢”。</em>但是，我想指出React建议这样开始:</p><blockquote class="oe of og"><p id="cf9b" class="kw kx od ky b kz la jr lb lc ld ju le oh lg lh li oi lk ll lm oj lo lp lq lr ij bi translated">React从一开始就被设计为逐步采用，你可以根据需要使用React的数量<strong class="ky ir">。也许你只是想给现有的页面增加一些“互动元素”。React组件是实现这一点的好方法。</strong></p><p id="02db" class="kw kx od ky b kz la jr lb lc ld ju le oh lg lh li oi lk ll lm oj lo lp lq lr ij bi translated">大多数网站不是，也不需要成为单页应用。用<strong class="ky ir">几行代码，没有构建工具</strong>，在你网站的一小部分中尝试React。然后，您可以逐渐扩展它的存在，或者保持它包含在几个动态小部件中。</p></blockquote><p id="c817" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">来源</strong>:【https://reactjs.org/docs/add-react-to-a-website.html】T2</p><p id="cc8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还可以向您保证，我知道有公司在使用这种方法，生产版本仍然不到1MB，客户在使用这种方法的领域没有看到任何性能下降！</p><p id="e1f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还想重申，这是一个迁移计划，目的是扼杀Vue，直到我们剩下一个React应用程序。</p><p id="45db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就我个人而言，我认为这种迁移方法是最安全、最简单、最可维护的选择，因为您仍然在一个代码库中工作，并且一步一步地迁移，如果您决定替换整个页面或只是小组件，选项是您的，但这允许您开始。我还想指出的是，如果您正在开发一个大型应用程序，甚至是一个有大量技术债务的应用程序，那么花超过15个月的时间来迁移整个应用程序，同时交付特性工作并维护当前的应用程序可能是一个挑战。你需要从某个地方开始，为什么不从这里开始呢？</p><p id="0e7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我单独和Vue一起工作了几年，我确实喜欢Composition API，但是缺乏吸收、第三方库和社区，你真的想冒险在2年后再做一次迁移吗？React不会去任何地方，它有一个巨大的生态系统，任何JavaScript开发人员都会爱上它。</p><p id="6447" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，如果这还不足以动摇你的话……在你的简历中反应出你的技能也是很棒的。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="e59b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您花时间阅读我的文章。我希望你已经发现它的知识性和趣味性。我将围绕Typescript、Node、React、Vue、GraphQL、Performance、Go等等写更多的文章。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="f775" class="np mo iq bd mp ok ol dn mt om on dp mx lf oo op mz lj oq or nb ln os ot nd ou bi translated">GitHub知识库</h2><div class="ov ow gp gr ox oy"><a href="https://github.com/nic-jennings/vue2-to-react" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd ir gy z fp pd fr fs pe fu fw ip bi translated">GitHub-NIC-Jennings/vue 2-to-react</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">github.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm kp oy"/></div></div></a></div></div></div>    
</body>
</html>