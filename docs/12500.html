<html>
<head>
<title>5 Simple Tips For Debugging Docker Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">调试Docker容器的5个简单技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-simple-tips-for-debugging-docker-containers-271cb3dee77a?source=collection_archive---------8-----------------------#2022-06-09">https://betterprogramming.pub/5-simple-tips-for-debugging-docker-containers-271cb3dee77a?source=collection_archive---------8-----------------------#2022-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c677" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用最少的疯狂熏出恼人的容器问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8fc66ca2a8cd6a17e2541deb1e84634e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y1Tka4FSJebNVzEWB1etiw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@rubaitulazad?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Rubaitul Azad </a>在<a class="ae ky" href="https://unsplash.com/s/photos/docker?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="ddbf" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">有时候Docker容器可以是一个黑盒。无论您是构建底层映像还是使用公共映像，摆动的容器都令人沮丧。由于容器的执行方式和它们处理日志的方式，弄清楚发生了什么可能很困难。</p><p id="f7b8" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在本文中，我们将探索一些基本的命令和参数，您可以使用它们来对特别复杂的容器进行故障诊断。如果容器无法启动，间歇性爆炸，或者您只是想要更多地了解图像细节，这些简单的选项是真正的游戏规则改变者。</p><h1 id="ce4d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.更好的日志和时间戳</h1><p id="8b41" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">第一个也是最简单的例子是使用Docker已经提供的日志工具。大多数人已经知道如何查看容器中的日志:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="df9d" class="ne md it na b gy nf ng l nh ni">docker logs &lt;container_id&gt;</span></pre><p id="711f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">但是，如果这个特定的容器已经运行了很长时间，并且有一个德克萨斯州大小的日志呢？在这种情况下，您可以简单地添加额外的<code class="fe nj nk nl na b">--tail</code>参数:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a3ae" class="ne md it na b gy nf ng l nh ni">docker logs --tail 10 &lt;container_id&gt;</span></pre><p id="b8e4" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">使用<code class="fe nj nk nl na b">--tail</code>选项，您可以看到日志的最后几行<code class="fe nj nk nl na b">n</code>。传入您想要查看的行数，可以让您直接跳转到最相关和最近的信息。</p><p id="a9eb" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果容器中的日志输出默认不包含时间戳，您也可以添加时间戳。Docker允许您将<code class="fe nj nk nl na b">-t</code>标志传递给<code class="fe nj nk nl na b">log</code>，它将在每一行前面加上时间戳:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1487" class="ne md it na b gy nf ng l nh ni">docker logs -t &lt;container_id&gt;</span></pre><p id="0c38" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这些选项也可以结合起来，形成一个精确的故障诊断工具。现在，您将能够准确地说出事情发生的时间，而不必改变容器内的任何内容。</p><h1 id="247f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.以root用户身份执行命令</h1><p id="197a" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">如果您使用的是作为默认根用户运行的映像，那么这不是问题。当您不以root用户身份运行，而是使用非特权用户时，这是一个很好的故障排除工具。</p><p id="199d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果你跑步:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9ce8" class="ne md it na b gy nf ng l nh ni">docker exec -it &lt;container_id&gt; /bin/sh</span></pre><p id="a417" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这将始终以底层映像中定义的用户身份运行。如果这个用户没有root权限，那么就很难尝试进入一个正在运行的容器进行故障排除(特别是当您需要安装任何东西的时候)。</p><p id="1790" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果您想以root用户的身份进入容器，您所要做的就是传递以下内容:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6acb" class="ne md it na b gy nf ng l nh ni">docker exec -u 0 -it &lt;container_id&gt; /bin/sh</span></pre><p id="1322" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这将告诉Docker使用ID为<code class="fe nj nk nl na b">0</code>的用户。这是根。现在，当您进入容器时，您就可以使用全部权限进行调试了。</p><h1 id="9557" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.将容器提交为图像</h1><p id="c9d9" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">这是Docker一个经常被忽略的特性。实际上，您可以从现有的容器创建一个新的图像。这意味着，如果你一直在摆弄一个容器，并做了一些修改来修复一些错误，你可以马上从它旋转出新的容器。你甚至不用去重建docker文件。</p><p id="c6bd" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">以下命令将提交现有容器中的新映像:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="aa94" class="ne md it na b gy nf ng l nh ni">docker commit &lt;container_name&gt; &lt;new_image&gt;</span></pre><p id="8c6b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这将使用您指定的任何名称创建一个新的映像，并且您可以立即使用它来旋转新的容器。</p><p id="c3f3" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><code class="fe nj nk nl na b">commit</code>命令的另一个好处是，您可以在提交过程中将Dockerfile语法传递给它。如果您想要提交一个现有的容器，但是更改了其中的一个环境变量，那么您可以使用<code class="fe nj nk nl na b">--change</code>标志来传递它:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4a14" class="ne md it na b gy nf ng l nh ni">docker commit --change="ENV foo=bar" &lt;container_name&gt; &lt;new_image&gt;</span></pre><p id="8996" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">您可以将多个不同的<code class="fe nj nk nl na b">changes</code>传递给<code class="fe nj nk nl na b">commit</code>命令，以便在命令行上创建令人印象深刻的精细图像。</p><h1 id="7d57" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.匹配图像哈希</h1><p id="ae9b" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">如果您正在对已经存在一段时间的容器进行故障诊断，您可能不知道它是用哪个特定版本的映像构建的。如果您使用像Docker Hub或Elastic Container Registry这样的容器注册中心，您可以很容易地获得图像的散列，并将其与您的容器进行比较。</p><p id="2f1e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">获取容器所有元数据的一种快速方法是使用<code class="fe nj nk nl na b">inspect</code>命令。这很好，但是它给了你大量的信息。如果您想要的只是图像散列，那么您可以使用如下的一点格式化魔法来得到它:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8d8d" class="ne md it na b gy nf ng l nh ni">docker inspect --format "{{ .Image }}" &lt;container_id&gt;</span></pre><p id="ad81" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这应该会输出容器正在运行的映像的sha256哈希。哈希可以与注册表中的哈希进行比较，以确定它是何时构建的。</p><p id="7e63" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在你可以完全确定哪个版本在哪里运行。</p><h1 id="a32b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.跳过构建缓存</h1><p id="fecf" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">如果你真的很难理解为什么构建会失败，有问题或者只是没有包含你做的一些更改，那么可能是时候放弃缓存了。虽然Docker应该识别对层的更改并根据需要重建，但有时您需要从头开始的安心。</p><p id="1408" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果希望在不利用任何现有构建缓存的情况下构建映像，可以运行以下命令:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="543c" class="ne md it na b gy nf ng l nh ni">docker build --tag &lt;tag&gt; --no-cache .</span></pre><p id="45e5" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这将忽略缓存中任何以前构建的项目，并强制所有内容从零开始构建。如果您正在处理一个图像的多次迭代，并希望确保对一些图层进行非常细微的更改，这将非常方便。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="5892" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">感谢您的阅读！你最喜欢的码头工人建议是什么？看看我其他的一些Docker帖子:</p><ul class=""><li id="2e9f" class="nn no it li b lj lk lm ln lp np lt nq lx nr mb ns nt nu nv bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-share-a-postgres-socket-between-docker-containers-ad126e430de7"> <em class="nm">如何在Docker容器之间共享Postgres套接字</em> </a></li><li id="104a" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated"><a class="ae ky" href="https://levelup.gitconnected.com/deploying-docker-containers-with-ansible-2a74a420e2b1" rel="noopener ugc nofollow" target="_blank"> <em class="nm">用Ansible </em>部署码头集装箱</a></li></ul></div></div>    
</body>
</html>