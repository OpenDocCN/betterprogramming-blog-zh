<html>
<head>
<title>React Routers, Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React路由器，解释</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-routers-explained-ff89153a6405?source=collection_archive---------1-----------------------#2021-01-12">https://betterprogramming.pub/react-routers-explained-ff89153a6405?source=collection_archive---------1-----------------------#2021-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5d48" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何构建动态的多页面React应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5eeaf3f39205fcfdf5eb3ac203f90985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pZd1cYVf9AaxYn6e"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">斯文·皮伦在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="79cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传统上，React一直用于构建单页面web应用程序。但是，如果您坚持构建一个具有多个页面或路径的React应用程序，则必须完成以下过程:</p><ul class=""><li id="5d0b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">告诉React根据用户导航到的路线呈现页面。</li><li id="a4d4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">为了实现这一点，React必须从服务器获取页面。</li></ul><p id="022c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用代码实现这些步骤曾经有点乏味。这就是<a class="ae ky" href="https://reactrouter.com/" rel="noopener ugc nofollow" target="_blank">反应路由器</a>开始发光的地方。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d4e5" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">React路由器简介</h1><h2 id="83ad" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">什么是React路由器？</h2><p id="14d9" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">根据这篇<a class="ae ky" href="https://medium.com/@ridars01/react-router-tutorial-e6b1cc148925" rel="noopener">媒体文章</a>，React路由器库允许用户在他们的应用中实现动态路由。此外，它通过根据路线渲染React组件来利用基于组件的方法。换句话说，它告诉React在URL的特定路径上呈现特定的组件。例如，当用户位于<code class="fe nz oa ob oc b">/about</code>目录时，呈现<code class="fe nz oa ob oc b">About</code> React组件。</p><h2 id="00d7" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">何时使用React路由器</h2><p id="0db8" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">让我用一个例子来说明这一点。</p><p id="782c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个名为<code class="fe nz oa ob oc b">Home.js</code>的组件。这将是当用户导航到根目录(<code class="fe nz oa ob oc b">/</code>)时显示的组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/8141d8fe15a9d1c2c1acf88665f225e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*eee1aIfI82WUgcaGfChX4g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们示例中的Home组件</p></figure><p id="ac07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们编写另一个名为<code class="fe nz oa ob oc b">About.js</code>的组件。这将在用户转到URL的<code class="fe nz oa ob oc b">/about</code>目录时呈现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/527c7b303ced55629c9c4d587079c4a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E7e_l_ev_LmQ1p8ZVjufXA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们示例中的About组件</p></figure><p id="eb62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们将它显示给DOM。为此，让我们转到<code class="fe nz oa ob oc b">App.js</code>中的<code class="fe nz oa ob oc b">return</code>模块:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/6e020466e78d43249aa30f54fde3c270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NtafkW6UmryOQGRYCGG0Pg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">向DOM显示这些组件</p></figure><p id="7b94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将产生以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/52fb8f957e727c724cdb44abd69b5c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*UBVZVr_PjMqeOnx78l53lQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码示例的输出</p></figure><p id="3b1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的代码有效。然而，问题是我们不想在同一个页面上同时呈现<code class="fe nz oa ob oc b">About</code>和<code class="fe nz oa ob oc b">Home</code>。我们希望<code class="fe nz oa ob oc b">Home</code>呈现在<code class="fe nz oa ob oc b">/</code>页面上，而<code class="fe nz oa ob oc b">About</code>组件呈现在名为<code class="fe nz oa ob oc b">/about</code>的独立路径上。</p><p id="13e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们将利用React路由器库的能力。</p><p id="2553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这个库还有一个额外的好处:因为您的React应用程序不必从服务器获取页面，只需加载特定的组件，所以您的web应用程序变得更快、更动态。因此，这让你的应用感觉像一个原生的桌面或移动应用。</p><p id="bfc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们写点代码吧！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2533" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">入门指南</h1><p id="e5a5" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">首先，使用以下终端命令初始化项目的存储库:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/459bd0593b7227ecaec7d235cfd93a9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uMorAOdU-8nKGT-IO7ne8g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">初始化项目的命令</p></figure><p id="7259" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，现在让我们安装<code class="fe nz oa ob oc b">react-router-dom</code>包。</p><h2 id="d724" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">安装所需的库</h2><p id="496e" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">我们将只安装<code class="fe nz oa ob oc b">react-router-dom</code>模块，因为React路由器库依赖于这个包来运行。</p><p id="7005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，运行以下终端命令:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/a831daf584c72f602821aa3ba755e559.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IKEmh_4-2FiajDKEI9p0bg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安装react-router-dom包的命令</p></figure><p id="2bdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将编写代码来为我们的项目设置一个React路由器。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6c7b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">反应路由器:基本路由</h1><h2 id="9e99" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">设置</h2><p id="c767" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">开始之前，去<code class="fe nz oa ob oc b">App.js</code>并从<code class="fe nz oa ob oc b">react-router-dom</code>包中导入以下模块:</p><ul class=""><li id="c023" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nz oa ob oc b">Route</code>:这将允许我们告诉React根据路线渲染特定的组件。</li><li id="c2c8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">这将为我们的项目增加路线设施。<code class="fe nz oa ob oc b">BrowserRouter</code>标签之间的所有内容都能够执行路由。</li><li id="0f32" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nz oa ob oc b">Switch</code>:这将呈现它遇到的第一个与路线匹配的<code class="fe nz oa ob oc b">Route</code>。我们将在教程的后面更详细地介绍这一点。</li><li id="626a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nz oa ob oc b">Redirect</code>:<code class="fe nz oa ob oc b">Redirect</code>模块将允许我们根据用户导航到的目录将用户重定向到另一条路径。例如，如果用户导航到<code class="fe nz oa ob oc b">/</code>目录，则将用户重定向到<code class="fe nz oa ob oc b">/home</code>目录。</li></ul><p id="4712" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，转到<code class="fe nz oa ob oc b">App.js</code>并编写以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/2ef143faf807807adb2c04bb880be910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DGoTrj5KNC36n7mSI4y-mg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在App.js中导入库</p></figure><p id="147a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只是使用对象析构赋值来从<code class="fe nz oa ob oc b">react-router-dom</code>获取这些包。</p><ul class=""><li id="a123" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第3行:在这里，我们只是将<code class="fe nz oa ob oc b">BrowserRouter</code>重命名为<code class="fe nz oa ob oc b">Router</code>。</li></ul><p id="fb8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们继续创建一些组件，这些组件将用于演示React中的路由。</p><p id="5f3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的<code class="fe nz oa ob oc b">src</code>文件夹中，创建一个名为<code class="fe nz oa ob oc b">Home.js</code>的新文件，并编写以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/8141d8fe15a9d1c2c1acf88665f225e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*eee1aIfI82WUgcaGfChX4g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Home.js的代码</p></figure><p id="ced2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们创建另一个名为<code class="fe nz oa ob oc b">About.js</code>的组件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/527c7b303ced55629c9c4d587079c4a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E7e_l_ev_LmQ1p8ZVjufXA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">About.js中的代码</p></figure><p id="eef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，让我们创建另一个名为<code class="fe nz oa ob oc b">Nav.js</code>的组件。该组件将在每条路线上呈现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="94c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个基本组件，由一个<code class="fe nz oa ob oc b">ul</code>元素和几个<code class="fe nz oa ob oc b">li</code>子项组成。</p><p id="ea36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，让我们继续基本路由。</p><h2 id="cf52" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">基本路由</h2><p id="56a9" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在这一节中，我们将最终向我们的项目添加基本的路由设施。</p><p id="6d51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从把我们新制造的部件进口到<code class="fe nz oa ob oc b">App.js</code>开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/b5fb89e27655a0dffb0b20a0f45bd5ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TP9OhWoH6NFGXAK6XhF0ow.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在App.js中导入</p></figure><p id="ad20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">去<code class="fe nz oa ob oc b">App.js</code>找到你的<code class="fe nz oa ob oc b">return</code>区块:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/b0e22f07f836f230269ee06a8f694e25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PObzii0ib891oX01uD2bmw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在App.js中查找的代码</p></figure><p id="4f86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在删除<code class="fe nz oa ob oc b">div</code>标签之间的代码，并编写以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/a463f7cb203c90d003a2349f1a5714bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3CZjktUQbWdEs1Kf3s0prw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在App.js中编写的代码</p></figure><ul class=""><li id="21ed" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第4行:呈现<code class="fe nz oa ob oc b">Nav</code>组件。</li><li id="0ff2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第5行:如果用户在<code class="fe nz oa ob oc b">/</code>目录中，告诉React呈现<code class="fe nz oa ob oc b">Home</code>组件。</li><li id="7296" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第6行:假设用户在<code class="fe nz oa ob oc b">/about</code>页面，告诉React Router呈现<code class="fe nz oa ob oc b">About</code>组件。</li><li id="0459" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第3行和第7行:<code class="fe nz oa ob oc b">Router</code>标签之间的所有内容现在都能够执行基本的路由。</li></ul><p id="c848" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，现在让我们运行代码。这将是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/bc037dad43f1ae47485edee34261b640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/1*wTp3GTMjI7jXzM7rpI80dA.gif"/></div></figure><p id="ebd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，当我们导航到<code class="fe nz oa ob oc b">/about</code>页面时，呈现了<code class="fe nz oa ob oc b">About.js</code>组件。然而，尽管我们的代码告诉React在<code class="fe nz oa ob oc b">/</code>页面上呈现这个组件，但是<code class="fe nz oa ob oc b">Home</code>组件仍然被显示。那么为什么会出现这个问题呢？</p><p id="6b1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回溯到刚刚编写的这段代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/a463f7cb203c90d003a2349f1a5714bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3CZjktUQbWdEs1Kf3s0prw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在App.js中查找的代码</p></figure><p id="5693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因是<code class="fe nz oa ob oc b">Router</code>只是检查路线路径而不是太具体。所以在这段代码中，它基本上遍历了所有这些<code class="fe nz oa ob oc b">Route</code>组件。</p><ul class=""><li id="7e39" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">根据第5行，我们告诉React如果在任何子<code class="fe nz oa ob oc b">Route</code>组件的<code class="fe nz oa ob oc b">path</code>道具中遇到斜杠(<code class="fe nz oa ob oc b">/</code>)就渲染<code class="fe nz oa ob oc b">Home</code>组件。</li><li id="4fd2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">现在根据第6行，如果我们转到<code class="fe nz oa ob oc b">/about</code>页面，React Router首先检查路由是否包含一个<code class="fe nz oa ob oc b">/</code>。由于该状态为<code class="fe nz oa ob oc b">true</code>，再次显示<code class="fe nz oa ob oc b">Home</code>。此外，由于路径包含了关键字<code class="fe nz oa ob oc b">about</code>，那么<code class="fe nz oa ob oc b">About</code>组件也会被呈现。</li></ul><p id="65be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，默认情况下，React Router将呈现所有作为彼此子路由的组件。为了纠正这个问题，我们需要使用<code class="fe nz oa ob oc b">Switch</code>组件。</p><h2 id="6ef8" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">该开关组件</h2><p id="4aff" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">根据<a class="ae ky" href="https://reactrouter.com/web/api/Switch" rel="noopener ugc nofollow" target="_blank"> React Router的文档</a>,<code class="fe nz oa ob oc b">Switch</code>组件本质上是在匹配URL时停止遍历所有路由路径的整个过程。它将只呈现匹配当前URL的第一个<code class="fe nz oa ob oc b">Route</code>组件。</p><p id="f31a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nz oa ob oc b">App.js</code>中，找到你的<code class="fe nz oa ob oc b">return</code>区块:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/a463f7cb203c90d003a2349f1a5714bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3CZjktUQbWdEs1Kf3s0prw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在App.js中查找的代码</p></figure><p id="f30d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe nz oa ob oc b">Switch</code>标签包装所有的<code class="fe nz oa ob oc b">Route</code>组件。最后，您的<code class="fe nz oa ob oc b">return</code>块应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="aaa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们在<code class="fe nz oa ob oc b">Switch</code>标签之间包装了<code class="fe nz oa ob oc b">Route</code>标签，React Router现在将查看这些<code class="fe nz oa ob oc b">Routes</code>并呈现第一个符合其标准的<code class="fe nz oa ob oc b">Route</code>组件。所以理论上，如果用户转到<code class="fe nz oa ob oc b">/</code>路径，应该呈现<code class="fe nz oa ob oc b">Home</code>，而当用户导航到<code class="fe nz oa ob oc b">/about</code>目录时，应该只呈现<code class="fe nz oa ob oc b">About</code>。</p><p id="321d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">写完代码后，运行程序。这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/af7996451c2a854f2e5757b3c42dce59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/1*C32kTOzD6BAwc1AATK95tw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="cba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，<code class="fe nz oa ob oc b">Switch</code>组件在我们的程序中引入了一个问题。即使我们转到<code class="fe nz oa ob oc b">/about</code>页面，也只有<code class="fe nz oa ob oc b">Home</code>被渲染。发生了什么事？</p><p id="d6d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回溯到刚刚编写的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/6f80d5472a8fbb107b0eb9a03e5b19a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aHJKuwPTikYWI7Y4dkPnZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要参考的代码(App.js)</p></figure><ul class=""><li id="a5df" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第2行:我们告诉React Router如果URL包含一个<code class="fe nz oa ob oc b">/</code>就渲染<code class="fe nz oa ob oc b">Home</code>。</li><li id="5d92" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第3行:我们告诉React Router如果URL包含一个<code class="fe nz oa ob oc b">/about</code>就渲染<code class="fe nz oa ob oc b">About</code>。</li><li id="6f7e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">所以当我们导航到<code class="fe nz oa ob oc b">/about</code>时，React Router首先检查URL是否包含<code class="fe nz oa ob oc b">/</code>。由于这个条件是<code class="fe nz oa ob oc b">true</code>，所以渲染了<code class="fe nz oa ob oc b">Home</code>。</li><li id="a385" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">这就是<code class="fe nz oa ob oc b">Switch</code>接手的地方。回想一下，<code class="fe nz oa ob oc b">Switch</code>只呈现匹配URL的第一个<code class="fe nz oa ob oc b">Route</code>组件。所以在<code class="fe nz oa ob oc b">/about</code>上，现在<code class="fe nz oa ob oc b">Home</code>被渲染了(匹配URL的第一个<code class="fe nz oa ob oc b">Route</code>组件)，<code class="fe nz oa ob oc b">Switch</code>停止了URL匹配过程。因此，<code class="fe nz oa ob oc b">About</code>没有被呈现到DOM中。</li></ul><p id="8be8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来纠正这个问题。为此，我们需要在我们的<code class="fe nz oa ob oc b">Route</code>组件中使用<code class="fe nz oa ob oc b">exact</code> prop。</p><h2 id="1f60" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">确切的道具</h2><p id="8e70" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">如果路径名与URL <em class="om">完全匹配</em>，那么<code class="fe nz oa ob oc b">exact</code>属性实际上告诉React Router呈现<code class="fe nz oa ob oc b">Route</code>的组件。所以在我们的应用程序中，我们可以预期当用户导航到<code class="fe nz oa ob oc b">/</code>时<code class="fe nz oa ob oc b">Home</code>应该只显示<strong class="lb iu"> </strong>，如果用户转到<code class="fe nz oa ob oc b">/about</code>目录，那么<code class="fe nz oa ob oc b">About</code>应该只显示<strong class="lb iu"> </strong>。</p><p id="26c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到<code class="fe nz oa ob oc b">App.js</code>中的<code class="fe nz oa ob oc b">return</code>块，找到以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/6f80d5472a8fbb107b0eb9a03e5b19a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aHJKuwPTikYWI7Y4dkPnZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在App.js中查找的代码</p></figure><p id="f6be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，就像这样将<code class="fe nz oa ob oc b">exact</code>道具添加到<code class="fe nz oa ob oc b">Route</code>组件中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/54d3f3f75765c9bc9a01e95816936478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NxNMK8B9ALx5FlK_TP2aiw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">App.js中要替换的代码</p></figure><ul class=""><li id="1e96" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第2行:<code class="fe nz oa ob oc b">exact</code> prop现在告诉React Router，如果用户导航到<code class="fe nz oa ob oc b">/</code>目录，只显示<code class="fe nz oa ob oc b">Home</code>组件<strong class="lb iu"> </strong>。</li></ul><p id="80ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">写完代码后，运行程序。这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/58ac623a3bd1660421df3e09f0405f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/1*pJdteQr6CjuOdTa4P1nFtw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="21fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的代码有效！我们的产出是我们想要的。</p><p id="ca9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将使用<code class="fe nz oa ob oc b">Link</code>组件为我们的应用程序添加导航。</p><h2 id="e68c" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">链接组件</h2><p id="978d" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在现实世界中，用户不希望通过在地址栏中手动输入路线来导航我们的网站。我们必须使用按钮或锚链接，用户将点击，以便他们可以通过网站。</p><p id="aca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是React路由器的<code class="fe nz oa ob oc b">Link</code>组件的用武之地。您可以假设<code class="fe nz oa ob oc b">Link</code>组件是一个<code class="fe nz oa ob oc b">a</code>标签。</p><p id="ad18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe nz oa ob oc b">Link</code>用于导航目的，我们将在<code class="fe nz oa ob oc b">Nav.js</code>中使用它。</p><p id="fa71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到<code class="fe nz oa ob oc b">Nav.js</code>，从<code class="fe nz oa ob oc b">react-router-dom</code>包中导入<code class="fe nz oa ob oc b">Link</code>开始，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/522cb6557bd8a7da4f6e6be2a9e44268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AHezHCnkHfWX9ME1cQTgrg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">导入Nav.js</p></figure><p id="54bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nz oa ob oc b">Nav.js</code>中，找到你的<code class="fe nz oa ob oc b">return</code>区块:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/55c2addcc77b62c839d95b8b92ff9e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSOCbEUpY6ifqi7wTShf4A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在Nav.js中查找的代码</p></figure><p id="4062" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在用下面这段代码替换它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><ul class=""><li id="770d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第4-6行:我们将<code class="fe nz oa ob oc b">Link</code>组件包装在<code class="fe nz oa ob oc b">li</code>标签之间，这样它们就可以呈现在列表元素中。这个<code class="fe nz oa ob oc b">Link</code>通过将用户指引到<code class="fe nz oa ob oc b">/</code>路线，将他们带到主页。</li><li id="63a8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第7-9行:我们已经将<code class="fe nz oa ob oc b">Link</code>组件包装在<code class="fe nz oa ob oc b">li</code>标签之间，这样它们就可以呈现在我们的列表元素中。此<code class="fe nz oa ob oc b">Link</code>通过将用户指引到<code class="fe nz oa ob oc b">/about</code>路线，将用户带到“关于”页面。</li></ul><p id="672f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在运行代码。这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/89f97924c74b2f605999d9c7dbcd1d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/1*fRWsDzhKqC3j8_rjTaLvnw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="b09e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的代码有效。现在让我们继续处理重定向。</p><h2 id="9f1e" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">重定向组件</h2><p id="1ea6" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">组件<code class="fe nz oa ob oc b">Redirect</code>的用法相当简单。呈现时，它会将用户导航到一个新的位置。例如，在我们的程序中，如果用户在地址栏中键入<code class="fe nz oa ob oc b">/home</code>路线，我们希望我们的应用程序将他们重定向到<code class="fe nz oa ob oc b">/</code>页面。</p><p id="34c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到<code class="fe nz oa ob oc b">App.js</code>中的<code class="fe nz oa ob oc b">return</code>块:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/167f84c953dea0e15d0fe1d798426b15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iwxO43QUGQfN3woNLz2hcQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在App.js中查找的代码</p></figure><p id="d90f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在将它改为下面这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="6578" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">零钱在第7行。</p><ul class=""><li id="5a9b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第7行:这里，我们告诉React Router将用户从<code class="fe nz oa ob oc b">/home</code>重定向到<code class="fe nz oa ob oc b">/</code>目录。属性是重定向的路径名。此外，<code class="fe nz oa ob oc b">to</code>道具是重定向到的位置。</li></ul><p id="15d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！让我们运行代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/8250d27327de871871d98206f5c3085b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/1*ARLYcTnYnvrigpzFu7N60A.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="9442" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，当我们在地址栏中输入<code class="fe nz oa ob oc b">/home</code>路线时，应用程序引导我们回到<code class="fe nz oa ob oc b">/</code>目录。这意味着我们的代码有效！</p><p id="fb21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在完成了基本的路由。在下一节中，我们将创建动态和自定义路线。</p><p id="b14e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe nz oa ob oc b">App.js</code>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="bb59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而<code class="fe nz oa ob oc b">Home.js</code>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="2497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且，<code class="fe nz oa ob oc b">Nav.js</code>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="2349" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe nz oa ob oc b">About.js</code>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="13e9" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">React路由器:动态和定制路由</h1><p id="4a38" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在本文的这一部分，我们将从外部API获取数据。我们将特别使用这个<a class="ae ky" href="https://sampleapis.com/api-list/coffee" rel="noopener ugc nofollow" target="_blank">咖啡API </a>。这是我们要做的:</p><ul class=""><li id="bc26" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在主页上，我们将展示两个<code class="fe nz oa ob oc b">Link</code>组件。</li><li id="1bdc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一个<code class="fe nz oa ob oc b">Link</code>组件将引导用户到一个有热咖啡名称列表的页面，另一个将引导他们到一个有冰咖啡名称列表的页面。</li><li id="c017" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当用户点击列表中的任何名字时，他们将被带到另一个页面，显示他们刚刚点击的咖啡的描述。</li></ul><p id="e1cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们用代码实现它。</p><p id="a648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的第一步是渲染<code class="fe nz oa ob oc b">Home.js</code>中的两个<code class="fe nz oa ob oc b">Links</code>。转到<code class="fe nz oa ob oc b">Home.js</code>，从<code class="fe nz oa ob oc b">react-router-dom</code>导入<code class="fe nz oa ob oc b">Link</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/e2b07f2f0c125c8d4efe553a954b4649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UhlZ3NLso2O43SpeZIEfPQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Home.js中导入</p></figure><p id="2fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在转到<code class="fe nz oa ob oc b">App.js</code>中的<code class="fe nz oa ob oc b">return</code>块:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/859d6b558a2fe9400648d60e2585ad3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e5L60FuI1YuKmxHkqNhthQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在Home.js中查找的代码</p></figure><p id="5a80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们现在渲染它。用下面的代码块替换它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="b2cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们简单地创建了两个将显示在列表中的<code class="fe nz oa ob oc b">Link</code>组件。</p><ul class=""><li id="f245" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第6-8行:这个<code class="fe nz oa ob oc b">li</code>元素有一个<code class="fe nz oa ob oc b">Link</code>组件，将用户重定向到<code class="fe nz oa ob oc b">/coffee/hot</code>目录。</li><li id="bee9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第9-11行:这个<code class="fe nz oa ob oc b">li</code>元素有一个<code class="fe nz oa ob oc b">Link</code>组件，将用户重定向到<code class="fe nz oa ob oc b">/coffee/iced</code>目录。</li></ul><p id="6af1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/3d476820541257b73d3f8e33c0255531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*XAGESyMrSlvgGKE_-4gc6g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="b506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的代码有效。然而，我们还没有处理<code class="fe nz oa ob oc b">/coffee/hot</code>和<code class="fe nz oa ob oc b">/coffee/iced</code>路径，这就是为什么当它们被点击时，页面上不会呈现任何东西。</p><p id="5617" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但有一个问题:我们如何处理这两条路线？我们先想想。</p><p id="54e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个解决方案是这样的:</p><ul class=""><li id="5aa9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">创建两个组件，分别处理<code class="fe nz oa ob oc b">/coffee/hot</code>和<code class="fe nz oa ob oc b">/coffee/iced</code>路线:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/cf0d9fb4c51b5e9ee3ace2dd947200f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t6iJ4iS_ZojCZKmZC6fRBQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">冰咖啡样品溶液</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/730b28bff4e847ff08dff5b325d26175.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VuUT8lg-7Eq-AYRqvDtHlA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">样品溶液热咖啡</p></figure><ul class=""><li id="ea14" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">然后，我们可以创建两个<code class="fe nz oa ob oc b">Route</code>组件来在<code class="fe nz oa ob oc b">App.js</code>中呈现它们:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/d69ac27824e099330348b8da3e1facd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eedXRVAOBX9mrfjeBij7Gg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例解决方案App.js</p></figure><p id="1fc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这是纠正我们问题的一种方法，但这并不理想。<code class="fe nz oa ob oc b">HotCoffee</code>和<code class="fe nz oa ob oc b">IcedCoffee</code>的代码都差不多，这就打破了编程的枯燥(不要重复自己)原则。</p><p id="9f5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">纠正这个问题的另一种方法是使用参数。这种方法更好，需要编写的代码更少。注意在<code class="fe nz oa ob oc b">/coffee/hot</code>和<code class="fe nz oa ob oc b">/coffee/iced</code>中，我们可以将<code class="fe nz oa ob oc b">/hot</code>和<code class="fe nz oa ob oc b">/iced</code>路线归类为参数。</p><h2 id="59fb" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">使用useParams访问参数</h2><p id="740a" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">如果您曾经使用过Express.js，我们将使用如下参数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/bec3ce2ff4e489ddd69176dda2231840.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3lxWHoZ73xMw8-y27PspHw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实施此流程App.js</p></figure><p id="1b56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们如何在React中访问这些参数呢？</p><p id="b888" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好消息是React Router允许在我们的代码中访问参数。为了在React路由器中访问URL参数，我们使用了<code class="fe nz oa ob oc b">useParams</code>钩子。</p><p id="f8a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先创建一个<code class="fe nz oa ob oc b">Route</code>来处理<code class="fe nz oa ob oc b">/coffee/:type</code>路线。这里，<code class="fe nz oa ob oc b">type</code>是我们想要访问的参数。</p><p id="8008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到<code class="fe nz oa ob oc b">App.js</code>并在<code class="fe nz oa ob oc b">return</code>块中找到以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/018c1cd697f4f8776f0e3d2f885878a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jsHTQHCKil98EjydElRbKA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在App.js中查找的代码</p></figure><p id="5862" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在用下面的代码编辑它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/ef9dca9a8d038d2e15b58c0b4078ff39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*srwl91MeVvW5Bj3MOa1-dQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在App.js中编写的代码</p></figure><ul class=""><li id="d3ac" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第5行:这里，我们告诉React Router，如果用户在<code class="fe nz oa ob oc b">/coffee/:type</code>目录中，就呈现<code class="fe nz oa ob oc b">Coffee</code>组件。</li></ul><p id="f666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们使用<code class="fe nz oa ob oc b">useParams</code>吊钩。下一步，我们将创建一个组件来呈现咖啡列表。创建一个名为<code class="fe nz oa ob oc b">Coffee.js</code>的新文件，并编写以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><ul class=""><li id="a81b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第1行和第2行:分别从<code class="fe nz oa ob oc b">react-router-dom</code>和<code class="fe nz oa ob oc b">react</code>模块导入<code class="fe nz oa ob oc b">useParams</code>和<code class="fe nz oa ob oc b">useEffect</code>挂钩。</li><li id="ee64" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第4行:这个<code class="fe nz oa ob oc b">params</code>变量将为我们提供关于URL中参数的数据。它被赋予了包含URL中参数值的<code class="fe nz oa ob oc b">useParams</code>钩子。</li><li id="0b4e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第6-8行:这里，当<code class="fe nz oa ob oc b">Coffee</code>组件被安装到DOM时，我们记录下<code class="fe nz oa ob oc b">params</code>的值。</li></ul><p id="c3c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在运行程序之前，让我们在<code class="fe nz oa ob oc b">App.js</code>中导入这个组件。转到<code class="fe nz oa ob oc b">App.js</code>并像这样导入<code class="fe nz oa ob oc b">Coffee</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/cb2ef022f3bae6e6c0ba04c2b2b65d1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8U2QPPFoVzsH5qsLq-w55w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在App.js中编写的代码</p></figure><p id="fdd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在运行程序。让我们先来看看指向<code class="fe nz oa ob oc b">/coffee/hot</code>的链接:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/5f5bf239c57fd2d6be0ee20e39806c4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/1*1ZHhWFlAHHSa6A0HpDxI9g.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="301e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看你的浏览器的开发者工具的控制台。在这里，我们可以看到<code class="fe nz oa ob oc b">params</code>的价值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/af06f5a43b114ea6a6b6ae42fe060912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*t2-FsBX4RhRvWmBPtFt-ew.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">控制台中的输出</p></figure><p id="76e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们得到了<code class="fe nz oa ob oc b">type</code>参数的值！让我们使用它。</p><p id="0d63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们点击将用户重定向到<code class="fe nz oa ob oc b">/coffee/iced</code>的链接。控制台中的输出如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/b04732428461ce21eaa4340c60048fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*h-BHXf2ABUJSjamtEsC5bg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">控制台中的输出</p></figure><p id="57f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，<code class="fe nz oa ob oc b">type</code>参数现在是<code class="fe nz oa ob oc b">iced</code>。我们的代码有效！</p><p id="8a9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步，我们将从<a class="ae ky" href="https://sampleapis.com/api-list/coffee" rel="noopener ugc nofollow" target="_blank"> Coffee API </a>中获取<code class="fe nz oa ob oc b">fetch</code>数据，然后按类型呈现咖啡列表。</p><h2 id="c1c5" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">获取数据</h2><p id="e37f" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在<code class="fe nz oa ob oc b">Coffee.js</code>中，创建一个名为<code class="fe nz oa ob oc b">fetchData</code>的函数。在那里，编写以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/e6776ac01120be5d71809ab163970441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ttleMvE_N69W6oymhKA0UQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用Coffee.js编写的代码</p></figure><ul class=""><li id="69b0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第2行:这里，我们调用Coffee API。最后，我们追加了从<code class="fe nz oa ob oc b">params</code>对象获得的<code class="fe nz oa ob oc b">type</code>参数值。因此，根据点击的链接，我们从<code class="fe nz oa ob oc b">https://api.sampleapis.com/coffee/iced/</code>或<code class="fe nz oa ob oc b">https://api.sampleapis.com/coffee/hot</code>获取数据。</li><li id="8cf6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第3-4行:将提取的原始数据转换成JSON。</li><li id="861b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第5行:然后将JSON数据注销到控制台。</li></ul><p id="6039" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，停留在<code class="fe nz oa ob oc b">Coffee.js</code>中，在<code class="fe nz oa ob oc b">useEffect</code>钩子中找到代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/9cb15e489fcc8199331fa05998300d31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bl-Y-B7C_kAiVESLYmCCeQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Coffee.js中要查找的代码</p></figure><p id="1d23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且像这样改变它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/0e9c39fb2ea0320a762b6c5f1d627c0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DgPFthaPYpHgVUHDgXB7XA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Coffee.js中替换为的代码</p></figure><ul class=""><li id="488e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第2行:在这里，组件一挂载，我们就调用<code class="fe nz oa ob oc b">fetchData</code>函数。</li></ul><p id="a813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行代码。这将是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/cab90e9eead6ce2003fb681a29f1fdec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/1*0gGSjevGtTAd0lGU7fPI2Q.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="5de0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里什么都没变。但是，打开控制台并查看输出。</p><p id="b060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是我们去<code class="fe nz oa ob oc b">/coffee/hot</code>时的控制台输出。<code class="fe nz oa ob oc b">type</code>参数为<code class="fe nz oa ob oc b">hot</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/1be72ce8c7ecd358ffe559f38e4c0c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bj0Tilcwl8hgH22Q4pN7AA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">控制台中的输出</p></figure><p id="baa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们导航到<code class="fe nz oa ob oc b">/coffee/iced</code>目录时的控制台输出。<code class="fe nz oa ob oc b">type</code>参数为<code class="fe nz oa ob oc b">iced</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/ca1401e5a969747fb1867d29c99f90e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h6muvY3AJl13uAplTsFbpQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">控制台中的输出</p></figure><p id="03bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们从API获得了一组对象。现在，我们将只从这些对象中提取<code class="fe nz oa ob oc b">title</code>字段。</p><p id="68b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nz oa ob oc b">Coffee.js</code>中，创建一个钩子，该钩子将被分配来自该API的数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/db2c199bacc20dd7f29ed7ee9b665b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AYhWhviGJkK3mFGYg_XMew.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用Coffee.js编写的代码</p></figure><p id="5696" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在在<code class="fe nz oa ob oc b">Coffee.js</code>中找到你的<code class="fe nz oa ob oc b">fetchData</code>功能:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/20cb49cf8cc3d8a713a6492e41c5fea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z5xauFPc037mHK_7_Ag7JA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Coffee.js中要查找的代码</p></figure><p id="8096" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并将其更改为下面这段代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/570a4c0cbe5671eda64f82e4f350393c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W4_NE5xMI6jkerDPtLeNOw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Coffee.js中替换为的代码</p></figure><ul class=""><li id="6456" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第5行:这里，我们将<code class="fe nz oa ob oc b">data</code>钩子的值设置为我们刚刚从Coffee API中获取的数据。</li></ul><p id="f86a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在在<code class="fe nz oa ob oc b">Coffee.js</code>中找到你的<code class="fe nz oa ob oc b">return</code>块:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/bf0b8dcb13fe2bf1eef82f2e0718fca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5XuJc1LTWzl3K-q4Va3DZQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Coffee.js中要查找的代码</p></figure><p id="8e86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后将其更改为以下代码块:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/a0a1fc6b4e787d6cffd58cc055640b7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VwfpmD8cbhEbqSQGvuft6Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Coffee.js中替换为的代码</p></figure><ul class=""><li id="2fd5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nz oa ob oc b">Line 3</code>:对<code class="fe nz oa ob oc b">data</code>数组的内容使用<code class="fe nz oa ob oc b">map</code>方法。这将遍历数组。</li><li id="46b3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第4行:输出数组中每个对象的<code class="fe nz oa ob oc b">title</code>字段。<code class="fe nz oa ob oc b">title</code>字段包含咖啡的名称。</li></ul><p id="fbec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行代码。这将是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/2653e0f8f547f080141f5378d7ca2056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/1*AGKr1aRoql7K5Paq6Lgn8A.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="2444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的代码有效。现在让我们将列表中的每一项都变成一个可点击的<code class="fe nz oa ob oc b">Link</code>元素。</p><p id="4c81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">找到我们刚刚写的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/a0a1fc6b4e787d6cffd58cc055640b7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VwfpmD8cbhEbqSQGvuft6Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Coffee.js中要查找的代码</p></figure><p id="2fd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样改变它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/1b48bbbbc1f737ae670829bdc7811861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8OsUCVLqcFbbuw1GdEeuXw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用Coffee.js编写的代码</p></figure><p id="30fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变化在第5行。</p><ul class=""><li id="7e02" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nz oa ob oc b">Line 5</code>:现在渲染列表中的每一项都会将用户导向<code class="fe nz oa ob oc b">/coffee/:type/:id</code>。这里，<code class="fe nz oa ob oc b">type</code>和<code class="fe nz oa ob oc b">id</code>是参数。我们已经提取了数组中每个对象的<code class="fe nz oa ob oc b">id</code>字段。</li></ul><p id="92a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将呈现一个单独的页面来显示每种咖啡的描述。</p><p id="403f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe nz oa ob oc b">Coffee.js</code>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="62fc" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">显示描述</h2><p id="29d3" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">让我们首先创建一个<code class="fe nz oa ob oc b">Route</code>组件，它将在用户导航到<code class="fe nz oa ob oc b">/coffee/:type/:id</code>目录时呈现一个组件。</p><p id="1822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到<code class="fe nz oa ob oc b">App.js</code>并找到您的<code class="fe nz oa ob oc b">return</code>块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="d190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在把它改成这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><ul class=""><li id="03b4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第10行:在这里，我们告诉React Router，如果用户前往<code class="fe nz oa ob oc b">/coffee/:type/:id</code>路线，就呈现<code class="fe nz oa ob oc b">CoffeeInfo</code>组件。在这一行上，<code class="fe nz oa ob oc b">type</code>和<code class="fe nz oa ob oc b">id</code>是参数。</li></ul><p id="022d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们创建<code class="fe nz oa ob oc b">CoffeeInfo</code>组件。创建一个名为<code class="fe nz oa ob oc b">CoffeeInfo.js</code>的新文件，并编写以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="df45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码与最初版本的<code class="fe nz oa ob oc b">Coffee.js</code>非常相似:</p><ul class=""><li id="bd6b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第4行:我们只是用<code class="fe nz oa ob oc b">useParams</code>钩子提取URL的参数，然后将它们存储在<code class="fe nz oa ob oc b">params</code>变量中。</li><li id="8a54" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第7行:记录组件安装后<code class="fe nz oa ob oc b">params</code>的结果。</li></ul><p id="4673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们在<code class="fe nz oa ob oc b">App.js</code>中导入这个文件。转到<code class="fe nz oa ob oc b">App.js</code>并导入<code class="fe nz oa ob oc b">CoffeeInfo.js</code>文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/0d228b8f0237ee96635942034f56b67b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jazCTN1ycZfU0nbM6uM0RQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在App.js中导入</p></figure><p id="027b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在运行代码。这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/4588a8c6ac5b1762bc619dff92bb721e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/1*5k7N2AqsXID65n-H2Uulqg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="0f59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有什么异常发生，但是我们在控制台的<code class="fe nz oa ob oc b">CoffeeInfo</code>文件中记录了参数值。看看你的控制台。这将是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/16b364be348ee28fb86ac75c0ab3521e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*13gJi9p0p9f0ap7sxUGM7w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">控制台中的输出</p></figure><p id="06b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！我们得到了参数的值。让我们现在使用它。</p><p id="e3f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nz oa ob oc b">CoffeeInfo.js</code>中，创建一个名为<code class="fe nz oa ob oc b">fetchData</code>的函数。在那里，编写以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/bf04d5c32be91d406ec7599b5d6bd984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*12kDgs_Z1mpfjWoqi8sqfA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要写入CoffeeInfo.js的代码</p></figure><ul class=""><li id="3051" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第2行:这里，我们从Coffee API获取数据。但是这一次，我们附加了参数的<code class="fe nz oa ob oc b">type</code>和<code class="fe nz oa ob oc b">id</code>值来获得想要的咖啡描述和名称。</li><li id="bb24" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第5行:将获取的数据输出到控制台。</li></ul><p id="a7be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行代码。这将是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/76010385e7dd5a3fa0763a401b606e65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/1*VxZQ7zYDCSzsAjvYTYnH1w.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="ee2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么都没变。但是看看控制台:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/2fd68483d2156e9217ebbacf1a99a223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*_re7BauG3wdwDZBMeUosOw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">控制台中的输出</p></figure><p id="196b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧啊。我们得到了想要的数据。</p><p id="d0ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为我们的最后一步，现在让我们向浏览器显示这些数据。</p><p id="61c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nz oa ob oc b">CoffeeInfo.js</code>中，声明两个钩子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/9f6ab9159b51a33cc5f17793ef75efd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PKBZrd9z2kHJSvd27_Wpfw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在CoffeeInfo.js中声明钩子</p></figure><ul class=""><li id="554b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nz oa ob oc b">data</code>钩子将存储提取的数据。</li><li id="a896" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nz oa ob oc b">ingredients</code>钩子将从获取的数据中存储<code class="fe nz oa ob oc b">ingredients</code>数组的内容。</li></ul><p id="db30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在转到<code class="fe nz oa ob oc b">CoffeeInfo</code>中的<code class="fe nz oa ob oc b">fetchData</code>函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/bf04d5c32be91d406ec7599b5d6bd984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*12kDgs_Z1mpfjWoqi8sqfA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在CoffeeInfo中查找的代码</p></figure><p id="d9bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样改变它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/4b68da5a87c37404240f4ccbff26f920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Lavu_iiWe11buQiQTiX_Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">CoffeeInfo.js中要替换的代码</p></figure><p id="6caf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第6行和第7行发生了变化:</p><ul class=""><li id="e86b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第6行:将获取的数据存储在<code class="fe nz oa ob oc b">data</code>钩子中。</li><li id="9729" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第7行:将取出的数据中的<code class="fe nz oa ob oc b">ingredients</code>数组存储到<code class="fe nz oa ob oc b">ingredients</code>钩子中。</li></ul><p id="d8c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们现在展示它。</p><p id="fb3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到您在<code class="fe nz oa ob oc b">CofeeInfo</code>中的<code class="fe nz oa ob oc b">return</code>块:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/90f73f026157886a8971d60e8dae5f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3VVp4fjibWEJhQKN0qMfOQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">CoffeeInfo.js中要查找的代码</p></figure><p id="42ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样改变它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><ul class=""><li id="91bd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第3-4行:显示提取数据的<code class="fe nz oa ob oc b">title</code>和<code class="fe nz oa ob oc b">description</code>值。</li><li id="d41f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第7行:因为<code class="fe nz oa ob oc b">ingredients</code>是一个数组，所以我们使用了<code class="fe nz oa ob oc b">map</code>函数。</li><li id="0378" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第8行:遍历<code class="fe nz oa ob oc b">ingredients</code>数组并显示它们的值。</li></ul><p id="a6d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行代码。这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/ec1d93e57afbeb98af639b4ebaf7785e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/1*bGdwL9HCchL83I3TgUhOAg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="a3f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的代码有效。</p><p id="4b4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，<code class="fe nz oa ob oc b">CoffeeInfo.js</code>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="a991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<code class="fe nz oa ob oc b">App.js</code>应该有的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="af07" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">构建水平导航条</h2><p id="09a9" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在本节中，我们现在将构建一个水平导航组件。这将有助于用户轻松浏览我们的网站。</p><p id="54b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，请转到<code class="fe nz oa ob oc b">Nav.js</code>并为您的<code class="fe nz oa ob oc b">ul</code>元素分配一个<code class="fe nz oa ob oc b">className</code>属性。</p><pre class="kj kk kl km gt ow oc ox oy aw oz bi"><span id="e13b" class="ni mr it oc b gy pa pb l pc pd">//change in Nav.js<br/>return (<br/>  &lt;&gt;<br/>    &lt;ul className="nav"&gt; &lt;/ul&gt;<br/>    {/* Further code..*/}</span></pre><p id="40d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，进入你的<code class="fe nz oa ob oc b">App.css</code>文件。在这里，附加以下代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><ul class=""><li id="f216" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第2行:我们的<code class="fe nz oa ob oc b">nav</code>组件应该有一个<code class="fe nz oa ob oc b">inline</code>的<code class="fe nz oa ob oc b">display</code>属性。这意味着React将在一行中呈现其子元素。</li><li id="14fe" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第6–8行:<code class="fe nz oa ob oc b">float</code>属性表示JavaScript将显示所有相邻的元素。后来，我们添加了一些填充，这样所有的元素之间就会有一些空间。这使得链接更容易点击。</li></ul><p id="333d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/b38d4e5a929454676e4621b3f617447b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/1*7HS9A9eSbPGKMVi4X0ZTQw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="d5ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们完事了。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="e648" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">GitHub链接和其他资源</h1><h2 id="3b2b" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">GitHub链接</h2><p id="dba9" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated"><a class="ae ky" href="https://github.com/HussainArif12/react-router-tutorial" rel="noopener ugc nofollow" target="_blank">本项目回购</a></p><h2 id="e625" class="ni mr it bd ms nj nk dn mw nl nm dp na li nn no nc lm np nq ne lq nr ns ng nt bi translated">其他阅读资源</h2><ul class=""><li id="7835" class="lv lw it lb b lc nu lf nv li pf lm pg lq ph lu ma mb mc md bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=Law7wfdg_ls" rel="noopener ugc nofollow" target="_blank"> React路由器教程—开发版</a></li><li id="2bea" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=yQf1KbGiwiI" rel="noopener ugc nofollow" target="_blank">5分钟内反应路由器—詹姆斯·奎克</a></li><li id="612e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://reactrouter.com/web/api/Hooks/useparams" rel="noopener ugc nofollow" target="_blank">反应路由器</a>T5】</li><li id="90e8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://reactjs.org/docs/lists-and-keys.html" rel="noopener ugc nofollow" target="_blank">反应列表和键</a>(显示数组内容的指南)</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="1389" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="9c5f" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">如果您在本教程中遇到了任何问题，那么请仔细研究代码，全面掌握React路由器的内部工作原理。不要放弃！</p><p id="97a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇教程绝不是一篇短文。恭喜你坚持到最后！我希望你学到了很多。感谢阅读！</p><p id="3fa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一篇:<a class="ae ky" href="https://medium.com/better-programming/the-complete-guide-to-using-graphql-in-node-js-with-apollo-server-aef347a7a0ee" rel="noopener">在Node.js中使用GraphQL与Apollo Server的完整指南</a> <br/>上一篇:<a class="ae ky" href="https://medium.com/javascript-in-plain-english/build-a-react-pomodoro-app-with-material-ui-and-tailwindcss-e4bab98e30ae" rel="noopener">用TailwindCSS和Material UI构建一个React Pomodoro应用</a></p></div></div>    
</body>
</html>