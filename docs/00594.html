<html>
<head>
<title>Sync Your State in Local Storage With NgRx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用NgRx同步本地存储中的状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sync-your-state-in-local-storage-with-ngrx-9d6ceba93fc0?source=collection_archive---------0-----------------------#2019-06-17">https://betterprogramming.pub/sync-your-state-in-local-storage-with-ngrx-9d6ceba93fc0?source=collection_archive---------0-----------------------#2019-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e0c5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何创建一种通用的可配置机制，用于将部分应用程序状态持久化和重新组合到本地存储中。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/41775945325458cfffc0e7abe1a88d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fJEnn8n2ICffDeMGW8LvJg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@grohsfabian" rel="noopener ugc nofollow" target="_blank"> Fabian Grohs </a>在<a class="ae kv" href="https://unsplash.com/photos/TUnXXhb2-a8" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8144" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当开发一个应用程序时，我们自然会考虑尽可能构建最佳的用户体验。确保我们的应用程序在重新启动时返回到之前的状态，维护用户偏好，以及支持离线支持只是我们希望包含在应用程序中的一小部分功能。</p><p id="4f37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这段代码中，我们将有效地将应用程序的一些状态保存到<strong class="ky ir"> </strong> <code class="fe ls lt lu lv b">localStorage</code> <strong class="ky ir"> </strong>中，并在刷新后恢复它。然后，我们将构建一个通用机制，使我们不仅能够保存状态的一部分，而且能够配置它，同时还支持延迟加载特性。</p><h2 id="73f8" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">设置和库</h2><p id="1f12" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">对于该解决方案，我使用了以下技术:</p><ul class=""><li id="5ee4" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated"><a class="ae kv" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank">有角7+ </a></li><li id="fd89" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://ngrx.io/guide/store" rel="noopener ugc nofollow" target="_blank"> NgRx 7+ </a></li><li id="b574" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://www.npmjs.com/package/lodash-es" rel="noopener ugc nofollow" target="_blank">Lodash-es</a>—Lodash的树摇动版本</li></ul><h2 id="cdfe" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">基本解</h2><p id="1545" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">假设我们的应用程序中有多个自定义主题，我们希望我们的应用程序在页面重新加载后保留用户的偏好。为此，我们将创建一个新的<code class="fe ls lt lu lv b">layoutState</code>，它将在<code class="fe ls lt lu lv b">localStorage</code>中维护。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9b63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了捕捉每一个变化的新状态，我们想要挂钩每一个用户动作<em class="nk">。</em>对于那个<em class="nk">，</em>我们就用<code class="fe ls lt lu lv b">metaReducer</code>。</p><h2 id="1591" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">元还原剂</h2><p id="1b79" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">元缩减器(也称为高阶缩减器)是一个函数，它接受一个缩减器函数作为输入参数，并返回一个新的缩减器函数作为结果。它的基本特征如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e29b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以把它想象成一个减少动作的管道。</p><p id="ef6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解更多关于元减速器的信息，我推荐阅读来自<em class="nk"> ngrx.io </em>的<a class="ae kv" href="https://ngrx.io/guide/store/metareducers" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h2 id="d011" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">履行</h2><p id="8c14" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">为了拯救和恢复我们国家的一部分，我们需要:</p><ul class=""><li id="60e8" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">定义我们将保存和恢复的密钥。</li><li id="6331" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">将存储的状态恢复并合并到初始状态。</li><li id="e7bf" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">为每个状态变化选择这些键并保存它们。</li></ul><p id="3a5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们首先创建一个文件<code class="fe ls lt lu lv b">storage.metareducer.ts</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7f3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，要在我们的商店中使用我们的<code class="fe ls lt lu lv b">storageMetaReducer</code>，我们需要将它添加到<code class="fe ls lt lu lv b">app.module.ts</code>中的<code class="fe ls lt lu lv b">storeConfig</code>,如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/6839346206139e3bfba6e473cb54203a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6Ouv49UivKKuFeK8aGy2mg.gif"/></div></div></figure><h2 id="e903" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">通用解决方案</h2><p id="da42" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">到目前为止还不错，但是随着我们应用程序的增长，我们将自然地把状态分解成特性，我们希望能够为每个特性使用<code class="fe ls lt lu lv b">metaReducer</code>。</p><p id="08f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，让我们的<code class="fe ls lt lu lv b">metaReducer</code>通用。每个功能模块都会为<code class="fe ls lt lu lv b">metaReducer</code>设置自己的<strong class="ky ir"> </strong>配置，其中包含<code class="fe ls lt lu lv b">storageKey</code>、<code class="fe ls lt lu lv b">stateKeys</code>和一个外部<code class="fe ls lt lu lv b">localStorage</code>服务。这样，我们可以将我们的<code class="fe ls lt lu lv b">metaReducer</code>绑定到正确的特性模块。我们将通过角度依赖注入来实现。</p><p id="5fe7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们首先创建一个新的<code class="fe ls lt lu lv b">app.tokens.ts</code>文件，我们将在其中定义我们的令牌:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0a74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将创建<code class="fe ls lt lu lv b">LocalStorageService</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="cc87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将创建一个工厂函数，使用NgRx的<code class="fe ls lt lu lv b">META_REDUCERS</code>令牌将其配置传递给<code class="fe ls lt lu lv b">metaReducer</code>。</p><p id="ea27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我们需要为模块的提供者中的<code class="fe ls lt lu lv b">ROOT_STORAGE_KEYS</code>和<code class="fe ls lt lu lv b">ROOT_LOCAL_STORAGE_KEY</code>标记提供值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f5bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是<code class="fe ls lt lu lv b">metaReducer</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="62f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们已经使<code class="fe ls lt lu lv b">metaReducer</code>可配置，让我们将它用于我们的惰性加载特性。</p><p id="d32a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有一个按级别显示课程列表的应用程序，允许用户查看、注册和更改课程。在这种情况下，我们希望保留显示的课程列表和用户最后选择的级别。</p><p id="804f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们的状态:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="3ed3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并使用以下标记添加新的<code class="fe ls lt lu lv b">courses.tokens</code>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7712" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后但同样重要的是，这是我们的课程特色模块:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="c36e" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">摘要</h2><p id="22a8" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">我们创建了一个通用的元缩减器来获取一个配置，并使用它来保存一些从状态中选择的部分。</p><p id="ec72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们简单地演示了应用程序如何总是显示最新用户的应用程序状态，即使是在刷新之后。当然，这可以用于与服务器同步信息、离线支持和大量其他功能，所有这些都是为了改善用户体验。</p><p id="2999" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常感谢<a class="ae kv" href="https://medium.com/@timdeschryver" rel="noopener">蒂姆·德施里弗</a>和<a class="ae kv" href="https://twitter.com/BarkiNoaa" rel="noopener ugc nofollow" target="_blank">诺亚·巴克利</a>帮助我写这篇文章。</p><p id="e211" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章中使用的所有代码示例都可以在<a class="ae kv" href="https://github.com/itayod/sync-state-blog" rel="noopener ugc nofollow" target="_blank">这个库</a>中找到。</p></div></div>    
</body>
</html>