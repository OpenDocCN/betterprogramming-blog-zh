<html>
<head>
<title>4 Simple and Effective Ways To Avoid Too Many Ifs With TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript避免太多if的4种简单有效的方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-simple-and-effective-ways-to-avoid-too-many-ifs-with-typescript-89937c0f9a99?source=collection_archive---------1-----------------------#2021-09-21">https://betterprogramming.pub/4-simple-and-effective-ways-to-avoid-too-many-ifs-with-typescript-89937c0f9a99?source=collection_archive---------1-----------------------#2021-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3f88" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">If…else还不错——过度使用才是</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/795b8540eff3e2d4994aa0be1c30a1cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*igV9dW6Ciq6w2JEiLcrwQQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@ilyapavlov?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">伊利亚·巴甫洛夫</a>在<a class="ae ky" href="https://unsplash.com/s/photos/coding-complexity?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c875" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">If…else存在于所有编程语言中。如果使用得当，它们并不是坏习惯。这是一种简单、易于理解、灵活的逻辑控制结构。</p><p id="25dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但在现实中，它经常被过度使用。在下列情况下，它们可能是坏的:</p><ul class=""><li id="4ecb" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">嵌套if-else或多层嵌套(更糟)</li><li id="94b4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">太多的if-else会导致大量的条件分支</li><li id="13dc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">具有混合标志的复杂条件语句</li></ul><p id="d118" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">if…else的过度使用是代码气味。这使得你的代码库难以阅读和维护，因为要考虑更多的分支路径。</p><p id="b56b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为开发人员，我们总是期待通过重构来改进代码。在本文中，我们将在TypeScript的上下文中介绍四种不同的方法。</p><p id="21e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向前跳:</p><ul class=""><li id="dcbc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="#377c" rel="noopener ugc nofollow">守护和提前返回</a></li><li id="83ee" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#87a7" rel="noopener ugc nofollow">表格驱动法</a></li><li id="9313" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#0026" rel="noopener ugc nofollow">提取</a></li><li id="9703" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="http://283e" rel="noopener ugc nofollow" target="_blank">默认值和||运算符</a></li><li id="ae75" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#b519" rel="noopener ugc nofollow">关注根本原因</a></li></ul><h1 id="377c" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">1.守卫和早归</h1><p id="3833" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><strong class="lb iu">问题</strong>:在这个嵌套的<code class="fe ng nh ni nj b">if...else</code>代码片段中，跟随<code class="fe ng nh ni nj b">status</code>值的变化可能是一个挑战。即使在这个简化的例子中，控制流也不是简单明了的。您可以想象，当添加更多的条件逻辑时，代码会迅速增长到难以维护的状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d01b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解</strong> : <a class="ae ky" href="https://refactoring.guru/replace-nested-conditional-with-guard-clauses" rel="noopener ugc nofollow" target="_blank">守</a>早退是我最喜欢的重构方法。它实施起来很简单，并能给你带来立竿见影的效果。</p><p id="843a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码中，我们将边缘情况移到函数的开头。我们还将嵌套的if简化为带有三元运算符的平面语句。当满足边缘情况条件时，立即返回错误状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a541" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重构后，代码变成线性的。早期返回首先处理失败案例，使代码更容易测试，更不容易出错。结果是更好的可读性和更好的可维护性。</p><p id="aae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种类似的方式是使用包含验证逻辑的“数据保护”<a class="ae ky" href="https://sunnysun-5694.medium.com/how-to-map-rest-api-data-using-decorator-pattern-in-angular-6-94eb49ba16b1" rel="noopener">装饰器</a>。main函数只有在验证通过后才会被调用。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="87a7" class="mj mk it bd ml mm nt mo mp mq nu ms mt jz nv ka mv kc nw kd mx kf nx kg mz na bi translated">2.表格驱动方法</h1><p id="f68a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><strong class="lb iu">问题</strong>:下面的代码片段的意图是获取一个月的天数。显然，它容易出错，而且很难改变。例如，如果我们在闰年需要支持会发生什么？这将是一场维护噩梦。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3a2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解决方案</strong>:我们使用<a class="ae ky" href="https://rads.stackoverflow.com/amzn/click/com/0735619670" rel="noopener ugc nofollow" target="_blank">表格驱动的方法</a>来改进上面的代码片段。</p><blockquote class="ny nz oa"><p id="71ee" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">表驱动方法是允许您在表中查找信息而不是使用逻辑语句(例如，case、if)的方案。—开发到</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ff1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们定义了一个数组<code class="fe ng nh ni nj b">monthDays </code>,它映射了一个月的可能值。结果更加简洁，可读性更好。请注意，当输入参数互斥时，这种方法更合适。</p><p id="7386" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样的方法可以应用于一组函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4899" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码示例中，<code class="fe ng nh ni nj b">performAction </code>函数包含多个if。当需要添加更多的动作时，很难扩展。我们使用<code class="fe ng nh ni nj b">funcs </code> <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/typescripts-record-type-explained-691372b1a449">记录类型</a>来映射<code class="fe ng nh ni nj b">actionName </code>匹配函数。这样我们就避免了多个if，并且它可以很容易地扩展到附加的动作。</p><p id="8c17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表驱动方法的应用不仅仅是一对一的键值映射。在下面的示例中，ifs语句用于根据给定的分数范围进行评级。如何重构这个方法？</p><pre class="kj kk kl km gt of nj og bn oh oi bi"><span id="d705" class="oj mk it nj b be ok ol l om on">  getRating(score: number) {<br/>    if (score &gt; 12) {<br/>      return 5;<br/>    } else if (score &gt; 9) {<br/>      return 4;<br/>    } else if (score &gt; 6) {<br/>      return 3;<br/>    } else if (score &gt; 3) {<br/>      return 2;<br/>    } else {<br/>      return 1;<br/>    }<br/>  }</span></pre><p id="6f21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe ng nh ni nj b">Object.keys</code>应用表格驱动方法，如下所示:</p><pre class="kj kk kl km gt of nj og bn oh oi bi"><span id="4a08" class="oj mk it nj b be ok ol l om on">  getRating(score: number) {<br/>    const ratingScoreMap = {<br/>      12: 5,<br/>      9: 4,<br/>      6: 3,<br/>      3: 2,<br/>      1: 1<br/>    };<br/>    const sortedRating = Object.keys(ratingScoreMap)<br/>      .map(Number)<br/>      .sort((a, b) =&gt; b - a);<br/>    for (const threshold of sortedRating) {<br/>      if (score &gt; Number(threshold)) {<br/>        return ratingScoreMap[threshold];<br/>      }<br/>    }<br/>    return 1;<br/>  }</span></pre><p id="7397" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用查找表来存储映射关系，表驱动的方法允许在各种上下文中进行高效和灵活的值映射。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="0026" class="mj mk it bd ml mm nt mo mp mq nu ms mt jz nv ka mv kc nw kd mx kf nx kg mz na bi translated">3.提取</h1><p id="9ca7" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><strong class="lb iu">问题</strong>:只要可读，复杂的条件不是问题。下面的例子包含一个嵌套的复杂的<code class="fe ng nh ni nj b">if</code>条件语句。很难搞清楚是什么状况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="406c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解决方案</strong>:extract方法是一种将条件逻辑重构为更模块化形式的方法。在下面的代码片段中，我们使用extract方法来重构上面的示例。</p><p id="e8b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嵌套ifs中的多重检查被包装到一个单独的函数中，并有一个有意义的名称。嵌套的if由一个带有简单条件函数的if代替。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">改进后的版本更容易理解和更改。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="283e" class="mj mk it bd ml mm nt mo mp mq nu ms mt jz nv ka mv kc nw kd mx kf nx kg mz na bi translated">4.默认值和<code class="fe ng nh ni nj b">||</code>运算符</h1><p id="4d59" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><strong class="lb iu">问题</strong>:下面的<code class="fe ng nh ni nj b">if..else</code>用于执行空值检查，但是代码过于复杂，可读性不强。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0f8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解决方案</strong>:给参数一个默认值是我个人喜欢的另一种重构方法。</p><p id="7fef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认值结合<code class="fe ng nh ni nj b">||</code>操作符是降低代码复杂度的一种简单有效的方法。</p><p id="c955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们给状态一个默认值，并使用<code class="fe ng nh ni nj b">||</code>操作符来处理空检查。得益于JavaScript的灵活性，结果是代码重复更少，代码更可读。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="b519" class="mj mk it bd ml mm nt mo mp mq nu ms mt jz nv ka mv kc nw kd mx kf nx kg mz na bi translated">关注根本原因</h1><p id="e6e0" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">过度使用<code class="fe ng nh ni nj b">if…else</code>可能是其他问题的征兆。当致力于重构时，我们应该关注根本原因，而不是仅仅修复症状。</p><p id="1b88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个函数由输入、内部状态和输出组成。该函数接受输入参数，执行内部状态突变，并返回输出结果。if的过度使用..否则可能是以下原因造成的:</p><ul class=""><li id="63a8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">内部状态逻辑过多</strong>:以上四种方法都可以用来改进代码。</li><li id="68dd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">带有混合标志的复杂输入参数</strong>:在这种情况下，默认值方法可能会有所帮助。但根本原因可能是函数接口抽象。我们可能需要回顾和改进抽象。</li><li id="d52d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">太多不同的返回路径和复杂的输出</strong>:这是该函数可能正在做太多事情的迹象。重点应该是重构函数，而不是减少if..else语句。</li></ul><p id="10fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了做一个干净的重构，我们应该专注于制定一个清晰的接口，以便函数只做一件事情。(<a class="ae ky" href="https://en.wikipedia.org/wiki/Single-responsibility_principle#:~:text=The%20single%2Dresponsibility%20principle%20(SRP,it%20should%20encapsulate%20that%20part.&amp;text=Hence%2C%20each%20module%20should%20be%20responsible%20for%20each%20role." rel="noopener ugc nofollow" target="_blank">单一责任原则</a>)。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="79fc" class="mj mk it bd ml mm nt mo mp mq nu ms mt jz nv ka mv kc nw kd mx kf nx kg mz na bi translated">摘要</h1><p id="7146" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们讨论了四种简单有效的方法来消除if…else的过度使用。应用这些方法将帮助您编写更清晰、更易读的代码。</p><p id="4a95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有其他方法来重构if..否则，像使用<a class="ae ky" href="https://medium.com/codex/factory-pattern-type-script-implementation-with-type-map-ea422f38862" rel="noopener">工厂模式</a>或责任链模式。本文没有涉及它们，因为我想把重点放在更简单、更实用的解决方案上。</p><p id="9f05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有放之四海而皆准的解决方案，因为每种方法都有自己的优缺点。为特定工作选择合适工具的能力将顶级开发人员与普通开发人员区分开来。</p><p id="de7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，你可能也喜欢阅读另一篇打字稿文章。</p><div class="oo op gp gr oq or"><a rel="noopener  ugc nofollow" target="_blank" href="/apply-builder-pattern-to-generate-query-filter-in-typescript-651a6b13da38"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">应用生成器模式在TypeScript中生成查询筛选器</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">实现一个不可变的强类型过滤器生成器</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">better编程. pub</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div><p id="0fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编程快乐！</p></div></div>    
</body>
</html>