<html>
<head>
<title>The Ultimate Docker Command List</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">终极Docker命令列表</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-ultimate-docker-command-list-d98ef300fe6d?source=collection_archive---------7-----------------------#2020-03-17">https://betterprogramming.pub/the-ultimate-docker-command-list-d98ef300fe6d?source=collection_archive---------7-----------------------#2020-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="90a3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Docker命令的精选列表，可以节省您调试和查找堆栈溢出的时间</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8f9ad4ae515372c62f1ae530765f40f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iE5NxLhVgf2WgyNHij4lZQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@grzegorzwalczak?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Grzegorz Walczak </a>的照片</p></figure><h1 id="b5c9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">目录</h1><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="3cb5" class="lw la it ls b gy lx ly l lz ma">#1. Docker Build<br/>#2. Running Docker Containers<br/>#3. Debugging Docker Containers<br/>  ○ Docker on AWS ECS<br/>#4. Cleaning Up Docker Images<br/>#5. Pulling Docker Images from a Remote Registry<br/>#6. Exporting and Importing Physical Docker Images<br/>#7. Final Thoughts</span></pre></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="7774" class="kz la it bd lb lc mi le lf lg mj li lj jz mk ka ll kc ml kd ln kf mm kg lp lq bi translated">介绍</h1><p id="f428" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">Docker容器已经从一项小众技术转变为我们环境中的绝对必需品。有时候，作为开发人员，我们花了大量的时间来调试或使用本该帮助我们提高工作效率的工具。每一次新的技术浪潮，都有数量惊人的移动部件需要学习。</p><p id="a19e" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">你们中有多少人花了一两天的时间来尝试安装Docker集群，或者得到了一段使Docker容器无法启动的代码？对于大多数开发人员来说，很多时间都花在了与配置的协商上——寻找bug似乎比实际推出新功能花费的时间还要多，尤其是当您工作的环境相对较新或不成熟的时候。</p><p id="a5f2" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">我们中的一些人没有幸运地拥有稳定的CI/CD流程环境。对于那些属于这个阵营的人，这篇文章是给你的。这篇文章成了经验的副产品。就像你一样，我也经历了几天的调试。这篇文章旨在补充Docker主要技术文档网站上的资料，同时也侧重于您在日常使用Docker时最有可能与之交互的常见命令。</p><p id="d0a9" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">有关全面可选标志和参数的更详细列表，请参考Docker <a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/cli/" rel="noopener ugc nofollow" target="_blank">手册</a>。请注意，根据您的Docker系统配置，您可能需要在每个<code class="fe no np nq ls b">docker </code>命令前加上<code class="fe no np nq ls b">sudo</code>。</p><p id="01f8" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated"><strong class="mp iu">提示:</strong>每个Docker命令都有内置文档。学会使用它。键入<code class="fe no np nq ls b">docker run --help</code>将生成以下帮助文档。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/215f0da648440164a4dfc4957fb4cb6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXUMqPH3PvOEUfGhM3BjQw.png"/></div></div></figure><p id="3900" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">我希望这篇指南能帮助你在调试和使用Docker的兔子洞的战壕中导航。阅读命令时，请注意命令附带的解释。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="d458" class="kz la it bd lb lc mi le lf lg mj li lj jz mk ka ll kc ml kd ln kf mm kg lp lq bi translated">码头工人建造</h1><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="1249" class="lw la it ls b gy lx ly l lz ma">$ docker build \<br/>--build-arg ARTIFACTORY_USERNAME=timothy.mugayi \<br/>--build-arg ARTIFACTORY_SECRET_TOKEN=AP284233QnYX9Ckrdr7pUEY1F \<br/>--build-arg LICENSE_URL='<a class="ae ky" href="https://math-engine-qed.s3.amazonaws.com/app/GAMS/license/dev/gamslice.txt?AWSAccessKeyId=AKIA4H32CCVXJWXVR7HA&amp;Signature=%2BEwLxP0NS8LsdculF8a72HKPUIs%3D&amp;Expires=1614488484'" rel="noopener ugc nofollow" target="_blank">https://source.com/license.txt'</a> \<br/>--no-cache  -t helloworld:latest .</span></pre><p id="c09e" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">这将用可选的构建参数构建一个Docker映像。Docker将默认缓存docker文件的第一次构建或后续构建的结果，这些结果基于通过docker文件中的<code class="fe no np nq ls b">run</code>命令添加到图像的新层，从而使后续构建更快。</p><p id="c6c5" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">如果您不需要这样做，您可以附加一个无缓存参数，就像我们在上面的示例中所做的那样。如果您想了解如何在构建过程中使用ARGs和Docker环境变量，您可以阅读我的另一篇文章</p><div class="ns nt gp gr nu nv"><a href="https://medium.com/better-programming/how-to-get-docker-to-play-nicely-with-your-python-data-science-packages-81d16f1080d2" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">如何让Docker很好地使用您的Python数据科学包</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">数据科学项目分类指南</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ks nv"/></div></div></a></div><p id="8d52" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">注意:Docker命令可以通过名称或Docker容器ID来执行。<code class="fe no np nq ls b">&lt;CONTAINER&gt;</code>可与集装箱ID或集装箱名称互换。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="cb75" class="kz la it bd lb lc mi le lf lg mj li lj jz mk ka ll kc ml kd ln kf mm kg lp lq bi translated">运行码头集装箱</h1><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="8bd6" class="lw la it ls b gy lx ly l lz ma">$ docker start &lt;CONTAINER&gt;</span></pre><p id="2fb5" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">启动现有容器。我们假设已经下载并创建了容器。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="b635" class="lw la it ls b gy lx ly l lz ma">$ docker stop &lt;CONTAINER&gt;</span></pre><p id="b936" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">停止现有正在运行的Docker容器。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="c6d9" class="lw la it ls b gy lx ly l lz ma">$ docker stop $(docker container ls -aq)</span></pre><p id="b4a1" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">如果你有多个Docker容器在运行，并且你希望停止所有的容器，输入<code class="fe no np nq ls b">docker stop</code>和所有容器id的列表。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="6b14" class="lw la it ls b gy lx ly l lz ma">$ docker exec -ti &lt;CONTAINER&gt; [COMMAND]</span></pre><p id="6bbe" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">在特定容器中运行shell命令。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="fbda" class="lw la it ls b gy lx ly l lz ma">$ docker run -ti — image &lt;IMAGE&gt; &lt;CONTAINER&gt; [COMMAND]</span></pre><p id="0eb4" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">码头工人<code class="fe no np nq ls b">run</code>和<code class="fe no np nq ls b">start</code>之间有着非常明显的区别。Docker <code class="fe no np nq ls b">run</code>本质上做了两件事:(1)创建一个图像的新容器，以及(2)执行该容器。如果你想重新运行一个失败或退出的容器，那么使用<code class="fe no np nq ls b">docker start</code>命令。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="d6fa" class="lw la it ls b gy lx ly l lz ma">$ docker run -ti — rm — image &lt;IMAGE&gt; &lt;CONTAINER&gt; [COMMAND]</span></pre><p id="f46b" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">这是一个有趣的命令，用于同时创建和启动一个容器。它还在其中运行一个命令，然后在执行完命令后删除容器。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="9d80" class="lw la it ls b gy lx ly l lz ma">docker run -d  &lt;IMAGE&gt;:&lt;IMAGE_TAG&gt;</span><span id="4a67" class="lw la it ls b gy ok ly l lz ma">Usage: <br/>   docker run -d  helloworld:latest</span></pre><p id="40f5" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">如果您希望在分离状态下启动<code class="fe no np nq ls b">docker run</code>命令——例如，作为后台的Linux守护进程——您可以将<code class="fe no np nq ls b">-d</code>添加到<code class="fe no np nq ls b">run</code>命令中。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="3a57" class="lw la it ls b gy lx ly l lz ma">$ docker pause &lt;CONTAINER&gt;</span></pre><p id="e41a" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">暂停特定容器中运行的所有进程。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="b295" class="lw la it ls b gy lx ly l lz ma">$ docker ps -a</span></pre><p id="fcea" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">上面的命令列出了以前运行过的所有Docker映像。一旦确定了要运行的映像，请执行下面的命令。确保更改容器ID，以反映初始<code class="fe no np nq ls b">docker ps -a</code>命令显示的结果。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="ade9" class="lw la it ls b gy lx ly l lz ma">$ sudo docker run {container ID} -e AWS_DEFAULT_REGION=us-east-1 \<br/>e INPUT_QUEUE_URL="<a class="ae ky" href="https://sqs.us-east-1.amazonaws.com/my_input_sqs_queue.fifo" rel="noopener ugc nofollow" target="_blank">https://sqs.us-east-1.amazonaws.com/my_input_sqs_queue.fifo</a>" \<br/>e REDIS_ENDPOINT="redis.dfasdf.0001.cache.amazonaws.com:8000" \<br/>e ENV=dev \<br/>e DJANGO_SETTINGS_MODULE=engine.settings \<br/>e REDIS_HOST="cmgadsfv7avlq.us-east-1.redis.amazonaws.com" \<br/>e REDIS_PORT=5439 \<br/>e REDIS_USER=hello \<br/>e REDIS_PASSWORD=trasdf**#0ynpXkzg</span></pre><p id="0008" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">上面的命令演示了如何运行一个Docker映像，其中多个环境变量作为参数传入，其中<code class="fe no np nq ls b">\</code>是一个换行符。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="5a8b" class="lw la it ls b gy lx ly l lz ma">$ docker run -p &lt;host_<!-- -->public_port<!-- -->&gt;:&lt;container_port&gt;</span></pre><p id="8598" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">如果你发现自己不得不暴露码头。run命令采用参数p进行端口转发。其中<code class="fe no np nq ls b">host_</code> public_port是您希望docker转发container_port的机器端口。对于多个端口，附加另一个-p参数。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="b149" class="lw la it ls b gy lx ly l lz ma">$ docker run -p &lt;host_<!-- -->public_port1<!-- -->&gt;:&lt;container_port1&gt; -p &lt;host_<!-- -->public_port2<!-- -->&gt;:&lt;container_port2&gt;</span></pre></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="fac0" class="kz la it bd lb lc mi le lf lg mj li lj jz mk ka ll kc ml kd ln kf mm kg lp lq bi translated">调试Docker容器</h1><p id="f5bd" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">使用<code class="fe no np nq ls b">docker ps</code>获取当前正在运行的现有容器的名称。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="954f" class="lw la it ls b gy lx ly l lz ma">$ docker history &lt;IMAGE&gt; </span><span id="2666" class="lw la it ls b gy ok ly l lz ma">example usage:</span><span id="a5e4" class="lw la it ls b gy ok ly l lz ma">$ docker history my_image_name</span></pre><p id="7be3" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">显示特定图像的历史。当您想要深入了解并详细了解Docker图像的形成过程时，这些信息非常有用。让我们暂时离开这个话题，因为有必要真正理解这个命令的作用。关于司令部的文献很少。</p><p id="a1c5" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">当我们谈论Docker时，图像是建立在层之上的，层是Docker图像的构建块。每个容器都由一个带有可读/写层的图像组成，可以把它想象成一个持久化的状态或文件。在此之上，附加了其他只读层。当Docker文件中的命令被执行时，这些层(也称为<em class="ol">中间图像</em>)被生成。</p><p id="33ab" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">如果您在docker文件中有一个<code class="fe no np nq ls b">from</code>、<code class="fe no np nq ls b">run</code>和/或<code class="fe no np nq ls b">copy</code>指令，然后有<code class="fe no np nq ls b">build</code>个图像，那么这个<code class="fe no np nq ls b">run</code>指令将导致创建一个具有自己的图像ID的层。该图像/图层将显示在<code class="fe no np nq ls b">docker history</code>下，带有图像ID和图像创建日期。后续指令将导致另一个条目，以此类推。<code class="fe no np nq ls b">CREATED BY</code>列将大致对应于Dockerfile文件中的一行，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/ff51edc5a09ca17401dcd02b3602a7a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yd1NLlGGi-LYnZCsK-cCZw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“停靠历史”命令的图示</p></figure><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="9739" class="lw la it ls b gy lx ly l lz ma"><strong class="ls iu">$</strong> docker images</span></pre><p id="1ac9" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">列出当前存储在机器上的所有图像。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="90c4" class="lw la it ls b gy lx ly l lz ma">$ docker inspect &lt;IMAGE|CONTAINER ID&gt;</span></pre><p id="33b1" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">Docker <code class="fe no np nq ls b"><a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/inspect/" rel="noopener ugc nofollow" target="_blank">inspect</a></code>显示关于特定Docker对象的底层信息。存储在该对象中的数据在调试情况下非常有用，例如，交叉检查Docker挂载点。</p><p id="feb7" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">请注意:该命令获取两个主要响应——图像级别的详细信息和容器级别的详细信息。您可以从该命令中获得一些启示:</p><ul class=""><li id="b6a4" class="on oo it mp b mq nj mt nk mw op na oq ne or ni os ot ou ov bi translated">创建时的容器ID和时间戳</li><li id="6c5b" class="on oo it mp b mq ow mt ox mw oy na oz ne pa ni os ot ou ov bi translated">当前状态(在尝试确定容器是否停止以及停止的原因时很有用)</li><li id="d371" class="on oo it mp b mq ow mt ox mw oy na oz ne pa ni os ot ou ov bi translated">Docker映像信息、文件系统绑定和卷信息，以及挂载</li><li id="4005" class="on oo it mp b mq ow mt ox mw oy na oz ne pa ni os ot ou ov bi translated">环境变量—例如，传递到容器中的命令行参数</li><li id="538f" class="on oo it mp b mq ow mt ox mw oy na oz ne pa ni os ot ou ov bi translated">网络配置:IP地址和网关以及IPv4和IPv6的辅助地址</li></ul><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="5049" class="lw la it ls b gy lx ly l lz ma">$ docker version</span></pre><p id="b181" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">显示Docker的版本包括当前安装在机器上的客户机和服务器版本。</p><p id="8a80" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">是的，你基本上没看错。Docker是一个客户端-服务器应用程序。守护进程(长期运行的Linux后台服务)是服务器，CLI是众多客户机中的一个。Docker守护进程公开了一个REST API，许多不同的工具可以通过这个API与守护进程进行对话。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Docker版本输出</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/b1643ceeca15809f0e19dbddfa1b159e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ak77rzdczx8hXNnfXNcwKg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这里有一个客户机-服务器架构是如何设置的图像</p></figure><h2 id="6553" class="lw la it bd lb pe pf dn lf pg ph dp lj mw pi pj ll na pk pl ln ne pm pn lp po bi translated">AWS ECS上的Docker</h2><p id="6e6d" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">一般来说，有时您需要进入一个正在运行的Docker容器来调试或交叉检查配置是否正确。</p><p id="6e5e" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">使用命令<code class="fe no np nq ls b">docker exec -it &lt;container ID&gt; /bin/bash</code>获得shell访问权限。如果您发现自己试图查找一个无法运行的Docker映像，例如，如果您正在使用AWS ECS集群，您会得到一个模糊的错误消息，如下所示。</p><p id="af8f" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">老实说，这可能是由许多事情引起的，例如(1)您的代码有问题——例如，抛出了一个未捕获的异常，并且您的Docker容器在启动时死亡，(2)如果您在EC2实例上使用ECS集群，磁盘空间不足——也就是说，如果您没有使用ECS放置类型<a class="ae ky" href="https://aws.amazon.com/fargate/" rel="noopener ugc nofollow" target="_blank"> Fargate，</a>或者(3)您现有的Docker容器超出了您的EC2可用内存。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="3f3d" class="lw la it ls b gy lx ly l lz ma">Essential container in task exited</span></pre><p id="1b40" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">执行下面的命令来识别最近运行失败的Docker容器。如果您的帐户有<code class="fe no np nq ls b">sudo</code>权限，请省略<code class="fe no np nq ls b">sudo</code>。对于给定的输出，使用它来重新运行容器，以查看失败的原因。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="824f" class="lw la it ls b gy lx ly l lz ma">$ sudo docker ps -a --filter status=dead --filter status=exited --last 1</span></pre><h2 id="298b" class="lw la it bd lb pe pf dn lf pg ph dp lj mw pi pj ll na pk pl ln ne pm pn lp po bi translated">如有疑问，请重新启动Docker服务</h2><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="d765" class="lw la it ls b gy lx ly l lz ma">$ sudo service docker stop</span><span id="2790" class="lw la it ls b gy ok ly l lz ma">$ sudo service docker start</span><span id="14a6" class="lw la it ls b gy ok ly l lz ma"># on a MAC you an use the docker utilty or alternatively run </span><span id="63f2" class="lw la it ls b gy ok ly l lz ma">$ killall Docker &amp;&amp; open /Applications/Docker.app</span></pre><p id="c8fb" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">这不需要进一步解释。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="7e52" class="kz la it bd lb lc mi le lf lg mj li lj jz mk ka ll kc ml kd ln kf mm kg lp lq bi translated">清理Docker图像</h1><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="8459" class="lw la it ls b gy lx ly l lz ma">$ docker system prune</span></pre><p id="4222" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">Docker采用保守的方法来清理未使用的对象，如图像、容器、卷和网络。</p><p id="caf5" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">这些对象通常不会被删除，除非您明确要求Docker这样做。因此，如果这些对象没有被删除，这可能会很快开始占用大量空间。因此，定期运行以下命令来清理未使用的Docker映像非常重要。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="6dba" class="lw la it ls b gy lx ly l lz ma">docker kill &lt;CONTAINER&gt;</span></pre><p id="78f9" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">终止现有的运行容器。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="0508" class="lw la it ls b gy lx ly l lz ma">$ docker kill $(docker ps -q)</span></pre><p id="4f5d" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">终止当前正在运行的所有容器。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="d0aa" class="lw la it ls b gy lx ly l lz ma">$ docker rm &lt;CONTAINER&gt;</span></pre><p id="d0ae" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">删除当前未运行的特定容器。如果图像存在于远程注册表中，图像不会受到影响。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="eba8" class="lw la it ls b gy lx ly l lz ma">$ docker rm $(docker ps -a -q):</span></pre><p id="fdbd" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">删除所有当前没有运行的容器。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="3d61" class="lw la it ls b gy lx ly l lz ma">$ docker logs my_container</span></pre><p id="37c1" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">获得对容器日志的访问(对调试有用)。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="d34d" class="kz la it bd lb lc mi le lf lg mj li lj jz mk ka ll kc ml kd ln kf mm kg lp lq bi translated">从远程注册表中提取Docker图像</h1><h2 id="7edc" class="lw la it bd lb pe pf dn lf pg ph dp lj mw pi pj ll na pk pl ln ne pm pn lp po bi translated">码头枢纽</h2><p id="8b79" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">Docker Hub是Docker提供的一项服务，用于查找和共享打开的容器图像。</p><p id="d271" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">如果您希望将图像从那里拖到您的本地注册表，只需运行Docker <code class="fe no np nq ls b">run</code>命令，后跟图像路径即可。下面的命令演示了提取和运行版本稳定的R Rocker映像。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="3eb6" class="lw la it ls b gy lx ly l lz ma">$ docker run --rm -p 8787:8787 rocker/verse</span></pre><p id="3e01" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">Docker最初会尝试检查这个映像在您的本地机器上是否可用。如果它没有从Docker Hub存储库下载图像，这是现成的。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="2ad9" class="lw la it ls b gy lx ly l lz ma">$ docker pull rocker/verse</span></pre><p id="6ee9" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">如果您只想提取图像而不运行容器，那么<code class="fe no np nq ls b">docker pull</code>就足够了。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="203f" class="lw la it ls b gy lx ly l lz ma">docker login --username={DOCKERHUB_USERNNAME} --email={DOCKERHUB_EMAIL}</span></pre><p id="6497" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">要登录Docker Hub，可以运行上面的命令，该命令会提示您输入密码。</p><h2 id="7fdb" class="lw la it bd lb pe pf dn lf pg ph dp lj mw pi pj ll na pk pl ln ne pm pn lp po bi translated">自定义Docker注册表</h2><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="5c06" class="lw la it ls b gy lx ly l lz ma">$ docker login your.docker.host.com<br/>Username: foo<br/>Password: ********<br/>Email: user@myemail.com</span></pre><p id="82f3" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">如果您从一个需要认证的通用定制Docker注册中心获取，那么<code class="fe no np nq ls b">docker login</code>命令允许您从任何Docker注册中心获取，如上图所示。注意，在执行上述操作时，它会在您的<code class="fe no np nq ls b">~/.docker/config.json</code>文件中创建一个条目。连接<code class="fe no np nq ls b">~/.docker/config.json</code>以修改认证细节。</p><h2 id="4f5e" class="lw la it bd lb pe pf dn lf pg ph dp lj mw pi pj ll na pk pl ln ne pm pn lp po bi translated">亚马逊弹性容器注册中心</h2><p id="49a1" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">Amazon Elastic Container Registry(ECR)是一个完全托管的Docker容器注册表，允许开发人员存储、管理和部署Docker容器映像。亚马逊ECR与<a class="ae ky" href="https://aws.amazon.com/ecs/" rel="noopener ugc nofollow" target="_blank">亚马逊弹性容器服务(ECS) </a>无缝协作。如果您发现自己需要从ECR注册表中提取图像，请遵循以下命令。</p><p id="0380" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">您需要为您的IAM用户配置AWS CLI<a class="ae ky" href="https://aws.amazon.com/cli/" rel="noopener ugc nofollow" target="_blank">和一个密钥。</a></p><p id="1dd2" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">Amazon ECR要求IAM用户访问密钥具有IAM策略允许的权限(<code class="fe no np nq ls b">ecr:GetAuthorizationToken</code>)，然后您才能向注册中心认证并提取任何图像。或者，您可以利用<a class="ae ky" href="https://github.com/awslabs/amazon-ecr-credential-helper" rel="noopener ugc nofollow" target="_blank"> Amazon ECR Docker凭证助手</a>实用程序。下面的方法假设您正在使用AWS CLI并配置了所有权限。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="908c" class="lw la it ls b gy lx ly l lz ma">$ aws ecr list-images --repository-name=twitter-data-engine-core</span><span id="7d7c" class="lw la it ls b gy ok ly l lz ma">$ aws ecr describe-images —- repository-name=twitter-data-engine-core</span></pre><p id="691f" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated"><code class="fe no np nq ls b">get-login</code>命令生成一个长Docker登录命令。复制并执行它。在您尝试从AWS ECR执行Docker映像提取之前，需要进行身份验证。</p><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="3d5d" class="lw la it ls b gy lx ly l lz ma">$ aws ecr get-login —- region us-east-1 —- no-include-email --profile {AWS_NAMED_PROFILE_NAME}</span><span id="10d0" class="lw la it ls b gy ok ly l lz ma"># profile argument is optional provided your using the default aws cli profile. if you have multiple named profiles in your aws /.aws/credentials file then you need to explicity set the named profile to pick the onen you wish to use</span><span id="3523" class="lw la it ls b gy ok ly l lz ma">$ docker login -u AWS -p {YOUR_TEMPORARY_TOKEN}</span><span id="9d46" class="lw la it ls b gy ok ly l lz ma">$ docker pull 723123836077.dkr.ecr.us-east-1.amazonaws.com/twitter-data-engine-core:build-9</span></pre></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="26ba" class="kz la it bd lb lc mi le lf lg mj li lj jz mk ka ll kc ml kd ln kf mm kg lp lq bi translated">导出和导入物理Docker图像</h1><pre class="kj kk kl km gt lr ls lt lu aw lv bi"><span id="79b1" class="lw la it ls b gy lx ly l lz ma">$ docker save your_docker_image:latest &gt; /usr/local/your_docker_image.tar</span><span id="10f6" class="lw la it ls b gy ok ly l lz ma">$ docker load &lt; /usr/local/your_docker_image.tar</span></pre><p id="a79c" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">如果你曾经有一个需要，并希望出口到磁盘和加载回Docker图像，那么上述将做到这一点。</p><p id="e254" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">例如，当您想要通过替代介质(而不是Docker注册表)将Docker图像从一台机器传输到另一台机器时，导出到文件非常有用。出于安全原因，您可能对某些环境的访问受到限制。这可能会使您无法进行注册表间的迁移，因此，这是一个很有用的命令，很容易被遗忘。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="19a4" class="kz la it bd lb lc mi le lf lg mj li lj jz mk ka ll kc ml kd ln kf mm kg lp lq bi translated">最后的想法</h1><p id="e0b3" class="pw-post-body-paragraph mn mo it mp b mq mr ju ms mt mu jx mv mw mx my mz na nb nc nd ne nf ng nh ni im bi translated">为了确保本指南保持相关性，我们会不时地对其进行定期更新，以确保其跟上Docker中的新变化和新功能——因此，请不时查看。</p><p id="41fe" class="pw-post-body-paragraph mn mo it mp b mq nj ju ms mt nk jx mv mw nl my mz na nm nc nd ne nn ng nh ni im bi translated">干杯，编码快乐！</p></div></div>    
</body>
</html>