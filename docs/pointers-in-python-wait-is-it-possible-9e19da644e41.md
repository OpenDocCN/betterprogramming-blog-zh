# Python 中的指针？等等……可能吗？

> 原文：<https://betterprogramming.pub/pointers-in-python-wait-is-it-possible-9e19da644e41>

## 在 Python 代码中直接使用指针的力量

![](img/9c5c7f62ebcb8a19fa8119c97f810c67.png)

由 [Pakata Goh](https://unsplash.com/@pakata?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

指针在低级编程语言中非常强大。
Python 被认为是一种高级编程语言，但可以用或桥扩展到低级语言，即 C 和 C++。

最近发布的一个包允许我们在 Python 代码中直接使用指针的力量。

# 指针是什么？

指针被定义为`data-types`，其值是计算机内存中的物理地址。

例如，让我们看看下面的 C 代码:

在这个非常简单的例子中，我们声明了一个名为`i`的整数，并给它赋值`1`，然后我们声明了一个指向名为`i_ptr`的整数的指针，并给它赋值该整数的物理地址`i`。

然后我们打印出`i`的值、`i_ptr`的值(是存储`i`的地址)，然后是`i_ptr`指向的地址中存储的值。

如果我们运行这段代码，结果可能是这样的:

```
i=1i_ptr=0061FEC8*i_ptr=1
```

# 为什么是指针？

通过使用指针，我们可以使用值的地址而不是值本身。

这在很多情况下都很有用。

例如，当`sorting`一个数组时，我们经常需要交换项目。交换值的代价很高，因为我们需要将整个数据结构从一个地址转移到另一个地址。

另一方面，交换指针更加资源友好。

指针还允许动态分配内存。

在 C 语言中，这是通过使用`malloc`函数来完成的，如下所示:

在这个例子中，我们为十个整数动态分配了空间。

每个整数的长度是 4 个字节，所以总的来说，这个内存空间是 40 个字节长。
我们用 1 到 10 的数字填充每个插槽，然后打印每个插槽当时的地址和值。

这是一个可能的输出:

# 指针简介. py

[pointers.py](https://pypi.org/project/pointers.py/) 提供了一个很好的抽象，可以在我们的 Python 代码中使用指针，而不用显式地使用`c-types`或 c 扩展。

首先，让我们用下面的命令从 pip 安装`pointers.py`:

```
pip install pointers.py
```

现在，让我们写一个简单的程序:

所以我们有一个值为“hello world”的字符串，我们创建了一个名为`ptr`的指针来获取字符串的地址。

然后我们打印指针和它所指向的值。

如果我们运行这段代码，我们会得到以下结果:

```
0x26638d28430
hello world
```

所以我们可以直接访问存储“hello world”的地址。

或者，我们可以使用以下语法从值中提取指针:

现在我们可以直接改变这个字符串的值了！

记住，Python 中的字符串是不可变的，这意味着我们不能改变字符串的值。相反，我们只能创建一个新字符串。

有了指针，我们可以绕过这个限制，如下所示:

如果我们运行这个，我们会得到以下结果:

```
0x1ee67fabe30
hello world  
0x1ee67f38430
hi world
```

**勘误表更新(2022 年 8 月 20 日)**:

我注意到这两个地址不一样，这是真的。
然而，如果我们看看下面的代码片段:

在这个例子中，`ptr`和`ptr2`引用包含字符串“hello world”的同一个对象。
如果没有指针，一旦一个字符串的值改变，它将被赋给一个新的 python 内存结构，另一个保持不变。

然而，在我们更改了`ptr`中的值后，我们看到`ptr2`的值也发生了变化:

```
0x1c4bbd58530
hello world    
0x1c4bbd58530  
hello world    
===============
0x1c4bbe17870  
hi world       
0x1c4bbd58530  
hi world
```

那么不变的作为确实变异了，好吗？不好？丑？你将是裁判:)

谢谢你的评论！

**勘误表结束**

这就是我们如何使用`pointers.py`动态分配和释放内存:

在这个代码片段中，我们分配了 1 个整数(28 字节)大小的内存，并将数字 1 压入这个分配的内存中。

然后我们打印地址和值，然后我们释放内存。

下面是一个可能的输出:

```
0x1c21a612470
1
```

现在，让我们做一些奇怪的事情:)。

我们应该预料到这段代码中的断言错误，对吗？
嗯……不！

在这段代码中，我们没有得到任何异常。

因为我们在地址 1 中插入了值 2，所以我们完全把事情弄糟了。

所以记住，指针给你巨大的力量，但是伴随着巨大的力量而来的是巨大的责任！

# 最后一点

我个人比较喜欢低级编程，所以我的观点可能会有偏差。但是我相信这是对你的 Pythonic 工具带的一个很好的补充。

它可以轻松地在 Python 和它的 C 环境之间架起桥梁，并帮助处理可能需要直接内存访问的更复杂的任务。

*感谢您的阅读！*

*敬请期待更多。*