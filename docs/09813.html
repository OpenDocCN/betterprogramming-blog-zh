<html>
<head>
<title>3 Ways to Create the Iconic Matrix Opening Credits Scene in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中创建标志性矩阵开场演职员表场景的3种方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-ways-to-create-the-iconic-matrix-opening-credits-scene-in-swiftui-dcdfac072175?source=collection_archive---------3-----------------------#2021-10-14">https://betterprogramming.pub/3-ways-to-create-the-iconic-matrix-opening-credits-scene-in-swiftui-dcdfac072175?source=collection_archive---------3-----------------------#2021-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fb70" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">并比较各种SwiftUI迭代的实现</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e5d9c392c4d0dd1873a14e51418d7419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dl0F36mQqB_LNtA_dKd3ug.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com/s/photos/the-matrix?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ec56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1991年，第一部《终结者》电影的续集问世——这部电影远远领先于它的时代，计算机生成的SFX至今仍然有效。对比一下1986年出的《异形2》；就在几年前，SFX看起来已经过时了。但是1991年并不是使用计算机生成的SFX的分水岭。</p><p id="dbc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1999年，“黑客帝国”推出了现在标志性的打斗场景，这些场景都是使用电脑控制的摄像机的特殊装置完成的，而不仅仅是电脑。这三部电影很好地说明了这样一个事实，即几乎总是有不止一个解决方案——有些比其他的更好。</p><p id="d38f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正是最后一部电影的片头激发了我在本文中给自己设定的挑战。</p><p id="dfa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在标题序列中看到的绿色背景上复制下落的字符的挑战。加入我的旅程，尝试使用Swift为iOS 13、iOS 14以及最终的iOS 15编写类似矩阵的屏幕。结果喜忧参半，你肯定会惊讶于哪一个结果最好。</p><h1 id="ebc1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">案情摘要</h1><p id="bccc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我想建立一个落款屏幕。有些字母会是镜像——大多数不会。它们需要有不同的大小和不透明度。背景当然是绿色的，每一列中的第一个字母比后面的要亮。这些字母会在不同的时间落下。只有在当前列通过屏幕上的中间标记后，新列才能开始。较小的字母会比较大的字母更暗，给人以深刻的印象。</p><p id="5bd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想建立三个原型——第一个我计划在iOS 13下使用SwiftUI最纯粹的意义。其次，我将使用为iOS 14推出的SpriteKit，即SwiftUI 2.0。第三，我使用iOS 15中新的画布视图，也就是Swift UI 3.0。</p><h1 id="83ad" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">iOS 13的纯SwiftUI</h1><p id="b46a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们从我第一次尝试开始——它看起来像这样。它是使用纯Swift UI编写的，所以可以在iOS 13上运行。</p><p id="7fb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它几乎做了我在简介中指定的所有事情，尽管它不包括不同大小的字符或颠倒的字符。</p><p id="58af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动画GIF实时显示结果，尽管我运行它的2014 Retina开始发热，这种解决方案平均占用65%的CPU。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/11a380fe1e59e75c24885c3e8ef39d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9CElcgXPVDr4DatJfuCOnw.gif"/></div></div></figure><p id="6bbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我首先将所有的文本绘制到屏幕上，然后使用一个循环来管理显示字符的不透明度。我敢肯定你没有注意到，但它在每一个运行的每一列显示相同的字母。</p><p id="f687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用Combine框架向每一列发送消息以开始运行，在一个循环中用完全相同的消息管理运行。你会看到32个进程从头到尾独立地管理着每一行字符。这里有32列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2f65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，我对这个实现很满意，尽管感觉有点不稳定。我确实试着给颜色变化添加了一个<code class="fe mv mw mx my b">withAnimation</code>,但是我不能把手放在心上说它工作得更好。</p><h1 id="6cff" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">iOS 14版SpriteKit SwiftUI</h1><p id="f987" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">SwiftUI 2.0中悄悄加入的一项是SpriteKit。下面是更多相同的内容，在SwiftUI中使用它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/798a64e53c2e439fca959f01c8a78f82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yU75LmY3L4cIl6UKPXrCQQ.gif"/></div></div></figure><p id="81e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案实现了更多，这次包括了更小的字体。事实上，我不确定动画GIF是否公正——你需要复制并粘贴代码才能欣赏它。它运行起来也更酷，平均占用60%的CPU这可能是因为<code class="fe mv mw mx my b">SpriteKit</code>更容易使用GPU。</p><p id="2e97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我开始创建一个单独的字符序列，这是一个递归的程序，在不透明的后面用一个较小的数字一遍又一遍地调用它自己。已经有一行运行了，我简单地使用一个重复的<code class="fe mv mw mx my b">SKAction</code>来获得多行。下面是动画GIF背后的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="fd5c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">CanvasView SwiftUI和iOS 15</h1><p id="310c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后到Swift 3.0。在这个版本中，Apple引入了Canvas视图，这似乎是我开始使用这个应用程序时的理想选择。</p><p id="d0bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我在允许的时间里所做的事情的副本。这个解决方案是第一个和第二个的结合。I行文本是在屏幕外构建的，然后在屏幕上显示动画。所有的字符行都是预先设定的，它们在运行之间不会改变，大小也不会变化。</p><p id="bcf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有64个序列，足以让屏幕保持忙碌，并让用户认为他们不断变化。屏幕上有一个滤镜，可以帮助控制颜色的变化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/69712dbdee34567ea2f8fd6244d75e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PqP7jPkuqXy82zcrPzR1bg.gif"/></div></div></figure><p id="c000" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我对这个实现有两种想法——它运行起来比SpriteKit版本酷得多[大约30-40%的CPU],但看起来不那么酷。下面是这个版本背后的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="3323" class="lv lw it bd lx ly ng ma mb mc nh me mf jz ni ka mh kc nj kd mj kf nk kg ml mm bi translated">最后的想法</h1><p id="1099" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">总而言之，虽然我希望画布版是终极版，但我得出的结论是，SpriteKit版更接近原版。最后一个版本是最难实现的，尽管这可能是因为我需要更多地练习核心图形——有趣的是，所有三个版本最终都只有大约100行代码；它不是故意的，它只是以那种方式结束。</p><p id="1c68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为至少有三种其他的解决方案——你可以使用Metal框架作为基础来编写它，你可以使用UIKit作为基础来编写它，当然，如果你已经完全疯了，你也可以在Objective C中这样做。我希望看到有人尝试这些解决方案中的一个或多个——一个挑战，写下来——并记录在介质上——我将在本文中为未来的读者提供一个链接，链接到您的解决方案。</p><p id="a97c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的是，在这里更新一个现有的并张贴出来！一个挑战，让它尽可能接近原始。</p></div></div>    
</body>
</html>