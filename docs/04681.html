<html>
<head>
<title>How to Build an API Client Library in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript构建API客户端库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-an-api-client-library-in-javascript-665df869bdd5?source=collection_archive---------8-----------------------#2020-04-29">https://betterprogramming.pub/how-to-build-an-api-client-library-in-javascript-665df869bdd5?source=collection_archive---------8-----------------------#2020-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4044" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为API创建自己的JavaScript包装器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d1f608515ea4a0f4208455a06e4c4f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9jx43qwZvelrAuAo"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">j萨莫拉在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="b645" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当我发现自己连接到一个没有客户端库的第三方API时，我都必须围绕它创建许多样板文件:</p><ul class=""><li id="9f0b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">手动获取身份验证凭据并将其传递给数据提取层。如果您想要持久化API键或执行OAuth过程，该怎么办？</li><li id="c760" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">定义数据模型和规范化。您需要确保从API接收的数据以结构化的方式保存。</li><li id="694a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">为API创建一个控制器，将所有方法保存在一个地方，这样您就可以轻松地修改和查找API在整个代码库中的所有用法。</li><li id="a26a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">保持更新。API往往会有很大的变化。新方法来了，旧方法过时了。</li></ul><p id="41d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就在这几天，我决定连接到<a class="ae kv" href="https://docs.dev.to/api/" rel="noopener ugc nofollow" target="_blank"> DEV API </a>来自动收集我发表的文章的统计数据。没有任何可供使用的API客户端，所以我最终创建了所有的包装逻辑。如果它已经存在，那么为什么不与他人分享我的学习成果呢？我们将经历五个步骤，并就如何实现您自己的客户端提出一个清晰的计划。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="7208" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">1.语言和目标平台</h1><p id="5e93" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">在进入编码部分之前，让我们讨论一下我们将使用哪种语言。还记得我关于定义数据模型的观点吗？对于API客户端，向用户提供更多关于将要返回的数据的信息是非常重要的，这样我们就不必经常在文档和IDE之间切换上下文。这也有助于在编写代码时避免错误和打字错误。我们最后都有考试，不是吗？记住所有这些，目前最好的选择是使用TypeScript。</p><p id="f34e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们考虑一下我们的图书馆将在哪里运行。基本上，它可以是浏览器或Node.js服务器。为什么不开发一个两者都适用的库呢？它还将使它与服务器端呈现一起使用变得更容易，在服务器端呈现中，代码首先在服务器上执行，然后在客户端执行。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="a43c" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">2.集束</h1><p id="3d83" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">任何库的两个主要区别在于它的规模和对新旧客户端用户的支持。首先，我们希望我们的规模尽可能小API客户端不应该给项目增加太多的重量。其次，该库应该通过为那些不支持现代版本的用户提供CommonJS包，同时为拥有较新版本的客户提供一个现代包，来提供像样的浏览器支持。</p><p id="9995" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">web项目的默认选择是<a class="ae kv" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>，但是我们的库相当小而且简单，所以我选择了<a class="ae kv" href="https://rollupjs.org/" rel="noopener ugc nofollow" target="_blank"> Rollup </a>和<code class="fe nk nl nm nn b"><a class="ae kv" href="https://github.com/developit/microbundle" rel="noopener ugc nofollow" target="_blank">microbundle</a></code>作为基础捆绑器，以便于设置。</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="ae9c" class="ns mo iq nn b gy nt nu l nv nw">npm i -D microbundle</span></pre><p id="c682" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在用构建任务和入口点的路径更新<code class="fe nk nl nm nn b">package.js</code>:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="d228" class="ns mo iq nn b gy nt nu l nv nw">{<br/>  "source": "src/foo.js",          // Your source file (same as 1st arg to microbundle)<br/>  "main": "dist/foo.js",           // Output path for CommonJS/Node<br/>  "module": "dist/foo.module.js",  // Output path for JS Modules<br/>  "unpkg": "dist/foo.umd.js",      // Optional, for unpkg.com<br/>  "scripts": {<br/>    "build": "microbundle",        // Uses "source" and "main" as input and output paths by default<br/>    "dev": "microbundle watch"<br/>  }<br/>}</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="2f24" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">3.图书馆的结构</h1><p id="e4ce" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">因为我们打算支持许多API端点，所以如果API扩展，我们希望我们的代码具有良好的伸缩性。最好的方法之一是将文件夹与资源名称对齐。对于API 的<a class="ae kv" href="https://docs.dev.to/api/" rel="noopener ugc nofollow" target="_blank">开发，它看起来像这样:</a></p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="b7fa" class="ns mo iq nn b gy nt nu l nv nw">/src<br/>	/articles<br/>		index.ts // Everything that's related to articles<br/>		...<br/>	/comments<br/>		index.ts<br/>		...<br/>	/users<br/>		...<br/>	index.ts // Imports and joins all resources together</span></pre><p id="77a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将资源保存为单独的类也很有用，这样你就不需要在每次添加新方法时改变根<code class="fe nk nl nm nn b">index.ts</code>。然后，您需要使用<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/mixins.html" rel="noopener ugc nofollow" target="_blank"> TypeScript Mixins </a>将它们合并在一起:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="075b" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">4.获取库</h1><p id="f3c2" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们想做一个既能在浏览器中工作又能在Node.js中工作的库。我们如何让我们的请求也通用呢？<code class="fe nk nl nm nn b">fetch</code>在浏览器中有，但在Node.js中没有，在那里你应该使用<code class="fe nk nl nm nn b">http</code>模块。</p><p id="ce82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/developit/unfetch/tree/master/packages/isomorphic-unfetch" rel="noopener ugc nofollow" target="_blank">同构-解锁</a>将帮助我们在任何地方使用<code class="fe nk nl nm nn b">fetch</code>函数，并在浏览器和Node.js版本之间自动切换。</p><p id="fa1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来看看包装<code class="fe nk nl nm nn b">fetch</code>并附加认证头的<code class="fe nk nl nm nn b">request</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="5836" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们总是返回<code class="fe nk nl nm nn b">Promise</code>,这样客户端可以将请求链接在一起或者等待结果。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="a4d8" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">5.测试</h1><p id="677d" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">API客户端中的大部分代码都与第三方端点集成在一起。为了使测试更容易，我们可以利用<a class="ae kv" href="https://github.com/nock/nock" rel="noopener ugc nofollow" target="_blank"> Nock </a>库，它可以方便地模拟一个HTTP服务器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="adb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们设置了模拟，然后发出请求，最后检查模拟是否已经执行。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="a462" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">结论</h1><p id="1598" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们构建了一个API客户端，它很小，可伸缩，支持开箱即用的TypeScript，可以在浏览器和Node.js中工作。</p><p id="758f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想看最终的代码，请随意查看<a class="ae kv" href="https://github.com/ilyamkin/dev-to-js" rel="noopener ugc nofollow" target="_blank">库</a>。不要犹豫问我细节或建议改进。</p></div></div>    
</body>
</html>