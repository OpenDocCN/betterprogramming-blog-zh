<html>
<head>
<title>How To Use Streams in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Node.js中使用流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-streams-in-node-js-ad1b73409d37?source=collection_archive---------1-----------------------#2022-11-22">https://betterprogramming.pub/how-to-use-streams-in-node-js-ad1b73409d37?source=collection_archive---------1-----------------------#2022-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0cb5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么、为什么和如何</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/966c572be43866617850f4b5566ff0dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z01O0QC9usxOtMR4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@jachan_devol?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">贾尚·德沃尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="bb49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Node.js中的大多数异步编程都是使用promises完成的，但是如果您需要解耦数据和时间域，该怎么办呢？数据可能会连续生成，或者数据太大而无法一次性处理。承诺在这些情况下不起作用，流是首选的替代方案。我们将详细描述流，并查看具体的例子。到本文结束时，您将知道为什么以及如何使用它们。</p><p id="bb85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">流的一些常见应用有:</p><ul class=""><li id="d864" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">物联网传感器等实时数据处理</li><li id="b01a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">记录</li><li id="525f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">实时广告平台</li><li id="bb9a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">(直播)视频流</li><li id="3bee" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">音频流</li><li id="f6c6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">处理大文件</li><li id="fb1f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">大型数据(基础)迁移</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/07b4d0d4f3dbeedd68ca5cdc31c0bde1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GOaeIxB3qqFlZPIw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@martinadams?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马丁·亚当斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d1c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从1.0之前的早期版本开始，流就已经是Node.js的一个特性，并且比承诺的时间还早。作为一个范例，它不是Node.js独有的。( Linux)终端stdin和管道操作符是一种数据流形式，网络套接字也是如此。Node.js流为这些现有范例提供了一个很好的抽象。</p><p id="abb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">流顾名思义。数据将从一个应用/线程/套接字流到下一个。数据在接收时即被处理—以块为单位。流可以从各种数据源和接收器中读取或写入，包括文件、网络套接字和标准输入/标准输出。流可以通过管道连接在一起，以便一个流的输出成为另一个流的输入。这可用于创建复杂的数据处理管道。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="b66b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，JavaScript中流有两种相互竞争的标准。</p><p id="927a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WebStreams是一个相对较新的本地API，允许您直接访问和操作浏览器的媒体流(通常通过网络摄像头或麦克风)。</p><p id="f077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，Node.js流已经存在了很长时间。Node.js最近对stream API进行了改进，使其更易于使用，更像一个函数构造。在本文中，我们将重点关注Node.js流。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/5bcc972ec1ed1def68f647bd74ba62da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jJtOR6-q3tH5XRsi.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Streams_API" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/Streams _ API</a></p></figure><p id="d1ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">流是扩展<code class="fe ms mt mu mv b">EventEmitter</code>的对象。有三种基本的流结构:</p><ul class=""><li id="9047" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ms mt mu mv b">Readable </code> stream:可以读取的数据生产者。</li><li id="bf39" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">流:一个数据接收器。我们可以向这个流中写入数据。</li><li id="105e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ms mt mu mv b">Transform </code> stream:既可读又可写的流，具有转换数据的功能。</li></ul><p id="15b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以自己扩展这些流对象来创建新的源和接收器，尽管更常见的是实现转换流。</p><p id="77db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从Node.js v12开始，可以从任何(异步)可迭代对象中创建一个<code class="fe ms mt mu mv b">Readable</code>，这使得使用流进行函数式编程变得更加容易。</p><p id="dcde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，流以缓冲或字符串模式运行，但是它们可以选择以<a class="ae ky" href="https://nodejs.org/api/stream.html#object-mode" rel="noopener ugc nofollow" target="_blank">对象模式</a>运行。</p><p id="6581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们知道了什么是流，让我们更深入地挖掘一些用例及优点。</p><h1 id="10d2" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">更低的内存使用率</h1><p id="e4ee" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">当数据到达时，处理数据将降低内存需求，垃圾收集器必须做得更少，从而导致更快的服务器和更低的基础设施成本。通过下面的例子，这种工作方式将变得更加清晰。</p><p id="dd6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们从S3下载一个文件，将它存储在一个局部变量中，然后发送给客户端，这是一个常见的用例。</p><pre class="kj kk kl km gt nt mv nu bn nv nw bi"><span id="c5ba" class="nx mx it mv b be ny nz l oa ob">const handler = (req, res, next)=&gt;{<br/>  let data = await S3.getObject(params).promise()<br/>  res.send(data);<br/>}<br/></span></pre><p id="d251" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设文件大小为1mb；这意味着Node.js运行时必须在下载文件时为文件分配1 Mb的内存，并在下载完成后通过等待响应套接字发送文件。当文件被发送后，它必须释放内存。当数据以较小的块到达时，分配和清理内存是一种浪费，因为我们可以立即发送这些数据。</p><p id="897a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个例子展示了我们如何将数据从S3直接逐块传输到响应套接字。我们省略了局部变量，使用的内存会更少，到达第一个字节的时间也会减少。</p><p id="0cf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于单个请求，差异很小，但是在一个繁忙的服务器上，这些差异会很快增加。</p><pre class="kj kk kl km gt nt mv nu bn nv nw bi"><span id="7a2d" class="nx mx it mv b be ny nz l oa ob">const handler = (req, res, next)=&gt;{<br/>  S3.getObject(params).createReadStream()<br/>  .pipe(res)<br/>}</span></pre><h1 id="2288" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">反压力</h1><p id="f8da" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">想象一下这样一种情况，我们有一个快速的生产者和一个慢速的消费者，比方说，一部移动电话作为客户端的连接不稳定。</p><p id="6ead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于传统的分离的生产者和消费者，服务器上的内存使用会增加，因为电话连接不能足够快地处理数据。当我们使用管道流来避免这个问题时，下游管道将提供反压力。每个上游连接都将根据链中最慢链路的吞吐量进行调节。可以使用高水位线值配置流，以设置内部缓冲区/缓存。</p><h1 id="1699" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">数据转换</h1><p id="5bf8" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">Node.js中的一个基本示例是从文件流通过管道传输到服务器输出流。它确实像它看起来的那样:读取一个文件，并在读取的同时写入响应流。</p><pre class="kj kk kl km gt nt mv nu bn nv nw bi"><span id="c930" class="nx mx it mv b be ny nz l oa ob">const {createReadStream} = require('fs');<br/><br/>handler(req, res, next){<br/>   createReadStream('myFile.txt).pipe(res)<br/>}</span></pre><p id="fe76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们想在阅读时对文件内容做些什么呢？我们可以创建一个转换流。</p><pre class="kj kk kl km gt nt mv nu bn nv nw bi"><span id="50ff" class="nx mx it mv b be ny nz l oa ob">const { Transform } = require('node:stream');<br/><br/>const myTransform = new Transform({<br/>  transform(chunk, encoding, callback) {<br/>     callback(chunk.toUppercase())<br/>  }<br/>});<br/><br/>handler(req, res, next){<br/>   createReadStream('myFile.txt).myTransform.pipe(res)<br/>}</span></pre><p id="4eaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们可以用上面的简写构造函数创建我们自己的流，或者扩展<code class="fe ms mt mu mv b">Transform </code>(或者可读/可写)类，并添加我们自己的方法和功能。</p><p id="ea7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面例子的问题是错误没有很好地传播，必须在每个管道调用中处理，这就把我们带到了数据管道。</p><h1 id="7b01" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">数据管道</h1><p id="fe24" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">管道方法负责错误处理和清除。使用管道，我们不必手动从一个<code class="fe ms mt mu mv b">Readable</code>到<code class="fe ms mt mu mv b">Writable</code>进行管道传输，也不必为每个流捕捉错误。</p><pre class="kj kk kl km gt nt mv nu bn nv nw bi"><span id="5e68" class="nx mx it mv b be ny nz l oa ob">const { pipeline } = require('node:stream');<br/>const fs = require('node:fs');<br/><br/>pipeline(<br/>  fs.createReadStream('archive.tar'),<br/>  zlib.createGzip(),<br/>  fs.createWriteStream('archive.tar.gz'),<br/>  (err) =&gt; {<br/>    if (err) {<br/>      console.error('Pipeline failed.', err);<br/>    } else {<br/>      console.log('Pipeline succeeded.');<br/>    }<br/>  }<br/>);</span></pre><p id="5e30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">管道返回一个可写流，该流将通过管道传输到一个<code class="fe ms mt mu mv b">Writable</code>流。它将回调作为最后一个参数(尽管有一个基于承诺的版本)。回调用于处理错误。不得不提的是，当流水线出现错误时，所有的流都会被销毁，包括最后的<code class="fe ms mt mu mv b">Writable</code>流。</p><p id="b4c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用服务器响应作为管道中的最后一个流时，当出现错误时，您将无法向客户端发送错误消息，因为在出现错误的情况下，响应会被销毁。简单的解决方案是通过管道将管道流传输到响应流。</p><pre class="kj kk kl km gt nt mv nu bn nv nw bi"><span id="261f" class="nx mx it mv b be ny nz l oa ob">const { finished } = require('node:stream/promises');<br/><br/>async function handler(req, res, next){<br/>  pipeline(<br/>    stream1,<br/>    stream2,<br/>    (err) =&gt; {<br/>       console.log(error);<br/>       res.status(500).end('something went wrong')<br/>    }<br/>  )<br/>  .pipe(res);<br/>}<br/><br/>await finished(res);<br/>//do more work</span></pre><p id="c4d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，如果正在进行的操作出错，响应流不会被破坏。它将可以优雅地处理对客户端的响应。</p><p id="2e7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们看到了finished方法的使用，当参数中的流完成处理时，它解析一个承诺。</p><h1 id="fe11" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">在命令行应用程序和实用程序中使用</h1><p id="b7d7" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">Node.js' <code class="fe ms mt mu mv b">process.stdout</code>是一个可写的流，而<code class="fe ms mt mu mv b">process.stdin</code>是一个可读的流，这意味着我们可以通过管道将各种数据传输到Node.js进程，也可以从Node.js进程接收数据。</p><p id="fd9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看这个六行图像缩放器，例如:</p><pre class="kj kk kl km gt nt mv nu bn nv nw bi"><span id="c68e" class="nx mx it mv b be ny nz l oa ob">const { createReadStream } = require('node:fs');<br/>const sharp = require('sharp');<br/>const resizer = sharp().resize(200, 200).png();<br/><br/>createReadStream(process.argv[2])<br/>  .pipe(resizer)<br/>  .pipe(process.stdout);</span></pre><p id="96ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以称之为:</p><pre class="kj kk kl km gt nt mv nu bn nv nw bi"><span id="a58e" class="nx mx it mv b be ny nz l oa ob"># node resizer.js input-img.png &gt; out.png</span></pre><p id="123a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它接受一个参数，该参数是一个现有图像的路径，然后创建一个可读的流，通过管道将其传递给一个<a class="ae ky" href="https://www.npmjs.com/package/sharp" rel="noopener ugc nofollow" target="_blank"> sharp </a>实例，然后将调整大小的图像写入输出流。</p><p id="0e74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令行命令显示了我们如何使用<code class="fe ms mt mu mv b">&gt; out.png</code>部分将原始输出写入文件。</p><h1 id="3835" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">映射/减少/过滤</h1><p id="aca5" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">在Node.js 17中，引入了几个实验性的特性，使流更具功能性。有了这些方法，用原生Node.js代码替换RXjs将成为可能。</p><p id="cad7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个来自Node.js文档的例子展示了流是如何超越流数据而成为实用工具的强大部分的。</p><pre class="kj kk kl km gt nt mv nu bn nv nw bi"><span id="d10c" class="nx mx it mv b be ny nz l oa ob">import { Readable } from 'node:stream';<br/>import { stat } from 'node:fs/promises';<br/><br/>Readable.from(['a', 'b', 'c', 'd'])<br/>  .map((x) =&gt; x.toUpperCase())<br/>  .forEach((x:any)=&gt;console.log(x))<br/><br/>const pairs = await Readable.from(['a', 'b', 'c']).asIndexedPairs().toArray();<br/>console.log(pairs); // [[0, 'a'], [1, 'b'], [2, 'c']]</span></pre><p id="b561" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了map函数，我们不再需要创建自己的转换流，我们的代码将变得更加简洁。</p><p id="0c6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看文档，请注意这些函数中有些返回承诺，有些返回<code class="fe ms mt mu mv b">Readable</code>。</p><h1 id="fe96" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">并行数据处理</h1><p id="d6f1" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">但是对于这些流函数来说，有一个并发选项有多好呢？现在我们有了类似于Scala或F#的功能，例如，并行数组函数。如果我们有I/O繁重的任务需要拆分，或者有CPU密集型的计算需要在web workers中运行，这就允许我们决定并行运行多少任务。</p><p id="57c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我非常兴奋的一个特性。有了新的功能特性，您可以定义想要使用的并发性。假设您必须发出十个HTTP请求，并且在某个管道中进行十次文件写入。由于这些操作非常不同，您可能希望为每个操作分配更多或更少的线程。</p><pre class="kj kk kl km gt nt mv nu bn nv nw bi"><span id="3d3f" class="nx mx it mv b be ny nz l oa ob">// With an asynchronous predicate, making at most 2 file checks at a time.<br/>const anyBigFile = await Readable.from([<br/>  'file1',<br/>  'file2',<br/>  'file3',<br/>]).some(async (fileName) =&gt; {<br/>  const stats = await stat(fileName);<br/>  return stat.size &gt; 1024 * 1024;<br/>}, { concurrency: 2 });</span></pre><h1 id="b758" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">CSV解析</h1><p id="7286" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">Node.js有一个叫readline的模块，可以逐行处理一个<code class="fe ms mt mu mv b">Readable</code>流。它可以用来读取终端应用程序中的命令行输入，或者从流中解析CSV，如下例所示。我以前曾用它将大型数据集导入数据库，其中的CSV文件来自S3存储桶。</p><p id="ca78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些文件从S3流式传输，使用readline模块将文件分割成记录。多个转换流在将数据直接传输到Postgres数据库之前对其进行净化和处理。它的效果非常好，我们能够将数据库迁移的持续时间从几天缩短到几个小时。</p><p id="f4d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，这是一个相当大的数据集。</p><pre class="kj kk kl km gt nt mv nu bn nv nw bi"><span id="2467" class="nx mx it mv b be ny nz l oa ob">const fs = require('fs');<br/>const readline = require('readline');<br/><br/>  const fileStream = fs.createReadStream('input.csv');<br/><br/>  const rl = readline.createInterface({<br/>    input: fileStream,<br/>    crlfDelay: Infinity<br/>  });<br/><br/> for await (const line of rl) {<br/>    // process the line as CSV<br/>   const arr = line.split(',')   <br/> }</span></pre><p id="4d0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您对streams的功能有所了解。请阅读<a class="ae ky" href="https://nodejs.org/api/stream.html" rel="noopener ugc nofollow" target="_blank">文档</a>获取更多有用的提示。这个主题大得足以写一整本书。请在评论中告诉我你是如何在应用程序中使用流的。</p><p id="7845" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@laurent.zuijdwijk/membership" rel="noopener"> <em class="oc">如果你喜欢你所读的，考虑加入Medium，多读一些文章。你的一部分稿费用来支持像我这样的作者。点击这里加入。</em> </a></p></div></div>    
</body>
</html>