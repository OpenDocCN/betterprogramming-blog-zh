<html>
<head>
<title>The Node.js fs Module — Changing Ownership and Copying Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js fs模块—更改所有权和复制文件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/node-js-fs-module-changing-ownership-and-copying-files-1a818da5a11b?source=collection_archive---------6-----------------------#2020-01-18">https://betterprogramming.pub/node-js-fs-module-changing-ownership-and-copying-files-1a818da5a11b?source=collection_archive---------6-----------------------#2020-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="412d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们如何操作节点中的文件和目录？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0940df0a29602573638db85fbd7e51a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3BALpdZmz15fA9qw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">奥利弗·黑尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="80e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">操作文件和目录是任何程序的基本操作。因为Node.js是一个服务器端平台，可以直接与运行它的计算机交互，所以能够操作文件是一个基本特性。</p><p id="a8ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，Node.js的库中内置了一个<code class="fe lv lw lx ly b">fs</code>模块。它有许多功能，可以帮助操纵文件和文件夹。支持的文件和目录操作包括基本的操作，如操作和打开目录中的文件。</p><p id="f03a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，它也可以对文件做同样的事情。它可以同步和异步地做到这一点。它有一个异步API，该API具有支持承诺的功能。</p><p id="186d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它还可以显示文件的统计数据。几乎所有我们能想到的文件操作都可以用内置的<code class="fe lv lw lx ly b">fs</code>模块来完成。</p><p id="0e40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将使用<code class="fe lv lw lx ly b">chown</code>函数改变文件的所有权，并使用<code class="fe lv lw lx ly b">copyFile</code>函数复制文件。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0118" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用fs.chown和fs.chownSync函数更改文件所有权</h1><p id="a505" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">chown</code>函数让我们异步改变文件的所有权。它需要四个参数。</p><ol class=""><li id="061d" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">第一个参数是path对象，它可以是字符串、<code class="fe lv lw lx ly b">Buffer</code>对象或URL对象的形式。</li><li id="acce" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">第二个参数是UID，它是用户的用户ID。</li><li id="496b" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">第三个参数是GID，它是组ID。</li><li id="628d" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">第四个参数是一个回调函数，它有一个<code class="fe lv lw lx ly b">err</code>参数，如果<code class="fe lv lw lx ly b">chown</code>操作成功，这个参数就是<code class="fe lv lw lx ly b">null</code>，否则<code class="fe lv lw lx ly b">err</code>将是一个错误对象。<code class="fe lv lw lx ly b">chown</code>操作完成后，无论成功与否，回调函数都会被调用。</li></ol><p id="2de9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用<code class="fe lv lw lx ly b">chown</code>函数，我们可以编写如下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们将文件<code class="fe lv lw lx ly b">file.txt</code>的所有权更改为UID为1000的用户和GID为1000的组。为了找出Linux系统中当前用户和用户组的UID和GID，我们可以使用<code class="fe lv lw lx ly b">id</code>命令。</p><p id="5ae8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">chown</code>函数有一个名为<code class="fe lv lw lx ly b">chownSync</code>的同步版本。它需要三个参数。</p><ol class=""><li id="0e5d" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">第一个参数是path对象，它可以是字符串、<code class="fe lv lw lx ly b">Buffer</code>对象或URL对象的形式。</li><li id="f7ce" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">第二个参数是UID，它是用户的用户ID。</li><li id="5b37" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">第三个参数是GID，它是组ID。它返回<code class="fe lv lw lx ly b">undefined</code>。</li></ol><p id="3ef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在下面的代码中使用它:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="7dbc" class="nx mh it ly b gy ny nz l oa ob">const fs = require("fs");<br/>const file = "./files/file.txt";</span><span id="c0e7" class="nx mh it ly b gy oc nz l oa ob">fs.chownSync(file, 1000, 1000);<br/>console.log("File ownership changed");</span></pre><p id="c4ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它和<code class="fe lv lw lx ly b">chown</code>做同样的事情，但是同步进行。如果我们只想按顺序执行<code class="fe lv lw lx ly b">chown</code>操作，我们不必使用<code class="fe lv lw lx ly b">chown</code>，更好的选择是使用<code class="fe lv lw lx ly b">chown</code>函数的promise版本。</p><p id="2d6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">chown</code>函数的promise版本有三个参数。</p><ol class=""><li id="a5af" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">第一个参数是path对象，它可以是字符串、<code class="fe lv lw lx ly b">Buffer</code>对象或URL对象的形式。</li><li id="898e" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">第二个参数是UID，它是用户的用户ID。</li><li id="ee51" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">第三个参数是GID，它是组ID。当<code class="fe lv lw lx ly b">chown</code>操作成功完成时，它返回一个没有参数的承诺。</li></ol><p id="505b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在下面的代码中使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="09ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确认<code class="fe lv lw lx ly b">chown</code>如我们预期的那样工作，我们可以在Linux系统中运行以下命令。一种方法是运行<code class="fe lv lw lx ly b">ls -l</code>，如下面的命令所示:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="440b" class="nx mh it ly b gy ny nz l oa ob">ls -l ./files/file.txt</span></pre><p id="63ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用<code class="fe lv lw lx ly b">stat</code>命令。</p><p id="1a9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以运行<code class="fe lv lw lx ly b">stat ./files/file.txt</code>从<code class="fe lv lw lx ly b">Uid</code>和<code class="fe lv lw lx ly b">Gid</code>输出中获取<code class="fe lv lw lx ly b">./files/file.txt</code>的所有权信息。使用<code class="fe lv lw lx ly b">stat</code>命令，我们应该得到如下所示的输出:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="9ea6" class="nx mh it ly b gy ny nz l oa ob">File: './files/file.txt'<br/>  Size: 16              Blocks: 0          IO Block: 512    regular file<br/>Device: eh/14d  Inode: 22799473115106242  Links: 1<br/>Access: (0555/-r-xr-xr-x)  Uid: ( 1000/hauyeung)   Gid: ( 1000/hauyeung)<br/>Access: 2019-11-02 12:26:47.996290200 -0700<br/>Modify: 2019-11-02 12:26:47.996290200 -0700<br/>Change: 2019-11-02 12:44:45.037581600 -0700<br/> Birth: -</span></pre><p id="ec08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以过滤掉我们不需要的信息，只获得带有<code class="fe lv lw lx ly b">"%U %G"</code>格式序列的UID和GID。例如，我们可以运行<code class="fe lv lw lx ly b">stat -c “%U %G” ./files/file.txt</code>来获取<code class="fe lv lw lx ly b">file.txt</code>的UID和GID。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/90e4adf5df08a25ce37bb1e048544419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9NLaF9fKlnlmED5D"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@louishansel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">路易斯·汉瑟</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6ec6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">用fs.copyFile和fs.copyFileSync复制文件</h1><p id="24da" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">要复制Node.js程序中的文件，我们可以使用<code class="fe lv lw lx ly b">copyFile</code>函数。<code class="fe lv lw lx ly b">copyfile</code>函数有四个参数。</p><ol class=""><li id="8cff" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">第一个参数是源文件的路径，可以是字符串、<code class="fe lv lw lx ly b">Buffer</code>对象或URL对象。</li><li id="1869" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">第二个参数是目标文件的路径，也可以是字符串、<code class="fe lv lw lx ly b">Buffer</code>对象或URL对象。</li><li id="4c96" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">第三个参数是一个数字标志参数，它指定复制操作的行为。该标志的默认值为0。</li></ol><p id="3557" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该标志可以是下列值之一或它们的按位组合:</p><ul class=""><li id="0c60" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu oe nj nk nl bi translated"><code class="fe lv lw lx ly b">fs.constants.COPYFILE_EXCL</code> —如果目标文件已经存在，复制操作将失败。</li><li id="86c0" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu oe nj nk nl bi translated"><code class="fe lv lw lx ly b">fs.constants.COPYFILE_FICLONE</code> —复制操作将尝试创建写入时复制引用链接。写入时复制意味着如果文件被复制但没有被修改，那么它将只引用原始文件。只有当我们第一次写入文件时，它才会进行实际的复制。如果平台不支持写入时复制，则使用回退复制机制。</li><li id="196b" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu oe nj nk nl bi translated"><code class="fe lv lw lx ly b">fs.constants.COPYFILE_FICLONE_FORCE</code> —复制操作将尝试创建写入时复制引用链接。如果平台不支持写入时复制，则操作将失败。</li></ul><p id="1a23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将上面的常量与按位的<code class="fe lv lw lx ly b">OR</code>运算符结合起来，例如<code class="fe lv lw lx ly b">fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE</code>。</p><p id="f3cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.第四个参数是文件复制操作完成时调用的回调函数。它有一个<code class="fe lv lw lx ly b">err</code>参数，当复制文件操作成功时为<code class="fe lv lw lx ly b">null</code>，否则为一个带有错误信息的对象。</p><p id="9b4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复制操作的原子性没有保证。如果在打开目标文件进行写入后出现错误，Node.js将尝试删除目标。</p><p id="4ee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，如果没有设置标志，目标文件将覆盖同一位置同名的现有文件(如果存在)。</p><p id="14c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用<code class="fe lv lw lx ly b">copyFile</code>函数，我们可以编写类似下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="22b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们将源文件的源设置为<code class="fe lv lw lx ly b">file.txt</code>，目标文件设置为<code class="fe lv lw lx ly b">fileCopy.txt</code>。</p><p id="1780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们指定了如果文件以<code class="fe lv lw lx ly b">fs.constants.COPYFILE_EXCL</code>常量存在，复制操作将会失败，并且我们指定了复制文件操作将通过带有<code class="fe lv lw lx ly b">fs.constants.COPYFILE_FICLONE</code>标志的写时复制方法来完成。</p><p id="942b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">copyFile</code>功能的同步版本是<code class="fe lv lw lx ly b">copyFileSync</code>功能。除了回调之外，它采用与<code class="fe lv lw lx ly b">copyFile</code>函数相同的参数。</p><ol class=""><li id="3e1e" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">第一个参数是源文件的路径，可以是字符串、<code class="fe lv lw lx ly b">Buffer</code>对象或URL对象。</li><li id="3dbd" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">第二个参数是目标文件的路径，也可以是字符串、<code class="fe lv lw lx ly b">Buffer</code>对象或URL对象。</li><li id="0c74" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">第三个参数是一个数字标志参数，它指定复制操作的行为。该标志的默认值为0。这些标志和<code class="fe lv lw lx ly b">copyFile</code>函数的标志是一样的，我们也可以用同样的方式组合它们。</li></ol><p id="aea7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复制操作的原子性没有保证。如果在打开目标文件进行写入后出现错误，Node.js将尝试删除目标。</p><p id="4709" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，如果没有设置标志，目标文件将覆盖同一位置同名的现有文件(如果存在)。</p><p id="7083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用<code class="fe lv lw lx ly b">copyFileSync</code>函数，我们可以编写一些代码，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="87e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们设置源文件的来源为<code class="fe lv lw lx ly b">file.txt</code>，目标文件为<code class="fe lv lw lx ly b">fileCopy.txt</code>。</p><p id="93f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们指定了如果文件以<code class="fe lv lw lx ly b">fs.constants.COPYFILE_EXCL</code>常量存在，复制操作将会失败，并且我们指定了复制文件操作将通过带有<code class="fe lv lw lx ly b">fs.constants.COPYFILE_FICLONE</code>标志的写时复制方法来完成。</p><p id="5fb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过用<code class="fe lv lw lx ly b">try...catch</code>块包围代码来捕捉任何抛出的异常。</p><p id="b135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个<code class="fe lv lw lx ly b">copyFile</code>函数的承诺版本。它将文件从源异步复制到目标。</p><ol class=""><li id="0781" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">第一个参数是源文件的路径，可以是字符串、<code class="fe lv lw lx ly b">Buffer</code>对象或URL对象。</li><li id="3a28" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">第二个参数是目标文件的路径，它也可以是字符串、<code class="fe lv lw lx ly b">Buffer</code>对象或URL对象。</li><li id="c9ac" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">第三个参数是一个数字标志参数，它指定复制操作的行为。该标志的默认值为0。这些标志与<code class="fe lv lw lx ly b">copyFile</code>函数相同，我们可以用同样的方式组合它们。</li></ol><p id="9b25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复制操作的原子性没有保证。如果在打开目标文件进行写入后出现错误，Node.js将尝试删除目标。</p><p id="160f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，如果没有设置标志，目标文件将覆盖同一位置同名的现有文件(如果存在)。</p><p id="e01f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果复制操作成功，则<code class="fe lv lw lx ly b">copyFile</code>的promise版本解析时不带任何参数。</p><p id="5133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在下面的代码中使用<code class="fe lv lw lx ly b">copyFile</code>的承诺:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4fa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们将源文件的源设置为<code class="fe lv lw lx ly b">file.txt</code>，目标文件设置为<code class="fe lv lw lx ly b">fileCopy.txt</code>。</p><p id="6600" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们指定了如果文件以<code class="fe lv lw lx ly b">fs.constants.COPYFILE_EXCL</code>常量存在，复制操作将会失败，并且我们指定复制文件操作将通过带有<code class="fe lv lw lx ly b">fs.constants.COPYFILE_FICLONE</code>标志的写时复制方法来完成。</p><p id="8042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过用<code class="fe lv lw lx ly b">try...catch</code>块包围代码来捕捉任何抛出的异常。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="74f9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="28ae" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">通过<code class="fe lv lw lx ly b">chown</code>功能，我们可以改变文件的所有权。函数有两个异步版本，一个是常规异步版本，一个是promise版本。</p><p id="932e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个同步版本的<code class="fe lv lw lx ly b">chown</code>函数，也就是<code class="fe lv lw lx ly b">chownSync</code>函数。它们都通过传入您选择的用户的UID和GID来更改所有者。UID是用户ID，GID是组ID。我们可以用<code class="fe lv lw lx ly b">copyFile</code>功能复制文件。</p><p id="37cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">copyFile</code>函数有两个异步版本，一个是常规异步版本，一个是promise版本。</p><p id="254b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个同步版本的<code class="fe lv lw lx ly b">copyFile</code>函数，叫做<code class="fe lv lw lx ly b">copyFileSync</code>函数。我们可以用在<code class="fe lv lw lx ly b">fs</code>模块中作为常量的标志改变文件的复制方式。</p></div></div>    
</body>
</html>