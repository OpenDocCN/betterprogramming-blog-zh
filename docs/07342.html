<html>
<head>
<title>Rails 6 Development With Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Docker开发Rails 6</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rails-6-development-with-docker-55437314a1ad?source=collection_archive---------1-----------------------#2021-01-06">https://betterprogramming.pub/rails-6-development-with-docker-55437314a1ad?source=collection_archive---------1-----------------------#2021-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a404" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用确定性开发环境增强Rails工作流的实用指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/954648f7d0c5e7c75f795d5904fdc744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mP8v1WKh2HxpbMg9R6Fafg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="8b46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本指南涵盖了在本地机器上为Rails开发配置<a class="ae lu" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>。我的目标是引导您为构建Ruby on Rails应用程序建立一个符合人体工程学的、可重复的开发环境。</p><p id="332c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建Docker配置时考虑了以下目标:</p><ol class=""><li id="c20f" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">在单独的Docker容器中运行测试，并在套件运行后拆除支持基础设施</li><li id="d3bb" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">使用<a class="ae lu" href="https://docs.docker.com/storage/bind-mounts/" rel="noopener ugc nofollow" target="_blank"> Docker绑定挂载</a>支持开发模式下的Rails热重载(不需要将源代码复制到Docker容器中)</li><li id="6638" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">Gems安装在单独的卷上</li><li id="0305" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">byebug/pry支持</li><li id="5ae4" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">允许从应用程序卷内部运行Rails生成器并写入主机文件系统(使用绑定挂载)</li></ol><p id="8ccc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了支持上述内容，体系结构将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d9df906519824ca417e320e283bcfa64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tREN5tzZyTeL9xejnk5Hnw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="fa10" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将“dockerizing”的Rails应用程序具有一个<a class="ae lu" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>数据库和<a class="ae lu" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>(用于<a class="ae lu" href="https://guides.rubyonrails.org/action_cable_overview.html" rel="noopener ugc nofollow" target="_blank">动作电缆</a>)并被命名为<code class="fe mj mk ml mm b">restarone</code>。</p><p id="d960" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想观看视频，请点击此处:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在这个视频中，我遵循了本文中概述的所有步骤</p></figure><p id="9ba3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们开始吧。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="a958" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">创建Dockerfile文件</h1><p id="e621" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">首先，我在项目根目录下创建了一个<code class="fe mj mk ml mm b">Dockerfile.dev</code>,并加入了安装依赖项的管道。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt mo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Dockerfile.dev</p></figure><p id="33ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">稍后我们将研究第11和12行引用的入口点文件，但是这个脚本只是安装Rails依赖项并清除缓存在容器中的gem。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="a27e" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">使用Docker Compose定义卷、网络和服务</h1><p id="b121" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">接下来，我创建了定义应用程序使用的卷、服务和网络的<code class="fe mj mk ml mm b">docker-compose.yml</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt mo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">docker-compose.yml</p></figure><p id="0e09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">app源代码的绑定挂载在第30行，指向本地文件系统上的Rails根目录。gem被缓存在一个单独的卷上，因此可以在不干扰应用程序其余部分的情况下清理和重建它们。</p><p id="99a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mj mk ml mm b">tty:true</code>谓词在附加到Docker容器时启用byebug/pry支持。我将PostgreSQL(第23行)绑定到主机上的一个非标准端口，以避免与运行在端口<code class="fe mj mk ml mm b">5432</code>上的本地安装的PostgreSQL服务器冲突。因此，如果您想运行PgAdmin，请确保您将主机端口指定为<code class="fe mj mk ml mm b">5099</code>，或者简单地将其更改为映射到<code class="fe mj mk ml mm b">5432:5432</code>。</p><p id="474b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Rails测试环境被简单地映射到已经构建好的Rails dev环境映像，但是它将在一个单独的容器和网络中运行。这允许我们同时运行开发服务器和测试套件，而不必在它们之间做出选择。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="4255" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">在容器内部运行脚本的入口点</h1><p id="62d6" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">现在让我们看一下每个环境的入口点文件。对于开发，我创建了以下入口点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt mo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">dev-docker-entrypoint.sh</p></figure><p id="69a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它只是打印出Rails环境，检查是否满足包依赖关系，然后删除<code class="fe mj mk ml mm b">puma server.pid</code>文件。(我倾向于强制退出容器。)接下来，它将通过在命令前加上前缀<code class="fe mj mk ml mm b">bundle exec</code>来运行传递给它的任何命令。</p><p id="f3bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了删除服务器pid文件之外，测试入口点是相同的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt mo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">test-docker-entrypoint.sh</p></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="dd08" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">传递环境变量</h1><p id="ae0c" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">现在，重物不再碍事了。在开始之前的最后一步是创建各自的环境文件，这些文件定义了应用程序所需的变量。我创建了两个名为<code class="fe mj mk ml mm b">.env.development</code>和<code class="fe mj mk ml mm b">.env.test</code>的文件，并放入每个环境的db配置中:</p><pre class="kj kk kl km gt nu mm nv nw aw nx bi"><span id="f924" class="ny mx it mm b gy nz oa l ob oc">DATABASE_HOST=restarone_db<br/>DATABASE_USERNAME=postgres<br/>DATABASE_PASSWORD=password<br/>DATABASE_NAME=restarone_development<br/>DATABASE_PORT=5432<br/>REDIS_URL=redis://restarone_redis:6379/1</span></pre><p id="6dc1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为DNS解析是由Docker处理的，所以Rails应用程序可以通过容器名(例如<code class="fe mj mk ml mm b">restarone_db</code>和<code class="fe mj mk ml mm b">restarone_redis</code>)找到/解析主机。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="57d7" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">命令</h1><p id="cf90" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">这就是Docker的设置。让我们来看看几个命令。</p><h2 id="7bd2" class="ny mx it bd my od oe dn nc of og dp ng lh oh oi ni ll oj ok nk lp ol om nm on bi translated">构建应用程序并运行它</h2><p id="5a68" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">首先，我们需要构建容器，然后运行它们:</p><pre class="kj kk kl km gt nu mm nv nw aw nx bi"><span id="3fb2" class="ny mx it mm b gy nz oa l ob oc">docker-compose build &amp;&amp; docker-compose up</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/16e8c9cb6c56c31488bd5d44007632fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*XgrfvOpnXk-X8UE42JhEZw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">您应该看到正在构建的映像和正在启动的应用程序服务</p></figure><h2 id="8879" class="ny mx it bd my od oe dn nc of og dp ng lh oh oi ni ll oj ok nk lp ol om nm on bi translated">附加到开发应用程序</h2><p id="7aa3" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">要在byebug/pry中使用断点，只需在项目的目录名前加上<code class="fe mj mk ml mm b">app</code>(我的目录名为<code class="fe mj mk ml mm b">restarone</code>，因此应用程序名为<code class="fe mj mk ml mm b">restarone_app</code>，测试环境名为<code class="fe mj mk ml mm b">restarone_test</code>):</p><pre class="kj kk kl km gt nu mm nv nw aw nx bi"><span id="6916" class="ny mx it mm b gy nz oa l ob oc">docker attach restarone_app</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/8b5fccb17872b2c93a74ae5d257074df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LPTxmPTHqsK824FXzGn93w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">完整的应用程序日志(上图)，byebug会话(下图)</p></figure><h2 id="83fb" class="ny mx it bd my od oe dn nc of og dp ng lh oh oi ni ll oj ok nk lp ol om nm on bi translated">运行测试套件</h2><p id="712b" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">我们可以为测试套件创建一个一次性容器，然后在套件完成后通过运行以下命令将其拆除:</p><pre class="kj kk kl km gt nu mm nv nw aw nx bi"><span id="8997" class="ny mx it mm b gy nz oa l ob oc">docker-compose run --rm restarone_test rails test:full_suite</span></pre><p id="6e0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只需传入应用程序使用的任何测试命令。我喜欢为运行测试创建一个rake任务，所以对我来说它是<code class="fe mj mk ml mm b">rails test:full_suite</code>。</p><h2 id="5259" class="ny mx it bd my od oe dn nc of og dp ng lh oh oi ni ll oj ok nk lp ol om nm on bi translated">铁路发电机</h2><p id="6a65" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">就像测试套件一样，我们也可以构建一次性容器来运行标准的Rails生成器。</p><pre class="kj kk kl km gt nu mm nv nw aw nx bi"><span id="5123" class="ny mx it mm b gy nz oa l ob oc">docker-compose run --rm restarone_app rails g model User name:string</span><span id="6198" class="ny mx it mm b gy oq oa l ob oc"># for running migrations</span><span id="051b" class="ny mx it mm b gy oq oa l ob oc">docker-compose run --rm restarone_app rails db:migrate</span></pre><h2 id="45b3" class="ny mx it bd my od oe dn nc of og dp ng lh oh oi ni ll oj ok nk lp ol om nm on bi translated">运行将输出写入本地文件系统的一次性脚本</h2><p id="4270" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">有时rake任务会写入文件系统。我们可以通过运行如下命令来实现这一点:</p><pre class="kj kk kl km gt nu mm nv nw aw nx bi"><span id="8c47" class="ny mx it mm b gy nz oa l ob oc">docker-compose run --rm -v $PWD/tmp:/tmp restarone_app bundle exec rails r /tmp/script.rb</span><span id="f876" class="ny mx it mm b gy oq oa l ob oc"># or</span><span id="5342" class="ny mx it mm b gy oq oa l ob oc">docker-compose run --rm -v $PWD/tmp:/tmp restarone_app rake some_namespace:some_task</span></pre><h2 id="9a48" class="ny mx it bd my od oe dn nc of og dp ng lh oh oi ni ll oj ok nk lp ol om nm on bi translated">连接到数据库容器</h2><p id="0caf" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">要运行<code class="fe mj mk ml mm b">psql</code>命令，您需要使用<code class="fe mj mk ml mm b">docker-compose exec</code>从PostgreSQL容器运行一个shell:</p><pre class="kj kk kl km gt nu mm nv nw aw nx bi"><span id="7943" class="ny mx it mm b gy nz oa l ob oc">docker-compose exec restarone_db sh</span></pre><h2 id="5be0" class="ny mx it bd my od oe dn nc of og dp ng lh oh oi ni ll oj ok nk lp ol om nm on bi translated">将本地文件复制到Docker容器中</h2><p id="565d" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">有时我需要从SQL转储中恢复我的开发数据库。您可以使用<code class="fe mj mk ml mm b">docker cp</code>将任何文件复制到容器中的共享卷:</p><pre class="kj kk kl km gt nu mm nv nw aw nx bi"><span id="aaee" class="ny mx it mm b gy nz oa l ob oc">docker cp /local/path/to/local/file/here container_name:/var/shared</span><span id="8eb1" class="ny mx it mm b gy oq oa l ob oc"># to copy a SQL dump to the shared folder in the db: <br/>docker cp /local/path/to/dump/latest.dump restarone_db:/var/shared</span><span id="f041" class="ny mx it mm b gy oq oa l ob oc"># to copy a file to the shared folder in the app: <br/>docker cp /local/path/to/file/some-rb-script.rb restarone_app:/var/shared</span></pre><p id="b738" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后通过指向<code class="fe mj mk ml mm b">var/shared/</code>从容器中引用该文件。在下面的例子中，我使用Docker <code class="fe mj mk ml mm b">exec</code>命令直接在正在运行的<code class="fe mj mk ml mm b">restarone_db</code>容器上运行<code class="fe mj mk ml mm b">psql</code>命令:</p><pre class="kj kk kl km gt nu mm nv nw aw nx bi"><span id="9f2e" class="ny mx it mm b gy nz oa l ob oc">docker-compose exec restarone_db pg_restore -U postgres -d restarone_development /var/shared/latest.dump --no-owner --clean -F c</span></pre></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="5dc2" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">总结想法</h1><p id="6e7f" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">Rails是令人惊奇的，当与Docker打包在一起时，您会得到一个优雅的可移植性和确定性的Rails开发环境，您可以随时随地使用它进行构建。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="5b53" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">沙施克是一名来自多伦多的软件工程师，也是Restarone公司的创始人。当他不开发软件时，他在Medium和YouTube上创作内容，帮助人们过渡到技术领域。</p></div></div>    
</body>
</html>