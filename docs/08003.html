<html>
<head>
<title>Top 5 TypeScript Features You Should Master</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您应该掌握的五大打字稿功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/top-5-typescript-features-you-should-master-2358db9ab3d5?source=collection_archive---------1-----------------------#2021-03-15">https://betterprogramming.pub/top-5-typescript-features-you-should-master-2358db9ab3d5?source=collection_archive---------1-----------------------#2021-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a5f1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用这些必须知道的特性来提高您的打字稿知识</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/59f33bff9100cded817c0f4836d43803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M1QgnmpXAherbcbF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿诺德·弗朗西斯卡在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="affd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript的影响力与日俱增。它现在是任何新的web/Node项目的首选配套工具。使用TypeScript的好处不能被夸大。然而，了解和理解JavaScript超集拥有的所有工具非常重要。</p><p id="b0ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你在投资时间来提高你的打字技能吗？你想充分利用它吗？有时，由于没有使用正确的TypeScript特性，也没有遵循它的最佳实践，可能会有大量的代码重复和样板文件。</p><p id="b076" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究TypeScript赋予我们的五个最重要的特性。通过确保我们理解它们并知道它们的用例，我们可以构建一个更好、更全面的代码库。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5c72" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.联合</h1><p id="f7b8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">联合是最基本和易于使用的类型脚本特性之一。它们让我们可以轻松地将多种类型组合成一种。交集和并集类型是我们可以组合类型的方式之一。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9ae5" class="ne md it na b gy nf ng l nh ni">function logIdentifier(id: string | number) {<br/>  console.log('id', id);<br/>}</span></pre><p id="9f52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们想表达某个类型可以为空时，它们非常有用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1ffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">联合不仅限于<code class="fe nl nm nn na b">undefined</code>或原语。它们可以用于任何接口或类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定如上的联合类型，我们如何区分<code class="fe nl nm nn na b">Bike</code>和<code class="fe nl nm nn na b">Plane</code>？通过使用区别并集特征。我们将创建一个名为<code class="fe nl nm nn na b">Vehicles</code>的枚举，并将其用作属性值。</p><p id="8066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看我们的代码看起来怎么样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2c66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们刚刚看到了工会是一个简单而强大的工具，它有一些技巧。然而，如果我们想以更强大和动态的方式表达类型/接口，我们需要使用泛型。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0240" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.无商标消费品</h1><p id="bed0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们的方法/API可重用的最好方法是什么？仿制药！这是大多数类型化语言中的一个特性。它让我们以更通用的方式表达类型。这将增强我们的类和类型。</p><p id="afc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说一个基本的例子。让我们创建一个向数组添加任何已定义类型的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="cdf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想为一个<code class="fe nl nm nn na b">int</code>类型创建相同的实用程序呢？要不要重做同样的方法？通过简单地使用泛型，我们可以重用代码，而不是添加更多的样板文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="0960" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何防止不需要的类型在<code class="fe nl nm nn na b">T</code>中被使用？为此，我们可以使用<code class="fe nl nm nn na b">extends</code>关键字:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1a44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">泛型将使我们能够为我们的类型构建全面的动态接口。它们是我们日常开发中必须掌握的特性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="595b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.元组</h1><p id="4daa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">什么是元组？让我们来看看定义:</p><blockquote class="no np nq"><p id="df00" class="kz la nr lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated">元组类型允许您用固定数量的元素来表示数组，这些元素的类型是已知的，但不必相同。例如，您可能希望将一个值表示为一对<code class="fe nl nm nn na b">string</code>和<code class="fe nl nm nn na b">number</code>。— <a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/basic-types.html" rel="noopener ugc nofollow" target="_blank">打字稿的文档</a></p></blockquote><p id="3dfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的一点是，这些数组的长度是固定的。有两种方法来定义元组:</p><ul class=""><li id="99fa" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">明确地:</li></ul><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a95b" class="ne md it na b gy nf ng l nh ni">const array: [string, number] = ['test', 12];</span></pre><ul class=""><li id="1e38" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">隐含地:</li></ul><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="07c9" class="ne md it na b gy nf ng l nh ni">const array = ['test', 12] as const;</span></pre><p id="f752" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的区别是<code class="fe nl nm nn na b">as const</code>将使数组只读，这在我看来更可取。</p><p id="cde8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，元组也可以被标记:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="98f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标签不要求我们在析构时用不同的名字命名变量。它们纯粹是为了文档和工具。标签将有助于使我们的代码更具可读性和可维护性。</p><p id="e254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，使用带标签的元组时有一个重要的规则:当标记一个元组元素时，元组中的所有其他元素也必须被标记。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="47ce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.映射类型</h1><p id="8b0b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">什么是映射类型？它们是一种避免反复定义接口的方法。您可以将一个类型建立在另一个类型或接口的基础上，从而省去手工操作。</p><blockquote class="no np nq"><p id="5927" class="kz la nr lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated">“当你不想重复自己的时候，有时候一种类型需要建立在另一种类型的基础上。</p><p id="5e76" class="kz la nr lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated">映射类型建立在索引签名的语法之上，索引签名用于声明尚未提前声明的属性类型。”— <a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html" rel="noopener ugc nofollow" target="_blank">打字稿的文档</a></p></blockquote><p id="d866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，映射类型允许我们在现有类型的基础上创建新的类型。</p><p id="f1c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript附带了许多实用程序类型，所以我们不必在每个项目中重写它们。我们来看一些最常见的:<code class="fe nl nm nn na b">Omit</code>、<code class="fe nl nm nn na b">Partial</code>、<code class="fe nl nm nn na b">Readonly</code>、<code class="fe nl nm nn na b">Readonly</code>、<code class="fe nl nm nn na b">Exclude</code>、<code class="fe nl nm nn na b">Extract</code>、<code class="fe nl nm nn na b">NonNullable</code>、<code class="fe nl nm nn na b">ReturnType</code>。</p><p id="6889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看他们中的一个。假设我们想要将一个名为<code class="fe nl nm nn na b">Teacher</code>的实体的所有属性转换为<code class="fe nl nm nn na b">readonly</code>。我们可以使用什么工具？我们可以使用<code class="fe nl nm nn na b">Readonly</code>实用程序类型。让我们来看看它的实际应用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9e5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回顾一下<code class="fe nl nm nn na b">Readonly</code>是如何工作的:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d609" class="ne md it na b gy nf ng l nh ni">type Readonly&lt;T&gt; = { readonly [P in keyof T]: T[P]; }</span></pre><p id="8085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们创建我们的自定义实用程序来取乐。让我们反转<code class="fe nl nm nn na b">Readonly</code>类型来创建一个<code class="fe nl nm nn na b">Writable</code>类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="b58d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nr">注:注意</em> <code class="fe nl nm nn na b"><em class="nr">-</em></code> <em class="nr">修饰语。在这个场景中，它被用来移除</em> <code class="fe nl nm nn na b"><em class="nr">readonly</em></code> <em class="nr">修改器。它可以用来从</em> <code class="fe nl nm nn na b"><em class="nr">?</em></code> <em class="nr">等属性中移除其他修改器。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cea3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.防护类型</h1><p id="e574" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">类型守卫是一套帮助我们缩小对象类型的工具。这意味着我们可以从更一般的类型到更具体的类型。</p><p id="0abb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有多种技术可以执行类型保护。对于本文，我们将只关注用户定义的类型保护。这些基本上是断言——类似于任何给定类型的函数。</p><p id="f0a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何使用它们？我们只需要定义一个返回类型为a <code class="fe nl nm nn na b">type predicate</code>的函数，它返回<code class="fe nl nm nn na b">true/false</code>。让我们看看如何将一个<code class="fe nl nm nn na b">typeof</code>操作符变成一个类型保护函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3c98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，如果<code class="fe nl nm nn na b">isNumber</code>检查是<code class="fe nl nm nn na b">false</code>，TypeScript可以假设该值将是一个字符串，因为<code class="fe nl nm nn na b">x</code>可能是<code class="fe nl nm nn na b">string</code>或<code class="fe nl nm nn na b">number</code>。</p><p id="c706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看另一个使用自定义接口的类型保护的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe nl nm nn na b">isHunter</code>函数的返回类型是<code class="fe nl nm nn na b">x is Hunter</code>。断言函数将是我们的类型守卫。</p><p id="3764" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型保护是有作用域的。在<code class="fe nl nm nn na b">isHunter(x)</code>代码块中，<code class="fe nl nm nn na b">x</code>变量属于<code class="fe nl nm nn na b">Hunter</code>类型。这意味着我们可以安全地调用它的<code class="fe nl nm nn na b">hunt</code>方法。但是，在这个代码块之外，<code class="fe nl nm nn na b">x</code>类型仍然是<code class="fe nl nm nn na b">unknown</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f3c1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="7ebc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们只是探索了我们所拥有的最重要的Typescript特性。由于这只是一个概述，我们只是触及了它们的表面。</p><p id="edd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的目标是让您好奇并展示Typescript的能力。现在就看你能不能深入其中任何一个了。</p><p id="23ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过尝试逐步采用它们，你会发现你的代码变得更整洁、更容易维护。</p><p id="718a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你不是中等会员吗？支持我<a class="ae ky" href="http://dioxmio.medium.com/membership" rel="noopener">在这里</a>成为其中一员。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="40dc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">相关文章</h1><div class="oe of gp gr og oh"><a rel="noopener  ugc nofollow" target="_blank" href="/typescript-a-gentle-introduction-to-mapped-types-f65e45fa2598"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">TypeScript:映射类型的简明介绍</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">学习构建自己的一套TypeScript工具</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">better编程. pub</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div><div class="oe of gp gr og oh"><a rel="noopener  ugc nofollow" target="_blank" href="/getting-strict-with-typescript-2e906b48c0a"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">对类型脚本越来越严格</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">使您的类型脚本代码更具可读性和类型安全</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">better编程. pub</p></div></div><div class="oq l"><div class="ow l os ot ou oq ov ks oh"/></div></div></a></div><div class="oe of gp gr og oh"><a rel="noopener  ugc nofollow" target="_blank" href="/master-typescripts-type-guards-1fd5436bc6f2"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">Master TypeScript的类型保护</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">在TypeScript的type guards中从初学者到专业人员</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">better编程. pub</p></div></div><div class="oq l"><div class="ox l os ot ou oq ov ks oh"/></div></div></a></div></div></div>    
</body>
</html>