<html>
<head>
<title>5 Principles for Writing Clean and Maintainable Vue.js Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写干净且可维护的Vue.js代码的5个原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-principles-for-writing-clean-and-maintainable-vue-js-code-35dfcf5ef08c?source=collection_archive---------2-----------------------#2021-03-01">https://betterprogramming.pub/5-principles-for-writing-clean-and-maintainable-vue-js-code-35dfcf5ef08c?source=collection_archive---------2-----------------------#2021-03-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f52c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写他人能够理解和喜爱的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fc002978425c79bed351f60cb1fd2ca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MYXTzQCM_XX8_cKVYkt_Xg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔安娜·科辛斯卡在<a class="ae ky" href="https://unsplash.com/s/photos/candy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8fba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干净的代码有很大的力量。干净的代码可能不会像好酒一样随着时间的推移变得更好，但至少随着时间的推移它仍然是可以理解的。</p><p id="5117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">意大利面代码则相反，时间越久越糟糕。你现在也许能够处理混乱，但是如果你在做别的事情，三个月、五个月或者20个月后再回来做，那会怎么样呢？</p><p id="c857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名程序员，包括在Vue.js项目中，我喜欢坚持的一个主要原则是DRY原则。</p><p id="b95f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DRY代表<em class="lv">不要重复自己，</em>它的目标是减少重复。</p><p id="82c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我坚持认为这很重要的原因是湿<em class="lv">(每件事写两遍)</em>解决方案在许多情况下会带来额外的复杂性。我分享一个简单的例子帮助你理解。</p><p id="27f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您在代码库中的两个地方有重复的代码。如果您决定更改逻辑或某些参数，该怎么办？您必须在这两个地方重构代码。不过，这能有多糟呢？</p><ul class=""><li id="d0cf" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">换了一个地方又忘了另一个地方怎么办？</li><li id="3629" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">如果你在五个地方都有相同的代码，那该怎么办？</li><li id="6f6c" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">如果你不做这个项目，五个月后又回来做，那该怎么办？</li></ul><p id="cb2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保持代码的整洁可以避免很多问题，还可以节省大量时间。这在短期内可能看起来不明显，但是从长期来看，干净的代码在生产率方面是更好的选择。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="0d51" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">使用混音</h1><p id="c4e5" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在Vue中创建可重用方法、数据属性、计算属性等的主要方法是创建mixins。</p><p id="2d0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您跨组件重用逻辑，那么在mixins中定义逻辑是有意义的，您可以在整个应用程序中使用它。</p><p id="2f7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您的应用程序有多条路线，通过使用<code class="fe no np nq nr b">vue-router</code>，您将每条路线与相应的组件连接起来。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="d317" class="nw ms it nr b gy nx ny l nz oa">- App.vue<br/>-- Home.vue<br/>-- Analytics.vue<br/>-- Reports.vue</span></pre><p id="0b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们假设您已经创建了一个定制的产品游览，您希望每当用户进入任何选项卡时就开始这个游览。</p><p id="05a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你没有使用mixins，并且你希望产品之旅出现在所有页面上，你需要将相同的代码复制到每个<code class="fe no np nq nr b">mounted</code>回调和<code class="fe no np nq nr b">startProductTour</code>方法中。我在这里写了<code class="fe no np nq nr b">Home.vue</code>的例子，但是在<code class="fe no np nq nr b">Analytics.vue</code>和<code class="fe no np nq nr b">Reports.vue</code>中你需要相同的代码。</p><h2 id="4484" class="nw ms it bd mt ob oc dn mx od oe dp nb li of og nd lm oh oi nf lq oj ok nh ol bi translated"><strong class="ak"> Home.vue </strong></h2><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="4432" class="nw ms it nr b gy nx ny l nz oa"><strong class="nr iu">export</strong> <strong class="nr iu">default</strong> {<br/>  mounted() {<br/>    <strong class="nr iu">this</strong>.startProductTour();<br/>  }.<br/>  methods: {<br/>    startProductTour() {<br/>      // start product tour actions here<br/>    }<br/>  }<br/>}</span></pre><p id="0981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你把以上定义为mixin…</p><p id="06f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b"><strong class="lb iu">ProductTour</strong></code> <strong class="lb iu">米欣</strong></p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="5e44" class="nw ms it nr b gy nx ny l nz oa"><strong class="nr iu">export</strong> <strong class="nr iu">default</strong> {<br/>  mounted() {<br/>    <strong class="nr iu">this</strong>.startProductTour();<br/>  }.<br/>  methods: {<br/>    startProductTour() {<br/>      // start product tour actions here<br/>    }<br/>  }<br/>}</span></pre><p id="5fd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…然后您可以在所有组件中使用它，只要一行代码就可以在任何需要的地方使用它。而如果你换了产品，你只需要更新你的mixin一次，而不是编辑多个文件。</p><h2 id="a509" class="nw ms it bd mt ob oc dn mx od oe dp nb li of og nd lm oh oi nf lq oj ok nh ol bi translated"><strong class="ak"> Home.vue </strong></h2><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="e7e5" class="nw ms it nr b gy nx ny l nz oa">import ProductTourMixin from '../mixins/ProductTourMixin';<br/>export default {<br/>  mixins: [ProductTourMixin]<br/>}</span></pre><p id="3660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，您的新项目结构将如下所示:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="75f8" class="nw ms it nr b gy nx ny l nz oa">- App.vue<br/>- mixins/ProductTourMixin<br/>-- Home.vue<br/>-- Analytics.vue<br/>-- Reports.vue</span></pre><p id="c5af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用mixins，您节省了时间和精力，避免了头痛——只需保持物品清洁干燥。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="e387" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">不要廉价使用组件</h1><p id="d9f2" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在我的第一个Vue应用程序中，我的组件会增长到数百甚至数千行代码。我的giga组件可以在里面做任何事情，包括一个巨大的HTML <code class="fe no np nq nr b">&lt;template&gt;</code>，许多方法，以及这些方法中的大量JavaScript。问题是:</p><ul class=""><li id="a3c6" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">我构建的所有东西都没有可重用性。如果我想重用我的giga组件的一部分，我需要将它复制到一个新的组件中，这会导致重复。</li><li id="091f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">giga组件很难阅读和维护，如果我不进行重构，它只会随着时间变得更长</li><li id="9b14" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">很难在不引起冲突的情况下在人们之间划分工作，这导致部署功能代码需要更多的时间</li></ul><p id="eb9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为这一点很清楚——创建一个或几个大型组件而不是许多小型组件绝对是一场噩梦。</p><p id="58df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么创建许多小组件而不是更少的大组件有什么好处呢？</p><ol class=""><li id="5fbb" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu om mc md me bi translated">小组件通常是可重用的，这样可以节省您的时间，还可以避免重复代码</li><li id="905b" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu om mc md me bi translated">在大多数情况下，父元素和子元素的逻辑是分离的。如果对子组件进行更改，不会影响父元素。对于父元素来说也是如此，只要您没有以任何方式改变被传递的属性。</li><li id="2a96" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu om mc md me bi translated">在大型v-for循环中，较小的组件带来了性能优势，因为Vue不会更新它们，除非属性改变(对于非对象属性)。</li></ol><p id="7762" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大型应用程序中，有必要将整个应用程序分成组件，以便于开发。</p><p id="1602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这句话来自关于组件的Vue官方文档，它说明了将你的应用拆分成组件的重要性。</p><p id="19d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>通读你喜欢的框架和技术的全部文档，可以揭示一个信息宝库，所以我建议你经常这样做。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="a865" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">验证你的道具</h1><p id="bac9" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">验证您的props是使您的Vue应用程序可维护的一个重要部分。</p><p id="9c87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们来看看在一个组件中定义道具的错误方式。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="4676" class="nw ms it nr b gy nx ny l nz oa">export default {<br/>  props: ['myProp'],<br/>}</span></pre><p id="e72e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种定义道具的方式只在开发阶段可以接受，但是在上线之前，你应该为你的道具写完整的定义。至少，你应该为你的道具定义一个类型。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="3c8e" class="nw ms it nr b gy nx ny l nz oa">// quick way<br/>export default {<br/>  props: {<br/>    myProp: String,<br/>  }<br/>}</span><span id="85b2" class="nw ms it nr b gy on ny l nz oa">// this should be preferred<br/>export default {<br/>  props: {<br/>    myProp: {<br/>      type: String<br/>    }<br/>  }<br/>}</span></pre><p id="e217" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但最好的方法是充分定义你的道具，并验证它们。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="3fc5" class="nw ms it nr b gy nx ny l nz oa">props: {<br/>  myProp: {<br/>    type: Number,<br/>    required: true,<br/>    validator: (value) =&gt; {<br/>      return value &gt; 0;<br/>    }<br/>  }<br/>}</span></pre><p id="4d0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过验证您的props，您可以确保避免与传递意外值相关的问题，这将有助于您在开发过程中发现此类错误。</p><p id="18ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个额外的优势，通过拥有定义良好的props，您将始终能够查看您的prop定义和验证，以了解预期的值。可以把它看作是组件期望的小型文档。有时候，定义良好的输入，语义上正确的名称比大量的注释更好。</p><p id="08f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再一次，干净的代码战胜了马虎的代码，让你避免错误，并随时记住道具的用途。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="9fca" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">使用服务与API交互</h1><p id="a0a9" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">Vue没有Angular这样的服务，可以让你创建服务与API交互，构建通用的应用逻辑。</p><p id="63bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我的经验，尽可能地将表示逻辑从应用程序逻辑中分离出来是值得的。</p><p id="517d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地说明我的想法，我将分享一个例子。假设您有一个包含三个子组件的<code class="fe no np nq nr b">Reports</code>组件:<code class="fe no np nq nr b">ReportTable</code>、<code class="fe no np nq nr b">ReportChart</code>和<code class="fe no np nq nr b">ReportStats</code>。</p><h2 id="f9c8" class="nw ms it bd mt ob oc dn mx od oe dp nb li of og nd lm oh oi nf lq oj ok nh ol bi translated"><strong class="ak"> Reports.vue </strong></h2><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="4ca3" class="nw ms it nr b gy nx ny l nz oa">&lt;!-- This example is intentionally kept simple --&gt;<br/>&lt;template&gt;<br/>  &lt;report-stats :stats="stats" /&gt;<br/>  &lt;report-chart :chartData="chartData" /&gt;<br/>  &lt;report-table :breakdown="breakdown" /&gt;<br/>&lt;/template&gt;</span><span id="0323" class="nw ms it nr b gy on ny l nz oa">&lt;script&gt;<br/>export default {<br/>  data() {<br/>    return {<br/>      stats: null,<br/>      chartData: null,<br/>      breakdown: null<br/>    }<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><p id="66d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是你的<code class="fe no np nq nr b">Reports</code>组件的基础。现在，您需要一种从API中获取数据的方法，因此您会得到如下结果:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="3c3f" class="nw ms it nr b gy nx ny l nz oa">mounted() {<br/>  this.getStats();<br/>}</span></pre><p id="9013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后你会看到这样的东西:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="1b87" class="nw ms it nr b gy nx ny l nz oa">methods: {<br/>  getStats() {<br/>    axios.get('/api/to-get/the-data')<br/>      .then(response =&gt; {<br/>        this.stats = response.data.stats<br/>      });<br/>  }<br/>}</span></pre><p id="a0dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这绝对不错，在较小的应用程序中，这可能还不错。但是将应用程序逻辑从表示逻辑中分离出来有很多好处:</p><ul class=""><li id="de64" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">您可以在后端环境或不同的前端环境中使用相同的服务，而无需使用Vue</li><li id="99cc" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">你保持你的Vue代码清晰易懂。表示层不需要知道应用程序的全部复杂性。</li><li id="d365" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">您有一个定义良好的API，有点像预控制器，可以帮助您和您的团队理解需要什么参数以及每个调用是如何工作的。</li></ul><p id="b679" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们如何把我们的例子变成一个服务呢？</p><h2 id="e925" class="nw ms it bd mt ob oc dn mx od oe dp nb li of og nd lm oh oi nf lq oj ok nh ol bi translated"><strong class="ak"> ReportsService.js </strong></h2><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="048d" class="nw ms it nr b gy nx ny l nz oa"><strong class="nr iu">const</strong> ReportsService = {<br/>  stats: {<br/>    index: <strong class="nr iu">async</strong> (/* params */) =&gt; {<br/>      <strong class="nr iu">const</strong> response = <strong class="nr iu">await</strong> axios.get('/api-link');<br/>      <strong class="nr iu">return</strong> response.data;<br/>    }<br/>  }<br/>}<br/><strong class="nr iu">export</strong> <strong class="nr iu">default </strong>ReportsService;</span></pre><h2 id="833a" class="nw ms it bd mt ob oc dn mx od oe dp nb li of og nd lm oh oi nf lq oj ok nh ol bi translated"><strong class="ak"> Reports.vue </strong></h2><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="ffb7" class="nw ms it nr b gy nx ny l nz oa"><strong class="nr iu">import</strong> ReportsService <strong class="nr iu">from</strong> '../services/ReportsService';<br/><strong class="nr iu">export default </strong>{<strong class="nr iu"><br/>  </strong>methods: {<br/>    async getStats() {<br/>      this.stats = <strong class="nr iu">await </strong>ReportsService.stats.index(/* params */);<br/>    }<br/>  }<br/>}</span></pre><p id="1a25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用简单的逻辑，我们创建了一个能够与后端API交互或实现应用程序逻辑的服务。然后，我们的Vue组件能够与我们的服务交互，获取它需要的数据，并将其传递给组件，<em class="lv">而不需要</em>知道任何关于我们的API或应用程序逻辑的更多细节。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="e601" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">遵循风格指南</h1><p id="6524" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">深入研究Vue风格指南超出了本文的范围。一般来说，了解你正在使用的框架是如何设计的，以及它们期望你如何使用它们是很重要的。</p><p id="2cba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">框架的创建者有制定风格指南的经验，但是因为社区可能会遵循相同的指南，所以为了一致性，遵循它们也很重要。</p><p id="ff87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些最重要的样式指南规则如下:</p><h2 id="c170" class="nw ms it bd mt ob oc dn mx od oe dp nb li of og nd lm oh oi nf lq oj ok nh ol bi translated">使用data()函数代替数据对象</h2><p id="4688" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">这是<em class="lv">错误的</em>做事方式:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="2060" class="nw ms it nr b gy nx ny l nz oa">export default {<br/>  data: {<br/>    value: 1,<br/>  }<br/>}</span></pre><p id="d8b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是正确的方式:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="9f5d" class="nw ms it nr b gy nx ny l nz oa">export default {<br/>  data() {<br/>    return {<br/>      value: 1,<br/>    }<br/>  }<br/>}</span></pre><p id="42f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之所以必须使用函数而不是对象，是因为使用对象会使同一组件的所有实例都可以改变<code class="fe no np nq nr b">data</code>属性。</p><h2 id="fc3d" class="nw ms it bd mt ob oc dn mx od oe dp nb li of og nd lm oh oi nf lq oj ok nh ol bi translated">总是键入v-for</h2><p id="a117" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">所有的<code class="fe no np nq nr b">v-for</code>循环都必须有一个键传递下去，因为它有助于Vue更有效地呈现你的列表。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="66cc" class="nw ms it nr b gy nx ny l nz oa">&lt;my-item<br/>  v-for="item in items"<br/>  :key="item.id"<br/>  :item="item" /&gt;</span><span id="2129" class="nw ms it nr b gy on ny l nz oa">&lt;!-- or with HTMl elements --&gt;<br/>&lt;div<br/>  v-for="item in items"<br/>  :key="item.id"<br/>&gt;<br/>  {{ item.value }}<br/>&lt;/div&gt;</span></pre><h2 id="1f5f" class="nw ms it bd mt ob oc dn mx od oe dp nb li of og nd lm oh oi nf lq oj ok nh ol bi translated">不要在与<code class="fe no np nq nr b">v-for</code>相同的元素上使用<code class="fe no np nq nr b">v-if</code></h2><p id="c3f4" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">文档很清楚为什么这是个坏主意。不这样做对性能有负面影响——因为Vue需要重新呈现整个列表，即使<code class="fe no np nq nr b">items</code>数组没有改变。</p><p id="9202" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我会解释你可以选择做什么，以及为什么这样更好。</p><p id="754c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而不是…</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="1441" class="nw ms it nr b gy nx ny l nz oa">&lt;div v-for="item in items" v-if="item.shouldShow()"&gt;<br/>  {{ item.value }}<br/>&lt;/div&gt;</span></pre><p id="d04a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…您应该做到以下几点:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="6131" class="nw ms it nr b gy nx ny l nz oa">&lt;div v-for="item in visibleItems"&gt;<br/>    {{ item.value }}<br/>&lt;/div&gt;</span></pre><p id="49fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并将此添加到您的<code class="fe no np nq nr b">computed</code>属性中:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="59a1" class="nw ms it nr b gy nx ny l nz oa">visibleItems() {<br/>  return this.items.filter(item =&gt; {<br/>    return item.shouldShow();<br/>  });<br/>}</span></pre><p id="a82c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的好处如下:</p><ol class=""><li id="8677" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu om mc md me bi translated">只有在<code class="fe no np nq nr b">items</code>数组中发生变化时，计算属性<code class="fe no np nq nr b">visibleItems</code>才会被重新赋值。</li><li id="931f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu om mc md me bi translated"><code class="fe no np nq nr b">v-for</code>只需要处理<code class="fe no np nq nr b">visibleItems</code>数组，而不是整个<code class="fe no np nq nr b">items</code>数组，这使得渲染更加高效。</li><li id="5765" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu om mc md me bi translated">您维护了一个内部逻辑更少的更整洁的模板，这总是好的。请记住，从表示层解耦逻辑可以保持事物的整洁和可维护性。</li></ol><p id="6dbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要进一步阅读风格指南，您可以查看Vue文档的<a class="ae ky" href="https://vuejs.org/v2/style-guide/" rel="noopener ugc nofollow" target="_blank">官方部分。即使你是一个有经验的Vue开发者，你也可以从阅读中学到很多东西。</a></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="36ef" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="a367" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">编写干净且可维护的代码将使与您一起工作的人的生活更加轻松。但这也会让你自己的生活变得更好，因为你要处理的意大利面条式的代码混乱会更少。</p><p id="b47b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在做代码审查，你应该考虑以上的很多因素，以确保你的团队部署了高质量的代码，并长期保持高生产率。</p><p id="1192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢你读到这里！</p></div></div>    
</body>
</html>