<html>
<head>
<title>How to Use Golang Structs With MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在MongoDB中使用Golang结构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-golang-structs-with-mongodb-f1772e4a1da3?source=collection_archive---------2-----------------------#2022-04-12">https://betterprogramming.pub/how-to-use-golang-structs-with-mongodb-f1772e4a1da3?source=collection_archive---------2-----------------------#2022-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7d11" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在这个简短的例子中，我将向您展示如何在Go语言中创建用于MongoDB的结构</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/df7b424e09170e9a2e235a1cbf88c4dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cHvJJm-P3gi5vid8"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Ana Abad 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a1a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了演示Golang结构在MongoDB中的使用，我创建了一个简单的电子邮件自动回复器作为示例。我们想给一些联系人发电子邮件。此外，我们还会在特定时间发送电子邮件，注明主题和内容。最后，我们还有一个将联系人与电子邮件联系起来的序列。</p><p id="3744" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用Golang结构，我们最大限度地减少了代码中BSON的使用，提高了数据库查询结果的可用性。这篇文章可以看作是上一篇文章<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-golang-with-mongodb-26f043d31d23">“如何在MongoDB中使用Go”的延续。</a></p><p id="aaf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接下来的内容中，我会一段一段地检查一个小演示的代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5b9b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">导入相关包</h1><p id="1480" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我们将导入必要的Golang包。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要导入这些库来完成以下任务:</p><ul class=""><li id="bcfc" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated"><code class="fe nk nl nm nn b">context</code>是<a class="ae ky" href="https://www.mongodb.com/docs/drivers/go/current/fundamentals/context/" rel="noopener ugc nofollow" target="_blank">为MongoDB操作创建上下文</a>所必需的。</li><li id="4b26" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated"><code class="fe nk nl nm nn b">bson</code>用于序列化发送到MongoDB服务器的数据。</li><li id="a58f" class="nb nc it lb b lc no lf np li nq lm nr lq ns lu ng nh ni nj bi translated"><code class="fe nk nl nm nn b">mongo</code>处理与MongoDB服务器的连接，并设置数据库和集合。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4cf5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建结构</h1><p id="e3f2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这里的想法是使用Golang结构，而不是像我们在上一篇文章中所做的那样使用<code class="fe nk nl nm nn b">bson</code>序列化。这些结构需要使用<code class="fe nk nl nm nn b">bson</code>注释才能正常工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ec86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面这段代码中，我们可以看到各种<code class="fe nk nl nm nn b">bson</code>注释。</p><p id="3ffc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些注释都遵循相同的模式:</p><blockquote class="nt nu nv"><p id="c23f" class="kz la nw lb b lc ld ju le lf lg jx lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated"><code class="fe nk nl nm nn b">bson:"&lt;fieldname&gt;,omitempty"</code>其中<code class="fe nk nl nm nn b">&lt;fieldname&gt;</code>是数据库中的实际字段名，而<code class="fe nk nl nm nn b">omitempty</code>表示如果没有给出值，该字段将被省略。</p></blockquote><p id="73c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，注释也在向下重音符号之间<strong class="lb iu">，并且没有<strong class="lb iu">没有空格</strong>。</strong></p><p id="ca34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了使用<code class="fe nk nl nm nn b">omitempty</code>，还可以使用其他struct标签(或者根本不使用)。点击阅读更多关于<a class="ae ky" href="https://www.mongodb.com/docs/drivers/go/current/fundamentals/bson/" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="887b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第2、9和16行，我们将<code class="fe nk nl nm nn b">ID</code>字段的类型设置为<code class="fe nk nl nm nn b">primitive.ObjectID</code>。通过这样做，我们告诉BSON这些字段将是实际的MongoDB <code class="fe nk nl nm nn b">ObjectIDs</code>。</p><p id="cfeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，<code class="fe nk nl nm nn b">_id</code>数据库字段将总是被填充，即使我们在定义这些结构的实例时会省略它们(稍后会有更多的介绍)。MongoDB服务器将填充这些字段，并赋予它们惟一的<code class="fe nk nl nm nn b">ObjectIDs</code>。我们将使用这些<code class="fe nk nl nm nn b">ObjectIDs</code>来处理集合中的单个文档。</p><p id="3ff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第5行，我们创建了一个字符串片段。这个切片会自动转换成一个<code class="fe nk nl nm nn b">bson.A</code> (BSON数组)。</p><p id="7a08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第10行，您可以看到也可以使用一个字段<code class="fe nk nl nm nn b">time.Time</code>。</p><p id="535f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第17–18行，我们将引用数据库中的其他文档。这些参考将是<code class="fe nk nl nm nn b">ObjectIDs</code>的列表。在这里，我向你展示两种方法。</p><p id="236d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe nk nl nm nn b">[]interface{}</code>，这是最通用的方法。危险在于您可以在这里放入任何值—包括整数、字符串等。</p><p id="75b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种可能是使用<code class="fe nk nl nm nn b">[]primitive.ObjectID</code>。这是声明类型的一种特定方式。现在只接受<code class="fe nk nl nm nn b">ObjectIDs</code>。这种方法的问题是，我们需要在以后编写更多的代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5562" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">MongoDB连接和数据库设置</h1><p id="f277" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在<code class="fe nk nl nm nn b">main()</code>函数中要做的第一件事是连接到MongoDB服务器，并用包含文档的集合创建数据库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="2be9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第1行和第2行，我们使用<code class="fe nk nl nm nn b">NewClient()</code>和正确的URI为MongoDB创建了一个新的客户端。注意，我的MongoDB运行在端口为<code class="fe nk nl nm nn b">27017</code>的<code class="fe nk nl nm nn b">localhost</code>上。没有设置用户名或密码，因为这是我的测试服务器。</p><p id="9779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第7行，我们使用<code class="fe nk nl nm nn b">context.TODO()</code>创建了一个上下文。这是可能的最基本的上下文。</p><p id="7566" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第9行，我们让客户机用给定的上下文连接到MongoDB服务器。</p><p id="9705" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第14行，我们<code class="fe nk nl nm nn b">defer</code>从MongoDB服务器断开连接。假设<code class="fe nk nl nm nn b">Disconnect()</code>函数被延迟，它将在<code class="fe nk nl nm nn b">main()</code>函数中的所有其他语句运行完之后执行。</p><p id="6604" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第16行，我们创建了一个名为<code class="fe nk nl nm nn b">autoresponder</code>的数据库。</p><p id="aa0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第17–19行，我们在这个数据库中进行了三次收集。这些集合分别被称为<code class="fe nk nl nm nn b">contacts</code>、<code class="fe nk nl nm nn b">emails</code>和<code class="fe nk nl nm nn b">sequences</code>。</p><p id="3102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第21–23行，我们<code class="fe nk nl nm nn b">defer</code>删除数据库集合。这只针对我们的例子，因为我不希望每次运行代码和测试新东西时数据库都被填满。如果您希望将数据保留在数据库中，请删除这些行。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0797" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据库插入</h1><h2 id="688a" class="oa md it bd me ob oc dn mi od oe dp mm li of og mo lm oh oi mq lq oj ok ms ol bi translated">将联系人插入数据库</h2><p id="e828" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们创建一些模拟触点并将它们插入到<code class="fe nk nl nm nn b">contactsCollection</code>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第1–17行，我们创建了三个联系人(MongoDB术语中的“文档”)，创建方式与创建常规结构相同。注意这与我们在这里使用的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-golang-with-mongodb-26f043d31d23"/>(向下滚动页面一半)使用BSON有什么不同。</p><p id="4df6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第19行，我们使用<code class="fe nk nl nm nn b">InsertMany()</code>将这些联系人插入到<code class="fe nk nl nm nn b">contact</code>集合中，因为我们想要一次插入多个文档。</p><p id="015d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第24行，我们使用第19行的结果<code class="fe nk nl nm nn b">insertResult </code>和属性<code class="fe nk nl nm nn b">InsertedIDs</code>获得插入的联系人的id。</p><p id="23a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第26行，我们创建了一个名为<code class="fe nk nl nm nn b">contactIDs_</code>的<code class="fe nk nl nm nn b">[]primitive.ObjectID</code>类型的切片。</p><p id="96c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第17–29行，我们循环返回的<code class="fe nk nl nm nn b">contactIDs</code>，将每个元素转换为<code class="fe nk nl nm nn b">primitive.ObjectID</code>，并将其附加到<code class="fe nk nl nm nn b">contactIDs_</code>。显然，从<code class="fe nk nl nm nn b">[]interface{}</code>到<code class="fe nk nl nm nn b">[]primitive.ObjectID</code>的类型转换无法完成；这就是我们使用<code class="fe nk nl nm nn b">for</code>循环的原因。</p><p id="d167" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们没有自己定义id。当插入文档时，MongoDB自动分配id。这些id保存在实际数据库的<code class="fe nk nl nm nn b">_id</code>字段中，也可以通过使用<code class="fe nk nl nm nn b">ID</code>属性在结构中访问。</p><p id="6dcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第31行，我们打印出<code class="fe nk nl nm nn b">contactIDs_</code>切片来证明我们插入了三个触点，并且类型是正确的。</p><p id="342c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用<a class="ae ky" href="https://www.mongodb.com/products/compass" rel="noopener ugc nofollow" target="_blank"> MongoDB Compass </a>来检查这一点。</p><h2 id="969a" class="oa md it bd me ob oc dn mi od oe dp mm li of og mo lm oh oi mq lq oj ok ms ol bi translated">将电子邮件插入数据库</h2><p id="8629" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，让我们也将一些电子邮件插入到<code class="fe nk nl nm nn b">emailsCollection</code>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与触点的插入非常相似。</p><p id="bfc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里要注意的是，在第3、7和11行中，我们使用<code class="fe nk nl nm nn b">time.Now()</code>作为变量值。</p><p id="22c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第21行，我们从第16行的<code class="fe nk nl nm nn b">InsertMany()</code>操作的返回结果中检索<code class="fe nk nl nm nn b">emailIDs</code>。</p><h2 id="591f" class="oa md it bd me ob oc dn mi od oe dp mm li of og mo lm oh oi mq lq oj ok ms ol bi translated">将序列插入数据库</h2><p id="9b67" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后，让我们也在<code class="fe nk nl nm nn b">sequencesCollection</code>中插入一个序列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="80ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第1行，我们使用<code class="fe nk nl nm nn b">Sequence</code>结构创建了一个序列。在这个结构中，我们放置了之前从插入结果中获取的<code class="fe nk nl nm nn b">emailIDs</code>和<code class="fe nk nl nm nn b">contactIDS_</code>。</p><p id="05cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第3行中，我们使用<code class="fe nk nl nm nn b">InsertOne()</code>而不是之前使用的<code class="fe nk nl nm nn b">InsertMany()</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0932" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据库查询</h1><h2 id="1bd1" class="oa md it bd me ob oc dn mi od oe dp mm li of og mo lm oh oi mq lq oj ok ms ol bi translated">查找特定联系人</h2><p id="2e32" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在下面的代码中，我演示了如何使用自定义过滤器查找联系人。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="cec5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第2行，我们使用<code class="fe nk nl nm nn b">Find()</code>函数来查找满足过滤器<code class="fe nk nl nm nn b">bson.M{"tags": "Customer"}</code>的所有<code class="fe nk nl nm nn b">contacts</code>。通过这个过滤器，我们将找到标签列表中包含<code class="fe nk nl nm nn b">"Customer"</code>的所有联系人。</p><p id="c7a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，您可以根据自己的需要调整这个过滤器。如果要查找所有联系人，可以使用<code class="fe nk nl nm nn b">bson.M{}</code>。或者，如果您希望找到电子邮件地址为<code class="fe nk nl nm nn b">mm@example.com</code>的联系人，您可以写<code class="fe nk nl nm nn b">bson.M{"email":"mm@example.com"}</code>。</p><p id="de30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您可以使用<code class="fe nk nl nm nn b">bson.D</code>而不是使用<code class="fe nk nl nm nn b">bson.M</code>格式进行过滤。更多关于这个<a class="ae ky" href="https://stackoverflow.com/questions/64281675/bson-d-vs-bson-m-for-find-queries" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="bcbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第7行，使用<code class="fe nk nl nm nn b">All()</code>将查询结果加载到名为<code class="fe nk nl nm nn b">contacts</code>的<code class="fe nk nl nm nn b">[]Contact</code>切片中。</p><p id="aac1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第11–15行，我们简单地打印出了<code class="fe nk nl nm nn b">Contact</code>结构的一些属性，就像我们对任何结构所做的那样。</p><p id="56bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们可以最大限度地利用Golang结构，并减少查询中过滤器的BSON使用。</p><h2 id="82f8" class="oa md it bd me ob oc dn mi od oe dp mm li of og mo lm oh oi mq lq oj ok ms ol bi translated">找到序列并检索联系人和电子邮件</h2><p id="550d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面，我们从<code class="fe nk nl nm nn b">sequencesCollection</code>开始恢复序列。我们从这个序列中得到电子邮件id和接收者id。这些id随后用于检索相应的电子邮件和联系人。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0bcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第10–13行，我们使用了<code class="fe nk nl nm nn b">[0]</code>,因为只返回了一个序列。</p><p id="4296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第17行和第23行，我们使用<code class="fe nk nl nm nn b">FindOne()</code>和<code class="fe nk nl nm nn b">bson.M{"_id": &lt;id&gt;}</code>来查找和过滤电子邮件和联系人，只找到一个基于其<code class="fe nk nl nm nn b">ObjectID</code>(在<code class="fe nk nl nm nn b">&lt;id&gt;</code>中)的特定文档。由于只有一个结果，我们也可以使用<code class="fe nk nl nm nn b">Decode()</code>而不是<code class="fe nk nl nm nn b">All()</code>将结果分别提取到<code class="fe nk nl nm nn b">Email</code>和<code class="fe nk nl nm nn b">Contact</code> struct中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="14e2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">完整的代码</h1><p id="de6e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面你可以找到完整的代码。确保在执行代码之前有一个MongoDB服务器在<code class="fe nk nl nm nn b">mongodb://localhost:27017</code>上运行——或者更改URI。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5a38" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><p id="77f6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://www.mongodb.com/blog/post/quick-start-golang--mongodb--modeling-documents-with-go-data-structures" rel="noopener ugc nofollow" target="_blank">MongoDB</a>的“快速入门:Golang &amp; MongoDB —用Go数据结构建模文档”</p><p id="a819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.mongodb.com/docs/drivers/go/current/fundamentals/bson/" rel="noopener ugc nofollow" target="_blank">“与BSON合作”，MongoDB文档</a></p><p id="de11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/64281675/bson-d-vs-bson-m-for-find-queries" rel="noopener ugc nofollow" target="_blank">“bson。d对bson。m用于查找查询”</a></p></div></div>    
</body>
</html>