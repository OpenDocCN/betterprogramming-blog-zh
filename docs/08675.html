<html>
<head>
<title>Turning a Raspberry Pi Into a Controllable Webcam With Background Removal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将树莓派变成可控制的网络摄像头，并去除背景</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/turning-a-raspberry-pi-into-a-controllable-webcam-with-background-removal-54e06a194d6a?source=collection_archive---------5-----------------------#2021-05-28">https://betterprogramming.pub/turning-a-raspberry-pi-into-a-controllable-webcam-with-background-removal-54e06a194d6a?source=collection_archive---------5-----------------------#2021-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="78cb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">带有摄像头模块的Raspberry Pi、Python MJPG流服务器和用于预览和控制网络摄像头的OpenGL/C++客户端</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/83d9079a8fff369246f1a2bced349fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xnRZMdtK-WH65CrxufvZvQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我的Raspberry Pi网络摄像头项目的客户端窗口，具有可调设置和背景移除功能。图片由作者提供。</p></figure><p id="291f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">自疫情开始以来，视频会议已经成为我们许多人的日常习惯，网络摄像头的销量因此增长了309% 。然而，您不必总是为视频通话购买新的网络摄像头。有时候，一个随机的Raspberry Pi相机模块也可以做到这一点。</p><p id="a083" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在几分钟内使用免费且容易获得的软件<a class="ae lu" href="https://medium.com/geekculture/how-to-turn-your-raspberry-pi-into-a-webcam-a8bf775edfb6" rel="noopener">将树莓皮变成网络摄像头</a>。它在大多数情况下都工作得很好，但是我不喜欢缺乏控制和缺少功能。因此，我创建了自己的软件来控制摄像头模块，通过网络传输视频，预览视频，去除背景，最终将其变成虚拟网络摄像头。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b866" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">视频流</h1><p id="080e" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">第一个挑战是将Raspberry Pi摄像头的视频信号传输到我的台式电脑上。在之前的项目中，比如我的<a class="ae lu" href="https://pingpoli.de/raspberry-pi-camera" rel="noopener ugc nofollow" target="_blank">“智能”监控摄像机</a>，我就使用了<a class="ae lu" href="https://github.com/jacksonliam/mjpg-streamer" rel="noopener ugc nofollow" target="_blank"> mjpg-streamer </a>来做这个。然而，当使用mjpg-streamer时，在程序运行时没有办法改变相机的设置。这使mjpg-streamer软件失去了资格，但<a class="ae lu" href="https://en.wikipedia.org/wiki/Motion_JPEG" rel="noopener ugc nofollow" target="_blank"> MJPG协议</a>仍然是通过局域网传输视频信号的一个好选择。MJPG是一种简单的基于HTTP的协议，其中视频帧作为由边界和小报头分隔的独立JPG图像发送。</p><p id="bfb4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与Raspberry Pi相机接口的最佳库是Python中的<a class="ae lu" href="https://picamera.readthedocs.io/en/release-1.13/" rel="noopener ugc nofollow" target="_blank"> picamera </a>模块。所以尽管我不是Python开发者，也不太喜欢Python，我还是用它实现了一个MJPG流服务器。幸运的是，大多数套接字函数与其他语言的函数非常相似，所以让它工作起来并不太困难。使用MJPG作为协议有一个很大的优势:来自Python程序的流仍然可以用其他兼容程序查看，比如VLC媒体播放器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python中的mjpg流循环。它从摄像机获取一帧，并将帧头及其数据写入套接字。下面是完整的源代码。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="572a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">视频显示器</h1><p id="af83" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">有了一个工作的MJPG流服务器，是时候实现一个客户端来查看和控制流了。在之前的项目中，我已经用C++编写了一个MJPG客户端，所以我可以在这个项目中再次使用它。</p><p id="2252" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于用户界面，我正在使用我的OpenGL/C++游戏引擎的菜单库。还有其他的方法也可以，但是我最喜欢自己的代码，我知道它是如何工作的，所以这是我创建UI最快的方法。</p><p id="848c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当客户端接收到一个新的帧时，它会执行一些图像处理步骤，然后更新一个OpenGL纹理。使用OpenGL显示视频还有一个额外的好处，那就是可以使用显卡来实现一些后期处理效果。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1f59" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">相机设置</h1><p id="fdd1" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我想创建自己的网络摄像头软件的主要原因之一是能够在摄像头运行时改变其设置，这在mjpg-streamer解决方案中是不可能的。</p><p id="53f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用picamera模块，可以随时更改相机设置。然而，我不确定通过MJPG流连接发送其他消息是否是个好主意。因为它是多线程的，我需要添加关键部分和安全措施来避免在视频帧中间随机设置数据包。因此，我最终创建了第二个套接字连接来处理所有设置控制消息和其他各种通信，而不会阻塞视频流。</p><p id="6ebc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我想使用普通的C++网络消息，所以我也必须用Python实现它们，这比我想象的要复杂，因为Python和C++在数据类型的大小和对齐上不一定一致。</p><p id="ac2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，设置控件变得非常好。在客户端窗口中，有一个来自相机的raw流的预览，它下面是设置的控制。当您更改一个选项时，会向服务器发送一条消息，将该消息应用到相机模块，预览流会自动即时显示更改。这样，就可以很容易很快地根据自己的喜好调整设置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/9e75e44978098cd76077415565dc0f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*8G7aZAsy6ZikhF1O48vp6A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自摄像机的原始视频流及其下方的设置控制。图片由作者提供。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="34a1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">虚拟网络摄像头</h1><p id="ee9b" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">此时，Raspberry Pi的视频流正在流向我的OpenGL查看器。然而，像Zoom或Teams这样的视频会议程序还不会将其识别为网络摄像头。幸运的是，使用<a class="ae lu" href="https://obsproject.com/" rel="noopener ugc nofollow" target="_blank"> OBS(开放广播软件)</a> <a class="ae lu" href="https://obsproject.com/forum/resources/obs-virtualcam.539/" rel="noopener ugc nofollow" target="_blank"> VirtualCam </a>插件，很容易将任何东西变成虚拟网络摄像头。使用它，您可以创建一个新的窗口捕获，并将其限制为只捕获窗口的输出区域。一旦打开VirtualCam插件，其他程序会将OBS输出识别为常规网络摄像头。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f209" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">背景去除</h1><p id="3c32" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">背景去除是我想创建自己的网络摄像头解决方案的另一个原因。你可能知道，许多视频会议工具都有一个去除背景的选项，通常效果很好。然而，我更喜欢使用大多数工具的浏览器版本。不幸的是，他们没有这个选择。此外，我很好奇是否可以从头开始实现我自己的背景去除算法。</p><p id="77d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用实时视频和图像处理很困难。信号很嘈杂，受光线变化的影响，计算机很难区分图像的哪一部分是人，哪一部分是背景。我的主要想法是闪出画面几秒钟，在此期间只记录背景，并保存一张普通的背景图像。然后，我可以移回到帧中，计算当前图像和背景图像之间的差异。</p><p id="9898" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那个天真的想法有点效果，但并不太好。结果非常嘈杂，我身上的许多斑点被移除，而背景中的一些区域没有被移除。然而，它们中的大多数都很小，所以我想知道是否有可能用图像处理来清理它们。我依稀记得在大学图像处理课上学到的一些东西，随着更多的研究，我发现了看起来很有前途的<a class="ae lu" href="https://scikit-image.org/docs/dev/auto_examples/applications/plot_morphology.html" rel="noopener ugc nofollow" target="_blank">形态滤波器</a>。</p><p id="3b87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">形态学滤波器可以用来去除图像中的小伪像。它们适用于灰度图像，但对二进制图像更有用。二进制图像是只有两种颜色(黑白)的图像，幸运的是，这正是我在这里需要的:前景是白色，背景是黑色的遮罩。我在我的图像库中添加了一个新的二进制图像类，并实现了变形过滤器。通过结合一个开始和一个结束过滤器，结果看起来更好。</p><p id="4527" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我也尝试了其他方法，但带有变形滤镜的图像似乎产生了迄今为止最好的结果。然而，我的背景去除算法远非完美。在某些情况下，它工作得很好，但它仍然受到光线变化或碰撞网络摄像头或桌子的影响，因此背景图像和框架不再对齐。小的照明变化不是问题，因为我可以改变阈值或相机设置来解决它们，但是大的和突然的变化(例如，太阳在乌云后面移动)至少会部分破坏背景去除。还有很多需要改进的地方，我已经有了一些想法，我会在未来尝试。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d8fcd1be12ebdc8e10dae7bac9218727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qBypERChaJlBbV4FJCM8VA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">背景模糊的背景去除算法实例。它并不完美，但在良好的条件下是可以接受的。图片由作者提供。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4fb8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">模糊背景</h1><p id="f3a5" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">使用OpenGL进行视频显示的优势之一是能够使用着色器来实现一些处理效果。不是把背景换成纯色，而是模糊的时候看起来好很多。高斯模糊可以在着色器中有效地实现。这样，图形卡可以完成一些工作，我们不会浪费其他图像处理任务所需的宝贵的CPU时间。</p><h2 id="0cb8" class="nc md it bd me nd ne dn mi nf ng dp mm lh nh ni mo ll nj nk mq lp nl nm ms nn bi translated">其他着色器效果</h2><p id="d500" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">除了模糊图像，着色器还可以用于其他后期处理效果。目前，作为概念验证，我只有一个将图像转换为灰度的选项，但我计划添加其他颜色校正功能来进一步调整输出。因为我的<a class="ae lu" href="https://www.raspberrypi.org/products/pi-noir-camera-v2/" rel="noopener ugc nofollow" target="_blank">相机模块没有红外滤镜</a>，所以有些颜色看起来不真实，我也许可以在帖子中纠正一些。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="22e1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">延时模式</h1><p id="bcfa" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我喜欢用我的树莓皮相机来记录时间流逝。与其他靠电池运行且只能拍摄两小时延时的相机不同，插入式Raspberry Pi可以记录更长时间。所以当我在做这个项目的时候，我决定也加入一个延时模式。</p><p id="2b71" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以前拍摄延时照片时，我将相机的大部分设置为自动，这不是最佳设置。当光线变化时，自动曝光模式会改变图像的亮度，产生的延时视频会闪烁。通过新程序中的实时预览和设置控件，我可以微调设置，并将曝光模式设置为关闭，这样可以产生更平滑的结果。</p><p id="42ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实现延时模式最棘手的部分是断开和重新连接实时预览。相机模块可以拍摄高帧率和低质量的视频帧或高质量的图像。因此，当开始延时拍摄时，我必须关闭MJPG流媒体服务器，并为延时拍摄启动新的图像捕捉循环。停止计时后，将启动一个新的流媒体服务器，客户端可以重新连接到该服务器，以便再次预览。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/6c097d6b2e600a9680c25f065044cabb.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*6tC9_K0gAph5OCNv1oE4CQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用我的树莓派拍摄的一个非常短的延时例子。图片由作者提供。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dcc7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="e885" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在Raspberry Pi网络摄像头程序上工作非常有趣，我学到了很多东西。这绝对是普通网络摄像头的有效替代品。能够独立于其他程序移除背景是一个非常好的好处，所以我可以使用基于浏览器的视频会议工具，并且仍然可以从模糊的背景中获得额外的隐私。如果我感到非常偏执，我可以在自己的程序上使用其他程序的模糊背景功能，以进行双重保护。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ebf1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="7faf" class="no np it la b lb mu le mv lh nq ll nr lp ns lt nt nu nv nw bi translated">Python代码:<a class="ae lu" href="https://gist.github.com/pingpoli/0ee3ef912cdf78085b16c75b702e64e0" rel="noopener ugc nofollow" target="_blank"> main.py </a>，<a class="ae lu" href="https://gist.github.com/pingpoli/185870b652b59a59f71536f16be3f097" rel="noopener ugc nofollow" target="_blank"> RaspiCamServer.py </a>，<a class="ae lu" href="https://gist.github.com/pingpoli/d1a76cd4ad4666a8108b5b09e92d3aa9" rel="noopener ugc nofollow" target="_blank"> RaspiCam.py </a></li><li id="0b55" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><a class="ae lu" href="https://picamera.readthedocs.io/en/release-1.13/" rel="noopener ugc nofollow" target="_blank"> Picamera Python模块</a></li><li id="b08a" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><a class="ae lu" href="https://github.com/jacksonliam/mjpg-streamer" rel="noopener ugc nofollow" target="_blank">mjpg-流光</a></li></ul></div></div>    
</body>
</html>