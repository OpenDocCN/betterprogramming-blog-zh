<html>
<head>
<title>Getting Started With Kustomize</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kustomize入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-kustomize-e9a84c4c2f97?source=collection_archive---------4-----------------------#2021-08-10">https://betterprogramming.pub/getting-started-with-kustomize-e9a84c4c2f97?source=collection_archive---------4-----------------------#2021-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2293" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Kubernetes资源的声明式管理及实践示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bcf4c82e9cfda0ad8bbd26dcab44fe87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GL2P-0Lg8L8UrWvY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@chris_zarriello?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Christopher Zarriello </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="8baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes是著名的容器编制者之一，并导致了围绕它的整个生态系统的发展。它允许组织通过提供多种资源来管理容器部署、副本、扩展、服务发现和通过单个API接口进行联网，从而轻松管理其容器应用程序。</p><p id="8157" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在将这些应用程序部署到生产环境之前，大多数组织都有多个环境来开发和测试这些应用程序。这些环境之间的配置可能会有所不同，并且可能有几个方面需要调整。</p><p id="ca2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有多种方法可以为多种环境管理Kubernetes资源，例如Helm和Kustomize。Helm是最动态的基于模板的Kubernetes资源管理器。然而，你可能不需要所有的头盔。Kustomize是Kubernetes为多种环境管理Kubernetes资源清单的本地方法。它是根据叠加原理来实现的。让我们在下一节了解这两种方法。</p><h1 id="7d96" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">模板与覆盖</h1><p id="abc9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">基于模板的引擎的工作原理是用值替换变量。Helm是一个基于模板的引擎，它允许您通过在通用清单的特定位置声明变量占位符来定义基于模板的通用清单。然后使用变量文件用值替换变量。</p><p id="a730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于覆盖的引擎按照查找和替换的原则工作，即，它搜索清单中的特定部分，并使用基于查找、替换和合并的策略用所需的值替换它们。这允许您创建基本的清单文件，这些文件基本上是标准的Kubernetes资源定义文件，可以独立部署。然后，您可以使用Kustomize根据您的需求进一步定制这些文件。</p><h1 id="3707" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Kustomize如何工作</h1><p id="e4f3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Kustomize使用一个名为<code class="fe ms mt mu mv b">kustomization.yaml</code>的文件，该文件包含声明性的规范，说明需要从什么清单文件中导入什么资源以及需要进行什么更改。一旦处理完资源，它就将它们发送到标准输出，标准输出可以存储在一个文件中，也可以直接与kubectl一起使用，以将其应用到特定的集群。</p><p id="b6a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kustomize的一个优秀用例是管理多个环境的Kubernetes资源。为了让Kustomize在这种情况下工作，您需要一个包含所有公共元素的所有清单文件的<code class="fe ms mt mu mv b">base</code>目录和一个包含特定环境的所有差异的<code class="fe ms mt mu mv b">overlays</code>目录。</p><p id="f51b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解，我们来看一个动手的例子。</p><h1 id="fda9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">先决条件</h1><p id="a087" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您将需要一个运行Kubernetes 1.14或更高版本的Kubernetes集群和一个类似版本的<code class="fe ms mt mu mv b">kubectl</code> CLI。</p><p id="26b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还需要派生这个存储库<a class="ae ky" href="https://github.com/bharatmicrosystems/kustomize-example-app" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ad0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要安装Kustomize。那么，让我们在下一节来看看。</p><h1 id="e572" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">安装Kustomize</h1><p id="bef5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">安装Kustomize有多种方法，你可以在<a class="ae ky" href="https://kubectl.docs.kubernetes.io/installation/kustomize/" rel="noopener ugc nofollow" target="_blank">https://kubectl.docs.kubernetes.io/installation/kustomize/</a>找到。在我们的例子中，我们将使用二进制方法安装它。</p><p id="6314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，请运行以下命令:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="9086" class="na lw it mv b gy nb nc l nd ne">$ curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh"  <strong class="mv iu">|</strong> bash<br/>$ sudo mv kustomize /usr/bin/</span></pre><p id="e3c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经安装了Kustomize，让我们来理解问题陈述以及我们计划实现什么。</p><h1 id="7468" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">问题陈述</h1><p id="2fe0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们有一个web应用程序，希望部署在几个环境中。它具有以下特定于环境的差异:</p><ol class=""><li id="cd60" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">它应该包含一个与其部署环境相对应的<code class="fe ms mt mu mv b">env</code>标签(即开发、测试和生产)。</li><li id="e14a" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">它应该部署在与环境相对应的名称空间上(例如，开发、测试和生产)。</li><li id="3887" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">开发环境中的副本数量应该是一个，测试环境中两个，生产环境中三个。</li><li id="88a6" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">在prod环境中，我们将使用<code class="fe ms mt mu mv b">maxSurge</code> 1和<code class="fe ms mt mu mv b">maxUnavailable</code> 1实现滚动更新策略。</li></ol><p id="0844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们来看看它的目录结构。</p><h1 id="948c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">目录结构</h1><p id="fa23" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将在两个文件<code class="fe ms mt mu mv b">deployment.yaml</code>和<code class="fe ms mt mu mv b">service.yaml</code>中创建一个<code class="fe ms mt mu mv b">Deployment</code>和一个<code class="fe ms mt mu mv b">Service</code>资源。目录结构如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="94a0" class="na lw it mv b gy nb nc l nd ne">kustomize-example-app/<br/>├── base<br/>│   ├── deployment.yaml<br/>│   ├── kustomization.yaml<br/>│   └── service.yaml<br/>└── overlays<br/>    ├── dev<br/>    │   ├── deployment.yaml<br/>    │   ├── kustomization.yaml<br/>    │   ├── namespace.yaml<br/>    │   └── service.yaml<br/>    ├── prod<br/>    │   ├── deployment.yaml<br/>    │   ├── kustomization.yaml<br/>    │   ├── namespace.yaml<br/>    │   └── service.yaml<br/>    └── test<br/>        ├── deployment.yaml<br/>        ├── kustomization.yaml<br/>        ├── namespace.yaml<br/>        └── service.yaml</span></pre><p id="c77a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">base</code>目录包含基本清单和一个<code class="fe ms mt mu mv b">kustomization.yaml</code>文件，该文件包含三个环境之间的所有公共元素。<code class="fe ms mt mu mv b">overlays</code>目录包括分别用于<code class="fe ms mt mu mv b">dev</code>、<code class="fe ms mt mu mv b">test</code>和<code class="fe ms mt mu mv b">prod</code>的目录。因为我们只是简单地改变了开发、测试和生产环境中的<code class="fe ms mt mu mv b">Deployment</code>和<code class="fe ms mt mu mv b">Service</code>资源的属性，所以我们为它们分别准备了一个清单。然而，清单将只包含资源之间的差异。</p><p id="4725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们先来看一下<code class="fe ms mt mu mv b">base</code>目录。</p><h1 id="a175" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基本配置</h1><p id="6958" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在<code class="fe ms mt mu mv b">base</code>目录中，<code class="fe ms mt mu mv b">deployment.yaml</code>文件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8f0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">service.yaml</code>文件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="329b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了让Kustomize工作，我们需要创建一个类似如下的<code class="fe ms mt mu mv b">kustomization.yaml</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="501b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，Kustomization文件像任何其他Kubernetes资源一样包含了<code class="fe ms mt mu mv b">apiVersion</code>和<code class="fe ms mt mu mv b">kind</code>属性。根据您的计划，该文件也可以有几个部分。在这种情况下，由于我们只是试图在Kustomization中导入<code class="fe ms mt mu mv b">Deployment</code>和<code class="fe ms mt mu mv b">Service</code>，我们使用<code class="fe ms mt mu mv b">resources</code>部分来完成。</p><p id="8995" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在<code class="fe ms mt mu mv b">base</code>目录上运行<code class="fe ms mt mu mv b">kustomize build</code>命令时，Kustomize发出一个清单yaml，它是两者的组合。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们来看一下特定于环境的配置。</p><h1 id="e256" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">特定于环境的配置</h1><p id="c3a8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，我们将重点放在<code class="fe ms mt mu mv b">overlays</code>目录上。我们在<code class="fe ms mt mu mv b">overlays</code>目录中有针对<code class="fe ms mt mu mv b">dev</code>、<code class="fe ms mt mu mv b">test</code>和<code class="fe ms mt mu mv b">prod</code>环境的目录。我们先来看看<code class="fe ms mt mu mv b">dev</code>目录的内容。</p><h2 id="df08" class="na lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">开发配置</h2><p id="8bbf" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe ms mt mu mv b">namespace.yaml</code>文件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="4e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，基本配置中没有这一点，因为命名空间会随着环境而变化。</p><p id="0e94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们来看一下<code class="fe ms mt mu mv b">kustomization.yaml</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="cd0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，你可以看到有几个部分。让我们来详细了解一下每一项:</p><ul class=""><li id="207b" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu og nl nm nn bi translated"><code class="fe ms mt mu mv b">bases </code> —此部分包含对<code class="fe ms mt mu mv b">base</code>目录的引用。</li><li id="19bb" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu og nl nm nn bi translated"><code class="fe ms mt mu mv b">commonLables</code> —本节定义了我们希望应用于Kustomize生成的所有资源的任何通用标签。根据我们的要求，我们给了标签<code class="fe ms mt mu mv b">env:dev</code>。</li><li id="bc1b" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu og nl nm nn bi translated"><code class="fe ms mt mu mv b">resources </code> —此部分包含我们想要添加到Kustomize配置中的任何附加资源。因为我们在这里指定了一个额外的清单文件<code class="fe ms mt mu mv b">namespace.yaml</code>。</li><li id="862e" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu og nl nm nn bi translated"><code class="fe ms mt mu mv b">namespace </code> —此部分定义了应该在其中部署资源的任何公共名称空间。这种情况下就是<code class="fe ms mt mu mv b">dev</code>。</li></ul><p id="9efd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们在<code class="fe ms mt mu mv b">dev</code>目录上运行<code class="fe ms mt mu mv b">kustomize build</code>，看看我们会得到什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="326c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，它符合我们的所有要求。</p><p id="5394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将清单应用到Kubernetes集群，我们可以使用下面的kubectl命令:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="9142" class="na lw it mv b gy nb nc l nd ne">$ kubectl apply -k overlays/dev<br/>namespace/dev created<br/>service/nginx-service created<br/>deployment.apps/nginx-deployment created</span></pre><p id="2798" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，这三个资源都已创建。让我们使用下面的代码列出<code class="fe ms mt mu mv b">dev</code>名称空间中的所有资源:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！现在，我们有了一个<code class="fe ms mt mu mv b">Deployment</code>，其中一个副本<code class="fe ms mt mu mv b">Pod</code>由负载平衡器<code class="fe ms mt mu mv b">Service</code>公开。所有这些资源都被部署到<code class="fe ms mt mu mv b">dev</code>名称空间，并包含标签<code class="fe ms mt mu mv b">env: dev</code>。</p><p id="e283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们转到<code class="fe ms mt mu mv b">test</code>目录，看看那里有什么。</p><h2 id="9403" class="na lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">测试配置</h2><p id="b8c0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在<code class="fe ms mt mu mv b">test</code>目录中，我们有以下<code class="fe ms mt mu mv b">namespace.yaml</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7c63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，我们还有下面的<code class="fe ms mt mu mv b">deployment.yaml</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e1d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个<code class="fe ms mt mu mv b">deployment.yaml</code>文件的原因是因为我们想将测试环境中的副本数量从1个改为2个。</p><p id="b3f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们来看看<code class="fe ms mt mu mv b">kustomization.yaml</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="07fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数部分都类似于dev <code class="fe ms mt mu mv b">kustomization.yaml</code>文件。不过我们这里多了一段，也就是<code class="fe ms mt mu mv b">patchesStrategicMerge</code>。在其中，我们声明了<code class="fe ms mt mu mv b">deployment.yaml</code>文件，它只包含增量配置(补丁)，即副本的数量。<code class="fe ms mt mu mv b">patchesStrategicMerge</code>将用补丁yaml文件中声明的配置为与资源<code class="fe ms mt mu mv b">name</code>、<code class="fe ms mt mu mv b">kind</code>和<code class="fe ms mt mu mv b">apiVersion</code>匹配的所有资源打补丁。</p><p id="3d14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在<code class="fe ms mt mu mv b">test</code>目录上运行kustomize构建时，我们将得到以下结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="9ce2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们使用以下命令将其应用到我们的Kubernetes集群:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="ec3e" class="na lw it mv b gy nb nc l nd ne">$ kubectl apply -k overlays/testnamespace/test created<br/>service/nginx-service created<br/>deployment.apps/nginx-deployment created</span></pre><p id="ba60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，让我们使用下面的命令获取部署在<code class="fe ms mt mu mv b">test</code>名称空间中的所有资源的详细信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="36d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，这次我们有一个<code class="fe ms mt mu mv b">Deployment</code>运行两个副本。</p><p id="8e02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们继续看prod的例子。</p><h2 id="a56a" class="na lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">生产配置</h2><p id="3115" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">产品目录由类似于<code class="fe ms mt mu mv b">test</code>和<code class="fe ms mt mu mv b">dev</code>配置的<code class="fe ms mt mu mv b">namespace.yaml</code>组成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8d47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还包含以下<code class="fe ms mt mu mv b">deployment.yaml</code>补丁清单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e0ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个补丁包含三个<code class="fe ms mt mu mv b">Deployment</code>副本，以及一个类型为<code class="fe ms mt mu mv b">RollingUpdate</code>、<code class="fe ms mt mu mv b">maxSurge</code> 1和<code class="fe ms mt mu mv b">maxUnavailable</code> 1的部署<code class="fe ms mt mu mv b">strategy</code>部分。</p><p id="693e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来看看<code class="fe ms mt mu mv b">kustomization.yaml</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a7a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个与我们在<code class="fe ms mt mu mv b">test</code>中的相似。现在，让我们继续运行<code class="fe ms mt mu mv b">kustomize build</code>，看看如果应用它我们会得到什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="d055" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如我们所见，<code class="fe ms mt mu mv b">replicas</code>和<code class="fe ms mt mu mv b">strategy</code>部分已正确填写。现在，让我们使用以下命令来应用它:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="b2a6" class="na lw it mv b gy nb nc l nd ne">$ kubectl apply -k overlays/prod<br/>namespace/prod created<br/>service/nginx-service created<br/>deployment.apps/nginx-deployment created</span></pre><p id="03c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们列出<code class="fe ms mt mu mv b">prod</code>名称空间中的所有资源，自己看看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ef3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们看到的，我们现在有三个副本在运行。</p><p id="4c4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试使用<code class="fe ms mt mu mv b">curl</code>到达<code class="fe ms mt mu mv b">Service</code>端点，看看我们会得到什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b947" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到默认的NGINX响应！这证明设置工作正常。</p><h1 id="1596" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="b122" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">显然，这是对Kustomize是什么以及我们如何有效地使用它的一个初步了解。使用Kustomize还有很多其他方法和途径，我认为这将是未来故事中一个有趣的探索。</p><p id="c260" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望你喜欢这篇文章！</p></div></div>    
</body>
</html>