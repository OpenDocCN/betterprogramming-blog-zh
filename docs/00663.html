<html>
<head>
<title>Creating CSV and ZIP files With Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node.js创建CSV和ZIP文件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-csv-and-zip-files-with-node-js-4ca136852019?source=collection_archive---------3-----------------------#2019-06-27">https://betterprogramming.pub/creating-csv-and-zip-files-with-node-js-4ca136852019?source=collection_archive---------3-----------------------#2019-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="caf5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">详细的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3ca80e87f3bbf617a22a37fb725f688a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0fs9Hl5ffph5IhoMXvpMtg.png"/></div></div></figure><p id="72fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Node.js有一个非常健壮的文件管理系统，有很多本地文件操作功能。除了Node强大的原生特性，<a class="ae lq" href="https://stuk.github.io/jszip/" rel="noopener ugc nofollow" target="_blank"> JSZip </a>是一个方便的JavaScript库，用于创建、读取和编辑Zip文件。我将在这篇文章的后面更深入地讨论它，但是现在，这里是文件生成的一些上下文。</p><p id="d13b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用户需要能够生成一个裸数据模板，以便稍后提交。该模板由不同的<a class="ae lq" href="https://www.lifewire.com/csv-file-2622708" rel="noopener ugc nofollow" target="_blank"> CSV文件</a>组成，将用于数据处理。总共有六个CSV文件，但是需要根据用户输入动态生成一个文件。姑且称之为<code class="fe lr ls lt lu b">nums.csv</code>。</p><p id="9f8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lv">注意:由于我们的其他文件是静态的，所以它们会保存在项目中自己的模板目录中，以供参考。稍后会详细介绍。</em></p><p id="2017" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">nums.csv</code>需要能够拥有从1到10的行，这取决于用户的输入。行数在如何处理数据方面起着关键作用。在我们处理这个文件之前，让我们看看我们的UI，它是使用<a class="ae lq" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>和<a class="ae lq" href="https://ant.design/" rel="noopener ugc nofollow" target="_blank"> Ant Design </a>构建的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/bac27f9ed271ad168e21fb31b01263cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*rexHjo4bwiN5Ct9bjl_1Bw.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">我们将使用Ant Design的<a class="ae lq" href="https://ant.design/components/button/" rel="noopener ugc nofollow" target="_blank">按钮</a>和<a class="ae lq" href="https://ant.design/components/input-number/" rel="noopener ugc nofollow" target="_blank">输入数字</a>组件</p></figure><p id="f935" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们有一个按钮，当点击时，显示我们的数字输入和提交按钮。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/3862fe7df2b96c68aa14592225f8391d.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*qVt32Ox8zORPOPRP28X-YQ.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">当输入/提交按钮打开时，我们原来的按钮的文本变为关闭。</p></figure><p id="9add" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用户选择想要生成多少个<code class="fe lr ls lt lu b">nums </code>(对应于行数和这些行中的值)。他们输入的数字存储在state中。当他们点击<em class="lv">下载</em>时，<code class="fe lr ls lt lu b">createTemplate</code>被执行。见下文。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="997e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了创建可行的CSV内容，我们需要为每一行创建数组。数组中的信息将与行相对应。在第一行，我们初始化一个名为<code class="fe lr ls lt lu b">rows</code>的数组，包含一个字符串数组(<em class="lv"> Id </em>、<em class="lv"> Name </em>和<em class="lv"> SortOrder </em>)。这些将是我们的<code class="fe lr ls lt lu b">nums.csv</code> <em class="lv"> </em>文件中的列标题。</p><p id="cb1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，<code class="fe lr ls lt lu b">createTemplate</code>使用<code class="fe lr ls lt lu b">this.state.nums</code>来决定为我们的rows变量生成多少行。如果<code class="fe lr ls lt lu b">this.state.nums</code>是三，那么该函数将添加一个包含Id、Name和SortOrder值的数组(行)三次。第一行<em class="lv"> </em>的Id为1，名称为<code class="fe lr ls lt lu b">NUM 1</code>，排序顺序为1。</p><p id="895b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们有了数组(行)的数组，我们就声明变量<code class="fe lr ls lt lu b">csvContent</code>。<code class="fe lr ls lt lu b">csvContent</code>将以字符串的形式存储CSV数据。我们需要映射<code class="fe lr ls lt lu b">rows</code>，并对每个数组元素执行<code class="fe lr ls lt lu b">.join(",")</code>。这将把每个数组转换成一个字符串。为什么我们用逗号连接数据？逗号是CSV文件分隔列值的方式。事实上，CSV代表<em class="lv">逗号分隔值</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi me"><img src="../Images/cdd4ad8c50b15a29d02a441434bfcdfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/1*sNvTfbPsjFFbU34cjM5wVQ.gif"/></div></figure><p id="ab29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们有一个字符串数组。最终确定CSV字符串内容的最后一步是对字符串数组执行另一个<code class="fe lr ls lt lu b">.join()</code>。我们的字符串数组目前看起来像这样:</p><pre class="kj kk kl km gt mf lu mg mh aw mi bi"><span id="03b4" class="mj mk it lu b gy ml mm l mn mo">["Id,Name,SortOrder", "1,NUM 1,1", "2,NUM 2,2", "3,NUM 3,3"]</span></pre><p id="b3bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们用<code class="fe lr ls lt lu b">\n</code>连接我们的数据，因为这个字符表示换行符。如果我们不包括这一点，我们所有的数据将出现在同一行。<code class="fe lr ls lt lu b">\n</code>允许我们在移动到下一个元素时开始新的一行。所以<code class="fe lr ls lt lu b">\n</code>会在Id，Name，SortOrder和before 1，NUM 1，1之间开始一个新行。在这一切的最后，<code class="fe lr ls lt lu b">csvContent</code>看起来会是这样的:</p><pre class="kj kk kl km gt mf lu mg mh aw mi bi"><span id="11a1" class="mj mk it lu b gy ml mm l mn mo">"Id,Name,SortOrder<br/>1,NUM 1,1<br/>2,NUM 2,2<br/>3,NUM 3,3"</span></pre><p id="833b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来的几个步骤将把我们从上面笨拙的字符串带到下面有组织的数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/d594fdc5604e925fa8bf0bbec3cec05f.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*QG4Zozns-yLw1Z5QTQA3cw.png"/></div></figure><p id="d15f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有了我们的<code class="fe lr ls lt lu b">csvContent</code>，我们可以把它传递给<code class="fe lr ls lt lu b">this.props.createTemplate</code>。该功能将<code class="fe lr ls lt lu b">{csv: csvContent}</code>传递给动作。当动作被分派时，一个请求被发送到控制器。我们将在控制器中创建文件。</p><p id="a2cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们进入函数之前，我们需要这些本地节点依赖关系:</p><pre class="kj kk kl km gt mf lu mg mh aw mi bi"><span id="965c" class="mj mk it lu b gy ml mm l mn mo">path = require(“path”),<br/>fs = require(“fs”) <br/>//don’t need npm install for either of these</span></pre><p id="9d19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以及用于创建zip文件的npm包JSZip。</p><pre class="kj kk kl km gt mf lu mg mh aw mi bi"><span id="a607" class="mj mk it lu b gy ml mm l mn mo">JSZip = require(“jszip”); //npm install needed</span></pre><p id="0be3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以开始创建所有文件的函数了，<code class="fe lr ls lt lu b">createTemplate</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="fe88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个函数有很多代码，我们一行一行来看。</p><pre class="kj kk kl km gt mf lu mg mh aw mi bi"><span id="73a4" class="mj mk it lu b gy ml mm l mn mo">const dir = path.resolve(__dirname) + '/template/';</span></pre><p id="7152" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一行声明了前面提到的其他五个CSV文件所在的目录。见下文。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/74a01c92cac8c27df49e759736e7b184.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*P0oCuW5sOvlpOEJ86oNmzw.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">路径可以表示为{PROJECT_DIRECTORY}/template/…</p></figure><p id="2b78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要这个路径来读取其他文件的文件数据并压缩它们，以及传递的<code class="fe lr ls lt lu b">nums.csv</code>数据。<code class="fe lr ls lt lu b">path.resolve()</code>将当前模块的目录名(<code class="fe lr ls lt lu b">__dirname</code>)解析为绝对路径(<code class="fe lr ls lt lu b">/template/</code>)。这样我们就不必根据环境改变路径，它总是相对于项目目录。</p><pre class="kj kk kl km gt mf lu mg mh aw mi bi"><span id="7b46" class="mj mk it lu b gy ml mm l mn mo">var zip = new JSZip();<br/><br/>zip.file('nums.csv', req.body.body.csv) </span></pre><p id="70c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这几行代码创建了JSZip(我们的Zip文件)的一个实例，然后将我们的<code class="fe lr ls lt lu b">nums.csv</code>文件添加到其中。<code class="fe lr ls lt lu b">.file()</code>是一个JSZip函数，允许我们向Zip文件中添加一个文件，并给它一个文件名。<code class="fe lr ls lt lu b">req.body.body.csv</code>是我们作为有效载荷发送的<code class="fe lr ls lt lu b"> csvContent</code>。</p><p id="7410" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们继续进行<code class="fe lr ls lt lu b"><a class="ae lq" href="https://nodejs.org/api/fs.html#fs_fs_readdir_path_options_callback" rel="noopener ugc nofollow" target="_blank">fs.readdir</a>()</code>。</p><p id="a84b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">fs</code>是节点与<a class="ae lq" href="https://nodejs.org/api/fs.html" rel="noopener ugc nofollow" target="_blank">文件系统</a>交互的模块。<code class="fe lr ls lt lu b">fs.readdir()</code>读取给定的目录，并执行回调函数。这个回调包含两个参数，文件(文件名及其扩展名)和<code class="fe lr ls lt lu b">err</code>，这代表了<code class="fe lr ls lt lu b">fs.readdir</code>可能遇到的错误。对于我们的例子，我们使用这个函数读取我们的<code class="fe lr ls lt lu b">dir</code>变量来访问<code class="fe lr ls lt lu b">/template/</code>中的文件。回调函数之前的<code class="fe lr ls lt lu b"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function#Simple_example" rel="noopener ugc nofollow" target="_blank">async</a></code>至关重要，因为我们希望异步读取文件。这确保了我们不会在之前返回数据<em class="lv">我们已经能够读取所有的文件并将它们添加到我们的zip中。接下来，我们需要看一下<code class="fe lr ls lt lu b"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">promises</a></code>。</em></p><pre class="kj kk kl km gt mf lu mg mh aw mi bi"><span id="c0e4" class="mj mk it lu b gy ml mm l mn mo">var promises = files.map(function(_path){...} </span></pre><p id="8b13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们映射文件并为每个文件名返回一个<code class="fe lr ls lt lu b">Promise</code>，因为我们想要执行另一个异步动作<code class="fe lr ls lt lu b"><a class="ae lq" href="https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback" rel="noopener ugc nofollow" target="_blank">fs.readFile()</a></code>。在文件的<em class="lv">数据</em>(不仅仅是文件名和扩展名)被读取之前，我们不想返回任何数据。</p><p id="c82f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果没有承诺，该函数将返回一个空对象作为响应，因为该函数将继续运行，而不会等待<code class="fe lr ls lt lu b">fs.readFile()</code>。我们一会儿将重温承诺，但是现在，让我们继续讨论<code class="fe lr ls lt lu b">fs.readFile()</code>。</p><pre class="kj kk kl km gt mf lu mg mh aw mi bi"><span id="5f9e" class="mj mk it lu b gy ml mm l mn mo">fs.readFile(dir + _path, 'utf8', function(err, data){</span><span id="1694" class="mj mk it lu b gy mr mm l mn mo">  if(err){<br/>    <em class="lv">console</em>.log(err);<br/>    resolve("");<br/>  } else {<br/>    resolve({filename: _path, content: data});<br/>  }</span><span id="0086" class="mj mk it lu b gy mr mm l mn mo">});</span></pre><p id="fbe3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们连接<code class="fe lr ls lt lu b">dir + _path</code>来创建访问我们目录中的文件所需的绝对路径。如果是<code class="fe lr ls lt lu b">dir === 'ROOT_PROJECT_DIRECTORY/template/'</code>和<code class="fe lr ls lt lu b">_path === file.csv</code>，那么连接两者将得到<code class="fe lr ls lt lu b">'ROOT_PROJECT_DIRECTORY/template/file.csv'</code>，这是该文件的绝对路径。<code class="fe lr ls lt lu b"><a class="ae lq" href="https://www.w3schools.com/charsets/ref_html_utf8.asp" rel="noopener ugc nofollow" target="_blank">'utf8'</a></code>指定编码格式，我们接受<code class="fe lr ls lt lu b">err</code>和<code class="fe lr ls lt lu b">data</code>的回调函数将解析或拒绝当前的<code class="fe lr ls lt lu b">Promise</code>。</p><p id="221f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">data</code>是读取的文件数据(文件的实际内容)。当我们有了这些数据，我们就把它作为一个对象。该对象将包含文件名以及文件内容。当我们想把它添加到我们的zip中时，这是很重要的。在那之前，我们还有一步。就一次，我保证。</p><p id="9bcc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看看这部分街区:</p><pre class="kj kk kl km gt mf lu mg mh aw mi bi"><span id="2a24" class="mj mk it lu b gy ml mm l mn mo">}.bind(this, _path));</span></pre><p id="d510" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一行允许我们维护<code class="fe lr ls lt lu b">this</code>和<code class="fe lr ls lt lu b">_path</code>的<a class="ae lq" href="https://whatis.techtarget.com/definition/lexical-scoping-static-scoping" rel="noopener ugc nofollow" target="_blank">词法</a>值，否则它们会在我们的异步函数中丢失。我们的<code class="fe lr ls lt lu b">_path</code>将是<code class="fe lr ls lt lu b">undefined</code>，我们的<code class="fe lr ls lt lu b">Promise</code>将被拒绝。在这一行之后，我们应该有一个可以传递给<code class="fe lr ls lt lu b"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank">Promise.all()</a></code>的<code class="fe lr ls lt lu b">Promises</code>数组。</p><p id="e20f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank">Promise.all()</a></code>接收数组，当数组中的所有<code class="fe lr ls lt lu b">Promises</code>都被解析后，返回一个解析的<code class="fe lr ls lt lu b">Promise</code>。现在我们终于可以开始向JSZip实例添加文件数据了。这是从<code class="fe lr ls lt lu b">Promise.all()</code>之后的<code class="fe lr ls lt lu b"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" rel="noopener ugc nofollow" target="_blank">.then()</a></code>开始的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="c37e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">.then()</code>使我们能够执行一个回调函数来处理我们的<code class="fe lr ls lt lu b">Promise</code>，无论它是已解决的还是被拒绝的。我们可以从这里开始向zip文件添加文件。</p><pre class="kj kk kl km gt mf lu mg mh aw mi bi"><span id="bcfa" class="mj mk it lu b gy ml mm l mn mo">results.forEach((obj)=&gt;{<br/>   zip.file(obj.filename,obj.content);<br/>})</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/1d30042e200dfba3a8848520c2e551cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*N3stxHJ8R-UIs90JxaxAKQ.gif"/></div></figure><p id="f505" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，我们迭代数组并使用JSZip的<code class="fe lr ls lt lu b">.file()</code>。这个函数接受两个参数，文件名和文件内容。这将在用户提取zip文件时使用。<code class="fe lr ls lt lu b">obj.filename</code>将指向<code class="fe lr ls lt lu b">obj.content</code>(很像Mac的Finder或Window的文件浏览器中文件名与实际文件的对应关系)。最后，我们转移到回调的<code class="fe lr ls lt lu b">try</code>和<code class="fe lr ls lt lu b">catch</code>部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="def7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch" rel="noopener ugc nofollow" target="_blank"> try and catch </a>语句将<em class="lv"> try </em>一个语句(在我们的例子中是Promise ),如果这个尝试失败了，<em class="lv">将会捕获</em>错误并相应地处理它。</p><p id="4a93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的尝试中，我们将使用<code class="fe lr ls lt lu b"><a class="ae lq" href="https://stuk.github.io/jszip/documentation/howto/write_zip.html" rel="noopener ugc nofollow" target="_blank">.generateAsync()</a></code>来异步设置zip的文件类型。<code class="fe lr ls lt lu b"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding" rel="noopener ugc nofollow" target="_blank">base64</a></code>是编码/解码二进制数据的标准类型，旨在通过媒体存储和传输。我们添加了另一个<code class="fe lr ls lt lu b">.then()</code>，其中我们将把生成的zip文件作为JSON响应发送回去。在我们的对象中，我们传递了<em class="lv">标题</em>(我们希望我们的zip被命名的内容)和<em class="lv">内容</em>(zip数据)。</p><p id="28d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回到动作，接收响应并下载zip文件。</p><p id="d968" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">见下文。</p><pre class="kj kk kl km gt mf lu mg mh aw mi bi"><span id="1fa1" class="mj mk it lu b gy ml mm l mn mo">var file_path = "data:application/zip;base64," + payload.content;<br/>var a = <em class="lv">document</em>.createElement("A");<br/>a.href = file_path;<br/>a.download = payload.title;<br/><em class="lv">document</em>.body.appendChild(a);<br/>a.click();<br/><em class="lv">document</em>.body.removeChild(a);</span></pre><p id="f9ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们创建一个锚标签，有一个<code class="fe lr ls lt lu b">download</code>属性，一个<code class="fe lr ls lt lu b">href</code>等于<code class="fe lr ls lt lu b">file_path</code>。</p><p id="72a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">file_path</code>利用一个<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs" rel="noopener ugc nofollow" target="_blank">数据URL </a>。在这个URL中，我们包含了<code class="fe lr ls lt lu b">application/zip</code>来指定<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types" rel="noopener ugc nofollow" target="_blank"> MIME类型</a>，以及一个<code class="fe lr ls lt lu b">base64</code>标记(表示文件不是文本的)，然后我们从响应中追加实际的文件数据。<code class="fe lr ls lt lu b">download</code>属性被赋予<code class="fe lr ls lt lu b">title</code>(也来自响应)，一旦文件数据被下载，它将被应用于文件数据。</p><p id="2ecc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将anchor标记附加到我们的文档主体，在anchor上执行<code class="fe lr ls lt lu b">.click()</code>，模拟一个触发下载的click事件。下载完成后，该元素将从我们的文档体中删除，以避免其他人使用相同的下载。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="f579" class="na mk it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">摘要</h1><p id="b967" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">这是开发步骤的分解。</p><ul class=""><li id="b7ce" class="nw nx it kw b kx ky la lb ld ny lh nz ll oa lp ob oc od oe bi translated">获取用户输入以生成CSV文件数据，存储为字符串。</li><li id="302f" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated">在请求中将该字符串发送到我们控制器中的<code class="fe lr ls lt lu b">createTemplate</code>。</li><li id="0fe9" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated">实例化一个JSZip实例。</li><li id="a176" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated">将CSV字符串添加到JSZip实例中。</li><li id="27be" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated">异步遍历项目目录，将每个文件的数据存储在一个<code class="fe lr ls lt lu b">Promise</code>中。</li><li id="a06f" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated">将所有的<code class="fe lr ls lt lu b">Promises</code>分解成一个。</li><li id="e052" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated">我们遍历了Promise中的文件，并使用<code class="fe lr ls lt lu b">.file()</code>将它们附加到JSZip实例中。</li><li id="3c58" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated">使用<code class="fe lr ls lt lu b">.generateAsync()</code>从我们的JSZip实例中异步生成zip内容。</li><li id="7010" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated">发回了一个包含压缩文件数据和文件名的JSON响应。</li><li id="2848" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated">创建了一个带有<code class="fe lr ls lt lu b">download</code>属性的锚点标签。</li><li id="89ac" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated">从响应数据URL <strong class="kw iu"> </strong>中追加的文件数据在我们的锚标签的<code class="fe lr ls lt lu b">href</code>中。</li><li id="9395" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated">使用<code class="fe lr ls lt lu b">.click()</code>启动下载，然后从DOM中删除锚标记，以防止未经授权的使用。</li></ul><p id="59b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你喜欢这篇文章或者需要澄清任何提到的事情，请在评论中告诉我！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="03af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在此  <em class="lv">将您的免费媒体会员升级为付费会员，每月只需5美元，您就可以收到来自各种出版物上数千名作家的无限量无广告故事。这是一个附属链接，你的会员资格的一部分帮助我为我创造的内容获得奖励。谢谢大家！</em></p><h1 id="8b5f" class="na mk it bd nb nc ok ne nf ng ol ni nj jz om ka nl kc on kd nn kf oo kg np nq bi translated">参考</h1><div class="op oq gp gr or os"><a href="https://stuk.github.io/jszip/" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">JSZip</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">创造。使用JavaScript压缩文件。提供一个简单的API将JavaScript生成的任何内容放入一个. zip文件…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">stuk.github.io</p></div></div></div></a></div><div class="op oq gp gr or os"><a href="https://www.lifewire.com/csv-file-2622708" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">什么是CSV文件，如何打开它？</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">CSV文件是逗号分隔值文件。所有CSV文件都是纯文本文件，只能包含数字和字母…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">www.lifewire.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://nodejs.org/api/fs.html" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">文件系统| Node.js v12.4.0文档</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">在POSIX系统上，对于每个进程，内核维护一个当前打开的文件和资源的表。每个打开的文件…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">nodejs.org</p></div></div></div></a></div><div class="op oq gp gr or os"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">承诺</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">Promise对象表示异步操作的最终完成(或失败),及其结果…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">developer.mozilla.org</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">文件系统| Node.js v12.4.0文档</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">在POSIX系统上，对于每个进程，内核维护一个当前打开的文件和资源的表。每个打开的文件…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">nodejs.org</p></div></div></div></a></div><div class="op oq gp gr or os"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function#Simple_example" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">异步功能</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">异步函数声明定义了一个异步函数，该函数返回一个异步函数对象。</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">developer.mozilla.org</p></div></div><div class="pb l"><div class="pi l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">文件系统| Node.js v12.4.0文档</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">在POSIX系统上，对于每个进程，内核维护一个当前打开的文件和资源的表。每个打开的文件…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">nodejs.org</p></div></div></div></a></div><div class="op oq gp gr or os"><a href="https://whatis.techtarget.com/definition/lexical-scoping-static-scoping" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">什么是词法范围(静态范围)？-WhatIs.com的定义</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">词法作用域(有时称为静态作用域)是许多编程语言使用的一种约定，它设置了…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">whatis.techtarget.com</p></div></div><div class="pb l"><div class="pj l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">Promise.all()</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">Promise.all()方法返回一个承诺，当作为iterable传递的所有承诺都有…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">developer.mozilla.org</p></div></div><div class="pb l"><div class="pk l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">Promise .原型. then()</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">then()方法返回一个承诺。它需要两个参数:成功和失败情况下的回调函数…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">developer.mozilla.org</p></div></div><div class="pb l"><div class="pl l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">尝试...捕捉</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">尝试...catch语句标记要尝试的语句块，并指定在引发异常时的响应。</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">developer.mozilla.org</p></div></div><div class="pb l"><div class="pm l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://stuk.github.io/jszip/documentation/howto/write_zip.html" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">如何编写文件/将文件交给用户</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">创造。使用JavaScript压缩文件。提供一个简单的API将JavaScript生成的任何内容放入一个. zip文件…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">stuk.github.io</p></div></div></div></a></div><div class="op oq gp gr or os"><a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">Base64编码和解码</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">Base64是一组类似的二进制到文本的编码方案，它们通过…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">developer.mozilla.org</p></div></div><div class="pb l"><div class="pn l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">数据URL</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">数据URL，即以data: scheme为前缀的URL，允许内容创建者在文档中内嵌小文件。</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">developer.mozilla.org</p></div></div><div class="pb l"><div class="po l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">MIME类型(IANA媒体类型)</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">媒体类型(也称为多用途互联网邮件扩展或MIME类型)是一种标准，表示…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">developer.mozilla.org</p></div></div><div class="pb l"><div class="pp l pd pe pf pb pg ks os"/></div></div></a></div></div></div>    
</body>
</html>