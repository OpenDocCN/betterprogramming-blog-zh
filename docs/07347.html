<html>
<head>
<title>Getting Started With Asynchronous Programming in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python异步编程入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-asynchronous-programming-in-python-2797129dd0b3?source=collection_archive---------6-----------------------#2021-01-06">https://betterprogramming.pub/getting-started-with-asynchronous-programming-in-python-2797129dd0b3?source=collection_archive---------6-----------------------#2021-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f053" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用asyncio中的异步和等待特性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/82123c465bf69401fdde6904baf7d7bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0LujPeBF0FNGTMUP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@badashproducts?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ash Edmonds </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7c14" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">第一眼</h1><p id="b841" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在我们的许多应用程序中，我们只需要处理同步编程。这意味着代码将在单线程上线性执行。以下代码向您展示了一个简单的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">同步代码示例</p></figure><ul class=""><li id="8c92" class="mw mx it ma b mb my me mz mh na ml nb mp nc mt nd ne nf ng bi translated"><code class="fe nh ni nj nk b">load_data_for_user</code>函数调用<code class="fe nh ni nj nk b">authenticate_user</code>和<code class="fe nh ni nj nk b">get_posts_remotely</code>。</li><li id="6082" class="mw mx it ma b mb nl me nm mh nn ml no mp np mt nd ne nf ng bi translated">这两个函数按顺序执行，需要五秒钟完成，与时间戳中显示的时间差相匹配。</li></ul><p id="ab7d" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">显然，如果用户必须等待五秒钟才能显示数据，用户体验不会太好。这就是异步编程特别有用的地方。看看下面更新的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">异步代码示例</p></figure><p id="8113" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">如果你现在还不明白，那也没关系，因为我们将在本文中学习异步编程。然而，要注意的一点是，相同功能(即不同的功能，但完成相同的工作)的总执行时间减少到三秒。</p><p id="8b7f" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">与前面显示的同步代码示例不同，在这个异步代码示例中，身份验证和后期获取功能有所重叠。更简单地说，异步编程可以启动下一个任务，而不必等待前面的任务返回结果。换句话说，同步代码按顺序运行任务(例如，函数)，直到当前任务完成，执行才会继续。相比之下，异步编程允许不同的任务同时运行。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="8769" class="nt lh it bd li nu nv dn lm nw nx dp lq mh ny nz ls ml oa ob lu mp oc od lw oe bi translated">为什么是异步编程</h2><p id="8a84" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在最近的Python版本中，已经引入了<code class="fe nh ni nj nk b">asyncio</code>模块，使得编写异步程序变得更加容易。您可能想知道为什么我们会费心使用异步编程技术，如果您同步运行它，会增加程序的复杂性。一个快速的经验法则是，如果你的程序涉及较慢的输入/输出(I/o——这就是<code class="fe nh ni nj nk b">asyncio</code>所指的)通信(例如，上面讨论的互联网请求),你可以考虑用异步技术优化你的程序，这将极大地提高你的程序的整体效率。</p><p id="88c3" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">用一个更专业的术语来说，异步编程允许代码中的任务并发运行。就处理i/o而言，并发性试图解决i/o相关的问题——那些由于输入/输出需求而具有速度限制的问题。并发性肯定比逐个运行这些任务要快，因为这些任务中的每一个都需要花费相当长的时间来等待特定的i/o事件完成。</p><p id="30f9" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">然而，应该注意的是，使用基于<code class="fe nh ni nj nk b">asyncio</code>的代码并不是编写并发代码的唯一方式。在Python中，还有一些实现并发的其他方法，比如<em class="of">线程</em>和<em class="of">多处理</em>。后者对于解决CPU受限的问题特别有用，比如解决计算量大的任务。关于这个主题的精彩概述，请参考博客文章<a class="ae ky" href="https://realpython.com/python-concurrency/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2eb1" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">用Async/Await创建协同例程</h1><p id="8d4c" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">协程是一种编程技术，其中特定的进程在某一点开始，在稍后的某一点退出，这可以通过使用<code class="fe nh ni nj nk b">yield</code>关键字的生成器函数来实现。我在以前的博客文章中提到过这个话题，如果你想了解更多，请随意参考。随着标准库中引入了<code class="fe nh ni nj nk b">asyncio</code>模块，使用<code class="fe nh ni nj nk b">async</code>关键字已经成为实现协程的首选方式。让我们来看看。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">协程的创建</p></figure><ul class=""><li id="6e25" class="mw mx it ma b mb my me mz mh na ml nb mp nc mt nd ne nf ng bi translated">如前所示，我们在<code class="fe nh ni nj nk b">def</code>关键字之前使用了<code class="fe nh ni nj nk b">async</code>关键字来表示异步函数的声明。</li><li id="abef" class="mw mx it ma b mb nl me nm mh nn ml no mp np mt nd ne nf ng bi translated">在函数体中，我们使用<code class="fe nh ni nj nk b">await</code>关键字来表示协程上的等待。在这种情况下，我们简单地模拟一个需要一秒钟来执行的虚拟流程。</li><li id="0bfb" class="mw mx it ma b mb nl me nm mh nn ml no mp np mt nd ne nf ng bi translated">您可能会觉得有趣的一点是，当您调用这个函数时，您不会看到预期的文本(例如，Hello)被打印出来。相反，您得到的是一个协程对象，如交互式控制台中的对象表示所示。如果您熟悉Python生成器，可以打个比方。以类似的方式，调用生成器函数将创建一个生成器，它本质上是一个协程功能。</li></ul><p id="4249" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">要实际运行协程，有几个选项，将在下一节讨论。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ae39" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">执行协程</h1><p id="86d3" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在第一节中，您已经看到了第一个选项— <em class="of">使用</em> <code class="fe nh ni nj nk b"><em class="of">asyncio</em></code> <em class="of">模块</em>中的 <code class="fe nh ni nj nk b"><em class="of">run</em></code> <em class="of">函数。让我们看看它是否像预期的那样工作。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用run执行协程</p></figure><p id="6aa0" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">我们将创建的协程对象发送给<code class="fe nh ni nj nk b">asyncio.run</code>函数。如您所见，这两个字符串打印成功，这意味着协程已经执行。</p><p id="df9d" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">需要注意的一点是，<code class="fe nh ni nj nk b">run</code>函数总是会创建一个新的事件循环。因此，建议您使用该函数作为异步程序的起点。</p><p id="7e36" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">第二种选择与第一种密切相关。考虑下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用await执行协程</p></figure><ul class=""><li id="0bf3" class="mw mx it ma b mb my me mz mh na ml nb mp nc mt nd ne nf ng bi translated">我们创建了另一个名为<code class="fe nh ni nj nk b">say_hello_caller</code>的异步函数。在函数中，我们从前面定义的函数(即<code class="fe nh ni nj nk b">say_hello</code>)创建一个协程对象。我们只是使用<code class="fe nh ni nj nk b">await</code>关键字等待协程对象。</li><li id="7ffa" class="mw mx it ma b mb nl me nm mh nn ml no mp np mt nd ne nf ng bi translated">当您使用<code class="fe nh ni nj nk b">asyncio.run</code>函数调用<code class="fe nh ni nj nk b">say_hello_caller</code>函数时，您会注意到协程<code class="fe nh ni nj nk b">say_hello_coroutine</code>被执行了。本质上，协程上的<code class="fe nh ni nj nk b">await</code>关键字能够调度协程运行。</li></ul><p id="8968" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">因此，执行协程的第二个选择是等待协程。实际上，当我们使用<code class="fe nh ni nj nk b">asyncio.sleep</code>创建虚拟延迟时，我们已经开始使用它了。如果您还不知道的话，<code class="fe nh ni nj nk b">sleep</code>方法实际上创建了一个协程对象。见下文:</p><pre class="kj kk kl km gt og nk oh oi aw oj bi"><span id="86c3" class="nt lh it nk b gy ok ol l om on">&gt;&gt;&gt; asyncio.sleep(1)<br/>&lt;coroutine object sleep at 0x111075f40&gt;</span></pre><p id="761a" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">只是在我们运行函数的时候，<code class="fe nh ni nj nk b">sleep</code>方法让我们等了一秒。在上面的代码片段中，<code class="fe nh ni nj nk b">sleep</code>方法只是返回一个协程对象。</p><p id="cf76" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">第三个选项是<em class="of">运行包装成任务的协程</em>。在Python中，任务是类似未来的对象，在事件循环中运行协程。如果你熟悉JavaScript，它们与JavaScript的未来有相似的概念。本质上，它们是用来处理将要发生的异步结果的。以下代码片段向您展示了如何将协程作为任务执行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用任务运行协程</p></figure><ul class=""><li id="0a3a" class="mw mx it ma b mb my me mz mh na ml nb mp nc mt nd ne nf ng bi translated">我们简单地使用<code class="fe nh ni nj nk b">create_task</code>将协程封装到一个任务中。</li><li id="cc43" class="mw mx it ma b mb nl me nm mh nn ml no mp np mt nd ne nf ng bi translated">使用创建的任务，我们可以简单地在异步函数中等待任务。</li><li id="6b82" class="mw mx it ma b mb nl me nm mh nn ml no mp np mt nd ne nf ng bi translated">如您所见，协程对象能够执行任务。</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6ceb" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">使用并发任务的结果</h1><p id="fa06" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在本文的开始，您可能已经注意到使用了<code class="fe nh ni nj nk b">gather</code>函数来并发运行协程。具体来说，我们只需在gather函数中列出协程，它会自动将它们包装成任务并并发执行。让我们看看下面的简化代码示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">收集任务</p></figure><p id="3320" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">上面的代码向您展示了我们使用gather函数并发运行任务的情况。然而，它确实有一个问题—我们不能使用这些任务返回的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用任务中的数据</p></figure><p id="27a0" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">实际上，获取数据就像使用任务返回值一样简单，如上面代码片段的第八行所示。</p><p id="7009" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">需要注意的一点是，聚集函数本身不会让任务立即运行。相反，它在您使用<code class="fe nh ni nj nk b">await</code>关键字时运行。从打印输出中，您可以看到从聚合任务返回的结果。值得注意的是，结果的顺序与任务的顺序相匹配。</p><p id="37a4" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">当然，我们可以从异步函数返回获取的结果，并使用这些数据相应地更新用户界面。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="cb21" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">在你走之前</h1><p id="4558" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在本文中，我们已经通过利用<code class="fe nh ni nj nk b">asyncio</code>模块触及了基于异步编程。请注意，这只是关于这个主题的介绍——本文中提供的例子对于您编写异步程序来说还不够。对于更高级的用例，参考<a class="ae ky" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>来了解更多关于这个方便的模块总是一个好主意。</p><p id="cdcc" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">感谢您阅读这篇文章。</p></div></div>    
</body>
</html>