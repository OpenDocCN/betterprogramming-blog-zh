<html>
<head>
<title>An Introduction to Public Key Cryptography</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">公钥密码学导论</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-introduction-to-public-key-cryptography-3ea0cf7bf4ba?source=collection_archive---------9-----------------------#2020-03-11">https://betterprogramming.pub/an-introduction-to-public-key-cryptography-3ea0cf7bf4ba?source=collection_archive---------9-----------------------#2020-03-11</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="c130" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">作为一名工程师，你应该学习的非对称加密概念</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/8c6c2d68301adcd58b12f922fc2b6139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5KEhokCr2XiW7mR4k5sZ7A.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">英格玛机由<a class="ae kz" href="https://www.flickr.com/photos/manunimaths/" rel="noopener ugc nofollow" target="_blank">数学学院——曼切斯特大学</a>在<a class="ae kz" href="https://www.flickr.com/photos/manunimaths/44960892745" rel="noopener ugc nofollow" target="_blank"> flickr </a> ( <a class="ae kz" href="https://creativecommons.org/licenses/by/2.0/" rel="noopener ugc nofollow" target="_blank"> CC BY 2.0 </a>)</p></figure><p id="cae5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你从事软件开发，你可能已经以这样或那样的方式接触过密码学。签署消息、加密有效负载、验证签名和使用证书；这些都是我们每天都在使用的功能，即使我们没有意识到。</p><p id="e2c4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">公钥密码学，或称非对称密码学，是从70年代中期开始的广泛科学研究的主题，也是至今许多书籍和研究论文的目标。</p><p id="6df8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这篇文章绝不是试图在任何水平的科学或学术细节中呈现密码学。</p><p id="1408" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">相反，我将尝试展示非对称加密背后的关键功能概念，并提供如何使用它的示例(同时尽可能避免行话)。</p><p id="ac83" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在以下部分中，我们将讨论:</p><ul class=""><li id="ef1e" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">对称与非对称加密。</li><li id="d48d" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">密钥生成。</li><li id="e411" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">不对称加密，或如何发送加密的消息。</li><li id="3b94" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">签名有效负载。</li><li id="93fb" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">证书。</li></ul></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="11cf" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">对称与非对称加密</h1><p id="d9ca" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">对称加密与非对称加密的区别在于使用密钥来传递底层加密功能的方式:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj no"><img src="../Images/0571bdbeb79fdf790cfd3ff07422afc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vp3h5GeGYENhmDo1dMQ-MA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">对于对称加密，一个密钥由一方或多方共享(图片由作者提供)</p></figure><p id="a27a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在对称加密中，加密和解密使用相同的密钥。密钥成为共享的秘密，在参与者之间共享。</p><p id="ac86" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">显然，随着参与者数量的增加，密钥泄露的风险也在增加。</p><p id="df36" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上图中，例如，如果Steve的PC遭到破坏，任何获得密钥的人也可以解密发送给Alice、John和Elizabeth的所有消息。</p><p id="dd5b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，一旦共享秘密在任何一个位置被泄露，整个系统的安全性就会受到威胁。这种使用单一共享密钥的要求，以及找到一种安全的方法来传播它，是对称加密的主要缺点。</p><p id="71a5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对称加密一直是主要的加密机制，直到70年代中期，研究人员开始提出一种不同的方法来创建(更重要的是传播)密钥。</p><p id="628f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这就是不对称加密的诞生:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj np"><img src="../Images/550adff739943db6a5bf580ac9eb5450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DU91RVVrspsG1lYXqP7gAA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用非对称加密，各方维护密钥对并交换公钥(图片由作者提供)</p></figure><p id="ab17" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在非对称加密中，每一方都拥有一对密钥，一个公钥和一个私钥。</p><p id="5164" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">主要的突破是公开密钥不是应该由两方或多方小心隐藏的共享秘密。相反，参与者可以通过不可信的网络交换公钥，甚至与任何人共享自己的公钥。</p><p id="4686" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对称加密彻底改变了密码学领域，它是当今大多数大规模加密方案的基础；比如互联网。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="7805" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">密钥生成</h1><p id="4985" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">非对称加密中公钥和私钥的创建取决于数学问题，尤其是单向函数。</p><p id="9f04" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">单向函数具有易于以一种方式求解(即，生成密钥)但是逆向计算(即，当具有加密的有效载荷时找到密钥)在计算上非常昂贵的特性。</p><p id="22a6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如我在本文开头所承诺的，我不会不必要地使用与密码学相关的技术术语。然而，让我们记住这一点:不是所有的键都是相同的。</p><p id="c501" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">密钥的质量和强度取决于用来生成它的算法以及它所包含的位数。</p><p id="969b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于使用Diffie-Hellman算法生成的密钥，当前推荐的密钥大小是2048位或更大，大约是使用椭圆曲线算法生成的密钥的1/10。</p><p id="56be" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以，是时候使用加密工具的瑞士军刀来创建我们的第一个非对称加密密钥对了，<a class="ae kz" href="https://www.libressl.org" rel="noopener ugc nofollow" target="_blank">libres sl</a>(v 2 . 8 . 3——如果您使用的是<a class="ae kz" href="https://www.openssl.org/" rel="noopener ugc nofollow" target="_blank"> OpenSSL </a>，下面的大多数命令应该也可以工作)。</p><h2 id="5d5d" class="nq ms iu bd mt nr ns dn mx nt nu dp nb lj nv nw nd ln nx ny nf lr nz oa nh ob bi translated">创建加密的私钥</h2><pre class="kk kl km kn gu oc od oe of aw og bi"><span id="2138" class="nq ms iu od b gz oh oi l oj ok">openssl genrsa -des3 -out alice-privatekey.pem 2048</span><span id="351f" class="nq ms iu od b gz ol oi l oj ok">openssl genrsa -des3 -out bob-privatekey.pem 2048</span></pre><p id="ff46" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，您已经成功地为Alice和Bob生成了私钥。LibreSSL和OpenSSL中都有额外的选项来指定密钥的属性，包括在生成过程中使用椭圆曲线算法。</p><p id="76e8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">私钥应该保存好...保密，不与任何人分享。</p><h2 id="c9a0" class="nq ms iu bd mt nr ns dn mx nt nu dp nb lj nv nw nd ln nx ny nf lr nz oa nh ob bi translated">从私钥中提取公钥</h2><pre class="kk kl km kn gu oc od oe of aw og bi"><span id="debd" class="nq ms iu od b gz oh oi l oj ok">openssl rsa -in alice-privatekey.pem -outform PEM -pubout -out alice-publickey.pem</span><span id="fd36" class="nq ms iu od b gz ol oi l oj ok">openssl rsa -in bob-privatekey.pem -outform PEM -pubout -out bob-publickey.pem</span></pre><p id="591b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Alice和Bob的公钥现在被提取出来，并且可以发送给任何感兴趣的一方，因为其中没有嵌入敏感信息。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="44a4" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">不对称加密，或如何发送加密消息</h1><p id="0270" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">不对称加密使用公钥和私钥。要发送加密的邮件，在加密过程中使用收件人的公钥，在解密过程中使用收件人的私钥，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj om"><img src="../Images/66b2434f66f0ff277742fb0a03b6e61d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jg-GHfVj3X4ejILwbYIpxQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">公钥加密/解密(图片由作者提供)</p></figure><p id="c4bd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是上述场景中涉及的步骤，其中Alice想要向Bob发送一条加密的消息:</p><ol class=""><li id="73d0" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv on mc md me bi translated">爱丽丝获得了鲍勃的公钥。</li><li id="3bf3" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">Alice存储Bob的公钥以备将来使用。</li><li id="9041" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">Alice使用Bob的公钥和要加密的有效载荷，并通过她的加密软件传递它们。</li><li id="75e8" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">加密的有效载荷被发送给Bob。</li><li id="52a9" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">Bob将他的私钥和Alice发送的加密消息传递给他的解密软件。</li><li id="7554" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">Bob收到Alice发送的原始有效载荷。</li></ol><p id="4638" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">那么，让我们转到实用部分，使用Bob的公钥给他发送一个加密文件。哦，等等…我们不能！</p><h2 id="4005" class="nq ms iu bd mt nr ns dn mx nt nu dp nb lj nv nw nd ln nx ny nf lr nz oa nh ob bi translated">混合加密</h2><p id="4d34" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">上面介绍的理论部分没有任何问题，因为它完全按照广告宣传的那样工作。然而，不对称加密有一个“问题”:要加密的有效载荷的大小必须(几乎)与用于加密的公钥的大小相匹配。</p><p id="705d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以，为了给Bob发送一张大约1MB的照片，你需要Bob有一个至少800万比特的公钥。那是八百万个1和0，一个接一个。生成这样一个密钥可能不太实际——即使可以实现。</p><p id="a5bf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然您可以创建一个结构，其中在块模式下使用非对称加密来加密大型有效负载，通过以接近可用公钥大小的较小位来加密有效负载，但在实践中，没有人使用这种方法。从空间使用的角度来看效率很低，而且会非常慢。</p><p id="3295" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了缓解非对称加密的密钥大小限制，当前的做法是使用混合加密:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oo"><img src="../Images/bccfcf55053f652d53de6385e6263bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6XQF0XZe9TxFN36sg_xfw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">混合加密(作者图片)</p></figure><p id="32eb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在混合加密中，创建随机对称密钥来加密有效负载，公钥用于加密随机对称密钥。让我们看看这是如何工作的:</p><ol class=""><li id="b27c" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv on mc md me bi translated">鲍勃把他的公钥发送给爱丽丝。</li><li id="b190" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">Alice生成一个共享对称密钥。</li><li id="f755" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">Alice用Bob的公钥加密对称密钥。</li><li id="0111" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">Alice用(2)中创建的共享密钥加密消息。</li><li id="5b86" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">Alice向Bob发送加密的消息和加密的共享密钥。</li><li id="5e57" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">Bob使用他的私钥解密共享密钥。</li><li id="f806" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">Bob使用共享密钥解密加密的消息。</li></ol><p id="b688" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果手动执行的话，上面的场景是冗长而乏味的。然而，已经有成熟的工具和标准来自动化安全交换消息和文件的过程，例如<a class="ae kz" href="https://www.openpgp.org" rel="noopener ugc nofollow" target="_blank"> OpenPGP </a>及其在<a class="ae kz" href="https://en.wikipedia.org/wiki/Pretty_Good_Privacy" rel="noopener ugc nofollow" target="_blank"> PGP </a>和<a class="ae kz" href="https://gnupg.org" rel="noopener ugc nofollow" target="_blank"> GPG </a>的化身。</p><h2 id="7a8f" class="nq ms iu bd mt nr ns dn mx nt nu dp nb lj nv nw nd ln nx ny nf lr nz oa nh ob bi translated">用GPG加密(GNU隐私卫士)</h2><p id="4760" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated"><a class="ae kz" href="https://gnupg.org/" rel="noopener ugc nofollow" target="_blank"> GnuPG </a>是由<a class="ae kz" href="https://tools.ietf.org/html/rfc4880" rel="noopener ugc nofollow" target="_blank"> RFC4880 </a>(也称为PGP)定义的OpenPGP标准的完整免费实现。</p><p id="f38e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">GnuPG允许你对你的数据和通信进行加密和签名，它有一个通用的密钥管理系统，以及各种公共密钥目录的访问模块。</p><p id="cefb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在让我们尝试使用GPG将加密文件从Alice发送给Bob:</p><ol class=""><li id="b57a" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv on mc md me bi translated">爱丽丝和鲍勃都需要创建GPG密钥对:<br/> <code class="fe op oq or od b">gpg --gen-key</code></li><li id="a9c3" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">Bob应该导出他的公钥并将其发送给Alice: <br/> <code class="fe op oq or od b">gpg --output bob.gpg --export bob@bob.com</code></li><li id="aca3" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">一旦爱丽丝收到鲍勃的公钥，她应该将它导入到她的本地密钥数据库:<br/> <code class="fe op oq or od b">gpg --import bob.gpg</code></li><li id="af84" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">爱丽丝创建了一条未加密的消息:<br/> <code class="fe op oq or od b">echo "Hello Bob" &gt; bob.msg</code></li><li id="4b54" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">爱丽丝对消息进行加密，并将加密的消息连同加密的共享密钥一起发送给鲍勃:<br/> <code class="fe op oq or od b">gpg --output bob.msg.gpg --encrypt --recipient bob@bob.com bob.msg</code></li><li id="9262" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">Bob接收加密的消息，并通过解密共享密钥对其进行解密，并利用它对加密的消息进行解密:<br/> <code class="fe op oq or od b">gpg --output bob.msg --decrypt bob.msg.pgp</code></li></ol><p id="0f5a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">GPG和PGP都被广泛使用，并且已经集成到我们日常使用的许多产品中，例如电子邮件客户端，因此您很少需要手动执行上述序列。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="12ec" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">签名有效负载</h1><p id="3ca1" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">有时，可能没有必要对消息的内容进行加密，但是，我们可能仍然希望确定发送者的身份。其他时候，内容需要加密，发送者的身份也需要验证。在这两种情况下，这就是我们使用数字签名的地方。</p><p id="5383" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我们了解数字签名是如何生成的以及它如何有助于验证内容以及发送者的身份之前，让我们在这里做一个重要的区分——这是我经常看到人们互换使用的:数字签名<em class="os">不是</em>电子签名。</p><h2 id="e564" class="nq ms iu bd mt nr ns dn mx nt nu dp nb lj nv nw nd ln nx ny nf lr nz oa nh ob bi translated">数字签名</h2><p id="28f5" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">数字签名只是验证数字信息真实性的数学证明。</p><p id="1789" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它使信息的接收者能够非常确定地相信某一特定信息是由一个已知的发送者创建的，并且该信息在传输过程中没有被更改。</p><h2 id="8781" class="nq ms iu bd mt nr ns dn mx nt nu dp nb lj nv nw nd ln nx ny nf lr nz oa nh ob bi translated">电子签名</h2><p id="1f59" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">电子签名带有物理签名的意图，通常使用数字签名来实现。</p><p id="be84" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在许多国家，只要电子签名符合创建时所依据的具体条例的要求，它就具有与手写签名相同的法律地位。</p><p id="0d8a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">数字签名由发送方使用私钥生成，并由接收方使用发送方的公钥验证:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ot"><img src="../Images/8c07928c7f432e0e605e9964115a8abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5FDfHDbmyjQk6e6ksQ5s_g.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">用数字签名验证邮件(图片由作者提供)</p></figure><ol class=""><li id="65c0" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv on mc md me bi translated">爱丽丝将她的公钥发送给鲍勃。</li><li id="7d99" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">Alice创建了一条消息，并使用她的私钥生成了一个数字签名。数字签名通常是在计算出的消息散列上产生的，例如，在产生的<a class="ae kz" href="https://en.wikipedia.org/wiki/Secure_Hash_Algorithms" rel="noopener ugc nofollow" target="_blank"> SHA-256 </a>上产生的。</li><li id="35c5" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">Bob收到原始的未加密邮件和Alice对该邮件的数字签名。</li><li id="a840" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">Bob使用Alice的公钥重新计算原始未加密邮件的数字签名，并将其与Alice发送的签名进行比较。</li><li id="b188" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv on mc md me bi translated">如果两个签名都匹配，Bob知道是Alice发送了原始消息，并且消息的内容没有被更改。</li></ol><p id="3654" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来让我们看看如何创建数字签名，以及收件人如何验证收到的消息没有被篡改。</p><h2 id="a81d" class="nq ms iu bd mt nr ns dn mx nt nu dp nb lj nv nw nd ln nx ny nf lr nz oa nh ob bi translated">签发签名</h2><pre class="kk kl km kn gu oc od oe of aw og bi"><span id="82d8" class="nq ms iu od b gz oh oi l oj ok">openssl dgst -sha256 -sign alice-privatekey.pem -out bob.msg.sign bob.msg</span></pre><p id="24d6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的命令使用Alice的私钥来计算文件<code class="fe op oq or od b">bob.msg</code>的SHA-256输出上的数字签名。然后爱丽丝将<code class="fe op oq or od b">bob.msg</code>和<code class="fe op oq or od b">bob.msg.sign</code>文件发送给鲍勃。</p><h2 id="2291" class="nq ms iu bd mt nr ns dn mx nt nu dp nb lj nv nw nd ln nx ny nf lr nz oa nh ob bi translated">验证签名</h2><pre class="kk kl km kn gu oc od oe of aw og bi"><span id="da03" class="nq ms iu od b gz oh oi l oj ok">openssl dgst -sha256 -verify alice-publickey.pem -signature bob.msg.sign bob.msg</span></pre><p id="678e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Bob从Alice那里收到了这两个文件，并继续使用Alice的公钥验证签名。上述命令根据数字签名验证结果返回<code class="fe op oq or od b">Verified OK</code>或<code class="fe op oq or od b">Verification Failure</code>。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="be76" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">证书</h1><p id="ad53" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">证书，也称为数字证书、身份证书或公钥证书，是证明公钥所有权的电子文档。</p><p id="5e7e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最常见的证书格式由<a class="ae kz" href="https://en.wikipedia.org/wiki/X.509" rel="noopener ugc nofollow" target="_blank"> X.509 </a>定义，它基本上包含一个公钥、该公钥的数字签名以及公钥所有者的身份信息。</p><p id="57c8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">证书可用于各种目的，因此存在不同的证书配置文件。</p><p id="dd8e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">公钥对应于证书的所有者。然而，对于能够验证所有者身份的任何其他人来说，需要一个可信的第三方实体。</p><p id="8b0c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这就是证书颁发机构的用武之地。证书颁发机构是负责签署证书的一方，通常是受信任的知名公司或组织。</p><p id="ed2b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了有效地履行这一职责，证书颁发机构需要拥有尽可能多的用户信任的自己的根证书。但是，证书颁发机构也可以提供交叉签名，从而签署其他证书颁发机构的根证书。</p><p id="4229" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这可能一开始听起来很混乱，所以让我们试着用一个例子来解释一下:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ou"><img src="../Images/79f27852d4c37484c29d68ec80cee7af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g1GK9_sWiqM15bRMF57bCg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">信任的证书验证链(图片由作者提供)</p></figure><ul class=""><li id="effa" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">在上面的例子中，Bob连接到Alice的网站，并希望验证是否真的是Alice在操作它。</li><li id="9246" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">Bob在访问Alice的网站时获得了一个证书。该证书包含Alice的公钥以及来自认证机构CA1的数字签名。</li><li id="b6a2" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">因为Bob不知道也不信任CA1，所以他检查了嵌入到证书中的证书链。</li><li id="e3c5" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">通过回溯可用的交叉签名，Bob到达他信任的认证机构CA3。他现在知道爱丽丝的网站可以信任由爱丽丝操作。</li></ul><p id="0d73" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当然，所有这些过程都是在HTTPS协议的传输层安全性(<a class="ae kz" href="https://en.wikipedia.org/wiki/Transport_Layer_Security" rel="noopener ugc nofollow" target="_blank"> TLS </a>)下，通过您的互联网浏览器在幕后进行的。</p><p id="d568" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">证书身份的验证是基于一个普遍信任的父证书颁发机构，这也是对证书的主要批评之一。</p><p id="2f5d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果父证书颁发机构受到威胁或失控，该怎么办？</p><p id="70eb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">尽管证书主要用于网站隐私、身份识别和内容可靠性，但它们也可用于客户身份识别。</p><p id="d5bb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您有兴趣运营自己的认证中心，您可以尝试各种可用的开源实现，如<a class="ae kz" href="https://www.openca.org/" rel="noopener ugc nofollow" target="_blank"> OpenCA </a>、<a class="ae kz" href="https://www.ejbca.org/" rel="noopener ugc nofollow" target="_blank"> EJBCA </a>或<a class="ae kz" href="https://github.com/openxpki/openxpki" rel="noopener ugc nofollow" target="_blank"> OpenXKPI </a>。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ov"><img src="../Images/52405fad7600d4706f985192db936ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dPd26foyixxt_bjg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">EJBCA的web管理控制台截图(<a class="ae kz" href="https://commons.wikimedia.org/wiki/User:David_CARELLA" rel="noopener ugc nofollow" target="_blank"> David CARELLA </a>、<a class="ae kz" href="https://en.wikipedia.org/wiki/EJBCA#/media/File:EJBCA_6.5.0_en_-_Administration_-_Home.png" rel="noopener ugc nofollow" target="_blank"> Wikipedia </a>、<a class="ae kz" href="https://creativecommons.org/licenses/by-sa/4.0" rel="noopener ugc nofollow" target="_blank"> CC BY-SA 4.0 </a>)</p></figure><p id="7d4a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当然，要考虑到，由于您自己的证书颁发机构的根证书不被您的互联网浏览器或任何其他人信任，您需要按照操作系统的说明手动将其插入到可信证书存储中。</p><p id="15ab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用您自己的证书颁发机构颁发的证书的所有用户的机器也是如此。</p><p id="a79e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">不，它不是一个选择，让一个大的，已知的根证书权威交叉签署你自己的证书权威的根证书。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="a0c2" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">结论</h1><p id="fe00" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">公钥加密或不对称加密是一种基于成对密钥(公钥和私钥)的加密系统。不对称加密的主要用例是加密通信、提供消息验证和真实性。</p><p id="bbe7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我试图展示非对称加密背后的基本概念，尽管只是触及了如此复杂主题的皮毛。密码学是一个迷人的领域，至今仍有活跃的研究，为好奇的人们提供了大量的信息。</p><p id="0d88" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在您离开之前，如果您的项目需要加密，请记住加密黄金法则:<em class="os">不要使用您自己的密码</em>。</p><p id="aa3c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有大量的库和已经实现的强大、安全、经过实战检验的算法。做你的研究，选择那些已经满足你的项目需求的。</p><p id="7187" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢您阅读这篇文章。希望下一部能见到你。</p></div></div>    
</body>
</html>