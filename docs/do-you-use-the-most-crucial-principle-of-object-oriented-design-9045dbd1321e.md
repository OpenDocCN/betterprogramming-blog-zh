# 你使用了面向对象设计的最重要的原则吗？

> 原文：<https://betterprogramming.pub/do-you-use-the-most-crucial-principle-of-object-oriented-design-9045dbd1321e>

## 开合原理在起作用

![](img/71a3847f3335f8d4fd277d038ad38e6e.png)

照片由 [Unsplash](https://unsplash.com/s/photos/open-closed-open?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的[尼克·费因斯](https://unsplash.com/@jannerboy62?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)拍摄

面向对象设计最重要的原则是开闭原则(OCP)。

我花了一段时间才理解了 OCP。我发现“模块应该既开放又封闭”这个矛盾很模糊。

直到我读了马丁·福勒的《重构:改进现有代码的设计》之后，这一切才开始变得有意义。

在这篇文章中，我将阐述我对 OCP 的观点。我将使用两个真实的例子——一个来自以前的项目，另一个来自 GitHub 上的开源项目。

最后，我将分享一些启发式方法来检测可以使用 OCP 改进的源代码。

# OCP 的定义

一点历史:

OCP 是 Bertrand Meyer 在 1988 年他的书[“面向对象软件构造”中描述的五个原则之一](https://en.wikipedia.org/wiki/Object-Oriented_Software_Construction)这五个软件构造原则描述了如何使用面向对象的概念创建模块化系统。

在书中，伯特兰把 OCP 描述为:

> 模块应该是开放的和封闭的。
> 如果一个模块仍可用于扩展，则称其为开放的。
> 如果一个模块可供其他模块使用，则该模块被认为是关闭的。

2000 年，Robert C. Martin 在《设计原则和设计模式》中描述了这一原则:

> “我们希望能够改变模块的功能，而不改变模块的源代码。”

后来，Michael Feathers 从 Robert C. Martin 的“设计原则和设计模式”中提出了代表五个重要原则的缩写词 SOLID。这增加了原则的普及。

实线中的 O 代表开闭原理

## OCP 背后的原因是什么？

OCP 和其他面向对象设计原则背后有一个问题:

我们如何设计一个系统，使得向应用程序代码库添加新功能变得容易？

# OCP 是什么意思？

OCP 声明我们应该能够在不改变源代码的情况下改变一个模块的功能。

这听起来不奇怪吗？如何在不改变源代码的情况下改变模块的行为？这恰恰是我第一次学习这个原理时的挣扎。

## 对扩展开放，但对修改关闭

如果我们看看另一种解释，OCP 开始变得更有意义了:“一个模块应该为了扩展而*打开*，为了改变而*关闭【T11”。”*

所以我们可以添加新的东西——但不能改变现有的源代码。

现在，我们开始有所进展了。因此，我可以添加一个类，但不能更改现有的类。

那么，我们如何设计一个在添加新类时改变其行为的应用程序呢？有一个简单的答案:

通过使用继承和多态。

# 第一个例子:物联网传感器测量

![](img/51f732e249780a0067b16fa0149f8733.png)

利用物联网技术测量温室温度。作者照片。

让我们看一个例子。我们有一个物联网解决方案，可以从不同类型的传感器读取测量值。这些传感器测量温度、湿度、二氧化碳和压力。

在应用程序可以使用测量值之前，它必须转换该值。

每种类型的传感器的转换是不同的。有些直接返回正确的值，有些使用线性转换，还有一些使用更复杂的转换。

## 不遵循 OCP 的转换

下面的模块显示了一个用于转换值的函数。

将传感器测量值从总值转换为净值

该函数接受传感器类型和总值。根据`sensorType`，该函数执行特定的转换。

目前该功能支持三种类型的传感器:`PT500`、`ERH`和`CLIMAPREC`。如果我们必须支持一种新的传感器，我们必须通过向交换机添加新的外壳来改变它。

当我们做这个改变时，我们可能会在现有的转换中引入错误。在修改现有代码时引入错误是 OCP 试图阻止的。

因此，这个模块*没有*遵循 OCP。不是关闭修改的。

我们如何改变这个转换函数，使其适用于 OCP？

## 使用 OCP 进行转换

我们引入了多个传感器类别，而不是单一的转换功能。每个传感器类别负责特定传感器类型的转换。

pt500-sensor.js，一个用于从 pt500 温度传感器转换总值的类

clima-sensor.js，用于转换提斯降水传感器的总值的类

执行实际转换的函数使用一组传感器类型。传感器构建器模块创建此集合。

sensorbuilder.js，用于构建传感器字典的模块

`MeasurementConverter`使用给定的`sensorType`作为检索正确的`sensor`类的密钥。

我们在这个检索到的`sensor`类上调用`convert`函数。

measurementConverter.js，执行实际转换的模块

如果我们必须支持一个新的传感器类型，我们为这个特定的传感器添加一个新的类，并实现 convert 函数。

所以我们添加了一个新的类，而不是改变现有的代码。我们没有将错误引入现有代码的风险。

这是 OCP 在行动。

# 第二个例子:Fastify 注册路由

![](img/e9549a596e54f5713a54628d6c0e7244.png)

Node.js 的快速低开销 web 框架

您是否注意到在前面的示例中，我仍然必须更改填充传感器字典的源代码？如果严格来说，也不是完全的开合。如果我还想删除这个更改，我必须从文件系统中加载传感器。

[Fastify Register Routes](https://github.com/israeleriston/fastify-register-routes) 是由 Israelériston 创建的 Fastify 插件，它从指定路径加载路线，并将其注册到 Fastify。

看看以色列是如何实现这一功能的很有意思。下面我们可以看到部分源代码。

从文件系统加载路由文件并需要它们

在第 8 行，他从一个特定的目录中检索所有可用的路由文件。然后在第 9 行，他使用`.map`对每个文件调用`require`。这将产生一个具有路由功能的数组。

然后他为每条满载的路线呼叫`registerRoutes`。这将向 Fastify 注册每条路由。

```
const routes = loadRoutesByPath(dirname, options);
routes.forEach(route => registerRoutes(server, route));
```

结果是，您可以通过添加一个定义路由的 JavaScript 文件来将路由添加到 API 中。所以没有必要改变现有的源代码。

这是 OCP 的又一个美丽例子。

# 如何识别可以改进的源代码

那么，如何利用 OCP 来识别解决方案中可以改进的地方呢？

我在 Martin Fowler 的《重构:改进现有代码的设计》一书中找到了一些技巧。顺便说一句，这是一本极好的书。

## **用多态替换条件**

书中所做的重构之一是用多态替换条件。在以下情况下，您可以应用此重构:

> "你有一个根据对象类型选择不同行为的条件."

这正是前面传感器示例的情况。根据传感器的类型，我使用不同的转换函数。更具体地说:如果您的源代码中有一个使用类型代码的开关，这可能是需要改进的地方。

带有类型代码的开关—使用 OCP 的可能位置

如果您的源代码包含基于类型代码的 if-else-if 结构，而不是开关，这可能也是一个需要改进的地方。

基于类型代码的 if-else-if 结构——使用 OCP 的另一个可能位置

所以每当你在源代码中看到一个变化，我希望你能想想 OCP。你能通过继承和多态来改进设计吗？

# 结论

OCP 是面向对象设计最重要的原则之一。如果您正确使用它，它会使您的源代码更加模块化和易于维护。

两个真实世界的例子展示了如何使用 OCP。第一种方法使用 OCP 将总测量值转换为净值。在第二个例子中，Fastify 插件使用 OCP 来添加路线。

最后，每当你在源代码中看到开关或 if-else-if 结构时，我希望你问自己一个问题。这个问题是:“我可以应用 OCP 来改进源代码的设计吗？”

感谢您的阅读。