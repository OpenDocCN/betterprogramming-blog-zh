<html>
<head>
<title>Top 3 CSS Grid Features To Start Using in Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开始在生产中使用的3大CSS网格特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/top-3-css-grid-features-to-start-using-in-production-b0fe59b2e0f7?source=collection_archive---------8-----------------------#2021-02-09">https://betterprogramming.pub/top-3-css-grid-features-to-start-using-in-production-b0fe59b2e0f7?source=collection_archive---------8-----------------------#2021-02-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fe80" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入探究一些广泛支持的CSS网格特性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0b1024d5ba17640bd8f8758ffe2924d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mWiTIfu6BVlYQ5lf"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网格最初由微软团队起草，并于2011年发布到Internet Explorer 10中。经过近九年的时间，我们现在可以说它的浏览器支持变得足够好，我们可以在生产中使用它。</p><p id="8a44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将看一看具有可靠浏览器支持的三大特性。尽管有一些很酷的新特性，比如<code class="fe lv lw lx ly b">subgrid</code>，但是请注意不要在产品中使用它们。在运输任何东西之前，检查一下<a class="ae ky" href="https://www.caniuse.com" rel="noopener ugc nofollow" target="_blank">我能使用</a>总是一个好习惯。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c82f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">简短的复习</h1><p id="2025" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">网格到底是什么？网格是一个以容器为中心的多维布局系统。简而言之:它可以在任意x/y方向生长，所有的布局信息都存储在父节点中。孩子们大多掌握着如何在网格上定位的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/52c15fc3156f5d2590f19373ed71e755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*6YeEVVXSRcJwnZBHo2EgpQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一维布局与二维布局</p></figure><p id="8515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Grid进行开发时，建议使用Firefox浏览器。它的开发工具比任何竞争对手都要好。它是支持网格最好的浏览器。这是目前唯一实现了<code class="fe lv lw lx ly b">subgrid</code>的浏览器。</p><p id="8166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们深入了解三大生产就绪的CSS网格特性。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="775b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak"> 1。网格模板区域</strong></h1><p id="19ec" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这是我最喜欢的CSS网格特性。它允许您以声明的方式定义网格布局。</p><p id="ff40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需几行CSS代码，您就可以创建一个非常复杂且响应迅速的布局:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/4a9077c17fea8f81c09f7dae5528581d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kxxETOv_yi4ECBfYz_D-mw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">复杂网格布局</p></figure><p id="f410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的魔法都发生在<code class="fe lv lw lx ly b">grid-templates-areas</code>和<code class="fe lv lw lx ly b">grid-area</code>里。前者定义了所有的网格轨迹，而后者只是在这些区域上定位网格元素。</p><p id="5297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:网格轨迹是两条网格线之间的空间。</p><p id="2478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用Firefox inspector检查一下，以便清楚地看到我们创建的网格布局。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/d2e5a6af890d08c2efc9249c5147f1c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U9o4_M-wfMeBHindl1H4sw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">网格布局的内部</p></figure><p id="569f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们希望内容周围有一些空白空间，而不是左/右栏，我们可以使用<code class="fe lv lw lx ly b">.</code> / <code class="fe lv lw lx ly b">...</code>符号。</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="b0ad" class="nm mh it ly b gy nn no l np nq">#grid {<br/>  background-color: #73937E;<br/>  height: calc(100vh - 20px);<br/>  display: grid;<br/>  <!-- -->grid-template-rows:1fr 2fr 1fr;<br/>  <!-- -->grid-template-areas:<br/>    "navigation navigation navigation navigation"<br/>    ". content content ."<br/>    "footer footer footer footer";<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/8be821230c6a56da0bff86239d556344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*frMRKP1wKAGbxlAuQVI_SQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在内容div的左侧和右侧定义空网格</p></figure><p id="3021" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:在使用网格区域时，有几件事情需要注意:</p><ul class=""><li id="49c9" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">每个区域名只能定义一次。如果具有相同区域名称的单元格没有连接，它们将计为两个声明。</li><li id="201b" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">网格区域单元格必须形成一个矩形。否则，声明无效。</li></ul><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="95f3" class="nm mh it ly b gy nn no l np nq">// Example of an invalid Grid<br/>#grid {<br/>  background-color: #73937E;<br/>  height: calc(100vh - 20px);<br/>  display: grid;<br/>  grid-template-areas:<br/>    "navigation navigation navigation navigation"<br/>    "left content content right"<br/>    "content content content content"<br/>    "left content content right"<br/>    "footer footer footer footer";<br/>}</span></pre><p id="b8a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子不成立。<code class="fe lv lw lx ly b">right</code>和<code class="fe lv lw lx ly b">left</code>有两种定义。移除那一行<code class="fe lv lw lx ly b">"content content content content"</code>将修复它，因为<code class="fe lv lw lx ly b">left</code>和<code class="fe lv lw lx ly b">right</code>将被连接。</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="cd15" class="nm mh it ly b gy nn no l np nq">// Example of an invalid Grid<br/>#grid {<br/>  background-color: #73937E;<br/>  height: calc(100vh - 20px);<br/>  display: grid;<br/>  grid-template-areas:<br/>    "navigation navigation navigation navigation"<br/>    "content right"<br/>    "content content"<br/>    "right"<br/>    "footer";<br/>}</span></pre><p id="36e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子不成立。我们已经描述了一个非矩形区域。网格不是为此而构建的，也不支持它。</p><p id="a8ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:可以将<code class="fe lv lw lx ly b">grid-template-rows</code>与<code class="fe lv lw lx ly b">grid-template-areas</code>配合使用。但是，结果会不一样。你必须选择一个适合你的具体情况。</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="d43c" class="nm mh it ly b gy nn no l np nq">// Approach A<br/>grid-template-rows: 1fr 3fr 1fr;<br/>grid-template-areas:<br/>  "navigation navigation navigation navigation"<br/>  "left content content right"<br/>  "footer footer footer footer";</span><span id="6b46" class="nm mh it ly b gy og no l np nq">// Approach B<br/>grid-template-areas:<br/>  "navigation navigation navigation navigation"<br/>  "left content content right"<br/>  "left content content right"<br/>  "left content content right"<br/>  "footer footer footer footer";</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/d2e5a6af890d08c2efc9249c5147f1c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U9o4_M-wfMeBHindl1H4sw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">方法A</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/682e97cc407d2fe55f1feb6730cbfe48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*18VMr9MkDmUHOS-biKfckQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">方法B</p></figure><p id="b79d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:使用<code class="fe lv lw lx ly b">grid-template-area</code>时，网格线是免费创建的。这意味着即使使用<code class="fe lv lw lx ly b">grid-template-area</code>，你仍然可以使用网格线的位置逻辑。那我们就简单查一下负指数<code class="fe lv lw lx ly b">-1</code>吧。</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="7a2e" class="nm mh it ly b gy nn no l np nq">.customContent {<br/>  background-color: white;<br/>  grid-row: 1 / -1; <br/>  grid-column: 1;<br/>}</span></pre><p id="d84b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加负索引会使CSS更加健壮。您变得不知道网格线的数量:您设置您的内容扩展到最后一个网格线。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/77b171e538e118d02ed88c09aa1a1f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mFCCFIxCWZ_EA5H80t-BjQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对行使用负索引的结果</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5066" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak"> 2。网格间隙</strong></h1><p id="96f4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Grid <code class="fe lv lw lx ly b">gap</code>使用起来超级简单直观。使用<code class="fe lv lw lx ly b">column-gap</code>、<code class="fe lv lw lx ly b">row-gap</code>或<code class="fe lv lw lx ly b">gap</code>定义网格布局中的间隙。</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="c3c6" class="nm mh it ly b gy nn no l np nq">#grid {<br/>  background-color: #73937E;<br/>  height: calc(100vh - 20px);<br/>  display: grid;<br/>  row-gap: 5px;<br/>  column-gap: 15px;<br/>  grid-template-areas:<br/>    "navigation navigation navigation navigation"<br/>    "left content content right"<br/>    "content content content content"<br/>    "left content content right"<br/>    "footer footer footer footer";<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/e1a322baccd4778f1422737b5fceb2c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aajG-IirnfyHHYyPb2YKsw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用间隙功能</p></figure><p id="fa07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:不要使用<code class="fe lv lw lx ly b">grid-gap</code>、<code class="fe lv lw lx ly b">grid-column-gap</code>或<code class="fe lv lw lx ly b">grid-column-gap</code>:这些现在被认为是过时的，将会失去支持。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="73f0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak"> 3。最小最大值</strong></h1><p id="628e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">起初<code class="fe lv lw lx ly b">MinMax</code>看起来不像是一个令人兴奋的功能。API非常简单:</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="e69f" class="nm mh it ly b gy nn no l np nq">minmax(min, max)</span></pre><p id="e742" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将获得<code class="fe lv lw lx ly b">min</code>和<code class="fe lv lw lx ly b">max</code>之间的最大值。它接受:<code class="fe lv lw lx ly b">length</code>、<code class="fe lv lw lx ly b">percentage</code>、<code class="fe lv lw lx ly b">max-content</code>、<code class="fe lv lw lx ly b">min-content</code>和<code class="fe lv lw lx ly b">auto</code>值。它是为网格构建的，这一事实使它变得非常强大。</p><p id="209e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个有三列的布局，并使用<code class="fe lv lw lx ly b">minmax</code>让它们扩展到整个网格区域。</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="18b1" class="nm mh it ly b gy nn no l np nq">grid-template-columns: repeat(3, minmax(100px, 1fr));</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/c788b26c3db12d60e2af3f12f85024f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DqLyXYT5DlN7k8NHejQ1nQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用minmax定义三列布局</p></figure><p id="4009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:它看起来很可爱，但是有一个很大的缺点:如果容器小于<code class="fe lv lw lx ly b">3 * 100px + 2 * 10px</code>，内容就会溢出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/7ff3adc69cb33331b3c3f7c24a8023ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*q-y32_HSK0RUABQregRtJw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">没有足够的空间来呈现最小列宽为100像素的三列布局</p></figure><p id="f763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何解决这个问题？以响应的方式构建网格布局。我们可以让网格容器通过使用<code class="fe lv lw lx ly b">auto-fill</code>或<code class="fe lv lw lx ly b">auto-fit</code>来决定自己的列数。</p><p id="b809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这一简单的更改，我们的三列布局现在可以响应视窗的大小:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/e6e0058d7a9c806e2a8bd6c7e91f5746.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*wu16vXlLxgjnrI8Gragp1g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">响应式网格布局</p></figure><p id="48db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们所有的魔法发生的地方:</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="4f4c" class="nm mh it ly b gy nn no l np nq">grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));</span></pre><p id="8781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们告诉网格布局创建填充网格空间的轨迹，它们应该有最小的<code class="fe lv lw lx ly b">200px</code>和最大的<code class="fe lv lw lx ly b">1fr</code>。</p><p id="42ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:有一个警告:你不能使用<code class="fe lv lw lx ly b">auto-fill</code>并设置最大列数。事情不应该是这样的。要设置最大列数，您必须使用媒体查询并调整<code class="fe lv lw lx ly b">minMax</code>的值。另一种选择是使用<code class="fe lv lw lx ly b">css variables</code>。任一选项都需要使用媒体查询。</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="ed3b" class="nm mh it ly b gy nn no l np nq">// Example of using media queries + css variables to have responsive fixed column layout</span><span id="3669" class="nm mh it ly b gy og no l np nq">.grid {<br/>  --repeat: auto-fit;<br/>}</span><span id="9014" class="nm mh it ly b gy og no l np nq">@media screen and (max-width: 700px) {<br/>  .grid {<br/>    --repeat: 3;<br/>  }<br/>}</span><span id="ed30" class="nm mh it ly b gy og no l np nq">grid-template-columns: repeat(<!-- -->var(--repeat, auto-fit)<!-- -->, minmax(200px, 1fr));</span></pre><p id="afa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们充分理解<code class="fe lv lw lx ly b">auto-fit</code>和<code class="fe lv lw lx ly b">auto-fill</code>的区别:</p><ul class=""><li id="98d1" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated"><code class="fe lv lw lx ly b">auto-fill</code>:根据给定的约束条件，尝试用尽可能多的列填充行</li><li id="fff8" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe lv lw lx ly b">auto-fit</code>:行为方式与<code class="fe lv lw lx ly b">auto-fill</code>相同，但是任何空的重复轨道将被折叠，并且它将扩展其他轨道以占据所有可用空间(如果有的话)</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/a556249de437382da541ce8493be77a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Be3yz9t1oZ-OzfWghQ_l0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自动填充与自动适应</p></figure><p id="0590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当有足够的元素填充网格时，这两个属性的行为方式相同。这意味着根据不同的分辨率，它们可能看起来是一样的。这就是为什么了解它们的内部是有好处的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/a62b3c014ac50b0c47f074a94930e9c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bjQpF-R9e7ki-5u2c5zOwg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在某些分辨率下，它们可能看起来是一样的</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5001" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">总结</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/cef409b525b97c8c7966a5b086cd8a72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qOzhnK7sH5tZyk_T"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@dnevozhai?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Denys Nevozhai </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经深入研究了三个主要的网格特性以及如何最好地使用它们。现在，您可以用更少的CSS代码以更高的性能和效率构建您的布局。破解Flex API的日子已经一去不复返了——用网格增强自己的能力。</p><p id="254b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，我们不能等待探索者11号消失，因为它至少在四年内不会发生。它仍然在企业级使用。只要确保添加一些polyfills来为100%的用户提供支持。</p><p id="7ae1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望我的文章能够为您提供在生产中开始使用网格所需要的最后推动力。一旦开始使用，就没有回头路了。</p><p id="f119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对Subgrid感兴趣，我建议您查看另一篇文章:</p><div class="op oq gp gr or os"><a href="https://medium.com/better-programming/using-css-subgrid-for-pixel-perfection-6d4343b057cd" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">使用CSS子网格实现像素完美</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">展示CSS的子网格特性的简单美丽</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">medium.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div><p id="869a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干杯！</p></div></div>    
</body>
</html>