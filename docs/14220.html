<html>
<head>
<title>Angular 15: What’s Changed and What’s New</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular 15:有什么变化和新变化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-15-193cb008e8f3?source=collection_archive---------0-----------------------#2022-11-18">https://betterprogramming.pub/angular-15-193cb008e8f3?source=collection_archive---------0-----------------------#2022-11-18</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="5187" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://rakiabensassi.medium.com/list/software-engineering-7a179a23ebfd" rel="noopener">网络开发</a></h2><div class=""/><div class=""><h2 id="dcc9" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">指令组合API、稳定的独立API、更少的样板代码、更好的性能等等</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/66c6076a79d04b7acfadddc1610fb698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WDEY7yO8iikE7gVfnl-ePQ.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://unsplash.com/@nebe3etogo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼尔·阿克谢诺夫</a>在<a class="ae li" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的原始照片(作者编辑)</p></figure><p id="4fed" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">2022年11月16日，谷歌发布了其Angular框架的第十五个主要版本。</p><p id="6149" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">就像社区的许多成员一样，我对它给生态系统带来的巨大改善感到非常兴奋。</p><p id="b7cd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在这篇文章中，我将深入挖掘新功能和几十项改进，并分解它们对Angular landscape的意义，以及它们如何改善<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/how-to-improve-developer-experience-2d5908d7bbb0">开发者体验</a>和<a class="ae li" href="https://medium.com/better-programming/javascript-memory-leaks-390957523a9e" rel="noopener"> web性能</a>。</p><p id="e339" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">但是在我们开始之前，我将解释一些伴随的术语。</p><pre class="kt ku kv kw gu mf mg mh bn mi mj bi"><span id="4c5f" class="mk ml iu mg b be mm mn l mo mp">Table of Contents<br/><br/>Lingo<br/>   ∘ Function composition<br/>   ∘ HMR<br/>   ∘ @keyframes<br/>   ∘ Lazy loading<br/>   ∘ Stack trace<br/>   ∘ Tree shaking<br/><br/>New Features<br/><br/>   1. Directive Composition API<br/>   2. Stable Standalone APIs<br/>   3. Tree-shakable Router API<br/>   4. HTTP with provideHttpClient<br/>   5. Functional Router Guard<br/>   6. Dynamic Router Outlet Names<br/>   7. Easy Lazy Loading<br/>   8. Stable Image Directive<br/>   9. Better stack traces<br/>   10. Mistyped banana in the Box<br/>   11. Component-Scoped keyframes<br/>   12. Compatibility for MDC Components<br/>   13. CDK Listbox<br/><br/>Additional Improvements<br/><br/>   ∘ Ivy Landmark / Better Performance<br/>   ∘ Angular DevTools<br/>   ∘ Angular CLI<br/>   ∘ More utility in forms package<br/>   ∘ Deprecated Protractor<br/>   ∘ Improvements in the esbuild support<br/><br/>Final Thought</span></pre><h1 id="db71" class="mq ml iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">术语</h1><h2 id="59aa" class="nh ml iu bd mr ni nj dn mv nk nl dp mz ls nm nn nb lw no np nd ma nq nr nf ja bi translated">功能组成</h2><p id="6496" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">当我们将一个函数的结果传递给下一个函数，然后将这个函数的结果传递给另一个函数，直到我们从最终执行的函数中获得最终结果，我们在JavaScript函数合成中调用这个过程。</p><pre class="kt ku kv kw gu mf mg mh bn mi mj bi"><span id="c069" class="mk ml iu mg b be mm mn l nx mp">// Instead of passing the result of one function to another this way:<br/><br/>func1(func2(func3(15)))<br/><br/>// You can define a compose function (if you're not using a library like lodash or ramda)<br/><br/>const compose = (…fns) =&gt; x =&gt; fns.reduceRight((y, f) =&gt; f(y), x)<br/><br/>compose(func1, func2, func3)(15)</span></pre><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ny"><img src="../Images/ef19467abeb70b7312b316f41828b695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aNSjdnbZw2aKVzRC6SaRdg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">JavaScript中的函数组合(<a class="ae li" href="https://www.educative.io/answers/function-composition-in-javascript" rel="noopener ugc nofollow" target="_blank">源</a></p></figure><h2 id="edf3" class="nh ml iu bd mr ni nj dn mv nk nl dp mz ls nm nn nb lw no np nd ma nq nr nf ja bi translated">HMR</h2><p id="514a" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">当应用程序在浏览器上运行时，我们可以添加、删除或交换模块，而无需完全重新加载。我们称这个过程为热模块更换(HMR)。</p><ul class=""><li id="2534" class="nz oa iu ll b lm ln lp lq ls ob lw oc ma od me oe of og oh bi translated">它节省了宝贵的开发时间，因为当源代码发生变化时，它只更新应用程序中发生变化的内容。</li><li id="df01" class="nz oa iu ll b lm oi lp oj ls ok lw ol ma om me oe of og oh bi translated">与完全重新加载不同，HMR保持应用程序状态，可以显著加快开发速度。</li></ul><h2 id="6052" class="nh ml iu bd mr ni nj dn mv nk nl dp mz ls nm nn nb lw no np nd ma nq nr nf ja bi translated">@关键帧</h2><p id="9d59" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">CSS中的<code class="fe on oo op mg b">@keyframes</code> <a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule" rel="noopener ugc nofollow" target="_blank"> at-rule </a>指定了动画从一组风格逐渐变化到另一组风格的中间步骤。</p><p id="5b0e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们使用关键字“从”和“到”或0%和100%来确定这种变化。这里有一个例子:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq or l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/CSS/@keyframes" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj os"><img src="../Images/5ee634aa1d58500626e832f04343fec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*cmkZ8seAk_pb99GC0dMHmQ.gif"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">CSS @keyframes规则(<a class="ae li" href="https://www.w3schools.com/cssref/css3_pr_animation-keyframes.php" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></figure><h2 id="f01a" class="nh ml iu bd mr ni nj dn mv nk nl dp mz ls nm nn nb lw no np nd ma nq nr nf ja bi translated">惰性装载</h2><p id="5ac9" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">为了提高性能和系统资源的利用率，我们延迟了模块和对象的初始化或加载，直到应用程序需要它们。我们称这种设计模式为延迟加载。</p><h2 id="cdce" class="nh ml iu bd mr ni nj dn mv nk nl dp mz ls nm nn nb lw no np nd ma nq nr nf ja bi translated">堆栈跟踪</h2><p id="d27e" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">堆栈和堆是程序运行时动态分配内存的两个地方。</p><p id="6264" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">堆栈跟踪是程序执行过程中某个时间点的执行堆栈的报告。</p><p id="d792" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">开发人员通常在交互式或事后调试会话中使用堆栈跟踪。</p><h2 id="aef7" class="nh ml iu bd mr ni nj dn mv nk nl dp mz ls nm nn nb lw no np nd ma nq nr nf ja bi translated">树摇晃</h2><p id="19b6" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">JavaScript中的摇树就是剔除死代码的过程。结果将是最小的束尺寸。</p><p id="aee4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">通过检查<code class="fe on oo op mg b">import</code>和<code class="fe on oo op mg b">export</code>语句，像<a class="ae li" href="https://webpack.js.org/guides/tree-shaking/" rel="noopener ugc nofollow" target="_blank"> webpack </a>和<a class="ae li" href="https://rollupjs.org/guide/en/" rel="noopener ugc nofollow" target="_blank"> Rollup </a>这样的模块捆绑器会自动删除应用程序不使用的代码。</p><h1 id="127f" class="mq ml iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">新功能</h1><h1 id="df69" class="mq ml iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">1.指令合成API</h1><p id="49c0" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">Directive Composition是GitHub 上的<a class="ae li" href="https://github.com/angular/angular/issues/8785" rel="noopener ugc nofollow" target="_blank">特性请求，在Angular 15中实现之前已经需求了六年。</a></p><p id="f44c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">谷歌开发者关系主管兼Angular团队的工程师Minko Gechev 将其描述为一种编写UI逻辑的新方法，因为它允许代码重用，而不是传统的继承。</p><p id="c56a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">类似于JavaScript 中的<a class="ae li" href="#59aa" rel="noopener ugc nofollow">函数组合，指令组合支持通过利用<code class="fe on oo op mg b">hostDirectives</code>属性将组件和其他指令中的单个指令组合成一个更复杂的指令:</a></p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ov or l"/></div></figure><p id="6443" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在上面的例子中，我们使用了<code class="fe on oo op mg b">HasColor</code>指令和来自<code class="fe on oo op mg b">CdkMenu</code>的指定输入和输出。</p><p id="162f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">请记住，只有独立的指令才能用于合成。</p><h1 id="48cf" class="mq ml iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">2.稳定的独立API</h1><p id="4065" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">独立组件和API是Angular 14中引入的一个显著特性。没有<code class="fe on oo op mg b">NgModule</code>，它们使应用构建变得更加容易。有了这个新版本，API变得稳定，不再处于开发者预览状态。</p><h1 id="16f6" class="mq ml iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">3.树摇动路由器API</h1><p id="81b9" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">在Angular 14.2中添加了<code class="fe on oo op mg b">provideRouter()</code>功能的<a class="ae li" href="https://kevinkreuzer.medium.com/angular-router-standalone-apis-461547e92bbc" rel="noopener">路由器独立API </a>现在也有了稳定的状态。</p><pre class="kt ku kv kw gu mf mg mh bn mi mj bi"><span id="b568" class="mk ml iu mg b be mm mn l nx mp">const appRoutes: Routes = [];<br/>bootstrapApplication(AppComponent,<br/>  {<br/>    providers: [<br/>      provideRouter(appRoutes,<br/>        withDebugTracing(),<br/>        withRouterConfig({paramsInheritanceStrategy: 'always'}))<br/>    ]<br/>  }<br/>);</span></pre><p id="f90c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">路由器独立API允许树抖动，从而消除了多余的代码。当捆绑器在构建过程中删除不需要的代码时，我们得到了大约11%的精简路由器实现。</p><h1 id="8be6" class="mq ml iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">4.HTTP with provideHttpClient</h1><p id="ecca" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">就像在路由器API中使用<code class="fe on oo op mg b">provideRouter()</code>函数一样，在Angular 15的新世界中，我们可以使用<code class="fe on oo op mg b">provideHttpClient()</code>在一个模块可选的app中提供<code class="fe on oo op mg b">HttpClient</code>。</p><p id="4786" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">同样的逻辑也适用于HTTP拦截器。我们可以使用<code class="fe on oo op mg b">withInterceptors()</code>将它们定义为函数:</p><pre class="kt ku kv kw gu mf mg mh bn mi mj bi"><span id="f189" class="mk ml iu mg b be mm mn l nx mp">bootstrapApplication(AppComponent, {<br/>  providers: [provideHttpClient(withInterceptors([authInterceptor()]))]<br/>});</span></pre><p id="2036" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">或者通过使用<code class="fe on oo op mg b">withInterceptorsFromDi()</code>注册一个基于类的拦截器:</p><pre class="kt ku kv kw gu mf mg mh bn mi mj bi"><span id="8cdb" class="mk ml iu mg b be mm mn l nx mp">bootstrapApplication(AppComponent, {<br/>  providers: [provideHttpClient(withInterceptorsFromDi([AuthInterceptor]))]<br/>});</span></pre><h1 id="7870" class="mq ml iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">5.功能路由器防护</h1><p id="5c04" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">除了树抖动路由器API，Angular 15还带来了其他创新，以减少样板代码。新的功能性路由器保护提供了一种更简洁的方法来直接在声明中实现保护，正如我们在下面的示例中看到的:</p><p id="9237" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">对于传统方法，我们实现一个<code class="fe on oo op mg b">AuthGuard</code>并在其中注入一个<code class="fe on oo op mg b">AuthService</code>来检查用户是否通过了<code class="fe on oo op mg b">canActivate()</code>方法的认证:</p><pre class="kt ku kv kw gu mf mg mh bn mi mj bi"><span id="0177" class="mk ml iu mg b be mm mn l nx mp">// The traditional approach: Implement AuthGuard and inject AuthService in it<br/>@Injectable({ providedIn: 'root' })<br/>export class AuthGuard implements CanActivate {<br/>  constructor(private authService: AuthService) {}<br/><br/>  canActivate() {<br/>    return this.authService.isAuthenticated();<br/>  }<br/>}<br/><br/>const route = {<br/>  path: 'dashboard',<br/>  canActivate: [AuthGuard]<br/>};</span></pre><p id="00e1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">有了功能性的路由器防护，我们可以去掉所有的样板代码，在我们的路由声明中注入<code class="fe on oo op mg b">AuthService</code>并调用它的<code class="fe on oo op mg b">isAuthenticated()</code>方法:</p><pre class="kt ku kv kw gu mf mg mh bn mi mj bi"><span id="b936" class="mk ml iu mg b be mm mn l nx mp">const route = {<br/>  path: 'dashboard',<br/>  canActivate: [() =&gt; inject(AuthService).isAuthenticated()]<br/>};</span></pre><h1 id="074c" class="mq ml iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">6.动态路由器出口名称</h1><p id="6033" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">我们现在可以在Angular 15中动态设置路由器出口名称。</p><p id="50e2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">比如我们可以从For循环中把它绑定到一个变量上，这在以前是不可能的。这是一个游戏改变者，它允许我们编写健壮的弹性组件。所以你要在一个循环中这样写:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq or l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">Angular 15:动态路由器出口名称</p></figure><p id="a540" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">您可以将插座作为输入参数传递。</p><h1 id="7a88" class="mq ml iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">7.轻松延迟加载</h1><p id="14a8" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">以前，当您在路由模块中延迟加载组件或其子组件时，您必须遵循延迟加载语法来选择要加载的内容，这有点复杂。</p><p id="f0ad" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我个人从来没有背过。每次我需要使用它时，我都会从另一个模块或项目中复制/粘贴它，并对其进行调整:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq or l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">Angular 14:惰性加载语法</p></figure><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq or l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">以角度导出模块</p></figure><p id="2784" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">Angular 15中的新语法叫做<a class="ae li" href="https://github.com/angular/angular/pull/47586" rel="noopener ugc nofollow" target="_blank"> router unwraps默认导入</a> s，这要简单得多。如果你像我一样，喜欢编写较少的样板代码，你会喜欢它的。</p><p id="1e3e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">您所需要做的就是使用<code class="fe on oo op mg b">export default</code>来指定默认情况下应该加载什么组件。然后就可以去掉<code class="fe on oo op mg b">.then(..)</code>操作了:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq or l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">Angular 15:惰性加载语法</p></figure><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq or l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">使用“导出默认值”以角度方式导出模块</p></figure><h1 id="e35f" class="mq ml iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">8.稳定图像指令</h1><p id="bb84" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">在Angular 14.2中添加到框架中的图像指令<code class="fe on oo op mg b"><a class="ae li" href="https://angular.io/guide/image-directive" rel="noopener ugc nofollow" target="_blank">NgOptimizedImage</a></code>，现在在当前版本中是稳定的。它优化了网页性能和<a class="ae li" href="https://medium.com/p/b56e28798e7f" rel="noopener">核心网页重要指标</a>得分，例如<a class="ae li" href="https://www.landsend.com/" rel="noopener ugc nofollow" target="_blank"> Land's End </a>在使用该指令后，其<a class="ae li" href="http://web.dev/lcp" rel="noopener ugc nofollow" target="_blank">最大内容油漆(LCP) </a>提高了75%。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj ow"><img src="../Images/3798359fd9789c78249af56224f61845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/0*qkpzpl8EcsKUV6r6"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">演示应用前后(<a class="ae li" href="https://medium.com/angular-blog/angular-v15-is-now-available-df7be7f2f4c8" rel="noopener">来源</a>)</p></figure><p id="db42" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">Angular 15还提供以下功能:</p><ul class=""><li id="94d4" class="nz oa iu ll b lm ln lp lq ls ob lw oc ma od me oe of og oh bi translated">图像警告的改进</li><li id="575c" class="nz oa iu ll b lm oi lp oj ls ok lw ol ma om me oe of og oh bi translated">由于自动生成了<code class="fe on oo op mg b">srcset</code>指令，缩短了下载时间</li><li id="50c6" class="nz oa iu ll b lm oi lp oj ls ok lw ol ma om me oe of og oh bi translated">实验性填充模式:当没有指定尺寸时，它让图像填充其父容器</li></ul><h1 id="9b55" class="mq ml iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">9.更好的堆栈跟踪</h1><p id="d06a" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">有了与Chrome DevTools团队合作开发的新的异步堆栈标记API，我们现在在堆栈跟踪中不再有<code class="fe on oo op mg b">zone.js</code>废话，有了更好的调试体验。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ox"><img src="../Images/b0e6a9ce3bd4ac1970f3f9637dd2276b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RBY1GZ-9kzZ4lJxQ-9GJIg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">角度为15°的堆栈跟踪的改进</p></figure><h1 id="d5e5" class="mq ml iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">10.盒子里打错了的香蕉</h1><p id="c2b0" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">“盒子里的香蕉”是一个描述角度模板中两种绑定方式的语法的术语。你可能在使用<code class="fe on oo op mg b">ngModel</code>时见过多次:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq or l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">带ngModel的角形材料下拉列表</p></figure><p id="2d97" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">有时开发人员通过将括号放在方框<code class="fe on oo op mg b">([])</code>之外来写括号(香蕉)和方括号(方框)的顺序不正确，这导致了很多错误。</p><p id="36da" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">新Angular版本中的修复将报告此类问题，并通过<a class="ae li" href="https://angular.io/guide/language-service" rel="noopener ugc nofollow" target="_blank">语言服务</a>提供修复。根据您的IDE，您可能需要也可能不需要在您的项目上安装<code class="fe on oo op mg b">@angular/language-service</code>并将其添加到您的<code class="fe on oo op mg b">package.json</code>中。例如，WebStorm从2019.1版开始不再需要它:</p><pre class="kt ku kv kw gu mf mg mh bn mi mj bi"><span id="62b3" class="mk ml iu mg b be mm mn l nx mp">npm install --save-dev @angular/language-service</span></pre><h1 id="92e3" class="mq ml iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">11.组件范围的关键帧</h1><p id="4e09" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">很长一段时间，Angular中的CSS关键帧都有问题。</p><p id="f9c9" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">尽管框架提供了一个<code class="fe on oo op mg b">Emulated</code> <code class="fe on oo op mg b">viewEncapsulation</code>来防止样式表的命名冲突，CSS <code class="fe on oo op mg b">@keyframes</code>动画并没有锁定到组件的属性选择器。它们仍然在全球范围内可用，因此，<a class="ae li" href="https://github.com/angular/angular/issues/33885" rel="noopener ugc nofollow" target="_blank">它们会泄漏或与其他同名的关键帧</a>重叠。下面是本·纳德尔为这种情况做的演示:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oy or l"/></div></figure><p id="f7fa" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在Angular 15中，如果在应用程序的多个位置有相同的关键帧名称，它们将不会在组件定义和渲染中发生冲突，因为它们现在是组件范围的。</p><p id="ec4e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">Angular团队通过用主机组件选择器假装关键帧名称来解决这个已经运行了多年的问题。</p><p id="2ca0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果您依赖于关键帧的全局方面，此更改可能会破坏您的代码。在这种情况下，需要将它们移到全局样式表中。</p><h1 id="05f0" class="mq ml iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">12.MDC组件的兼容性</h1><p id="4389" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">为了更好地符合材料设计规范并采用材料3组件样式，Angular团队基于<a class="ae li" href="https://github.com/material-components/material-components-web" rel="noopener ugc nofollow" target="_blank">Web材料设计组件(MDC) </a>重构了Angular材料组件。</p><p id="f370" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">您可能会注意到这些组件的样式和DOM结构有所更新，有些是从头开始重写的。因此，当<a class="ae li" href="https://github.com/angular/components/blob/main/guides/v15-mdc-migration.md#how-to-migrate" rel="noopener ugc nofollow" target="_blank">迁移到Angular 15 </a>时，您可能需要调整您的项目。</p><h1 id="6354" class="mq ml iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">13.CDK列表框</h1><p id="b95b" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">在Angular 15中，组件开发工具包(CDK)包附带了一个基于WAI ARIA列表框模式的<code class="fe on oo op mg b">@angular/cdk/listbox</code>模块:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj oz"><img src="../Images/22113eb08a4148030cbec96c7dbad294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/0*R-lksWjW10Si32I6"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">CDK列表框用户体验(<a class="ae li" href="https://medium.com/angular-blog/angular-v15-is-now-available-df7be7f2f4c8" rel="noopener">来源</a>)</p></figure><p id="78ec" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这个新的CDK模块有助于创建定制的列表框交互，这要归功于它提供的指令。它提供了<a class="ae li" href="https://medium.com/better-programming/angular-keyboard-listeners-good-practices-b208edc6bf89" rel="noopener">可访问性(A11y) </a>特性，比如bidi布局支持、键盘交互和焦点管理。</p><h1 id="7df7" class="mq ml iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">其他改进</h1><p id="04ae" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">对于角度15，我们还有以下变化:</p><ul class=""><li id="a748" class="nz oa iu ll b lm ln lp lq ls ob lw oc ma od me oe of og oh bi translated">常青藤地标/更好的性能:Angular的最新版本提供了一个舒适的构建，重建HMR更容易实现。</li><li id="e20b" class="nz oa iu ll b lm oi lp oj ls ok lw ol ma om me oe of og oh bi translated">更好的堆栈跟踪:</li><li id="9ae0" class="nz oa iu ll b lm oi lp oj ls ok lw ol ma om me oe of og oh bi translated">Angular DevTools现在提供了依赖注入调试的预览。</li><li id="e5f4" class="nz oa iu ll b lm oi lp oj ls ok lw ol ma om me oe of og oh bi translated">Angular CLI:当你用<code class="fe on oo op mg b">ng new myAppName</code>创建一个新的Angular工作空间时，你会得到一个简化的输出和更少的生成文件。</li><li id="246f" class="nz oa iu ll b lm oi lp oj ls ok lw ol ma om me oe of og oh bi translated">表单包有更多的实用功能。</li><li id="8426" class="nz oa iu ll b lm oi lp oj ls ok lw ol ma om me oe of og oh bi translated">弃用量角器:基于社区反馈，Angular团队宣布e2e测试框架<a class="ae li" href="https://www.protractortest.org/#/" rel="noopener ugc nofollow" target="_blank">量角器</a>弃用，它将在2023年夏天停止使用。可供选择的端到端测试解决方案包括<a class="ae li" href="https://www.cypress.io/" rel="noopener ugc nofollow" target="_blank"> Cypress </a>、<a class="ae li" href="https://nightwatchjs.org/" rel="noopener ugc nofollow" target="_blank"> Nightwatch </a>和<a class="ae li" href="https://webdriver.io/" rel="noopener ugc nofollow" target="_blank"> WebdriverIO </a>。</li><li id="40c6" class="nz oa iu ll b lm oi lp oj ls ok lw ol ma om me oe of og oh bi translated">新版本改进了Angular 14中引入的实验性esbuild支持。要尝试esbuild，您需要在<code class="fe on oo op mg b">angular.json</code>中更新您的构建器，如下所示:</li></ul><pre class="kt ku kv kw gu mf mg mh bn mi mj bi"><span id="18a7" class="mk ml iu mg b be mm mn l nx mp">"builder": "@angular-devkit/build-angular:browser-esbuild"</span></pre><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pa"><img src="../Images/9cb9468847263ff6f6d55edd88bee22d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pL05Z-1RA-f61zy6"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">esbuild登录页面(<a class="ae li" href="https://blog.angular.io/angular-v15-is-now-available-df7be7f2f4c8" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></figure><h1 id="74d3" class="mq ml iu bd mr ms mt mu mv mw mx my mz kj na kk nb km nc kn nd kp ne kq nf ng bi translated">最终想法</h1><p id="7e29" class="pw-post-body-paragraph lj lk iu ll b lm ns ke lo lp nt kh lr ls nu lu lv lw nv ly lz ma nw mc md me in bi translated">与React等轻量级库相比，Angular存在性能问题。但在移除了遗留的编译器和渲染引擎并用Ivy替换后，Angular团队和社区贡献者实现了新的改进，这将使Angular超快。</p><p id="b3cf" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">正如你所看到的，在框架版本15中有很多变化。如果你还没有涉足其中，我希望你能从这篇文章中获得一些见解，并更愿意在你的项目中使用它。</p><p id="b8f2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">更多详情可以查看GitHub上的<a class="ae li" href="https://medium.com/angular-blog/angular-v15-is-now-available-df7be7f2f4c8" rel="noopener">Angular博客</a>或者Angular 15 <a class="ae li" href="https://github.com/angular/angular/blob/main/CHANGELOG.md" rel="noopener ugc nofollow" target="_blank"> Changelog </a>。</p><p id="3923" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">下面这篇文章可以帮助您完成迁移过程:<a class="ae li" href="https://medium.com/gitconnected/angular-upgrade-26d331837012" rel="noopener">升级到Angular 15:我们的经验和教训</a>。</p></div><div class="ab cl pb pc hy pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="in io ip iq ir"><pre class="kt ku kv kw gu mf mg mh bn mi mj bi"><span id="fb84" class="mk ml iu mg b be mm mn l mo mp"><strong class="mg je">Want more?</strong><br/><br/>I write about engineering, technology, and leadership <br/>for a community of smart, curious people.<br/> <br/>Join <a class="ae li" href="https://rakiabensassi.substack.com/" rel="noopener ugc nofollow" target="_blank">my free email newsletter</a> for exclusive access.</span></pre></div></div>    
</body>
</html>