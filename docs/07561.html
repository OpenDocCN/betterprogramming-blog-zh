<html>
<head>
<title>Divide Your Codebase by Domains and Features To Keep It Scalable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">按照领域和特性划分你的代码库，以保持它的可伸缩性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/divide-code-by-domains-and-features-and-keep-it-scalable-bb5bd66cf3d2?source=collection_archive---------7-----------------------#2021-01-27">https://betterprogramming.pub/divide-code-by-domains-and-features-and-keep-it-scalable-bb5bd66cf3d2?source=collection_archive---------7-----------------------#2021-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cf12" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们确保我们的代码不难导航</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/79da166747c71905f3c8f7cbbf3b6125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2BXZ3DsUeWGN9PZw"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="c19b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="c769" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在我的编程生涯中，我有机会使用不同的框架和不同的目录结构参与许多不同的项目。我的第一次经历是简单的MVC后来我看到了MVVM和六边形建筑，我注意到了一些事情:</p><ul class=""><li id="5233" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj mr ms mt mu bi translated">尽管这些体系结构有一些规则和概念，但不同的框架建议不同的目录结构</li><li id="2915" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">为所有的模型/控制器/视图/ <put any="" module="" type="" there="">建立一个单一的目录只能在较小的应用程序中运行良好。当应用程序增长时，会出现越来越多的问题，例如，单个目录中有太多文件，很难在它们之间导航</put></li><li id="bfab" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">每个程序员都有自己的偏好，如果你不同意一套通用的目录结构规则(框架建议的或者你自己的)，你将会陷入一片混乱:)</li></ul><p id="859a" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">显而易见的结论是:<em class="nd">您的目录结构很重要。它可以让合作变得更容易，也可能成为你在试图寻找某样东西时浪费时间和沮丧的原因。</em></p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="c78b" class="kw kx iq bd ky kz nl lb lc ld nm lf lg jw nn jx li jz no ka lk kc np kd lm ln bi translated">为你的新项目选择最好的方法</h1><p id="0617" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">通常，教程和框架文档建议一个简单的目录结构，比如一个目录用于所有视图，另一个目录用于控制器，等等。很多时候，这就够了！如果你只是学习一项新技术或编写一个私人应用程序，你不需要其他任何东西。即使你正在开发一个商业应用程序，但是整个实现计划了几个星期/几个月，团队中只有1-2个开发人员——可能你的应用程序不会增长太多，简单的模块/类类型划分就足够了。</p><p id="8ae2" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">如果你在你的公司开始一个长期项目，乐趣就开始了——在这种情况下，可能许多不同的开发人员会处理这些代码(同时或不同时——这并不重要)。您希望拥有这样一种结构:</p><ul class=""><li id="8317" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj mr ms mt mu bi translated">允许新开发人员快速开始工作，即使有成千上万行代码</li><li id="eeb5" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">易于维护</li><li id="4222" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">不需要太多努力就可以随着时间而改变</li></ul><h1 id="7cf3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">按领域/特性划分代码</h1><p id="d0a8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">基本思想是在你的目录结构中保持相关的模块/类彼此靠近，这样当你的应用程序增长时，你就不会被迫搜索不同的目录来引入一个功能的变化。通常，应用程序中的变化与特定的领域或特性相关，在构建结构时，您应该关注业务领域，而不是模块/类类型。</p><p id="d002" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">如果你有兴趣在你的整个过程中实现这种方法，你可以学习更多关于领域驱动设计(DDD)的知识。</p><p id="6c76" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">让我们考虑一个简单的应用程序，它有按模块/类类型分类的目录。</p><p id="423b" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">(我使用了<code class="fe nq nr ns nt b">.js</code>扩展名来区分文件和目录——您可以将相同的原则应用于任何编程语言)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="3d77" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">不错，也许你已经习惯了，但是想象一下每个目录中有20多个文件。现在让我们用另一种方式来组织它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="f18e" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">这种类型的结构将允许你改变，例如，公司逻辑，而不用在不同的目录之间跳转，即使有许多应用程序模块。更重要的是:如果一个新的开发人员进入一个项目并被分配到公司逻辑的变更中，他们会在一个地方找到所有相关的文件！</p><p id="745b" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">这是一个非常简单的例子，在这种情况下，两种方法都可以很好地工作。但是通常应用程序中的特性更复杂，你需要不止一个类来处理它们的逻辑。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="eb1e" class="kw kx iq bd ky kz nl lb lc ld nm lf lg jw nn jx li jz no ka lk kc np kd lm ln bi translated">按照逻辑的领域/特性划分到最低层</h1><p id="7a4c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们想象一下,<code class="fe nq nr ns nt b">task </code>目录中的逻辑非常复杂，您想要将单个控制器分成几个更小的模块/类。这是一种按领域/功能划分的情况。你可以为特定的特性引入越来越多的文件，它们会粘在一起。下面介绍一些与具体特性相关的子目录:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="b98a" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">以这种方式构建您的应用程序，您最终会得到多个相互嵌套的目录。这似乎是一个问题，但是请记住，我们讨论的是一种适合具有数百个模块/类的大型应用程序的结构——因此，另一种选择是建立一个相对扁平的目录树，每个目录中有几十个文件。这种场景中的深层结构更容易维护的原因如下:</p><ul class=""><li id="724d" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj mr ms mt mu bi translated">它使得搜索与特定功能相关的文件变得非常容易。如果你想改变“导出任务列表到CSV”中的一些东西，你只需要打开树的下一层:tasks &gt; export &gt; buildCsv.js。这对于向项目介绍新的开发人员来说是至关重要的，而且这也使得审查代码更加容易，因为所有与特性相关的代码都在一个地方，所以您不会错过任何东西。</li><li id="c0f9" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">实际上，您可以利用嵌套来隐藏底层细节——当您以这种方式构建项目结构时，您的目录将成为独立的、自给自足的模块——这样您就可以公开每个目录的API，而不必在使用另一个模块逻辑时关心内部细节</li></ul></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="95e7" class="kw kx iq bd ky kz nl lb lc ld nm lf lg jw nn jx li jz no ka lk kc np kd lm ln bi translated">公开目录的API</h1><p id="0ebd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们更多地讨论如何将目录作为独立的、自给自足的模块来使用。当您构建提到的<code class="fe nq nr ns nt b">task </code>模块，并且您需要在其他地方使用它的某个部分时，请考虑这种情况(例如，在<code class="fe nq nr ns nt b">user</code>模块中显示分配给当前用户的所有任务)。您可以创建一个公开<code class="fe nq nr ns nt b">task</code>模块的“公共API”的文件，并如下使用它，而不是引用<code class="fe nq nr ns nt b">task</code>目录中的特定文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="7061" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">这样你就不需要处理很长的导入路径，并且你总是知道一个特定模块的哪些部分在它之外被使用！</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="a379" class="kw kx iq bd ky kz nl lb lc ld nm lf lg jw nn jx li jz no ka lk kc np kd lm ln bi translated">可重用代码呢？</h1><p id="6eb3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当按照领域和特性划分结构时，需要回答的一个棘手问题是将不属于任何领域(例如，抽象)的可重用代码放在哪里。</p><p id="8b4a" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">我想没有一个单一的解决方案适用于所有情况。通常，您可以尝试以下方法之一:</p><ul class=""><li id="a8e5" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj mr ms mt mu bi translated">创建一个只包含可重用代码的专用目录，例如<code class="fe nq nr ns nt b">abstractions</code>或<code class="fe nq nr ns nt b">common</code></li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="7ce5" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj mr ms mt mu bi translated">为抽象域/特征创建目录，例如，<code class="fe nq nr ns nt b">list</code>用于与列表相关的所有抽象，<code class="fe nq nr ns nt b">export</code>用于与导出相关的所有抽象，等等。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="ab6d" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj mr ms mt mu bi translated">混合以上两者——例如<code class="fe nq nr ns nt b">abstractions</code>纯抽象模块/类的目录和其他可重用代码的专用目录</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="b9d8" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">你必须自己找出什么对你和你的项目最有利。好消息是——你不需要担心做出错误的决定，因为你以后可以很容易地修正它。例如，从第三个示例切换到第一个示例只需要将<code class="fe nq nr ns nt b">cardPayment</code>目录移动到<code class="fe nq nr ns nt b">abstractions</code>并将<code class="fe nq nr ns nt b">abstractions</code>重命名为<code class="fe nq nr ns nt b">common</code>。当你移动文件时，大多数编辑器会自动更新文件中的所有导入。易于重构是这种结构规模如此之大的另一个原因！</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="ca34" class="kw kx iq bd ky kz nl lb lc ld nm lf lg jw nn jx li jz no ka lk kc np kd lm ln bi translated">易于维护，难以创建</h1><p id="c9c6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们总结一下，谈谈一些利弊:</p><h1 id="ef69" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">优点:</h1><ul class=""><li id="9de7" class="mk ml iq lq b lr ls lu lv lx nw mb nx mf ny mj mr ms mt mu bi translated">移动整个目录或重命名它们不是问题</li><li id="52a7" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">很容易找到与特定功能相关的所有文件，这简化了使用您以前从未见过(或很久没有见过)的代码的工作</li><li id="0f8f" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">您的代码被分成多个更小的模块，因此您可以逐个对每个模块进行大的修改</li><li id="bbf8" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">如果有必要，可以很容易地将应用程序分成几个更小的部分(同样，您的代码已经被分成了自给自足的模块！)</li><li id="f06e" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">当您构建一个新特性时，类似于另一个已经存在的特性，您可以轻松地复制整个目录，然后开始应用更改。当然，复制-粘贴是一种反模式，但是当您需要创建一个新的类似结构的模块时，它可能会很有用。请不要复制业务逻辑。它总会在某个时候回来咬你一口</li><li id="6ab8" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">不仅您的代码，而且您的目录也反映了面向对象的设计</li></ul><h1 id="9415" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">缺点:</h1><ul class=""><li id="737d" class="mk ml iq lq b lr ls lu lv lx nw mb nx mf ny mj mr ms mt mu bi translated">创建适当的目录结构需要一些努力</li><li id="38e6" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">当你添加/更改功能时，你必须更新它</li><li id="f97e" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">为可重用模块/类找到一个好的位置可能比平常更难</li><li id="8945" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">可能有一些框架的限制，比如按照类型强制划分目录结构的一部分(例如，一些框架要求将所有模型保存在一个目录中)</li></ul><p id="4a73" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">总的来说，从我的经验来看，当构建新的东西时，你必须花更多的时间，但是一旦有了新的东西，维护就容易多了——这在长期项目中非常有效。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="97ad" class="kw kx iq bd ky kz nl lb lc ld nm lf lg jw nn jx li jz no ka lk kc np kd lm ln bi translated">一些最后的提示</h1><ul class=""><li id="d48e" class="mk ml iq lq b lr ls lu lv lx nw mb nx mf ny mj mr ms mt mu bi translated">尽量不要在目录路径和文件名中重复名称(例如，最好用<code class="fe nq nr ns nt b">list/View</code>代替<code class="fe nq nr ns nt b">list/ListView</code>)。如果你需要重命名目录，你不需要重命名里面的文件</li><li id="756b" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">按照领域/特性划分到最深层次。当你引入一个按类型分类的子目录(例如<code class="fe nq nr ns nt b">task/list/views</code>)时，你将会失去结构的整体灵活性，如果子目录会增长，那么重构它将需要很大的努力</li><li id="6aea" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">总是创建一个模块/类来公开特定目录的API。这是确保您的目录作为单独的模块工作的好方法<br/>(参见展示您的目录的API一节中的最后一个例子)</li><li id="c477" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">不要犹豫，尝试将本文中的一些解决方案与您自己的混合使用——但是要确保您的结构规则是明确定义的，并且被整个团队所接受</li></ul><p id="46f6" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">感谢阅读；希望你觉得有用。如果你有任何问题，请随时回复。</p></div></div>    
</body>
</html>