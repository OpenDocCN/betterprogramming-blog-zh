<html>
<head>
<title>Creating a Reusable and Generic Database Layer in Swift 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift 5中创建可重复使用的通用数据库层</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/reusable-generic-database-layer-in-swift-7950d604883b?source=collection_archive---------1-----------------------#2019-10-19">https://betterprogramming.pub/reusable-generic-database-layer-in-swift-7950d604883b?source=collection_archive---------1-----------------------#2019-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0fff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习使用Mapper，神奇的课堂</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4f8d85c656cd5b969e5f0d52e367afc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DjFzq_JcSPviXP4u5b60Vw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@fabioha?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">法比奥</a>在<a class="ae ky" href="https://unsplash.com/s/photos/database?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4aed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的重点是创建一个可重用的通用数据库(DB)层，并解释如何执行一个特定的实现，在本例中是<a class="ae ky" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/index.html" rel="noopener ugc nofollow" target="_blank">核心数据</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8a42" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">初步说明</h1><p id="4daa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一些黄金法则/建议:</p><ol class=""><li id="bb87" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">DB层不应该暴露给视图层(视图控制器)。</li><li id="bde3" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">只有服务应该能够调用DB层来执行创建、读取、更新和删除(CRUD)操作。</li><li id="503b" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">DB层的内部工作决不能暴露给外层。</li><li id="6cab" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">DB层必须以这样一种方式编写，即如果需要，可以在以后更改DB客户端，而不需要进行太多的更改，例如，如果您最初使用核心数据，然后想要使用<a class="ae ky" href="https://realm.io/" rel="noopener ugc nofollow" target="_blank">领域</a>来代替。</li><li id="0151" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">数据库实体不应该暴露在外层。视图控制器或服务不应该知道实体/模型类，比如<code class="fe nn no np nq b">NSManagedObject</code>子类。这将减少层的耦合，并且DB实现可以在以后容易地切换。</li></ol><p id="8a3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将涵盖的内容:</p><ol class=""><li id="c610" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">准备通用数据库层，</li><li id="47c4" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">创建DB层的特定实现，</li><li id="d1d0" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">在第二步中为数据库实现提供映射器层。</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ed51" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">第一步:准备一个通用数据库层</h1><p id="66bd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将从创建一个通用数据库层开始。</p><p id="5836" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何需要保存到数据库的实体都应该实现<code class="fe nn no np nq b">Storable</code>协议。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">StorageContext由几乎任何数据库实施都需要的通用数据库操作组成</p></figure><p id="1a6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程的命名约定:</p><ol class=""><li id="6866" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">DBEntity:实现<code class="fe nn no np nq b">Storable</code>接口的实体。这个实体可以保存到数据库中。在我们的例子中，<code class="fe nn no np nq b">NSManagedObject</code>子类是DBEntities。例如，<code class="fe nn no np nq b">StoryEntity</code>就是一个DBEntity。</li><li id="5187" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">DomainEntity:实现<code class="fe nn no np nq b">Mappable</code>接口的实体。这个实体可以用在视图层和业务层。这无法保存到数据库。域名实体的一个例子是<code class="fe nn no np nq b">Story</code>。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3fef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">Sorted</code>类需要给出一个因子来对结果进行排序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="38cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最常见的数据库有具体的和内存中的实现。核心数据具有可用于单元测试的内存类型。<code class="fe nn no np nq b">Enum</code> <code class="fe nn no np nq b">ConfigurationType</code>支持这种需求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f46e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">第二步:创建DB层的具体实现</h1><p id="02bc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我将在这里使用核心数据为我在第一步中创建的DB层提供一个实现。核心数据有一些大多数情况下都需要的函数，所以让我们添加这些方法作为<code class="fe nn no np nq b">StorageContext</code>的扩展。<code class="fe nn no np nq b">CoreData</code>实体由<code class="fe nn no np nq b">NSManagedObjectID</code>识别；当通过ID从数据库中获取现有对象时，我们将需要这个方法。您还可以根据需要添加其他类似的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">CoreDataStorageContext</code>是<code class="fe nn no np nq b">StorageContext</code>的实现。这是我前面讲的具体实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b014" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，<code class="fe nn no np nq b">CoreDataStorageContext</code>实现了<code class="fe nn no np nq b">StorageContext</code>协议中所有需要的方法。这里需要注意的是，所有的方法都需要<code class="fe nn no np nq b">Storable</code>类型的实体。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e51f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">CoreDataStoreCoordinator</code>是负责数据库初始化和设置所有先决条件的类。我在文章中包含了这个类，这样您就可以理解DB层的端到端实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="59e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有核心数据实体都继承<code class="fe nn no np nq b">NSManagedObject</code>，默认情况下<code class="fe nn no np nq b">NSManagedObject</code>不实现<code class="fe nn no np nq b">Storable</code>协议。要将<code class="fe nn no np nq b">NSManagedObject</code>标记为可存储，我们需要使其符合<code class="fe nn no np nq b">Storable</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d142" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个样本<code class="fe nn no np nq b">StoryEntity</code>的样子。记住<code class="fe nn no np nq b">StoryEntity</code>是一个DBEntity，也就是说，它可以持久化到DB中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="03da" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">步骤三:为数据库实现准备一个映射层</h1><p id="6cfa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如我在文章开始时提到的，领域实体和数据库实体应该是不同的。视图控制器和业务(服务)层不应该知道数据库实体；视图控制器应该不知道什么是<code class="fe nn no np nq b">NSManagedObject</code>。所以这一步就是专门为此服务的。如果您不想创建模型类的不同版本，您可能不需要这一步。</p><p id="4915" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们之前已经看到，我们所有的DBEntities都应该实现<code class="fe nn no np nq b">Storable</code>协议。类似地，我们所有的域实体都应该实现<code class="fe nn no np nq b">Mappable</code>协议。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d3f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到，我在<code class="fe nn no np nq b">Mappable</code>中声明了一个名为<code class="fe nn no np nq b">NSManagedObjectID </code>的属性。我这样做是因为我们正在处理由<code class="fe nn no np nq b">NSManagedObjectID</code>定义的核心数据和<code class="fe nn no np nq b">CoreData</code>实体。将域实体映射到数据库实体时，这是必需的。如果您已经有了实体的自定义ID，例如story number，则可能不需要它。</p><p id="6586" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我没有在我们的每个域实体中添加属性<code class="fe nn no np nq b">NSManagedObjectID</code>，而是将它添加到了<code class="fe nn no np nq b">Mappable</code>协议中。</p><p id="f81e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为我所有的域实体创建了一个基本实体。所有的域实体都应该继承这个<code class="fe nn no np nq b">DomainBaseEntity</code>。来自<code class="fe nn no np nq b">Mappable</code>协议的<code class="fe nn no np nq b">NSManagedObjectID</code>属性在<code class="fe nn no np nq b">DomainBaseEntity</code>中定义。所以没有一个模型类需要提供这个属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="0f9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是示例域实体的外观。实现<code class="fe nn no np nq b">Codable</code>接口的原因是为了从JSON到对象的自动映射。我已经在我的文章<a class="ae ky" href="https://medium.com/better-programming/highly-customizable-network-layer-in-swift-5-1e5c1e163674" rel="noopener"> <strong class="lb iu">这里</strong> </a>中详细解释过了</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="adc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经准备好创建存储上下文到业务层的映射层，反之亦然。</p><p id="2a44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">BaseDao</code>是所有数据访问对象(DAO)类的父类。它有可以在<code class="fe nn no np nq b">StorageContext</code>上执行的方法。它将<code class="fe nn no np nq b">StorageContext</code>声明为依赖项。你可以在这里传递<code class="fe nn no np nq b">StorageContext</code>的任何实现，比如<code class="fe nn no np nq b">CoreDataStorageContext</code>或者<code class="fe nn no np nq b">RealmStorageContext</code>。您会看到<code class="fe nn no np nq b">BaseDao</code>期望两种类型的实体:Domain和DB。<code class="fe nn no np nq b">DomainEntity</code>应为<code class="fe nn no np nq b">Mappable</code>类型，而<code class="fe nn no np nq b">DBEntity</code>应符合<code class="fe nn no np nq b">Storable</code>协议。这些实体是在域和数据库实体之间进行映射所必需的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b84b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有一个神奇的类，<em class="nt"> Mapper </em>，它将实体从域映射到数据库，反之亦然。我使用了<a class="ae ky" href="https://github.com/wickwirew/Runtime" rel="noopener ugc nofollow" target="_blank">运行时</a>库来迭代属性，并将它们从域实体复制到DB实体，反之亦然。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="16e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个特定的<code class="fe nn no np nq b">StoryDao</code>，它是<code class="fe nn no np nq b">BaseDao</code>的子类。<code class="fe nn no np nq b">BaseDao</code>的每个子类都应该提供域和DB实体。在<code class="fe nn no np nq b">StoryDao</code>的情况下，域实体是<code class="fe nn no np nq b">Story</code>，DBentity是<code class="fe nn no np nq b">StoryEntity</code>。我更喜欢为每个实体/数据库表创建不同的DAO。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ac86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了便于使用，我创建了一个<code class="fe nn no np nq b">DBManager</code>来初始化所需的Dao。我们需要在初始化DAO类时提供<code class="fe nn no np nq b">StorageContext</code>实现。<code class="fe nn no np nq b">StorageContext</code>是<code class="fe nn no np nq b">DBManager</code>的依赖，应该在调用任何DAO之前设置。这样，您可以在运行时更改<code class="fe nn no np nq b">StorageContext</code>实现。我们还可以为<code class="fe nn no np nq b">StorageContext</code>提供不同的配置类型，比如在运行测试用例时在内存中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d9c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提供<code class="fe nn no np nq b">StorageContext</code>实现的理想位置是在应用程序的开始。但是，它可以根据您的需要进行更改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cd13" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">测试</h1><blockquote class="nu"><p id="61cc" class="nv nw it bd nx ny nz oa ob oc od lu dk translated">空谈不值钱，给我看看代码。莱纳斯·托沃兹</p></blockquote><p id="0446" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">现在我们都准备好了。我们已经成功创建了一个数据库层，可以直接从服务中开始使用。在下面的代码片段中，我向<code class="fe nn no np nq b">createStory()</code>方法传递了一个新的<code class="fe nn no np nq b">story</code>对象，并将其保存到数据库的<code class="fe nn no np nq b">Story</code>表中。我们所要做的就是提供<code class="fe nn no np nq b">story</code>对象。我们的<code class="fe nn no np nq b">storyDAO</code>已经知道应该用来保存<code class="fe nn no np nq b">story</code>对象的DB实体。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f4d5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">总有改进的空间</h1><ol class=""><li id="de37" class="mz na it lb b lc mu lf mv li ok lm ol lq om lu ne nf ng nh bi translated">域实体不是100%独立的，因为它们必须从<code class="fe nn no np nq b">DomainBaseEntity</code>继承。如果您在每个实体中有一些自定义标识符，如<code class="fe nn no np nq b">storyNumber</code>，则可以省略<code class="fe nn no np nq b">DomainBaseEntity</code>。</li><li id="fc6a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">在<code class="fe nn no np nq b">StorageContext</code>和<code class="fe nn no np nq b">BaseDao</code>中重复基本的数据库CRUD操作。由于域和数据库有不同的实体，这是一种折衷。如果你有一个用例，你想在整个项目中使用相同的域和数据库实体，你不需要<code class="fe nn no np nq b">BaseDao</code>。在这个场景中，您的Dao，比如<code class="fe nn no np nq b">StoreDao</code>，可以直接从<code class="fe nn no np nq b">StorageContext</code>继承，如果需要的话，甚至可以提供定制的方法。</li></ol><p id="f281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望一切都很清楚。你可以从<a class="ae ky" href="https://github.com/waseemwk22/NetworkLayerSwift" rel="noopener ugc nofollow" target="_blank"> Github </a>下载完整的项目。</p><p id="17e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如有任何困惑，请留言。我很乐意帮忙。欢迎建议。</p></div></div>    
</body>
</html>