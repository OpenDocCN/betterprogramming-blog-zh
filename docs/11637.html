<html>
<head>
<title>5 NestJS Techniques to Build Efficient and Maintainable Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建高效且可维护的应用程序的5种NestJS技术</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-nestjs-techniques-to-build-efficient-and-maintainable-apps-be6bc77e789e?source=collection_archive---------2-----------------------#2022-04-05">https://betterprogramming.pub/5-nestjs-techniques-to-build-efficient-and-maintainable-apps-be6bc77e789e?source=collection_archive---------2-----------------------#2022-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a0ab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在5分钟内学会5个隐藏的宝石</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0406c9a5112c27577188d218bd731222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I00HTH4kt3AFGZuIeT5qng.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@whatisdelirium?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">在<a class="ae ky" href="https://unsplash.com/s/photos/cat-gem?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的</a></p></figure><p id="1105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NestJS是一个复杂的框架，并且在不断发展。这是一个很棒的框架，有许多现成的特性。有些功能并不广为人知，也没有得到充分利用，但如果用在正确的地方，它们会非常强大。</p><p id="34b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将走过5个隐藏的宝石。</p><p id="b64e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">向前跳转:</em></p><ul class=""><li id="4522" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae ky" href="#f150" rel="noopener ugc nofollow">版本控制</a></li><li id="c433" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#7497" rel="noopener ugc nofollow">使用带有自定义装饰器的内存缓存</a></li><li id="532b" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#017e" rel="noopener ugc nofollow"> NestJS Cron Job </a></li><li id="bcc2" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#5dfc" rel="noopener ugc nofollow">用管道验证输入</a></li><li id="9527" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#d54a" rel="noopener ugc nofollow">通过切换底层平台提高性能</a></li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="f150" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">版本控制</h1><p id="30f7" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">版本控制对于web API开发至关重要。<a class="ae ky" href="https://medium.com/p/5e826ef832b6" rel="noopener">我们经常需要为重大变更创建新的API版本</a>，同时保持旧版本的工作。</p><p id="5179" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在NestJS 8之前，没有现成的API版本支持。因此，您需要手动实现版本控制。</p><p id="ff66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在NestJS 8中引入了3种不同类型的版本控制。</p><ul class=""><li id="c365" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">URI版本控制——版本将在请求的URI内传递(默认)</li><li id="0c45" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">标题版本——自定义请求标题将指定版本</li><li id="d477" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">媒体类型版本控制-请求的接受报头将指定版本</li></ul><p id="9503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以默认的URI版本为例。</p><p id="11af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要启用URI版本控制，请执行以下操作:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="7f2c" class="nt ms it np b gy nu nv l nw nx">app.enableVersioning({<br/>  type: VersioningType.URI,<br/>});</span></pre><p id="4812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要对控制器应用URL版本控制:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0381" class="nt ms it np b gy nu nv l nw nx">@Controller({<br/>  version: '1',<br/>})<br/>export class CatsControllerV1 { ....</span></pre><p id="799f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者您可以将它应用到单独的路线</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="e0c0" class="nt ms it np b gy nu nv l nw nx">@Version('2')<br/>  @Get('cats')<br/>  findAllV2(): string {<br/>    return 'This action returns all cats for version 2';<br/>  }</span></pre><p id="c225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个有用的功能是版本“<a class="ae ky" href="https://docs.nestjs.com/techniques/versioning" rel="noopener ugc nofollow" target="_blank">中性</a>”。您可以将控制器设置为版本中立的:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="60c6" class="nt ms it np b gy nu nv l nw nx">@Controller({<br/>  version: VERSION_NEUTRAL,<br/>})<br/>export class CatsController {</span></pre><p id="7855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果传入的请求根本不包含版本，它将被映射到<code class="fe ny nz oa np b">VERSION_NEUTRAL </code>控制器。</p><p id="1d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NestJS中新的版本控制特性简单而灵活。这为使用NestJS提供了另一个很好的理由。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="7497" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">使用带有自定义装饰器的内存缓存</h1><p id="4b4d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">缓存是计算机科学中的难题之一。NestJs提供了一个现成的c <a class="ae ky" href="https://docs.nestjs.com/techniques/caching" rel="noopener ugc nofollow" target="_blank"> ache manager </a>，默认情况下有一个内存中的数据存储。</p><p id="1593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用起来很简单。首先导入<code class="fe ny nz oa np b">CacheModule.</code></p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="a7c4" class="nt ms it np b gy nu nv l nw nx">imports: [CacheModule.register()]</span></pre><p id="76a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以使用<code class="fe ny nz oa np b">CACHE_MANAGER</code>令牌将其注入到一个类中，并开始使用它。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="e2e6" class="nt ms it np b gy nu nv l nw nx">constructor(@Inject(CACHE_MANAGER) private cacheManager: Cache) {}</span><span id="7b2a" class="nt ms it np b gy ob nv l nw nx">// To <!-- -->retrieve items from the cache<br/>await this.cacheManager.get('key');</span><span id="adce" class="nt ms it np b gy ob nv l nw nx">// To add an item to the cache<br/>await this.cacheManager.set('key', 'value');</span></pre><p id="5aaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在NestJS API中实现缓存，代码通常如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="9c3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当应用程序增长时，具有上述模式的代码将到处重复。</p><p id="080c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何减少重复？答案是一个定制装饰器。</p><p id="3ca7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">装饰器是一个可以扩展另一个函数的行为而不用修改它的函数。为了创建一个可以与缓存管理器交互的装饰器，我们需要将缓存管理器注入到装饰器中。强大的NestJS DI使它变得相对容易。</p><p id="cc29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是使用内存缓存管理器的装饰器的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="6ba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案的要点是:</p><ul class=""><li id="e74d" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><code class="fe ny nz oa np b">target</code>是包含装饰器的类</li><li id="7df0" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ny nz oa np b">descriptor </code>是对被修饰的类方法的引用</li><li id="0b62" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">在第12行，我们提取目标构造函数名和方法名以形成一个<code class="fe ny nz oa np b">cacheKey</code>，所以它是唯一的</li><li id="202a" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ny nz oa np b">ttl</code>是使缓存失效的持续时间，我们将默认值设置为10秒</li><li id="e17a" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第4行和第10行相当于在构造函数中调用@Inject decorator，如下所示:</li></ul><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="76a2" class="nt ms it np b gy nu nv l nw nx">constructor(@Inject(CACHE_MANAGER) private cacheManager: Cache) {}</span></pre><p id="83c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">装饰器的使用非常简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="6566" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它现在干净多了，我们可以将它应用于任何需要缓存的服务。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="017e" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">NestJS Cron Job</h1><p id="6960" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">尽管NestJS主要是为REST API设计的，但它也附带了一个调度包。这个包公开了一个API，允许我们创建cron作业。</p><p id="b675" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要开始使用NestJS cron作业，我们需要首先安装这个包</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="201e" class="nt ms it np b gy nu nv l nw nx">$ npm install --save @nestjs/schedule <br/>$ npm install --save-dev @types/cron</span></pre><p id="03f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过两种不同的方式创建cron作业:</p><ul class=""><li id="9601" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">以声明的方式创建cron作业。</li></ul><p id="8a61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ny nz oa np b">@Cron</code>装饰器支持<a class="ae ky" href="http://crontab.org/" rel="noopener ugc nofollow" target="_blank"> cron模式</a>。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="1301" class="nt ms it np b gy nu nv l nw nx">@Cron('45 * * * * *')<br/>  handleCron() {<br/>    this.logger.debug('Called when the current second is 45');<br/>  }</span></pre><p id="4ac5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第45秒时，将每分钟调用一次<code class="fe ny nz oa np b">handleCron </code>方法。您还可以使用预定义的cron表达式来设置作业。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="775b" class="nt ms it np b gy nu nv l nw nx">@Cron(CronExpression.EVERY_MINUTE)</span></pre><ul class=""><li id="4655" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">动态创建一个新的cron作业。</li></ul><p id="44cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用来自<code class="fe ny nz oa np b">cron</code>包的<code class="fe ny nz oa np b">CronJob</code>对象，您可以创建cron作业。然后，您可以使用<code class="fe ny nz oa np b">SchedulerRegistry.addCronJob()</code>方法将作业添加到调度注册表中。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="e9c4" class="nt ms it np b gy nu nv l nw nx">addCronJob(name: string, seconds: string) {<br/>  const job = new CronJob(`${seconds} * * * * *`, () =&gt; {<br/>    this.logger.warn(`time (${seconds}) for job ${name} to run!`);<br/>  });<br/><br/>this.schedulerRegistry.addCronJob(name, job);<br/>job.start();</span></pre><p id="cc98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解NestJS任务调度包中可用的其他选项和特性，请查看官方文档<a class="ae ky" href="https://docs.nestjs.com/techniques/task-scheduling" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="5dfc" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">用管道验证输入</h1><p id="c7a8" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">数据验证对任何Web API都很重要。在NestJS中，我们可以使用<a class="ae ky" href="https://docs.nestjs.com/pipes" rel="noopener ugc nofollow" target="_blank">管道</a>在运行时执行验证。当管道用于验证时，如果验证成功，它将返回未更改的数据，如果数据不正确，将引发错误。</p><p id="d578" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NestJS自带开箱管道，其中一个就是<code class="fe ny nz oa np b">ValidationPipe</code>。内置的验证管道基于流行的<a class="ae ky" href="https://github.com/typestack/class-validator" rel="noopener ugc nofollow" target="_blank">类验证器</a>包。下面显示了一个用法示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><ul class=""><li id="5dea" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><code class="fe ny nz oa np b">@IsString()</code>:传入值是否为字符串，</li><li id="687c" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ny nz oa np b">@Length(10)</code>:验证值的最小长度是否为10个字符。如果值不是字符串，它也会返回一个错误。</li></ul><p id="4e25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当收到的请求体<code class="fe ny nz oa np b">CreateCatDto</code>中的属性无效时，应用程序将自动响应一个<code class="fe ny nz oa np b">400 Bad Request</code>。</p><p id="3664" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，验证是用decorators进行的。同一个装饰器可以在整个NestJS应用程序的不同DTO类中使用。这使得验证逻辑更容易维护。</p><p id="bc0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内置的验证管道提供了更多的装饰器。您还可以在<a class="ae ky" href="https://github.com/typestack/class-transformer" rel="noopener ugc nofollow" target="_blank"> class-transformer </a>和class-validator包之上创建自己的定制验证管道。</p><p id="b064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NestJS中的管道灵活而强大。它可以是同步的，也可以是异步的。它还可以应用于不同级别的范围:参数、方法、控制器或全局。</p><p id="910f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于如何使用NestJS管道进行验证的更多细节，您可以查看官方文档<a class="ae ky" href="https://docs.nestjs.com/pipes" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="d54a" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">通过切换底层平台来提高性能</h1><p id="0d3d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">默认情况下，NestJS运行在Express之上。与其他API框架相比，它的性能并不是最好的。对于一个正常的app来说，性能上的差异是不会被注意到的。</p><p id="65f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你正在开发一个性能非常高的应用程序，你可以迁移你的NestJS应用程序来使用F <a class="ae ky" href="https://docs.nestjs.com/techniques/performance" rel="noopener ugc nofollow" target="_blank"> astify </a>。Fastify比Express快得多，大约快两倍。</p><p id="91a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从Express到Fastify的迁移相对容易，因为NestJS提供了基于适配器模式的框架独立性。换句话说，NestJS的设计使得Express和Fastify可以互换。</p><p id="7cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用Fastify，我们需要安装软件包</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="cfe0" class="nt ms it np b gy nu nv l nw nx">npm i --save @nestjs/platform-fastify</span></pre><p id="ae53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以在<code class="fe ny nz oa np b">main.ts.</code>中配置Fastify平台</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="a05d" class="nt ms it np b gy nu nv l nw nx">async function bootstrap() {<br/>  const app = await NestFactory.create&lt;NestFastifyApplication&gt;(<br/>    AppModule,<br/>    new FastifyAdapter()<br/>  );<br/>  await app.listen(3000);<br/>}</span></pre><p id="a912" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在Fastify已经准备好了！</p><p id="a761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，在NestJS中，Fastify被用作HTTP提供者。因此，那些依赖于Express的包将需要由Fastify等价包来替换。</p><p id="fed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想了解更多关于如何构建高性能NestJS应用程序的信息吗？</p><div class="oe of gp gr og oh"><a href="https://levelup.gitconnected.com/build-a-high-performance-nestjs-app-5b807ff452e4" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">构建高性能NestJS应用程序</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">优化NestJS应用性能的4个最佳实践</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="db77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们介绍了5个鲜为人知的特性及其用例。我希望你学到了一些东西。</p></div></div>    
</body>
</html>