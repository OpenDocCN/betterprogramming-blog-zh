<html>
<head>
<title>How to Use Event Bus in React Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React架构中使用事件总线</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-event-bus-in-react-architecture-f90485477647?source=collection_archive---------2-----------------------#2022-08-03">https://betterprogramming.pub/how-to-use-event-bus-in-react-architecture-f90485477647?source=collection_archive---------2-----------------------#2022-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5f9c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们创建一个混音应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bcf873becf37aa025c13cb63c1f8c832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2uMcGH7-ZrRalRI0f35OWw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="3db5" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="77cf" class="lq lr it ls b lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">我们将用60行代码从头开始编写一个轻量级的事件总线！</li><li id="1730" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated">我们将学习在React best中使用事件总线的用例。</li><li id="be97" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated">我们将在Google Maps API的演示中应用事件总线。</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="8816" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">我最近在工作中遇到了一个有趣的事件总线用例。在全球范围的web应用程序中，这是一个非常精简的模块来组织日志分析。它在一个大的代码库中创造了巨大的清晰度，所以我想与你分享我对这个有用的设计模式的案例研究。</p><p id="064a" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">我们走吧。</p><h1 id="1e2c" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">什么是事件总线？</h1><p id="17d4" class="pw-post-body-paragraph mu mv it ls b lt lu ju mx lv lw jx mz lx nj nb nc lz nk ne nf mb nl nh ni md im bi translated">事件总线是一种设计模式，它允许组件之间进行发布子样式的通信，同时组件保持松散耦合。</p><p id="0c77" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">组件可以向事件总线发送消息，而不知道消息发送到哪里。另一方面，组件可以监听事件总线上的消息，并在不知道消息来自何处的情况下决定如何处理该消息。通过这种设计，独立的组件可以在彼此不了解的情况下进行通信。</p><p id="d653" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">可视化看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a02de76c5cda8888e399642d287e8a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLRXfKgSrFCRsBE4VDJNqQ.png"/></div></div></figure><ul class=""><li id="626f" class="lq lr it ls b lt mw lv my lx nm lz nn mb no md me mf mg mh bi translated">事件:在事件总线上发送和接收的消息。</li><li id="2e20" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated">发布者:发出事件的发送者。</li><li id="b83c" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated">订阅者:监听事件的接收者。</li></ul><p id="ba5e" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">让我们仔细看看事件总线。</p><h1 id="2b42" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">从头开始构建事件总线</h1><p id="31f4" class="pw-post-body-paragraph mu mv it ls b lt lu ju mx lv lw jx mz lx nj nb nc lz nk ne nf mb nl nh ni md im bi translated">受<a class="ae np" href="https://v3-migration.vuejs.org/breaking-changes/events-api.html" rel="noopener ugc nofollow" target="_blank"> Vue的遗留事件API </a>的启发，我们将为我们的事件总线实现以下API:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><ul class=""><li id="e666" class="lq lr it ls b lt mw lv my lx nm lz nn mb no md me mf mg mh bi translated"><code class="fe ns nt nu nv b">on</code>:供订阅者监听(订阅)一个事件，并注册其事件处理程序。</li><li id="cbea" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><code class="fe ns nt nu nv b">off</code>:供订阅者删除(取消订阅)一个事件及其事件处理程序。</li><li id="a29f" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><code class="fe ns nt nu nv b">once</code>:对于订阅者来说，一个事件只听一次。</li><li id="e9ea" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><code class="fe ns nt nu nv b">emit</code>:发布者向事件总线发送事件。</li></ul><p id="01ea" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">现在，我们的事件总线的数据结构应该有两种能力:</p><ul class=""><li id="aca7" class="lq lr it ls b lt mw lv my lx nm lz nn mb no md me mf mg mh bi translated">对于发布者:能够在调用emit时触发与事件键关联的已注册事件处理程序。</li><li id="50c1" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated">对于订阅者:能够在调用on、once或off时添加或移除事件处理程序。</li></ul><p id="1092" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">我们可以为它使用一个键值结构，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="369a" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">要实现<code class="fe ns nt nu nv b">on</code>方法，我们需要做的就是将事件键添加到总线上，并将事件处理程序追加到处理程序数组中。我们还想返回一个取消订阅函数来删除事件处理程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a0f6" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">为了实现<code class="fe ns nt nu nv b">off</code>，我们可以简单地从总线上移除事件处理器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="059a" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">当调用<code class="fe ns nt nu nv b">emit</code>时，我们希望触发所有与事件相关的事件处理程序。我们将在这里添加错误处理，以确保所有的事件处理程序将被触发，尽管有错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="00c9" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">由于<code class="fe ns nt nu nv b">once</code>只会监听一个事件一次，我们可以把它看作是一个注册处理程序的方法，这个处理程序在触发后会取消自己的注册。一种方法是创建一个高阶函数<code class="fe ns nt nu nv b">handleOnce</code>。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="64d3" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">现在我们的事件总线中有了所有的方法！</p><h1 id="35b4" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">改进打字稿打字</h1><p id="28c4" class="pw-post-body-paragraph mu mv it ls b lt lu ju mx lv lw jx mz lx nj nb nc lz nk ne nf mb nl nh ni md im bi translated">事件总线的当前类型是相当开放的。事件键可以是任何字符串，事件处理程序可以是任何函数。为了使用起来更安全，我们可以添加类型检查，将事件键和处理程序关联添加到<code class="fe ns nt nu nv b">EventBus</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="41dd" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">现在，我们指示TypeScript键必须是<code class="fe ns nt nu nv b">keyof T</code>中的一个，并且处理程序应该具有相应的处理程序类型。例如:</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="e123" class="oa kz it nv b gy ob oc l od oe">interface MyBus {<br/>  'on-event-1': (payload: { data: string }) =&gt; void<br/>}</span><span id="2fc9" class="oa kz it nv b gy of oc l od oe">const myBus = eventbus&lt;MyBus&gt;()</span></pre><p id="ac44" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">开发时应该能看到清晰的类型定义。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/62b9d72175b824ba989cc6d354a635d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XFDiPwYjURmXf_76rPO14Q.png"/></div></div></figure><h1 id="19a6" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">在React中使用事件总线</h1><p id="09d3" class="pw-post-body-paragraph mu mv it ls b lt lu ju mx lv lw jx mz lx nj nb nc lz nk ne nf mb nl nh ni md im bi translated">我创建了一个<a class="ae np" href="https://remix.run/" rel="noopener ugc nofollow" target="_blank"> Remix </a>应用程序来演示如何使用我们刚刚构建的事件总线。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/cda8e8f3ed3320b555c5036be2553c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b8x4mW5-CjsH2Cwx.gif"/></div></div></figure><blockquote class="oi oj ok"><p id="3900" class="mu mv ol ls b lt mw ju mx lv my jx mz om na nb nc on nd ne nf oo ng nh ni md im bi translated"><em class="it">你可以在这里</em>  <em class="it">找到</em> <a class="ae np" href="https://github.com/DawChihLiou/eventbus-demo" rel="noopener ugc nofollow" target="_blank"> <em class="it"> GitHub库进行演示。</em></a></p></blockquote><p id="3f40" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">该演示展示了如何在同构的React应用程序中使用事件总线组织日志记录。我选择了三个事件来记录:</p><ul class=""><li id="e9d2" class="lq lr it ls b lt mw lv my lx nm lz nn mb no md me mf mg mh bi translated"><code class="fe ns nt nu nv b">onMapIdle</code>:当地图完成实例化或者用户完成拖动或缩放地图时，事件发生。</li><li id="26a6" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><code class="fe ns nt nu nv b">onMapClick</code>:用户点击地图时事件发生。</li><li id="10d2" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><code class="fe ns nt nu nv b">onMarkerClick</code>:当用户点击地图标记时事件发生。</li></ul><p id="c5df" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">让我们创建两个事件通道。一个用于地图，一个用于标记。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="3f39" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">分离事件通道的原因是为了清晰地分离关注点。当应用程序增长时，这种模式可以水平增长。</p><p id="7ecb" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">现在，让我们使用React组件中的事件通道。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8f35" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">我们订阅了<code class="fe ns nt nu nv b">Index</code>组件中的事件，并在地图和标记交互时发出事件。此外，通过订阅和取消订阅组件的生命周期，我们可以在用户旅程开始时只注册必要的事件处理程序。</p><h1 id="c767" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">最后的想法</h1><p id="67cc" class="pw-post-body-paragraph mu mv it ls b lt lu ju mx lv lw jx mz lx nj nb nc lz nk ne nf mb nl nh ni md im bi translated">如果你正在寻找一个事件总线库，Vue.js 推荐了几个选择:</p><ul class=""><li id="71ac" class="lq lr it ls b lt mw lv my lx nm lz nn mb no md me mf mg mh bi translated">米特</li><li id="3ee5" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae np" href="https://github.com/scottcorgan/tiny-emitter" rel="noopener ugc nofollow" target="_blank">微型发射器</a></li></ul><p id="1c3b" class="pw-post-body-paragraph mu mv it ls b lt mw ju mx lv my jx mz lx na nb nc lz nd ne nf mb ng nh ni md im bi translated">Reddit上还有一个有趣的关于使用Redux作为事件总线的讨论。一个维护者建议了一些基于Redux的工具来处理事件:</p><ul class=""><li id="1cac" class="lq lr it ls b lt mw lv my lx nm lz nn mb no md me mf mg mh bi translated"><a class="ae np" href="https://github.com/reduxjs/redux-toolkit/releases/tag/v1.8.0" rel="noopener ugc nofollow" target="_blank"> redux-toolkit的新监听器中间件</a></li><li id="b4d0" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae np" href="https://github.com/redux-observable/redux-observable/" rel="noopener ugc nofollow" target="_blank"> redux-observable </a></li><li id="d40a" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae np" href="https://github.com/redux-saga/redux-saga" rel="noopener ugc nofollow" target="_blank"> Redux-Saga </a></li></ul><h1 id="673d" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">参考</h1><ul class=""><li id="3c9e" class="lq lr it ls b lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><a class="ae np" href="https://github.com/developit/mitt" rel="noopener ugc nofollow" target="_blank"> GitHub:米特</a></li><li id="fb8b" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae np" href="https://github.com/scottcorgan/tiny-emitter" rel="noopener ugc nofollow" target="_blank"> GitHub:微型发射器</a></li><li id="f0c6" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae np" href="https://github.com/redux-observable/redux-observable/" rel="noopener ugc nofollow" target="_blank">GitHub:redux-observable</a></li><li id="5e39" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae np" href="https://github.com/redux-saga/redux-saga" rel="noopener ugc nofollow" target="_blank"> GitHub: Redux-Saga </a></li><li id="c198" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae np" href="https://github.com/DawChihLiou/eventbus-demo" rel="noopener ugc nofollow" target="_blank"> GitHub: eventbus-demo </a></li><li id="fe78" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae np" href="https://v3-migration.vuejs.org/breaking-changes/events-api.html" rel="noopener ugc nofollow" target="_blank">文档:Vue 3迁移指南—事件API </a></li><li id="35e6" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated">文档:redux-toolkit的新监听器中间件</li><li id="e2f0" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae np" href="https://remix.run/" rel="noopener ugc nofollow" target="_blank">文档:混音</a></li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="d82b" class="oa kz it nv b gy ob oc l od oe"><strong class="nv iu">Want to Connect?</strong></span><span id="928e" class="oa kz it nv b gy of oc l od oe">This article is originally posted on <a class="ae np" href="https://dawchihliou.github.io/articles/event-bus-for-react" rel="noopener ugc nofollow" target="_blank">Daw-Chih’s website</a>.</span></pre></div></div>    
</body>
</html>