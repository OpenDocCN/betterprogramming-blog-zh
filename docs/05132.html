<html>
<head>
<title>An Easy Way to Create Custom Alerts in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中创建自定义提醒的简单方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-easy-way-to-create-custom-alerts-in-swiftui-8a6b3dda8633?source=collection_archive---------2-----------------------#2020-06-12">https://betterprogramming.pub/an-easy-way-to-create-custom-alerts-in-swiftui-8a6b3dda8633?source=collection_archive---------2-----------------------#2020-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a33e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为您的用户构建和呈现自定义提醒</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0918fc1bf5a58c7d2e1cb6506b456b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*edQ4F7FPTdd0OecauE-z2Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="45c5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在SwiftUI上呈现系统警报非常简单。只需调用一个实例方法<code class="fe lr ls lt lu b">alert</code>并传递几个参数，就大功告成了。但是出现的系统警告对于不可定制的默认设计来说太基本了。这就是为什么拥有您自己的自定义提醒是一个好方法，更适合您的需求和设计。有各种方法可以实现这一点，但在本文中，我将向您介绍我开发的一个很酷的新开源库，名为AlertX，使用它可以以一种超级简单的方式实现自定义警报，就像实现那些默认警报一样。</p><p id="4e92" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇文章中，我将通过几个例子详细解释这个过程，但是如果你想知道它是如何工作的，可以在它的<a class="ae lv" href="https://github.com/neel-makhecha/AlertX" rel="noopener ugc nofollow" target="_blank"> GitHub页面</a>上查看这个库的文档。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="0142" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">安装AlertX</h1><p id="a760" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">AlertX基本上是一个Swift包，可以使用Swift包管理器安装在任何现有的Xcode项目上。因此，如果您使用Xcode 11或更高版本(您肯定会这样做，因为这个库只用于SwiftUI ),您可以从那里安装任何Swift包依赖项。</p><p id="1016" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，让我们首先为iOS创建一个新的SwiftUI Xcode项目(或者您可以继续使用现有的项目)。</p><p id="cd0d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第一步。</strong>在您的Xcode项目中，导航到文件&gt; Swift包&gt;添加包依赖关系。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/26ab3d14490050c1bdbdc116e5378204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4h1qz4DES0cvxPJN06zNaQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">第一步</p></figure><p id="899b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第二步。</strong>在包存储库URL中，输入这个:<a class="ae lv" href="https://github.com/neel-makhecha/AlertX.git" rel="noopener ugc nofollow" target="_blank">https://github.com/neel-makhecha/AlertX.git</a>。(快速提示:您可以快速查看并添加您在GitHub上标记的所有repos列表中的依赖项)，然后单击Next。如果你愿意，你可以制定规则；否则，单击“下一步”，最后确保选中“选择产品和目标包”下的AlertX，然后单击“完成”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/9c18a86f5b5932e1650d07cff4ae5d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E3sI-dx_o67nAUQRRpRUfA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">第二步</p></figure><p id="131b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">成功完成第2步后，您将在Xcode的项目导航器中看到一个新的部分，上面写着“Swift Package Dependencies”，后面是所有已安装的Swift软件包的列表。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="866b" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">开始:展示自定义提醒</h1><p id="04aa" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">使用AlertX显示自定义警报与显示系统原生警报一样简单。只需在您的文件中导入AlertX，您将有一个在每个SwiftUI视图上调用的新方法。</p><h2 id="18e7" class="nb me iq bd mf nc nd dn mj ne nf dp mn le ng nh mp li ni nj mr lm nk nl mt nm bi translated"><strong class="ak">第一步。</strong>设置视图</h2><p id="6f2c" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">(这里我用一个按钮来说明，但是它也适用于其他视图，比如使用<code class="fe lr ls lt lu b">onTapGesture</code>的<code class="fe lr ls lt lu b">Text</code></p><pre class="kg kh ki kj gt nn lu no np aw nq bi"><span id="08fe" class="nb me iq lu b gy nr ns l nt nu">import SwiftUI</span><span id="5332" class="nb me iq lu b gy nv ns l nt nu">import AlertX</span><span id="580f" class="nb me iq lu b gy nv ns l nt nu">struct ContentView: View {</span><span id="e3f6" class="nb me iq lu b gy nv ns l nt nu">      @State var showAlertX: Bool = false</span><span id="b68b" class="nb me iq lu b gy nv ns l nt nu">      var body: some View {</span><span id="c168" class="nb me iq lu b gy nv ns l nt nu">            Button(action: {</span><span id="99de" class="nb me iq lu b gy nv ns l nt nu">                self.showAlertX.toggle()</span><span id="5b94" class="nb me iq lu b gy nv ns l nt nu">             }, label: {</span><span id="d78c" class="nb me iq lu b gy nv ns l nt nu">                Text("Show AlertX")</span><span id="2150" class="nb me iq lu b gy nv ns l nt nu">            })</span><span id="3d89" class="nb me iq lu b gy nv ns l nt nu">      }</span><span id="322d" class="nb me iq lu b gy nv ns l nt nu">}</span></pre><p id="530c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码中，我刚刚导入了AlertX并创建了一个布尔类型的变量<code class="fe lr ls lt lu b">showAlertX</code>，它具有<code class="fe lr ls lt lu b">@State </code>属性包装器，将负责我们的自定义警报的显示。我也有一个按钮，它的动作只是切换<code class="fe lr ls lt lu b">showAlertX</code>的值。我们也可以只写<code class="fe lr ls lt lu b">self.showAlertX = true </code>而不使用toggle，因为我们稍后将把值作为<code class="fe lr ls lt lu b">Binding</code>传递，所以一旦警报解除，它将被库自动更改为<code class="fe lr ls lt lu b">false</code>。</p><h2 id="af66" class="nb me iq bd mf nc nd dn mj ne nf dp mn le ng nh mp li ni nj mr lm nk nl mt nm bi translated">第二步。新方法alertX和相同的旧参数</h2><pre class="kg kh ki kj gt nn lu no np aw nq bi"><span id="b32d" class="nb me iq lu b gy nr ns l nt nu">alertX(isPresented: Binding&lt;Bool&gt;, content: () -&gt; AlertX)</span></pre><p id="f744" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如上面的方法签名所示，<code class="fe lr ls lt lu b">alertX</code>接受两个参数:<code class="fe lr ls lt lu b">Binding&lt;Bool&gt;</code>类型的<code class="fe lr ls lt lu b">isPresented</code>，它将接受<code class="fe lr ls lt lu b">showAlertX</code>属性和一个返回类型为<code class="fe lr ls lt lu b">AlertX</code>的闭包。(该方法与现有方法<code class="fe lr ls lt lu b">alert</code>非常相似。唯一的区别在于第二个参数，即返回类型为<code class="fe lr ls lt lu b">Alert</code>的闭包。)</p><pre class="kg kh ki kj gt nn lu no np aw nq bi"><span id="ec23" class="nb me iq lu b gy nr ns l nt nu">Button(action: {</span><span id="ac37" class="nb me iq lu b gy nv ns l nt nu">      self.showAlertX = true</span><span id="f5cb" class="nb me iq lu b gy nv ns l nt nu">}, label: {</span><span id="dcf7" class="nb me iq lu b gy nv ns l nt nu">      Text("Show AlertX")</span><span id="2f3b" class="nb me iq lu b gy nv ns l nt nu">}).alertX(isPresented: $showAlertX, content: {</span><span id="529d" class="nb me iq lu b gy nv ns l nt nu">      AlertX(title: Text("AlertX Title"))</span><span id="23ba" class="nb me iq lu b gy nv ns l nt nu">})</span></pre><p id="1f03" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:从这里开始，我将只展示相关代码的片段，而不是展示每个示例中的完整代码，以使其更加清晰。</p><p id="6d74" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码片段显示了<code class="fe lr ls lt lu b">alertX</code>的实现，其中我将<code class="fe lr ls lt lu b">showAlertX</code>作为<code class="fe lr ls lt lu b">$showAlertX</code>传递，以访问它的<code class="fe lr ls lt lu b">Binding&lt;Bool&gt;</code>值。</p><p id="1e6c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还传递了一个闭包，其中有一个语句，用一些参数声明AlertX(还不需要<code class="fe lr ls lt lu b">return</code>关键字，因为我们只在一个语句中声明了要返回的对象)。</p><p id="3b1d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事实上就是这样！只需继续运行项目并点击按钮。您现在将看到一种全新类型的警报，就像这样…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/3bcc5c71d3a56a6a11cadf2cd74661f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/1*-zKLwO5r8pG1CJ25vVTYqw.gif"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="a06b" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">按钮和动作</h1><p id="1a0d" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">AlertX的按钮属于<code class="fe lr ls lt lu b">AlertX.Button</code>类型，与<code class="fe lr ls lt lu b">Alert.Button</code>非常相似，用静态方法初始化你想要的按钮类型，即默认或取消，<strong class="kx ir"> </strong>带有<code class="fe lr ls lt lu b">AlertX.Button.default()</code>和<code class="fe lr ls lt lu b">AlertX.Button.cancel()</code>。</p><h2 id="6bb4" class="nb me iq bd mf nc nd dn mj ne nf dp mn le ng nh mp li ni nj mr lm nk nl mt nm bi translated">主要按钮和次要按钮</h2><p id="bdd1" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">您可以使用上述方法创建<code class="fe lr ls lt lu b">AlertX.Button</code>的实例，并将AlertX的初始化器传入名为<code class="fe lr ls lt lu b">primaryButton</code>和<code class="fe lr ls lt lu b">secondaryButton</code>的参数中。这些按钮的外观将基于按钮的类型，即默认或取消(这些按钮类型的外观基于警报的主题，这将在本文的下一个主题中讨论)。</p><p id="7da5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一个说明按钮的示例:</p><pre class="kg kh ki kj gt nn lu no np aw nq bi"><span id="91c5" class="nb me iq lu b gy nr ns l nt nu">AlertX(title: Text("Confirm"),</span><span id="8b74" class="nb me iq lu b gy nv ns l nt nu">       primaryButton: .cancel(),</span><span id="0a79" class="nb me iq lu b gy nv ns l nt nu">       secondaryButton: .default(Text("Okay"), action: {</span><span id="f76a" class="nb me iq lu b gy nv ns l nt nu">               //Execute when okay tapped</span><span id="de30" class="nb me iq lu b gy nv ns l nt nu">       }))</span></pre><h2 id="3ec8" class="nb me iq bd mf nc nd dn mj ne nf dp mn le ng nh mp li ni nj mr lm nk nl mt nm bi translated">添加多个按钮</h2><p id="56a8" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">使用AlertX，您还可以拥有两个以上的按钮。你所要做的就是创建一个包含所有动作的<code class="fe lr ls lt lu b">AlertX.Button</code>数组，并将其传递给AlertX初始化器的<code class="fe lr ls lt lu b">buttonStack</code>参数。这里有一个例子可以说明这一点:</p><pre class="kg kh ki kj gt nn lu no np aw nq bi"><span id="30b2" class="nb me iq lu b gy nr ns l nt nu">let buttons = [</span><span id="bb61" class="nb me iq lu b gy nv ns l nt nu">       AlertX.Button.default(Text("Yes"), action: {</span><span id="7c59" class="nb me iq lu b gy nv ns l nt nu">             //Execute this when Yes tapped</span><span id="cc7f" class="nb me iq lu b gy nv ns l nt nu">       }),</span><span id="eadd" class="nb me iq lu b gy nv ns l nt nu">       AlertX.Button.default(Text("Unsure"), action: {</span><span id="e1a5" class="nb me iq lu b gy nv ns l nt nu">            // Execute this when Unsure tapped</span><span id="6cef" class="nb me iq lu b gy nv ns l nt nu">       }),</span><span id="3f42" class="nb me iq lu b gy nv ns l nt nu">       AlertX.Button.cancel()]</span><span id="6532" class="nb me iq lu b gy nv ns l nt nu">return AlertX(title: Text("Are you sure?"), buttonStack: buttons)</span></pre><p id="5b5b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:当您为<code class="fe lr ls lt lu b">buttonStack</code>传递一个值时，您不能传递<code class="fe lr ls lt lu b">primaryButton</code>和<code class="fe lr ls lt lu b">secondaryButton</code>参数。另外，请注意，现在我们已经在闭包的主体中声明了一个数组，我们必须使用<code class="fe lr ls lt lu b">return</code>关键字。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="afb3" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">自定义外观</h1><p id="7dec" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">几乎所有AlertX组件的外观都可以定制，以更好地适应项目的设计和主题。您可以更改提醒窗口、按钮、按钮上的文本的颜色，以及标题和消息的颜色。此外，还有其他选项来设置圆角以及启用或禁用透明度。通过在AlertX初始化器中传递一个类型为<code class="fe lr ls lt lu b">AlertX.Theme</code>的主题属性，可以应用AlertX中不同的外观。</p><h2 id="e5a4" class="nb me iq bd mf nc nd dn mj ne nf dp mn le ng nh mp li ni nj mr lm nk nl mt nm bi translated">使用预定义的主题</h2><p id="3222" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">类型<code class="fe lr ls lt lu b">AlertX.Theme</code>的实例存储了上面提到的警报外观的所有属性。为了快速应用和开始，有一些预定义的主题可以使用。</p><p id="f162" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不带参数初始化<code class="fe lr ls lt lu b">AlertX.Theme</code>的实例将返回一个默认主题，即graphite。</p><p id="7baf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要获得一个预定义主题的实例，请使用具有各自名称的静态方法。以下是所有预定义主题的列表(也是所有静态方法的名称):</p><pre class="kg kh ki kj gt nn lu no np aw nq bi"><span id="16ad" class="nb me iq lu b gy nr ns l nt nu">graphite (default)<br/>light<br/>dark<br/>sun<br/>cherry<br/>mint<br/>wine</span></pre><p id="4e98" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有静态方法都可以在没有参数的情况下调用。但是对于所有这些方法，您也可以传递两个参数来启用或禁用任何预定义主题的透明度和圆角。以下是您可以使用的方法签名:</p><pre class="kg kh ki kj gt nn lu no np aw nq bi"><span id="397f" class="nb me iq lu b gy nr ns l nt nu">AlertX.Theme.graphite()<br/>AlertX.Theme.graphite(withTransparency: Bool, roundedCorners: Bool)</span></pre><p id="f936" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">调用不带参数的方法将默认启用透明度并禁用圆角。</p><p id="1ccd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个说明主题的简单例子:</p><pre class="kg kh ki kj gt nn lu no np aw nq bi"><span id="6b3e" class="nb me iq lu b gy nr ns l nt nu">Button(action: {</span><span id="dbab" class="nb me iq lu b gy nv ns l nt nu">    self.showAlertX = true</span><span id="49ec" class="nb me iq lu b gy nv ns l nt nu">}, label: {</span><span id="dc31" class="nb me iq lu b gy nv ns l nt nu">    Text("Show AlertX")</span><span id="6c01" class="nb me iq lu b gy nv ns l nt nu">}).alertX(isPresented: $showAlertX, content: {</span><span id="531f" class="nb me iq lu b gy nv ns l nt nu">     AlertX(title: Text("Confirm"), <br/>           primaryButton: .cancel(), <br/>           secondaryButton: .default(Text("Okay")), <br/>           theme: .cherry())</span><span id="8c8f" class="nb me iq lu b gy nv ns l nt nu">})</span></pre><p id="e1fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的例子中，我刚刚使用了一个静态方法<code class="fe lr ls lt lu b">cherry</code>，没有传递任何参数。它看起来会像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/c13ce956dfffefc43ba11c617b61b2e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*oZzKtilCUKAxi6pyCibaqg.png"/></div></figure><pre class="kg kh ki kj gt nn lu no np aw nq bi"><span id="d11d" class="nb me iq lu b gy nr ns l nt nu">AlertX(title: Text("Confirm"), <br/>           primaryButton: .cancel(), <br/>           secondaryButton: .default(Text("Okay")), <br/>           theme: .cherry(withTransparency: true, roundedCorners: true))</span></pre><p id="1de0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是上面的例子在<code class="fe lr ls lt lu b">roundedCorners</code>被启用时的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/56d9de019782e4c1b907353012d0207c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*uFMqgSfqv4jPky2SPY4DZA.png"/></div></figure><h2 id="3f9f" class="nb me iq bd mf nc nd dn mj ne nf dp mn le ng nh mp li ni nj mr lm nk nl mt nm bi translated">创建您的自定义主题</h2><p id="6266" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">类似于预定义的主题，您可以使用名为<code class="fe lr ls lt lu b">custom</code>的静态方法，并传递每个属性的所有值，以拥有您自己的自定义颜色组合和外观。这是它的方法签名:</p><pre class="kg kh ki kj gt nn lu no np aw nq bi"><span id="7576" class="nb me iq lu b gy nr ns l nt nu">AlertX.Theme.custom(windowColor: Color,<br/>                   alertTextColor: Color,<br/>                   enableShadow: Bool,<br/>                   enableRoundedCorners: Bool,<br/>                   enableTransparency: Bool,<br/>                   cancelButtonColor: Color,<br/>                   cancelButtonTextColor: Color,<br/>                   defaultButtonColor: Color,<br/>                   defaultButtonTextColor: Color)</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="bc51" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">自定义动画</h1><p id="ef89" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">动画属于<code class="fe lr ls lt lu b">AlertX.AnimationX</code>类型，它只是<code class="fe lr ls lt lu b">AnyTransition</code>的包装。这意味着在AlertX上应用动画类似于在任何SwiftUI视图上应用动画。</p><h2 id="5492" class="nb me iq bd mf nc nd dn mj ne nf dp mn le ng nh mp li ni nj mr lm nk nl mt nm bi translated">使用预定义的动画</h2><p id="86ae" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">有几个常见的预定义动画，可以像<code class="fe lr ls lt lu b">AlertX.Theme </code>一样，通过调用各自的静态方法直接使用。以下是预定义动画的所有方法列表:</p><pre class="kg kh ki kj gt nn lu no np aw nq bi"><span id="4179" class="nb me iq lu b gy nr ns l nt nu">defaultEffect<br/>classicEffect <br/>zoomEffect<br/>fadeEffect<br/>slideUpEffect</span></pre><p id="13a7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">classicEffect</code>是一种倒退，有点像更老的iOS 6和更早的版本。这里有一个例子:</p><pre class="kg kh ki kj gt nn lu no np aw nq bi"><span id="f4a4" class="nb me iq lu b gy nr ns l nt nu">AlertX(title: Text("How's the classic animation?"), animation: .classicEffect())</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/f6160556f000f52cef8cae0e34fea6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/1*Vo-s9irQTCzaM9hpalWCiA.gif"/></div></figure><h2 id="cb1f" class="nb me iq bd mf nc nd dn mj ne nf dp mn le ng nh mp li ni nj mr lm nk nl mt nm bi translated">创建您的自定义动画</h2><p id="dc59" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">通过传递<code class="fe lr ls lt lu b">AnyTransition</code>，使用下面的静态方法创建一个<code class="fe lr ls lt lu b">AlertX.AnimationX</code>的实例:</p><pre class="kg kh ki kj gt nn lu no np aw nq bi"><span id="c488" class="nb me iq lu b gy nr ns l nt nu">AlertX.AnimationX.custom(withTransition: AnyTransition)</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="35db" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">总结</h1><p id="c65c" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">显示提醒对于几乎所有的应用程序来说都是非常常见的事情，所以如果你喜欢经常使用这个库，可以考虑在GitHub上使用它，这样在为任何新项目安装时，它都可以在Xcode上快速访问。</p><p id="e3f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">AlertX是一个开源库，因此如果您希望做出贡献，请随时提交请求。文档中的“未来工作”中已经提到了一些要点。你可以从那里学到一些东西，或者提出一个全新的想法。</p><p id="7377" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望你喜欢这篇文章，找到你可能正在寻找的问题的答案，或者学到一些新的东西。也请考虑浏览GitHub上的<a class="ae lv" href="https://github.com/neel-makhecha/AlertX" rel="noopener ugc nofollow" target="_blank"> AlertX文档页面</a> (README ),以防本文中没有提到的任何更新。</p></div></div>    
</body>
</html>