<html>
<head>
<title>Goodbye, Target Actions. Hello, UIActions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">再见，目标行动。你好，UIActions</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/goodbye-target-actions-hello-uiactions-a60e1e2052d5?source=collection_archive---------4-----------------------#2020-07-01">https://betterprogramming.pub/goodbye-target-actions-hello-uiactions-a60e1e2052d5?source=collection_archive---------4-----------------------#2020-07-01</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="f141" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">iOS 14引入了一种在UIControls上设置动作的新方法</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/8c622d361084c46dcb9dfe9bed792354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kjebOPY5Lr_QyAFS"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@mantashesthaven?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">曼塔斯·赫斯塔文</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="e06b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">到目前为止，iOS开发人员必须使用目标-动作模式来设置UIKit控件上的动作。自从选择器在Objective-C中诞生以来，这并不是一种设置动作的快捷方式。</p><p id="f909" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在iOS 13之前，对于大多数<code class="fe lw lx ly lz b">UIControls</code>，你必须<code class="fe lw lx ly lz b">addTarget</code>，设置一个选择器函数名，并在代码中的其他地方定义该函数。这不仅乏味，而且在处理多个按钮或分段控件时，还需要为选择器设置默认动作。如果修改了<code class="fe lw lx ly lz b">UIButton</code>或<code class="fe lw lx ly lz b">UISegmentedControl</code>元素，这可能会带来问题，因为我们必须处理选择器处理函数，并确保有一个<code class="fe lw lx ly lz b">default</code>案例。</p><p id="4bab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">iOS 14通过提供初始化器来设置<code class="fe lw lx ly lz b">UIAction</code>，改变了我们在一些UI元素上设置动作的方式。这样做，我们可以摆脱事件处理程序，因为<code class="fe lw lx ly lz b">UIAction</code>的处理程序会自动处理它。</p><p id="497d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以，是时候告别iOS 13和更老的设定目标行动的方式了:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="8ffa" class="me mf iu lz b gz mg mh l mi mj">button.addTarget(self, action: #selector(test(sender:)), for: .touchUpInside)</span><span id="901e" class="me mf iu lz b gz mk mh l mi mj">@objc<br/>func test(sender: UIButton){...}</span></pre><p id="02b1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看看在按钮和分段控件上设置<code class="fe lw lx ly lz b">UIAction</code>的新方法，以及如何用<code class="fe lw lx ly lz b">UIAction</code>设置控件事件。</p></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h1 id="45d5" class="ms mf iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">iOS 14新的UIAction初始化器</h1><p id="98ff" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">从<code class="fe lw lx ly lz b">DatePicker</code>到<code class="fe lw lx ly lz b">ColorPicker</code>和<code class="fe lw lx ly lz b">UIBarButtonItems</code>的所有UI控件都可以用iOS 14中的一个<code class="fe lw lx ly lz b">UIAction</code>初始化。</p><p id="ced7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">UIButton</code>现在提供了<code class="fe lw lx ly lz b">primaryAction</code>作为其初始化器中的附加参数，这让我们可以设置按钮<code class="fe lw lx ly lz b">title</code>、<code class="fe lw lx ly lz b">image</code>、<code class="fe lw lx ly lz b">state</code>、<code class="fe lw lx ly lz b">identifier</code>和动作处理程序。下面的<code class="fe lw lx ly lz b">UIButton</code>中的<code class="fe lw lx ly lz b">UIAction</code>初始化器显示了基本设置:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj no"><img src="../Images/0d33be65cf39a439b65d16adee60fa45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UcGt-WfMm0HbZPvrUBTlTw.png"/></div></div></figure><p id="8207" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">UISegmentedControl</code>引入了一个<code class="fe lw lx ly lz b">actions</code>参数，让您设置一个<code class="fe lw lx ly lz b">UIActions</code>数组——每个项目一个:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="np nq l"/></div></figure></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h1 id="63e4" class="ms mf iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">使用addActions为控件事件设置UIActions</h1><p id="1a4c" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">关于<code class="fe lw lx ly lz b">UIAction</code>需要注意的重要一点是它继承自<code class="fe lw lx ly lz b">UIMenuElement</code>类。</p><p id="8870" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">值得注意的是，<code class="fe lw lx ly lz b">UIAction</code>状态不是<code class="fe lw lx ly lz b">UIControl</code>事件，它是为在<code class="fe lw lx ly lz b">UIControls</code>设置<code class="fe lw lx ly lz b">UIMenus</code>而设计的。</p><p id="c4b7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">既然我们真的不能在<code class="fe lw lx ly lz b">UIControl</code>初始化器中设置控制事件，那么如何为特定的控制事件设置<code class="fe lw lx ly lz b">UIAction</code>？</p><p id="95fd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">幸运的是，我们还有一个<code class="fe lw lx ly lz b">addAction</code>方法，可以让您基于控制事件设置<code class="fe lw lx ly lz b">UIAction</code>处理程序:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="c4c7" class="me mf iu lz b gz mg mh l mi mj">button.<strong class="lz iv">addAction</strong>(UIAction(title: "Click Me", handler: { _ in  print("Hi")}), <strong class="lz iv">for: .menuActionTriggered)</strong></span></pre><p id="0bbe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">menuActionTriggered</code>是iOS 14的<code class="fe lw lx ly lz b">UIButton</code>中新增的控制事件。当按下<code class="fe lw lx ly lz b">UIButton</code>键显示菜单时，它被调用。</p></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h1 id="3bf4" class="ms mf iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">将UIAction与UITextField一起使用</h1><p id="a446" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">对于一个<code class="fe lw lx ly lz b">UITextField</code>控件，我们想要监听像<code class="fe lw lx ly lz b">editingDidBegin</code>这样的事件，在初始化器中设置一个<code class="fe lw lx ly lz b">primaryAction</code>没有帮助，我们必须利用<code class="fe lw lx ly lz b">addAction</code>方法来监听特定的控件事件:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj no"><img src="../Images/c65aa0e3cad2037251b176847a8a43d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uUM21r603LZQAsc9CeJE2w.png"/></div></div></figure><p id="6ca8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以遵循相同的方法为不同的控制事件设置动作。</p></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h1 id="bf14" class="ms mf iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">结束语</h1><p id="b547" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">记住，<code class="fe lw lx ly lz b">UIAction</code>对于在所有<code class="fe lw lx ly lz b">UIControl</code>初始化器上设置主要动作是有用的。但是如果你想为特定的<code class="fe lw lx ly lz b">UIControl</code>事件设置动作，实现<code class="fe lw lx ly lz b">addAction</code>方法是一条可行之路。</p><p id="b8ac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">UIAction</code>基本上是在iOS 13的上下文菜单中用来设置菜单动作的。考虑到已经暴露了太多与菜单相关的初始化器，将它暴露给<code class="fe lw lx ly lz b">UIControls</code>用于tap和其他事件是一个值得讨论的设计。无论如何，对于Swift开发人员来说，脱离目标-行动模式是一个好的举措和急需的改变。</p><p id="291d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在实现<code class="fe lw lx ly lz b">UIAction</code>处理程序时，您需要警惕闭包中可能出现的保留周期。</p><p id="e9fe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">除了<code class="fe lw lx ly lz b">UIAction</code>，从iOS 14开始的UIKit中<code class="fe lw lx ly lz b">UIMenu</code>也暴露给了所有<code class="fe lw lx ly lz b">UIControls</code>。我们将在下一篇文章中看到如何做到这一点以及<code class="fe lw lx ly lz b">UIMenu</code>中的其他变化。敬请关注，感谢阅读。</p></div></div>    
</body>
</html>