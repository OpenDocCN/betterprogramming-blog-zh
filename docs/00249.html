<html>
<head>
<title>Clock-In/Out System Part 5: Seed Database and Migration Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">上下班打卡系统第5部分:种子数据库和迁移数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/part-5-clock-in-out-system-seed-database-and-migration-data-cf037be21aac?source=collection_archive---------0-----------------------#2018-12-21">https://betterprogramming.pub/part-5-clock-in-out-system-seed-database-and-migration-data-cf037be21aac?source=collection_archive---------0-----------------------#2018-12-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6f7a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">NestJS + Angular教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/27028d592125269574905771e8218205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*KhCkmbtORw2Ux3n5WCrtzA.png"/></div></figure><p id="dfb8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这篇文章是我描述上下班打卡系统的系列文章的一部分。如果你想了解更多，你可以阅读以下内容:</p><ul class=""><li id="3e7e" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-1-clock-in-out-system-diagram-a0a51bab02a7?source=post_page---------------------------" rel="noopener">上下班打卡系统第1部分:图</a></li><li id="9369" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-2-clock-in-out-system-basic-backend-i-authmodule-66d4a5c56122?source=post_page---------------------------" rel="noopener">上下班打卡系统第二部分:基础后端— AuthModule </a></li><li id="08c2" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-3-clock-in-out-system-basic-backend-ii-usersmodule-a56f42b20f62?source=post_page---------------------------" rel="noopener">上下班打卡系统第3部分:基本后端——用户模块</a></li><li id="42b6" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-4-clock-in-out-system-basic-backend-iii-appmodule-850dd17883e?source=post_page---------------------------" rel="noopener">上下班打卡系统第4部分:基础后端— AppModule </a></li><li id="8610" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-5-clock-in-out-system-seed-database-and-migration-data-cf037be21aac?source=post_page---------------------------" rel="noopener">上下班打卡系统第5部分:种子数据库和迁移数据</a></li><li id="cca0" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-6-clock-in-out-system-basic-frontend-an-7e5f9ed08c3f?source=post_page---------------------------" rel="noopener">上下班打卡系统第6部分:基本前端</a></li><li id="c462" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-7-deploy-backend-nestjs-docker-docker-compose-2429c0b6aa9c?source=post_page---------------------------" rel="noopener">上下班打卡系统第7部分:使用Docker/Docker-Compose部署后端(NestJS)</a></li><li id="c216" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-8-clock-in-out-system-deploy-frontend-angular-6-using-environments-ad267325d3b6?source=post_page---------------------------" rel="noopener">上下班打卡系统第8部分:使用环境部署前端(角度6+)</a></li><li id="6d2c" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-9-testing-backend-testing-2d021f48403b?source=post_page---------------------------" rel="noopener">上下班打卡系统第9部分:后端测试——服务的单元测试</a></li><li id="6e53" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-10-testing-backend-testing-unit-testing-controllers-4177370ef581?source=post_page---------------------------" rel="noopener">上下班打卡系统第10部分:后端测试——控制器单元测试</a></li><li id="3eec" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第11部分:后端测试-e2e测试</li><li id="e816" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第12部分:前端测试单元测试</li><li id="3ad5" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第13部分:前端测试集成测试</li></ul><p id="b9f2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在之前的文章中，我描述了打卡系统后端的开发，但是没有数据证明我们的后端已经开发成功。</p><p id="b69f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这篇文章中，我将描述我如何创建一系列脚本(<a class="ae lv" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>)，这些脚本允许从客户从他们的旧软件(MS Excel)提供的<a class="ae lv" href="https://office.live.com/start/Excel.aspx" rel="noopener ugc nofollow" target="_blank"> Excel </a>表中填充数据库。</p><p id="12cb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第一步是在<code class="fe mc md me mf b">package.json</code> <em class="mb"> </em>中添加一个<a class="ae lv" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>脚本<em class="mb"> </em>，允许在<a class="ae lv" href="http://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>中执行我们的脚本，使用<a class="ae lv" href="https://www.npmjs.com/ts-node" rel="noopener ugc nofollow" target="_blank"> ts-node </a> <em class="mb">。</em></p><p id="2750" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们脚本的执行会执行命令<code class="fe mc md me mf b">npm run init:db</code> <em class="mb">。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mg"><img src="../Images/e6c70a998ada2efee669af138ae1d075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qO5mLnit_30iTVhvPNU6g.png"/></div></div></figure><p id="6651" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">脚本<code class="fe mc md me mf b">create-data-fixture</code>是一个自执行函数，它基于<code class="fe mc md me mf b">DatabaseTest</code>创建一个新对象，并调用方法<code class="fe mc md me mf b">db.reload()</code>。</p><p id="abf6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用两个参数创建函数<code class="fe mc md me mf b">DatabaseTest</code> <em class="mb"> </em>:</p><ul class=""><li id="a62b" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated">用于存储数据的数据库连接，如果我们想要使用不同的数据库，那么每次执行的数据都是不同的。当我们想要并行运行不同的数据库，用模拟数据运行e2e(端到端)测试时，这个事实很有趣。</li><li id="4eac" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe mc md me mf b"><strong class="ks iu">DataFixture</strong></code>，它是一个对象，包含将要插入数据库的信息(<code class="fe mc md me mf b">Users</code>和<code class="fe mc md me mf b">Users-schedule</code>)。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ml"><img src="../Images/1d3d7993d1a733e9190de575377f2bb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w6w75taONOpzCJbJpABqnA.png"/></div></div></figure><p id="9d52" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最简单的文件是<code class="fe mc md me mf b">TestFixture</code>，一旦数据从数据映射脚本(也将由我们开发)的XLS文件导入和加载，它就导出数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mm"><img src="../Images/861082508e44458078bfd45113ed0410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KtcvXxjyuYhY4cbdWH5QZw.png"/></div></div></figure><p id="34a3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">另一方面，<code class="fe mc md me mf b">database.test.ts</code>文件负责将假数据加载到数据库中。即<code class="fe mc md me mf b">Users</code>和<code class="fe mc md me mf b">UsersSchedule</code>将从<code class="fe mc md me mf b">test.fixture</code>文件中取出。</p><p id="4421" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们将描述这个文件，因为它非常重要:</p><ul class=""><li id="8962" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><code class="fe mc md me mf b">DatabaseTest</code>类接收数据库连接和使用DI(依赖注入)从<code class="fe mc md me mf b">test.fixture</code>文件模拟的数据。</li><li id="515f" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">初始化<code class="fe mc md me mf b">modelsCharged</code>属性，它存储已经加载到数据库中的模型，并且不需要重新加载它们。</li><li id="080d" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe mc md me mf b">createConnectionDB</code>方法是静态的，用于从类外部连接到数据库。这样，当注入类时，连接就已经成功建立了。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mn"><img src="../Images/0c7a7a69e3f0a83a895fe8debbee536e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OkUgICbYJkkKDiW-zKhS6A.png"/></div></div></figure><p id="4561" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下一步是构建初始化、重新加载和同步数据库的基本方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mo"><img src="../Images/c16ead77ce66f9f6fa6abf1794bdf0d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jC9ECyDPMv4rEZkwJKMv5g.png"/></div></div></figure><p id="191c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">接下来，模型被加载，它被递归地一个接一个地执行，获取不同模型之间的现有依赖关系的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mp"><img src="../Images/5ac0c8ea0ac18411397ca4a325b0da5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YFOd2aNy9rdm4GUNZXfIsQ.png"/></div></div></figure><p id="9532" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">概括一下，完整的<code class="fe mc md me mf b">database.test</code>文件如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mq"><img src="../Images/46bcf3979378c8e6fd9acc3c26c2593a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3uG0YiznrZXRi73XgXMAGg.png"/></div></div></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="0a61" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">奖金</h1><p id="6ba2" class="pw-post-body-paragraph kq kr it ks b kt nq ju kv kw nr jx ky kz ns lb lc ld nt lf lg lh nu lj lk ll im bi translated">接下来，我们将展示<code class="fe mc md me mf b">XLSToJson</code>方法，它简单地将Excel的每一行转换成需要由<a class="ae lv" href="https://typeorm.io/" rel="noopener ugc nofollow" target="_blank"> TypeORM </a>导入的不同的<a class="ae lv" href="https://www.json.org/" rel="noopener ugc nofollow" target="_blank"> JSON </a>对象。</p><p id="4caf" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">值得注意的是，每个开发者都必须从他们的XLS中改编<code class="fe mc md me mf b">XLSToJson</code>函数。</p><p id="9469" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，我们需要安装<code class="fe mc md me mf b">node-xlsx</code> <strong class="ks iu"> </strong>包，它允许我们与XLS文件进行交互。下面是第一个版本，它使用了几个<code class="fe mc md me mf b">forEach</code> <strong class="ks iu"> </strong>循环来遍历并构建类似于下面的数据结构:[schedulers，users]，其中<code class="fe mc md me mf b">scheduler</code>是以下类型的对象:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nv"><img src="../Images/e3cefa41fb26e11ef82b0a68c0baed39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1rInbpm0n3Irp41KNMuXGg.png"/></div></div></figure><p id="8249" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">并且<code class="fe mc md me mf b">user</code>是以下类型的对象:</p><pre class="kj kk kl km gt nw mf nx ny aw nz bi"><span id="2490" class="oa mz it mf b gy ob oc l od oe">{ uid: string, name: string, }</span></pre><p id="1915" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我不认为下面的代码是最干净的版本，它不是最干净的版本，我计划在系统完成后，在未来的作品中进行很好的重构。</p><p id="9432" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果有人想开始这项任务，提出以下几点:</p><ol class=""><li id="faf6" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll of ls lt lu bi translated">根据执行的任务提取函数，而不是一个大的、单一的函数。</li><li id="d399" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll of ls lt lu bi translated">用更实用、更合适的方法替换隐藏经典数据结构的<code class="fe mc md me mf b">forEach</code>方法，比如<code class="fe mc md me mf b">reduce</code>。</li></ol><p id="8c40" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe mc md me mf b">migration.ts</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi og"><img src="../Images/8e5d6f11cdeb7df9492209aa9bc3effb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0HhII86DZiJuAzYY89R9nA.png"/></div></div></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="3be7" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">结论</h1><p id="0a7d" class="pw-post-body-paragraph kq kr it ks b kt nq ju kv kw nr jx ky kz ns lb lc ld nt lf lg lh nu lj lk ll im bi translated">在本文中，我解释了我的种子数据库，它由一系列脚本组成，允许我将任何数据结构加载到数据库中。</p><p id="bcee" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了从Excel导入，创建了一个特定的脚本，将XLS文件转换成JSON。</p><p id="b54a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">GitHub项目是<a class="ae lv" href="https://github.com/Caballerog/clock-in-out" rel="noopener ugc nofollow" target="_blank">https://github.com/Caballerog/clock-in-out</a>。</p><p id="0846" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这一块的GitHub分支是<a class="ae lv" href="https://github.com/Caballerog/clock-in-out/tree/part5-seed-database" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Caballerog/clock-in-out/tree/part 5-seed-database</a></p></div></div>    
</body>
</html>