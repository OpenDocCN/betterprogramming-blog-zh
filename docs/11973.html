<html>
<head>
<title>5 Major Features of Node.js 18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js 18的5大特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-major-features-of-node-js-18-5f4a164cc9fc?source=collection_archive---------2-----------------------#2022-05-02">https://betterprogramming.pub/5-major-features-of-node-js-18-5f4a164cc9fc?source=collection_archive---------2-----------------------#2022-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2ca2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Node.js 18新特性的详细信息，包括实验性的fetch API和test runner，以及V8 JavaScript engine 10.1特性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fb5896fb2005f21ca18b91045c4033c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KAcf85sA-2gx_LQ7"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯西·霍纳在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="91c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Node.js主版本每六个月更新一次。新版本变成了为期六个月的<code class="fe lv lw lx ly b">Current</code>版本，这给了库作者时间来添加对他们的支持。</p><p id="8ddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">六个月后，奇数版本(如17)变得不受支持，偶数版本(如16)转移到<code class="fe lv lw lx ly b">Active LTS</code>(长期支持)状态，并准备好供一般使用。<code class="fe lv lw lx ly b">LTS</code>发布通常保证关键缺陷将在总共30个月内得到修复。生产应用程序应该只使用<code class="fe lv lw lx ly b">Active LTS</code>或<code class="fe lv lw lx ly b">Maintenance LTS</code>版本。</p><p id="f357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://nodejs.org/en/blog/release/v18.0.0/" rel="noopener ugc nofollow" target="_blank"> Node.js 18 </a>发布于2022年4月19日。它变成了<code class="fe lv lw lx ly b">Current</code>版本。它有5个主要特点:</p><ul class=""><li id="dcee" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">实验提取API</li><li id="8fc0" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">Web流API</li><li id="7774" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">HTTP超时</li><li id="7dc4" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">实验测试转轮</li><li id="c995" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">V8 JavaScript引擎已更新至V8 10.1</li></ul><p id="3952" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来探索它们是什么以及如何使用它们。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f47e" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">使用NVM浏览节点</h1><p id="def7" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-nvm-to-manage-node-js-17-and-npm-8-2da8bf3ca5e9">之前的一篇文章</a>中，我们提供了关于使用<a class="ae ky" href="https://github.com/nvm-sh/nvm" rel="noopener ugc nofollow" target="_blank"> NVM(节点版本管理器)</a>管理Node.js和NPM版本的说明。</p><p id="6063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行命令安装节点18.0.0:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="02e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在任何窗口上，运行命令以使用节点18:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="aa33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们准备探索:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="3d4c" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">实验提取API</h1><p id="3d34" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">fetch API启动从网络获取资源的过程，返回一个承诺，一旦响应可用，该承诺就被实现。</p><p id="e7bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是获取语法:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="4c07" class="nx mv it ly b gy ny nz l oa ob">function fetch(input: RequestInfo, init?: RequestInit): Promise&lt;Response&gt;</span></pre><p id="5c81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">input</code>是URL字符串或请求对象。<code class="fe lv lw lx ly b">init</code>为可选参数，是包含<code class="fe lv lw lx ly b">method</code>、<code class="fe lv lw lx ly b">headers</code>、<code class="fe lv lw lx ly b">body</code>、<code class="fe lv lw lx ly b">mode</code>、<code class="fe lv lw lx ly b">credentials</code>、<code class="fe lv lw lx ly b">cache</code>、<code class="fe lv lw lx ly b">redirect</code>、<code class="fe lv lw lx ly b">referrer</code>、<code class="fe lv lw lx ly b">referrerPolicy</code>、<code class="fe lv lw lx ly b">integrity</code>、<code class="fe lv lw lx ly b">keepalive</code>、<code class="fe lv lw lx ly b">signal</code>自定义设置的对象。</p><p id="4936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子，<code class="fe lv lw lx ly b">fetchExample.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="62a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第2行，<code class="fe lv lw lx ly b">fetch</code>被调用到<code class="fe lv lw lx ly b">https://catfact.ninja/fact</code>，它获得随机的cat事实。</p><p id="a6dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">fetch</code>仅在遇到网络错误时拒绝。它不拒绝HTTP错误。因此，响应需要检查<code class="fe lv lw lx ly b">response.ok</code>以了解获取是否成功。如果失败，<code class="fe lv lw lx ly b">response.status</code>和<code class="fe lv lw lx ly b">response.statusText</code>提供更多信息(第7行)。</p><p id="3a54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果成功，初始的<code class="fe lv lw lx ly b">fetch</code>调用仅检索以下信息，包括<code class="fe lv lw lx ly b">headers</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b6b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要获得主体消息，必须从传入流中读取主体数据，并将其解析为JSON(第4行<code class="fe lv lw lx ly b">fetchExample.js</code>)。因为从TCP流中读取是异步的，所以<code class="fe lv lw lx ly b">.json()</code>操作也以异步结束。</p><p id="8a75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">fetch API从2015年就开始提供了，除了Internet Explorer，所有主流浏览器都支持它。但是Node.js 17及更低版本不支持<code class="fe lv lw lx ly b">fetch</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c62a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，Node.js 18中添加了这种支持，尽管这是一个实验性的特性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d22c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Node.js 18中，fetch API基于<a class="ae ky" href="https://undici.nodejs.org/#/" rel="noopener ugc nofollow" target="_blank"> undici </a>，这是一个HTTP/1.1客户端，为Node.js从头开始编写。</p><p id="fcc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以使用<code class="fe lv lw lx ly b">--no-experimental-fetch</code>命令行标志禁用获取API。</p><p id="4355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe lv lw lx ly b">fetch</code>，这些类型<code class="fe lv lw lx ly b">FormData</code>、<code class="fe lv lw lx ly b">Headers</code>、<code class="fe lv lw lx ly b">Request</code>和<code class="fe lv lw lx ly b">Response</code>也被全局化。全局对象是内置对象，是JavaScript语言本身的一部分，可以全局访问。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="8d98" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">Web流API</h1><p id="efe9" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">以前，我们必须下载视频、图像或任何其他资源的整个文件，等待它被反序列化为合适的格式，然后在完全接收后处理整个文件。</p><p id="732d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Streams_API" rel="noopener ugc nofollow" target="_blank"> Web Streams API </a>，我们现在可以开始以编程方式访问通过网络接收的数据流，并按块处理它们，而不需要生成缓冲区、字符串或blob。此外，我们可以检测流何时开始或结束，将流链接在一起，根据需要处理错误和取消流，并对流的读取速度做出反应。</p><p id="f281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Node.js 18展示了Web Streams API在全局范围内的实验性实现。</p><p id="6400" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个<code class="fe lv lw lx ly b">ReadableStream</code>和<code class="fe lv lw lx ly b">ReadableStreamDefaultController</code>的例子。<code class="fe lv lw lx ly b">ReadableStream</code>代表可读的数据流，<code class="fe lv lw lx ly b">ReadableStreamDefaultController</code>是<code class="fe lv lw lx ly b">ReadableStream</code>的状态和内部队列的控制器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第2行，<code class="fe lv lw lx ly b">fetch</code>被调用到<code class="fe lv lw lx ly b">https://catfact.ninja/fact</code>，它获得随机的cat事实。</p><p id="6aa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第4行，控制台日志显示<code class="fe lv lw lx ly b">response.body</code>是一个<code class="fe lv lw lx ly b">ReadableStream</code>。</p><p id="8ccb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从可读流中获取一个读取器(第9行)，并返回一个新的可读流，该流对原始流进行处理(第17–65行)。要创建一个<code class="fe lv lw lx ly b">ReadableStream</code>，需要设置三个可选的回调函数，<code class="fe lv lw lx ly b">start</code>、<code class="fe lv lw lx ly b">cancel</code>和<code class="fe lv lw lx ly b">pull</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8aac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的可读流实现了<code class="fe lv lw lx ly b">start</code>回调(第18–64行)，它接收一个类型为<code class="fe lv lw lx ly b">ReadableStreamDefaultController</code>的<code class="fe lv lw lx ly b">controller</code>(第18行)。控制器可以将数据放入队列(第40行)并关闭可读流(第35行)。这个代码片段不改变任何数据，除了记录<code class="fe lv lw lx ly b">done</code>状态和块值(第43行)，以及最终的<code class="fe lv lw lx ly b">done</code>状态(第33行)。</p><p id="9854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第67行接收到流之后，它用流内容创建一个<code class="fe lv lw lx ly b">Response</code>(第72–74行)。</p><p id="1f7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">收到第76行的响应文本后，它会在控制台上记录消息。</p><p id="612b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个代码片段展示了一个简单的流处理。然而，Web Streams API支持许多高级的流处理。</p><p id="9150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Node.js 18使以下流API全球可用:</p><ul class=""><li id="c078" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">ReadableStream</code></li><li id="5f09" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">ReadableStreamDefaultReader</code></li><li id="4fc4" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">ReadableStreamBYOBReader</code></li><li id="2300" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">ReadableStreamBYOBRequest</code></li><li id="5d56" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">ReadableByteStreamController</code></li><li id="15ae" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">ReadableStreamDefaultController</code></li><li id="e01f" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">TransformStream</code></li><li id="d386" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">TransformStreamDefaultController</code></li><li id="bf34" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">WritableStream</code></li><li id="b0b5" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">WritableStreamDefaultWriter</code></li><li id="53a5" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">WritableStreamDefaultController</code></li><li id="c30b" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">ByteLengthQueuingStrategy</code></li><li id="04aa" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">CountQueuingStrategy</code></li><li id="3cc7" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">TextEncoderStream</code></li><li id="d022" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">TextDecoderStream</code></li><li id="a56c" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">CompressionStream</code></li><li id="68a1" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">DecompressionStream</code></li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="9389" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">HTTP超时</h1><p id="dc14" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe lv lw lx ly b">server.headersTimeout</code>限制解析器等待从客户端接收完整HTTP头的时间(毫秒)。</p><p id="7cfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">server.requestTimeout</code>设置从客户端接收整个请求的超时值(毫秒)。</p><p id="a98d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这些超时过期，服务器以状态408响应，而不将请求转发给请求监听器，然后关闭连接。</p><p id="be78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是在<a class="ae ky" href="https://javascript.plainenglish.io/a-hands-on-guide-for-creating-a-production-ready-react-app-864ad98e7497" rel="noopener ugc nofollow" target="_blank">创建生产就绪型React应用的实践指南</a>中使用和描述的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="70c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们添加第15行来显示<code class="fe lv lw lx ly b">server.headersTimeout</code>的值。</p><p id="1ea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还添加了第16行来显示<code class="fe lv lw lx ly b">server.requestTimeout</code>的值。</p><p id="241a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于node.js 17，<code class="fe lv lw lx ly b">server.headersTimeout</code>默认设置为<code class="fe lv lw lx ly b">60000</code> (1分钟)，<code class="fe lv lw lx ly b">server.requestTimeout</code>默认设置为<code class="fe lv lw lx ly b">0</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a420" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于node.js 18，<code class="fe lv lw lx ly b">server.headersTimeout</code>默认还是<code class="fe lv lw lx ly b">60000</code> (1分钟)，默认<code class="fe lv lw lx ly b">server.requestTimeout</code>设置为<code class="fe lv lw lx ly b">300000</code> (5分钟)。</p><p id="b63e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从node.js 18开始，两个超时都必须设置为非零值，以防止在部署服务器时前面没有反向代理的情况下出现潜在的拒绝服务攻击。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2eeb" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">实验测试转轮</h1><p id="a4a6" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">测试跑步者模块仍然是实验性的。我们可以导入<code class="fe lv lw lx ly b">node:test</code>模块来编写单元测试，并以<a class="ae ky" href="https://testanything.org/" rel="noopener ugc nofollow" target="_blank"> Test Anything Protocol (TAP)格式</a>报告结果。我们展示几个例子来看看它是如何工作的。在某种程度上，它类似于JavaScript测试框架Jest。</p><h2 id="0958" class="nx mv it bd mw oc od dn na oe of dp ne li og oh ng lm oi oj ni lq ok ol nk om bi translated">两个同步测试</h2><p id="558b" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">以下是两个同步测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="34af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一次测试通过是因为<code class="fe lv lw lx ly b">1 = 1</code>。第二次试验失败是因为<code class="fe lv lw lx ly b">1 ≠ 2</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="e4a3" class="nx mv it bd mw oc od dn na oe of dp ne li og oh ng lm oi oj ni lq ok ol nk om bi translated">两个异步测试</h2><p id="a783" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">以下是两个异步测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一次测试通过是因为<code class="fe lv lw lx ly b">1 = 1</code>。第二次试验失败是因为<code class="fe lv lw lx ly b">1 ≠ 2</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="94e9" class="nx mv it bd mw oc od dn na oe of dp ne li og oh ng lm oi oj ni lq ok ol nk om bi translated">两个异步测试作为两个子测试</h2><p id="e811" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">对于<code class="fe lv lw lx ly b">test()</code>方法，我们可以添加子测试。我们将它们写成两个子测试，而不是两个异步测试。<code class="fe lv lw lx ly b">await</code>用于确保两个子测试都已完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b3c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="11d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，测试结果显示有1个测试(第33行)，它失败了(第35行)。这是因为任何子测试失败都会导致父测试失败。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="7c24" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">V8 JavaScript引擎已更新至V8 10.1</h1><p id="db00" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">V8 10.1中有许多新功能。除了改进类字段和私有类方法的性能之外，还有以下三个新特性:</p><ul class=""><li id="50ca" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">findLast</code>和<code class="fe lv lw lx ly b">findLastIndex</code>数组方法</li><li id="bcd1" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">对<code class="fe lv lw lx ly b">Intl.Locale</code> API的改进</li><li id="cfb4" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">Intl.supportedValuesOf</code>功能</li></ul><h2 id="a3a0" class="nx mv it bd mw oc od dn na oe of dp ne li og oh ng lm oi oj ni lq ok ol nk om bi translated">findLast和findLastIndex数组方法</h2><p id="1da5" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">数组有查找满足某个条件的元素的方法。除了现有的从头查找元素或索引的方法外，还增加了从末尾查找元素或索引的<code class="fe lv lw lx ly b">findLast</code>和<code class="fe lv lw lx ly b">findLastIndex</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="3451" class="nx mv it bd mw oc od dn na oe of dp ne li og oh ng lm oi oj ni lq ok ol nk om bi translated">对Intl的改进。区域设置API</h2><p id="be4f" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">对于<code class="fe lv lw lx ly b">Intl.Locale</code> API，对象中增加了七个新属性:<code class="fe lv lw lx ly b">calendars</code>、<code class="fe lv lw lx ly b">collations</code>、<code class="fe lv lw lx ly b">hourCycles</code>、<code class="fe lv lw lx ly b">numberingSystems</code>、<code class="fe lv lw lx ly b">timeZones</code>、<code class="fe lv lw lx ly b">textInfo</code>和<code class="fe lv lw lx ly b">weekInfo</code>。</p><p id="79a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个地区的例子，<code class="fe lv lw lx ly b">en-us</code>(美国英语):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5b0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是另一个地区的例子，<code class="fe lv lw lx ly b">zh-cn</code>(中国的中文):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="bf63" class="nx mv it bd mw oc od dn na oe of dp ne li og oh ng lm oi oj ni lq ok ol nk om bi translated">函数的Intl.supportedValuesOf</h2><p id="952a" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">添加了一个新函数<code class="fe lv lw lx ly b">Intl.supportedValuesOf(code)</code>，为Intl APIs返回V8中支持的标识符数组。<code class="fe lv lw lx ly b">code</code>参数可以是<code class="fe lv lw lx ly b">calendar</code>、<code class="fe lv lw lx ly b">collation</code>、<code class="fe lv lw lx ly b">currency</code>、<code class="fe lv lw lx ly b">numberingSystem</code>、<code class="fe lv lw lx ly b">timeZone</code>或<code class="fe lv lw lx ly b">unit</code>。</p><p id="e882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码显示了支持的标识符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="8b6b" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="98b2" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Node.js 18有许多新特性和改进。在node.js 19发布之前都是<code class="fe lv lw lx ly b">Current</code>版本。</p><p id="c630" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想了解其他版本的特性，请阅读以下文章:</p><ul class=""><li id="c2dc" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/6-major-features-of-node-js-19-b98e28b9670c">node . js 19的6大特色</a></li><li id="23aa" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/3-major-features-of-node-js-17-4bee7135df02">node . js 17的3大特色</a></li><li id="8399" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/a-quick-look-at-the-node-js-16-features-d616e8b2f29">快速浏览Node.js 16特性</a></li><li id="2d50" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/whats-new-in-node-js-15-fc24e87e2590">node . js 15新增功能</a></li></ul><p id="8471" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="cfcc" class="nx mv it ly b gy ny nz l oa ob"><strong class="ly iu">Want to Connect?</strong></span><span id="42a8" class="nx mv it ly b gy on nz l oa ob">If you are interested, check out <a class="ae ky" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener">my directory of web development articles</a>.</span></pre></div></div>    
</body>
</html>