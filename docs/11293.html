<html>
<head>
<title>Chaining Animations With Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jetpack合成链接动画</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/chaining-animations-with-jetpack-compose-b4ff6e2e047d?source=collection_archive---------7-----------------------#2022-03-07">https://betterprogramming.pub/chaining-animations-with-jetpack-compose-b4ff6e2e047d?source=collection_archive---------7-----------------------#2022-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d457" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何运行顺序和并行动画</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e7e8dc9a8610783bff3d30a940e99b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RAlldDgYzefOOJse"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@messrro?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈赫迪·梅瑟罗</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e57b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当涉及到单独运行动画时，谷歌提供了全面的文档。当谈到链接几个动画时——不管它们是连续的还是并行的——我一直在努力寻找合适的资源。</p><p id="7ff3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">直到我偶然看到这个视频，它准确地总结了我一直在寻找的东西:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="9ac5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个视频解释了如何利用协程来链接你的动画。这是我完成洗牌动画所缺少的部分。我会制作两张卡片的动画，它们会来回平移，同时缩小比例，直到它们都达到中间点。</p><p id="458d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自己看看最后的效果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lu"><img src="../Images/655d1b100849a756bc1a06832554a449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jEgBV0GUz7T0tGuZ-PWLnw.gif"/></div></div></figure><p id="80c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看实现这种无序播放效果的不同动画。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="5da8" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">洗牌效应</h1><p id="def6" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">如果你仔细看动画，我们可以把它分成一组动画。实际上有3组动画，有时包含一组动画:</p><ol class=""><li id="92cf" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">开篇:从1%小幅下调至0.9%</li><li id="a7aa" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">核心:三个持续时间相同的平行动画，比例缓慢下降，直到达到0.8%。类似地，不透明度从1减少到0.4%。最后，我们以更快的速度重复五次同样的来回翻译。</li><li id="fdc0" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">结尾:我们隐藏一张卡片，而另一张不透明度重置为1。所选卡片的偏移量设置为两张卡片之间高度的70%。最后，经过一小段时间的延迟后，卡片会自动回到屏幕的顶部，而刻度会恢复正常。</li></ol><p id="8210" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些动画既按顺序运行，也同时运行。它们可以表示如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/a088ab0b91e2da6878feb17ce25a9f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FX2hnF9s5a6I6vnsQ75aPQ.png"/></div></div></figure><p id="2849" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们已经说明了动画应该如何表现，让我们看看如何利用协程来包装它们。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="135d" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">用协程链接动画</h1><p id="54bd" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">Jetpack Compose使用协程让您链接几个动画。无论它们是顺序的还是同时的，您都可以创建尽可能多的协程来产生想要的效果。</p><p id="8d3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将从构建洗牌动画的框架开始。因为它包括顺序和并行动画，我们将需要创建几个协程以及一些用于同时方面的<code class="fe no np nq nr b">coroutineScope</code>。</p><p id="0871" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">骨架应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns lt l"/></div></figure><p id="dc5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个框架通过将动画分割成协程的子集来引导动画。</p><p id="5c94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至于动画本身，Jetpack Compose公开了一个可从协程上下文调用的<code class="fe no np nq nr b">animate</code> suspend方法。</p><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="bbf1" class="nx md iq nr b gy ny nz l oa ob">suspend fun animate(<br/>    initialValue: Float,<br/>    targetValue: Float,<br/>    initialVelocity: Float = 0f,<br/>    animationSpec: AnimationSpec&lt;Float&gt; = <em class="oc">spring</em>(),<br/>    block: (value: Float, velocity: Float) -&gt; Unit<br/>)</span></pre><p id="7e69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一个例子，让我们从输入动画开始。我们想把我们的卡片从1缩小到0.9。</p><p id="4aeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以从保存一个缩放比例并在<code class="fe no np nq nr b">animate</code>方法中更新它的值开始。</p><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="d730" class="nx md iq nr b gy ny nz l oa ob">var scale by <em class="oc">remember </em><strong class="nr ir">{ </strong><em class="oc">mutableStateOf</em>(1f) <strong class="nr ir">}</strong></span><span id="cb3d" class="nx md iq nr b gy od nz l oa ob"><em class="oc">LaunchedEffect</em>(key1 = Unit) <strong class="nr ir">{<br/>    </strong>animate(1f, 0.9f) <strong class="nr ir">{ </strong>value: Float, _: Float <strong class="nr ir">-&gt;<br/>       </strong>scale = value<br/>    <strong class="nr ir">}<br/>}</strong></span></pre><p id="ae48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们可以将这个值应用于我们的两个卡组件。</p><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="c144" class="nx md iq nr b gy ny nz l oa ob"><em class="oc">PlayerCard</em>(<br/>    modifier = Modifier<br/>        .<em class="oc">scale</em>(scale),<br/>    // Other parameters<br/>)</span></pre><p id="89ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe no np nq nr b">animate</code>函数将使用默认的<code class="fe no np nq nr b">spring</code>效果对刻度值进行插值。您可以通过覆盖<code class="fe no np nq nr b">animationSpec</code>属性来改变这种效果。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="1410" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">来回翻译</h1><p id="5876" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">动画的这一部分值得拥有自己的部分。作为免责声明，我想强调的是，我并不是在鼓吹我是如何处理这种转变的。原因在于它缺乏可伸缩性，就像预感到一定有更好的方法一样。我鼓励你分享你的选择，以进一步提高这部动画的整体质量。</p><p id="9b25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">话虽如此，我的方法是有效的。我首先检索我想翻译的位置，叫做<code class="fe no np nq nr b">finalOffset</code>。在我的例子中，由于卡片交换，这个值等于卡片的高度和它们之间的填充。</p><p id="c68f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我记得这个值来自使用<code class="fe no np nq nr b">onGloballyPositioned</code> <em class="oc"> </em>方法组合的第二张卡。</p><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="7090" class="nx md iq nr b gy ny nz l oa ob">val density = <em class="oc">LocalDensity</em>.current<br/>val padding = 30.dp</span><span id="9951" class="nx md iq nr b gy od nz l oa ob">var finalOffset by <em class="oc">remember </em><strong class="nr ir">{ </strong><em class="oc">mutableStateOf</em>(0f) <strong class="nr ir">}</strong></span><span id="3ed4" class="nx md iq nr b gy od nz l oa ob"><em class="oc">PlayerCard</em>(<br/>    modifier = Modifier<br/>        .padding(top = padding * 2)<br/>        .<em class="oc">onGloballyPositioned </em><strong class="nr ir">{<br/>            </strong>finalOffset = <em class="oc">with</em>(density) <strong class="nr ir">{<br/>                </strong>it.size.height + padding.<em class="oc">toPx</em>() * 2<br/>            <strong class="nr ir">}<br/>        }<br/></strong>        // Other properties<br/>)</span></pre><p id="a1d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行动画时，我们需要存储插值偏移。最后，平移会产生用动画偏移插值的最终偏移。我们对第二张卡的这个值取反，使其向相反方向平移。</p><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="af91" class="nx md iq nr b gy ny nz l oa ob">var offset by <em class="oc">remember </em><strong class="nr ir">{ </strong><em class="oc">mutableStateOf</em>(0f) <strong class="nr ir">}</strong><br/>val translation = finalOffset * offset</span><span id="9e00" class="nx md iq nr b gy od nz l oa ob"><em class="oc">PlayerCard</em>(<br/>    modifier = Modifier<br/>        .<em class="oc">graphicsLayer</em>(<br/>            translationY = translation<br/>        ),<br/>    // Other parameters<br/>)</span><span id="6e7c" class="nx md iq nr b gy od nz l oa ob"><em class="oc">PlayerCard</em>(<br/>    modifier = Modifier<br/>        .<em class="oc">graphicsLayer</em>(<br/>            translationY = -translation<br/>        ),<br/>    // Other parameters<br/>)</span></pre><p id="450f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至于<code class="fe no np nq nr b">offset</code>的计算，我们将使用与<code class="fe no np nq nr b">scale</code>相同的机制。我们需要应用两个连续的动画，其中偏移从0到1，然后从1到0来模拟一个来回。为了总结这一点，我们重复这个循环多次(在这个例子中是五次)。</p><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="1b15" class="nx md iq nr b gy ny nz l oa ob"><em class="oc">launch </em><strong class="nr ir">{<br/>    </strong><em class="oc">repeat</em>(5) <strong class="nr ir">{<br/></strong>        animate(0f, 1f) <strong class="nr ir">{ </strong>value: Float, _: Float <strong class="nr ir">-&gt;<br/>            </strong>offset = value<br/>        <strong class="nr ir">}<br/>        </strong>animate(1f, 0f) <strong class="nr ir">{ </strong>value: Float, _: Float <strong class="nr ir">-&gt;<br/>            </strong>offset = value<br/>        <strong class="nr ir">}<br/>    }<br/>}</strong></span></pre></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="4680" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">结束动画</h1><p id="f9ed" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">对于其余的动画，我们将应用相同的逻辑，但在不同的属性。让我们从存储它们开始:</p><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="4f6b" class="nx md iq nr b gy ny nz l oa ob">var scale by <em class="oc">remember </em><strong class="nr ir">{ </strong><em class="oc">mutableStateOf</em>(1f) <strong class="nr ir">}<br/></strong>var firstCardAlpha by <em class="oc">remember </em><strong class="nr ir">{ </strong><em class="oc">mutableStateOf</em>(1f) <strong class="nr ir">}<br/></strong>var secondCardAlpha by <em class="oc">remember </em><strong class="nr ir">{ </strong><em class="oc">mutableStateOf</em>(1f) <strong class="nr ir">}<br/></strong>var offset by <em class="oc">remember </em><strong class="nr ir">{ </strong><em class="oc">mutableStateOf</em>(0f) <strong class="nr ir">}</strong></span></pre><p id="1802" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，有一件重要的事情需要提及。因为我们同时操作可组合对象的不同属性，所以我们不能再依赖直接的<code class="fe no np nq nr b">Modifier</code>属性，比如<code class="fe no np nq nr b">scale</code>、<code class="fe no np nq nr b">alpha</code>和<code class="fe no np nq nr b">offset</code>。你需要使用<code class="fe no np nq nr b">Modifier</code>的<code class="fe no np nq nr b">graphicsLayer</code>属性。</p><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="0e80" class="nx md iq nr b gy ny nz l oa ob"><em class="oc">PlayerCard</em>(<br/>    modifier = Modifier<br/>        .<em class="oc">graphicsLayer</em>(<br/>            alpha = firstCardAlpha,<br/>            scaleX = scale,<br/>            scaleY = scale,<br/>            translationY = translation<br/>        ),<br/>    // Other parameters<br/>)</span><span id="eae7" class="nx md iq nr b gy od nz l oa ob"><em class="oc">PlayerCard</em>(<br/>    modifier = Modifier<br/>        .<em class="oc">graphicsLayer</em>(<br/>            alpha = secondCardAlpha,<br/>            scaleX = scale,<br/>            scaleY = scale,<br/>            translationY = -translation<br/>        ),<br/>    // Other parameters<br/>)</span></pre><p id="201b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的动画块应该倾向于这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns lt l"/></div></figure><p id="4a9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能会得到稍微不同的结果，因为它应该与您的用例相匹配——更不用说我隐藏了一些与本文无关的业务逻辑。</p><p id="56cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">链接动画导致利用协程和改变可组合的内在属性。不要犹豫，用复杂的动画为你的用户创造惊人的用户体验。通过这个洗牌动画，用户理解了隐藏在背后的随机性。</p><p id="6164" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我非常希望这篇文章能让你更容易使用Jetpack Compose制作连锁动画。编码快乐！</p></div></div>    
</body>
</html>