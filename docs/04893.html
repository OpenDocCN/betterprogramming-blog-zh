<html>
<head>
<title>Explaining Expressible Literals in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释Swift中的可表达文字</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/explaining-expressible-literals-in-swift-e7a55514edbd?source=collection_archive---------14-----------------------#2020-05-19">https://betterprogramming.pub/explaining-expressible-literals-in-swift-e7a55514edbd?source=collection_archive---------14-----------------------#2020-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d425" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过用字符串、数组或其他类型初始化自定义类型来丰富它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/045a04529152ae450642065d52b7ce4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WJ8FHQnIIp7V_ONAK-UTSw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@brobroda?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Zuzanna Adamczyk </a>在<a class="ae ky" href="https://unsplash.com/s/photos/neon-green?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e3ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可表达文字允许您通过使用文字来初始化类型。Swift标准库中有多种可用的协议，您可能已经在使用其中一种。</p><p id="a903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个例子是,<code class="fe lv lw lx ly b">ExpressibleByStringLiteral</code>允许我们使用双引号来初始化<code class="fe lv lw lx ly b">String</code>,而不是使用<code class="fe lv lw lx ly b">String(init:)</code>方法。我们都可以受益于这样一个事实，即Swift是通过采用我们自己定义的类型的协议来构建的。</p><h1 id="4e31" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">什么是字面意思？</h1><p id="3371" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">文字是一种表示固定值的符号，如整数、字符串和布尔值。Swift中的文字通过几种可用的协议成为可能。标准类型符合这些协议，并允许我们如下初始化值:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="8a82" class="na ma it ly b gy nb nc l nd ne">var integer = 0 // ExpressibleByIntegerLiteral<br/>var string = "Hello!" // ExpressibleByStringLiteral<br/>var array = [0, 1, 2] // ExpressibleByArrayLiteral<br/>var dictionary = ["Key": "Value"] // ExpressibleByDictionaryLiteral<br/>var boolean = true // ExpressibleByBooleanLiteral</span></pre><p id="b659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是最常用的，但还有一些其他的。它们值得探索，当你探索的时候，你可能会遇到一个叫做<code class="fe lv lw lx ly b">ExpressibleByNilLiteral</code>的特殊协议。</p><p id="8cf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">ExpressibleByNilLiteral</code>用于通过<code class="fe lv lw lx ly b">nil</code>初始化选项:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="0a7c" class="na ma it ly b gy nb nc l nd ne">var optional: String? = nil // ExpressibleByNilLiteral</span></pre><p id="27d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此协议仅用于选项，不应用于自定义类型。基本上就忽略这一条。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="f364" class="lz ma it bd mb mc nm me mf mg nn mi mj jz no ka ml kc np kd mn kf nq kg mp mq bi translated">向自定义类型添加文本支持</h1><p id="f4b8" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在大多数情况下，使用默认的协议集成就可以了。但是，您可能希望向现有类型或项目中定义的自定义类型添加自定义文本支持。</p><p id="286a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解释这是如何工作的，我们将以向URL添加字符串支持为例。这允许我们直接从一个字符串初始化一个URL。</p><p id="4fed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要对<code class="fe lv lw lx ly b">URL</code>类型采用<code class="fe lv lw lx ly b">ExpressibleByStringLiteral</code>协议:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="d093" class="na ma it ly b gy nb nc l nd ne">extension URL: ExpressibleByStringLiteral {<br/>    public init(stringLiteral value: StaticString) {<br/>        self.init(string: "\(value)")!<br/>    }<br/>}</span></pre><p id="aa9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得指出的是这里的限制，因为我们不能创建一个失败的或者抛出的初始化式。这需要我们强制打开创建的URL，这可能不是你想要的。如果是这样的话，你可以直接使用<code class="fe lv lw lx ly b">URL(string:)</code>初始化器。</p><p id="7e4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果出于您的目的，强制unwrap是有意义的，您可以按如下方式开始使用文本:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="446b" class="na ma it ly b gy nb nc l nd ne">let url: URL = "https://www.avanderlee.com"</span></pre><p id="cf2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以简化URL的创建，尤其是如果您确定URL是有效的。注意，我们使用的是<code class="fe lv lw lx ly b">StaticString</code>类型，所以不支持动态字符串。动态字符串会增加额外的复杂性，比如URL编码参数。你可以支持这一点，但这不是这篇博文的重点。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="3255" class="lz ma it bd mb mc nm me mf mg nn mi mj jz no ka ml kc np kd mn kf nq kg mp mq bi translated">不同类型的字符串</h1><p id="7804" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">当您添加对字符串文字的支持时，您应该考虑采用<code class="fe lv lw lx ly b">ExpressibleByUnicodeScalarLiteral</code>来支持Unicode标量，采用<code class="fe lv lw lx ly b">ExpressibleByExtendedGraphemeClusterLiteral</code>来支持扩展的字形簇。扩展的字素簇是一组一个或多个Unicode标量值，这些值成为单个可见字符。</p><p id="9ec4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想同时支持这三种情况，您可以添加以下扩展:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="5826" class="lz ma it bd mb mc nm me mf mg nn mi mj jz no ka ml kc np kd mn kf nq kg mp mq bi translated">在自定义类型中使用文本的有用示例</h1><p id="e0fb" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">您可以在自定义类型中使用文本。下面举几个例子给你启发。</p><h2 id="717c" class="na ma it bd mb nt nu dn mf nv nw dp mj li nx ny ml lm nz oa mn lq ob oc mp od bi translated">直接从字符串初始化日期</h2><p id="bd6b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">当您经常使用相同的日期格式时，您可以直接从<code class="fe lv lw lx ly b">String</code>中初始化您的日期:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="a1bf" class="na ma it bd mb nt nu dn mf nv nw dp mj li nx ny ml lm nz oa mn lq ob oc mp od bi translated">从字典初始化自定义缓存</h2><p id="f5ee" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如果您定义了自己的自定义缓存存储，您可能希望直接从字典中初始化它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="3e20" class="na ma it bd mb nt nu dn mf nv nw dp mj li nx ny ml lm nz oa mn lq ob oc mp od bi translated"><strong class="ak">初始化自定义自动布局优先级</strong></h2><p id="079d" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">当您在代码中编写<a class="ae ky" href="https://www.avanderlee.com/swift/auto-layout-programmatically/" rel="noopener ugc nofollow" target="_blank">自动布局时，您可能需要设置一个自定义布局优先级:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d520" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:我们不能使用<code class="fe lv lw lx ly b">ExpressibleByFloatLiteral</code>协议，因为输入值总是被视为一个整数。因此，我们必须使用<code class="fe lv lw lx ly b">ExpressibleByIntegerLiteral</code>协议。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="1a48" class="lz ma it bd mb mc nm me mf mg nn mi mj jz no ka ml kc np kd mn kf nq kg mp mq bi translated">结论</h1><p id="b98c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">就是这样！希望您已经受到了在Swift中使用文字所能做的事情的启发。也许您有自己的定制类型，可以很好地与可用的文字协议兼容。</p><p id="32b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想进一步提高您的Swift知识，请查看<a class="ae ky" href="https://www.avanderlee.com/category/swift/" rel="noopener ugc nofollow" target="_blank"> Swift类别页面</a>。如果您有任何其他建议或反馈，请随时<a class="ae ky" href="mailto:contact@avanderlee.com" rel="noopener ugc nofollow" target="_blank">联系我</a>或在<a class="ae ky" href="https://www.twitter.com/twannl" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上发推文给我。</p><p id="fa47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢！</p></div></div>    
</body>
</html>