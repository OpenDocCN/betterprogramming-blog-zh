<html>
<head>
<title>Developing a RESTful API With Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go开发RESTful API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/developing-a-restful-api-with-go-b5150f693277?source=collection_archive---------3-----------------------#2022-05-15">https://betterprogramming.pub/developing-a-restful-api-with-go-b5150f693277?source=collection_archive---------3-----------------------#2022-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8aa8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看看我的归零项目如何让它变得更简单</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3dbf0f80adc687013c298d7356a262d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lp34pzcUd-7dMLme"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">道格拉斯·洛佩斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="b608" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">何时使用RESTful API</h1><p id="8b66" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于大多数初创公司来说，我们应该更多地关注在业务的早期阶段交付产品。单体服务具有架构简单、易于部署、开发效率高等优点，可以帮助我们快速实现产品需求。当我们使用单体服务快速交付产品时，我们还需要保留业务增值的可能性，因此我们通常在单体服务中清晰地划分不同的业务模块。</p><h1 id="5e9d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">购物中心整体服务架构</h1><p id="0eb8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们以商城为例，构建一个整体服务。商城服务一般比较复杂，由多个模块组成，比较重要的模块有账户、产品、订单等模块。每个模块都有自己独立的业务逻辑，并且每个模块都依赖于其他模块。例如，订单模块和产品模块将依赖于帐户模块。在单片应用程序中，这种依赖通常是通过模块间的方法调用来实现的。单体服务一般共享存储资源，比如<code class="fe mk ml mm mn b">MySQL</code>和<code class="fe mk ml mm mn b">Redis</code>。</p><p id="2a9a" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">单体服务的整体架构相对简单，这也是单体服务的优势。顾客的请求通过<code class="fe mk ml mm mn b">DNS</code>进行解析，并通过<code class="fe mk ml mm mn b">Nginx</code>转发给商场的后端服务。商城服务部署在云主机上。为了实现更大的吞吐量和高可用性，服务一般会部署多个副本。如果优化得当，这种简单的架构可以实现高吞吐量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/de07935a51bc3678e10e321a3fafeb20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XGpDYT4Vf8vHDO3r.png"/></div></div></figure><p id="e8a3" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">例如，对订单详细信息接口<code class="fe mk ml mm mn b">/order/detail</code>的请求被路由到订单模块，订单模块依靠帐户模块和产品模块将完整的订单详细信息返回给用户，单个服务中的多个模块通常共享数据库和缓存。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/9c46b13431fbc252d46e9f1b4c841ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LDSL1c2cxSNEiocz.png"/></div></div></figure><h1 id="00d8" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">整体服务</h1><p id="331f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">下一节将描述如何基于<code class="fe mk ml mm mn b">go-zero</code>快速实现一个商城单体服务。用过<code class="fe mk ml mm mn b">go-zero</code>的Devs都知道，我们提供了一个<code class="fe mk ml mm mn b">API</code>格式的文件来描述<code class="fe mk ml mm mn b">Restful API</code>，然后用一个命令就可以通过<code class="fe mk ml mm mn b">goctl</code>生成相应的代码，我们只需要在<code class="fe mk ml mm mn b">logic</code>文件中填入相应的业务逻辑即可。商城服务包含几个模块，为了使模块相互独立，不同的模块由单独的<code class="fe mk ml mm mn b">API</code>定义，但是所有的<code class="fe mk ml mm mn b">API</code>都是为同一个<code class="fe mk ml mm mn b">service (mall-api)</code>定义的。</p><p id="2dca" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">在<code class="fe mk ml mm mn b">api</code>目录下创建<code class="fe mk ml mm mn b">user.api</code>、<code class="fe mk ml mm mn b">order.api</code>、<code class="fe mk ml mm mn b">product.api</code>和<code class="fe mk ml mm mn b">mall.api</code>，其中<code class="fe mk ml mm mn b">mall.api</code>是聚合的<code class="fe mk ml mm mn b">api</code>文件。其他<code class="fe mk ml mm mn b">api</code>文件通过<code class="fe mk ml mm mn b">import</code>指令导入。</p><pre class="kg kh ki kj gt mv mn mw mx aw my bi"><span id="2c62" class="mz kx iq mn b gy na nb l nc nd">api<br/>|-- mall.api<br/>|-- order.api<br/>|-- product.api<br/>|-- user.api</span></pre><h1 id="7bac" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">商城API定义</h1><p id="8f7b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe mk ml mm mn b">mall.api</code>定义如下，其中<code class="fe mk ml mm mn b">syntax = "v1"</code>表示这是<code class="fe mk ml mm mn b">zero-api</code>的<code class="fe mk ml mm mn b">v1</code>语法。</p><pre class="kg kh ki kj gt mv mn mw mx aw my bi"><span id="1406" class="mz kx iq mn b gy na nb l nc nd">syntax = "v1"</span><span id="fd3a" class="mz kx iq mn b gy ne nb l nc nd">import "user.api"<br/>import "order.api"<br/>import "product.api"</span></pre><h1 id="c3c0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">帐户模块API定义</h1><ul class=""><li id="a5e8" class="nf ng iq lq b lr ls lu lv lx nh mb ni mf nj mj nk nl nm nn bi translated">查看用户详细信息</li><li id="bf3a" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated">获取用户的所有订单</li></ul><pre class="kg kh ki kj gt mv mn mw mx aw my bi"><span id="5cdb" class="mz kx iq mn b gy na nb l nc nd">syntax = "v1"</span><span id="0954" class="mz kx iq mn b gy ne nb l nc nd"><strong class="mn ir">type</strong> (<br/>    UserRequest {<br/>        ID <strong class="mn ir">int64</strong> `path:"id"`<br/>    }</span><span id="cb47" class="mz kx iq mn b gy ne nb l nc nd">    UserReply {<br/>        ID      <strong class="mn ir">int64</strong>   `json:"id"`<br/>        Name    <strong class="mn ir">string</strong>  `json:"name"`<br/>        Balance <strong class="mn ir">float64</strong> `json:"balance"`<br/>    }</span><span id="1445" class="mz kx iq mn b gy ne nb l nc nd">    UserOrdersRequest {<br/>        ID <strong class="mn ir">int64</strong> `path:"id"`<br/>    }</span><span id="212b" class="mz kx iq mn b gy ne nb l nc nd">    UserOrdersReply {<br/>        ID       <strong class="mn ir">string</strong> `json:"id"`<br/>        State    <strong class="mn ir">uint32</strong> `json:"state"`<br/>        CreateAt <strong class="mn ir">string</strong> `json:"create_at"`<br/>    }<br/>)</span><span id="518e" class="mz kx iq mn b gy ne nb l nc nd">service mall-api {<br/>    @handler UserHandler<br/>    get /user/:id (UserRequest) returns (UserReply)</span><span id="8dfd" class="mz kx iq mn b gy ne nb l nc nd">    @handler UserOrdersHandler<br/>    get /user/:id/orders (UserOrdersRequest) returns (UserOrdersReply)<br/>}</span></pre><h1 id="fce4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">订单模块API定义</h1><ul class=""><li id="32ed" class="nf ng iq lq b lr ls lu lv lx nh mb ni mf nj mj nk nl nm nn bi translated">获取订单详细信息</li><li id="3c8d" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated">生成订单</li></ul><pre class="kg kh ki kj gt mv mn mw mx aw my bi"><span id="3388" class="mz kx iq mn b gy na nb l nc nd">syntax = "v1"</span><span id="7a5d" class="mz kx iq mn b gy ne nb l nc nd"><strong class="mn ir">type</strong> (<br/>    OrderRequest {<br/>        ID <strong class="mn ir">string</strong> `path:"id"`<br/>    }</span><span id="33e2" class="mz kx iq mn b gy ne nb l nc nd">    OrderReply {<br/>        ID       <strong class="mn ir">string</strong> `json:"id"`<br/>        State    <strong class="mn ir">uint32</strong> `json:"state"`<br/>        CreateAt <strong class="mn ir">string</strong> `json:"create_at"`<br/>    }</span><span id="01b7" class="mz kx iq mn b gy ne nb l nc nd">    OrderCreateRequest {<br/>        ProductID <strong class="mn ir">int64</strong> `json:"product_id"`<br/>    }</span><span id="5730" class="mz kx iq mn b gy ne nb l nc nd">    OrderCreateReply {<br/>        Code <strong class="mn ir">int</strong> `json:"code"`<br/>    }<br/>)</span><span id="9d7f" class="mz kx iq mn b gy ne nb l nc nd">service mall-api {<br/>    @handler OrderHandler<br/>    get /order/:id (OrderRequest) returns (OrderReply)</span><span id="e86e" class="mz kx iq mn b gy ne nb l nc nd">    @handler OrderCreateHandler<br/>    post /order/create (OrderCreateRequest) returns (OrderCreateReply)<br/>}</span></pre><h1 id="ad21" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">产品模块API定义</h1><ul class=""><li id="0d28" class="nf ng iq lq b lr ls lu lv lx nh mb ni mf nj mj nk nl nm nn bi translated">查看产品详情</li></ul><pre class="kg kh ki kj gt mv mn mw mx aw my bi"><span id="2319" class="mz kx iq mn b gy na nb l nc nd">syntax = "v1"</span><span id="d09e" class="mz kx iq mn b gy ne nb l nc nd"><strong class="mn ir">type</strong> ProductRequest {<br/>    ID <strong class="mn ir">int64</strong> `path:"id"`<br/>}</span><span id="303f" class="mz kx iq mn b gy ne nb l nc nd"><strong class="mn ir">type</strong> ProductReply {<br/>    ID    <strong class="mn ir">int64</strong>   `json:"id"`<br/>    Name  <strong class="mn ir">string</strong>  `json:"name"`<br/>    Price <strong class="mn ir">float64</strong> `json:"price"`<br/>    Count <strong class="mn ir">int64</strong>   `json:"count"`<br/>}</span><span id="a3f0" class="mz kx iq mn b gy ne nb l nc nd">service mall-api {<br/>    @handler ProductHandler<br/>    get /product/:id (ProductRequest) returns (ProductReply)<br/>}</span></pre><h1 id="d387" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">生成整体服务</h1><p id="6712" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">有了已经定义的<code class="fe mk ml mm mn b">API</code>，用<code class="fe mk ml mm mn b">API</code>生成服务变得非常简单，我们使用<code class="fe mk ml mm mn b">goctl</code>来生成整体服务代码。</p><pre class="kg kh ki kj gt mv mn mw mx aw my bi"><span id="48ab" class="mz kx iq mn b gy na nb l nc nd">$ goctl api go -api api/mall.api -dir .</span></pre><p id="28c4" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">生成的代码结构如下。</p><pre class="kg kh ki kj gt mv mn mw mx aw my bi"><span id="a12e" class="mz kx iq mn b gy na nb l nc nd">.<br/>├── api<br/>│ ├── mall.api<br/>│ ├── order.api<br/>│ ├── product.api<br/>│ └── user.api<br/>├── etc<br/>│ └── mall-api.yaml<br/>├─ internal<br/>│ ├── config<br/>│ │ └── config.<strong class="mn ir">go</strong><br/>│ ├── handler<br/>│ │ ├── ordercreatehandler.<strong class="mn ir">go</strong><br/>│ │ ├── orderhandler.<strong class="mn ir">go</strong><br/>│ │ ├── producthandler.<strong class="mn ir">go</strong><br/>│ │ ├── routes.<strong class="mn ir">go</strong><br/>│ │ ├── userhandler.<strong class="mn ir">go</strong><br/>│ │ └─ userordershandler.<strong class="mn ir">go</strong><br/>│ ├─ logic<br/>│ │ ├─ ordercreatelogic.<strong class="mn ir">go</strong><br/>│ │ ├── orderlogic.<strong class="mn ir">go</strong><br/>│ │ ├── productlogic.<strong class="mn ir">go</strong><br/>│ │ ├── userlogic.<strong class="mn ir">go</strong><br/>│ │ └── userorderslogic.<strong class="mn ir">go</strong><br/>│ ├── svc<br/>│ │ └── servicecontext.<strong class="mn ir">go</strong><br/>│ └── types<br/>│ └── types.<strong class="mn ir">go</strong><br/>└── mall.<strong class="mn ir">go</strong></span></pre><p id="0de3" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我们来解释一下生成的文件。</p><ul class=""><li id="b196" class="nf ng iq lq b lr mo lu mp lx nt mb nu mf nv mj nk nl nm nn bi translated"><code class="fe mk ml mm mn b">api</code>:保存<code class="fe mk ml mm mn b">API</code>描述文件</li><li id="dff6" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated"><code class="fe mk ml mm mn b">etc</code>:用于定义项目配置，所有配置项都可以写入<code class="fe mk ml mm mn b">mall-api.yaml</code></li><li id="01dc" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated"><code class="fe mk ml mm mn b">internal/config</code>:服务的配置定义</li><li id="6056" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated"><code class="fe mk ml mm mn b">internal/handler</code>:对应于<code class="fe mk ml mm mn b">API</code>文件中定义的路线的<code class="fe mk ml mm mn b">handler</code>的执行</li><li id="0d85" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated"><code class="fe mk ml mm mn b">internal/logic</code>:用于放置每条路由对应的业务逻辑，区分<code class="fe mk ml mm mn b">handler</code>和<code class="fe mk ml mm mn b">logic</code>的原因是为了尽量减少业务处理部分的依赖性，将<code class="fe mk ml mm mn b">HTTP requests</code>从逻辑处理代码中分离出来，便于后续拆分成<code class="fe mk ml mm mn b">RPC service</code></li><li id="8bdb" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated"><code class="fe mk ml mm mn b">internal/svc</code>:用于定义业务逻辑处理的依赖关系，我们可以在<code class="fe mk ml mm mn b">main</code>函数中创建依赖资源，并通过<code class="fe mk ml mm mn b">ServiceContext</code>传递给<code class="fe mk ml mm mn b">handler</code>和<code class="fe mk ml mm mn b">logic</code></li><li id="3164" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated"><code class="fe mk ml mm mn b">internal/types</code>:定义<code class="fe mk ml mm mn b">API</code>请求和响应数据结构</li><li id="cf3d" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated"><code class="fe mk ml mm mn b">mall.go</code>:函数<code class="fe mk ml mm mn b">main</code>所在的文件，与<code class="fe mk ml mm mn b">API</code>定义中的<code class="fe mk ml mm mn b">service</code>同名，但去掉了<code class="fe mk ml mm mn b">-api</code>后缀</li></ul><p id="bf51" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">生成的服务无需任何修改即可运行:` 1</p><pre class="kg kh ki kj gt mv mn mw mx aw my bi"><span id="fcc6" class="mz kx iq mn b gy na nb l nc nd">$ go run mall.go<br/>Starting server at 0.0.0.0:8888...</span></pre><h1 id="9f12" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">实现业务逻辑</h1><p id="fa13" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">接下来，让我们实现业务逻辑。出于演示目的，该逻辑将是简单的，而不是真正的业务逻辑。</p><p id="a621" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">首先，让我们实现为用户获取所有订单的逻辑。由于用户模块中没有订单相关的信息，我们需要依靠订单模块来查询用户的订单，所以我们在<code class="fe mk ml mm mn b">UserOrdersLogic</code>中增加了对<code class="fe mk ml mm mn b">OrderLogic</code>的依赖。</p><pre class="kg kh ki kj gt mv mn mw mx aw my bi"><span id="e392" class="mz kx iq mn b gy na nb l nc nd"><strong class="mn ir">type</strong> UserOrdersLogic <strong class="mn ir">struct</strong> {<br/>    logx.Logger<br/>    ctx        context.Context<br/>    svcCtx     *svc.ServiceContext<br/>    orderLogic *OrderLogic<br/>}</span><span id="05a2" class="mz kx iq mn b gy ne nb l nc nd"><strong class="mn ir">func</strong> <strong class="mn ir">NewUserOrdersLogic</strong>(ctx context.Context, svcCtx *svc.ServiceContext) *<strong class="mn ir">UserOrdersLogic</strong> {<br/>    <strong class="mn ir">return</strong> &amp;UserOrdersLogic{<br/>        Logger:     logx.WithContext(ctx),<br/>        ctx:        ctx,<br/>        svcCtx:     svcCtx,<br/>        orderLogic: NewOrderLogic(ctx, svcCtx),<br/>    }<br/>}</span></pre><p id="0a00" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">在<code class="fe mk ml mm mn b">OrderLogic</code>中实现一个方法，根据<code class="fe mk ml mm mn b">user id</code>查询所有订单</p><pre class="kg kh ki kj gt mv mn mw mx aw my bi"><span id="087b" class="mz kx iq mn b gy na nb l nc nd"><strong class="mn ir">func</strong> (l *OrderLogic) <strong class="mn ir">ordersByUser</strong>(uid <strong class="mn ir">int64</strong>) ([]*types.OrderReply, error) {<br/>    <strong class="mn ir">if</strong> uid == 123 {<br/>        // It should actually be queried from database or cache<br/>        <strong class="mn ir">return</strong> []*types.OrderReply{<br/>            {<br/>                ID:       "236802838635",<br/>                State:    1,<br/>                CreateAt: "2022-5-12 22:59:59",<br/>            },<br/>            {<br/>                ID:       "236802838636",<br/>                State:    1,<br/>                CreateAt: "2022-5-10 20:59:59",<br/>            },<br/>        }, <strong class="mn ir">nil</strong><br/>    }</span><span id="05ea" class="mz kx iq mn b gy ne nb l nc nd">    <strong class="mn ir">return</strong> <strong class="mn ir">nil</strong>, <strong class="mn ir">nil</strong><br/>}</span></pre><p id="f812" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">调用<code class="fe mk ml mm mn b">UserOrdersLogic</code>的<code class="fe mk ml mm mn b">UserOrders</code>方法中的<code class="fe mk ml mm mn b">ordersByUser</code>方法。</p><pre class="kg kh ki kj gt mv mn mw mx aw my bi"><span id="f5ae" class="mz kx iq mn b gy na nb l nc nd"><strong class="mn ir">func</strong> (l *UserOrdersLogic) <strong class="mn ir">UserOrders</strong>(req *types.UserOrdersRequest) (*types.UserOrdersReply, error) {<br/>    orders, err := l.orderLogic.ordersByUser(req.ID)<br/>    <strong class="mn ir">if</strong> err ! = <strong class="mn ir">nil</strong> {<br/>        <strong class="mn ir">return</strong> <strong class="mn ir">nil</strong>, err<br/>    }</span><span id="de6e" class="mz kx iq mn b gy ne nb l nc nd">    <strong class="mn ir">return</strong> &amp;types.UserOrdersReply{<br/>        Orders: orders,<br/>    }, <strong class="mn ir">nil</strong><br/>}</span></pre><p id="11a1" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">此时，我们重启<code class="fe mk ml mm mn b">mall-api</code>服务，并在浏览器中请求用户的所有订单。</p><pre class="kg kh ki kj gt mv mn mw mx aw my bi"><span id="d174" class="mz kx iq mn b gy na nb l nc nd"><a class="ae kv" href="http://localhost:8888/user/123/orders" rel="noopener ugc nofollow" target="_blank">http://localhost:8888/user/123/orders</a></span></pre><p id="521e" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">返回的结果如下，正如我们所料</p><pre class="kg kh ki kj gt mv mn mw mx aw my bi"><span id="829d" class="mz kx iq mn b gy na nb l nc nd">{<br/>    "orders": [<br/>        {<br/>            "id": "236802838635",<br/>            "state": 1,<br/>            "create_at": "2022-5-12 22:59:59"<br/>        },<br/>        {<br/>            "id": "236802838636",<br/>            "state": 1,<br/>            "create_at": "2022-5-10 20:59:59"<br/>        }<br/>    ]<br/>}</span></pre><p id="f2b1" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">接下来，我们将实现创建订单的逻辑。要创建订单，我们首先需要查看库存中的商品是否足够，因此我们需要依赖订单模块中的商品模块。</p><pre class="kg kh ki kj gt mv mn mw mx aw my bi"><span id="90a3" class="mz kx iq mn b gy na nb l nc nd"><strong class="mn ir">type</strong> OrderCreateLogic <strong class="mn ir">struct</strong> {<br/>    logx.Logger<br/>    ctx          context.Context<br/>    svcCtx       *svc.ServiceContext<br/>    productLogic *ProductLogic<br/>    productLogic *ProductLogic<br/>}</span><span id="9390" class="mz kx iq mn b gy ne nb l nc nd"><strong class="mn ir">func</strong> <strong class="mn ir">NewOrderCreateLogic</strong>(ctx context.Context, svcCtx *svc.ServiceContext) *<strong class="mn ir">OrderCreateLogic</strong> {<br/>    <strong class="mn ir">return</strong> &amp;OrderCreateLogic{<br/>        Logger:       logx.WithContext(ctx),<br/>        ctx:          ctx,<br/>        svcCtx:       svcCtx,<br/>        productLogic: NewProductLogic(ctx, svcCtx),<br/>    }<br/>}</span></pre><p id="1618" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">创建订单的逻辑如下。</p><pre class="kg kh ki kj gt mv mn mw mx aw my bi"><span id="18a4" class="mz kx iq mn b gy na nb l nc nd"><strong class="mn ir">const</strong> (<br/>    success = 0<br/>    failure = -1<br/>)</span><span id="25b0" class="mz kx iq mn b gy ne nb l nc nd"><strong class="mn ir">func</strong> (l *OrderCreateLogic) <strong class="mn ir">OrderCreate</strong>(req *types.OrderCreateRequest) (*types.OrderCreateReply, error) {<br/>    product, err := l.productLogic.productByID(req.ProductID)<br/>    <strong class="mn ir">if</strong> err ! = <strong class="mn ir">nil</strong> {<br/>        <strong class="mn ir">return</strong> <strong class="mn ir">nil</strong>, err<br/>    }</span><span id="2513" class="mz kx iq mn b gy ne nb l nc nd">    <strong class="mn ir">if</strong> product.Count &gt; 0 {<br/>        <strong class="mn ir">return</strong> &amp;types.OrderCreateReply{Code: success}, <strong class="mn ir">nil</strong><br/>    }</span><span id="6828" class="mz kx iq mn b gy ne nb l nc nd">    <strong class="mn ir">return</strong> &amp;types.OrderCreateReply{Code: failure}, <strong class="mn ir">nil</strong><br/>}</span></pre><p id="e10c" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">从属产品模块的逻辑如下。</p><pre class="kg kh ki kj gt mv mn mw mx aw my bi"><span id="e972" class="mz kx iq mn b gy na nb l nc nd"><strong class="mn ir">func</strong> (l *ProductLogic) <strong class="mn ir">Product</strong>(req *types.ProductRequest) (*types.ProductReply, error) {<br/>    <strong class="mn ir">return</strong> l.productByID(req.ID)<br/>}</span><span id="d7ce" class="mz kx iq mn b gy ne nb l nc nd"><strong class="mn ir">func</strong> (l *ProductLogic) <strong class="mn ir">productByID</strong>(id <strong class="mn ir">int64</strong>) (*types.ProductReply, error) {<br/>    <strong class="mn ir">return</strong> &amp;types.ProductReply{<br/>        ID: id,<br/>        Name: "apple watch 3",<br/>        Price: 3333.33,<br/>        Count: 99,<br/>    }, <strong class="mn ir">nil</strong><br/>}</span></pre><p id="947f" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">以上说明使用<code class="fe mk ml mm mn b">go-zero</code>开发单片服务非常简单，有助于我们快速开发。而且我们还把模块分开了，这也为以后改做微服务提供了可能。</p><h1 id="587a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">摘要</h1><p id="93a5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">上面的例子表明，使用<code class="fe mk ml mm mn b">go-zero</code>开发单体服务非常简单。你只需要定义<code class="fe mk ml mm mn b">api</code>文件，然后<code class="fe mk ml mm mn b">goctl</code>工具就可以自动生成项目代码。我们只需要填写逻辑包中的业务逻辑代码。在本文中，我们刚刚演示了如何快速开发基于<code class="fe mk ml mm mn b">go-zero</code>的整体服务，这不涉及数据库。实际上，<code class="fe mk ml mm mn b">goctl</code>也可以用一条命令生成<code class="fe mk ml mm mn b">CRUD</code>和<code class="fe mk ml mm mn b">cache</code>代码。</p><p id="48db" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">并且针对不同的业务场景，还可以通过定制模板来实现定制。定制的模板可以通过远程<code class="fe mk ml mm mn b">git</code>存储库在团队内部共享，这对于团队协作来说非常有效。</p><div class="nw nx gp gr ny nz"><a href="https://github.com/zeromicro/go-zero" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">GitHub - zeromicro/go-zero:一个具有cli工具的云原生go微服务框架，用于…</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">具有cli工具的云原生Go微服务框架可提高工作效率。- GitHub - zeromicro/go-zero:一个云原生…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">github.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on kp nz"/></div></div></a></div><pre class="kg kh ki kj gt mv mn mw mx aw my bi"><span id="a599" class="mz kx iq mn b gy na nb l nc nd"><strong class="mn ir">Want to Connect?</strong></span><span id="0326" class="mz kx iq mn b gy ne nb l nc nd">Welcome to use <!-- -->go-zero<!-- --> and star to support us!</span></pre></div></div>    
</body>
</html>