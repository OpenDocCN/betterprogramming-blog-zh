<html>
<head>
<title>Solidity 0.6: You Might Be Sending Ether Incorrectly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实度0.6:你可能发送以太不正确</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solidity-0-6-you-might-be-sending-ether-all-wrong-1e119e1ffc27?source=collection_archive---------4-----------------------#2020-01-30">https://betterprogramming.pub/solidity-0-6-you-might-be-sending-ether-all-wrong-1e119e1ffc27?source=collection_archive---------4-----------------------#2020-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1950" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以太坊货币转移的类型安全入门</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6607b7e6cf4a09122c05f3ffb269d4cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J9fWINsMkBgU9K55KZPBpw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@cliffordgatewood?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Clifford摄影</a>拍摄于<a class="ae kv" href="https://unsplash.com/s/photos/ethereum?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="f7c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Solidity 0.6 最近已经发布，为智能合约的资金转移处理方式带来了一些语法上的变化。</p><p id="fcad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，这一基本功能仍然是type- <em class="ls"> un </em> safe，编译器无法保证传输的接收者实际上能够接受它。</p><p id="ba33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编译器和类型系统的主要目的之一是确保不允许带有给定错误的程序运行。相反，Solidity的编译器传递了一个会让用户赔钱的错误。</p><p id="4072" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管Solidity 0.5引入了类型<code class="fe lt lu lv lw b">address payable</code>和新引入的<code class="fe lt lu lv lw b">receive</code>功能，但资金转移的类型安全性多年来并没有改善。</p><p id="cb9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我会给你一个虚构的例子，强调在Solidity 0.5和0.6中实现的问题和对策。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="4a78" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">一点术语</h1><p id="31b2" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated"><em class="ls">智能合同</em>是使用区块链平台来执行某些操作的应用程序，例如在不依赖可信第三方实体的情况下交换信息或金钱。</p><p id="6c5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">智能契约非常像面向对象编程范式中的一个类，因此，它有一个状态并公开一组函数。调用函数是“激活”智能合约的唯一方式，通常发生在事务的上下文中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/78a0b2783e3a3a47762093ffa72964df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*36dEqQ35Z3mUBRIRVsjfnw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Solidity_logo.svg/2000px-Solidity_logo.svg.png" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></figure><p id="31f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为以太坊生态系统实现此类应用的最著名的语言是<em class="ls"> Solidity </em>。</p><p id="d24c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它是静态类型和面向契约的，后者意味着它的语法(受到JavaScript和C++的强烈影响)帮助程序员定义智能契约，就像他们在定义一个类一样。</p><p id="a586" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后但同样重要的是，智能合约不是以太坊中唯一的账户类型。</p><p id="8854" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，与它们一起的是所谓的<em class="ls">外部拥有的账户</em> <strong class="ky ir"> </strong> (EOA)，可以被认为是人类通过调用合同上的函数来开始交易。</p><p id="2386" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以太坊中的账户(EOA和智能合约)通过一个<em class="ls">地址</em>唯一标识，该地址是一个20字节长的十六进制字符序列。地址可用于向账户汇款或调用合同上的功能。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="5283" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">问题是</h1><p id="838d" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">正如我们刚刚看到的，以太坊中的智能合约使用它们的地址来引用。在Solidity中，<code class="fe lt lu lv lw b">address</code> es本质上是作为无类型指针来实现的，并以两种主要方式使用:</p><ul class=""><li id="d0d0" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">检索部署在区块链上的协定的实例，并随后调用其函数。</li><li id="39bc" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">向账户汇款(无论是EOA还是智能合约)。</li></ul><p id="a346" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然灵活，但这些使用模式很容易变得有害。使用非类型化指针会使推理代码变得更加困难，从而导致难以调试的细微错误。</p><p id="7bbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，Solidity的编译器在这里没有提供任何帮助:当涉及到<code class="fe lt lu lv lw b">address</code> es时，几乎不执行静态或动态检查。</p><p id="52e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能会在汇款过程中造成特别的麻烦。当合同收到款项时，会调用一个特定的函数(所谓的<em class="ls">回退函数</em>直到Solidity 0.6)。</p><p id="42f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果接收契约没有定义这样的函数，那么传输将失败，并引发一个异常。</p><p id="bcb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，miner节点仍然保留与其使用的气体相对应的乙醚量，实际上是从发出失败交易的帐户中取钱。</p><p id="0bb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更糟糕的是，这可能导致资金无限期锁定在合同余额中。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="3610" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">Solidity 0.5的新特性是什么</h1><p id="a4d1" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">为了帮助缓解这个问题，Solidity 0.5引入了一种新的类型，<code class="fe lt lu lv lw b">address payable</code>，来表示可以安全接收资金的合同的地址。</p><p id="e179" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从那个版本开始，转移以太的内置功能已经从<code class="fe lt lu lv lw b">address</code>转移到<code class="fe lt lu lv lw b">address payable</code>。</p><p id="3089" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，前者的实例不能直接转换成后者的实例，即使通过类型<code class="fe lt lu lv lw b">uint160</code>进行强制转换仍然是可能的:</p><pre class="kg kh ki kj gt nq lw nr ns aw nt bi"><span id="e3f1" class="nu mf iq lw b gy nv nw l nx ny">address payable payableAddress = address(uint160(nonPayableAddress))</span></pre><p id="1ea9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这种区分有效地澄清了不是每个地址都有资格收到钱，但它也造成了关于这个话题的更多混乱。</p><p id="7890" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，编译器不会检查由<code class="fe lt lu lv lw b">address payable</code>指向的契约是否定义了回退函数。</p><p id="6ca6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其次，一个函数的调用者，实际上被称为<code class="fe lt lu lv lw b">msg.sender</code>，总是<em class="ls">给定类型<code class="fe lt lu lv lw b">address payable</code>。<code class="fe lt lu lv lw b">msg.sender</code>是每个函数调用中的隐式变量集，包含调用函数的帐户地址。</em></p><p id="afa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Solidity 0.5之前，它的类型只是<code class="fe lt lu lv lw b">address</code>，但从那以后就变成了<code class="fe lt lu lv lw b">address payable</code>。这是一个严重的问题，因为使用<code class="fe lt lu lv lw b">msg.sender</code>作为资金转移的接收者是常见的做法，编译器只是假设适合作为目标。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="e3dd" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">Solidity 0.6的新特性</h1><p id="623b" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">如果你认为Solidity的最新版本增加了一些秩序，你最好再想想。该版本提供了两个关于电汇的关键功能:</p><ul class=""><li id="3763" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">由于内置函数<code class="fe lt lu lv lw b">payable(x)</code>，从<code class="fe lt lu lv lw b">address</code>到<code class="fe lt lu lv lw b">address payable</code>的转换变得更加容易，其中<code class="fe lt lu lv lw b">x</code>是一个<code class="fe lt lu lv lw b">address</code>。</li><li id="232e" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">通常被称为“回退功能”的未命名功能已被拆分为使用<code class="fe lt lu lv lw b">fallback</code>关键字定义的新回退功能和使用<code class="fe lt lu lv lw b">receive</code>关键字定义的接收以太功能。</li></ul><p id="accf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个合同被发送资金时，<code class="fe lt lu lv lw b">receive</code>被调用，如果定义的话。否则，会尝试调用<code class="fe lt lu lv lw b">fallback</code>，但是，如果它没有被定义或者没有被标记为<code class="fe lt lu lv lw b">payable</code>(Solidity中使用的一个关键字，用于显式声明一个函数可以接收乙醚)，事务将会恢复。</p><p id="cc27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管如此，这种新的区别仅用于区分以前回退功能的两种主要用途:</p><ul class=""><li id="8bc2" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated"><code class="fe lt lu lv lw b">receive</code>现在打算作为资金转移的结果参与进来。</li><li id="194b" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><code class="fe lt lu lv lw b">fallback</code>在没有其他函数匹配调用数据时被调用。</li></ul><p id="f2e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能会想，这并没有增加任何额外的类型安全性。</p><p id="c011" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以前的回退功能只是换了个名字，被拆分了，但是仍然不能保证一个合同可能收钱。因此，以太仍然可能被浪费，将钱发送给没有<code class="fe lt lu lv lw b">receive</code>或<code class="fe lt lu lv lw b">payable</code>或<code class="fe lt lu lv lw b">fallback</code>的合同。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="9c0c" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">行动中的不安全类型</h1><p id="2ead" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">两份合同足以说明Solidity资金转移的不安全性:</p><pre class="kg kh ki kj gt nq lw nr ns aw nt bi"><span id="edae" class="nu mf iq lw b gy nv nw l nx ny">pragma solidity 0.6.1;</span><span id="15a0" class="nu mf iq lw b gy nz nw l nx ny">contract ProdigalContract {<br/>    constructor () payable public {}<br/>    <br/>    function drainBalance() public {<br/>        msg.sender.transfer(address(this).balance);<br/>    }<br/>    <br/>    receive() external payable {}<br/>}</span><span id="f738" class="nu mf iq lw b gy nz nw l nx ny">contract WithoutReceive {<br/>    constructor () public {}<br/>    <br/>    function triggerUnsafeTransfer(address _address) public {<br/>        ProdigalContract(payable(_address)).drainBalance();<br/>    }<br/>}</span></pre><p id="7443" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以在<a class="ae kv" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix </a>中复制粘贴上述代码，用最新发布的Solidity编译器(编写时为0.6.1+commit.e6f7d5a4)进行测试。</p><p id="41e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b">ProdigalContract</code>表示持有一些钱并公开一个函数<code class="fe lt lu lv lw b">drainBalance()</code>的契约，该函数反过来简单地将其所有余额转移给该函数的调用者。</p><p id="8560" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它的构造函数被标记为<code class="fe lt lu lv lw b">payable</code>，这样<code class="fe lt lu lv lw b">ProdigalContract</code>实例可以用非空余额初始化。尽管这个契约并不代表真实世界的用例，但关键思想是它在<code class="fe lt lu lv lw b">msg.sender</code>上调用<code class="fe lt lu lv lw b">transfer()</code>(即函数的调用者)。</p><p id="f90f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，从实度0.5开始，<code class="fe lt lu lv lw b">transfer()</code>只在<code class="fe lt lu lv lw b">address payable</code>上定义，请注意<code class="fe lt lu lv lw b">msg.sender</code>是如何被<em class="ls">隐式假定为</em>的。这正是漏洞所在。</p><p id="0cfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还要注意空的<code class="fe lt lu lv lw b">receive</code>，它允许<code class="fe lt lu lv lw b">ProdigalContract</code>的实例接收以太。</p><p id="9291" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，<code class="fe lt lu lv lw b">WithoutReceive</code>只是公开了一个函数<code class="fe lt lu lv lw b">triggerUnsafeTransfer()</code>，通过调用<code class="fe lt lu lv lw b">ProdigalContract</code>的<code class="fe lt lu lv lw b">drainBalance()</code>来触发不安全的资金转移。</p><p id="1f9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能已经注意到了使用<code class="fe lt lu lv lw b">payable(_address))</code>将<code class="fe lt lu lv lw b">address</code>转换为<code class="fe lt lu lv lw b">address payable</code>。我们将在本文的后面详细讨论这一点。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="a1b3" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">测试合同</h1><p id="b1ee" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">要了解这些合同的行为，您必须采取以下步骤:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/6531d13130106361cdc70ce5437f9967.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*d5mkI766iMQrKxAN6CSHPg.png"/></div></figure><ol class=""><li id="c003" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr ob ni nj nk bi translated">使用Remix编译它们。</li><li id="89c4" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr ob ni nj nk bi translated">部署<code class="fe lt lu lv lw b">ProdigalContract</code>和<code class="fe lt lu lv lw b">WithoutReceive</code>的实例。</li><li id="82cb" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr ob ni nj nk bi translated">复制<code class="fe lt lu lv lw b">ProdigalContract</code>实例的地址(通过点击灰色框中的复制图标)并粘贴到橙色按钮<code class="fe lt lu lv lw b">“triggerUnsafeTransfer”</code>旁边(确保将地址放在双引号中)。</li><li id="9b7d" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr ob ni nj nk bi translated">点击<code class="fe lt lu lv lw b">triggerUnsafeTransfer</code>。</li></ol><p id="37d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">页面底部是事务日志。运行函数<code class="fe lt lu lv lw b">triggerUnsafeTransfer()</code>后，您将看到交易失败，并显示类似下图的错误信息:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/463f049cc0e311d4189dba5c3bf888a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0w-5kzztnVXDTG2vayq1g.png"/></div></div></figure><p id="1f28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着Solidity的运行时试图运行该函数，但失败了。这是因为<code class="fe lt lu lv lw b">ProdigalContract</code>试图给<code class="fe lt lu lv lw b">WithoutReceive</code>汇款，但是转账没有成功，因为后一个合同没有定义<code class="fe lt lu lv lw b">receive</code>也没有定义<code class="fe lt lu lv lw b">payable</code> <code class="fe lt lu lv lw b">fallback</code>。</p><p id="f92a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使事务将被正确地回滚，启动它的帐户将丢失相当于矿工消耗的汽油量的乙醚。在这个例子中，这个数字很低，但是在真实的用例中，这个数字可能会更高。</p><p id="d028" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的主要问题是，Solidity的编译器没有试图将对<code class="fe lt lu lv lw b">drainBalance()</code>的调用标记为不正确，因为它没有关于该函数的主体将做什么的任何有价值的信息。</p><p id="633f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仔细看看，这个问题依赖于这样一个事实:对<code class="fe lt lu lv lw b">msg.sender</code>的使用没有进行类型检查，因此，在运行时可能会出现类型错误，导致事务失败。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="ab41" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">与“外部世界”的融合</h1><p id="bb4b" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">最后一点，在函数<code class="fe lt lu lv lw b">triggerUnsafeTransfer</code>中，我们必须使用<code class="fe lt lu lv lw b">payable(_address)</code>从一个简单的<code class="fe lt lu lv lw b">address</code>中检索一个<code class="fe lt lu lv lw b">ProdigalContract</code>的实例。</p><p id="0681" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们只写了<code class="fe lt lu lv lw b">ProdigalContract(_address)</code>，编译器会给我们一个错误:</p><pre class="kg kh ki kj gt nq lw nr ns aw nt bi"><span id="6c97" class="nu mf iq lw b gy nv nw l nx ny">Type Error: Explicit type conversion not allowed from non-payable “address” to “contract ProdigalContract”, which has a payable fallback function.</span></pre><p id="7202" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">发生这种情况是因为编译器检测到<code class="fe lt lu lv lw b">ProdigalContract</code>定义了<code class="fe lt lu lv lw b">receive</code>，并强迫程序员使用<code class="fe lt lu lv lw b">payable address</code> es而不是“普通的”<code class="fe lt lu lv lw b">address</code> es来引用它。</p><p id="1110" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，下面的函数也可以使用(<code class="fe lt lu lv lw b">_address</code>是参数表中给定的类型<code class="fe lt lu lv lw b">address payable</code>):</p><pre class="kg kh ki kj gt nq lw nr ns aw nt bi"><span id="2036" class="nu mf iq lw b gy nv nw l nx ny">function triggerUnsafeTransfer(address payable _address) public {<br/>    ProdigalContract(_testAddress).drainBalance();<br/>}</span></pre><p id="87b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这告诉我们，当使用简单的<code class="fe lt lu lv lw b">address</code>而不是<code class="fe lt lu lv lw b">payable</code>时，编译器能够以某种方式检测到，但是，从上一节我们看到的情况来看，当涉及到资金转移时，它不会强制执行这种区分。</p><p id="e637" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更糟糕的是，当使用<code class="fe lt lu lv lw b">payable()</code>将<code class="fe lt lu lv lw b">address</code>转换为<code class="fe lt lu lv lw b">payable address</code>时，它不执行任何类型检查，即使它们是两种完全不同的类型。</p><p id="1b45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种显式强制转换已经在Solidity 0.6中添加，但它抛弃了Solidity 0.5在类型安全方面取得的所有(微小)进展。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="56ad" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">一个可能的解决方案</h1><p id="7897" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">解决这个问题并不容易。Solidity中的编译模型使得编译器很难精确地知道我们在应用程序中使用的契约的实际接口。</p><p id="30b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，地址通常作为参数出现在函数调用中，这使得问题更加复杂。</p><p id="908d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为这个问题不能只从内部解决。然而，后者能做的是给<code class="fe lt lu lv lw b">address</code> es赋予类型，使契约的界面更丰富，更容易交互。</p><p id="8345" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，<code class="fe lt lu lv lw b">address&lt;C&gt;</code>类型的值可能被保证(由编译器本身)引用契约<code class="fe lt lu lv lw b">C</code>的一个实例。这有助于程序员准确地知道在上面做什么是安全的。</p><p id="d76e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b">address payable</code>就是这样一个例子。如果它的约束得到适当的保证，它可以是引用与<code class="fe lt lu lv lw b">receive</code>或<code class="fe lt lu lv lw b">payable</code> <code class="fe lt lu lv lw b">fallback</code>的合同的所有地址的类型。</p><p id="8811" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个例子可以通过查看函数<code class="fe lt lu lv lw b">triggerUnsafeContract()</code>来完成。因为我们使用传入地址来检索<code class="fe lt lu lv lw b">ProdigalContract</code>的实例，所以参数<code class="fe lt lu lv lw b">_address</code>的类型可以是<code class="fe lt lu lv lw b">address&lt;ProdigalContract&gt;</code>，而不仅仅是<code class="fe lt lu lv lw b">address</code>。</p><p id="315a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，外部库应该检查它们提供给智能契约的地址是否满足这些约束。这在编译时可能很难做到，但在将事务发送到目标智能合约之前，可以在运行时完成。</p><p id="6c12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个完全不同的问题，需要一篇专门的文章来更详细地探讨它。如果你很好奇，可以在这里找到更多信息:<a class="ae kv" href="https://arxiv.org/pdf/1907.02952" rel="noopener ugc nofollow" target="_blank"> Solidity 0.5:当类型化不代表类型安全</a>。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="8277" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">结论</h1><p id="8c10" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">尽管Solidity声称是类型安全的，但本文中的例子表明编译器仍然无法实施与类型<code class="fe lt lu lv lw b">address</code>和<code class="fe lt lu lv lw b">address payable</code>相关的约束。</p><p id="0e93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，<code class="fe lt lu lv lw b">address</code>和<code class="fe lt lu lv lw b">address payable</code>之间的区别，以及<code class="fe lt lu lv lw b">receive</code>和<code class="fe lt lu lv lw b">fallback</code>之间的区别，应该有助于程序员写出更好、更容易理解的代码。</p><p id="3659" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这些构造的语义有时是混乱的，并不是微不足道的，可能会导致难以发现和修复的错误。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="39be" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">参考资料和进一步阅读</h1><ul class=""><li id="6af7" class="nc nd iq ky b kz mw lc mx lf od lj oe ln of lr nh ni nj nk bi translated">坚实度0.5 <a class="ae kv" href="https://solidity.readthedocs.io/en/v0.5.0/050-breaking-changes.html" rel="noopener ugc nofollow" target="_blank">突破变化</a>。</li><li id="6b86" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">实度0.6 <a class="ae kv" href="https://solidity.readthedocs.io/en/v0.6.1/060-breaking-changes.html" rel="noopener ugc nofollow" target="_blank">破变</a>。</li><li id="6b63" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">坚固性0.5: <a class="ae kv" href="https://arxiv.org/pdf/1907.02952" rel="noopener ugc nofollow" target="_blank">当被类型化并不意味着类型安全</a>。</li></ul></div></div>    
</body>
</html>