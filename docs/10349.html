<html>
<head>
<title>ES2022 Preview: 10 Exciting JavaScript Language Features From 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2022预览版:2021年的10个激动人心的JavaScript语言特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/es2022-preview-10-exciting-javascript-language-features-from-2021-679bebd6d6ae?source=collection_archive---------4-----------------------#2021-12-30">https://betterprogramming.pub/es2022-preview-10-exciting-javascript-language-features-from-2021-679bebd6d6ae?source=collection_archive---------4-----------------------#2021-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4a85" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">顶级await、RegExp等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bce17bd307577f0de6a13942796095f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kinWS9VUmmXC7-No"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@nebe3etogo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼尔·阿克谢诺夫</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="dd7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript发展很快。在2021年，几个<a class="ae kv" href="https://www.proposals.es/" rel="noopener ugc nofollow" target="_blank">提案</a>已经移动到<a class="ae kv" href="https://tc39.es/process-document/" rel="noopener ugc nofollow" target="_blank"> TC39流程</a>的第4阶段，并将包含在ES2022中。他们给JavaScript增加了以下特性:</p><h2 id="4655" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">类和实例</strong></h2><ul class=""><li id="9ea0" class="ml mm iq ky b kz mn lc mo lf mp lj mq ln mr lr ms mt mu mv bi translated">私有实例字段、方法和访问器</li><li id="6c72" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">私有字段的存在性检查</li><li id="ca15" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">公共静态类字段</li><li id="07fc" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">私有静态类字段和方法</li><li id="c124" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">静态类初始化块</li></ul><h2 id="33f7" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">模块加载</strong></h2><ul class=""><li id="bd31" class="ml mm iq ky b kz mn lc mo lf mp lj mq ln mr lr ms mt mu mv bi translated">顶级<code class="fe nb nc nd ne b">await</code></li></ul><h2 id="9789" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">内置物体</strong></h2><ul class=""><li id="7463" class="ml mm iq ky b kz mn lc mo lf mp lj mq ln mr lr ms mt mu mv bi translated">错误:<code class="fe nb nc nd ne b">.cause</code></li><li id="c87c" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">数组、字符串和类型数组:<code class="fe nb nc nd ne b">.at()</code></li><li id="d23b" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">对象:<code class="fe nb nc nd ne b">.hasOwn()</code></li><li id="8e19" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">正则表达式:匹配<code class="fe nb nc nd ne b">.indices</code> (' <code class="fe nb nc nd ne b">d</code>'标志)</li></ul><p id="d140" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇博客文章描述了每个功能，展示了如何使用它的示例，并查看了当前的浏览器和Node.js支持(截至2021年12月)。让我们开始吧。</p><h1 id="1166" class="nf lt iq bd lu ng nh ni lx nj nk nl ma jw nm jx md jz nn ka mg kc no kd mj np bi translated">私有实例字段、方法和访问器</h1><p id="0170" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">封装是面向对象编程的核心原则之一。它通常使用可见性修饰符来实现，如<code class="fe nb nc nd ne b">private</code>或<code class="fe nb nc nd ne b">public</code>。</p><p id="2026" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">私有实例字段、方法和访问器特性[ <a class="ae kv" href="https://github.com/tc39/proposal-class-fields" rel="noopener ugc nofollow" target="_blank"> 1 </a>、<a class="ae kv" href="https://github.com/tc39/proposal-private-methods" rel="noopener ugc nofollow" target="_blank"> 2 </a> ]为JavaScript增加了硬性可见性限制。前缀<code class="fe nb nc nd ne b">#</code>将类中的字段、方法或访问器标记为私有，这意味着您不能从实例本身之外访问它。</p><p id="759c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个私有字段和方法的例子；访问器的工作方式类似:</p><pre class="kg kh ki kj gt nt ne nu nv aw nw bi"><span id="bc1e" class="ls lt iq ne b gy nx ny l nz oa">class Example {<br/>  #value;</span><span id="4e5b" class="ls lt iq ne b gy ob ny l nz oa">  constructor(value) {<br/>    this.#value = value;<br/>  }</span><span id="0c56" class="ls lt iq ne b gy ob ny l nz oa">  #calc() {<br/>    return this.#value * 10;<br/>  }</span><span id="9eb4" class="ls lt iq ne b gy ob ny l nz oa">  print() {<br/>    console.log(this.#calc());<br/>  }<br/>}</span><span id="322e" class="ls lt iq ne b gy ob ny l nz oa">const object = new Example(5);<br/>console.log(object.#value);    // SyntaxError<br/>console.log(object.#calc());   // SyntaxError<br/>object.print();                // 50</span></pre><p id="08d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://caniuse.com/mdn-javascript_classes_private_class_fields" rel="noopener ugc nofollow" target="_blank">大多数浏览器</a>(2021年12月使用率:~90%)和Node.js 12+都支持私有实例字段。在浏览器中<a class="ae kv" href="https://caniuse.com/mdn-javascript_classes_private_class_methods" rel="noopener ugc nofollow" target="_blank">对私有方法和访问器的支持更加有限</a>(2021年12月使用率:~80%)。Node.js从14.6版本开始支持该特性。你可以<a class="ae kv" href="https://blog.saeloun.com/2021/06/24/babel-enables-class-field-and-private-methods.html" rel="noopener ugc nofollow" target="_blank">用Babel </a>传输你的代码，在不直接支持私有类字段和方法的环境中使用它们。</p><h1 id="12a4" class="nf lt iq bd lu ng nh ni lx nj nk nl ma jw nm jx md jz nn ka mg kc no kd mj np bi translated">私有字段的存在性检查</h1><p id="95a1" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">因为试图访问一个对象上不存在的私有字段会抛出异常，所以需要能够检查一个对象是否有给定的私有字段。<code class="fe nb nc nd ne b"><a class="ae kv" href="https://github.com/tc39/proposal-private-fields-in-in" rel="noopener ugc nofollow" target="_blank">in</a></code> <a class="ae kv" href="https://github.com/tc39/proposal-private-fields-in-in" rel="noopener ugc nofollow" target="_blank">操作符可用于检查对象</a>上的私有字段是否可用:</p><pre class="kg kh ki kj gt nt ne nu nv aw nw bi"><span id="0948" class="ls lt iq ne b gy nx ny l nz oa">class Example {<br/>  #field</span><span id="164b" class="ls lt iq ne b gy ob ny l nz oa">  static isExampleInstance(object) {<br/>    return #field in object;<br/>  }<br/>}</span></pre><p id="d90c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于在私有字段上使用 <code class="fe nb nc nd ne b"><a class="ae kv" href="https://caniuse.com/mdn-javascript_classes_private_class_fields_in" rel="noopener ugc nofollow" target="_blank">in</a></code> <a class="ae kv" href="https://caniuse.com/mdn-javascript_classes_private_class_fields_in" rel="noopener ugc nofollow" target="_blank">操作符的</a><a class="ae kv" href="https://caniuse.com/mdn-javascript_classes_private_class_fields_in" rel="noopener ugc nofollow" target="_blank">浏览器支持是有限的(2021年12月使用率:~70%)。Node.js从16.4版开始支持该功能。您可以通过</a>为私有字段 <code class="fe nb nc nd ne b"><a class="ae kv" href="https://babeljs.io/docs/en/babel-plugin-proposal-private-property-in-object" rel="noopener ugc nofollow" target="_blank">in</a></code> <a class="ae kv" href="https://babeljs.io/docs/en/babel-plugin-proposal-private-property-in-object" rel="noopener ugc nofollow" target="_blank">操作符</a><a class="ae kv" href="https://babeljs.io/docs/en/babel-plugin-proposal-private-property-in-object" rel="noopener ugc nofollow" target="_blank">传递文件用法。</a></p><h1 id="019d" class="nf lt iq bd lu ng nh ni lx nj nk nl ma jw nm jx md jz nn ka mg kc no kd mj np bi translated">公共静态类字段</h1><p id="67b4" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/tc39/proposal-static-class-features#static-public-fields" rel="noopener ugc nofollow" target="_blank">静态类字段</a>是向类对象添加属性的一种方便的符号。</p><pre class="kg kh ki kj gt nt ne nu nv aw nw bi"><span id="04fd" class="ls lt iq ne b gy nx ny l nz oa">// without static class fields:<br/>class Customer {<br/>  // ...<br/>}<br/>Customer.idCounter = 1;</span><span id="5f6e" class="ls lt iq ne b gy ob ny l nz oa">// with static class fields:<br/>class Customer {<br/>  static idCounter = 1;<br/>  // ...<br/>}</span></pre><p id="f625" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://caniuse.com/mdn-javascript_classes_static_class_fields" rel="noopener ugc nofollow" target="_blank">大部分浏览器</a>(2021年12月使用率:~90%)和Node.js 12+都支持公共类字段。</p><h1 id="b458" class="nf lt iq bd lu ng nh ni lx nj nk nl ma jw nm jx md jz nn ka mg kc no kd mj np bi translated">私有静态类字段和方法</h1><p id="9605" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">与私有实例字段和方法类似，封装和可见性限制在类级别上是有帮助的。<a class="ae kv" href="https://github.com/tc39/proposal-static-class-features" rel="noopener ugc nofollow" target="_blank">私有静态方法和字段特性</a>使用<code class="fe nb nc nd ne b">#</code>前缀为类级别的字段和方法添加了硬可见性限制。</p><pre class="kg kh ki kj gt nt ne nu nv aw nw bi"><span id="731f" class="ls lt iq ne b gy nx ny l nz oa">class Customer {<br/>  static #idCounter = 1; // static private</span><span id="cdb4" class="ls lt iq ne b gy ob ny l nz oa">  static #getNextId() { // static private<br/>    return Customer.#idCounter++;<br/>  }</span><span id="4741" class="ls lt iq ne b gy ob ny l nz oa">  #id; // instance private</span><span id="5ed1" class="ls lt iq ne b gy ob ny l nz oa">  constructor() {<br/>    this.#id = Customer.#getNextId();<br/>  }</span><span id="d740" class="ls lt iq ne b gy ob ny l nz oa">  toString() {<br/>    return `c${this.#id}`;<br/>  }<br/>}</span><span id="d777" class="ls lt iq ne b gy ob ny l nz oa">const customers = [new Customer(), new Customer()];<br/>console.log(customers.join(' ')); // c1 c2</span></pre><p id="63dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">浏览器和Node.js支持类似于上面的私有实例字段和方法。</p><h1 id="c149" class="nf lt iq bd lu ng nh ni lx nj nk nl ma jw nm jx md jz nn ka mg kc no kd mj np bi translated">静态类初始化块</h1><p id="259b" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">有时对静态类字段进行更复杂的初始化工作是必要的或方便的。对于上面的私有静态字段特性，这种初始化甚至必须发生在类内部，因为私有字段不可访问。</p><p id="ef9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/tc39/proposal-class-static-block" rel="noopener ugc nofollow" target="_blank">静态初始化块特性</a>提供了一种在类定义评估期间执行代码的机制。初始化类时，执行带有<code class="fe nb nc nd ne b">static</code>关键字的块语句中的代码:</p><pre class="kg kh ki kj gt nt ne nu nv aw nw bi"><span id="87ed" class="ls lt iq ne b gy nx ny l nz oa">class Example {<br/>  static propertyA;<br/>  static #propertyB; // private</span><span id="50b8" class="ls lt iq ne b gy ob ny l nz oa">  static { // static initializer block<br/>    try {<br/>      const json = JSON.parse(fs.readFileSync('example.json', 'utf8'));<br/>      this.propertyA = json.someProperty;<br/>      this.#propertyB = json.anotherProperty;<br/>    } catch (error) {<br/>      this.propertyA = 'default1';<br/>      this.#propertyB = 'default2';<br/>    }<br/>  }</span><span id="6aea" class="ls lt iq ne b gy ob ny l nz oa">  static print() {<br/>    console.log(Example.propertyA);<br/>    console.log(Example.#propertyB);<br/>  }<br/>}</span><span id="9812" class="ls lt iq ne b gy ob ny l nz oa">Example.print();</span></pre><p id="1a9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://caniuse.com/mdn-javascript_classes_static_initialization_blocks" rel="noopener ugc nofollow" target="_blank">浏览器对静态类初始化块</a>的支持是有限的(2021年12月:~70%)。Node.js从16.4版开始支持该功能。你可以<a class="ae kv" href="https://babeljs.io/docs/en/babel-plugin-proposal-class-static-block" rel="noopener ugc nofollow" target="_blank">用Babel </a>用静态初始化器块传输代码。</p><h1 id="91bf" class="nf lt iq bd lu ng nh ni lx nj nk nl ma jw nm jx md jz nn ka mg kc no kd mj np bi translated">顶级等待</h1><p id="7150" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">ES2017中引入了异步函数和<code class="fe nb nc nd ne b">await</code>关键字，以简化承诺的处理。然而，<code class="fe nb nc nd ne b">await</code>只能在<code class="fe nb nc nd ne b">async</code>函数内部使用。</p><p id="c55e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ES模块的<a class="ae kv" href="https://github.com/tc39/proposal-top-level-await" rel="noopener ugc nofollow" target="_blank">顶级</a> <code class="fe nb nc nd ne b"><a class="ae kv" href="https://github.com/tc39/proposal-top-level-await" rel="noopener ugc nofollow" target="_blank">await</a></code> <a class="ae kv" href="https://github.com/tc39/proposal-top-level-await" rel="noopener ugc nofollow" target="_blank">特性使得在CLI脚本中使用<code class="fe nb nc nd ne b">await</code>(例如，使用<code class="fe nb nc nd ne b">.mjs</code>源和</a><a class="ae kv" href="https://github.com/google/zx" rel="noopener ugc nofollow" target="_blank"> zx </a>)以及动态导入和数据加载变得非常容易。它将<code class="fe nb nc nd ne b">await</code>功能扩展到模块加载器中，这意味着从属模块将等待异步模块(带有顶级<code class="fe nb nc nd ne b">await</code>)被加载。</p><p id="069f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个例子:</p><pre class="kg kh ki kj gt nt ne nu nv aw nw bi"><span id="ccdf" class="ls lt iq ne b gy nx ny l nz oa">// load-attribute.mjs <br/>// with top-level await<br/>const data = await (await fetch("https://some.url")).text();<br/>export const attribute = JSON.parse(data).someAttribute;</span><span id="8e55" class="ls lt iq ne b gy ob ny l nz oa">// main.mjs <br/>// loaded after load-attribute.mjs is fully loaded<br/>// and its exports are available<br/>import { attribute } from "./load-attribute.mjs";<br/>console.log(attribute);</span></pre><p id="5da9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顶级await是现代浏览器(2021年12月使用率:~80%)和Node.js 14.8+支持的<a class="ae kv" href="https://caniuse.com/mdn-javascript_operators_await_top_level" rel="noopener ugc nofollow" target="_blank">。它只适用于ES模块，而且CommonJS模块是否会得到顶级的await支持也是个疑问。带有顶层<code class="fe nb nc nd ne b">await</code>的代码可以在捆绑阶段进行传输，以支持更老的浏览器，比如</a><a class="ae kv" href="https://webpack.js.org/configuration/experiments/" rel="noopener ugc nofollow" target="_blank"> Webpack 5 </a> <code class="fe nb nc nd ne b"><a class="ae kv" href="https://webpack.js.org/configuration/experiments/" rel="noopener ugc nofollow" target="_blank">experiments.topLevelAwait = true</a></code>。</p><h1 id="d4bb" class="nf lt iq bd lu ng nh ni lx nj nk nl ma jw nm jx md jz nn ka mg kc no kd mj np bi translated">错误:。原因</h1><p id="82a1" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">错误通常被包装以提供有意义的消息并记录错误上下文。然而，这意味着原始错误可能会丢失。出于日志记录和调试目的，需要将原始错误附加到包装错误上。</p><p id="54f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/tc39/proposal-error-cause" rel="noopener ugc nofollow" target="_blank">错误原因特性</a>提供了一种将原始错误附加到包装错误的标准化方法。它向<code class="fe nb nc nd ne b">Error</code>构造函数添加了<code class="fe nb nc nd ne b">cause</code>选项，并添加了一个用于检索原始错误的<code class="fe nb nc nd ne b">cause</code>字段。</p><pre class="kg kh ki kj gt nt ne nu nv aw nw bi"><span id="9741" class="ls lt iq ne b gy nx ny l nz oa">const load = async (userId) =&gt; {<br/>  try {<br/>    return await fetch(`https://service/api/user/${userId}`);<br/>  } catch (error) {<br/>    throw new Error(<br/>      `Loading data for user with id ${userId} failed`, <br/>      { cause: error }<br/>    );<br/>  }<br/>}</span><span id="432d" class="ls lt iq ne b gy ob ny l nz oa">try {<br/>  const userData = await load(3);<br/>  // ...<br/>} catch (error) {<br/>  console.log(error); // Error: Loading data for user with id 3 failed<br/>  console.log(error.cause); // TypeError: Failed to fetch<br/>}</span></pre><p id="2de1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当前浏览器对错误子句功能的支持是有限的(2021年12月使用率:~70%)。Node.js从16.9版本开始支持该功能。您可以使用<a class="ae kv" href="https://github.com/es-shims/error-cause" rel="noopener ugc nofollow" target="_blank">错误导致polyfill </a>立即开始使用该功能，即使在不支持该功能的JS环境中。</p><h1 id="ec39" class="nf lt iq bd lu ng nh ni lx nj nk nl ma jw nm jx md jz nn ka mg kc no kd mj np bi translated">数组、字符串和类型数组:。在()</h1><p id="6efc" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">从数组或字符串的末尾获取元素通常需要从数组的长度中减去，例如，<code class="fe nb nc nd ne b">let lastElement = anArray[anArray.length - 1]</code>。这要求数组存储在临时变量中，并防止无缝链接。</p><p id="4d73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nb nc nd ne b"><a class="ae kv" href="https://github.com/tc39/proposal-relative-indexing-method" rel="noopener ugc nofollow" target="_blank">.at()</a></code> <a class="ae kv" href="https://github.com/tc39/proposal-relative-indexing-method" rel="noopener ugc nofollow" target="_blank">特性</a>提供了一种在没有临时变量的情况下从字符串或数组的开头(正索引)或结尾(负索引)获取元素的方法。</p><pre class="kg kh ki kj gt nt ne nu nv aw nw bi"><span id="6cf8" class="ls lt iq ne b gy nx ny l nz oa">const getExampleValue = () =&gt; 'abcdefghi';</span><span id="babf" class="ls lt iq ne b gy ob ny l nz oa">console.log(getExampleValue().at(2));    // c<br/>console.log(getExampleValue()[2]);       // c</span><span id="4951" class="ls lt iq ne b gy ob ny l nz oa">const temp = getExampleValue();<br/>console.log(temp[temp.length - 2]);      // h<br/>console.log(getExampleValue().at(-2));   // h - no temp var needed</span></pre><p id="4e8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://caniuse.com/mdn-javascript_builtins_array_at" rel="noopener ugc nofollow" target="_blank">浏览器对。at特性</a>目前受限(2021年12月使用率:~70%)，仅在Node.js 16.6+中可用。可以用<a class="ae kv" href="https://github.com/zloirock/core-js#relative-indexing-method" rel="noopener ugc nofollow" target="_blank">。同时在()polyfill从核心JS </a>开始。</p><h1 id="8185" class="nf lt iq bd lu ng nh ni lx nj nk nl ma jw nm jx md jz nn ka mg kc no kd mj np bi translated">对象:。hasOwn()</h1><p id="6bab" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated"><code class="fe nb nc nd ne b"><a class="ae kv" href="https://github.com/tc39/proposal-accessible-object-hasownproperty" rel="noopener ugc nofollow" target="_blank">Object.hasOwn</a></code> <a class="ae kv" href="https://github.com/tc39/proposal-accessible-object-hasownproperty" rel="noopener ugc nofollow" target="_blank">特性</a>是一种更简洁、更健壮的检查属性是否直接在对象上设置的方法。这是使用<code class="fe nb nc nd ne b">hasOwnProperty</code>的首选替代方案:</p><pre class="kg kh ki kj gt nt ne nu nv aw nw bi"><span id="50ea" class="ls lt iq ne b gy nx ny l nz oa">const example = {<br/>  property: '123'<br/>};</span><span id="3c6e" class="ls lt iq ne b gy ob ny l nz oa">console.log(Object.prototype.hasOwnProperty.call(example, 'property'));<br/>console.log(Object.hasOwn(example, 'property')); // preferred</span></pre><p id="679e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://caniuse.com/mdn-javascript_builtins_object_hasown" rel="noopener ugc nofollow" target="_blank">浏览器支持目前有限</a>(2021年12月使用率:~70%)，需要Node 16.9+才能直接使用<code class="fe nb nc nd ne b">hasOwn</code>。同时， <code class="fe nb nc nd ne b"><a class="ae kv" href="https://github.com/zloirock/core-js/#accessible-objectprototypehasownproperty" rel="noopener ugc nofollow" target="_blank">hasOwn</a></code>有一个<a class="ae kv" href="https://github.com/zloirock/core-js/#accessible-objectprototypehasownproperty" rel="noopener ugc nofollow" target="_blank">核心JS polyfill。</a></p><h1 id="a4c6" class="nf lt iq bd lu ng nh ni lx nj nk nl ma jw nm jx md jz nn ka mg kc no kd mj np bi translated">RegExp:匹配索引(' d '标志)</h1><p id="eee9" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">默认情况下，正则表达式匹配记录匹配文本的开始索引，但不记录其结束索引，也不记录其捕获组的开始和结束索引。对于文本编辑器语法或搜索结果突出显示等用例，将捕获组匹配索引作为正则表达式匹配的一部分会很有帮助。</p><p id="ae4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<a class="ae kv" href="https://github.com/tc39/proposal-regexp-match-indices" rel="noopener ugc nofollow" target="_blank">正则表达式匹配索引特性(‘d’标志)</a>，匹配和捕获组索引在正则表达式结果的<code class="fe nb nc nd ne b">indices</code>数组属性中可用。<br/>匹配文本位置和匹配索引位置是相同的，例如，完全匹配的文本是匹配数组和索引数组中的第一个值。命名的捕获组的索引记录在<code class="fe nb nc nd ne b">indices.groups</code>中。</p><p id="d934" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个例子:</p><pre class="kg kh ki kj gt nt ne nu nv aw nw bi"><span id="20f6" class="ls lt iq ne b gy nx ny l nz oa">const text = "Let's match one:1.";<br/>const regexp = /match\s(?&lt;word&gt;\w+):(?&lt;digit&gt;\d)/gd;</span><span id="9917" class="ls lt iq ne b gy ob ny l nz oa">for (const match of text.matchAll(regexp)) {<br/>    console.log(match);<br/>}</span></pre><p id="6426" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的示例代码有以下输出:</p><pre class="kg kh ki kj gt nt ne nu nv aw nw bi"><span id="e81d" class="ls lt iq ne b gy nx ny l nz oa">[<br/>  'match one:1',<br/>  'one',<br/>  '1',<br/>  index: 6,<br/>  input: "Let's match one:1.",<br/>  groups: { word: 'one', digit: '1' },<br/>  indices: {<br/>    0: [6,17],<br/>    1: [12,15],<br/>    2: [16,17],<br/>    groups: { <br/>      digit: [16, 17],<br/>      word: [12, 15]<br/>    }<br/>  }<br/>]</span></pre><p id="d10f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于RegExp匹配索引特性的<a class="ae kv" href="https://caniuse.com/mdn-javascript_builtins_regexp_hasindices" rel="noopener ugc nofollow" target="_blank">浏览器支持目前是有限的</a>(2021年12月使用率:~80%)。在Node.js中，可以用<code class="fe nb nc nd ne b">--harmony-regexp-match-indices</code>标志激活这个特性，但是默认情况下是禁用的。您可以同时使用<a class="ae kv" href="https://github.com/rbuckton/regexp-match-indices" rel="noopener ugc nofollow" target="_blank"> RegExp匹配索引polyfill </a>。</p><h1 id="8aba" class="nf lt iq bd lu ng nh ni lx nj nk nl ma jw nm jx md jz nn ka mg kc no kd mj np bi translated">结论</h1><p id="5e5f" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">来自2021的新JavaScript特性有助于使开发更加方便和健壮，其中大多数已经可以在最新的浏览器和Node.js环境中工作。</p><p id="101c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，许多用户仍然使用不完全支持ES2022的浏览器和环境。对于生产使用，检查目标环境并根据需要使用polyfilling和transpiling，或者在使用新功能之前等待一段时间，这是非常重要的。</p><p id="a9bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2022年编码快乐！</p></div></div>    
</body>
</html>