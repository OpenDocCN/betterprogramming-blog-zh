# 用自定义挂钩来响应可重用的 API 调用

> 原文：<https://betterprogramming.pub/react-reusable-api-calls-with-custom-hooks-typescript-obviously-a62fda7df1b6>

## 显然使用了 Typescript

![](img/6580294db72c2c037bc771f1b9b92475.png)

由[塔蒂亚娜·罗德里格斯](https://unsplash.com/@tata186?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

目录:

*   [什么是 HTTP 方法(简单看一下 POST 和 GET)](#c71e)
*   [什么是自定义挂钩？为什么是 Typescript？](#2af5)
*   [带 GET 的自定义挂钩](#d8d6)
*   [带立柱的定制挂钩](#923e)
*   结论:[上得到](#466a)，[最终结论](#48f1)

# 什么是 HTTP 方法？(快速简介)

HTTP 提供了一组方法，通过这些方法，web 浏览器可以与 web 服务器进行通信。有 4 种流行/众所周知的方法:GET、POST、PUT 和 DELETE。我们将在本文中讨论 GET 和 POST，但还有更多。

**GET** :顾名思义，被设计成一个安全的操作，从服务器中检索一些数据。

**POST:** 这个方法允许我们向服务器发送一些数据，例如，向数据库添加一个新的实体。

# **什么是自定义挂钩？为什么是 typescript？**

当 React 切换到功能组件时，它给了我们一些非常酷和强大的工具来构建逻辑、管理状态和设计 UI，变得更加容易和快速。所谓的钩子就是一些直接来自 React 库的特殊函数。有一个约定是，钩子必须以 use 前缀开始，这样它们就很容易被识别。

其中之一是`useState`，它帮助我们在重新呈现器之间保存动态数据。

另一个是`useEffect`，它允许我们执行副作用，比如调用 API、与本地存储交互、使用定时器(setInterval/setTimeout)等。

还有更多:`useCallback`、`useMemo`、`useRef`等。本文就不讨论了。

自定义钩子是我们创建的一个特殊函数，它利用 React 在其实现中提供的钩子。这种方法使得代码可以重用，并且对组件隐藏了逻辑，使得代码简洁，组件更容易阅读、理解和维护。

## 为什么要打字稿？

因为它提供了类型检查等功能，允许我们塑造一个对象，以便我们在处理变量时有一个更快更清晰的理解。它也有编译错误，所以我们可以在进入浏览器看到错误之前解决它们。

# 带有 GET 的自定义挂钩

正如我们前面看到的，GET 用于从服务器检索数据。在 React 中，这可以通过它最著名的两个钩子来实现:`useState`和`useEffect`。使用 useState，我们可以跟踪检索到的数据、任何潜在的错误，或者数据是否还在路上。使用`useEffect`,我们可以执行对服务器的实际调用。

看起来组件要处理很多逻辑。让我们在一个自定义钩子中提取它，使我们的代码变得干净。

让我们看看这里会发生什么。我们的定制钩子有两个参数:

*   实际查询字符串(`https://myserver/myroute`)
*   第二个是地图功能。它的目的是将服务器返回的 any 类型的原始对象从客户端塑造成我们的模型。这样做的一些好处是，我们可以利用 TS 特性，并且总是清楚地看到对象的属性；此外，可能从服务器返回的对象比我们实际需要的属性更多，或者它的结构略有不同。这里更有趣的是函数的返回类型，类型为`T`。这表示一个泛型类型，意味着当我们实际调用钩子时，函数必须返回一个我们指定类型的对象。注意函数(hook)定义中的`<T,>` ？这意味着我们的钩子是一个泛型函数。

我们可以在这里看到我们如何定义我们的模型和一个映射函数的例子:

接下来，我们看到定义了三个`useState`钩子。第一个表示将从服务器接收的数据。我们在这里可以再次看到泛型(T)类型。
第二个只是一个布尔值，用于标记数据是否仍在加载，最后一个将保存任何可能出现的潜在错误；无论是从服务器还是从我们下面的代码。

接下来，我们有了执行 API 调用的`useEffect`钩子。首先，我们将 loading 标志设置为 true，表示正在获取数据。然后我们打真正的电话。在调用之后，我们将数据映射到我们的形状，并将加载标志设置回 false，以指示调用已经结束。

如果出现任何错误，我们将设置错误消息并将标志恢复为 false。

最后，我们返回 3 个对象:数据、加载标志和错误。然后，在组件中，我们可以按以下方式使用它。如果加载标志为真，那么我们显示一些加载指示器。否则，如果我们有错误显示一些用户友好的错误信息。如果没有，我们可以愉快地显示数据。

# **获取自定义挂钩的结论**

这里有趣的是泛型类型和映射函数的使用。如果我们需要调用不同的 API，我们只需用特定的查询调用钩子，并实现映射数据的函数。

这是我们使用钩子的方法:

当然，上面钩子实现中的东西可以用不同的方式实现。状态可以被分组为一个而不是三个。我们可以验证响应状态并相应地返回内容，甚至可以使用错误处理程序回调。我们可以为 fetch 添加 options 参数。以此类推，让这篇文章的读者决定什么最适合自己的场景。

# 带立柱的定制挂钩

POST 的钩子设计和实现与 GET 略有不同，但不会太多。因为它发送一些数据，我们可以定义一个通过主体发送的数据模型。当然，它也可以有响应数据。

让我们讨论一下不同之处。

首先，我们现在有两个泛型类型:`BodyData`和`ResponseData`。`BodyData`用于整形需要发送到服务器的体对象，`ResponseData`用于整形来自服务器的响应数据。

这个钩子实现的另一个显著区别是使用了`useCallback`钩子而不是`useEffect`。这里，`useCallbacks`包装了 API 调用函数，我们的自定义钩子返回它。我们这样做是为了在自定义钩子返回的函数被传递给子组件的情况下记忆该函数，以防止无用的重新呈现，因为每次 React 组件重新呈现时，它的函数都会被重新创建。

现在我们可以在点击按钮时调用这个方法，例如，触发 POST 请求，当然，这也可以应用到 GET 钩子中。我们可以定义 fetch 函数，从我们的钩子中返回它，并在我们触发某个动作时调用它，而不是在组件呈现时调用它(`useEffect`)。

此外，我们还可以为头设置一个参数。

# **结论**

同样，这两个定制挂钩的实现可能会有所不同，并根据开发人员的需求进行改进。值得注意的是 TypeScript 和泛型类型的用法、映射系统、自定义钩子的用法，以及实现钩子的`useEffect`和`useCallback`方法之间的区别。你可以随意摆弄它。