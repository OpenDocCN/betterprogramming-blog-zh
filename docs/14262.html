<html>
<head>
<title>Create a Horizontal Picker View Using UICollectionView in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用iOS中的UICollectionView创建水平选取器视图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-simple-horizontal-picker-view-from-scratch-using-swift-5-on-ios-16-a25b1f194426?source=collection_archive---------9-----------------------#2022-11-22">https://betterprogramming.pub/create-a-simple-horizontal-picker-view-from-scratch-using-swift-5-on-ios-16-a25b1f194426?source=collection_archive---------9-----------------------#2022-11-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="69de" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Swift 5</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e462d20bcf81b8230866e1ee9540fb87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ihiRM8_hNfc-6MdlYux4cw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="4021" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于生活、自由职业、做副业项目<a class="ae lr" href="https://apps.apple.com/us/app/nossaflex/id1523558285" rel="noopener ugc nofollow" target="_blank"> NOSSAFLEX </a>，已经很久没有写过教程了。</p><p id="a326" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管如此，在我们的应用程序上工作需要我们的测光表有一个水平的选择器视图。</p><p id="08e3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我花了很长时间寻找创建水平拾取器的解决方案。我试着旋转UIPicker，但这非常不切实际，定制也受到限制。我试图寻找在线解决方案，但找不到任何有益的东西。我找到的最好答案是来自<a class="ae lr" href="https://iosacademy.io/" rel="noopener ugc nofollow" target="_blank"> iOS Academy </a>的<a class="ae lr" href="https://github.com/AfrazCodes/Swift-HorizontalPickerView" rel="noopener ugc nofollow" target="_blank"> AfrazCodes </a>。这个解决方案工作得很好，但是我需要一些更适合的东西，并且不使用滚动单元格分页。</p><p id="4f9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我用简单的水平选择器视图创建的解决方案的演示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="650f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我必须感谢我对AfrazCodes的解决方案。他的解决方案帮助我实现了我所需要的。</p><p id="ee45" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个解决方案很简单。它使用UICollectionView，不需要添加任何不明确的代码。</p><h2 id="5a95" class="lu lv iq bd lw lx ly dn lz ma mb dp mc le md me mf li mg mh mi lm mj mk ml mm bi translated"><strong class="ak">主要功能包括</strong></h2><ul class=""><li id="5535" class="mn mo iq kx b ky mp lb mq le mr li ms lm mt lq mu mv mw mx bi translated">单元格突出显示/选择</li><li id="7493" class="mn mo iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">使用函数调用滚动到一个单元格</li><li id="9f11" class="mn mo iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">带/不带集合减速的自动滚动视图</li><li id="63a0" class="mn mo iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">每个单元的完全定制</li></ul><p id="933a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">NOSSAFLEX设计要求选定的单元格左对齐，但我将在本教程中使选定的单元格居中。对于感兴趣的人，我将在本文末尾添加我在NOSSAFLEX中使用的代码，该代码允许我将选定的单元格靠左对齐。</p><p id="ce99" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你想下载这个项目，这里有一个到GitHub Repo的链接。</p><p id="44e2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们开始吧。</p><h1 id="e1c7" class="nd lv iq bd lw ne nf ng lz nh ni nj mc jw nk jx mf jz nl ka mi kc nm kd ml nn bi translated">先决条件</h1><p id="b8b0" class="pw-post-body-paragraph kv kw iq kx b ky mp jr la lb mq ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">本教程的一些先决条件是将<code class="fe nr ns nt nu b">UICollectionViewFlowLayout</code>滚动方向设置为. horizontal。</p><p id="4437" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe nr ns nt nu b">UICollectionViewCell</code>中，我有一个名为<code class="fe nr ns nt nu b">configure()</code>的公共函数。此功能将设置选定的单元格。</p><pre class="kg kh ki kj gt nv nu nw bn nx ny bi"><span id="3140" class="nz lv iq nu b be oa ob l oc od">public func configure(with title: String, isSelected: Bool = false) {<br/>    titleLabel.text = title<br/>    backgroundColor = isSelected ? .green : .darkGray<br/>}</span></pre><p id="22ab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果单元格被选中，我们将改变背景为<code class="fe nr ns nt nu b">.green</code>，否则，我们将设置为<code class="fe nr ns nt nu b">.darkGray</code>。</p><p id="cd29" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你正在跟踪我的回购，这是它目前的样子。只是一个简单的横<code class="fe nr ns nt nu b">collectionview</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="81c8" class="nd lv iq bd lw ne nf ng lz nh ni nj mc jw nk jx mf jz nl ka mi kc nm kd ml nn bi translated">选择功能</h1><p id="6f6b" class="pw-post-body-paragraph kv kw iq kx b ky mp jr la lb mq ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">让我们首先创建<code class="fe nr ns nt nu b">select()</code>函数。</p><p id="a2ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们需要一个变量来跟踪选中的<code class="fe nr ns nt nu b">IndexPath</code>。</p><pre class="kg kh ki kj gt nv nu nw bn nx ny bi"><span id="e685" class="nz lv iq nu b be oa ob l oc od">var selectedCellIndexPath: IndexPath?</span></pre><p id="d6af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们将实现<code class="fe nr ns nt nu b">select()</code>功能。以下是完整的解决方案:</p><pre class="kg kh ki kj gt nv nu nw bn nx ny bi"><span id="caea" class="nz lv iq nu b be oa ob l oc od">/// Scrolls to selected cell<br/>/// - Parameters:<br/>///   - row: row index<br/>///   - section: Section index<br/>///   - animated: Animated boolean<br/>public func select(<br/>    row: Int,<br/>    in section: Int = 0,<br/>    animated: Bool = true<br/>) {<br/>    // Ensures selected row isnt more then data count<br/>    guard row &lt; data.count else { return }<br/>    <br/>    // removes any selected item<br/>    cleanupSelection()<br/>    <br/>    // set new selected item<br/>    let indexPath = IndexPath(row: row, section: section)<br/>    selectedCellIndexPath = indexPath<br/>    <br/>    // Update selected cell<br/>    let cell = collectionView.cellForItem(at: indexPath) as? HorizontalPickerViewCell<br/>    cell?.configure(<br/>        with: data[indexPath.row],<br/>        isSelected: true<br/>    )<br/>    <br/>    collectionView.selectItem(<br/>        at: indexPath,<br/>        animated: animated,<br/>        scrollPosition: .centeredHorizontally)<br/>}</span></pre><p id="cf07" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是该函数的分解。</p><p id="f419" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们检查选择的<code class="fe nr ns nt nu b">row</code>是否小于数组中的<code class="fe nr ns nt nu b">data</code>的数量。</p><pre class="kg kh ki kj gt nv nu nw bn nx ny bi"><span id="563b" class="nz lv iq nu b be oa ob l oc od">// Ensures selected row isnt more then data count<br/>guard row &lt; data.count else { return }</span></pre><p id="3df3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将删除任何现有的选定行。</p><p id="8146" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来我们将讨论<code class="fe nr ns nt nu b">cleanUpSection()</code>函数。</p><pre class="kg kh ki kj gt nv nu nw bn nx ny bi"><span id="72cf" class="nz lv iq nu b be oa ob l oc od">// removes any selected item<br/>cleanupSelection()</span></pre><p id="38e3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们更新<code class="fe nr ns nt nu b">selectedCellIndexPath</code>变量并更新<code class="fe nr ns nt nu b">UICollectionView</code>中的单元格。</p><pre class="kg kh ki kj gt nv nu nw bn nx ny bi"><span id="a56f" class="nz lv iq nu b be oa ob l oc od">// set new selected item<br/>let indexPath = IndexPath(row: row, section: section)<br/>selectedCellIndexPath = indexPath<br/><br/>// Update selected cell<br/>let cell = collectionView.cellForItem(at: indexPath) as? HorizontalPickerViewCell<br/>cell?.configure(<br/>    with: data[indexPath.row],<br/>    isSelected: true<br/>)</span></pre><p id="5f79" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们滚动到该项目。</p><pre class="kg kh ki kj gt nv nu nw bn nx ny bi"><span id="89e7" class="nz lv iq nu b be oa ob l oc od">// Use this for horizontal centering<br/>collectionView.selectItem(<br/>        at: indexPath,<br/>        animated: animated,<br/>        scrollPosition: .centeredHorizontally)</span></pre><p id="6fb9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是<code class="fe nr ns nt nu b">cleanupSelection()</code>功能的解决方案。</p><pre class="kg kh ki kj gt nv nu nw bn nx ny bi"><span id="b34f" class="nz lv iq nu b be oa ob l oc od">/// Cleans up prior highlighted selection<br/>private func cleanupSelection() {<br/>    guard let indexPath = selectedCellIndexPath else { return }<br/>    let cell = collectionView.cellForItem(at: indexPath) as? HorizontalPickerViewCell<br/>    cell?.configure(with: data[indexPath.row])<br/>    selectedCellIndexPath = nil<br/>}</span></pre><p id="532b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该函数获取<code class="fe nr ns nt nu b">selectedCellIndexPath</code>变量，并将<code class="fe nr ns nt nu b">UICollectionView</code>中的单元格设置为false。</p><p id="58c5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们调用<code class="fe nr ns nt nu b">didSelect</code>委托函数中的<code class="fe nr ns nt nu b">select()</code>函数。</p><pre class="kg kh ki kj gt nv nu nw bn nx ny bi"><span id="1636" class="nz lv iq nu b be oa ob l oc od">func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {<br/>    select(row: indexPath.row)<br/>}</span></pre><p id="c358" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">运行应用程序并查看其运行情况。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="b178" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">目前，第一个和最后两个单元格不居中对齐。为了解决这个问题，我们需要添加insets。</p><pre class="kg kh ki kj gt nv nu nw bn nx ny bi"><span id="1d54" class="nz lv iq nu b be oa ob l oc od">func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -&gt; UIEdgeInsets {<br/>    let inset = view.frame.width/2 - (cellWidth/2)<br/>    return UIEdgeInsets(<br/>        top: 0,<br/>        left: inset,<br/>        bottom: 0,<br/>        right: inset<br/>    )<br/>}</span></pre><p id="416b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了使单元格的边缘居中，我们需要得到视图宽度的一半，然后减去单元格宽度的一半。现在，当我们运行应用程序时，所有单元格都可以滚动到中心。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="ca61" class="nd lv iq bd lw ne nf ng lz nh ni nj mc jw nk jx mf jz nl ka mi kc nm kd ml nn bi translated">减速和滚动选择</h1><p id="2157" class="pw-post-body-paragraph kv kw iq kx b ky mp jr la lb mq ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">接下来，我们希望用户能够通过滚动来选择单元格。</p><p id="5075" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们要调用<code class="fe nr ns nt nu b">scrollViewDidEndDragging</code>和<code class="fe nr ns nt nu b">scrollViewDidEndDecelerating</code>。</p><p id="f122" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据苹果文件:</p><p id="67d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nr ns nt nu b"><a class="ae lr" href="https://developer.apple.com/documentation/uikit/uiscrollviewdelegate/1619436-scrollviewdidenddragging" rel="noopener ugc nofollow" target="_blank">scrollViewDidEndDragging</a> </code> —在滚动视图中告诉代理拖动何时结束。</p><p id="7a2b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nr ns nt nu b"><a class="ae lr" href="https://developer.apple.com/documentation/uikit/uiscrollviewdelegate/1619417-scrollviewdidenddecelerating" rel="noopener ugc nofollow" target="_blank">scrollViewDidEndDecelerating</a> </code> —告诉代表滚动视图结束，使滚动运动减速。</p><pre class="kg kh ki kj gt nv nu nw bn nx ny bi"><span id="a4bf" class="nz lv iq nu b be oa ob l oc od">func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {<br/>    // if decelerate doesnt occur, scrollToCell<br/>    if !decelerate {<br/>        scrollToCell()<br/>    } // else wait until decleration ends to scrollToCell<br/>}<br/><br/>func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {<br/>    // scroll to cell<br/>    scrollToCell()<br/>}</span></pre><p id="9f60" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这两个委托函数可以处理调用<code class="fe nr ns nt nu b">scrollToCell()</code>的用户交互。</p><p id="d225" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是<code class="fe nr ns nt nu b">scrollToCell().</code>的完整解决方案</p><pre class="kg kh ki kj gt nv nu nw bn nx ny bi"><span id="c59a" class="nz lv iq nu b be oa ob l oc od">/// Scrolls to visible cell based on `scrollViewDidEndDragging` or `scrollViewDidEndDecelerating` delegate functions<br/>private func scrollToCell() {<br/>    var indexPath = IndexPath()<br/>    var visibleCells = collectionView.visibleCells<br/>    <br/>    /// Gets visible cells<br/>    visibleCells = visibleCells.filter({ cell -&gt; Bool in<br/>        <br/>        let cellRect = collectionView.convert(<br/>            cell.frame,<br/>            to: collectionView.superview<br/>        )<br/>        /// Calculate if at least 50% of the cell is in the boundaries we created<br/>        let viewMidX = view.frame.midX<br/>        let cellMidX = cellRect.midX<br/>        let topBoundary = viewMidX + cellRect.width/2<br/>        let bottomBoundary = viewMidX - cellRect.width/2<br/>        <br/>        /// A print state representating what the return is calculating<br/>        print("topboundary: \(topBoundary) &gt; cellMidX: \(cellMidX) &gt; Bottom Boundary: \(bottomBoundary)")<br/>        return topBoundary &gt; cellMidX  &amp;&amp; cellMidX &gt; bottomBoundary<br/>    })<br/>    <br/>    /// Appends visible cell index to `cellIndexPath`<br/>    visibleCells.forEach({<br/>        if let selectedIndexPath = collectionView.indexPath(for: $0) {<br/>            indexPath = selectedIndexPath<br/>        }<br/>    })<br/>    <br/>    let row = indexPath.row<br/>    // Disables animation on the first and last cell<br/>    if row == 0 || row == data.count - 1 {<br/>        self.select(row: row, animated: false)<br/>        return<br/>    }<br/>    <br/>    self.select(row: row)<br/>}<br/></span></pre><p id="b06f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们正在抓取<code class="fe nr ns nt nu b">UICollectionView</code>上所有当前可见的单元格。</p><p id="45d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们通过抓取上下边界之间的单元格来过滤它们。</p><pre class="kg kh ki kj gt nv nu nw bn nx ny bi"><span id="e5f7" class="nz lv iq nu b be oa ob l oc od">/// Gets visible cells<br/>visibleCells = visibleCells.filter({ cell -&gt; Bool in<br/>    <br/>    let cellRect = collectionView.convert(<br/>        cell.frame,<br/>        to: collectionView.superview<br/>    )<br/>    /// Calculate if at least 50% of the cell is in the boundaries we created<br/>    let viewMidX = view.frame.midX<br/>    let cellMidX = cellRect.midX<br/>    let topBoundary = viewMidX + cellRect.width/2<br/>    let bottomBoundary = viewMidX - cellRect.width/2<br/>    <br/>    /// A print state representating what the return is calculating<br/>    print("topboundary: \(topBoundary) &gt; cellMidX: \(cellMidX) &gt; Bottom Boundary: \(bottomBoundary)")<br/>    return topBoundary &gt; cellMidX  &amp;&amp; cellMidX &gt; bottomBoundary<br/>})</span></pre><p id="b21e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">之后，我们将该单元格的<code class="fe nr ns nt nu b">indexPath </code>设置为我们在函数中创建的indexPath。</p><p id="664a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">禁用第一个和最后一个单元格的动画滚动可以防止动画失真。这是因为它试图同时做两个动画。单元格滚动的去抖和滚动动画。</p><p id="57d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">调用<code class="fe nr ns nt nu b">select()</code>函数，并滚动到该行。</p><pre class="kg kh ki kj gt nv nu nw bn nx ny bi"><span id="b84f" class="nz lv iq nu b be oa ob l oc od">/// Appends visible cell index to `cellIndexPath`<br/>visibleCells.forEach({<br/>    if let selectedIndexPath = collectionView.indexPath(for: $0) {<br/>        indexPath = selectedIndexPath<br/>    }<br/>})<br/>let row = indexPath.row<br/>// Disables animation on the first and last cell<br/>if row == 0 || row == data.count - 1 {<br/>    self.select(row: row, animated: false)<br/>    return<br/>}<br/><br/>self.select(row: row)</span></pre><p id="03a1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您运行应用程序时，您现在应该拥有新的功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="b7bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样！如果你想下载这个项目，这里有一个GitHub回购的链接。</p><h1 id="d7ad" class="nd lv iq bd lw ne nf ng lz nh ni nj mc jw nk jx mf jz nl ka mi kc nm kd ml nn bi translated">左对齐解决方案</h1><p id="b70e" class="pw-post-body-paragraph kv kw iq kx b ky mp jr la lb mq ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">如果您有兴趣像我在NOSSALFEX中所做的那样，将水平选取器配置为左对齐，这里是您需要实现的解决方案差异。当您运行应用程序时，您现在应该拥有新的功能。</p><p id="11d1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更新边缘插图。</p><pre class="kg kh ki kj gt nv nu nw bn nx ny bi"><span id="ba85" class="nz lv iq nu b be oa ob l oc od">func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -&gt; UIEdgeInsets {<br/>    return UIEdgeInsets(<br/>        top: 0,<br/>        left: 0,<br/>        bottom: 0,<br/>        right: view.frame.width - cellWidth<br/>    )<br/>}</span></pre><p id="1d65" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更新滚动方向。</p><pre class="kg kh ki kj gt nv nu nw bn nx ny bi"><span id="f71f" class="nz lv iq nu b be oa ob l oc od">collectionView.selectItem(<br/>        at: indexPath,<br/>     the scrollToCell() function.</span></pre><pre class="oe nv nu nw bn nx ny bi"><span id="ecc1" class="nz lv iq nu b be oa ob l oc od"><br/>/// Scrolls to visible cell based on `scrollViewDidEndDragging` or `scrollViewDidEndDecelerating` delegate functions<br/>private func scrollToCell() {<br/>    var cellIndexPath = [IndexPath]()<br/>    var visibleCells = collectionView.visibleCells<br/>    <br/>    /// Gets visible cells<br/>    visibleCells = visibleCells.filter({ cell -&gt; Bool in<br/>        let cellRect = collectionView.convert(<br/>            cell.frame,<br/>            to: collectionView.superview<br/>        )<br/>        /// Checks if at least 50% of the cell is visible on the `collectionView`<br/>        return cellRect.minX &gt; -((cellWidth)/2)<br/>    })<br/>    <br/>    /// Appends visible cell index to `cellIndexPath`<br/>    visibleCells.forEach({<br/>        if let indexPath = collectionView.indexPath(for: $0) {<br/>            cellIndexPath.append(indexPath)<br/>        }<br/>    })<br/>    <br/>    /// Sorts cell IndexPaths by row<br/>    let sortedIndexPath = cellIndexPath.sorted()<br/>    <br/>    /// Gets first index of cell<br/>    let row = sortedIndexPath[0].row<br/>    // Disables animation on the first and last cell<br/>    if row == 0 || row == data.count - 1 {<br/>        self.select(row: row, animated: false)<br/>        return<br/>    }<br/>    self.select(row: row)<br/>}</span></pre><p id="d1c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">干杯🍻。</p></div></div>    
</body>
</html>