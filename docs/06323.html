<html>
<head>
<title>Prime Numbers as Streams, With RxJS and Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">质数作为流，用RxJS和Go</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/prime-numbers-as-streams-with-rxjs-and-go-a18b0292fb5e?source=collection_archive---------11-----------------------#2020-09-21">https://betterprogramming.pub/prime-numbers-as-streams-with-rxjs-and-go-a18b0292fb5e?source=collection_archive---------11-----------------------#2020-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cdf9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用流递归实现的厄拉多塞算法的筛选</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/baea5f33ac303bc4ba8c95272b7aa01f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7hLZXY3ceZotjB0wqCZ5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">厄拉多塞之筛:质数如流</p></figure><p id="ff2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">质数可以被想象成一个无限的整数流:1，2，3，5，7，11…等等。</p><p id="050d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2000多年前，希腊数学家<a class="ae lu" href="https://en.wikipedia.org/wiki/Eratosthenes" rel="noopener ugc nofollow" target="_blank">厄拉多塞</a>发现<a class="ae lu" href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" rel="noopener ugc nofollow" target="_blank">素数可以用流</a>以递归方式计算。</p><p id="e5fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将看到这种逻辑的几种不同实现，一种使用RxJs和Typescript，另一种使用Go通道作为流。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5815" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">具有RxJs可观测流的“厄拉多塞筛”</h1><p id="0552" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">为了开始我们的计算，我们需要生成一个所有整数的流，从2开始，这将是算法使用的源。RxJs <code class="fe mz na nb nc b">range</code>函数给我们的正是这个:</p><p id="e672" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">const <strong class="la iu">source</strong> = range(2, 1000) // 2, 3, 4, 5, 6, ...</code></p><p id="f84a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们需要取<code class="fe mz na nb nc b">source</code>的第一个值，实际上是第一个<code class="fe mz na nb nc b">primeNumber</code>，用它来生成第二个数字流，这个数字流是从<code class="fe mz na nb nc b">source</code>过滤掉所有是<code class="fe mz na nb nc b">primeNumber</code>的乘数的数字得到的。<code class="fe mz na nb nc b">first</code>和<code class="fe mz na nb nc b">filter</code>是要使用的RxJs运算符:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="52d0" class="nh md it nc b gy ni nj l nk nl">const secondStream = <strong class="nc iu">source</strong>.pipe(<br/>   first(),<br/>   filter(<strong class="nc iu">primeNumber</strong> =&gt; <strong class="nc iu">source</strong>.pipe(<br/>     filter(n =&gt; n % <strong class="nc iu">primeNumber</strong> !== 0)<br/>   )<br/>)<br/>// 3, 5, 7, 9, 11, ...</span></pre><p id="0c04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们能够从<code class="fe mz na nb nc b">source</code>开始生成数字<code class="fe mz na nb nc b">secondStream</code>(3，5，7，9，11，…)，我们可以以完全相同的方式从<code class="fe mz na nb nc b">secondStream</code> <em class="nm"> </em>开始生成第三个流，即使用<code class="fe mz na nb nc b">first</code>和<code class="fe mz na nb nc b">filter</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8e4e" class="nh md it nc b gy ni nj l nk nl">const thirdStream = <strong class="nc iu">secondStream</strong>.pipe(<br/>   first(),<br/>   filter(<strong class="nc iu">primeNumber</strong> =&gt; <strong class="nc iu">secondStream</strong>.pipe(<br/>     filter(n =&gt; n % <strong class="nc iu">primeNumber</strong> !== 0)<br/>   )<br/>)<br/>// 5, 7, 11, 13, ...</span></pre><p id="45b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这显然是一个递归模式，可以编码为一个函数<code class="fe mz na nb nc b">pNumbers</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f4fd" class="nh md it nc b gy ni nj l nk nl">function <strong class="nc iu"><em class="nm">pNumbers</em></strong>(source: Observable&lt;number&gt;): Observable&lt;number&gt; {<br/>   return source.pipe(<br/>      first(),<br/>      concatMap(pn =&gt; <strong class="nc iu"><em class="nm">pNumbers</em></strong>(<br/>         source.pipe(filter(n =&gt; n % pn !== 0))<br/>      ))<br/>   );<br/>}</span></pre><p id="fbec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是为什么是<code class="fe mz na nb nc b">concatMap</code>？下面的大理石图有助于澄清。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/3a7caa8f4d07b51e7f3b1574ea29b39a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxwfQjV13bcs0bD7hjXRiw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<strong class="bd no"> pNumbers </strong>函数中发生的变换链</p></figure><p id="0877" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们从<code class="fe mz na nb nc b">source</code>开始，它是一个流，我们通过操作符<code class="fe mz na nb nc b">first</code>把它转换成一个新的流<code class="fe mz na nb nc b">obsFirst</code><strong class="la iu"/>。然后我们需要将<code class="fe mz na nb nc b">obsFirst</code>转换成一个新的流<code class="fe mz na nb nc b">secondStream</code>，它是由<code class="fe mz na nb nc b">pNumbers(source.pipe(filter(n =&gt; n%p !== 0)))</code>返回的<code class="fe mz na nb nc b">Observable</code>通知的值的流。</p><p id="1bd5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我们基本上是用<em class="nm">将</em>内部的<code class="fe mz na nb nc b">Observable</code>(也称为更高一级的<code class="fe mz na nb nc b">Observable</code>)，即由函数<code class="fe mz na nb nc b">pNumbers</code>返回并作为输入传递给<code class="fe mz na nb nc b">concatMap</code>的那个，展平到在<code class="fe mz na nb nc b">pipe</code>中执行的整个转换的结果流中。</p><p id="5037" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在RxJs中，由<code class="fe mz na nb nc b">mergeMap</code>、<code class="fe mz na nb nc b">switchMap</code>、<code class="fe mz na nb nc b">exaustMap</code>和<code class="fe mz na nb nc b">concatMap</code>等操作符对更高级别的可观察对象进行展平。在这种情况下，我们使用<code class="fe mz na nb nc b">concatMap</code>,因为通知应该在前一个源可观测值(在上面的例子中为<code class="fe mz na nb nc b">obsFirst</code>)完成时开始。</p><p id="dfb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">准备好递归函数<code class="fe mz na nb nc b">pNumbers</code>后，就可以计算达到某个阈值的质数了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">打印100以内的质数</p></figure><p id="4ffd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还可以创建一个<code class="fe mz na nb nc b">Observable</code>，通知所有达到给定阈值的质数。这是通过构建新的<code class="fe mz na nb nc b">Observable</code>包装<code class="fe mz na nb nc b">pNumbers</code>的函数获得的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">素数是一个函数，它返回一个可观察值，通知所有达到某个阈值的素数</p></figure><p id="aebc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了测试上面定义的<code class="fe mz na nb nc b">primeNumbers</code>函数返回的<code class="fe mz na nb nc b">Observable</code>，我们只需要像这样订阅它:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a715" class="nh md it nc b gy ni nj l nk nl">const pNums = primeNumbers(100);<br/>pNums.subscribe(pn =&gt; console.log(pn));</span></pre><h2 id="3637" class="nh md it bd me nr ns dn mi nt nu dp mm lh nv nw mo ll nx ny mq lp nz oa ms ob bi translated"><strong class="ak">这只是一个最终达到“最大调用堆栈大小”的长长的过滤器链</strong></h2><p id="6d8a" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">如果我们仔细观察我们的实现，我们会发现逻辑的核心在下面几行:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1f0e" class="nh md it nc b gy ni nj l nk nl">return pNumbers(<strong class="nc iu">source</strong>.pipe(<br/>  filter((n) =&gt; {<br/>    return n % primeNumber !== 0;<br/>  })<br/>);</span></pre><p id="ad0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们用一个<code class="fe mz na nb nc b">filter</code>函数链接<code class="fe mz na nb nc b">source</code>流。由于这一行被递归调用，我们最终构建了一个长长的<code class="fe mz na nb nc b">filter</code>函数链，附加到我们计算的初始<code class="fe mz na nb nc b">source</code>流。</p><p id="d674" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们重复这个递归足够多次，我们最终会一个接一个地链接许多<code class="fe mz na nb nc b">filter</code>函数，我们最终会达到调用栈的最大大小。如果我们用足够大的<code class="fe mz na nb nc b">upTo</code>输入数运行这段代码，就会发生这种情况。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5a08" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">以围棋频道为溪流的“厄拉多塞之筛”</h1><p id="8e53" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在Go中，我们可以使用通道来实现流。例如，从2开始的整数的未绑定流可以这样生成:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="520f" class="nh md it nc b gy ni nj l nk nl">ch := make(chan int)<br/>for i := 2; ; i++ {<br/>  ch &lt;- i<br/>}</span></pre><p id="327a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，流由信道<code class="fe mz na nb nc b">ch</code>表示。任何想要读取流的客户端代码只需读取通道<code class="fe mz na nb nc b">ch</code>。</p><p id="a5cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的逻辑要求从输入流开始递归地创建非质数倍数的流。我们可以使用<em class="nm">流作为通道</em>的概念编写一个<code class="fe mz na nb nc b">filter</code>函数来实现这样的逻辑:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c083" class="nh md it nc b gy ni nj l nk nl">func filter(inStream &lt;-chan int, filteredStream chan&lt;- int, n int) {<br/>  for i := range inStream {<br/>    if i%n != 0 {<br/>      filteredStream &lt;- i<br/>    }<br/>  }<br/>}</span></pre><p id="1358" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">inStream</code>是代表输入流的通道，<code class="fe mz na nb nc b">filteredStream</code>是代表非<code class="fe mz na nb nc b">n</code>倍数的流的通道，其中<code class="fe mz na nb nc b">n</code>是质数。注意<code class="fe mz na nb nc b">&lt;-chan</code>和<code class="fe mz na nb nc b">chan&lt;-</code>的使用。<code class="fe mz na nb nc b">inStream</code>的类型是<code class="fe mz na nb nc b">&lt;-chan int</code>，这意味着一个我们只能从中读取的通道，而<code class="fe mz na nb nc b">fitleredStream</code>的类型是<code class="fe mz na nb nc b">chan&lt;- int</code>，这意味着它是一个我们只能从中写入的通道。</p><p id="9f80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们需要<code class="fe mz na nb nc b">pNumbers</code>函数，给定一个输入流，它获取第一个值，这是一个质数，将过滤逻辑应用于流的其余部分，以创建一个新的“过滤”流，并使用这个新的“过滤”流作为输入流递归调用自身:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="57b4" class="nh md it nc b gy ni nj l nk nl">func pNumbers(inStream &lt;-chan int, lastPrime int) {<br/>  primeNumber := &lt;-inStream <br/>  fmt.Println(i, primeNumber)<br/>  filteredStream := make(chan int)<br/>  go filter(inStream, filteredStream, primeNumber)<br/>  pNumbers(filteredStream, primeNumber)<br/>}</span></pre><p id="17f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完整解决方案的最终版本只是我们刚刚创建的构件的组合。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">计算前100个质数</p></figure><p id="62c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">值得注意的是，对函数<code class="fe mz na nb nc b">pNumbers</code>的所有递归调用都在同一个“主”goroutine中运行，而对<code class="fe mz na nb nc b">generate</code>和<code class="fe mz na nb nc b">filter</code>的每个调用都在它们自己的go routine中运行。基本原因是<code class="fe mz na nb nc b">pNumbers</code>只是流的<em class="nm">消费者</em>，换句话说，它只是从创建的通道中读取，并且它必须顺序工作，因为我们想要一个有序的素数序列。消费者需要生产者，即在通道上写的函数。<code class="fe mz na nb nc b">generate</code>是一个制片人，因为它只在一个频道上写作。<code class="fe mz na nb nc b">filter</code>既是消费者，也是生产者，因为它从一个通道读取，在另一个通道写入。同一流的消费者和生产者，即同一通道上的读者和作者，需要在不同的goroutines中运行，以避免死锁。</p><p id="63cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">1之后的前三个质数(即2、3、5)的goroutines和通道之间的各种相互作用如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/1f60ae6bc8e24e486691cb35c66a3802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IOnXgh-Gm6TH_0Kev6-cXw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在计算1之后的前3个素数时，goroutines和channels交互</p></figure><p id="9b02" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际读取和写入的顺序可能略有不同。例如，在gr1创建chan 2之前，goroutine gr2可以将3写入源chan。然而，从逻辑的角度来看，上面的图表清楚地展示了流程中发生的交互。</p><p id="c388" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看计算的关闭方式也很有意思。当达到<code class="fe mz na nb nc b">upTo</code>值时，<code class="fe mz na nb nc b">generate</code>函数退出其循环，然后关闭通道源chan <strong class="la iu">、</strong>，即其写入的通道。<code class="fe mz na nb nc b">source chan</code>是运行在gorourine <code class="fe mz na nb nc b">gr3</code>中的<code class="fe mz na nb nc b">filter</code>函数读取的通道。因此，当该函数尝试从<code class="fe mz na nb nc b">source chan</code>进行下一次读取时，它发现一个关闭的通道，因此退出范围循环的<em class="nm">，并关闭通道<code class="fe mz na nb nc b">chan 2</code> <strong class="la iu">、</strong>，即它写入的通道。<code class="fe mz na nb nc b">chan 2</code>是<code class="fe mz na nb nc b">gr4</code>中运行的<code class="fe mz na nb nc b">filter</code>功能读取的通道。但是现在<code class="fe mz na nb nc b"><strong class="la iu"> chan 2</strong></code> <strong class="la iu"> </strong>关闭了，这就导致了关闭chan 3。依此类推，直到我们到达由<code class="fe mz na nb nc b">pNumbers</code>创建的最后一个通道，即<code class="fe mz na nb nc b">gr1</code>想要读取的通道。但是这个读操作不能完成，因为通道在任何东西被写入之前被关闭，所以<code class="fe mz na nb nc b">pNumbers</code>退出，导致整个程序退出。</em></p><p id="38dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该顺序如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/fc2496c17d69e1e652d664131a188773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SLoyRJ9_rNsTAmTdEqaHqA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">关闭频道和结束节目的顺序</p></figure><p id="c02d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的实现是Go中“Prime Sieve”的一个变体，集中在流概念上，这是一个非常优雅的解决方案，你可以在这个关于Go的原因的有趣讨论中找到相同问题的解释。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Go素数筛实现</p></figure><h2 id="71e1" class="nh md it bd me nr ns dn mi nt nu dp mm lh nv nw mo ll nx ny mq lp nz oa ms ob bi translated">并发的美妙之处在于您可以利用所有的内核</h2><p id="f232" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">“厄拉多塞之筛”的Go实现充分利用了并发性。为了找到前X个质数(从2开始)，我们创建了X个并发运行的goroutines。我们以并行的方式组织逻辑，这样我们可以同时处理许多事情。这许多事情是以并发方式发生的各种过滤操作。</p><p id="3836" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">执行不一定是并行的，因为它也只在一个可用的内核上工作。但是，如果有许多核心，并行性可以非常自然地派生出来。Go运行时将确保所有的内核都被使用，从而随着内核数量的增加而减少执行时间。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9f18" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="5231" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们已经看到了基于“厄拉多塞筛”算法的基于流的逻辑的两种不同实现，一种使用RxJs可观察值，另一种使用Go通道。</p><p id="44d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的目标不是构建高效的实现来寻找质数，而是感受基于流的逻辑的强大功能，以及RxJs和Go通道为这种编程模型提供的自然实现。</p><p id="aeac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在由云、分布式计算和事件驱动架构主导的世界中，基于流的逻辑可能会变得更加普遍。我们最好做好准备，学习如何使用这些工具。</p></div></div>    
</body>
</html>