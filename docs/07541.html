<html>
<head>
<title>Making a RESTful API Creation Easy in Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Spring Boot轻松创建RESTful API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/making-a-restful-api-creation-easy-in-spring-boot-dc56c0ede725?source=collection_archive---------3-----------------------#2021-01-26">https://betterprogramming.pub/making-a-restful-api-creation-easy-in-spring-boot-dc56c0ede725?source=collection_archive---------3-----------------------#2021-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="24cc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索Feign client和其他有用的库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7fb4b0b0f33d49dfeeb5c23d62f7e706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lvp72DhhdEdI3eLi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">戈兰·艾沃斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="ddce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您是否遇到过向几个不同的应用程序编程接口(API)发出HTTP请求的麻烦？将这些不同的API中您需要的东西组合成一个API不是更容易吗？</p><p id="2023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个中间件可以解决这个问题。软件应用程序中间件允许我们拥有单一的定制数据源。拥有中间件的主要好处之一是它将许多不同的产品和服务连接在一个共享系统中。那么，到底什么是中间件呢？根据<a class="ae ky" href="https://azure.microsoft.com/en-in/overview/what-is-middleware/" rel="noopener ugc nofollow" target="_blank">微软Azure </a>的说法，中间件是一种软件，作为操作系统和其上运行的应用程序之间的隐藏翻译层。它为分布式应用程序提供数据管理和通信。</p><p id="75d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将展示如何使用<a class="ae ky" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>在一些依赖项的帮助下创建一个中间件，比如<a class="ae ky" href="https://github.com/OpenFeign/feign" rel="noopener ugc nofollow" target="_blank"> Feign client </a>。Feign是一个由网飞创建的声明性web服务，它为进行表述性状态转移(REST) API调用提供了高度的抽象。同样，它消除了编写基本HTTP请求代码的需要，同时为源代码提供了效率和整洁。</p><p id="b3dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我们将调用一个名为JSONPlaceholder的用于测试和原型制作的伪在线REST API服务。参观https://jsonplaceholder.typicode.com/的不同路线。在这个练习中，我将使用“todo”路线。</p><p id="832d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文结束时，读者应该理解什么是中间件，并知道何时以及如何使用它。同样，他们应该熟悉Feign web服务客户端。</p><p id="e005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是Spring的新手，或者只是需要复习一下，请参考本文<a class="ae ky" href="https://medium.com/better-programming/demystifying-spring-boot-245e71feffc0" rel="noopener">中解释一些基本概念的文章</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5ee6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">开始吧！</strong></h1><p id="6453" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我们需要创建一个Spring Boot项目。为此，我们将使用<a class="ae ky" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank">弹簧初始值</a>。下面的屏幕截图突出显示了我们将使用的配置和依赖关系。现在，让我们保持简单，只使用Spring Web依赖。随着我们的进展，我们将为我们的项目手动添加所有其他依赖项。点击“生成”，将下载一个zip文件夹。提取内容，然后用IDE打开项目。我将使用的IDE是IntelliJ。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/f61b7b5e3cc28d7caed64d41087a8ba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cg7oHdGoxQati2lPXF_6jw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">截图来自<a class="ae ky" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring Initializr </a>。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="589c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">了解数据</strong></h1><p id="d2c0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如前所述，我们将使用一个名为JSONPlaceHolder的伪在线REST API。这个在线API有诸如帖子、待办事项和评论等资源。我们将在这个项目中使用todos资源。下图突出显示了使用Postman对todos资源的不同HTTP请求和响应:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/df0866056a07a43103de6e2aa58d38ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJ_TuWZuN8LjbffpBz7FOw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者显示从假的在线REST API get all todos端点返回的数据的截图。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/f6ad7cd069c0319b8ead6e90aeb82475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5gospog5Swl4VLBXnHFtFQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者展示REST API获得单个todos端点的数据返回的屏幕截图。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/a80e6e8d4226993e2c18e73a92377062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DjHAT5Ij2Syhz1UnEdYnJA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者显示todo创建的屏幕截图。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ab3d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">开始编码吧！</strong></h1><p id="6ef1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将首先创建一个类来模拟从API返回的数据。为了保持项目结构的优雅，我们将创建一个名为<code class="fe nd ne nf ng b">Model</code>的文件夹来包含我们的类。我们将调用这个类<code class="fe nd ne nf ng b">Todo</code>，它将有四个属性:</p><ul class=""><li id="48fc" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated"><code class="fe nd ne nf ng b">private Integer userId</code></li><li id="1453" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe nd ne nf ng b">private Integer id</code></li><li id="98b2" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe nd ne nf ng b">private String title</code></li><li id="bbbf" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><code class="fe nd ne nf ng b">private Boolean completed</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/d83fc95e4c58b58701e623dd0eb7cd0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8v7fWEMGZ42fXpmdSqv3Eg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者分享的屏幕。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="e001" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的<code class="fe nd ne nf ng b">@Data</code>注释来自我们手动添加和导入的Lombok依赖项，如上所示。这个库允许减少为类编写的公共Java代码。<code class="fe nd ne nf ng b">@Data</code>注释自动生成setters、getters、<code class="fe nd ne nf ng b">toStrings</code>等。对于<code class="fe nd ne nf ng b">Todo</code>类。从本质上讲，Lombok简化了创建普通旧Java对象(POJO)的过程。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="117a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">创建虚拟客户端接口</strong></h1><p id="9f93" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们首先将伪在线REST API的基本URL存储在我们的<code class="fe nd ne nf ng b">application.properties</code>文件中。下面显示了一个示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/8e2f23c46fa59442acb0fca29973941a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uyJS4JNRHxJdvguNFZwV5A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图。</p></figure><p id="12f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是创建一个名为<code class="fe nd ne nf ng b">Client</code>的包(文件夹)，它将包含我们的假扮客户端界面。我们将创建三个端点。第一个将用于获取所有todo，第二个将用于通过在URL中提供一个数字作为路径变量来获取单个todo，第三个将是一个以todo对象作为请求主体来创建todo的post请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/dc42802be46377d1cd079c95f152b02e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*sBWtmMZtYNNnxWSlPAwlmQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的屏幕共享。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="174f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们关注一下假动作，如上面的GIF所示。“假装”注释可以接受多个参数，例如名称、值、URL和配置。但是，名称或值必须是提供的参数之一。URL参数将是存储在我们的<code class="fe nd ne nf ng b">application.properties</code>文件中的基本URL，并且假装客户端将向它发出HTTP请求。请注意，如果API需要任何形式的身份验证，我们可以为处理身份验证的API资源创建一个配置类，然后提供该类作为配置参数的值。例如:我们分配<code class="fe nd ne nf ng b">configuration = JSONPlaceHolderConfig.class</code>。</p><p id="c1c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf ng b">GetMapping</code>注释根据提供的URL执行GET HTTP请求。请注意，当提供给这个注释的URL与传递给假装客户端的基本URL组合在一起时，就成为了REST API的实际资源端点。该接口有两个get request方法:一个将返回所有todo，另一个将返回与提供的路径变量相关的单个todo。POST方法接受类型为<code class="fe nd ne nf ng b">Todo</code>的请求体，并允许使用指定的端点进行HTTP POST请求。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ebfc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">创建服务</strong></h1><p id="cd57" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">秉承关注点分离设计原则，我们将创建一个名为<code class="fe nd ne nf ng b">Service</code>的包，其中包含我们的服务类(<code class="fe nd ne nf ng b">TodoService</code>)。该服务利用之前在假扮客户端界面中声明的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="5d52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们稍微消化一下代码。</p><p id="9e7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf ng b">@Service</code>注释是更大的<code class="fe nd ne nf ng b">@Component</code>注释的一部分，也包括<code class="fe nd ne nf ng b">@Controller</code>注释。<code class="fe nd ne nf ng b">@Service</code>注释将我们的<code class="fe nd ne nf ng b">TodoService</code>类声明为一个spring bean，因此它可以由spring应用程序上下文来维护。这个注释将我们的<code class="fe nd ne nf ng b">TodoService</code>类标记为包含应用程序业务逻辑的服务层。</p><p id="8e43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，日志记录对于这种实现非常有用——尤其是在调试或少量审计时。<code class="fe nd ne nf ng b">@Slf4j</code>(Java的简单日志门面)注释是Lombok库的一部分，它允许我们使用<code class="fe nd ne nf ng b">log.info()</code>方法轻松地将信息记录到控制台。</p><p id="27f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三个注释，<code class="fe nd ne nf ng b">@Autowired</code>，通过使用依赖注入，消除了对setters、getters和constructors的需求。这是通过将对象插入到其他对象中来实现的，从而导致组件的松散耦合。因此，我们不需要实例化Feign client接口。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="444c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">创建控制器</strong></h1><p id="64d3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">外界使用HTTP请求与控制器类通信。这是我们的Spring Boot应用程序的入口点。当我们将来向应用程序发出HTTP请求时，它将直接指向控制器类，在控制器类中进行请求映射以识别和调用所需的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="b732" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的要点展示了位于<code class="fe nd ne nf ng b">Controller</code>包中的控制器类。注意到什么新情况了吗？上面使用的三个注释不是强制性的，而是个人偏好。它们确保我不必编写额外的代码行。</p><p id="e528" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们简要地看一下<code class="fe nd ne nf ng b">@RestController</code>的注解。<code class="fe nd ne nf ng b">@RestController</code>是<code class="fe nd ne nf ng b">@Controller</code>和<code class="fe nd ne nf ng b">@ResponseBody</code>注释的组合。默认情况下，<code class="fe nd ne nf ng b">@RestController</code>注释执行映射方法的扫描和检测(<code class="fe nd ne nf ng b">@Controller</code>注释的功能)。它还自动将控制器类中的方法返回的对象(数据)序列化为JSON，这将形成HTTP响应体(<code class="fe nd ne nf ng b">@ResponseBody</code>的函数)。</p><p id="a523" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，<code class="fe nd ne nf ng b">@RequestMapping</code>注释相当简单。它将HTTP请求映射到不同的方法和类。将<code class="fe nd ne nf ng b">@RequestMapping</code>注释添加到我们的类定义中，可以确保我们的控制器基本URL是我们作为参数传递给所述注释的任何值(在本例中是<code class="fe nd ne nf ng b">todo-list</code>)。</p><p id="dea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Lombok库中的<code class="fe nd ne nf ng b">@RequiredArgsConstructor</code>注释非常有用。构造函数有时会让我们被许多行代码弄糊涂。<code class="fe nd ne nf ng b">@RequiredArgsConstructor</code>为任何提供的用final关键字声明的类字段创建构造函数(例如<code class="fe nd ne nf ng b">private final TodoService todoService</code>)。</p><p id="8cfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">控制器类中定义的方法使用由服务层(我们的服务类)提供的各自的业务逻辑。每个方法都映射到一个指定的URL(端点),并从指定的服务方法返回一个响应。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b265" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">整理完毕！</strong></h1><p id="ec6d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们执行应用程序，您认为它会像预期的那样工作吗？嗯，不。为什么不呢？原因很简单，我们还没有在应用程序主类上启用Feign。我们可以通过简单地用<code class="fe nd ne nf ng b">@EnableFeignClients</code>注释我们的主类来获得成功。这个注释负责扫描所有声明的伪客户端接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/d9e6188373efd93ed77e66822c6c3405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YdaDqW8JEvCjsQA1lSEAzw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者展示项目结构和MiddlewareApplication类的截图。</p></figure><p id="857b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图展示了在我们的中间件应用程序中使用Postman(客户端)与不同的路由进行通信。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/c8e5e0204f2a24475f1857c4287a747f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QzWNwy42bLenIXjb06MLbQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者展示get all todos端点结果的屏幕截图。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/990d817925770a2da9825397310658a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QX22Vq3kIeap-YCOCz0YyA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者突出显示与get single todo端点通信的结果的屏幕截图。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/14152ef5fed668b11d52253e0ec90fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OJHouYy0NIow0qASaXxB7g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者演示使用create todo端点创建todo的屏幕截图。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d2f5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="7e85" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们已经做到了:我们已经开发了一个功能性的应用程序，通过HTTP请求来促进通信。我们现在可以通过我们的应用程序与假的在线REST API进行通信。应用程序本质上是客户机(Postman)和伪REST API之间的中间人，满足中间件的一个定义角色。</p><p id="bc7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个当前的应用程序只集成了一个API服务，但是它有可能与许多提供数据的不同服务进行通信。下一次您必须使用许多不同的数据源时，中间件可以让您的生活变得更容易——特别是使用诸如Feign和Lombok之类的库。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6063" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">资源</strong></h1><div class="ob oc gp gr od oe"><a href="https://jsonplaceholder.typicode.com/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">JSONPlaceholder</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">免费使用假冒的在线REST API进行测试和原型开发。截至2020年12月，由JSON服务器+ LowDB提供支持，服务于…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">jsonplaceholder.typicode.com</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://azure.microsoft.com/en-in/overview/what-is-middleware/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">什么是中间件-定义和示例|微软Azure</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">中间件是位于操作系统和运行于其上的应用程序之间的软件。本质上…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">azure.microsoft.com</p></div></div><div class="on l"><div class="ot l op oq or on os ks oe"/></div></div></a></div></div></div>    
</body>
</html>