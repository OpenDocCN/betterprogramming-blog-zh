<html>
<head>
<title>Apply Builder Pattern To Generate Query Filter In TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用生成器模式在TypeScript中生成查询筛选器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/apply-builder-pattern-to-generate-query-filter-in-typescript-651a6b13da38?source=collection_archive---------3-----------------------#2021-08-31">https://betterprogramming.pub/apply-builder-pattern-to-generate-query-filter-in-typescript-651a6b13da38?source=collection_archive---------3-----------------------#2021-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4775" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实现一个不可变的强类型过滤器生成器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/86025b758d7a2b22d65c07a9a7003180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZq-7O2aRZnREPjoCKFYfw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@lindsayhenwood?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">林赛·亨伍德</a>在<a class="ae ky" href="https://unsplash.com/s/photos/step?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="5c8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建器模式是GoF设计模式中的一种，它被设计用来构建通常需要一长串参数的对象。它允许您使用Builder类创建多个不同但相似的对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/5ba49972ab7d0377228bc838c93f1334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*5UKx-KgsjNqKEsbW2ELE5A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">构建模式的UML类(来源:Wikipedia: <a class="ae ky" href="https://en.wikipedia.org/wiki/Builder_pattern" rel="noopener ugc nofollow" target="_blank">构建模式</a>)</p></figure><p id="5261" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如UML图所示，构建者模式包括一个指导者和构建者。构建者一步一步地创建对象的一部分。导演管理将各部分组装在一起的方式。导演的角色是在呼叫客户和建造者之间提供分离。</p><p id="e07b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，模式是在没有控制器的情况下实现的。这意味着客户端直接调用构建器方法并获得结果。这样，我们有了一个更简单的实现，并且仍然保留了主要的好处:封装了构建对象过程的复杂性。在本文中，我们实现了没有控制器的构建器模式。</p><p id="1bd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文的目的是展示如何用构建器模式重构代码块，使其成为不可变和强类型的。</p><p id="30e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向前跳:</p><ul class=""><li id="7ccf" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae ky" href="#0c3c" rel="noopener ugc nofollow">第一次尝试</a></li><li id="cc46" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#7a86" rel="noopener ugc nofollow">使内部状态不可变</a></li><li id="9aa1" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#4cce" rel="noopener ugc nofollow">添加强打字</a></li><li id="cd5d" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#82cb" rel="noopener ugc nofollow">最终想法</a></li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="252f" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">问题定义</h1><p id="30ff" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们需要在一个<code class="fe no np nq nr b">Node.js</code>应用中重构URL过滤器的生成。下面的代码片段展示了过滤器如何与多个if语句连接在一起。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="de09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以很容易地从这个人为的例子中指出一些问题:</p><ul class=""><li id="682b" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae ky" href="https://medium.com/p/89937c0f9a99" rel="noopener">多个if语句</a>让人难以读懂。</li><li id="eeba" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">当添加更多的过滤条件时，它会很快变得难以管理</li><li id="9bd3" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">相似的代码块在许多不同的地方重复出现。(我们需要在各种API调用中使用多个类似的过滤器)。</li></ul><p id="abdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始重构时，我首先想到的是提取。让我们继续将这段代码提取到一个生成器类中。</p><h2 id="0c3c" class="nu ms it bd mt nv nw dn mx nx ny dp nb li nz oa nd lm ob oc nf lq od oe nh of bi translated">第一次尝试</h2><p id="93b3" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们创建了一个<code class="fe no np nq nr b">EventFilterBuilder</code>类。它包括以下内容:</p><ul class=""><li id="74b1" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">设置单个过滤器的几种“设置”方法</li><li id="0d4e" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">一个私有的<code class="fe no np nq nr b">filterResult</code>对象来表示内部状态</li><li id="34d4" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">一种产生滤波器输出的<code class="fe no np nq nr b">build</code>方法</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="4de9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以从客户端调用新的构建器，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="6095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的第一次尝试几乎解决了原始代码的所有痛点。多个if语句被分隔到每个set方法中。代码变得更易于维护。</p><p id="34dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的改进是构建逻辑被封装到了builder类中。我们可以从应用程序中删除重复的过滤器连接。一个额外的好处是构建器集合方法支持链接。它使代码更流畅，更容易阅读。</p><p id="adc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，仍有改进的余地。</p><h2 id="7a86" class="nu ms it bd mt nv nw dn mx nx ny dp nb li nz oa nd lm ob oc nf lq od oe nh of bi translated">使内部状态不可变</h2><p id="deb4" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">当在Builder中调用set方法时，将返回该类的当前实例，并改变内部的<code class="fe no np nq nr b">filterResult</code>状态。这是一个潜在的风险。</p><p id="b385" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子说明了一个风险的例子。我们声明了两个建设者:<code class="fe no np nq nr b">statusBuilder</code> <em class="og"> </em>和<code class="fe no np nq nr b">openOnlyBuilder</code>。因为两个构建器持有对内部<code class="fe no np nq nr b">filterResult</code>状态的相同引用，因此向<code class="fe no np nq nr b">statusBuilder</code>添加状态过滤器会无意中影响<code class="fe no np nq nr b">openOnlyBuilder</code>的输出。因此，<code class="fe no np nq nr b">openOnlyBulder</code>会产生不正确的输出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="facc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种错误可能会逃过代码审查，导致运行时错误。我们应该通过使它不可变来防止它发生。</p><p id="e93d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">改进后的<code class="fe no np nq nr b">EventFilterBuilder2</code>如下图。在这个版本中，为每个<code class="fe no np nq nr b">set</code> filter方法调用返回一个新的构建器实例，内部状态<code class="fe no np nq nr b">filterResult</code>用只读修饰符注释。创建一个新的实例可能会有很小的开销。但是这个小小的代价是值得的，因为我们实现了不变性，防止了上述问题的发生。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1c23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个显著的改进是我们使用<code class="fe no np nq nr b">Object.values</code>来迭代<code class="fe no np nq nr b">build</code>方法中的所有过滤器。这使得代码更容易维护和扩展，以适应未来的变化。</p><h2 id="4cce" class="nu ms it bd mt nv nw dn mx nx ny dp nb li nz oa nd lm ob oc nf lq od oe nh of bi translated">添加强类型</h2><p id="e25e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">您可能已经注意到，构建器中的<code class="fe no np nq nr b">filterResult</code>状态是一个具有字符串类型键值对的对象。这意味着，如果我们在添加或更改过滤器属性时出现打字错误，将不会有任何编译器错误。我们如何提高类型安全性？</p><p id="5d57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们为<code class="fe no np nq nr b">Filter</code>创建一个类型。然后我们使用<code class="fe no np nq nr b">Generics</code>将新创建的<code class="fe no np nq nr b">FilterType</code> <em class="og"> </em>传递到构建器中。这允许我们在构造函数和所有引用<code class="fe no np nq nr b">FilterType</code>的键的内部状态中实施类型约束。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们介绍一个新的助手功能<code class="fe no np nq nr b">mergeSubObject</code>。它用于将新的过滤器合并到内部<code class="fe no np nq nr b">filterResult</code>对象中。你可能想知道为什么我们不能使用像spread操作符这样简单的方法来执行合并…</p><pre class="kj kk kl km gt oh nr oi oj aw ok bi"><span id="0b06" class="nu ms it nr b gy ol om l on oo">{...this.filterResult, openOnly: openOnly ? `(deleted eq 0)`: undefined }</span></pre><p id="b1ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因是，虽然上面的代码可以工作，但是我们失去了类型安全。根本原因是TypeScript没有对参数类型强制进行<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks" rel="noopener ugc nofollow" target="_blank">超额属性检查</a>，除了“新鲜”对象。因此,<code class="fe no np nq nr b">mergeSubObject</code>是强制类型检查的一种变通方法。</p><p id="39a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以调用新的构建器，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="6d86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个错误输入的过滤器被应用时，我们将被友好的错误消息警告。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/4e195834e7e8e3fbea33f5abf0ad651e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uz3pwb5FpxYQDYXNeTtZxg.png"/></div></div></figure><p id="70fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也使构建器更具可扩展性。当提出新的需求时，我们可以从现有的构建器中扩展一个新的构建器，并从<code class="fe no np nq nr b">FilterType</code> <em class="og">中派生出一个新的过滤器类型。</em></p><h1 id="82cb" class="mr ms it bd mt mu oq mw mx my or na nb jz os ka nd kc ot kd nf kf ou kg nh ni bi translated">最后的想法</h1><p id="50c9" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在本文中，我们将介绍一个应用构建器模式重构过滤器生成代码块的实例。我们将现有的逻辑提取到一个构建器类中，使其不可变，并在几次迭代中被强类型化。最后但同样重要的是，set方法的链接使得代码可读性更好。</p><p id="bf30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这是一个人为的例子。对于复杂的用例，可以做更多的改进。例如，如果需要实现多个构建器来匹配不同的API格式，我们可以引入一个抽象构建器，从这个抽象构建器可以扩展多个具体的构建器。</p><p id="6461" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你找到了这篇文章，你会发现下面的内容也很有用。</p><div class="ov ow gp gr ox oy"><a href="https://sunnysun-5694.medium.com/path-to-functional-style-a-typescript-refactoring-example-f5f052fe4d84" rel="noopener follow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">函数式风格之路:一个类型脚本重构示例</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">本文讨论如何将命令式风格的功能重构为函数式风格。功能是…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">sunnysun-5694.medium.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm ks oy"/></div></div></a></div><p id="d3fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编程快乐！</p></div></div>    
</body>
</html>