<html>
<head>
<title>Writing Framework for Inter Thread Message Passing in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C++编写线程间消息传递框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-framework-for-inter-thread-message-passing-in-c-256b5308a471?source=collection_archive---------0-----------------------#2021-12-07">https://betterprogramming.pub/writing-framework-for-inter-thread-message-passing-in-c-256b5308a471?source=collection_archive---------0-----------------------#2021-12-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f437" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个在线程间传递消息的框架，而不必担心底层线程代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ca2ff0df6642719775316202f88e5a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ezKjnyB8EvvVXRUi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@christianw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Christian Wiediger </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="d05b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">C++中的线程间消息传递</h1><h2 id="b15f" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">概观</h2><p id="a4d7" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">在许多情况下，开发人员在开发应用程序时必须处理多线程。在处理多线程时，我们几乎肯定需要同步它们，而同步方法之一就是消息传递。</p><p id="4fb5" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">在本文中，我将从使用标准库在C++中实现线程间消息传递开始，然后介绍实现问题，最后展示如何编写一个简单的框架来使我们的代码更加优雅。</p><h2 id="862a" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">互斥线程同步</h2><p id="8d16" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">我相信大家都熟悉互斥体，我们使用同步原语来防止共享资源或共享对象被多个线程同时访问，从而导致一种称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Race_condition#In_software" rel="noopener ugc nofollow" target="_blank">竞争条件</a>的情况。</p><p id="eedd" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">一个简单的例子是一个应该修改一个<code class="fe ne nf ng nh b">int</code>的线程，另一个例子是如果值不为零就打印它，然后把它设置为零。在C++中，我们可以通过使用<code class="fe ne nf ng nh b">std::thread</code>和<code class="fe ne nf ng nh b">std::mutex</code>来实现这个简单的例子，如下面的代码所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="867b" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们有两个线程，<code class="fe ne nf ng nh b">producer</code>和<code class="fe ne nf ng nh b">consumer</code>，它们的运行时间由运行这个应用程序的操作系统控制。在访问<code class="fe ne nf ng nh b">count</code>之前，两个线程都必须获取<code class="fe ne nf ng nh b">count_mutex</code>。我们不能轻易预测这段代码的结果，因为两个线程的调度都是由操作系统控制的。</p><p id="500f" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">您可能会注意到这种锁定机制的一个问题是，两个线程都必须不断地检查共享资源<code class="fe ne nf ng nh b">count</code>是否准备好被使用，这浪费了本来可以用于其他目的的CPU周期。</p><p id="1b74" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们已经解决了防止竞态条件的问题，但是由于上面的原因，这个解决方案不是很有效。为了提高代码的效率，我们可以使用另一个同步原语，条件变量。</p><h2 id="4e0f" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">条件变量</h2><p id="1b04" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">条件变量是一个同步原语，它允许线程在处理共享资源之前等待条件发生。与前面的例子不同，在前面的例子中，线程必须定期检查共享资源是否准备好被使用，通过条件变量，等待线程被置于睡眠状态，直到条件发生。</p><p id="3b5c" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">条件变量必须与互斥体一起使用。这是因为条件变量不能保护资源不被同时访问，而只是为线程提供了一种等待条件和其他线程发出条件信号的机制。因此，为了保护我们的共享资源，我们仍然需要一个互斥体。</p><p id="60ea" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">在C++中，我们可以使用<code class="fe ne nf ng nh b">std::condition_variable</code>，它类似于<code class="fe ne nf ng nh b">std::thread</code>和<code class="fe ne nf ng nh b">std::mutex</code>，是POSIX实现<code class="fe ne nf ng nh b">pthread_cond_t</code>的包装器。有一点需要注意的是，<code class="fe ne nf ng nh b">std::condition_variable::wait()</code>只能和<code class="fe ne nf ng nh b">std::unique_lock</code>一起使用。现在让我们更新我们的代码，使它更有效。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="3799" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">在程序退出之前，这段代码将打印0到9。现在，我们的代码完全按照我们想要的方式运行。我们不会浪费CPU周期不断轮询我们的共享资源是否准备好使用。</p><p id="6f30" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">但是，我想在这里强调的一点是，当我第一次学习条件变量时，我花了一些时间来理解它，因为它不是很清楚，甚至我可以说非常混乱条件变量如何使用互斥体。</p><p id="e29d" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">下面是我们的<code class="fe ne nf ng nh b">consumer</code>线程发生的情况(见评论)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="fddc" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">当我们构造<code class="fe ne nf ng nh b">std::unique_lock</code>时，它将获得互斥体。在<code class="fe ne nf ng nh b">std::condition_variable::wait()</code>函数中，互斥体被释放，并且<code class="fe ne nf ng nh b">consumer</code>线程被置于睡眠状态。当条件发生时，<code class="fe ne nf ng nh b">consumer</code>线程被唤醒，并立即获取互斥体，仍然在<code class="fe ne nf ng nh b">wait</code>函数中。所以你可以看到有<strong class="mi iu"> <em class="nk">副作用</em> </strong>当我们调用<code class="fe ne nf ng nh b">std::condition_variable::wait()</code>时，它会在返回前释放并获取互斥体。</p><p id="a3b2" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">在<code class="fe ne nf ng nh b">producer</code>线程中，会发生以下情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e7a7" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">它比<code class="fe ne nf ng nh b">consumer</code>线程更容易理解，因为当我们调用<code class="fe ne nf ng nh b">std::condition_variable::notify_one()</code>时没有副作用。</p><p id="c43f" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">另一件不太明显的事情是，互斥体和条件变量都可以让线程休眠。我希望现在更清楚了，我们需要一个互斥体来保护共享资源<code class="fe ne nf ng nh b">count</code>。</p><p id="92c9" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">作为一个例子，下面的序列图显示了一个可能发生的场景。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/3800a114134a3207fb98575b76a808a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*C8JHk6U7Sa56xZTbf7Kj6g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个可能场景的序列图(图片由作者提供)</p></figure><p id="a5dd" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">现在我们知道了条件变量是如何工作的(它们是如何使用互斥体的)，我们可以继续下一节来实现一个更有用的线程间通信机制，消息传递。</p><h1 id="3c70" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">线程间消息传递</h1><p id="2f88" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">我们上面的例子不是很有用或实用，因为它只是修改和检查一个<code class="fe ne nf ng nh b">int</code>。我们通常需要的是一种通信方式，从一个线程向另一个线程发送命令/消息。我们还需要有一个队列，这样发送线程就不用担心给接收线程CPU时间。我们可以使用一个受互斥体保护的<code class="fe ne nf ng nh b">std::queue</code>。</p><p id="2b71" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">现在我们来看一个例子。假设我们正在实现一个应用程序来控制一个智能灯泡，它具有以下要控制的功能:</p><ul class=""><li id="b9b9" class="nm nn it mi b mj mz mm na lw no lz np mc nq my nr ns nt nu bi translated">状态:开/关</li><li id="9bdb" class="nm nn it mi b mj nv mm nw lw nx lz ny mc nz my nr ns nt nu bi translated">强度:0–255</li><li id="eb04" class="nm nn it mi b mj nv mm nw lw nx lz ny mc nz my nr ns nt nu bi translated">颜色:红色(0–255)，绿色(0–255)，蓝色(0–255)</li></ul><p id="1446" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们有两个线程，一个是<code class="fe ne nf ng nh b">controller</code>，另一个是<code class="fe ne nf ng nh b">handler</code>。第一步是实现<code class="fe ne nf ng nh b">Message</code>结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9be7" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">接下来，我们创建处理函数。对于这个例子，我们只打印接收到的数据。在实际应用中，这些是我们控制实际硬件的地方。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8fab" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">现在，我们还可以通过创建两个函数来包装发送端和接收端，从而简化上面的条件变量实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="20a6" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><code class="fe ne nf ng nh b">GetMessage</code>函数将阻塞调用线程，直到收到一条消息，并返回所收到消息的副本。<code class="fe ne nf ng nh b">PutMessage</code>函数确保在推送新消息和通知接收线程之前获取互斥体。</p><p id="26cb" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated"><code class="fe ne nf ng nh b">controller</code>线程可以如下实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f674" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">并且<code class="fe ne nf ng nh b">handler</code>线程可以实现如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7ba6" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">一旦开始，<code class="fe ne nf ng nh b">handler</code>线程将等待接收消息。当接收到消息时，将检查其id，并将其参数传递给正确的函数处理程序。最后，我们可以创建一个简单的主函数来测试我们的程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="87c2" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">这个程序打印如下，它的工作！</p><pre class="kj kk kl km gt oa nh ob oc aw od bi"><span id="e15f" class="lr la it nh b gy oe of l og oh">SetState 1<br/>SetIntensity 255<br/>SetColor 255, 255, 255<br/>SetState 0</span></pre><h2 id="5b61" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">这种方法的问题是</h2><p id="88a9" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">这种方法的一个问题是，每次我们想要添加新消息时，我们都必须执行以下操作:</p><ul class=""><li id="ac93" class="nm nn it mi b mj mz mm na lw no lz np mc nq my nr ns nt nu bi translated">添加一个处理函数</li><li id="f022" class="nm nn it mi b mj nv mm nw lw nx lz ny mc nz my nr ns nt nu bi translated">修改<code class="fe ne nf ng nh b">Message</code>类，添加一个新的<code class="fe ne nf ng nh b">id</code>和一个新的<code class="fe ne nf ng nh b">param</code></li><li id="c87d" class="nm nn it mi b mj nv mm nw lw nx lz ny mc nz my nr ns nt nu bi translated">修改<code class="fe ne nf ng nh b">handler</code>线程，向<code class="fe ne nf ng nh b">switch</code>语句添加新的<code class="fe ne nf ng nh b">case</code></li></ul><p id="d951" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">这没什么大不了的，但是如果我们可以简单地注册一个处理程序就好了，这个处理程序可能是下列之一:</p><ul class=""><li id="ab90" class="nm nn it mi b mj mz mm na lw no lz np mc nq my nr ns nt nu bi translated">自由函数</li><li id="853e" class="nm nn it mi b mj nv mm nw lw nx lz ny mc nz my nr ns nt nu bi translated">兰姆达斯</li><li id="043a" class="nm nn it mi b mj nv mm nw lw nx lz ny mc nz my nr ns nt nu bi translated">功能对象</li><li id="391c" class="nm nn it mi b mj nv mm nw lw nx lz ny mc nz my nr ns nt nu bi translated"><code class="fe ne nf ng nh b">std::function</code>物体</li></ul><p id="3dc3" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们想要的是类似如下的东西:</p><pre class="kj kk kl km gt oa nh ob oc aw od bi"><span id="29dc" class="lr la it nh b gy oe of l og oh">Receiver receiver;<br/>receiver.Handle([](const Color&amp; color){});</span></pre><p id="30ed" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">它可以支持不同类型的调用，但是最有用的一个当然是使用lambda，正如你在上面看到的，因为我们可以在代码中看到处理程序，而不必跳到函数定义中。</p><h1 id="f689" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">抽象消息传递</h1><p id="52a8" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">要实现一个更简单的框架，请遵循以下步骤。</p><h2 id="e253" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">接收器类别</h2><p id="d3ea" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">首先，让我们创建一个名为<code class="fe ne nf ng nh b">Receiver</code>的类来包装接收线程以及管理处理程序。它应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="89c7" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们可以调用<code class="fe ne nf ng nh b">Receiver::Run()</code>来启动线程，<code class="fe ne nf ng nh b">Receiver::Join()</code>来加入线程。注意，我们对消息使用<code class="fe ne nf ng nh b">std::any</code>,因为我们希望能够接收任何类型，并将该类型传递给能够处理它的处理程序。</p><p id="dfc4" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们需要的下一件事是有一个<code class="fe ne nf ng nh b">std::vector</code>来存储我们的处理程序，并实现一个名为<code class="fe ne nf ng nh b">Handle()</code>的函数模板，该模板接收可调用对象并将其存储到我们的<code class="fe ne nf ng nh b">std::vector</code>中。</p><p id="4f2c" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">要实现它，我们需要两种技术，我们在以前的帖子中讨论过，即:</p><ul class=""><li id="0a9d" class="nm nn it mi b mj mz mm na lw no lz np mc nq my nr ns nt nu bi translated">类型擦除:包装任何类型的可调用程序，以便我们可以将它们存储在类似<code class="fe ne nf ng nh b">std::vector</code>的容器中</li><li id="5c0d" class="nm nn it mi b mj nv mm nw lw nx lz ny mc nz my nr ns nt nu bi translated">函数特征:检查函数的arity和参数类型</li></ul><p id="b344" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">如果你还不熟悉这些技术，可以看看我下面的文章。</p><div class="oi oj gp gr ok ol"><a href="https://towardsdatascience.com/c-type-erasure-wrapping-any-type-7f8511634849" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">C++类型擦除:包装任何类型</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">了解如何用C++编写类中任何类型的包装器，以提高代码的抽象层次。</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a rel="noopener  ugc nofollow" target="_blank" href="/inspecting-properties-of-callables-with-function-traits-in-c-6bb2d9388fc5"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">C++中用函数特征检验可调用函数的性质</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">理解我们如何检查可调用的属性来提高代码的抽象层次</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">better编程. pub</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz ks ol"/></div></div></a></div><h2 id="07cf" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">实现CallbackWrapper类</h2><p id="cde6" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">现在我们可以使用这两种技术实现<code class="fe ne nf ng nh b">CallbackWrapper</code>类。我们希望我们的类为以下各项提供接口:</p><ul class=""><li id="0cf2" class="nm nn it mi b mj mz mm na lw no lz np mc nq my nr ns nt nu bi translated">检查它是否可以接受类型作为参数，以及</li><li id="2b37" class="nm nn it mi b mj nv mm nw lw nx lz ny mc nz my nr ns nt nu bi translated">将调用转发到包装的对象，该对象可以是任何类型的可调用对象</li></ul><p id="05dd" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">所以我们实现了下面的基类/接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6d46" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">对于本文，我们限制我们的类只支持一个参数。接下来我们需要实现的是一个类模板，它实现了上面的接口，并使用<code class="fe ne nf ng nh b">function_traits</code>类模板生成<code class="fe ne nf ng nh b">arg_type</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1c8d" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们有两个<code class="fe ne nf ng nh b">operator()</code>重载，一个接受<code class="fe ne nf ng nh b">std::type_info</code>，如果类型匹配包装的可调用参数类型，则返回<code class="fe ne nf ng nh b">true</code>，否则返回<code class="fe ne nf ng nh b">false</code>。</p><p id="ff58" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">另一个接受<code class="fe ne nf ng nh b">std::any</code>并使用<code class="fe ne nf ng nh b">std::any_cast</code>将其转换为<code class="fe ne nf ng nh b">arg_type</code>，然后将其转发给包装的可调用函数。如果用错误的类型调用，它将抛出<code class="fe ne nf ng nh b">std::bad_any_cast</code>。</p><p id="945e" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">下面是<code class="fe ne nf ng nh b">CallbackWrapper</code>类的完整实现。您应该阅读上面链接的关于类型擦除的文章，以完全理解它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="60e0" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">实现句柄函数模板</h2><p id="901a" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">最后，我们的<code class="fe ne nf ng nh b">CallbackWrapper</code>类已经实现，现在我们可以返回到<code class="fe ne nf ng nh b">Receiver</code>类并添加<code class="fe ne nf ng nh b">std::vector&lt;CallbackWrapper&gt; callbackWrappers;</code>私有成员变量来存储我们的处理程序。我们可以添加一个名为<code class="fe ne nf ng nh b">Handle</code>的函数模板，它接受任何类型的调用，并将它们存储到<code class="fe ne nf ng nh b">callbackWrappers</code>容器中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5e97" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我们添加了一个<code class="fe ne nf ng nh b">static_assert</code>来让客户端代码知道我们只支持一种参数类型。然后我们实现我们的<code class="fe ne nf ng nh b">Consume()</code>线程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="26c7" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">如您所见，每次收到消息时，它都会遍历所有处理程序，检查处理程序是否可以接受该类型，如果可以，它将被调用来处理数据。</p><p id="8caa" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">请注意，对于同一数据类型，我们可以有多个处理程序。<code class="fe ne nf ng nh b">Receiver</code>类的完整实现如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="30ff" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">我们如何使用这个框架？</h2><p id="dd0d" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">这是我们在代码中使用它时的样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d6de" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">有了这个框架，<strong class="mi iu"> <em class="nk">我们在添加新消息时唯一需要做的事情</em> </strong>就是通过调用<code class="fe ne nf ng nh b">Handle</code>函数模板来注册处理程序。这比我们必须修改更多代码的原始版本要简单得多。</p><p id="3120" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">如果我们愿意，我们也可以注册函数对象，自由函数，或者<code class="fe ne nf ng nh b">std::function</code>对象。例如，我们可以在上面的例子中重用现有的免费函数。它看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="25a5" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我个人更喜欢lambda版本，因为我可以看到处理函数，而不必像自由函数版本那样跳到函数定义。</p><h1 id="d564" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><ul class=""><li id="56f0" class="nm nn it mi b mj mk mm mn lw pb lz pc mc pd my nr ns nt nu bi translated">C++通过包装线程、互斥体、条件变量等的POSIX实现来支持线程同步机制。</li><li id="319b" class="nm nn it mi b mj nv mm nw lw nx lz ny mc nz my nr ns nt nu bi translated">我们可以使用互斥锁通过锁定机制来同步多线程共享的资源的使用</li><li id="18f5" class="nm nn it mi b mj nv mm nw lw nx lz ny mc nz my nr ns nt nu bi translated">为了避免在睡眠和轮询中浪费CPU周期，我们可以使用条件变量来等待和发送信号</li><li id="ad95" class="nm nn it mi b mj nv mm nw lw nx lz ny mc nz my nr ns nt nu bi translated">使用<code class="fe ne nf ng nh b">std::queue</code>，我们可以为线程创建一个框架来发送和接收消息</li><li id="83ab" class="nm nn it mi b mj nv mm nw lw nx lz ny mc nz my nr ns nt nu bi translated">为了简化我们的框架，我们可以结合函数特征使用类型擦除技术</li><li id="730d" class="nm nn it mi b mj nv mm nw lw nx lz ny mc nz my nr ns nt nu bi translated">有了这个简化的框架，我们可以简单地注册我们的处理程序/回调函数，它可以是任何类型的可调用函数，剩下的由框架来处理</li></ul><p id="3393" class="pw-post-body-paragraph mg mh it mi b mj mz ju ml mm na jx mo lw nb mq mr lz nc mt mu mc nd mw mx my im bi translated">我希望你喜欢阅读这篇文章。</p></div></div>    
</body>
</html>