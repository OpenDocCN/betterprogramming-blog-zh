<html>
<head>
<title>iOS Notifications — The Whole Truth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS通知—全部真相</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ios-basic-questions-88e668cc95c7?source=collection_archive---------0-----------------------#2018-09-06">https://betterprogramming.pub/ios-basic-questions-88e668cc95c7?source=collection_archive---------0-----------------------#2018-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="304b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通知和通知中心的好处</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/456b86a0414f571022ab3c88ea344af2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bx4GCVNGkXHJWDdbssYnMA.gif"/></div></div></figure><p id="88e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然每篇文章都解释了iOS中通知的实现和用法，但很少有人充分强调基础知识。在这里，我试图强调这些被忽略的要点。</p><p id="f147" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe ln lo lp lq b">NotificationCenter</code>,你可以将数据从应用程序的一部分传播到另一部分。它使用<em class="lr">观察器模式</em>在通知到来时通知注册的观察器，使用中央调度器<code class="fe ln lo lp lq b">NotificationCenter</code>。</p><p id="53d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b"><em class="lr">NotificationCenter</em></code>到底是怎么工作的？</p><p id="78c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它有三个组成部分:</p><ul class=""><li id="59f9" class="ls lt iq kt b ku kv kx ky la lu le lv li lw lm lx ly lz ma bi translated">监听通知的“监听器”，称为<em class="lr">观察器</em></li><li id="9f3e" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">当事情发生时发送通知的“发送者”</li><li id="1431" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">通知中心本身，它跟踪观察者和通知</li></ul><p id="70e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">NSNotificationCenter可以处理一对多和多对多的通信。</p><h2 id="64fc" class="mg mh iq bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx my bi translated">什么时候用<code class="fe ln lo lp lq b">NotificationCenter</code>？</h2><ul class=""><li id="c92a" class="ls lt iq kt b ku mz kx na la nb le nc li nd lm lx ly lz ma bi translated">当没有正式连接的应用程序的两个或多个组件之间需要进行通信时</li><li id="2b7d" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">当交流需要重复和一致地发生时</li><li id="bdb9" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">当使用一对多或多对多通信时</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/0c93d796beea22d8f656167771e1c2e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*retOwqlt3Fe_teJiuxYmlw.png"/></div></div></figure><h2 id="3997" class="mg mh iq bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx my bi translated">如何注册观察员？</h2><pre class="kg kh ki kj gt nf lq ng nh aw ni bi"><span id="7b89" class="mg mh iq lq b gy nj nk l nl nm">NotificationCenter.default.addObserver(self, selector: #selector(onDidReceiveData(_:)), name: .didReceiveData, object: nil)</span></pre><p id="9c5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">addObserver(_:selector:name:object:)</code>函数有四个参数:</p><ul class=""><li id="64e8" class="ls lt iq kt b ku kv kx ky la lu le lv li lw lm lx ly lz ma bi translated">第一个参数<code class="fe ln lo lp lq b">observer</code>是未命名的<em class="lr">。</em>您为它提供一个对象的引用，该对象是这个通知的<em class="lr">观察者</em>，通常是<code class="fe ln lo lp lq b">self</code>。</li><li id="96fc" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">第二个参数<code class="fe ln lo lp lq b">selector</code>是通知发生时调用的函数。它的工作原理类似于<em class="lr">目标-行动模式。</em></li><li id="aaf0" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">第三个参数<code class="fe ln lo lp lq b">name</code>是您想要监听的通知的名称，类型为<code class="fe ln lo lp lq b">Notification.Name</code>。</li><li id="c0b8" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">第四个参数<code class="fe ln lo lp lq b">object</code>是一个可选对象，您希望接收其通知，所以如果您设置了它，您将只接收来自那个“发送者”的通知</li></ul><h2 id="703a" class="mg mh iq bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx my bi translated">如何添加通知？</h2><pre class="kg kh ki kj gt nf lq ng nh aw ni bi"><span id="16e1" class="mg mh iq lq b gy nj nk l nl nm">extension Notification.Name {     <br/>static let didReceiveData = Notification.Name("didReceiveData")     static let didCompleteTask = Notification.Name("didCompleteTask")     static let completedLengthyDownload = Notification.Name("completedLengthyDownload") <br/>}</span><span id="b7ed" class="mg mh iq lq b gy nn nk l nl nm">NotificationCenter.default.addObserver(self, selector: [selector], name: .didCompleteTask, object: nil)</span></pre><h2 id="d9ab" class="mg mh iq bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx my bi translated">如何发布通知？</h2><pre class="kg kh ki kj gt nf lq ng nh aw ni bi"><span id="3cf8" class="mg mh iq lq b gy nj nk l nl nm">NotificationCenter.default.postNotification(name: .didReceiveData, object: nil)</span></pre><p id="cfab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">onDidReceiveData(_:)</code>功能看起来是这样的:</p><pre class="kg kh ki kj gt nf lq ng nh aw ni bi"><span id="559a" class="mg mh iq lq b gy nj nk l nl nm">@objc func onDidReceiveData(_ notification: Notification)  <br/>{     if let data = notification.userInfo as? [String: Int]     <br/>      {         <br/>           for (name, score) in data         <br/>           {             <br/>               print("\(name) has sent \(score) points!")         <br/>           }     <br/>      } <br/>} </span></pre><p id="21f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的例子中，情况是这样的:</p><ul class=""><li id="57d8" class="ls lt iq kt b ku kv kx ky la lu le lv li lw lm lx ly lz ma bi translated">首先，你使用<em class="lr">条件绑定</em>到<em class="lr">向下转换</em>的类型<code class="fe ln lo lp lq b">userInfo</code>到<code class="fe ln lo lp lq b">[String: Int]</code>与<em class="lr">类型转换操作符</em> <code class="fe ln lo lp lq b">as?</code>。因为<code class="fe ln lo lp lq b">userInfo</code>的类型是<code class="fe ln lo lp lq b">[AnyHashable: Any]?</code>——基本上是<em class="lr">任何字典</em>——你可以将它的类型向下转换为你期望的字典类型。那是字符串键，上面例子中的整数值。如果转换成功，那么<code class="fe ln lo lp lq b">data</code>包含<code class="fe ln lo lp lq b">userInfo</code>的值作为类型<code class="fe ln lo lp lq b">[String: Int]</code>。</li><li id="0049" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">然后，使用一个<code class="fe ln lo lp lq b">for-in</code>循环，迭代<code class="fe ln lo lp lq b">data</code>字典中的条目。我们使用元组<code class="fe ln lo lp lq b">(name, score)</code>来分解字典条目的键和值。</li><li id="5bb7" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">最后，在循环内部，我们打印出名字和分数。</li></ul><p id="2659" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要发布包含数据的通知，我们需要执行以下操作:</p><pre class="kg kh ki kj gt nf lq ng nh aw ni bi"><span id="58d3" class="mg mh iq lq b gy nj nk l nl nm">let scores = ["A": 5, "B": 3, "C": 42]  NotificationCenter.default.postNotification(name: .didReceiveData, object: self, userInfo: scores)</span></pre><p id="9429" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个类可能是这样的:</p><pre class="kg kh ki kj gt nf lq ng nh aw ni bi"><span id="ff8c" class="mg mh iq lq b gy nj nk l nl nm">class API  <br/>{     <br/>        static let shared = API()      <br/>        func getData() <br/>        {                          </span><span id="f8d2" class="mg mh iq lq b gy nn nk l nl nm">          NotificationCenter.default.postNotification(name: .didReceiveData, object: self, userInfo: ...)       <br/>        }<br/>}</span></pre></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="b725" class="nv mh iq bd mi nw nx ny ml nz oa ob mo jw oc jx mr jz od ka mu kc oe kd mx of bi translated"><strong class="ak">总结</strong></h1><ul class=""><li id="42f0" class="ls lt iq kt b ku mz kx na la nb le nc li nd lm lx ly lz ma bi translated">首先，用<code class="fe ln lo lp lq b">addObserver(_:selector:name:object:)</code>注册一个通知的观察者</li><li id="c07c" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">然后，发布一个通知，内容为:<code class="fe ln lo lp lq b">postNotification(name:object:userInfo:)</code> …</li><li id="f27a" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">…之后会调用您的<em class="lr">选择器</em></li><li id="f5c1" class="ls lt iq kt b ku mb kx mc la md le me li mf lm lx ly lz ma bi translated">不要忘记用<code class="fe ln lo lp lq b">removeObserver(...)</code>移除观察器</li></ul><p id="9685" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe ln lo lp lq b">NotificationCenter</code>进行重复、一致的一对多或多对多通信。</p><h2 id="bef4" class="mg mh iq bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx my bi translated"><strong class="ak">通知与代表</strong></h2><p id="aa27" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la og lc ld le oh lg lh li oi lk ll lm ij bi translated">通知更像是无线电广播。从任何对象广播；任何其他文件都可以收听该通知，观察它并调用一个操作。重要的是要记住通知是没有保证的。如果文件已被取消初始化，它将不再侦听通知广播，您的应用程序可能无法正常工作。</p><p id="d784" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">委托允许我们向创建子视图的类发送信息。只要将子类的委托设置为父类，然后在需要传递信息时调用子类内部的委托方法，就可以保证信息流。与通知不同，父节点肯定会收到来自子节点的信息，因为如果父节点被取消初始化，子节点也会被取消初始化。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="241a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读！</p><p id="a34b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">即将推出:代表团—全部真相</p></div></div>    
</body>
</html>