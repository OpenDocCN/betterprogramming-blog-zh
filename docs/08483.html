<html>
<head>
<title>3 Lines of Code That Really Messed Up My Day</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">三行代码让我的一天变得一团糟</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-lines-of-code-that-really-messed-up-my-day-52c936aa7413?source=collection_archive---------3-----------------------#2021-05-05">https://betterprogramming.pub/3-lines-of-code-that-really-messed-up-my-day-52c936aa7413?source=collection_archive---------3-----------------------#2021-05-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5d62" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">只是一些有趣的台词，让我对着桌子上的东西大喊大叫</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/84265285acce86d74650ca06ac79d786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3cuRoEt-88bLmkGJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@spanic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Damir spanick</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="163d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码很有趣——通常是这样。有时你只是坐在那里，想知道这一行代码是否真的值得它引起的所有麻烦。你想知道你是否应该辞职，收工，拿着那份丰厚的薪水，把它投资到当地街角商店的所有酒类上。</p><p id="c4af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有三个特殊的例子，它们本身看起来无害，但却花费了我一天甚至一周的时间。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7402" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">；提交；</h1><p id="3349" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从简单的开始:别人写的SQL脚本。就我个人而言，我总是使用Toad For Oracle中的提交按钮，该按钮基本上允许您运行脚本，查看它影响了多少行，然后如果有任何意义，您可以提交更改。当然，这是在首先测试<code class="fe mz na nb nc b">select</code>然后运行更新的常规方法之上的。</p><p id="80c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这一次，我依赖于别人写的脚本——有人喜欢把提交命令放在脚本的末尾。换句话说，一个知道自己在做什么并且不需要退路的人。</p><p id="fff8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我在我的<code class="fe mz na nb nc b">select</code>语句中留下了测试条件的一部分，它不应该包含在最终的脚本中。但是，天哪，我刚刚用错误的值更新了数据库中的3000多行。</p><p id="6b9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">花了一整天来清理这些混乱，包括不得不依赖来自测试数据库的条目，并将它们映射到生产数据库。真是一场噩梦。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b7f9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">。ToList()。FirstOrDefault(x = &gt; x . status = = open)</h1><p id="94e2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这实际上是我一直以来最喜欢的bug之一。这一行代码花费了一个五人团队一周的时间来查找和修复。</p><p id="1a56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的队列函数中有一个性能漏洞，它有一个非常奇怪的症状:只要您运行具有1000个或更少打开任务的队列的代码，它就不会出现任何问题——它实际上非常快。一旦运行的时间超过这个数(在5，000个或更多未完成任务的情况下)，获取队列的时间会突然增加2-3分钟，并且随着队列的增大会成倍增加。</p><p id="1549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发现这个bug的真正问题是上面的代码行完全有效。你可以读一百遍，看不出有什么问题。事实上，我们最初认为问题出在数据库或数据库映射上——甚至在我们用性能检查工具查看代码之后。</p><p id="c676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直到很晚，有人才意识到，我们基本上有一个不必要的调用，因为一个函数调用返回了一个列表，然后这个列表被LINQ查询求值。通过转换为列表，整个队列对象被反序列化为一个对象，然后立即再次序列化为一个可查询的对象。这个过程依赖于每次都将整个对象加载到系统RAM中——可能每分钟数百次。只要有一个小队列要加载到RAM中，这并不重要，但是它很快就必须依赖HDD上的内存不足存储。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fdb0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">通过StringBuilder构造的错误消息</h1><p id="0e51" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">好家伙，这个让我大吃一惊。我们有一个我们无法理解的错误信息。我们不知道它来自哪里，也不知道它是生成日志文件的系统中的错误，还是该系统调用的远程服务。</p><p id="69c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使对错误消息进行全文搜索也没有结果——我们无法调试它，因为我们甚至不知道应该调试哪个解决方案。</p><p id="a402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这在一条随机发现的信息中总结如下:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b371" class="nh md it nc b gy ni nj l nk nl">String message = sb.Append({Part,of,the,error,message});</span></pre><p id="5683" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体细节还不清楚。我只知道，最后，我在搜索了所有结果后找到了句子的一部分，这完全是偶然的。我也不记得为什么这个东西会在那里——只记得我给每个人看的时候，他们的眼睛都有点抽搐。</p><p id="2554" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这尤其令人恼火，因为它混淆了实际的堆栈跟踪，而这本来会更有帮助，然后用非常简单的日志记录将它记录到一个文本文件中，甚至不显示行号或来源。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9938" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">要点:分离和混淆是真正的混蛋</h1><p id="29e7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在编码中，有一些事情是我真正讨厌的。几乎所有这些都让你陷入了一个循环，混淆了真正的源代码或真正的错误消息。</p><p id="69f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖注入是另一个例子，堆栈跟踪通常距离错误的实际来源有一光年远。至少在那些情况下，你通常可以确定一个起点。</p><p id="395c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，这里有一些我写的其他文章:</p><div class="nm nn gp gr no np"><a href="https://levelup.gitconnected.com/looking-for-a-profitable-coding-project-take-this-one-d94bc061705e" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">寻找一个有利可图的编码项目？拿着这个</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">这是一个有真实需求、真实用途和巨大潜力的项目</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ks np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://levelup.gitconnected.com/the-ideals-of-software-development-that-i-strive-for-fcac46a7b2e8" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">我为之奋斗的软件开发的理想</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">作为对我最近关于有害程序员的帖子的回应</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od ks np"/></div></div></a></div></div></div>    
</body>
</html>