<html>
<head>
<title>A Full-Featured Hotkeys Library in 200 Lines of JavaScript Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">200行JavaScript代码的全功能热键库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/full-featured-hotkeys-library-in-200-lines-of-javascript-code-81a74e3138cc?source=collection_archive---------3-----------------------#2019-08-20">https://betterprogramming.pub/full-featured-hotkeys-library-in-200-lines-of-javascript-code-81a74e3138cc?source=collection_archive---------3-----------------------#2019-08-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a088" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">干净、可测试且无依赖性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5f4786dc3177e2381ab8f0891987f6dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YPkc-c3Rp4vy4pikejK0VQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@skabrera" rel="noopener ugc nofollow" target="_blank"> Sergi Kabrera </a>在<a class="ae ky" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1d04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我很乐意分享我的发现，如何用200行代码创建一个全功能、干净和可测试的热键库，没有依赖性。</p><p id="b7ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然有一些类似的现有<a class="ae ky" href="https://github.com/search?q=hotkeys+javascript" rel="noopener ugc nofollow" target="_blank">项目</a>，如果你问我的话，这仍然是一个有趣的练习。</p><h1 id="4506" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">要求</h1><p id="1924" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">该库应支持各种组合键:</p><ul class=""><li id="651e" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">像<code class="fe nb nc nd ne b">a</code>、<code class="fe nb nc nd ne b">b</code>、<code class="fe nb nc nd ne b">c</code>这样的单键</li><li id="eafb" class="ms mt it lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated">带修饰键:<code class="fe nb nc nd ne b">ctrl+c</code>、<code class="fe nb nc nd ne b">ctrl+v</code>、<code class="fe nb nc nd ne b">ctr+shift+v</code></li><li id="1778" class="ms mt it lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated">按键顺序:<code class="fe nb nc nd ne b">h e l l o</code>、<code class="fe nb nc nd ne b">ctrl+k</code>、<code class="fe nb nc nd ne b">ctrl+t a</code></li></ul><p id="4fa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它应该有以下选项:</p><ul class=""><li id="149b" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">注册和取消注册特定热键的回拨</li><li id="2e84" class="ms mt it lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated">创建热键上下文，以便可以单独打开/关闭侦听器组</li></ul></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="f52c" class="lv lw it bd lx ly nr ma mb mc ns me mf jz nt ka mh kc nu kd mj kf nv kg ml mm bi translated">履行</h1><p id="af86" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我使用的是<a class="ae ky" href="https://www.tutorialspoint.com/es6/" rel="noopener ugc nofollow" target="_blank"> ES6 </a>语法，所以请确保您至少熟悉块范围的变量、箭头函数、对象析构和模板字符串。</p><p id="8d46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将分别描述每一个功能，做一些重构，添加验证，然后在最后展示所有代码。</p><p id="a55d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文不包括如何在浏览器中运行ES6模块。如果你还不知道这一点，就从像<a class="ae ky" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>这样的transpiler开始吧。</p><h2 id="3bd6" class="nw lw it bd lx nx ny dn mb nz oa dp mf li ob oc mh lm od oe mj lq of og ml oh bi translated">注册热键</h2><p id="4940" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在第一阶段，我们需要创建一个为特定热键注册回调的函数。该函数获得一个热键(字符串)和一个回调函数，并存储起来以备将来重用。姑且称之为<code class="fe nb nc nd ne b">register</code>:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="7f14" class="nw lw it ne b gy om on l oo op">const listeners = [];<br/>const register = (hotkey, callback) =&gt; {<br/>  listeners.push({ hotkey: normalizeHotkey(hotkey), callback });<br/>}</span></pre><p id="7887" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个<code class="fe nb nc nd ne b">listeners</code>数组:这是一个用于注册回调的包。我们稍后将处理数组，但是现在，请注意<code class="fe nb nc nd ne b">normalizeHotkey</code>函数。</p><p id="4db7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数将热键字符串转换为一个结构，该结构:</p><ul class=""><li id="772a" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">容易(有效)与他人进行比较，并且</li><li id="1b04" class="ms mt it lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated">很容易(有效)从键盘事件中创建</li></ul><p id="7fd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的原因是不同的字符串可能对应同一个热键。比如<code class="fe nb nc nd ne b">ctrl+shift+s</code>和<code class="fe nb nc nd ne b">shift+ctrl+s</code>指的是同一个组合，可能很难和键盘事件直接匹配。</p><p id="40fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数将字符串转换为字典数组。字典键保存一个实际的键，其值为<code class="fe nb nc nd ne b">true</code>。</p><p id="2006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是如何工作的一些例子:</p><ul class=""><li id="44e9" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><code class="fe nb nc nd ne b">normalizeHotkey('a')</code>回报<code class="fe nb nc nd ne b">[{ a: true }]</code></li><li id="ca7e" class="ms mt it lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated"><code class="fe nb nc nd ne b">normalizeHotkey('ctrl+a')</code>回报<code class="fe nb nc nd ne b">[{ ctrl: true, a: true }]</code></li><li id="0181" class="ms mt it lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated"><code class="fe nb nc nd ne b">normalizeHotkey('meta+a shift+b')</code>返回<br/> <code class="fe nb nc nd ne b">[{ meta: true, a: true }, { shift: true, b: true }]</code></li></ul><p id="a526" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实施:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="c5c3" class="nw lw it ne b gy om on l oo op">const arrayToObject = arr =&gt; arr.reduce(<br/>  (obj, key) =&gt; ({ ...obj, [key]: true }),<br/>  {},<br/>);</span><span id="6d90" class="nw lw it ne b gy oq on l oo op">const normalizeHotkey = (hotkey) =&gt;<br/>  hotkey.split(' ').map((part) =&gt; arrayToObject(part.split('+')));</span></pre><h2 id="fe6d" class="nw lw it bd lx nx ny dn mb nz oa dp mf li ob oc mh lm od oe mj lq of og ml oh bi translated">按键监听器</h2><p id="299b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">好了，我们注册完了。现在我们需要设置一个keydown监听器。</p><p id="a43d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们支持多个组合键，所以我们需要存储后续的keydown事件，以确定一系列事件是否与组合键匹配。</p><p id="522d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次按下键时，事件描述都会添加到缓冲区数组中，并且只要keydown事件被触发，它就会继续增长。我们不希望在一段时间不活动后继续匹配热键，因此必须在keydown监听器停止触发一段时间后清除缓冲区。</p><p id="49d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法称为去抖。如果你还不熟悉这个概念，我建议你看看类似于<a class="ae ky" href="https://css-tricks.com/debouncing-throttling-explained-examples/#article-header-id-0" rel="noopener ugc nofollow" target="_blank"> this </a>的文章。</p><p id="a476" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接受函数和去抖时间作为参数的<code class="fe nb nc nd ne b">debounce</code>函数的最小实现。该函数返回“去抖”函数:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="c51d" class="nw lw it ne b gy om on l oo op">const debounce = (fn, time) =&gt; {<br/>  let timeoutId = null;</span><span id="b2d8" class="nw lw it ne b gy oq on l oo op">  return () =&gt; {<br/>    clearTimeout(timeoutId);<br/>    timeoutId = setTimeout(fn, time);<br/>  };<br/>};</span></pre><p id="5a6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">keydown监听器实现:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="7e9b" class="nw lw it ne b gy om on l oo op">let buffer = [];</span><span id="764d" class="nw lw it ne b gy oq on l oo op">const clearBufferDebounced = debounce(<br/>  () =&gt; { buffer = []; },<br/>  debounceTime,<br/>);</span><span id="377b" class="nw lw it ne b gy oq on l oo op">const keyDownListener = (event) =&gt; {<br/>  if (event.repeat) {<br/>    return;<br/>  }</span><span id="3896" class="nw lw it ne b gy oq on l oo op">  if (event.getModifierState(event.key)) {<br/>    return;<br/>  }</span><span id="a8d7" class="nw lw it ne b gy oq on l oo op">  clearBufferDebounced();</span><span id="f0cd" class="nw lw it ne b gy oq on l oo op">  const description = {<br/>    [getKey(event.key)]: true,<br/>  };</span><span id="a5c1" class="nw lw it ne b gy oq on l oo op">  allModifiers.forEach((m) =&gt; {<br/>    if (event[`${m}Key`]) {<br/>      description[m] = true;<br/>    }<br/>  });</span><span id="4c98" class="nw lw it ne b gy oq on l oo op">  buffer.push(description);</span><span id="2e6b" class="nw lw it ne b gy oq on l oo op">  listeners.forEach((listener) =&gt; {<br/>    if (matchHotkey(buffer, listener.hotkey)) {<br/>      listener.callback(event);<br/>    }<br/>  });<br/>};</span></pre><p id="13c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主逻辑检查每个侦听器，并在与缓冲区匹配时调用其回调。</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="e191" class="nw lw it ne b gy om on l oo op">listeners.forEach((listener) =&gt; {<br/>  if (matchHotkey(buffer, listener.hotkey)) {<br/>    listener.callback(event);<br/>  }<br/>});</span></pre><p id="7c60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，该事件必须满足以下条件才能到达。</p><p id="8dd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您按住某个键一段时间，它可能会开始重复触发keydown事件。这种行为是不可取的，我们必须找到一种方法来忽略这种事件。</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="1b10" class="nw lw it ne b gy om on l oo op">if (event.repeat) {<br/>  return;<br/>}</span></pre><p id="c1f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您按下修饰键本身时，该事件也会被忽略:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="2b56" class="nw lw it ne b gy om on l oo op">if (event.getModifierState(event.key)) {<br/>  return;<br/>}</span></pre><p id="a749" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方法<code class="fe nb nc nd ne b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState" rel="noopener ugc nofollow" target="_blank">event.getModifierState</a></code>接受修饰键的字符串表示，如果当前键是修饰键，则返回true。更多详情参见<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="1bc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解释我们为什么需要这个，让我们考虑一个热键序列<code class="fe nb nc nd ne b">ctrl+c ctrl+k</code>。我们可以通过两种方式实现这一目标:</p><ul class=""><li id="9bcd" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">按住<code class="fe nb nc nd ne b">control</code>并按下<code class="fe nb nc nd ne b">c</code>然后按下<code class="fe nb nc nd ne b">k</code>；或者</li><li id="c087" class="ms mt it lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated">按住<code class="fe nb nc nd ne b">control</code>并按下<code class="fe nb nc nd ne b">c</code>，松开<code class="fe nb nc nd ne b">control</code>然后再次按住并按下<code class="fe nb nc nd ne b">k</code></li></ul><p id="2ee2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个将导致三个事件存储在缓冲区中— <code class="fe nb nc nd ne b">ctrl ctrl+c ctrl+k</code>。由于<code class="fe nb nc nd ne b">ctrl+c ctrl+k</code>与缓冲区匹配，所以会按预期工作。</p><p id="ee70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">后者导致四个事件— <code class="fe nb nc nd ne b">ctrl ctrl+c ctrl ctrl+k</code>。由于在<code class="fe nb nc nd ne b">ctrl+c</code>和<code class="fe nb nc nd ne b">ctrl+k</code>之间有一个<code class="fe nb nc nd ne b">ctrl</code>事件，所以序列不会匹配。</p><p id="ea7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，你是对的，这是一个极限。因此，您不能只绑定到修饰键。像<code class="fe nb nc nd ne b">shift</code>、<code class="fe nb nc nd ne b">ctrl</code>或<code class="fe nb nc nd ne b">alt</code>这样的热键不起作用。这种情况将在以后的验证中涉及。</p><p id="d95b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">description</code>变量保持规范化的热键定义——与我们存储在<code class="fe nb nc nd ne b">listeners</code>数组中的格式相同。</p><p id="d95d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我决定使用<code class="fe nb nc nd ne b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key" rel="noopener ugc nofollow" target="_blank">ke</a>y</code>属性，因为<code class="fe nb nc nd ne b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode" rel="noopener ugc nofollow" target="_blank">keyCode</a></code>、<code class="fe nb nc nd ne b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/charCode" rel="noopener ugc nofollow" target="_blank">charCode</a></code>、<code class="fe nb nc nd ne b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/which" rel="noopener ugc nofollow" target="_blank">which</a></code>已经过时。</p><p id="f117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">属性保存了键盘按键的打印表示，因此我们不必编写定制逻辑来找出当前按键是什么。</p><p id="d37b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要处理两个异常——空格键和加号。我们在传递给register和unregister函数的热键字符串中使用两者作为分隔符。</p><p id="0f34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方法是将<code class="fe nb nc nd ne b">' '</code>替换为<code class="fe nb nc nd ne b">'space'</code>，将<code class="fe nb nc nd ne b">'+'</code>替换为<code class="fe nb nc nd ne b">'plus'</code>:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="6d4c" class="nw lw it ne b gy om on l oo op">const getKey = (key) =&gt; {<br/>  switch (key) {<br/>    case '+': <br/>      return 'plus';<br/>    case ' ':<br/>      return 'space';<br/>    default: <br/>      // may be an uppercased letter, in case the shift is active<br/>      return key.toLowerCase(); <br/>  }<br/>};</span></pre><p id="72e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">allModifiers</code>数组包含一个修饰符列表，它用于填充描述图。引入它是为了避免冗余语法，如:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="ac0a" class="nw lw it ne b gy om on l oo op">(...)<br/>if (event.ctrlKey) {<br/>  description.ctrl = true;<br/>}</span><span id="c2a2" class="nw lw it ne b gy oq on l oo op">if (event.shiftKey) {<br/>  description.shift = true;<br/>}<br/>(...)</span></pre><p id="ba9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能认为我们可以直接设置所有的修饰符，比如:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="c277" class="nw lw it ne b gy om on l oo op">const description = {<br/>  (...)<br/>  ctrl: event.ctrlKey,<br/>  shift: event.shiftKey,<br/>  alt: event.altKey,<br/>  meta: event.metaKey<br/>}</span></pre><p id="21de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它看起来整洁干净，但与从<code class="fe nb nc nd ne b">normalizeHotkey</code>函数返回的确切状态不匹配——后者只包括被按下的键。<br/>当前的实现似乎有些粗糙，因为它假设事件对象中有<code class="fe nb nc nd ne b">*Key</code>个属性(<code class="fe nb nc nd ne b">ctrlKey</code>、<code class="fe nb nc nd ne b">altKey</code>、<code class="fe nb nc nd ne b">shiftKey</code>、<code class="fe nb nc nd ne b">metaKey</code>):</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="369e" class="nw lw it ne b gy om on l oo op">allModifiers.forEach((m) =&gt; {<br/>  if (event[`${m}Key`]) {<br/>    description[m] = true;<br/>  }<br/>});</span></pre><p id="151e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使有效，我们也仅限于这四个修改器。另一个解决方案是像这样使用<code class="fe nb nc nd ne b">event.getModifierState</code>:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="7822" class="nw lw it ne b gy om on l oo op">allModifiers.forEach((m) =&gt; {<br/>  if (event.getModifierState(m) {<br/>    description[m.toLowerCase()] = true;<br/>  }<br/>});</span></pre><p id="14b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来更好。然而:</p><ul class=""><li id="87c5" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">它要求你操作常规和小写的名字</li><li id="a51b" class="ms mt it lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated"><code class="fe nb nc nd ne b">ctrl</code>变成了<code class="fe nb nc nd ne b">control</code>——如果你想保留<code class="fe nb nc nd ne b">ctrl</code>，你需要将它映射到<code class="fe nb nc nd ne b">normalizeHotkeyMethod</code></li></ul><p id="54d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我只是想让你知道一个可能的改进。</p><p id="ddc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，将<code class="fe nb nc nd ne b">description</code>添加到<code class="fe nb nc nd ne b">buffer</code>数组中，然后对照<code class="fe nb nc nd ne b">listeners</code>进行检查。</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="8c92" class="nw lw it ne b gy om on l oo op">buffer.push(description);<br/>listeners.forEach((listener) =&gt; {<br/>  if (matchHotkey(buffer, listener.hotkey)) {<br/>    listener.callback(event);<br/>  }<br/>});</span></pre><h2 id="4f25" class="nw lw it bd lx nx ny dn mb nz oa dp mf li ob oc mh lm od oe mj lq of og ml oh bi translated">匹配算法</h2><p id="b645" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">该算法检查缓冲区是否包含热键数组中的后续元素。</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="1d16" class="nw lw it ne b gy om on l oo op">const isEqual = (a, b) =&gt; {<br/>  const aKeys = Object.keys(a);<br/>  if (aKeys.length !== Object.keys(b).length) {<br/>    return false;<br/>  }</span><span id="74c0" class="nw lw it ne b gy oq on l oo op">  return aKeys.every(<br/>    (k) =&gt; b.hasOwnProperty(k) &amp;&amp; a[k] === b[k]<br/>  );<br/>}</span><span id="faf1" class="nw lw it ne b gy oq on l oo op">const matchHotkey = (buffer, hotkey) =&gt; {<br/>  if (buffer.length &lt; hotkey.length) {<br/>    return false<br/>  }</span><span id="e4a6" class="nw lw it ne b gy oq on l oo op">  const indexDiff = buffer.length - hotkey.length;<br/>  for(let i = hotkey.length - 1; i &gt;= 0; i--) {<br/>    if(!isEqual(buffer[indexDiff + i], hotkey[i])) {<br/>      return false;<br/>    }<br/>  }<br/>  return true;<br/>}</span></pre><p id="87dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它得到一个<code class="fe nb nc nd ne b">buffer</code>数组和<code class="fe nb nc nd ne b">hotkey</code>序列。当<code class="fe nb nc nd ne b">buffer</code>的元素比<code class="fe nb nc nd ne b">hotkey</code>少时，返回<code class="fe nb nc nd ne b">false</code>。否则，它以相反的顺序遍历<code class="fe nb nc nd ne b">hotkey</code>数组，并检查<code class="fe nb nc nd ne b">buffer</code>中的相应元素是否相等。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="9c2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">isEqual</code>函数中的附加条件是避免可能的假阳性结果。如果<code class="fe nb nc nd ne b">a[k]</code>存在，但值未定义，并且<code class="fe nb nc nd ne b">b</code>对象不包含关键字<code class="fe nb nc nd ne b">k</code>，条件<code class="fe nb nc nd ne b">a[k] === b[k]</code>返回true，因为两个值都是<code class="fe nb nc nd ne b">undefined</code>——但这不应该。这就是检查<code class="fe nb nc nd ne b">b</code>是否包含钥匙的原因。</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="d69f" class="nw lw it ne b gy om on l oo op">b.hasOwnProperty(k) &amp;&amp; a[k] === b[k]</span></pre><p id="3b26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比较<code class="fe nb nc nd ne b">buffer</code>和<code class="fe nb nc nd ne b">hotkey</code>时不会出现这种情况，因为<code class="fe nb nc nd ne b">buffer</code>没有空值。考虑到它的一般用途，我将为将来保留这个条件。安全总比后悔好。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="1ca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面有一个可视化。动画展示了算法是如何工作的，从空缓冲区开始。考虑这里注册的热键是<code class="fe nb nc nd ne b">a b c</code>，键盘接收的是<code class="fe nb nc nd ne b">a b d c a b c</code>序列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/cdb9f1323365a2f5cff42822abbb18a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jCExoPak1BaQWq6IbFnJAw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">匹配算法—最佳</p></figure><p id="c8d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">红色表示不匹配，黄色表示部分匹配，绿色表示完全匹配。</p><p id="6d79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一句，有一个从头到尾迭代的选项，但是它更糟糕，因为它需要执行更多的冗余检查。参见下面的动画:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/26af5d57b1f0d7556629e8e0e2c418cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hN66VzH-joW95-yOdGAEmA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">匹配算法—错误</p></figure><h2 id="6ecf" class="nw lw it bd lx nx ny dn mb nz oa dp mf li ob oc mh lm od oe mj lq of og ml oh bi translated">注销热键</h2><p id="59e8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">应该有一个选项来删除注册的热键。该函数接受与register函数相同的参数—作为字符串的热键序列和回调函数。该函数从<code class="fe nb nc nd ne b">listeners</code>数组中删除匹配的元素。</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="9ad3" class="nw lw it ne b gy om on l oo op">const isArrayEqual = (a, b) =&gt; <br/>  a.length === b.length &amp;&amp; a.every((v, i) =&gt; isEqual(v, b[i]));</span><span id="a8d1" class="nw lw it ne b gy oq on l oo op">const unregister = (hotkeyString, callback) =&gt; {<br/>  const normalized = normalizeHotkey(hotkeyString);</span><span id="d37a" class="nw lw it ne b gy oq on l oo op">  const index = listeners.findIndex(<br/>    (l) =&gt; l.callback === callback <br/>      &amp;&amp; isArrayEqual(normalized, l.hotkey)<br/>  );</span><span id="0800" class="nw lw it ne b gy oq on l oo op">  if (index !== -1) {<br/>    listeners.splice(index, 1);<br/>  }<br/>}</span></pre><p id="e7c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，它不比较字符串，而是比较规范化的热键定义为两个不同的字符串，如<code class="fe nb nc nd ne b">shift+ctr+c</code>和<code class="fe nb nc nd ne b">ctrl+shift+c</code>。这些指的是同一个组合，必须视为相等。</p><p id="4388" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">isArrayEqual</code>检查数组是否相等。换句话说:如果它们长度相同，并且每一项都相同。我们之前介绍过的<code class="fe nb nc nd ne b">isEqual</code>函数被重用来比较数组项。</p><h2 id="8c28" class="nw lw it bd lx nx ny dn mb nz oa dp mf li ob oc mh lm od oe mj lq of og ml oh bi translated">热键上下文</h2><p id="c21e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这一部分中，我们将封装逻辑，这样我们就可以创建具有自己的<code class="fe nb nc nd ne b">listeners</code>状态和自定义<code class="fe nb nc nd ne b">debounceTime</code>值的独立上下文。</p><p id="4000" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数将在公共API中对用户可用。</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="4146" class="nw lw it ne b gy om on l oo op">const registerListener = (listeners, hotkey, callback) =&gt; {<br/>  listeners.push({ hotkey: normalizeHotkey(hotkey), callback });<br/>};</span><span id="cf41" class="nw lw it ne b gy oq on l oo op">const unregisterListener = (listeners, hotkey, callback) =&gt; {<br/> <strong class="ne iu"> // (...) the unregister logic</strong><br/>};</span><span id="c5bd" class="nw lw it ne b gy oq on l oo op">const createKeyDownListener = (listeners, debounceTime) =&gt; {<br/>  let buffer = [];<br/>  const clearBufferDebounced = debounce(<br/>    () =&gt; { buffer = []; },<br/>    debounceTime,<br/>  );<br/>  return (event) =&gt; {<br/><strong class="ne iu">    // (...) contents of the former keyDownListener </strong><br/>  };<br/>};</span><span id="19ab" class="nw lw it ne b gy oq on l oo op">export const createContext = (<br/>  { debounceTime = 500, autoEnable = true } = {},<br/>) =&gt; {<br/>  const listeners = [];</span><span id="7a28" class="nw lw it ne b gy oq on l oo op">  const register = (hotkey, callback) =&gt; {<br/>    registerListener(listeners, hotkey, callback);<br/>  };</span><span id="1ad9" class="nw lw it ne b gy oq on l oo op">  const unregister = (hotkey, callback) =&gt; {<br/>    unregisterListener(listeners, hotkey, callback);<br/>  };</span><span id="06fc" class="nw lw it ne b gy oq on l oo op">  const keyDownListener = createKeyDownListener(<br/>    listeners,<br/>    debounceTime,<br/>  );</span><span id="9282" class="nw lw it ne b gy oq on l oo op">  const enable = () =&gt; document.addEventListener(<br/>    'keydown',<br/>    keyDownListener,<br/>  );</span><span id="bc69" class="nw lw it ne b gy oq on l oo op">  const disable = () =&gt; document.removeEventListener(<br/>    'keydown',<br/>    keyDownListener,<br/>  );</span><span id="36b5" class="nw lw it ne b gy oq on l oo op">  if (autoEnable) {<br/>    enable();<br/>  }</span><span id="fed9" class="nw lw it ne b gy oq on l oo op">  return {<br/>    register,<br/>    unregister,<br/>    enable,<br/>    disable,<br/>  };<br/>};</span></pre><p id="8ef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">register和unregister逻辑被移到单独的函数中，这些函数将<code class="fe nb nc nd ne b">listeners</code>数组作为参数，这样每个上下文都将重用现有的函数:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="1d9b" class="nw lw it ne b gy om on l oo op">const register = (hotkey, callback) =&gt; {<br/>  registerListener(listeners, hotkey, callback);<br/>};</span><span id="1f64" class="nw lw it ne b gy oq on l oo op">const unregister = (hotkey, callback) =&gt; {<br/>  unregisterListener(listeners, hotkey, callback);<br/>};</span></pre><p id="ed34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似的事情也适用于<code class="fe nb nc nd ne b">keyDownListener</code>。它被提取到一个单独的工厂函数中。该函数基于对<code class="fe nb nc nd ne b">listeners</code>数组和去抖时间参数的引用创建一个keydown监听器。</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="45ce" class="nw lw it ne b gy om on l oo op">const keyDownListener = createKeyDownListener(<br/>  listeners,<br/>  debounceTime,<br/>);</span></pre><p id="c226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上下文本身返回一个带有<code class="fe nb nc nd ne b">register</code>和<code class="fe nb nc nd ne b">unregister</code>方法的对象，它们有自己的listeners数组。</p><p id="9fc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，还有<code class="fe nb nc nd ne b">enable</code>和<code class="fe nb nc nd ne b">disable</code>方法分别添加和移除<code class="fe nb nc nd ne b">keyDownListener</code>，因此您可以一次打开/关闭整个组。</p><p id="e62f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，在上下文创建期间调用<code class="fe nb nc nd ne b">enable</code>，因为<code class="fe nb nc nd ne b">autoEnable</code>参数设置为true:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="9cb7" class="nw lw it ne b gy om on l oo op">if (autoEnable) {<br/>  enable();<br/>}</span></pre><p id="e0e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如有必要，您可以通过为<code class="fe nb nc nd ne b">autoEnable</code>参数提供自己的值来关闭它:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="824b" class="nw lw it ne b gy om on l oo op">const context = createContext({ autoEnable = false });</span></pre><p id="234d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能有一组热键组，当应用程序进入特定页面/功能/上下文(如编辑模式等)时，可以启用这些热键组。</p><p id="1658" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，当与其他库如<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>或<a class="ae ky" href="https://angularjs.org/" rel="noopener ugc nofollow" target="_blank"> Angular </a>集成时，这可能是有用的。您可以在组件初始化期间启用上下文，在组件销毁期间禁用上下文。</p><p id="b541" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你用钩子使用React的单一功能组件，这里有一篇文章<a class="ae ky" href="https://dev.to/trentyang/replace-lifecycle-with-hooks-in-react-3d4n" rel="noopener ugc nofollow" target="_blank">描述了如何用钩子替换生命周期方法。</a></p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="ffcd" class="lv lw it bd lx ly nr ma mb mc ns me mf jz nt ka mh kc nu kd mj kf nv kg ml mm bi translated">确认</h1><p id="a346" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们必须确保代码在收到意外的用户输入时不会中断。我不打算为它编写自己的验证库，不过，我将向您展示如何避免代码重复。</p><p id="51b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要两个函数来验证。第一个验证给定条件是否为真，第二个检查给定值是否属于指定类型:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="5355" class="nw lw it ne b gy om on l oo op">const validate = (value, message) =&gt; {<br/>  if (!value) {<br/>    throw new Error(message);<br/>  }<br/>};</span><span id="8375" class="nw lw it ne b gy oq on l oo op">const validateType = (value, name, type) =&gt; {<br/>  validate(<br/>    typeof value === type,<br/>    `The ${name} must be a ${type}; given ${typeof value}`,<br/>  );<br/>};</span></pre><p id="203a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，多余的语法:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="bb28" class="nw lw it ne b gy om on l oo op">if (typeof value1 !== 'string') {<br/>  throw new Error(<br/>    `The value1 must be a string; given ${typeof value1}`<br/>  );<br/>}</span><span id="4ea4" class="nw lw it ne b gy oq on l oo op">if (typeof value2 !== 'boolean') {<br/>  throw new Error(<br/>    `The value2 must be a boolean; given ${typeof value2}`<br/>  );<br/>}</span><span id="9f99" class="nw lw it ne b gy oq on l oo op">if (value3 &gt; 3) {<br/>  throw new Error('The value3 must be lower than 3');<br/>}</span><span id="8539" class="nw lw it ne b gy oq on l oo op">if (value4 &lt; 4) {<br/>  throw new Error('The value4 must be greater or equal to 4');<br/>}</span></pre><p id="818e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以替换为:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="6393" class="nw lw it ne b gy om on l oo op">validateType(value1, 'value1', 'string');<br/>validateType(value2, 'value2', 'boolean');<br/>validate(value3 &gt; 3, 'The value3 must be lower than 3');<br/>validate(value4 &lt; 4, 'The value4 must be greater or equal to 4');</span></pre><h2 id="2252" class="nw lw it bd lx nx ny dn mb nz oa dp mf li ob oc mh lm od oe mj lq of og ml oh bi translated"><strong class="ak">create context验证</strong></h2><p id="d6cd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们需要验证函数参数中传递的<code class="fe nb nc nd ne b">debounceTime</code>和<code class="fe nb nc nd ne b">autoEnable</code>选项。</p><p id="2a16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个函数可以验证<code class="fe nb nc nd ne b">options</code>参数:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="f941" class="nw lw it ne b gy om on l oo op">const validateContext = (options) =&gt; {<br/>  const { debounceTime = 500, autoEnable = true } = (options || {});</span><span id="1a02" class="nw lw it ne b gy oq on l oo op">  validateType(debounceTime, 'debounceTime', 'number');<br/>  validate(debounceTime &gt; 0, 'debounceTime must be &gt; 0');<br/>  validateType(autoEnable, 'autoEnable', 'boolean');</span><span id="1ea7" class="nw lw it ne b gy oq on l oo op">  return { debounceTime, autoEnable };<br/>};</span><span id="2ad4" class="nw lw it ne b gy oq on l oo op">export const createContext = (options) =&gt; {<br/>  const { debounceTime, autoEnable } = validateContext(options);<br/>  // (...)<br/>}</span></pre><p id="a8ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不是直接析构函数参数，而是对<code class="fe nb nc nd ne b">options || {}</code>语句的结果执行析构，所以当选项被求值为false时，它将对空对象进行操作。如果没有这个，当null作为参数传递时，函数抛出。</p><h2 id="5f70" class="nw lw it bd lx nx ny dn mb nz oa dp mf li ob oc mh lm od oe mj lq of og ml oh bi translated"><strong class="ak">注册/注销验证</strong></h2><p id="5b9e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在第一阶段，<code class="fe nb nc nd ne b">register</code>和<code class="fe nb nc nd ne b">unregister</code>方法应该只允许string类型的热键和function类型的回调。因为我们必须使用两次验证，所以应该有另一个只用于验证的函数:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="f8db" class="nw lw it ne b gy om on l oo op">const validateListenerArgs = (hotkey, callback) =&gt; {<br/>  validateType(hotkey, 'hotkey', 'string');<br/>  validateType(callback, 'callback', 'function');<br/>};</span></pre><p id="c44a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是锻炼函数构图的绝佳案例。问题是，我们不需要在目标函数中使用<code class="fe nb nc nd ne b">validateListenerArgs</code>。我们将创建一个包装目标函数的函数，并进行验证。检查一下<code class="fe nb nc nd ne b">createListenersFn</code>:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="62cc" class="nw lw it ne b gy om on l oo op">const createListenersFn = (listeners, fn) =&gt; (hotkey, callback) =&gt; {<br/>  validateListenerArgs(hotkey, callback);<br/>  fn(listeners, hotkey, callback);<br/>};</span><span id="5d67" class="nw lw it ne b gy oq on l oo op">const registerListener = (listeners, hotkey, callback) =&gt; {<br/>  // (...)<br/>};</span><span id="5929" class="nw lw it ne b gy oq on l oo op">const unregisterListener = (listeners, hotkey, callback) =&gt; {<br/>  // (...)<br/>};</span><span id="20f6" class="nw lw it ne b gy oq on l oo op">export const createContext = ({ debounceTime = 500 } = {}) =&gt; {<br/>  // (...)<br/>  return {<br/>    register: createListenersFn(listeners, registerListener),<br/>    unregister: createListenersFn(listeners, unregisterListener),</span><span id="6d24" class="nw lw it ne b gy oq on l oo op">  }<br/>}</span></pre><p id="a9ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它获取必须包装的侦听器数组和目标函数。<br/>它返回另一个验证<code class="fe nb nc nd ne b">hotkey</code>和<code class="fe nb nc nd ne b">callback</code>参数的函数，然后调用目标函数并传递listeners数组。</p><p id="9f12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二阶段是在规范化过程中验证热键结构。<br/>有效的热键字符串是由空格分隔的组合序列。组合:</p><ul class=""><li id="4903" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">恰好包含一个非修饰键</li><li id="c1e8" class="ms mt it lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated">包含零个或多个修饰键</li><li id="0f5c" class="ms mt it lb b lc nf lf ng li nh lm ni lq nj lu mx my mz na bi translated">由唯一的值组成。</li></ul><p id="1692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">normalizeHotkey</code>功能更新如下:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="07cf" class="nw lw it ne b gy om on l oo op">const indexedModifiers = arrayToObject(allModifiers);</span><span id="db2f" class="nw lw it ne b gy oq on l oo op">const isHotkeyValid = (hotkey) =&gt; Object.keys(hotkey)<br/>  .filter((k) =&gt; !indexedModifiers[k])<br/>  .length === 1;</span><span id="ece1" class="nw lw it ne b gy oq on l oo op">const normalizeHotkey = (hotkey) =&gt; hotkey.split(/ +/g).map(<br/>  (part) =&gt; {<br/>    const arr = part.split('+').filter(Boolean);<br/>    const result = arrayToObject(arr);</span><span id="1013" class="nw lw it ne b gy oq on l oo op">    validate(<br/>      Object.keys(result).length &gt;= arr.length,<br/>      `Hotkey combination has duplicates "${hotkey}"`,<br/>    );<br/>    validate(<br/>      isHotkeyValid(result),<br/>      `Invalid hotkey combination: "${hotkey}"`,<br/>    );</span><span id="64b1" class="nw lw it ne b gy oq on l oo op">    return result;<br/>  },<br/>);</span></pre><p id="7b82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">isHotkeyValid</code>函数过滤掉所有的修饰键，当只有一个非修饰键时返回true。我使用<code class="fe nb nc nd ne b">indexedModifiers</code>来避免在每次迭代中调用<code class="fe nb nc nd ne b">allModifier.includes</code>。</p><p id="df90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它还检查热键组合是否由唯一的值组成。仍然可以多次设置同一个修改器，就像<code class="fe nb nc nd ne b">shift+shift+b</code>。</p><p id="a55a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意新的<code class="fe nb nc nd ne b">.filter(Boolean)</code>语句，它可以防止创建空键。例如，<code class="fe nb nc nd ne b">normalizeHotkey('')</code>产生<code class="fe nb nc nd ne b">[{ '': true }]</code>。</p><h2 id="488a" class="nw lw it bd lx nx ny dn mb nz oa dp mf li ob oc mh lm od oe mj lq of og ml oh bi translated">所有的代码</h2><p id="7882" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">完整的实现可从以下要点获得:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="5241" class="lv lw it bd lx ly nr ma mb mc ns me mf jz nt ka mh kc nu kd mj kf nv kg ml mm bi translated">使用</h1><p id="b360" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您可以从这个简单的例子开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="9baf" class="lv lw it bd lx ly nr ma mb mc ns me mf jz nt ka mh kc nu kd mj kf nv kg ml mm bi translated">测试</h1><p id="d763" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">由于代码被分成许多更小的函数，测试起来相当容易。</p><p id="7cdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一节中，我将展示我们已经创建的几个函数的一些测试示例(<a class="ae ky" href="https://jasmine.github.io/" rel="noopener ugc nofollow" target="_blank"> jasmine </a>)。我假设你已经知道了基本知识。</p><p id="2058" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">normalizeHotkey</code>:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="74b9" class="nw lw it ne b gy om on l oo op">// (...)<br/>it('should throw when the hotkey is empty ', () =&gt; {<br/>  expect(() =&gt; normalizeHotkey('')).toThrow();<br/>});</span><span id="2484" class="nw lw it ne b gy oq on l oo op">it('should return an array', () =&gt; {<br/>  expect(normalizeHotkey('a')).toEqual(jasmine.any(Array));<br/>});</span><span id="d2a7" class="nw lw it ne b gy oq on l oo op">it('should convert single key to a one element array', () =&gt; {<br/>  expect(normalizeHotkey('a')).toEqual([{ a: true }]);<br/>});</span><span id="d12c" class="nw lw it ne b gy oq on l oo op">it('should convert multiple keys to a dictionary', () =&gt; {<br/>  expect(normalizeHotkey('ctrl+alt+a')).toEqual(<br/>    [{ ctrl: true, a: true, alt: true }],<br/>  );<br/>});</span><span id="15a7" class="nw lw it ne b gy oq on l oo op">it(<br/>  'should convert multiple combinations to multiple dictionaries',<br/>  () =&gt; {<br/>    expect(normalizeHotkey('shift+c ctrl+alt+[')).toEqual(<br/>      [<br/>        {<br/>          shift: true,<br/>          c: true,<br/>        },<br/>        {<br/>          ctrl: true,<br/>          alt: true,<br/>          '[': true,<br/>        },<br/>      ],<br/>    );<br/>  },<br/>);<br/>// (...)</span></pre><p id="6e6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">matchHotkey</code>:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="9480" class="nw lw it ne b gy om on l oo op">// (...)<br/>it(<br/>  'should return false when some key is checked with empty buffer', <br/>  () =&gt; {<br/>    expect(matchHotkey([], [{ a: true }])).toBe(false);<br/>  }<br/>);</span><span id="09f4" class="nw lw it ne b gy oq on l oo op">it('should return true when buffer matches the hotkey', () =&gt; {<br/>  expect(matchHotkey([{ a: true }], [{ a: true }])).toBe(true);<br/>});</span><span id="3613" class="nw lw it ne b gy oq on l oo op">it('should return true when buffer matches the hotkey #2', () =&gt; {<br/>  expect(<br/>    matchHotkey(<br/>      [<br/>        { a: true, alt: true },<br/>        { b: true, ctrl: true, shift: true },<br/>      ],<br/>      [<br/>        { a: true, alt: true },<br/>        { b: true, ctrl: true, shift: true },<br/>      ],<br/>    )<br/>  ).toBe(true);<br/>});</span><span id="d965" class="nw lw it ne b gy oq on l oo op">it(<br/>  'should return false when there is some other key in-between',<br/>  () =&gt; {<br/>    expect(<br/>      matchHotkey(<br/>        [<br/>          { a: true, alt: true },<br/>          { v: true },<br/>          { b: true, ctrl: true, shift: true },<br/>        ],<br/>        [<br/>          { a: true, alt: true },<br/>          { b: true, ctrl: true, shift: true },<br/>        ],<br/>    )<br/>  ).toBe(false);<br/>});<br/>// (...)</span></pre><p id="1860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">热键上下文:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="ba88" class="nw lw it ne b gy om on l oo op">// (...)<br/>it('should call callback when event matches the hotkey', () =&gt; {<br/>  const spy = jasmine.createSpy('callback');<br/>  context.register('ctrl+a shift+b', spy);<br/>  document.dispatchEvent(<br/>    new KeyboardEvent('keydown', { key: 'a', ctrlKey: true })<br/>  );<br/>    <br/>  const event2 = new KeyboardEvent(<br/>    'keydown',<br/>    { key: 'b', shiftKey: true }<br/>  );<br/>  <br/>  document.dispatchEvent(event2);<br/>  <br/>  expect(spy).toHaveBeenCalledWith(event2);<br/>});</span><span id="d845" class="nw lw it ne b gy oq on l oo op">it(<br/>  'should call the callback when there is delay between the events',<br/>  () =&gt; {<br/>    jasmine.clock().install();</span><span id="403d" class="nw lw it ne b gy oq on l oo op">    const spy = jasmine.createSpy('callback');<br/>    context.register('a b c', spy);</span><span id="9d41" class="nw lw it ne b gy oq on l oo op">    document.dispatchEvent(<br/>      new KeyboardEvent('keydown', { key: 'a' }),<br/>    );<br/>    jasmine.clock().tick(200);</span><span id="4aaf" class="nw lw it ne b gy oq on l oo op">    document.dispatchEvent(<br/>      new KeyboardEvent('keydown', { key: 'b' }),<br/>    );<br/>    jasmine.clock().tick(200);</span><span id="1751" class="nw lw it ne b gy oq on l oo op">    document.dispatchEvent(<br/>      new KeyboardEvent('keydown', { key: 'c' })<br/>    );</span><span id="70a3" class="nw lw it ne b gy oq on l oo op">    expect(spy).toHaveBeenCalled();<br/>    jasmine.clock().uninstall();<br/>  }<br/>);</span><span id="61d8" class="nw lw it ne b gy oq on l oo op">it(<br/>  'do nothing when keys where pressed after the time window',<br/>  () =&gt; {<br/>    jasmine.clock().install();<br/>    const spy = jasmine.createSpy('callback');<br/>    context.register('a b c', spy);<br/>    document.dispatchEvent(<br/>      new KeyboardEvent('keydown', { key: 'a' })<br/>    );<br/>  <br/>    document.dispatchEvent(<br/>      new KeyboardEvent('keydown', { key: 'b' })<br/>    );<br/>    jasmine.clock().tick(550);</span><span id="322f" class="nw lw it ne b gy oq on l oo op">    document.dispatchEvent(<br/>      new KeyboardEvent('keydown', { key: 'c' })<br/>    );<br/>  <br/>    expect(spy).not.toHaveBeenCalled();<br/>    jasmine.clock().uninstall();<br/>  }<br/>);<br/>// (...)</span></pre></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="523f" class="lv lw it bd lx ly nr ma mb mc ns me mf jz nt ka mh kc nu kd mj kf nv kg ml mm bi translated">关于event.code属性的补充说明</h1><p id="e3ad" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe nb nc nd ne b">event.code</code>物业可视为<code class="fe nb nc nd ne b">event.key</code>的替代物。我不想使用它，因为它返回的键码名称太笼统了。这里有一个例子显示了不同之处:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="3d9e" class="nw lw it ne b gy om on l oo op">{key: "a", code: "KeyA"}, <br/>{key: "A", code: "KeyA"},           // shift is on<br/>{key: "1", code: "Digit1"}, <br/>{key: "!", code: "Digit1"},         // shift is on<br/>{key: "Shift", code: "ShiftRight"}, // wow, it holds the location<br/>{key: "End", code: "Numpad1"},      // numlock is on<br/>{key: "1", code: "Numpad1"},        // numlock is on<br/>{key: "Tab", code: "Tab"},<br/>{key: " ", code: "Space"}</span></pre><p id="7a26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以查看MDN文档中的<code class="fe nb nc nd ne b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key#Result" rel="noopener ugc nofollow" target="_blank">key</a></code>和<code class="fe nb nc nd ne b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code" rel="noopener ugc nofollow" target="_blank">code</a></code>来玩“试用”演示，或者只需将以下代码片段粘贴到浏览器的控制台中:</p><pre class="kj kk kl km gt oi ne oj ok aw ol bi"><span id="99c2" class="nw lw it ne b gy om on l oo op">document.addEventListener(<br/>  'keydown', <br/>  (e) =&gt; { <br/>    e.preventDefault();<br/>    console.log({ key: e.key, code: e.code })<br/>  }<br/>);</span></pre><p id="c354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe nb nc nd ne b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/location" rel="noopener ugc nofollow" target="_blank">event.location</a></code>属性获得键盘位置(数字小键盘、左键盘、右键盘、标准键盘),所以我们不仅限于使用<code class="fe nb nc nd ne b">key</code>属性。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="705c" class="lv lw it bd lx ly nr ma mb mc ns me mf jz nt ka mh kc nu kd mj kf nv kg ml mm bi translated">更多注释</h1><ul class=""><li id="8ba3" class="ms mt it lb b lc mn lf mo li ou lm ov lq ow lu mx my mz na bi translated">用<code class="fe nb nc nd ne b">event.code</code>代替<code class="fe nb nc nd ne b">event.key</code>不安全——正如<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent" rel="noopener ugc nofollow" target="_blank">文档</a>中强调的:</li></ul><blockquote class="ox"><p id="48ec" class="oy oz it bd pa pb pc pd pe pf pg lu dk translated">这忽略了用户的键盘布局，因此如果用户在QWERTY键盘布局中的“Y”位置(靠近home行上方的行的中间)按下按键，这将总是返回“KeyY”，即使用户具有QWERTZ键盘(这意味着用户期望“Z”，所有其他属性将指示“Z”)或Dvorak键盘布局(其中用户期望“F”)。</p></blockquote><ul class=""><li id="5a19" class="ms mt it lb b lc ph lf pi li pj lm pk lq pl lu mx my mz na bi translated">似乎微软的Edge浏览器不支持<code class="fe nb nc nd ne b">event.code</code>属性(截至2019年8月:参见<a class="ae ky" href="https://caniuse.com/#search=event.code" rel="noopener ugc nofollow" target="_blank">can use</a>和<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent" rel="noopener ugc nofollow" target="_blank"> MDN docs </a>)。</li></ul></div></div>    
</body>
</html>