<html>
<head>
<title>Apply the Dependency Inversion Principle in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中应用依赖倒置原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/apply-the-dependency-inversion-principle-in-react-c20a0afc3d64?source=collection_archive---------4-----------------------#2021-05-06">https://betterprogramming.pub/apply-the-dependency-inversion-principle-in-react-c20a0afc3d64?source=collection_archive---------4-----------------------#2021-05-06</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="6c83" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">你的React组件知道的太多了。让我们解决这个问题</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/39f8d5df74fcfaa7b055686695557666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TTks1T743pZbAdAP5NIojA.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://www.pexels.com/photo/photo-of-keyboard-near-phone-3184453/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kz" href="https://www.pexels.com/@fauxels?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">faxels</a>拍摄。</p></figure><p id="9e55" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">依赖倒置</em>原则是著名的坚实原则之一。也是最重要的一条。</p><p id="8899" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">今天，我们将看到如何解决一个非常常见的错误，新手反应开发人员使用这一原则。</p><p id="413f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我会尽量保持简单。我们开始吧！</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="f160" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">这个原理告诉我们什么？</h1><p id="139c" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">就面向对象编程而言，这一原则背后的主要思想是始终有一个抽象的高级代码接口，而不是实现细节。</p><p id="f13a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">坚持住！我知道你在想什么:“我是一个简单的前端开发人员。你为什么用这些复杂的术语来烦我？”</p><p id="c8a4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我为你简单地陈述它。对于React应用程序，这一原则意味着:</p><blockquote class="nb"><p id="9038" class="nc nd iu bd ne nf ng nh ni nj nk lv dk translated">"任何组件或功能都不应该关心一件特定的事情是如何完成的."</p></blockquote><p id="1d8f" class="pw-post-body-paragraph la lb iu lc b ld nl jv lf lg nm jy li lj nn ll lm ln no lp lq lr np lt lu lv in bi translated">还不清楚？好了，让我们用一些代码来弄脏我们的手吧！</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="9136" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">实际例子</h1><p id="f734" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">我们举一个很常见的用例。我们将从我们的组件发出一个API调用，从远程数据源获取一些数据。实现可能如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nq nr l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">用户. js</p></figure><p id="4553" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">看这个组件。它依赖于从组件内部获取的一些远程数据。</p><p id="05bf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的组件的主要职责是呈现数据。它不应该关心数据是如何获取的，也不应该关心数据来自哪里。</p><p id="f954" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个组件知道的太多了——这是个问题。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="785d" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">为什么？</h1><p id="4e91" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">好吧，让我们假设你有十个其他组件，它们都获取自己的数据。</p><p id="8bdc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在你的经理走过来，告诉你使用<code class="fe ns nt nu nv b">axios</code>而不是<code class="fe ns nt nu nv b">fetch</code></p><p id="ed61" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你有麻烦了！现在您必须进入每个文件并重构逻辑以使用<code class="fe ns nt nu nv b">axios</code>。</p><p id="9ed5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是生活并不是那么简单！几天后，您的经理又来了，告诉您实现缓存。</p><p id="a902" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你必须再次做同样的事情。</p><p id="801a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，它增加了在你的软件中引入错误的机会。此外，代码变得不可维护，浪费了宝贵的时间。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="3483" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">那我们该怎么办？</h1><p id="964b" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">让我们引入一个数据获取钩子，将我们的逻辑抽象到组件之外，因为这正是这个原则告诉我们的。依赖抽象，记得吗？</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nq nr l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">useFetch.ts</p></figure><p id="5cbb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在在我们的<code class="fe ns nt nu nv b">Users</code>组件中使用这个钩子:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nq nr l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">User.tsx</p></figure><p id="ba73" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意这个解决方案的一个伟大之处:你的<code class="fe ns nt nu nv b">useFetch</code>钩子不关心谁在调用它。它只是将一个<code class="fe ns nt nu nv b">URL</code>作为输入并返回数据。</p><p id="6306" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，所有其他组件都可以利用我们刚刚编写的钩子。我们的<code class="fe ns nt nu nv b">Users</code>组件不再依赖于数据如何返回或者哪个库正在被使用的具体细节！</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="a158" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">更高级的用法</h1><p id="e2b3" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">现在，让我们用基本的缓存功能来满足您的经理:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nq nr l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">useFetch.ts</p></figure><p id="409f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您现在只需要在一个地方更改代码。太好了！假设您需要将API错误显示为吐司。你现在能做到吗？如果是这样，那么你明白我的意思了。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="8260" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">如何检测</h1><ul class=""><li id="814f" class="nw nx iu lc b ld mw lg mx lj ny ln nz lr oa lv ob oc od oe bi translated">在大多数情况下，如果您违反了单一责任原则，那么您也可能违反了依赖倒置原则。</li><li id="97d3" class="nw nx iu lc b ld of lg og lj oh ln oi lr oj lv ob oc od oe bi translated">对于任何组件，查看顶部的导入部分。如果你正在导入一些不负责显示某些东西的库(比如吐司或者模态)，那么你可能违反了这个原则。</li></ul><h1 id="a595" class="me mf iu bd mg mh ok mj mk ml ol mn mo ka om kb mq kd on ke ms kg oo kh mu mv bi translated">本系列的前几篇文章</h1><ol class=""><li id="09cb" class="nw nx iu lc b ld mw lg mx lj ny ln nz lr oa lv op oc od oe bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-apply-solid-principles-to-clean-your-code-in-react-cdfd5e0a9cea">单一责任原则</a></li><li id="0947" class="nw nx iu lc b ld of lg og lj oh ln oi lr oj lv op oc od oe bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/applying-the-open-closed-principle-to-write-clean-react-components-4e4514963e40">开启关闭原理</a></li><li id="5d41" class="nw nx iu lc b ld of lg og lj oh ln oi lr oj lv op oc od oe bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/applying-the-liskov-substitution-principle-in-react-3a0614a42a08">利斯科夫替代原理</a></li><li id="9bf4" class="nw nx iu lc b ld of lg og lj oh ln oi lr oj lv op oc od oe bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-apply-interface-segregation-principle-in-reactjs-fadf77113c5d">界面偏析原理</a></li></ol><p id="0631" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">今天到此为止。我希望你喜欢这篇文章以及这个系列。</p><p id="6e50" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">有话要说？通过</strong><a class="ae kz" href="https://www.linkedin.com/in/56faisal/" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv">LinkedIn</strong></a>联系我</p><div class="oq or gq gs os ot"><a rel="noopener  ugc nofollow" target="_blank" href="/top-7-libraries-for-blazingly-fast-reactjs-applications-c0069e87c8b7"><div class="ou ab fp"><div class="ov ab ow cl cj ox"><h2 class="bd iv gz z fq oy fs ft oz fv fx it bi translated">快速反应应用的7大库</h2><div class="pa l"><h3 class="bd b gz z fq oy fs ft oz fv fx dk translated">摇滚明星开发人员的必备工具</h3></div><div class="pb l"><p class="bd b dl z fq oy fs ft oz fv fx dk translated">better编程. pub</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph kt ot"/></div></div></a></div></div></div>    
</body>
</html>