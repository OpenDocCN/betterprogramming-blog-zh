<html>
<head>
<title>Want More From ColorPicker in iOS 14? Create 1,500+ SwiftUI Pickers of Your Own</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">想要iOS 14中的ColorPicker提供更多功能吗？创建1500多个您自己的SwiftUI选择器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/want-more-from-colorpicker-in-ios-14-create-1500-swiftui-pickers-of-your-own-7533514bf824?source=collection_archive---------15-----------------------#2020-06-23">https://betterprogramming.pub/want-more-from-colorpicker-in-ios-14-create-1500-swiftui-pickers-of-your-own-7533514bf824?source=collection_archive---------15-----------------------#2020-06-23</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="a8ee" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">使用Swift Package Manager定制颜色选择器，并在任何项目中重复使用</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/d810b1efde03c3205c1d315fe93183cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v9WuX8CEM-207auD-OPf9Q.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@mbaumi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae kz" href="https://unsplash.com/s/photos/paint-palette?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="b6b7" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">iOS 14颜色选择器</h1><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><p id="aadb" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">iOS 14对SwiftUI API进行了更新，这意味着我们可以在应用中使用一些新的视图。可能令人惊讶的是，我们现在有了一个<code class="fe mx my mz na b">ColorPicker</code>，我们可以简单地通过为我们想要选择的颜色传递绑定来使用它。这使得在我们的iOS、iPadOS和MacOS应用程序中选择自定义颜色比以往任何时候都更容易，但是当我们想要自定义控件时呢？ColorPicker看起来有一套相当严格的控件，开发者无法更改。</p><p id="13a2" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">如果我们想要不同的控件呢？</p><p id="ae52" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">如果我们想让控件看起来像我们想要的样子呢？</p><p id="b7a6" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">如果我们自己做，我们可以做任何我们想做的事！</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="42cd" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">1，500多名拾色器</h1><p id="d027" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">我也许应该解释一下我是如何在标题中找到1500+这个数字的。</p><p id="36fc" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">这将显示我没有夸大，同时显示你将学到的一切，所以它有多种用途。</p><p id="4fdd" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我们为这些颜色选择器使用了四种颜色空间:</p><ul class=""><li id="8a59" class="ng nh iu md b me mf mh mi mk ni mo nj ms nk mw nl nm nn no bi translated">青色、洋红色、黄色、黑色、alpha (CMYKA)</li><li id="e7ca" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">色调、饱和度、亮度、alpha (HSBA)</li><li id="a448" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">红色、绿色、蓝色、阿尔法(RGBA)</li><li id="1faa" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">白色，阿尔法(灰度)</li></ul><p id="b50d" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">您在本教程中制作的每个拾色器都占用一个颜色空间，并允许您设置每个参数，而无需为同一个参数设置多个控件。</p><p id="8cb8" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">以下是您将进行的控制:</p><h2 id="f4f6" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">帆布</h2><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj og"><img src="../Images/98da15f3600c8a2173521f1a2b48d8e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nhlDrW7pHqFqDpGT3CSLXQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">画布使用x和y坐标一次选取两个参数(本例中为色调/饱和度)</p></figure><p id="0f41" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">您将学习创建画布，画布允许您在正方形上选取一个点。如果<em class="oh"> x- </em>轴是亮度，而<em class="oh"> y- </em>轴是饱和度，您选择的点的坐标将设置这两个参数。</p><h2 id="5b68" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">车轮</h2><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oi"><img src="../Images/86d0e03fb5c635d418b20381c05f750f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLu2arJUkY5vsOobdoC6qQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">轮子使用围绕一个圆旋转的度数，而不是二维坐标</p></figure><p id="3a07" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">你将学习创建色轮，这在表现色调(我们通常称之为<em class="oh">色轮</em>)和饱和度时更有意义。但是这些轮子可以用来显示你想要的任何参数组合，不管它看起来有多奇怪。</p><h2 id="62ef" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">滑块</h2><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj og"><img src="../Images/43743ec42cfa953383480a000f6885d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rq_CAoS_YWtFLHA0-d0Z1A.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">滑块一次只能选取一个参数，但可以与其他控制结合使用</p></figure><p id="d958" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">您将学习创建滑块，可以拖移滑块来选择单个参数。滑块可以选择垂直而不是水平——为什么不呢？这些是自定义控件。</p><h2 id="ea87" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">调色板</h2><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oj"><img src="../Images/ad7b41bd8e76f10ffd87afcf233af6ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oODeA3Rr3RIFaDHgIANc_A.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">调色板可以包含任意数量的样本，并根据水平和垂直方向上的不同参数而变化</p></figure><p id="645c" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">您将学习创建调色板，它在水平和垂直方向上创建自定义数量的样本。您可以选择每个方向上有多少色板，因此实际上有数百种调色板大小。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="2703" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">将控件组合到选择器中</h1><p id="b8f4" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">RGBA和HSBA色彩空间中的拾音器只能通过以下任何方式制作:</p><ul class=""><li id="e723" class="ng nh iu md b me mf mh mi mk ni mo nj ms nk mw nl nm nn no bi translated">四个滑块</li><li id="6d96" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">两张画布</li><li id="7c38" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">两个轮子</li><li id="5b98" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">两个调色板</li><li id="d72b" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">一个画布和两个滑块</li><li id="1bbc" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">一个轮子和两个滑块</li><li id="b399" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">一个调色板和两个滑块</li><li id="94c5" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">一块帆布和一个轮子</li><li id="5cd3" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">一块画布和一块调色板</li><li id="b014" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">一个轮子和一个调色板</li></ul><p id="5877" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">RGBA或HSBA参数有24种排列，每种排列有10种方式。</p><p id="5b25" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">这意味着有240名RGBA拣货员和240名HSBA拣货员，总共480人。</p><p id="b997" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">CMYK色彩空间中的拾色器只能是以下方式之一:</p><ul class=""><li id="2804" class="ng nh iu md b me mf mh mi mk ni mo nj ms nk mw nl nm nn no bi translated">五个滑块</li><li id="6b34" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">两张画布和一个滑块</li><li id="1fa8" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">两个轮子和一个滑块</li><li id="384d" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">两个调色板和一个滑块</li><li id="7e63" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">一个画布、一个滚轮和一个滑块</li><li id="8b14" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">一个画布、一个调色板和一个滑块</li><li id="c542" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">一个滚轮、一个调色板和一个滑块</li><li id="0d1b" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">一个画布和三个滑块</li><li id="f3b6" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">一个轮子和三个滑块</li><li id="856e" class="ng nh iu md b me np mh nq mk nr mo ns ms nt mw nl nm nn no bi translated">一个调色板和三个滑块</li></ul><p id="1d80" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">CMYKA参数有120种排列方式，每种排列方式有10种。</p><p id="629c" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">这意味着有1，200个可能的CMYK拾取器，总共有1，680个。</p><p id="2ffe" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">由于它只有白度和不透明度参数，灰度只能用两个滑块、一个画布、一个调色板或一个色轮来制作。</p><p id="e069" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">这使得挑选者总数达到1，684，我甚至没有包括滑块可以是水平或垂直的事实，挑选者可以排除alpha，调色板可以是任何大小。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="f600" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">我们开始吧</h1><p id="66c2" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">虽然我将向您展示如何将这些颜色选择器快速打包，但我想我会把它留到最后。毕竟，您可能不想使用Swift Package Manager，您可能只想将代码按原样放在项目中。记住这一点，使用SwiftUI作为用户界面创建一个新的单视图<a class="ae kz" href="https://developer.apple.com/xcode/" rel="noopener ugc nofollow" target="_blank"> Xcode </a>项目。这将创建<code class="fe mx my mz na b">ContentView</code>作为你界面中的第一个<code class="fe mx my mz na b">View</code>，你可以修改它来预览我们将要处理的各种<code class="fe mx my mz na b">View</code>。由于<code class="fe mx my mz na b">ContentView</code>是在<code class="fe mx my mz na b">SceneDelegate</code>中创建的，所以在<code class="fe mx my mz na b">ContentView</code>中放一个你想在模拟器或物理设备上预览的<code class="fe mx my mz na b">View</code>是很有用的。</p><p id="fa84" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">如果你想为模拟器或设备建立另一个<code class="fe mx my mz na b">View</code>，你需要改变<code class="fe mx my mz na b">SceneDelegate</code>来使用那个<code class="fe mx my mz na b">View</code>而不是<code class="fe mx my mz na b">ContentView</code>。</p><p id="69f5" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">当我给出一个代码的例子时，它可以在同一个文件中或者通过为每个视图创建单独的文件。</p><p id="e6a9" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">如何组织你的观点取决于你自己。</p><h2 id="416b" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated"><strong class="ak">扩展数值类型</strong></h2><p id="afc5" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">我给苹果的数值类型添加了一些扩展，因为我认为它可以限制我们使用的双精度类型的范围。每当我计算角度时，我都倾向于将<code class="fe mx my mz na b">halfPi</code>和<code class="fe mx my mz na b">doublePi</code>作为常数添加，因为如果您不在每次需要时进行浮点除法和乘法来获得这些值，这可能会稍微提高性能。当我们谈到轮子时，它们都是需要的，但现在，我只是把它们放在这里，这样我不会忘记告诉你以后添加它们。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><p id="f7c6" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我最初编写了这个方法的<code class="fe mx my mz na b">clampFrom</code>变体，它可以用来将CGFloat或Double的值限制在最小和最大值之内。但是我注意到每次我使用它的时候，我都把它限制在零和正数之间，所以我创建了<code class="fe mx my mz na b">clampFromZero</code>来节省时间。不管怎样，我已经把<code class="fe mx my mz na b">clampFrom</code>留在了扩展中，因为我可能会遇到一种情况，我会发现它很有用。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="916a" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated"><strong class="ak">颜色模型</strong></h1><p id="03a8" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">由于SwiftUI视图在状态改变时会刷新，因此我们的颜色参数无法轻松存储在视图本身中。SwiftUI结构属性中缺少<code class="fe mx my mz na b">didSet</code>块，一旦我们调整了其中一个参数，更新我们选择的颜色的预览将是一个挑战。我创建的ColourModel类只做这些，其他的很少。它是独立于色彩空间的，这意味着不管你使用哪个色彩空间，它都包含所有的参数。</p><pre class="kk kl km kn gu ok na ol om aw on bi"><span id="92c8" class="nu li iu na b gz oo op l oq or">typealias RGBAValues = (red: Double, green: Double, blue: Double, alpha: Double)</span></pre><p id="8d5e" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我决定对颜色使用元组，因为它们纯粹是我们传递的数值组。这使得将我们需要的四五个参数作为一个单独的<code class="fe mx my mz na b">Binding</code>传递变得容易，而不必创建一个只包含这些值而不做任何其他事情的结构。我没有将红色、绿色、蓝色和alpha声明为新结构类型的属性，而是简单地使用<code class="fe mx my mz na b">typealias</code>来保存我想要的元组外观，并且我已经在一行中声明了一个唯一的类型。</p><p id="0254" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">请注意，我已经标记了元组内的参数。元组中参数的标签是可选的，但是我想确保在使用<code class="fe mx my mz na b">RGBAValues</code>类型时得到正确的参数。毕竟，我不太可能在指<code class="fe mx my mz na b">valuesInRGBA.blue</code>的时候不小心用到了<code class="fe mx my mz na b">valuesInRGBA.green</code>。当我打算使用<code class="fe mx my mz na b">valuesInRGBA.1</code>时，意外地使用<code class="fe mx my mz na b">valuesInRGBA.2</code>的可能性要大得多，如果我们不给类型添加标签，这将是我们唯一的选择。</p><p id="3e4c" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">看看我还在<code class="fe mx my mz na b">ColourModel</code>上加了什么。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><p id="21aa" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">这里有很多代码，但不是很复杂。</p><p id="0943" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">My <code class="fe mx my mz na b">valuesInRGBA</code>和类似的元组被初始化并标记为<code class="fe mx my mz na b">@Published</code>，这意味着任何依赖它们的SwiftUI <code class="fe mx my mz na b">View</code>将被告知任何变化。选择器组件将只被传递这些元组，但是<code class="fe mx my mz na b">colour</code>属性将改变并更新层次结构中其他地方的其他视图。这可能在我们创建<code class="fe mx my mz na b">PreviewColourView</code>时最为明显，它显示了当前的颜色，尽管与改变这些值的拾取器没有任何共同之处。显示颜色选择器的视图需要一个用<code class="fe mx my mz na b">@ObservedObject</code>属性包装器标记的ColourModel实例。这将允许它将相关的颜色元组作为<code class="fe mx my mz na b">Binding&lt;RGBAValues&gt;</code>传递给颜色选择器，允许在那里更改参数。</p><p id="c1c1" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">不要传递整个ColourModel，它有颜色选择器不需要的数据和功能，最好只允许访问最少的部分。</p><p id="e22d" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">每个元组都有一个调用<code class="fe mx my mz na b">setColour()</code>的<code class="fe mx my mz na b">didSet</code>闭包。<code class="fe mx my mz na b">colourSpace</code>参数用于确定应该使用哪个元组来设置<code class="fe mx my mz na b">colour</code>。这在阿尔法的情况下很好，它存在于每一个颜色空间。但是每隔一个元组需要传递它的颜色空间，以确保颜色设置正确。</p><p id="289e" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我已经包含了<code class="fe mx my mz na b">ColourSpace</code>枚举，它定义了所有的颜色空间。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="7895" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">创建可扩展颜色协议</h1><p id="05b0" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated"><code class="fe mx my mz na b">ColourModel</code>代码还不能编译，因为我们需要一个允许<code class="fe mx my mz na b">fromValues</code>方法的<code class="fe mx my mz na b">Color</code>扩展。这使得从形式为<code class="fe mx my mz na b">Color.fromValues(valuesInRGBA)</code>的值元组中创建<code class="fe mx my mz na b">Color</code>的实例变得更加容易，而不是像下面这样:</p><pre class="kk kl km kn gu ok na ol om aw on bi"><span id="d1ec" class="nu li iu na b gz oo op l oq or">Color(red: valuesInRGB.red, green: valuesInRGB.green, blue: valuesInRGB.blue, opacity: valuesInRGB.alpha)</span></pre><p id="f505" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">有必要有一种方法将CMYKA值与RGBA色彩空间相互转换，因为没有办法直接使用CMYKA参数构建SwiftUI <code class="fe mx my mz na b">Color</code>结构。一旦一个值元组从CMYKA转换成RGBA，就可以用<code class="fe mx my mz na b">Color.fromValues(valuesInRGBA)</code>构造一种颜色，和上面的例子一样。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><p id="1c4e" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">在这种情况下，这并不是绝对必要的，但是我已经将这个扩展的声明分离到一个名为<code class="fe mx my mz na b">ColorExtendable</code>的协议中。然而，这是一个介绍协议的好方法，在整个教程中都会用到。通过使用<code class="fe mx my mz na b">Color: ColorExtendable</code>使扩展一致，我承诺我将提供协议的方法签名的实现。要求仅仅是存在一个具有特定签名的方法，这样我就知道我可以在任何相容的结构上调用这个方法。</p><p id="2eee" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我添加了SwiftUI颜色结构中没有的颜色，因为这些颜色以后会很有用。除了已经讨论过的转换和<code class="fe mx my mz na b">fromValues</code>方法之外，我还提供了<code class="fe mx my mz na b">blend</code>方法，在相同的颜色空间中组合颜色。这将有助于制作画布。</p><p id="23bf" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">因为我把文档注释放在了协议中，所以没有必要对实现做同样的事情。这意味着可以按住option键单击这些方法和属性来显示它们是什么的文档。单击右侧面板中的问号打开快速帮助检查器，也会显示您单击的任何方法或属性的文档。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="4af3" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">创建参数枚举</h1><p id="7a5f" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">我创建了一个枚举来覆盖所有的参数，而不考虑颜色空间。这意味着我们可以将一个<code class="fe mx my mz na b">Parameter</code>传递给一个适用于任何颜色空间的方法，并且我们可以使用一个switch语句从RGBA元组中获取红色，或者从HSBA元组中获取色调。这使得重用代码更加容易，而不需要为每个颜色空间的参数分别枚举。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><p id="081c" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">Swift中枚举的伟大之处在于我们可以添加方法和计算属性。我们有一种方法来获取任何参数的色彩空间和RGBA或CMYKA值，这对于创建渐变非常有用。</p><p id="7a3d" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我添加了一个方法来比较<code class="fe mx my mz na b">Parameter</code>的情况，以查看它们是否来自相同的颜色空间，另一个方法除了检查<code class="fe mx my mz na b">Parameter</code>的情况是否不同之外，还做了同样的事情。</p><p id="f84b" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我们要制作的大多数控件都需要两个参数，如果参数相同，它们将无法正常工作。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="4eab" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated"><strong class="ak">扩展SwiftUI渐变结构</strong></h1><p id="c373" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">渐变是使用一组<code class="fe mx my mz na b">Color</code>实例制作的，但是<code class="fe mx my mz na b">LinearGradient</code>用一个<code class="fe mx my mz na b">startPoint</code>和一个<code class="fe mx my mz na b">endPoint</code>组合了这些实例。我添加了一种更简单的方法来制作水平或垂直渐变，而不必每次都指定这些点。该扩展具有SwiftUI中不包含的颜色，以及为任何颜色空间计算渐变的方法。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><p id="5f96" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">可以从值元组创建梯度，方法是在一端将所讨论的参数减少到零，在另一端将其增加到1。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="2174" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">创建预览颜色视图</h1><p id="6659" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">你需要能够看到你选择的颜色，所以我提供了一个简单的预览颜色的方法。你不一定需要这个，因为你可以随心所欲地展示你的颜色。但是我将把它包含在我的选择器示例中。我包含了一个名为<code class="fe mx my mz na b">square</code>的bool，它将纵横比锁定为1:1。当我测试我的选择器时，我发现这很有用，因为我倾向于将它们都放在VStack中，这将屏幕很好地分为选择器和预览。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="80f8" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">TransparencyCheckerboardView</h1><p id="a753" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">如果你曾经在图像编辑器中处理过透明图像，你会发现白色和灰色的拼贴指示了图像透明的地方。如果你想让你的拾色器显示透明，这是很重要的，因为如果没有它，你的颜色只会显示你的拾色器所覆盖的背景色。在白色背景上，选择不透明度为零会使你选择的颜色看起来像白色，而实际上你的颜色是完全透明的。<code class="fe mx my mz na b">TransparencyCheckerboardView</code>使用<code class="fe mx my mz na b">ForEach</code>遍历瓷砖的索引，用交替的颜色覆盖任何需要的形状。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><p id="7d32" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我表达观点的方式你可能不熟悉。我的结构不符合视图协议，它所做的只是声明属性和初始化器。不是直接符合View，而是符合<code class="fe mx my mz na b">TransparencyCheckerboardDisplayable</code>协议，符合View本身。</p><p id="a864" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">这是将结构分成两个不同组件的好方法:</p><p id="a3b0" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated"><strong class="md iv">结构</strong>就是视图。</p><p id="8ff5" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated"><strong class="md iv">行为</strong>是一个视图所做的事情，包括它的外观。</p><p id="2f05" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">本质上，我们很容易确定任何符合<code class="fe mx my mz na b">TransparencyCheckerboardDisplayable</code>的结构都有一个名为<code class="fe mx my mz na b">tileSize</code>的<code class="fe mx my mz na b">CGFloat</code>属性和两个名为<code class="fe mx my mz na b">colour1</code>和<code class="fe mx my mz na b">colour2</code>的<code class="fe mx my mz na b">Color</code>属性。我们可以确定，一致性结构有一个名为<code class="fe mx my mz na b">squareColour</code>的方法，我们可以发送任何瓷砖的行和列，并获得瓷砖应有的颜色。</p><p id="1cb5" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">尽管协议本身不能提供方法实现，但是协议的扩展可以。</p><p id="dc73" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">这就是面向协议的方法使我的SwiftUI视图与您可能习惯的视图有很大不同的地方。由于<code class="fe mx my mz na b">TransparencyCheckerboardDisplayable</code>符合View，它可以提供一个<code class="fe mx my mz na b">body</code>属性的实现，该实现将用于所有符合它的结构。这就是为什么我能够不提供身体，尽管它符合观点。当符合一个协议时，结构会自动符合该协议本身符合的任何其他协议。</p><p id="7648" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">需要注意的是，这不是继承。</p><p id="44b0" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">与引用类型的类不同，结构是值类型，因此不能继承。</p><p id="11a9" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated"><code class="fe mx my mz na b">TransparencyCheckerboardView</code>的初始化器具有使用传统灰色和白色瓷砖的<code class="fe mx my mz na b">colour1</code>和<code class="fe mx my mz na b">colour2</code>的默认值。虽然您可以在创建此视图时提供自定义颜色，但不指定任何颜色将允许使用默认颜色。对于占据半个iPhone屏幕的预览和画布，20的平铺尺寸是可以接受的，但是调色板需要更小的平铺尺寸。这意味着我将为调色板使用构造函数<code class="fe mx my mz na b">TransparencyCheckerboardView(tileSize: 10)</code>,但是为了使用默认大小，其他所有东西都可以在没有参数的情况下构造。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="846c" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated"><strong class="ak">画布:创建幻灯片缩略图</strong></h1><p id="7db1" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">任何滑块的位置都由一个叫做<em class="oh">拇指</em>的形状来指示。为了让拇指与任何颜色一起工作，滑块拇指由黑白胶囊组成。如果拇指只是黑色的，它进入一个黑暗的区域，它就会消失。如果它是白色的，进入一个明亮的区域，同样的情况也会发生。同样的道理也适用于<code class="fe mx my mz na b">CircleThumbView</code>，我们稍后将创建它用于画布和轮子。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><p id="0f02" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">虽然胶囊大小相同，但下面的白色胶囊线宽是原来的两倍。因此，在黑色胶囊的外部和内部都可以看到白色。</p><h2 id="0b09" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">滑块:创建DirectionalDragModifier来检测用户输入</h2><p id="09ad" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">我们将需要一个自定义的拖动手势，以了解用户在滑块上选择的位置。当我开始做这个的时候，我犯了一个错误，把拖拽手势应用到了拇指上。如果你想拖动滑块，这是没问题的，但是如果你想点击滑块上的任意位置呢？对此的解决方案是将拖动手势应用于滑块本身，并让拖动手势传回一个偏移绑定。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><p id="fa8a" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">传回偏移值允许视图定位滑块，即使实际上是画布检测拖动并告诉它去哪里。</p><p id="19f6" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">创建一个视图扩展总是很有帮助的，它提供了一种更简单的方法来调用定制的<code class="fe mx my mz na b">ViewModifier</code>。这使得你的修改器看起来更像苹果提供的修改器，因为你不需要在修改器视图方法中构造<code class="fe mx my mz na b">ViewModifie</code> r。</p><p id="4b7e" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">换句话说:</p><pre class="kk kl km kn gu ok na ol om aw on bi"><span id="f809" class="nu li iu na b gz oo op l oq or">.modifier(DirectionalDragModifier(offset:, xValue:, yValue:, size:))</span></pre><p id="eec9" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">变成了:</p><pre class="kk kl km kn gu ok na ol om aw on bi"><span id="337b" class="nu li iu na b gz oo op l oq or">.drag(offset:, xValue:, yValue:, size:)</span></pre><p id="eedc" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">这样，长的修饰符名称可以短得多，并且更容易阅读代码。</p><h2 id="7036" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">创建SliderDataBindable协议</h2><p id="06a3" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">由于滑块一次只能选取一个参数，所以我们将以不同于所有其他控件类型的方式存储滑块所需的数据。除了有一个参数之外，这个协议的大部分与其他协议相同。我对<code class="fe mx my mz na b">values</code>属性使用了泛型类型，这意味着我不局限于使用元组。换句话说，<code class="fe mx my mz na b">SliderDataBindable</code>协议是在说我们不关心你如何存储你的颜色数据，不管它是一个结构，一个元组，甚至是一个单个的Double。我们所关心的是使用什么参数，以及如何从值中获得该参数的绑定。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><p id="580e" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">这些结构将出现编译错误，因为它们尚未实现协议要求的方法。由于四个颜色空间被存储为具有不同命名参数的元组，我们需要指定如何访问这些元组中的每一个。这是在扩展中完成的，因此我们创建的任何结构都将自动拥有一个版本的<code class="fe mx my mz na b">getBinding</code>方法，而不必自己实现它。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><h2 id="f056" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">滑块:创建滑块可拾取协议</h2><p id="4b7f" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">我将把<em class="oh"> Pickable </em>添加到所有控制协议的名称中，因为这是把一个枯燥的结构变成一个允许选择的结构。我会说它给<code class="fe mx my mz na b">View</code>添加了挑选行为，但它实际上也添加了<code class="fe mx my mz na b">View</code>主体，因为这是在协议扩展中完成的，就像对<code class="fe mx my mz na b">TransparencyCheckerboardView</code>一样。您可能会注意到滑块可以在水平或垂直位置。</p><p id="cbf2" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">这给了我们更多的方法来创造独特的采摘。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><p id="069b" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">由于每个符合<code class="fe mx my mz na b">SliderPickable</code>协议的<code class="fe mx my mz na b">View</code>都有相同的基本结构，这只是一个复制粘贴的例子。当在你的协议中使用一个<code class="fe mx my mz na b">associatedtype</code>然后在一致性结构中变成一个<code class="fe mx my mz na b">typealias</code>时，尽可能使用通用名称是有用的。</p><p id="1da6" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">在RGBASliderView中，使用<code class="fe mx my mz na b">let data: DataType</code>而不是<code class="fe mx my mz na b">let data: RGBASliderData</code>更有意义。</p><p id="e52d" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">换句话说，我们在每个结构中需要改变的只是<code class="fe mx my mz na b">typealias</code>，因为其他行每次都是一样的。</p><h2 id="67ed" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">滑块:为每个色彩空间创建视图</h2><p id="f0a3" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">您可能想知道为什么我们将数据、逻辑和<code class="fe mx my mz na b">View</code>主体从<code class="fe mx my mz na b">RGBASliderView</code>中分离出来，并将其放在<code class="fe mx my mz na b">SliderPickable</code>协议中。</p><p id="7945" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">虽然将所有的逻辑放在<code class="fe mx my mz na b">View</code>中肯定是可能的，但这将使结构膨胀到类似于UIKit黑暗时期的巨大视图控制器的程度。当我第一次开始使用面向协议的编程技术时，我会对我的代码在哪里感到困惑。毕竟，按住command键单击一个<code class="fe mx my mz na b">View</code>结构并选择“跳转到定义”，您将不再立即看到<code class="fe mx my mz na b">body</code>属性。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><p id="6d5a" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">但是，重要的是要考虑一个视图与其他视图有什么共同点。无论我们使用什么样的颜色空间，我们都需要一个可选择的控件。在那里你可以找到滑块共有的代码。我们不能对数据类型使用泛型，因为我们只有四种颜色空间的实现。这意味着我们也需要每个颜色空间的<code class="fe mx my mz na b">View</code>结构，因为我们不想做很多if-else来确定我们在什么颜色空间以及我们在处理什么类型的数据。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="483a" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">ColourDataBindable协议</h1><p id="a0ab" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">现在我们已经创建了sliders，我们需要了解将用于所有其他控件的数据类型。正如我之前提到的，所有其他控件都需要两个参数，所以它们将接受一组<code class="fe mx my mz na b">Parameter</code>案例。与数组不同，这是一种确保参数不会多于或少于两个的方法。我已经给了他们X和Y的标签，这使得它更容易到达画布的X和Y坐标。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><h2 id="3cd0" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">扩展ColourDataBindable协议</h2><p id="d376" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">就像使用<code class="fe mx my mz na b">SliderDataBindable</code>一样，这里创建的结构不会编译，因为它们还没有实现所需的方法。我们需要能够在视图主体中调用<code class="fe mx my mz na b">getBindings</code>方法，即使我们不知道我们在什么颜色空间或者数据将有什么结构。这意味着我们需要能够为每个参数提供T4的T3语句。我再次将它作为一个元组返回，主要是因为我认为它通过没有单独的<code class="fe mx my mz na b">getXBinding</code>和<code class="fe mx my mz na b">getYBinding</code>减少了代码量。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="14e7" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">调色板:入门</h1><p id="10d6" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">由于调色板使用<code class="fe mx my mz na b">Button</code>而不是自定义手势，它们看起来没有其他控件类型复杂。但是为了知道每个样本看起来是什么样子，需要一些计算。这意味着我们需要计算这些值，并且我们需要能够在点击样本时将这些值发送回<code class="fe mx my mz na b">ColourModel</code>。对于滑块、画布和滚轮，我们直接在<code class="fe mx my mz na b">ColourModel</code>中编辑参数，因此没有理由发回数据。</p><p id="1f6b" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">但是<code class="fe mx my mz na b">Button</code>只在被点击时运行它的<code class="fe mx my mz na b">action</code>闭包，所以这是一个不同的情况。</p><h2 id="eca1" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">调色板:创建PalettePickable协议</h2><p id="1a9e" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">值得注意的是，我将文档注释放在协议中。这为声明提供了一些上下文和解释，但它消除了在其他地方这样做的需要。我们可以在调用方法的地方按住option键单击方法的名称，并查看协议中的文档。我们可以点击将文本光标放在一个方法的名称中，右边面板中的快速帮助检查器也会向我们展示这一点。</p><p id="d94c" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">对我来说，声明是定义的最佳位置，因为定义没有被长的实现块分开。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><p id="1979" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">这个<code class="fe mx my mz na b">View</code>是如何创建的应该是相当明显的。我们正在为<code class="fe mx my mz na b">size.rows</code>中的每一行创建一个<code class="fe mx my mz na b">HStack</code>布局，其中每一行包含一个<code class="fe mx my mz na b">size.columns</code>中每一列的<code class="fe mx my mz na b">Button</code>。我们调用<code class="fe mx my mz na b">getSwatchColour</code>来获得<code class="fe mx my mz na b">Color</code>，这可能令人惊讶地被直接用作<code class="fe mx my mz na b">View</code>。尽管协议扩展不知道我们在什么颜色空间。它只知道这个函数会返回一个<code class="fe mx my mz na b">Color</code>。<code class="fe mx my mz na b">getSwatchParameter</code>也是如此，它会告诉我们将什么值发送回我们的<code class="fe mx my mz na b">Binding&lt;Double&gt;</code>。</p><p id="925a" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">例如，如果我们点击色调为0.2的样本，该值将被计算并发送回<code class="fe mx my mz na b">ColourModel</code>以相应改变当前颜色。</p><h2 id="ea44" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">调色板:为每个色彩空间创建视图</h2><p id="0343" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">这些结构不会很大，但我想创建一个成员式的初始化器，使用水平和垂直维度的默认值。这允许您创建一个有100个样本的大小合适的调色板，而不必每次都记住传递这些参数。和往常一样，我提供了一个包含<code class="fe mx my mz na b">ColourModel</code>的预览，为了证明我关于调色板大小的观点，我通过设置自定义大小来挑战默认设置。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="18aa" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">为画布和轮子创建圆形阴影视图</h1><p id="65b6" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">当我们开始制作可以二维移动的控件时，我们用于<code class="fe mx my mz na b">SliderThumbView</code>的胶囊看起来就不那么好了。然而，这个圆是用同样的技术创建的，用一条细线将一个黑色的圆叠加在一个粗线的白色的圆上。由于这不是特定于画布或轮子的，我们不会为这些控件制作单独的拇指。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="7c72" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">画布:入门</h1><p id="00b6" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">尽管在垂直方向上改变一个参数，在水平方向上改变另一个参数，画布与滑块的共同点可能多于调色板。您正在<code class="fe mx my mz na b">View</code>的边界内拖动，任何颜色参数的值都在0和1之间。这意味着水平参数的值实际上是距前(左)边缘的距离除以画布的宽度，而垂直参数的值是距顶部的距离除以高度。</p><h2 id="0371" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">画布:创建双向DragModifier来检测用户输入</h2><p id="a226" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">画布的拖动手势类似于滑块的拖动手势，但它同时考虑了X和Y坐标。注意我们在开始时添加的<code class="fe mx my mz na b">CGFloat</code>和<code class="fe mx my mz na b">Double</code>扩展中的方法是如何限制值的？夹紧<code class="fe mx my mz na b">xValue</code>和<code class="fe mx my mz na b">yValue</code>意味着我们总是得到一个介于0和1之间的有效参数值。因为画布的大小是作为属性传递的，所以缩略图不能移出画布。<code class="fe mx my mz na b">maxY</code>和<code class="fe mx my mz na b">maxX</code>减少了25，因为这允许拇指(大小为50)伸出画布两侧的一半。这是画布正常工作的方式，但是如果你愿意，你可以改变它。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><h2 id="2085" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">画布:创建DoubleGradientDisplayable协议</h2><p id="cf3e" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">画布需要显示一个真实的渐变，显示如果拇指移动到给定点会选择什么颜色。我发现这可以通过将两个渐变分层来实现，尽管这些渐变是什么取决于参数和色彩空间。因为<code class="fe mx my mz na b">ColourDataBindable</code>需要一个<code class="fe mx my mz na b">getBackground</code>方法，如果没有选择颜色，我们可以计算出背景是什么。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><h2 id="3f49" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">画布:创建CanvasPickable协议</h2><p id="f3a9" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">与滑块一样，渐变背景被赋予了拖动手势。在一个<code class="fe mx my mz na b">ZStack</code>中<code class="fe mx my mz na b">CircleThumbView</code>在它的上面，并且它仅仅去由<code class="fe mx my mz na b">bidirectionalDrag</code>修改器计算的偏移。无论如何，将拇指偏移到用户触摸的确切位置的代码相对容易，而拖动需要计算拖动手势从初始位置移动了多远。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><h2 id="b08f" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">画布:为每个色彩空间创建视图</h2><p id="34c5" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">画布视图与滑块视图没有太多不同。数据明显不同，因为它需要两个参数，但其他都是一样的。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="94e7" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">轮子:入门</h1><p id="5bff" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">轮子是canvas的附加版本，它使用旋转而不是二维坐标来计算参数。离中心的距离作为第二个参数，这意味着我们仍然可以使用<code class="fe mx my mz na b">ColourDataBindable</code>来达到这个目的。</p><h2 id="c93e" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">轮子:创建RadialDragModifier以检测用户输入</h2><p id="c7fb" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">因为我们现在正在处理一个圆，我们将需要不同的计算来找到我们的参数值。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><p id="27b2" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">这个修改器使用最初创建的扩展<code class="fe mx my mz na b">CGPoint</code>以及<code class="fe mx my mz na b">CGFloat</code>和<code class="fe mx my mz na b">Double</code>扩展。这使得我们可以很容易地获得一个<code class="fe mx my mz na b">CGPoint</code>和另一个<code class="fe mx my mz na b">CGPoint</code>之间的距离，以及两点之间的角度。现在我们知道了这些值，我们就可以知道我们的参数是什么了。应该注意的是，当离中心的距离在1处达到峰值时，我们通过计算圆上该角度处的一个点来迫使拇指停留在圆内。</p><p id="2196" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">作为计算的一部分，我要减去圆周率的一半，这可能会令人困惑，但这是因为苹果的坐标系出于某种原因从右侧开始圆。我希望我的色轮从顶部开始，所以我添加了一个偏移量。这个偏移量可以在计算点之间角度的<code class="fe mx my mz na b">CGPoint</code>扩展中找到，否则我所有的计算都会偏离90度。</p><h2 id="bf5c" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">轮子:创建CircleGradientDisplayable协议</h2><p id="2cc0" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">我们不能再像使用其他控件一样使用<code class="fe mx my mz na b">LinearGradient</code>。那些日子一去不复返了！幸运的是SwiftUI为我们提供了<code class="fe mx my mz na b">AngularGradient</code>和<code class="fe mx my mz na b">RadialGradient</code>，前者以度数或弧度绕圈，后者以圆心为起点，以指定半径为终点。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">请注意，由于previews是一个静态属性，所以您想要添加的任何属性也需要是静态的</p></figure><h2 id="7c7d" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">轮子:创建可选择轮子的协议</h2><p id="a3b7" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated"><code class="fe mx my mz na b">WheelPickable</code>非常类似于画布，尽管我也选择在那里存储渐变。这使得创建<code class="fe mx my mz na b">View</code>主体变得容易，因为我相信我会在初始化过程中得到某种渐变。这确实意味着由结构根据轮子给定的参数来决定它们的梯度应该是多少。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><h2 id="ee92" class="nu li iu bd lj nv nw dn ln nx ny dp lr mk nz oa lt mo ob oc lv ms od oe lx of bi translated">轮子:为每个色彩空间创建视图</h2><p id="a472" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">因为我们并没有考虑坡度来创建车轮，所以我们需要从给定的数据和参数中创建一个。这是相对容易的，因为我们在开始时将<code class="fe mx my mz na b">fromValues</code>添加到了<code class="fe mx my mz na b">Gradient</code>扩展中。这只是在值元组中找到我们感兴趣的值，在一端将它减为零，在另一端将它增加到1。色调略有不同，因为它会随着时间的推移而变化，并且需要中途多次停留。</p><p id="b669" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我通过手动返回一个渐变来解决这个问题，这是彩虹的所有颜色！*</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div></figure><p id="d305" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">*我发现去掉橙色会使颜色分布更加准确。因为渐变无论如何都会在红色和黄色之间变成橙色，这使得色调渐变比色调参数变化得更慢。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="b058" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">创建Swift包</h1><p id="c7aa" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">您可以将您的代码放入Swift包中，然后您只需一个URL就可以将它添加到任何项目中。如果这似乎是你想做的事情，这一部分是为你准备的。如果你希望别人为你制作这个包，可以在GitHub 上查看<a class="ae kz" href="https://github.com/sturdysturge/SwiftUIColourPickerMaker" rel="noopener ugc nofollow" target="_blank">我的版本，并根据你在那里找到的MIT许可条款随意修改它。我欢迎提交新的问题，因为这个包是最近几天才创建的，可能有一些错误和改进。</a></p><p id="274d" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">如果您对Swift软件包不感兴趣，请随意跳到本文底部的后续步骤部分。</p><p id="9f40" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">在开始使用Swift软件包时，重要的是要记住，项目中未标记为私有或公共的每个类、结构、属性或方法都被赋予了默认的内部范围。</p><p id="a653" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">大多数情况下这是没问题的，因为internal意味着对同一个模块中的任何东西都是公共的。我们可以选择将颜色选择器的一部分保留在内部，只将一些部分暴露给导入它的项目。</p><p id="a0b7" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">相反，我要让事情变得简单，把一切都公开。</p><p id="8dc6" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">关于结构的一个伟大的事情是我们得到了一个成员式初始化器，而不需要创建一个。这就是为什么我之前创建的结构只有几行，但是我仍然可以通过为每个属性指定值来构造它们。然而，我们自动得到的初始化器是内部的，这意味着我们不能在包之外构造我们的视图。</p><p id="7de4" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">进入“文件”&gt;“新建”&gt;“Swift包”,并在Mac上的某个位置创建包。这将打开包并允许您编辑文件，即使它们与您的项目不在同一个文件夹中。</p><p id="d56e" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">如果你在<code class="fe mx my mz na b">package.swift</code>文件中查找，它会清楚它构建的目标文件夹是什么。这将与您创建包时给它起的名字相同。为了确保这个包不是为不受支持的目标构建的，您需要在<code class="fe mx my mz na b">package.swift</code>中指定平台。</p><p id="5df2" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我是这样做的:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lz ma l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">这里唯一的变化是靠近顶部的平台</p></figure><p id="db13" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">没有这个，你需要<a class="ae kz" href="https://www.hackingwithswift.com/new-syntax-swift-2-availability-checking" rel="noopener ugc nofollow" target="_blank">经常检查API可用性</a>。</p><p id="0867" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我们几乎只使用iOS 13和MacOS Catalina APIs，那么为什么不限制平台并避免额外的工作呢？</p><p id="f295" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">右键单击包中与您的包同名的文件夹，因为这是文件需要被编译的地方。选择“添加文件…”选项，从您的项目中添加您需要的所有文件。</p><p id="a970" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">按住Command键点按任何结构都会给出一个生成成员初始化器的选项，这会加速这个过程。</p><p id="88de" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">将初始化器标记为public是有帮助的，但是结构本身也必须是public。将<code class="fe mx my mz na b">import YourPackageName</code>放在SwiftUI文件的顶部并试图使用你的包中的结构应该会导致Xcode抱怨由于它的访问级别什么是不可访问的。</p><p id="d7c7" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">这应该有助于缩小你忘记公开的任何事情。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="888e" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">后续步骤</h1><p id="56d2" class="pw-post-body-paragraph mb mc iu md b me nb jv mg mh nc jy mj mk nd mm mn mo ne mq mr ms nf mu mv mw in bi translated">显然，你可以在任何你想要的地方使用这些颜色选择器，无论是通过复制和粘贴代码，还是通过使用Swift包来加速这个过程。如果你发现了代码中的错误，请在这里或者在GitHub上的某期文章中告诉我。</p><p id="21e8" class="pw-post-body-paragraph mb mc iu md b me mf jv mg mh mi jy mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">你可以在库的<a class="ae kz" href="https://github.com/sturdysturge/SwiftUIColourPickerMaker/tree/release/20-medium-tutorial" rel="noopener ugc nofollow" target="_blank">中级教程分支中找到一个项目，它使用了本教程中提到的所有代码。</a></p></div></div>    
</body>
</html>