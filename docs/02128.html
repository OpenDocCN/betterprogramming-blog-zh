<html>
<head>
<title>How To Build a Drag-and-Drop Grid in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中构建拖放网格</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-drag-and-drop-grid-in-react-3008c5384b29?source=collection_archive---------2-----------------------#2019-11-08">https://betterprogramming.pub/how-to-build-a-drag-and-drop-grid-in-react-3008c5384b29?source=collection_archive---------2-----------------------#2019-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="60b7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建一个简单、漂亮、交互式的图片网格</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/93284fc5db359ff558d6c20c55e3a87d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BNxm8dGTrNmlWX8AsPH8Fg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼尔·麦卡洛在<a class="ae ky" href="https://unsplash.com/s/photos/grid?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="bdf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们将在React中构建一个拖放图像网格。下面的gif展示了想要的效果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/6badc5a3432684cc8788113e985b966c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*M-b-Bpk7MWhtbLanASX8Sw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">所有图片均来自Pexels.com</p></figure><p id="0c30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我开始写这篇文章的时候，我找不到任何关于如何着手这个项目的好资料来源，于是决定自己从头开始创建它。还有，有几个很棒的库，比如<code class="fe lw lx ly lz b"><a class="ae ky" href="https://github.com/atlassian/react-beautiful-dnd" rel="noopener ugc nofollow" target="_blank">react-beautiful-dnd</a></code>，但是它们没有提供我需要的简单的二维网格支持。</p><p id="636d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该项目可在:<a class="ae ky" href="https://github.com/tfiechowski/react-dnd-grid-tutorial" rel="noopener ugc nofollow" target="_blank">github.com/tfiechowski/react-dnd-grid-tutorial</a></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="955d" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">设置</h1><p id="bd40" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">让我们从创建应用程序和安装一些我们将在整个项目中使用的依赖项开始。<code class="fe lw lx ly lz b">react-dnd</code>是我们将用于拖放交互的库，我们将使用<code class="fe lw lx ly lz b">styled-components</code>进行样式化。</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="7511" class="ni mi it lz b gy nj nk l nl nm">create-react-app dnd-grid-tutorial<br/>cd dnd-grid-tutorial<br/>yarn add styled-components react-dnd react-dnd-html5-backend</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="dba3" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">网格组件</h1><p id="7d6f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">让我们首先创建一些网格组件来保存我们的图像。我的风格基于StackOverflow 的这个答案。CSS不是本教程的主要话题，所以我将省略细节。</p><p id="c373" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe lw lx ly lz b">background-image</code> CSS属性代替<code class="fe lw lx ly lz b">&lt;img /&gt;</code>标签，以便有一些好的助手属性，如<code class="fe lw lx ly lz b">background-size</code>和<code class="fe lw lx ly lz b">background-position</code>。网格的宽度是600px，所以不会扩展到整个屏幕。这只是为了测试和开发的目的。<code class="fe lw lx ly lz b">GridItemWrapper</code>的<code class="fe lw lx ly lz b">flex-basis (flex: 0 0 33.3%;)</code>设置为33.3%。因此，我们每行将有三个项目。</p><p id="ff3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">GridItem</code>有一些带参的魔术，现在不关注了。我稍后会解释。</p><p id="7af8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把下面的代码放到<code class="fe lw lx ly lz b">src/Grid.js</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/Grid.js</p></figure><p id="0131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是教程中使用的接口组件。如果您寻求另一种布局或风格，请随意使用这里的属性。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="d937" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">拖放式</h1><p id="d98f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">所需的拖放功能本身不会工作。关于订购的状态和信息需要存储在某个地方。为此，我们将使用React上下文并创建<code class="fe lw lx ly lz b">GridContext</code>。它还将保存用于重新排序项目的逻辑。</p><p id="1a6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使网格项目可以拖放，我们将创建一个定制的包装器组件(<code class="fe lw lx ly lz b">DragItem</code>)，它将利用<code class="fe lw lx ly lz b">react-dnd</code>的拖放特性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/14898c7921883e0f750a81d944c5e2ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*lryARXv2wSSO0UwNWlhtOQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">渲染/顺序更新循环</p></figure><p id="6c0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这张图表简要显示了引擎盖下将要发生的事情:</p><ul class=""><li id="cdc0" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe lw lx ly lz b">Grid</code>从<code class="fe lw lx ly lz b">GridContext</code>获取物品，并渲染<code class="fe lw lx ly lz b">DragItems</code>列表。</li><li id="96ef" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">如果悬停<code class="fe lw lx ly lz b">GridContext</code> <strong class="lb iu"> </strong>时项目位置改变，则更新项目在其内部状态的顺序。</li><li id="d235" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lw lx ly lz b">Grid</code> <strong class="lb iu"> </strong>使用更新后的项目及其顺序进行重新渲染。</li></ul><h2 id="563a" class="ni mi it bd mj oe of dn mn og oh dp mr li oi oj mt lm ok ol mv lq om on mx oo bi translated">拖放源和目标</h2><p id="dc2f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">简单来说，<a class="ae ky" href="http://react-dnd.github.io/react-dnd/docs/api/use-drag" rel="noopener ugc nofollow" target="_blank">拖动源是可拖动的组件</a>，而<a class="ae ky" href="http://react-dnd.github.io/react-dnd/docs/api/use-drop" rel="noopener ugc nofollow" target="_blank">拖放目标是我们可以将某些东西拖放到</a>上的组件。</p><p id="ac7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个可拖动的组件需要指定它的<code class="fe lw lx ly lz b">item</code>属性，用来描述被拖动的数据。这是拖放源和拖放目标之间唯一共享的信息。将大量数据放在那里可能很诱人，甚至是对源对象(在我们的例子中是一个图像)的引用，但是最好尽可能保持简单。为了实现这一点，每个<code class="fe lw lx ly lz b">item</code>将有一个唯一的ID。</p><p id="f655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lw lx ly lz b"><a class="ae ky" href="http://react-dnd.github.io/react-dnd/docs/api/use-drag" rel="noopener ugc nofollow" target="_blank">useDrag</a></code>创建拖动源，使用<code class="fe lw lx ly lz b"><a class="ae ky" href="http://react-dnd.github.io/react-dnd/docs/api/use-drop" rel="noopener ugc nofollow" target="_blank">useDrop</a></code>创建放下目标。在下面的例子中，我们将创建一个既可拖动又可感知拖放的简单元素。两个项目的IDs一个被悬停，另一个被悬停——将被显示。</p><p id="0b47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数时候我们可能会使用React组件，但是在拖放的情况下，我们需要直接访问DOM节点。为了实现这一点，<a class="ae ky" href="https://pl.reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank">我们将创建一个</a> <code class="fe lw lx ly lz b"><a class="ae ky" href="https://pl.reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank">ref</a></code>并将它与<code class="fe lw lx ly lz b">react-dnd</code>和一个DOM元素连接起来。</p><p id="f5c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">useDrag</code>和<code class="fe lw lx ly lz b">useDrop</code>都返回数组，其中第二个元素是将我们的ref与<code class="fe lw lx ly lz b">react-dnd</code>内部连接起来的函数。这些功能被称为<em class="op">连接器功能</em>。</p><p id="bfcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，您可以看到<code class="fe lw lx ly lz b">item</code>属性是如何在拖动源和拖放目标之间传递的。此外，<a class="ae ky" href="http://react-dnd.github.io/react-dnd/docs/api/use-drag#specification-object-members" rel="noopener ugc nofollow" target="_blank">还有一个</a> <code class="fe lw lx ly lz b"><a class="ae ky" href="http://react-dnd.github.io/react-dnd/docs/api/use-drag#specification-object-members" rel="noopener ugc nofollow" target="_blank">type</a></code> <a class="ae ky" href="http://react-dnd.github.io/react-dnd/docs/api/use-drag#specification-object-members" rel="noopener ugc nofollow" target="_blank">字段，告诉空投目标他们应该对</a>的哪些物品做出反应。一个<code class="fe lw lx ly lz b">ref</code>被创建，通过<code class="fe lw lx ly lz b">connectDrag</code>和<code class="fe lw lx ly lz b">connectDrop</code>与<code class="fe lw lx ly lz b">react-dnd</code>连接，然后被传递给<code class="fe lw lx ly lz b">div</code>元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">拖放挂钩的简单例子</p></figure><p id="df63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以渲染一些元素并把它们拖到其他元素上。</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="571c" class="ni mi it lz b gy nj nk l nl nm">&lt;SimpleDragAndDropComponent <em class="op">itemId</em>="1" /&gt;<br/>&lt;SimpleDragAndDropComponent <em class="op">itemId</em>="2" /&gt;<br/>&lt;SimpleDragAndDropComponent <em class="op">itemId</em>="3" /&gt;<br/>&lt;SimpleDragAndDropComponent <em class="op">itemId</em>="4" /&gt;</span></pre><p id="9917" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">控制台的示例输出可能是:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="2416" class="ni mi it lz b gy nj nk l nl nm">Hovering item. id:  1  created:  10:06<br/>Hovered over item with id:  2</span><span id="ec68" class="ni mi it lz b gy oq nk l nl nm">Hovering item. id:  1  created:  10:06<br/>Hovered over item with id:  3</span><span id="5d76" class="ni mi it lz b gy oq nk l nl nm">Hovering item. id:  3  created:  10:06<br/>Hovered over item with id:  2</span></pre><p id="dc1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子展示了一些潜力，但是我们还不能动态地重新排序这些项目。将元素放到另一个元素上暂时不会有任何作用。现在让我们来处理这个问题。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="b45d" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">网格上下文</h1><p id="22f2" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">为了构建<code class="fe lw lx ly lz b">GridContext</code>，我们将使用React上下文。该组件将保存关于项目的信息，并公开对它们进行重新排序的方法。</p><p id="28b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用有状态的组件代替上下文是可能的，但是这样有更大的灵活性。如果组件结构变得稍微复杂一点，就不需要深度的prop传递，因为我们基本上可以在任何地方访问上下文，特别是用<code class="fe lw lx ly lz b">useContext</code> hook。</p><p id="7ad3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们决定如何即时重新订购商品。</p><h2 id="d7cc" class="ni mi it bd mj oe of dn mn og oh dp mr li oi oj mt lm ok ol mv lq om on mx oo bi translated">重新排序机制</h2><p id="a134" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">要在拖动项目时重新排序它们，我们将使用一个简单的方法:每当拖动的项目在另一个项目上时，它将取代它的位置，并将右边的所有剩余项目推得更远:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/597a380882ca2265a53209795851ae01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*So1N3byLJMbyyKaoqitdEA.png"/></div></figure><p id="16e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住这一点，同时要求我们对条目id进行操作，我们可以开始实现<code class="fe lw lx ly lz b">GridContext</code>。</p><h2 id="6722" class="ni mi it bd mj oe of dn mn og oh dp mr li oi oj mt lm ok ol mv lq om on mx oo bi translated">网格上下文</h2><p id="6540" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">它将保持项目数组的状态，并公开两个方法:<code class="fe lw lx ly lz b">moveItem(sourceId, destinationId)</code>和<code class="fe lw lx ly lz b">setItems(items)</code>。</p><p id="7912" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">moveItem</code>功能负责将给定<code class="fe lw lx ly lz b">sourceId</code>的项目移动到另一个带有<code class="fe lw lx ly lz b">destinationId</code>的项目的位置，并将其余项目向右移动一个位置。还有<code class="fe lw lx ly lz b">move</code>和<code class="fe lw lx ly lz b">moveElement</code>实用函数来处理数组的重新排列。<code class="fe lw lx ly lz b">setItems</code>仅覆盖上下文状态中的项目。</p><p id="b986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/tfiechowski/react-dnd-grid-tutorial/commit/d6aa0a2ae8a10640726f7f41d563610eff256b91" rel="noopener ugc nofollow" target="_blank"/><code class="fe lw lx ly lz b"><a class="ae ky" href="https://github.com/tfiechowski/react-dnd-grid-tutorial/commit/d6aa0a2ae8a10640726f7f41d563610eff256b91" rel="noopener ugc nofollow" target="_blank">GridContext</a></code><a class="ae ky" href="https://github.com/tfiechowski/react-dnd-grid-tutorial/commit/d6aa0a2ae8a10640726f7f41d563610eff256b91" rel="noopener ugc nofollow" target="_blank">可以通过以下方式实现:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/grid text . js</p></figure><h2 id="24f2" class="ni mi it bd mj oe of dn mn og oh dp mr li oi oj mt lm ok ol mv lq om on mx oo bi translated">DragItem</h2><p id="216a" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">现在，让我们来处理<code class="fe lw lx ly lz b">DragItem</code>组件，并像这样实现它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/DragItem.js</p></figure><p id="82a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来了解一下这里发生了什么。</p><p id="e252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们用 <code class="fe lw lx ly lz b"><a class="ae ky" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank">memo</a></code>包装了组件本身<a class="ae ky" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank">。它提高了性能，因为它只是浅显地检查道具是否改变，如果没有，它重用最后渲染的结果。在我们的道具中:</a></p><ul class=""><li id="acc1" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe lw lx ly lz b">id</code> —该商品的唯一标识，</li><li id="32f6" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lw lx ly lz b">onMoveItem</code> —实际移动和重新排列项目的处理程序，</li><li id="7fae" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lw lx ly lz b">children</code> —要渲染的子对象。</li></ul><p id="b406" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们创建一个<code class="fe lw lx ly lz b">ref</code>，它将被用作对相应DOM节点的引用。</p><p id="3f71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">拖动:</strong>拖动源由<code class="fe lw lx ly lz b">useDrag</code>创建。在返回数组的第一个元素中，我们有<code class="fe lw lx ly lz b">{ isDragging }</code>。它不是现成可用的，但它实际上是从下面的<code class="fe lw lx ly lz b">collect</code>方法返回的一个值。<code class="fe lw lx ly lz b">collect</code>函数可以访问<a class="ae ky" href="http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor" rel="noopener ugc nofollow" target="_blank">监视器，该监视器有几个可用的助手方法</a>。<code class="fe lw lx ly lz b">item</code>是必需的属性。我们将唯一的ID和一个<code class="fe lw lx ly lz b">type</code>放在那里，以指定它是哪种可拖动的项目。</p><p id="c688" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">下降:</strong>现在我们使用<code class="fe lw lx ly lz b">useDrop</code>设置下降目标。<code class="fe lw lx ly lz b">accept</code>属性被设置为<code class="fe lw lx ly lz b">IMG</code>，因为我们只希望将该类型的项目放在这里。当<a class="ae ky" href="http://react-dnd.github.io/react-dnd/docs/api/use-drop#specification-object-members" rel="noopener ugc nofollow" target="_blank">一个被拖动的项目悬停在放置目标组件</a>上时，调用<code class="fe lw lx ly lz b">hover</code>方法。</p><p id="7475" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题:<code class="fe lw lx ly lz b">hover</code>函数如何获得作为参数的<code class="fe lw lx ly lz b">hoveredOverItem</code>?</p><p id="5512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，网格中的每一项都是可拖放的。拖放机制与同一个DOM元素相关联(通过<code class="fe lw lx ly lz b">connectDrag/Drop(ref)</code>)，所以每当我们将一个项目悬停在另一个项目上时，我们实际上会在<code class="fe lw lx ly lz b">useDrag</code>中获得在那个<code class="fe lw lx ly lz b">item</code>中指定的内容。</p><p id="d853" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">重新排序:</strong>通过比较拖动和悬停项目的id，我们可以检测到项目应该重新排序的时刻。我们使用<code class="fe lw lx ly lz b">onMoveItem</code>处理器，按照以下方式完成:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="47c0" class="ni mi it lz b gy nj nk l nl nm">hover(hoveredOverItem) {<br/>  if (hoveredOverItem.id !== id) {<br/>    onMoveItem(hoveredOverItem.id, id);<br/>  }<br/>}</span></pre><p id="d931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要用拖放操作来连接我们的<code class="fe lw lx ly lz b">ref</code>:我们通过调用从<code class="fe lw lx ly lz b">useDrag/Drop</code>获得的连接器函数来完成:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="cfa0" class="ni mi it lz b gy nj nk l nl nm">connectDrag(ref);<br/>connectDrop(ref);</span></pre><p id="e909" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">一些样式:</strong>让我们使用得到的<code class="fe lw lx ly lz b">isDragging</code>变量来区分被拖动的项目。让我们这样做，改变其不透明度为0.5:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="99a0" class="ni mi it lz b gy nj nk l nl nm">const opacity = isDragging ? 0.5 : 1;<br/>const containerStyle = { opacity };</span></pre><p id="e384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">渲染儿童:</strong>现在来了一点棘手的部分。我们希望<code class="fe lw lx ly lz b">DragItem</code>尽可能地可重用，所以直接在这里放一些div或图像是不合理的。我们可以利用<code class="fe lw lx ly lz b"><a class="ae ky" href="https://medium.com/javascript-in-plain-english/how-to-use-props-children-in-react-7d6ab5836c9d" rel="noopener">children</a></code> <a class="ae ky" href="https://medium.com/javascript-in-plain-english/how-to-use-props-children-in-react-7d6ab5836c9d" rel="noopener">道具</a>来渲染我们放在<code class="fe lw lx ly lz b">DragItem</code>里面的任何东西。</p><p id="2161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">能够在<code class="fe lw lx ly lz b">DragItem</code>中呈现任何内容是一个很大的优势，但是有一个警告:我们创建的<code class="fe lw lx ly lz b">ref</code>不能直接附加到任何实际的DOM节点上，我们也不能轻易传递它。根据<a class="ae ky" href="https://reactjs.org/docs/forwarding-refs.html#forwarding-refs-in-higher-order-components" rel="noopener ugc nofollow" target="_blank"> React文档</a>，“那是因为<code class="fe lw lx ly lz b">ref</code>不是道具。和<code class="fe lw lx ly lz b">key</code>一样，React的处理方式也不一样。”</p><p id="7e12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要将它作为一个自定义道具传递，并手动将其附加到目标组件中。现在，您可以看到我们之前创建的<code class="fe lw lx ly lz b">GridItem</code>组件中的<code class="fe lw lx ly lz b">ref</code>和<code class="fe lw lx ly lz b">forwardedRef</code>的神奇之处:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="be95" class="ni mi it lz b gy nj nk l nl nm">export const GridItem = ({ <em class="op">forwardedRef</em>, ...<em class="op">props</em> }) =&gt; (<br/>  &lt;GridItemWrapper <em class="op">ref</em>={forwardedRef} {...props} /&gt;<br/>);</span></pre><p id="6245" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">GridItemWrapped</code>只是一个div(用<code class="fe lw lx ly lz b">styled.div</code>创建的)，所以在这里传递<code class="fe lw lx ly lz b">ref</code>完全没问题。记住这一点，让我们完成<code class="fe lw lx ly lz b">DragItem</code>并让它返回带有更新的样式和一个<code class="fe lw lx ly lz b">forwardedRef</code>的孩子:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="f2ba" class="ni mi it lz b gy nj nk l nl nm">return React.Children.map(children, <em class="op">child</em> =&gt;<br/>  React.cloneElement(child, {<br/>    forwardedRef: ref,<br/>    style: containerStyle<br/>  })<br/>);</span></pre><p id="57bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有子道具，所以我们将使用React内置API来操纵它们:<code class="fe lw lx ly lz b"><a class="ae ky" href="https://reactjs.org/docs/react-api.html#reactchildrenmap" rel="noopener ugc nofollow" target="_blank">React.Children.map</a></code>和<code class="fe lw lx ly lz b"><a class="ae ky" href="https://reactjs.org/docs/react-api.html#cloneelement" rel="noopener ugc nofollow" target="_blank">React.cloneElement</a></code>。我们传递的每个子对象都将把<code class="fe lw lx ly lz b">ref</code>作为<code class="fe lw lx ly lz b">forwardedRef</code>传递，并有一个自定义的不透明样式。如前所述，<code class="fe lw lx ly lz b">forwardedRef</code>被手动附加到GridItem组件中的DOM元素。</p><p id="eb05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:<strong class="lb iu"> </strong>这种情况会自动发生<em class="op"/>。我相信这个例子没问题，但是如果你发现以这种方式修改子样式太含蓄，你可以，例如，在这里传递<code class="fe lw lx ly lz b">isDragging</code>作为一个道具，然后决定组件本身的样式。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="0de9" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">把一切都连接起来</h1><p id="f0c7" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">好了，我们有了所有的积木，现在让我们把所有的东西连接起来。<code class="fe lw lx ly lz b">react-dnd</code>需要<a class="ae ky" href="http://react-dnd.github.io/react-dnd/docs/tutorial#adding-drag-and-drop-interaction" rel="noopener ugc nofollow" target="_blank">设置拖拽交互和上下文</a>,<code class="fe lw lx ly lz b">GridContext</code>需要一个提供者来正确工作。<code class="fe lw lx ly lz b">src/index.js</code>这是一个完美的地方:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/index.js</p></figure><p id="0042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:这超出了本教程的范围，但是将来你可能想探索其他的拖放后端，比如<a class="ae ky" href="https://react-dnd.github.io/react-dnd/docs/backends/touch" rel="noopener ugc nofollow" target="_blank">触摸后端</a>。</p><p id="354a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们去<code class="fe lw lx ly lz b">src/App.js</code>，接上<code class="fe lw lx ly lz b">GridContext</code>、<code class="fe lw lx ly lz b">Grid</code>和<code class="fe lw lx ly lz b">DragItems</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="76db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管网格是空的，但现在一切都应该工作正常。我准备了<a class="ae ky" href="https://github.com/tfiechowski/react-dnd-grid-tutorial/commit/e28a0213b90b2f337e2cac9348cb8d4fa2a32d91" rel="noopener ugc nofollow" target="_blank">几样东西来用</a>。随意复制它们并在<code class="fe lw lx ly lz b">GridContext</code>构造函数中使用它们来初始化项目列表。我们将看到预期的效果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/6badc5a3432684cc8788113e985b966c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*M-b-Bpk7MWhtbLanASX8Sw.gif"/></div></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="a579" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">旁注</h1><p id="5bd9" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这是一个简单的例子，没有复杂的事情发生，也没有任何API集成。有几个进一步发展它的机会。</p><p id="f369" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以扩展<code class="fe lw lx ly lz b">DragItem</code>组件来接受类似<code class="fe lw lx ly lz b">onItemDrop</code>的道具(在 <code class="fe lw lx ly lz b"><a class="ae ky" href="http://react-dnd.github.io/react-dnd/docs/api/use-drop" rel="noopener ugc nofollow" target="_blank">useDrop</a></code>中的<code class="fe lw lx ly lz b"><a class="ae ky" href="http://react-dnd.github.io/react-dnd/docs/api/use-drop" rel="noopener ugc nofollow" target="_blank">drop</a></code> <a class="ae ky" href="http://react-dnd.github.io/react-dnd/docs/api/use-drop" rel="noopener ugc nofollow" target="_blank">中调用)并指示拖动结束。它可以用于更新后端或同步整个应用程序中的其他东西。</a></p><p id="c771" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以扩展<code class="fe lw lx ly lz b">GridContext</code>来保存两个列表，一个是主工作网格，另一个是备用网格，其中的图像等待添加到第一个列表中。</p><p id="6593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在教程中跳过了这一部分，但是在GridContext 中也添加了一些简单的测试。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="99b7" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">摘要</h1><p id="2412" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们学习了如何通过动态重新排序来创建图像网格。您可以在此基础上进行构建，或者只是了解如何处理更复杂的拖放场景。</p><p id="8ded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整个项目都在GitHub仓库中:【https://github.com/tfiechowski/react-dnd-grid-tutorial T2】</p><p id="ca47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢！欢迎在评论中发表你的观点。我非常开放，渴望听到你的反馈，无论是积极的还是消极的！</p></div></div>    
</body>
</html>