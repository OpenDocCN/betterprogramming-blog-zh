<html>
<head>
<title>5 Easy Steps To Master Currying and Higher-Order Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握JavaScript中Currying和高阶函数的5个简单步骤</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-easy-steps-to-master-currying-and-higher-order-functions-in-javascript-85e2a7e2c268?source=collection_archive---------3-----------------------#2021-07-16">https://betterprogramming.pub/5-easy-steps-to-master-currying-and-higher-order-functions-in-javascript-85e2a7e2c268?source=collection_archive---------3-----------------------#2021-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7de5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过函数式编程提高JavaScript的可重用性和性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/92fd35fe353f26ab81b0bc23e9026f03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pu_GF45IbYBsxVRHmi-L_w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="a190" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Currying和高阶函数代表了函数式编程的基础。因为JavaScript直接支持他们，他们可以把你的代码变成纯粹的魔术。</p><p id="b7fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过函数式编程，它们可以对代码的可重用性和性能产生显著的积极影响。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d245" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">一流的功能</h1><p id="52d2" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">JavaScript的函数式编程特性之一是基于函数是一等公民这一事实。这意味着函数可以像字符串或任何其他类型的值一样被传递或返回。</p><p id="203b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是一些非常基本的例子，说明函数在JavaScript中是一等公民:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na lv l"/></div></figure><p id="6ef8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nb nc nd ne b">firstClassType</code>函数就是我们在函数式编程中所说的<em class="nf">恒等式</em>。它只是将其输入作为输出返回，没有任何改变。</p><p id="c66b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nb nc nd ne b">myFunctionAsOutput</code>不接受任何输入，只是返回包含函数的<code class="fe nb nc nd ne b">firstClassType</code>变量。因此，当我们调用<code class="fe nb nc nd ne b">myFunctionAsOutput()</code>时，它返回一个函数，我们可以使用其他括号再次调用该函数:</p><pre class="kj kk kl km gt ng ne nh ni aw nj bi"><span id="9b50" class="nk me it ne b gy nl nm l nn no">myFunctionAsOutput()('value');</span></pre><p id="38e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当你看着<code class="fe nb nc nd ne b">myFunctionAsInputAndOutput</code>时，你可能会注意到它只是另一个<em class="nf">身份</em>的例子，因为它只是返回它得到的值。</p><p id="473b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以调用<code class="fe nb nc nd ne b">myFunctionAsInputAndOutput(firstClassType)(‘value’);</code>和调用<code class="fe nb nc nd ne b">firstClassType(firstClassType)(‘value’);</code>是一样的。唯一的区别是一个是用经典函数定义的，另一个是用箭头函数定义的。这两个函数是同一个函数。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2157" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">高阶函数</h1><p id="ba9a" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">在函数式编程中，高阶函数就是任何将函数作为输入或返回函数作为输出的函数。因此，上例中的所有函数都是高阶函数。</p><p id="726b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嵌套的返回函数始终可以访问其父函数的作用域，您也可以使用它来编写函数，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na lv l"/></div></figure><p id="807c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是来自<a class="ae np" href="https://www.7urtle.com/" rel="noopener ugc nofollow" target="_blank"> @7urtle/lambda </a>的memoization函数的一个简化(并且更详细)的实现。记忆化是一种函数式编程优化技术，它通过直接在键值映射中查找结果来使用内存跳过计算。</p><p id="1f1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们定义我们的<code class="fe nb nc nd ne b">upperCase</code>函数时，我们通过把我们的<code class="fe nb nc nd ne b">a =&gt; a.toUpperCase()</code>作为<code class="fe nb nc nd ne b">memo</code>的第一个参数来调用<code class="fe nb nc nd ne b">memo</code>。<code class="fe nb nc nd ne b">memo</code>将这个函数包装在memoization中返回。</p><p id="21e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将允许我们简单地调用<code class="fe nb nc nd ne b">upperCase('7urtle');</code>，当重复调用时，它将使用内存直接查找结果。</p><p id="6e84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nb nc nd ne b">upperCase</code>的定义也是<em class="nf">无点</em>无参数定义的一个例子，我们可以用一个参数来定义它，如<code class="fe nb nc nd ne b">upperCase2</code>所示。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ad39" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">JavaScript中的函数Currying</h1><p id="08aa" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">你可能会认为currying这个名字来源于你最喜欢的咖喱菜肴。然而，你就大错特错了。柯里是以数学家哈斯克尔·库里的名字命名的。他的组合逻辑研究，连同阿隆佐·邱奇的λ演算，为函数式编程奠定了基础。函数式编程语言<a class="ae np" href="https://www.haskell.org/" rel="noopener ugc nofollow" target="_blank">哈斯克尔</a>也是以库里的名字命名的。</p><p id="a79a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在前面的例子中，您可能已经注意到，我们通过连续使用多个带参数的括号来使用多个函数调用。这也是你调用curried函数的方式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na lv l"/></div></figure><p id="1ee2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这段代码中，你可以看到两个相等的函数:<code class="fe nb nc nd ne b">curry1</code>和<code class="fe nb nc nd ne b">curry2</code>。利用JavaScript中的箭头函数编写的<code class="fe nb nc nd ne b">curry2</code>，当然更短更简单。</p><p id="8639" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">箭头函数中的每个箭头都返回在它之后定义的所有内容，您可以使用任意多个箭头函数。因此，当我们调用<code class="fe nb nc nd ne b">curry1(5);</code>时，它将返回期望参数<code class="fe nb nc nd ne b">b</code>的第二个函数。</p><p id="2819" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">curry就是用一系列函数的多个参数替换一个n元函数的过程，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na lv l"/></div></figure><p id="176f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在函数式编程中，我们总是喜欢用arity <em class="nf"> 1 </em>(一元)来创建函数。他们只有一个论点。<code class="fe nb nc nd ne b">curriedBinary</code>函数由两个一元函数组成。当我写我的代码时，我所有的函数总是被简化。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="499c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">定制函数的可重用性</h1><p id="4b3d" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">Curried函数之所以伟大，是因为它们可以被重用或组合来创建其他函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na lv l"/></div></figure><p id="325c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，我们将<code class="fe nb nc nd ne b">filter</code>、<code class="fe nb nc nd ne b">lowerCaseOf</code>和<code class="fe nb nc nd ne b">includes</code>函数设为一元函数。然后我们通过函数组合定义<code class="fe nb nc nd ne b">isTortoise</code>函数。建造<code class="fe nb nc nd ne b">filterTortoises</code>就像组装乐高积木一样简单。</p><p id="634c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种风格的代码编写也遵循了<em class="nf">亲</em>、<em class="nf">干</em>的最佳实践，以及<em class="nf">单责</em>原则。这也使得测试你的代码更加容易，因为你只剩下小的原子片段，它们是完全可检查的，没有任何黑盒或者共享的副作用。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="dd5d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">更好的功能组合</h1><p id="6923" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">因为每次想要使用JavaScript函数时都使用它们很烦人，所以使用像<a class="ae np" href="https://www.7urtle.com/" rel="noopener ugc nofollow" target="_blank"> @7urtle/lambda </a>这样的库要好得多，它已经为我们做了一切，甚至为我们的合成提供了一个非常有用的<code class="fe nb nc nd ne b">compose</code>函数。最终的代码看起来就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na lv l"/></div></figure><p id="bb5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，你可以看到在一行中，我们可以将<code class="fe nb nc nd ne b">isTortoise</code>定义为一个记忆化的组合无点函数。在下一行，我们简单地通过使用该函数定义了<code class="fe nb nc nd ne b">filterTortoises</code>。</p><p id="8096" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像这样写代码需要一点实践，但它是神奇的。除了使你的代码更加可重用和简短，它也将变得更容易理解和讨论。</p><p id="bf7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了在命令式过程代码中只使用原生JavaScript来做同样的事情，我可以用17行代码编写<code class="fe nb nc nd ne b">imperativeFilterTortoises</code>。如果您想比较字符而不是行，函数式声明代码需要115个字符，而命令式函数需要515个字符。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="473c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">额外收获:咖喱和普通功能</h1><p id="6e21" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">你可能希望能够使用一个函数，这个函数可以神奇地将你的n元函数转换成一个curried函数，或者允许你的函数以任何一种方式被调用。</p><p id="93b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我将为您提供采用n个函数的<code class="fe nb nc nd ne b">curry</code> <em class="nf"> </em>函数<em class="nf"> </em>和采用curried函数的<code class="fe nb nc nd ne b">nary</code> <em class="nf"> </em>函数<em class="nf"> </em>。两者都允许你以任何方式调用你自己的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na lv l"/></div></figure><p id="bc46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，<code class="fe nb nc nd ne b">curry</code> <em class="nf"> </em>和<code class="fe nb nc nd ne b">nary</code> <em class="nf"> </em>函数<em class="nf"> </em>本身是以函数式编程风格声明式编写的。考虑学习更多关于JavaScript 中<a class="ae np" href="https://medium.com/weekly-webtips/imperative-vs-declarative-programming-in-javascript-25511b90cdb7" rel="noopener">命令式和声明式编程的知识。</a></p><p id="cfe7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，这两个功能在<a class="ae np" href="https://www.7urtle.com/" rel="noopener ugc nofollow" target="_blank"> @7urtle/lambda </a>中也是可用的。事实上，@7urtle/lambda在内部使用了<code class="fe nb nc nd ne b">nary</code> <em class="nf"> </em>函数的魔力，允许库的消费者调用它的所有函数，作为curried或<em class="nf">n</em>ary函数。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b47e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="d482" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">在学习了JavaScript的函数式编程并使用了<a class="ae np" href="https://www.7urtle.com/" rel="noopener ugc nofollow" target="_blank"> @7urtle/lambda </a>之后，我就再也不想回去了。即使是现在，我有时仍然会停下来欣赏这样创建代码的简单和优雅。</p><p id="c905" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的希望是这篇文章能让你走上一条能让你获得同样醉人体验的道路。</p><p id="75ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请在评论中告诉我，你是否曾经自己编写过功能性代码，或者你是否有过将这些原则引入团队的经历。</p></div></div>    
</body>
</html>