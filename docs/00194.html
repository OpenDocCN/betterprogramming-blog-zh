<html>
<head>
<title>Docker Tips: Running a Container With a Non Root User</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker提示:用非根用户运行容器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/running-a-container-with-a-non-root-user-e35830d1f42a?source=collection_archive---------0-----------------------#2018-09-20">https://betterprogramming.pub/running-a-container-with-a-non-root-user-e35830d1f42a?source=collection_archive---------0-----------------------#2018-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fe7d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">方法和示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/972d2ebdeec33e231462e080c0806d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EGZoiM1nZNgrBCpmSpGOKQ.png"/></div></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="e8be" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="3a99" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">运行容器的一个最佳实践是使用非root用户启动流程。这通常通过使用<a class="ae mt" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank">docker文件</a>中的<code class="fe mp mq mr ms b">USER </code>指令来完成。但是，如果该指令不存在，并不一定意味着该进程以root用户身份运行。</p><h2 id="abdd" class="mu lc it bd ld mv mw dn lh mx my dp ll mc mz na ln mg nb nc lp mk nd ne lr nf bi translated">基本原理</h2><p id="fc3c" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">默认情况下，容器中的根与主机上的根(<code class="fe mp mq mr ms b">uid 0</code>)相同。如果一个用户设法从一个容器中以根用户身份运行的应用程序中脱离出来，他就能够以相同的根用户身份访问主机。如果容器运行时使用了不正确的标志，或者在读/写中绑定了主机文件夹，则获得这种访问权限会更容易。</p><h2 id="1321" class="mu lc it bd ld mv mw dn lh mx my dp ll mc mz na ln mg nb nc lp mk nd ne lr nf bi translated">运行MongoDB容器</h2><p id="a3f1" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">如果你还不知道，我强烈推荐用Docker 试试<a class="ae mt" href="http://play-with-docker.com" rel="noopener ugc nofollow" target="_blank">的玩法。也被称为<em class="ng"> PWD </em>，这是一个在线游乐场，你可以测试所有最新的Docker功能，而不必在本地安装任何东西。一旦到了PWD，你就可以创建一个实例，你会觉得自己好像在一个Linux虚拟机的外壳里。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/1803be4a996610c0792bff595049872e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgYoeUD3o32YrsOIwUxFZA.png"/></div></div></figure><p id="42b1" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated"><strong class="lv iu">注意:</strong>在幕后，您将有一个shell，但是在一个安装了Docker守护进程的Alpine容器中。这就是所谓的<em class="ng"> DinD </em>，对于Docker中的Docker，因为Docker守护进程在一个容器中运行自己。</p><p id="0488" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">在终端中，让我们运行一个基于<a class="ae mt" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>映像的容器:</p><pre class="kj kk kl km gt nn ms no np aw nq bi"><span id="8730" class="mu lc it ms b gy nr ns l nt nu">[node1] (local) root@192.168.0.13 ~<br/>$ docker container run -d -p 27017:27017 --name mongo mongo:4.0<br/>8cce38822a23bbacb5349c5af63c50f1d2e371029f5b6332b1144fcc4f8cb723</span></pre><p id="9f54" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">并从主机上检查哪个用户运行了<code class="fe mp mq mr ms b">mongod </code>流程:</p><pre class="kj kk kl km gt nn ms no np aw nq bi"><span id="f31a" class="mu lc it ms b gy nr ns l nt nu">[node1] (local) root@192.168.0.13 ~<br/>$ ps aux | grep mongo<br/> 1143 <strong class="ms iu">999</strong> 0:00 mongod --bind_ip_all</span></pre><p id="a642" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">从上面的输出中，我们可以看到由<code class="fe mp mq mr ms b">uid 999</code>标识的用户是拥有<code class="fe mp mq mr ms b">mongod</code>流程的人。让我们检查主机上的现有用户:</p><pre class="kj kk kl km gt nn ms no np aw nq bi"><span id="cbe6" class="mu lc it ms b gy nr ns l nt nu">$ cat /etc/passwd<br/>root:x:0:0:root:/root:/bin/bash<br/>bin:x:1:1:bin:/bin:/sbin/nologin<br/>daemon:x:2:2:daemon:/sbin:/sbin/nologin<br/>adm:x:3:4:adm:/var/adm:/sbin/nologin<br/>lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin<br/>sync:x:5:0:sync:/sbin:/bin/sync<br/>shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown<br/>halt:x:7:0:halt:/sbin:/sbin/halt<br/>mail:x:8:12:mail:/var/spool/mail:/sbin/nologin<br/>news:x:9:13:news:/usr/lib/news:/sbin/nologin<br/>uucp:x:10:14:uucp:/var/spool/uucppublic:/sbin/nologin<br/>operator:x:11:0:operator:/root:/bin/sh<br/>man:x:13:15:man:/usr/man:/sbin/nologin<br/>postmaster:x:14:12:postmaster:/var/spool/mail:/sbin/nologin<br/>cron:x:16:16:cron:/var/spool/cron:/sbin/nologin<br/>ftp:x:21:21::/var/lib/ftp:/sbin/nologin<br/>sshd:x:22:22:sshd:/dev/null:/sbin/nologin<br/>at:x:25:25:at:/var/spool/cron/atjobs:/sbin/nologin<br/>squid:x:31:31:Squid:/var/cache/squid:/sbin/nologin<br/>xfs:x:33:33:X Font Server:/etc/X11/fs:/sbin/nologin<br/>games:x:35:35:games:/usr/games:/sbin/nologin<br/>postgres:x:70:70::/var/lib/postgresql:/bin/sh<br/>cyrus:x:85:12::/usr/cyrus:/sbin/nologin<br/>vpopmail:x:89:89::/var/vpopmail:/sbin/nologin<br/>ntp:x:123:123:NTP:/var/empty:/sbin/nologin<br/>smmsp:x:209:209:smmsp:/var/spool/mqueue:/sbin/nologin<br/>guest:x:405:100:guest:/dev/null:/sbin/nologin<br/>nobody:x:65534:65534:nobody:/:/sbin/nologin<br/>dockremap:x:100:101:Linux User,,,:/home/dockremap:/bin/false</span></pre><p id="7f8b" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">没有带<code class="fe mp mq mr ms b">uid 999</code>的用户，这就是为什么在前面的命令中没有用户名可以映射到这个uid的原因。</p><h2 id="247e" class="mu lc it bd ld mv mw dn lh mx my dp ll mc mz na ln mg nb nc lp mk nd ne lr nf bi translated">Dockerfile文件</h2><p id="1c17" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">这是用于构建MongoDB 4.0映像的Dockerfile文件:</p><div class="nv nw gp gr nx ny"><a href="https://github.com/docker-library/mongo/blob/36a011c5f198ad05c47310284795ad029d8340ba/4.0/Dockerfile" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">docker-图书馆/mongo</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">MongoDB的Docker官方形象包装。在…上创建一个帐户，为docker-library/mongo的发展做出贡献</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ks ny"/></div></div></a></div><p id="d5f0" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">在这个文件中，没有用户指令，但是我们可以看到在图像中创建了一个新的<code class="fe mp mq mr ms b">mongodb </code>用户，并将其添加到同时创建的<code class="fe mp mq mr ms b">mongodb </code>组中。这就是以下指令的用途:</p><pre class="kj kk kl km gt nn ms no np aw nq bi"><span id="2def" class="mu lc it ms b gy nr ns l nt nu">RUN groupadd -r mongodb &amp;&amp; useradd -r -g mongodb mongodb</span></pre><p id="bbf4" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">由于docker文件中的用户指令没有指定该用户，因此在映像构建期间不会使用该用户；一切都是用root做的。</p><p id="449b" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">但是，如果我们仔细看看docker文件的末尾，我们可以看到<code class="fe mp mq mr ms b">ENTRYPOINT </code>和<code class="fe mp mq mr ms b">CMD </code>指令。</p><pre class="kj kk kl km gt nn ms no np aw nq bi"><span id="3c0b" class="mu lc it ms b gy nr ns l nt nu">ENTRYPOINT ["docker-entrypoint.sh"]</span><span id="810f" class="mu lc it ms b gy on ns l nt nu">CMD ["mongod"]</span></pre><p id="779d" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">您可能知道，这两条指令的组合定义了当容器从mongo映像启动时运行的命令。该命令如下所示:</p><pre class="kj kk kl km gt nn ms no np aw nq bi"><span id="3870" class="mu lc it ms b gy nr ns l nt nu">$ docker-entrypoint.sh mongod</span></pre><h2 id="2c80" class="mu lc it bd ld mv mw dn lh mx my dp ll mc mz na ln mg nb nc lp mk nd ne lr nf bi translated">入口点</h2><p id="a198" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">现在让我们来看看<code class="fe mp mq mr ms b">docker-entrypoint.sh file</code>的代码:</p><div class="nv nw gp gr nx ny"><a href="https://github.com/docker-library/mongo/blob/36a011c5f198ad05c47310284795ad029d8340ba/4.0/docker-entrypoint.sh" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">docker-图书馆/mongo</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">MongoDB的Docker官方形象包装。在…上创建一个帐户，为docker-library/mongo的发展做出贡献</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="oo l oj ok ol oh om ks ny"/></div></div></a></div><p id="f3bb" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">文件开头的下面这段代码非常有趣。这是由于<code class="fe mp mq mr ms b">gosu </code>实用程序，执行流程的用户从<code class="fe mp mq mr ms b">root </code>变为<code class="fe mp mq mr ms b">mongodb </code>的部分。</p><pre class="kj kk kl km gt nn ms no np aw nq bi"><span id="23c8" class="mu lc it ms b gy nr ns l nt nu"># allow the container to be started with ` — user<br/># all mongo* commands should be dropped to the correct user<br/>if [[ “$originalArgOne” == mongo* ]] &amp;&amp; [ “$(id -u)” = ‘0’ ]; then<br/>    if [ “$originalArgOne” = ‘mongod’ ];<br/>        then chown -R mongodb /data/configdb /data/db<br/>    fi <br/>    # make sure we can write to stdout and stderr as “mongodb”<br/>    # (for our “initdb” code later; see “ — logpath” below)<br/>    chown --dereference mongodb “/proc/$$/fd/1” “/proc/$$/fd/2” || :<br/>    exec <strong class="ms iu">gosu</strong> mongodb “$BASH_SOURCE” “$@”<br/>fi</span></pre><p id="faec" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated"><strong class="lv iu">注意:</strong>我们可以在docker文件中看到，<code class="fe mp mq mr ms b">gosu </code>实用程序是创建映像时安装的软件包之一。</p><h2 id="65b3" class="mu lc it bd ld mv mw dn lh mx my dp ll mc mz na ln mg nb nc lp mk nd ne lr nf bi translated">基于Ubuntu的图像</h2><p id="68da" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">Dockerfile文件中的第一条指令表明<a class="ae mt" href="https://ubuntu.com/" rel="noopener ugc nofollow" target="_blank"> ubuntu:xenial </a>是基本映像，mongo映像就是从这个映像创建的。</p><p id="5e8b" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">让我们运行一个基于Ubuntu的交互式容器，并列出现有用户:</p><pre class="kj kk kl km gt nn ms no np aw nq bi"><span id="5dc8" class="mu lc it ms b gy nr ns l nt nu">$ docker container run -ti ubuntu:xenial<br/><br/>root@9e367c3d9ca1:/# cat /etc/passwd<br/>root:x:0:0:root:/root:/bin/bash<br/>daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin<br/>bin:x:2:2:bin:/bin:/usr/sbin/nologin<br/>sys:x:3:3:sys:/dev:/usr/sbin/nologin<br/>sync:x:4:65534:sync:/bin:/bin/sync<br/>games:x:5:60:games:/usr/games:/usr/sbin/nologin<br/>man:x:6:12:man:/var/cache/man:/usr/sbin/nologin<br/>lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin<br/>mail:x:8:8:mail:/var/mail:/usr/sbin/nologin<br/>news:x:9:9:news:/var/spool/news:/usr/sbin/nologin<br/>uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin<br/>proxy:x:13:13:proxy:/bin:/usr/sbin/nologin<br/>www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin<br/>backup:x:34:34:backup:/var/backups:/usr/sbin/nologin<br/>list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin<br/>irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin<br/>gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin<br/>nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin<br/>systemd-timesync:x:100:102:systemd Time Synchronization,,,:/run/systemd:/bin/false<br/>systemd-network:x:101:103:systemd Network Management,,,:/run/systemd/netif:/bin/false<br/>systemd-resolve:x:102:104:systemd Resolver,,,:/run/systemd/resolve:/bin/false<br/>systemd-bus-proxy:x:103:105:systemd Bus Proxy,,,:/run/systemd:/bin/false<br/>_apt:x:104:65534::/nonexistent:/bin/false</span></pre><p id="d364" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">现在让我们创建一个虚拟用户和组:</p><pre class="kj kk kl km gt nn ms no np aw nq bi"><span id="3e60" class="mu lc it ms b gy nr ns l nt nu">root@9e367c3d9ca1:/# groupadd -r mygrp &amp;&amp; useradd -r -g mygrp myuser</span></pre><p id="bb6d" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">并再次列出用户:</p><pre class="kj kk kl km gt nn ms no np aw nq bi"><span id="f9ca" class="mu lc it ms b gy nr ns l nt nu">root@9e367c3d9ca1:/# cat /etc/passwd<br/>root:x:0:0:root:/root:/bin/bash<br/>daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin<br/>bin:x:2:2:bin:/bin:/usr/sbin/nologin<br/>sys:x:3:3:sys:/dev:/usr/sbin/nologin<br/>sync:x:4:65534:sync:/bin:/bin/sync<br/>games:x:5:60:games:/usr/games:/usr/sbin/nologin<br/>man:x:6:12:man:/var/cache/man:/usr/sbin/nologin<br/>lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin<br/>mail:x:8:8:mail:/var/mail:/usr/sbin/nologin<br/>news:x:9:9:news:/var/spool/news:/usr/sbin/nologin<br/>uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin<br/>proxy:x:13:13:proxy:/bin:/usr/sbin/nologin<br/>www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin<br/>backup:x:34:34:backup:/var/backups:/usr/sbin/nologin<br/>list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin<br/>irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin<br/>gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin<br/>nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin<br/>systemd-timesync:x:100:102:systemd Time Synchronization,,,:/run/systemd:/bin/false<br/>systemd-network:x:101:103:systemd Network Management,,,:/run/systemd/netif:/bin/false<br/>systemd-resolve:x:102:104:systemd Resolver,,,:/run/systemd/resolve:/bin/false<br/>systemd-bus-proxy:x:103:105:systemd Bus Proxy,,,:/run/systemd:/bin/false<br/>_apt:x:104:65534::/nonexistent:/bin/false<br/><strong class="ms iu">myuser:x:999:999::/home/myuser:</strong></span></pre><p id="3659" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">我们可以看到新用户被创建为<code class="fe mp mq mr ms b">uid 999</code>，这是从一个新的<code class="fe mp mq mr ms b">ubuntu:xenial</code>映像中创建的第一个用户的uid。这个uid就是我们之前看到的用于运行<code class="fe mp mq mr ms b">mongod </code>流程的uid。提醒一下:</p><pre class="kj kk kl km gt nn ms no np aw nq bi"><span id="a4cc" class="mu lc it ms b gy nr ns l nt nu">[node1] (local) root@192.168.0.13 ~<br/>$ ps aux | grep mongo<br/> 1143 <strong class="ms iu">999</strong> 0:00 mongod --bind_ip_all</span></pre><h2 id="aa4e" class="mu lc it bd ld mv mw dn lh mx my dp ll mc mz na ln mg nb nc lp mk nd ne lr nf bi translated">基于阿尔卑斯山的图像</h2><p id="b217" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">应用程序映像不一定基于<code class="fe mp mq mr ms b">ubuntu:xenial.</code>很多都基于<a class="ae mt" href="https://alpinelinux.org/" rel="noopener ugc nofollow" target="_blank"> Alpine </a>(专注于安全的微小分布)。</p><p id="d50f" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">让我们从一个新的alpine容器中添加一个新用户，并检查它的uid。</p><pre class="kj kk kl km gt nn ms no np aw nq bi"><span id="ebdd" class="mu lc it ms b gy nr ns l nt nu">$ docker container run -ti alpine:3.8<br/>/ # adduser -D myuser<br/>/ # cat /etc/passwd<br/>root:x:0:0:root:/root:/bin/ash<br/>bin:x:1:1:bin:/bin:/sbin/nologin<br/>daemon:x:2:2:daemon:/sbin:/sbin/nologin<br/>adm:x:3:4:adm:/var/adm:/sbin/nologin<br/>lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin<br/>sync:x:5:0:sync:/sbin:/bin/sync<br/>shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown<br/>halt:x:7:0:halt:/sbin:/sbin/halt<br/>mail:x:8:12:mail:/var/spool/mail:/sbin/nologin<br/>news:x:9:13:news:/usr/lib/news:/sbin/nologin<br/>uucp:x:10:14:uucp:/var/spool/uucppublic:/sbin/nologin<br/>operator:x:11:0:operator:/root:/bin/sh<br/>man:x:13:15:man:/usr/man:/sbin/nologin<br/>postmaster:x:14:12:postmaster:/var/spool/mail:/sbin/nologin<br/>cron:x:16:16:cron:/var/spool/cron:/sbin/nologin<br/>ftp:x:21:21::/var/lib/ftp:/sbin/nologin<br/>sshd:x:22:22:sshd:/dev/null:/sbin/nologin<br/>at:x:25:25:at:/var/spool/cron/atjobs:/sbin/nologin<br/>squid:x:31:31:Squid:/var/cache/squid:/sbin/nologin<br/>xfs:x:33:33:X Font Server:/etc/X11/fs:/sbin/nologin<br/>games:x:35:35:games:/usr/games:/sbin/nologin<br/>postgres:x:70:70::/var/lib/postgresql:/bin/sh<br/>cyrus:x:85:12::/usr/cyrus:/sbin/nologin<br/>vpopmail:x:89:89::/var/vpopmail:/sbin/nologin<br/>ntp:x:123:123:NTP:/var/empty:/sbin/nologin<br/>smmsp:x:209:209:smmsp:/var/spool/mqueue:/sbin/nologin<br/>guest:x:405:100:guest:/dev/null:/sbin/nologin<br/>nobody:x:65534:65534:nobody:/:/sbin/nologin<br/><strong class="ms iu">myuser:x:1000:1000:Linux User,,,:/home/myuser:</strong></span></pre><p id="a5fc" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">正如我们在这里看到的，一个<code class="fe mp mq mr ms b">alpine </code>图像中第一个用户的id是1000，不同于一个<code class="fe mp mq mr ms b">ubuntu </code>图像的<code class="fe mp mq mr ms b">uid 999</code>。如果我们在<code class="fe mp mq mr ms b">alpine </code>图像中添加一个用户，并使用该用户运行一个流程(例如，使用owner文件中的用户指令)，我们将看到<code class="fe mp mq mr ms b">uid 1000</code>是流程的所有者。让我们试一试。</p><p id="d743" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">让我们使用一个简单的docker文件，它将用户添加到一个<code class="fe mp mq mr ms b">Alpine </code>图像，并定义一个基本的<em class="ng"> </em> <code class="fe mp mq mr ms b">sleep 1000</code>命令。</p><pre class="kj kk kl km gt nn ms no np aw nq bi"><span id="6010" class="mu lc it ms b gy nr ns l nt nu">FROM alpine:3.8<br/>RUN adduser -D myuser<br/>USER myuser<br/>ENTRYPOINT [“sleep”]<br/>CMD [“1000”]</span></pre><p id="e583" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">让我们用它来构建一个图像:</p><pre class="kj kk kl km gt nn ms no np aw nq bi"><span id="364e" class="mu lc it ms b gy nr ns l nt nu">$ docker image build -t sleep:1.0 .<br/>Sending build context to Docker daemon 1.775MB<br/>Step 1/5 : FROM alpine:3.8<br/>3.8: Pulling from library/alpine<br/>4fe2ade4980c: Pull complete<br/>Digest: sha256:621c2f39f8133acb8e64023a94dbdf0d5ca81896102b9e57c0dc184cadaf5528<br/>Status: Downloaded newer image for alpine:3.8<br/> — -&gt; 196d12cf6ab1<br/>Step 2/5 : RUN adduser -D myuser<br/> — -&gt; Running in a7474167f27d<br/>Removing intermediate container a7474167f27d<br/> — -&gt; 7a17f0862780<br/>Step 3/5 : USER myuser<br/> — -&gt; Running in b0a7eea711a4<br/>Removing intermediate container b0a7eea711a4<br/> — -&gt; d63533ce5be1<br/>Step 4/5 : ENTRYPOINT [“sleep”]<br/> — -&gt; Running in f0dfc3ea4495<br/>Removing intermediate container f0dfc3ea4495<br/> — -&gt; 763dd8ac4f40<br/>Step 5/5 : CMD [“1000”]<br/> — -&gt; Running in 14db1ea262f9<br/>Removing intermediate container 14db1ea262f9<br/> — -&gt; 978294e76184<br/>Successfully built 978294e76184<br/>Successfully tagged sleep:1.0</span></pre><p id="48d9" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">然后从新创建的映像运行一个容器:</p><pre class="kj kk kl km gt nn ms no np aw nq bi"><span id="07d8" class="mu lc it ms b gy nr ns l nt nu">[node1] (local) root@192.168.0.8 ~<br/>$ docker container run -d sleep:1.0<br/>534e340780a89b3a86917aff2c20405dadbd7d50cfe5cb03e9cb6786a0517f21</span></pre><p id="d892" class="pw-post-body-paragraph lt lu it lv b lw ni ju ly lz nj jx mb mc nk me mf mg nl mi mj mk nm mm mn mo im bi translated">如果我们检查主机上的<code class="fe mp mq mr ms b">sleep </code>进程的所有者，我们可以看到它属于带有<code class="fe mp mq mr ms b">uid 1000</code>的用户，即在映像中创建的用户。</p><pre class="kj kk kl km gt nn ms no np aw nq bi"><span id="5de0" class="mu lc it ms b gy nr ns l nt nu">[node1] (local) root@192.168.0.8 ~<br/>$ ps aux | grep sleep<br/> 1181 <strong class="ms iu">1000</strong> 0:00 sleep 1000</span></pre></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="e206" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">摘要</h1><p id="2c5c" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">我希望这些例子能帮助你理解非根用户运行容器的一些方法，要么通过done文件中的<code class="fe mp mq mr ms b">USER </code>指令的映像，要么通过在运行时改变用户(通常在<code class="fe mp mq mr ms b">entrypoint </code>脚本中完成)。我们在这里没有涉及的另一种方法是在运行容器时使用<code class="fe mp mq mr ms b">--user</code>标志。</p></div></div>    
</body>
</html>