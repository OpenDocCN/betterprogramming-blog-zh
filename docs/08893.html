<html>
<head>
<title>3 Ways To Templatize Kubernetes Manifest Files in Production Systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在生产系统中模板化Kubernetes清单文件的3种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-ways-to-templatize-kubernetes-manifest-files-in-production-systems-c6808be4b1a2?source=collection_archive---------8-----------------------#2021-06-23">https://betterprogramming.pub/3-ways-to-templatize-kubernetes-manifest-files-in-production-systems-c6808be4b1a2?source=collection_archive---------8-----------------------#2021-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d83b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基于两年来对Kubernetes的研究</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/186a336f7bf6e6b3f2fdfe64dad4dc59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebZDQ3Ad_8WgDfh-QjivRA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@carrier_lost?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">伊恩·泰勒</a>在<a class="ae ky" href="https://unsplash.com/s/photos/container?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="b8e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初由Google开发的,<a class="ae ky" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>是一个开源容器编排平台，旨在自动化容器化应用程序的部署、扩展和管理。写这篇文章的时候，Kubernetes已经七岁左右了，它是最受人喜爱的平台之一。一份<a class="ae ky" href="https://www.flexera.com/about-us/press-center/rightscale-2019-state-of-the-cloud-report-from-flexera-identifies-cloud-adoption-trends.html" rel="noopener ugc nofollow" target="_blank"> RightScale报告</a>显示，集装箱采用率从2018年的49%增长到2019年的57%。包括微软Azure、谷歌云和亚马逊AWS在内的许多云提供商也推出了容器。</p><p id="c8ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes使用形式为<code class="fe lv lw lx ly b">.yaml</code>的清单文件来创建、修改和删除Kubernetes资源，比如pod、部署、服务等。但是Kubernetes没有提供任何自己的模板机制，因为部署的清单应该是静态的YAML文件。这意味着，如果您希望对生产、转移和开发使用不同的配置集，默认情况下将不可用。</p><p id="0615" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="a53d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可能希望有不同数量的副本用于转移和QA。同样，您使用的映像可能因环境而异。如果您硬编码这些值，可能很难在不同的环境中使用它们。</p><p id="8eca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是模板化派上用场的时候。这是创建您自己的清单文件或更新和编辑现有文件的一种方式。</p><p id="1f0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看完成这项工作的不同方法。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="39f8" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">用代码生成清单文件</h1><p id="6ee4" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">您可以通过编写代码以编程方式生成Kubernetes YAML文件。Kubernetes有几个<a class="ae ky" href="https://kubernetes.io/docs/reference/using-api/client-libraries/" rel="noopener ugc nofollow" target="_blank">客户端库</a>来帮助创建对象，比如部署和Pod代码。</p><p id="7128" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，我将展示一个Java例子来说明如何轻松地做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="ec71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在环境中传递给这个函数，它会为你创建一个pod YAML。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="d960" class="nj mj it ly b gy nk nl l nm nn">Pod pod = <em class="no">createPod</em>(environment);</span></pre><p id="2414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是由此产生的YAML:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="c046" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以使用此YAML在整个集群中应用。你可以在GitHub 上找到完整的代码库<a class="ae ky" href="https://github.com/learnk8s/templating-kubernetes" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4741" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写代码的好处是您不必担心替换变量、配置等。守则会照顾到所有这一切。你只需传递一些变量，它就会为你创建文件。</p><p id="9a8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，编写代码来生成这些清单文件在Kubernetes世界中并不常见——可能是因为这比手工编写YAML更难。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="b2bd" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">使用Kustomize更新和修补清单文件</h1><p id="7560" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">是一个帮助你管理Kubernetes清单文件的工具。从1.14开始，Kubectl还支持使用kustomization文件管理Kubernetes对象。</p><p id="e351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">Kustomize</code>，创建一个基本的YAML文件，然后对其应用补丁。假设您为创建一个Pod编写了一个YAML文件。但是您的公司需要对其应用额外的网络策略。您可以在YAML中对策略进行硬编码，也可以将其作为单独的文件添加，并在部署时对其进行修补。</p><p id="73b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相同的概念可以应用于副本、配置映射、环境变量等。</p><p id="df9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Kustomize</code>通过草绘文件工作。让我们看一个如何使用<code class="fe lv lw lx ly b">Kustomize</code>创建和修补清单文件的例子。</p><p id="94aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个新目录中，创建两个文件夹:<code class="fe lv lw lx ly b">base</code>(用于基本YAMLs)和<code class="fe lv lw lx ly b">overlays</code>(用于您想要修补的任何额外内容)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/48a6b2a70a39bef43ecc72c11c7f926f.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*iB7IB_pEQTrBaZuSCaeMdQ.png"/></div></figure><p id="a497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的<code class="fe lv lw lx ly b">base</code>中，我有一个用于创建pod资源的部署YAML:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="2a58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了这个<code class="fe lv lw lx ly b">base</code>清单文件，我们还需要添加一个库定制文件。看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="e8b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们看一下专门为我们的临时集群添加一个映像。</p><p id="fcc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">overlays</code>文件夹中，让我们为配置创建一个<code class="fe lv lw lx ly b">stag</code>文件夹。添加一个文件:<code class="fe lv lw lx ly b">image.yaml</code>。</p><p id="cd74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是该文件的外观:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="547f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="no">注意:请确保名称与</em> <code class="fe lv lw lx ly b"><em class="no">base</em></code> <em class="no">相同。</em></p><p id="097f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，我们还需要一个<code class="fe lv lw lx ly b">kustomization.yaml</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="c76d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们尝试修补YAMLs:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="d269" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以观察图像是如何添加到基本YAML的。</p><p id="5aa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目录结构如下所示:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="dbf9" class="nj mj it ly b gy nk nl l nm nn">Cintos-Mac:testKustomize cinto [druiddevdev]$ tree .<br/>.<br/>├── base<br/>│   ├── deployment.yaml<br/>│   ├── kustomization.yaml<br/>│   └── service.yaml<br/>└── overlays<br/>    └── stag<br/>        ├── image.yaml<br/>        └── kustomization.yaml</span></pre><p id="3e27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kustomize在为不同环境修补清单文件方面提供了很大的灵活性。Kustomize唯一的小问题是不能在YAMLs中逐字替换，这可能是一些人的用例。但是有很多选项可以做到这一点，比如sed或<code class="fe lv lw lx ly b">yq</code>。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="8aab" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">使用yq更新清单文件</h1><p id="0dc8" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated"><code class="fe lv lw lx ly b">yq</code>是一个伟大的轻量级命令行工具，用于模板化YAML文件。</p><p id="de11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如vik代码所示，<code class="fe lv lw lx ly b">yq</code> <a class="ae ky" href="https://dev.to/vikcodes/yq-a-command-line-tool-that-will-help-you-handle-your-yaml-resources-better-8j9" rel="noopener ugc nofollow" target="_blank">也可以</a>:</p><blockquote class="nq nr ns"><p id="4e00" class="kz la no lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated">"1.从文件中读取值。</p><p id="ee15" class="kz la no lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated">2.添加新值。</p><p id="28d9" class="kz la no lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated">3.更新现有值。</p><p id="520f" class="kz la no lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated">4.生成新的YAML文件。</p><p id="6322" class="kz la no lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated">5.将YAML转换成JSON。</p><p id="b856" class="kz la no lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated">6.合并两个或多个YAML文件。"</p></blockquote><p id="c077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个如何使用<code class="fe lv lw lx ly b">yq</code>更新清单文件的例子。以下是用于创建pod的YAML文件示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="2331" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望将副本数量从<code class="fe lv lw lx ly b">2</code>更新到<code class="fe lv lw lx ly b">5</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="0ed4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以使用<code class="fe lv lw lx ly b">sed</code>或<code class="fe lv lw lx ly b">awk</code>来完成这些转换。但是使用<code class="fe lv lw lx ly b">yq</code>优于<code class="fe lv lw lx ly b">sed</code>的地方在于，与<code class="fe lv lw lx ly b">sed</code>不同的是，<code class="fe lv lw lx ly b">yq</code>理解YAML格式，并且能够导航和处理结构化标记。<code class="fe lv lw lx ly b">sed</code>将文件视为字符串，不介意文件是否是有效的YAML。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="ae98" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结论</h1><p id="6b5a" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">如果您使用Kubernetes进行部署，您将需要某种方法来为不同的环境和集群模板化您的清单文件。</p><p id="c399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是三种最常用的方法:</p><ul class=""><li id="7acb" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">编写您的清单文件。</li><li id="df31" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">使用<code class="fe lv lw lx ly b">Kustomize</code>修补文件。</li><li id="eed7" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">使用<code class="fe lv lw lx ly b">yq</code>更新文件。</li></ul><p id="a377" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经在我的生产集群中使用了这三个工具。我经常使用<code class="fe lv lw lx ly b">Kustomize</code>和<code class="fe lv lw lx ly b">yq</code>一起更新和修补文件。</p></div></div>    
</body>
</html>