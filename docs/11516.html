<html>
<head>
<title>Make Your Legacy Code Testable Again</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让您的遗留代码再次可测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/make-your-legacy-code-testable-again-becdb5212c38?source=collection_archive---------5-----------------------#2022-03-27">https://betterprogramming.pub/make-your-legacy-code-testable-again-becdb5212c38?source=collection_archive---------5-----------------------#2022-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fdfe" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在本文中，我们将关注如何重构遗留代码库，以便它可以再次测试(不需要依赖注入框架)</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a44dec1307ca9bd2c49e5d456d66c4ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2GPBrDR-mX5JFznM"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@mullyadii?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">穆利亚迪</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="622a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">背景</h1><p id="4df5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">可能大多数软件开发人员都非常了解诸如单元测试和TDD<em class="mk">T5这样的术语。参与项目的开发人员努力工作，尽最大努力交付满足业务需求的解决方案。</em></p><p id="e5fc" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">然而，有时，由于意想不到的困难(低估的用户故事/变化的需求/即将到来的截止日期/太小的团队/缺乏知识—选择一个)，技术债务可能会出现。这在一开始看起来可能是无辜的，但是我们的债务越大，出现bug的可能性就越大。</p><p id="cef3" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在本文中，我将关注技术债务的一个特殊味道，那就是不可测试的代码。</p><h1 id="c06d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">让我们来看看不可测试的代码</h1><p id="fe81" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">但是首先，简短的定义:我们可以说代码在不可能的时候是不可测试的，或者很难用单元/集成测试来覆盖代码。</p><p id="d389" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我个人最喜欢从实例中学习，那么我们来考虑一个与保险行业相关的假设案例。</p><p id="22ac" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">为了更好地了解索赔注册过程，粗略地说，我们可以将整个索赔注册过程分成几个较小的部分:</p><ol class=""><li id="7386" class="mq mr iq lq b lr ml lu mm lx ms mb mt mf mu mj mv mw mx my bi translated">查找保单—通常有一个单独的系统保存客户的保单</li><li id="80b3" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">从保单中选择适当的保险类型—例如，如果我们撞了别人的车，我们必须在保单中投保汽车第三方责任险；另一方面，如果冰雹损坏了我们的汽车，这种情况有一个单独的保险类型——所以，如果我们的保单没有与路上发生的情况相关的保险，保险公司不会支付我们任何赔偿</li><li id="7c7f" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">收集必要的数据以识别被保险人、索赔人、涉及的车辆等</li><li id="d074" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">有时，为了使整个索赔处理过程更加顺利，最好利用外部服务来提供涉及车辆的附加信息</li></ol><p id="1760" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">因此，了解了这一点，您现在是一名专家了，企业渴望给您带来新的挑战，其中一个挑战听起来如下:<em class="mk">实施新的索赔登记流程</em>。</p><h1 id="86df" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">案例:实施新的索赔登记流程</h1><ul class=""><li id="a052" class="mq mr iq lq b lr ls lu lv lx ne mb nf mf ng mj nh mw mx my bi translated">您一直在为一家保险公司开发一个处理汽车索赔的Java应用程序</li><li id="2f24" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj nh mw mx my bi translated">要求是允许索赔人登记MTPL(机动车第三方责任)索赔</li><li id="57e0" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj nh mw mx my bi translated">索赔人将向我们提供车辆的详细信息，如品牌、型号、VIN(车辆识别号)</li><li id="c3f5" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj nh mw mx my bi translated">为了加快索赔处理的整个过程，企业希望您使用一种奇特的第三方服务来解码VIN，这样索赔处理人员将会收到有关所涉及车辆的附加信息</li></ul><p id="5467" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在，假设您得到了需求，并且立即开始了实现部分:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">初始实施</p></figure><p id="8f50" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">您刚刚完成了实现，点击了UI，一切看起来都很好，万岁！你有时间看搞笑狗:)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/f15570fbcf3cd7afc82f6255b409b0ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pbcQw07NIOKlfnkZ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@rpnickson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗伯特·尼克森</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d848" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">好消息是企业接受了这个解决方案，坏消息是企业不知道(也许你也不知道)由于没有用单元/集成测试覆盖引入的功能，技术债务增加了。</p><h2 id="148b" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">上面的代码有什么问题？</h2><ol class=""><li id="b635" class="mq mr iq lq b lr ls lu lv lx ne mb nf mf ng mj mv mw mx my bi translated">代码没有被测试覆盖</li><li id="734d" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">如果您想稍后编写单元测试，您会看到在测试中调用<code class="fe nx ny nz oa b">RegisterMotorClaimService#registerClaim()</code>试图调用策略系统和VIN解码服务</li></ol><p id="c019" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">第一点是不言自明的。用测试覆盖代码永远不会太晚，所以让我们专注于第二点。</p><p id="3cab" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">就集成测试而言，您可以说:</p><blockquote class="ob oc od"><p id="4ec2" class="lo lp mk lq b lr ml jr lt lu mm ju lw oe mn lz ma of mo md me og mp mh mi mj ij bi translated">嘿，但是<code class="fe nx ny nz oa b">new PolicyService()</code>可能包含了调用适当服务所需的所有信息，比如URL、用户名、密码和其他数据。也许构造器从数据库或一些属性文件中获得这些信息，所以我们可以区分生产环境和测试环境。</p></blockquote><p id="20c5" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">说到集成测试，事实上，可能就是这样，所以我们可以编写它们。然而，在单元测试的情况下，事情变得有点复杂。</p><p id="d843" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们如何编写与外部环境和服务隔离的单元测试，以便无论何时运行它们，我们都可以确保它们不会因为策略系统安装或VIN解码服务关闭而失败？</p><p id="eb5e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">答案是:允许被测试的功能使用假依赖。换句话说，告诉这个类使用一个不同版本的服务，它可以抵抗失败，而且，它总是可以返回我们想要的。使用这种方法，您可以从策略系统和VIN解码服务准备测试响应。反过来，这将允许您编写不关心服务访问中断的测试，因此您的测试不会随机失败。</p><h1 id="194e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">重构步骤</h1><p id="c1f5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">有些人倾向于以“火了就忘”的方式编写代码，但我个人发现重构可以带来很大的满足感，尤其是当我可以用一些测试覆盖它时——测试报告中没有什么比绿色更好的了:)。</p><p id="9e1d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">因为我们已经了解了之前解决方案的后果，所以让我们从重构中获得一些乐趣。</p><p id="cb7b" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">为了使上面的代码再次可测试，我们需要识别我们想要隔离的外部依赖，在我们的例子中是<code class="fe nx ny nz oa b">SomePolicyService</code>和<code class="fe nx ny nz oa b">SomeVinDecodingService</code>。</p><h2 id="6c5c" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">步骤1:从外部提供依赖关系</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在从外部提供依赖关系之前</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">重构后</p></figure><p id="6585" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">使用这种方法，您可以摆脱硬编码的依赖，并通过<code class="fe nx ny nz oa b">RegisterMotorClaimService</code>中的构造函数注入从外部提供它们</p><p id="1d36" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如果您使用像Mockito这样的库，您很可能就在这里完成重构过程，因为您的mock库应该允许您模仿具体的类。</p><p id="8c03" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">然而，如果由于某种原因，您不能模仿具体的类，那么继续第2步。</p><h2 id="5409" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">步骤2:提取依赖关系的接口</h2><p id="d5bd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果您不能模拟具体的类，或者如果您根本不能使用模拟库，那么您就需要执行这个额外的步骤，以便手动模拟对象。</p><p id="7c3a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们创建将分别由<code class="fe nx ny nz oa b">SomePolicyService</code>和<code class="fe nx ny nz oa b">SomeVinDecodingService</code>实现的接口。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">服务的提取接口</p></figure><p id="4a8c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">最后一件事是在我们现有的类中实现这些接口:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">实现提取接口的服务</p></figure><h2 id="0585" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">步骤3:更改传递的依赖项的类型</h2><p id="5a6b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果您已经执行了步骤#2，您还需要更改通过<code class="fe nx ny nz oa b">RegisterMotorClaimService</code>中的构造函数传递的对象的参数类型。通过将参数类型从具体的类改为它们的接口等价物来实现。</p><p id="0d3e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">之后:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将参数类型从具体类更改为接口</p></figure><p id="02e1" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">通过这样做，您可以用PROD环境的真实依赖关系实例化<code class="fe nx ny nz oa b">RegisterMotorClaimService</code>,或者传递单元测试的假依赖关系。</p><h2 id="1541" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">步骤4:编写一个样本测试</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试提供虚假依赖的业务逻辑</p></figure><p id="d4f4" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在这个测试中，我通过创建服务的匿名实现来手动模拟服务。</p><p id="36f4" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">然后我将这些依赖项传递给测试中的服务<code class="fe nx ny nz oa b">RegisterMotorClaimService</code>。</p><p id="7baa" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">最后，我验证注册的索赔是否与具有给定保单号的保单相关联。</p><h1 id="4ff1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">最后的想法</h1><p id="6661" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">总结一下:</p><ul class=""><li id="b8ec" class="mq mr iq lq b lr ml lu mm lx ms mb mt mf mu mj nh mw mx my bi translated">在编写实际代码之前，我们应该考虑如何编写可测试的实现</li><li id="faff" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj nh mw mx my bi translated">依赖关系应该从类的外部提供，所以我们可以很容易地替换它们来进行单元测试</li><li id="baa7" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj nh mw mx my bi translated">重构代码并为现有功能添加测试永远不会太迟</li></ul></div></div>    
</body>
</html>