<html>
<head>
<title>Exploring Collections and Sequences in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在科特林探索收藏和序列</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-collections-and-sequences-in-kotlin-3a324ea08fb9?source=collection_archive---------19-----------------------#2020-03-18">https://betterprogramming.pub/exploring-collections-and-sequences-in-kotlin-3a324ea08fb9?source=collection_archive---------19-----------------------#2020-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4bd9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习如何根据上下文处理集合</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1baa7c7ff18970725db5a6d3e6d038c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QjW4XREmLKBU0NqD"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Clem Onojeghuo 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="797b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于任何平台上的开发人员来说，处理集合都是一项常见的任务。Kotlin提供了许多扩展函数来处理集合。主要来说，它提供了两种处理集合的方法:急切地<strong class="lb iu"> </strong>处理集合，懒散地<strong class="lb iu"> </strong>处理序列。请继续阅读，了解它们。</p><p id="376f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不打算评判两者中哪一个最好。相反，我将用一个简单的例子来解释它们是如何工作的，这样你就可以根据你的环境选择最好的一个。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f7fc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">准备抢劫</h1><p id="399b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了让事情变得有趣，让我们考虑一系列抢劫。<code class="fe mz na nb nc b">Heist</code>是一个有四个变量的数据类，分别是数据类型为<code class="fe mz na nb nc b">String</code>、<code class="fe mz na nb nc b">Int</code>、<code class="fe mz na nb nc b">Boolean</code>、<code class="fe mz na nb nc b">Crew</code>的<code class="fe mz na nb nc b">place</code>、<code class="fe mz na nb nc b">year</code>、<code class="fe mz na nb nc b">execute</code>、<code class="fe mz na nb nc b">crew</code>。看一看:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9283" class="nh md it nc b gy ni nj l nk nl">data class Heist(val <strong class="nc iu">place </strong>: String,<br/>                 val <strong class="nc iu">year </strong>: Int,<br/>                 val <strong class="nc iu">execute </strong>: Boolean,<br/>                 val <strong class="nc iu">crew </strong>: Crew)<br/>var <strong class="nc iu">lishOfHeists </strong>: ArrayList&lt;Heist&gt; = ArrayList()</span></pre><p id="92a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">crew是另一个数据类，在这个数据类中，我们将船员的数据作为一个带有<code class="fe mz na nb nc b">CrewMember</code>类型的数组列表。看看<code class="fe mz na nb nc b">Crew </code>和<code class="fe mz na nb nc b">CrewMember</code>数据类:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="130c" class="nh md it nc b gy ni nj l nk nl">data class Crew(val <strong class="nc iu">crewList </strong>: ArrayList&lt;CrewMember&gt;,<br/>                val <strong class="nc iu">total </strong>: Int)</span><span id="e037" class="nh md it nc b gy nm nj l nk nl">data class CrewMember(val <strong class="nc iu">name </strong>: String,<br/>                val <strong class="nc iu">expertise </strong>: String)</span></pre><p id="793d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">准备工作到此为止。让我们开始真正的任务吧。在<code class="fe mz na nb nc b">lishOfHeists</code>中，我在第5位找到了一件2020年的抢劫物品。我们的任务是在2020年实施抢劫。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6d53" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用收藏品执行抢劫</h1><p id="7eca" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，让我们用集合来热切地做它。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="05f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们有两个操作:<code class="fe mz na nb nc b">map</code>(中间转换)和<code class="fe mz na nb nc b">first</code>(终端操作)。</p><p id="2f5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe mz na nb nc b">map </code>内部触发<code class="fe mz na nb nc b">listOfHeists </code>时，会创建另一个列表。一旦列表中的所有对象都在<code class="fe mz na nb nc b">map</code>中迭代完毕，就会进入终端操作<code class="fe mz na nb nc b">first</code>。</p><p id="a06f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论列表中有10个还是100个项目，当您执行集合时，所有100个项目都将在<code class="fe mz na nb nc b">map</code>中急切地运行<strong class="lb iu"> </strong>。然后将执行终端操作。</p><p id="91b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们要搜索的物品位于第五个位置，就像我们的抢劫一样，地图将执行所有100次抢劫，因为只有在中间转换中完成所有迭代后,<code class="fe mz na nb nc b">terminal</code>函数才会执行。</p><p id="fc93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是中间转换发生在所有项目上，不必要地浪费了宝贵的资源。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="107e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用序列执行抢劫</h1><p id="82ff" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们用序列懒洋洋地做它。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d4d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与集合不同，序列不会立即执行中间转换。它将缓慢地<strong class="lb iu"> </strong>等待，直到<code class="fe mz na nb nc b">terminal</code>功能被触发，然后它将依次执行<code class="fe mz na nb nc b">intermediate</code>和<code class="fe mz na nb nc b">terminal</code>功能。</p><p id="b9b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，在迭代中，<code class="fe mz na nb nc b">intermediate</code>和<code class="fe mz na nb nc b">terminal</code>函数将依次执行。所以在位置5，迭代将在条件满足时终止。这解决了不必要地迭代列表中所有项目的问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dde9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="384d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当您处理小列表并且转换不超过两到三次时，集合可能就可以了。但是当你处理大型列表和复杂操作时，我建议使用序列。务实一点，选择适合自己的。</p><p id="e3c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>