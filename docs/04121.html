<html>
<head>
<title>How I Built a TypeScript-Coverage Report Tool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何构建一个类型覆盖报告工具</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-did-i-build-a-ts-coverage-report-tool-af34e110d02c?source=collection_archive---------18-----------------------#2020-03-24">https://betterprogramming.pub/how-did-i-build-a-ts-coverage-report-tool-af34e110d02c?source=collection_archive---------18-----------------------#2020-03-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9f70" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">冠状病毒隔离期间建立的包裹的故事</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/9c9bcaafe89ba14fe2dac6efb5dacfff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7NJIG6zxXEe4LxMOtPC6w.jpeg"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">由<a class="ae kw" href="https://unsplash.com/@freegraphictoday?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">absolute vision</a>在<a class="ae kw" href="https://unsplash.com/s/photos/announcement?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="2fb6" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">这个想法</h1><p id="66a6" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">在转换成TypeScript之前，我曾经在我的项目中有<a class="ae kw" href="https://flow.org/" rel="noopener ugc nofollow" target="_blank">流</a>。关于心流，我真正喜欢的是覆盖报告。</p><p id="31a7" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">有一个名为<a class="ae kw" href="https://github.com/rpl/flow-coverage-report" rel="noopener ugc nofollow" target="_blank"> flow-coverage-report </a>的包可以生成文本、JSON和HTML报告。</p><p id="6ba5" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">但是，(<a class="ae kw" href="https://github.com/alexcanessa/typescript-coverage-report" rel="noopener ugc nofollow" target="_blank"> <em class="mq">没有，</em>至少</a>)没有任何东西可供打字。</p><p id="87b6" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">社区建立的检查TS覆盖率的唯一工具是<a class="ae kw" href="https://github.com/plantain-00/type-coverage" rel="noopener ugc nofollow" target="_blank">类型-覆盖率</a>。这个包使用<code class="fe mr ms mt mu b">tsc</code>分析代码和覆盖率(有多少<code class="fe mr ms mt mu b">Anys</code>),并根据<code class="fe mr ms mt mu b">COVERAGE_PERCENTAGE &gt; THRESHOLD || 80</code>判断成功或失败。</p><p id="90db" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">在<code class="fe mr ms mt mu b">README.md</code>文件的结尾，有一个小小的惊喜:一个API部分。</p><pre class="kh ki kj kk gt mv mu mw mx aw my bi"><span id="6954" class="mz ky iq mu b gy na nb l nc nd">import { lint } from 'type-coverage-core'</span><span id="26c5" class="mz ky iq mu b gy ne nb l nc nd">const result = await lint('.', { strict: true })</span></pre><p id="8354" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">相当酷！所以我有一个鼓舞人心的工具(流量-覆盖-报告)和收集我需要的数据的方法。让我们把它们放在一起。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="6914" class="kx ky iq bd kz la nm lc ld le nn lg lh jw no jx lj jz np ka ll kc nq kd ln lo bi translated">路线图</h1><p id="7e08" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">作为一个受到Flow替代方案强烈启发的项目，我希望这个项目支持相同的特性:以HTML、JSON和text(终端上的一个表格)导出和呈现一个覆盖报告。</p><p id="fd8c" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">让我们从数据开始:<code class="fe mr ms mt mu b">type-coverage-core</code>(由<code class="fe mr ms mt mu b">type-coverage</code> monorepo导出)给了我们一个<code class="fe mr ms mt mu b">lint</code>函数，它返回这种类型的对象:</p><pre class="kh ki kj kk gt mv mu mw mx aw my bi"><span id="24e5" class="mz ky iq mu b gy na nb l nc nd">Promise&lt;{<br/>    correctCount: number;<br/>    totalCount: number;<br/>    anys: AnyInfo[];<br/>    program: ts.Program;<br/>    fileCounts: Map&lt;string, {<br/>       totalCount: number;<br/>       correctCount: number;<br/>    };<br/>}&gt;;</span></pre><p id="7449" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">所以我将简单地创建一个<code class="fe mr ms mt mu b">getCoverage</code>来收集信息并将其传递给一个报告文件。那很容易！</p><h2 id="99e2" class="mz ky iq bd kz nr ns dn ld nt nu dp lh ly nv nw lj mc nx ny ll mg nz oa ln ob bi translated">端子台</h2><p id="261e" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">现在，让我们通过创建第一个记者来形象化它。它必须是简单的，这样我就可以有一些内啡肽释放到我的身体里——就像终端视图中的文本表。</p><p id="b02e" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">我看到flow-coverage-report使用了一个叫做<code class="fe mr ms mt mu b"><a class="ae kw" href="https://github.com/zaftzaft/terminal-table" rel="noopener ugc nofollow" target="_blank">terminal-table</a></code>的模块。听起来很有希望。这是一个数组的数组，它不支持头，这有点糟糕，但不会有问题。此外，我希望同样的外观和感觉，你从流。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oc"><img src="../Images/8509f294cf6e758cd31a5c9214375c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nH2AJDlAnUrrTB8A7-ah6A.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">很酷，是吧？</p></figure><h2 id="123b" class="mz ky iq bd kz nr ns dn ld nt nu dp lh ly nv nw lj mc nx ny ll mg nz oa ln ob bi translated">好了，现在是HTML覆盖率报告</h2><p id="8eee" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">我需要在<code class="fe mr ms mt mu b">coverage-ts</code>文件夹下创建一个小型网站(就像伊斯坦布尔或流量覆盖报告的网站一样)。</p><p id="9e3b" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">在这一点上，我在代码中到处留下了<code class="fe mr ms mt mu b"><em class="mq">// TODO</em></code>注释，主要是针对我想在配置文件中抽象的东西。在配置文件中包含coverage文件夹输出路径目前并不重要。</p><p id="1955" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">我想使用<a class="ae kw" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>但是生成静态HTML文件。为此，我可以使用导出函数<code class="fe mr ms mt mu b"><a class="ae kw" href="https://reactjs.org/docs/react-dom-server.html#rendertostaticmarkup" rel="noopener ugc nofollow" target="_blank">renderToStaticMarkup</a></code>的<code class="fe mr ms mt mu b">react-dom/server</code>，但是JS和CSS都无法工作。</p><p id="7af7" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">我不打算从头开始构建一个表或任何组件，我喜欢<a class="ae kw" href="https://react.semantic-ui.com/" rel="noopener ugc nofollow" target="_blank">语义UI React </a>。等一下。流量覆盖报告使用的是同一个东西吗？我发誓这是偶然发生的，但如果这两个工具看起来非常相似，那就更好了，在我看来。</p><p id="de44" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">所以我有了数据，有了UI库，现在可以生成一个<code class="fe mr ms mt mu b">coverage-ts/index.html</code>文件。我们目前不需要任何客户端JS，我可以从语义UI CDN链接样式。</p><p id="496f" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">瞧，我们有相同的表格，但在网页上。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi od"><img src="../Images/1deda7264b52044db94c14dcec75a7da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tD_ymaBgaNo2wKW-PSCQug.png"/></div></div></figure><h2 id="8e4e" class="mz ky iq bd kz nr ns dn ld nt nu dp lh ly nv nw lj mc nx ny ll mg nz oa ln ob bi translated">现在，当我点击一个文件，我想去一个详细的页面，看看源代码和到底是什么没有涵盖</h2><p id="b98d" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">为了实现详细页面，我需要一个代码编辑器，支持:</p><ol class=""><li id="1a5b" class="oe of iq lr b ls ml lv mm ly og mc oh mg oi mk oj ok ol om bi translated">只读模式</li><li id="7030" class="oe of iq lr b ls on lv oo ly op mc oq mg or mk oj ok ol om bi translated">语法荧光笔</li><li id="f68a" class="oe of iq lr b ls on lv oo ly op mc oq mg or mk oj ok ol om bi translated">显示行号</li><li id="bab5" class="oe of iq lr b ls on lv oo ly op mc oq mg or mk oj ok ol om bi translated">允许注释特定的代码行</li><li id="6eeb" class="oe of iq lr b ls on lv oo ly op mc oq mg or mk oj ok ol om bi translated">突出显示行号</li></ol><p id="702f" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">我环顾四周，我把它归结为两个选项:<a class="ae kw" href="https://github.com/JedWatson/react-codemirror" rel="noopener ugc nofollow" target="_blank"> Codemirror </a>和<a class="ae kw" href="https://github.com/securingsincity/react-ace" rel="noopener ugc nofollow" target="_blank"> Ace </a>。我最初选择了后者，但是注释实现起来并不简单——所以我决定选择前者。</p><p id="474b" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">还有一个问题:由于我们正在创建静态HTML页面，我需要通过<code class="fe mr ms mt mu b">script</code>标签导入JavaScript，并且不能依赖React来处理任何非标记的内容。</p><p id="ddf4" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">此时，我不小心用生成的覆盖文件覆盖了所有的源文件，丢失了我所做的1/3(幸运的是我提交了我所做的2/3)。从我的错误中吸取教训:坚持不懈。</p><p id="9e34" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">为了包含Codemirror，我必须向页面添加一些资产(到目前为止有几个JS资产和一个CSS资产)——记住我只使用React生成静态标记。</p><p id="5285" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">现在，我必须注释源代码。我会分两步做:</p><p id="5559" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">1.使用<code class="fe mr ms mt mu b">DetailPage</code>组件创建一个带有注释的<code class="fe mr ms mt mu b">&lt;pre&gt;</code>元素(代码中的所有<code class="fe mr ms mt mu b">any</code>)。</p><pre class="kh ki kj kk gt mv mu mw mx aw my bi"><span id="34cf" class="mz ky iq mu b gy na nb l nc nd">// totalCount and correctCount will be needed later on.<br/>const DetailPage = ({<br/>  sourceCode,<br/>  totalCount,<br/>  correctCount,<br/>  annotations<br/>}: Props) =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;textarea id="editor" value={sourceCode} readOnly /&gt;<br/>      &lt;pre id="annotations" style={{ display: "none" }}&gt;<br/>        {JSON.stringify(annotations)}<br/>      &lt;/pre&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="4505" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">2.将这个脚本注入到单独的页面中，以获得注释并标记特定的字符。</p><pre class="kh ki kj kk gt mv mu mw mx aw my bi"><span id="4d76" class="mz ky iq mu b gy na nb l nc nd">const myTextArea = document.getElementById("editor");<br/>const codeMirrorInstance = CodeMirror.fromTextArea(myTextArea, {<br/>  readOnly: true,<br/>  lineNumbers: true,<br/>  mode: "text/typescript",<br/>  gutters: [<br/>    "CodeMirror-linenumbers"<br/>  ]<br/>});<br/>const annotations = JSON.parse(document.getElementById("annotations").textContent);<br/>console.log(annotations);<br/>annotations.forEach((annotation) =&gt; {<br/>  codeMirrorInstance.markText(<br/>    { line: annotation.line, ch: annotation.character },<br/>    { line: annotation.line, ch: annotation.character + annotation.text.length },<br/>    {<br/>      className: "uncovered",<br/>    }<br/>  );<br/>})</span></pre><p id="0ecb" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">如果我需要注释多行，这可能不起作用，但我现在不考虑这个。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi os"><img src="../Images/60c3788cee1ac993e3343f7399d5aeef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oiInWFSl75MrjDF_iWqoPQ.png"/></div></div></figure><p id="cc57" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">我们现在只需要稍微整理一下页面，并添加行栏上缺少的注释的数量。</p><p id="7d19" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">我为注释使用了循环，并创建了一个<code class="fe mr ms mt mu b">gutter</code>对象<code class="fe mr ms mt mu b">{ [line: string]: count: number }</code>，然后<code class="fe mr ms mt mu b">CM.setGutterMarker()</code>允许您在线条上注入它。</p><p id="536c" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">我基本上使用了来自flow-coverage-report的相同的风格(同样，我的目标是在两个覆盖工具之间使用相同的风格)。</p><pre class="kh ki kj kk gt mv mu mw mx aw my bi"><span id="23fa" class="mz ky iq mu b gy na nb l nc nd">Object.entries(gutters).forEach(([line, count]) =&gt; {<br/>  const gutterMarker = document.createElement("div");</span><span id="94ab" class="mz ky iq mu b gy ne nb l nc nd">gutterMarker.textContent = count + "x";<br/>  gutterMarker.style.textAlign = "center";<br/>  gutterMarker.style.fontSize = "0.6em";<br/>  gutterMarker.style.background = "rgba(255,0,0," + count * 0.2 + ")";<br/>  <br/>  codeMirrorInstance.setGutterMarker(+line, "TS-lineuncovered", gutterMarker);<br/>});</span></pre><p id="ae73" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">然后嘣！我们有我们的详细信息页面。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ot"><img src="../Images/9797c27ed6223052c5f61ed8d91d61a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MdePgLHZy-13zkQdFP4z6g.png"/></div></div></figure><p id="d6f9" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">这就是我们的摘要页面，已完成。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ou"><img src="../Images/9223f7a2d731a8a5fb64267c73bb5342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3UfYJWQlATcUBJbXyQmAw.png"/></div></div></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="cde1" class="kx ky iq bd kz la nm lc ld le nn lg lh jw no jx lj jz np ka ll kc nq kd ln lo bi translated">最后几件事</h1><h2 id="dd89" class="mz ky iq bd kz nr ns dn ld nt nu dp lh ly nv nw lj mc nx ny ll mg nz oa ln ob bi translated">资产文件夹</h2><p id="3154" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">现在一切都正常了，我有时间整理一下我留下的一些东西:首先，将页面JS和CSS移动到assets文件夹中。</p><p id="358e" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">我使用<a class="ae kw" href="https://github.com/AvianFlu/ncp" rel="noopener ugc nofollow" target="_blank"> ncp </a>将文件夹和文件(我刚刚从注入到单个页面中的内容中抽象出来的)复制到<code class="fe mr ms mt mu b">coverage-ts</code>文件夹中。然后，我必须为单个文件生成链接，并返回到<code class="fe mr ms mt mu b">coverage-ts/assets</code>文件夹。</p><h2 id="a19f" class="mz ky iq bd kz nr ns dn ld nt nu dp lh ly nv nw lj mc nx ny ll mg nz oa ln ob bi translated">选择</h2><p id="0cd6" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">我想给CLI增加一些选项，我已经知道我要用什么包了:<a class="ae kw" href="https://github.com/tj/commander.js/" rel="noopener ugc nofollow" target="_blank"> Commander.js </a>。我已经用过几次了，我真的很喜欢它的API和结果。</p><p id="c402" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">要设置选项，非常简单:</p><pre class="kh ki kj kk gt mv mu mw mx aw my bi"><span id="f164" class="mz ky iq mu b gy na nb l nc nd">#!/usr/bin/env node</span><span id="1b63" class="mz ky iq mu b gy ne nb l nc nd">import { program } from "commander";<br/>import { version, description } from "package.json";</span><span id="792d" class="mz ky iq mu b gy ne nb l nc nd">program<br/>  .version(version)<br/>  .description(description)<br/>  .option(<br/>    "-o, --outputDir [string]",<br/>    "The output directory where to generate the report.",<br/>    "coverage-ts"<br/>  ) // I also have other options here.<br/>  .parse(process.argv);</span></pre><p id="b485" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">当我运行代码时，<code class="fe mr ms mt mu b">program</code>的属性和我们传递的选项一样多。但是它不会自动与<code class="fe mr ms mt mu b">defaultValue</code>合并，所以我自己创建了自己的util函数来做这件事:</p><pre class="kh ki kj kk gt mv mu mw mx aw my bi"><span id="4c7b" class="mz ky iq mu b gy na nb l nc nd">const getOptionName = (option: CommandOption): string =&gt;<br/>  option.long.replace("--", "");</span><span id="9337" class="mz ky iq mu b gy ne nb l nc nd">const getOptions = (program: Command) =&gt; {<br/>  return (program.options)<br/>    .reduce((carry, option) =&gt; {<br/>      if (ignoredOptions.includes(getOptionName(option))) {<br/>         return carry;<br/>      }</span><span id="1b2a" class="mz ky iq mu b gy ne nb l nc nd">      return {<br/>        ...carry,<br/>        [getOptionName(option)]:<br/>          program[getOptionName(option)] || option.defaultValue<br/>      };<br/>    }, {});<br/>};</span></pre><h2 id="0b7e" class="mz ky iq bd kz nr ns dn ld nt nu dp lh ly nv nw lj mc nx ny ll mg nz oa ln ob bi translated">添加README.md文件</h2><p id="bc98" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">这是任何项目中最复杂的部分之一，它真的会让你思考你做了什么。</p><p id="c7fa" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">事实上，在我写的时候，我修改了一些在用法上没有意义的东西。</p><p id="3e97" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">为了给我的<code class="fe mr ms mt mu b">README.md</code>文件一点结构，我按照<a class="ae kw" href="https://github.com/RichardLitt/standard-readme/blob/master/spec.md" rel="noopener ugc nofollow" target="_blank">标准自述</a>中的说明进行了操作。</p><h2 id="8f3e" class="mz ky iq bd kz nr ns dn ld nt nu dp lh ly nv nw lj mc nx ny ll mg nz oa ln ob bi translated">添加测试</h2><p id="b16b" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">是的，我把它留在最后。<br/>这是我决定的筹码:</p><ol class=""><li id="75a9" class="oe of iq lr b ls ml lv mm ly og mc oh mg oi mk oj ok ol om bi translated">埃斯林特</li><li id="c94b" class="oe of iq lr b ls on lv oo ly op mc oq mg or mk oj ok ol om bi translated">较美丽</li><li id="482a" class="oe of iq lr b ls on lv oo ly op mc oq mg or mk oj ok ol om bi translated">笑话(+巴别塔)</li><li id="a54a" class="oe of iq lr b ls on lv oo ly op mc oq mg or mk oj ok ol om bi translated">皮棉阶段</li></ol><p id="efac" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">然后我用<a class="ae kw" href="https://github.com/typicode/husky" rel="noopener ugc nofollow" target="_blank"> Husky </a>在Git钩子上运行它们。</p><p id="f2b5" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">对于Jest，我必须调整一些东西，以便支持React代码和通用类型脚本。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="d731" class="kx ky iq bd kz la nm lc ld le nn lg lh jw no jx lj jz np ka ll kc nq kd ln lo bi translated">结论</h1><p id="f3a6" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">现在<a class="ae kw" href="https://github.com/alexcanessa/typescript-coverage-report" rel="noopener ugc nofollow" target="_blank">typescript-coverage-report</a>已经部署完毕，可以使用了！</p></div></div>    
</body>
</html>