<html>
<head>
<title>Floating Point Numbers Are Weird in Python — Here’s How To Fix Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浮点数在Python中很奇怪——以下是解决它们的方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/floating-point-numbers-are-weird-in-python-heres-how-to-fix-them-51336e4ad51a?source=collection_archive---------4-----------------------#2021-02-09">https://betterprogramming.pub/floating-point-numbers-are-weird-in-python-heres-how-to-fix-them-51336e4ad51a?source=collection_archive---------4-----------------------#2021-02-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3a0a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Python处理浮点运算</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4e1ee1a2fa1ff8ea0920dba2b7eb3d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*prM6OUzSmF2IZSzSyKm7HQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/numbers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@carlosirineu?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Carlos Irineu da Costa </a>拍摄的照片</p></figure><p id="8707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在处理浮点数时，你有没有遇到过奇怪的问题——例如，在做如下事情时？</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a802" class="ma mb it lw b gy mc md l me mf">a = 10</span><span id="c1f0" class="ma mb it lw b gy mg md l me mf">b = 0.1</span><span id="7220" class="ma mb it lw b gy mg md l me mf">c = 0.2</span><span id="e600" class="ma mb it lw b gy mg md l me mf">a*(b+c) == a*b + a*c # This will print False</span></pre><p id="0fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等，什么？如果我的数学课是正确的，这种比较应该是正确的。</p><p id="4a18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看另一个例子。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3ff1" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; .2 + .2 + .2 == .6</span><span id="3770" class="ma mb it lw b gy mg md l me mf">False</span></pre><p id="fa72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者看看这个循环——它将无限期运行。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1978" class="ma mb it lw b gy mc md l me mf">foo = 0</span><span id="f5e0" class="ma mb it lw b gy mg md l me mf">while foo != 1.0:</span><span id="1bb0" class="ma mb it lw b gy mg md l me mf">    foo = foo + 0.1</span><span id="8f40" class="ma mb it lw b gy mg md l me mf">print(foo)</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="3cf4" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">发生了什么事？</h1><p id="61c3" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><strong class="lb iu">TL；</strong> — <strong class="lb iu"> </strong>博士浮点数诡异！</p><p id="9158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">浮点数的行为不同于你在所有编程语言中习惯的行为，不仅仅是在Python中。这是因为一些十进制数在二进制系统中没有精确的表示。</p><p id="b0dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要理解为什么，我们先来看看计算机是如何表示分数的。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="3b3a" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">计算机如何处理浮点数？</h1><p id="b160" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">所有计算机都使用IEEE浮点运算标准来近似计算分数的值。</p><p id="2057" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分数在计算机上用二进制表示。例如，分数3/4 (0.75)的二进制表示是0.11。我们自己看看怎么算吧。</p><p id="14e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了得到十进制数的二进制表示，我们必须遵循以下步骤:</p><ol class=""><li id="ebca" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">将十进制数乘以2。</li><li id="3864" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">取出整数(进位)，将新分数乘以2。</li><li id="e504" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">重复这个过程，直到不再有小数值。</li><li id="fded" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">现在把你所有的进位放在一起。</li></ol><p id="a1da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例1 </strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9873" class="ma mb it lw b gy mc md l me mf">0.75 * 2 = 1.5 # Carry 1</span><span id="94ed" class="ma mb it lw b gy mg md l me mf">0.5 * 2 = 1 # Carry 1</span><span id="56e2" class="ma mb it lw b gy mg md l me mf">Binary representation: 0.11</span></pre><p id="524b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例2 </strong></p><p id="60ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们做一个更长的:0.8125</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c966" class="ma mb it lw b gy mc md l me mf">0.8125 * 2 = 1.625 # Carry 1</span><span id="8674" class="ma mb it lw b gy mg md l me mf">0.625 * 2 = 1.25 # Carry 1</span><span id="847a" class="ma mb it lw b gy mg md l me mf">0.25 * 2 = 0.5 # Carry 0</span><span id="d40c" class="ma mb it lw b gy mg md l me mf">0.5 * 2 = 1.0 # Carry 1</span><span id="6e71" class="ma mb it lw b gy mg md l me mf">Binary representation = 0.1101</span></pre><p id="aa34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们还没有真正看到这一切的问题是什么。为此，让我们看看十进制世界中类似的问题。当我们得到分数1/3时，我们可以把它表示为0.3，或者更准确地说是0.33，或者更准确地说是0.333333。你可以添加无限数量的3，1/3的表示每次都会更接近。</p><p id="2eff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于计算机，同样的情况也会发生。让我们按照之前的步骤，尝试用二进制表示十进制值0.8。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1359" class="ma mb it lw b gy mc md l me mf">0.8 * 2 = 1.6 # Carry 1</span><span id="dcd6" class="ma mb it lw b gy mg md l me mf">0.6 * 2 = 1.2 # Carry 1</span><span id="68bc" class="ma mb it lw b gy mg md l me mf">0.2 * 2 = 0.4 # Carry 0</span><span id="92f7" class="ma mb it lw b gy mg md l me mf">0.4 * 2 = 0.8 # Carry 0</span><span id="d544" class="ma mb it lw b gy mg md l me mf">0.8 * 2 = 1.6 # Carry 1  – Do you start to notice the problem?</span></pre><p id="8597" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们继续前进:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4bbe" class="ma mb it lw b gy mc md l me mf">0.6 * 2 = 1.2 # Carry 1</span><span id="a32c" class="ma mb it lw b gy mg md l me mf">0.2 * 2 = 0.4 # Carry 0</span><span id="1a97" class="ma mb it lw b gy mg md l me mf">0.4 * 2 = 0.8 # Carry 0</span><span id="ef0b" class="ma mb it lw b gy mg md l me mf">0.8 * 2 = 1.6 # Carry 1</span></pre><p id="151e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，停下来！</p><p id="f2c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，十进制数0.8实际上不能用二进制来表示。我们可以通过写出0.11001或者更好的0.110011001或者更好的0.1100110011001来近似它，并且我们可以不断增加无限数量的位来获得更精确的近似。</p><p id="ac51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们最初的一个例子:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9ecb" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; .2 + .2 + .2 == .6</span><span id="f6eb" class="ma mb it lw b gy mg md l me mf">False</span></pre><p id="4961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在明白为什么会这样了吗？计算机基本上是在做近似值的求和，正如我们之前看到的，0.2和0.6都不能在二进制世界中精确表示。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="8ffd" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">这些问题有解决方法吗？</h1><p id="3c79" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">有几种方法可以缓解这个问题。在Python中，您可以使用下面的包进行浮点数运算，</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a9a5" class="ma mb it lw b gy mc md l me mf">from fractions import Fraction</span></pre><p id="849e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以像下面这样做，而不必编写foo = 0.3。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d8e1" class="ma mb it lw b gy mc md l me mf">foo = Fraction(1, 3)</span></pre><p id="ea00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看我们的例子的变通办法。</p><p id="229d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第一个例子</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="574f" class="ma mb it lw b gy mc md l me mf">a = 10</span><span id="7c44" class="ma mb it lw b gy mg md l me mf">b = Fraction(1,10)</span><span id="c70b" class="ma mb it lw b gy mg md l me mf">c = Fraction(2,10)</span><span id="3e67" class="ma mb it lw b gy mg md l me mf">a*(b+c) == a*b + a*c # Prints True</span></pre><p id="d473" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第二个例子</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="cb46" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; Fraction(2,10) + Fraction(2,10) + Fraction(2,10) == Fraction(6,10)</span><span id="436a" class="ma mb it lw b gy mg md l me mf">True</span></pre><p id="43cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe ny nz oa lw b">for</code>循环，我们可以用两种不同的方法来解决它。最简单的方法是通过如下改变条件操作符。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="93c6" class="ma mb it lw b gy mc md l me mf">foo = 0</span><span id="ce57" class="ma mb it lw b gy mg md l me mf">while foo &lt;= 1:</span><span id="4a96" class="ma mb it lw b gy mg md l me mf">   foo = foo + 0.1</span><span id="14b5" class="ma mb it lw b gy mg md l me mf">print(foo) # 1.09999999999</span></pre><p id="2214" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个选择是再次使用<code class="fe ny nz oa lw b">fractions</code>包。举个例子，</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5946" class="ma mb it lw b gy mc md l me mf">foo = 0</span><span id="d226" class="ma mb it lw b gy mg md l me mf">while foo != Fraction(1,10):</span><span id="6e63" class="ma mb it lw b gy mg md l me mf">    foo = foo + Fraction(1,10)</span><span id="94ca" class="ma mb it lw b gy mg md l me mf">print(foo) # 1/10</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="1ee9" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="183e" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">浮点数在二进制系统中的行为非常奇怪。因此，了解这种行为很重要。我将帮助你避免容易被忽略的简单错误，比如无限循环或者仅仅是基本的比较。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="3ecb" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">进一步阅读</h1><ul class=""><li id="d940" class="nk nl it lb b lc nf lf ng li ob lm oc lq od lu oe nq nr ns bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/IEEE_754" rel="noopener ugc nofollow" target="_blank"> IEEE浮点运算标准(IEEE 754) </a></li><li id="84b4" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu oe nq nr ns bi translated"><a class="ae ky" href="https://www.geeksforgeeks.org/fraction-module-python/" rel="noopener ugc nofollow" target="_blank">Python中的分数模块</a></li><li id="fce0" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu oe nq nr ns bi translated"><a class="ae ky" href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="noopener ugc nofollow" target="_blank">浮点运算:问题与限制</a></li></ul></div></div>    
</body>
</html>