<html>
<head>
<title>How To Approach Concurrency in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在围棋中实现并发</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-approach-concurrency-in-go-b7ac7c171e37?source=collection_archive---------1-----------------------#2022-12-14">https://betterprogramming.pub/how-to-approach-concurrency-in-go-b7ac7c171e37?source=collection_archive---------1-----------------------#2022-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7acc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">并发永远是最好的选择吗？让我们找出答案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/45f82e9f0c6aa9cd36b40da1c953bfa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MNwSpex7GITrSLaTGtsDmQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gopherize.me/" rel="noopener ugc nofollow" target="_blank">https://gopherize.me/</a></p></figure><p id="2c17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文旨在展示根据程序的工作负载类型，何时使用并发更有益。</p><p id="d0e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我不会讨论流行的并发术语，比如goroutines、等待组、通道和数据竞争等等。我打算撰写一系列文章，详细解释最常用的并发构建块和怪癖的有用示例。</p><h1 id="ea19" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">如何解决问题？</h1><p id="1910" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我早期使用并发的时候，一个常见的错误是试图从一开始就使用并发来实现问题解决方案。这不仅使寻找最佳解决方案变得更加困难，而且存在使用并发性不适合该问题的风险。</p><p id="570c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我的经验，我建议您从获得一个可工作的顺序解决方案开始，然后迭代，如果必要的话，检查实现并发解决方案是否有意义。</p><p id="fd88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在考虑并发性之前，尝试用顺序解决方案来解决问题。</p><h1 id="ad53" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">并发性和并行性</h1><p id="236a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我不会详细解释什么是并发性和并行性，因为互联网上有许多解释得很好的文章。尽管如此，我还是要留下围棋创始人之一的几个定义:</p><blockquote class="ms mt mu"><p id="1b32" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">“并发是指同时处理许多事情。并行就是同时做很多事情。”—罗布·派克</p><p id="d0a1" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">“并发与结构有关，而并行与执行有关。换句话说，并发是一种构建事物的方式，以便您可以(可能)使用并行性来更好地完成工作。”—罗布·派克</p></blockquote><h1 id="684f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">工作量</h1><p id="f20e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">了解并发性是否合适的一个有用方法是了解您的程序的工作负载。分析并发性时，主要需要考虑两种类型的工作负载:</p><h2 id="ec8f" class="mz lw it bd lx na nb dn mb nc nd dp mf li ne nf mh lm ng nh mj lq ni nj ml nk bi translated"><strong class="ak"> CPU密集型工作负载</strong></h2><p id="6184" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">它们描述了程序的执行高度依赖CPU的情况；它直接关系到中央处理器的速度。</p><p id="bac5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们有一个以上的内核可用时，这些是利用并行性的完美工作负载(我们将在基准测试部分看到这并不总是正确的)。如果我们在具有多个go routine的单核中运行它，我们不会看到任何性能改进，因为go运行时将浪费宝贵的时间来调度go routine的进出，也称为上下文切换。</p><h2 id="ab70" class="mz lw it bd lx na nb dn mb nc nd dp mf li ne nf mh lm ng nh mj lq ni nj ml nk bi translated"><strong class="ak"> I/O相关的工作负载</strong></h2><p id="dc34" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">它们描述了程序的执行高度依赖于输入输出系统而不是CPU资源的情况。</p><p id="08a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦一个任务块通过了I/O，Go调度程序将恢复这些工作负载上的任何其他任务。因此，我们可以利用单个内核中的多个goroutines来提高性能。使用并行性不会提高性能。</p><p id="ec65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要小心，不要产生比可用内核更多的goroutines，以避免性能下降。</p><h1 id="88c5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我们来编码吧！</h1><p id="92f1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我将编写一些简单的函数，我们可以用它们来运行基准测试，以检查哪个性能更高，尝试利用并发性和并行性。</p><p id="57e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是使用的Golang函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e8d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是使用的基准测试函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基准测试的结果可能因运行的机器而异。您应该不止一次地进行基准测试，同时尽可能让您的机器空闲。</p><p id="9873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在运行基准测试时使用<code class="fe nn no np nq b">-count</code>标志来运行特定的次数；为了举例，我跳过了它。</p><p id="09c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在我的笔记本电脑上运行这些基准测试，总共有十个内核，所以使用Golang <code class="fe nn no np nq b">runtime.NumCPU()</code>的函数的并发版本将总共使用十个goroutines。</p><h1 id="75bf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基准测试:CPU工作负载</h1><p id="cac4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">以下是运行一个线程时，没有并行性的工作负载基准的情况:</p><pre class="kj kk kl km gt nr nq ns bn nt nu bi"><span id="63b6" class="nv lw it nq b be nw nx l ny nz">go test -cpu=1 -run=XXX -bench=. -benchtime=5s<br/>goos: darwin<br/>goarch: arm64<br/>pkg: concurrency-workloads<br/>BenchmarkComputeHighNumberSequentially      1869           3147006 ns/op<br/>BenchmarkComputeHighNumberConcurrently       632           9490364 ns/op</span></pre><p id="a3d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行顺序解决方案比运行并发解决方案快3倍。由于goroutines上下文切换造成的开销，这是可以预料的。</p><p id="2bfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个利用并行性并运行十个线程的工作负载基准测试示例:</p><pre class="kj kk kl km gt nr nq ns bn nt nu bi"><span id="0c7c" class="nv lw it nq b be nw nx l ny nz">go test -cpu=10 -run=XXX -bench=. -benchtime=5s<br/>goos: darwin<br/>goarch: arm64<br/>pkg: concurrency-workloads<br/>BenchmarkComputeHighNumberSequentially-10           1794           3145169 ns/op<br/>BenchmarkComputeHighNumberConcurrently-10           3162           1699410 ns/op</span></pre><p id="3138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在每个线程上分别运行10个go routine，我们可以观察到，由于10个go routine同时并行工作，因此并发解决方案比顺序解决方案快2倍。</p><p id="0844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管有这些结果，并不是所有的CPU工作负载都适合并发。接下来，我们将对合并排序算法进行基准测试来演示它:</p><pre class="kj kk kl km gt nr nq ns bn nt nu bi"><span id="2e1c" class="nv lw it nq b be nw nx l ny nz">go test -cpu=1 -run=XXX -bench=. -benchtime=5s<br/>goos: darwin<br/>goarch: arm64<br/>pkg: concurrency-workloads<br/>BenchmarkMergeSortSequentially   3908991              1530 ns/op<br/>BenchmarkMergeSortConcurrently    452580             12307 ns/op</span></pre><pre class="oa nr nq ns bn nt nu bi"><span id="8b27" class="nv lw it nq b be nw nx l ny nz">go test -cpu=10 -run=XXX -bench=. -benchtime=5s<br/>goos: darwin<br/>goarch: arm64<br/>pkg: concurrency-workloads<br/>BenchmarkMergeSortSequentially-10        4068475              1496 ns/op<br/>BenchmarkMergeSortConcurrently-10         533010             12462 ns/op</span></pre><p id="eae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺序解决方案如何可能比并行使用并发性更有效？让我们分析一下合并排序算法在做什么来理解前面的结果。</p><p id="948c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在每次迭代中生成几个goroutines来计算列表的第一个和第二个块。由于这是一个递归算法，我们将会在这样一种情况下结束，即我们将会生成goroutines，但只计算一个元素。这是非常低效的。我们现在的情况是，创建和安排一个goroutine比合并同一个goroutine中的单个项目更昂贵。</p><p id="3db8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们想要并行化的工作负载很小，以至于创建和调度一个goroutine的成本更高，那么并发和并行的优势就丧失了。</p><p id="c933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当分解工作或组合结果的成本非常高时，并发可能不是一个好的选择。</p><h1 id="5f52" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基准:I/O工作负载</h1><p id="ee50" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是一个没有并行性的工作负载，运行一个线程:</p><pre class="kj kk kl km gt nr nq ns bn nt nu bi"><span id="4a6e" class="nv lw it nq b be nw nx l ny nz">go test -cpu=1 -run=XXX -bench=. -benchtime=5s<br/>goos: darwin<br/>goarch: arm64<br/>pkg: concurrency-workloads<br/>BenchmarkComputeURLSequentially                2        2814863021 ns/op<br/>BenchmarkComputeURLConcurrently                7         838693786 ns/op</span></pre><p id="0539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行并发解决方案的速度提高了约4倍。这是意料之中的，因为I/O工作负载的go routine正在移入和移出等待状态，利用新的go routine来高效地使用同一个线程。</p><p id="5d86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用并行性的工作负载示例，运行10个线程:</p><pre class="kj kk kl km gt nr nq ns bn nt nu bi"><span id="4375" class="nv lw it nq b be nw nx l ny nz">go test -cpu=10 -run=XXX -bench=. -benchtime=5s<br/>goos: darwin<br/>goarch: arm64<br/>pkg: concurrency-workloads<br/>BenchmarkComputeURLSequentially-10             2        2548004562 ns/op<br/>BenchmarkComputeURLConcurrently-10             7        1001367625 ns/op</span></pre><p id="bd24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过用10个goroutines运行工作负载，每个goroutines都在一个单独的线程上，性能并没有提高。如前所述，这是因为我们可以在单线程中高效处理I/O工作负载的上下文切换，因此使用并行性并不会提高性能。</p><h1 id="6174" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="2806" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一般来说，我们可以得出结论，CPU受限的工作负载<strong class="lb iu"> </strong>非常适合利用并行性的并发性。而另一方面，I/O相关的工作负载并不适合并行。</p><p id="29d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，每个工作负载都需要仔细分析，因为我们观察到，由于其实现的性质，CPU绑定的合并排序算法不太适合并发和并行。</p><p id="7f39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我想提一下，增加并发性总是会带来额外的复杂性，所以要明智地使用它，并且只有当它增加性能改进时才使用它！</p><h1 id="b7a4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">资源</h1><ul class=""><li id="b0f7" class="ob oc it lb b lc mn lf mo li od lm oe lq of lu og oh oi oj bi translated"><a class="ae ky" href="https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html" rel="noopener ugc nofollow" target="_blank">阿登实验室并发系列</a></li></ul></div></div>    
</body>
</html>