<html>
<head>
<title>How to Broadcast Channels to Multiple Listeners in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Golang向多个听众广播频道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-broadcast-messages-in-go-using-channels-b68f42bdf32e?source=collection_archive---------0-----------------------#2022-07-27">https://betterprogramming.pub/how-to-broadcast-messages-in-go-using-channels-b68f42bdf32e?source=collection_archive---------0-----------------------#2022-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7bab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在GO中，一个通道不能同时向几个监听器发送数据。了解如何用可靠的模式实现这一点</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d0cdf4d4b57ebaf53d8eb21b3169c44c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sMRN3ip3PsN4o6iWZf_U7Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">保罗·艾纳汉德在<a class="ae ky" href="https://unsplash.com/photos/Dy6a8sLrVl4?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2ded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通道是Golang中并发编程的关键组件。它们提供了一种清晰的方式来在不同的围棋程序之间进行交流。</p><p id="02a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们的工作是同步和允许发送者和接收者之间的通信。一种常见的模式是使用它们在发送者和接收者之间执行一对一的通信。</p><p id="3eaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，我们可能希望将消息从一个通道传递给多个侦听器。这种行为通常被称为<strong class="lb iu">广播。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/33a5a10bfcef8ded10cbb5d1c515741a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t_0Vn1Q-h2uL8jDlnoH9ag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">广播示例。作者图片</p></figure><p id="bf26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，在Go中，同一数据只能从一个通道中读取一次。在这种特殊情况下，这种行为是一种限制。</p><p id="8714" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过下面的例子看到这一点，其中两个Go例程监听同一个通道:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="39e1" class="md me it lz b gy mf mg l mh mi">Listener 2: 1 <br/>Listener 1: 2</span></pre><p id="522a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于运行时调度程序的随机性，我们无法预测上面代码的准确输出，它可能会给出:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="aed3" class="md me it lz b gy mf mg l mh mi">Listener 2: 1 <br/>Listener 2: 2</span></pre><p id="8f87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中只有一个听众收到了消息。</p><h1 id="8570" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated"><strong class="ak">播音原理</strong></h1><p id="d920" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">因此，为了能够向多个侦听器发送相同的信息，我们有两个主要选项:</p><ul class=""><li id="ae48" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">多次向源通道写信，确保每个侦听器都收到了消息。</li><li id="92b7" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">只写入源通道一次，读取数据，然后复制数据，分别写入每个侦听器。</li></ul><p id="205f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们采用了第二种方案来实现频道广播。</p><h1 id="d2c2" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated"><strong class="ak">解决方案</strong></h1><p id="6758" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">为简单起见，我们将认为所有通道都是整数类型。我们可以从使用以下方法定义接口开始:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="1637" class="md me it lz b gy mf mg l mh mi">type BroadcastServer interface {<br/>  Subscribe() &lt;-chan int<br/>  CancelSubscription(&lt;-chan int)<br/>}</span></pre><ul class=""><li id="3372" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">第一种方法将负责创建订阅源的新频道。</li><li id="d070" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">第二个方法将处理取消由前一个方法打开的订阅。</li></ul><p id="8926" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建实现该接口的具体类型，并在工厂函数中实例化它(这意味着我们在内部创建结构，而不公开创建细节)。</p><p id="5c55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">混凝土类型<code class="fe nt nu nv lz b">broadcastServer</code>内部有四个通道:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="9649" class="md me it lz b gy mf mg l mh mi">type broadcastServer struct {<br/>  source &lt;-chan int<br/>  listeners []chan int<br/>  addListener chan chan int<br/>  removeListener chan (&lt;-chan int)<br/>}</span></pre><ul class=""><li id="c52a" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">来源:其他频道将要收听的数据源。</li><li id="a2bb" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">监听器:使用频道切片来接收广播消息</li><li id="0bc2" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe nt nu nv lz b">addListerner</code>:将用于向<code class="fe nt nu nv lz b">listeners</code>切片添加新通道的通道</li><li id="0bf2" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe nt nu nv lz b">removeListener</code>:将用于从<code class="fe nt nu nv lz b">listeners</code> <strong class="lb iu"> </strong>切片中移除项目的辅助通道。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="48a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv lz b">NewBroadcastServer</code>函数将负责创建广播服务器实例。它将处理适当取消的上下文和将要广播的源频道作为输入。</p><h1 id="678a" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated"><strong class="ak">发球方法</strong></h1><p id="7df4" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">与广播业务逻辑相关的所有细节都在<code class="fe nt nu nv lz b">serve</code>方法中运行。</p><p id="6c4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总共，它将负责处理四项任务:</p><ul class=""><li id="e1e1" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">添加新的侦听器</li><li id="5edf" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">移除监听器</li><li id="a1da" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">从源广播数据</li><li id="a181" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">适当的清理。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8c4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">for-select结构有四种情况:</p><ol class=""><li id="a7b3" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nw nl nm nn bi translated">等待上下文取消。</li><li id="44bf" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nw nl nm nn bi translated">通过将监听器追加到<code class="fe nt nu nv lz b">listeners</code>片来添加新的监听器</li><li id="96e9" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nw nl nm nn bi translated">删除侦听器。假设切片中的顺序不重要，我们用切片的最后一个元素替换要移除的侦听器。然后，最后一个元素也被删除。</li><li id="0b7a" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nw nl nm nn bi translated">处理广播逻辑。首先，它检查源代码是否仍然是开放的。然后，为了避免被未准备好接收的信道阻塞。我们还有另一个<code class="fe nt nu nv lz b">for-select</code>语句，它一直监听上下文取消。</li></ol><p id="fe35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，有一个函数使用一个<code class="fe nt nu nv lz b">defer</code>语句来执行清理任务，当我们不再需要运行广播服务时关闭所有的监听器。</p><h1 id="64dc" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated"><strong class="ak">工作示例</strong></h1><p id="82c6" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">让我们把它们放在一起，测试我们的广播服务器。</p><p id="9c38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为我们的数据源，我们将使用一个范围通道，它发送一个从0到值<strong class="lb iu"> n. </strong>的整数流</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="b4bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在主功能中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="9acd" class="md me it lz b gy mf mg l mh mi">Listener 1: 1/10 <br/>Listener 2: 1/10 <br/>Listener 1: 2/10 <br/>Listener 3: 1/10 <br/>Listener 3: 2/10 <br/>Listener 1: 3/10 <br/>...</span><span id="6dbf" class="md me it lz b gy nx mg l mh mi">Listener 1: 9/10 <br/>Listener 1: 10/10 <br/>Listener 2: 9/10 <br/>Listener 2: 10/10 <br/>Listener 3: 10/10</span></pre><p id="dc7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，每个侦听器都会收到一个从0到9的整数流(上面显示了1到10，因为我们正在打印<strong class="lb iu"> i+1 </strong>)</p><p id="070b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就在最后的<code class="fe nt nu nv lz b">wg.Wait()</code>之前，我们可以从切片中移除一个监听器，并看到它将不再接收广播消息:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="c6ec" class="md me it lz b gy mf mg l mh mi">broadcaster.CancelSubscription(listener1)</span></pre><p id="ca4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="b08a" class="md me it lz b gy mf mg l mh mi">Listener 3: 1/10 <br/>Listener 3: 2/10 <br/>Listener 2: 1/10 <br/>Listener 2: 2/10 <br/>Listener 2: 3/10 <br/>Listener 3: 3/10 <br/>Listener 3: 4/10 <br/>Listener 2: 4/10 <br/>Listener 2: 5/10 <br/>Listener 3: 5/10 <br/>Listener 3: 6/10 <br/>Listener 3: 7/10 <br/>Listener 2: 6/10 <br/>Listener 2: 7/10 <br/>Listener 3: 8/10 <br/>Listener 3: 9/10 <br/>Listener 2: 8/10 <br/>Listener 2: 9/10 <br/>Listener 2: 10/10 <br/>Listener 3: 10/10</span></pre><p id="2d37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个侦听器不再接收任何数据，因为它已从广播服务器中删除并关闭。</p><h1 id="84cb" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated"><strong class="ak">结论和关键要点</strong></h1><p id="1f56" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">以下是本文总结的要点:</p><ul class=""><li id="79d7" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">在Golang中，我们只能从一个频道读取一次相同的数据，默认情况下，它不会广播消息。</li><li id="5262" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">广播<strong class="lb iu"> </strong>服务器作为客户端-服务器通信的本地版本工作，它处理不同的请求，例如:从收听者切片中添加或删除频道。</li><li id="5a81" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">这种行为是通过使用一个带有正常关闭选项的<code class="fe nt nu nv lz b">for-select</code>结构实现的，允许我们在不再需要广播的情况下关闭侦听器。</li><li id="6947" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">这种模式只通过两种方法公开一个公共接口:<code class="fe nt nu nv lz b">Subscribe</code>和<code class="fe nt nu nv lz b">CancelSubscription</code> <strong class="lb iu">。</strong>我们可以创建不同的广播公司来处理其他类型的商业逻辑。</li></ul></div></div>    
</body>
</html>