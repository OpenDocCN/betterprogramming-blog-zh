<html>
<head>
<title>Understanding the Basic MLOps Principle for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解数据科学家的基本MLOps原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-the-basic-mlops-principle-for-data-scientists-256b8e5f83b1?source=collection_archive---------0-----------------------#2022-12-25">https://betterprogramming.pub/understanding-the-basic-mlops-principle-for-data-scientists-256b8e5f83b1?source=collection_archive---------0-----------------------#2022-12-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4a6a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">帮助您将更强大的模型投入生产的介绍性指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5af7a9b696b982e0dfa3660619b71f6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M_OilC54-XOXy8Yy0y_uTA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自维基媒体</p></figure><p id="689c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你是一名数据科学家或者一名有抱负的数据科学家，你可能听说过大多数ML模型都无法进入生产阶段(<a class="ae kv" href="https://venturebeat.com/2019/07/19/why-do-87-of-data-science-projects-never-make-it-into-production/" rel="noopener ugc nofollow" target="_blank"> Venture beat文章</a>)。这是有原因的，但人们可以认为当前的数据科学学习路径侧重于构建ML模型和改进指标。虽然这些事情很重要，但将您的模型投入生产是数据科学家如何影响公司的。在这里，我介绍了MLOps最基本的原理，这样您就可以帮助您的公司将一个更强大的模型投入生产。</p><h1 id="7183" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">MLOps到底是什么？</h1><p id="3eb1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在DevOps在IT行业取得巨大成功之后，其他领域也已经将这些“操作”纳入了日常工作中。但是MLOps到底是什么？根据维基百科:</p><blockquote class="mp mq mr"><p id="82a9" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">“MLOps或ML Ops是一套实践，旨在可靠有效地在生产中部署和维护机器学习模型。”</p></blockquote><p id="e2ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，在一个公司内部，MLOps是实验、开发和编码实践的标准化，它将帮助您更快、更可靠、更简单地将ML模型投入生产。</p><p id="7e5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它包括开发模型，将其投入生产，监控它，并在需要时触发再培训。这可能非常复杂，并不是所有的公司都解决了这个问题。但作为一名数据科学家，你可能会问自己:我该如何开始？毕竟，你是这个过程中至关重要的一部分。</p><h1 id="b842" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基本原则</h1><p id="eaca" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如前所述，可靠性是MLOps的核心。这意味着您在Jupyter或Python环境中本地运行的所有代码必须在生产环境中产生相同的结果。有随机种子就不难解决了。您可以在整个代码中使用相同的种子，这样就没问题了。但是当涉及到环境配置和依赖性时，事情就变得有点困难了。</p><p id="5fce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再现性是这个词。如何确保您的代码可以在不同的机器上重现？</p><h1 id="3d90" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">码头工人来救援了</h1><p id="b9eb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Docker是一个开源平台，它使得创建和管理孤立的系统变得更加简单明了。你可以说它有点像虚拟机，但事实并非如此。您可以使用Docker将您的模型转换成一个“包”为了让事情更清楚，让我们直接进入代码。作为一个指导项目，我们将使用泰坦尼克号数据集。假设您希望使用Docker映像将您的模型准备好投入生产。我们将致力于REST API，它可以用于无数其他问题。<br/>完整的代码可以在我创建的这个<a class="ae kv" href="https://github.com/danielKatagiri/basic-mlops" rel="noopener ugc nofollow" target="_blank"> repo </a>中找到，虽然我将在这里对代码进行评论，但完整的工作代码只能在存储库中找到。一定要去看看。</p><h1 id="0d4c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.项目要求</h1><p id="58a3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要在您的本地环境中复制这个项目，您必须安装Python(我使用的是python 3.8)和Docker引擎。如果你没有Docker，可以查看文档看看怎么做:<br/><a class="ae kv" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/install/</a>。</p><p id="67fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装Docker后，为我们的项目创建一个新文件夹，并使用以下内容创建一个新的虚拟环境:</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="bddb" class="nb lt iq mx b be nc nd l ne nf">python3 -m venv .env<br/>source .env/bin/activate</span></pre><h1 id="518b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.开发模型</h1><p id="c69c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">由于这里的重点是使用Docker而不是建模，我们将使用一个简单的梯度推进分类器，它具有我们所拥有的数字特征。如果克隆存储库，请使用以下命令安装依赖项:</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="5ef1" class="nb lt iq mx b be nc nd l ne nf">pip install -r requirements</span></pre><p id="13f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并使用以下命令运行培训脚本:</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="f891" class="nb lt iq mx b be nc nd l ne nf">python -m train_titanic</span></pre><p id="8a9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有一个模型工件可以在我们的API中使用。</p><h1 id="7325" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.创建预测器类</h1><p id="a0bd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">下一步是创建一个模块来预测给定的乘客是否会幸存。这个模块叫做<code class="fe ng nh ni mx b">titanic_model</code>。它有一个主类来处理与模式相关的一切，包括以下内容:</p><ul class=""><li id="5271" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated">加载要使用的模型和定标器</li><li id="d3f3" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">创建预测管道，包括根据训练中使用的缩放器和预测本身来缩放要素</li></ul><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="128f" class="nb lt iq mx b be nc nd l ne nf">class TitanicModel:<br/>    def __init__(self):<br/>        self.model = self._load_artifact(filename="titanic_classifier")<br/><br/>    @staticmethod<br/>    def _load_artifact(<br/>        filename: str,<br/>    ) -&gt; Union[pd.DataFrame, GradientBoostingClassifier, StandardScaler]:<br/>       ...<br/><br/>    def predict(<br/>        self, pclass: int, sex: str, age: Union[float, int], fare: Union[float, int]<br/>    ) -&gt; bool:<br/>        predictions = self.model.predict([[<br/>          pclass, encoded_sex, scaled_age, scaled_fare<br/>        ]]).tolist()<br/>        return bool(predictions[0])</span></pre><h1 id="3b3e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">打包代码</h1><p id="2af9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在我们有了包含模型的Python代码，我们可以打包我们的模型了。这是再现性的第一步。在这一步之后，可以pip安装我们的代码，模块<code class="fe ng nh ni mx b">titanic_model</code>将在Python控制台中可用。</p><p id="eb64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们必须在项目的根目录下创建一个<code class="fe ng nh ni mx b">setup.py</code>，其中包含安装代码的指令。</p><p id="2775" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从<code class="fe ng nh ni mx b">setuptools</code>开始，我们导入<code class="fe ng nh ni mx b">setup</code>函数，并将一些信息(包括在哪里寻找Python代码)传递给这个函数。看起来是这样的:</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="64fa" class="nb lt iq mx b be nc nd l ne nf">from setuptools import find_packages, setup<br/><br/>setup(<br/>   name="titanic",<br/>   version="0.1",<br/>   url="https://github.com/danielKatagiri/basic-mlops",<br/>   description="Package to create a predictor for the Titanic dataset",<br/>   packages=find_packages(exclude=["train*"]),<br/>   install_requires=install_requires<br/>)</span></pre><p id="c937" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可以通过在新的虚拟环境中安装软件包来测试一切是否正常(这样当前的环境就不会变脏)。下面是实现这一点的代码:</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="dfc5" class="nb lt iq mx b be nc nd l ne nf">deactivate<br/>python3 -m venv .env2<br/>source .env2/bin/activate<br/>python3 -m pip install .<br/>python3 -m pip freeze | grep titanic</span></pre><p id="0ab6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一切正常，您应该在输出中看到包<code class="fe ng nh ni mx b">titanic==0.1</code>。现在，您可以放弃这个新创建的虚拟环境，并激活旧的虚拟环境，如下所示:</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="05f7" class="nb lt iq mx b be nc nd l ne nf">deativate<br/>rm -rf .env2/<br/>source .env/bin/activate</span></pre><h1 id="f807" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">用FastAPI创建REST API</h1><p id="9b16" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在我们有了一个处理预测的类，并且我们的python代码是pip可安装的，我们可以创建一个FastAPI应用程序，将我们的模型封装在一个<code class="fe ng nh ni mx b">app.py</code>文件中。这是REST API，这意味着我们的模型现在可以接收带有特性的HTTP请求，并用预测来响应它们。</p><p id="de8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ng nh ni mx b">app.py</code>文件使用Pydantic创建了一个<code class="fe ng nh ni mx b">Passenger</code>模型。这是FastAPI验证HTTP请求发送的输入所必需的。然后，该脚本创建一个带有预测路由的<code class="fe ng nh ni mx b">FastAPI</code>实例，该实例将接收一个<code class="fe ng nh ni mx b">GET</code>请求。</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="e1fb" class="nb lt iq mx b be nc nd l ne nf">class Passenger(BaseModel):<br/>    pclass: int<br/>    sex: str<br/>    age: Union[float, int]<br/>    fare: Union[float, int]<br/><br/><br/>def create_app():<br/>    application = FastAPI()<br/>    model = TitanicModel()<br/><br/>    @application.get("/predict")<br/>    async def predict(<br/>        pclass: int, sex: str, age: Union[float, int], fare: Union[float, int]<br/>    ):<br/>        return model.predict(pclass=pclass, sex=sex, age=age, fare=fare)<br/><br/>    return application<br/><br/><br/>if __name__ == "__main__":<br/>    app = create_app()<br/>    uvicorn.run(app, host="0.0.0.0", port=8080)</span></pre><p id="46f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在API的代码已经完成，您可以通过在您的终端中运行<code class="fe ng nh ni mx b">python app.py</code>来测试它。</p><h1 id="a8bc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">创建Docker图像</h1><p id="70cc" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在我们节目的最后一幕，我们将为Docker引擎编写一些代码来构建我们的应用程序，并将其编译为Docker图像。由于这可能是你第一次看“Docker”代码，我将对它进行更彻底的评论。</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="2fa8" class="nb lt iq mx b be nc nd l nx nf"># First, we choose the base image. Theses base images can be found at<br/># https://hub.docker.com/. As our code is running in python, we can choose<br/># the python image as our base image<br/>FROM python:3.8-slim-buster<br/><br/># In the TitanicModel class, you can check the `_load_artifact` method.<br/># It tries to find the artifacts used by the model in a specific folder<br/># determined by the enviroment variable `ARTIFACTS_HOME`. So here we are<br/># setting this environment variable to be in /home/artifacts<br/>ENV ARTIFACTS_HOME='/home/artifacts/'<br/><br/># This folder does not exists yet, so this next command creates the path<br/># for us<br/>RUN mkdir -p $ARTIFACTS_HOME<br/><br/># Now we will copy our local created artifacts to this folder within our image<br/># In this example, we are copying from the local file system, but idealy these<br/># artifacts will be stored in a Model Registry (MLFlow, Google storage, <br/># VertexAI, S3, ...)<br/>COPY ./artifacts/* $ARTIFACTS_HOME<br/><br/># This next line copies the files from our project into the /package folder<br/># and sets this new folder as working directory. It would be as if the docker<br/># engine running this piece of code did a `cd package` when running.<br/>COPY . /package<br/>WORKDIR /package<br/><br/># We are now going to upgrade our pip and install the package, as we did before<br/># in the virtual environment. After installing, we delete this `package` folder<br/>RUN pip3 install --upgrade pip<br/>RUN pip install . &amp;&amp; rm -rf /package<br/><br/># Now we set our working directory to be a `app` folder and copy the `app.py`<br/># file into it, so that our FastAPI application is available in the image<br/>WORKDIR /app<br/>COPY app.py .<br/><br/># Now that everythin is set up, we can call the command to run the FastAPI<br/># application<br/>CMD ["python", "app.py"]</span></pre><p id="2c4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了测试一切是否正常，您可以通过运行<code class="fe ng nh ni mx b">docker build -t titanic</code>来构建映像。这个命令告诉Docker构建一个映像。<code class="fe ng nh ni mx b">-t titanic</code>标记这个新图像，<code class="fe ng nh ni mx b">.</code>参数告诉Docker在当前文件夹中构建它。</p><p id="fa85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果映像构建成功，您可以通过运行<code class="fe ng nh ni mx b">docker run --rm -it -p 8080:8080</code>来运行它。现在您可以在浏览器中访问<code class="fe ng nh ni mx b">localhost:8080/docs</code>来查看由FastAPI swagger生成的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/256d8fc30be38c7cc43badb73cee30a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yzd2MqK6r6WTdhuWmecMJA.png"/></div></div></figure><p id="9f57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用curl发出请求，请运行:</p><pre class="kg kh ki kj gt mw mx my bn mz na bi"><span id="6ef3" class="nb lt iq mx b be nc nd l ne nf">curl -X GET “http://localhost:8080/predict?pclass=3&amp;sex=male&amp;age=22&amp;fare=7.25"</span></pre><p id="9b7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并且它应该返回<code class="fe ng nh ni mx b">false</code>。</p><h1 id="6516" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最后的想法</h1><p id="43f3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果您可以复制到目前为止的步骤，您就有了一个定制的docker映像，它封装了您的REST API和一个在幕后工作的ML模型。现在，负责部署您的模型的团队将只需要担心创建一个虚拟机或一个K8s部署，在其中运行您的映像(以及其他一些东西，但不封装您的模型)。</p><p id="4c85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以为其他类型的问题复制这些原则，例如批量预测。</p><p id="9f67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读，如果您对此有任何想法，请告诉我。</p></div></div>    
</body>
</html>