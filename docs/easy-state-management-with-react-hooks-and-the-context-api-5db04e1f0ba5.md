# 使用 React 钩子和上下文 API 进行简单的状态管理

> 原文：<https://betterprogramming.pub/easy-state-management-with-react-hooks-and-the-context-api-5db04e1f0ba5>

## 使用上下文跨组件共享状态

![](img/8f5f03fa28134d42e94dd9254a832c31.png)

照片由 [NASA](https://unsplash.com/@nasa?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

对于 React 开发人员来说，状态管理似乎是一项艰巨的任务。在过去，维护在组件树的不同部分共享的状态是极其复杂的，我们通常求助于第三方状态管理库来帮助我们。但是我们是时候更新思维了！

React 中的状态管理很容易，因为我们有了钩子和上下文 API。让我们看看如何在整个应用程序中管理一个状态，只使用我们已经在使用的工具和 React 内置的工具！

# 调整我们的思维

当面临管理 React 应用程序中的状态的挑战时，一些开发人员可能会很快转向像 Redux 这样的状态管理库来解决我们所有的问题。但是，如果我们仔细思考我们需要做什么，我们可能会意识到，我们正在考虑的国家根本不需要全球化。

例如，假设我们正在构建一个通知组件。该组件需要知道来自我们后端的提醒和任务，并使它们在侧抽屉中可供用户阅读和标记为已查看。

## 选项 1——将事情复杂化

如果我们处于 Redux 状态，我们可能会很快认为我们需要实现一个非常复杂的 thunk 动作，该动作发出一个 GET 请求并向我们的 reducer 分派一个动作，reducer 将通知添加到我们的数据存储中，然后通过将状态映射到我们的 notifications drawer 组件中的 props 来访问该数据存储。

当用户将通知标记为已读时，将触发另一个 dispatch thunk 操作，该操作将 POST 请求发送到后端，一旦成功，将调度另一个操作，从我们的数据存储中删除该特定项目…t *这太复杂了！！*

## 选项 2——让你的生活更轻松

当我们仔细和创造性地思考这个问题时，我们可能会意识到这根本没有必要成为一个全球性的国家。通知组件实际上是唯一需要了解这些数据的组件。

事实上，它可能根本不需要存储在*状态*中！如果我们使用一个简单的、定制的钩子来负责获取和返回通知，以及发送`markAsRead`请求，会怎么样？所有复杂的状态管理代码都可以被清除，从组件中抽象出来，在组件中只用一行代码就可以使用！

(关于如何使用这种技术的更全面的解释，请查看使用 React-Query 的[异步状态管理](/asynchronous-state-management-with-react-query-a9937457ed5e)

通过调整我们的思维，我们最终得到了一个非常干净的组件`<NotificationsDrawer />`和一个定制的钩子，它比一个成熟的状态管理系统的实现更具可读性。如果我们需要改变获取的方式/内容，维护起来也会容易得多。

也就是说，有时我们需要在组件树的不同部分共享状态，而上述技术是行不通的。当我们希望用户能够控制选择/使用什么数据时尤其如此，而不仅仅是需要从我们的后端访问响应。这就是上下文 API 的闪光点！

# 使用上下文跨组件共享状态

React 的上下文 API 为我们提供了一种方式来访问组件树深处的状态，而不需要沿途将道具传递给每个组件(称为“道具钻取”)。

这个 API 将涵盖几乎所有需要管理整个应用程序共享的简单状态的情况。实现这项技术将需要我们构建两个相关的部分——一个*提供者*和一个*钩子*，用于从提供者访问状态。

对于这个例子，让我们假设我们有一个棒球统计应用程序。用户可以在顶部菜单栏中选择一个团队，应用程序的每个页面现在都使用特定于该团队的数据。

例如，用户在显示当前名单的页面上，从顶部菜单栏选择波士顿红袜队。他们现在看到了红袜队的最新名单。当他们导航到显示当前击球统计数据的页面时，我们希望他们看到红袜队的统计数据，而不是一些默认的球队，这将迫使用户不得不在每个页面上重新选择他们的球队(不是很好的 UX！).

如果没有上下文 API，这个简单的需求实现起来会非常复杂。我们要么需要通过遍布组件树的道具来传递团队(“道具训练”)，要么我们不得不放弃使用笨重的第三方状态管理库(讨厌！).

如果我们使用上下文，这就是我们实现这个特性的样子…

这处理一切！上下文中到底存储了什么？我们有`allTeams`，它是从后端返回的所有团队对象的数组。这可以用来创建一个选择组件的选项，我们将把它放在顶部的菜单栏中，供用户更改所选的团队。

我们还有`team`，它将被用作用户当前选择的*团队，以及当用户改变他的选择时我们可以调用的`setTeam`(这将在团队选择组件的`onChange`中被调用)。*

## 使用钩子

现在，我们该怎么办？存储在上下文中的所有这些数据都可以通过使用我们在文件底部导出的`useTeamContext`钩子来获得。我们实际上如何使用那个钩子呢？这里有一个示例选择组件，允许用户选择将在整个应用程序中使用的团队…

没有调度，没有选择器，什么都没有！只是一个干净简单的钩子，给我们提供了我们需要的数据，以及在应用程序中改变选择的功能。

虽然我们构建的钩子是我们最常使用的，但是提供者也同样重要！

## 提供商呢？

我们只能在`Provider`的后代组件中使用我们的`useTeamContext`钩子。这是我们的`<TeamsProvider />`组件拿`children`当道具的时候！

如果我们希望在整个应用程序中使用上下文挂钩，我们应该把`TeamsProvider`组件放在组件树的很高的位置。事实上，在`<App />`组件中看到提供者是很常见的，因为这实际上意味着您的整个应用程序将可以访问它所提供的相同上下文。

# 结论

在许多情况下，我们可以通过调整我们的思维，真正评估什么需要访问有状态数据/如何访问它，来避开第三方状态管理库的陷阱和复杂性。

很多时候我们可以实现一个非常简单的钩子来满足我们的需求。有时我们可能*实际上*需要某种方式在组件树中不同部分的组件间共享状态。

在那些情况下，React 内置的上下文 API 超级有帮助！熟悉这个 API 可以帮助您编写干净、可维护、可读的代码。你的团队和你未来的自己会感谢你的！