<html>
<head>
<title>Building a To-Do List App with SwiftUI, Combine, and Firebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI、Combine和Firebase构建待办事项应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/replicating-the-ios-reminders-app-part1-44211a7b7029?source=collection_archive---------1-----------------------#2020-01-27">https://betterprogramming.pub/replicating-the-ios-reminders-app-part1-44211a7b7029?source=collection_archive---------1-----------------------#2020-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="fa49" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">功能反应式编程</h2><div class=""/><div class=""><h2 id="2579" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">复制iOS提醒应用程序，第1部分</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/2ee9f44e99b517b3cb79a9027f988ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AnmMGh5fPOJHWxzO9wLGPA.png"/></div></div></figure><p id="c91e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在WWDC 2019上，苹果公司宣布了其声明式UI框架SwiftUI。到目前为止，你们中的大多数人可能已经花时间体验了SwiftUI，并了解了它的一般工作原理。</p><p id="1772" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在这个系列中，我想改变一下思路，看看我们在使用SwiftUI和其他一些技术编写真实的iOS应用程序方面能走多远。</p><p id="56f5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了更容易看出SwiftUI的优势(和不足)，让我们复制一个大家都知道的应用程序:iOS提醒应用程序。</p><p id="5b32" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在，如果你和我一样，你可能很少使用提醒应用程序，而是使用App Store中流行的待办事项应用程序。</p><p id="91a2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我惊喜地发现，iOS提醒应用程序已经赶上了竞争对手，并成为一个功能更加完整和强大的生产力应用程序。</p><p id="5db6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了简单起见，我们将把重点放在核心功能上，并将在以后的文章中逐渐添加更多的特性。</p><p id="dcec" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因为还有很多内容要介绍，所以我决定将这个项目分成一系列文章，这些文章互为基础。下面是我们将要构建的内容的快速概述:</p><ul class=""><li id="c9a1" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">在本系列的第1部分(您现在正在阅读的部分)中，我们将关注使用SwiftUI构建UI，使用一个简单的数据模型。</li><li id="c0c6" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">在第2部分中，我们将把应用程序连接到<a class="ae mn" href="https://firebase.google.com/" rel="noopener ugc nofollow" target="_blank"> Firebase </a>，并将用户的任务与<a class="ae mn" href="https://firebase.google.com/docs/firestore" rel="noopener ugc nofollow" target="_blank">云Firestore </a>同步。</li><li id="c0ef" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">在第3部分中，我们将实现与Apple的登录，将应用程序变成一个真正的多用户应用程序。</li></ul><p id="d215" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你觉得不错，那我们就开始吧！</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="0f84" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">入门指南</h1><p id="0cf1" class="pw-post-body-paragraph ld le it lf b lg nn kd li lj no kg ll lm np lo lp lq nq ls lt lu nr lw lx ly im bi translated">应用程序的源代码可以在这个GitHub库中找到，应用程序的各个阶段都有相应的标签。</p><p id="3c07" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果您想继续，请随意查看存储库——我会指出我们在哪个分支/标签，这样您就可以将您的实现与我的进行比较。</p><p id="a8c0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">首先，克隆<a class="ae mn" href="https://github.com/peterfriese/MakeItSo" rel="noopener ugc nofollow" target="_blank">库</a>，并查看签出的文件夹:</p><ul class=""><li id="d82a" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated"><code class="fe ns nt nu nv b">starter</code>文件夹包含一个已经清理了一点的单视图应用程序，以及一个好看的应用程序图标。</li><li id="3b4c" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><code class="fe ns nt nu nv b">final</code>文件夹包含项目的完成版本，以及所有中间步骤。</li></ul><p id="74d7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">您可以在起始文件夹中编写自己的实现，或者在最终文件夹中检查各个检查点。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="5f96" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">数据模型</h1><p id="b8ad" class="pw-post-body-paragraph ld le it lf b lg nn kd li lj no kg ll lm np lo lp lq nq ls lt lu nr lw lx ly im bi translated">如果你正在跟进，检查标签<code class="fe ns nt nu nv b"><a class="ae mn" href="https://github.com/peterfriese/MakeItSo/tree/stage_1/data_model/start" rel="noopener ugc nofollow" target="_blank">stage_1/data-model/start</a></code>并打开<code class="fe ns nt nu nv b">final</code>文件夹中的<code class="fe ns nt nu nv b">MakeItSo.xcodeproj</code>。</p><p id="41ac" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如上所述，我们将特意实现简化版的iOS提醒应用程序，以便能够更好地关注核心概念。例如，我们的实现将只支持一个任务列表(iOS提醒应用程序支持多个列表并在它们之间导航)。</p><p id="612d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，我们的数据模型非常简单:</p><p id="f0f5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">每个任务都有:</p><ul class=""><li id="6a82" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">标题(即指示用户需要做什么)。</li><li id="f341" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">优先级(高、中、低)。</li><li id="8f92" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">指示任务是否完成的标志。</li></ul><p id="b3bf" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">以下是我们的数据模型的代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="cd70" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">有几点需要注意:</p><ul class=""><li id="347d" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">我们制作了<code class="fe ns nt nu nv b">Task</code>结构<code class="fe ns nt nu nv b">Identifiable</code>，还添加了一个<code class="fe ns nt nu nv b">id</code>属性。这是必要的，因为我们将在SwiftUI <code class="fe ns nt nu nv b">List</code>中显示任务，这要求它的项目是<code class="fe ns nt nu nv b">Identifiable</code>。使用<code class="fe ns nt nu nv b">UUID</code>确保每个任务将获得一个唯一的标识符。</li><li id="c579" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">我们用测试数据定义了一个集合，我们可以用它来驱动UI的开发，直到我们真正连接到一个数据源。</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="b995" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">构建任务列表视图</h1><p id="e546" class="pw-post-body-paragraph ld le it lf b lg nn kd li lj no kg ll lm np lo lp lq nq ls lt lu nr lw lx ly im bi translated">如果您正在跟进，检查标签<code class="fe ns nt nu nv b"><a class="ae mn" href="https://github.com/peterfriese/MakeItSo/tree/stage_1/build_task_list/start" rel="noopener ugc nofollow" target="_blank">stage_1/build_task_list/start</a></code>并打开<code class="fe ns nt nu nv b">final</code>文件夹中的<code class="fe ns nt nu nv b">MakeItSo.xcodeproj</code>。</p><p id="be1a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在我们开始自己构建任务列表视图之前，让我们来看看iOS提醒应用程序。查看主列表视图界面，我们可以看到三个主要的UI元素:</p><ol class=""><li id="962a" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly ny mf mg mh bi translated">列表标题(本例中为“任务”)。</li><li id="be40" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly ny mf mg mh bi translated">列表视图。</li><li id="7e6a" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly ny mf mg mh bi translated">添加新任务的按钮。</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nz"><img src="../Images/a88d0ed0d07cd739d60bd02c5903dedf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xEvS3QnMb_eq44v2wH-pxg.png"/></div></div><p class="oa ob gj gh gi oc od bd b be z dk translated">原始iOS提醒应用程序的用户界面元素</p></figure><p id="6998" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">您还可以通过点击最后一个项目下方的空白区域来添加新项目，这将向列表视图添加一个新的空行，光标在文本字段中等待您，准备接收您的新任务。</p><p id="0cc5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">同样的在线编辑UX也可以用来修改条目:点击一个任务，开始输入进行修改。这个UX模式非常简洁，因为它允许用户在列表中的其他项目的上下文中看到他们当前正在编辑的项目:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oe"><img src="../Images/f7c0bd9e01b6df440b619042a132c86c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_1IX2lS6P_jhfO5GSMt89A.png"/></div></div><p class="oa ob gj gh gi oc od bd b be z dk translated">编辑模式下的iOS提醒应用程序</p></figure><p id="3bee" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">用SwiftUI重新创建这个布局或多或少很简单——让我们看看它是如何完成的:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="e31c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">您会注意到，我们正在使用数据模型中的测试任务(1 ),由于Xcode的预览画布，我们在构建数据模型时可以在UI中看到一些数据。</p><p id="c5bd" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们看看代码的几个有趣的方面:</p><ul class=""><li id="bb83" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">整个视图被包装在一个<code class="fe ns nt nu nv b">NavigationView</code> (2)中，这让我们可以使用<code class="fe ns nt nu nv b">.navigationBarTitle()</code>设置视图标题。</li><li id="c9d9" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">我们没有用<code class="fe ns nt nu nv b">List(self.tasks)</code>遍历我们的任务集合，而是使用了嵌套的<code class="fe ns nt nu nv b">ForEach</code> (3)，原因是<code class="fe ns nt nu nv b">.onDelete()</code>只在<code class="fe ns nt nu nv b">ForEach</code>可用。</li><li id="9477" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">说到这里，<code class="fe ns nt nu nv b">onDelete()</code> (4)启用列表上的<em class="of">删除模式</em>，让用户在单元格上向左滑动以显示删除操作。不幸的是，SwiftUI(还)不支持任何其他上下文动作。我的猜测是，苹果想用一些额外的时间来完善DSL，为列表添加上下文动作。</li><li id="4654" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">每个任务的单元格已经被提取到一个单独的视图中，<code class="fe ns nt nu nv b">TaskCell</code> (5)，这使得调用点(6)更加清晰。</li><li id="58f1" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">用于添加新任务的按钮(7)由两个子视图组成:加号图像(8)和文本“新任务”(9)。这是SwiftUI如何推广可组合UI的一个很好的例子。</li><li id="af41" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">为了确保复选框(即<a class="ae mn" href="https://developer.apple.com/design/human-interface-guidelines/sf-symbols/" rel="noopener ugc nofollow" target="_blank"> SF符号</a>图标)和加号提供足够大的触摸目标，我们将图标的大小调整为20 x 20像素(11)和(12)。</li><li id="517e" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">最后，我们添加一些填充，并用强调色将按钮染成红色(13)。使用系统颜色确保这在亮暗模式下都很棒(阅读<a class="ae mn" href="https://developer.apple.com/documentation/xcode/supporting_dark_mode_in_your_interface" rel="noopener ugc nofollow" target="_blank">这篇文章</a>了解更多关于如何在你的应用中实现暗模式的背景)。我想不出一种方法来给导航条标题上色——如果你知道如何做到这一点，请在回购上提交一个pull请求！</li></ul><p id="576e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">至此，我们已经有了UI的基本版本。</p><p id="21d9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">和往常一样，你可以在模拟器或物理设备上运行应用程序，以查看它的运行情况，但由于SwiftUI的预览，我们不需要这样做！</p><p id="1935" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">事实上，由于我们的测试数据和Xcode的SwiftUI预览画布(这相当拗口)，我能够在构建UI时享受预览:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/37280fbb6f5861b94fb8af74f435cbcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7NXVo-fvcWAJgheYq0RTg.png"/></div></div><p class="oa ob gj gh gi oc od bd b be z dk translated">Xcode预览画布中完成的用户界面</p></figure><p id="d65c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">要快速打开预览窗格，请按下<code class="fe ns nt nu nv b">⌥ + ⌘ + ↩</code>。如果预览显示“自动预览更新暂停”，按<code class="fe ns nt nu nv b">⌥ + ⌘ + P</code>恢复。更多Xcode快捷键，参见<a class="ae mn" href="https://peterfriese.dev/xcode-shortcuts/" rel="noopener ugc nofollow" target="_blank"> <em class="of">更高效编码的基本Xcode快捷键</em> </a>。</p><p id="de6c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当运行该应用程序(或使用实时预览)时，您会注意到它的功能还不是很好——例如，当您试图添加一个新任务时，什么都不会发生，甚至点击其中一个复选框也不会将该任务标记为已完成。</p><p id="615d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">所以，现在让我们改变这种情况，实现我们应用程序的业务逻辑！</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="20e3" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">应用架构</h1><p id="cc66" class="pw-post-body-paragraph ld le it lf b lg nn kd li lj no kg ll lm np lo lp lq nq ls lt lu nr lw lx ly im bi translated">在我们继续深入之前，让我们花点时间考虑一下我们的应用程序的架构。虽然当然可以构建包含业务逻辑的SwiftUI视图，但是这种方法很容易导致代码不仅难以阅读，而且几乎不可测试。</p><p id="5de4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">幸运的是，SwiftUI的声明性本质使其适合于功能性反应方法，这种方法由MVVM(模型、视图、视图模型)架构支持，将产生易于阅读、可测试性好的代码。</p><p id="be65" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了更好地概述SwiftUI的不同架构模式，包括对MVVM的深入讨论，请查看<a class="ae mn" href="https://quickbirdstudios.com/blog/swiftui-architecture-redux-mvvm/" rel="noopener ugc nofollow" target="_blank"> <em class="of"> SwiftUI架构:模型视图、Redux和MVVM </em> </a>。</p><p id="cb35" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">除了我们的应用程序的视图和模型之外，我们还需要一些视图模型和存储库:</p><ul class=""><li id="b752" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">视图负责显示数据和处理用户交互。</li><li id="81b2" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">视图模型负责向视图提供数据，并将用户交互转化为对数据存储库的更新请求。</li><li id="ce81" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">模型保存应用程序操作的数据。它们在视图模型和存储库之间来回传递。</li><li id="47e8" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">存储库提供了数据层的抽象，使得将本地存储替换为基于云的存储变得容易。</li></ul><p id="be2d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">从下图中可以看出上述所有因素之间的关系:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/351a029e7818c09c79816f52b6b97b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKLGDke3OHcgaTryRq8z7Q.png"/></div></div><p class="oa ob gj gh gi oc od bd b be z dk translated">SwiftUI的MVVM(模型、视图、视图模型)架构</p></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="13c5" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">实现视图模型</h1><p id="2f2e" class="pw-post-body-paragraph ld le it lf b lg nn kd li lj no kg ll lm np lo lp lq nq ls lt lu nr lw lx ly im bi translated">如果你正在跟随，检查标签<code class="fe ns nt nu nv b"><a class="ae mn" href="https://github.com/peterfriese/MakeItSo/tree/stage_2/implement_view_models/start" rel="noopener ugc nofollow" target="_blank">stage_2/implement_view_models/start</a></code>并打开<code class="fe ns nt nu nv b">final</code>文件夹中的<code class="fe ns nt nu nv b">MakeItSo.xcodeproj</code>。</p><p id="5e4c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">MVVM呼吁在视图和视图模型之间建立1:1的关系:每个视图都有一个视图模型，所有的UI元素都绑定到这个模型，这个模型将处理在这个特定屏幕上发生的任何用户交互。</p><p id="01b9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当我告诉您我们将需要为我们的应用程序实现两个不同的视图模型时，一开始可能会有点惊讶:<code class="fe ns nt nu nv b">TaskListViewModel</code>和<code class="fe ns nt nu nv b">TaskCellViewModel</code>。</p><p id="ef41" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这是因为列表视图中的每一行都是各自底层模型元素的编辑器视图。因此，<code class="fe ns nt nu nv b">TaskListViewModel</code>是列表本身的视图模型，而<code class="fe ns nt nu nv b">TaskCellViewModel</code>是单个列表视图行(或者说，单元格)的视图模型。</p><p id="e973" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">所有的空谈都是廉价的，我们来看一些代码吧！</p><p id="bab2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这里是<code class="fe ns nt nu nv b">TaskListViewModel</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="608e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这里是<code class="fe ns nt nu nv b">TaskCellViewModel</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="7473" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">一些注意事项:</p><ul class=""><li id="d22b" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">两个视图模型都实现了<code class="fe ns nt nu nv b">ObservableObject</code> (1)，因此我们可以将它们绑定到SwiftUI元素，并确保UI对视图模型的任何更改做出反应。这就是SwiftUI的超能力:无需手动将您的UI与底层数据模型同步。我不能夸大这方面的重要性。</li><li id="a877" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">在后面的步骤中，我们将连接到本地存储(然后，连接到Firestore)，但是目前，我们将使用在<code class="fe ns nt nu nv b">testDataTasks</code> (2)中定义的测试数据。使用<code class="fe ns nt nu nv b">map()</code>方法，我们将这个集合中的<code class="fe ns nt nu nv b">Task</code>模型转换成<code class="fe ns nt nu nv b">TaskCellViewModel</code> s。包含这些转换后的视图模型的数组<code class="fe ns nt nu nv b">taskCellViewModels</code> (3)被注释为<code class="fe ns nt nu nv b">@Published</code>，这允许我们将<code class="fe ns nt nu nv b">TaskListView</code>上的<code class="fe ns nt nu nv b">List</code>绑定到它。</li><li id="0a85" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">为了进一步帮助将UI从底层模型中分离出来，我们还添加了两种添加和删除任务的方法— <code class="fe ns nt nu nv b">addTask</code> (5)和<code class="fe ns nt nu nv b">removeTask</code> (4)。</li><li id="a3b3" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><code class="fe ns nt nu nv b">TaskListView</code>中的单个行由<code class="fe ns nt nu nv b">TaskCellViewModels</code>支持。由于SwiftUI要求<code class="fe ns nt nu nv b">List</code>视图中的项目是<code class="fe ns nt nu nv b">Identifiable</code>，我们必须实现这个协议(6)并提供一个<code class="fe ns nt nu nv b">id</code>属性。每当<code class="fe ns nt nu nv b">task</code>属性改变时，<code class="fe ns nt nu nv b">id</code>属性的值将被更新。为了实现这一点，我们将<code class="fe ns nt nu nv b">task</code>属性标注为<code class="fe ns nt nu nv b">@Published</code>，并在构造函数中订阅它(7)。</li><li id="10f7" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">类似地，我们通过订阅<code class="fe ns nt nu nv b">task</code>属性并将其<code class="fe ns nt nu nv b">completed</code>属性映射到相应的图像名称(8)来更新代表任务完成状态的图标的名称。</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="176c" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">绑定视图模型</h1><p id="9a37" class="pw-post-body-paragraph ld le it lf b lg nn kd li lj no kg ll lm np lo lp lq nq ls lt lu nr lw lx ly im bi translated">现在，我们已经准备好将视图模型绑定到我们的UI，并连接任何UI操作，例如删除或添加新项目，以及在编辑单元格或点击行的复选框时更新底层任务。</p><p id="37d4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们先来看看<code class="fe ns nt nu nv b">TaskCell</code>更新后的实现，以了解需要更改的内容:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0762" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">有很多变化，所以让我们一次看一个:</p><ul class=""><li id="0803" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">我们将<code class="fe ns nt nu nv b">TaskCell</code>的所有子视图绑定到一个<code class="fe ns nt nu nv b">TaskCellViewModel</code>，这并不奇怪，因此我们将<code class="fe ns nt nu nv b">task</code>属性重构为<code class="fe ns nt nu nv b">taskCellVM</code>。</li><li id="4663" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">我们没有用业务逻辑来计算视图状态，而是将视图属性绑定到各自的视图模型属性。例如，我们从<code class="fe ns nt nu nv b">taskCellVM.completionStateIconName</code> (2)中获取已完成状态图像的图标名称。</li><li id="09af" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">也许最大的变化是我们将一直用来显示任务标题的<code class="fe ns nt nu nv b">Text</code>视图换成了<code class="fe ns nt nu nv b">TextField</code> (3)。这允许用户通过点击单元格并开始键入来编辑任务标题，这非常方便。</li></ul><p id="95a7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在处理用户交互方面，有几个明显的变化，但也有一些需要更多的解释。让我们从一个简单的开始:</p><p id="c2ea" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如前所述，用户可以通过点击相应的<code class="fe ns nt nu nv b">TextField</code>并开始输入来编辑任务标题。这些更改将反映在本地视图模型(<code class="fe ns nt nu nv b">taskCellVM</code>)和包含父视图的视图模型中的数组中。</p><p id="0483" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">那么在<code class="fe ns nt nu nv b">TextField</code>上实现<code class="fe ns nt nu nv b">onCommit</code> (4)的原因是什么，为什么我们要将它转发给我们自己的<code class="fe ns nt nu nv b">onCommit</code>处理程序(5)？</p><p id="7f56" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">要回答这个问题，我们先来看看<code class="fe ns nt nu nv b">TaskListView</code>的更新实现:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="ffc4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我提醒你注意这个类中的两个位置:首先，我们使用<code class="fe ns nt nu nv b">TaskCell</code>在<code class="fe ns nt nu nv b">List</code>视图(1)中呈现一个普通单元格的地方。这里没有什么特别的，我们只是在这里使用一个普通的<code class="fe ns nt nu nv b">TaskCell</code>。</p><p id="ad2e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然而，再往下一点(2)，一大堆事情正在发生:</p><ul class=""><li id="7df9" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">最突出的是，单元格现在有一个接收<code class="fe ns nt nu nv b">Result</code>的尾随闭包。</li><li id="9dc4" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">如果结果是一个<code class="fe ns nt nu nv b">success</code>，我们从结果中提取一个<code class="fe ns nt nu nv b">Task</code>，以便添加一个新的<code class="fe ns nt nu nv b">TaskCellViewModel</code> (3)到包含所有任务单元视图模型的视图模型中。</li><li id="6de8" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">其他任何情况都会被默默忽略。如果你回到<code class="fe ns nt nu nv b">TaskCell</code>的实现，你会看到唯一的另一种情况是<code class="fe ns nt nu nv b">empty</code>，如果用户没有输入任何文本，我们将发送它。</li><li id="54f5" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">最后，我们切换<code class="fe ns nt nu nv b">presentAddNewItem</code> (4)。这是一个标志，用来保护整个块的可见性，当用户点击“新任务”按钮时，这个标志就会被切换。</li></ul><p id="df43" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果您仔细观察，您会注意到整个块都被包裹在<code class="fe ns nt nu nv b">List</code>中，这意味着每当用户点击“新任务”按钮时，我们都会在列表的末尾添加一个新的空单元格。这是用户可以用来添加新任务的单元格。</p><p id="7313" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">回到为什么我们需要<code class="fe ns nt nu nv b">onCommit</code>回调的问题:这是必需的，因为我们只想在用户点击键盘上的回车键时添加一个新的<code class="fe ns nt nu nv b">Task</code>。</p><p id="6193" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最后，你会看到我们创建了一个<code class="fe ns nt nu nv b">TaskListViewModel</code> (7)，注释为<code class="fe ns nt nu nv b">@ObservedObject</code>，允许我们将<code class="fe ns nt nu nv b">List</code>视图绑定到它的<code class="fe ns nt nu nv b">taskCellViewModels</code>属性(8)。</p><p id="6d9f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你现在运行这个应用程序，你会注意到UI大部分是功能性的:你可以添加新任务，修改现有任务，并将任务标记为已完成。</p><p id="35a2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是，您的更改不会持久化:每次重新启动应用程序时，您都会回到硬编码的演示数据。</p><p id="923f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了解决这个问题，我们需要实现一个持久层(我们从用户界面到磁盘……)。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="6033" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">将任务保存在存储库中</h1><p id="df6c" class="pw-post-body-paragraph ld le it lf b lg nn kd li lj no kg ll lm np lo lp lq nq ls lt lu nr lw lx ly im bi translated">如果你正在跟随，检查标签<code class="fe ns nt nu nv b"><a class="ae mn" href="https://github.com/peterfriese/MakeItSo/tree/stage_2/implement_repository/start" rel="noopener ugc nofollow" target="_blank">stage_2/implement_repository/start</a></code>并打开<code class="fe ns nt nu nv b">final</code>文件夹中的<code class="fe ns nt nu nv b">MakeItSo.xcodeproj</code>。</p><p id="b85b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了在应用启动时保持用户的任务，我们将实现一个<em class="of">存储库</em>。存储库充当持久层的抽象——这将使我们更容易选择不同的技术来存储数据。</p><p id="d877" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">例如，我们将首先在磁盘上存储用户的数据，然后实现一个连接到Firebase的存储库，让我们在Cloud Firestore中存储数据。</p><p id="68d6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">作为中间步骤，我们将实现一个<code class="fe ns nt nu nv b">TestDataTaskRepository</code>，从我们的测试数据数组中检索数据(并写回其中)。</p><p id="21dc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在这个过程中，我们将研究依赖注入，以及它如何帮助我们编写更加灵活和可维护的代码。</p><p id="968c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">事不宜迟，下面是<code class="fe ns nt nu nv b">TestDataTaskRepository</code>的代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="d6b9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如您所见，<code class="fe ns nt nu nv b">TaskRepository</code>协议定义了一些添加、删除和更新任务的方法。任务本身保存在一个数组<code class="fe ns nt nu nv b">Tasks</code>中，这个数组是<code class="fe ns nt nu nv b">@Published</code>，所以我们的客户可以很容易地订阅任何更新。</p><p id="f94c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在初始化器中，我们获取实际的测试数据。显然，我们对任务数组所做的任何更改都不会在任何地方持久化。</p><p id="3f7d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了改变这一点，我们将提供一个能够读写磁盘的<code class="fe ns nt nu nv b">TaskRepository</code>实现。</p><p id="61c9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是在我们这样做之前，我们需要谈谈依赖注入。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="148e" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">依赖注入</h1><p id="4eb6" class="pw-post-body-paragraph ld le it lf b lg nn kd li lj no kg ll lm np lo lp lq nq ls lt lu nr lw lx ly im bi translated">将架构图与我们目前得到的代码进行比较，很明显我们需要从两个视图模型中访问<code class="fe ns nt nu nv b">TaskRepository</code>。</p><p id="a19f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这说起来容易做起来难，因为存储库是有状态的:它保存了我们的任务集合。如果我们在每个视图中创建一个任务存储库的实例，我们很快就会失去同步。</p><p id="cee0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">解决这种情况的一种方法是使存储库成为单例。关于单例已经说了很多，也写了很多，虽然使用单例没有错(苹果也这样做)，但我想在这里采取不同的方法，使用依赖注入，因为它会给我们带来一些好处。</p><p id="e560" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">Swift最优雅和轻量级的依赖注入框架之一是由Michael Long开发的<a class="ae mn" href="https://github.com/hmlongco/Resolver" rel="noopener ugc nofollow" target="_blank">Resolver</a>，所以让我们将它添加到我们的项目中吧！</p><p id="20a5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">您可以使用<a class="ae mn" href="https://swift.org/package-manager/" rel="noopener ugc nofollow" target="_blank"> Swift包管理器</a>、<a class="ae mn" href="https://github.com/Carthage/Carthage" rel="noopener ugc nofollow" target="_blank"> Carthage </a>或<a class="ae mn" href="https://cocoapods.org/" rel="noopener ugc nofollow" target="_blank"> CocoaPods </a>来完成这项工作。</p><p id="5cee" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">由于我们需要在稍后阶段将Firebase添加到我们的项目中，所以让我们选择CocoaPods(在撰写本文时，Firebase仅支持CocoaPods和Carthage，并支持正在进行的SPM<a class="ae mn" href="https://github.com/firebase/firebase-ios-sdk/issues/3136" rel="noopener ugc nofollow" target="_blank"/>)。</p><p id="d5f6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">使用Resolver很简单，只需要对我们的项目做三处修改:</p><p id="74c2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">首先，我们必须使用CocoaPods将它添加到项目中:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0248" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果您正在跟进，不要忘记在您的项目文件夹中运行<code class="fe ns nt nu nv b">pod install</code>来安装Resolver。</p><p id="ac45" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在CocoaPods安装完Resolver及其依赖项之后，关闭Xcode中的项目，打开CocoaPods为您创建的工作区。</p><p id="07e6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">专业提示:在项目文件夹中运行<code class="fe ns nt nu nv b">xed .</code>——这将打开项目或工作空间(取决于哪个存在)。</p><p id="85e5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">接下来，我们需要在其他地方注册我们想要注入的任何类。为了做到这一点，Resolver提供了一个方便的扩展，我们可以挂接:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="94a8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这段代码本质上说:“创建一个<code class="fe ns nt nu nv b">TastDataTaskRepository</code>的实例，并在任何需要<code class="fe ns nt nu nv b">Taskrepository</code>实例的地方注入它。”</p><p id="8743" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最后，我们的视图模型需要更新。让我们看看<code class="fe ns nt nu nv b">TaskViewModel</code>来了解变化:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0d52" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如您所见，我们通过调用<code class="fe ns nt nu nv b">Resolver.resolve()</code>请求Resolver为<code class="fe ns nt nu nv b">TaskRepository</code>提供一个实现，之后我们就可以像使用常规属性一样使用<code class="fe ns nt nu nv b">taskRepository</code>属性。</p><p id="34f0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">有了这些，在我们的应用程序中使用不同的<code class="fe ns nt nu nv b">TaskRepository</code>实现现在只需要将注册从<code class="fe ns nt nu nv b">register { TestDataTaskRepository() as TaskRepository }.scope(application)</code>更改为<code class="fe ns nt nu nv b">register { SomeOtherTaskRepository() as TaskRepository }.scope(application)</code>。</p><p id="ef3f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">就这么简单——不需要接触任何其他代码！</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="3661" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">坚持是有回报的</h1><p id="be5e" class="pw-post-body-paragraph ld le it lf b lg nn kd li lj no kg ll lm np lo lp lq nq ls lt lu nr lw lx ly im bi translated">如果您正在跟进，请检查标签<code class="fe ns nt nu nv b"><a class="ae mn" href="https://github.com/peterfriese/MakeItSo/tree/stage_2/implement_disk_repository/start/final/MakeItSo" rel="noopener ugc nofollow" target="_blank">stage_2/implement_disk_repository/start</a></code>并打开<code class="fe ns nt nu nv b">final</code>文件夹中的<code class="fe ns nt nu nv b">MakeItSo.xcworkspace</code>。</p><p id="05b7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最后，让我们构建一个在磁盘上持久化任务的<code class="fe ns nt nu nv b">TaskRepository</code>实现。</p><p id="e5fa" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了帮助保持我们的代码尽可能的干净，我决定使用<a class="ae mn" href="https://github.com/saoudrizwan/Disk" rel="noopener ugc nofollow" target="_blank"> Disk </a>，这是一个很好的小框架，它抽象了对iOS文件系统的访问。它支持<code class="fe ns nt nu nv b">Codable</code>，所以读写磁盘只需要一行代码。</p><p id="f3f6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你自己看看:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="e94b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">到现在为止，这些代码的大部分你应该已经很熟悉了，唯一的区别是对<code class="fe ns nt nu nv b">saveData()</code>和<code class="fe ns nt nu nv b">loadData()</code>的一些调用。</p><p id="29e7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">从磁盘中读取一组<code class="fe ns nt nu nv b">Codable</code>对象是与磁盘的一行代码:<code class="fe ns nt nu nv b">try? Disk.retrieve("tasks.json", from: .documents, as: [Task].self)</code>。</p><p id="bd42" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">存储数据也不会复杂多少:<code class="fe ns nt nu nv b">try Disk.save(self.tasks, to: .documents, as: "tasks.json")</code>。</p><p id="d070" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">值得注意的是，我们必须稍微更新一下<code class="fe ns nt nu nv b">TaskListViewModel</code>中的代码，以反映这样一个事实，即当对存储库进行更改时，我们的视图模型会自动更新:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="dc6b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，我们不需要从存储库中删除一个任务，然后再从本地<code class="fe ns nt nu nv b">taskCellViewModels</code>集合中删除它，我们只需要从存储库中删除它。这将触发我们在初始化器(2)中设置的订阅者，它将适时地将输入模型转换成视图模型。</p><p id="7dc2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这同样适用于添加新任务:只要将它们添加到存储库中，订阅者就会自动更新视图模型的本地集合。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="bfb6" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">终点线</h1><p id="f8ea" class="pw-post-body-paragraph ld le it lf b lg nn kd li lj no kg ll lm np lo lp lq nq ls lt lu nr lw lx ly im bi translated">如果您正在跟进，检查标签<code class="fe ns nt nu nv b"><a class="ae mn" href="https://github.com/peterfriese/MakeItSo/tree/stage_2/finish_line/final/MakeItSo" rel="noopener ugc nofollow" target="_blank">stage_2/finish_line</a></code>并打开<code class="fe ns nt nu nv b">final</code>文件夹中的<code class="fe ns nt nu nv b">MakeItSo.xcworkspace</code>。</p><p id="0e70" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在是运行应用程序并享受我们辛勤工作的成果的时候了(实际上并没有那么难，不是吗)。继续点击<em class="of">运行</em>按钮，在你的模拟器或手机上启动应用程序，并添加一些任务！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/7a7b60fd123eb9c60dcdc979e81c5bcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nQZV1O0Q1iU5eFpg3xdl5A.gif"/></div></div><p class="oa ob gj gh gi oc od bd b be z dk translated">运行中的最终应用</p></figure><p id="9f18" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">用很少的代码，我们就能够构建一个功能齐全的任务列表应用程序。在本系列的下一部分中，我们将研究如何将应用程序连接到Firebase，以便在云Firestore中保存数据。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="fa1a" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">家庭作业</h1><p id="ac99" class="pw-post-body-paragraph ld le it lf b lg nn kd li lj no kg ll lm np lo lp lq nq ls lt lu nr lw lx ly im bi translated">在等待本系列的下一篇文章时，作为一个小小的挑战，为什么不尝试实现对任务优先级的支持呢？</p><p id="5a26" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">iOS提醒应用程序会在任务标题的左侧显示感叹号，以指示任务的优先级。</p><p id="ffe6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">更改任务优先级不太容易发现:您需要点击任务的信息图标来打开其详细信息屏幕，向下滚动一点，然后从选择器中选择所需的任务优先级。</p><p id="3106" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">随意实现这种行为，或者想出自己的解决方案。</p><p id="97aa" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果您想展示您的实现，请执行以下操作:</p><ol class=""><li id="9beb" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly ny mf mg mh bi translated">分叉<a class="ae mn" href="https://github.com/peterfriese/MakeItSo/" rel="noopener ugc nofollow" target="_blank">仓库</a>。</li><li id="1b22" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly ny mf mg mh bi translated">查看<a class="ae mn" href="https://github.com/peterfriese/MakeItSo/tree/stage_2/finish_line" rel="noopener ugc nofollow" target="_blank">阶段2终点线标签</a>。</li><li id="2318" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly ny mf mg mh bi translated">实施您的解决方案。</li><li id="ef1c" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly ny mf mg mh bi translated">发个PR。</li><li id="16e9" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly ny mf mg mh bi translated">(可选)在推特上发布一个你公关的链接，作为对<a class="ae mn" href="https://twitter.com/peterfriese/status/1221715939651092487?s=20" rel="noopener ugc nofollow" target="_blank">这条推特</a>的回复。</li></ol><p id="a933" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后，我会浏览解决方案，并转发最有创意的解决方案。</p><p id="e587" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">感谢您的阅读，祝您在完成作业挑战的过程中愉快！</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="27fa" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">资源</h1><div class="oj ok gp gr ol om"><a href="https://github.com/peterfriese/MakeItSo" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd jd gy z fp or fr fs os fu fw jc bi translated">彼得·弗里斯/马凯索</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">这是Make It So的源代码，它是我的博客文章“复制iOS提醒应用程序…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">github.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa lb om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://developer.apple.com/documentation/xcode/supporting_dark_mode_in_your_interface" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd jd gy z fp or fr fs os fu fw jc bi translated">在你的界面中支持黑暗模式</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">在macOS和iOS中，用户可以选择采用全系统的浅色或深色外观。黑暗的外表，被称为黑暗…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">developer.apple.com</p></div></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://medium.com/better-programming/modern-dependency-injection-in-swift-952286b308be" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd jd gy z fp or fr fs os fu fw jc bi translated">Swift中的现代依赖注入</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">在iOS应用程序中充分利用依赖注入系统的技巧、技术和策略</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.com</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa lb om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://quickbirdstudios.com/blog/swiftui-architecture-redux-mvvm/" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd jd gy z fp or fr fs os fu fw jc bi translated">SwiftUI架构:模型视图、Redux和MVVM -快鸟工作室博客</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">随着SwiftUI和Xcode 11最近刚刚发布，我们决定研究不同的应用架构，可以…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">quickbirdstudios.com</p></div></div><div class="ov l"><div class="pc l ox oy oz ov pa lb om"/></div></div></a></div><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pd nx l"/></div></figure><div class="oj ok gp gr ol om"><a href="https://github.com/hmlongco/Resolver" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd jd gy z fp or fr fs os fu fw jc bi translated">hmlongco/解析器</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">iOS上Swift 5.1的超轻依赖注入/服务定位器框架。依赖注入框架…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">github.com</p></div></div><div class="ov l"><div class="pe l ox oy oz ov pa lb om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://github.com/saoudrizwan/Disk" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd jd gy z fp or fr fs os fu fw jc bi translated">saoudrizwan/磁盘</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">安装*使用*调试* A Word *文档*使用磁盘的应用*许可证* Contribute *问题？磁盘是…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">github.com</p></div></div><div class="ov l"><div class="pf l ox oy oz ov pa lb om"/></div></div></a></div></div></div>    
</body>
</html>