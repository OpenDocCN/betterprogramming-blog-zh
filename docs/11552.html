<html>
<head>
<title>A Hexagonal Approach to Writing Microservices for Scalable and Decentralized Business</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为可扩展和分散的业务编写微服务的六边形方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-ports-and-adapter-with-typescript-32a50a0fc9eb?source=collection_archive---------1-----------------------#2022-03-30">https://betterprogramming.pub/how-to-ports-and-adapter-with-typescript-32a50a0fc9eb?source=collection_archive---------1-----------------------#2022-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="decd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在TypeScript中使用端口和适配器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6e1cd9aaed0740353ade7886024d9b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6GWWqvsIAiT_0FqF"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">萨姆·巴耶在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5551" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从我们作为软件工程师的职业生涯开始，我们就听说了好的实践、好的架构，以及向我们所有人宣扬它们的各自的清单，但是你并不总是清楚地看到如何在日常基础上将它们付诸实践。不是批评，干净的代码和干净的架构是我形成的基础。</p><p id="dff5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">去年，我和我的团队在GeekHunter这里集思广益，我们试图<em class="ls">整理关于我们主系统架构的房子</em>，以及我们可以采取的一些步骤，以达到我们所谓的带有功能外壳的<em class="ls">无状态核心。</em></p><p id="647d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在享受我们播种的果实，现在我们更接近百分之百的无国籍核心。</p><p id="fc77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这让我想起了我去年做的一个POC项目，使用TypeScript实现六角形或端口适配器架构的概念。</p><p id="f389" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我想与社区分享它，实践这些概念后，我可以看到这个小项目如何帮助我在过去更好地看到地面，并在尝试架构改进时将皮肤放在游戏上。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="925e" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">1—问题</h1><p id="d255" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这个项目是从开发猎人在Linkedin上发给你的几十个评估测试中选择一个来写的，以便进入一些随机的公司。</p><p id="0119" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的背景是一家专门从事长途电话的电话公司，它想向市场发布一项新计划。它被称为“FaleMais”。</p><p id="2441" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该公司根据呼叫者的来源和呼叫的目的地向客户收取一分钟的通话费用，如下表所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/7650541d4e58147896dc2407a716a293.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*HCRxZoSaHlFfIeusBh5Jtw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">原始代码/目的代码/分钟价格</p></figure><p id="1b4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用新的FaleMais产品，客户购买一个计划，就可以在一定时间内(以分钟为单位)免费通话，只需为额外的分钟付费。超出的分钟数在正常分钟费率的基础上增加10%。这些计划是FaleMais 30 (30分钟)、FaleMais 60 (60分钟)和FaleMais 120 (120分钟)。</p><p id="950e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">VxTel公司关心其客户的透明度，希望提供一个网页，让客户可以计算呼叫的价值。在那里，客户可以选择始发地和目的地城市的代码，以分钟为单位的通话时间，并选择FaleMais计划。该系统应显示两个值:(1)与计划关联的值和(2)没有计划的值。对于这个问题，应该忽略获取计划的初始成本。</p><p id="03b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们只寻找后端，因为我们想接近六边形架构。这不一定是一个可伸缩的问题，但是可以。如果在现实世界中，每秒钟会有大量的调用，肯定需要一个好的架构。这里不提数据科学部分。</p><p id="2d95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我将跳过项目的配置部分，那不是重点。用Docker记下用打字稿写的笔记是有效的。</p><p id="5e11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先我想解释一下目录结构，这是理解六边形结构的一个重要部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/d178f83bd32d940c2fac1b9f27b1d378.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*0fA_B9s-7ldKikPMeYIV3g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/Thrashattack/vxtel/tree/main/backend/src" rel="noopener ugc nofollow" target="_blank">六角形建筑目录</a></p></figure><p id="9962" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们有我们的<code class="fe mz na nb nc b">Core</code>。就是我们上面提到的无状态核心。it dir中的所有内容都是无状态的、声明性的和可实现的代码。</p><p id="9117" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，它包含代表我们在域中处理的内容的<code class="fe mz na nb nc b">Entities</code>、<code class="fe mz na nb nc b">Repositories</code>，这些是说明如何获取/存储数据的接口，以及做任何需要实现业务目标的事情的<code class="fe mz na nb nc b">Services</code>，服务还处理业务规则。核心永远不会依赖于它的目录之外的任何东西。</p><p id="48e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们有<code class="fe mz na nb nc b">data sources</code>和<code class="fe mz na nb nc b">use-cases</code>都是功能外壳的一部分。我们想要多少贝壳都可以。</p><p id="33fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，<code class="fe mz na nb nc b">data-sources</code>是我们在<code class="fe mz na nb nc b">Core</code>中定义的存储库的实现，这里您会发现一个<code class="fe mz na nb nc b">mysql</code>实现和一个<code class="fe mz na nb nc b">postgresql</code>实现，因为我决定将东西存储在单独的数据库中，以便不损害整个系统的可用性(以及作为POC)。</p><p id="0192" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里你可以有任何你想要的数据源，如果你使用人工智能并且需要获取弹性数据，在这里实现它，等等…</p><p id="19bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用例将API作为微服务。他们使用数据源和核心服务来提供REST API。我们可以按照我们想要的方式分割它，我们可以在不同的端口有不同的路由，或者我们可以轻松地在无服务器功能中转换每个用例。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="8c9e" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">2 —无状态核心</h1><p id="4edd" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">深入我们的应用核心，我们可以找到定义问题实体的结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7b96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个接口足以映射我们的问题。首先，我们有一个计划，它是一个实体，有一个名称，一个免费的发言时间，以及当超过免费时间时要征收的额外百分比税。</p><p id="0c4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们有税映射成本在来源和目的地表以上。</p><p id="6a9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进入内核的<code class="fe mz na nb nc b">Repositories</code>层，我们有定义如何获取或存储数据的接口。它们是接口，因为它们不想知道数据获取是如何实现的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cc77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们都定义了两种方法，一种是通过某些标识获取数据，另一种是获取所有数据。</p><p id="d721" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以深入到服务中，看看它是如何与业务规则相联系的。</p><p id="2f45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有三个服务，一个用于开账单，一个用于列出所有的税和计划，另一个用于开账单，将计划计入账户。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/c3b2ad05c3ac125c2d67a21cb2ab558c.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*gZznjb50RxOUNFCc70ISqg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/Thrashattack/vxtel/tree/main/backend/src/core/services" rel="noopener ugc nofollow" target="_blank">核心服务</a></p></figure><p id="5b67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">计费是一个简单地做问题中所描述的事情的服务:<br/>它获取一个源和一个目的地(称为A和B)，呼叫的总分钟数，并计算其计费。它还允许您传递每分钟的额外费用。</p><p id="7ec6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，这个服务使用存储库，所以它需要接收注入到构造函数中的存储库。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="127d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在此之后，我们有一个简单的列表服务，将用于获取所有的计划和税收。它还接收存储库作为依赖注入。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c39c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一个服务是计算给定特定计划的账单的服务。</p><p id="623f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它旨在扩展现有的<code class="fe mz na nb nc b">Billing</code>服务。您可以注意到，如果需要的话，在计算了额外的税费之后，它总是会从<code class="fe mz na nb nc b">Billing</code>服务返回方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c37b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们的无状态核心就准备好了，我们现在能够将这个核心服务用于我们想要的任何数据库，并在我们想要的任何REST、Graphql或RPC端点中公开它。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="3861" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">3 —功能外壳(数据源)</h1><p id="6996" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如前所述，我们决定在这里使用两个数据库，更多的是作为概念验证。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/cc9df18c71e16d13ed66a965596eed12.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*N2ZDo0vJtfAVQq0SQJXLDg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/Thrashattack/vxtel/tree/main/backend/src/data-sources" rel="noopener ugc nofollow" target="_blank">数据来源</a></p></figure><p id="2379" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个实现都有一个config dir来存储迁移和QueryBuilders，如果需要更多的数据源，它可以是一个公共接口。这里的ORM是Knex。除了<code class="fe mz na nb nc b">config</code>dir，我们还有数据源实现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/ce4f8ade05805ea7f2b3e21ddf9862bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*Tr-pBj89r-URrkK7WZ1ksQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/Thrashattack/vxtel/tree/main/backend/src/data-sources/mysql/config" rel="noopener ugc nofollow" target="_blank"> Mysql数据源</a></p></figure><p id="49c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在数据源配置中导航很重要，但这不是这里的重点。所以让我们跳过这一部分，因为您可以从存储库中浏览它。</p><p id="6bf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">PlansDataSource</code>使用一些配置从核心实现<code class="fe mz na nb nc b">PlansRepository</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d725" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">转到<code class="fe mz na nb nc b">postegres</code>实施，我们有<code class="fe mz na nb nc b">TaxesDataSource</code>，我们还有一些将被跳过的配置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="86d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也就是说，我们现在离拥有一个自上而下的全六边形架构只有一步之遥。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="62d6" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">4 —功能外壳(用例)</h1><p id="d866" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">既然一切都已设置好，而且最重要的是，它们是分离的，那么没有什么比作为微服务的用例更好的了。这里我们有两个:计费和列表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/1e3b5d95c7c45000bd35d742d61d34cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*TfbgA6PmuTgEJ2aP9VFcxA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/Thrashattack/vxtel/tree/main/backend/src/use-cases" rel="noopener ugc nofollow" target="_blank">用例</a></p></figure><p id="3d30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在计费用例中，我们有一个REST API的Express服务器的完整实现，带有一些验证和对核心服务的调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="226e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在另一个端口，在另一个服务中，如果您愿意，可能在另一个群集中(你好，AWS lambda)，我们有列表服务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="9c87" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">还有更多</h1><p id="fb27" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在这篇文章之后，你可以访问<a class="ae kv" href="https://github.com/Thrashattack/vxtel/tree/main/backend" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>来完全理解这个实现，我真的希望这能帮助你理解干净的六角形架构。</p></div></div>    
</body>
</html>