<html>
<head>
<title>How Do React State Management Tools Like Redux, Recoil Actually Work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像Redux，反冲这样的React状态管理工具实际上是如何工作的？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-do-react-state-management-tools-like-redux-recoil-actually-work-5b5913814a6c?source=collection_archive---------8-----------------------#2022-05-19">https://betterprogramming.pub/how-do-react-state-management-tools-like-redux-recoil-actually-work-5b5913814a6c?source=collection_archive---------8-----------------------#2022-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2648" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在后台</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/353473e5227d74602081044bd4cd262f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DqmRsX32NbQjFbmVFnPZSg.jpeg"/></div></div></figure><p id="a42d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很久以来一直有一个问题，React <strong class="kt ir">上下文API</strong>(React支持的状态管理)与其他状态管理工具如Redux或反冲<strong class="kt ir">在内部</strong>有何不同。</p><p id="836d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你看一下这些工具的文档，你会发现一些共同点，那就是这些工具更适合具有频繁变化的全局状态的应用程序。</p><p id="e2c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，Redux和反冲不断地告诉他们的用户，如果您有一个包含少量组件的小应用程序，并且它们的状态不会频繁变化，那么您可能不需要使用我们的工具。</p><p id="0e84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所知，Context API在性能方面不是很好，原因很简单，当Provider中的任何状态发生变化时，Provider下的所有子组件都将重新呈现。</p><p id="5ddc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这使得依赖上下文API作为状态管理是绝对苛刻的原因，损害了我们的应用程序性能。如果这是一个用例，比如静态的主题颜色，那么这将是上下文API的一个很好的用例。</p><p id="a8b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每个React组件都会自动重新渲染，原因很简单，有三个。</p><ul class=""><li id="a2a1" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">当组件的状态发生变化时，即使该状态是从像<code class="fe lx ly lz ma b"><em class="ln">useQuery()</em></code>或<code class="fe lx ly lz ma b"><em class="ln">useContext()</em></code>这样的定制钩子中获取的。</li><li id="8291" class="lo lp iq kt b ku mb kx mc la md le me li mf lm lt lu lv lw bi translated">当组件的特性发生变化时。</li><li id="6525" class="lo lp iq kt b ku mb kx mc la md le me li mf lm lt lu lv lw bi translated">当父组件重新呈现时，它会强制所有子组件重新呈现，特别是如果子组件没有用<code class="fe lx ly lz ma b">memo</code>函数包装的话。</li></ul><p id="134e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不必要的重新渲染会影响应用程序的性能，并导致用户电池的损耗，这肯定是没有用户想要的。让我们详细了解为什么组件会被重新渲染，以及如何防止不必要的重新渲染来优化应用程序组件。</p><blockquote class="mg mh mi"><p id="fc72" class="kr ks ln kt b ku kv jr kw kx ky ju kz mj lb lc ld mk lf lg lh ml lj lk ll lm ij bi translated">Redux和其他状态管理工具如反冲试图用React构建一个优化的<strong class="kt ir">观察者系统</strong>。</p></blockquote><p id="dc2c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一些工具有不同的术语和不同的数据结构，如图形和集合上的反冲继电器，Redux是更简单的面向对象的工具，具有更高级的复杂变异减少器。</p><h1 id="b85f" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">可观测系统</h1><p id="cc8e" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">如果我们把可观察性系统看作一幅大图，可观察性系统是一种设计模式，将状态和观察者(有些人称之为订户)作为回调，当状态发生变化时，系统会自动通知这些注册的观察者。</p><p id="66f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">观察者设计有三个主要组件:</strong>实例的状态或数据，作为堆栈回调的注册订阅者/观察者，以及一个可以改变状态的mutator，mutator不仅改变状态，还试图在状态改变时通知所有注册订阅者/观察者。</p><p id="84dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它与发布/订阅系统完全不同，发布/订阅系统允许设计定义特定事件，您可以向订阅者发送自定义参数或包含您需要的值的不同事件。</p><p id="d91b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将在下一章尝试实现观察者系统，并将其与React绑定。</p><h1 id="0f91" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">建筑可观测系统</h1><p id="dc5a" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">谈论理论是伟大的，但让我们谈谈实施。正如我们之前提到的，观察器有三个主要组件:状态、赋值函数和订阅者/观察器。</p><p id="1eb7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">显然，订阅者是一个接收一个属性引用(新状态)的回调，所以观察者接口应该有这些我们需要变异、订阅和检索状态的基本方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="nl nm gj gh gi nn no bd b be z dk translated">观察者界面。</p></figure><p id="be83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">观察者的基本流程是这样的，</p><ul class=""><li id="1705" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated"><code class="fe lx ly lz ma b">getState()</code>方法只是返回我们的状态。</li><li id="0fda" class="lo lp iq kt b ku mb kx mc la md le me li mf lm lt lu lv lw bi translated"><code class="fe lx ly lz ma b">mutate()</code>方法改变我们的状态(例如，通过输入提交新用户)，然后运行<code class="fe lx ly lz ma b">notify()</code>通知所有注册用户回调并传递新状态。</li><li id="57af" class="lo lp iq kt b ku mb kx mc la md le me li mf lm lt lu lv lw bi translated"><code class="fe lx ly lz ma b">subscriber()</code>当状态发生变化时，您可以注册我们的订户或回拨收听。</li></ul><p id="c86e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我知道您肯定想知道如何将其与React绑定，以便与我们的React组件进行通信。我们将在下一章和那一章讨论这个问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="nl nm gj gh gi nn no bd b be z dk translated">观察者类。</p></figure><h1 id="0040" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">具有React的绑定可观测系统</h1><p id="e47d" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">反冲试图将观察者系统和React绑定API合并在同一个库中，其他工具如Redux试图将概念<a class="ae np" href="https://github.com/reduxjs/redux#basic-example" rel="noopener ugc nofollow" target="_blank"> Redux </a>作为状态管理和观察者分离在一个包中，并将绑定Redux的<a class="ae np" href="https://github.com/reduxjs/react-redux" rel="noopener ugc nofollow" target="_blank"> React-redux </a>分离在不同的包中。</p><h2 id="50f7" class="nq mn iq bd mo nr ns dn ms nt nu dp mw la nv nw my le nx ny na li nz oa nc ob bi translated"><observerprovider/></h2><p id="5fbe" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">该提供者的<code class="fe lx ly lz ma b">ObserverProvider</code>将观察者类实例传递给所有子组件。该提供者接受<code class="fe lx ly lz ma b">initialState</code>属性，将初始状态注入到将被传递给观察者的<code class="fe lx ly lz ma b">Provider</code>中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="nl nm gj gh gi nn no bd b be z dk translated">观察者对环境做出反应。</p></figure><p id="c437" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里的观察者实例注入了<code class="fe lx ly lz ma b">useRef</code>来避免与React反应系统的任何交互。<code class="fe lx ly lz ma b">useRef</code>当组件的值发生变化时，不会通知组件，即使ref值发生变化，也不会导致任何重新渲染。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="nl nm gj gh gi nn no bd b be z dk translated">观察者反应提供者。</p></figure><h2 id="3981" class="nq mn iq bd mo nr ns dn ms nt nu dp mw la nv nw my le nx ny na li nz oa nc ob bi translated">useMutate()</h2><p id="16ea" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">基本上，mutate钩子<code class="fe lx ly lz ma b">useMutate</code>充当我们状态的setter函数，从提供者那里检索观察者实例，并使用<code class="fe lx ly lz ma b">mutate</code>方法将新的突变状态发送给观察者。</p><p id="2661" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你注意到这里我们用<code class="fe lx ly lz ma b">useCallback</code>包装了箭头函数，以避免每次被挂钩的组件重新渲染时重新创建一个新函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="nl nm gj gh gi nn no bd b be z dk translated">useMutate()挂钩。</p></figure><h2 id="ff79" class="nq mn iq bd mo nr ns dn ms nt nu dp mw la nv nw my le nx ny na li nz oa nc ob bi translated">使用选择器()</h2><p id="4828" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">显然，选择器钩子<code class="fe lx ly lz ma b">useSelector</code>为我们的观察者充当了一个getter函数，但是有一些不同。</p><p id="e096" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尝试将观察者状态与钩子内部的React本地状态同步，这样就能够与被钩住的React组件进行通信和交互。</p><p id="5bb6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在第一行中，我们将Observer的初始状态注入React状态，然后订阅Observer以在状态发生变化时进行监听，并将订阅封装在<code class="fe lx ly lz ma b">useEffect</code>中，以避免被挂钩的组件重新呈现时的任何撤销，最终检索React状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="b447" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您尝试对最流行的React状态管理工具的工作方式进行逆向工程，您会看到它们的核心设计围绕着该设计模式，一些工具具有高级功能，如Redux中管理变异复杂性的reducers和反冲中的选择器图依赖。</p><p id="ca4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">资源</strong></p><p id="c384" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae np" href="https://refactoring.guru/design-patterns/observer" rel="noopener ugc nofollow" target="_blank">观察者(refactoring . guru)</a><br/><a class="ae np" href="https://codesandbox.io/s/observer-system-binded-react-eyniy0?file=/src/App.tsx" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">文章的完整代码</strong> </a></p><pre class="kg kh ki kj gt oj ma ok ol aw om bi"><span id="a1dc" class="nq mn iq ma b gy on oo l op oq"><strong class="ma ir">Want to Connect?</strong></span><span id="6a20" class="nq mn iq ma b gy or oo l op oq">Twitter: <a class="ae np" href="http://twitter.com/bouhuolia" rel="noopener ugc nofollow" target="_blank">twitter.com/bouhuolia</a><br/>Github: <a class="ae np" href="http://github.com/abouolia" rel="noopener ugc nofollow" target="_blank">github.com/abouolia</a></span></pre></div></div>    
</body>
</html>