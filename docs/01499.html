<html>
<head>
<title>Introduction to Linked Lists in C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C语言中的链表介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-linked-lists-in-c-80fc426a6a2f?source=collection_archive---------8-----------------------#2019-09-19">https://betterprogramming.pub/introduction-to-linked-lists-in-c-80fc426a6a2f?source=collection_archive---------8-----------------------#2019-09-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5eee" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">链表的可视化指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/f4c72abba35cd0a7d4933e8d1b6342e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8AFEgXn3wNJCG6ik"/></div></figure><p id="f277" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">链表是一种数据结构。数据结构就是我们如何组织和存储内存中的数据。</p><p id="6ec0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">链表由各个节点组成，每个节点包含两样东西:一个是数据，一个是指针，<em class="lk"> </em>将指向下一个节点。一个链表基本上可以有<em class="lk"> n </em>个节点，每个节点通过指针连接到下一个节点。有两种类型的链表:单向链表(SLL)和双向链表(DLL)。</p><p id="675f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在SLL中，我们有一个指向下一个节点的指针，因此，它被称为单链表。在DLL中，我们有两个指针:一个指针指向下一个节点，另一个指向前一个节点。这就是为什么我们称之为双向链表。</p><p id="dccb" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在C编程中，我们使用结构来创建一个链表。结构是一种数据类型，在结构中我们可以定义不同数据类型的变量(如<code class="fe ll lm ln lo b">int</code>、<code class="fe ll lm ln lo b">char</code>、<code class="fe ll lm ln lo b">pointer</code>等)。).</p><p id="1ea7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了创建一个链表，我们将定义链表的结构(使用<code class="fe ll lm ln lo b">struct</code>数据类型)，它将表示链表中单个节点的样子。然后我们将通过使用<code class="fe ll lm ln lo b">malloc()</code>函数分配内存来创建一个链表。</p><h2 id="3c8b" class="lp lq iq bd lr ls lt dn lu lv lw dp lx kw ly lz ma la mb mc md le me mf mg mh bi translated"><strong class="ak">链表的结构:</strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="105a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">上面的代码代表了我们的链表结构，它包含两个东西。首先是一个变量<code class="fe ll lm ln lo b">data</code>，它将在其中保存整数值。第二个是<code class="fe ll lm ln lo b">struct node *p</code>，它是一个指向链表中下一个节点的指针。这里，<code class="fe ll lm ln lo b">struct</code>表示结构数据类型，<code class="fe ll lm ln lo b">node</code>是该结构的名称。你可以给这个结构取任何你想要的名字。</p><p id="657b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，你可能会有一个问题:为什么指针和结构有相同的数据类型？这背后的原因是链表中的节点是自引用的，这仅仅意味着一个节点中的指针将指向另一个相同类型的节点(在本例中是<code class="fe ll lm ln lo b">struct</code>节点)。</p><p id="9a94" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">注意，写完上面的代码后，不会创建链表——也不会给它分配任何内存。这只是一个模板，它将定义我们的链表的结构(我们的链表看起来会是什么样子)。</p><p id="1c20" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，让我们编写一个代码，通过使用<code class="fe ll lm ln lo b">malloc()</code>函数分配一些内存来创建一个链表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="dfe0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">上面的代码行将在内存中创建一个节点，后跟一个名为<code class="fe ll lm ln lo b">new</code>的指针，它将指向新创建的节点。</p><p id="c9ab" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">之前，在为我们的节点创建模板时，我们将其命名为<code class="fe ll lm ln lo b">struct node</code>。因此，要分配内存，首先我们必须找出该数据类型的大小，然后将其传递给malloc函数来为其分配内存。</p><p id="1dd2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">之后，我们可以创建一个名为<code class="fe ll lm ln lo b">*new</code> <strong class="kp ir"> </strong>的新指针，并使用类型转换将malloc函数的输出分配给该指针。malloc函数默认返回<code class="fe ll lm ln lo b">void</code>，但是我们的指针<code class="fe ll lm ln lo b">new</code>属于<code class="fe ll lm ln lo b">struct node</code>类型；因此，我们必须对其进行定型。</p><p id="f1a3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这就是它看起来的样子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/ec4b9e2b5a449109214c2b456aa4ea9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hig84tKodcEqxClGxPC6hQ.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">链表中的单个节点</p></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="01df" class="na lq iq bd lr nb nc nd lu ne nf ng lx jw nh jx ma jz ni ka md kc nj kd mg nk bi translated">在SLL上执行的操作</h1><h2 id="78b4" class="lp lq iq bd lr ls lt dn lu lv lw dp lx kw ly lz ma la mb mc md le me mf mg mh bi translated">1.在链接列表中插入元素</h2><ul class=""><li id="347e" class="nl nm iq kp b kq nn kt no kw np la nq le nr li ns nt nu nv bi translated">在将一个节点(元素)插入一个链表之前，首先必须使用<code class="fe ll lm ln lo b">malloc</code>创建一个节点。</li><li id="7e33" class="nl nm iq kp b kq nw kt nx kw ny la nz le oa li ns nt nu nv bi translated">同样，在插入一个节点(元素)之前，你首先要检查<code class="fe ll lm ln lo b">head</code>是否指向<code class="fe ll lm ln lo b">NULL</code><strong class="kp ir"/>——否则，它会给出一个分段错误。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div></figure><ul class=""><li id="58b3" class="nl nm iq kp b kq kr kt ku kw ob la oc le od li ns nt nu nv bi translated">考虑下面的例子:</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/21073735d416a2942b544b3c280cc8d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BQwwcL4njRbeW8EhSHqQ2A.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">链接列表的示例</p></figure><ul class=""><li id="8256" class="nl nm iq kp b kq kr kt ku kw ob la oc le od li ns nt nu nv bi translated">现在，有三种方法可以将这个节点插入到上面的链表中</li></ul><p id="dd39" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir"> a .在开头插入节点</strong></p><p id="b56f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了在链表的开头插入一个我们创建的节点，这个节点由一个名为<code class="fe ll lm ln lo b">new</code>的指针指向，我们必须编写下面的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="2103" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这样做的目的是:它首先将由<code class="fe ll lm ln lo b"><strong class="kp ir">pointer head</strong></code>指向的节点的起始地址存储到由<code class="fe ll lm ln lo b">pointer new</code>指向的节点中。<strong class="kp ir"> </strong>然后把<code class="fe ll lm ln lo b">new pointer</code>的地址分配给<code class="fe ll lm ln lo b">head pointer</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/23b2e7803ccd1df7deab6bad9b2dcca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1FcGOOhVvh3gDzag.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">在开头插入节点</p></figure><p id="3027" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果在将<code class="fe ll lm ln lo b">head pointer</code>的地址存储到<code class="fe ll lm ln lo b">new pointer</code>之前，直接将<code class="fe ll lm ln lo b">new pointer</code>的地址分配给<code class="fe ll lm ln lo b">head pointer</code>以在开头插入节点，那么整个链表将会丢失，因为在这种情况下，没有指针指向链表起始节点所在的内存位置。</p><p id="ca7a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一开始理解起来可能有些混乱，所以我建议你多读几遍，试着从视觉上理解它。</p><p id="4a64" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir"> b .在中间插入节点</strong></p><p id="ae16" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在要在中间插入节点，我们首先要考虑在哪里插入新节点。</p><p id="d060" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">假设我们想在上述链表中的第二个节点之后插入新创建的节点。为此，我们必须到达第二个节点，然后将第二个节点指向的内容存储到<code class="fe ll lm ln lo b">new-&gt;link</code>中。然后，我们将在该位置插入节点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/e42825b8df599c914f309024242e995b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*30DkEl4zSSvUDPX4.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/64e403545dba6a634cb22b95cbc32e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WpLMIZd4XZGtvHii.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/07807dbe98351c53372e9c8d011effd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1PmTr4BFAMODhdLG.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/f7f2e89092fc3d00db2348d227859856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D9q_RNL7iEGEUXEpsBBBqw.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">在中间插入节点</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="b369" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir"> c .在末尾插入节点</strong></p><p id="ba4d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了在末尾插入一个节点，我们首先要找到链表的末尾。链表中的结束节点或最后一个节点在下一部分总是有一个<code class="fe ll lm ln lo b">NULL</code> <strong class="kp ir"> </strong>(也表示为<code class="fe ll lm ln lo b">\0</code>)。从上面的链表中，我们可以说值为5的节点是最后一个节点，因为它的下一个节点是<code class="fe ll lm ln lo b">NULL</code>。</p><p id="c7d9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了达到目的，我们首先必须检查<code class="fe ll lm ln lo b">t-&gt;next</code>是否为空。如果为空，那么我们可以在该位置插入节点。否则，继续前进，直到到达<code class="fe ll lm ln lo b">t-&gt; next</code>为空。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/fdd4ccffecb4dd174fc457750536aebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*77gXXCj8C_KM7m1F.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/fcdfe0f76be8f398794d09eac9278221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fw3ZRuRg9jaAvIA_xBKVWQ.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">在末尾插入节点</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h2 id="1853" class="lp lq iq bd lr ls lt dn lu lv lw dp lx kw ly lz ma la mb mc md le me mf mg mh bi translated"><strong class="ak"> 2。遍历链表</strong></h2><ul class=""><li id="f1e0" class="nl nm iq kp b kq nn kt no kw np la nq le nr li ns nt nu nv bi translated">遍历意味着访问链表中的每个节点。</li><li id="5767" class="nl nm iq kp b kq nw kt nx kw ny la nz le oa li ns nt nu nv bi translated">对于遍历，我们不使用当前指向链表的实际指针，而是创建另一个指针(比如，<code class="fe ll lm ln lo b">t</code>)。通过使用它，我们可以遍历列表。因为如果我们移动当前指针，那么有可能会丢失链表中的一些节点。</li><li id="385a" class="nl nm iq kp b kq nw kt nx kw ny la nz le oa li ns nt nu nv bi translated">我们用一个例子来理解这个。假设我们有一个链表，如下所示。所以让我们穿越它。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/0f21a2f5b5492b1343d00d263b94a3ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QyGiUp8Bx6R86v2g.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">链接列表的示例</p></figure><p id="57ed" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">遍历上述链表的代码:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="62ec" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">输出:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="8ce5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先，我们有一个节点模板，它定义了链表中的内容。其次，我们在里面有main函数，为此我们创建了一个类型为<code class="fe ll lm ln lo b">struct node</code>的新指针<code class="fe ll lm ln lo b">t</code>(一个我们将用来遍历列表的指针)和一个while循环，它将打印列表中的数据，然后递增指针。</p><p id="074c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这种情况下，我们现在触摸<code class="fe ll lm ln lo b">head</code>指针。如果我们这样做，那么我们可能会丢失链表中的一些节点，因为我们在链表的起始位置没有指针。</p><p id="8c9a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">创建另一个指针后——比如说，<code class="fe ll lm ln lo b">t</code>——<code class="fe ll lm ln lo b"> </code>你有一个选择。您可以移动<code class="fe ll lm ln lo b">t</code>或<code class="fe ll lm ln lo b">head</code>。哪个都没关系，因为现在在链表的起始位置有两个指针。</p><h2 id="492e" class="lp lq iq bd lr ls lt dn lu lv lw dp lx kw ly lz ma la mb mc md le me mf mg mh bi translated"><strong class="ak"> 3。从链表中删除一个元素</strong></h2><ul class=""><li id="60fa" class="nl nm iq kp b kq nn kt no kw np la nq le nr li ns nt nu nv bi translated">在删除一个节点(元素)之前，首先要检查<code class="fe ll lm ln lo b">head</code>是否指向<code class="fe ll lm ln lo b">NULL</code>。否则，它会给出一个分段错误。</li><li id="52f5" class="nl nm iq kp b kq nw kt nx kw ny la nz le oa li ns nt nu nv bi translated">每当你从使用<code class="fe ll lm ln lo b">malloc()</code>函数创建的链表中删除一个元素时，你也必须使用<code class="fe ll lm ln lo b">free()</code>函数释放它。删除一个元素后释放空间并不是强制性的，但是这样做是一个好习惯。</li><li id="ac8d" class="nl nm iq kp b kq nw kt nx kw ny la nz le oa li ns nt nu nv bi translated">另外，创建一个临时指针——比方说，<code class="fe ll lm ln lo b">t </code> —来保存您想要删除的节点，然后执行其他操作。否则，您要删除的节点将会丢失。</li></ul><p id="0b0b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">检查条件:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="5398" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有三种方法可以像插入一样删除节点。</p><p id="67e6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir"> a .删除开头的节点</strong></p><p id="873d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要删除开头的节点，创建一个新指针<code class="fe ll lm ln lo b">t</code>，并使其指向头部。现在，我们必须使用<code class="fe ll lm ln lo b">head = head-&gt;next</code>将头部指针的位置向前移动一步。然后释放<code class="fe ll lm ln lo b">t</code>删除链表中的第一个元素。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/b0af82ea1761958fe344bdf85e22e3a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ymb820jIuKlPbMV0.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/27868bd37535d04a068561f2c969c86e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MCZrS3fPgIYbysDy.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">删除开头的节点</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="8ffa" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir"> b .删除中间的节点</strong></p><p id="31c8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这里，我们必须确定要删除哪个节点。之后，创建一个新的指针，并使其指向头部指针所指向的位置。</p><p id="ce38" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">假设我们想要删除一个数据部分的值为3的节点。然后，检查<code class="fe ll lm ln lo b">t-&gt;next-&gt;data</code>是否为<code class="fe ll lm ln lo b">3</code> <strong class="kp ir"> </strong>。如果数据部分的值为3，那么创建另一个指针—比方说，<code class="fe ll lm ln lo b">p</code>—<strong class="kp ir">—</strong>来保存值为3的节点的下一部分。之后，释放<code class="fe ll lm ln lo b">t</code>指针当前指向的位置，然后将<code class="fe ll lm ln lo b">p</code>指针的地址赋给<code class="fe ll lm ln lo b">t-&gt;next</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/f7d672387b24403933d0ad27341588e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EMwjC4jwX7KDlEzF.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/402e3aa32164cff131ba342d5f66d39a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aveCe17urCFcywon.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/2871ab02cdcfcb595b72c22d69e3ceb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eyj-b1zi0KFTXKU3.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">删除中间的节点</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="b55d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir"> c .删除最后的节点</strong></p><p id="5d25" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当我们删除最后一个节点时，我们必须后退两步，检查第二个元素是否为空。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="bc2e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下图解释了上面的代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/f2ee5a7cbfc29fa5ca9bb4489f7c922e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DgK8bki-KPVkXcPI.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/1b6640b3de96f78d58f580188914be3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T9psKJRWvm4x4L21.png"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">删除末尾的节点</p></figure><p id="fca5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在链表中搜索一个元素需要更长的时间O(n) <strong class="kp ir"> </strong>因为在最坏的情况下，我们要遍历<strong class="kp ir"> </strong> <em class="lk"> n </em>个元素。<strong class="kp ir"> </strong>而在最好的情况下，我们可以在第一次尝试中找到元素，所以时间复杂度会是O(1)。</p><p id="87b8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在数组中搜索一个元素时，需要O(1)次(考虑到数组是排序的)；否则，只需要O(n)次。</p><p id="d1ac" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">更多此类博客请访问<a class="ae lj" href="https://liongueststudios.com/" rel="noopener ugc nofollow" target="_blank"> LionGuest工作室</a>。</p><p id="1a7b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>