<html>
<head>
<title>Build an RSA Asymmetric Cryptography Generator in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中构建一个RSA非对称密码生成器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-an-rsa-asymmetric-cryptography-generator-in-go-d202b18bcfd0?source=collection_archive---------15-----------------------#2020-01-29">https://betterprogramming.pub/build-an-rsa-asymmetric-cryptography-generator-in-go-d202b18bcfd0?source=collection_archive---------15-----------------------#2020-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1977" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编写一个小的便携式Go应用程序来生成一对RSA密钥</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7d4fe223405ed08b0eb19ac9da8de686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yeF86NncRejLnXJz.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作为加密的非对称(公钥)加密用例。从<a class="ae kv" href="https://www.twilio.com/blog/what-is-public-key-cryptography" rel="noopener ugc nofollow" target="_blank">提里奥</a></p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="d7d5" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated"><strong class="ak">背景</strong></h1><p id="d096" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">安全通信对于企业提供强大的信任至关重要。此外，大多数政府强制要求在向其他业务方发送信息时加密个人身份信息(PII)。</p><p id="e462" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">非对称加密是信息交换应用中的一种通用加密方法。</p><p id="f671" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">根据我的经验，我发现一些新企业很难生成他们的非对称密钥对。然后他们要求我的团队为他们生成密钥对。</p><p id="372c" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">从原则上讲，这是一种违反安全惯例的做法。因为私钥应该只由所有者看到和保存，如果我的团队为他们创建了私钥，他们实际上冒着商业信息泄露到我的团队的风险，因为他们已经看到了。</p><p id="50b0" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我经常注意到的另一种情况是另一方生成的密钥与规范不符。我们要求2048位，但我们从业务合作伙伴那里得到了1024位。</p><p id="0a1f" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">根据观察，我认为构建一个可以在任何地方运行的便携式非对称密码生成器是一个好主意。</p><p id="5b25" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">不费吹灰之力就能在大多数平台上运行的应用程序是一个有用的工具——拥有这种能力可以解决建立安全通信的大部分初始阶段。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="e6f2" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated"><strong class="ak">目标</strong></h1><p id="65f9" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">创建一个可重用和可移植的非对称密码生成器。输出是一个私钥和一个公钥，可用于加密目的。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="47cd" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated"><strong class="ak">伪代码</strong></h1><ol class=""><li id="1e32" class="mw mx iq lx b ly lz mb mc me my mi mz mm na mq nb nc nd ne bi translated">生成以位大小作为输入的私钥。</li><li id="1d6e" class="mw mx iq lx b ly nf mb ng me nh mi ni mm nj mq nb nc nd ne bi translated">从私钥生成公钥。</li><li id="98fa" class="mw mx iq lx b ly nf mb ng me nh mi ni mm nj mq nb nc nd ne bi translated">将私钥格式化为PEM格式。</li><li id="6d9d" class="mw mx iq lx b ly nf mb ng me nh mi ni mm nj mq nb nc nd ne bi translated">将公钥格式化为PEM格式。</li><li id="0579" class="mw mx iq lx b ly nf mb ng me nh mi ni mm nj mq nb nc nd ne bi translated">将私钥和公钥写入不同的文件。</li></ol></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="5131" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated"><strong class="ak">代码</strong></h1><p id="feba" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">该应用程序需要一个密码术和编码库。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="cf29" class="np le iq nl b gy nq nr l ns nt"> "crypto/rand"<br/> "crypto/rsa"<br/> "crypto/x509"<br/> "encoding/pem"<br/> "errors"<br/> "fmt"<br/> "io/ioutil"</span></pre><p id="3874" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">基于伪代码，我们创建了一个接受一个数字作为RSA密钥大小的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="f5ad" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">函数<code class="fe nw nx ny nl b">generateRsaKeyPair</code> <strong class="lx ir"> </strong>的输出是RSA私钥和公钥。PEM需要格式化以将密钥存储在字符串类型文件中，如伪代码编号3和5中所述。</p><p id="3056" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">以下是PEM格式化代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9311" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">函数<code class="fe nw nx ny nl b">exportKeytoPEM</code>的输出是两串PEM格式的密钥。我们需要将值存储在一个持久文件中，这样我们就可以移动键。下面是将值写入文件的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="787c" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我们需要执行函数<code class="fe nw nx ny nl b">writeFile</code>两次，让私钥和公钥写入不同的文件。</p><p id="ce6d" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我们生成密钥的函数已经完成。现在，让我们将所有这些函数放在<code class="fe nw nx ny nl b">main</code>函数中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="6c36" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated"><strong class="ak">测试应用</strong></h1><p id="5a83" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">一旦<code class="fe nw nx ny nl b">main</code> <strong class="lx ir"> </strong>函数准备就绪，我们就可以使用Go命令运行<a class="ae kv" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>应用程序。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="3d2c" class="np le iq nl b gy nq nr l ns nt">go run main.go</span></pre><p id="1aa2" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">输出两个文件:<code class="fe nw nx ny nl b">private.pem</code>和<code class="fe nw nx ny nl b">public.pem</code>。这些文件可以在与<code class="fe nw nx ny nl b">main.go</code>文件相同的目录下访问。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/537af2cf59ca0c576761d8340b59508b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4FQ1ePa9Xe6p9FIS9xyzbQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">生成的密钥与Go应用程序位于同一位置</p></figure><p id="1a89" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">该文件的示例如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/455f0a2b7799788b895f42bf522c32c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qN0iKnMAMd2NDhK_AaQiNA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">PEM格式的私钥和公钥示例</p></figure><p id="62d3" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">最后，为了使应用程序可移植，我们可以使用Go命令将应用程序构建到一个可移植文件中:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="1a9b" class="np le iq nl b gy nq nr l ns nt">go build -o key-generator</span></pre></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="6d56" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated"><strong class="ak">总结</strong></h1><p id="6865" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">应用程序可以在基于文本的文件中生成许多对RSA密钥。这个密钥对解决了加密和签名文档的业务需求。</p><ul class=""><li id="ddab" class="mw mx iq lx b ly mr mb ms me ob mi oc mm od mq oe nc nd ne bi translated">完整代码— <a class="ae kv" href="https://github.com/purnaresa/secureme/tree/master/key-generator" rel="noopener ugc nofollow" target="_blank"> Git存储库</a>。</li></ul><p id="5620" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">虽然这个应用程序是可移植的，可以在大多数类型的操作系统上运行，但是这个应用程序仍然需要在机器上安装Go。</p><p id="9759" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">为了扩展应用程序的功能，我们可以编写一个端点来触发密钥生成器，并用一对RSA密钥回复触发器。这样，我们只能在一台服务器上运行应用程序，并根据需要生成任意多的密钥对。</p><p id="e793" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">你觉得那有意思吗？或者你觉得离线生成密钥对就够了？让我们在评论中讨论这个问题。</p></div></div>    
</body>
</html>