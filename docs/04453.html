<html>
<head>
<title>What is Hashable in Swift?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中有什么可散列的？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swifts-hashable-fd57e6cd6426?source=collection_archive---------9-----------------------#2020-04-14">https://betterprogramming.pub/swifts-hashable-fd57e6cd6426?source=collection_archive---------9-----------------------#2020-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="051b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">集合或字典中的条目需要是可散列的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1d0b5fea35fc9e2cdba52108c43c1d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9XXt1wlEVAwL2nMe"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@alesnesetril?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ales Nesetril </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="efd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">集合或字典中的项目需要符合可散列协议。这篇文章探讨的正是这一点！</p><h1 id="7d98" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">先决条件</h1><ul class=""><li id="cb5f" class="mn mo it lb b lc mp lf mq li mr lm ms lq mt lu mu mv mw mx bi translated">能够产生一句“你好，世界！”iOS应用(<a class="ae ky" href="https://medium.com/swlh/your-first-ios-application-using-xcode-9983cf6efb71" rel="noopener">指南</a>)。</li><li id="1295" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">假设您对协议有所了解(<a class="ae ky" href="https://medium.com/@stevenpcurtis.sc/protocols-in-swift-f46c31283b18" rel="noopener">指南</a>)。</li><li id="e899" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">了解与Swift同等和可比协议的一致性(<a class="ae ky" href="https://medium.com/@stevenpcurtis.sc/swifts-equatable-and-comparable-protocols-54811114a5cf" rel="noopener">指南</a>)。</li><li id="1f2e" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">了解扩展的使用(<a class="ae ky" href="https://medium.com/@stevenpcurtis.sc/extensions-in-swift-68cfb635688e" rel="noopener">指南</a>)。</li></ul></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="2321" class="lv lw it bd lx ly nk ma mb mc nl me mf jz nm ka mh kc nn kd mj kf no kg ml mm bi translated">术语</h1><ul class=""><li id="db5f" class="mn mo it lb b lc mp lf mq li mr lm ms lq mt lu mu mv mw mx bi translated">哈希:也称为哈希或校验和，是哈希算法的结果。</li><li id="eda4" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">可散列:如果一个对象的散列值在对象的生命周期内是相同的，那么这个对象就是可散列的。</li><li id="2c0e" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">哈希表:将键映射到值的数据结构。</li><li id="b18a" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">哈希算法:用于生成哈希的算法。</li><li id="2443" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">集合:值的无序集合(其中所有的值都是同一类型)。</li><li id="a6e5" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">类型:可以处理的数据类型的表示(例如，整数或字符串)。</li></ul></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="8b18" class="lv lw it bd lx ly nk ma mb mc nl me mf jz nm ka mh kc nn kd mj kf no kg ml mm bi translated">动机</h1><p id="cd53" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">如果您希望将元素存储在一个集合或字典中，那么您需要遵循Hashable协议。尽管Swift可以综合一致性，但了解其工作原理以及我们如何手动符合协议是非常有利的。</p><p id="b3b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章就是来帮你解决的！</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="c096" class="lv lw it bd lx ly nk ma mb mc nl me mf jz nm ka mh kc nn kd mj kf no kg ml mm bi translated">常见哈希算法</h1><p id="9b03" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">MD5、SHA-1和SHA-2很常见<code class="fe ns nt nu nv b">hashing algorithms</code>。它们以单向函数的形式将数据映射到一个<code class="fe ns nt nu nv b">hash</code>，这个函数应该是不可行的。</p><p id="0787" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个扩展是使用一个<code class="fe ns nt nu nv b">hashing algorithm</code>来索引一个<code class="fe ns nt nu nv b">hash table</code>中的数据。</p><h2 id="8711" class="nw lw it bd lx nx ny dn mb nz oa dp mf li ob oc mh lm od oe mj lq of og ml oh bi translated">哈希表</h2><p id="c7b3" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">一个整数索引可以被计算为一个<code class="fe ns nt nu nv b">hash table</code>中的一个位置，正如我们将看到的，有一个理论围绕着散列表以及它们如何在Swift中实现。</p><p id="574b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哈希表是一个数组。当一个数组被输入到哈希表中时，该键用于通过哈希函数计算该元素的数组索引。</p><p id="e252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">散列函数的选择极其重要。</p><p id="1eab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有元素都存储在同一索引中的哈希表的功能类似于链表。访问一个特定的元素需要花费<em class="oi"> O(n) </em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/4e9cd7bab19504a573fdfbf0b3440572.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*ATUC1jkRX4guo8hg4bXxJg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">哈希表的糟糕实现。</p></figure><p id="ef6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个明显更好的实现是每个元素(尽可能接近)都有自己的索引。这需要一个好的散列函数来处理多个索引的情况(实际的崩溃)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/7486136816eef40c1c212189e783f7aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*y3X4nu8G6O0VPTWuTQ8aWw.png"/></div></figure><p id="b121" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift有自己的内置<code class="fe ns nt nu nv b">hashValue</code>。应该注意的是，这些值不能保证在程序的执行过程中是相等的。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="49ed" class="lv lw it bd lx ly nk ma mb mc nl me mf jz nm ka mh kc nn kd mj kf no kg ml mm bi translated">创建你自己的哈希类型</h1><p id="840d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">要求保存在字典中或设置在Swift中的类型符合<code class="fe ns nt nu nv b">Hashable</code>类型。</p><p id="7e67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们为人员类型创建一个结构:</p><pre class="kj kk kl km gt ol nv om on aw oo bi"><span id="4b29" class="nw lw it nv b gy op oq l or os">struct Person {<br/>    var name: String<br/>    var age: Int<br/>}</span></pre><p id="b99e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还不能将它添加到集合或字典中。以下内容:</p><pre class="kj kk kl km gt ol nv om on aw oo bi"><span id="2b3e" class="nw lw it nv b gy op oq l or os">var personSet = Set&lt;Person&gt;()<br/>personSet.insert(me)</span></pre><p id="21a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成不受欢迎的错误:“类型‘Person’不符合协议‘has hable’。”"</p><p id="32cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是相当令人失望的。然而，它清楚地表明我们需要这个特殊的结构来符合<code class="fe ns nt nu nv b">Hashable</code>协议。</p><h2 id="cbe7" class="nw lw it bd lx nx ny dn mb nz oa dp mf li ob oc mh lm od oe mj lq of og ml oh bi translated">符合可散列协议</h2><p id="8323" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">为此，我们可以使该结构符合<code class="fe ns nt nu nv b">Hashable</code>协议:</p><pre class="kj kk kl km gt ol nv om on aw oo bi"><span id="7249" class="nw lw it nv b gy op oq l or os">struct Person: Hashable {<br/>    var name: String<br/>    var age: Int<br/>}</span></pre><p id="b8fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这样做，可以将<code class="fe ns nt nu nv b">Person</code>添加到集合或字典中。</p><p id="b80e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">精彩！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/e47f34b20113112269a257e5ac0c071a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QdYO4afz2M6aURkzpByWEA.gif"/></div></div></figure><p id="cfe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从Swift 4.1开始就是如此。<code class="fe ns nt nu nv b">Hashable</code>自动合成<code class="fe ns nt nu nv b">hashValue</code>。每次启动应用程序时，Hasher都会生成随机的种子值，从而提供一些安全保护，因为每次执行Swift程序时，生成的哈希值会有所不同。</p><p id="39ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些？太棒了。</p><p id="920a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们想自己实现呢？很明显，就大多数情况下的性能而言，这种合成已经足够好了，但是如果有许多冲突，您可能希望创建自己的方法来符合协议。</p><h2 id="0635" class="nw lw it bd lx nx ny dn mb nz oa dp mf li ob oc mh lm od oe mj lq of og ml oh bi translated">手动符合可散列协议</h2><p id="1955" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">你可能想要手动符合<code class="fe ns nt nu nv b">Hashable</code>。例如，如果您只是想要一个<em class="oi">属性来符合协议。</em></p><p id="7f08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将它放入包含<code class="fe ns nt nu nv b">combine(_:)</code>函数的扩展中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="02e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在上面的<code class="fe ns nt nu nv b">hasher.combine(_:)</code> <strong class="lb iu"> </strong>部分采用了<code class="fe ns nt nu nv b">Hasher</code>结构，并在每次被调用时增加一个值(上面有两次调用)。现在<code class="fe ns nt nu nv b">Hasher</code>结构创建了一个<code class="fe ns nt nu nv b">Integer</code>哈希值。因为您不拥有这个<code class="fe ns nt nu nv b">Hasher</code>，所以您不会使用<code class="fe ns nt nu nv b">finalize()</code>生成最终值，如果您想要创建自己的散列生成器，您会这样做。</p><h2 id="f2bd" class="nw lw it bd lx nx ny dn mb nz oa dp mf li ob oc mh lm od oe mj lq of og ml oh bi translated">创建自己的哈希函数</h2><p id="b560" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">因为一个<code class="fe ns nt nu nv b">Hasher</code>生成一个<code class="fe ns nt nu nv b">Integer</code>哈希值:</p><pre class="kj kk kl km gt ol nv om on aw oo bi"><span id="49fa" class="nw lw it nv b gy op oq l or os">var hasher = Hasher()<br/>hasher.combine(james)<br/>hasher.combine(ahmed)<br/>let hash = hasher.finalize()</span></pre><p id="e6a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu nv b">hash</code>(如果打印)返回值<em class="oi"> -479264489210986059 </em>。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="c88a" class="lv lw it bd lx ly nk ma mb mc nl me mf jz nm ka mh kc nn kd mj kf no kg ml mm bi translated">覆盖NSObject子类上的哈希</h1><p id="2a15" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在Swift中子类化NSObject为您带来了Objective-C运行时的灵活性以及Objective-C的性能，这是因为NSObject是大多数Objective-C对象的根类。</p><p id="befb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着在一些特定的情况下，你可能必须继承NSObject的子类，比如KVO,<code class="fe ns nt nu nv b"><a class="ae ky" href="https://developer.apple.com/documentation/objectivec/nsobject/1412787-addobserver" rel="noopener ugc nofollow" target="_blank">addObserver(_:forKeyPath:options:context:)</a></code>要求观察者是NSObject的子类——这是不可避免的！</p><p id="5146" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在NSObject已经符合Hashable协议，但是如果我们希望覆盖hash怎么办？</p><p id="ffb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个值相等，我们需要重写，并使它完全依赖于我们给定的哈希值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="56fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，像这样将值传递给构造函数是…一个有趣的选择。你需要用不同的方式来计算散列值。</p><p id="f9ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，这意味着你可以设置两个名字和年龄相同的人(这是可能的——而且他们不是同一个人！)</p><pre class="kj kk kl km gt ol nv om on aw oo bi"><span id="2d68" class="nw lw it nv b gy op oq l or os">let testPerson = Person(name: "James", age: 32, hashVal: 5)<br/>let testPerson2 = Person(name: "James", age: 32, hashVal: 4)<br/>(testPerson == testPerson2) // false</span></pre><p id="afce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们可以确定，两个散列相同的人是同一个人，他们应该是同一个人</p><pre class="kj kk kl km gt ol nv om on aw oo bi"><span id="53c7" class="nw lw it nv b gy op oq l or os">let testPerson = Person(name: "James", age: 32, hashVal: 5)<br/>let testPerson2 = Person(name: "James", age: 32, hashVal: 5)<br/>(testPerson == testPerson2) // true</span></pre><p id="211a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">精彩！拿着那个东西！</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="f68f" class="lv lw it bd lx ly nk ma mb mc nl me mf jz nm ka mh kc nn kd mj kf no kg ml mm bi translated">结论</h1><p id="5bd7" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">当我们在集合或字典中存储元素时，我们需要符合<code class="fe ns nt nu nv b">Hashable</code>协议。合成一致性通常适用于大多数情况，但也可以手动符合协议，并选择哪些值将在哈希函数中组合。</p><p id="bb26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您甚至可以选择符合NSObject的类如何生成散列，这意味着您可以控制一切！</p><p id="8845" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能让您了解这是如何工作的，以及您如何在自己的项目中遵循该协议。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="2316" class="lv lw it bd lx ly nk ma mb mc nl me mf jz nm ka mh kc nn kd mj kf no kg ml mm bi translated">扩展你的知识</h1><ul class=""><li id="ee9b" class="mn mo it lb b lc mp lf mq li mr lm ms lq mt lu mu mv mw mx bi translated">维基百科有一篇关于<a class="ae ky" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" rel="noopener ugc nofollow" target="_blank">哈希函数</a>的文章，还有一篇关于<a class="ae ky" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank">哈希表</a>的文章。</li><li id="4d5a" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">苹果有关于<a class="ae ky" href="https://developer.apple.com/documentation/swift/hasher" rel="noopener ugc nofollow" target="_blank">哈希结构</a>的文档。</li></ul></div></div>    
</body>
</html>