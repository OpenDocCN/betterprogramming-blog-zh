<html>
<head>
<title>Tricks for Successfully Using vcpkg in C and C++ Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C和C++项目中成功使用vcpkg的技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/tricks-for-successfully-using-vcpkg-in-c-and-c-projects-b775cc836d81?source=collection_archive---------7-----------------------#2022-06-17">https://betterprogramming.pub/tricks-for-successfully-using-vcpkg-in-c-and-c-projects-b775cc836d81?source=collection_archive---------7-----------------------#2022-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="00d8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何有效地使用vcpkg来管理库依赖项</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fb33678ca99b1ab01cd8e22ec484e966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9rjT05OvkYtNljNr8bY4_Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@purzlbaum?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克劳迪奥·施瓦茨</a>在<a class="ae ky" href="https://unsplash.com/s/photos/package-truck?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="24a9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="f0f0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">今天，现代语言(例如<a class="ae ky" href="https://golang.org" rel="noopener ugc nofollow" target="_blank"> Go </a>)经常提供集成的包管理来提取库的所有依赖项。然而，许多软件是用C/C++创建和维护的，没有现成的包管理器。</p><p id="462f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">将一个软件移植到另一个目标平台(macOS、Windows、Linux)通常非常困难。有帮助的是，有第三方的包管理器。其中一个叫做<a class="ae ky" href="https://vcpkg.io" rel="noopener ugc nofollow" target="_blank"> vcpkg </a>，是微软提供的开源项目。在续集中，我展示了一些技巧，涵盖了vcpkg中的一些困难。</p><p id="62b9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ms">从源代码下载、修补和编译vcpkg中的所有包。所以，当使用大型库时，比如boost、ITK或OpenCV，这需要一些时间！</em></p><h1 id="7da0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">vcpkg入门</h1><p id="3129" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，通过使用<a class="ae ky" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> Git </a>克隆存储库来检查vcpkg的最新版本。除此之外，你还需要一个C++编译器(GCC、MinGW、clang、Visual Studio cl、Xcode)，具体取决于你的平台(参见<a class="ae ky" href="https://vcpkg.io/en/getting-started.html" rel="noopener ugc nofollow" target="_blank">VC pkg</a>入门)和<a class="ae ky" href="https://cmake.org/" rel="noopener ugc nofollow" target="_blank"> CMake </a>。在macOS上，我推荐<a class="ae ky" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">自制</a>的依赖项:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9a1c" class="my la it mu b gy mz na l nb nc">brew install cmake</span></pre><p id="8e97" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在您可以安装vcpkg:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="6153" class="my la it mu b gy mz na l nb nc">git clone https://github.com/Microsoft/vcpkg.git<br/>cd vcpkg<br/>./bootstrap-vcpkg.sh</span></pre><p id="8800" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您想要减小存储库的大小(这样您就不会看到旧的历史)，那么您可以将选项<code class="fe nd ne nf mu b">--depth=1</code>添加到clone命令读数中</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="3d6f" class="my la it mu b gy mz na l nb nc">git clone --depth=1 <a class="ae ky" href="https://github.com/Microsoft/vcpkg.git" rel="noopener ugc nofollow" target="_blank">https://github.com/Microsoft/vcpkg.git</a></span></pre><p id="5b76" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">更新vcpkg现在很容易:调用vcpkg安装路径中的<code class="fe nd ne nf mu b">git pull</code>。但是当你着急的时候，要小心不要那样做。在这一步之后，您的项目和依赖的vcpkg库需要重新编译！</p><p id="0f6c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">建议保持vcpkg安装目录的路径简短并且没有空格(例如，<code class="fe nd ne nf mu b">/opt/vcpkg</code>或<code class="fe nd ne nf mu b">C:\opt\vcpkg</code>)，特别是对于Windows，因为有些包(boost)具有相当深的层次结构。</p><p id="3183" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将在续集中调用vcpkg安装目录<code class="fe nd ne nf mu b">VCPK_ROOT</code>。以下内容将使使用更简单、更便携:</p><ul class=""><li id="685c" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm nl nm nn no bi translated">创建一个指向vcpkg安装目录的环境变量<code class="fe nd ne nf mu b">VCPK_ROOT</code>。</li><li id="c4bb" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">请在您的CMake文件中参考有利于硬编码路径的内容。</li></ul><p id="19f4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">或者，您可以通过以下对CMake的调用来安装CMake: <code class="fe nd ne nf mu b">cmake -B cmake-build -DCMAKE_TOOLCHAIN_FILE=&lt;VCPKG_ROOT&gt;/scripts/buildsystems/vcpkg.cmake</code>。所以你最好使用我提供的<a class="ae ky" href="https://github.com/andremueller/vcpkg-template" rel="noopener ugc nofollow" target="_blank"> vcpkg模板</a>。</p><p id="e921" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后，将vcpkg安装目录添加到您的搜索中<code class="fe nd ne nf mu b">PATH</code>。</p><h1 id="63a7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用vcpkg命令行工具</h1><p id="a35a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用库的最重要的vcpkg命令是:</p><p id="e2f3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nd ne nf mu b">vcpkg help &lt;command&gt;</code>在命令行中显示一些帮助</p><p id="de19" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nd ne nf mu b">vcpkg search</code>用于查找库(称为端口)</p><p id="8977" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nd ne nf mu b">vcpkg install</code>用于安装库</p><p id="68e6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一个例子是:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="18e9" class="my la it mu b gy mz na l nb nc">vcpkg search catch</span></pre><p id="a454" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它返回</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="4bfe" class="my la it mu b gy mz na l nb nc">catch                    alias#1          Deprecated alias for Catch2 unit testing framework<br/>catch-classic            1.12.2#1         A modern, header-only test framework for unit tests<br/>catch2                   3.0.1#1          A modern, header-only test framework for unit testing.<br/>The result may be outdated. Run `git pull` to get the latest results.</span><span id="166f" class="my la it mu b gy nu na l nb nc">If your port is not listed, please open an issue at and/or consider making a pull request:<br/>    <a class="ae ky" href="https://github.com/Microsoft/vcpkg/issues" rel="noopener ugc nofollow" target="_blank">https://github.com/Microsoft/vcpkg/issues</a></span></pre><p id="6d14" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您决定使用<code class="fe nd ne nf mu b">catch2</code>，您可以使用以下命令安装该软件包:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2162" class="my la it mu b gy mz na l nb nc">vcpkg install catch2</span></pre><p id="1f06" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">该库将被编译并安装在您的<code class="fe nd ne nf mu b">VCPKG_ROOT</code>中，从而登陆到<code class="fe nd ne nf mu b">$VCPKG_ROOT/packages/&lt;LIBRARY&gt;_&lt;TRIPLET&gt;</code>中。在安装命令的末尾，会出现一个用法提示:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8c1f" class="my la it mu b gy mz na l nb nc">catch2 provides CMake targets:<br/>    # this is heuristically generated, and may not be correct<br/>    find_package(Catch2 CONFIG REQUIRED)<br/>    target_link_libraries(main PRIVATE Catch2::Catch2 Catch2::Catch2WithMain)</span></pre><p id="24df" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这有时就是问题所在。如果不检查已安装的包，可能会产生误导，并且不清楚哪些CMake目标可以在<code class="fe nd ne nf mu b">target_link_libraries</code>中使用。</p><p id="9299" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">什么是三胞胎？</p><p id="a02c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">三元组反映编译的目标系统(见<a class="ae ky" href="https://github.com/microsoft/vcpkg/blob/master/docs/users/triplets.md" rel="noopener ugc nofollow" target="_blank">三元组文件</a>)。对我来说，是<code class="fe nd ne nf mu b">x64-osx</code>。另一个三元组是例如<code class="fe nd ne nf mu b">x64-windows-static</code>。调用<code class="fe nd ne nf mu b">vcpkg help triplet</code>列出可能的值。</p><p id="e436" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当你对默认的三个一组不满意时，你可以通过在你的CMake文件中指定<code class="fe nd ne nf mu b">VCPKG_TARGET_TRIPLET</code>来控制<code class="fe nd ne nf mu b">vcpkg install</code>将会做什么，或者像这样安装带有<code class="fe nd ne nf mu b">--triplet</code>选项的包(以下内容在macOS上不起作用):</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="44c4" class="my la it mu b gy mz na l nb nc">vcpkg install catch2 --triplet x64-windows</span></pre><p id="8794" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nd ne nf mu b">-static</code>三元组创建了一个库的静态构建版本。</p><h1 id="535c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">安装模式</h1><p id="529c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">安装包有两种不同的模式:在经典模式下，可以通过调用<code class="fe nd ne nf mu b">vcpkg install &lt;port-name&gt;</code>全局安装新的库，如上一节所示。在清单模式下，您需要在项目目录中创建一个<code class="fe nd ne nf mu b">vcpkg.json</code>文件，列出所有依赖项。详见<a class="ae ky" href="https://github.com/microsoft/vcpkg/blob/master/docs/users/manifests.md" rel="noopener ugc nofollow" target="_blank">清单模式</a>。</p><p id="036f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这有一个很大的优势，即项目所需的所有信息都在一个地方，并且在编译项目时会自动下载和安装所需的包。这类似于Go mod文件。以下是我的<a class="ae ky" href="https://github.com/andremueller/vcpkg-template" rel="noopener ugc nofollow" target="_blank"> vcpkg模板</a>中的小<code class="fe nd ne nf mu b">vcpkg.json</code>文件:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="b572" class="my la it mu b gy mz na l nb nc">{<br/>  "name": "vcpkg-template",<br/>  "version-string": "0.0.1",<br/>  "dependencies": ["catch2"]<br/>}</span></pre><h1 id="8476" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">清理库</h1><p id="f6db" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在当你通过调用<code class="fe nd ne nf mu b">git clean -dxf</code>清理<code class="fe nd ne nf mu b">VCPKG_ROOT</code>目录时，所有安装的库和下载的文件都将消失，需要重新安装。除此之外，在我的系统(macOS)上，vcpkg在<code class="fe nd ne nf mu b">$HOME/.cache/vcpkg</code>下创建缓存文件，必须删除这些文件才能进行清理。</p><p id="f4cd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在清单模式下，清理项目目录也会移除所有已安装的库。所以在下一个版本中，一切都将被重新编译。</p><h1 id="b6f0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">控制vcpkg版本</h1><p id="b80f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">可以使用CMake变量控制vcpkg的行为，这些变量可以是:</p><ul class=""><li id="1972" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm nl nm nn no bi translated">在<code class="fe nd ne nf mu b">CMakelists.txt</code>文件中设置(在<code class="fe nd ne nf mu b">project()</code>子句之前)或</li><li id="669b" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">在命令行上用<code class="fe nd ne nf mu b">cmake -D &lt;VARIABLE&gt;=&lt;VALUE&gt;</code>定义，或者</li><li id="f471" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">像<code class="fe nd ne nf mu b">&lt;VARIABLE&gt;=&lt;VALUE&gt; make -C</code>一样设置为环境变量</li></ul><p id="5177" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以下变量对于目标架构和链接过程(静态或动态)是最重要的:<code class="fe nd ne nf mu b">VCPKG_TARGET_TRIPLET</code> -控制构建的目标，例如<code class="fe nd ne nf mu b">x64-windows-static</code>更多信息请参见<a class="ae ky" href="https://github.com/microsoft/vcpkg/blob/master/docs/users/buildsystems/cmake-integration.md" rel="noopener ugc nofollow" target="_blank"> CMake Integration </a>。</p><h1 id="3758" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">包装的五个维度</h1><p id="96d6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在vcpkg中，使用库需要知道不同的名称。这并不总是简单的，需要一点搜索！</p><p id="9b43" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以有:</p><p id="a609" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">1.<code class="fe nd ne nf mu b">vcpkg.json</code>依赖部分或<code class="fe nd ne nf mu b">vcpkg install &lt;PORT&gt;</code>命令中的vcpkg端口名称字段:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="e007" class="my la it mu b gy mz na l nb nc">{  <br/>    "dependencies": [ "boost-asio" ]<br/>}</span></pre><p id="894a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意，端口名不得包含除<code class="fe nd ne nf mu b">[a-zA-Z]</code>和破折号<code class="fe nd ne nf mu b">-</code>之外的其他字符。</p><p id="fd2e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">2.在<code class="fe nd ne nf mu b">vcpkg.json</code>中选择的特征看起来像这样:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="cc9e" class="my la it mu b gy mz na l nb nc">{<br/>    "dependencies": [<br/>        {  <br/>         "name": "opencv",  <br/>         "features": [ "png" ]<br/>        }<br/>    ]<br/>}</span></pre><p id="dc90" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">3.由<code class="fe nd ne nf mu b">find_package(&lt;PKG&gt; REQUIRED)</code>找到的CMake包名</p><p id="7aef" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">4.<code class="fe nd ne nf mu b">find_package(&lt;PKG&gt; REQUIRED COMPONENTS &lt;COMP1&gt; &lt;COMP2&gt;)</code>中的CMake组件名</p><p id="50e8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">5.<code class="fe nd ne nf mu b">target_link_library(myApp PRIVATE &lt;DEP1&gt; &lt;DEP2&gt;</code>依赖目标名称。除此之外有时还必须设置<code class="fe nd ne nf mu b">target_include_directories()</code>！</p><p id="0138" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这种差异的一个例子是以下情况:</p><ul class=""><li id="17f0" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm nl nm nn no bi translated">vcpkg端口名:<code class="fe nd ne nf mu b">boost-asio</code></li><li id="45cb" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">CMake包名:<code class="fe nd ne nf mu b">find_package(boost_asio CONFIG REQUIRED)</code> -要为链接<code class="fe nd ne nf mu b">target_link_library(myApp PRIVATE Boost::asio)</code>找到的目标别名<code class="fe nd ne nf mu b">Boost::asio</code>。谷歌后，你发现你可能需要与<code class="fe nd ne nf mu b">${Boost_LIBRARIES}</code>链接，这不是来自于增强端口使用帮助。</li></ul><p id="3c4a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当CMake运行时，一些软件包会发送或多或少有用的消息，试图支持用户如何像这样包含特定的库:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="0ab4" class="my la it mu b gy mz na l nb nc">The package boost is compatible with built-in CMake targets:</span><span id="92f8" class="my la it mu b gy nu na l nb nc">    find_package(Boost REQUIRED [COMPONENTS &lt;libs&gt;...])<br/>    target_link_libraries(main PRIVATE Boost::boost Boost::&lt;lib1&gt; Boost::&lt;lib2&gt; ...)</span></pre><p id="3915" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是你不会轻易找到目标的名字！有趣的是，您会在<code class="fe nd ne nf mu b">ports</code>目录中找到一个用法文件，它显示了<code class="fe nd ne nf mu b">target_link_libraries()</code>的正确方法。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="893d" class="my la it mu b gy mz na l nb nc">/opt/vcpkg/ports/boost&gt; cat usage<br/>The package boost is compatible with built-in CMake targets:<br/><br/>    find_package(Boost REQUIRED [COMPONENTS &lt;libs&gt;...])<br/>    target_link_libraries(main PRIVATE ${Boost_LIBRARIES})<br/>    target_include_directories(main PRIVATE ${Boost_INCLUDE_DIRS})</span><span id="ad55" class="my la it mu b gy nu na l nb nc">    find_package(Boost REQUIRED [COMPONENTS &lt;libs&gt;...])<br/>    target_link_libraries(main PRIVATE ${Boost_LIBRARIES})<br/>    target_include_directories(main PRIVATE ${Boost_INCLUDE_DIRS})</span></pre><p id="aa8a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">还有另一篇很好的文章(参见<a class="ae ky" href="https://izzys.casa/2020/12/how-to-find-packages-with-cmake-the-basics/" rel="noopener ugc nofollow" target="_blank">如何使用CMake查找包:基础知识</a>)解决了在没有vcpkg的情况下在CMake中查找包的一般问题。一件事是检查vcpkg安装目录中的<code class="fe nd ne nf mu b">Find&lt;Package&gt;.cmake</code>文件。</p><p id="485a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，boost库中的CMake文件要比这复杂得多。这些包并不都是同质和简单的。好的一面是，所有具有良好的本地CMake支持的包通常更容易添加。一个例子是用于JSON流的伟大的<code class="fe nd ne nf mu b">nlohmann-json</code>库。</p><p id="5f84" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里安装后的用法打印非常有用:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="275a" class="my la it mu b gy mz na l nb nc">The package nlohmann-json provides CMake targets:<br/><br/>    find_package(nlohmann_json CONFIG REQUIRED)<br/>    target_link_libraries(main PRIVATE nlohmann_json::nlohmann_json)<br/><br/>The package nlohmann-json can be configured to not provide implicit conversions via a custom triplet file:<br/><br/>    set(nlohmann-json_IMPLICIT_CONVERSIONS OFF)<br/><br/>For more information, see the docs here:<br/><br/>    <a class="ae ky" href="https://json.nlohmann.me/features/macros/#json_use_implicit_conversions" rel="noopener ugc nofollow" target="_blank">https://json.nlohmann.me/features/macros/#json_use_implicit_conversions</a></span></pre><h1 id="e2ef" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">信息来源</h1><p id="8361" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">所以问题是:</p><blockquote class="nv"><p id="c67c" class="nw nx it bd ny nz oa ob oc od oe mm dk translated">我从哪里得到这些名字的？</p></blockquote><p id="591f" class="pw-post-body-paragraph lr ls it lt b lu of ju lw lx og jx lz ma oh mc md me oi mg mh mi oj mk ml mm im bi translated">端口名可以在网上找到<a class="ae ky" href="https://vcpkg.io/en/packages.html" rel="noopener ugc nofollow" target="_blank">https://vcpkg.io/en/packages.html</a>或者更好的<a class="ae ky" href="https://vcpkg.info/" rel="noopener ugc nofollow" target="_blank">https://vcpkg.info/</a>，或者使用vcpkg命令行实用程序<code class="fe nd ne nf mu b">vcpkg search &lt;name&gt;</code>。一旦安装了端口<code class="fe nd ne nf mu b">&lt;PORT&gt;</code>(我们假设您使用<code class="fe nd ne nf mu b">vcpkg install</code>全局安装了它)，您需要检查<code class="fe nd ne nf mu b">$VCPKG_ROOT/ports/&lt;PORT&gt;/portfile.cmake</code>文件，就像下面的<code class="fe nd ne nf mu b">boost-asio</code>文件一样:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="1c81" class="my la it mu b gy mz na l nb nc"># Automatically generated by scripts/boost/generate-ports.ps1<br/><br/>vcpkg_from_github(<br/>    OUT_SOURCE_PATH SOURCE_PATH<br/>    REPO boostorg/asio<br/>    REF boost-1.78.0<br/>    SHA512 78c58a64d669eaeabb5ba003200c581065412d33912e641143186ee95c11e0fb0411ed8dbb9a9acced8c8ecd258e0de33872b2e22dfc4a572315cd9a665db8a6<br/>    HEAD_REF master<br/>    PATCHES windows_alloca_header.patch<br/>)<br/><br/>include(${CURRENT_INSTALLED_DIR}/share/boost-vcpkg-helpers/boost-modular-headers.cmake)<br/>boost_modular_headers(SOURCE_PATH ${SOURCE_PATH})</span></pre><p id="238f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">除了查找可能的特性名称，您还可以查看这个包的<code class="fe nd ne nf mu b">$VCPKG_ROOT/ports/&lt;PORT&gt;/vcpkg.json</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="4305" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">出于好奇，您可以通过调用以下命令列出<code class="fe nd ne nf mu b">boost-asio</code>的所有依赖项:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8799" class="my la it mu b gy mz na l nb nc">vcpkg depend-info boost-asio</span></pre><h1 id="832c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">默认功能</h1><p id="76ea" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当在<code class="fe nd ne nf mu b">vcpkg.json</code>中仅指定端口名称时，安装的功能是所谓的默认功能。可通过设置<code class="fe nd ne nf mu b">dependencies</code>部分的<code class="fe nd ne nf mu b">vcpkg.json</code>文件中的<code class="fe nd ne nf mu b">"default-features": false</code>选项来禁用此行为。因此，<code class="fe nd ne nf mu b">vcpkg.json</code>文件可能是这样的:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="5e55" class="my la it mu b gy mz na l nb nc">{<br/>  "name": "vcpkg-template",<br/>  "version-string": "0.0.1",<br/>  "dependencies": [<br/>    {<br/>        "name": "boost",<br/>        "default-features": false<br/>    }<br/>  ]<br/>}</span></pre><p id="0a63" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">参见<a class="ae ky" href="https://vcpkg.readthedocs.io/en/latest/users/selecting-library-features/" rel="noopener ugc nofollow" target="_blank">https://VC pkg . readthedocs . io/en/latest/users/selecting-library-features/</a>。</p><h1 id="4e14" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="349c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我给出了一个使用vcpkg的简短调查，并提供了一些提示和技巧。vcpkg的用法并不总是那么简单。我为新项目创建了一个小的vcpkg模板。</p><p id="3d03" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以在GitHub 上检查并重用我的<a class="ae ky" href="https://github.com/andremueller/vcpkg-template" rel="noopener ugc nofollow" target="_blank"> vcpkg模板，以获得C++项目的基本布局。所以，只要<code class="fe nd ne nf mu b">git clone https://github.com/andremueller/vcpkg-template</code>就出发了。</a></p><p id="2ede" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另一个有趣的主题是vcpkg的版本支持(参见<a class="ae ky" href="https://devblogs.microsoft.com/cppblog/take-control-of-your-vcpkg-dependencies-with-versioning-support/" rel="noopener ugc nofollow" target="_blank">通过版本支持控制你的vcpkg依赖关系</a>)。还有vcpkg的替代品比如<a class="ae ky" href="https://conan.io/" rel="noopener ugc nofollow" target="_blank">柯南</a>或者<a class="ae ky" href="https://build2.org/" rel="noopener ugc nofollow" target="_blank"> build2 </a>。</p></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><p id="9f79" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">感谢阅读。敬请期待更多。</p></div></div>    
</body>
</html>