<html>
<head>
<title>How to Use UICalendarView in iOS 16</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在iOS 16中使用UICalendarView</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/uicalendarview-tutorial-593731e52b72?source=collection_archive---------2-----------------------#2022-06-12">https://betterprogramming.pub/uicalendarview-tutorial-593731e52b72?source=collection_archive---------2-----------------------#2022-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7851" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">UICalendarView教程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/780cd138d0c4aac2b077863befcf04b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*e-y3di4TnowjjneG.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">UICalendarView</p></figure><p id="e8d7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在WWDC 22上，苹果宣布了新的UIKit控件。在本教程中，我们将深入研究最有用和最通用的组件之一- <code class="fe lr ls lt lu b">UICalendarView</code>。</p><h1 id="a480" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">什么是UICalendarView</h1><p id="36cf" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated"><code class="fe lr ls lt lu b">UIDatePicker</code>的内嵌日期选择器组件现在可以作为一个单独的组件使用了。</p><p id="6e79" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">日历视图用于向用户显示特定的日期以及这些特定日期的附加信息和装饰。</p><p id="b35c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，在日历应用程序中，有事件的日期会在日期下方标上一个粉红色的圆点。日历视图也可以用于选择一个或多个日期，或者根本不选择日期。</p><p id="2c81" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过<code class="fe lr ls lt lu b">UICalendarView</code>，你可以预设日期，禁止某些日期被选中，等等。</p><h1 id="c14e" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">它与UIDatePicker有何不同？</h1><p id="2cfe" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated"><code class="fe lr ls lt lu b">UIDatePicker</code>允许用户选择一个时间点。此选择是单一的，不能用于选择一个范围或多个日期。</p><p id="e9e3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您希望从用户那里获得关于特定时间点的输入，比如必须注册事务的日期，那么仍然必须使用日期选择器。</p><p id="3600" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">日历视图仅用于显示和选择日期。如果您想处理日期和时间选择，请使用<code class="fe lr ls lt lu b">UIDatePicker</code>。</p><h1 id="45bf" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">考虑</h1><ul class=""><li id="fd62" class="ms mt iq kx b ky mn lb mo le mu li mv lm mw lq mx my mz na bi translated"><code class="fe lr ls lt lu b">UICalendarView</code>和<code class="fe lr ls lt lu b">UIDatePicker</code>的一个重要区别是<code class="fe lr ls lt lu b">UICalendarView</code>用<code class="fe lr ls lt lu b">NSDateComponents</code>表示日期，而<code class="fe lr ls lt lu b">UIDatePicker</code>用<code class="fe lr ls lt lu b">NSDate</code>表示特定的时间点。</li><li id="4386" class="ms mt iq kx b ky nb lb nc le nd li ne lm nf lq mx my mz na bi translated">由于<code class="fe lr ls lt lu b">UICalendarView</code>的日期由<code class="fe lr ls lt lu b">NSDateComponents</code>表示，我们有责任明确我们想要使用的当前日历。我们不能假设，比如默认会设置公历。<code class="fe lr ls lt lu b">UICalendarView</code>如果没有明确传递日历，将根据用户当前设置的日历，用系统默认日历配置自身。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/732457d372ef16d942c1226ac082fda7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KokzVFRCdN_aqY-R.png"/></div></div></figure><p id="2624" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里，我们可以看到可用日历的列表。我们必须明确我们想用哪个日历来输入。</p><h1 id="a1e0" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">入门指南</h1><p id="a059" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">为了创建一个日历视图，我们创建一个<code class="fe lr ls lt lu b">UICalendarView</code>的实例并设置它的日历。然后，我们可以使用自动布局约束将其添加到视图中。</p><pre class="kg kh ki kj gt nh lu ni nj aw nk bi"><span id="9f7a" class="nl lw iq lu b gy nm nn l no np">let calendarView = UICalendarView()<br/>calendarView.calendar = Calendar(identifier: .gregorian)<br/>calendarView.translatesAutoresizingMaskIntoConstraints = false<br/>view.addSubview(calendarView)<br/>NSLayoutConstraint.activate([<br/>    calendarView.leadingAnchor.constraint(equalTo: view.leadingAnchor),<br/>    calendarView.trailingAnchor.constraint(equalTo: view.trailingAnchor),<br/>    calendarView.centerXAnchor.constraint(equalTo: view.centerXAnchor)<br/>])</span></pre><h1 id="b943" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">设置日期范围</h1><p id="fd3c" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated"><code class="fe lr ls lt lu b">UICalendarView</code>有设置可见日期范围的方法。</p><p id="77a1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该范围集也可以被动画化以显示响应于用户输入或运行时条件变化的变化。</p><p id="bf9e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">若要设置可见的日期组件，请使用此方法</p><pre class="kg kh ki kj gt nh lu ni nj aw nk bi"><span id="8257" class="nl lw iq lu b gy nm nn l no np">func setVisibleDateComponents(<br/>    _ dateComponents: DateComponents,<br/>    animated: Bool<br/>)<br/><em class="nq">// calendarView.setVisibileDateComponents(..., animated: true)</em></span></pre><blockquote class="nr ns nt"><p id="b565" class="kv kw nq kx b ky kz jr la lb lc ju ld nu lf lg lh nv lj lk ll nw ln lo lp lq ij bi translated">如果提供的日期部分与<code class="fe lr ls lt lu b">UICalendarView</code>不在同一个日历中，输入的日期部分将被转换为使用<code class="fe lr ls lt lu b">UICalendarView.calendar</code>。这可能会导致日期不匹配，并且如果两个日历系统的日期不同，可能会导致日期无效。</p></blockquote><h1 id="1a64" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">处理日期选择</h1><p id="000f" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">我们可以在日历视图上设置一个选择行为属性来定义它将接受哪种类型的输入。我们可以用单选和多选来配置它。在本例中，我们设置了一个多日期选择。</p><pre class="kg kh ki kj gt nh lu ni nj aw nk bi"><span id="73ed" class="nl lw iq lu b gy nm nn l no np">let multiDateSelection = UICalendarSelectionMultiDate(delegate: self)</span></pre><p id="c34e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还有另一种选择方法叫做<code class="fe lr ls lt lu b">UICalendarSelectionSingleDate</code>,仅用于选择单个日期。</p><p id="e7a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">UICalendarSelectionMultiDate</code>的委托人必须符合<code class="fe lr ls lt lu b">UICalendarSelectionMultiDateDelegate</code>。该委托有2个必需方法和2个可选方法。</p><h1 id="9a5b" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">必需的方法</h1><ul class=""><li id="b35a" class="ms mt iq kx b ky mn lb mo le mu li mv lm mw lq mx my mz na bi translated">第一个方法是<code class="fe lr ls lt lu b">didSelectDate</code>，它的函数签名如下所示。</li></ul><pre class="kg kh ki kj gt nh lu ni nj aw nk bi"><span id="d11f" class="nl lw iq lu b gy nm nn l no np">func multiDateSelection(_ selection: UICalendarSelectionMultiDate, didSelectDate dateComponents: DateComponents)</span></pre><p id="51fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用户在日历视图中选择日期后，将调用此方法。</p><ul class=""><li id="1c4e" class="ms mt iq kx b ky kz lb lc le nx li ny lm nz lq mx my mz na bi translated">另一个必需的方法是<code class="fe lr ls lt lu b">didDeselectDate</code>，它的函数签名如下所示。</li></ul><pre class="kg kh ki kj gt nh lu ni nj aw nk bi"><span id="a70f" class="nl lw iq lu b gy nm nn l no np">func multiDateSelection(_ selection: UICalendarSelectionMultiDate, didDeselectDate dateComponents: DateComponents)</span></pre><p id="4f7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当用户从日历视图中的一个选定日期中移除选择后，调用此方法。</p><h2 id="a4f7" class="nl lw iq bd lx oa ob dn mb oc od dp mf le oe of mh li og oh mj lm oi oj ml ok bi translated">可选方法</h2><ul class=""><li id="a6e1" class="ms mt iq kx b ky mn lb mo le mu li mv lm mw lq mx my mz na bi translated">第一个可选的方法是<code class="fe lr ls lt lu b">canSelectDate</code>。</li></ul><pre class="kg kh ki kj gt nh lu ni nj aw nk bi"><span id="9882" class="nl lw iq lu b gy nm nn l no np">optional func multiDateSelection(_ selection: UICalendarSelectionMultiDate, canSelectDate dateComponents: DateComponents) -&gt; Bool</span></pre><p id="74f6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该调用确定日期是否可选。日历视图中将禁用不可选择的日期。</p><ul class=""><li id="a623" class="ms mt iq kx b ky kz lb lc le nx li ny lm nz lq mx my mz na bi translated">第二个可选的委托方法是<code class="fe lr ls lt lu b">canDeselectDate</code>。</li></ul><pre class="kg kh ki kj gt nh lu ni nj aw nk bi"><span id="3b40" class="nl lw iq lu b gy nm nn l no np">optional func multiDateSelection(_ selection: UICalendarSelectionMultiDate, canDeselectDate dateComponents: DateComponents) -&gt; Bool</span></pre><p id="7309" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此调用确定是否可以取消选择日期。</p><h1 id="9c95" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">定制</h1><p id="e2ec" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated"><code class="fe lr ls lt lu b">UICalendarView</code>让我们为日期提供装饰，类似于您在系统日历应用程序中看到的内容。这个组件有一个默认设置为true的<code class="fe lr ls lt lu b">wantsDateDecorations</code>。</p><p id="4651" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，您必须实现委托方法来提供这些装饰。这就是我们将在这一小节中探讨的内容。将<code class="fe lr ls lt lu b">calendarView</code>的代理设置为<code class="fe lr ls lt lu b">self</code>并将您的视图控制器设置为<code class="fe lr ls lt lu b">UICalendarViewDelegate</code>。</p><pre class="kg kh ki kj gt nh lu ni nj aw nk bi"><span id="c3eb" class="nl lw iq lu b gy nm nn l no np">calendarView.delegate = self</span><span id="8ab3" class="nl lw iq lu b gy ol nn l no np">extension ViewController: UICalendarViewDelegate {}</span></pre><p id="9318" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种一致性要求我们实现一个必需的方法。</p><pre class="kg kh ki kj gt nh lu ni nj aw nk bi"><span id="b8b2" class="nl lw iq lu b gy nm nn l no np">func calendarView(_ calendarView: UICalendarView, decorationFor dateComponents: DateComponents) -&gt; UICalendarView.Decoration?</span></pre><h1 id="651b" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">UICalendarView。装饰</h1><p id="dc65" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">装饰有三种不同的类型。常规、图像和自定义视图。</p><h2 id="7889" class="nl lw iq bd lx oa ob dn mb oc od dp mf le oe of mh li og oh mj lm oi oj ml ok bi translated">规则的</h2><p id="e8ec" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">默认<code class="fe lr ls lt lu b">init()</code>创建一个带有圆形图像的默认装饰，如系统日历应用中所示。</p><h2 id="b58b" class="nl lw iq bd lx oa ob dn mb oc od dp mf le oe of mh li og oh mj lm oi oj ml ok bi translated">带图像</h2><p id="ca54" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">这个初始化器接受一个<code class="fe lr ls lt lu b">UIImage</code>、一个<code class="fe lr ls lt lu b">UIColor</code>和一个<code class="fe lr ls lt lu b">UICalendarViewDecorationSize</code>，并用指定的图像、颜色和大小创建一个新的基于图像的装饰。</p><ul class=""><li id="a2cd" class="ms mt iq kx b ky kz lb lc le nx li ny lm nz lq mx my mz na bi translated">如果没有图像被显式传递，则<code class="fe lr ls lt lu b">image</code>默认为<code class="fe lr ls lt lu b">circlebadge.fil</code>。</li><li id="d6e1" class="ms mt iq kx b ky nb lb nc le nd li ne lm nf lq mx my mz na bi translated">如果没有显式传递颜色，则<code class="fe lr ls lt lu b">color</code>默认为<code class="fe lr ls lt lu b">UIColor.systemFillColor</code>。</li><li id="acf6" class="ms mt iq kx b ky nb lb nc le nd li ne lm nf lq mx my mz na bi translated">如果没有显式传递大小，<code class="fe lr ls lt lu b">size</code>默认为<code class="fe lr ls lt lu b">UICalendarViewDecorationSizeMedium</code>。</li></ul><h2 id="e3bf" class="nl lw iq bd lx oa ob dn mb oc od dp mf le oe of mh li og oh mj lm oi oj ml ok bi translated">使用自定义视图</h2><p id="bdf9" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">苹果文档很好地解释了这一点。</p><blockquote class="nr ns nt"><p id="07f3" class="kv kw nq kx b ky kz jr la lb lc ju ld nu lf lg lh nv lj lk ll nw ln lo lp lq ij bi translated">使用提供的视图提供程序创建新的自定义视图装饰。当首次加载装饰视图时，将调用该提供程序一次。装饰将被剪切到其父级的边界，并且不能进行交互。</p></blockquote><p id="6737" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个初始化器接受一个<code class="fe lr ls lt lu b">UIView</code>并将它设置为日历的日期装饰，服从前面提到的限制。</p><p id="93c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">UICalendarView.DecorationSize</code>是表示装饰项目的可用尺寸的枚举。</p><pre class="kg kh ki kj gt nh lu ni nj aw nk bi"><span id="d156" class="nl lw iq lu b gy nm nn l no np">UICalendarViewDecorationSizeSmall = 0,<br/>UICalendarViewDecorationSizeMedium = 1,<br/>UICalendarViewDecorationSizeLarge = 2,</span></pre><p id="2df0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要设置装饰视图，只需在委托方法中提供所需的装饰。比如说。来自2022年WWDC的<code class="fe lr ls lt lu b">What’s New in UIKit</code>会议:</p><pre class="kg kh ki kj gt nh lu ni nj aw nk bi"><span id="8951" class="nl lw iq lu b gy nm nn l no np"><em class="nq">// Configuring Decorations</em><br/>func calendarView(<br/>    _ calendarView: UICalendarView,<br/>    decorationFor dateComponents: DateComponents<br/>) -&gt; UICalendarView.Decoration? {<br/>    switch myDatabase.eventType(on: dateComponents) {<br/>    case .none:<br/>        return nil<br/>    case .busy:<br/>        return .default()<br/>    case .travel:<br/>        return .image(airplaneImage, color: .systemOrange)<br/>    case .party:<br/>        return .customView {<br/>            MyPartyEmojiLabel()<br/>        }<br/>    }<br/>}</span></pre><p id="5e84" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以通过调用<code class="fe lr ls lt lu b">reloadDecorations(forDateComponents:animated:)</code>方法在运行时重新加载装饰。</p><p id="0565" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它接受一个数组<code class="fe lr ls lt lu b">DateComponents</code>,表示装饰必须重新加载的日期。您甚至可以选择将这些变化制作成动画。</p><h1 id="df47" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">结论</h1><p id="32d3" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">与<code class="fe lr ls lt lu b">UIDatePicker</code>提供的单个时间点相比，新的<code class="fe lr ls lt lu b">UICalendarView</code>是选择单个和多个日期的强大组件。这两个组件有它们自己的用例，不应该被视为任何一个的替代品。</p><p id="e0d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您想要选择一个时间点时，使用<code class="fe lr ls lt lu b">UIDatePicker</code>。当您想要选择一个日期或一系列日期时，请使用新的日历视图。日历视图接受<code class="fe lr ls lt lu b">DateComponents</code>，而日期选择器接受<code class="fe lr ls lt lu b">NSDate</code>。</p><p id="b0ae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢您的阅读！</p></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt nh lu ni nj aw nk bi"><span id="9f9c" class="nl lw iq lu b gy nm nn l no np"><strong class="lu ir">Want to Connect?</strong></span><span id="197e" class="nl lw iq lu b gy ol nn l no np"><a class="ae ot" href="https://www.buymeacoffee.com/swapnanildhol" rel="noopener ugc nofollow" target="_blank">I</a>f you liked this article, consider<a class="ae ot" href="https://www.buymeacoffee.com/swapnanildhol" rel="noopener ugc nofollow" target="_blank"> buying me a coffee to reward my efforts</a>. You can also choose to <a class="ae ot" href="https://github.com/sponsors/SwapnanilDhol" rel="noopener ugc nofollow" target="_blank">sponsor me on Github</a>. With Github sponsors, you can request various services such as pair programming, code reviews, consultancy, and more!</span></pre></div></div>    
</body>
</html>