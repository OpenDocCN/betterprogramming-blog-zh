<html>
<head>
<title>JavaScript Generators — Practical Use Cases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript生成器——实际用例</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-generators-practical-use-cases-945d512ef252?source=collection_archive---------0-----------------------#2021-05-19">https://betterprogramming.pub/javascript-generators-practical-use-cases-945d512ef252?source=collection_archive---------0-----------------------#2021-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df41" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么是发电机？它能有什么帮助？发电机有具体和实际的用例吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/131da63ec903b84dc9b5413549df96b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S0k6nvwXDbkZdVJI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="c3d8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">JavaScript中的函数类型</h1><h2 id="a5f1" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">运行至完成功能</h2><p id="27d2" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">让我们来看看这个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4dd6" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">一旦被调用，这个函数将运行到最后一行:一个不可停止的或运行到完成的函数。执行上下文将在完成后释放。</p><p id="1293" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">从运行到完成的功能是关于现在的:我们需要马上得到结果。</p><p id="5fe2" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">如果<code class="fe ng nh ni nj b">operation1</code>的执行时间很长怎么办？由于JavaScript是一个单线程，所有进一步的处理都将被阻塞，直到<code class="fe ng nh ni nj b">operation1</code>完成它的计算。</p><p id="879f" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">我们能做得更好吗？是的，让我们看看。</p><h2 id="65bc" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">异步函数</h2><p id="a8f6" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">考虑下面的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c560" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">让我们了解一下发生了什么:</p><ul class=""><li id="a2bf" class="nk nl it mi b mj nb mm nc lw nm lz nn mc no my np nq nr ns bi translated"><code class="fe ng nh ni nj b">async/await</code>返回一个<code class="fe ng nh ni nj b">Promise</code>。</li><li id="6cd5" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated"><code class="fe ng nh ni nj b">doOperations</code>是一个异步函数。</li><li id="4f11" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">我们现在不等待结果，而是等待未来。</li><li id="0e95" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">我们直接前进到剩余的处理。</li><li id="39e3" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">一旦<code class="fe ng nh ni nj b">doOperations</code>完成执行，将执行<code class="fe ng nh ni nj b">then</code>或<code class="fe ng nh ni nj b">catch</code>块。</li></ul><p id="a209" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">异步函数是关于未来的:当结果可用时，我们需要它，而不阻塞主线程的执行。</p><p id="5830" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">主线程通过<code class="fe ng nh ni nj b">then</code>和<code class="fe ng nh ni nj b">catch</code>信号与异步代码通信。这就好像主线程已经订阅了<code class="fe ng nh ni nj b">doOperations</code>事件。一旦被通知，主线程将永远不会被挂起，但是<code class="fe ng nh ni nj b">then</code>或<code class="fe ng nh ni nj b">catch</code>块将被添加到当前任务列表的底部。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/899d9b0b3314ada7e817e164deff7364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ilpfCqPBE45jSiAWOfI6Yw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JS执行运行时(图片由作者提供)</p></figure><p id="e856" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">好吧，这不是魔术，这就是JavaScript执行异步代码的方式。</p><p id="cc1e" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">神奇的事情发生在这一行:<code class="fe ng nh ni nj b">const operation1 = await doLongOperation(x + y);</code>。让我们再次看看执行步骤:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="9f3a" class="lr la it nj b gy od oe l of og">1. "Lets resolve the operation"<br/>2. "Lets continue others staff"<br/>3. "operation1 : ", 5<br/>4. "operation2 : ", 3<br/>5. "operation3 : ", 17<br/>6. "value : ", 17</span></pre><p id="46bb" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated"><code class="fe ng nh ni nj b">operation2</code>直到<code class="fe ng nh ni nj b">operation1</code>解决后才执行。这是不寻常的。A <code class="fe ng nh ni nj b">Promise</code>一般代表未来，但这里是现在(马上解决或拒绝)。</p><p id="a414" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">怎么会这样？怎样才能暂停函数执行？挂起只针对异步代码吗？</p><p id="b318" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">显然关键字<code class="fe ng nh ni nj b">await</code>有一些内在的魔力。让我们深入探讨一下。</p><blockquote class="oh oi oj"><p id="19b8" class="mg mh ok mi b mj nb ju ml mm nc jx mo ol nd mq mr om ne mt mu on nf mw mx my im bi translated">"异步函数本质上是生成器上的糖，所以它们属于同一类."— <a class="ae ky" href="https://v8.dev/blog/high-performance-es2015" rel="noopener ugc nofollow" target="_blank">高性能ES2015及以后</a></p></blockquote><p id="7c59" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">什么是发电机？他们有什么特别的？</p><h2 id="8c64" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">发电机功能</h2><p id="bc60" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">考虑下面的函数:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="ae04" class="lr la it nj b gy od oe l of og"><strong class="nj iu">function*</strong> doOperations() {<br/>  <strong class="nj iu">yield</strong> 2;<br/>  yield 3;<br/>  yield 4;<br/>}</span><span id="d285" class="lr la it nj b gy oo oe l of og">doOperations();</span></pre><p id="438d" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">调用<code class="fe ng nh ni nj b">doOperations()</code>没有任何作用。为什么？</p><p id="6e2e" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated"><code class="fe ng nh ni nj b">doOperations</code>现在是一个特殊的函数，因为神奇的<code class="fe ng nh ni nj b">*</code>，它发出特殊的生成器函数类型的信号。</p><p id="fda6" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">那么，如何执行生成器呢？</p><p id="81d7" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">为了推动函数执行，我们必须调用<code class="fe ng nh ni nj b">next</code>:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="d09f" class="lr la it nj b gy od oe l of og">const operations = doOperations();</span><span id="07b0" class="lr la it nj b gy oo oe l of og"><strong class="nj iu">// "operations : ", [object Generator] { ... }</strong><br/>console.log('operations : ', operations);</span><span id="bd8e" class="lr la it nj b gy oo oe l of og">/*<br/>"next : ", {<br/>  done: false,<br/>  value: 2<br/>}<br/>*/<br/><strong class="nj iu">console.log('next : ', operations.next());</strong></span><span id="721a" class="lr la it nj b gy oo oe l of og">/*<br/>"next : ", {<br/>  done: false,<br/>  value: 3<br/>}<br/>*/<br/><strong class="nj iu">console.log('next : ', operations.next());</strong></span><span id="6a8a" class="lr la it nj b gy oo oe l of og">/*<br/>"next : ", {<br/>  done: false,<br/>  value: 4<br/>}<br/>*/<br/><strong class="nj iu">console.log('next : ', operations.next());</strong></span><span id="3b2d" class="lr la it nj b gy oo oe l of og">/*<br/>"next : ", {<br/>  done: true,<br/>  value: undefined<br/>}<br/>*/<br/><strong class="nj iu">console.log('next : ', operations.next());</strong></span></pre><ul class=""><li id="ff55" class="nk nl it mi b mj nb mm nc lw nm lz nn mc no my np nq nr ns bi translated">第一次调用<code class="fe ng nh ni nj b">doOperations</code>会给出一个<code class="fe ng nh ni nj b">Generator object</code>。</li><li id="f511" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">每次我们调用<code class="fe ng nh ni nj b">next</code>，我们都会得到一个对象<code class="fe ng nh ni nj b">{ done: true|false, value: number| undefined }</code>。</li><li id="95a7" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated"><code class="fe ng nh ni nj b">next</code>和<code class="fe ng nh ni nj b">yield</code>允许作为调试器逐行运行函数。</li></ul><p id="d610" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">让我们更深入地探讨一下:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="6262" class="lr la it nj b gy od oe l of og">function* doOperations() {<br/>  console.log('1');<br/> <strong class="nj iu"> yield 2;</strong><br/>  console.log('2');<br/>  <strong class="nj iu">yield 3;</strong><br/>  console.log('3');<br/>  <strong class="nj iu">yield 4;</strong><br/>  console.log('4');<br/>}</span><span id="c262" class="lr la it nj b gy oo oe l of og">const operations = doOperations();</span><span id="60f1" class="lr la it nj b gy oo oe l of og">/*<br/>"1"<br/>"next : ", { done: false, value: 2 }<br/>*/<br/>console.log('next : ', operations.next());</span></pre><ul class=""><li id="7e5f" class="nk nl it mi b mj nb mm nc lw nm lz nn mc no my np nq nr ns bi translated">调用第一个<code class="fe ng nh ni nj b">next</code>，该功能一直执行到遇到<code class="fe ng nh ni nj b">yield</code>。</li><li id="24ca" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated"><code class="fe ng nh ni nj b">yield</code>暂停功能的执行。</li><li id="de78" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">要恢复执行，我们必须再次调用<code class="fe ng nh ni nj b">next</code>。</li></ul><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="280c" class="lr la it nj b gy od oe l of og">function* doOperations() {<br/>  console.log('1');<br/>  yield 2;<br/>  console.log('2');<br/>  yield 3;<br/>  console.log('3');<br/>  yield 4;<br/>  console.log('4');<br/>}</span><span id="1bbe" class="lr la it nj b gy oo oe l of og">const operations = doOperations();</span><span id="3261" class="lr la it nj b gy oo oe l of og">/*<br/>"1"<br/>"next : ", { done: false, value: 2 }<br/>*/<br/>console.log('next : ', operations.next());</span><span id="fb14" class="lr la it nj b gy oo oe l of og">/*<br/>"2"<br/>"next : ", { done: false, value: 3 }<br/>*/<br/>console.log('next : ', operations.next());</span></pre><p id="c4c0" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">生成器函数保持运行-停止-运行的生命周期，直到不再有代码要运行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/fab27fdf29235098539e3139089202b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F_J2kyREQ3tzcEPzKxL8CQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生成器函数生命周期(图片由作者提供)</p></figure><p id="e27c" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">那么最后的<code class="fe ng nh ni nj b">next</code>返回将是:<code class="fe ng nh ni nj b">{ done: true, value: undefined }</code>。</p><p id="e9ae" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">简单地说，生成器是可以暂停和恢复的函数。</p><p id="c56a" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">如果我们想让生成器保存这些值，那么每次调用<code class="fe ng nh ni nj b">next ()</code>是很繁琐的，对吗？我们怎么做呢？</p><p id="3002" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">让我们来看看MDN的描述:</p><blockquote class="oh oi oj"><p id="3e65" class="mg mh ok mi b mj nb ju ml mm nc jx mo ol nd mq mr om ne mt mu on nf mw mx my im bi translated">“生成器对象由生成器函数返回，它符合可迭代协议和迭代器协议。”— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="8f20" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">这意味着生成器可以通过循环和递归(<code class="fe ng nh ni nj b">for-of</code>循环、扩展操作符等等)产生值序列:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="6ce1" class="lr la it nj b gy od oe l of og">function* doOperations() {<br/>  yield 2;<br/>  yield 3;<br/>  yield 4;<br/>}</span><span id="c16d" class="lr la it nj b gy oo oe l of og">/*<br/>"values : ", [2, 3, 4]<br/>*/<br/>console.log('values : ', [...doOperations()]);</span><span id="b48d" class="lr la it nj b gy oo oe l of og">const operations = doOperations();</span><span id="e6a1" class="lr la it nj b gy oo oe l of og">/*<br/>"value : ", 2<br/>"value : ", 3<br/>"value : ", 4<br/>*/<br/>for (const val of operations) {<br/>  console.log('value : ', val);<br/>}</span></pre><p id="3776" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">厉害！这意味着我们可以创建自己的迭代器。</p><h2 id="379e" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">从发电机返回</h2><p id="0ace" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">让我们对我们的<code class="fe ng nh ni nj b">doOperations</code>函数做一个小小的修改:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="46a7" class="lr la it nj b gy od oe l of og">function* doOperations() {<br/>  yield 2;<br/>  yield 3;<br/>  yield 4;<br/>  <strong class="nj iu">return 'end of generator !';</strong><br/>}</span></pre><p id="aedb" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">这次处决给了我们:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="b9c8" class="lr la it nj b gy od oe l of og">console.log('next : ', operations.next());</span><span id="c047" class="lr la it nj b gy oo oe l of og">console.log('next : ', operations.next());</span><span id="9f43" class="lr la it nj b gy oo oe l of og">console.log('next : ', operations.next());</span><span id="aefe" class="lr la it nj b gy oo oe l of og">console.log('next : ', operations.next());</span><span id="a4fd" class="lr la it nj b gy oo oe l of og">"next : ", {<br/>  done: false,<br/>  value: 2<br/>}</span><span id="f65f" class="lr la it nj b gy oo oe l of og">"next : ", {<br/>  done: false,<br/>  value: 3<br/>}</span><span id="eba6" class="lr la it nj b gy oo oe l of og">"next : ", {<br/>  done: false,<br/>  value: 4<br/>}</span><span id="3f53" class="lr la it nj b gy oo oe l of og">"next : ", {<br/>  done: true,<br/> <strong class="nj iu"> value: "end of generator !"</strong><br/>}</span></pre><p id="3835" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">最后一个值现在是<code class="fe ng nh ni nj b">end of generator !</code>而不是<code class="fe ng nh ni nj b">undefined</code>。</p><p id="d1eb" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">返回值<code class="fe ng nh ni nj b">end of generator !</code>不包含在iterable中:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="7157" class="lr la it nj b gy od oe l of og">// "arrays : ", [2, 3, 4]<br/>console.log('arrays : ',[...doOperations()]);</span></pre><p id="3f3c" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">太神奇了！</p><h2 id="64ef" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">生成器:提前完成(取消执行)</h2><p id="0bf5" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">让我们看看这个例子:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="5ff7" class="lr la it nj b gy od oe l of og">function* doOperations() {<br/>  yield 2;<br/>  yield 3;<br/>  yield 4;<br/>}</span><span id="8584" class="lr la it nj b gy oo oe l of og">const operations = doOperations();</span><span id="44e1" class="lr la it nj b gy oo oe l of og">/*<br/>"next : ", {<br/>  done: false,<br/>  value: 2<br/>}<br/>*/<br/>console.log('next : ', operations.next());</span><span id="bcc5" class="lr la it nj b gy oo oe l of og">/*<br/>"next : ", {<br/>  done: false,<br/>  value: 3<br/>}<br/>*/<br/>console.log('next : ', operations.next());</span><span id="4ad6" class="lr la it nj b gy oo oe l of og"><strong class="nj iu">/*<br/>"forcedResult : ", {<br/>  done: true,<br/>  value: 12<br/>}<br/>*/<br/>const forcedResult = operations.return(12);<br/>console.log('forcedResult : ', forcedResult);</strong></span><span id="8862" class="lr la it nj b gy oo oe l of og">/*<br/>"next : ", {<br/><strong class="nj iu">  done: true,<br/>  value: undefined</strong><br/>}<br/>*/<br/>console.log('next : ', operations.next());</span><span id="7f11" class="lr la it nj b gy oo oe l of og">/*<br/>"next : ", {<br/><strong class="nj iu">  done: true,<br/>  value: undefined</strong><br/>}<br/>*/<br/>console.log('next : ', operations.next());</span></pre><p id="c5b0" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated"><code class="fe ng nh ni nj b">return(x)</code>正在强制退货<code class="fe ng nh ni nj b">x</code>在那个时候被处理。</p><blockquote class="oh oi oj"><p id="e62a" class="mg mh ok mi b mj nb ju ml mm nc jx mo ol nd mq mr om ne mt mu on nf mw mx my im bi translated">"一旦生成器正常或提前完成，它就不再处理任何代码或返回任何值."——<a class="ae ky" href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/es6%20&amp;%20beyond/README.md#you-dont-know-js-es6--beyond" rel="noopener ugc nofollow" target="_blank">你不知道的JS: ES6 &amp;超越</a>凯尔·辛普森著</p></blockquote><h2 id="582a" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">生成器:引发异常</h2><p id="c41a" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">让我们对我们的<code class="fe ng nh ni nj b">doOperations</code>函数做一个小小的修改:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="0b9a" class="lr la it nj b gy od oe l of og">function* doOperations() {<br/>  yield 2;<br/>  yield 3;<br/>  yield 4;<br/> <strong class="nj iu"> throw new Error('Problem!');</strong><br/>}</span></pre><p id="19e0" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">这次处决给了我们:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="6d4f" class="lr la it nj b gy od oe l of og">console.log('next : ', operations.next());<br/>console.log('next : ', operations.next());<br/>console.log('next : ', operations.next());<br/>console.log('next : ', operations.next());</span><span id="7e37" class="lr la it nj b gy oo oe l of og">"next : ", {<br/>  done: false,<br/>  value: 2<br/>}</span><span id="da4f" class="lr la it nj b gy oo oe l of og">"next : ", {<br/>  done: false,<br/>  value: 3<br/>}</span><span id="e970" class="lr la it nj b gy oo oe l of og">"next : ", {<br/>  done: false,<br/>  value: 4<br/>}</span><span id="7124" class="lr la it nj b gy oo oe l of og">Uncaught Error: Problem!"</span></pre><p id="1e53" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">这意味着<code class="fe ng nh ni nj b">next()</code>可以产生三种不同的结果:</p><ul class=""><li id="7703" class="nk nl it mi b mj nb mm nc lw nm lz nn mc no my np nq nr ns bi translated">对于迭代序列中的<code class="fe ng nh ni nj b">yield x</code>，它返回<code class="fe ng nh ni nj b">{ done: false, value: x}</code>。</li><li id="710f" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">对于具有值<code class="fe ng nh ni nj b">return</code>的迭代序列的结尾<code class="fe ng nh ni nj b">b</code>，它返回<code class="fe ng nh ni nj b">{ done: true, value:b }</code>。</li><li id="1759" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">对于异常，它抛出该异常。</li></ul><h2 id="0e19" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">生成器:提前中止</h2><p id="9946" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">让我们看看这个例子:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="11d5" class="lr la it nj b gy od oe l of og">function* doOperations() {<br/>  yield 2;<br/>  yield 3;<br/>  yield 4;<br/>}</span><span id="3696" class="lr la it nj b gy oo oe l of og">const operations = doOperations();</span><span id="0a89" class="lr la it nj b gy oo oe l of og">/*<br/>"next : ", {<br/>  done: false,<br/>  value: 2<br/>}<br/>*/<br/>console.log('next : ', operations.next());</span><span id="5e6f" class="lr la it nj b gy oo oe l of og">/*<br/>"next : ", {<br/>  done: false,<br/>  value: 3<br/>}<br/>*/<br/>console.log('next : ', operations.next());</span><span id="dd23" class="lr la it nj b gy oo oe l of og"><strong class="nj iu">try {<br/> operations.throw( "An error was occurred !" );<br/>}catch (error) {<br/> console.log('Exception: ', error); <br/>// Exception: An error was occurred!<br/>}</strong></span><span id="6bab" class="lr la it nj b gy oo oe l of og">/*<br/>"next : ", {<br/>  <strong class="nj iu">done: true,<br/>  value: undefined</strong><br/>}<br/>*/<br/>console.log('next : ', operations.next());</span><span id="13d0" class="lr la it nj b gy oo oe l of og">/*<br/>"next : ", {<br/>  <strong class="nj iu">done: true,<br/>  value: undefined</strong><br/>}<br/>*/<br/>console.log('next : ', operations.next());</span></pre><h2 id="9b4a" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">生成器:双向数据流</h2><p id="2794" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">让我们看看这个例子:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="c2d1" class="lr la it nj b gy od oe l of og">function* genDialog() {<br/>  // line 1<br/>  let question1 = <strong class="nj iu">yield "What's your name ?";</strong></span><span id="e8ee" class="lr la it nj b gy oo oe l of og">  // line 2<br/>  console.log('response 1 : ', question1); <br/>  // "response 1 : ", "My name is Héla !"</span><span id="9e1c" class="lr la it nj b gy oo oe l of og">  // line 3<br/>  let question2 = <strong class="nj iu">yield "Where do you live ?"</strong></span><span id="ddd0" class="lr la it nj b gy oo oe l of og">  // line 4<br/>  console.log('response 2 : ', question2); <br/>  // "response 2 : ", "I live in France."<br/>}</span><span id="94d5" class="lr la it nj b gy oo oe l of og">// line 5<br/>let generatorDialog = genDialog();</span><span id="d618" class="lr la it nj b gy oo oe l of og">// line 6<br/>console.log(`question 1: ${<strong class="nj iu">generatorDialog.next('Hi !').value</strong>}`);<br/>// "question 1: What's your name ?"</span><span id="539c" class="lr la it nj b gy oo oe l of og">// line 7<br/>console.log(`question 2: ${<strong class="nj iu">generatorDialog.next('My name is Héla !').value</strong>}`);<br/>// "question 2: Where do you live ?"</span><span id="21b4" class="lr la it nj b gy oo oe l of og">// line 8<br/>console.log(<strong class="nj iu">generatorDialog.next("I live in France.")</strong>);<br/>// {done: true, value: undefined}</span></pre><ul class=""><li id="c7d8" class="nk nl it mi b mj nb mm nc lw nm lz nn mc no my np nq nr ns bi translated">第一个<code class="fe ng nh ni nj b">next('Hi')</code>开始执行。它达到第一个产量。</li><li id="88a0" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">然而，值<code class="fe ng nh ni nj b">Hi</code>被忽略，因为没有<code class="fe ng nh ni nj b">yield</code>接收它。</li><li id="0c51" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">发电机保持的电流值为<code class="fe ng nh ni nj b">What's your name ?</code>。</li><li id="b00c" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated"><code class="fe ng nh ni nj b">line 1</code>被执行，当前保存的值被返回到调用代码<code class="fe ng nh ni nj b">line 6</code>。</li><li id="52a3" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">第二个<code class="fe ng nh ni nj b">next('My name is Héla!')</code>将第一个<code class="fe ng nh ni nj b">yield</code>的结果<code class="fe ng nh ni nj b">'My name is Héla!'</code>传回给发生器，并继续执行。</li><li id="a4f1" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">它到达第二个<code class="fe ng nh ni nj b">yield</code>，成为发电机调用<code class="fe ng nh ni nj b">line 7</code>的结果。</li><li id="9b8f" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">发电机保持的电流值现在是<code class="fe ng nh ni nj b">Where do you live ?</code>。</li><li id="25e6" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">第三个<code class="fe ng nh ni nj b">next('I live in France.')</code>将<code class="fe ng nh ni nj b">'I live in France.'</code>作为第二个<code class="fe ng nh ni nj b">yield</code>的结果传递给发生器，并继续执行，直到函数结束，因此<code class="fe ng nh ni nj b">done = true</code>。</li></ul><p id="25f5" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">这就像是生成器和调用代码之间的对话。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/3807a76442e8e2df56580ca7036c5524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*erLhIksr3mkJiCLEixSf2Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生成器和调用代码对话框(图片由作者提供)</p></figure><p id="011b" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">一个很棒的图案。这让我想起了异步流:</p><ul class=""><li id="0835" class="nk nl it mi b mj nb mm nc lw nm lz nn mc no my np nq nr ns bi translated">启动异步功能。</li><li id="d845" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">当它完成工作时，它将结果返回给调用函数。</li></ul><h2 id="ee46" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">发电机组成:产量*</h2><p id="7799" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">让我们看看这个例子:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="d712" class="lr la it nj b gy od oe l of og"><strong class="nj iu">function*</strong> generateCharSequence(start, end) {<br/>  for (let i = start; i &lt;= end; i++) yield String.fromCharCode(i);<br/>}</span><span id="ab9a" class="lr la it nj b gy oo oe l of og"><strong class="nj iu">function*</strong> generateAPassword() {<br/>  // 0..9<br/>  <strong class="nj iu">yield*</strong> generateCharSequence(48, 57);</span><span id="1949" class="lr la it nj b gy oo oe l of og">  // A..Z<br/>  <strong class="nj iu">yield*</strong> generateCharSequence(65, 90);</span><span id="6986" class="lr la it nj b gy oo oe l of og">  // a..z<br/>  <strong class="nj iu">yield*</strong> generateCharSequence(97, 122);<br/>}</span><span id="a51a" class="lr la it nj b gy oo oe l of og">let password = '';</span><span id="51d1" class="lr la it nj b gy oo oe l of og">for (let code of generateAPassword()) {<br/>  password += code;<br/>}</span><span id="a5a3" class="lr la it nj b gy oo oe l of og">console.log('password : ', password);<br/>// "password : ", "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"</span></pre><p id="517f" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated"><code class="fe ng nh ni nj b">yield*</code>指令将执行委托给另一个生成器。</p><p id="721c" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">生成器组合是将流从一个生成器插入到另一个生成器的自然方式。</p><p id="a320" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">上面的代码相当于:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="f76f" class="lr la it nj b gy od oe l of og">function* generateAPassword() {</span><span id="2412" class="lr la it nj b gy oo oe l of og">  // yield* generateCharSequence(48, 57);<br/>  <strong class="nj iu">for (let i = 48; i &lt;= 57; i++) yield i;</strong></span><span id="6477" class="lr la it nj b gy oo oe l of og">  // yield* generateCharSequence(65, 90);<br/>  <strong class="nj iu">for (let i = 65; i &lt;= 90; i++) yield i;</strong></span><span id="f149" class="lr la it nj b gy oo oe l of og">  // yield* generateCharSequence(97, 122);<br/>  <strong class="nj iu">for (let i = 97; i &lt;= 122; i++) yield i;</strong></span><span id="ae63" class="lr la it nj b gy oo oe l of og">}</span></pre><p id="3842" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">这是一个非常有用的模式，可以保持生成器的小规模和可读性。</p><p id="f540" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">这种模式的一个实际应用:</p><div class="or os gp gr ot ou"><a href="https://redux-saga.js.org/docs/advanced/SequencingSagas/" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">测序传奇|还原传奇</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">您可以使用内置的yield*运算符以连续的方式编写多个传奇。这允许您对您的…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">redux-saga.js.org</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div><p id="6ab6" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">让我们看看其他一些更实际的使用案例，在这些案例中，发电机大放异彩。</p></div><div class="ab cl pj pk hx pl" role="separator"><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po"/></div><div class="im in io ip iq"><h1 id="ae39" class="kz la it bd lb lc pq le lf lg pr li lj jz ps ka ll kc pt kd ln kf pu kg lp lq bi translated">发电机的实际使用案例</h1><h2 id="e365" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">按需转换阵列(数据流)</h2><p id="3991" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">让我们看看这段代码:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="ebee" class="lr la it nj b gy od oe l of og">function* transform(iterable, transformFunc) {<br/>    for (const x of iterable) {<br/>        yield transformFunc(x);<br/>    }<br/>}</span><span id="50ed" class="lr la it nj b gy oo oe l of og"><strong class="nj iu">const transformGen = transform([1, 2, 3], x =&gt; x * x);</strong></span><span id="3da7" class="lr la it nj b gy oo oe l of og">/*<br/>"transformGen : ", {<br/>  done: false,<br/>  value: 1<br/>}<br/>*/<br/>console.log('transformGen : ', transformGen.next());</span><span id="5df4" class="lr la it nj b gy oo oe l of og">/*<br/>"transformGen : ", {<br/>  done: false,<br/>  value: 4<br/>}<br/>*/<br/>console.log('transformGen : ', transformGen.next());</span><span id="96fb" class="lr la it nj b gy oo oe l of og">/*<br/>"transformGen : ", {<br/>  done: false,<br/>  value: 9<br/>}<br/>*/<br/>console.log('transformGen : ', transformGen.next());</span><span id="aeb2" class="lr la it nj b gy oo oe l of og">/*<br/>"transformGen : ", {<br/>  done: true,<br/>  value: undefined<br/>}<br/>*/<br/>console.log('transformGen : ', transformGen.next());</span></pre><p id="4bdd" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">我们还可以做:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="1c73" class="lr la it nj b gy od oe l of og"><strong class="nj iu">// "transform the whole array : ", [1, 4, 9]</strong><br/>console.log('transform the whole array : ', <strong class="nj iu">[...transform([1, 2, 3], x =&gt; x * x)]</strong>);</span></pre><p id="b317" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">魔法。</p><p id="2d48" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">上面的代码和这个有什么区别？</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="7d41" class="lr la it nj b gy od oe l of og">const transform = (array, f) =&gt; {<br/>  const arrayCopy = [<br/>    ...array || [],<br/>  ];<br/>  if (arrayCopy &amp;&amp; arrayCopy.length &amp;&amp; f) {<br/>    for (let i = 0; i &lt; arrayCopy.length; i++) {<br/>      arrayCopy[i] =  f(arrayCopy[i]);<br/>    }<br/>  }<br/>  return arrayCopy;<br/>}</span></pre><p id="9dcf" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">使用<code class="fe ng nh ni nj b">transform</code>的生成器版本，我们可以选择:</p><ul class=""><li id="fcec" class="nk nl it mi b mj nb mm nc lw nm lz nn mc no my np nq nr ns bi translated">逐个元素转换并返回:按需转换。</li><li id="8e8f" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">使用<code class="fe ng nh ni nj b">for…of</code>或扩展操作符变换整个数组。</li></ul><p id="1213" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">按需转换有什么帮助？</p><p id="83fa" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">让我们假设我们有这个<code class="fe ng nh ni nj b">json</code>格式:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="50fd" class="lr la it nj b gy od oe l of og">[{<br/> "id": 1,<br/> "name": "Leanne Graham",<br/> "username": "Bret",<br/> "email": "<a class="ae ky" href="mailto:Sincere@april.biz" rel="noopener ugc nofollow" target="_blank">Sincere@april.biz</a>",<br/> "address": {<br/>  "street": "Kulas Light",<br/>  "suite": "Apt. 556",<br/>  "city": "Gwenborough",<br/>  "zipcode": "92998-3874",<br/>  "geo": {<br/>   "lat": "-37.3159",<br/>   "lng": "81.1496"<br/>  }<br/> },<br/> "phone": "1-770-736-8031 x56442",<br/> "website": "hildegard.org",<br/> "company": {<br/>  "name": "Romaguera-Crona",<br/>  "catchPhrase": "Multi-layered client-server neural-net",<br/>  "bs": "harness real-time e-markets"<br/> }<br/>}]</span></pre><p id="fdc1" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">然而，对于UI显示(list + load more ),我们需要这样的格式:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="5a9c" class="lr la it nj b gy od oe l of og">[{<br/> "id": 1,<br/> "name": "Leanne Graham",<br/> "username": "Bret",<br/> "email": "<a class="ae ky" href="mailto:Sincere@april.biz" rel="noopener ugc nofollow" target="_blank">Sincere@april.biz</a>",<br/><strong class="nj iu"> "address": "Kulas Light, Apt. 556, Gwenborough 92998-3874",</strong><br/> "phone": "1-770-736-8031 x56442",<br/> "website": "hildegard.org",<br/> <strong class="nj iu">"company": "Romaguera-Crona, Multi-layered client-server neural-net, harness real-time e-markets"</strong><br/>}]</span></pre><p id="1dd0" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated"><code class="fe ng nh ni nj b">address = street, suite, city, zipcode</code>。</p><p id="2553" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated"><code class="fe ng nh ni nj b">company = name, catchPhrase, bs</code>。</p><p id="ce42" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">我们有许多解决方案:</p><ul class=""><li id="4823" class="nk nl it mi b mj nb mm nc lw nm lz nn mc no my np nq nr ns bi translated">我们可以在显示之前对整个数组进行变换(普通变换、<code class="fe ng nh ni nj b">for…of</code>或展开)。</li><li id="e3f1" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">我们可以按需转换项目(<code class="fe ng nh ni nj b">next</code>):每次我们在底部滚动并加载更多的项目。</li></ul><p id="473d" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">解决方案二更具性能，尤其是如果UI显示使用类似于<code class="fe ng nh ni nj b">load more</code>或<code class="fe ng nh ni nj b">lazy load</code>或<code class="fe ng nh ni nj b">pagination</code>的机制。解决方案一不是高性能的，因为用户可能不会滚动到底部或移动到下一页。</p><p id="6e2a" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">我们可以有自己的<code class="fe ng nh ni nj b">map</code>:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="ce0d" class="lr la it nj b gy od oe l of og">function* transform(iterable, transformFunc) {<br/>    for (const x of iterable) {<br/>        yield transformFunc(x);<br/>    }<br/>}</span><span id="dea3" class="lr la it nj b gy oo oe l of og">function* map(iterable, mapFunc) {<br/>   <strong class="nj iu"> yield* transform(iterable, mapFunc);</strong><br/>}</span><span id="0b08" class="lr la it nj b gy oo oe l of og"><strong class="nj iu">// "map the whole array : ", [2, 4, 6]</strong><br/>console.log('map the whole array : ', [...map([1, 2, 3], x =&gt; x + x)]);</span><span id="e21b" class="lr la it nj b gy oo oe l of og"><br/><strong class="nj iu">const mapGen = map([1, 2, 3], x =&gt; x * x);</strong></span><span id="41c6" class="lr la it nj b gy oo oe l of og">/*<br/><strong class="nj iu">"map only the first element : "</strong>, {<br/>  done: false,<br/>  value: 1<br/>}<br/>*/<br/>console.log('map only the first element : ', mapGen.next());</span></pre><p id="08ff" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">还有我们自己的<code class="fe ng nh ni nj b">filter</code>:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="0f52" class="lr la it nj b gy od oe l of og">function* filter(iterable, filterFunc) {<br/>    for (const x of iterable) {<br/>        if (filterFunc(x)) {<br/>            yield x;<br/>        }<br/>    }<br/>}</span><span id="a8f1" class="lr la it nj b gy oo oe l of og">// "keep only even : ", [2, 4]<br/>console.log('keep only even : ', [<strong class="nj iu">...filter([1, 2, 4, 3], x =&gt; x%2 === 0)]</strong>);</span><span id="29b5" class="lr la it nj b gy oo oe l of og">const filterGen = filter([1, 2, 4, 3], x =&gt; x%2 === 0);</span><span id="31ca" class="lr la it nj b gy oo oe l of og">/*<br/><strong class="nj iu">"get the first matched element : "</strong>, {<br/>  done: false,<br/>  value: 2<br/>}<br/>*/<br/>console.log('get the first matched element : ', filterGen.next());</span></pre><p id="e98f" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">按需转换是内存和计算高效的，因为我们只转换我们需要的和按需的(像<a class="ae ky" href="https://nodejs.dev/learn/nodejs-streams" rel="noopener ugc nofollow" target="_blank">流</a>，一段一段地读取，一个块一个块地读取)。</p><h2 id="92ed" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">队列(先进先出)</h2><p id="2f5d" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">让我们来看看这个神奇的HTTP承诺执行者:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="dc76" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">以下是这段代码的执行轨迹:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="b121" class="lr la it nj b gy od oe l of og"><strong class="nj iu">// init generator</strong><br/>"onTaskSuccess requestId : ", null<br/>"onTaskSuccess requestResponse : ", undefined<br/>"onTaskSuccess responsesStack : ", []</span><span id="620c" class="lr la it nj b gy oo oe l of og"><strong class="nj iu">// first promise</strong><br/>"onTaskSuccess requestId : ", "1"<br/>"onTaskSuccess requestResponse : ", "Albert Einsten"<br/>"onTaskSuccess responsesStack : ", ["Albert Einsten"]</span><span id="e5b2" class="lr la it nj b gy oo oe l of og"><strong class="nj iu">// second promise</strong><br/>"onTaskSuccess requestId : ", "2"<br/>"onTaskSuccess requestResponse : ", "Nicolas Tesla"<br/>"onTaskSuccess responsesStack : ", ["Albert Einsten", "Nicolas Tesla"]</span><span id="10f8" class="lr la it nj b gy oo oe l of og"><strong class="nj iu">// third promise</strong><br/>"onTaskFail requestId : ", "3"<br/>"onTaskFail requestError : ", "taskFn is not a function"</span><span id="8d46" class="lr la it nj b gy oo oe l of og"><strong class="nj iu">// last promise</strong><br/>"onTaskSuccess requestId : ", "4"<br/>"onTaskSuccess requestResponse : ", "Marie Curie"<br/>"onTaskSuccess responsesStack : ", ["Albert Einsten", "Nicolas Tesla", "Marie Curie"]</span></pre><p id="a53e" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">你可以看到我们可以得到:</p><ul class=""><li id="ad7b" class="nk nl it mi b mj nb mm nc lw nm lz nn mc no my np nq nr ns bi translated">请求的ID</li><li id="651d" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">对请求的响应(如果成功)</li><li id="aa59" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">请求失败的原因(如果失败)</li><li id="4e6e" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">当前持有的响应堆栈</li></ul><p id="479f" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">我们也可以取消请求:</p><pre class="kj kk kl km gt nz nj oa ob aw oc bi"><span id="7088" class="lr la it nj b gy od oe l of og">httpRequestsExecutor.executeTask('1', celebrities =&gt; Promise.resolve([...celebrities, 'Albert Einsten']));</span><span id="b77b" class="lr la it nj b gy oo oe l of og">httpRequestsExecutor.executeTask('2', celebrities =&gt; Promise.resolve([...celebrities, 'Nicolas Tesla']));</span><span id="0418" class="lr la it nj b gy oo oe l of og"><strong class="nj iu">asyncHttpFifoExecutor.cancel();</strong></span><span id="c240" class="lr la it nj b gy oo oe l of og">httpRequestsExecutor.executeTask('3', null);</span><span id="0982" class="lr la it nj b gy oo oe l of og">httpRequestsExecutor.executeTask('4', celebrities =&gt; Promise.resolve([...celebrities, 'Marie Curie']));<br/></span><span id="a674" class="lr la it nj b gy oo oe l of og"><strong class="nj iu">// init generator</strong><br/>"onTaskSuccess requestId : ", null<br/>"onTaskSuccess requestResponse : ", undefined<br/>"onTaskSuccess responsesStack : ", []</span><span id="cd4e" class="lr la it nj b gy oo oe l of og"><strong class="nj iu">// first promise</strong><br/>"onTaskSuccess requestId : ", "1"<br/>"onTaskSuccess requestResponse : ", "Albert Einsten"<br/>"onTaskSuccess responsesStack : ", ["Albert Einsten"]</span><span id="69a5" class="lr la it nj b gy oo oe l of og"><strong class="nj iu">// second promise</strong><br/>"onTaskSuccess requestId : ", "2"<br/>"onTaskSuccess requestResponse : ", "Nicolas Tesla"<br/>"onTaskSuccess responsesStack : ", ["Albert Einsten", "Nicolas Tesla"]</span></pre><p id="1dca" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">其余的任务没有被执行。我们可以取消承诺。</p><h2 id="0d12" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">设计我们自己的异步/等待</h2><p id="de4f" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">我们可以在不使用async/await的情况下实现异步。让我们看看这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a644" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">太神奇了。会发生什么？</p><ul class=""><li id="b425" class="nk nl it mi b mj nb mm nc lw nm lz nn mc no my np nq nr ns bi translated">第一个<code class="fe ng nh ni nj b">yield</code>会回报一个承诺。</li><li id="dc32" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">然后我们尝试解决承诺(第10行)。</li><li id="754a" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">在第11行，我们得到了第一个承诺的响应。</li><li id="79c2" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">我们将此响应反馈给<code class="fe ng nh ni nj b">generator</code>以从线路<code class="fe ng nh ni nj b">yield response.json()</code>恢复(乒乓)。</li><li id="d731" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">在第15行，我们因为<code class="fe ng nh ni nj b">response.json()</code>返回一个新的承诺。</li><li id="56fe" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">既然是承诺，我们可以链。</li><li id="2715" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">在第17行，我们得到了最终结果，因为没有其他的<code class="fe ng nh ni nj b">yield</code>可以运行。</li></ul><p id="fa3d" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">当我们想要执行一步一步的HTTP请求，并且想要在任何步骤控制取消-暂停-恢复时，这种模式非常有用。</p><p id="aa57" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">这就像一个线程API:</p><ul class=""><li id="ae44" class="nk nl it mi b mj nb mm nc lw nm lz nn mc no my np nq nr ns bi translated">我们可以叉一根新线。</li><li id="0b4c" class="nk nl it mi b mj nt mm nu lw nv lz nw mc nx my np nq nr ns bi translated">并控制其生命周期(开始-停止-取消-恢复)。</li></ul></div><div class="ab cl pj pk hx pl" role="separator"><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po"/></div><div class="im in io ip iq"><h1 id="733c" class="kz la it bd lb lc pq le lf lg pr li lj jz ps ka ll kc pt kd ln kf pu kg lp lq bi translated">发电机的其他鼓舞人心的例子</h1><h2 id="d283" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><strong class="ak"> Redux saga </strong></h2><div class="or os gp gr ot ou"><a href="https://redux-saga.js.org/" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">一个直观的Redux副作用管理器。还原传奇</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">您的Docusaurus站点没有正确加载。一个非常常见的原因是错误的site baseUrl配置。当前…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">redux-saga.js.org</p></div></div><div class="pd l"><div class="pv l pf pg ph pd pi ks ou"/></div></div></a></div><h2 id="d57b" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><strong class="ak">状态机</strong></h2><div class="or os gp gr ot ou"><a href="https://egghead.io/lessons/egghead-create-a-state-machine-with-a-generator" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">创建一个带生成器的状态机</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">由于生成器可以接受初始值并公开下一个可以对初始值进行更新的方法，所以它…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">蛋头</p></div></div><div class="pd l"><div class="pw l pf pg ph pd pi ks ou"/></div></div></a></div><h2 id="a898" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><strong class="ak">可观测量(RxJS的本地替代)</strong></h2><div class="or os gp gr ot ou"><a href="https://exploringjs.com/es6/ch_generators.html#sec_generators-as-observers" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">22.发电机</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">22.1.概述22.1.1。什么是发电机？22.1.2.发电机的种类。用例:实现iterables…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">exploringjs.com</p></div></div><div class="pd l"><div class="px l pf pg ph pd pi ks ou"/></div></div></a></div><div class="or os gp gr ot ou"><a href="https://medium.com/javascript-scene/the-hidden-power-of-es6-generators-observable-async-flow-control-cfa4c7f31435" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">ES6发电机的隐藏能量:可观测的异步流量控制</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">在我用JavaScript编写斐波那契生成器时学到的7件令人惊讶的事情中，我介绍了ES6的一个明显的用例…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">medium.com</p></div></div><div class="pd l"><div class="py l pf pg ph pd pi ks ou"/></div></div></a></div><h2 id="01c7" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated">协同程序(协同多任务处理)</h2><div class="or os gp gr ot ou"><a href="https://exploringjs.com/es6/ch_generators.html#sec_generators-as-coroutines" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">22.发电机</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">22.1.概述22.1.1。什么是发电机？22.1.2.发电机的种类。用例:实现iterables…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">exploringjs.com</p></div></div><div class="pd l"><div class="pz l pf pg ph pd pi ks ou"/></div></div></a></div></div><div class="ab cl pj pk hx pl" role="separator"><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po"/></div><div class="im in io ip iq"><h1 id="f1bb" class="kz la it bd lb lc pq le lf lg pr li lj jz ps ka ll kc pt kd ln kf pu kg lp lq bi translated">结论</h1><p id="595b" class="pw-post-body-paragraph mg mh it mi b mj mk ju ml mm mn jx mo lw mp mq mr lz ms mt mu mc mv mw mx my im bi translated">在本文中，我们一起看到了一种新类型的JavaScript函数:生成器。</p><p id="c8d3" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">生成器的价值在于一步一步执行函数的可能性，不像运行到完成的函数。</p><p id="8f8d" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">多亏了<code class="fe ng nh ni nj b">yield</code>和<code class="fe ng nh ni nj b">next</code>，我们可以启动-暂停-恢复一个功能。例如，使用这个模式，我们可以控制一个承诺的执行流程。</p><p id="7e9d" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">生成器函数可以提前完成(提前返回以取消执行)或提前中止(例如通过抛出异常)。</p><p id="ef4b" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">一个生成器可以作为一个强大的迭代器运行:一个流一个块地或者按需一个一个地完成计算。当我们应该做一个<code class="fe ng nh ni nj b">lazy loading</code>或<code class="fe ng nh ni nj b">load more</code>或<code class="fe ng nh ni nj b">pagination</code>时，这个技巧是很有用的。</p><p id="69ab" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">惰性求值机制将表达式的求值延迟到需要它的值时。价值是按照我们的要求计算的。</p><p id="fa97" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">惰性计算对内存使用有直接影响。仅生成和计算所需的值。对于从运行到完成的函数，我们必须预先生成所有的值，并保留它们以备将来使用。</p><p id="5b14" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">生成器的另一个好处是一次性访问。一旦所有的值都用完了，我们就不能再迭代了。为了再次生成值，我们应该实例化一个新的生成器对象。</p><p id="77d0" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">此外，生成器对象不允许随机访问(对于数组也是如此)，因为值是逐个生成的。这有助于形成一个队列(FIFO:先进先出)。</p><p id="87a4" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">最后，当我们想从头开始编写一个像async/await这样的API或者一个线程API(协程、协作多任务、fork、cancel、suspend、resume等等)时，生成器非常有用。</p></div><div class="ab cl pj pk hx pl" role="separator"><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po"/></div><div class="im in io ip iq"><p id="c1f1" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">感谢您阅读我的文章。</p><p id="f69b" class="pw-post-body-paragraph mg mh it mi b mj nb ju ml mm nc jx mo lw nd mq mr lz ne mt mu mc nf mw mx my im bi translated">你可以在GitHub找到我:<a class="ae ky" href="https://github.com/helabenkhalfallah" rel="noopener ugc nofollow" target="_blank">https://github.com/helabenkhalfallah</a></p></div></div>    
</body>
</html>