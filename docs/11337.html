<html>
<head>
<title>SwiftPM + CoreData: Failing SwiftUI Previews? Here Are 5 Tips to Fix</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">swift pm+CoreData:swift ui预览失败？这里有5个技巧可以修正</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftpm-coredata-failing-swiftui-previews-5-tips-to-fix-feef1bfa3f88?source=collection_archive---------12-----------------------#2022-03-09">https://betterprogramming.pub/swiftpm-coredata-failing-swiftui-previews-5-tips-to-fix-feef1bfa3f88?source=collection_archive---------12-----------------------#2022-03-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df05" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">修复Xcode错误，该错误导致SwiftUI预览在使用SwiftPM模块化的应用程序和使用CoreData的应用程序中失败</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/27bcb64143740f125757e974df18099b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xARP6TgC55AuBtAg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@tumbao1949?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">詹姆斯·温斯科特</a>拍摄的照片</p></figure><p id="2cf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自从我在Xcode中使用Point-Free的<a class="ae ky" href="https://www.pointfree.co/episodes/ep171-modularization-part-1" rel="noopener ugc nofollow" target="_blank">模块化方法</a>为<a class="ae ky" href="https://github.com/FlineDevPublic/OpenFocusTimer" rel="noopener ugc nofollow" target="_blank">打开焦点定时器</a>设置项目以来，我的SwiftUI预览就无法正常工作——启用CoreData复选框以获得我的模型层的良好起点。这很烦人，毕竟获得更快的构建和更可靠的SwiftUI预览是我首先选择将我的应用模块化成小块的主要原因之一。</p><p id="77f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以在<a class="ae ky" href="https://youtu.be/OMhzx3zdrJw?t=6415" rel="noopener ugc nofollow" target="_blank">我的一个流</a>(这是我在Twitch<a class="ae ky" href="https://www.twitch.tv/Jeehut" rel="noopener ugc nofollow" target="_blank">上直播时完全公开开发的开源应用</a>)中，我决定解决这个问题，一劳永逸地修复SwiftUI预览错误。我失败了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="6005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢Twitter上伟大的Swift社区的帮助，我找到了问题的根源:</p><p id="85eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> SwiftUI预览在引用CoreData模型时遇到麻烦</strong>。</p><p id="7ad5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，虽然我认为这只是一个路径问题，可以通过一个简单的解决方法来解决，但事情并没有那么简单。是的，这涉及到路径问题，但是在解决预览时，我遇到了多种级别的失败。在这个过程中，我学会了如何调试SwiftUI预览。让我分享一下我的经验…</p><h1 id="5911" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">#1:包清单中的显式依赖关系</h1><p id="acdd" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">重要的事情先来。使用Point-Free的模块化方法意味着您将有一个<code class="fe mu mv mw mx b">Package.swift</code>文件需要手动管理。对于每个模块，您将添加一个<code class="fe mu mv mw mx b">target</code>、一个<code class="fe mu mv mw mx b">testTarget</code>和一个<code class="fe mu mv mw mx b">library</code>条目，并且对于每个目标，您将需要指定依赖项。Xcode除了识别您在该文件中所做的更改之外，在这里没有任何帮助。对于许多包，清单文件可能会显著增长，目前我还不知道有什么帮助可以让这变得更容易。这是我现在的清单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my lw l"/></div></figure><p id="a8d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">手动管理这个文件的问题不仅仅是手工工作。Xcode似乎在依赖关系方面表现得不一致:例如，当你以模拟器为目标进行正常构建时，依赖关系的依赖关系似乎会自动链接到你的目标。因此，例如，如果我的<code class="fe mu mv mw mx b">TimerFeature</code>正在导入<code class="fe mu mv mw mx b">Utility</code>，但它没有被列为<code class="fe mu mv mw mx b">TimerFeature</code>目标下的一个依赖项，如果另一个依赖项，例如<code class="fe mu mv mw mx b">Model</code>也依赖于<code class="fe mu mv mw mx b">Utility</code>，Xcode可能仍然能够正确编译，因此Xcode可以间接访问<code class="fe mu mv mw mx b">TimerFeature</code>内的<code class="fe mu mv mw mx b">Utility</code>，因为<code class="fe mu mv mw mx b">TimerFeature</code>将<code class="fe mu mv mw mx b">Model</code>列为其依赖项。</p><p id="17fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这听起来非常有用，但它可能会变得非常令人沮丧，因为SwiftUI预览的工作方式不同。据我所知，对他们来说，这种可传递的隐式导入不起作用。运行测试似乎也是如此(至少有时是这样)。换句话说:始终仔细检查每个目标的<code class="fe mu mv mw mx b">dependencies</code>，并且不要忘记将您在目标中创建的每个<code class="fe mu mv mw mx b">import</code>添加到您的<code class="fe mu mv mw mx b">Package.swift</code>清单文件中的相关目标，这一点很重要。</p><p id="c398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许，将来会有人编写一个工具来帮助简化这个过程。🤞</p><h1 id="8b63" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"># 2:Xcode无法可靠地拾取生成的代码</h1><p id="1c13" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我遇到的另一个问题是，即使我的构建成功了，Xcode也会(在向我显示“构建成功”对话框后)在编辑器中显示一个错误，在<code class="fe mu mv mw mx b">PreviewProvider</code>中指出它找不到<code class="fe mu mv mw mx b">FocusTimer</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/2a371ff4002c6fc22ac101ba789a5e0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hr-Ht7uG4gRXUxY4cjZDkw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">错误说明尽管“导入模型”并成功构建，但在范围内找不到“FocusTimer”。</p></figure><p id="9f04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然不一定是一个拦截器，但这让我觉得SwiftUI预览也可能由于生成的代码而失败。为了解决这个问题，我选择让Xcode一次性生成代码文件，并将它们显式添加到我的包中。这可以通过打开<code class="fe mu mv mw mx b">.xcdatamodel</code>文件，然后点击<code class="fe mu mv mw mx b">Editor</code>并选择<code class="fe mu mv mw mx b">Create NSManagedObject Subclass...</code>来完成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/96c762748d34c976ef58be18ee449ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6d483DtWuUcZvwjWTRBXOQ.png"/></div></div></figure><p id="dc01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，每次对模型进行更改时，您都需要删除并重新创建这些生成的文件(无论如何，您应该很少这样做，以防止数据库迁移问题)。此外，在Xcode中选择型号并将<code class="fe mu mv mw mx b">Codegen</code>设置为<code class="fe mu mv mw mx b">Manual/None</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/af6d9ec5aa34bd052a2153b61b92925d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uzwo0aVkYaavPCC9swt-Jw.png"/></div></div></figure><p id="7cb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，编辑器不再显示错误。</p><h1 id="d933" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">#3: SwiftUI诊断！= SwiftUI崩溃报告</h1><p id="cd0c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">对于那些(像我一样)想知道当SwiftUI预览失败时按下<code class="fe mu mv mw mx b">Diagnostics</code>按钮后如何利用这样的错误的人来说，这里有一个学习:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/ad93d7264e0a4584b9d798d950bb6c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pikdtcSd9-Ls0KfxEW3VMQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">点击“诊断”，只显示“信息错误:连接中断”。</p></figure><p id="39d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这条错误消息对我们有什么帮助，它不是很有用:</p><blockquote class="nd ne nf"><p id="46eb" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">向代理发送previewInstances消息的消息发送失败<br/> ==== <br/>消息错误:连接中断</p></blockquote><p id="ce7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解更多详细信息，请阅读模式标题下方的灰色小文本:</p><blockquote class="nd ne nf"><p id="3c06" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">使用“生成报告”来创建可发送给Apple以诊断系统问题的信息。</p></blockquote><p id="8bd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个暗示很有误导性。听起来这一步只对帮助苹果分析问题有用。但是我们也可以用！只需点击“生成报告”按钮，并在下拉列表中选择“在Finder中显示”。然后Xcode会生成一份报告，并打开Finder应用程序，生成的文件夹会高亮显示，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/cd995d525fe380d74c4a891b7be75ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*H6_CZEsMRWS2W3RHOom-sg.png"/></div></div></figure><p id="591e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看突出显示的文件夹的内容将显示许多文件，这些文件包含有关SwiftUI预览版本的不同种类的详细信息。对调试最有用的文件位于文件夹<code class="fe mu mv mw mx b">CrashLogs</code>中，在那里你可以找到一个或多个<code class="fe mu mv mw mx b">.ips</code>文件，我们可以通过双击在Xcode中轻松打开它们:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/bb6861c430e976e0d8c9dd4c8b057487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FbPxWD0DZR3XfDI_2cmjqQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Xcode预览的内容。带有正确错误控制台输出的ips文件。</p></figure><p id="fa72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个文件的内容看起来更像构建失败时我们在Xcode控制台中得到的错误输出，包括构建失败的原因，甚至是失败时发生的一堆调用。它指出:</p><blockquote class="nd ne nf"><p id="68cd" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">由于未捕获的异常“NSInvalidArgumentException”而终止应用程序，原因:“- <strong class="lb iu"> [FocusTimer正在运行]:无法识别的选择器</strong>被发送到实例0x12886cac0”</p></blockquote><p id="babd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了一个可以开始调试的地方，我们知道由于某种原因SwiftUI预览无法访问我们的<code class="fe mu mv mw mx b">FocusTimer</code>模型的<code class="fe mu mv mw mx b">running</code>属性。这是连接CoreData的关键，否则我不得不胡乱猜测为什么预览会失败。</p><p id="acf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为Xcode应该立即在诊断屏幕中显示这个堆栈跟踪，这会帮助我节省一些时间。可能在Xcode 14？🤞</p><h1 id="1288" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">#4:模拟中的内存中ManagedObjectContext</h1><p id="c69d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在尝试了一些不同的东西之后，我找到了<code class="fe mu mv mw mx b">unrecognized selector</code>问题的根本原因:这与我如何创建我的模仿的<code class="fe mu mv mw mx b">FocusTimer</code>对象以便在<code class="fe mu mv mw mx b">PreviewProvider</code>中使用有关:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my lw l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my lw l"/></div></figure><blockquote class="nd ne nf"><p id="110b" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated"><strong class="lb iu">顺便说一下:</strong>是的，我将所有与SwiftUI预览相关的代码(包括<code class="fe mu mv mw mx b"><em class="it">PreviewProvider</em></code>)放在<code class="fe mu mv mw mx b"><em class="it">#if DEBUG</em></code>指令中。这确保了我永远不会在我的生产代码中意外调用我只为SwiftUI预览编写的代码。</p></blockquote><p id="d1d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不假思索地在我的<code class="fe mu mv mw mx b">FocusTimer</code>上调用了<code class="fe mu mv mw mx b">.init</code>方法，它是<code class="fe mu mv mw mx b">NSManagedObject</code>的子类，因为我认为这是初始化空<code class="fe mu mv mw mx b">FocusTimer</code>的最简单方法。但是在<code class="fe mu mv mw mx b">NSManagedObject</code>上没有<code class="fe mu mv mw mx b">init</code>方法，相反<code class="fe mu mv mw mx b">NSManagedObject</code>本身是<code class="fe mu mv mw mx b">NSObject</code>的子类，并且<a class="ae ky" href="https://developer.apple.com/documentation/objectivec/nsobject/1418641-init" rel="noopener ugc nofollow" target="_blank"> init() </a>被定义在那个级别上。这并没有创建一个合适的CoreData模型，相反我们需要调用<code class="fe mu mv mw mx b">NSManagedObject</code>的<a class="ae ky" href="https://developer.apple.com/documentation/coredata/nsmanagedobject/1640602-init" rel="noopener ugc nofollow" target="_blank"> init(context:) </a>方法。</p><p id="e089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，当创建一个新的Xcode项目并启用<code class="fe mu mv mw mx b">CoreData</code>复选框时，Xcode会创建一个<code class="fe mu mv mw mx b">PersistenceController</code>文件，该文件带有一个接受<code class="fe mu mv mw mx b">inMemory: Bool</code>参数的init方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my lw l"/></div></figure><p id="7edf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很重要，因为我们不想在我们的预览中创建实际的数据库(这可能会导致另一个错误，使我们的预览失败)，相反，我们只想使用一个内存中的数据库，它永远不会真正持久化(尽管名称为<code class="fe mu mv mw mx b">PersistenceController</code>)。</p><p id="06a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我必须用以下3行代码替换创建<code class="fe mu mv mw mx b">container</code>的第一行代码，以便在将CoreData模型代码提取到单独的SwiftPM模块时，从正确的路径加载CoreData模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my lw l"/></div></figure><p id="b08b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我将这个<code class="fe mu mv mw mx b">mocked</code>属性添加到<code class="fe mu mv mw mx b">PersistenceController</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my lw l"/></div></figure><p id="1168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我通过调用正确的init方法来调整<code class="fe mu mv mw mx b">FocusTimer</code>模拟:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my lw l"/></div></figure><p id="3e9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这修复了SwiftUI预览中的<code class="fe mu mv mw mx b">unrecognized selector</code>错误！🎉</p><p id="576d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这还没有结束，还有一个非常奇怪的Xcode错误需要修复…</p><h1 id="021c" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">#5: Bundle.module在预览中不工作</h1><p id="bb9d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">最后，在应用了前面的所有步骤后，我遇到了这样一个错误:</p><blockquote class="nd ne nf"><p id="fc91" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">致命错误:找不到名为OpenFocusTimer_Model的包</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/f7189f05cd7b28eb3924b6d565f1cce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JwTGbP-nbfw6M8zVqJfUwQ.png"/></div></div></figure><p id="5933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢天谢地，这里前面提到的Twitter上Swift社区的一位好心开发者的<a class="ae ky" href="https://twitter.com/NiklasBuelow/status/1499160862220857349?s=20" rel="noopener ugc nofollow" target="_blank">指针</a>帮了我，它在StackOverflow上给我指出了一个有<a class="ae ky" href="https://stackoverflow.com/a/65789298/3451975" rel="noopener ugc nofollow" target="_blank">这个答案</a>的帖子。</p><p id="1a29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上就是说目前Xcode(或者SwiftPM)有一个bug？)使得<code class="fe mu mv mw mx b">Bundle.module</code>在SwiftUI预览中指向错误的路径。为了解决这个问题，他们建议添加一个带有自定义搜索的<code class="fe mu mv mw mx b">Bundle</code>扩展。下面是为适应我的编码&amp;注释风格而稍微调整的完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my lw l"/></div></figure><blockquote class="nd ne nf"><p id="74b4" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">当复制和粘贴这段代码时，确保将<code class="fe mu mv mw mx b">packageName</code>和<code class="fe mu mv mw mx b">targetName</code>变量相应地调整到您的包&amp;目标名称。</p></blockquote><p id="d07e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我将变通方法包装到了一个<code class="fe mu mv mw mx b">#if DEBUG</code>中，以确保我的生产代码不会意外地使用这个路径搜索，而是依赖于官方的<code class="fe mu mv mw mx b">Bundle.module</code>。此外，我从StackOverflow上找到的工作区代码中删除了<code class="fe mu mv mw mx b">fatalError</code>,因此万一它在自定义搜索路径中找不到包，它不会失败，而是将<code class="fe mu mv mw mx b">return Bundle.module</code>作为后备。这应该使代码更有弹性，即使在未来的Xcode版本中修复了这个错误，也能继续工作，但自定义搜索路径可能不再工作。</p><p id="c7d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我必须在<code class="fe mu mv mw mx b">PersistenceController</code>中做的最后一个更改是用对新<code class="fe mu mv mw mx b">Bundle.swiftUIPreviewsCompatibleModule</code>的调用替换对<code class="fe mu mv mw mx b">Bundle.module</code>的调用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my lw l"/></div></figure><p id="ef4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我的SwiftUI预览又开始工作了！</p><pre class="kj kk kl km gt nn mx no np aw nq bi"><span id="93a9" class="nr ly it mx b gy ns nt l nu nv"><strong class="mx iu">Want to Connect?</strong></span><span id="f9ca" class="nr ly it mx b gy nw nt l nu nv">You can also find me on 👾 <a class="ae ky" href="https://www.twitch.tv/Jeehut" rel="noopener ugc nofollow" target="_blank">Twitch</a>, on 🎬 <a class="ae ky" href="https://www.youtube.com/channel/UCtg6Ck7oYa_9k1oSTmFGNRw" rel="noopener ugc nofollow" target="_blank">YouTube</a> and on 🐦 <a class="ae ky" href="https://twitter.com/Jeehut" rel="noopener ugc nofollow" target="_blank">Twitter</a>.</span></pre></div></div>    
</body>
</html>