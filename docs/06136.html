<html>
<head>
<title>Asynchronous Tasks in Python With the Concurrent.Futures Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的异步任务。期货模块</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/asynchronous-tasks-in-python-with-the-concurrent-futures-module-7325dc555d?source=collection_archive---------1-----------------------#2020-09-04">https://betterprogramming.pub/asynchronous-tasks-in-python-with-the-concurrent-futures-module-7325dc555d?source=collection_archive---------1-----------------------#2020-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e000" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中的多线程和并行编程比您想象的要简单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b1422a6af5462c7183587b8bff2a85f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5CMxBnvWXBaDra_0ir0H9Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">伊恩·贝克利在<a class="ae ky" href="https://www.pexels.com/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄的照片。</p></figure><p id="7e07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.python.org/3/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank">concurrent.futures</a></code>模块，用Python进行多线程和并行编程很容易。</p><p id="fd73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在试图解决AWS lambda函数在一些长时间的I/O操作完成之前超时的问题时，我使用一个<code class="fe lv lw lx ly b">ThreadPoolExecutor</code>重写了Python代码。它立即修复了问题。</p><p id="f6a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何使用<code class="fe lv lw lx ly b">concurrent.futures</code>模块来启动并行任务。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="add3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Python中的进程与线程</h1><p id="73f4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">concurrent.futures</code>模块为您提供了使用进程或线程的不同实现。</p><ul class=""><li id="10b5" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">多进程:使用<code class="fe lv lw lx ly b">ProcessPoolExecutor</code>的任务产生多个进程(每个进程都有自己的Python解释器)，通过这样做，它们绕过了Python的全局解释器锁。最适合CPU密集型任务。</li><li id="5830" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">多线程:使用<code class="fe lv lw lx ly b">ThreadPoolExecutor</code>的任务在同一个进程中使用多个线程。线程共享相同的解释器和内存空间。最适合I/O繁重的任务。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f21d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">多线程示例</strong></h1><p id="06ba" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">想象一个I/O密集型任务，比如从rest API获取数据。下面的例子正好说明了这一点。让我们使用法国政府的<a class="ae ky" href="https://geo.api.gouv.fr/adresse" rel="noopener ugc nofollow" target="_blank"> geo API </a>获取法国一组地址的详细信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="00bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数将负责获取数据。对于如何获得多个地址，我们有不同的方法。</p><h2 id="ca88" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated"><strong class="ak">选项1:顺序获取地址(剧透:这真的效率很低)</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="78c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段愚蠢的代码运行了0.267秒。它获取了所有的地址数据，但我们可以做得更好。</p><h2 id="9cdf" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated"><strong class="ak">选项2:使用多线程并行处理请求</strong></h2><p id="fd5a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了做到这一点，我们将使用Python的<code class="fe lv lw lx ly b">concurrent.futures</code>模块中的<code class="fe lv lw lx ly b">ThreadPoolExecutor</code>,这个模块从Python 3.2开始就可用了。它提供了异步执行任务的高级接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d140" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在我们的执行器中调用<code class="fe lv lw lx ly b">map</code>函数时，我们正在为可迭代的<code class="fe lv lw lx ly b">request_data</code>中的所有对象执行<code class="fe lv lw lx ly b">get_french_addresses</code>任务，并等待所有线程的结果。</p><p id="5cc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在0.177秒内获得所有API调用的响应，这比使用顺序版本要好。这是如何使用多线程的一个例子。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d138" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">多重处理示例</strong></h1><p id="7b07" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在是多重处理。这利用了不同的CPU内核来启动不同的Python解释器并并行化任务。这就是为什么它们应该被用来加速CPU繁重的任务，如数字运算。</p><p id="093c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们以这个函数为例，它取最小值和最大值，并对这些值之间的所有质数求和:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a66d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要为一组五对鞋运行这个函数。让我们看看我们如何能做它。</p><h2 id="e1b5" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated"><strong class="ak">方案一:依次计算每个数字(剧透:这样真的效率很低)</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e2d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们称<code class="fe lv lw lx ly b">find_prime_numbers_sum</code>为五对。它按顺序处理这些数字，总共花费了25.73秒。让我们看看是否可以通过并行化来改进它。</p><h2 id="05d6" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated"><strong class="ak">选项2:使用多处理并行化</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="33eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二个版本中，我们创建了一个最多有四个工作线程的进程池。<code class="fe lv lw lx ly b">run_heavy_function</code>是一个助手，允许我们用多个参数调用<code class="fe lv lw lx ly b">find_prime_numbers_sum</code>。运行这个版本后，计算所有素数需要15.529s。与以前的方法相比，这是一个很好的改进。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d33c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">摘要</h1><ul class=""><li id="e4fc" class="nd ne it lb b lc my lf mz li of lm og lq oh lu ni nj nk nl bi translated">当您想要并行处理CPU密集型任务时，请使用多进程，因为这可以利用多个CPU和内核。</li><li id="fc6d" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">当您需要并行处理I/O绑定的任务或创建响应性ui时，请使用多线程。请记住，线程不像进程那样是可中断/可终止的。</li></ul></div></div>    
</body>
</html>