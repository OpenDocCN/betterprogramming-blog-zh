# 为什么 React 的使用状态不是派生值的好解决方案

> 原文：<https://betterprogramming.pub/why-reacts-usestate-isn-t-a-good-solution-for-derived-values-2a8e41b55fe6>

## React 中使用状态的常见误用及更好的解决方案

![](img/bc45a4268f667bf7862badcb74f8362b.png)

图片由[费伦茨·阿尔马西](https://unsplash.com/@flowforfrank)在 [Unsplash](https://unsplash.com/) 拍摄

状态是 React 中的基本概念之一。`useState`钩子是功能性 React 组件中状态管理的基础。事实上，大多数初学者从学习状态管理和`useState`钩子开始他们的 React 之旅。

然而，在编写代码时，有些东西不幸地被用在了有更好替代方案的地方。这些通常会导致代码变得比实际需要的更复杂。在这里，我们将看看一个常见的滥用`useState`钩和一个更好的解决问题的方法。这种特殊的误用是我见过很多开发人员做的，也是我很长一段时间以来一直做的。

# 使用案例

为了研究如何更好地使用和管理状态，我们将实现一个用例。我们将创建一个名为`ColorList`的 React 组件。

*   组件以`startHex`、`endHex`、`selectedHexes`、`onColorClicked`为道具。
*   该组件显示位于`startHex`和`endHex`之间的所有颜色。如果这些属性中的任何一个发生变化，颜色列表也必须发生变化。
*   用户可以从列表中选择多种颜色。通过`selectedHexes`列表的颜色显示为选中。

例如:如果`startHex`为`#FF0000`且`endHex`为`#FF0002`，则组件将显示颜色`#FF0000`、`#FF0001`和`#FF0002`。

我们不会在这里实现算法，而只是看看与状态管理相关的东西。因此，我们将省略实际生成十六进制值的实现细节。

# 解决方案

我们可能会想出这样一个简单的解决方案:

这显然完成了任务。但是，这个组件有一个问题。该组件将在每次重新渲染时重新计算`allHexes`。每当父元素改变`selectedHexes`数组的值时，就会发生这些不必要的重新计算。每次单击一种颜色时，很可能会发生这种情况。

对于较小的组件来说，这不是一个大问题，但可能会降低这个特定组件的速度，比如说，当父组件想要生成所有颜色时，即`startHex`是`#000000`而`endHex`是`#FFFFFF`。这相当于 16，777，216 种颜色！所以我们可能要对此进行一点优化。

# 复杂的方式

我们现在已经停止在每次重新渲染时计算`allHexes`。相反，我们将`allHexes`置于一种状态。我们延迟计算初始状态，这样就不会在每次重新渲染时重新计算。然后每当`startHex`或`endHex`改变时，我们运行一个重新计算`allHexes`的效果。

***奖金提示:*** *你可以将一个函数作为初始值传递给* `*useState*` *。钩子将运行这个函数来初始化状态。在随后的重新渲染中，它将不会运行该函数。如果您发现自己在调用一个函数来计算初始状态，这是一个很好的选择。*

也就是说，你不必事事都使用惰性初始化。仅将它用于昂贵的计算。在其他情况下，这是不值得的，甚至可能会降低组件的速度。

这个解决方案的问题是，为了计算同一个变量的值，在两个不同的地方使用相同的参数调用了`calcColorsBetween`。

在本例中，如果我们需要将`calcColorsBetween`更改为其他函数，我们需要在两个地方进行更改。这里的代码比需要的要多。此外，阅读和维护这些代码比它需要的更困难。但只是两个地方，对吗？

不尽然！对于其他用例，可能是三个、四个甚至更多的地方。这是因为当`startHex`或`endHex`改变时`allHexes`必须更新。

要是有办法让这变得更容易就好了。嗯，有，而且完全不需要用`useState`！

# 更好的方法

我们已经删除了作为状态的`allHexes`。这是有道理的，因为当你仔细想想，`allHexes`更适合术语*派生值*而不是术语*状态*。这与我们最初的尝试相同，但增加了`useMemo`挂钩。

使用`useState`存储派生值需要在多个地方编写相同的代码。这可能会使阅读和维护代码变得更加困难。这是因为为了保持状态同步，由`useState`钩子返回的 setter 必须在每个依赖关系改变的地方被调用。

相反，当计算派生值很昂贵时，我们可以使用`useMemo`钩子。这个钩子接受一个返回值的函数。只有当派生值的任何依赖关系发生变化时，才会重新计算该值。这些依赖关系在第二个参数中列出，类似于`useEffect`。

# 结论

如果某个值可以使用已经可用的其他值来计算，那么将其存储为一个状态没有太大的好处。相反，它使代码更难维护。因此，最好是即时计算。如果性能是一个问题，那么可以使用`useMemo`。