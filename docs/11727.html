<html>
<head>
<title>Ace This Hard Computer Science Question In Your Next Coding Interview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在你的下一次编码面试中，Ace这个计算机科学难题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ace-this-hard-computer-science-question-in-your-next-coding-interview-4760b535c05c?source=collection_archive---------8-----------------------#2022-04-12">https://betterprogramming.pub/ace-this-hard-computer-science-question-in-your-next-coding-interview-4760b535c05c?source=collection_archive---------8-----------------------#2022-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3376" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提示:它需要组合多种数据结构</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/528add9e69be2bbadf85a18c86e6e99a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u5p72HZKerktHK4R"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·福南德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3b5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一些面试中，面试官会要求你设计一个数据结构，以满足一定的标准，并在特定的内存和速度限制下完成任务。</p><p id="fc96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我事先没有解决这个问题，所以我们将一起解决它。几天来，这个问题一直萦绕在我的脑海中，我突然有了一个难以捉摸的顿悟时刻。</p><p id="8387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些类型的问题比普通问题更难，如果你以前用过leetcode.com的<a class="ae ky" href="http://leetcode.com" rel="noopener ugc nofollow" target="_blank"/>，这个特定的问题属于中等类型。</p><p id="34c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不是非常难，但也绝不容易；这些问题通常需要更深入的思考，并结合两个或更多现有的数据结构来完成。</p><p id="82c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/91414237aee3b59280a946bc24ce2407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*88gUBZEh0D_fdE21"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="c3ca" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">这个问题</h1><p id="7bec" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这是直接从leetcode.com取出的</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/8c99cd912faad7ae34e9037cf927bd03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Js11xZh5MYrODNGj5nBvA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://leetcode.com/problems/lru-cache/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/lru-cache/</a></p></figure><h2 id="99a8" class="mu lx it bd ly mv mw dn mc mx my dp mg li mz na mi lm nb nc mk lq nd ne mm nf bi translated">理解问题</h2><p id="e1bf" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这个问题要求我们做几件事。</p><ul class=""><li id="8b65" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">首先，我们知道需要将项目存储为键:值对。如果它们存在，我们就返回值。如果不是，我们返回-1。</li><li id="7f37" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">如果键已经存在，我们还需要能够插入新的键-值对或更新值。</li><li id="3274" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">我们知道缓存有一个指定的<em class="nu">容量</em>，所以我们必须以某种方式跟踪最近最少使用的(LRU)项，并在插入新项之前删除它。</li></ul><h2 id="084b" class="mu lx it bd ly mv mw dn mc mx my dp mg li mz na mi lm nb nc mk lq nd ne mm nf bi translated">做出假设(并提出问题)</h2><p id="7799" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们可以从这些陈述中推断出一些东西，但无论如何，我们可以要求面试来确认我们确实走对了路。</p><ol class=""><li id="730a" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nv nm nn no bi translated">当我们添加一个新值或更新它时，我们把它移到列表的前面，使它成为最近使用的。</li><li id="4181" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">每当我们到达一个当前值时，我们就把它移到列表的前面。</li></ol><p id="443e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经解决了这个问题，让我们更深入地挖掘，并找出我们如何才能做到这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/f3b81ea5b1110c6f132811c06093043c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XmvqHEMI7EY3Vkvy"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@helloimnik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">你好我是尼克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h1 id="9a01" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">分解它</h1><h2 id="e0b4" class="mu lx it bd ly mv mw dn mc mx my dp mg li mz na mi lm nb nc mk lq nd ne mm nf bi translated">存储数据</h2><p id="5bf4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了将数据存储为键值对，我们可以使用哈希表。</p><p id="3dae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些语言中通常称为地图或字典。它在O(1)时间或常数时间内解决了我们的存储和检索问题。</p><h2 id="fd5f" class="mu lx it bd ly mv mw dn mc mx my dp mg li mz na mi lm nb nc mk lq nd ne mm nf bi translated">跟踪LRU项目</h2><p id="fa65" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">真正的问题是弄清楚如何跟踪哈希表中最近最少使用的项，并在空间用完时将其删除。</p><p id="3870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来的问题可能会要求您在固定时间内解决这两种方法，这种情况并不少见。</p><blockquote class="nx ny nz"><p id="26cb" class="kz la nu lb b lc ld ju le lf lg jx lh oa lj lk ll ob ln lo lp oc lr ls lt lu im bi translated">如果您不熟悉大O符号，这意味着存储、访问和删除LRU项应该总是在一个常量操作中执行，不管输入是什么。</p></blockquote><p id="e9ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们知道我们可以在固定时间内访问项目，但是我们可以使用什么数据结构来控制项目的顺序呢？</p><h1 id="35c4" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">一个链表！</h1><p id="0760" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">准确地说，是一个双向链表。</p><p id="1437" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不熟悉这种数据结构，请查看下面的文章。</p><div class="od oe gp gr of og"><a href="https://medium.com/javascript-in-plain-english/implementing-a-linked-list-in-javascript-717d2ab5d9a9" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">用JavaScript实现一个链表</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">今天我们将创建一个二叉查找树的实现，但是在我们写一行代码之前，它…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><p id="5c67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要每个节点的上一个和下一个指针来从列表中删除它们。</p><p id="7fca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">搜索一个链表需要O(n)次运算，其中n是链表的大小。</p><p id="09a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加和删除值就像修改一两个指针一样简单。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/41f32065763008e1a92a4ca15dfcdbbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vECJ996w2jM_TQZs"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@coopery?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">穆罕默德·诺哈西</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="83de" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">两全其美</h1><p id="02ad" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这就是神奇之处，因为我们使用一种数据结构的优势来弥补另一种数据结构的不足。</p><h2 id="0f9c" class="mu lx it bd ly mv mw dn mc mx my dp mg li mz na mi lm nb nc mk lq nd ne mm nf bi translated">对于链接列表</h2><p id="c0e6" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">链表不太适合查找值，但是如果你知道位置的话，它很适合修改顺序。</p><h2 id="6fa9" class="mu lx it bd ly mv mw dn mc mx my dp mg li mz na mi lm nb nc mk lq nd ne mm nf bi translated">对于哈希表</h2><p id="95e4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">哈希表很棒，可以快速找到值，但是它们通常是无序的，我们没有权限修改底层结构。</p><h1 id="2797" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">这将如何工作？</h1><p id="8aad" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，创建一个哈希表，其中的值引用LinkedList中的节点。</p><p id="fe58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">键将是相同的数字，但是链表将保存键和值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/f9031b0f45321bfef295c2c5f3c50bfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VQErKp1IgLZ0PtyZSDjWfw.png"/></div></div></figure><h2 id="f5e5" class="mu lx it bd ly mv mw dn mc mx my dp mg li mz na mi lm nb nc mk lq nd ne mm nf bi translated">为什么我们需要节点内部的密钥？</h2><p id="c008" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果我们想要删除LRU值——它将位于列表的末尾——我们还必须从哈希表中删除它。</p><p id="83b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LinkedList知道哪个项目是LRU，但是哈希表不知道。</p><blockquote class="nx ny nz"><p id="5878" class="kz la nu lb b lc ld ju le lf lg jx lh oa lj lk ll ob ln lo lp oc lr ls lt lu im bi translated">通过将键存储在列表中，我们知道应该删除哈希表中的哪一项。</p></blockquote><h1 id="ed77" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">跟踪链表中的LRU</h1><p id="5768" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在我们的列表中添加或删除项目时，我们必须执行某些操作。</p><ol class=""><li id="1ebd" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nv nm nn no bi translated"><strong class="lb iu">在清单前面加上</strong>(如果我们有空间的话)</li></ol><p id="61af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<strong class="lb iu">在get()调用后，将现有项目移动到列表的前面</strong></p><p id="c17e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.<strong class="lb iu">删除列表中的最后一项(最近最少使用的)</strong></p><blockquote class="nx ny nz"><p id="d399" class="kz la nu lb b lc ld ju le lf lg jx lh oa lj lk ll ob ln lo lp oc lr ls lt lu im bi translated"><strong class="lb iu">重要提示:</strong>我将提供一个可视化的表示，但是因为这部分更多的是关于链表，所以作为一个挑战，尝试自己解决它们。</p></blockquote><h1 id="c8d9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">添加到列表的前面</h1><p id="d913" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这个不会给你带来任何麻烦，因为它非常简单。但是，请记住更新所有受影响的节点！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/adaac5ad640f1d2964395ca1fccfe3e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1_qF012rivW_wffM_lGYBw.png"/></div></div></figure><h1 id="6eec" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">将现有项目移到前面</h1><p id="76d9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这里我们需要考虑三种情况。</p><h2 id="43df" class="mu lx it bd ly mv mw dn mc mx my dp mg li mz na mi lm nb nc mk lq nd ne mm nf bi translated">1.该项目已经在列表的最前面</h2><p id="ca9b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在这种情况下，我们什么都不做。</p><h2 id="e864" class="mu lx it bd ly mv mw dn mc mx my dp mg li mz na mi lm nb nc mk lq nd ne mm nf bi translated">2.这个项目在列表的末尾</h2><p id="9633" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果该项位于列表的末尾，我们必须更新受此操作影响的所有节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/2c3e1619340fcad5c11287258f92a6ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*HvyG6qeT6Y4rc7P8RQzy5Q.png"/></div></figure><h2 id="30cf" class="mu lx it bd ly mv mw dn mc mx my dp mg li mz na mi lm nb nc mk lq nd ne mm nf bi translated">3.该项目位于其他节点之间</h2><p id="baaa" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这里我们必须考虑上一个节点、下一个节点和节点的头。</p><p id="f59e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">小心点。这个是最棘手的！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/a29431631e09737b138b200d4a52e877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YeZBrULNpyYOxzaASFhWWA.png"/></div></div></figure><h1 id="b209" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">移除最后一个项目</h1><p id="fdc5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">删除最后一项很容易，因为我们只需要更新前一个节点以指向null。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/d7cbc008adb1addc485ce3100a2eb2cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjRT_9NOI5-umWencP8Nxg.png"/></div></div></figure><p id="10b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唷，有太多东西需要接受，但希望你能够迎接挑战。到目前为止，您的自定义双向链表的实现应该如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h1 id="6476" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">实现Get方法</h1><h2 id="557a" class="mu lx it bd ly mv mw dn mc mx my dp mg li mz na mi lm nb nc mk lq nd ne mm nf bi translated">这里有两种可能。</h2><ol class=""><li id="6295" class="ng nh it lb b lc mo lf mp li pa lm pb lq pc lu nv nm nn no bi translated">该键存在，所以我们返回值并将该项移到列表的前面。</li><li id="f0ed" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">值不存在，所以我们返回-1；</li></ol><p id="95d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个很简单，应该是这样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h1 id="75c8" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">实现Set方法</h1><p id="c20a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这是一个棘手的问题，但是我们已经实现了大部分繁重的工作，所以这应该不是问题。</p><h2 id="5ccf" class="mu lx it bd ly mv mw dn mc mx my dp mg li mz na mi lm nb nc mk lq nd ne mm nf bi translated">这里有三种可能性。</h2><ol class=""><li id="89b7" class="ng nh it lb b lc mo lf mp li pa lm pb lq pc lu nv nm nn no bi translated">这个键已经存在，所以我们更新了这个值，并把它移到列表的前面。</li><li id="0fd9" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">值不存在，我们仍然有空间——我们仍然有空间，所以我们将该项添加到列表和散列的前面。</li><li id="7ef9" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nv nm nn no bi translated">价值不存在，我们也没有空间。所以我们还需要从链表中删除最后一个值，并使用键将其从哈希表中删除。然后，我们可以将新项目添加到前面。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h1 id="44f1" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">最终结果</h1><p id="c23b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在这里，所有这些都放在一起，并从另一个文件导入DLinkedList。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h1 id="388d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">测试</h1><p id="04f3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们通过添加和删除值并打印结果来测试我们的数据结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="7ae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您将console.log添加到get函数中，您可以看到当我们试图调用<code class="fe pd pe pf pg b">get(2)</code>时，结果将是-1，因为我们正好在传递容量之前调用了<code class="fe pd pe pf pg b">get(1)</code>。</p><p id="82b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个将是列表中5之后的第二个元素，因此，当我们添加5时，2是LRU项，所以我们删除了它。</p><p id="34ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您显示该列表，您还可以看到它现在显示的是<code class="fe pd pe pf pg b">5 → 1 →4 →3 </code>，因为2是LRU，因此被删除了——因为容量是4。</p><h1 id="22df" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="19f8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果一切顺利，您现在可以体会到数据结构可以带来的价值。</p><p id="1d21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但更重要的是，将它们结合在一起可以给你力量，用一方的力量来弥补另一方的弱点。</p><p id="183f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，总会有权衡，在这种情况下，我们使用额外的空间来优化速度。</p><blockquote class="nx ny nz"><p id="b48c" class="kz la nu lb b lc ld ju le lf lg jx lh oa lj lk ll ob ln lo lp oc lr ls lt lu im bi translated">N <!-- -->注:<a class="ae ky" href="https://github.com/pacosw1/datastructures-ts/tree/master/LRU" rel="noopener ugc nofollow" target="_blank">完整的代码可以在这里找到</a>，但是我强烈推荐你在阅读文章的同时解决它。</p></blockquote></div></div>    
</body>
</html>