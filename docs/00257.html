<html>
<head>
<title>How to Build a Command Line JSON/CSV Converter in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python构建命令行JSON/CSV转换器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-command-line-json-csv-converter-in-python-204d74563456?source=collection_archive---------3-----------------------#2019-01-02">https://betterprogramming.pub/how-to-build-a-command-line-json-csv-converter-in-python-204d74563456?source=collection_archive---------3-----------------------#2019-01-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9327" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何构建CSV到JSON/JSON到CSV转换器的分步演练</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/04992df03a2b75f5edf9fcb6a4a283f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmIXwq_D3eBeqEEjZA-aEw.jpeg"/></div></div></figure><p id="d1e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不是开发商。我有一些编程的背景，但是我想说我更擅长跟随教程而不是编程。我开始这个项目，因为我厌倦了谷歌在线转换器和运行到文件的限制。该项目可在<a class="ae lq" href="https://github.com/jhsu98/json-csv-converter" rel="noopener ugc nofollow" target="_blank">https://github.com/jhsu98/json-csv-converter</a>获得，但是如果你想知道我是如何建造它的，那么请继续。</p><p id="f172" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们开始之前，我假设您已经安装了Python 3.x，并且知道要运行脚本，您需要键入<code class="fe lr ls lt lu b">python3 json-csv-converter.py</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6eed" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">入门指南</h1><p id="5296" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">我们需要导入四个库:os、csv、json和OrderedDict。跟随教程时，有一件事让我慢了下来，那就是不知道每个导入是用来做什么的。这里有一个快速纲要:</p><ul class=""><li id="c0a4" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated">操作系统:操作文件名并检查文件是否存在</li><li id="4ea4" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated"><strong class="kw iu"> csv: </strong>导入csv文件并写入转换后的CSV文件</li><li id="96bb" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated"><strong class="kw iu"> json: </strong>导入json文件并写入转换后的JSON文件</li><li id="1c54" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated"><strong class="kw iu"> OrderedDict: </strong>创建一个有序字典，它跟踪添加到对象的顺序属性。这是来自模块<code class="fe lr ls lt lu b">collections</code>。</li></ul><p id="32be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了导入这四个库，我们将使用<code class="fe lr ls lt lu b">import</code>关键字，后跟模块名。</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="ddfb" class="nr md it lu b gy ns nt l nu nv">import os <br/>import csv <br/>import json <br/>from collections import OrderedDict</span></pre><p id="462a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们添加一些欢迎用户使用我们的脚本的描述性文本。</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="8bca" class="nr md it lu b gy ns nt l nu nv">print("Welcome to the JSON-CSV Converter.") <br/>print("This script will convert a JSON file to CSV or a CSV file to JSON")</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="678e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">请求并加载文件</h1><p id="24b6" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">从这里开始，下一步是请求加载文件。我们可以做一个简单的输入，但是，如果文件不存在，我们的脚本的其余部分将无法工作。所以我们将使用try/except/else语句来控制我们的脚本流。以下是大致的结构:</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="77c4" class="nr md it lu b gy ns nt l nu nv">try: <br/>   # ask for the filename <br/>   # load data <br/>except Exception as e: <br/>   # print error message, exit script<br/>   print("Error opening file ... exiting:",e) <br/>   exit() <br/>else: <br/>   # convert the file and save the output</span></pre><p id="f7d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您仍然不确定代码块是如何工作的，那么<em class="nw"> try </em>部分将会执行，如果出现任何错误，除了部分之外的<em class="nw">部分将会执行。假设没有出错，一旦try <em class="nw"> </em>部分<em class="nw"> </em>完成，将执行<em class="nw"> else </em>部分。</em></p><p id="3700" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们具体询问文件名并加载文件。我们使用<code class="fe lr ls lt lu b">input</code>函数向用户询问文件名，并在基于句点(<code class="fe lr ls lt lu b">.</code>)进行分割时通过获取最后一部分来确定扩展名。然后，我们将使用适当的方法读入文件— <code class="fe lr ls lt lu b">csv.reader()</code>或<code class="fe lr ls lt lu b">json.load()</code>—同时打印一条错误消息，如果文件没有适当的扩展名，则退出。</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="c6a8" class="nr md it lu b gy ns nt l nu nv">try: <br/>   print("Which file do you want to convert?") <br/>   filename = input("Filename: ") <br/>   extension = filename.split(".")[-1].lower() <br/>   f = open(filename) <br/>   if extension == "csv": <br/>      # load csv file data = list(csv.reader(f)) <br/>      print("CSV file loaded") <br/>   elif extension == "json": <br/>      # load json file data = json.load(f, object_pairs_hook=OrderedDict) <br/>      print("JSON file loaded") <br/>   else: <br/>      print("unsupported file type ... exiting") <br/>      exit()</span></pre><p id="f14d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的论点<code class="fe lr ls lt lu b">object_pairs_hook=OrderedDict</code>很关键。如果没有这个设置，JSON键值对将是无序的，这意味着每个对象的属性将以不同的方式显示。<em class="nw"> OrderedDict </em>设置将确保属性保持其被读取的顺序。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b0db" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将CSV转换为JSON</h1><p id="8d83" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">我们将首先把CSV处理成JSON。因为CSV文件是表格形式的，所以第一行将包含每一列的名称。这些列名将成为JSON的键值对结构中的键。键是对象中值的标识符。知道了第一行是键，我们现在需要遍历剩余的数据行。为所有转换后的数据创建一个空列表后，将对每个包含数据的行执行以下步骤:</p><ol class=""><li id="bc84" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp nx nf ng nh bi translated">创建一个新的空有序字典</li><li id="9590" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nx nf ng nh bi translated">遍历每个值(电子表格中的每个单元格是什么)</li><li id="94bc" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nx nf ng nh bi translated">将键-值对添加到有序字典中，其中键是来自第一行的文本，值是数据(如果存在)或者是空的<code class="fe lr ls lt lu b">None</code>。</li><li id="63ab" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp nx nf ng nh bi translated">将该行的所有单元格添加到有序字典后，将对象添加到更大的数组中。</li></ol><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="c918" class="nr md it lu b gy ns nt l nu nv"># CONVERT CSV TO JSON<br/>if extension == "csv":<br/>   keys = data[0]<br/>   converted = []<br/>   for i in range(1, len(data)):<br/>      obj = OrderedDict()<br/>      for j in range(0,len(keys)):<br/>         if len(data[i][j]) &gt; 0:<br/>            obj[keys[j]] = data[i][j]<br/>         else:<br/>            obj[keys[j]] = None<br/>      converted.append(obj)</span></pre><p id="f904" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请务必仔细阅读代码。我们正在嵌套循环，所以外部循环使用变量<code class="fe lr ls lt lu b">i</code>，而内部循环使用变量<code class="fe lr ls lt lu b">j</code>。另外，请注意，外部循环从范围的索引1开始，因为第一行包含键而不是数据。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d697" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将JSON转换为CSV</h1><p id="84a4" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">现在编写将JSON转换成CSV的部分。块的一般结构是相似的，但是部分更复杂一点。这是因为在一个CSV文件中，所有的键都方便地位于第一行。在JSON文件中，每个对象都独立于其他对象，这意味着它可能有其他对象没有的键。这意味着我们需要遍历整个数据集来找到所有唯一的键。</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="0ecd" class="nr md it lu b gy ns nt l nu nv"># CONVERT JSON TO CSV<br/>if extension == "json":<br/>   # get all keys in json objects<br/>   keys = []</span><span id="f1df" class="nr md it lu b gy ny nt l nu nv">   for i in range(0,len(data)):<br/>      for j in data[i]:<br/>         if j not in keys:<br/>            keys.append(j)</span></pre><p id="c832" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有了所有的键，让我们创建一个数组来保存转换后的数据，并将这些键添加为第一行。接下来，我们将第二次遍历数据集。这里的技巧是嵌套循环不是数据，而是我们上面创建的键数组。我们必须确保数据的顺序与键的顺序相匹配。对于每个键——我们的CSV文件中的一列——如果该键存在于当前对象中，则添加相应的值，否则添加<code class="fe lr ls lt lu b">None</code>值。</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="53f4" class="nr md it lu b gy ns nt l nu nv"># map data in each row to key index<br/>converted = []<br/>converted.append(keys)</span><span id="6a24" class="nr md it lu b gy ny nt l nu nv">for i in range(0,len(data)):<br/>   row = []</span><span id="e4dc" class="nr md it lu b gy ny nt l nu nv">   for j in range(0,len(keys)):<br/>      if keys[j] in data[i]:<br/>         row.append(data[i][keys[j]])<br/>      else:<br/>         row.append(None)</span><span id="08fe" class="nr md it lu b gy ny nt l nu nv">   converted.append(row)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="803e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建转换后的文件</h1><p id="e56c" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">我们准备好将转换后的数据保存到一个新文件中。首先，让我们为即将转换的文件准备基本名称和扩展名。在<code class="fe lr ls lt lu b">try/except/else</code>的<code class="fe lr ls lt lu b">else</code>块中，我们将从之前输入的名称中分离出基本名称，并交换扩展。我们还需要确保我们即将发布的文件的名称不存在。如果它确实存在，我们将在文件名中添加一个数字迭代器。</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="4005" class="nr md it lu b gy ns nt l nu nv">converted_file_basename = os.path.basename(filename).split(".")[0]<br/>converted_file_extension = ".json" if extension == "csv" else ".csv"</span><span id="4848" class="nr md it lu b gy ny nt l nu nv">if(os.path.isfile(converted_file_basename + converted_file_extension)):<br/>   counter = 1</span><span id="78d7" class="nr md it lu b gy ny nt l nu nv">   while os.path.isfile(converted_file_basename + " (" + str(counter) + ")" + converted_file_extension):<br/>      counter += 1<br/>   <br/>converted_file_basename = converted_file_basename + " (" + str(counter) + ")"</span></pre><p id="476f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您不熟悉三元运算符，这是编写if/else语句的一种速记方式。Python处理顺序的方式与其他语言略有不同，其他语言的表达方式首先是肯定和否定。在Python中，首先是正数，然后是表达式，最后是else值。</p><p id="8bd4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的最后一步是使用<code class="fe lr ls lt lu b">json.dump()</code>或<code class="fe lr ls lt lu b">csv.writer()</code>方法在我们新创建的文件中写入数据。如果一切顺利，将打印一条成功消息。否则，将打印失败信息。</p><pre class="kj kk kl km gt nn lu no np aw nq bi"><span id="36a8" class="nr md it lu b gy ns nt l nu nv">try:<br/>   if converted_file_extension == ".json":<br/>      with open(converted_file_basename + converted_file_extension, 'w') as outfile:<br/>         json.dump(converted, outfile)<br/>   elif converted_file_extension == ".csv":<br/>      with open(converted_file_basename + converted_file_extension, 'w') as outfile:<br/>         writer = csv.writer(outfile)<br/>         writer.writerows(converted)<br/>except:<br/>   print("Error creating file ... exiting")<br/>else:<br/>   print("File created:",converted_file_basename + converted_file_extension)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cb10" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="bfb8" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">我希望你从这个教程中学到了一些东西。这里没有什么惊天动地的东西，它实际上是一个非常简单的脚本，但它满足了一个需要，我想分享我学到的东西。我完全知道我的代码可能会用到一些工作，你也可以去<a class="ae lq" href="https://github.com/jhsu98/json-csv-converter" rel="noopener ugc nofollow" target="_blank"> GitHub </a>查看回购协议。如果你没有按照上面的方法去做，克隆它，提交问题进行改进，我很乐意接受任何建设性的批评。</p><p id="b392" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nw">查看</em><a class="ae lq" href="https://github.com/jhsu98/json-csv-converter" rel="noopener ugc nofollow" target="_blank"><em class="nw">https://github.com/jhsu98/json-csv-converter</em></a>仓库</p></div></div>    
</body>
</html>