<html>
<head>
<title>Using Public IDs in an API Without Killing Database Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在不降低数据库性能的情况下在API中使用公共id</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-public-ids-in-an-api-without-killing-database-performance-1e4536c2af40?source=collection_archive---------3-----------------------#2021-01-18">https://betterprogramming.pub/using-public-ids-in-an-api-without-killing-database-performance-1e4536c2af40?source=collection_archive---------3-----------------------#2021-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f915" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们提高数据库速度</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a93ed1fae31a1e329b06b74485cb96e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2Hf2TOAb3uA5a4lF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@bradencollum?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布拉登·科拉姆</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="868f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你曾经访问过现代网络应用，你可能会注意到一个类似这样的网址:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f52b" class="ma mb it lw b gy mc md l me mf"><a class="ae ky" href="https://medium.com/p/1e4536c2af40" rel="noopener">https://medium.com/p/1e4536c2af40</a></span></pre><p id="fe0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">众所周知，URL的最后一位<code class="fe mg mh mi lw b"><a class="ae ky" href="https://medium.com/p/1e4536c2af40" rel="noopener">1e4536c2af40</a></code>是一个惟一的标识符，用于获取和显示资源。说到后端开发，这可以称之为公共ID。</p><p id="34e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，web应用程序或用户通常可以使用这个公共ID进行呼叫。Stripe的API文档中的API调用示例(本文中的示例是REST APIs，但它也与GraphQL APIs密切相关！):</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2a43" class="ma mb it lw b gy mc md l me mf"><a class="ae ky" href="https://api.stripe.com/v1/customers/abcdef123456" rel="noopener ugc nofollow" target="_blank">https://api.stripe.com/v1/customers/abcdef123456</a> </span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="dbd8" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">为什么公开id有用？</h1><p id="208f" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">使用公共ID的替代方法通常是使用数据库为该对象提供的主键。给定上面Stripe的API查询，它会变成类似于:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0d17" class="ma mb it lw b gy mc md l me mf"><a class="ae ky" href="https://api.stripe.com/v1/customers/abcdef123456" rel="noopener ugc nofollow" target="_blank">https://api.stripe.com/v1/customers/3</a></span></pre><h2 id="13de" class="ma mb it bd mr nm nn dn mv no np dp mz li nq nr nb lm ns nt nd lq nu nv nf nw bi translated"><strong class="ak">但是为什么这样更不好呢？</strong></h2><p id="7f81" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">这是一个很好的问题，关于这个话题有几个不同的阵营。</p><p id="1f3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要论点是，尽可能少地给出关于数据库的信息总是更好的主意。</p><p id="3a79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，使用真实的数据库ID所揭示的信息是ID本身，以及可能有多少行。在上面的例子中，攻击者可能会推断出<code class="fe mg mh mi lw b">/1</code>和<code class="fe mg mh mi lw b">/2</code>可能是真实的资源。使用公共ID，猜测真实资源的标识符变得更加困难。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="30ff" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">使用公共id的缺点是什么？</h1><p id="682e" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">反对使用公共id的主要理由是，很容易以负面影响性能的方式实现它们。考虑以下场景:</p><ul class=""><li id="f7d4" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">Stripe有一个用户数据库</li><li id="0d75" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">users表具有典型的自动递增和唯一整数主键</li><li id="a0bb" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">因为我们希望使用公共ID，所以每次创建用户时，Stripe都会生成一个公共ID，并将其作为文本存储在一个新列中</li><li id="9ec3" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">当给定一个公共ID调用get-user端点时，将触发一个查询，该查询按公共ID进行搜索并返回匹配的用户</li></ul><p id="74d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经发现了这里的问题。现在，数据库必须进行全表扫描，而不是通过唯一的主键进行搜索。这可以通过使public ID列惟一或被索引来缓解，但这并不理想，因为真正的主键列已经惟一并被索引了。</p><p id="4c08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有另一个问题:外键怎么办？如果我有一个用户可以拥有的<code class="fe mg mh mi lw b">paymentOption</code>对象，那么<code class="fe mg mh mi lw b">paymentOption</code> <code class="fe mg mh mi lw b">ownedByUserId</code>列应该是公共ID还是主键？API中应该返回什么？这已经变得一团糟了！</p><p id="37cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以做得更好。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="58ca" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">在不牺牲性能的情况下实现公共IDs</h1><p id="59b7" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">让我们在不影响性能的情况下重写条带场景:</p><ul class=""><li id="54b6" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">Stripe有一个用户数据库</li><li id="49a1" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">users表具有典型的自动递增和唯一整数主键</li><li id="d94b" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">除了这个主键之外，我们不在模式中添加任何东西</li></ul><p id="62a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不会在模式中做任何与公共id相关的事情，而是让它保持原样。现在让我们进入我们虚构的Stripe Node.js服务器。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="408e" class="ma mb it lw b gy mc md l me mf">const processGetQuery = (customerId) =&gt; {<br/>  const dbCustomer = await Database.fetchCustomer(customerId);<br/>  return dbCustomer;<br/>}</span></pre><p id="9589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们神奇的<code class="fe mg mh mi lw b">getCustomer</code>端点函数获取客户的ID，获取并返回对象。目前这使用一个真实的数据库ID。让我们解决这个问题。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f3c2" class="ma mb it lw b gy mc md l me mf">const getCustomerPublicId = (databaseId) =&gt; encodeFunction(`user-${databaseId}`);</span><span id="4827" class="ma mb it lw b gy ol md l me mf">const getCustomerDatabaseId = (publicId) =&gt; decodeFunction(`user-${databaseId}`);</span><span id="3909" class="ma mb it lw b gy ol md l me mf">const processGetQuery = (publicCustomerId) =&gt; {<br/>  const databaseId = getCustomerDatabaseId(publicCustomerId);<br/>  const dbCustomer = await Database.fetchCustomer(databaseId);<br/>  return {<br/>    ...dbCustomer,<br/>    id: getCustomerPublicId(dbCustomer.id)<br/>  };<br/>}</span></pre><p id="df3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，用户向API提供了一个公共ID。在服务器上，我们使用某种解码功能将其转换为数据库ID。然后，我们使用真正的主键获取客户并返回结果——在向用户显示之前，将ID编码为公共ID。</p><p id="1df8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经受益于标准自动递增整数主键带来的一切，不需要在数据库中瞎折腾了。</p><p id="406a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">关于前缀</strong>的快速说明:想知道为什么使用<code class="fe mg mh mi lw b">user-${databaseId}</code>翻译公共ID吗？那是因为在用户表上，有一个带<code class="fe mg mh mi lw b">primary key = 1</code>的用户，在另一个表上，会有另一个带<code class="fe mg mh mi lw b">primary key = 1</code>的对象。为了确保它们有不同的公共ID，我们在将表名交给编码函数之前，在表名前添加了数据库ID。</p><p id="a19d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">关于分布式数据库的快速说明</strong>:这种方法并不真正适用于分布式数据库场景，在分布式数据库场景中，由于体系结构的原因，您需要一个UUID，并且只能处理它！</p><p id="1d69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该使用哪种编码函数？在Node工作，我个人推荐<a class="ae ky" href="https://www.npmjs.com/package/hashids" rel="noopener ugc nofollow" target="_blank"> Hashids </a>。(注意:Hashids只支持整数编码，所以如果您不想从整数id编码，您需要找到另一个工具！)</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="560c" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">进一步优化</h1><p id="b42b" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">当然，在真实的应用程序中使用这种类型的代码会很快变得非常冗长。这是我在一个项目中做的一个片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="abf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到，添加新类型的ID并在任何地方快速访问它变得非常简单，而不需要太多的样板文件。</p></div></div>    
</body>
</html>