<html>
<head>
<title>Build Your Own AI-Powered Virtual Assistant on the Web</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在网络上建立你自己的人工智能虚拟助手</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-your-own-ai-powered-virtual-assistant-on-the-web-175fc9e61973?source=collection_archive---------2-----------------------#2022-08-21">https://betterprogramming.pub/build-your-own-ai-powered-virtual-assistant-on-the-web-175fc9e61973?source=collection_archive---------2-----------------------#2022-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0c59" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Houndify API</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bbedc746b33384a38afe40b1d7249506.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w7DG_ifl83zfRU-ilUX3_g.png"/></div></div></figure><p id="6ff9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇文章中，我将向你展示如果你不想花这笔钱，你可以如何集成<a class="ae ln" href="https://www.houndify.com/dashboard" rel="noopener ugc nofollow" target="_blank"> Houndify API </a>来制作一个类似Alexa或Siri的个人助理。下面是我们将要制作的演示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><h1 id="59e4" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">安装</h1><p id="1cc5" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">我们将使用<code class="fe mn mo mp mq b">create-react-app</code>和Typescript制作这个项目。</p><pre class="kg kh ki kj gt mr mq ms mt aw mu bi"><span id="e055" class="mv lr iq mq b gy mw mx l my mz">npx create-react-app my-assistant --template typescript</span></pre><p id="0baf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦完成，让我们安装我们需要开始的库。</p><pre class="kg kh ki kj gt mr mq ms mt aw mu bi"><span id="8c46" class="mv lr iq mq b gy mw mx l my mz">npm i houndify jotai react-feather</span></pre><p id="4666" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将为我们提供以下信息:</p><ul class=""><li id="a715" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">扩展节点SDK</li><li id="4a37" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">Jotai:一个简单的状态管理库(作为React上下文API的替代)</li><li id="4758" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">react-feather是来自feathericons.com的伟大开源图标的包装器</li></ul><p id="841a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还将使用Sass来设计我们的组件，并使用<code class="fe mn mo mp mq b">npm i -D sass</code>进行安装。</p><h1 id="4249" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">创建服务器</h1><p id="4f0e" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">我们首先需要一个服务器来验证对Houndify API的请求。Houndify SDK提供了一个<code class="fe mn mo mp mq b">HoundifyExpress</code>对象。这将连接到一个Express服务器，并在<code class="fe mn mo mp mq b">server.js</code>中添加我们需要的路线。添加以下代码来设置服务器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no lp l"/></div></figure><p id="8e9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，它还服务于来自<code class="fe mn mo mp mq b">build</code>目录的<code class="fe mn mo mp mq b">index.html</code>文件。因此，如果我们要部署这个应用程序，我们将首先运行<code class="fe mn mo mp mq b">npm run build</code>来生成静态文件。然后运行<code class="fe mn mo mp mq b">node server.js</code>启动服务器并从那里访问应用程序。</p><p id="656e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外，注意我们正在使用的环境变量，在<code class="fe mn mo mp mq b">.env</code>中配置，我们还没有添加。我们也没有客户ID和客户密钥。所以让我们从Houndify API开始吧。</p><h1 id="dd69" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">使用API仪表板</h1><p id="4798" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">在<a class="ae ln" href="https://www.houndify.com/signup" rel="noopener ugc nofollow" target="_blank"> Houndify </a>免费创建一个开发者账户，然后创建一个新的客户端。进入后，输入应用程序的名称和类型，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/c2b1d8192cbad5ce85e93eb49fa2140c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p8DA8LGaBzxb4BU0.jpeg"/></div></div></figure><p id="f63a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，你应该会看到一个页面，询问你想要为应用程序启用哪些域。我们将使用以下十个域(全部来自第一页):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/d4314296bcba8cbe57b5e9d033baaed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_PuXAO0-1QzoyrNr.jpeg"/></div></div></figure><p id="1bf1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你看一看，其中一些领域需要客户端集成。客户端必须应用额外的逻辑来集成功能。我们可以在以后添加其他域，但是现在，我们不需要它们。</p><p id="88fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">点击显示概述和API键的按钮:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/3768edec166d1b05c07dd9fdb35b05de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_1WQqHPcRrV4S8JB.jpeg"/></div></div></figure><p id="bd60" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在那里，复制客户端ID和客户端密钥，并将它们添加到下面的<code class="fe mn mo mp mq b">.env</code>文件中:</p><pre class="kg kh ki kj gt mr mq ms mt aw mu bi"><span id="c12c" class="mv lr iq mq b gy mw mx l my mz">HOUNDIFY_CLIENT_ID={YOUR_CLIENT_ID}<br/>HOUNDIFY_CLIENT_KEY={YOUR_CLIENT_SECRET}</span></pre><p id="997d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们准备开始构建前端。</p><h1 id="a32c" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">创建语音请求</h1><p id="52f0" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">首先，打开<code class="fe mn mo mp mq b">src</code>目录，删除以下我们不需要的文件:</p><ul class=""><li id="d1d5" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">徽标. svg</li><li id="2b7e" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">setupTests.ts</li><li id="0425" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">App.test.tsx</li></ul><p id="c19f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，定义一个函数来初始化对houndify API的语音请求。它获取关于音频流的信息，并使用处理程序来捕获各种事件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no lp l"/></div></figure><p id="f628" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来分解这段代码:</p><ul class=""><li id="7b97" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">RequestHandlers:响应语音请求状态的函数的类型接口</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no lp l"/></div></figure><ul class=""><li id="8c6e" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">对话状态:在此阅读文档<a class="ae ln" href="https://www.houndify.com/docs#conversation-state" rel="noopener ugc nofollow" target="_blank"/></li><li id="9b12" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">记录器:来自SDK的一个<code class="fe mn mo mp mq b">AudioRecorder</code>对象。它允许从用户的麦克风捕获音频流。我们必须在这里使用<code class="fe mn mo mp mq b">any</code>类型，因为SDK没有定义类型(真遗憾！)</li><li id="db3c" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">enableVAD:启用时，一旦用户停止讲话，就会发送请求</li><li id="2c73" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">ts-ignore:禁用编辑器中访问<code class="fe mn mo mp mq b">window.Houndify</code>的linter警告。这包含对Houndify浏览器SDK的引用。我们可以在<code class="fe mn mo mp mq b">public/index.html</code>中包含来自CDN的SDK，代码如下:</li></ul><p id="af9e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mn mo mp mq b">&lt;script src="https://unpkg.com/houndify@3.1.12/dist/houndify.js"&gt;&lt;/script&gt;</code></p><h1 id="ddc0" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">语音输入显示器</h1><p id="7e72" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">现在在<code class="fe mn mo mp mq b">src</code>目录中创建一个名为<code class="fe mn mo mp mq b">VoiceInput.tsx</code>的文件，并添加以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no lp l"/></div></figure><p id="252e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该组件执行以下操作:</p><ul class=""><li id="def9" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">获取一个转录字符串，该字符串将记录用户当前所说的内容</li><li id="e2df" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">利用<code class="fe mn mo mp mq b">lib/store.ts</code>中定义的原子。这允许我们访问我们的<code class="fe mn mo mp mq b">AudioRecorder</code>对象和一个<code class="fe mn mo mp mq b">recording</code>布尔值。这决定了用户的麦克风是否被捕获</li><li id="415a" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">当点击按钮时，录音机被切换。该按钮的图标也会随之更新</li></ul><p id="bce9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以用下面的代码添加样式表了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no lp l"/></div></figure><p id="4b93" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以在<code class="fe mn mo mp mq b">src/lib/store.ts</code>文件中定义我们的<code class="fe mn mo mp mq b">atoms</code>:</p><pre class="kg kh ki kj gt mr mq ms mt aw mu bi"><span id="cbe0" class="mv lr iq mq b gy mw mx l my mz">import { atom } from "jotai";</span><span id="d7fe" class="mv lr iq mq b gy nr mx l my mz">export const recorderAtom = atom&lt;any&gt;(null);<br/>export const recordingAtom = atom(false);</span></pre><h1 id="e434" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">构建应用程序组件</h1><p id="9c16" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">用以下代码替换<code class="fe mn mo mp mq b">src/App.tsx</code>的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no lp l"/></div></figure><p id="4ffc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，定义我们的语音请求处理器功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no lp l"/></div></figure><p id="0028" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以在这里查看服务器响应格式<a class="ae ln" href="https://www.houndify.com/docs#server-response" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="def3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以创建一个挂载效果来初始化AudioRecorder对象。然后，它将其事件与初始化的VoiceRequest对象联系起来:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no lp l"/></div></figure><h1 id="e3c8" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">首次预览</h1><p id="aa03" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">首先，在<code class="fe mn mo mp mq b">src/index.css</code>中添加我们的全局样式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no lp l"/></div></figure><p id="62ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这使得我们的主div元素占据了整个页面，并将所有内容保存在一个视图中。</p><p id="0b2c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了让来自<code class="fe mn mo mp mq b">create-react-app</code>的服务器了解我们的另一个服务器，我们需要向我们的<code class="fe mn mo mp mq b">package.json</code>文件添加一个<code class="fe mn mo mp mq b">proxy</code>:</p><pre class="kg kh ki kj gt mr mq ms mt aw mu bi"><span id="c002" class="mv lr iq mq b gy mw mx l my mz">{<br/>    ...<br/>    "proxy": "http://localhost:8080",<br/>    ...<br/>}</span></pre><p id="3de0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在在项目目录中打开一个终端窗口，在另一个窗口中运行<code class="fe mn mo mp mq b">node server.js</code>和<code class="fe mn mo mp mq b">npm start</code>。</p><p id="423e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果一切正常，端口8080上的服务器应该记录8080，dev服务器应该记录它自己的端口。在您的浏览器中打开后者，您应该会看到以下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/7b0205a387407e0d25394565fb09bccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Xh1EyjOikCe1PTJS.jpeg"/></div></div></figure><p id="1d20" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您尝试单击按钮并说出一个命令，客户端会向服务器发送请求。同时，它显示部分转录。但之后不会发生其他事情。因此，让我们向应用程序添加输出。</p><h1 id="71f6" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">向语音添加文本</h1><p id="0b35" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">我们希望显示来自服务器的书面响应或口头响应。让我们使用语音响应并使用<a class="ae ln" href="https://github.com/mdn/dom-examples/tree/master/web-speech-api" rel="noopener ugc nofollow" target="_blank"> Web语音API </a>实现TTS，这样应用程序就可以“说出”响应。</p><p id="b9e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">设置这一点很简单，只需首先将以下内容添加到<code class="fe mn mo mp mq b">App.tsx</code>文件的顶部:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no lp l"/></div></figure><p id="6e41" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后将这段代码添加到我们的<code class="fe mn mo mp mq b">handleResult</code>函数中:</p><pre class="kg kh ki kj gt mr mq ms mt aw mu bi"><span id="d842" class="mv lr iq mq b gy mw mx l my mz">const handleResult = (result: any) =&gt; {<br/>    // We'll add more here later<br/>    say(result["SpokenResponseLong"]);<br/>};</span></pre><p id="9239" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一切都准备好了！</p><h1 id="3510" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">声频反馈</h1><p id="f811" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">当用户按下主按钮时，我们还可以添加一些听觉反馈。我们可以用Howler.js库来播放音频文件，我们可以用下面这行代码来安装它:</p><pre class="kg kh ki kj gt mr mq ms mt aw mu bi"><span id="2b03" class="mv lr iq mq b gy mw mx l my mz">npm i howler</span></pre><p id="acd8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后在<code class="fe mn mo mp mq b">lib/playSound.ts</code>创建一个文件，该文件具有播放任何音频源的功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no lp l"/></div></figure><p id="048c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，在我们的<code class="fe mn mo mp mq b">App.tsx</code>文件顶部导入我们需要的所有内容，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no lp l"/></div></figure><p id="c7cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以在这里下载麦克风提示音。用各自的名字:<code class="fe mn mo mp mq b">start</code>和<code class="fe mn mo mp mq b">stop</code>将它们添加到<code class="fe mn mo mp mq b">src/audio</code>文件夹中。</p><p id="7393" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后将下面一行添加到<code class="fe mn mo mp mq b">setRecording</code>函数中:</p><pre class="kg kh ki kj gt mr mq ms mt aw mu bi"><span id="0169" class="mv lr iq mq b gy mw mx l my mz">playSound(sources[value ? "start" : "stop"]);</span></pre><p id="4187" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在打开浏览器。您应该会听到播放的音频和口头回应。</p><h1 id="5847" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">奖励—可视化音频输入</h1><p id="e76b" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">我们可以使用Wave.js库来可视化来自用户麦克风的音频，并使用以下代码行安装它:</p><pre class="kg kh ki kj gt mr mq ms mt aw mu bi"><span id="d963" class="mv lr iq mq b gy mw mx l my mz">npm i <a class="ae ln" href="https://github.com/WoolDoughnut310/Wave.js" rel="noopener ugc nofollow" target="_blank">https://github.com/WoolDoughnut310/Wave.js</a></span></pre><p id="17d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">确保从我的回购安装它，而不是从NPM。这是因为我对它做了一点小小的改动，使它可以和我们的<code class="fe mn mo mp mq b">AudioRecorder</code>对象一起工作。我已经发出了一个pull请求，但是我仍然在等待库作者的响应。</p><p id="5fe2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">打开<code class="fe mn mo mp mq b">src/VoiceInput.tsx</code>并添加以下导入语句:</p><pre class="kg kh ki kj gt mr mq ms mt aw mu bi"><span id="4c14" class="mv lr iq mq b gy mw mx l my mz">import { Wave } from "@foobar404/wave";</span></pre><p id="6d28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后将以下代码添加到我们之前创建的<code class="fe mn mo mp mq b">onClickMic</code>函数的末尾:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no lp l"/></div></figure><p id="301f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在运行代码，我们应该和开始展示的演示一样了。</p><h1 id="5fdb" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">最终注释</h1><p id="17cc" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mk lc ld le ml lg lh li mm lk ll lm ij bi translated">如果您有任何问题，请随时发表评论。如果你对这个基于网络的Jarvis克隆感到满意，一定要和朋友们分享。下一次，我们将实现额外的功能，如音乐播放和歌曲识别。和以前一样，我把代码留在了我的<a class="ae ln" href="https://github.com/WoolDoughnut310/houndify-voice-assistant/tree/part1" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上，所以尽情享受吧。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="fead" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nz">原载于</em><a class="ae ln" href="https://cs310.hashnode.dev/build-your-own-ai-powered-virtual-assistant-on-the-web-part1" rel="noopener ugc nofollow" target="_blank"><em class="nz">https://cs 310 . hash node . dev</em></a><em class="nz">。</em></p></div></div>    
</body>
</html>