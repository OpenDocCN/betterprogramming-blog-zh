<html>
<head>
<title>The Duality of CLS With Lazy Loading Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有惰性加载分量的CLS的对偶</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-duality-of-cls-with-lazy-loading-components-c0a0e06eabf8?source=collection_archive---------20-----------------------#2022-03-28">https://betterprogramming.pub/the-duality-of-cls-with-lazy-loading-components-c0a0e06eabf8?source=collection_archive---------20-----------------------#2022-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9a9f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建优化的web应用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a3b5326cf055f8c48cd77147e555af19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*knH5ID3Ddftya47sCEhreg.png"/></div></div></figure><p id="8ce0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你优化你的web应用程序时，你的目标是让用户体验更好:这意味着通常通过传输和解析更少的数据来“更快”。但是注意:同样的web应用程序在较慢的连接上可能会导致累积布局偏移(CLS ),但是在较快的连接上运行时没有CLS。</p><p id="439c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想重温一下网络的核心要素，我在<a class="ae ln" href="https://wicki.io/posts/2021-07-core-web-vitals/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中用gif图解释了它们。</p><blockquote class="lo lp lq"><p id="5d5d" class="kr ks lr kt b ku kv jr kw kx ky ju kz ls lb lc ld lt lf lg lh lu lj lk ll lm ij bi translated"><strong class="kt ir">TL；博士:</strong>较慢的连接<em class="iq">会</em>导致CLS，因为你在wifi连接上看不到它。</p><p id="e1ee" class="kr ks lr kt b ku kv jr kw kx ky ju kz ls lb lc ld lt lf lg lh lu lj lk ll lm ij bi translated">要么根本不要延迟加载组件，要么等待js文件被加载和挂载。</p></blockquote></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="0181" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">二元性</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/62aed0900aff452d7ceb45c50d848214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*4XnCQjFaf-YEF1EKXpfdsw.gif"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">慢速与快速连接:相同的网络应用程序，不同的CLS。</p></figure><p id="f016" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们假设一个web应用程序在较慢的连接上加载相同的内容，只是慢了<em class="lr"/>。不幸的是，懒惰的可加载组件并不总是这样。</p><p id="dab8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于惰性可加载组件，我们处理两个<code class="fe mz na nb nc b">asyncnesses</code>:</p><ol class=""><li id="6d6c" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm ni nj nk nl bi translated">异步API响应(JSON)</li><li id="8c78" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated">异步延迟加载组件(JS)</li></ol><p id="0cc3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果API响应(1)比动态加载的JS (2)快会怎样？如果您延迟加载位于web内容中间的组件会怎么样？你在上面谷歌截图中看到的这些问题的答案将会用CLS惩罚你。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="02a0" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">CLS测量</h1><p id="e8c2" class="pw-post-body-paragraph kr ks iq kt b ku nr jr kw kx ns ju kz la nt lc ld le nu lg lh li nv lk ll lm ij bi translated">我已经看到了很多关于核心网站的困惑，尤其是CLS。</p><p id="8263" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与其他核心网络指标不同的是，CLS被持续测量，并且<em class="lr">被累计</em>计入得分。对于一个经典的SPA网络应用程序，这意味着谷歌将保留每条路线的CLS分数。</p><p id="e4ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">CLS有以下特点:</p><ul class=""><li id="5425" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm nw nj nk nl bi translated">每次路由更改后，CLS重置为0</li><li id="b26c" class="nd ne iq kt b ku nm kx nn la no le np li nq lm nw nj nk nl bi translated">在任何用户交互之后，您将获得500毫秒的宽限期，在此期间，CLS不会被考虑在内</li></ul><p id="9db7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">真实用户的测量</strong> : Chrome用户直接向谷歌发送核心网络重要指标。它不是一个在抓取网站时捕捉这些指标的Googlebot。</p><p id="676b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些真实的用户测量被收集为<a class="ae ln" href="https://web.dev/lab-and-field-data-differences/#field-data" rel="noopener ugc nofollow" target="_blank">现场数据</a>并流入谷歌的<a class="ae ln" href="https://developers.google.com/web/tools/chrome-user-experience-report" rel="noopener ugc nofollow" target="_blank">症结报告</a>。</p><p id="8eab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着你需要考虑现实世界:</p><ul class=""><li id="3fbb" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm nw nj nk nl bi translated">如果你有很多来自印度的流量，但是你的服务器在世界的另一端，你的LCP(最大内容油漆)可能会受到影响。</li><li id="55a0" class="nd ne iq kt b ku nm kx nn la no le np li nq lm nw nj nk nl bi translated">如果你有很多来自中国的流量，很可能一些服务被中国的互联网服务提供商屏蔽了，无法加载。这可能会在您的内容中导致不必要的CLS。</li></ul></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="7e9f" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">解决方法</h1><p id="5cdf" class="pw-post-body-paragraph kr ks iq kt b ku nr jr kw kx ns ju kz la nt lc ld le nu lg lh li nv lk ll lm ij bi translated">我们需要完全控制在什么时间向用户显示什么。考虑到二元性，我们需要知道以下几点:</p><ul class=""><li id="5899" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm nw nj nk nl bi translated">API请求还在加载吗？</li><li id="ded9" class="nd ne iq kt b ku nm kx nn la no le np li nq lm nw nj nk nl bi translated">异步组件还在加载吗？</li></ul><p id="1c06" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">骨架加载器是等待API请求和异步组件都准备好的理想方式。</p><h1 id="d134" class="mc md iq bd me mf nx mh mi mj ny ml mm jw nz jx mo jz oa ka mq kc ob kd ms mt bi translated">解决方案1:根本不要延迟加载组件</h1><p id="6828" class="pw-post-body-paragraph kr ks iq kt b ku nr jr kw kx ns ju kz la nt lc ld le nu lg lh li nv lk ll lm ij bi translated">最快且最不容易出错的解决方案是传递延迟加载组件。在大多数情况下，通过延迟加载节省的千字节数不足以抵消它可能导致的CLS。如果您的性能预算允许，请使用此解决方案。</p><p id="d323" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我们有一个Vue web应用，有10%的登录用户。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="21ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果没有代码分割，我们会将<code class="fe mz na nb nc b">&lt;HugeComponent&gt;</code>的JS发送给90%不需要它的用户。这会影响LCP和FID。</p><p id="7711" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过代码分割，我们将把<code class="fe mz na nb nc b">&lt;HugeComponent&gt;</code>的JS打包到additional-comps.js块中，只在需要的时候通过网络发送。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="a17f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有两个标准可以帮助您决定是否应该延迟加载组件:</p><ul class=""><li id="771a" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm nw nj nk nl bi translated"><code class="fe mz na nb nc b">&lt;HugeComponent&gt;</code>的大小</li><li id="8448" class="nd ne iq kt b ku nm kx nn la no le np li nq lm nw nj nk nl bi translated">多久向用户呈现一次<code class="fe mz na nb nc b">&lt;HugeComponent&gt;</code></li></ul><p id="4b8f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您得出的结论是您的性能预算紧张，您需要延迟加载组件，请参见解决方案2。</p><h1 id="be49" class="mc md iq bd me mf nx mh mi mj ny ml mm jw nz jx mo jz oa ka mq kc ob kd ms mt bi translated">解决方案#2:等待组件的加载和安装</h1><p id="03f0" class="pw-post-body-paragraph kr ks iq kt b ku nr jr kw kx ns ju kz la nt lc ld le nu lg lh li nv lk ll lm ij bi translated">如果您的组件没有被大多数用户使用，并且会增加很多捆绑包，那么看看这个解决方案。</p><p id="1bb4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">等待异步组件被延迟加载和挂载可能很棘手。您需要渲染组件，但是安装会在以后进行。以下是如何做到这一点的要点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="395e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们不使用<code class="fe mz na nb nc b">display: hidden</code>作为<code class="fe mz na nb nc b">&lt;HugeComponent&gt;</code>上的加载状态，我们永远不会触发异步组件的加载。因此，永远不会到达第28行，并且<code class="fe mz na nb nc b">isLoading</code>状态将永远停留在<code class="fe mz na nb nc b">false</code>上。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="c2f9" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">结论</h1><p id="2e06" class="pw-post-body-paragraph kr ks iq kt b ku nr jr kw kx ns ju kz la nt lc ld le nu lg lh li nv lk ll lm ij bi translated">当你在谷歌搜索控制台<a class="ae ln" href="https://search.google.com/search-console" rel="noopener ugc nofollow" target="_blank">中因为CLS而丢失绿色网址，并且你自己无法重现时，试着用较慢的连接调试你的网络应用。</a></p><p id="9f7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以如果你使用懒惰的可加载组件，很有可能成为CLS二元性的受害者。</p></div></div>    
</body>
</html>