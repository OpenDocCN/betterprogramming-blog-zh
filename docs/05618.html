<html>
<head>
<title>3 Mistakes Junior Developers Make With React Function Component State</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初级开发人员在使用React函数组件状态时犯的3个错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-mistakes-junior-developers-make-with-react-function-component-state-8a744ab99a0d?source=collection_archive---------1-----------------------#2020-07-22">https://betterprogramming.pub/3-mistakes-junior-developers-make-with-react-function-component-state-8a744ab99a0d?source=collection_archive---------1-----------------------#2020-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0364" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">“初级开发人员对React组件状态犯的3个错误”的后续</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e397080fb1dca834393cd5b9677dd009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tNujN7ngHldWUdg5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@zyan_bmo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Zyanya BMO </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="4816" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几周前，我写了一篇关于开发人员在使用React组件状态时有时会犯的错误的文章。我提供的所有例子都使用了类组件和<code class="fe lv lw lx ly b">setState</code>方法。</p><p id="9f3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有人几次问我，这些原则是否也适用于函数组件和钩子。答案是肯定的！</p><p id="2755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据大众的需求，我们将在本文中探索这些相同的概念，但是这次是使用<code class="fe lv lw lx ly b">useState</code>钩子的功能组件。我们将看看三个常见的错误以及如何纠正它们。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="282c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">1.直接修改状态</h1><p id="4b33" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当改变一个组件的状态时，重要的是返回一个修改过的状态的新副本，而不是直接修改当前状态。如果您错误地修改了组件的状态，React的区分算法将不会捕捉到更改，并且您的组件将不会正确更新。</p><p id="63dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子。假设你有这样一个状态:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="1c0e" class="nh mh it ly b gy ni nj l nk nl">const initialState = ['red', 'blue', 'green']<br/>let [colors] = useState(initialState)</span></pre><p id="c90c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你想给这个数组添加颜色<code class="fe lv lw lx ly b">yellow</code>。这样做可能很诱人:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="f4f2" class="nh mh it ly b gy ni nj l nk nl">colors.push('yellow')</span></pre><p id="5e38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">甚至是这个:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9edc" class="nh mh it ly b gy ni nj l nk nl">colors = [...colors, 'yellow']</span></pre><p id="caa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这两种方法都是不正确的！当在一个函数组件中更新状态时，你总是需要使用由<code class="fe lv lw lx ly b">useState</code>钩子提供的setter方法，并且你应该总是小心不要改变对象。setter方法是数组中<code class="fe lv lw lx ly b">useState</code>返回的第二个元素，所以你可以像析构state值一样析构它。</p><p id="3054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将元素添加到数组的正确方法如下:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="905b" class="nh mh it ly b gy ni nj l nk nl">// Initial setup<br/>const initialState = ['red', 'blue', 'green']<br/>const [colors, setColors] = useState(initialState)</span><span id="872d" class="nh mh it ly b gy nm nj l nk nl">// Later, modifying the state<br/>setColors(colors =&gt; [...colors, 'yellow'])</span></pre><p id="27e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我们犯了第二个错误。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2919" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">2.设置依赖于前一状态而不使用函数的状态</h1><p id="b59f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有两种方法可以使用<code class="fe lv lw lx ly b">useState</code>钩子返回的setter方法。第一种方法是提供一个新值作为参数。第二种方法是提供一个函数作为参数。那么，你什么时候想用一个而不是另一个呢？</p><p id="7ccc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您有一个可以启用或禁用的按钮，您可能会有一个名为<code class="fe lv lw lx ly b">isDisabled</code>的状态来保存一个布尔值。如果您想将按钮从启用状态切换到禁用状态，那么编写类似下面这样的代码，使用一个值作为参数:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="1330" class="nh mh it ly b gy ni nj l nk nl">// Initial setup<br/>const [isDisabled, setIsDisabled] = useState(false)</span><span id="a965" class="nh mh it ly b gy nm nj l nk nl">// Later, modifying the state<br/>setIsDisabled(!isDisabled)</span></pre><p id="d9f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，这有什么错呢？问题在于React状态更新可以是批处理的，这意味着多个状态更新可以在一个更新周期中发生。如果您的更新是批处理的，并且您有多个更新处于启用/禁用状态，那么最终结果可能不是您所期望的。</p><p id="e14c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新此处状态的更好方法是提供前一状态的函数作为参数:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="654c" class="nh mh it ly b gy ni nj l nk nl">// Initial setup<br/>const [isDisabled, setIsDisabled] = useState(false)</span><span id="fc95" class="nh mh it ly b gy nm nj l nk nl">// Later, modifying the state<br/>setIsDisabled(isDisabled =&gt; !isDisabled)</span></pre><p id="a096" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，即使您的状态更新是批处理的，并且对启用/禁用状态的多次更新是一起进行的，每次更新都将依赖于正确的先前状态，以便您总是以您期望的结果结束。</p><p id="687d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于像递增计数器这样的事情也是如此。</p><p id="e66f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要这样做:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="cf64" class="nh mh it ly b gy ni nj l nk nl">// Initial setup<br/>const [counterValue, setCounterValue] = useState(0)</span><span id="ccd6" class="nh mh it ly b gy nm nj l nk nl">// Later, modifying the state<br/>setCounterValue(counterValue + 1)</span></pre><p id="0d98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行以下操作:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e79f" class="nh mh it ly b gy ni nj l nk nl">// Initial setup<br/>const [counterValue, setCounterValue] = useState(0)</span><span id="8d1e" class="nh mh it ly b gy nm nj l nk nl">// Later, modifying the state<br/>setCounterValue(counterValue =&gt; counterValue + 1)</span></pre><p id="2a06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的关键是，如果你的新状态依赖于旧状态的值，你应该总是使用一个函数作为参数。如果您设置的值不依赖于旧状态的值，则可以使用值作为参数。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2c9a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">3.忘记了useState中的Setter方法是异步的</h1><p id="9ab4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最后，重要的是要记住由<code class="fe lv lw lx ly b">useState</code>钩子返回的setter方法是一个异步方法。例如，假设我们有一个状态如下的组件:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="89f2" class="nh mh it ly b gy ni nj l nk nl">const [name, setName] = useState('John')</span></pre><p id="8b7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们有一个更新状态并将状态记录到控制台的方法:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="66f5" class="nh mh it ly b gy ni nj l nk nl">const setNameToMatt = () =&gt; {<br/>  setName('Matt')<br/>  console.log(`The name is now... ${name}!`)<br/>}</span></pre><p id="8de6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能认为这会将<code class="fe lv lw lx ly b">'Matt'</code>记录到控制台，但事实并非如此！它记录了<code class="fe lv lw lx ly b">'John'</code>！</p><p id="34a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的原因是，<code class="fe lv lw lx ly b">useState</code>钩子返回的setter方法是异步的。这意味着当它到达调用<code class="fe lv lw lx ly b">setName</code>的代码行时，它将开始状态更新，但是它下面的代码将继续执行，因为异步代码是非阻塞的。</p><p id="bcf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有需要在状态更新后运行<em class="nn">的代码，React提供了<code class="fe lv lw lx ly b">useEffect</code>钩子，允许您编写在任何指定的依赖项更新后运行的代码。</em></p><p id="e5f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nn">注意:这与你在一个类组件中为</em> <code class="fe lv lw lx ly b"><em class="nn">setState</em></code> <em class="nn">方法提供回调函数的方式有点不同。出于某种原因，</em> <code class="fe lv lw lx ly b"><em class="nn">useState</em></code> <em class="nn">钩子不支持相同的API，所以回调函数在这里不起作用。</em></p><p id="3769" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新后记录当前状态的正确方法是:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="34ea" class="nh mh it ly b gy ni nj l nk nl">useEffect(() =&gt; {<br/>  if (name !== 'John') {<br/>    console.log(`The name is now... ${name}!`)<br/>  }<br/>}, [name])<br/><br/>const setNameToMatt = () =&gt; setName('Matt')</span></pre><p id="4036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好多了！现在它像预期的那样正确地记录了<code class="fe lv lw lx ly b">'Matt'</code>。</p><p id="424c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nn">注意:在这种情况下，我添加了</em> <code class="fe lv lw lx ly b"><em class="nn">if</em></code> <em class="nn">语句来防止组件第一次挂载时出现控制台日志。如果您想要一个更通用的解决方案，推荐使用</em> <a class="ae ky" href="https://stackoverflow.com/questions/53253940/make-react-useeffect-hook-not-run-on-initial-render" rel="noopener ugc nofollow" target="_blank"> <em class="nn">使用</em> </a> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://stackoverflow.com/questions/53253940/make-react-useeffect-hook-not-run-on-initial-render" rel="noopener ugc nofollow" target="_blank"><em class="nn">useRef</em></a></code> <a class="ae ky" href="https://stackoverflow.com/questions/53253940/make-react-useeffect-hook-not-run-on-initial-render" rel="noopener ugc nofollow" target="_blank"> <em class="nn">钩子</em> </a> <em class="nn">来保存一个在组件挂载后更新的值。这将成功地阻止你的</em> <code class="fe lv lw lx ly b"><em class="nn">useEffect</em></code> <em class="nn">钩子在组件第一次挂载时运行。</em></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8435" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="b6e0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">你有它！三个常见错误以及如何改正。你可以在GitHub 上<a class="ae ky" href="https://github.com/thawkin3/react-component-state-demo" rel="noopener ugc nofollow" target="_blank">找到代码。</a></p><p id="84b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，犯错是可以的。你在学习。我正在学习。我们都在学习。让我们继续学习，一起变得更好。</p></div></div>    
</body>
</html>