<html>
<head>
<title>How to Manage GitOps Environments at Scale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何大规模管理GitOps环境</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-manage-gitops-environments-at-scale-a-technical-guide-86e62bbdb12e?source=collection_archive---------24-----------------------#2022-04-12">https://betterprogramming.pub/how-to-manage-gitops-environments-at-scale-a-technical-guide-86e62bbdb12e?source=collection_archive---------24-----------------------#2022-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5837" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">技术指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/17044a79675ff22caa28a211770d487d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1mG9ySrYMXoKYliN"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@afgprogrammer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">穆罕默德·拉赫马尼</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6fb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多组织正在为Kubernetes采用GitOps，因为它正在成为Kubernetes部署的标准。本文将着重于解决技术上的GitOps环境问题，并提供可以用来设置GitOps部署架构的解决方案。如果你对GitOps不熟悉，建议看<a class="ae kv" href="https://www.pionative.com/post/gitops-a-fully-declarative-way-to-deploy-to-kubernetes-1" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p><p id="8ba5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在大中型企业中实施GitOps时，会遇到一些挑战。这些挑战之一是GitOps环境问题。如何在GitOps中管理不同的环境，而不影响质量、稳定性、安全性、合规性和自动化等重要因素？</p><h1 id="fe1d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">GitOps环境挑战</h1><p id="d9a1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">根据您的DevOps成熟度、组织类型或合规性要求，您在Kubernetes上最常见的部署可能是(部分)自动化或手动的，或大或小，或简单或复杂。但是一般来说，对于Kubernetes，有两种不同的GitOps部署:</p><h2 id="e6f4" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> 1。图像版本更改(简单)</strong></h2><p id="4dd3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在现代DevOps团队中，由于自动化，这些简单的部署经常发生。当使用像Helm或Kustomize这样的YAML模板时(请使用其中一个！)，这通常是一个特定于环境的配置文件(自定义文件夹或<code class="fe nb nc nd ne b">values.yaml</code>文件)，其中只更新一个图像标签。对于每个环境，都有一个单独的文件，因此一次为一个环境更新这些文件(开发→试运行→生产)相当容易。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/b0a4d4ef7219103b487416afeaefb460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iG31gWfT-37LFI-p.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个简单的变化—生产版本增量</p></figure><h2 id="130c" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> 2。清单变更(不太简单)</strong></h2><p id="f678" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当需要对Kubernetes YAML配置进行更改时(例如，更改配置映射结构、卷映射或服务类型)，这些资源将被模板化(在环境中重用)。</p><p id="11f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果我们希望在生产中推广之前，在试运行环境中测试我们的更改，我们需要一些适当的机制。此外，出于法规遵从性的原因(尤其是在企业级)，我们需要确保对staging的更改不会影响生产，即使这是开发人员的无心之失。为此，我们需要一个良好的环境分离。本文将聚焦这一挑战，并提出可能的解决方案。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/84eb0c2a897c9b8985730194cbe38858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xOXaP3TN2ejDqgd1.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个不太简单的变化—清单更新</p></figure><h1 id="a3b2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">一些GitOps注意事项</h1><p id="635f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在我们深入研究可能的解决方案之前，设定一些基本规则和最佳实践非常重要。当然，这取决于您的公司标准和工作方式，但一般来说，这些规则适用于大多数实现GitOps的DevOps团队。</p><h2 id="417e" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> 1。所有GitOps环境都应该使用主线(主分支)</strong></h2><p id="d74f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">GitOps环境挑战的一个建议模式(在GitOps早期特别流行)是每个环境分支的设置。您为每个环境创建一个分支，并使用拉请求来促进变更。对于某些组织类型来说，这种解决方案是可行的，但是这种方法有很多缺点，尤其是在实现自动化的时候。关于这种(反)模式的缺点的一篇好文章可以在<a class="ae kv" href="https://medium.com/containers-101/stop-using-branches-for-deploying-to-different-gitops-environments-7111d0632402" rel="noopener">这里</a>找到。</p><p id="98fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于使用连续部署的现代DevOps团队，我们需要一个更好的解决方案，尤其是如果我们想要一个良好的连续部署设置的话。分支并不意味着是永久的。我们应该为所有的永久环境使用主线(主/主要分支),并使用其他机制分离环境逻辑。</p><h2 id="8cea" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> 2。应尽可能避免代码重复</strong></h2><p id="14e7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">通过最大限度地减少代码重复，我们确保部署是可预测的。手动更改重复的代码既耗时又容易导致灾难，尤其是当环境配置不同或环境数量增加时。使用Helm或Kustomize等模板工具可以避免代码重复</p><h2 id="a2fc" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> 3。应评估访问控制和合规性规则</strong></h2><p id="9d37" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">根据组织的类型，团队、环境或公司部门的角色和访问控制可能会有所不同。一些公司对生产环境有严格的法规遵从性规则。例如，一些遵从性规则可能是:</p><ul class=""><li id="69a2" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">生产应该完全隔离</li><li id="e88a" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">有限数量的用户(人或应用程序)拥有生产的编辑权限</li><li id="d099" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">所有源代码(包括Kubernetes清单)在部署到生产环境之前都应该经过两个同行的审查</li></ul><p id="ec0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GitOps中的访问控制是通过Git完成的。所以你应该考虑将环境和团队分割成多个GIT仓库，仅仅是为了RBAC。</p><h2 id="0ffa" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> 4。让您的清单靠近源代码</strong></h2><p id="0e38" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我见过许多团队将Kubernetes清单放在单独的存储库中。有时只有高级开发人员、DevOps工程师或者(甚至更糟)其他团队知道这些Kubernetes清单，这使得开发人员不习惯使用Kubernetes清单。将清单放在您的源代码附近将激励开发人员在他们的本地开发环境中使用它们并编辑它们，这将增加您的DevOps成熟度。此外，将它们放在源代码中会更容易在Kubernetes清单上实施测试自动化。您可以简单地使这成为您的CI流程的一部分，测试对主线的每个拉请求的每个YAML变更。</p><h2 id="9c7e" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> 5。部署应该自动化</strong></h2><p id="9417" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">即使您的组织没有为持续部署做好准备，您也应该尽可能地关注自动化。它将增加部署频率、可靠性、交付时间，并最终提高应用程序的质量。</p><h2 id="adb7" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> 6。应对GitOps部署启用自动同步</strong></h2><p id="b353" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">GitOps的力量来自于Git，它是你唯一的真理来源。这就是为什么我们应该将我们选择的GitOps工具(例如ArgoCD或Flux)配置为自动同步。如果我们手动单击sync按钮，或者让我们的管道使用API调用来运行sync，我们将失去GitOps没有配置漂移的优势，并且不能再依赖于单一真实来源(GIT)。这就是为什么部署应该在git提交后立即触发，而不是其他。可以找到关于为什么应该使用自动同步的更详细的解释。</p><h1 id="0db2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">可能的解决方案</h1><p id="3b58" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">考虑到GitOps最佳实践和基本规则，我们可以设计一个适合大多数用例的解决方案框架。为了简单起见，我将使用Helm作为所有解决方案的示例，因为这是部署Kubernetes清单最流行的模板方法。</p><h2 id="9557" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">Kubernetes清单放在哪里</h2><p id="8579" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如前所述，我建议在源代码库中构建Kubernetes清单。但是，我不建议将这个存储库作为GitOps存储库，链接到您的ArgoCD或Flux，用于您的稳定环境(staging，production)。这样做有一些缺点:</p><ul class=""><li id="5ba9" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">您不能同时更新清单和源代码，因为您的Docker构建需要时间来完成。GitOps将立即同步更改(带自动同步)，因此如果映像不存在，这将导致问题。</li><li id="4a11" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">使用GitOps，您的提交历史就是您的部署历史。从部署的角度来看，使用您的源代码库进行部署将使“何时发生了什么”变得更加困难。</li><li id="6796" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">将您的变更部署到多个环境将导致您的主线中的多个提交——在不同的文件夹中。与此同时，有人可能已经更改了与您的部署相冲突的其他内容。</li><li id="6757" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">回滚变得更加复杂，因为您的主线被其他不相关的源代码更新所污染。</li><li id="2369" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">可观察性是GitOps的另一个挑战，如果不将部署集中到数量有限的存储库中，这将变得更加困难。</li><li id="2ec4" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">如果您需要明确的环境分离(风险、法规遵从性、安全性或其他原因)，您将需要在您的生产环境中使用某种RBAC。使用Git，这只能在分支或存储库级别上实现。可能会意外(手动)更改错误的文件夹，这在企业级是不可接受的。</li></ul><p id="757b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么我建议将您的清单构建到一个包(Helm Chart)中，并在一个单独的GitOps存储库中使用这个图表。特定于环境的配置可以存储在GitOps存储库中。</p><p id="f0c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的渠道将包括如下内容:</p><ol class=""><li id="bea0" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nv nn no np bi translated">构建您的映像并将其发布到容器注册中心</li><li id="7514" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nv nn no np bi translated">构建您的舵图，并将其发布到舵图存储库</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/186eb867f9c8da8865f43102e2b9c179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/0*W0JfoE8ggdo2WhsJ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">源代码库文件夹结构</p></figure><h2 id="ce0c" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">我的环境应该有多少个存储库</h2><p id="6f7d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有很多方法可以构建您的GitOps存储库，但这完全取决于您的组织。最简单的开始方式是为所有GitOps环境准备一个存储库。我建议使用尽可能少的存储库。这使得实施、监控和维护更加容易。此外，它有助于维护整个组织的统一标准，因为所有代码都被分组在一起。</p><p id="125a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，如果您非常重视生产环境的稳定性，那么让一个GitOps存储库用于所有部署几乎是不可能的。创建的GitOps存储库越多，实现以下需求的灵活性就越大:</p><ol class=""><li id="0df4" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nv nn no np bi translated">我是否为某些环境(生产)实施RBAC？</li><li id="30dd" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nv nn no np bi translated">在投入生产之前，我需要人工(拉动式请求)批准吗？</li><li id="9773" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nv nn no np bi translated">我是否允许团队A修改团队B的部署？</li><li id="3477" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nv nn no np bi translated">我有几个环境？我是否希望将所有的开发环境集中到一个GitOps存储库中？</li><li id="b3ab" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nv nn no np bi translated">我的暂存环境的结构是否应该与生产环境相同？然后，我可能会创建3个GitOps存储库(开发、登台、生产)</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/6f785adf2b3b0610a126beb074942fe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Nzs22vSbNeBRWI1U.png"/></div></div></figure><p id="a1e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上图展示了3个如何构建GitOps库的例子。我通常发现最佳的结构是在中间的某个位置(每个环境一个repo)，为每个应用程序拥有一个单独的存储库将很快在规模上失控，但它为您提供了最大的灵活性。这些解决方案之间有许多变化，所以请根据您的组织结构谨慎选择。一些变化可能包括:</p><ul class=""><li id="5fe0" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">每个环境每个团队1个存储库</li><li id="32c5" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">每个环境的每个技术堆栈(团队组)有一个存储库</li><li id="a650" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">一个存储库用于所有非生产环境，一个存储库用于生产环境</li></ul><h2 id="3292" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">舵依赖与模板</h2><p id="8864" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">GitOps存储库中的舵图可以在本地定义，有一个包含所有Kubernetes清单的templates文件夹，或者没有一个使用依赖项的templates文件夹。这种依赖关系指向您的图表所在的外部舵图表存储库。每种方法的优缺点解释如下。</p><p id="27bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 1。如果没有使用模板文件夹<br/>T3的依赖关系，当在GitOps存储库的模板文件夹中定义资源时，必须将helm图表从App存储库复制到GitOps存储库。这种方法更容易使用，但是在版本控制和稳定性方面扩展性和可靠性较差。</strong></p><p id="9a59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的资源结构如下:</p><ul class=""><li id="8e28" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">使用本地舵图表，图表中没有外部依赖性。yaml</li><li id="2875" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">这个特定环境的values.yaml包含所有特定于环境的配置，并包含一个指向容器注册表中的标记的image标记</li><li id="2e85" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">资源从应用程序存储库复制到每个环境的模板文件夹中</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/9639998a8040478d40a0d29864063bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*e3enmv2ITscHX5tRxvqnjA.png"/></div></div></figure><p id="e0b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">优点</strong></p><ul class=""><li id="13fb" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated"><strong class="ky ir">便于没有掌舵经验的开发者调试</strong>。不需要直接下载Helm cli进行调试，也不需要下载外部依赖项</li><li id="1d4f" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><strong class="ky ir">更容易观察到。git中的一切都是直接可见的，这使得无需Helm CLI就能更容易地看到真实的单一来源。此外，使用git diff可以更容易地看到历史中的部署差异。</strong></li><li id="1a85" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><strong class="ky ir">通过简单的git提交手动修改生成的清单，轻松修复生产问题</strong></li></ul><p id="31be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">缺点</strong></p><ul class=""><li id="0de1" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">大量重复的清单，特别是当您有许多环境时，这可能会很快变得混乱。但是，资源是生成的，所以可能可以接受。</li><li id="97f1" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">不应手动修改生成的文件。这需要使用RBAC策略或工作方式来强制执行，否则，将会导致部署问题。手动热修复一个生成的文件是非常容易的，但是如果不小心处理的话会有后果。</li><li id="a24e" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">没有完成图表版本控制，所以回滚到特定版本更困难，因为这是git恢复，而不仅仅是版本更新。此外，它与图表版本和Docker映像版本没有关系，这使得部署不太容易预测。</li></ul><p id="659e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 2。在Helm Chart存储库中使用外部图表<br/> </strong>在这种设置下，GitOps存储库中存在的唯一配置是基于版本的特定于环境的配置和依赖关系。这个解决方案具有更好的伸缩性和版本控制能力，但是需要开发人员更多的经验。</p><p id="db24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的资源结构如下:</p><ul class=""><li id="7e6a" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">对于这个特定的环境，您定义了一个对图表版本具有外部依赖性的<code class="fe nb nc nd ne b">Chart.yaml</code>。舵图位于远程舵图存储库中</li><li id="cefd" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">这个特定环境的<code class="fe nb nc nd ne b">values.yaml</code>包含所有特定于环境的配置，并包含一个指向容器注册表中的标记的图像标记</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/cb529bb5d6b61c7ec98d88254653e212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*zaM492S1qskBpPcnYZI_Nw.png"/></div></figure><p id="f034" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">优点</strong></p><ul class=""><li id="98d8" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated"><strong class="ky ir">无重复</strong>。Kubernetes清单集中存储在舵图中</li><li id="f567" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><strong class="ky ir">更好的版本控制</strong>。掌舵图有一个清晰的版本，使Kubernetes资源成为你的发布管道的一部分。Docker映像和Kubernetes资源可以作为一个版本，使生产部署更加可预测，并且更容易在特定环境下快速测试特定版本，而无需复制许多资源。</li><li id="1bc0" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><strong class="ky ir">标准化</strong>。有了舵依赖，你可以使用更多层的舵依赖。如果你是一个更大的组织，中央团队为你的整个组织开发掌舵图，这是有优势的。例如，您可以为每个技术堆栈/部门构建中心图表。</li><li id="907c" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><strong class="ky ir">集权</strong>。无论您有多少个GitOps存储库，您都将有一个单独的位置来存放所有运行在试运行/生产中的Kubernetes清单。这有几个优点:使用中央Helm图表存储库在Kubernetes清单上容易执行中央漏洞扫描。这些漏洞可以更好地定位到特定版本。您还可以更好地观察已部署的版本及其各自的Kubernetes资源。</li></ul><p id="85f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">缺点</strong></p><ul class=""><li id="5b62" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">生产中的快速热修复更加困难。只能恢复旧版本。在大多数情况下，恢复旧版本是推荐的回滚，但在更复杂的情况下，您需要运行管道或生成一些自定义代码。</li><li id="a665" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">出于调试和观察目的查看GitOps存储库时，您需要Helm CLI。在大多数情况下，这就像运行一个“helm template”命令一样简单，但是它增加了一层复杂性。</li></ul><h1 id="5046" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="1432" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">与所有事情一样，构建GitOps存储库和环境取决于您的用例。没有放之四海而皆准的方法，但是有了一个好的GitOps Bootstrap平台，以后改变你的结构真的很容易。在Pionative，我们在实施GitOps解决方案时会考察公司的结构、团队、部门、DevOps成熟度、未来目标和整体架构。</p><p id="fe96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oa">最初发表于</em><a class="ae kv" href="https://www.pionative.com/post/how-to-manage-gitops-environments-at-scale-a-technical-guide" rel="noopener ugc nofollow" target="_blank"><em class="oa">https://www.pionative.com</em></a></p><pre class="kg kh ki kj gt ob ne oc od aw oe bi"><span id="91c9" class="mp lt iq ne b gy of og l oh oi"><strong class="ne ir">Want to Connect?</strong></span><span id="c041" class="mp lt iq ne b gy oj og l oh oi">If you would like to save the hassle and make sure you implement a good GitOps solution that has been battle-tested in production and has had many development iterations, plan an <a class="ae kv" href="https://www.pionative.com/introduction-meeting" rel="noopener ugc nofollow" target="_blank">introduction meeting</a>, I would love to talk about your specific use case.</span></pre></div></div>    
</body>
</html>