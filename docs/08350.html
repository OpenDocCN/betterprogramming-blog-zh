<html>
<head>
<title>How To Efficiently Validate Input Types in Python Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python函数中有效地验证输入类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-efficiently-validate-input-types-in-python-functions-1f662f45c24c?source=collection_archive---------10-----------------------#2021-04-20">https://betterprogramming.pub/how-to-efficiently-validate-input-types-in-python-functions-1f662f45c24c?source=collection_archive---------10-----------------------#2021-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5bac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">油漆工来拯救</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ab62431e2d45cc30da30a3e82b3f1d9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8e7Er42GiwPIe3-E"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@dmjdenise?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Denise Jans </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="d250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当要编写在生产中运行的复杂管道时，清楚地理解每个函数的作用以及它的输出如何影响下游函数是至关重要的。但是，尽管我们尽了最大努力来编写模块化的、经过良好测试的功能，错误还是喜欢藏在功能之间的交接中——即使是端到端的测试也很难捕捉到它们。</p><p id="6fb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将介绍一个用于输入验证的Python装饰器，我们可以用它来“锁定”函数的输入，并在出现意外的不匹配时立即注意到。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b76f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">示例管道</h1><p id="93ed" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">考虑一个简单的管道，其中我们查询一个API，清理我们得到的数据，然后保存一个CSV。我们有一个用户可以触发的主函数(<code class="fe na nb nc nd b">run_pipeline</code>)，它接受一个日期范围，运行<code class="fe na nb nc nd b">query_api</code>和<code class="fe na nb nc nd b">process_dict</code>，然后保存一个CSV:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6f5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单，对吧？现在让我们看看<code class="fe na nb nc nd b">query_api</code>和<code class="fe na nb nc nd b">process_dict</code>。虽然它们看起来也很简单，但实际上有两个失败点——一个比另一个更容易发现。你能看见他们吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="6615" class="ng me it bd mf nh ni dn mj nj nk dp mn li nl nm mp lm nn no mr lq np nq mt nr bi translated">故障1:对<code class="fe na nb nc nd b">query_api</code>的非日期时间输入</h2><p id="f45c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">你可能已经抓住了失败的第一点。在<code class="fe na nb nc nd b">query_api</code>中，如果输入不是<code class="fe na nb nc nd b">datetime</code>对象呢？</p><p id="064e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe na nb nc nd b">start_date</code>和<code class="fe na nb nc nd b">end_date</code>不是<code class="fe na nb nc nd b">datetime</code>值，当我们试图将这些对象转换成字符串时，我们会在第16-17行立即失败。没有什么可以阻止这种情况发生，因为<code class="fe na nb nc nd b">run_pipeline</code>(实际上是向用户公开的函数)会毫不犹豫地将其输入直接传递给<code class="fe na nb nc nd b">query_api</code>。</p><p id="a687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过检查<code class="fe na nb nc nd b">run_pipeline</code>的输入并确保它们是<code class="fe na nb nc nd b">datetime</code>对象来解决第一个问题，在继续管道之前立即提醒用户这个问题。</p><p id="a069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们的第二期呢？你找到了吗？</p><h2 id="0e76" class="ng me it bd mf nh ni dn mj nj nk dp mn li nl nm mp lm nn no mr lq np nq mt nr bi translated">故障二:<code class="fe na nb nc nd b">query_api</code>查询失败</h2><p id="274e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">从API请求数据并不总是有效的。服务器可能脱机，URL可能无效，或者我们的请求可能导致服务器端的内部错误。为了解决这种可变性并避免我们的管道崩溃，我们将我们的API请求放在一个<code class="fe na nb nc nd b">try</code> - <code class="fe na nb nc nd b">except</code>块中。</p><p id="2cfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好…除了如果<code class="fe na nb nc nd b">except</code>被触发会发生什么。</p><p id="09a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的API请求出错，我们会记录一条错误消息，但不会显式返回任何内容。默认情况下，Python函数返回<code class="fe na nb nc nd b">None</code>。如果我们的代码采用<code class="fe na nb nc nd b">except</code>分支，<code class="fe na nb nc nd b">query_api</code>返回<code class="fe na nb nc nd b">None</code>，然后将它传递给<code class="fe na nb nc nd b">process_dict</code>。<code class="fe na nb nc nd b">process_dict</code>然后当我们试图获取应该是字典的<code class="fe na nb nc nd b">sales</code>和<code class="fe na nb nc nd b">date</code>字段时崩溃。</p><p id="2afe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们开始认真地运行我们的管道时，这些问题将不可避免地出现，但是理想情况下，我们应该在开发的早期发现它们。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c7bd" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">解决办法</h1><p id="fee0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果我们密切关注哪些值进入了我们的函数，我们就能更快地发现错误。虽然类型提示表明我们<em class="lv">期望什么数据类型</em>，Python不会阻止错误的输入被传入。因此，我们需要自己编写逻辑来验证输入是正确的。</p><p id="8433" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种方法可以验证输入:一种简单的方法是函数中的某种帮助方法，如下面的<code class="fe na nb nc nd b">_validate_query_api_inputs</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5957" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们所做的只是检查输入是否匹配它们的类型提示，我们可能需要一个更通用的函数。否则，我们需要为<code class="fe na nb nc nd b">run_pipeline</code>、<code class="fe na nb nc nd b">query_api</code>和<code class="fe na nb nc nd b">process_dict</code>编写<code class="fe na nb nc nd b">_validate</code>函数，它们都有效地做同样的事情。</p><p id="2829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了满足这些需求，我编写了一个名为<code class="fe na nb nc nd b">enforce_type_hints</code>的装饰器。这个装饰器遍历函数的输入，并确认它们与提供的类型提示相匹配。如果不匹配，<code class="fe na nb nc nd b">enforce_type_hints</code>会产生一个<code class="fe na nb nc nd b">AssertionError</code>。这里有一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="caeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来看看<code class="fe na nb nc nd b">enforce_type_hints</code>是如何工作的。想跳过教程看原码？查看GitHub repo 并提交一份PR，如果你看到一个使它变得更好的方法！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c93d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><code class="fe na nb nc nd b">ArgChecker</code></h1><p id="97f6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">因为运行我们的类型检查需要多个组件，所以我将<code class="fe na nb nc nd b">enforce_type_hints</code>放在一个名为<code class="fe na nb nc nd b">ArgChecker</code>的Python类中。<code class="fe na nb nc nd b">ArgChecker</code>看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9a7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，<code class="fe na nb nc nd b">enforce_type_hints</code>从函数中获取参数和类型提示，必要时将类型提示转换为原生Python类型，然后迭代检查位置和关键字参数是否匹配它们的类型提示。这个检查作为一个<code class="fe na nb nc nd b">assert isinstance(arg, accepted_types)</code>调用发生。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6f97" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">修理我们的管道</h1><p id="0030" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">通过用<code class="fe na nb nc nd b">enforce_type_hints</code>修饰我们的函数，我们保证了在函数内部执行的任何代码都是参数的类型提示中提供的数据类型。</p><p id="03c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，提高一个<code class="fe na nb nc nd b">AssertionError</code>会让我们的管道陷入停顿。但是它立即将我们引向<em class="lv">错误在向下游传播之前发生的地方。移除函数输入中的任何解释空间意味着我们不得不努力思考每个函数(以及它之前和之后的函数)到底应该做什么。</em></p><p id="0013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是回到我们最初的管道。以下是我如何改变我们的渠道，使其更加稳健:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2b07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让管道的输入正确至关重要，因为这可以节省大量的下游错误处理。通过用<code class="fe na nb nc nd b">enforce_type_hints</code>锁定输入，如果输入无效，我们会立即停止执行管道。</p><p id="c35d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们改变<code class="fe na nb nc nd b">query_api</code>和<code class="fe na nb nc nd b">process_dict</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0b0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从在<code class="fe na nb nc nd b">query_api</code>和<code class="fe na nb nc nd b">process_dict</code>上实施类型提示开始。在<code class="fe na nb nc nd b">query_api</code>的<code class="fe na nb nc nd b">except</code>块中，我们现在返回一个空字典而不是<code class="fe na nb nc nd b">None</code>来保持一致的输出。最后，在<code class="fe na nb nc nd b">process_dict</code>中，我们检查输入字典是否包含必要的字段。如果没有，我们记录缺失的字段并返回一个空的<code class="fe na nb nc nd b">DataFrame</code>。</p><p id="680a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有很多其他的漏洞我们可以探究，比如<code class="fe na nb nc nd b">run_pipeline</code>是否应该写一个空的CSV或者发送某种作业失败的警告。但是我会让你来决定！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="530a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="4ff6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">本文介绍了<code class="fe na nb nc nd b">enforce_type_hints</code>，一个装饰器，用于确保函数的输入匹配它们的类型提示。当一个函数接收到一个它没有预料到的输入时引发一个错误可能看起来有点极端，但是它迫使我们批判性地思考<em class="lv">我们的函数到底在做什么</em>以及上游输出是如何被下游接收的。</p><p id="ae82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有兴趣投稿吗？分叉<a class="ae ky" href="https://github.com/mgsosna/jewelry" rel="noopener ugc nofollow" target="_blank">GitHub repo</a>并提交PR。还有很多其他领域可以探索。我个人对用于验证<code class="fe na nb nc nd b">DataFrame</code>或<code class="fe na nb nc nd b">dict</code>输入是否有必要字段的装饰器感兴趣(如上面的第34-37行)。</p><p id="02ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读，愿您的管道永远如您所愿。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="73f8" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">资源</h1><ul class=""><li id="2f19" class="ns nt it lb b lc mv lf mw li nu lm nv lq nw lu nx ny nz oa bi translated"><a class="ae ky" href="https://github.com/mgsosna/jewelry" rel="noopener ugc nofollow" target="_blank">珠宝GitHub回购</a></li></ul></div></div>    
</body>
</html>