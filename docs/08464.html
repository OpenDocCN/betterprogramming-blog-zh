<html>
<head>
<title>Getting Started With Redis: A Python Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis入门:Python教程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-redis-a-python-tutorial-3a18531a73a6?source=collection_archive---------1-----------------------#2021-05-04">https://betterprogramming.pub/getting-started-with-redis-a-python-tutorial-3a18531a73a6?source=collection_archive---------1-----------------------#2021-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e0c1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索概念并构建一个库</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3980ff07f86865d1bc9a2cc47407bf36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cdgDatcfb1b1C7jWax6cAQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="add3" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">内容</h1><ul class=""><li id="457b" class="lu lv iq lw b lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">先决条件</li><li id="09b9" class="lu lv iq lw b lx mm lz mn mb mo md mp mf mq mh mi mj mk ml bi translated">Redis是什么？</li><li id="3c05" class="lu lv iq lw b lx mm lz mn mb mo md mp mf mq mh mi mj mk ml bi translated">使用Docker设置本地Redis服务器</li><li id="3f36" class="lu lv iq lw b lx mm lz mn mb mo md mp mf mq mh mi mj mk ml bi translated">使用CLI客户机探索基本的Redis概念</li><li id="c09e" class="lu lv iq lw b lx mm lz mn mb mo md mp mf mq mh mi mj mk ml bi translated">构建和使用自己的Python Redis库</li><li id="34aa" class="lu lv iq lw b lx mm lz mn mb mo md mp mf mq mh mi mj mk ml bi translated">为Redis使用真正的Python库</li><li id="df83" class="lu lv iq lw b lx mm lz mn mb mo md mp mf mq mh mi mj mk ml bi translated">摘要</li></ul></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="983c" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">先决条件</h1><ul class=""><li id="8de9" class="lu lv iq lw b lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">码头工人</li><li id="868f" class="lu lv iq lw b lx mm lz mn mb mo md mp mf mq mh mi mj mk ml bi translated">Python 3.6以上版本</li></ul></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="6af8" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">Redis是什么？</h1><p id="f865" class="pw-post-body-paragraph mr ms iq lw b lx ly jr mt lz ma ju mu mb mv mw mx md my mz na mf nb nc nd mh ij bi translated">Redis docker页面称它是“一个开源的、网络化的、内存中的、键值数据存储，具有可选的持久性。”这个描述抓住了Redis的关键特性。</p><p id="d204" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated"><strong class="lw ir">开源</strong>——任何人都可以检查Redis的代码或者为<a class="ae ne" href="https://github.com/redis/redis" rel="noopener ugc nofollow" target="_blank">项目</a>做贡献。</p><p id="e3a0" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated"><strong class="lw ir">网络化</strong> — Redis使用客户机-服务器模型，客户机和服务器之间的通信通过网络进行。在本教程中，客户端和服务器都运行在一台机器上。在生产系统中，一个负载平衡的多节点Redis集群(由服务器组成)将为来自多个客户端的请求提供服务。</p><p id="1be4" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated"><strong class="lw ir">内存中</strong> — Redis将数据存储在主计算机内存(即RAM)中。查看计算机内存层次结构。存储在RAM中的数据比存储在较慢的(二级)内存(如磁盘)中的数据访问速度更快。这就是Redis快速且适用于要求低延迟数据访问(例如缓存)的应用程序的原因。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/59411108de9ae8f79948628c2d6af253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*q1wwZ1VDPbtPgRh2.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae ne" href="https://commons.wikimedia.org/wiki/File:ComputerMemoryHierarchy.svg" rel="noopener ugc nofollow" target="_blank">计算机内存层次</a>由丹拉什在<a class="ae ne" href="https://en.wikipedia.org" rel="noopener ugc nofollow" target="_blank">en.wikipedia.org</a></p></figure><p id="01bd" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated"><strong class="lw ir">键值数据存储</strong> — Redis是一个美化了的字典。支持的主要操作是用键的值设置键，用相关的键获取值，以及其他类似的操作。事实上，<em class="nl"> Redis </em>恰当地表示<strong class="lw ir">re</strong>mote<strong class="lw ir">di</strong>dictionary<strong class="lw ir">s</strong>server，指向它的网络化和键值存储特性。</p><p id="ff52" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated"><strong class="lw ir">可选的持久性</strong> —《设计数据密集型应用程序:可靠、可伸缩和可维护系统背后的伟大理念的作者Martin Kleppmann将持久性定义为“一旦事务成功提交，它写入的任何数据都不会被忘记，即使出现硬件故障或数据库崩溃。”</p><p id="6138" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated">Redis作为内存中的数据存储，默认情况下并不完全持久。如果Redis主机出现故障，成功写入Redis的一些数据可能会丢失。查看计算机内存层次结构。请注意，RAM是易失性的，这意味着如果断电，RAM中存储的内容也会丢失。这对于任何想要构建最大化性能而不牺牲耐用性的系统的人来说都是不可取的。幸运的是，Redis提供了几个具有不同性能持久性特征的<a class="ae ne" href="https://redis.io/topics/persistence" rel="noopener ugc nofollow" target="_blank">持久性选项</a>，包括一个提供完全持久性的选项。</p><p id="9f62" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated"><strong class="lw ir">数据类型多样性</strong>—Redis Docker页面描述中忽略的一个关键特征是Redis对其值的不同类型数据结构的原生支持，但这在别处可以找到。例如，Redis项目在GitHub上的描述提到了它对各种数据结构的支持，包括“字符串、列表、集合、排序集合、哈希、流、超级日志、位图。”这种灵活性使得使用Redis更像是使用Python等编程语言中的字典数据结构。这也使得Redis成为支持应用程序的简单选择，这些应用程序将从这些数据结构提供的约束中受益。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="8718" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">使用Docker设置本地Redis服务器</h1><p id="917e" class="pw-post-body-paragraph mr ms iq lw b lx ly jr mt lz ma ju mu mb mv mw mx md my mz na mf nb nc nd mh ij bi translated">为Redis之类的工具设置服务器可能是一项痛苦的工作，在第一次接触该工具时没有必要忍受。在本教程中，我们将使用Docker作为一个黑盒程序。Docker是一个热门工具，很多人都把它列在了学习清单上，但是你不需要了解它的复杂性和特性就可以完成这篇教程。就用吧。</p><h2 id="7c4d" class="nm ld iq bd le nn no dn li np nq dp lm mb nr ns lo md nt nu lq mf nv nw ls nx bi translated">获取最新的Redis Docker映像(撰写本文时为6.2.2版)</h2><p id="3a42" class="pw-post-body-paragraph mr ms iq lw b lx ly jr mt lz ma ju mu mb mv mw mx md my mz na mf nb nc nd mh ij bi translated">这就像下载Redis的安装文件一样。</p><pre class="kg kh ki kj gt ny nz oa ob aw oc bi"><span id="8976" class="nm ld iq nz b gy od oe l of og">docker pull redis</span></pre><h2 id="9aec" class="nm ld iq bd le nn no dn li np nq dp lm mb nr ns lo md nt nu lq mf nv nw ls nx bi translated">将Redis服务器作为守护进程运行(后台进程)</h2><p id="0c0b" class="pw-post-body-paragraph mr ms iq lw b lx ly jr mt lz ma ju mu mb mv mw mx md my mz na mf nb nc nd mh ij bi translated">在这个命令中，我们将计算机上的端口6379映射到Redis容器中公开的端口6379。端口6379是Redis服务器的默认端口。</p><pre class="kg kh ki kj gt ny nz oa ob aw oc bi"><span id="b37c" class="nm ld iq nz b gy od oe l of og">docker run -d -p 6379:6379 --name redis-server redis</span></pre></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="51a8" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">使用CLI客户机探索基本的Redis概念</h1><p id="9d6b" class="pw-post-body-paragraph mr ms iq lw b lx ly jr mt lz ma ju mu mb mv mw mx md my mz na mf nb nc nd mh ij bi translated">在本节中，您将了解Redis数据库，如何设置键-值对，如何使用各自的键获取值，以及如何删除键。</p><h2 id="d4eb" class="nm ld iq bd le nn no dn li np nq dp lm mb nr ns lo md nt nu lq mf nv nw ls nx bi translated">连接到Redis服务器</h2><p id="b7c4" class="pw-post-body-paragraph mr ms iq lw b lx ly jr mt lz ma ju mu mb mv mw mx md my mz na mf nb nc nd mh ij bi translated">我们在上一节中启动的Redis服务器内置了一个Redis CLI客户端。我们将在教程的这一部分使用它。</p><pre class="kg kh ki kj gt ny nz oa ob aw oc bi"><span id="2345" class="nm ld iq nz b gy od oe l of og">docker exec -it redis-server redis-cli</span></pre><h2 id="40a5" class="nm ld iq bd le nn no dn li np nq dp lm mb nr ns lo md nt nu lq mf nv nw ls nx bi translated">概念1。数据库</h2><p id="5425" class="pw-post-body-paragraph mr ms iq lw b lx ly jr mt lz ma ju mu mb mv mw mx md my mz na mf nb nc nd mh ij bi translated">在通过Redis CLI程序连接到Redis服务器后，我们会看到类似这样的提示。它只显示我们连接的服务器的IP地址和端口号。</p><pre class="kg kh ki kj gt ny nz oa ob aw oc bi"><span id="c4af" class="nm ld iq nz b gy od oe l of og">127.0.0.1:6379&gt;</span></pre><p id="1044" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated">Redis有数据库的概念，数据库是由键值对组成的索引组。那是什么意思？假设您有两个需要Redis服务器的应用程序。它们都存储使用相同键(例如，实体的ID)的键-值对，但是它们存储与那些键相关联的不同值。第一个应用程序可能想要存储<code class="fe oh oi oj nz b">StudentID</code>到<code class="fe oh oi oj nz b">StudentEnrolledCourses</code>的键值对，而第二个应用程序可能想要存储<code class="fe oh oi oj nz b">StudentID</code>到<code class="fe oh oi oj nz b">StudentProfiles</code>的键值对。<code class="fe oh oi oj nz b">StudentEnrolledCourses</code>和<code class="fe oh oi oj nz b">StudentProfiles</code>的确切类型在这里并不重要。重要的是密钥来自同一个域(用集合论术语来说)。这意味着如果两个应用程序都将其密钥写入Redis服务器上的同一个Redis数据库，将会出现有问题的密钥冲突。</p><p id="72af" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated">这个问题可以通过拥有多个Redis服务器来解决，但这是不优雅且笨拙的。另一个解决方案是让Redis服务器拥有多个数据库，这些数据库由唯一的符号标识，这些符号代表独立的键值对组。这正是Redis所允许的。Redis有多个由整数标识的数据库，这些整数独立地对键值对进行分组。</p><p id="4e34" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated">回到我们的例子，第一个应用程序可以使用Redis数据库1，第二个应用程序可以使用Redis数据库2。默认的Redis数据库的索引为0，当我们登录到Redis服务器时，会自动使用这个索引。我们可以通过发出<code class="fe oh oi oj nz b">SELECT</code>命令来改变我们想要使用的数据库。</p><pre class="kg kh ki kj gt ny nz oa ob aw oc bi"><span id="01f4" class="nm ld iq nz b gy od oe l of og">127.0.0.1:6379&gt; SELECT 1<br/>OK<br/>127.0.0.1:6379[1]&gt;</span></pre><p id="fe51" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated">对于本教程的剩余部分，我们将使用索引为1的数据库。这是一个任意的选择，所以如果你想在线外着色，可以随意选择不同的索引。</p><h2 id="1447" class="nm ld iq bd le nn no dn li np nq dp lm mb nr ns lo md nt nu lq mf nv nw ls nx bi translated">概念2。设置键值对</h2><p id="da5c" class="pw-post-body-paragraph mr ms iq lw b lx ly jr mt lz ma ju mu mb mv mw mx md my mz na mf nb nc nd mh ij bi translated">设置键值对有一个简单的语法。在这里。</p><pre class="kg kh ki kj gt ny nz oa ob aw oc bi"><span id="df5f" class="nm ld iq nz b gy od oe l of og">127.0.0.1:6379[1]&gt; SET hello world<br/>OK</span></pre><p id="eff4" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated">在设置了一个键-值对之后，我们得到一个漂亮的“OK”来告诉我们操作成功了。</p><p id="e9bd" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated">你也可以设置自动过期的密钥。对于如何使密钥过期，有多种选择，例如秒(EX)、毫秒(PX)和以秒为单位的时间戳(EXAT)来列出其中的一些。</p><pre class="kg kh ki kj gt ny nz oa ob aw oc bi"><span id="3592" class="nm ld iq nz b gy od oe l of og">127.0.0.1:6379[1]&gt; SET bye "In 60 seconds, I'll self-delete" EX 60<br/>OK</span></pre><h2 id="844c" class="nm ld iq bd le nn no dn li np nq dp lm mb nr ns lo md nt nu lq mf nv nw ls nx bi translated">概念3。使用各自的键获取值</h2><p id="68b6" class="pw-post-body-paragraph mr ms iq lw b lx ly jr mt lz ma ju mu mb mv mw mx md my mz na mf nb nc nd mh ij bi translated">通过使用键获取值也有一个简单的语法。看那个！😲</p><pre class="kg kh ki kj gt ny nz oa ob aw oc bi"><span id="5719" class="nm ld iq nz b gy od oe l of og">127.0.0.1:6379[1]&gt; GET hello<br/>"world"</span><span id="ef27" class="nm ld iq nz b gy ok oe l of og"># before 60 seconds elapses</span><span id="b2ea" class="nm ld iq nz b gy ok oe l of og">127.0.0.1:6379[1]&gt; GET bye<br/>"In 60 seconds, I'll self-delete"</span><span id="8548" class="nm ld iq nz b gy ok oe l of og"># after 60 seconds elapses</span><span id="94dd" class="nm ld iq nz b gy ok oe l of og">127.0.0.1:6379[1]&gt; GET bye<br/>(nil)</span></pre><h2 id="15aa" class="nm ld iq bd le nn no dn li np nq dp lm mb nr ns lo md nt nu lq mf nv nw ls nx bi translated">概念4。删除密钥</h2><pre class="kg kh ki kj gt ny nz oa ob aw oc bi"><span id="8c54" class="nm ld iq nz b gy od oe l of og">127.0.0.1:6379[1]&gt; DEL hello<br/>OK<br/>127.0.0.1:6379[1]&gt; GET hello<br/>(nil)</span></pre></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="0988" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">构建和使用自己的Python Redis库</h1><blockquote class="ol"><p id="d66c" class="om on iq bd oo op oq or os ot ou mh dk translated">Redis是一本被美化了的词典。</p></blockquote><p id="3e81" class="pw-post-body-paragraph mr ms iq lw b lx ov jr mt lz ow ju mu mb ox mw mx md oy mz na mf oz nc nd mh ij bi translated">让我向您展示Redis实际上是一个美化了的字典，它为Redis提供了一个过于简化的Python接口实现。尽管非常简单，但该实现将Redis剥离到其本质，并消除了您可能因使用该工具的复杂性而产生的任何犹豫。这个实现中唯一剩下的就是我们有一个内存中的键值数据存储。</p><h2 id="268c" class="nm ld iq bd le nn no dn li np nq dp lm mb nr ns lo md nt nu lq mf nv nw ls nx bi translated">redisx.py</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="dec7" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated">让我们用我们的图书馆吧！</p><h2 id="a55b" class="nm ld iq bd le nn no dn li np nq dp lm mb nr ns lo md nt nu lq mf nv nw ls nx bi translated">redisx _ hello _ world.py</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="cd19" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">为Redis使用真正的Python库</h1><h2 id="31a0" class="nm ld iq bd le nn no dn li np nq dp lm mb nr ns lo md nt nu lq mf nv nw ls nx bi translated">安装redis-py Python库</h2><pre class="kg kh ki kj gt ny nz oa ob aw oc bi"><span id="b15f" class="nm ld iq nz b gy od oe l of og">python -m pip install redis==3.5.3</span></pre><p id="94cb" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated">我们可以将前一节中编写的客户机代码修改到本地运行的Redis服务器上，并在其上执行一些基本操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="e104" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated">我就不做“找出差异”的练习了，注意在这个版本的客户端代码中，<code class="fe oh oi oj nz b">Redis</code>类的<code class="fe oh oi oj nz b">host</code>和<code class="fe oh oi oj nz b">port</code>参数被赋值。同样，我们得到的值是一个二进制值(如前缀<code class="fe oh oi oj nz b">b</code>所示)。我们可以使用<code class="fe oh oi oj nz b">.decode()</code>方法将返回值转换为更简单的Python类型，如下面的代码所示。</p><p id="4aa3" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated">让我们通过Python客户机复制我们在Redis CLI客户机中所做的事情。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa pb l"/></div></figure></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="1723" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">摘要</h1><p id="fae7" class="pw-post-body-paragraph mr ms iq lw b lx ly jr mt lz ma ju mu mb mv mw mx md my mz na mf nb nc nd mh ij bi translated">Redis是一个流行的键值数据存储，以其速度和灵活性而闻名。在本教程中，我描述了一些更常见的Redis特性。我们使用Docker设置了一个本地Redis服务器，并研究了基本的Redis概念，如数据库、设置键-值对、获取值以及使用Redis CLI客户机删除键。我们还构建并使用了我们自己的Python Redis库，以了解Redis的本质。最后，我们使用<a class="ae ne" href="https://pypi.org/project/redis/" rel="noopener ugc nofollow" target="_blank"> redis-py </a> Python库编写了一个基本的redis客户机，该客户机复制了我们以前研究基本Redis概念时与Redis服务器的交互。</p><p id="5b36" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated">本教程非常简洁，但它描绘了Redis的一个简单视图，使新用户更容易更快地开始使用该工具。Redis的先进性和相关的复杂性是非常真实的，它们既可以为您提供很好的服务，也可以带来挑战。但是关于它的高级启示、复杂性以及它们帮助或阻碍你的方式的讨论是另一个时间的话题。</p><p id="5857" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated">要了解更多Redis特性，请看一下它的<a class="ae ne" href="https://redis.io/documentation" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="248a" class="pw-post-body-paragraph mr ms iq lw b lx nf jr mt lz ng ju mu mb nh mw mx md ni mz na mf nj nc nd mh ij bi translated">感谢您的阅读！</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="c6e4" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">更多计算资源</h1><p id="f563" class="pw-post-body-paragraph mr ms iq lw b lx ly jr mt lz ma ju mu mb mv mw mx md my mz na mf nb nc nd mh ij bi translated">在OnelTalksTech.com<a class="ae ne" href="https://oneltalkstech.com" rel="noopener ugc nofollow" target="_blank">观看涵盖各种计算主题的视频</a></p></div></div>    
</body>
</html>