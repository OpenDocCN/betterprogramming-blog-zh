<html>
<head>
<title>Explore GraphQL by Building a Blog With Slash GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过用Slash GraphQL构建一个博客来探索GraphQL</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/explore-graphql-by-building-a-blog-with-slash-graphql-161443b9e110?source=collection_archive---------6-----------------------#2020-10-23">https://betterprogramming.pub/explore-graphql-by-building-a-blog-with-slash-graphql-161443b9e110?source=collection_archive---------6-----------------------#2020-10-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="680e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过构建一些对你的职业生涯有帮助的实用工具来提高你的GraphQL技能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/31f07a6d71dcff0257155e39a7e0791d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pjuDXsV9mzB7JWXH"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@grakozy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格雷格·拉科齐</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c795" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将通过构建一个由最近发布的<a class="ae ky" href="https://dgraph.io/slash-graphql" rel="noopener ugc nofollow" target="_blank">斜杠GraphQL</a>——一个托管的graph QL后端支持的概念验证博客来探索graph数据库/GraphQL。</p><p id="caff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图是一种对系统中的信息建模的迷人方式，其中数据片段(节点)之间的关系(边)是系统的一级实体。这是与更常见的关系数据库(RDBMS)模型不同的方法，在RDBMS模型中，记录之间的关系是隐含的。例如，“该用户拥有这篇文章是因为<code class="fe lv lw lx ly b">user.id == post.user_id</code>”</p><p id="c921" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当数据之间的关系和数据本身一样重要时，图表是最有用的。例如:</p><ul class=""><li id="67f5" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">知识图表</li><li id="d7af" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">推荐引擎</li><li id="ce1c" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">供应链管理</li><li id="6faf" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">社会化媒体</li></ul><p id="4b14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，图提供了更具描述性的查询，在调整模型时具有更大的灵活性，并且在遍历关系时具有更好的性能。GraphQL(我们将在本文中使用)是一种数据操作和查询语言，它让您能够通过API绘制图表。</p><p id="8928" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您习惯于使用RDBMSs，那么使用图形可能会感到有些陌生，因此在本文中，我将尝试向您展示一些基本知识。我打算建立一个基于GraphQL的博客。<code class="fe lv lw lx ly b">User</code>、<code class="fe lv lw lx ly b">Post</code>和<code class="fe lv lw lx ly b">Comment</code>之间的关系(<code class="fe lv lw lx ly b">User</code>有许多<code class="fe lv lw lx ly b">Post</code>、<code class="fe lv lw lx ly b">Post</code>有许多<code class="fe lv lw lx ly b">Comment</code>、<code class="fe lv lw lx ly b">User</code>有许多<code class="fe lv lw lx ly b">Comment</code>)凸显了GraphQL的强大，如下所示。像往常一样，我并不打算在这里制作完成的、生产就绪的代码——只是一些简单的例子向您展示底层的概念。</p><p id="b5da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在这里找到本文<a class="ae ky" href="https://github.com/alvinslee/slash-graphql-blog" rel="noopener ugc nofollow" target="_blank">的所有示例代码。</a></p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="3535" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">数据图表</h1><p id="c560" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">对于本文，我将使用<a class="ae ky" href="https://dgraph.io/" rel="noopener ugc nofollow" target="_blank"> Dgraph </a>，这是一个用<a class="ae ky" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>编写的原生GraphQL数据库(相对于关系数据存储之上的GraphQL层),为具有高可用性和事务支持的大规模应用程序而设计。如果你有兴趣了解更多关于这个项目的信息，他们的<a class="ae ky" href="https://www.youtube.com/channel/UCghE41LR8nkKFlR3IFTRO4w/" rel="noopener ugc nofollow" target="_blank"> YouTube频道</a>上有一些很好的介绍视频。在GraphQL层上使用原生GraphQL数据库通常是首选，因为它提供了更简单的数据建模和深度连接速度，并解决了<a class="ae ky" href="https://medium.com/@bretdoucette/n-1-queries-and-how-to-avoid-them-a12f02345be5" rel="noopener"> n+1问题</a>。</p><p id="e9bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与其在服务器上安装Dgraph，或者通过Docker在本地运行它，我将使用他们托管的GraphQL后端服务，<a class="ae ky" href="https://dgraph.io/slash-graphql" rel="noopener ugc nofollow" target="_blank">斜杠GraphQL </a>。该平台提供了一个适用于本文的免费试用版(然后移动到9.99美元/月的固定费用，最高5GB的数据)。</p><p id="92e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始吧。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0b6b" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">在斜杠GraphQL上创建GraphQL后端</h1><p id="5e73" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">为了使用Slash GraphQL，您需要使用您的GitHub或Google帐户登录，然后您将看到带有创建和管理后端选项的web界面，以及许多教程和其他文档的链接，我建议您探索这些内容。</p><p id="a22e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Dgraph最近发布了<a class="ae ky" href="https://www.npmjs.com/package/slash-graphql" rel="noopener ugc nofollow" target="_blank">斜杠-graphql </a>，一个托管的graphql后端。有了托管后端，您不需要管理自己的基础设施，创建和管理自己的数据库，或者创建API端点。这些都已经为您处理好了，所以这是我们项目的绝佳选择。因为我非常喜欢使用命令行，所以我将在本文中使用它。但是如果你愿意，你可以通过网络界面做任何事情。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/f6726645facd6e918bb32d1af236d17e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_wcqklIHuz1em27o"/></div></div></figure><p id="063c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过运行以下命令来安装命令行工具:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="d7e6" class="nw mv it ly b gy nx ny l nz oa">npm install — global slash-graphql</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0491" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">创建后端</h1><p id="e318" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">使用slash-graphql来管理Slash GraphQL后端感觉很像使用Heroku命令行工具来管理Heroku应用程序，所以如果您对此感到满意，您会发现这很熟悉。</p><p id="3882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要通过命令行创建斜杠GraphQL后端，我们首先必须登录:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="e4c8" class="nw mv it ly b gy nx ny l nz oa">slash-graphql login</span></pre><p id="9a24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将提示您确认终端上的代码与该命令将打开的网页上显示的代码相匹配。一旦你做到了这一点，你可以发出命令斜线GraphQL。</p><p id="42a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以创建我们的GraphQL后端，如下所示:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="782f" class="nw mv it ly b gy nx ny l nz oa">slash-graphql create-backend blog</span></pre><p id="b7d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将输出您的后端的端点，这通常需要大约20秒来创建。这是我们将用来与GraphQL数据库交互的URL。您将在整篇文章中使用它，所以请记下来。在我的例子中，我的GraphQL端点是<code class="fe lv lw lx ly b"><a class="ae ky" href="https://anxious-aunt.us-west-2.aws.cloud.dgraph.io/graphql" rel="noopener ugc nofollow" target="_blank">https://anxious-aunt.us-west-2.aws.cloud.dgraph.io/graphql</a></code>。</p><p id="30df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请在代码示例中的任何地方替换您自己的端点。</p><p id="1d13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。只需几个步骤，您就拥有了一个功能完整的托管GraphQL后端。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="6e13" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">定义模式</h1><p id="cf1f" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">接下来，我们需要为我们的博客数据定义一个模式。创建一个名为<code class="fe lv lw lx ly b">schema.graphql</code>的新文件，内容如下:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="44b1" class="nw mv it ly b gy nx ny l nz oa">type User {<br/>  email: String! @id @search(by: [hash])<br/>  name: String @search(by: [exact])<br/>  posts: [Post] @hasInverse(field: user)<br/>}</span><span id="334c" class="nw mv it ly b gy ob ny l nz oa">type Post {<br/>  id: ID!<br/>  title: String! @search(by: [fulltext])<br/>  body: String!<br/>  image: String<br/>  user: User!<br/>  comments: [Comment] @hasInverse(field: post)<br/>}</span><span id="d581" class="nw mv it ly b gy ob ny l nz oa">type Comment {<br/>  id: ID!<br/>  body: String!<br/>  user: User!<br/>  post: Post!<br/>}</span></pre><p id="34e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们稍微分解一下。我将在这里介绍几个亮点。详情请看<a class="ae ky" href="https://dgraph.io/docs/slash-graphql/slash-quick-start/" rel="noopener ugc nofollow" target="_blank">斜线GraphQL文档</a>。</p><p id="b935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从最后一个实体开始，我们这样定义<code class="fe lv lw lx ly b">Comment</code>:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="b35c" class="nw mv it ly b gy nx ny l nz oa">type Comment {<br/>  id: ID!<br/>  body: String!<br/>  user: User!<br/>  post: Post!<br/>}</span></pre><p id="b335" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们有一个名为<code class="fe lv lw lx ly b">Comment</code>的节点类型，它有几个属性。</p><p id="1278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">id</code> : <code class="fe lv lw lx ly b">ID!</code>告诉Dgraph为这个类型生成自己的uid值。</p><p id="0658" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">body</code>是必需的字符串值。</p><p id="c520" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">post</code>和<code class="fe lv lw lx ly b">user</code>有类型<code class="fe lv lw lx ly b">Post</code>和<code class="fe lv lw lx ly b">User</code>，而<code class="fe lv lw lx ly b">!</code>表示这些是必填字段——即每个评论属于一个<code class="fe lv lw lx ly b">Post</code>并且也属于一个<code class="fe lv lw lx ly b">User</code>。</p><p id="0a42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Post</code>类型有一个<code class="fe lv lw lx ly b">comments</code>属性，它是<code class="fe lv lw lx ly b">Comment</code>节点的列表:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="4ef7" class="nw mv it ly b gy nx ny l nz oa">comments: [Comment] @hasInverse(field: post)</span></pre><p id="4224" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，<code class="fe lv lw lx ly b">User</code>也有很多帖子。</p><p id="ca0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>我们告诉我们的后端存在什么样的节点类型以及它们如何相互关联，但是我们不需要定义如何使这些关系工作——没有外键，没有连接，也没有多对多映射表。</p><p id="edbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用一个命令将这个模式应用到我们的后端:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="d984" class="nw mv it ly b gy nx ny l nz oa">slash-graphql update-schema — endpoint <a class="ae ky" href="https://anxious-aunt.us-west-2.aws.cloud.dgraph.io/graphql" rel="noopener ugc nofollow" target="_blank">https://anxious-aunt.us-west-2.aws.cloud.dgraph.io/graphql</a> schema.graphql</span></pre><p id="54fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在使用web界面，下面是该设置的外观:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/1db0957673cd90ebf9d13cd8cf4b530b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*34qgamoe2d35AmGI"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/3c4fd0468a3639219be68280fa4f99a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8hdqPAFiI5gTCqHa"/></div></div></figure><p id="9dce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了模式，我们可以添加一些数据。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="406f" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">使用curl添加数据</h1><p id="e8a5" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">虽然slash-graphql工具有导入数据功能，但它是为恢复备份而不是添加数据块而设计的。</p><p id="826b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与GraphQL数据库交互的通常方式是通过HTTP请求，所以这就是我们如何使用curl添加数据，通过这个脚本，我们将它保存为<code class="fe lv lw lx ly b">post.sh</code>:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="11fd" class="nw mv it ly b gy nx ny l nz oa">#!/bin/bash<br/>FILE=$1<br/>curl — request POST \<br/> — header “Content-Type: application/graphql” \<br/> — data “$(cat ${FILE})” \<br/>${ENDPOINT}</span></pre><p id="cbac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该脚本使用curl向我们的graphql端点<code class="fe lv lw lx ly b">${ENDPOINT}</code>发出HTTP POST请求(<code class="fe lv lw lx ly b"> — request POST</code>)。</p><p id="d9f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求的主体是文件<code class="fe lv lw lx ly b">${FILE}</code> ( <code class="fe lv lw lx ly b"> — data $(cat “${FILE})”</code>)的内容，我们将文件名作为参数传递给脚本<code class="fe lv lw lx ly b">FILE=$1</code>。</p><p id="46d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将<code class="fe lv lw lx ly b">Content-Type</code>头设置为<code class="fe lv lw lx ly b">application/graphql</code>(也可以用JSON发送命令)。</p><p id="2fc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">斜杠GraphQL说它的<a class="ae ky" href="https://dgraph.io/docs/slash-graphql/security/" rel="noopener ugc nofollow" target="_blank">查询和变异在默认情况下是不受限制的</a>。您可以通过在Slash GraphQL的模式中添加一个<code class="fe lv lw lx ly b">@auth</code>指令来保护您的后端。这将要求您在请求中使用一个API键和一个<code class="fe lv lw lx ly b">Authorization</code>头。不过，为了简单起见，我们不限制我们的后端。</p><p id="8d8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一下，记得用下面的命令将<code class="fe lv lw lx ly b">post.sh</code>设置为可执行:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="1e53" class="nw mv it ly b gy nx ny l nz oa">chmod u+x post.sh</span></pre><p id="3548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以在我们的<code class="fe lv lw lx ly b">post.sh</code>脚本中设置我们需要的环境变量:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="e481" class="nw mv it ly b gy nx ny l nz oa">export ENDPOINT=https://anxious-aunt.us-west-2.aws.cloud.dgraph.io/graphql</span></pre><p id="9428" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以添加我们的数据。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="7668" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">添加数据</h1><p id="4a17" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">下面是我们将要发送的<code class="fe lv lw lx ly b">.graphql</code>(一种改变数据的方式)，我们将它保存在一个名为<code class="fe lv lw lx ly b">addData.graphql</code>的文件中:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="32f1" class="nw mv it ly b gy nx ny l nz oa">mutation {<br/>  addPost(input: [<br/>    {<br/>      user: {<br/>        name: “Burk Dronsfield”,<br/>        email: “bdronsfield0@apple.com”<br/>      },<br/>      title: “Scallops — 10/20”,<br/>      image: “https://picsum.photos/id/441/600/300",<br/>      body: “Vestibulum ac est lacinia nisi venenatis tristique. Fusce congue, diam id ornare imperdiet, sapien urna pretium nisl, ut volutpat sapien arcu sed augue. Aliquam erat volutpat.\n\nIn congue. Etiam justo. Etiam pretium iaculis justo.”,<br/>      comments: [<br/>        {<br/>          body: “First post!”,<br/>          user: {<br/>            email: “tgodleman1@chronoengine.com”,<br/>            name: “Tamar Godleman”<br/>          }<br/>        }<br/>      ]<br/>    }<br/>  ])<br/>  {<br/>    post {<br/>      id<br/>      title<br/>    }<br/>  }<br/>}</span></pre><p id="8136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些用户都不是真实的人——这是来自<a class="ae ky" href="https://mockaroo.com/" rel="noopener ugc nofollow" target="_blank"> Mockaroo </a>的样本数据。</p><p id="5ee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意我们是如何添加两个用户、一篇博客文章和一条评论的，所有这些都是通过对后端的一个请求完成的。从这里我们可以开始看到GraphQL数据库的威力。</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="a2c8" class="nw mv it ly b gy nx ny l nz oa">./post.sh addData.graphql | jq</span></pre><p id="df12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">| jq</code>是可选的，但是对我们的帖子的响应将是一个JSON文档，通过<a class="ae ky" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a>传递它会更容易阅读。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c2c4" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">查询数据库</h1><p id="6edd" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们可以通过HTTP POST以完全相同的方式查询数据库。这里有一个查询来检索用户和他们所写的任何帖子的标题，我们将把它们保存在一个名为<code class="fe lv lw lx ly b">queryUser.graphql</code>的文件中:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="a135" class="nw mv it ly b gy nx ny l nz oa">query {<br/>  queryUser {<br/>    name<br/>    email<br/>    posts {<br/>      title<br/>    }<br/>  }<br/>}</span></pre><p id="b9a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们以与变异完全相同的方式运行这个查询:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="9f12" class="nw mv it ly b gy nx ny l nz oa">./post.sh queryUser.graphql | jq</span></pre><p id="3ff7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您得到的输出顶部应该是这样的:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="c71b" class="nw mv it ly b gy nx ny l nz oa">{<br/>  “data”: {<br/>    “queryUser”: [<br/>      {<br/>        “name”: “Tamar Godleman”,<br/>        “posts”: []<br/>      },<br/>      {<br/>        “name”: “Burk Dronsfield”,<br/>        “posts”: [<br/>          {<br/>            “title”: “Scallops — 10/20”<br/>          }<br/>        ]<br/>      }<br/>    ]<br/>  },</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="8217" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">阿波罗中间件层</h1><p id="68bf" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Slash GraphQL为我们提供了一种快速简单的方法来启动和运行GraphQL后端。几分钟之内，我们就有了一个本地图形数据库和一个运行最常见查询和变化的界面。通过进入Slash GraphQL 的<a class="ae ky" href="https://slash.dgraph.io/_/explorer" rel="noopener ugc nofollow" target="_blank"> API Explorer，您可以看到已经预先构建好的查询和变化。对于希望快速入门的开发人员来说，Slash GraphQL是一个很好的选择。</a></p><p id="f11e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当您准备构建面向公众的应用程序时，您可能会发现在Slash GraphQL之上构建一个GraphQL服务器作为一个瘦中间件层会很有帮助。我们可以使用Apollo服务器作为客户端和Slash GraphQL之间的网关。您可能会选择这样做，原因有很多。以下是一些可能性:</p><ul class=""><li id="697b" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">基于您提供的模式，Slash GraphQL提供了一组标准的查询和变异。您可能决定不希望<em class="od">所有这些查询对公众可用，并为面向公众的GraphQL API选择一组缩小范围的查询。</em></li><li id="4b2e" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">您可能希望您的服务器适应更复杂的查询或变化，然后您的中间件层处理并映射到各种请求以削减GraphQL。</li><li id="4363" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">您可能希望使用Slash GraphQL提供的查询，但是要对它们进行重命名，或者在使它们对面向公众的API可用时更改签名或默认值。</li><li id="35b7" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">您可能希望您的Slash GraphQL后端被一个API密匙锁定，但又希望您自己的GraphQL API在不需要那个API密匙的情况下公开可用。您的API密匙可以存储在您的中间件层上，并且总是传递给Slash GraphQL，而您的客户端或最终用户从来不需要担心它。</li></ul><p id="fe30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，让我们<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/getting-started/" rel="noopener ugc nofollow" target="_blank">构建一个简单的Apollo服务器</a>；然后我们可以直接在Apollo Server的内置平台上运行我们的查询。</p><p id="ad40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个名为<code class="fe lv lw lx ly b">server-layer</code>的新文件夹。在该文件夹中，我们将创建一个新项目，添加几个包，并创建一个名为<code class="fe lv lw lx ly b">index.js</code>的新文件:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="804f" class="nw mv it ly b gy nx ny l nz oa">&gt; mkdir server-layer<br/>&gt; cd server-layer<br/>&gt; npm init — yes<br/>&gt; npm install — save apollo-server graphql node-fetch<br/>&gt; touch index.js</span></pre><p id="f8bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要配置Apollo服务器，我们需要提供两件东西。首先，我们需要<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/getting-started/#step-3-define-your-graphql-schema" rel="noopener ugc nofollow" target="_blank">提供一个模式</a>，我们称之为<code class="fe lv lw lx ly b">typeDefs</code>。我们可以使用发送给Slash GraphQL的稍微修改的模式版本，但也可以添加一个希望服务器提供的查询列表。</p><p id="64bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，我们需要<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/getting-started/#step-5-define-a-resolver" rel="noopener ugc nofollow" target="_blank">提供解析器</a>,告诉我们的服务器如何检索数据以响应来自客户端的查询。这就是奇迹发生的地方。我们的解析器将向我们的Slash GraphQL端点发送经过身份验证的请求，然后获取响应结果并将其作为我们的响应传递给客户端。</p><p id="0bd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是<code class="fe lv lw lx ly b">index.js</code>的内容，我们将在下面一步步介绍:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="b841" class="nw mv it ly b gy nx ny l nz oa">const { ApolloServer, gql } = require(‘apollo-server’)<br/>const fetch = require(‘node-fetch’)</span><span id="4499" class="nw mv it ly b gy ob ny l nz oa">const ENDPOINT = ‘https://anxious-aunt.us-west-2.aws.cloud.dgraph.io/graphql'</span><span id="9348" class="nw mv it ly b gy ob ny l nz oa">const typeDefs = gql`<br/>  type User {<br/>    email: String!<br/>    name: String<br/>    posts: [Post]<br/>  }</span><span id="f5e0" class="nw mv it ly b gy ob ny l nz oa">  type Post {<br/>    id: ID!<br/>    title: String!<br/>    body: String!<br/>    image: String<br/>    user: User!<br/>    comments: [Comment]<br/>  }</span><span id="a64f" class="nw mv it ly b gy ob ny l nz oa">  type Comment {<br/>    id: ID!<br/>    body: String!<br/>    user: User!<br/>    post: Post!<br/>  }</span><span id="dd58" class="nw mv it ly b gy ob ny l nz oa">  type Query {<br/>    getUser(email: String!): User<br/>    getAllUsers: [User]<br/>    getAllPosts: [Post]<br/>  }<br/>`</span><span id="0df7" class="nw mv it ly b gy ob ny l nz oa">const method = ‘POST’<br/>const headers = {<br/>  ‘Content-type’: ‘application/graphql’<br/>}</span><span id="3be7" class="nw mv it ly b gy ob ny l nz oa">const argsToString = (args) =&gt; {<br/>  if (typeof args === ‘object’) { let argStrings = []<br/>    Object.keys(args).forEach((key) =&gt; {<br/>    argStrings.push(`${key}:”${args[key]}”`)<br/>    })<br/>    if (argStrings.length) {<br/>      return `${argStrings.join(‘, ‘)}`<br/>    }<br/>  }<br/>  return ‘’<br/>}</span><span id="68c8" class="nw mv it ly b gy ob ny l nz oa">const sendQuery = async({ name, args, fields }) =&gt; {<br/>  let body = `<br/>    query {<br/>      ${name} (${argsToString(args)}) {<br/>      ${fields}<br/>    }<br/>  }`<br/>  const fetchResult = await fetch(ENDPOINT, {<br/>    method,<br/>    headers,<br/>    body<br/>  })<br/>  const result = await fetchResult.json()<br/>  return result.data[name]<br/>}</span><span id="3f53" class="nw mv it ly b gy ob ny l nz oa">const resolvers = {<br/>  Query: {<br/>    getAllUsers: async () =&gt; sendQuery({ name: ‘queryUser’, fields: ‘name posts { id title }’ }),<br/>    getUser: async (_parent, args) =&gt; sendQuery({ name: ‘getUser’, args, fields: ‘name email posts { id title }’ }),<br/>    getAllPosts: async () =&gt; sendQuery({ name: ‘queryPost’, fields: ‘id title body image user { name } comments { id body user { name } }’ })<br/>  }<br/>}</span><span id="293e" class="nw mv it ly b gy ob ny l nz oa">const server = new ApolloServer({<br/>  typeDefs,<br/>  resolvers,<br/>})</span><span id="914f" class="nw mv it ly b gy ob ny l nz oa">server.listen().then(({ url })=&gt; {<br/>  console.log(`Server ready at at ${url}`)<br/>})</span></pre><p id="1771" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一下，记得更改<code class="fe lv lw lx ly b">ENDPOINT</code>以匹配您的Slash GraphQL帐户的端点。</p><p id="3370" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回顾一下我们在这里所做的事情。</p><p id="4fb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们包含了我们需要的包(最重要的是，<code class="fe lv lw lx ly b">ApolloServer</code>)并定义了几个常量。</p><p id="1a9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们定义了我们的<code class="fe lv lw lx ly b">typeDefs</code>，它是我们的模式，以及我们希望服务器提供的任何查询的签名。</p><p id="a1cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到这里使用的模式看起来<em class="od">非常类似于我们在Slash GraphQL中使用的模式。唯一的区别是，我们删除了任何与斜杠GraphQL一起使用的<code class="fe lv lw lx ly b">@</code>指令。那些指令是专门针对Slash GraphQL和Dgraph的，Apollo Server不知道如何处理它们。我们在斜杠GraphQL级别上仍然拥有这些指令的功能，因此我们不会因为在这里不包含它们而丢失任何东西。</em></p><p id="15f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe lv lw lx ly b">typeDefs</code>中，您还会看到我们将接受的查询:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="aab7" class="nw mv it ly b gy nx ny l nz oa">type Query {<br/>  getUser(email: String!): User<br/>  getAllUsers: [User]<br/>  getAllPosts: [Post]<br/>}</span></pre><p id="7649" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该注意到这里的一些事情。首先，虽然Slash GraphQL为我们提供了类似于<code class="fe lv lw lx ly b">getComment</code>或<code class="fe lv lw lx ly b">queryPost</code>的查询(再次参考Slash GraphQL 上的<a class="ae ky" href="https://slash.dgraph.io/_/explorer" rel="noopener ugc nofollow" target="_blank"> API Explorer)，但是我们可能已经决定不希望我们面向公众的API允许这些查询。我们只想允许上面的两个查询。</a></p><p id="8682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您会注意到我们有一个名为<code class="fe lv lw lx ly b">getAllUsers</code>的查询—我们将通过解析器将它映射到斜杠GraphQL的<code class="fe lv lw lx ly b">queryUser</code>查询。也许是因为现有的API规范要求我们在这个查询中使用名称<code class="fe lv lw lx ly b">getAllUsers</code>。构建这个中间件层允许我们进行这种重命名。我们对<code class="fe lv lw lx ly b">getAllPosts</code>做同样的事情。</p><p id="6412" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在讨论解析器之前，我们写了一些方便的方法来简化我们的工作。最终，我们的解析器将发送一个HTTP请求到我们的Slash GraphQL端点，然后用我们从Slash GraphQL得到的结果来响应。接下来的几个方法可以帮助我们做到这一点。</p><p id="4128" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">sendQuery</code>使用node-fetch向斜杠GraphQL <code class="fe lv lw lx ly b">ENDPOINT</code>发送HTTP请求。这看起来非常类似于我们上面做的curl调用。我们将我们的方法设置为<code class="fe lv lw lx ly b">POST</code>，并且正确地设置了我们的头。</p><p id="eed8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们做一些字符串连接工作(在<code class="fe lv lw lx ly b">argsToString</code>和<code class="fe lv lw lx ly b">sendQuery</code>中)来拼凑我们的fetch请求的主体以斜杠GraphQL。当Apollo服务器收到请求时，我们接受它；然后我们构建适当的请求体。</p><p id="fe19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们看一下我们的解析器。我们编写的解析器应该与我们在<code class="fe lv lw lx ly b">typeDefs</code>中定义的查询相匹配。我们的Apollo服务器提供了一个<code class="fe lv lw lx ly b">getUser</code>查询，这个查询<em class="od">通过向Slash GraphQL发送一个非常相似的查询来解析</em>。同时，我们的<code class="fe lv lw lx ly b">getAllUsers</code>查询<em class="od">通过将等价的<code class="fe lv lw lx ly b">queryUser</code>查询发送到斜杠GraphQL来解析</em>，并且<code class="fe lv lw lx ly b">getAllPosts</code>的行为类似。</p><p id="bc25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一下，你可能已经注意到，我们也限制哪些字段可以被返回。例如，在<code class="fe lv lw lx ly b">getAllUsers</code>和<code class="fe lv lw lx ly b">getAllPosts</code>中，我们查询姓名，但<em class="od">不是</em>电子邮件。虽然Slash GraphQL可能允许我们查询电子邮件，但我们已经决定，我们面向公众的GraphQL API将<em class="od">而不是</em>允许用户在获取用户列表时检索电子邮件。</p><p id="9a4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为替代，我们也可以为Apollo GraphQL服务器修改我们的<code class="fe lv lw lx ly b">typeDefs</code>,使类型<code class="fe lv lw lx ly b">User</code>定义不包括电子邮件。尽管我们的Slash GraqhQL后端包含了一封电子邮件，但我们可以决定，出于所有的意图和目的，面向公众的Apollo GraphQL服务器不应该包含电子邮件。</p><p id="beb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了看到这一点，我们可以启动我们的服务器，然后打开我们的浏览器来查看Apollo Server的内置游戏:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="553c" class="nw mv it ly b gy nx ny l nz oa">&gt; node index.js<br/>Server ready at <a class="ae ky" href="http://localhost:4000/..." rel="noopener ugc nofollow" target="_blank">http://localhost:4000/...</a></span></pre><p id="dbad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开浏览器，并转至<code class="fe lv lw lx ly b"><a class="ae ky" href="http://localhost:4000" rel="noopener ugc nofollow" target="_blank">http://localhost:4000</a></code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/c0911e7d6f00b06e3f0b030e0d6bf1e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e3ORE5XIYLTUPX0E"/></div></div></figure><p id="6446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们执行一个<code class="fe lv lw lx ly b">getUser</code>查询来查找电子邮件为<code class="fe lv lw lx ly b"><a class="ae ky" href="mailto:bdronsfield0@apple.com" rel="noopener ugc nofollow" target="_blank">bdronsfield0@apple.com</a></code>的用户:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/b2e0bbdcb046094bfa675f321ba4d234.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/0*_lGnbuxcInfmCNy5"/></div></figure><p id="c54d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们得到的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/637695647ea66307102560f4e7caa185.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/0*V9BwHbTQ1ekQr-6n"/></div></figure><p id="d8c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的瘦中间件已经启动并运行了！现在，有了Apollo Server作为我们的客户端和Slash GraphQL之间的代理，我们可以构建一些额外的控制，并微调哪些查询是可用的——以及我们希望这些查询如何结构化。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f973" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">在Web客户端查看我们的博客</h1><p id="7e5b" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">最后，如果我们没有一个前端客户端来显示博客文章，那么提供博客文章的服务器又有什么用呢？为了进行端到端的演示，我们将构建一个小型Vue.js web客户端来显示我们的博客文章。</p><p id="848b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<a class="ae ky" href="https://github.com/alvinslee/slash-graphql-blog" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>包含了一个非常简单的Vue客户端。要运行它，只需执行以下操作:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="ee7b" class="nw mv it ly b gy nx ny l nz oa">&gt; git clone <a class="ae ky" href="https://github.com/alvinslee/slash-graphql-vue-blog.git" rel="noopener ugc nofollow" target="_blank">https://github.com/alvinslee/slash-graphql-blog.git</a><br/>&gt; cd slash-graphql-blog/vue-client<br/>&gt; npm install<br/>&gt; npm run serve</span></pre><p id="dc75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，打开浏览器进入<code class="fe lv lw lx ly b"><a class="ae ky" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/</a></code>。简单来说，我们的Vue客户端只是一个带有<code class="fe lv lw lx ly b">PostList</code>组件的页面。该组件通过向本地Apollo GraphQL服务器发出<code class="fe lv lw lx ly b">getAllPosts</code>查询请求来填充自身(在<code class="fe lv lw lx ly b"><a class="ae ky" href="http://localhost:4000" rel="noopener ugc nofollow" target="_blank">http://localhost:4000</a></code>——确保它也在运行！).</p><p id="ab01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过打开<code class="fe lv lw lx ly b">src/components/PostList.vue</code>，我们可以快速一瞥在我们的<code class="fe lv lw lx ly b">PostList</code>组件下发生了什么。具体来说，让我们看看<code class="fe lv lw lx ly b">fetchData</code>方法:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="df19" class="nw mv it ly b gy nx ny l nz oa">fetchData: async function () {<br/>  const body = {<br/>    query: ‘query { getAllPosts { id title body image user { name } comments { id body user { name } } } }’<br/>}<br/>  const sendFetch = await fetch(‘http://localhost:4000', {<br/>    method: ‘POST’,<br/>    headers: {<br/>      ‘Content-Type’: ‘application/json’<br/>    },<br/>    body: JSON.stringify(body)<br/>  })<br/>  this.posts = (await sendFetch.json()).data.getAllPosts<br/>}</span></pre><p id="2b7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法创建了一个GraphQL查询，并在<code class="fe lv lw lx ly b"><a class="ae ky" href="http://localhost:4000" rel="noopener ugc nofollow" target="_blank">http://localhost:4000</a></code>将它作为POST请求发送给我们的Apollo服务器。返回的响应中的数据是组件用来填充页面的数据，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/49c10bd1d6c7aeb6416adbea2907378e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nba-MI8HZNhOWE5a"/></div></div></figure><p id="8156" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不错！</p><p id="66a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可能想知道:<em class="od">我们为什么要为Apollo GraphQL服务器费心？难道我不能设置我的客户机直接查询斜杠GraphQL端点吗？</em>答案是:<em class="od">是的，你可以，但是:</em></p><ul class=""><li id="3d4d" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">如果您已经将Slash GraphQL设置为只能由客户端API键访问，那么您需要在您的客户端中使该键可用，以便它可以发出Slash GraphQL请求。出于安全原因，您可能不想这样做。将密钥隐藏在Apollo GraphQL服务器中更安全。</li><li id="54e5" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">如果有人查看客户机代码，他们可以看到端点和正在发送的查询。有了这些信息，他们可以尝试自己的一些查询。当您不希望公开数据时，恶意用户可能会尝试访问博客文章作者的电子邮件字段。通过让Apollo GraphQL服务器充当网关，您能够限制进出Slash GraphQL的内容。</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0429" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="244c" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们已经简要讨论了图形数据库和传统RDBMS之间的区别，并且我们已经经历了用斜杠GraphQL建立托管GraphQL后端、创建模式以及使用突变和查询来操作数据的过程。</p><p id="2fc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们构建了一个瘦的Apollo GraphQL服务器层，作为最终用户和Slash GraphQL之间的网关，以限制可以通过的查询类型。最后，我们组装了一个非常基本的web界面，作为GraphQL支持的博客的概念验证。</p><p id="d08b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我仅仅触及了使用Slash GraphQL和GraphQL数据库所能做的事情的表面，但是我希望它能激发您深入研究并了解更多。</p></div></div>    
</body>
</html>