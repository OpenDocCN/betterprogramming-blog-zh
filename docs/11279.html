<html>
<head>
<title>Learn Powerful MongoDB Aggregation Pipelines From Practical Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从实际例子中了解强大的MongoDB聚合管道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-powerful-mongodb-aggregation-pipelines-from-practical-examples-efead98f08?source=collection_archive---------5-----------------------#2022-03-05">https://betterprogramming.pub/learn-powerful-mongodb-aggregation-pipelines-from-practical-examples-efead98f08?source=collection_archive---------5-----------------------#2022-03-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8b2a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过聚合深入了解MongoDB中的数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/64c1ed07485045d5f86f897e086c140f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*t-5rhVZafCqhYqx-.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/illustrations/conveyor-valve-pressure-gauge-5438440/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="75a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MongoDB不仅仅是一个NoSQL文档数据库。您可以使用聚合管道对集合中的文档执行复杂的分析。一个常见的任务是对结果进行分组，并获得每组的总数据或平均数据。您甚至可以在分组前过滤、转换或清理数据。</p><p id="0689" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">聚合管道由一个或多个按顺序处理文档的阶段组成。每个阶段对输入文档执行一些操作，并将处理过的文档传递给下一个阶段。例如，第一个阶段可以根据一些条件过滤文档，第二个阶段可以对过滤的文档进行分组并进行一些聚合，第三个阶段可以输出结果。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="f387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文的演示中，我们将使用文章中介绍的数据进行高级MongoDB查询。如果您想继续学习，查看该文章中的系统设置步骤会有所帮助，以便更好地了解数据。但是，如果您很着急，您可以下载这个JSON文件并使用以下命令导入数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="afe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们使用Docker在本地启动MongoDB服务器，但是您可以使用MongoDB Atlas这样的托管服务器，它有一个免费层，对于学习来说是一个不错的选择。</p><p id="a54d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当上面的代码运行时，我们将在<code class="fe me mf mg mh b">products</code>数据库中拥有一个包含200个笔记本电脑数据文档的<code class="fe me mf mg mh b">laptops</code>集合。这些文件的内容如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="4a11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在数据已经准备好了，我们可以开始编写聚合管道来分析数据。建议使用<a class="ae ky" href="https://medium.com/codex/how-to-use-mongodb-with-graphical-ides-420597ede80e" rel="noopener"> MongoDB IDE </a>来编写通常跨越多行的管道。使用IDE，您可以自动完成代码，并且可以方便地编写跨多行的查询或管道。然而，在这篇文章中，你可以复制代码，在<code class="fe me mf mg mh b">mongosh</code>中运行并检查结果。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f77e" class="mi mj it bd mk ml mm dn mn mo mp dp mq li mr ms mt lm mu mv mw lq mx my mz na bi translated"><code class="fe me mf mg mh b"><strong class="ak">$group</strong></code> <strong class="ak">阶段</strong></h2><p id="c338" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">让我们首先检查一下我们的集合中有多少文档。</p><pre class="kj kk kl km gt ng mh nh ni aw nj bi"><span id="592e" class="mi mj it mh b gy nk nl l nm nn">$ <strong class="mh iu">docker exec -it mongo-server bash</strong><br/>$ <strong class="mh iu">mongosh "mongodb://admin:pass@localhost:27017"</strong></span><span id="9932" class="mi mj it mh b gy no nl l nm nn">test&gt; <strong class="mh iu">use products</strong><br/>products&gt; <strong class="mh iu">db.laptops.countDocuments</strong>()<br/>200</span></pre><p id="63ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用一个聚合管道来计算文档的数量，这在现在看起来有点过了，但它可以作为以后更复杂管道的介绍:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="baa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的第一个管道中，只有一个<code class="fe me mf mg mh b">$group</code>阶段，顾名思义，它按照指定的<code class="fe me mf mg mh b">_id</code>对文档进行分组。通常我们会为<code class="fe me mf mg mh b">_id</code>指定一个字段，根据该字段对文档进行分组。然而，特别是当<code class="fe me mf mg mh b">_id</code>是<code class="fe me mf mg mh b">null</code>时，这意味着我们将所有的文件分组在一起。此外，<code class="fe me mf mg mh b">total</code>是一个新字段，保存由<code class="fe me mf mg mh b">$count</code>累加器运算符返回的数据，它只是统计每组中的文档数。</p><p id="1780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们按品牌分组，并检查每个品牌的数量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="8cec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，在<code class="fe me mf mg mh b">$group</code>阶段，<code class="fe me mf mg mh b">_id</code>指定对输入文档进行分组的字段。<code class="fe me mf mg mh b">_id</code>接受一个<a class="ae ky" href="https://docs.mongodb.com/manual/meta/aggregation-quick-reference/#std-label-aggregation-expressions" rel="noopener ugc nofollow" target="_blank">聚合表达式</a>作为其值，可以是<a class="ae ky" href="https://docs.mongodb.com/manual/meta/aggregation-quick-reference/#std-label-agg-quick-ref-field-paths" rel="noopener ugc nofollow" target="_blank">字段路径</a>、<a class="ae ky" href="https://docs.mongodb.com/manual/meta/aggregation-quick-reference/#std-label-agg-quick-ref-variables" rel="noopener ugc nofollow" target="_blank">系统变量</a>、<a class="ae ky" href="https://docs.mongodb.com/manual/meta/aggregation-quick-reference/#std-label-agg-quick-ref-expression-objects" rel="noopener ugc nofollow" target="_blank">表达式对象</a>等。</p><p id="cafc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b"><strong class="lb iu">"</strong>$brand"</code>是字段路径，必须用引号括起来。您可能想知道为什么我们必须在字段名前加一个美元符号<code class="fe me mf mg mh b">$</code>。是的，这是你第一次看到它时非常困惑的。您需要理解<code class="fe me mf mg mh b">_id</code>接受一个表达式，而不是一个普通的字段名称。并且在表达式中，如果我们要指定一个字段，就必须在它前面加一个美元符号，否则，它会被当作一个文字字符串。</p><p id="90dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从技术上来说，<code class="fe me mf mg mh b">"$brand"</code>是<code class="fe me mf mg mh b">"$$CURRENT.brand"</code>的快捷方式，其中<code class="fe me mf mg mh b"><a class="ae ky" href="https://docs.mongodb.com/manual/reference/aggregation-variables/#mongodb-variable-variable.CURRENT" rel="noopener ugc nofollow" target="_blank">CURRENT</a></code>是默认为当前单据的系统变量。一旦知道了这些，<code class="fe me mf mg mh b">"$brand"</code>就没那么神秘了吧？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="b166" class="mi mj it bd mk ml mm dn mn mo mp dp mq li mr ms mt lm mu mv mw lq mx my mz na bi translated"><code class="fe me mf mg mh b"><strong class="ak">$sort</strong></code> <strong class="ak">阶段</strong></h2><p id="f3c3" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">让我们按品牌数量降序排列笔记本电脑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="8cbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe me mf mg mh b">$group</code>阶段之后添加新的<code class="fe me mf mg mh b">$sort</code>阶段。正如我们已经知道的，一个阶段过滤或聚合的文档被传递到下一个阶段。在这种情况下，分组结果被传递到<code class="fe me mf mg mh b">$sort</code>阶段。原始文档的字段现在不可用，只有以前<code class="fe me mf mg mh b">$group</code>阶段的字段可用。因此，我们可以通过在前面的<code class="fe me mf mg mh b">$group</code>阶段生成的<code class="fe me mf mg mh b">total</code>字段进行排序。另外，<code class="fe me mf mg mh b">$sort</code>接受一个普通的字符串作为字段名，这样就不需要在它前面加上美元符号。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="7809" class="mi mj it bd mk ml mm dn mn mo mp dp mq li mr ms mt lm mu mv mw lq mx my mz na bi translated"><code class="fe me mf mg mh b"><strong class="ak">$match</strong></code> <strong class="ak">舞台</strong></h2><p id="4d41" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们可以添加一个<code class="fe me mf mg mh b">$match</code>阶段来过滤输入文档，只将符合指定条件的文档传递给下一个管道阶段。我们把没有现货的笔记本电脑过滤掉，只计算还有现货的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="0e3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在同一个管道中多次使用<code class="fe me mf mg mh b">$match</code>阶段。我们只输出库存超过10个的品牌:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="709a" class="mi mj it bd mk ml mm dn mn mo mp dp mq li mr ms mt lm mu mv mw lq mx my mz na bi translated"><code class="fe me mf mg mh b"><strong class="ak">$unwind</strong></code>阶段<strong class="ak">阶段</strong></h2><p id="fede" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">现在让我们介绍一个更复杂的阶段，<code class="fe me mf mg mh b">$unwind</code>，它从输入文档中解构一个数组字段，并为原始数组的每个元素输出一个文档。</p><p id="67d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这样的文档:</p><pre class="kj kk kl km gt ng mh nh ni aw nj bi"><span id="682e" class="mi mj it mh b gy nk nl l nm nn">{"_id": 1, "name": "John", "scores": [70, 90, 80]}</span></pre><p id="a8ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">scores</code>字段上的<code class="fe me mf mg mh b">$unwind</code>阶段将生成以下文件:</p><pre class="kj kk kl km gt ng mh nh ni aw nj bi"><span id="319a" class="mi mj it mh b gy nk nl l nm nn">{"_id": 1, "name": "John", "scores": 70}<br/>{"_id": 1, "name": "John", "scores": 90}<br/>{"_id": 1, "name": "John", "scores": 80}</span></pre><p id="5a23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由来自相同数组的<code class="fe me mf mg mh b">$unwind</code>产生的文档将具有相同的主键<code class="fe me mf mg mh b">_id</code>。现在让我们展开<code class="fe me mf mg mh b">laptops</code>文档的<code class="fe me mf mg mh b">attributes</code>字段，它是一个属性文档数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="60ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，它按预期展开，每个新文档包含原始数组的一个属性。注意，<code class="fe me mf mg mh b">$unwind</code>阶段期望一个<a class="ae ky" href="https://docs.mongodb.com/manual/reference/glossary/#std-term-field-path" rel="noopener ugc nofollow" target="_blank">字段路径</a>作为输入，它应该用类似于<code class="fe me mf mg mh b">$group</code>阶段的<code class="fe me mf mg mh b">_id</code>字段的美元符号前缀来指定。</p><p id="e7f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们找出每个品牌笔记本电脑的最大内存:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><pre class="kj kk kl km gt ng mh nh ni aw nj bi"><span id="7a94" class="mi mj it mh b gy nk nl l nm nn">[<br/>  { _id: 'HP', max_memory: '8GB' },<br/>  { _id: 'Dell', max_memory: '8GB' },<br/>  { _id: 'Asus', max_memory: '8GB' },<br/>  { _id: 'Apple', max_memory: '8GB' },<br/>  { _id: 'Lenovo', max_memory: '8GB' }<br/>]</span></pre><p id="5b8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">操作符获取一个组的最后一个成员。当与按指定字段对文档排序的<code class="fe me mf mg mh b">$sort</code>阶段一起使用时，我们可以获得按升序排序的字段的最大值。</p><p id="0924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，所有的品牌都有“8GB”作为最大值。这是因为内存值是一个字符串值，而“8GB”被视为大于“16GB”或“32GB”。我们需要把它转换成一个数值来排序，这可以用<code class="fe me mf mg mh b">$project</code>阶段来实现。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="9ba5" class="mi mj it bd mk ml mm dn mn mo mp dp mq li mr ms mt lm mu mv mw lq mx my mz na bi translated"><code class="fe me mf mg mh b"><strong class="ak">$project</strong></code> <strong class="ak">阶段</strong></h2><p id="1c63" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe me mf mg mh b">$project</code>阶段将带有请求字段的文档传递到管道中的下一个阶段。指定的字段可以是输入文档中的现有字段，也可以是新计算的字段。在本例中，我们希望按原样传递品牌，但是将内存字符串值转换为数值(在本例中为整数)。内存字符串值都包含一个“GB ”,我们需要在它被转换成整数之前移除它，这可以用<code class="fe me mf mg mh b"><a class="ae ky" href="https://docs.mongodb.com/manual/reference/operator/aggregation/trim/#mongodb-expression-exp.-trim" rel="noopener ugc nofollow" target="_blank">$trim</a></code>操作符来完成。从字符串到整数的转换可以用<code class="fe me mf mg mh b"><a class="ae ky" href="https://docs.mongodb.com/manual/reference/operator/aggregation/toInt/#mongodb-expression-exp.-toInt" rel="noopener ugc nofollow" target="_blank">$toInt</a></code>操作符来完成。</p><p id="8fc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终使用的管道如下所示。注意<code class="fe me mf mg mh b">$sort</code>载物台也用了两次，就像上面介绍的<code class="fe me mf mg mh b">$match</code>载物台一样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="3c7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，内存已正确排序:</p><pre class="kj kk kl km gt ng mh nh ni aw nj bi"><span id="f64d" class="mi mj it mh b gy nk nl l nm nn">[<br/>  { _id: 'HP', max_memory: 32 },<br/>  { _id: 'Lenovo', max_memory: 32 },<br/>  { _id: 'Dell', max_memory: 16 },<br/>  { _id: 'Asus', max_memory: 16 },<br/>  { _id: 'Apple', max_memory: 16 }<br/>]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="ff51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以继续分析不同阶段组合的数据。然而，它将类似于我们所介绍的。一旦您掌握了聚合管道的基本和常用阶段，您将能够执行您想要的各种分析。建议您手动编写一些管道，并检查每个阶段的输出，以便更好地了解不同阶段的逻辑。</p><div class="np nq gp gr nr ns"><a href="https://lynn-kwong.medium.com/all-you-need-to-know-about-using-mongodb-in-python-caa077c9a20f" rel="noopener follow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">关于在Python中使用MongoDB，您需要知道的是</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">了解Python中MongoDB的常见用例</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">lynn-kwong.medium.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og ks ns"/></div></div></a></div></div></div>    
</body>
</html>