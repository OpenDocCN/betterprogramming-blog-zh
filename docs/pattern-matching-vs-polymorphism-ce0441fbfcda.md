# 模式匹配与多态性

> 原文：<https://betterprogramming.pub/pattern-matching-vs-polymorphism-ce0441fbfcda>

## 构建可扩展的架构

![](img/503ce62163238dadd9ce53be94c6c6bf.png)

Photo by [贝莉儿 NG](https://unsplash.com/@danist07?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

# TL；速度三角形定位法(dead reckoning)

子类型多态性对于添加更多的实体类型非常有用。模式匹配是添加更多功能的更好选择。在许多用例中，请求更多的功能比请求更多的实体类型更有可能。

在本文中，我们基于一组简单的需求实现了一个程序。首先，我们使用子类型多态性实现它，然后使用模式匹配。给定这些实现，我们添加另外两个需求，并比较实现新需求所需的更改。

## 放弃

当使用术语*模式匹配*时，我指的是有限的子集。您可以在`Resources`部分找到更详细的模式匹配解释的链接。

# 初始要求

让我们考虑二维形状的例子。我们希望允许两种不同的类型:矩形和圆形。所有形状都有周长和面积。矩形是由两条长度各不相同的边定义的。它的周长是`(x + y) * 2`，面积是`x * y`。圆是由半径定义的。它的周长是`2 * PI * r`，面积是`PI * r * r`。

# 使用子类型多态性

让我们用 Java 中的子类型多态性来建模这个例子。

我们将形状建模为界面。它有一个检索周长的方法和一个检索面积的方法。

矩形是`Shape`接口的一个实现。

圆形是`Shape`接口的第二个实现。

这个类层次结构成功地实现了需求。我们的利益相关者现在可以计算矩形和圆形的周长和面积。太好了。

# 额外要求

现在，我们的涉众提出了两个额外的要求。

1.  他们也想计算平行四边形的这些性质。
2.  他们想计算一个形状的直径。这是一个形状中最长的距离。

# 向子类型架构中添加新类

有了我们给定的子类型架构，满足第一个要求是很容易的。

我们从创建一个类`Parallelogram`开始，并在类签名中添加一个`implements`子句。

此时，Java 编译器已经通知我们该类缺少方法`perimeter`和`area`的实现。IDE 为我们提供了生成方法存根的选项。

现在我们可以向类中添加属性并实现这两种方法。

子类型多态性允许我们用一个新文件来满足这个需求。我们不需要接触现有的代码库。

子类型多态性简化了新实体类型的添加。

# 向子类型架构中添加新方法

我们来看第二个要求。

*   利益相关者想要计算形状的直径。这是一个形状中最长的距离。

我们向接口`Shape`添加了一个新方法。

此时，Java 编译器在类`Rectangle`、`Shape`和`Parallelogram`中通知我们。每个类都缺少一个新方法`diameter`的实现。

我们将方法`diameter`的实现添加到类`Rectangle`中。

又到了`Circle`类。

AAA 和到类`Parallelogram`。

为了增加直径，我们需要触及层次结构中的每个类。这些更改分散在整个应用程序中。

子类型多态性使添加新方法变得复杂。

# 使用模式匹配

让我们看一种不同的方法:模式匹配。Java 目前还不支持模式匹配。(这很可能在即将到来的版本中发生变化: [JEP 305](http://openjdk.java.net/jeps/305) ， [JEP 354](https://openjdk.java.net/jeps/354) 。)目前，我们将使用 Kotlin 进行模式匹配。Kotlin 为模式匹配提供了足够的支持来展示这个例子。

形状被建模为没有任何属性的`sealed`类。关键字`sealed`强制要求`Shape`的所有子类都在同一个文件中声明。我们将`Rectangle`和`Circle`定义为`Shape`类的唯一子类。

新的层次结构看起来类似于使用子类型多态性的层次结构。关键的区别在于，我们没有在类层次结构中指定方法。相反，我们将方法定义为层次结构之外的函数。

让我们实现函数`area`。

因为函数是在层次结构之外定义的，所以我们不知道传递的形状是矩形还是圆形。我们使用模式匹配来区分这两种情况。如果形状是`Rectangle`的子类型，编译器会将参数`shape`转换为矩形并对`shape.x * shape.y`求值。如果形状是`Circle`的子类型，编译器将参数`shape`转换成一个圆，并对`PI * shape.radius * shape.radius`求值。

注意，没有必要定义默认子句，因为类`Shape`是`sealed`。如果有一个类没有被覆盖，编译器会通知我们。

我们可以类似地实现函数`perimeter`。

我们为这两个实现添加了两个子句:矩形和圆形。

# 将新方法添加到模式匹配架构中

我们成功地满足了最初的要求。现在，让我们考虑一个额外的要求。

*   利益相关者想要计算形状的直径。这是一个形状中最长的距离。

有了新的架构，满足这一要求就像添加新功能一样简单。

不需要修改任何现有文件。同样，如前所述，如果我们错过了`Shape`的一个子类，编译器会自动通知我们。

模式匹配简化了新功能的添加。

# 将新类添加到模式匹配体系结构中

让我们考虑另一个要求。

*   利益相关者也想计算平行四边形的这些属性。

使用子类型架构很容易满足这个要求。模式匹配更难。

首先，我们添加一个新的子类`Shape`。

此时，编译器通知我们函数`perimeter`、`area`和`diameter`中的`when`表达式缺少一个用于`Parallelogram`的子句。

我们将缺失的案例添加到函数`perimeter`中。

以及功能`area`。

AAA 和功能`diameter`。

为了添加新的类`Parallelogram`，我们需要触及每一个现有的函数。这些更改分散在整个应用程序中。

模式匹配使添加新的实体类型变得复杂。

# 摘要

模式匹配和子类型多态性是设计架构的两种不同工具。前者非常适合添加新功能，而后者非常适合添加新的实体类型。在决定一个架构之前，问问你自己你是否更可能需要更多的功能或者更多的实体类型。根据我的经验，随着时间的推移，大多数用例不成比例地需要更多的功能，而不是更多的实体类型。

你怎么想呢?

# 资源

*   Java 中模式匹配的例子:[https://gist . github . com/fbo eller/f 1465 df 917 BAF 854 f 7 D6 BC 07 DCE 7b 96d](https://gist.github.com/fboeller/f1465df917baf854f7d6bc07dce7b96d)
*   Kotlin 中具有子类型多态性的示例:[https://gist . github . com/fbo eller/57295 C2 BD 2089 c 229 cf 09 f 9297 b5 E8 a 1](https://gist.github.com/fboeller/57295c2bd2089c229cf09f9297b5e8a1)
*   模式匹配说明:【http://learnyouahaskell.com/syntax-in-functions 
*   http://openjdk.java.net/jeps/305 JEP 305:
*   http://openjdk.java.net/jeps/325 JEP 325: