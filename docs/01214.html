<html>
<head>
<title>Understanding the Kubernetes YAML Syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解库伯内特YAML语法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-kubernetes-yaml-syntax-83359d33f9c2?source=collection_archive---------4-----------------------#2019-08-23">https://betterprogramming.pub/understanding-kubernetes-yaml-syntax-83359d33f9c2?source=collection_archive---------4-----------------------#2019-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b432" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JSON能做的一切，还有更多</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bba719dfcb1a97e0629ea22327a1e1fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e_Xmd8wJ-wua1Z9beb8uCQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@brandomakesbranding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">白兰度在<a class="ae kv" href="https://unsplash.com/search/photos/kubernetes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上制作品牌</a></p></figure><p id="4485" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如JSON 的<a class="ae kv" href="https://en.wikipedia.org/wiki/JSON#YAML" rel="noopener ugc nofollow" target="_blank">维基百科页面上所说，YAML(另一种标记语言)是JSON的超集，这意味着它拥有JSON的所有功能，但它也在某种程度上扩展了这种功能。</a></p><p id="565d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">YAML基本上是JSON的一个包装器，做JSON能做的一切，甚至更多。</p><p id="eeeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了说明这一点，让我们从Kubernetes文档页面获取一个名为<a class="ae kv" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/" rel="noopener ugc nofollow" target="_blank"> <em class="ls">理解Kubernetes对象</em> </a>的YAML文件，并使用<a class="ae kv" href="http://convertjson.com/" rel="noopener ugc nofollow" target="_blank">http://convertjson.com</a>将其转换为JSON，这是一个可以将YAML转换为JSON的在线实用程序。</p><p id="2194" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是原始的<code class="fe lt lu lv lw b">deployment.yaml</code>文件:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="465f" class="mb mc iq lw b gy md me l mf mg">apiVersion: apps/v1 # for versions before 1.9.0 use apps/v1beta2<br/>kind: Deployment<br/>metadata:<br/>  name: nginx-deployment<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: nginx<br/>  replicas: 2 # tells deployment to run 2 pods matching the template<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nginx<br/>    spec:<br/>      containers:<br/>      - name: nginx<br/>        image: nginx:1.7.9<br/>        ports:<br/>        - containerPort: 80</span></pre><p id="b681" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是转换成JSON的文件:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="2a24" class="mb mc iq lw b gy md me l mf mg">{<br/>   "apiVersion": "apps/v1",<br/>   "kind": "Deployment",<br/>   "metadata": {<br/>      "name": "nginx-deployment"<br/>   },<br/>   "spec": {<br/>      "selector": {<br/>         "matchLabels": {<br/>            "app": "nginx"<br/>         }<br/>      },<br/>      "replicas": 2,<br/>      "template": {<br/>         "metadata": {<br/>            "labels": {<br/>               "app": "nginx"<br/>            }<br/>         },<br/>         "spec": {<br/>            "containers": [<br/>               {<br/>                  "name": "nginx",<br/>                  "image": "nginx:1.7.9",<br/>                  "ports": [<br/>                     {<br/>                        "containerPort": 80<br/>                     }<br/>                  ]<br/>               }<br/>            ]<br/>         }<br/>      }<br/>   }<br/>}</span></pre><p id="69bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有几件明显的事情需要注意。</p><p id="fe89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">1.YAML副本比JSON副本占用更少的空间。</p><p id="aec2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.YAML比JSON需要更少的字符。</p><p id="50e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.YAML允许评论，而JSON不允许。</p><p id="236f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显而易见，YAML比JSON占用更少的空间，使用更少的字符。即使考虑到YAML例子中的注释，YAML代码也使用了414个字符，而JSON代码使用了697个字符。</p><p id="ff09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在YAML使用评论的能力也很不错。注释由<code class="fe lt lu lv lw b">#</code>字符表示，在这一行中:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="e48f" class="mb mc iq lw b gy md me l mf mg">apiVersion: apps/v1 # for versions before 1.9.0 use apps/v1beta2</span></pre><p id="711b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b">#</code>之后的一切都是注释。</p><p id="36b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管您可能想知道为什么有人会使用JSON而不是YAML，但是JSON确实有一些优势。JavaScript提供了内置的工具来解析和处理JSON(毕竟JSON代表JavaScript对象符号)。</p><p id="8b61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不仅仅是JavaScript，很多其他语言都内置了JSON助手，包括很多C族语言。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="60d9" class="mo mc iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">YAML语法基础</h1><p id="ce0c" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">让我们深入了解一些YAML语法的基础知识。</p><p id="d8a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">YAML文件由键值对的映射(或字典)组成。YAML地图只是一个包含键和值的对象。</p><p id="9330" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是五个键值对的映射:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="9d73" class="mb mc iq lw b gy md me l mf mg">key1: value1<br/>key2: value2<br/>key3: value3<br/>key4: value4<br/>key5: value5</span></pre><p id="0f85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JSON中的对应内容是:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="7c57" class="mb mc iq lw b gy md me l mf mg">{<br/>   "key1": "value1",<br/>   "key2": "value2",<br/>   "key3": "value3",<br/>   "key4": "value4",<br/>   "key5": "value5"<br/>}</span></pre><p id="643b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个键本身可以包含一个映射:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="c46b" class="mb mc iq lw b gy md me l mf mg">key1:<br/>  subkey1: subvalue1<br/>  subkey2: subvalue2<br/>  subkey3: subvalue3</span></pre><p id="86cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嵌套地图只是一个嵌套对象。JSON中的对应内容是:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="4ebf" class="mb mc iq lw b gy md me l mf mg">{<br/>   "key1": {<br/>      "subkey1": "subvalue1",<br/>      "subkey2": "subvalue2",<br/>      "subkey3": "subvalue3"<br/>   }<br/>}</span></pre><p id="5723" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">YAML也有列表:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="faad" class="mb mc iq lw b gy md me l mf mg">list:<br/>  - item1<br/>  - item2<br/>  - item3<br/>  - item4<br/>  - item5</span></pre><p id="6a2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">YAML列表只是一个特定键的值数组。JSON中的对应内容是:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="927b" class="mb mc iq lw b gy md me l mf mg">{<br/>   "list": [<br/>      "item1",<br/>      "item2",<br/>      "item3",<br/>      "item4",<br/>      "item5"<br/>   ]<br/>}</span></pre><p id="1a08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">列表也可以包含地图:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="3115" class="mb mc iq lw b gy md me l mf mg">list:<br/>  - item1<br/>  - <br/>    mapItem1: value<br/>    mapItem2: value<br/>  - item3<br/>  - item4<br/>  - item5</span></pre><p id="c837" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">包含地图的列表项只是数组中的一个对象。JSON中的对应内容是:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="239f" class="mb mc iq lw b gy md me l mf mg">[<br/>   "item1",<br/>   {<br/>      "mapItem1": "value",<br/>      "mapItem2": "value"<br/>   },<br/>   "item3",<br/>   "item4",<br/>   "item5"<br/>]</span></pre></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="baf5" class="mo mc iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">再看看我们的YAML档案</h1><p id="2275" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">给定上面的例子，让我们再看一下我们的<code class="fe lt lu lv lw b">deployment.yaml</code>文件，看看我们是否能读得更好一点。</p><p id="9cdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">拿这部分来说:</p><p id="53bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">YAML:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="f3f9" class="mb mc iq lw b gy md me l mf mg">spec:<br/>  selector:<br/>    matchLabels:<br/>      app: nginx</span></pre><p id="558e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JSON:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="ca72" class="mb mc iq lw b gy md me l mf mg">"spec": {<br/>      "selector": {<br/>         "matchLabels": {<br/>            "app": "nginx"<br/>         }<br/>      }</span></pre><p id="f9f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">缩进仍然存在，但是引号和花括号被抽象掉了。</p><p id="c3ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们进一步看看YAML文件中使用列表的地方:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="8e35" class="mb mc iq lw b gy md me l mf mg">spec:<br/>      containers:<br/>      - name: nginx<br/>        image: nginx:1.7.9<br/>        ports:<br/>        - containerPort: 80</span></pre><p id="b3de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和JSON等价物:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="cb31" class="mb mc iq lw b gy md me l mf mg">"spec": {<br/>            "containers": [<br/>               {<br/>                  "name": "nginx",<br/>                  "image": "nginx:1.7.9",<br/>                  "ports": [<br/>                     {<br/>                        "containerPort": 80<br/>                     }<br/>                  ]<br/>               }<br/>            ]<br/>         }</span></pre><p id="4e24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在JSON等价物中看到的那样，<code class="fe lt lu lv lw b">"containers"</code>处的值是一个数组，数组中的第一个(也是唯一一个)项是一个对象。</p><p id="c01a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那个对象有三个键:<code class="fe lt lu lv lw b">name</code>、<code class="fe lt lu lv lw b">image</code>和<code class="fe lt lu lv lw b">ports</code>。<code class="fe lt lu lv lw b">ports</code>的值是一个包含一个项目的数组，该项目是一个对象。</p><p id="ccf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在越来越擅长阅读YAML了！</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="88d4" class="mo mc iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">Kubernetes YAML文件中的必填字段</h1><p id="b251" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">每个Kubernetes YAML文件中都有几个必填字段:</p><ul class=""><li id="a4d6" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated"><code class="fe lt lu lv lw b">apiVersion</code></li><li id="1b6e" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated"><code class="fe lt lu lv lw b">kind</code></li><li id="8758" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated"><code class="fe lt lu lv lw b">metadata</code></li><li id="663c" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated"><code class="fe lt lu lv lw b">spec</code></li></ul><p id="553a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将看到我们提供的YAML文件包含所有这四个顶级密钥。</p><p id="0ec3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kubernetes文档将<code class="fe lt lu lv lw b">apiVersion</code>描述为:</p><blockquote class="ny"><p id="935d" class="nz oa iq bd ob oc od oe of og oh lr dk translated"><em class="oi">“您正在使用哪个版本的Kubernetes API来创建此对象。”</em></p></blockquote><p id="51b1" class="pw-post-body-paragraph kw kx iq ky b kz oj jr lb lc ok ju le lf ol lh li lj om ll lm ln on lp lq lr ij bi translated">有不同的Kubernetes API版本。我们使用的是<code class="fe lt lu lv lw b">apps/v1</code>，这个API可以在<a class="ae kv" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/#deployment-v1-apps" rel="noopener ugc nofollow" target="_blank"> Kubernetes文档</a>中找到。</p><p id="0a12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将会看到Kubernetes API非常庞大，详细介绍它的各个方面，甚至关注<code class="fe lt lu lv lw b">apps/v1</code>，都超出了本文的范围。</p><p id="80e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管如此，API有不同的种类和版本，您必须熟悉哪个API适合您正在创建的Kubernetes对象。</p><p id="d925" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一个必填字段是<code class="fe lt lu lv lw b">kind</code>。文件对此的定义是:</p><blockquote class="ny"><p id="ce53" class="nz oa iq bd ob oc od oe of og oh lr dk translated"><em class="oi">“你想创建什么样的对象。”</em></p></blockquote><p id="a6c9" class="pw-post-body-paragraph kw kx iq ky b kz oj jr lb lc ok ju le lf ol lh li lj om ll lm ln on lp lq lr ij bi translated">您可以创建大量不同的Kubernetes对象。它们列在<a class="ae kv" href="https://stackoverflow.com/a/55161551/7386637" rel="noopener ugc nofollow" target="_blank">这个栈溢出答案</a>里。</p><p id="6082" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">必填字段列表中的下一项是<code class="fe lt lu lv lw b">metadata</code>。这些文档将元数据定义为:</p><blockquote class="ny"><p id="bb47" class="nz oa iq bd ob oc od oe of og oh lr dk translated"><em class="oi">“帮助唯一标识对象的数据，包括一个</em> <code class="fe lt lu lv lw b"><em class="oi">name</em></code> <em class="oi">字符串、</em> <code class="fe lt lu lv lw b"><em class="oi">UID</em></code> <em class="oi">、可选的</em> <code class="fe lt lu lv lw b"><em class="oi">namespace</em></code> <em class="oi">”</em></p></blockquote><p id="936b" class="pw-post-body-paragraph kw kx iq ky b kz oj jr lb lc ok ju le lf ol lh li lj om ll lm ln on lp lq lr ij bi translated">这相当容易理解。在我们的<code class="fe lt lu lv lw b">deployment.yaml</code>文件中，我们给对象一个<code class="fe lt lu lv lw b">nginx-deployment</code>的<code class="fe lt lu lv lw b">name</code>元数据值。</p><p id="53c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，其他对象可以使用该值来引用该对象，并且它还为我们提供了关于该Kubernetes对象用途的更多上下文。</p><p id="0d50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一个必填字段是<code class="fe lt lu lv lw b">spec</code>，但肯定不是最不重要的。医生检查了这个:</p><blockquote class="oo op oq"><p id="15ca" class="kw kx ls ky b kz la jr lb lc ld ju le or lg lh li os lk ll lm ot lo lp lq lr ij bi translated"><em class="iq">"你还需要提供对象</em> <code class="fe lt lu lv lw b"><em class="iq">spec</em></code> <em class="iq">字段。对象</em> <code class="fe lt lu lv lw b"><em class="iq">spec</em></code> <em class="iq">的精确格式对于每个Kubernetes对象都是不同的，并且包含特定于该对象的嵌套字段。</em><a class="ae kv" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/" rel="noopener ugc nofollow" target="_blank"><em class="iq">Kubernetes API reference</em></a><em class="iq">可以帮助您找到使用Kubernetes创建的所有对象的规范格式。”</em></p></blockquote><p id="0aab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b">spec</code>字段是您更详细地描述对象的地方，您需要使用Kubernetes API来完成。</p><p id="4e01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们特定的YAML文件，我们将引用<a class="ae kv" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/#deployment-v1-apps" rel="noopener ugc nofollow" target="_blank">用于部署v1应用的API</a>，因为这是我们在<code class="fe lt lu lv lw b">apiVersion</code>字段中指定的API版本。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="f66f" class="mo mc iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">结论</h1><p id="9c11" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">希望这能让你更好地理解Kubernetes YAML文件是如何工作的。</p><p id="ef43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与JSON相比，YAML看起来非常好，但是它如何抽象掉JSON的一些特征可能很难理解。YAML也不像JSON那样常用。</p><p id="a3aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我计划更深入地研究Kubernetes API，以及如何为这些对象正确配置<code class="fe lt lu lv lw b">spec</code>字段。敬请期待！</p></div></div>    
</body>
</html>