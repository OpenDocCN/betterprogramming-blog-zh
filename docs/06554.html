<html>
<head>
<title>Getting Started With Kubernetes for Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Kubernetes入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-kubernetes-for-python-254d4c1d2041?source=collection_archive---------0-----------------------#2020-10-13">https://betterprogramming.pub/getting-started-with-kubernetes-for-python-254d4c1d2041?source=collection_archive---------0-----------------------#2020-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1177" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解基础知识并部署您的第一个集群</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a137a0b9d0c60445ea7163343e03d40e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oG-ipjxqpIyWpxf2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马克西米利安·魏斯贝克尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="7fff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下，你有一个尖端的机器学习过程，在你出色的、震惊世界的web应用程序的背景下突突前进。</p><p id="09b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是有一个问题。</p><p id="e02c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦web应用程序收到的流量超过预期，每个人都会认为你的服务是垃圾，因为后端magic ML解决方案现在超级慢——它只能处理预先规定的流量…</p><p id="8b85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸好我们有<a class="ae ky" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>！现在，我们可以<em class="lv">在我们的ML魔法容器大军之间协调</em>工作负载。我们甚至可以按需扩充我们的军队。一旦后端达到高容量，就制造更多的容器！</p><p id="50ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes是一个Docker容器编排器。这意味着我们可以自动平衡工作负载，保持部署的高可用性、高响应性和高效率。</p><p id="3231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes是一项改变游戏规则的技术。</p><p id="c62a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始部署我们的第一个Kubernetes Python API集群之前，我们将快速介绍Kubernetes的设置！其实也没那么难。从开始到结束，我们将涵盖:</p><ul class=""><li id="940a" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">创建Docker图像。</li><li id="fc06" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">上传图像到Docker Hub。</li><li id="4224" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">配置我们的pod <strong class="lb iu"> <em class="lv"> </em> </strong>(我们把容器放在这个里面)。</li><li id="73c6" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">使用服务配置群集网络。</li><li id="289f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">将我们的pod和服务部署到集群。</li></ul><p id="a707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每一步都将包含易于遵循的分步说明。尽情享受吧！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="156b" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">Kubernetes设置</h1><p id="3069" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们将使用Docker部署我们的Kubernetes集群。为此我们确实需要Windows 10 Pro/Enterprise。或者，也可以使用<a class="ae ky" href="https://kubernetes.io/docs/tasks/tools/install-minikube/" rel="noopener ugc nofollow" target="_blank"> Minikube </a>，但我们不会在这里讨论它。</p><p id="9206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为<a class="ae ky" href="https://docs.docker.com/docker-for-windows/install/" rel="noopener ugc nofollow" target="_blank"> Windows </a>或<a class="ae ky" href="https://docs.docker.com/docker-for-mac/install/" rel="noopener ugc nofollow" target="_blank"> Mac </a>下载Docker。</p><p id="0329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装完成后，我们右键单击任务栏中的Docker桌面图标(它是一个小鲸鱼),然后单击设置:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/29593698b7c89249f24e9a965154cba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wa_fGjKsrQHBt1eKJqNDGg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kubernetes &gt;启用Kubernetes &gt;应用并重启。</p></figure><p id="962d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们点击Kubernetes &gt;检查启用Kubernetes &gt;点击应用和重启！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/40c6d637051c0051291354ce6569a993.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*B74U_dAldH48IpzM5gUM3w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kubernetes运行成功！</p></figure><p id="2c9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置好Kubernetes后，我们应该会在Docker设置窗口的左下角看到它与Docker一起运行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/f098c908a421b3241fda58048f6180eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ZfIi9lkl3ZhojBKaEyMlQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">检查Kubernetes是否正在使用kubectl cluster-info。</p></figure><p id="9ed4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了再次检查所有设置是否正确，我们打开首选的CLI并键入<code class="fe nr ns nt nu b">kubectl cluster-info</code>。我们应该会看到我们的集群信息，如上所示。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="0343" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">该过程</h1><ol class=""><li id="0115" class="lw lx it lb b lc nj lf nk li nv lm nw lq nx lu ny mc md me bi translated">我们创造我们的码头工人形象。</li><li id="963a" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu ny mc md me bi translated">将图像上传到Docker Hub。</li><li id="1239" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu ny mc md me bi translated">配置容纳容器的pod</li><li id="5b25" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu ny mc md me bi translated">使用服务配置我们的集群网络。</li><li id="5dc6" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu ny mc md me bi translated">将我们的pod和服务部署到集群。</li></ol></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="2de6" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">形象</h1><p id="f468" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">首先，我们需要一个Docker映像，它将被用作Kubernetes集群中的核心流程。</p><p id="70f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用一个用Python构建的简单API，它简单地向收到的每个请求返回<code class="fe nr ns nt nu b">{"hello": "world"}</code>。我们将使用的代码是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="c6c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的Python文件叫做<code class="fe nr ns nt nu b">app.py</code>。在同一个目录中，我们还添加了<code class="fe nr ns nt nu b">requirements.txt</code>，它包含我们的Python包导入:</p><pre class="kj kk kl km gt ob nu oc od aw oe bi"><span id="d6e1" class="of ms it nu b gy og oh l oi oj">flask<br/>flask-restful</span></pre><p id="75cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及一个我们用来创建容器的docker文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="f35d" class="of ms it bd mt ok ol dn mx om on dp nb li oo op nd lm oq or nf lq os ot nh ou bi translated">建立码头工人形象</h2><p id="444b" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">然后，我们打开一个CLI，导航到包含我们的API文件的目录，并使用<code class="fe nr ns nt nu b">docker build -t &lt;image name&gt;</code>构建我们的映像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/cc6394002f11ce450c23165ead93bb85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BD7Fghvg1d-YxMV8Tpr3VQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">构建一个映像就像docker build -t <name> <path>一样简单。记住结尾的点——我每次都忘记。</path></name></p></figure><p id="66ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了检查我们的容器是否正常工作，我们键入<code class="fe nr ns nt nu b">docker run -p 3050:3000 hello-api</code>。这将告诉Docker在<code class="fe nr ns nt nu b">localhost:3050</code>运行我们的容器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/28522225c080fbaedfe00a9c8fcc5e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*z0TKEr-xxw0lIpycXUO7Dw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">当我们导航到localhost:3050时，应该会看到{"hello": "world"}。</p></figure><p id="8abf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在浏览器中输入这些内容后，应该会看到我们的API！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="aa08" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">码头枢纽</h1><p id="407a" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">接下来，我们将图像上传到<a class="ae ky" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>。</p><p id="6cc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.创建一个帐户或登录。</p><p id="9029" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.单击创建存储库。</p><p id="b1f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.选择一个名字。在本文中，我使用的是<code class="fe nr ns nt nu b">hello-api</code>。现在我们回到我们的CLI。</p><p id="3a77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.出现提示时，键入<code class="fe nr ns nt nu b">docker login --username=&lt;username&gt; --email=&lt;email&gt;</code>并输入您的密码。</p><p id="2047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.通过键入<code class="fe nr ns nt nu b">docker images</code>获得图像ID。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/34a0f139aee84e3f5858155f9620fa9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yqYNRQgNADpmjZl2EBjVxQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们可以通过键入Docker images来查看所有Docker图像的列表。</p></figure><p id="418e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">6.使用<code class="fe nr ns nt nu b">docker tag &lt;image ID&gt; &lt;hub repo&gt;</code>标记图像。对我来说，这就是<code class="fe nr ns nt nu b">docker tag 3aeaa19c2897 jamescalam/hello-api</code>。</p><p id="6c46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">7.使用<code class="fe nr ns nt nu b">docker push &lt;hub repo&gt;</code>将我们的图像推送到我们的repo。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/8cc753afa6bb7aa26e2f4f5e92abfc72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JMUPIoxU9TAWuJGatDgOxg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们通过docker push将我们的容器映像推送到Docker Hub。</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="3b09" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">分离舱</h1><p id="8d35" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">pod是可以在我们的Kubernetes集群中部署的最小计算单元。pod内部运行一个或多个容器。</p><h2 id="324d" class="of ms it bd mt ok ol dn mx om on dp nb li oo op nd lm oq or nf lq os ot nh ou bi translated">配置文件</h2><p id="ad18" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">要创建一个pod，我们只需要一个YAML文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="f65b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的配置文件的第一行是<code class="fe nr ns nt nu b">apiVersion: v1</code>。每个<code class="fe nr ns nt nu b">apiVersion</code>启用一组不同的对象。在这种情况下，要创建一个pod，我们必须使用<code class="fe nr ns nt nu b">v1</code>。</p><p id="67f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的下一个系列与此相关。我们现在从<code class="fe nr ns nt nu b">apiVersion</code>提供的集合中指定我们想要使用的对象。在这种情况下，它就是<code class="fe nr ns nt nu b">kind: Pod</code>。</p><p id="de55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nr ns nt nu b">metadata</code>中，我们存储了关于我们的pod的信息。首先是pod <code class="fe nr ns nt nu b">name</code>，接下来是pod <code class="fe nr ns nt nu b">labels</code>，我们在其中使用了<code class="fe nr ns nt nu b">run: connectApi</code>，这允许我们在服务配置中识别这个pod。</p><p id="28fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nr ns nt nu b">spec</code>中，我们使用<code class="fe nr ns nt nu b">containers</code>关键字来列出包含在pod中的容器。在我们的例子中，这只是一个容器:<code class="fe nr ns nt nu b">client</code>。</p><p id="2a41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的容器<code class="fe nr ns nt nu b">image</code>是存储在Docker Hub上的容器映像的名称。</p><p id="4c2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们定义暴露哪些<code class="fe nr ns nt nu b">ports</code>用于与外界通信。这与<code class="fe nr ns nt nu b">app.py</code>和我们的服务配置文件中使用的端口一致。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="abd8" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">服务</h1><p id="b88e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们使用服务在集群中建立网络。有几种以不同方式控制网络的服务。我们将使用的是一个节点端口。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/ed4c1b628a958047909dcdc51c57725d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wnBqxB6_CA8KoYB77WA3BQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加节点端口服务对象在我们的pod和外部世界之间创建了一个通信通道。</p></figure><p id="6d41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过添加我们的服务，我们创建了一个类似上面的网络。在我们的集群内部，我们的节点端口将充当我们的pod和集群端口(通往外部世界的网关)之间的流量定向器。</p><h2 id="c14d" class="of ms it bd mt ok ol dn mx om on dp nb li oo op nd lm oq or nf lq os ot nh ou bi translated">配置文件</h2><p id="122f" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">与我们的pod一样，我们只需要一个YAML文件来创建我们的服务。</p><p id="b76a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的服务配置文件的前三部分几乎反映了我们的pod配置，并且具有完全相同的目的，因此我们不再重复:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="bf73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在<code class="fe nr ns nt nu b">spec</code>中事情有些不同。首先，我们将服务类型设置为<code class="fe nr ns nt nu b">NodePort</code>。我们之前解释过了。</p><p id="ce80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们建立我们的网络<code class="fe nr ns nt nu b">ports</code>。这里，我们有三个端口:</p><ul class=""><li id="2137" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><code class="fe nr ns nt nu b">port: 3050</code>告知该服务通过其自己的<code class="fe nr ns nt nu b">3050</code>端口进行通信。</li><li id="c464" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe nr ns nt nu b">targetPort: 3000</code>告诉我们使用端口<code class="fe nr ns nt nu b">3000</code>与我们的目标对象(我们的吊舱)通信。</li><li id="ec07" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe nr ns nt nu b">nodePort: 32020</code>是我们使用的外部端口。任何想要从集群外部与我们的服务通信的人都必须使用端口<code class="fe nr ns nt nu b">32020</code> ( <a class="ae ky" href="https://v1-15.docs.kubernetes.io/docs/concepts/services-networking/service/#nodeport" rel="noopener ugc nofollow" target="_blank">这可以是30，000–32，767 </a>之间的任何数字)。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/c0a0f798b557ab01eae57faa55e37238.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O_C6h6h9cKpqC2sR_51mpA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的集群网络。NodePort通过nodeport.yaml中定义的端口控制通信。</p></figure><p id="3553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在这里少了一个细节。我们的服务如何知道我们的<code class="fe nr ns nt nu b">targetPort</code>是针对哪个对象的？当然，我们知道这是我们设置的pod，但是Kubernetes是怎么知道的呢？</p><p id="945a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在配置文件的最后两行定义了目标对象。我们写<code class="fe nr ns nt nu b">run: connectApi</code>，如果我们记得的话，它与pod配置中的<code class="fe nr ns nt nu b">run: connectApi</code>的<code class="fe nr ns nt nu b">labels</code>键值对相匹配！</p><p id="d473" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们的服务将找到所有其他带有键值标签<code class="fe nr ns nt nu b">run: connectApi</code>的对象，并通过它们的端口<code class="fe nr ns nt nu b">3000</code>进行连接。回到我们的pod配置，这就是我们设置<code class="fe nr ns nt nu b">containerPort: 3000</code>的原因。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="04d7" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">部署集群</h1><p id="8890" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">为了初始化Kubernetes部署中的pod和服务，我们使用了两个配置文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/84af792dd855693146024d47a08e4d37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fQHZBSxZx_6vBuexIf5TaQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们使用kubectl apply -f <yaml file="">来组装我们的集群对象。</yaml></p></figure><p id="357e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们执行了我们的YAML脚本，我们可以使用<code class="fe nr ns nt nu b">kubectl get pods</code>和<code class="fe nr ns nt nu b">kubectl get services</code>来检查我们的pod和服务是否已经成功部署。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/12894600a12f09cb87506e401e36ef38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ulIcaccQ3xcmg4WbN--Sg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们可以使用kubectl get <objects>检查集群中某个对象的状态。</objects></p></figure><ul class=""><li id="7806" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">我们的pod的状态应该是<code class="fe nr ns nt nu b">Running</code>。</li><li id="bd36" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">我们应该能够在模式<code class="fe nr ns nt nu b">port:nodePort</code>中看到我们在服务YAML中设置的端口。</li></ul><p id="7e9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，为了确认我们的本地集群已经启动并正在运行，我们打开浏览器并打开<code class="fe nr ns nt nu b">localhost:32020</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/b7a59b9bd007645c960ae7e7f4bc4ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*MpS8wAfh-dhf2OcuZHziqA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">成功，我们集群返回{"hello": "world"}。</p></figure><p id="d28c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该再次受到我们的Flask API的欢迎！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="dcb0" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结束了</h1><p id="7ba7" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们完了。你正式成为Kubernetes职业选手了！你可以在简历的技术技能部分写上“Kubernetes大师”。</p><p id="cfbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，也许不是“大师”，但我们已经迈出了熟悉Kubernetes基础的第一步。这是一项非常酷的技术，值得花点心思去掌握。</p><p id="3e9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章！如果你有任何想法或问题，请在下面的评论中联系我们。</p><p id="e769" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p><p id="46a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">*除非另有说明，所有图片均为作者。</em></p></div></div>    
</body>
</html>