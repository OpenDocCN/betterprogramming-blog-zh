<html>
<head>
<title>The Ultimate Domain Language: Declarative Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">终极领域语言:声明式Swift</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-ultimate-domain-language-declarative-swift-37b0a04e4e32?source=collection_archive---------3-----------------------#2022-11-17">https://betterprogramming.pub/the-ultimate-domain-language-declarative-swift-37b0a04e4e32?source=collection_archive---------3-----------------------#2022-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="745c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索声明性领域范例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/15644f3a4e665e6217c6436af467972f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5sTanfMd67CfTkh3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sh_sumon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Solaiman Hossen </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="df1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想向您介绍一下声明式Swift——一种允许我们高效且有效地创建易于验证的领域驱动代码的编码风格。事实证明，像这样编写代码比传统的编码更快，同时也给bug提供了更少的藏身空间。</p><h1 id="a5cf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">领域示例</h1><p id="50dc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们从一个简单的例子开始:待办事项列表。</p><p id="9e43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码块包含待办事项项和待办事项列表的数据类型:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="8beb" class="mx lw it mt b be my mz l na nb">struct TodoItem:Identifiable {<br/>    enum Change {<br/>        case title   (to:String)<br/>        case due     (to:TodoDate)<br/>        case location(to:Location)<br/>        case   finish<br/>        case unfinish<br/>    }<br/>    // members<br/>    let id       : UUID<br/>    let title    : String<br/>    let completed: Bool<br/>    let created  : Date<br/>    let due      : TodoDate<br/>    let location : Location<br/><br/>    // initialisers<br/>    init(title:String) { self.init(UUID(),title,false,.unknown, Date(),.unknown) }<br/>    private <br/>    init(_ i:UUID,_ t:String,_ c:Bool,_ d:TodoDate,_ cd:Date,_ l:Location) { id=i; title=t; completed=c; due=d; created=cd; location=l }<br/>    <br/>    func alter(_ c:Change...) -&gt; Self { c.reduce(self) { $0.alter($1) } }<br/>    private <br/>    func alter(_ c:Change   ) -&gt; Self {<br/>        switch c {<br/>        case let    .title(to:t): return Self(id,t    ,completed,due,created,location)<br/>        case       .finish      : return Self(id,title,true     ,due,created,location)<br/>        case     .unfinish      : return Self(id,title,false    ,due,created,location)<br/>        case let .location(to:l): return Self(id,title,false    ,due,created,l       )<br/>        case let      .due(to:.timeSpan(.start(.from(b),.to(e)))):<br/>            return e &gt; b  //check for timespans if dates are in correct order<br/>                ? Self(id,title,completed,.timeSpan(.start(.from(b),.to(e))),created,location)<br/>                : self<br/>        case let      .due(to:d): return Self(id,title,completed,d  ,created,location)<br/>        }<br/>    }<br/>}<br/>struct TodoList: Identifiable {<br/>    enum Change {<br/>        case add   (Add   ); enum Add    { case item(TodoItem) }<br/>        case remove(Remove); enum Remove { case item(TodoItem) }<br/>        case update(Update); enum Update { case item(TodoItem) }<br/>    }<br/>    // members<br/>    let id   : UUID<br/>    let items: [TodoItem]<br/>    <br/>    // initializers<br/>    init() { self.init(UUID(),[]) }<br/>    private <br/>    init(_ i:UUID,_ its:[TodoItem]) { id = i; items = its }<br/>    <br/>    func alter(_ c:Change...) -&gt; Self { c.reduce(self) { $0.alter($1) } }<br/>    private <br/>    func alter(_ c:Change   ) -&gt; Self {<br/>        switch c {<br/>        case let .add   (.item(i)): return Self(id,items + [i])<br/>        case let .remove(.item(i)): return Self(id,items - [i])<br/>        case let .update(.item(i)): return<br/>            items.contains(where:{ $0.id == i.id })<br/>                ? self<br/>                    .alter(<br/>                        .remove(.item(i)),<br/>                        .add   (.item(i)))<br/>                : self<br/>        }<br/>    }<br/>}</span></pre><p id="a913" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义所有成员属性<code class="fe nc nd ne mt b">let</code>。因此，这些数据类型实际上是不可变的。为了反映变化，我们需要从以前的状态重新生成一个新的对象，并引入变化。这里是通过用一个或多个更改值调用<code class="fe nc nd ne mt b">alter</code>方法来完成的——每次调用alter都会产生一个新的对象。</p><p id="cfe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，我们创建了一个<code class="fe nc nd ne mt b">TodoItem</code>,然后将标题改为更紧迫的内容:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="9720" class="mx lw it mt b be my mz l na nb">let t0 = TodoItem(title:"Get Coffee")<br/>let t1 = t0.alter(.title("Get Coffee — ASAP"))</span></pre><p id="3ca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个调用将完成一个项目:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="ee2a" class="mx lw it mt b be my mz l na nb">let t1 = t0.alter(.finish)</span></pre><p id="c079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这一个将完成它:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="5b2b" class="mx lw it mt b be my mz l na nb">let t1 = t0.alter(.unfinish)</span></pre><p id="a1ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">改变标题和完成/不完成一个项目是微不足道的。让我们看一些更有趣的例子。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="b375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的示例代码包含了对<code class="fe nc nd ne mt b">TodoDate</code>的声明。<br/>可能是<code class="fe nc nd ne mt b">unknown</code>，可能是<code class="fe nc nd ne mt b">Date</code>，也可能是<code class="fe nc nd ne mt b">TimeSpan</code>。</p><p id="c9ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe nc nd ne mt b">TimeSpan</code>可以被定义为开始和结束或者持续时间。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="80cc" class="mx lw it mt b be my mz l na nb">enum TodoDate {<br/>    case unknown<br/>    case date(Date)<br/>    case timeSpan(TimeSpan)<br/>    var timeSpan:TimeSpan? { switch self { case let .timeSpan(t): return t default: return nil } }<br/>    var date:Date?         { switch self { case let .date    (d): return d default: return nil } }<br/>}<br/>enum TimeSpan {<br/>    enum TimeComponent {<br/>        var id: Int { hashValue }<br/>        case seconds<br/>        case minutes<br/>        case hours<br/>        case days<br/>    }<br/>    enum Start {<br/>        var id:Int { hashValue }<br/>        case from(Date)<br/>        var date:Date { switch self { case .from(let d): return d } }<br/>    }<br/>    enum End {<br/>        var id: Int { hashValue }<br/>        case unknown<br/>        case to(Date)<br/>    }<br/>    var id:Int { hashValue }<br/>    case start   (Start,End)<br/>    case duration(Start,for:Int,TimeComponent)<br/>    var begin:Date {<br/>        switch self{<br/>        case let .start   (s,_  ): return s.date<br/>        case let .duration(s,_,_): return s.date<br/>        }<br/>    }<br/>}</span></pre><p id="c702" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这些代码是可能的:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="d233" class="mx lw it mt b be my mz l na nb">let t1 = t0.alter(.due(to:.date(.tomorrow.noon)))<br/>let t1 = t0.alter(.due(to:.unknown))<br/>let t1 = t0.alter(.due(to:.timeSpan(.duration(.from(.tomorrow.noon),for:3,.days))))<br/>let t1 = t0.alter(.due(to:.timeSpan(.start(.from(.tomorrow.noon),.to(.tomorrow.noon.dayAfter)))))<br/>let t1 = t0.alter(.due(to:.timeSpan(.start(.from(.tomorrow.noon),.unknown))))</span></pre><p id="de02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不言自明，对吧？</p><p id="c996" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码会无声地失败(也就是不要改变)，因为时间跨度是不可能的。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="9fcc" class="mx lw it mt b be my mz l na nb">let t1 = t0.alter(.due(to:.timeSpan(.start(.from(.tomorrow.noon.dayAfter),.to(.tomorrow.noon)))))</span></pre><p id="5e9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是通过<code class="fe nc nd ne mt b">TodoItem</code>的<code class="fe nc nd ne mt b">alter</code>方法检查有效性实现的:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="cb60" class="mx lw it mt b be my mz l na nb">func alter(_ c:Change) -&gt; Self {<br/>    switch c {<br/>    // ...<br/>    case let .due(to:.timeSpan(.start(.from(b),.to(e)))):<br/>         return e &gt; b  //check for timespans if dates are in correct order<br/>            ? Self(id,title,completed,.timeSpan(.start(.from(b),.to(e))),created,location)<br/>            : self // return unchanged<br/>    case let .due(to:d): return Self(id,title,completed,d  ,created,location)<br/>    }<br/>}</span></pre></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="157c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们只产生了少数几行代码，但我们已经获得了令人难以置信的高度可编码的信息——这些代码非常可读。</p><p id="eee4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们要表达一个项目的位置，位置可以是<code class="fe nc nd ne mt b">unknown</code>、<code class="fe nc nd ne mt b">address</code>、<code class="fe nc nd ne mt b">coordinate</code>或<code class="fe nc nd ne mt b">directions</code>，描述方式:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="d549" class="mx lw it mt b be my mz l na nb">enum Location {<br/>    var id:Int { hashValue }<br/>    case unknown<br/>    case address(Address)<br/>    case coordinate(Coordinate)<br/>    case directions(Directions)<br/>    var address   : Address?    { switch self { case .address   (let a): return a default: return nil } }<br/>    var coordinate: Coordinate? { switch self { case .coordinate(let c): return c default: return nil } }<br/>    var directions: Directions? { switch self { case .directions(let d): return d default: return nil } }<br/>}<br/>struct Address {<br/>    enum Change {<br/>        case street (String)<br/>        case city   (String)<br/>        case country(String)<br/>        case zipCode(String)<br/>    }<br/>    init(street:String, city:String, country:String, zipCode:String) { self.init(UUID(),street,city,country,zipCode) }<br/>    private <br/>    init(_ i:UUID,_ s:String,_ ci:String,_ co:String,_ z:String) { id=i; street=s; city=ci; country=co; zipCode=z }<br/>    let id     : UUID<br/>    let street : String<br/>    let city   : String<br/>    let country: String<br/>    let zipCode: String<br/>    <br/>    func alter(_ c:Change...) -&gt; Self { c.reduce(self) { $0.alter($1) } }<br/>    private <br/>    func alter(_ c:Change) -&gt; Self {<br/>        switch c {<br/>        case let .street (s):return .init(id,s,     city,country,zipCode)<br/>        case let .city   (c):return .init(id,street,c,   country,zipCode)<br/>        case let .country(c):return .init(id,street,city,c,      zipCode)<br/>        case let .zipCode(z):return .init(id,street,city,country,z      )<br/>        }<br/>    }<br/>}<br/>struct Coordinate {<br/>    init(latitude la:Double,longitude lo:Double)  { id = UUID(); latitude = la; longitude = lo }<br/>    let id       : UUID<br/>    let latitude : Double<br/>    let longitude: Double<br/>}<br/>struct Directions {<br/>    enum Step:Identifiable, Hashable,Codable {<br/>        var id: Int { hashValue }<br/>        case step(String)<br/>    }<br/>    enum Change {<br/>        case replace(Replace); enum Replace{<br/>            case steps([Step])<br/>        }<br/>    }<br/>    <br/>    init() { self.init(UUID(), []) }<br/>    private <br/>    init(_ x:UUID,_ s: [Step]) { id=x; steps=s }<br/>    let id: UUID<br/>    let steps: [Step]<br/>    func alter(_ c:Change) -&gt; Self {<br/>        switch c {<br/>        case let .replace(.steps(s)): return .init(id,s)<br/>        }<br/>    }<br/>}</span></pre><p id="e5f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许以下代码:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="ce2e" class="mx lw it mt b be my mz l na nb">let a = Address(street: "Karl Kunger 333", city: "Berlin", country: "Germany", zipCode: "12435")<br/>let t1 = t0.alter(.location(to:.address(a)))<br/><br/>let c = Coordinate(latitude:53.3174759,longitude:6.4681397)<br/>let t1 = t0.alter(.location(to:.coordinate(c)))<br/><br/>let d = Directions().alter(.replace(.steps([.step("Enter house"), .step("turn left"), .step("take lift to 3rd floor")])))<br/>let t1 = t0.alter(.location(to:.directions(d)))</span></pre><p id="a1fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些声明中只需要很少几行代码，我们就可以用非常不同的方式来表达一个项的位置。</p><p id="5d6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会在<code class="fe nc nd ne mt b"><a class="ae ky" href="https://gitlab.com/vikingosegundo/items" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/vikingosegundo/items</a></code>找到一个应用，包括一个简单的SwiftUI用户界面。[虽然我不认为自己是SwiftUI专家，但如果您看到问题或改进空间，请让我知道。]</p><p id="41d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们转到其他领域。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="36ed" class="mx lw it mt b be my mz l na nb">struct Snake {<br/>    init (head:Coordinate) { self.init(head, [], .north) }<br/>    <br/>    enum Facing { case north, east, south, west }<br/>    enum Move   { case forward, right, left     }<br/>    enum Change { case move(Move), grow         }<br/>    <br/>    let head  : Coordinate<br/>    let tail  : [Coordinate]<br/>    var body  : [Coordinate] { [head] + tail }<br/>    let facing: Facing<br/>    <br/>    func alter(_ change:Change) -&gt; Self {<br/>        func growTail() -&gt; [Coordinate] { tail.last != nil ? tail + [tail.last!] : [head] } // grow by appending last element again<br/>        switch change {<br/>        case let .move(direction): return move (direction)<br/>        case     .grow:            return .init(head, growTail(), facing)<br/>        }<br/>    }<br/>    <br/>    private init(_ h:Coordinate, _ t:[Coordinate], _ f:Facing) { head = h; tail = t; facing = f }<br/>    private func move(_ m:Move) -&gt; Self {<br/>        func newSnakeTail() -&gt; [Coordinate] { Array(([head] + tail).prefix(tail.count)) }<br/>        switch (m, facing) {<br/>        case (.forward, .north): return .init(.init(x:head.x,     y:head.y - 1), newSnakeTail(), .north)<br/>        case (.forward, .east ): return .init(.init(x:head.x + 1, y:head.y    ), newSnakeTail(), .east )<br/>        case (.forward, .south): return .init(.init(x:head.x,     y:head.y + 1), newSnakeTail(), .south)<br/>        case (.forward, .west ): return .init(.init(x:head.x - 1, y:head.y    ), newSnakeTail(), .west )<br/>        case (   .left, .north): return .init(.init(x:head.x - 1, y:head.y    ), newSnakeTail(), .west )<br/>        case (   .left, .east ): return .init(.init(x:head.x,     y:head.y - 1), newSnakeTail(), .north)<br/>        case (   .left, .south): return .init(.init(x:head.x + 1, y:head.y    ), newSnakeTail(), .east )<br/>        case (   .left, .west ): return .init(.init(x:head.x,     y:head.y + 1), newSnakeTail(), .south)<br/>        case (  .right, .north): return .init(.init(x:head.x + 1, y:head.y    ), newSnakeTail(), .east )<br/>        case (  .right, .east ): return .init(.init(x:head.x,     y:head.y + 1), newSnakeTail(), .south)<br/>        case (  .right, .south): return .init(.init(x:head.x - 1, y:head.y    ), newSnakeTail(), .west )<br/>        case (  .right, .west ): return .init(.init(x:head.x,     y:head.y - 1), newSnakeTail(), .north)<br/>        }<br/>    }<br/>}</span></pre><p id="c216" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个数据结构实现了来自同名游戏的<code class="fe nc nd ne mt b">Snake</code>。看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/a73b820d91fb473c0457988b0625dfe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*ygXBDYCUWQbDSdZfWW6sSw.gif"/></div></figure><p id="5048" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据结构的使用如下:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="690e" class="mx lw it mt b be my mz l na nb">snake = snake.alter(.move(.left)) <br/>snake = snake.alter(.move(.right))</span></pre><p id="96ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将改变蛇指向的方向，而</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="6ad3" class="mx lw it mt b be my mz l na nb">snake = snake.alter(.grow)</span></pre><p id="399b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">会在主体上附加一个坐标。</p><p id="e6cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里找到snake应用:<code class="fe nc nd ne mt b"><a class="ae ky" href="https://gitlab.com/vikingosegundo/declarative-snake" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/vikingosegundo/declarative-snake</a></code>，尽管它的用户界面只是一个原型。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="65b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们看看另一个非常不同的领域。</p><p id="a4b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们将看到一个单摆和双摆的模拟，其中双摆是两个钟摆相连。</p><p id="4ac2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是物理学解释复杂行为的一个标准例子。</p><p id="39be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顶部的两个单摆被模拟，只是起始位置略有不同。在底部，我们看到相同的设置，但这次是双摆。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/195ed92b65178a897c451dcf74f68c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*T84AxlsTz3BUfDJK_FdbRw.gif"/></div></figure><p id="5a27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，这两个简单的钟摆有着相同的命运。他们的行为在遥远的未来也是可以预测的。</p><p id="bac5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，双摆表现出复杂而混乱的行为。尽管他们的起点几乎完全相同，但他们的命运却立即发生了分歧。我们既不能预测一个双摆的未来，除了接下来的几个时刻，也不能从一个双摆的命运告诉我们任何关于另一个双摆的事情。</p><p id="d028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是单摆的代码:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="099b" class="mx lw it mt b be my mz l na nb">  struct SimplePendulum:Codable {<br/>    enum Change {<br/>        case tick<br/>        case pause<br/>        case unpause<br/>        case set(_Set); enum _Set {<br/>            case radius   (Double)<br/>            case gravity  (Double)<br/>            case dampening(Double)<br/>        }<br/>    }<br/>    let angle      : Double<br/>    let angleV     : Double<br/>    let angleA     : Double<br/>    let r          : Double<br/>    let gravity    : Double<br/>    let dampening  : Double<br/>    let bobDiameter: Double<br/>    let hue        : Double<br/>    let paused     : Bool<br/>    init(<br/>            angle: Double,<br/>                r: Double,<br/>          gravity: Double,<br/>      dampening d: Double = 0.0125,<br/>   bobDiameter bd: Double = 6,<br/>              hue: Double = 0.0,<br/>           paused: Bool   = false<br/>    ) {<br/>        self.init(angle,0.0,0.0,r,gravity,d,bd,hue,paused)<br/>    }<br/>    func alter(_ changes:  Change...) -&gt; Self { changes.reduce(self) { $0.alter($1) } }<br/>    func alter(_ changes: [Change]  ) -&gt; Self { changes.reduce(self) { $0.alter($1) } }<br/>    func bobPoint() -&gt; ((Double,Double)) { (r * sin(angle) ,r * cos(angle)) }<br/>}<br/><br/>//MARK: - manipulate recursively &amp; axiomatically<br/>private<br/>extension SimplePendulum {<br/>    init(<br/>     _       angle: Double,<br/>     _      angleV: Double,<br/>     _      angleA: Double,<br/>     _           r: Double,<br/>     _     gravity: Double,<br/>     _   dampening: Double,<br/>     _ bobDiameter: Double,<br/>     _         hue: Double,<br/>     _      paused: Bool<br/>    ) {<br/>        // math<br/>        self.angle     = angle<br/>        self.angleV    = angleV<br/>        self.angleA    = angleA<br/>        self.r         = r<br/>        self.gravity   = gravity<br/>        self.dampening = dampening<br/>        //style &amp; operations<br/>        self.bobDiameter = bobDiameter<br/>        self.hue         = hue<br/>        self.paused      = paused<br/>    }<br/>    func alter(_ cmd:Change) -&gt; Self {<br/>        switch (paused,cmd) {<br/>        case (false,       .tick        ): return advance()<br/>        case ( true,    .unpause        ): return .init(angle,angleV,angleA,r,gravity,dampening,bobDiameter,hue,false )<br/>        case (false,      .pause        ): return .init(angle,angleV,angleA,r,gravity,dampening,bobDiameter,hue,true  )<br/>        case (_, let .set(.radius   (r))): return .init(angle,angleV,angleA,r,gravity,dampening,bobDiameter,hue,paused)<br/>        case (_, let .set(.dampening(d))): return .init(angle,angleV,angleA,r,gravity,        d,bobDiameter,hue,paused)<br/>        case (_, let .set(.gravity  (g))): return .init(angle,angleV,angleA,r,g      ,dampening,bobDiameter,hue,paused)<br/>        case (_, _                      ): return self<br/>        }<br/>    }<br/>}<br/>// MARK: - // Calculations<br/><br/>private<br/>extension SimplePendulum {<br/>    func advance() -&gt; Self {<br/>        let force = gravity * sin(angle)<br/>        let aa = (-1 * force) / r<br/>        let av = (angleV + angleA) * (1.0 - dampening)<br/>        let  a = angle + angleV<br/>        return .init(a,av,aa,r,gravity,dampening,bobDiameter,hue,paused)<br/>    }<br/>}</span></pre><p id="9cbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是双摆的代码:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="1139" class="mx lw it mt b be my mz l na nb">struct DoublePendulum:Codable {<br/>    enum Change {<br/>        case tick<br/>        case pause<br/>        case unpause<br/>        case set(_Set); enum _Set {<br/>            case masses   ((Double,Double))<br/>            case radii    ((Double,Double))<br/>            case gravity  (Double)<br/>            case dampening(Double)<br/>        }<br/>    }<br/>    let bobDiameter: Double<br/>    let hue        : Double<br/>    let paused     : Bool<br/>    init( radii r: (Double, Double),<br/>         masses m: (Double, Double),<br/>         angles a: (Double, Double),<br/>      dampening d: Double = 0.0,<br/>        gravity g: Double = 1.0,<br/>   bobDiameter bd: Double = 6,<br/>            hue h: Double = 0.0,<br/>         paused p: Bool   = false<br/>    ) {<br/>        self.init(r,m,a,(0,0),d,g,bd,h,p)<br/>    }<br/>    func alter(_ changes:  Change...) -&gt; Self { changes.reduce(self) { $0.alter($1) } }<br/>    func alter(_ changes: [Change]  ) -&gt; Self { changes.reduce(self) { $0.alter($1) } }<br/>    func bobPoints() -&gt; (<br/>        (Double,Double),<br/>        (Double,Double)<br/>    ) {<br/>        let p0 = (       r0 * sin(a0),        r0 * cos(a0))<br/>        let p1 = (p0.0 + r1 * sin(a1), p0.1 + r1 * cos(a1))<br/>        return (p0, p1)<br/>    }<br/>    private let r0 : Double<br/>    private let r1 : Double<br/>    private let m0 : Double<br/>    private let m1 : Double<br/>    private let a0 : Double<br/>    private let a1 : Double<br/>    private let av0: Double<br/>    private let av1: Double<br/>    private let g  : Double<br/>    private let d  : Double<br/>}<br/><br/>//MARK: - manipulate recursively &amp; axiomatically<br/>private<br/>extension DoublePendulum {<br/>    init(      _ r: (Double,Double),<br/>               _ m: (Double,Double),<br/>               _ a: (Double,Double),<br/>              _ av: (Double,Double),<br/>               _ d: Double,<br/>               _ g: Double,<br/>     _ bobDiameter: Double,<br/>             _ hue: Double,<br/>          _ paused: Bool<br/>    ) {<br/>        // math<br/>        self.r0 = r.0<br/>        self.r1 = r.1<br/><br/>        self.m0 = m.0<br/>        self.m1 = m.1<br/><br/>        self.a0 = a.0<br/>        self.a1 = a.1<br/>        self.av0 = av.0<br/>        self.av1 = av.1<br/>        self.g = g<br/>        self.d = d<br/>        //style &amp; operations<br/>        self.bobDiameter = bobDiameter<br/>        self.hue         = hue<br/>        self.paused      = paused<br/>    }<br/>    func alter(_ cmd:Change) -&gt; Self {<br/>        switch (paused,cmd) {<br/>        case (false,       .tick        ): return advance()<br/>        case ( true,    .unpause        ): return .init((r0,r1),(m0,m1),(a0,a1),(av0,av1),d,g,bobDiameter,hue,false )<br/>        case (false,      .pause        ): return .init((r0,r1),(m0,m1),(a0,a1),(av0,av1),d,g,bobDiameter,hue,true  )<br/>        case (_, let .set(.radii    (r))): return .init(  r    ,(m0,m1),(a0,a1),(av0,av1),d,g,bobDiameter,hue,paused)<br/>        case (_, let .set(.masses   (m))): return .init((r0,r1),  m    ,(a0,a1),(av0,av1),d,g,bobDiameter,hue,paused)<br/>        case (_, let .set(.dampening(d))): return .init((r0,r1),(m0,m1),(a0,a1),(av0,av1),d,g,bobDiameter,hue,paused)<br/>        case (_, let .set(.gravity  (g))): return .init((r0,r1),(m0,m1),(a0,a1),(av0,av1),d,g,bobDiameter,hue,paused)<br/>        case (_, _                      ): return self<br/>        }<br/>    }<br/>}<br/>// MARK: - // Calculations<br/>private<br/>extension DoublePendulum {<br/>    func advance() -&gt; Self {<br/>        let damp = (1.0 - d)<br/>        let acc = calc()<br/>        let av  = ((av0 + acc.0) * damp, (av1 + acc.1) * damp)<br/>        let a   = ((a0 + av0 ) , (a1 + av1) )<br/>        return .init((r0,r1),(m0,m1),a,av,d,g,bobDiameter,hue,paused)<br/>    }<br/>    func calc() -&gt; (Double, Double) { // -&gt; (pendulum arm 0, pendulum arm 1)<br/>        //|      |&lt;------------------ pendulum arm 0 -----------------&gt;| |&lt;----------- pendulum arm 1 -----------&gt;|<br/>        let n0 = (-g * (2 * m0 + m1) * sin(a0),                        2 * sin(a0 - a1)                      )<br/>        let n1 = (-m1 * g * sin(a0 - 2 * a1),                          av0 * av0 * r0 * (m0 + m1)         )<br/>        let n2 = (-2 * sin(a0 - a1) * m1,                              g * (m0 + m1) * cos(a0)              )<br/>        let n3 = (av1 * av1 * r1 + av0 * av0 * r0 * cos(a0 - a1), av1 * av1 * r1 * m1 * cos(a0 - a1))<br/>        <br/>        let d0 = r0 * (2 * m0 + m1 - m1 * cos(2 * a0 - 2 * a1))<br/>        let d1 = r1 * (2 * m0 + m1 - m1 * cos(2 * a0 - 2 * a1))<br/>        <br/>        return (<br/>            (n0.0 +  n1.0 + (n2.0 * n3.0) / d0).truncatingRemainder(dividingBy:.pi * 2) / 360.0,<br/>            (n0.1 * (n1.1 +  n2.1 + n3.1) / d1))<br/>    }<br/>}</span></pre><p id="d472" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那些被用作</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="568d" class="mx lw it mt b be my mz l na nb">pendulum0 = pendulum0.alter(.tick))</span></pre><p id="ba23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来计算下一个位置</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="e28a" class="mx lw it mt b be my mz l na nb">pendulum0 = pendulum0.alter(.pause)<br/>pendulum0 = pendulum0.alter(.play)</span></pre><p id="a39f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">停下来玩一个钟摆</p><p id="0648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里找到钟摆代码:<code class="fe nc nd ne mt b"><a class="ae ky" href="https://gitlab.com/vikingosegundo/declarativependulum" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/vikingosegundo/declarativependulum</a></code></p><p id="f34c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，UI只是概念质量的证明。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="5e68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，作为最后一个领域的例子，我准备了康威生命游戏的实现——我们当中的计算机科学家应该明白，这证明了这种编码的图灵完整性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/e3d38be817dcede477e06ebe49821cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*oLDtP8mWQXwKugQWJwxI2A.gif"/></div></figure><p id="3831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne mt b">Life</code>数据结构</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="1f94" class="mx lw it mt b be my mz l na nb">struct Life:Codable {<br/>    enum Change {<br/>        case process<br/>        case pause, unpause<br/>        case set (_Set); enum _Set {<br/>            case cells([Cell])<br/>        }<br/>    }<br/>    struct Cell: Hashable, Equatable, Codable {<br/>        init(coordinate: Coordinate, state:State = .alive) {<br/>            self.coordinate = coordinate<br/>            self.state = state<br/>        }<br/>        let coordinate: Coordinate; struct Coordinate: Equatable, Codable {  let x, y: Int   }<br/>        let state     : State;        enum State     :  Hashable, Codable { case alive, dead }<br/>    }<br/>    init(coordinates: [Cell.Coordinate]) { self.init(cells:coordinates.map { Cell(coordinate:$0) }) }<br/>    init(cells      : [Cell           ]) { self.init(0,cells,false, 0)                              }<br/>    func alter(_ cs: [Change] ) -&gt; Self { cs.reduce(self) { $0.alter($1) } }<br/>    func alter(_ cs: Change...) -&gt; Self { cs.reduce(self) { $0.alter($1) } }<br/>    func alter(_ c : Change   ) -&gt; Self {<br/>        if paused &amp;&amp; !unpausing(c) { return self }<br/>        switch c {<br/>            // axomiatic                           |step|, |&lt;------------------------- cells ----------------------&gt;|, paused, |&lt;------- size --------&gt;|<br/>        case let .set(.cells(cells)): return .init(step+1, cells                                                     , paused, stateForCoordiantes.count)<br/>        case                  .pause: return .init(step+1, stateForCoordiantes.map{ Cell(coordinate: $0, state: $1) },   true, stateForCoordiantes.count)<br/>        case                .unpause: return .init(step+1, stateForCoordiantes.map{ Cell(coordinate: $0, state: $1) },  false, stateForCoordiantes.count)<br/>            // recursive<br/>        case                .process: return alter(.set(.cells(applyRules())))<br/>        }<br/>    }<br/>    func debug(_ exe: (Self) -&gt; ()) -&gt; Self { exe(self); return self }<br/>    let paused             : Bool<br/>    let step               : Int<br/>    let size               : Int<br/>    let stateForCoordiantes: [Life.Cell.Coordinate : Life.Cell.State]<br/>}<br/>//MARK: - private<br/>private extension Life {<br/>    init(_ step: Int,_ cells: [Cell] = [],_ paused:Bool,_ size:Int) {<br/>        self.step                = step<br/>        self.paused              = paused<br/>        self.stateForCoordiantes = cells.reduce([:]) { var a = $0; a[$1.coordinate] = $1.state; return a }<br/>        self.size                = size<br/>    }<br/>    func applyRules() -&gt; [Life.Cell] {<br/>        Array(Set(self.stateForCoordiantes.map { k,v in Cell(coordinate: k, state: v)}.flatMap { neighbors(for:$0) }))<br/>            .compactMap {<br/>                let neigbours = aliveNeighbors(for: $0)<br/>                let isAlive:Bool<br/>                switch (neigbours.count, $0.state) {<br/>                case (0...1, .alive): isAlive = false<br/>                case (2...3, .alive): isAlive = true<br/>                case (4...8, _     ): isAlive = false<br/>                case (3,      .dead): isAlive = true<br/>                case (_,      _    ): isAlive = false<br/>                }<br/>                return isAlive ? .init(coordinate: .init(x: $0.coordinate.x, y: $0.coordinate.y), state:.alive) : nil<br/>            }<br/>    }<br/>    func neighbors(for cell: Life.Cell) -&gt; [Life.Cell] {<br/>        aliveNeighbors(for: cell) + deadNeighbors(for: cell)<br/>    }<br/>    func aliveNeighbors(for cell: Life.Cell) -&gt; [Life.Cell] {<br/>        allNeigbourCoordinates(cell).map {<br/>            Cell(coordinate: $0, state: stateForCoordiantes[$0] ?? .dead)<br/>        }.filter { $0.state == .alive }<br/>    }<br/>    func allNeigbourCoordinates(_ cell: Life.Cell) -&gt; [Life.Cell.Coordinate] {<br/>        [<br/>            .init(x:cell.coordinate.x-1, y:cell.coordinate.y-1),<br/>            .init(x:cell.coordinate.x-1, y:cell.coordinate.y  ),<br/>            .init(x:cell.coordinate.x-1, y:cell.coordinate.y+1),<br/>            .init(x:cell.coordinate.x  , y:cell.coordinate.y-1),<br/>            .init(x:cell.coordinate.x  , y:cell.coordinate.y+1),<br/>            .init(x:cell.coordinate.x+1, y:cell.coordinate.y-1),<br/>            .init(x:cell.coordinate.x+1, y:cell.coordinate.y  ),<br/>            .init(x:cell.coordinate.x+1, y:cell.coordinate.y+1),<br/>        ]<br/>    }<br/>    func deadNeighbors(for cell: Life.Cell) -&gt; [Life.Cell] {<br/>        Set(allNeigbourCoordinates(cell))<br/>            .subtracting(aliveNeighbors(for:cell).map{ $0.coordinate })<br/>            .map { Cell(coordinate:$0,state:.dead) }<br/>    }<br/>}<br/>private func unpausing(_ c:Life.Change) -&gt; Bool {<br/>    switch c {<br/>    case .unpause: return true<br/>    default      : return false<br/>    }<br/>}<br/>extension Life.Cell.Coordinate: Hashable {<br/>    func hash(into hasher: inout Hasher) {<br/>        hasher.combine(x)<br/>        hasher.combine(y)<br/>    }<br/>}</span></pre><p id="df72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下命令将创建下一个有效状态</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="3db8" class="mx lw it mt b be my mz l na nb">life = life.alter(.process)</span></pre><h1 id="be26" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">公理代码</h1><p id="55a1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">上面的所有例子都是不可变的，这意味着每次触发更改时都会重新创建对象——未更改的值只是被重用，而更改的值会覆盖旧的值。</p><p id="517f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的代码中，这总是发生在<code class="fe nc nd ne mt b">alter</code>方法中，它们同样都有相同的结构:通过模式匹配，解码出一个<code class="fe nc nd ne mt b">Change</code> -DSL值，并执行正确的动作。我称之为“公理”，因为每个case语句的左边描述了需要什么，而右边实现了这个。</p><p id="35b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那些代码非常简单，很难想象虫子会藏在那里。通常，它们非常简单，很容易理解。</p><p id="16d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到带有更多代码的<code class="fe nc nd ne mt b">TodoItem</code>的例子:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="cb46" class="mx lw it mt b be my mz l na nb">func alter(_ c:Change   ) -&gt; Self {<br/>        switch c {<br/>        case let    .title(to:t): return Self(id,t    ,completed,due,created,location)<br/>        case       .finish      : return Self(id,title,true     ,due,created,location)<br/>        case     .unfinish      : return Self(id,title,false    ,due,created,location)<br/>        case let .location(to:l): return Self(id,title,completed,due,created,l       )<br/>        case let      .due(to:d): return Self(id,title,completed,d  ,created,location)<br/>        }<br/>    }</span></pre><p id="0dcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们很容易看到的，解码改变命令<code class="fe nc nd ne mt b">.title(to:t) </code>将导致<code class="fe nc nd ne mt b">return Self(id,t ,completed,due,created,location)</code>，其中<code class="fe nc nd ne mt b">t</code>替换<code class="fe nc nd ne mt b">title</code>的任何早期值。</p><p id="b6ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令<code class="fe nc nd ne mt b">.finish</code>将导致<code class="fe nc nd ne mt b">true</code>覆盖任何先前的完成值，<code class="fe nc nd ne mt b">.unfinish</code>将使用<code class="fe nc nd ne mt b">false</code>覆盖。<br/> <code class="fe nc nd ne mt b">.location(to:l)</code>将用新值覆盖当前位置。<br/> <code class="fe nc nd ne mt b">.due(to:d)</code>也会对到期日做同样的事情。</p><p id="70c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些都是公理化的陈述。case语句的左侧列出了变更DSL中声明的词汇表，而右侧尽可能简单地实现命令。</p><p id="d069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“生命宣言”app可以在这里找到:<code class="fe nc nd ne mt b"><a class="ae ky" href="https://gitlab.com/vikingosegundo/declaration-of-live" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/vikingosegundo/declaration-of-live</a></code></p><p id="018c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(UI不是生产质量)</p><h1 id="e953" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">验证正确性</h1><p id="0932" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">毫无疑问，您将在下一个代码块中注意到，测试具有一定的公理特征。我这里用的是<a class="ae ky" href="https://github.com/Quick/Quick" rel="noopener ugc nofollow" target="_blank">快速</a>和<a class="ae ky" href="https://github.com/Quick/Nimble" rel="noopener ugc nofollow" target="_blank">敏捷</a>。每个<code class="fe nc nd ne mt b">it(expect(…))</code>语句都是一个小单元测试。代码大约有130行(非空)，但是它包含89个单元测试。</p><p id="02d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试名称与测试嵌套的所有<code class="fe nc nd ne mt b">describe</code>、<code class="fe nc nd ne mt b">context</code>和<code class="fe nc nd ne mt b">it</code>描述相结合，测试的第一个程序块将是</p><p id="9920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne mt b">“TodoItem__just_created__has_an_id<br/>“TodoItem__just_created__has_correct_title”<br/>“TodoItem__just_created__has_unknown_due_date”<br/>“TodoItem__just_created__isnt_finished”<br/>“TodoItem__just_created__has_no_location”</code></p><p id="6804" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到，测试策略非常简单:进行一项更改，然后观察预期会发生更改的所有内容都发生了更改。而且还要确保没有其他事情发生变化。</p><p id="fd1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在“更改标题”上下文中，我们确切地看到:<br/>命令<code class="fe nc nd ne mt b">.title(to:”Get Coffee — ASAP”)</code>被传递到<code class="fe nc nd ne mt b">alter</code>中，在接下来的几行中，测试出只有标题被更改——而该上下文中的所有其他测试确保其他内容都没有更改。</p><p id="05e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，这是科学方法在起作用。</p><p id="e9ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您自己尝试并编写这样的代码和测试，您会很快注意到一件事:两者都编写得非常快。实现一个特性需要几分钟，每小时编写80或90个测试并不难。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="98bb" class="mx lw it mt b be my mz l na nb"><br/>import Quick<br/>import Nimble<br/>import ItemsModels<br/><br/>final class TodoItemSpecifications: QuickSpec {<br/>    override func spec() {<br/>        describe("TodoItem") {<br/>            let t0 = TodoItem(title:"Get Coffee")<br/>            context("just created") {<br/>                it("has an id"          ) { expect(t0.id       ).toNot(beNil()            ) }<br/>                it("has correct title"  ) { expect(t0.title    ).to   (equal("Get Coffee")) }<br/>                it("has unkown due date") { expect(t0.due      ).to   (equal(.unknown)    ) }<br/>                it("isnt finished"      ) { expect(t0.completed).to   (beFalse()          ) }<br/>                it("has no location"    ) { expect(t0.location ).to   (equal(.unknown)    ) }<br/>            }<br/>            context("change title") {<br/>                let t1 = t0.alter(.title(to:"Get Coffee — ASAP"))<br/>                it("has same id"        ) { expect(t1.id       ).to   (equal(t0.id)              ) }<br/>                it("has different title") { expect(t1.title    ).toNot(equal(t0.title)           ) }<br/>                it("has correct title"  ) { expect(t1.title    ).to   (equal("Get Coffee — ASAP")) }<br/>                it("has same due date"  ) { expect(t1.due      ).to   (equal(t0.due)             ) }<br/>                it("has same state"     ) { expect(t1.completed).to   (equal(t0.completed)       ) }<br/>                it("has same location"  ) { expect(t0.location ).to   (equal(t0.location)        ) }<br/>            }<br/>            context("change state") {<br/>                let t1 = t0.alter(.finish)<br/>                it("has same id"        ) { expect(t1.id       ).to   (equal(t0.id)       ) }<br/>                it("has different state") { expect(t1.completed).toNot(equal(t0.completed)) }<br/>                it("has correct state"  ) { expect(t1.completed).to   (beTrue()           ) }<br/>                it("has same title"     ) { expect(t1.title    ).to   (equal(t0.title)    ) }<br/>                it("has same due date"  ) { expect(t1.due      ).to   (equal(t0.due)      ) }<br/>                it("has same location"  ) { expect(t0.location ).to   (equal(t0.location) ) }<br/>                context("change state back") {<br/>                    let t2 = t1.alter(.unfinish)<br/>                    it("has same id"        ) { expect(t2.id       ).to   (equal(t1.id)       ) }<br/>                    it("has different state") { expect(t2.completed).toNot(equal(t1.completed)) }<br/>                    it("has correct state"  ) { expect(t2.completed).to   (beFalse()          ) }<br/>                    it("has same title"     ) { expect(t2.title    ).to   (equal(t1.title)    ) }<br/>                    it("has same due date"  ) { expect(t2.due      ).to   (equal(t1.due)      ) }<br/>                    it("has same location"  ) { expect(t2.location ).to   (equal(t1.location) ) }<br/>                }<br/>            }<br/>            context("change due date") {<br/>                context("to date") {<br/>                    let t1 = t0.alter(.due(to:.date(.tomorrow.noon)))<br/>                    it("has same id"               ) { expect(t1.id       ).to   (equal(t0.id)         ) }<br/>                    it("has different due date"    ) { expect(t1.due      ).toNot(equal(t0.due)        ) }<br/>                    it("has due date tomorrow noon") { expect(t1.due.date ).to   (equal(.tomorrow.noon)) }<br/>                    it("has same state"            ) { expect(t1.completed).to   (equal(t0.completed)  ) }<br/>                    it("has correct state"         ) { expect(t1.completed).to   (beFalse()            ) }<br/>                    it("has same title"            ) { expect(t1.title    ).to   (equal(t0.title)      ) }<br/>                    context("back to unknown") {<br/>                        let t2 = t1.alter(.due(to:.unknown))<br/>                        it("has same id"               ) { expect(t2.id       ).to   (equal(t1.id)       ) }<br/>                        it("has unkown due date"       ) { expect(t2.due      ).toNot(equal(t1.due)      ) }<br/>                        it("has due date tomorrow noon") { expect(t2.due      ).to   (equal(.unknown)    ) }<br/>                        it("has same state"            ) { expect(t2.completed).to   (equal(t1.completed)) }<br/>                        it("has correct state"         ) { expect(t2.completed).to   (beFalse()          ) }<br/>                        it("has same title"            ) { expect(t2.title    ).to   (equal(t1.title)    ) }<br/>                    }<br/>                }<br/>                context("to timespan with duration") {<br/>                    let t1 = t0.alter(.due(to:.timeSpan(.duration(.from(.tomorrow.noon),for:3,.days))))<br/>                    it("has same id"                    ) { expect(t1.id              ).to   (equal(t0.id)                        ) }<br/>                    it("has different due date"         ) { expect(t1.due             ).toNot(equal(t0.due)                       ) }<br/>                    it("has due date duration time span") { expect(t1.due.timeSpan    ).to   (equal(.duration(.from(.tomorrow.noon),<br/>                    it("has same state"                 ) { expect(t1.completed       ).to   (equal(t0.completed)                 ) }<br/>                    it("has correct state"              ) { expect(t1.completed       ).to   (beFalse()                           ) }<br/>                    it("has same title"                 ) { expect(t1.title           ).to   (equal(t0.title)                     ) }<br/>                    it("has timeSpan id"                ) { expect(t1.due.timeSpan?.id).toNot(beNil()                             ) }<br/><br/>                    context("back to unknown") {<br/>                        let t2 = t1.alter(.due(to:.unknown))<br/>                        it("has same id"               ) { expect(t2.id       ).to   (equal(t1.id)       ) }<br/>                        it("has unkown due date"       ) { expect(t2.due      ).toNot(equal(t1.due)      ) }<br/>                        it("has due date tomorrow noon") { expect(t2.due      ).to   (equal(.unknown)    ) }<br/>                        it("has same state"            ) { expect(t2.completed).to   (equal(t1.completed)) }<br/>                        it("has correct state"         ) { expect(t2.completed).to   (beFalse()          ) }<br/>                        it("has same title"            ) { expect(t2.title    ).to   (equal(t1.title)    ) }<br/>                    }<br/>                }<br/>                context("to timespan with start/end") {<br/>                    let t1 = t0.alter(.due(to:.timeSpan(.start(.from(.tomorrow.noon),.to(.tomorrow.noon.dayAfter)))))<br/>                    it("has same id"                     ) { expect(t1.id          ).to   (equal(t0.id)                                 ) }<br/>                    it("has different due date"          ) { expect(t1.due         ).toNot(equal(t0.due)                                ) }<br/>                    it("has due date start/end time span") { expect(t1.due.timeSpan).to   (equal(.start(.from(.tomorrow.noon),<br/>                    it("has same state"                  ) { expect(t1.completed   ).to   (equal(t0.completed)                          ) }<br/>                    it("has correct state"               ) { expect(t1.completed   ).to   (beFalse()                                    ) }<br/>                    it("has same title"                  ) { expect(t1.title       ).to   (equal(t0.title)                              ) }<br/>                    context("back to unknown") {<br/>                        let t2 = t1.alter(.due(to:.unknown))<br/>                        it("has same id"               ) { expect(t2.id       ).to   (equal(t1.id)       ) }<br/>                        it("has unkown due date"       ) { expect(t2.due      ).toNot(equal(t1.due)      ) }<br/>                        it("has due date tomorrow noon") { expect(t2.due      ).to   (equal(.unknown)    ) }<br/>                        it("has same state"            ) { expect(t2.completed).to   (equal(t1.completed)) }<br/>                        it("has correct state"         ) { expect(t2.completed).to   (beFalse()          ) }<br/>                        it("has same title"            ) { expect(t2.title    ).to   (equal(t1.title)    ) }<br/>                    }<br/>                }<br/>                context("to timespan with stat/end fails silently for mixed up dates") {<br/>                    let t1 = t0.alter(.due(to:.timeSpan(.start(.from(.tomorrow.noon.dayAfter),.to(.tomorrow.noon)))))<br/>                    it("has same id"               ) { expect(t1.id          ).to(equal(t0.id)       ) }<br/>                    it("has unchanged due date"    ) { expect(t1.due         ).to(equal(t0.due)      ) }<br/>                    it("doesnt correct mixed dates") { expect(t1.due.timeSpan).to(beNil()            ) }<br/>                    it("doesnt accept mixed dates" ) { expect(t1.due.timeSpan).to(beNil()            ) }<br/>                    it("has same state"            ) { expect(t1.completed   ).to(equal(t0.completed)) }<br/>                    it("has correct state"         ) { expect(t1.completed   ).to(beFalse()          ) }<br/>                    it("has same title"            ) { expect(t1.title       ).to(equal(t0.title)    ) }<br/>                    it("has same location"         ) { expect(t1.location    ).to(equal(t0.location) ) }<br/>                }<br/>            }<br/>            context("location") {<br/>                context("Address") {<br/>                    let a = Address(street: "Karl Kunger", city: "Berlin", country: "Germany", zipCode: "12435")<br/>                    let t1 = t0.alter(.location(to:.address(a)))<br/>                    it("has same id"           ) { expect(t1.id                 ).to   (equal(t0.id)       ) }<br/>                    it("has different location") { expect(t1.location           ).toNot(equal(t0.location) ) }<br/>                    it("has address location"  ) { expect(t1.location.address   ).to   (equal(a)           ) }<br/>                    it("has not coord location") { expect(t1.location.coordinate).to   (beNil()            ) }<br/>                    it("has same title"        ) { expect(t1.title              ).to   (equal(t0.title)    ) }<br/>                    it("has same due date"     ) { expect(t1.due                ).to   (equal(t0.due)      ) }<br/>                    it("has same state"        ) { expect(t1.completed          ).to   (equal(t0.completed)) }<br/>                }<br/>                context("Coordinate") {<br/>                    let c = Coordinate(latitude:53.3174759,longitude:6.4681397)<br/>                    let t1 = t0.alter(.location(to:.coordinate(c)))<br/>                    it("has same id"           ) { expect(t1.id                 ).to   (equal(t0.id)       ) }<br/>                    it("has different location") { expect(t1.location           ).toNot(equal(t0.location) ) }<br/>                    it("has coord location"    ) { expect(t1.location.coordinate).to   (equal(c)           ) }<br/>                    it("has no addr location"  ) { expect(t1.location.address   ).to   (beNil()            ) }<br/>                    it("has same title"        ) { expect(t1.title              ).to   (equal(t0.title)    ) }<br/>                    it("has same due date"     ) { expect(t1.due                ).to   (equal(t0.due)      ) }<br/>                    it("has same state"        ) { expect(t1.completed          ).to   (equal(t0.completed)) }<br/>                }<br/>                context("Directions") {<br/>                    let d = Directions().alter(.replace(.steps([.step("Enter house"), .step("turn left"), .step("take lift to 3rd floor")])))<br/>                    let t1 = t0.alter(.location(to:.directions(d)))<br/>                    it("has same id"            ) { expect(t1.id                 ).to   (equal(t0.id)       ) }<br/>                    it("has different location" ) { expect(t1.location           ).toNot(equal(t0.location) ) }<br/>                    it("has directions location") { expect(t1.location.directions).to   (equal(d)           ) }<br/>                    it("has no addr location"   ) { expect(t1.location.address   ).to   (beNil()            ) }<br/>                    it("has same title"         ) { expect(t1.title              ).to   (equal(t0.title)    ) }<br/>                    it("has same due date"      ) { expect(t1.due                ).to   (equal(t0.due)      ) }<br/>                    it("has same state"         ) { expect(t1.completed          ).to   (equal(t0.completed)) }<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="d1a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这种测试并不局限于数据结构。</p><p id="c46a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来的测试代码是测试应用程序(没有UI，更确切地说是<code class="fe nc nd ne mt b">AppDomain</code>)本身——这些是特别有价值的测试，因为这准确地反映了这些代码将如何在UI中使用——就像UI一样，测试是应用程序的简单客户端。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="5d9a" class="mx lw it mt b be my mz l na nb">/* abbriviations */<br/>func b(_ code:@escaping () -&gt;()) { beforeEach(code) }<br/>func a(_ code:@escaping () -&gt;()) {  afterEach(code) }<br/>typealias AppStore = Store&lt;AppState,AppState.Change&gt;<br/>func appdomain(_ roothandler: @escaping (Message) -&gt; (), _ store:AppStore) -&gt; Input { createAppDomain(store:store, receivers: [],rootHandler: roothandler) }<br/><br/>final class AppsSpecifications: QuickSpec {<br/>    override func spec() {              /* beforeEach */                                       /* afterEach */<br/>        var store      :AppStore!         ;b{store = createDiskStore(pathInDocs:"appspecs.json")};a{destroy(&amp;store)  }<br/>        var roothandler:((Message) -&gt; ())!;b{roothandler = { msg in }                           };a{roothandler = nil}<br/>        var app        :Input!            ;b{app         = appdomain(roothandler,store)         };a{app         = nil}<br/>        describe("ItemsApp") {<br/>            context("uninitialized") {<br/>                it("has no todos") { expect(store.state().todos).to(beNil()) }<br/>            }<br/>            context("initialized") {<br/>                beforeEach {<br/>                    app(.todos(.cmd(.initialize)))<br/>                }<br/>                it("has todos object"     ) { expect(store.state().todos       ).toNot(beNil())   }<br/>                it("has empty todos items") { expect(store.state().todos?.items).to   (beEmpty()) }<br/>                context("add") {<br/>                    let i0 = TodoItem(title:"hey Ho")<br/>                        beforeEach {<br/>                        app(.todos(.cmd(.add(item:i0))))<br/>                    }<br/>                    context("item defaults" ) {<br/>                        it("has an id"          ) { expect(i0.id        ).toNot(beNil())         }<br/>                        it("has correct title"  ) { expect(i0.title     ).to   (equal("hey Ho")) }<br/>                        it("isnt completed"     ) { expect(i0.completed ).to   (beFalse())       }<br/>                        it("no due date known"  ) { expect(i0.due       ).to   (equal(.unknown)) }<br/>                    }<br/>                    it("has a todo item"                  ) { expect(store.state().todos?.items                 ).to(haveCount(1))        }<br/>                    it("has the added item, title"        ) { expect(store.state().todos?.items.first?.title    ).to(equal("hey Ho"))     }<br/>                    it("has the added item, id"           ) { expect(store.state().todos?.items.first?.id       ).to(equal(i0.id))        }<br/>                    it("has the items completed unchanged") { expect(store.state().todos?.items.first?.completed).to(equal(i0.completed)) }<br/>                    it("no due date known"                ) { expect(store.state().todos?.items.first?.due      ).to(equal(i0.due))       }<br/>                    context("add") {<br/>                        let i1 = TodoItem(title:"Let's go")<br/>                        beforeEach {<br/>                            app(.todos(.cmd(.add(item:i1))))<br/>                        }<br/>                        it("has two todo items"                 ) { expect(store.state().todos?.items                 ).to(haveCount(2))        }<br/>                        it("has first item title"               ) { expect(store.state().todos?.items.first?.title    ).to(equal("hey Ho"))     }<br/>                        it("has first item id"                  ) { expect(store.state().todos?.items.first?.id       ).to(equal(i0.id))        }<br/>                        it("has first item completed unchanged" ) { expect(store.state().todos?.items.first?.completed).to(equal(i0.completed)) }<br/>                        it("has no due date known first item"   ) { expect(store.state().todos?.items.first?.due      ).to(equal(i0.due))       }<br/>                        it("has second item title"              ) { expect(store.state().todos?.items.last? .title    ).to(equal("Let's go"))   }<br/>                        it("has second item id"                 ) { expect(store.state().todos?.items.last? .id       ).to(equal(i1.id))        }<br/>                        it("has second item completed unchanged") { expect(store.state().todos?.items.last? .completed).to(equal(i1.completed)) }<br/>                        it("has no due date known second item"  ) { expect(store.state().todos?.items.first?.due      ).to(equal(i1.due))       }<br/>                        context("remove") {<br/>                            beforeEach {<br/>                                app(.todos(.cmd(.remove(item:i0))))<br/>                            }<br/>                            it("has the added item, id") { expect(store.state().todos?.items.first?.id).to(equal(i1.id)) }<br/>                            it("has a todo item"       ) { expect(store.state().todos?.items          ).to(haveCount(1)) }<br/>                            context("remove twice fails silently") {<br/>                                beforeEach {<br/>                                    app(.todos(.cmd(.remove(item:i0))))<br/>                                }<br/>                                it("has a todo item") { expect(store.state().todos?.items.map(\.id)).to(equal([i1.id])) }<br/>                            }<br/>                        }<br/>                    }<br/>                    context("remove") {<br/>                        beforeEach {<br/>                            app(.todos(.cmd(.remove(item:i0))))<br/>                        }<br/>                        it("has todos object"     ) { expect(store.state().todos       ).toNot(beNil())   }<br/>                        it("has empty todos items") { expect(store.state().todos?.items).to   (beEmpty()) }<br/>                        context("removing unpresent item fails silently") {<br/>                            beforeEach {<br/>                                app(.todos(.cmd(.remove(item:i0))))<br/>                            }<br/>                            it("has todos object"     ) { expect(store.state().todos       ).toNot(beNil())   }<br/>                            it("has empty todos items") { expect(store.state().todos?.items).to   (beEmpty()) }<br/>                        }<br/>                    }<br/>                    context("updates") {<br/>                        beforeEach {<br/>                            app(.todos(.cmd(.update(item: i0.alter(.title(to:"Hey Ho!"))))))<br/>                        }<br/>                        it("has a todo item"                  ) { expect(store.state().todos?.items                 ).to(haveCount(1))        }<br/>                        it("has the added item, title"        ) { expect(store.state().todos?.items.first?.title    ).to(equal("Hey Ho!"))    }<br/>                        it("has the added item, id"           ) { expect(store.state().todos?.items.first?.id       ).to(equal(i0.id))        }<br/>                        it("has the items completed unchanged") { expect(store.state().todos?.items.first?.completed).to(equal(i0.completed)) }<br/>                        it("no due date known"                ) { expect(store.state().todos?.items.first?.due      ).to(equal(i0.due))       }<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="87a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码为SwiftUI代码，其中<code class="fe nc nd ne mt b">viewState.roothandler </code>与之前测试中的<code class="fe nc nd ne mt b">app</code>功能相同。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="cb09" class="mx lw it mt b be my mz l na nb">Button {<br/>    viewState.roothandler(.todos(.cmd(.add(item:.init(title:"Item \(viewState.todos!.items.count)")))))<br/>} label: { Text("add item") }</span></pre><h1 id="e3d9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我们将何去何从</h1><p id="8c6e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我已经向您展示了我们如何编写声明性的域代码，并通过示例实现了使用<code class="fe nc nd ne mt b">Change</code>-DSL改变的数据结构。但是这种技术也可以有效地组装任何域和大小的应用程序结构。我的主要(虽然不是唯一的)架构通篇都使用这个，被称为“Khipu ”,在下面的文章中有描述:</p><ul class=""><li id="add2" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/meet-khipu-a-boilercode-free-implementation-of-clean-architecture-in-swift-f76ccab82ff3?sk=a8938450032cb5aa67a4e7938c0b774a">介绍Khipu:我在Swift中的干净架构的样板代码自由实现</a></li><li id="90b6" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/khipu-rapid-and-sustainable-software-creation-in-swift-using-engineering-and-science-principles-312a933cce57?sk=8359f48cc06571e53de156db8cbc005c"> Khipu:通过声明性领域范例在Swift中快速、可持续地创建软件</a></li></ul><p id="ad3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Khipu可以用作独立的架构或库，因为它唯一的接口是一个函数和一个<code class="fe nc nd ne mt b">Message</code> DSL值。它可以包装在任何其他类型中，如结构或类。</p></div></div>    
</body>
</html>