<html>
<head>
<title>A Technique to Inspect Complex Code With Mind Maps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用思维导图检查复杂代码的技术</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-technique-to-inspect-complex-code-with-mind-maps-2dc83bb4c3a9?source=collection_archive---------5-----------------------#2022-09-13">https://betterprogramming.pub/a-technique-to-inspect-complex-code-with-mind-maps-2dc83bb4c3a9?source=collection_archive---------5-----------------------#2022-09-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7626" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过Freemind</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/df0f29f5726ae2e0830696d96142625e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FXO8ebwIP17Pgiy0"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">娜塔莎·康奈尔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="19c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">阅读和理解复杂的代码是一项非常艰巨的任务。代码并不总是有好的变量名、简洁的函数、测试等等。不幸的是，重写代码很少是一个选项。</p><p id="ba54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的日常工作中，我需要阅读和理解旧的代码——这些代码是几年前写的，在软件开发的良好实践被创造出来之前。不仅是这种类型的代码，即使是最近用新语言编写的代码，第一次也很难理解。</p><p id="1954" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我试图找到一种方法，用更少的努力来分析这种类型的代码，并发现通过使用思维导图，可以用更好的方式来查看代码。我一直喜欢思维导图。从2008年开始，我用它来组织大量的信息。在我看来，思维导图是学习和储存信息的最好(或最好)方法之一。</p><p id="ff0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将使用<a class="ae kv" href="http://freemind.sourceforge.net/wiki/index.php/Main_Page" rel="noopener ugc nofollow" target="_blank"> Freemind思维导图工具</a>。</p><p id="97b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解释这项技术，我将使用Python中的一个例子。我是一名计算机教授，当我教编程语言时，我总是和我的学生一起玩井字游戏。要检测每轮是玩家1还是玩家2赢，请运行以下算法:</p><p id="b2ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开始一个用零填充的3x3矩阵。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/0a4c7ee04167723d9727edff1eabd68e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*RZYGbAdB5D15uDiuZlUP_w.png"/></div></figure><p id="8fcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当参与人1行动时，我在单元格中写1。当参与人2行动时，我在单元格中写2。这是一个参与人1在主对角线上获胜的例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/d8a5ba8871678ff1aca5399604251ada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*9ulwPi_4B_p--cNbfTOzXA.png"/></div></figure><p id="cf4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要检测到参与人1赢了，在线、列和对角线上做乘积。如果结果是1，玩家1获胜；如果结果是8，玩家2获胜；如果结果是0、2或4，在这条线、列或对角线上没有人赢。</p><p id="dc22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这样，简单。</p><p id="ab45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是实现了算法的Python函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="0105" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数的编写方式我认为已经足够了:在行、列和对角线上的搜索被分解成主函数中的嵌套函数，它使用枚举来描述玩家和赢家。此外，这个算法中的早期回报(这可以被认为是一件坏事)不是一个问题——假设主要流程是简单可见和易于理解的。</p><p id="c9b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使是本文中描述的技术也是集中在复杂的算法上，不像这样写得很好。我选择这个例子是因为它更容易解释和理解。</p><p id="6038" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，打开代码和Freemind，我复制并粘贴代码，瞧！魔法结束了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/912079bbc052cf4bbf60298ab49c9dad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2WDZ84oRbaadrb3MkN_cyA.gif"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lx"><img src="../Images/0081b412d57d598d1191d745ff3e34ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CqUzF-bTnoTx3QVsQw8AVg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ly"><img src="../Images/d4d46a975db10275235a54c4b0494768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OkOG-YT8NUA4kJnM6-jeyw.png"/></div></div></figure><p id="7624" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Freemind会自动将标签识别为子节点，因此不带标签的代码放在第一个节点片上，第二个节点片上有一个标签，依此类推。</p><p id="342c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Python时，由于缩进是源代码的一部分，这就更容易了。但是在像C#这样的语言中，默认情况下大括号在语句下面的一行中，思维导图很难阅读，因为有很多大括号。</p><p id="3bb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像这样的工具<a class="ae kv" href="https://formatter.org/csharp-formatter" rel="noopener ugc nofollow" target="_blank">https://formatter.org/csharp-formatter</a>将格式化程序设置为Chromium，并将线宽设置为一个较高的值，会有所帮助。</p><p id="e326" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个例子:如果代码有不寻常的缩进(就像在Visual FoxPro中if语句很长)，开发人员通常会破坏if条件，使用分号，转到下面的行添加使用制表符，使代码与原始if对齐。在这种情况下，您需要手动调整思维导图中的节点。</p><p id="c4b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，这个例子很简单——函数很少，代码写得很好。但是想象一个代码，里面有<code class="fe lz ma mb mc b">if</code><code class="fe lz ma mb mc b">else</code><code class="fe lz ma mb mc b">for</code><code class="fe lz ma mb mc b">while</code><code class="fe lz ma mb mc b">try</code>，还有很多这些语句，还有变量的可变性等等。</p><p id="c409" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">IDE的概要并不总是有助于可视化代码。当你阅读一个if语句的内容时，你可能会忘记这个if语句是用什么结构写的。</p><p id="e5ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将代码放在思维导图结构中，您可以更容易、更有层次地将其可视化，这是一种读写代码的自然方式。</p><p id="e6c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，Freemind提供了许多工具:写笔记、着色、在节点之间创建链接、在节点周围绘制云等等。所有这些都可以用来帮助理解复杂的代码。</p><p id="5471" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这个提示能帮助你理解复杂的(不幸的是，很多时候是糟糕的)代码。开发人员花在阅读上的时间比写代码多得多。因此提高可读性一直是软件开发的目标。</p><p id="e9d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在理想情况下，这种技术是不必要的！总是试图写出好的代码。如果需要使用这种技术，可以提示重构是必要的。从Robert Martin的干净代码手册和理解函数式编程的概念是编写更好代码的良好起点。</p></div></div>    
</body>
</html>