<html>
<head>
<title>Solving the Transposition Challenge Looping Through the String Once</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在字符串中循环一次，解决变调挑战</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solving-the-transposition-challenge-looping-through-the-string-once-9997b4f0c24?source=collection_archive---------13-----------------------#2019-09-05">https://betterprogramming.pub/solving-the-transposition-challenge-looping-through-the-string-once-9997b4f0c24?source=collection_archive---------13-----------------------#2019-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="445d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">转置字符串中的两个字符，而不会失去理智</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4b5267795431c6743cd92f3cbab14ffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kddhm97ou9lsNHF2enLrRw.jpeg"/></div></div></figure><p id="5cd1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在某种程度上，每个人的脑海中都有一首歌(好的或坏的)，对我来说，这首歌就是我今天要写的编程问题。现在解决了，旋律也在我脑子里解决了，我想和你分享一下我的知识。</p><p id="d2ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将很快向您展示问题陈述，以及一些您可以运行代码的测试用例，然后我将向您展示我是如何摆脱这个问题的。</p><p id="85dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你对他们没有任何经验，可以看看这个关于deques 的<a class="ae ln" href="https://medium.com/better-programming/implementing-a-deque-in-ruby-cf6e9bfd9c3c" rel="noopener">教程。此外，我想说的是，你可以拿着我将要向你展示的东西进行实验，因为我相信它有许多令人兴奋的应用，如果你找到了，你可以随时在回复中给我留言。</a></p><p id="fe1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为本教程的附加内容，我将向您展示如何使用基准模块来测试您的算法的性能时间。</p><p id="a98f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们开始吧！</p><h1 id="d25c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">学习成果</h1><ul class=""><li id="f540" class="mg mh iq kt b ku mi kx mj la mk le ml li mm lm mn mo mp mq bi translated">能够使用队列对字符串进行排序</li><li id="c1a4" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">能够使用Ruby的基准模块测试代码性能</li></ul><h1 id="93a8" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">问题陈述</h1><p id="2f28" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">换位错误是指两个字母被调换，比如“hte”代替了“the”，或者“rign”代替了“ring”。给定一个字符串，你能修复每个出现“gn”的地方，使它变成“ng”吗？如果一行中有多个“g”，则“n”应该与第一个“g”交换。最终文本中不应该出现“gn”，所以要小心所有的可能性！</p><h1 id="f967" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">全额信贷</h1><p id="d913" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">尝试仅通过一遍课文来解决这个问题。</p><h2 id="e5fb" class="mz lp iq bd lq na nb dn lu nc nd dp ly la ne nf ma le ng nh mc li ni nj me nk bi translated">例子</h2><p id="9710" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">以下是三个测试案例:</p><ul class=""><li id="bb49" class="mg mh iq kt b ku kv kx ky la nl le nm li nn lm mn mo mp mq bi translated"><code class="fe no np nq nr b">puts transpose(‘he was searchign on Bign for signign kigns’)</code></li></ul><p id="3d63" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe no np nq nr b"><em class="ns">Expected Output =&gt; he was searching on Bing for singing kings</em></code></p><ul class=""><li id="6f51" class="mg mh iq kt b ku kv kx ky la nl le nm li nn lm mn mo mp mq bi translated"><code class="fe no np nq nr b"><em class="ns">puts transpose(‘rignadingdiggn!’)</em></code></li></ul><p id="b627" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe no np nq nr b"><em class="ns">Expected Output =&gt; ringadingdingg!</em></code></p><ul class=""><li id="e4cb" class="mg mh iq kt b ku kv kx ky la nl le nm li nn lm mn mo mp mq bi translated"><code class="fe no np nq nr b">puts transpose(‘gngngnnggnngggnnn’)</code></li></ul><p id="984a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe no np nq nr b"><em class="ns">Expected Output =&gt; nnnnnnnnngggggggg</em></code></p><p id="69e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看着问题陈述，我相信你已经想到了一些解决方案。让我们来看看一个非常简单的解决方案:</p><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="3f4c" class="mz lp iq nr b gy nx ny l nz oa">while string.include?('gn')<br/>  string.gsub!("gn", 'ng')<br/>end<br/>puts string</span></pre><p id="ad18" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个解决方案只是尽可能多次地遍历字符串，直到它消除所有“gn”的实例。如果您的字符串中有一个、两个甚至三个换位错误，这是一个完美的解决方案，但是如果错误数量增加，会发生什么呢？请看下面的片段:</p><p id="6dda" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe no np nq nr b">transposer(‘gngngnnggnngggnnngngngngngngngngngngngngngngngngngngngngngngngngngngngngngngnnnnnnnnnnnnnnggggggggggggggggggggggggggggggggggggggggggngngngngnnnnnnnnnngng’)</code></p><p id="8d12" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们对此进行基准测试，我们会看到运行时间增加了一倍多。想象一个大得多的测试案例，像一个完整的Microsoft Word文档，有许多换位错误，我们可以很快看到为什么暴力解决方案可能不是最可靠的。</p><p id="01af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我想了一会儿，在一张白纸上草草写了一些伪代码，就可以完成你将要看到的东西。</p><h1 id="003d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">解决办法</h1><h2 id="c1cf" class="mz lp iq bd lq na nb dn lu nc nd dp ly la ne nf ma le ng nh mc li ni nj me nk bi translated">步伐</h2><ul class=""><li id="e172" class="mg mh iq kt b ku mi kx mj la mk le ml li mm lm mn mo mp mq bi translated">在字符串中循环</li><li id="61ac" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">如果你到达一个g，把它推到一个deque的后面</li><li id="9dcc" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">如果你到达一个n，把它推到队列的前面</li><li id="451b" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">如果您找到的不是上面两个字符，将deque清空到结果中，然后将这个新字符添加到结果中</li><li id="b588" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">继续，直到到达字符串的末尾</li></ul><p id="07e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你第一眼看不明白这些步骤，没关系，当我们完成实现时，你会明白的。</p><p id="e4f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们写点代码吧！</p><p id="1228" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">出于本教程的目的，我不会解释dequee中的方法，除非我在关于<a class="ae ln" href="https://medium.com/better-programming/implementing-a-deque-in-ruby-cf6e9bfd9c3c?source=your_stories_page---------------------------" rel="noopener"> deques </a>的教程中没有谈到它们。</p><p id="7e3b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们设置我们的节点:</p><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="e675" class="mz lp iq nr b gy nx ny l nz oa">class Node<br/>  attr_accessor :value, :next_node, :prev_node<br/><br/>  def initialize(value, next_node = nil, prev_node = nil)<br/>    @value = value<br/>    @next_node = next_node<br/>    @prev_node = prev_node<br/>  end<br/>end</span></pre><p id="373b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">把节点放在一边，让我们为deque及其漂亮的方法编写代码。首先，像这样初始化队列:</p><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="2a71" class="mz lp iq nr b gy nx ny l nz oa">class Deque<br/>  def initialize<br/>    @first = Node.new(nil)<br/>    @last = @first<br/>  end<br/>end</span></pre><p id="1f4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们将<code class="fe no np nq nr b">pushFront</code>方法添加到deque:</p><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="345a" class="mz lp iq nr b gy nx ny l nz oa">def pushFront(number)<br/>  @first = Node.new(number, @first, nil)<br/>  @last = @first if @last and @last.value.nil?<br/>end</span></pre><p id="a9bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，<code class="fe no np nq nr b">popFront</code>:</p><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="f019" class="mz lp iq nr b gy nx ny l nz oa">def popFront<br/>  if @last == @first<br/>    @first = Node.new(nil)<br/>    @last = @first<br/>    return <br/>  end<br/>  @first = @first.next_node<br/>end</span></pre><p id="6ce6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，因为我们需要能够添加到数据结构的后面，我们需要一个<code class="fe no np nq nr b">pushBack</code>方法:</p><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="3b3a" class="mz lp iq nr b gy nx ny l nz oa">def pushBack(number)<br/>  self.pushFront(number) &amp;&amp; return if @first.value.nil?<br/>  @last.next_node = Node.new(number)<br/>  @last = @last.next_node<br/>end</span></pre><p id="19a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ns">注意:这个实现没有</em> <code class="fe no np nq nr b"><em class="ns">popBack</em></code> <em class="ns">方法，因为我们不需要它来解决这个问题。如果你想了解更多，看看这篇关于在Ruby中实现一个Deque的教程</em></p><p id="4e26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们要使用的下一个方法至关重要，所以请密切关注。请记住我们的伪代码中的这一步— <em class="ns">“如果您到达的不是上面两个字符，则将deque清空到结果中”。</em>好了，我们将在我们的deque中添加一个方法来帮助我们方便地完成它:</p><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="c5ed" class="mz lp iq nr b gy nx ny l nz oa">def empty_into(container)<br/>  current = @first<br/>  while current do<br/>    container &lt;&lt; current.value unless current.value == nil<br/>    self.popFront<br/>    current = current.next_node<br/>  end<br/>end</span></pre><p id="e0cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">分解一下:</p><ul class=""><li id="2d6e" class="mg mh iq kt b ku kv kx ky la nl le nm li nn lm mn mo mp mq bi translated"><code class="fe no np nq nr b">current = @first</code>当方法被调用时，简单地将我们的当前变量初始化为deque中的第一个节点。</li><li id="ab98" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated"><code class="fe no np nq nr b">while loop</code>允许我们一直循环到队列中的最后一个元素。只要<code class="fe no np nq nr b">current</code>为“真”，循环就会运行，在这种情况下不是<code class="fe no np nq nr b">nil</code>。</li><li id="242d" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">将当前节点的值添加到容器中</li><li id="1f3f" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated"><code class="fe no np nq nr b">self.popFront</code>从队列中删除当前节点，因为我们试图清空队列。</li><li id="df86" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated"><code class="fe no np nq nr b">current = current.next_node</code>简单地将当前变量的值更新到下一次迭代的队列中的下一个节点，以避免无限循环。</li></ul><p id="ddb2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还有一些方法可能对其他问题的解决有用，请务必查看我上面提到的关于deques的教程。</p><p id="88c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们成功了！是时候实现转置功能了。让我们把它分成三个主要部分:</p><ul class=""><li id="70ee" class="mg mh iq kt b ku kv kx ky la nl le nm li nn lm mn mo mp mq bi translated">初始化我们的队列和结果变量</li><li id="bbfd" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">循环我们的字符串并执行移调</li><li id="045b" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">返回结果</li><li id="6f41" class="mg mh iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated">额外收获:用基准模块测试我们代码的速度</li></ul><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="ecf8" class="mz lp iq nr b gy nx ny l nz oa">def transposer(string)<br/>  #initialize the deque<br/>  deque = Deque.new<br/>  #initialize the result variable<br/>  result = ''<br/>  <br/>  #Correctly define our loop<br/>  for i in 0..string.length do<br/>    #The rest of our code goes in here<br/>  end<br/>  <br/>  #Return our result<br/>  result<br/>end</span></pre><p id="5e12" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们把操作写在循环中。如果我们仔细观察伪代码的第二步到第四步，使用组合If语句来处理我们的检查是有意义的:</p><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="48eb" class="mz lp iq nr b gy nx ny l nz oa">if string[i] == 'g'<br/>  deque.pushBack(string[ i ])<br/>  next<br/>elsif string[i] == 'n'<br/>  deque.pushFront(string[ i ])<br/>  next<br/>else<br/>  deque.empty_into(result) unless deque.empty?<br/>end</span></pre><p id="182b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们检查“g”字符。如果我们遇到一个，我们把它推到德克后面。<code class="fe no np nq nr b">elsif</code>模块正在检查是否遇到‘n’字符。最后，如果我们遇到除了‘g’或‘n’之外的任何字符，<code class="fe no np nq nr b">else</code>块将把deque清空到结果字符串中。</p><p id="e6c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ns">注意:注意</em> <code class="fe no np nq nr b"><em class="ns">if</em></code> <em class="ns">和</em> <code class="fe no np nq nr b"><em class="ns">elsif</em></code> <em class="ns">块中的</em> <code class="fe no np nq nr b"><em class="ns">next</em></code> <em class="ns">语句。它们确保当找到“n”或“g”时，循环直接进入下一次迭代。</em></p><p id="d37b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，对于上面伪代码中概述的最后一步，如果字符串中的某个字符既不是“n”也不是“g”，我们只需将它附加到结果字符串中:</p><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="eedf" class="mz lp iq nr b gy nx ny l nz oa">if string[ i ] != 'g' &amp;&amp; string[i] != 'n' &amp;&amp; string[i]<br/>  result += string[ i ]<br/>  next<br/>end</span></pre><p id="8e21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，我们就在<code class="fe no np nq nr b">transpose</code>算法上打结了。接下来，我想向您展示为什么以及何时这种解决方案可能比暴力解决方案更可取。为此，Ruby内置了漂亮的基准测试模块。</p><p id="5b5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将以下代码片段添加到您的文件中的<code class="fe no np nq nr b">transpose</code>函数之后:</p><pre class="kg kh ki kj gt nt nr nu nv aw nw bi"><span id="39be" class="mz lp iq nr b gy nx ny l nz oa">Benchmark.bm(10000000) do |x|<br/>  x.report {puts transposer('gngngnnggnngggnnngngngngngngngngngngngngngngngngngngngngngngngngngngngngngngnnnnnnnnnnnnnnggggggggggggggggggggggggggggggggggggggggggngngngngnnnnnnnnnngng')}<br/>end</span></pre><p id="b34f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在在您的终端中运行代码。它应该运行几秒钟，最后显示运行算法10000000次所用的总时间。</p><p id="a10a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于暴力解决方案，该数字应该在0.001214左右徘徊，而对于我们的最佳解决方案，它应该在0.000376秒左右。我们可以看到强力解决方案的运行时间比最优解决方案的运行时间长得多。随着我们增加算法运行的次数，我们会注意到最优解的时间并没有增加很多，但是强力求解的时间一直在增加。这是因为强力解决方案的时间复杂度为O(n ),而我们的优化解决方案的时间复杂度为O(n)。</p><p id="0b69" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这篇教程对你有所帮助——下次再见！</p><h1 id="1dc7" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">资源</h1><p id="f162" class="pw-post-body-paragraph kr ks iq kt b ku mi jr kw kx mj ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">在<a class="ae ln" href="https://github.com/Oluwadamilareolusakin/transposition-interview-challenge" rel="noopener ugc nofollow" target="_blank">我的报告</a>中找到本教程的代码。</p><p id="7d85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要获得更多关于实现deques的教程，请查看<a class="ae ln" href="https://medium.com/better-programming/implementing-a-deque-in-ruby-cf6e9bfd9c3c" rel="noopener">在Ruby中实现deques</a>。</p></div></div>    
</body>
</html>