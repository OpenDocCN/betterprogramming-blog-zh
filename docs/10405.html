<html>
<head>
<title>Sending Data Between watchOS and iOS App Using Watch Connectivity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用手表连接在watchOS和iOS应用程序之间发送数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sending-data-between-watchos-and-ios-apps-cf924e21b3c2?source=collection_archive---------1-----------------------#2022-01-05">https://betterprogramming.pub/sending-data-between-watchos-and-ios-apps-cf924e21b3c2?source=collection_archive---------1-----------------------#2022-01-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0a88" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在SwiftUI iOS和watchOS应用程序之间建立沟通桥梁，以获取状态更新</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/af9013bd728140496fbcbddf4e0e23a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UMlEPrZI6VLtOOyXjJditQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://undraw.co/" rel="noopener ugc nofollow" target="_blank">未绘制</a></p></figure><p id="9e5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是上一篇文章的延续，上一篇文章展示了如何将watchOS应用目标添加到现有的iOS项目中。这一部分包括:</p><ul class=""><li id="81a0" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://developer.apple.com/documentation/watchconnectivity" rel="noopener ugc nofollow" target="_blank">手表连接</a>及其为iOS和watchOS应用程序之间的数据传输提供的方法。</li><li id="d057" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">配置并激活<code class="fe mg mh mi mj b">WCSession</code>实现iOS和watchOS应用之间的双向通信。</li><li id="f1ac" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">发送消息。</li><li id="6249" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">接收信息。</li></ul><p id="b00e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和以前一样，我在这个演示中使用Xcode13.2。</p><h1 id="0f5a" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">观察连接性</h1><p id="1819" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">为了在iOS应用和watch应用之间传输数据，我们需要使用<a class="ae kv" href="https://developer.apple.com/documentation/watchconnectivity/wcsession" rel="noopener ugc nofollow" target="_blank"> WCSession </a>:</p><blockquote class="nh ni nj"><p id="bc94" class="kw kx nk ky b kz la jr lb lc ld ju le nl lg lh li nm lk ll lm nn lo lp lq lr ij bi translated">启动WatchKit扩展与其配套iOS应用程序之间的通信的对象。</p></blockquote><p id="135b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi mj b">WCSession</code>提供了五种传输数据的方式，可用于将数据从iOS应用程序发送到watch应用程序，反之亦然。</p><ul class=""><li id="fa5c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe mg mh mi mj b"><a class="ae kv" href="https://developer.apple.com/documentation/watchconnectivity/wcsession/1615621-updateapplicationcontext" rel="noopener ugc nofollow" target="_blank">updateApplicationContext(_:)</a></code>可用于在计数器应用仅关心数据的最新状态时向计数器应用发送数据(例如:一天中完成的步数，用户将仅关心最新值)。此方法将覆盖以前的数据，因此只有最新的更新可用。</li><li id="4ac8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe mg mh mi mj b"><a class="ae kv" href="https://developer.apple.com/documentation/watchconnectivity/wcsession/1615687-sendmessage" rel="noopener ugc nofollow" target="_blank">sendMessage(_:replyHandler:errorHandler:)</a></code>当您需要立即传输字典数据时可以使用。Apple不保证这些信息的传递。对于要传递的消息，对方必须是可到达的。如果使用手表来发送数据，iOS应用程序将从后台唤醒并变得可访问，而手表应用程序则相反。</li><li id="3c44" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe mg mh mi mj b"><a class="ae kv" href="https://developer.apple.com/documentation/watchconnectivity/wcsession/1615617-sendmessagedata" rel="noopener ugc nofollow" target="_blank">sendMessageData(_:replyHandler:errorHandler:)</a></code>同上，但发送的是数据对象而不是字典。</li><li id="e5ce" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe mg mh mi mj b"><a class="ae kv" href="https://developer.apple.com/documentation/watchconnectivity/wcsession/1615671-transferuserinfo" rel="noopener ugc nofollow" target="_blank">transferUserInfo(_:)</a></code>用于在后台传输字典数据。这些消息保证以FIFO方式尽快传递，即使计数器应用程序暂停。</li><li id="14ec" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe mg mh mi mj b"><a class="ae kv" href="https://developer.apple.com/documentation/watchconnectivity/wcsession/1615667-transferfile" rel="noopener ugc nofollow" target="_blank">transferFile(_:metadata:)</a></code>用于传输带有文件元数据的图像和可选字典等文件。</li></ul><h1 id="3710" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">设置WCSession</h1><p id="5a57" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">您可以添加代码，直接在发送或接收数据的类中配置和激活一个<code class="fe mg mh mi mj b">WCSession</code>实例，但是这需要每个类都符合<code class="fe mg mh mi mj b">WCSessionDelegate</code>协议。因此，我们将在单例类中这样做。</p><p id="0d5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的Xcode项目中创建一个文件夹，并添加一个iOS应用程序目标和watch应用程序扩展目标都可以使用的新swift文件。</p><p id="2100" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将该文件命名为<code class="fe mg mh mi mj b">WatchConnectivityManager</code>，并添加了通常的单例代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/d710f654ea30250e075478153258c4ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Umq8tZxs6grpyD_5NQm5ZQ.png"/></div></div></figure><p id="6ba2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要配置和激活一个会话，您需要获取一个对默认会话对象的引用，给它分配一个委托并调用<code class="fe mg mh mi mj b">activate()</code>。</p><p id="df03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将在iOS和watchOS应用程序之间建立连接:</p><pre class="kg kh ki kj gt np mj nq nr aw ns bi"><span id="75cb" class="nt ml iq mj b gy nu nv l nw nx">if WCSession.isSupported() {<br/>    WCSession.default.delegate = self    <br/>    WCSession.default.activate()<br/>}</span></pre><p id="1234" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们将把这段代码添加到我们的WatchConnectivityManager的构造函数中，并添加与<code class="fe mg mh mi mj b"><a class="ae kv" href="https://developer.apple.com/documentation/watchconnectivity/wcsessiondelegate" rel="noopener ugc nofollow" target="_blank">WCSessionDelegate</a></code>协议的一致性。<code class="fe mg mh mi mj b"><a class="ae kv" href="https://developer.apple.com/documentation/watchconnectivity/wcsessiondelegate" rel="noopener ugc nofollow" target="_blank">WCSessionDelegate</a></code>协议继承自<code class="fe mg mh mi mj b"><a class="ae kv" href="https://developer.apple.com/documentation/objectivec/nsobjectprotocol" rel="noopener ugc nofollow" target="_blank">NSObjectProtocol</a></code>，这意味着<code class="fe mg mh mi mj b">WatchConnectivityManager</code>需要继承自<code class="fe mg mh mi mj b">NSObject</code>。</p><p id="541e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还要考虑的一点是，委托方法<code class="fe mg mh mi mj b">sessionDidBecomeInactive</code>和<code class="fe mg mh mi mj b">sessionDidDeactivate</code>在watchOS上不可用，因此我们需要为平台<em class="nk">(第22行)</em>添加一个编译器检查。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="49d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第25行激活一个会话，以防它被停用。如果用户拥有几块手表，并且我们需要支持手表切换，就会出现这种情况。</p><p id="3ac9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至此，您已经在watch应用程序和iOS应用程序之间建立了连接。接下来我们将看看发送和接收消息。</p><h1 id="1ef1" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">发送消息</h1><p id="5a46" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">为了演示的目的，我们将只发送一个简单的字符串从手表到iOS应用程序，反之亦然，每当用户点击一个“Hello World”按钮。</p><p id="5f66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi mj b">transferUserInfo(:_)</code>方法最适合我们的用例，但是根据<a class="ae kv" href="https://developer.apple.com/documentation/watchconnectivity/wcsessiondelegate/1615633-session" rel="noopener ugc nofollow" target="_blank">苹果文档</a>系统不会在模拟器上调用<code class="fe mg mh mi mj b">didReceiveUserInfo</code>委托方法。</p><p id="feb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们将无法在模拟器上对收到的这些信息做出反应。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/7792699f4b6c00b79d6d1a8a24ac40a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gu_1gVtgGSSJWz-CqjIbng.png"/></div></div></figure><p id="98cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我将使用<code class="fe mg mh mi mj b"><a class="ae kv" href="https://developer.apple.com/documentation/watchconnectivity/wcsession/1615687-sendmessage" rel="noopener ugc nofollow" target="_blank">sendMessage(_:replyHandler:errorHandler:)</a></code>来代替。</p><p id="4c3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们在<code class="fe mg mh mi mj b">WatchConnectivityManager</code>中添加一个功能，如果从iOS应用程序发送，则向手表发送一条简单的文本消息，反之亦然。不要忘记检查您是否有活动的会话和配对的设备。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="3fa8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在在内容视图中添加一个按钮来调用这个函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="792f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们编写代码来接收消息并测试它是否工作。</p><h1 id="845a" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">接收消息</h1><p id="e195" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">为了接收使用<code class="fe mg mh mi mj b"><a class="ae kv" href="https://developer.apple.com/documentation/watchconnectivity/wcsession/1615687-sendmessage" rel="noopener ugc nofollow" target="_blank">sendMessage(_:replyHandler:errorHandler:)</a></code>方法发送的消息，我们需要实现来自<code class="fe mg mh mi mj b">WCSessionDelegate</code>协议的<code class="fe mg mh mi mj b">session(_:didReceiveMessage:)</code>方法。</p><p id="8601" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们收到消息，我们可以在主线程上将它作为一个发布变量存储在<code class="fe mg mh mi mj b">WatchConnectivityManager</code>中，因为我们应该总是确保我们在主线程上发布。</p><p id="acdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们的内容视图将观察这个变量的变化，并在状态变化时显示一个弹出警告。</p><p id="6c63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi mj b">WatchConnectivityManager</code>中的最终代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f029" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们添加代码来观察内容视图中通知消息的变化。在内容视图中，我们将为<code class="fe mg mh mi mj b">WatchConnectivityManager</code>添加<code class="fe mg mh mi mj b">ObservedObject</code>变量。</p><pre class="kg kh ki kj gt np mj nq nr aw ns bi"><span id="08f1" class="nt ml iq mj b gy nu nv l nw nx">@ObservedObject <strong class="mj ir">private</strong> <strong class="mj ir">var</strong> connectivityManager = WatchConnectivityManager.shared</span></pre><p id="d77e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们将从<code class="fe mg mh mi mj b">watchConnectivityManager</code>绑定<code class="fe mg mh mi mj b">notificationMessage</code>到警报。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="1d35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当你在手机和手表上运行应用程序并点击“Hello World！”按钮，您将在柜台应用程序上看到警告。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/1f81566c8b521313bcd71cfcf940677c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uap_ASOoQdDweTBjrYfBmQ.png"/></div></div></figure></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="d524" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，你有了一个既可以在手表上运行又可以在手机上运行的应用程序，可以在手机和手表之间来回发送数据，以更新用户界面和显示通知。希望这对你有帮助。</p><p id="6426" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编码快乐！</p></div></div>    
</body>
</html>