<html>
<head>
<title>How to Automatically Detect External Links in a Paragraph of Text With JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript自动检测一段文本中的外部链接</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/detecting-external-links-in-a-paragraph-of-text-with-javascript-automatically-3c15537f4997?source=collection_archive---------5-----------------------#2020-03-03">https://betterprogramming.pub/detecting-external-links-in-a-paragraph-of-text-with-javascript-automatically-3c15537f4997?source=collection_archive---------5-----------------------#2020-03-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5d0e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">避免明文中的虚假URL匹配</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/52bf9bd7f64b90e5cefa56e85179b5b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q37Cr9lNT7hlc3Yx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@sapegin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Artem Sapegin </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="13c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查一个字符串是否是有效的URL本身就是一门科学。regex验证方法的最终来源是检测有效的URL，而不是错误地匹配不是真正有效的URL，<a class="ae ky" href="https://mathiasbynens.be/demo/url-regex" rel="noopener ugc nofollow" target="_blank">很长，对于初次浏览者来说，非常复杂</a>。关于StackOverflow上URL检测的问题也是如此——人们对这些问题有相当大的兴趣。</p><p id="2ae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我没有看到详细解释的是一个易于实现的JavaScript解决方案，例如，如何在用户简档描述或用户之间发送的消息中获取几段文本，并自动检测该文本中的所有URL——特别是在您根本不知道是否有任何URL或它们在文本中的位置时。</p><p id="d134" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一些网站上有解决这个问题的好方法，但是我很确定没有完美的解决方法。这是我们在vue.js中实现的JavaScript函数。它在99%以上的情况下都有效，更重要的是，它不匹配非URL。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/1f1d6c9060bcef11f46d8bb3930e5362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Ie2DQp7HdYuQDkRagxDag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">此算法如何检测链接的屏幕截图</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="910a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">我们需要一个URL检查正则表达式</h1><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="96d7" class="na me it mw b gy nb nc l nd ne">$_HelperFunctions_modifyTextForLinks: function(textToCheck) {<br/> <br/>  var expression = /(https?:\/\/)?[\w\-~]+(\.[\w\-~]+)+(\/[\w\-~@:%]*)*(#[\w\-]*)?(\?[^\s]*)?/gi;</span><span id="3cad" class="na me it mw b gy nf nc l nd ne"> //*more code to follow here</span><span id="9ad9" class="na me it mw b gy nf nc l nd ne">}</span></pre><p id="8759" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不是正则表达式大师，我也不认为你需要成为一个。您只需要知道这个正则表达式匹配带有HTTP、HTTPS或不带eithre的URL。它还匹配以www .开头的URL。或者没有它，比如epiloge.com这样的短网址和<a class="ae ky" href="http://epiloge.com/terms" rel="noopener ugc nofollow" target="_blank">epiloge.com/terms</a>这样的深度路由。此外，它还可以匹配初始域名后带有@的URL，如<a class="ae ky" href="http://www.epiloge.com/@axel-wittmann." rel="noopener ugc nofollow" target="_blank">www.epiloge.com/@axel-wittmann</a>。</p><p id="eea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，一切顺利。让我们继续实际检查一段文本。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="26f3" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">一个While循环来检查我们是否得到了任何匹配</h1><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="7b93" class="na me it mw b gy nb nc l nd ne">var regex = new RegExp(expression);<br/>var match = ''; var splitText = []; var startIndex = 0;</span><span id="490c" class="na me it mw b gy nf nc l nd ne">while ((match = regex.exec(textToCheck)) != null) {<br/>        <br/>   splitText.push({text: textToCheck.substr(startIndex, (match.index - startIndex)), type: 'text'});<br/>               <br/>   var cleanedLink = textToCheck.substr(match.index, (match[0].length));<br/>   cleanedLink = cleanedLink.replace(/^https?:\/\//,'');<br/>   splitText.push({text: cleanedLink, type: 'link'});<br/>                <br/>   startIndex = match.index + (match[0].length);               <br/>}<br/>if (startIndex &lt; textToCheck.length) splitText.push({text: textToCheck.substr(startIndex), type: 'text'});</span><span id="8bde" class="na me it mw b gy nf nc l nd ne">return splitText;</span></pre><p id="87e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些代码看起来可能很复杂，但实际上并不复杂。它所做的只是遍历一段文本，并检查是否有匹配的正则表达式(我们假定的URL)。如果找到匹配，它会将链接前的任何文本放入一个数组中，表明它属于类型<code class="fe ng nh ni mw b">text</code>，同时将链接作为一种类型的链接放入数组中(为了一致性，删除HTTP或HTTPs)。它一直持续到检查完整个文本。</p><p id="44b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们到达段落的末尾时，末尾的任何文本也作为文本被推入数组。</p><p id="5cb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经做好准备，能够以我们喜欢的任何方式在我们的网站或本机应用程序中显示我们的数组。你可以遍历它，在一个<code class="fe ng nh ni mw b">&lt;span&gt;</code>中显示普通文本，而在一个<code class="fe ng nh ni mw b">&lt;a href=”link”&gt;</code>标签中显示一个链接。或者，如果你更喜欢Vue中的<code class="fe ng nh ni mw b">render</code>或者一个不同的HTML构造函数，你可以使用它。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="10d1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">句子之间不放空格的用户怎么办？</h1><p id="8470" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在本文的开头，我说过这个问题没有完美的解决方案，我们的解决方案适用于大多数用例。我知道，在寻找一个好的、即使不是完美的解决方案的问题上，我们并不孤独。如果你是LinkedIn的会员，试着用不同的网址给别人发信息。你会看到他们的算法没有检测出各种不太知名的顶级域名，如<a class="ae ky" href="http://www.google.nz" rel="noopener ugc nofollow" target="_blank"> www.google.nz </a>。这是故意的，因为将<code class="fe ng nh ni mw b">supermarket.Lots</code>匹配为“<em class="no">我要去超市”中的URL会更糟糕。那里有很多好橘子，而不是没有。nz匹配。</em></p><p id="0679" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免错误匹配，最好拿出<a class="ae ky" href="https://www.icdsoft.com/blog/what-are-the-most-popular-tlds-domain-extensions/" rel="noopener ugc nofollow" target="_blank">一个最常用的顶级域名列表</a>，用它们来检查你匹配的URL是否真的是一个URL。毕竟，我们想要一个好的解决方案，而不是一个完美的方案。我们挑选了以下几个:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="e165" class="na me it mw b gy nb nc l nd ne">var topDomains = [/\.com/, /\.de/, /\.org/, /\.net/, /\.us/, /\.co/, /\.edu/, /\.gov/, /\.biz/, /\.za/, /\.info/, /\.cc/, /\.ca/, /\.cn/, /\.fr/, /\.ch/, /\.au/, /\.in/, /\.jp/, /\.be/, /\.it/, /\.nl/, /\.uk/, /\.mx/, /\.no/, /\.ru/, /\.br/, /\.se/, /\.es/, /\.at/, /\.dk/, /\.eu/, /\.il/];</span></pre><p id="72a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您唯一需要做的就是循环遍历这些域，以排除所有不匹配的URL:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="2089" class="na me it mw b gy nb nc l nd ne">var abort = true;<br/>for (var i=0; i &lt; topDomains.length; i++) {<br/>   domainMatch = match[0].match(topDomains[i]);<br/>   if (domainMatch) {<br/>       urlLength = domainMatch[0].length + domainMatch.index;<br/>       if (match[0].length == urlLength) abort = false;<br/><br/>       if (match[0].length &gt; urlLength) {<br/>          if (match[0].substr(urlLength, 1) == ‘/’) abort = false;<br/>       } <br/>    }<br/> }</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1c64" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">电子邮件地址呢？</h1><p id="2e1b" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">用户有时会在文本中包含他们的电子邮件地址。你不要在“axel.wittmann@epiloge.com”中匹配“epiloge.com”。从匹配项中排除电子邮件地址的一个简单方法是在匹配的潜在URL (match.index是匹配的URL的第一个字符的位置)前加入一个abort语句，该语句忽略所有带有@的匹配项。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="ccc7" class="na me it mw b gy nb nc l nd ne">if ((match.index != 0) &amp;&amp; (textToCheck[match.index - 1] == '@')) { <br/>    abort = true;<br/>}</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0eaf" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">如果有人在你的链接后使用问号怎么办？</h1><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="6122" class="na me it mw b gy nb nc l nd ne"><br/>if ((match.index != 0) &amp;&amp; (textToCheck[match.index + match[0].length - 1] == '?')) { <br/>     match[0] = match[0].substr(0, match[0].length - 1); <br/>}</span></pre><p id="f888" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有人提出一个问题，并在末尾包含一个链接，该怎么办？这种情况下的问题是，URL实际上可以在有效链接中包含问号——这对于链接来说很常见。所以你不要排除这样的匹配。</p><p id="1cba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，想想下面这句话:“<em class="no">你有没有看到www.medium.com/article?</em>的那篇新文章《你不想也配吗？”或者更糟的是问号后面的任何东西。上面的代码检查。如果它是匹配的URL中的最后一个字符，就从匹配中删除它。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d75c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">你可以想出更多这样的排除</h1><p id="9e52" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">你可以在这里查看我们用来循环段落的整个函数<a class="ae ky" href="https://www.epiloge.com/detecting-external-links-in-a-paragraph-of-text-with-javascript-automatically-b1db50" rel="noopener ugc nofollow" target="_blank"/>。如果你的用例与我们的相似，如果你不能直接插入我们的代码并轻松地让它在你的网站上工作，我会感到很惊讶。</p><p id="e219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是一个完美主义者，并且知道更多错误匹配或有效URL不匹配的边缘情况，你总是可以包含更多的排除，甚至修改正则表达式。</p><p id="8e8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这个简短的解释对自己项目中面临这个普遍问题的人有用。感谢阅读！</p></div></div>    
</body>
</html>