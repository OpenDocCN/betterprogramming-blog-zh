# 在 C++中使用线程和互斥体的 4 个简单技巧

> 原文：<https://betterprogramming.pub/4-easy-tips-on-using-threads-and-mutexes-in-c-566eb2927152>

## C++程序中更好的线程

![](img/662d8882555623104145ab712ee6415a.png)

约翰·巴克利普在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片。

C++是一种很棒的编程语言，通常与快速性能、自定义内存管理和指针联系在一起。然而，该语言中一些最重要但很少被提及的组件是线程和互斥体。也许 C++最强大的特性之一是对多个并发线程的执行拥有广泛的控制和精度，并在这些线程之间安全地共享资源。你现在正在浏览的网页浏览器使用多线程来促进多个动作或同时显示。

在本文中，我将介绍在 C++中使用线程和互斥体的四个技巧。这里讨论的接口是该语言的 C++11 标准中定义的接口。在 C++11 之前，线程没有在语言中正式定义，只能使用特定于操作系统的线程接口，比如 posix 线程。

# 1.线不是一次性的——你必须把它们重新连在一起！

多线程新手常犯的一个错误是认为传递给正在创建的新线程的函数类似于调用另一个函数。不是的。下面我们来看看这个看似良性的程序:

您可能会想，“这段代码只是工作并打印出几条消息。”不对。它真的崩溃了！

```
terminate called without an active exception
exited, aborted
```

在上面的打印输出中，`terminate`是对 C++ `std::terminate()`函数的引用，该函数由运行时在几种危险情况下调用。在这种情况下，我们正在启动一个执行线程，但是我们没有加入它。你必须加入线程来保持程序同步，并维持任务的调度和执行顺序。在这个程序中加入`t1.join();`可以让它像预期的那样工作。

# 2.当线程应该关闭时，使用标志向线程发出信号

生成多线程的另一个潜在问题是当一个线程无限重复相同的函数或事件循环时。许多线程在实现时都考虑到了角色，在整个程序过程中，它们通常会一遍又一遍地重复任务列表。你不能直接`join()`一个无限循环中的线程，因为 join 调用会导致父线程永远等待。联接仅适用于可以到达工作终点的线程。

为了正确地关闭这样的线程，您将需要一个全局标志—理想情况下是一个布尔值—由线程检查以确定它们是否应该继续运行。从 C++11 开始，全局范围的变量被认为是线程安全的，可以被访问和修改。在这种情况下，只有父主线程可以修改布尔值，而派生的线程只能读取该值。因此，其示例代码可以编写如下:

添加语句`std::this_thread::sleep_for(std::chrono::milliseconds(100))`是为了表明当运行程序时，产生的线程做一些初始工作，但是通过读取`KEEP_GOING`已经被设置为`false`来结束它的执行。与进程不同，线程没有内置的停止运行的信号机制。所以像这样的设计模式对于线程关闭是至关重要的。

# 3.当线程访问共享资源和数据时，使用互斥体

在许多多线程程序和设计中，线程需要读取、写入数据，并与其他线程交换数据。线程可以共享不属于每个线程的任何资源。所以在一个线程的堆栈上分配的变量和对象将不能被其他线程访问。全局对象，或者指向传递到线程初始“主”函数中的对象的指针，可以被多个线程访问。然而，要有一个功能完整、没有错误的程序，您需要确保线程安全地共享资源。如果一个线程读取一个资源，比如一个数组或一块内存，而另一个线程向它写入，这将导致数据损坏。

有许多工具和技术可以用来实现安全的资源共享，但是最直接的工具是互斥。互斥体是一个具有特定于硬件和系统的实现的对象，它允许一个线程获得一个“锁”当线程持有互斥体时，其他试图获取互斥体的线程将停止或阻塞获取调用。这意味着在持有互斥体的线程当前解锁之前，其他线程不能继续锁定互斥体。C++11 标准定义了一种叫做`std::mutex`的跨平台类型，可以被不同的线程锁定或解锁。就像做一样简单:

尽管这些代码确实锁定和解锁了互斥体，但是通常不推荐直接调用互斥体上的方法——比如`lock`和`unlock`方法。这是因为一旦`.unlock()`被调用，任何等待该互斥体的线程都将被允许访问在`lock`和`unlock`语句之间的那部分代码。此外，`.unlock()`语句之前的`return`语句将导致互斥锁永远锁定，这是非常危险的情况。

利用互斥体最常见的方式是使用 RAII 样式的对象，该对象在作用域的顶部构造，在最后销毁。对于 C++11，标准库提供了一种叫做`std::lock_guard`的东西。在 C++17 中，有一个更好的类叫做`std::scoped_lock`，它是一个 RAII 对象，可以在一个作用域中一次锁定多个互斥体。使用 RAII 作用域方法锁定互斥体的优点是，当作用域结束时，解锁被处理，因此您不必担心语句的顺序，也不必显式调用`.unlock()`。

对于这个例子，两个不同的线程将从一个数组中读取和写入值，这个数组将由一个互斥体保护。一个线程将扮演作者的角色，而另一个线程将扮演读者的角色。像以前一样，线程将通过一个全局标志来控制。让我们来看看完整的代码:

您可能注意到的第一件事是传递`Point`对象的值。通常，在 C++中，当访问向量或数组的元素时，会通过引用传递。然而，一旦在作用域顶部带有锁保护的`any`函数返回，互斥体就会被解锁。您不能安全地返回由多个线程直接共享的资源的指针或引用。这是因为获得一个指针并不能保证阻止其他线程改变它所指向的值。那只由互斥体控制。

在上面的例子中，您可能会注意到几个`sleep_for`调用。这些并不是使代码工作所必需的，但是使用它们并改变它们的周期可以帮助可视化线程工作，进入睡眠，然后再次醒来。如果您运行此程序，并仅缩短编写器线程的睡眠时间，您可能会看到如下模式:

```
x=55 y=55
x=56 y=56
x=57 y=57
x=58 y=58
x=59 y=59
x=80 y=80
x=81 y=81
x=82 y=82
x=83 y=83
x=84 y=84
x=85 y=85
```

打印出来的东西有一处漏印了！但这不是 bug。如果读线程休眠的时间比写线程长，这意味着写线程在读线程休眠时有时间工作。这意味着当 reader 线程醒来时，数组中的值已经超过了它最后一次读取它们的时间点，使得它的观察不再是连续的。当两个睡眠期相等时，你应该不会看到这种情况发生。

# 4.当心硬件对并发线程的限制

在任何 CPU 上，并发运行的线程数量都是有限制的。尽管复杂的 C++程序可能有数百个线程，但它们肯定不会同时运行。运行字面上的意思是在当前时刻执行机器指令。因此，需要许多线程的程序将它们设计成以这样一种方式工作，即工作不总是精确地同时进行，而是分散进行，以最大化吞吐量和性能。

作为一个概念，平台上并发线程的数量是由 CPU 内核的数量决定的。例如，我目前使用的笔记本电脑配有 2.7 GHz 四核英特尔酷睿 i7 处理器。因此，我有四个内核，最多可以同时运行四个线程。用于运行服务器的机器，比如云计算产品中的机器，通常比你的个人电脑拥有更多的内核。

C++11 提供了一个静态接口来检查可能的并发线程数，如下例所示:

正如我所料，结果是:

```
The number of concurrent threads is 4
```

该值通常在实现线程池时很有用，线程池是一种设计，在这种设计中，线程连续运行一个循环来检查资源，如要执行的作业队列。在线程池中，使用超过硬件支持的并发线程数通常不会有什么好处。一般来说，检查硬件并发限制是一种以硬件为中心的设计。

现代 C++有许多组件，如原子变量和内存栅栏，为多线程程序提供了优化，但只针对特定的硬件架构。