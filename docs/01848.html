<html>
<head>
<title>Adventuring Into React Hooks Performance Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索React Hooks性能实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/adventuring-into-react-hooks-performance-practices-77a23825a946?source=collection_archive---------5-----------------------#2019-10-17">https://betterprogramming.pub/adventuring-into-react-hooks-performance-practices-77a23825a946?source=collection_archive---------5-----------------------#2019-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4178" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">性能陷阱以及如何避免它们</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/df03138430afd92d235716fc1aa213ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mH64FyEHDw9z-2xC"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@rockthechaos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kolleen Gladden </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="520c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从16.8.0版本开始，React向我们介绍了一种不用写类就能使用状态和其他React特性的方法— <a class="ae kv" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React Hooks </a>。</p><p id="043f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是对经典类范式的惊人改进，它允许我们在组件之间重用有状态逻辑。毫不奇怪，它有一个学习曲线，可能会导致性能陷阱。</p><p id="887d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们深入探讨最常见的问题，并尝试找出如何避免它们。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ba20" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">重新渲染物质</h1><p id="4373" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">好的，我们发现在使用钩子时可能会遇到一些性能问题，但是这些问题来自哪里呢？</p><p id="499e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本质上，钩子的大部分问题来自于组件不必要的渲染。看看下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6529" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个组件，它有两个状态，A和B，以及四个增量动作。我添加了<code class="fe my mz na nb b">console.log</code>方法来查看每次渲染的消息。前两个动作是基本的增量，只是将A或B值增加1。</p><p id="57b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们点击<em class="nc"> a++，b++ </em>按钮，看看控制台:每次点击，应该只有一个渲染。这真的很好，因为这正是我们想要的。</p><p id="b39a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在1s后按下<em class="nc"> a++，b++</em>按钮:每次点击，你会看到两次渲染。如果你想知道下面发生了什么，答案很简单。</p><p id="8423" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React将同步状态更新批处理为一个。</p><p id="6505" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，对于异步函数，每个<code class="fe my mz na nb b">setState</code>函数触发一个render方法。</p><p id="f6d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果你想有一致的行为呢？钩子的第一条规则来了。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="bd57" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">规则1:对于连接的数据模型，不要在几个useState方法之间分割状态</h1><p id="42fc" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">想象你有两个独立的国家。然后，需求改变了，因此一个状态的更新导致另一个状态的更新。</p><p id="2eaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，你必须把它们加入一个对象:<code class="fe my mz na nb b">const { A, B } = useState({ A: 0, B: 0})</code>。或者，利用<code class="fe my mz na nb b"><a class="ae kv" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">useReducer</a></code>功能。</p><p id="6956" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个规则的另一个很好的例子是数据加载。通常，你需要三个变量来处理它:<code class="fe my mz na nb b">isLoading</code>、<code class="fe my mz na nb b">data</code>和<code class="fe my mz na nb b">error</code>。不要试图将它们分开，而是更喜欢<code class="fe my mz na nb b">useReducer</code>。</p><p id="87eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它允许您将状态逻辑从组件中分离出来，并帮助您避免错误。拥有一个具有这三种属性的对象也是一种解决方案，但不会那么显式和容易出错。</p><p id="0227" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相信我，我见过很多人忘记将<code class="fe my mz na nb b">isLoading: false</code>设定为错误。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6073" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">定制挂钩</h1><p id="c8d3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">既然我们已经知道了如何在单个组件中管理<code class="fe my mz na nb b">useState</code>，让我们将增量功能移到不同的地方使用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd mx l"/></div></figure><p id="c0ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将增量逻辑重构到它自己的钩子上，然后使用<code class="fe my mz na nb b"><a class="ae kv" href="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank">useEffect</a></code>函数运行一次。</p><p id="d007" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们必须在依赖数组中提供<code class="fe my mz na nb b">incrementA</code> setter，因为我们在内部使用它，并且它是由<a class="ae kv" href="https://www.npmjs.com/package/eslint-plugin-react-hooks" rel="noopener ugc nofollow" target="_blank"> Hook的ESLint规则</a>强制执行的。(如果您之前没有启用它们，请启用它们！).</p><p id="6845" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你尝试渲染这个组件，你的页面将会因为无限的重新渲染而被冻结。为了解决这个问题，我们需要定义钩子的第二个规则。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="fedb" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">规则二。确保只有当新对象发生变化时，才从自定义钩子返回新对象</h1><p id="7eec" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">上面的组件总是被重新渲染，因为<code class="fe my mz na nb b">increment</code>钩子每次都返回一个新函数。为了避免每次都创建一个新函数，将它包装在<code class="fe my mz na nb b"><a class="ae kv" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">useCallback</a></code>函数中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd mx l"/></div></figure><p id="5206" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在使用这个钩子是安全的。</p><p id="39e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时，您需要从自定义钩子返回一个普通对象，确保您只在它的内容改变时使用<code class="fe my mz na nb b"><a class="ae kv" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">useMemo</a></code>更新它。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b6cd" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">如何在为时已晚之前找到这些重新渲染？</h1><p id="9d31" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">通常，在导致性能问题之前发现这些问题是很麻烦的，所以您必须使用特定的工具来预先检测它们。</p><p id="32f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中之一是<code class="fe my mz na nb b"><a class="ae kv" href="https://github.com/welldone-software/why-did-you-render" rel="noopener ugc nofollow" target="_blank">why-did-you-render</a></code>库，它告诉你可避免的重渲染。将您的组件标记为<code class="fe my mz na nb b">MyComponent.whyDidYouRender = true</code>，开始与它交互，并在控制台中寻找消息。</p><p id="d59b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我保证你会在接下来的五分钟内发现新的东西。</p><p id="311d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个选择是使用<a class="ae kv" href="https://github.com/facebook/react/tree/master/packages/react-devtools" rel="noopener ugc nofollow" target="_blank"> React Dev工具扩展</a>中的<em class="nc">分析器</em>选项卡。尽管您必须考虑您期望组件进行多少次重新渲染，但是该选项卡只显示了重新渲染的次数。</p><p id="c51c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我知道你还遇到过哪些关于钩子的挑战，让我们一起解决它们。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="62ad" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">参考资料和更多资源</h1><ul class=""><li id="e977" class="ne nf iq ky b kz mr lc ms lf ng lj nh ln ni lr nj nk nl nm bi translated"><a class="ae kv" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank"> React钩子API </a>。</li><li id="6a40" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><a class="ae kv" href="https://kentcdodds.com/blog/profile-a-react-app-for-performance" rel="noopener ugc nofollow" target="_blank">如何使用开发工具评测器评测React应用</a>。</li></ul></div></div>    
</body>
</html>