<html>
<head>
<title>Monads for Free in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的免费单子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/monads-for-free-in-swift-6a5246d0ef4b?source=collection_archive---------4-----------------------#2021-11-12">https://betterprogramming.pub/monads-for-free-in-swift-6a5246d0ef4b?source=collection_archive---------4-----------------------#2021-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2aab" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用预定义的符号编写工作流，并在以后对其进行解释</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/007a365de9ce3de50f94cc5ca71d73b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*92_9iEvRNKoBVNCc"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">布鲁诺·马丁斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="70ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我刚刚发现了一些惊人的事情:实际上有一种方法可以以一种相对通用的方式将免费的单子和单子解释器带到Swift！</p><p id="15bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等等……什么？</p><p id="cc64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许让我们从头开始。什么是单子？</p><p id="f830" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">monad只是一个泛型类型(想想:<code class="fe ls lt lu lv b">Optional</code>或<code class="fe ls lt lu lv b">Array</code>)，有一个非常特殊的接口。具体来说，有三个要求:</p><ol class=""><li id="5025" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">需要有一种方法将“普通”值提升到一元上下文中。</li><li id="f8d4" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">需要一种用“纯”函数转换一元值的方法。</li><li id="9b56" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">需要一种用“一元”函数转换一元值的方法。</li></ol><p id="ca8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，与其指出上述术语的确切含义，不如让我给你一个有效单子的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="5b03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是怎么回事？</p><p id="b673" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">MyMonad</code>所做的是:它使它的一般值T依赖于Env(在这个例子中，它只是一个占位符类型，但也可能包含有意义的信息)。</p><p id="7c25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，函数<code class="fe ls lt lu lv b">pure</code>表达了一个事实上不依赖于Env的值。方法<code class="fe ls lt lu lv b">map</code>接受您计算的任何值(取决于Env)并对其应用纯函数<code class="fe ls lt lu lv b">transform</code>。最后，方法<code class="fe ls lt lu lv b">flatMap</code>使得在“一元工作流”中的任意点多次依赖Env成为可能。</p><p id="4352" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，<code class="fe ls lt lu lv b">Optional</code>和<code class="fe ls lt lu lv b">Array</code>暴露的正是这个接口。不幸的是，Swift的类型系统不够强大，不足以写下一个“单子协议”，但它是你有时会看到的模式。如果你熟悉单子，你可能已经认识到上面的<code class="fe ls lt lu lv b">MyMonad</code>例子是读者单子。如果你关注Haskell，你可以在这里阅读更多关于这个<a class="ae kv" href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html" rel="noopener ugc nofollow" target="_blank">的内容</a>。</p><p id="43d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单子需要满足一些定律。基本上，它必须使用简单函数形成一个类别(通常的身份作为<code class="fe ls lt lu lv b">map</code>下的身份)，它必须使用一元箭头(通过<code class="fe ls lt lu lv b">flatMap</code>形成一个类别，其中<code class="fe ls lt lu lv b">pure</code>必须扮演身份箭头的角色。你不必真的理解这一点就能理解文章的其余部分。这里有一个<a class="ae kv" href="https://mokacoding.com/blog/functor-applicative-monads-in-pictures/" rel="noopener ugc nofollow" target="_blank">来源</a>。对于高级读者，查看<a class="ae kv" href="https://bartoszmilewski.com/2016/12/27/monads-categorically/" rel="noopener ugc nofollow" target="_blank">单子分类</a>指南。</p><p id="e84a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，单子有什么用呢？</p><p id="094d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，他们隐藏了一些样板文件，这通常是可取的。但更重要的是，它们编码了副作用！</p><p id="36bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你坚持不做任何副作用的约定，除非你以某种方式将它编码在单子中，你可以从函数的签名中准确地推断出它会有什么副作用，例如，读取一些<code class="fe ls lt lu lv b">Env</code>值或者可能失败或者做一些异步工作。事实上，抛出函数或异步函数可以被看作是形成一个单子。</p><h1 id="ca71" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">自由单子</h1><p id="7bd4" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">现在让我们转到自由单子。单子的一个严重问题是它们很难组合。给定两个单子，得到一个超级单子的通常方法是使用一个模糊的概念，叫做“单子变换器”。</p><p id="f813" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法的一个大问题是，通过单子转换器获得的“超级单子”取决于组合的顺序:<code class="fe ls lt lu lv b">Array[T]?</code>与<code class="fe ls lt lu lv b">Array[T?]</code>完全不同，单子转换器(它实际上只是提供了一点语法糖，使处理那些“单子堆栈”更容易)不会改变这一点。</p><p id="b540" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是实际上有一种更“平等”的方式来组合单子。好吧，至少如果你把自己限制在某种(非常有用的)单子类型上。</p><p id="2dba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实证明，有一种非常通用的方法可以“按需”构造单子。实际上，你可以使用任何“足够通用”的类型作为单子的基础:自由单子。</p><p id="91a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">废话少说，举例子时间到了！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="a7db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到的是类型级的单子:虽然我们没有一个单一的泛型类型充当单子，但是<code class="fe ls lt lu lv b">Symbol</code>协议本身有。</p><p id="bea4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们可以将只涉及有效<code class="fe ls lt lu lv b">Symbol</code>的任意计算序列链接起来，只要它们的含义与链中下一个函数的预期含义相匹配。</p><p id="5e56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是符号及其含义的具体示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="1b15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，这很好，但是我们能拿这些做什么呢？</p><h1 id="16e7" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">我们可以解读！</h1><p id="a1de" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="e245" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我们没有使<code class="fe ls lt lu lv b">Nothing</code>符合<code class="fe ls lt lu lv b">PureInterpretable</code>。这种一致性在一般情况下是不可能的。不过，有人可能会去T2。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="5fd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">tryInterpret</code>对于<code class="fe ls lt lu lv b">Map</code>和<code class="fe ls lt lu lv b">FlatMap</code>的实现其实和<code class="fe ls lt lu lv b">interpret</code>非常相似。其实就是一种模式。我们可以仅根据目标单子的<code class="fe ls lt lu lv b">flatMap</code>和映射方法来表达任意单子中<code class="fe ls lt lu lv b">Map</code>和<code class="fe ls lt lu lv b">FlatMap</code>的实现(或者仅使用<code class="fe ls lt lu lv b">flatMap</code>和pure，其中我们不映射纯函数，而是人为地将返回值包装到目标单子上下文中)。</p><p id="4feb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">唯一改变的是解释方法和目标单子的名称。我没有试过，但是应该可以通过codegen管理这个样板文件。</p><p id="14f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，让我们看看如何将符号的工作流编译成更有趣的东西。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="bacd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Map</code>和<code class="fe ls lt lu lv b">FlatMap</code>的一致性开始变得熟悉:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="32b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是对我们基本符号类型的一种可能的解释:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="4c02" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">结论</h1><p id="4eb2" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">使用上面的模式，可以用预定义的符号编写工作流，并在以后给它们一个解释。</p><p id="c59a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重要的是，解释实际上决定了你的工作流能做什么和不能做什么。我们得到了关注点的分离，这使得我们可以简单地把我们的代码看作一个链式函数的工作流。您甚至不必关心是否需要一台复杂的机器来实际运行您的计算并处理诸如错误或异步之类的异常，或者您是否只是返回一些默认值。</p><p id="c5fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设<code class="fe ls lt lu lv b">Map</code>和<code class="fe ls lt lu lv b">FlatMap</code>与“可解释”协议的一致性实际上可以通过代码生成来完成，那么在Swift中只有一个问题——类型很快变得难以理解。在这里，未来的发展，如完全存在的，改进的不透明返回类型或占位符类型可以有所帮助。</p></div></div>    
</body>
</html>