<html>
<head>
<title>Don’t Forget Setting Database Locks on Your Orm Entities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要忘记在你的Orm实体上设置数据库锁</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dont-forget-setting-database-locks-on-your-orm-entities-9cf4c074706?source=collection_archive---------11-----------------------#2022-06-14">https://betterprogramming.pub/dont-forget-setting-database-locks-on-your-orm-entities-9cf4c074706?source=collection_archive---------11-----------------------#2022-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="424a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关系数据库的一个巨大优势是事务和锁定。不要因为不使用它而浪费它</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/f62bbcf490a995c615e850c9ad143c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*0JclwTUovUvbLpZaGcja7Q.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片</p></figure><p id="fb37" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这到底是什么问题？</p><p id="f4d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，我们有两个单独的请求，它们都修改同一个数据库字段。但是，由于第二个进程在第一个进程写入其更改之前已经读取了实体，所以它们具有相同的起始信息。</p><p id="10c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着我们丢失了数据，甚至没有任何迹象表明发生了这种情况。</p><p id="1c3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么这个怎么解决呢？</p><h1 id="e9f4" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">实体锁定</h1><p id="6688" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">实体锁定是指实现任何一种允许检测并发问题的机制。</p><p id="efe2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基于数据库的能力和应用程序的需求，有许多方法可以实现这些功能。</p><p id="778f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我是从PHP的<a class="ae mk" href="https://www.doctrine-project.org/projects/orm.html" rel="noopener ugc nofollow" target="_blank">教条ORM </a>的角度来写这篇文章的，因为我对它最熟悉。但是在其他ORM中会非常相似，比如Java的<a class="ae mk" href="https://hibernate.org/" rel="noopener ugc nofollow" target="_blank"> Hibernate </a>。大多数策略也可以在ORM之外手工实现。</p><h2 id="e6bd" class="ml lo iq bd lp mm mn dn lt mo mp dp lx la mq mr lz le ms mt mb li mu mv md mw bi translated">乐观锁定</h2><p id="7dcf" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">这种策略包括向数据库记录添加一个<code class="fe mx my mz na b">version</code>字段，该字段捕获其中的事务数量。这是一个形象化的例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/ecbdd37e88aa605de4337cad8878f9b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*CDNC2hPR0J6kczLSZnXgFg.png"/></div></figure><p id="9242" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，这种变体并没有解决冲突。<br/>但它会防止静默数据丢失。所以这种方法是完美的，如果:</p><ul class=""><li id="1889" class="nb nc iq kt b ku kv kx ky la nd le ne li nf lm ng nh ni nj bi translated">你不期望高并发性</li><li id="4efc" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">您的逻辑或您的用户可以很容易地重试一个动作</li><li id="3f6e" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">你需要“锁定”一个实体更长的时间，例如用户交互。</li><li id="1e8c" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">您的数据库不支持本机锁定</li><li id="2d2d" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">在阅读之前，您不知道是否要修改实体</li></ul><p id="e8c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">仅使用基本的错误处理，您就可以通知您的用户出现了错误，他们应该再试一次。</p><p id="28a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您甚至可以在表单中包含该版本，以便可以检测用户交互和请求之间的变化。</p><p id="1e7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要实现它，您必须添加版本字段并将其标记为版本字段。理论上看起来会是这样的:</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="6574" class="ml lo iq na b gy nt nu l nv nw">#[<em class="nx">ORM</em>\Column(type: "integer")]<br/>#[<em class="nx">ORM</em>\Version]<br/>public int $version = 0;</span></pre><p id="9ae9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后锁定本身就完全为您处理好了。您只需要确保通过表单传递版本，就可以从请求间锁定中获益。</p><h2 id="8aec" class="ml lo iq bd lp mm mn dn lt mo mp dp lx la mq mr lz le ms mt mb li mu mv md mw bi translated">悲观锁定</h2><p id="011b" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">顾名思义，用这种方法我们预期事情会出错。充其量，我们的数据库应该支持本地锁定。但是这并不是严格要求的，尽管我不知道有什么数据库抽象可以帮助您模拟它。</p><p id="f9ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来看看悲观锁定的预期行为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/07e09f4ba490a59a167626769839729a.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*fHJqLUyDfMlLR-q9bike_g.png"/></div></figure><p id="28df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">悲观锁实际上会告诉数据库应该锁定文档。接下来发生的是数据库授予您锁，或者将阻塞您的请求，直到锁被释放。</p><p id="485b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着您可以确保当前没有其他进程可以修改您的记录。SQL数据库强制执行这一点，即使其他进程不使用锁。</p><p id="f60e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以这个方法很棒，如果:</p><ul class=""><li id="e220" class="nb nc iq kt b ku kv kx ky la nd le ne li nf lm ng nh ni nj bi translated">您期望高并发性</li><li id="0021" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">写入失败是不可接受的</li><li id="1c2a" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">您知道您将在请求中修改您的实体</li><li id="7e25" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">您不能更改数据库模式</li></ul><p id="96b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以把它分解为:如果你正在修改你的实体，你应该在请求它的时候锁定它。在教义中，它会是这样的:</p><pre class="kg kh ki kj gt np na nq nr aw ns bi"><span id="ed7a" class="ml lo iq na b gy nt nu l nv nw">$em-&gt;wrapInTransaction(function () use ($em) {<br/>  $obj = $em-&gt;find(Entity::class, 1, LockMode::PESSIMISTIC_WRITE);<br/>  $obj-&gt;counter = $obj-&gt;counter + 1;<br/>});</span></pre><p id="f4fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，您还需要一个显式的数据库事务。教条有一个很好的实用方法<code class="fe mx my mz na b">wrapInTransaction</code>，它为你做所有的请求，甚至最后的<code class="fe mx my mz na b">flush()</code>。如果这个函数有问题，它将回滚事务。</p><h1 id="77fa" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">奖励:原子写入</h1><p id="9f86" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">这不是一种锁定方法，但它可以实现相同的最终目标。当使用对象模型工作时，很容易忽略简单的解决方案。有些事情直接在数据库里做更容易。</p><p id="e968" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大多数数据库默认使用原子更新操作，甚至像<a class="ae mk" href="mongodb.com/docs/manual/reference/operator/update/inc/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>和<a class="ae mk" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.UpdateExpressions.html#Expressions.UpdateExpressions.SET.IncrementAndDecrement" rel="noopener ugc nofollow" target="_blank"> AWS DynamoDB </a>这样厌恶事务的NoSQL数据库也是这样工作的。这意味着，如果一行正在被更新，它不能同时被另一个会话更新。因此，这个模型非常类似于悲观锁。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/a6270088233cb29dc7af2e80cd0d2068.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*qG1xCRRa-19ANdYZVj2a1g.png"/></div></figure><p id="dd53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您所看到的，我们从来没有真正地读取行，只是直接更新它。</p><p id="414f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种方法相当有限，所以只有在以下情况下才应该使用它:</p><ul class=""><li id="d391" class="nb nc iq kt b ku kv kx ky la nd le ne li nf lm ng nh ni nj bi translated">您通常期望高并发性或许多更新</li><li id="a868" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">您只需要更新单个记录的几个字段</li><li id="545c" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">您不需要事先读取该值</li></ul><h1 id="b8e4" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">最终外卖</h1><p id="3c0e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">如果您的项目有可能被多人使用，那么您至少应该考虑实现乐观锁定。否则，你可能会试图复制意想不到的行为。</p><p id="f27d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果乐观锁表明您有并发问题，悲观锁就很有用。如果您编写命令或导入程序，那么他们可以先发制人地使用它们，但这通常是不必要的，只要您有乐观锁作为故障保险。</p><p id="90b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">别忘了考虑技术上不太复杂的替代方案。</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="ef82" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我错过了什么或者告诉了你一些新的东西吗？</p></div></div>    
</body>
</html>