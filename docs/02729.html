<html>
<head>
<title>Exploring Word Embeddings and Text Catalogs with Apple’s Natural Language Framework in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iOS中使用苹果的自然语言框架探索单词嵌入和文本目录</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-word-embeddings-and-text-catalogs-with-apples-natural-language-framework-in-ios-b4d9164f5a3b?source=collection_archive---------8-----------------------#2019-12-20">https://betterprogramming.pub/exploring-word-embeddings-and-text-catalogs-with-apples-natural-language-framework-in-ios-b4d9164f5a3b?source=collection_archive---------8-----------------------#2019-12-20</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="9051" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">了解NLGazetteer、NLWordEmbedding和其他NLP功能如何在Apple的自然语言框架中工作</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/77acea8acc4d9436e00b94fb3ad2db63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mqc6xZxyA5e5CFgp"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">照片由<a class="ae kw" href="https://unsplash.com/@accrualbowtie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瑞恩·华莱士</a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a814" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">早在iOS 5 SDK时就已推出的,<code class="fe lt lu lv lw b">NSLinguisticTagger</code>为苹果在WWDC 18大会上宣布他们的自然语言框架铺平了道路。从语言识别到词汇化和词性标注，所有这些都出现在<code class="fe lt lu lv lw b">NSLinguisticTagger</code>中，现在是自然语言框架的一部分，其API在Swift中进行了彻底的重新设计。</p><p id="8987" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">自然语言框架相对于<code class="fe lt lu lv lw b">NSLinguisticTagger</code>的额外好处是能够使用定制的NLP模型。</p><p id="8ac3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在WWDC 2019期间，苹果宣布了其自然语言框架的几个强大的新工具的到来。引入的三个值得注意的:</p><ul class=""><li id="059d" class="lx ly ir kz b la lb ld le lg lz lk ma lo mb ls mc md me mf bi translated">内置情感分析</li><li id="3716" class="lx ly ir kz b la mg ld mh lg mi lk mj lo mk ls mc md me mf bi translated">单词嵌入</li><li id="0e63" class="lx ly ir kz b la mg ld mh lg mi lk mj lo mk ls mc md me mf bi translated">文本目录</li></ul><p id="b76a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在我们深入研究这些特性之前，让我们快速浏览一下苹果自然语言框架中已经存在的重要API。</p></div><div class="ab cl ml mm hv mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ik il im in io"><h1 id="7dc3" class="ms mt ir bd mu mv mw mx my mz na nb nc jx nd jy ne ka nf kb ng kd nh ke ni nj bi translated">探索Apple的NLP APIs</h1><p id="0e83" class="pw-post-body-paragraph kx ky ir kz b la nk js lc ld nl jv lf lg nm li lj lk nn lm ln lo no lq lr ls ik bi translated"><a class="ae kw" href="https://heartbeat.comet.ml/the-7-nlp-techniques-that-will-change-how-you-communicate-in-the-future-part-i-f0114b2f0497" rel="noopener ugc nofollow" target="_blank">自然语言处理</a>负责将非结构化文本数据作为输入，并在其上推断出许多可能的观察结果。以下是iOS中用于NLP以智能方式处理文本的一些关键API。</p><h1 id="5b1b" class="ms mt ir bd mu mv np mx my mz nq nb nc jx nr jy ne ka ns kb ng kd nt ke ni nj bi translated">语言识别</h1><p id="9c7b" class="pw-post-body-paragraph kx ky ir kz b la nk js lc ld nl jv lf lg nm li lj lk nn lm ln lo no lq lr ls ik bi translated"><code class="fe lt lu lv lw b">NLLanguageRecognizer</code>帮助我们从字符串中确定一段文本的语言，如下所示:</p><pre class="kh ki kj kk gu nu lw nv nw aw nx bi"><span id="dae2" class="ny mt ir lw b gz nz oa l ob oc">import NaturalLanguage</span><span id="bc6a" class="ny mt ir lw b gz od oa l ob oc">var str = "Hola"</span><span id="cc8b" class="ny mt ir lw b gz od oa l ob oc">let recognizer = NLLanguageRecognizer()</span><span id="ae84" class="ny mt ir lw b gz od oa l ob oc">recognizer.processString(str)</span><span id="34ee" class="ny mt ir lw b gz od oa l ob oc">if let languageCode = recognizer.dominantLanguage?.rawValue{</span><span id="c69e" class="ny mt ir lw b gz od oa l ob oc">let detectedLangauge = Locale.current.localizedString(forIdentifier: languageCode)</span><span id="89be" class="ny mt ir lw b gz od oa l ob oc">print(detectedLangauge) //prints Spanish</span><span id="81a5" class="ny mt ir lw b gz od oa l ob oc">}</span></pre><p id="c806" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe lt lu lv lw b">NLLanguageRecognizer</code>类使得从文本的上下文中确定主要的语言代码成为可能。此外，API还提供了返回所预测语言的可信度的功能。</p><p id="219f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">以下函数返回预测为语言代码字典和概率值的前5种语言:</p><pre class="kh ki kj kk gu nu lw nv nw aw nx bi"><span id="4594" class="ny mt ir lw b gz nz oa l ob oc">recognizer.languageHypotheses(withMaximum: 5))</span></pre><p id="8252" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">目前，苹果的自然语言识别API不如Firebase准确。像印地语这样的语言(我在多种文本上进行了测试)目前还不能被<code class="fe lt lu lv lw b">NLLanguageRecognizer</code>从上下文中识别出来。</p><h1 id="c90a" class="ms mt ir bd mu mv np mx my mz nq nb nc jx nr jy ne ka ns kb ng kd nt ke ni nj bi translated">标记化</h1><p id="e507" class="pw-post-body-paragraph kx ky ir kz b la nk js lc ld nl jv lf lg nm li lj lk nn lm ln lo no lq lr ls ik bi translated">标记化是将字符串拆分成单词、句子、字符或段落的过程。然后，根据使用情况，可以一起或单独处理这些分段的文本。为了标记一个字符串，使用了<code class="fe lt lu lv lw b">NLTokenizer</code>类。</p><p id="0f9c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们需要指定应该对字符串进行标记的<code class="fe lt lu lv lw b">unit</code>类型。基于分配的单元方案，文本被分类。在下面的代码中，每个问题被分成不同的标记:</p><pre class="kh ki kj kk gu nu lw nv nw aw nx bi"><span id="8ab3" class="ny mt ir lw b gz nz oa l ob oc">import NaturalLanguage</span><span id="a8d6" class="ny mt ir lw b gz od oa l ob oc">var str = "How are you? Where were you?"</span><span id="347c" class="ny mt ir lw b gz od oa l ob oc">let tokenizer = NLTokenizer(unit: .sentence)</span><span id="54b1" class="ny mt ir lw b gz od oa l ob oc">tokenizer.string = str</span><span id="f18c" class="ny mt ir lw b gz od oa l ob oc">tokenizer.enumerateTokens(in: str.startIndex..&lt;str.endIndex) { tokenRange, _ in</span><span id="29d8" class="ny mt ir lw b gz od oa l ob oc">print(str[tokenRange])</span><span id="5d31" class="ny mt ir lw b gz od oa l ob oc">return true</span><span id="3ecc" class="ny mt ir lw b gz od oa l ob oc">}</span></pre></div><div class="ab cl ml mm hv mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ik il im in io"><h1 id="8b3e" class="ms mt ir bd mu mv mw mx my mz na nb nc jx nd jy ne ka nf kb ng kd nh ke ni nj bi translated">词汇化</h1><p id="8c35" class="pw-post-body-paragraph kx ky ir kz b la nk js lc ld nl jv lf lg nm li lj lk nn lm ln lo no lq lr ls ik bi translated">词汇化是将一个词转换成它的基本形式的过程。在你的NLP应用程序中，你经常会遇到一些用例，在这些用例中，几个单词之间唯一的区别就是它们使用的时态。例如,“假设”和“假设”是“假设”一词的不同用法，但具有相同的核心含义。</p><p id="df4b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">词汇化通常用于单词标记和模糊匹配(识别拼写错误的单词，就像你在谷歌搜索中看到的一样)。下面的代码展示了如何用<code class="fe lt lu lv lw b">NLTagger</code>实现词汇化:</p><pre class="kh ki kj kk gu nu lw nv nw aw nx bi"><span id="391a" class="ny mt ir lw b gz nz oa l ob oc">var text = "I am running late for the 10 km marathon run that was scheduled for today. Can we reschedule the meeting?"</span><span id="40d9" class="ny mt ir lw b gz od oa l ob oc">let tagger = NLTagger(tagSchemes: [.lemma])<br/>tagger.string = text</span><span id="ca6f" class="ny mt ir lw b gz od oa l ob oc">tagger.enumerateTags(in: text.startIndex..&lt;text.endIndex, unit: .word, scheme: .lemma) { tag, tokenRange in</span><span id="8261" class="ny mt ir lw b gz od oa l ob oc">if let tag = tag {</span><span id="c1a5" class="ny mt ir lw b gz od oa l ob oc">print("\(text[tokenRange]) - \(tag.rawValue)")</span><span id="365e" class="ny mt ir lw b gz od oa l ob oc">}<br/>return true<br/>}</span></pre><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oe"><img src="../Images/7d931ffcb2fe34b78db88820be46393a.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*n3eWqmL7lemFxlXRMn05uQ.png"/></div></div></figure></div><div class="ab cl ml mm hv mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ik il im in io"><h1 id="f620" class="ms mt ir bd mu mv mw mx my mz na nb nc jx nd jy ne ka nf kb ng kd nh ke ni nj bi translated">词性和命名实体识别</h1><p id="3b1b" class="pw-post-body-paragraph kx ky ir kz b la nk js lc ld nl jv lf lg nm li lj lk nn lm ln lo no lq lr ls ik bi translated">自然语言框架还具有将语音或句子中的单词分类和识别为名词、代词、动词、形容词、介词、习语等的能力。词性标注是使用<code class="fe lt lu lv lw b">NLTagger</code>完成的。</p><p id="14a0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这并不像听起来那么简单，因为同一个单词可以根据语义上下文标记为动词或名词。自然语言框架决定了适当的词法类。</p><p id="a2c0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在下面的代码中，我们使用了与之前相同的<code class="fe lt lu lv lw b">NLTagger</code>，但是指定了不同的<code class="fe lt lu lv lw b">scheme</code>:</p><pre class="kh ki kj kk gu nu lw nv nw aw nx bi"><span id="68e6" class="ny mt ir lw b gz nz oa l ob oc">import NaturalLanguage</span><span id="0614" class="ny mt ir lw b gz od oa l ob oc">var text = "His laugh was so shrill that it jarred everybody. You laugh in a shrill manner."</span><span id="a72b" class="ny mt ir lw b gz od oa l ob oc">let tagger = NLTagger(tagSchemes: [.lexicalClass])<br/>let options : NLTagger.Options = [.omitWhitespace, .omitPunctuation]</span><span id="6bed" class="ny mt ir lw b gz od oa l ob oc">tagger.string = text</span><span id="0f8b" class="ny mt ir lw b gz od oa l ob oc">tagger.enumerateTags(in: text.startIndex..&lt;text.endIndex, unit: .word, scheme: .lexicalClass, options: options) { tag, tokenRange in</span><span id="0587" class="ny mt ir lw b gz od oa l ob oc">if let tag = tag {</span><span id="69cf" class="ny mt ir lw b gz od oa l ob oc">print("\(text[tokenRange]) : is \(tag.rawValue)")</span><span id="be2e" class="ny mt ir lw b gz od oa l ob oc">}</span><span id="8097" class="ny mt ir lw b gz od oa l ob oc">return true</span><span id="cada" class="ny mt ir lw b gz od oa l ob oc">}</span></pre><p id="1ed3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在下面的结果中，你可以看到单词“laugh”在文本的不同部分被标记为名词和动词。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj of"><img src="../Images/83d913a3c05f5b4bc190063f25ab1be8.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*G3yHLNoB5Q4v19WTZfy8Lw.png"/></div></figure><p id="8d5a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">命名实体识别是词性标注的一个子集。我们可以通过将标签scheme设置为<code class="fe lt lu lv lw b">nameType</code>并遍历标签，以类似的方式识别人名、地名和组织名。此外，对于我们的特定用例，我们可以在<code class="fe lt lu lv lw b">NLTagger</code>类上设置我们的定制核心ML模型，如下所示:</p><pre class="kh ki kj kk gu nu lw nv nw aw nx bi"><span id="9621" class="ny mt ir lw b gz nz oa l ob oc">let scheme = NLTagScheme("CoffeeName")</span><span id="9ba6" class="ny mt ir lw b gz od oa l ob oc">let model = try NLModel(contentsOf: modelUrl)<br/>let tagger = NLTagger(tagSchemes: [scheme])      </span><span id="73c6" class="ny mt ir lw b gz od oa l ob oc">tagger.setModels([model], forTagScheme: scheme)</span></pre><p id="40ef" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在我们已经很好地了解了较老的自然语言框架工具，让我们深入研究一下较新的工具。</p></div><div class="ab cl ml mm hv mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ik il im in io"><h1 id="4476" class="ms mt ir bd mu mv mw mx my mz na nb nc jx nd jy ne ka nf kb ng kd nh ke ni nj bi translated">内置情感分析</h1><p id="52db" class="pw-post-body-paragraph kx ky ir kz b la nk js lc ld nl jv lf lg nm li lj lk nn lm ln lo no lq lr ls ik bi translated">随着情感分析API的加入，文本分类得到了极大的推动。它分析文本中的情感程度，并基于此给出从-1(非常负面)到1(非常正面)的分数。目前，自然语言框架支持7种语言进行情感分析。</p><p id="60a2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">要对一段文本使用内置的情感分析，只需将<code class="fe lt lu lv lw b">sentimentScore</code>标记方案传递给<code class="fe lt lu lv lw b">NLTagger</code>实例，如下所示:</p><pre class="kh ki kj kk gu nu lw nv nw aw nx bi"><span id="eed9" class="ny mt ir lw b gz nz oa l ob oc">import NaturalLanguage</span><span id="e2a3" class="ny mt ir lw b gz od oa l ob oc">var text = "I won't be possible to make it today."</span><span id="6c10" class="ny mt ir lw b gz od oa l ob oc">let tagger = NLTagger(tagSchemes: [.sentimentScore])</span><span id="5d20" class="ny mt ir lw b gz od oa l ob oc">tagger.string = text</span><span id="3e51" class="ny mt ir lw b gz od oa l ob oc">let (sentiment, _) = tagger.tag(at: text.startIndex, unit: .paragraph, scheme: .sentimentScore)</span><span id="4a0e" class="ny mt ir lw b gz od oa l ob oc">print(sentiment?.rawValue) //prints -0.8</span></pre><p id="b48d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">将<code class="fe lt lu lv lw b">unit</code>更改为<code class="fe lt lu lv lw b">word</code>或<code class="fe lt lu lv lw b">sentence</code>不起作用。为此，我们需要像以前一样列举课文。分配给每个单词或句子的情感分数与整个文本相同；因此，建议指定<code class="fe lt lu lv lw b">paragraph</code>为单位。</p><h1 id="f26b" class="ms mt ir bd mu mv np mx my mz nq nb nc jx nr jy ne ka ns kb ng kd nt ke ni nj bi translated">单词嵌入</h1><p id="26a6" class="pw-post-body-paragraph kx ky ir kz b la nk js lc ld nl jv lf lg nm li lj lk nn lm ln lo no lq lr ls ik bi translated">单词标注是自然语言处理的另一个重要方面，单词嵌入是其中的一部分。单词嵌入基本上将字符串映射到它们的向量对应物。这样，向量距离小的字符串被认为是相似的。</p><p id="9575" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">下图展示了放置在坐标空间中的几个随机字符串。您可以看到语义相似的群集在一起:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj og"><img src="../Images/dd03c758a4d7e5f4fdc70902a836312b.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*amn3OwyKVsx64XL-dxXgEg.png"/></div></figure><p id="7e8b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">单词嵌入是搜索引擎和索引搜索的重要组成部分，因为搜索不直接出现在搜索索引中的术语是很常见的。对于这种情况，通过使用单词嵌入，我们可以检索最接近的可能匹配。</p><p id="8f83" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">目前，自然语言框架支持7种语言的内置操作系统嵌入:英语、西班牙语、法语、意大利语、德语、葡萄牙语和简体中文。然而，我们也可以创建自己的自定义单词嵌入，我们很快就会看到。</p><p id="7ae5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">一个<code class="fe lt lu lv lw b">NLEmbedding</code>类实例被实例化如下:</p><pre class="kh ki kj kk gu nu lw nv nw aw nx bi"><span id="5e6e" class="ny mt ir lw b gz nz oa l ob oc">let embedding = NLEmbedding.wordEmbedding(for: .english)</span></pre><p id="db9c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">目前，操作系统嵌入只要求单词是小写的。不这样做不会返回任何结果。以下方法用于检索单词的矢量表示:</p><pre class="kh ki kj kk gu nu lw nv nw aw nx bi"><span id="1c5f" class="ny mt ir lw b gz nz oa l ob oc">embedding?.vector(for: "cat") //returns double array</span></pre><p id="a926" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">计算出的两个单词之间的距离是一个余弦值，在无法计算的情况下(例如，一个单词在内置OS嵌入中不存在)，返回值是2.0。</p><pre class="kh ki kj kk gu nu lw nv nw aw nx bi"><span id="b106" class="ny mt ir lw b gz nz oa l ob oc">embedding?.distance(between: "cat", and: "dog") //0.71</span></pre><p id="eb9e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">为了找到前K个最相似的单词，我们可以用下面的方式列举这个请求:</p><pre class="kh ki kj kk gu nu lw nv nw aw nx bi"><span id="5a31" class="ny mt ir lw b gz nz oa l ob oc">embedding?.enumerateNeighbors(for: "HeartBeat".lowercased(), maximumCount: 5) { (string, distance) -&gt; Bool in</span><span id="8a3b" class="ny mt ir lw b gz od oa l ob oc">print("\(string) - \(distance)")</span><span id="534f" class="ny mt ir lw b gz od oa l ob oc">return true</span><span id="409b" class="ny mt ir lw b gz od oa l ob oc">}</span></pre><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj oh"><img src="../Images/2bc341e8c094ad3af4706c09f51ef8ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*jNNvClXWvGRoMmypLL3Azg.png"/></div></figure><p id="0932" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">对于特定的用例，可以使用<a class="ae kw" href="https://heartbeat.comet.ml/coreml-with-glove-word-embedding-and-recursive-neural-network-part-2-d72c1a66b028" rel="noopener ugc nofollow" target="_blank"> GloVe </a>、Word2Vec、BERT和FastText数据集构建自定义单词嵌入。出于演示目的，我们创建一个向量字典，如下所示:</p><pre class="kh ki kj kk gu nu lw nv nw aw nx bi"><span id="3a7b" class="ny mt ir lw b gz nz oa l ob oc">let vectors = [</span><span id="f1bc" class="ny mt ir lw b gz od oa l ob oc">"dog": [-0.4, 0.37],</span><span id="b27c" class="ny mt ir lw b gz od oa l ob oc">"cat": [-0.15, -0.02],</span><span id="3428" class="ny mt ir lw b gz od oa l ob oc">"lion": [0.19, -0.4]</span><span id="0767" class="ny mt ir lw b gz od oa l ob oc">]</span><span id="40cc" class="ny mt ir lw b gz od oa l ob oc">let embedding = try MLWordEmbedding(dictionary: vectors)</span><span id="cad9" class="ny mt ir lw b gz od oa l ob oc">try embedding.write(to: URL(fileURLWithPath: "modelPathHere"))</span></pre><p id="b801" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe lt lu lv lw b">MLWordEmbedding</code>使用自动压缩技术，可以将千兆字节的数据压缩到一个非常小的核心ML模型中。</p><p id="fd78" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">为了在<code class="fe lt lu lv lw b">NLEmbedder</code>中使用核心ML模型，我们需要传递编译后模型的URL，如下所示:</p><pre class="kh ki kj kk gu nu lw nv nw aw nx bi"><span id="d2c3" class="ny mt ir lw b gz nz oa l ob oc">let compiledUrl = try MLModel.compileModel(at: URL(fileURLWithPath: "modelPathHere"))</span><span id="fb2a" class="ny mt ir lw b gz od oa l ob oc">let customEmbedding = try NLEmbedding(contentsOf: compiledUrl)</span><span id="bb6c" class="ny mt ir lw b gz od oa l ob oc">customEmbedding.enumerateNeighbors(for: "dog", maximumCount: 2) { (string, distance) -&gt; Bool in</span><span id="587c" class="ny mt ir lw b gz od oa l ob oc">print("\(string) - \(distance)")</span><span id="47cf" class="ny mt ir lw b gz od oa l ob oc">return true</span><span id="7a74" class="ny mt ir lw b gz od oa l ob oc">}</span></pre></div><div class="ab cl ml mm hv mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ik il im in io"><h1 id="621f" class="ms mt ir bd mu mv mw mx my mz na nb nc jx nd jy ne ka nf kb ng kd nh ke ni nj bi translated">文本目录</h1><p id="ce9b" class="pw-post-body-paragraph kx ky ir kz b la nk js lc ld nl jv lf lg nm li lj lk nn lm ln lo no lq lr ls ik bi translated">文本目录是自然语言框架中新添加的功能，它允许我们定制单词标记模型，而无需创建新的单词标记模型。</p><p id="869a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">相反，我们创建一个标签及其定制标签的字典，并将它们传递给Create ML的<code class="fe lt lu lv lw b">NLGazetteer</code>模型类型。生成的输出模型是输入字典的有效(在空间和速度方面)形式，然后可以与<code class="fe lt lu lv lw b">NLTagger</code>一起使用:</p><pre class="kh ki kj kk gu nu lw nv nw aw nx bi"><span id="ae10" class="ny mt ir lw b gz nz oa l ob oc">let entities = ["American Actor" : ["Tom Cruise", "Brad Pitt", "Will Smith" , ....],</span><span id="018b" class="ny mt ir lw b gz od oa l ob oc">"Indian Actor": ["Amitabh Bachchan", "Aamir Khan", "Sharukh Khan", ....]]</span><span id="0f76" class="ny mt ir lw b gz od oa l ob oc">let gazetteer = try MLGazetteer(dictionary: entities)</span><span id="900b" class="ny mt ir lw b gz od oa l ob oc">try gazetteer.write(to: URL(fileURLWithPath: "modelUrlPath"))</span></pre><p id="8a7d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">最后，我们将编译后的模型URL传递给<code class="fe lt lu lv lw b">NLGazetteer</code>，并在<code class="fe lt lu lv lw b">NLTagger</code>中设置它:</p><pre class="kh ki kj kk gu nu lw nv nw aw nx bi"><span id="673c" class="ny mt ir lw b gz nz oa l ob oc">let compiledUrl = try MLModel.compileModel(at: URL(fileURLWithPath: "modelUrlPath"))</span><span id="044a" class="ny mt ir lw b gz od oa l ob oc">let gazetteer = try! NLGazetteer(contentsOf: compiledUrl)</span><span id="c8cc" class="ny mt ir lw b gz od oa l ob oc">var text = "Amitabh Bachchan and Leonardo DiCaprio featured together in the Movie Great Gatsby"</span><span id="b50c" class="ny mt ir lw b gz od oa l ob oc">let tagger = NLTagger(tagSchemes: [.nameTypeOrLexicalClass])</span><span id="f8fa" class="ny mt ir lw b gz od oa l ob oc">let options : NLTagger.Options = [.omitWhitespace, .omitPunctuation]</span><span id="84f2" class="ny mt ir lw b gz od oa l ob oc">tagger.string = text</span><span id="230f" class="ny mt ir lw b gz od oa l ob oc">tagger.setGazetteers([gazetteer], for: .nameTypeOrLexicalClass)</span><span id="008e" class="ny mt ir lw b gz od oa l ob oc">tagger.enumerateTags(in: text.startIndex..&lt;text.endIndex, unit: .word, scheme: .nameTypeOrLexicalClass, options: options) { tag, tokenRange in</span><span id="f567" class="ny mt ir lw b gz od oa l ob oc">if let tag = tag {</span><span id="c42b" class="ny mt ir lw b gz od oa l ob oc">print("\(text[tokenRange]) - \(tag.rawValue)")</span><span id="0e72" class="ny mt ir lw b gz od oa l ob oc">}</span><span id="bf13" class="ny mt ir lw b gz od oa l ob oc">return true</span><span id="184f" class="ny mt ir lw b gz od oa l ob oc">}</span></pre><p id="f333" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe lt lu lv lw b">NLTagger</code>用地名录中指定的标签标注地名类型:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj oi"><img src="../Images/68e3397135e78cebc5a3369f3babf9a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/format:webp/1*FCjZ5yBfI6MZIiDA7lj9dQ.png"/></div></figure></div><div class="ab cl ml mm hv mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ik il im in io"><h1 id="58b8" class="ms mt ir bd mu mv mw mx my mz na nb nc jx nd jy ne ka nf kb ng kd nh ke ni nj bi translated">结论</h1><p id="924b" class="pw-post-body-paragraph kx ky ir kz b la nk js lc ld nl jv lf lg nm li lj lk nn lm ln lo no lq lr ls ik bi translated">我们探索了自然语言框架提供的不同功能，并并排查看了它们的用例示例。</p><p id="4c36" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">自然语言处理是一个复杂而强大的研究和应用领域。从我们处理非结构化数据(人类语言)的意义上来说，它是复杂的，在人类语言中，同一个词可以根据它所在的上下文被不同地标注。</p><p id="8629" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Create ML允许我们构建自己的文本分类器和单词标记器，并通过使用单词嵌入器和文本目录对它们进行定制。现在我们已经很好地了解了这个框架，您可以继续尝试使用NLP来构建智能文本处理应用程序。使用单词嵌入器来确定相似的句子将是一件非常有趣的事情。</p><p id="db2e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这一次到此为止。我希望你喜欢阅读。</p></div></div>    
</body>
</html>