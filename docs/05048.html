<html>
<head>
<title>Should You Use Recoil as a React State Management Library?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该使用反冲作为一个反应状态管理库吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/should-you-use-recoil-as-a-react-state-management-library-38ef14f3de10?source=collection_archive---------8-----------------------#2020-06-03">https://betterprogramming.pub/should-you-use-recoil-as-a-react-state-management-library-38ef14f3de10?source=collection_archive---------8-----------------------#2020-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5c81" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看一看脸书开发的新的反应状态管理库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/be786895b1d23c38f198a9b9c0752510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wQ0xoQBd5Fe-jiqx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@karock12?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡罗琳娜·加西亚·塔维松</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="663c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">脸书的人最近向我们介绍了一个新的React状态管理库。叫做<a class="ae ky" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">后坐力</a>。</p><p id="0bb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到新的解决方案总是令人兴奋的，但确实会想到一个问题:我们真的需要它吗？已经有成熟的解决方案——Redux、MobX和许多其他解决方案——我们需要一个新的吗？</p><p id="056f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对许多人来说，答案是否定的。但是让我们来了解一下什么是后坐力，它能解决什么样的问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aa3e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是后坐力？</h1><p id="7433" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">反冲是React的一个状态管理库，由脸书的Dave McCabe开发。</p><p id="c1c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反冲有两个核心概念:原子和选择器。</p><p id="7609" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原子是一种状态。您可以通过定义缓存键并传递默认数据来创建atom。您的组件可以消耗原子并订阅对它的更改。和React的<code class="fe mz na nb nc b">useState</code>差不多。</p><p id="630e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择器用于派生数据。它们类似于原子。在这里你可以消耗原子和其他选择器。此外，还可以在选择器中执行异步操作。其余与原子相同。您的组件可以消费和订阅对它们的更改。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7d1b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何使用它</h1><p id="8ab4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们看几个例子来理解它的用法。</p><p id="7903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，将您的应用程序包装在<code class="fe mz na nb nc b">RecoilRoot</code>提供程序中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ded9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，创建一个原子，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="256e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在任何组件中使用这个原子，并为其设置数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6686" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您需要一个派生数据时，创建一个选择器，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="589c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后你就可以像使用原子一样使用它了。唯一的区别是<code class="fe mz na nb nc b">useRecoilValue</code>而不是<code class="fe mz na nb nc b">useRecoilState</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="b1ca" class="mc md it bd me mf nf mh mi mj ng ml mm jz nh ka mo kc ni kd mq kf nj kg ms mt bi translated">后坐力有什么好处？</h1><p id="441d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这一点上，你可能想知道仅仅使用旧的<code class="fe mz na nb nc b">useState</code>和使用后坐力有什么区别。看起来一模一样。也可能你在想，相比Redux的优势在哪里。</p><p id="95aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您需要在多个组件中共享一个状态时，以及当您面临与此相关的性能问题时，反冲的力量就来了。</p><p id="c24b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你需要分享一部分状态时，你可以提升状态，就像官方React <a class="ae ky" href="https://reactjs.org/docs/lifting-state-up.html" rel="noopener ugc nofollow" target="_blank">文档</a>中推荐的那样。如果使用Redux，您不需要做任何事情，因为您的整个应用程序共享一个全局状态。</p><p id="a0e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种方法的问题是不必要的渲染。当您提升状态时，所有子组件都会重新呈现。在Redux中，如果你在一个大的容器组件下放置很多东西，整个应用程序或页面可能会重新呈现。这对于大多数应用程序来说是没问题的，但是对于有些应用程序来说就不太好了。</p><p id="81bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">举个例子，看看一些绘图应用程序，比如<a class="ae ky" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank">diagrams.net</a>。屏幕上有许多单独的部分，它们都有一些状态和需要访问这些状态的其他组件。整个重新渲染太昂贵了。您需要找到一种仅在状态改变时重新渲染的方法。</p><p id="9a21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以用传统的方法实现这一点，但是一般来说，它们太费力了，尤其是对于大型应用程序。</p><p id="f02c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反冲是来帮助你的。一个原子是一个独立的状态。您的组件可以订阅一个atom——当值改变时，只有相关的组件被重新呈现。</p><p id="82c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它为您提供了统一的状态共享方式，并在幕后解决了性能问题。它用一个简单的API完成所有这些。您不需要像在Redux中那样编写大量样板代码。</p><p id="3d91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">观看以下视频，了解更详细的解释。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3acc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">成本</h1><p id="0078" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在撰写本文时，v0.0.8是当前版本。它花费你<a class="ae ky" href="https://bundlephobia.com/result?p=recoil@0.0.8" rel="noopener ugc nofollow" target="_blank">8.3 KB gzip</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b7e5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">该不该用？</h1><p id="c24d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">虽然这个库很棒，但是大多数应用程序并没有从它的强大功能中受益。每一个新的解决方案都会让人兴奋，人们希望尽快尝试并投入其中。但与其这样做，不如退一步看看你<em class="nl">是否真的需要它。</em></p><p id="1295" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是要理解反冲是为了什么而产生的。如果您面临上述性能问题，反冲是一个很好的选择。否则，你真的不需要它——继续使用内置的React解决方案和你喜欢的任何东西。</p><p id="f69c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以部分使用后坐力。您的应用程序不需要完全依赖它。如果你看到一个特定的地方可以从中受益，就在那里使用它。没有必要疯狂地重构整个应用程序。</p><p id="7e7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还提供了一些很酷的特性，比如时间旅行、持久状态等等。但是，你的应用程序真的需要这些功能吗？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1713" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><div class="nm nn gp gr no np"><a href="https://recoiljs.org/" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">报应</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">React反冲工程的状态管理库。添加一些到您的应用程序，获得快速和灵活…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">recoiljs.org</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ks np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://reactjs.org/docs/lifting-state-up.html" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">提升状态向上-反应</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">通常，几个组件需要反映相同的变化数据。我们建议将共享状态提升到它们的…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">reactjs.org</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od ks np"/></div></div></a></div></div></div>    
</body>
</html>