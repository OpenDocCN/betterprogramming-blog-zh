<html>
<head>
<title>Build Your Pokédex: Part 3 — Improve NgRx Using Creator Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建您的Pokédex:第3部分——使用Creator函数改进NgRx</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-your-pok%C3%A9dex-part-3-improve-ngrx-using-create-functions-21e59ace65e?source=collection_archive---------6-----------------------#2019-08-14">https://betterprogramming.pub/build-your-pok%C3%A9dex-part-3-improve-ngrx-using-create-functions-21e59ace65e?source=collection_archive---------6-----------------------#2019-08-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a77f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">循序渐进的角度教程</h2></div><p id="b0fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章是我描述如何从初学者到忍者使用<a class="ae le" href="https://ngrx.io/" rel="noopener ugc nofollow" target="_blank"> NgRx </a>构建你的<a class="ae le" href="https://www.pokemon.com/us/pokedex/" rel="noopener ugc nofollow" target="_blank"> Pokédex </a>的系列文章的一部分。如果您想阅读更多内容，可以在本文底部找到该系列其余部分的链接。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/4fcb6416646c1ff36208e328cd8cda4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R9fthSR1G3r4fTLzDucNlg.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">照片由<a class="ae le" href="https://commons.wikimedia.org/wiki/User:Grandy02" rel="noopener ugc nofollow" target="_blank"> Grandy02 </a>在<a class="ae le" href="https://commons.wikimedia.org/wiki/File:Pokedex-German.jpg" rel="noopener ugc nofollow" target="_blank">维基共享资源</a>上拍摄</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ed8a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">介绍</h1><p id="c254" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">在这篇文章中，我们将使用<a class="ae le" href="http://angular.io" rel="noopener ugc nofollow" target="_blank"> Angular </a>框架和NgRx作为状态管理库来开发一个Pokédex。我们将使用NgRx 8中发布的新的creator函数。</p><p id="f362" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了正确理解这篇文章，最好了解如何在中级水平上管理Angular以及什么是状态管理库。在这个系列中，我们将展示如何开发一个具体的例子(Pokédex ),它可以作为您学习NgRX的补充。</p><p id="3603" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，沿着这些帖子构建的结果显示在下面的GIF中。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mz"><img src="../Images/ae60ff7a59da7a7613f8272c89b70bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xVTMs_KhIyM1Qqi0.gif"/></div></div></figure><p id="7b11" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">必须阅读本系列的第一部分和第二部分才能理解正在构建的内容。在这篇文章中，我们将通过使用<code class="fe na nb nc nd b">@ngrx/entity</code>包中的creator函数来改进代码，这将简化创建动作、减少器和效果所需的样板代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dee6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建操作</h1><p id="0ab0" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">在NgRx中，当您想要创建动作时，需要大量的样板代码。您经常需要创建枚举、动作类型、类和联合类型。在这个新版本中，您可以以更简单的方式创建操作。</p><p id="d4a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">NgRx核心团队使用了著名的工厂功能设计模式来达到这个目标。工厂功能是<code class="fe na nb nc nd b">createAction</code>。<code class="fe na nb nc nd b">createAction</code>函数接收两个参数:</p><ol class=""><li id="c67a" class="ne nf it kk b kl km ko kp kr ng kv nh kz ni ld nj nk nl nm bi translated"><code class="fe na nb nc nd b">action types</code>是用来标识动作的著名字符串。</li><li id="133d" class="ne nf it kk b kl nn ko no kr np kv nq kz nr ld nj nk nl nm bi translated"><code class="fe na nb nc nd b">props</code>是动作元数据(例如有效载荷)。</li></ol><p id="f306" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了比较两者，下面的代码说明了如何在Pokédex中使用新的<code class="fe na nb nc nd b">createAction</code>函数。</p><p id="afae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之前:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="345f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="d11d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在before代码中，您需要创建一个实现<code class="fe na nb nc nd b">Action</code>接口的类，定义<code class="fe na nb nc nd b">type</code>属性，并使用构造函数定义<code class="fe na nb nc nd b">payload</code>。</p><p id="f7d7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，在after代码中，您只需要使用<code class="fe na nb nc nd b">createAction</code>创建动作，其中第一个参数是<code class="fe na nb nc nd b">type</code>，第二个参数是<code class="fe na nb nc nd b">props</code>属性(在我们的上下文中，它将是<code class="fe na nb nc nd b">payload</code>)。</p><p id="92e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管核心团队声明不需要使用枚举，但在我的特定编码风格中，我更喜欢定义一个动作枚举来了解动作集。</p><p id="dd06" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，<code class="fe na nb nc nd b">pokemon.action.ts</code>的前后如下:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="d548" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我已经导出了一个<code class="fe na nb nc nd b">action const,</code>，它是一个字典，包含动作名称作为键，动作本身作为值。</p><p id="6c97" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe na nb nc nd b">createAction</code>是一个工厂函数，返回一个名为<code class="fe na nb nc nd b">ActionCreator</code>的函数，调用时返回一个action对象。因此，当您想要分派一个动作时，您必须调用<code class="fe na nb nc nd b">ActionCreator</code>。</p><pre class="lg lh li lj gt nu nd nv nw aw nx bi"><span id="7554" class="ny md it nd b gy nz oa l ob oc">this.store.dispatch(addSuccess(pokemon: Pokemon));</span></pre><p id="1903" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不再需要创建与动作的类相关联的对象，现在可以直接调用该函数。</p><p id="a2ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，下面的重构必须应用于所有创建动作的效果。</p><p id="31d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之前:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1336" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="79d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">效果本身将在下一节使用<code class="fe na nb nc nd b">createEffects</code>函数进行重构。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="514e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建效果</h1><p id="bcdd" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">NgRx 8提供了<code class="fe na nb nc nd b">createEffect</code>方法，它是<code class="fe na nb nc nd b">@Effect()</code>装饰器的替代方法。使用<code class="fe na nb nc nd b">createEffect</code>代替装饰器的主要优点是它是类型安全的——也就是说，如果效果没有返回<code class="fe na nb nc nd b">Observable&lt;Action&gt;</code>，它将给出编译错误。</p><p id="96ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的代码片段中，我将向您展示应用新的<code class="fe na nb nc nd b">createEffect</code>方法前后的<code class="fe na nb nc nd b">loadAllPokemon$</code>效果。迁移非常容易。</p><p id="cfce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之前:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="01d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="159c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，<code class="fe na nb nc nd b">pokemon.effects.ts</code>前后为:</p><p id="8258" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之前:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2780" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="4cd0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，之前传递给每个效果的参数<code class="fe na nb nc nd b">dispatch: false </code>现在是在<code class="fe na nb nc nd b">createEffect</code>方法中传递的第二个参数。记住选项<code class="fe na nb nc nd b">{ dispatch: false }</code>是用于不分派新动作的效果(添加这个选项也消除了效果必须返回一个<code class="fe na nb nc nd b">Observable&lt;Action&gt;</code>的限制)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d9ce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">还原剂</h1><p id="da53" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">新的<code class="fe na nb nc nd b">createReducer</code>方法允许用户创建一个没有<code class="fe na nb nc nd b">switch</code>语句的缩减器。有一个新的<code class="fe na nb nc nd b">on</code>方法来区分动作类型，它返回一个新的引用。另一个有趣的事实是不需要处理reducer中未处理动作的默认情况。</p><p id="7ca8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，<code class="fe na nb nc nd b">pokemon.reducers.ts</code>之前和之后是:</p><p id="b7cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之前:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="501c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="6ce7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，<code class="fe na nb nc nd b">createReducer</code>方法接收一个参数列表:第一个参数是初始状态，第二个参数是一个<code class="fe na nb nc nd b">on</code>方法列表。在<code class="fe na nb nc nd b">on</code>方法中，第一个参数是相关的动作。</p><p id="4e7a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的例子中，我维护了动作<code class="fe na nb nc nd b">enum</code>，因为我喜欢这种数据结构。当然，您可以不使用枚举直接导出操作。</p><p id="ae6c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe na nb nc nd b">on</code>方法的第二个参数是接收<code class="fe na nb nc nd b">state</code>和<code class="fe na nb nc nd b">payload</code>的回调。之后，我们可以使用强大的<code class="fe na nb nc nd b">EntityAdapter</code>来执行最常见的操作。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0e22" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="e5c4" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">在这篇文章中，我们通过使用<code class="fe na nb nc nd b">@ngrx/entity</code>包的<code class="fe na nb nc nd b">create*</code>函数重构了我们的Pokédex。使用<code class="fe na nb nc nd b">create*</code>函数将减少我们应用程序状态管理中不必要的复杂性。此外，适配器用于执行最常见的操作(例如CRUD)。</p><p id="5093" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在这篇文章中，我们讨论了以下主题:</p><ul class=""><li id="0366" class="ne nf it kk b kl km ko kp kr ng kv nh kz ni ld od nk nl nm bi translated">使用<code class="fe na nb nc nd b">@ngrx/entity</code>自动创建状态，因为这是非常重复的</li><li id="bd4f" class="ne nf it kk b kl nn ko no kr np kv nq kz nr ld od nk nl nm bi translated">使用<code class="fe na nb nc nd b">@ngrx/entity</code>自动创建效果和动作并简化reduce功能</li></ul><p id="c666" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本系列中的以下帖子将涵盖有趣的主题，例如:</p><ul class=""><li id="1ad0" class="ne nf it kk b kl km ko kp kr ng kv nh kz ni ld od nk nl nm bi translated">门面模式将通过<code class="fe na nb nc nd b">@ngrx/data</code>包使用</li><li id="d499" class="ne nf it kk b kl nn ko no kr np kv nq kz nr ld od nk nl nm bi translated">测试应用程序的状态</li></ul><p id="ce7d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">成功的主要因素是展示的概念，而不是使用的技术或库。因此，这个帖子应该作为那些开始有大角度应用程序和需要架构原则的人的指南。</p><h1 id="f00e" class="mc md it bd me mf oe mh mi mj of ml mm jz og ka mo kc oh kd mq kf oi kg ms mt bi translated">该系列的其他部分</h1><ol class=""><li id="8a4f" class="ne nf it kk b kl mu ko mv kr oj kv ok kz ol ld nj nk nl nm bi translated">第一部分。构建你的pokédex:NgRx简介</li><li id="8619" class="ne nf it kk b kl nn ko no kr np kv nq kz nr ld nj nk nl nm bi translated"><a class="ae le" href="https://medium.com/better-programming/build-your-pok%C3%A9dex-part-2-ngrx-entity-6e9d7256e6a8" rel="noopener">第二部分。构建你的Pokédex: @ngrx/entity </a></li><li id="4343" class="ne nf it kk b kl nn ko no kr np kv nq kz nr ld nj nk nl nm bi translated">第三部分。构建您的Pokédex:使用Creator函数改进NgRx</li><li id="8e4b" class="ne nf it kk b kl nn ko no kr np kv nq kz nr ld nj nk nl nm bi translated">第四部分。构建您的Pokédex: @ngrx/data(即将推出)</li><li id="fc20" class="ne nf it kk b kl nn ko no kr np kv nq kz nr ld nj nk nl nm bi translated">第五部分。构建您的Pokédex:测试NgRx(即将推出)</li></ol><h1 id="e26b" class="mc md it bd me mf oe mh mi mj of ml mm jz og ka mo kc oh kd mq kf oi kg ms mt bi translated">资源</h1><ul class=""><li id="e468" class="ne nf it kk b kl mu ko mv kr oj kv ok kz ol ld od nk nl nm bi translated"><a class="ae le" href="https://medium.com/ngrx/announcing-ngrx-version-8-ngrx-data-create-functions-runtime-checks-and-mock-selectors-a44fac112627" rel="noopener">安诺宁NgRx 8 </a></li><li id="b9df" class="ne nf it kk b kl nn ko no kr np kv nq kz nr ld od nk nl nm bi translated"><a class="ae le" href="https://angular-academy.com/angular-architecture-best-practices/" rel="noopener ugc nofollow" target="_blank">角度架构最佳实践</a></li><li id="5707" class="ne nf it kk b kl nn ko no kr np kv nq kz nr ld od nk nl nm bi translated"><a class="ae le" href="https://www.ng-conf.org/2019/angular-architecture-specific-layers/" rel="noopener ugc nofollow" target="_blank">棱角分明的建筑——ng-conf</a></li><li id="8d2c" class="ne nf it kk b kl nn ko no kr np kv nq kz nr ld od nk nl nm bi translated"><a class="ae le" href="https://angular.io/guide/architecture" rel="noopener ugc nofollow" target="_blank">棱角分明的建筑(官方文件)</a></li><li id="e3f6" class="ne nf it kk b kl nn ko no kr np kv nq kz nr ld od nk nl nm bi translated"><a class="ae le" href="https://ngrx.io/" rel="noopener ugc nofollow" target="_blank"> NgRx </a></li><li id="52f0" class="ne nf it kk b kl nn ko no kr np kv nq kz nr ld od nk nl nm bi translated"><a class="ae le" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a></li></ul></div></div>    
</body>
</html>