<html>
<head>
<title>Last Seen: Build an AI-based Discord Rich Presence Client Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最后一次看到:使用Python构建一个基于人工智能的Discord富呈现客户端</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/last-seen-an-ai-based-discord-rich-presence-client-ad57d6f6ba3c?source=collection_archive---------6-----------------------#2022-09-08">https://betterprogramming.pub/last-seen-an-ai-based-discord-rich-presence-client-ad57d6f6ba3c?source=collection_archive---------6-----------------------#2022-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0926" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我如何使用Python构建它</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/06d526d5ba0dbe9788fa683b725b16e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kac0ktMacHJ2-OLW"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@alexbemore?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历山大·沙托夫</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="33a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我真的很喜欢不和谐丰富的存在功能。这就像你的电脑版的Snapchat stories，展示你此刻在做什么。对于我电脑上的大多数活动，我喜欢找到丰富的在线客户端在我的个人资料上广播我的活动——无论是玩游戏、<a class="ae kv" href="https://github.com/andweeb/presence.nvim" rel="noopener ugc nofollow" target="_blank">用Neovim </a>编码，还是<a class="ae kv" href="https://github.com/MALSync/MALSync/wiki/Discord-Rich-Presence" rel="noopener ugc nofollow" target="_blank">看动漫</a>。</p><p id="88be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对Discord的丰富存在的兴趣让我创建了自己的RPC(丰富存在客户端)。我创作了<em class="ls"> Last Seen </em>，这是一个不和谐的RPC，它使用人工智能来展示你的相机胶卷的最新情况。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/30a81b9d7bcc10abf1595e142d319a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_UGlF1Pw2Ku07jd9hTZXDA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最后一次看到:自动从谷歌照片中抓取最新图片，并使用人工智能生成说明</p></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="5e4f" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">最后看到的建筑</h1><h2 id="0ef3" class="mt mc iq bd md mu mv dn mh mw mx dp ml lf my mz mn lj na nb mp ln nc nd mr ne bi translated">成分</h2><ol class=""><li id="a271" class="nf ng iq ky b kz nh lc ni lf nj lj nk ln nl lr nm nn no np bi translated">丰富的在线客户端功能</li><li id="0291" class="nf ng iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">轮询云服务以获取相机胶卷中的最新照片</li><li id="39f8" class="nf ng iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">图像托管</li><li id="6a07" class="nf ng iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">使用人工智能为最新图像生成标题</li></ol><h2 id="6a33" class="mt mc iq bd md mu mv dn mh mw mx dp ml lf my mz mn lj na nb mp ln nc nd mr ne bi translated">正在查找RPC库</h2><p id="b6b8" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">首先，我希望能够编程设置我的不和谐丰富的存在的内容。为此，我找到了<a class="ae kv" href="https://github.com/qwertyquerty/pypresence" rel="noopener ugc nofollow" target="_blank"> pypresence </a>，这是一个用于编写不和谐RPC的Python包装器。这使得通过调用一个简单的<code class="fe ny nz oa ob b">Presence.update(...)</code>函数从代码中更新丰富的表示变得非常容易。</p><h2 id="9235" class="mt mc iq bd md mu mv dn mh mw mx dp ml lf my mz mn lj na nb mp ln nc nd mr ne bi translated">为照片轮询相机胶卷</h2><p id="3e62" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">下一步是能够根据用户相机胶卷中的最新照片更新丰富的现场图像。要从桌面应用程序中做到这一点，最简单的方法是从云中提取最新的照片。人们使用的照片托管平台主要有两个，iCloud和Google Photos。作为一名Google相册用户，我决定从实现Google相册支持开始。</p><p id="2d29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Google Cloud控制台注册了我的应用程序后，我启用了照片库API，并获取了OAuth流所需的凭证。OAuth允许应用程序与Google Photos API交互并访问用户数据。我用下面要点中的<code class="fe ny nz oa ob b">GooglePhotosClient.load_auth()</code>函数运行了OAuth流。</p><p id="400e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将轮询限制为每5分钟一次，以帮助减少程序的资源消耗。Google的API客户端库通过将所有的小细节抽象成几个函数来执行，使得与它们的端点进行交互变得非常容易。我使用下面要点中的<code class="fe ny nz oa ob b">GooglePhotosClient.get_latest_image_url()</code>功能在Google相册中查询了最新的图片URL。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于与Google相册API交互的Python类</p></figure><h2 id="bd96" class="mt mc iq bd md mu mv dn mh mw mx dp ml lf my mz mn lj na nb mp ln nc nd mr ne bi translated">图像托管</h2><p id="9388" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">我们的照片已经通过Google Photos托管在云上，所以你可能会奇怪，为什么图像托管被列为另一个组件？原因是Discord的丰富内容只允许最长256个字符的URL，而我们所有的Google相册URL都要长得多。为了解决这个问题，我想出了链接缩短和图像托管的解决方案。我确实试图在本地托管这些图片，但似乎不和谐要求URL托管在互联网上。虽然链接缩短会更有效，但我选择了图像托管，因为每个用户都必须用链接缩短服务设置自己的API键(像Bitly)，这可能会令人望而生畏。幸运的是，图像托管服务Imgur为托管的图像提供了比256个字符短得多的链接。它还允许匿名上传图像，只需要一个客户端ID，而不是客户端ID和密码。不幸的是，将来可能会有一个问题，一个客户端ID上的用户太多，达到API使用限制；然而，与大多数其他服务相比，使用Imgur创建新的客户端凭证非常容易，也非常用户友好。</p><p id="8a44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当该应用程序从Google相册中检测到最新图片URL的变化，它就会删除最后一张托管的Imgur图片并上传新图片。这可以防止图像混乱，并限制用户图像的曝光。即使程序终止，清理功能也会运行以删除最后一个托管映像。这些Imgur URLs是为了呈现图像而提供给Discord RPC的。请参见下面的Imgur客户端类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于与Imgur API交互的Python类</p></figure><h2 id="da10" class="mt mc iq bd md mu mv dn mh mw mx dp ml lf my mz mn lj na nb mp ln nc nd mr ne bi translated">图像字幕生成</h2><p id="3467" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">真正让这个应用程序从众多RPC中脱颖而出的最后一步是集成AI。仅仅看到最新的图像不会让最后看到的看起来有吸引力，它需要一些标题。我决定让人工智能为正在显示的任何图像生成标题。我考虑过训练我自己的模型，并在本地运行它来生成字幕，但我认为这样做计算量太大，而且不如在云上使用已建立的模型准确。用谷歌快速搜索图像标题生成API，我通过微软Azure的认知服务找到了一个。与微软Azure合作很愉快，因为它有非常清晰的说明和文档，告诉我如何使用他们的服务来满足我的需求。此外，为了防止触及API使用限制，我只在检测到新的URL时发送一个图像进行分析，就像我对Imgur主机所做的那样。下面是我写的通过Azure的端点生成标题的类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用人工智能生成图像标题的Python类</p></figure><h2 id="933f" class="mt mc iq bd md mu mv dn mh mw mx dp ml lf my mz mn lj na nb mp ln nc nd mr ne bi translated">GitHub知识库</h2><div class="oe of gp gr og oh"><a href="https://github.com/arhanjain/last-seen" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">GitHub-arhan Jain/最后出现时间</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">一个不和谐的丰富的存在客户端，使用人工智能炫耀你的相机卷的最新。在…中克隆此存储库</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov kp oh"/></div></div></a></div></div></div>    
</body>
</html>