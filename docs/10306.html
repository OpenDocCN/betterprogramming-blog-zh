<html>
<head>
<title>The Whole Shebang: Dockerfiles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">整个事情:Dockerfiles</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-whole-shebang-dockerfiles-5d59ace94d28?source=collection_archive---------3-----------------------#2021-12-24">https://betterprogramming.pub/the-whole-shebang-dockerfiles-5d59ace94d28?source=collection_archive---------3-----------------------#2021-12-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="40f9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在实践中学习，这个实用的教程通过例子解释了所有的docker文件说明</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7edcc1ea1a121d68db56e95e435ba0b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jP65gx9EYT2L3Tjl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nazahery?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">纳扎尔·穆罕默德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a02d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你开始了你的码头之旅。你想做的第一件事是:“构建我自己的容器应用”。</p><p id="a551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在部署容器应用程序之前，您需要将该应用程序打包成一个可执行的软件单元，也就是Docker映像。</p><p id="458a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，您需要一种Docker可以在构建时读取的配方文件。这些配方文件被称为Dockerfiles！</p><p id="387a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些包含由<code class="fe lv lw lx ly b">docker build</code>执行的指令，并遵循一个你可以在<a class="ae ky" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/reference/builder/</a>找到的文档化的语法。</p><p id="09f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了帮助你构建docker文件，这里有所有文档中支持的说明，但是有真实的例子。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="5ccc" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">从</h2><p id="e100" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">它为您的构建奠定了基础。此后的每条指令(从到另一个<strong class="lb iu">)都将在该基础上运行。</strong></p><p id="ba1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="73af" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> echo '<br/># This is the Dockerfile<br/>FROM ubuntu<br/># End of the Dockerfile' | docker build -t test-image -</span><span id="d301" class="mg mh it ly b gy nm nj l nk nl"><strong class="ly iu">$</strong> docker run test-image cat /etc/os-release</span></pre><p id="677f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出将是:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="848f" class="mg mh it ly b gy ni nj l nk nl">NAME=”Ubuntu”<br/>VERSION=”20.04.2 LTS (Focal Fossa)”<br/>…</span></pre><p id="c22b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着最终的容器非常像一个临时的Ubuntu文件系统。</p><h2 id="a05a" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">奔跑</h2><p id="849c" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">它允许您在构建时在前一层之上执行命令，并将结果提交给下一层和最终图像。</p><p id="38fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="ed12" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> echo '<br/># This is the Dockerfile<br/>FROM ubuntu</span><span id="41a5" class="mg mh it ly b gy nm nj l nk nl"># shell syntax <br/>RUN ls /<br/># exec syntax<br/>RUN ["touch", "/foo"]<br/># End of the Dockerfile' | docker build -t test-image -</span></pre><p id="5e81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出显示以下内容:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="c688" class="mg mh it ly b gy ni nj l nk nl">Step 2/3 : RUN ls /<br/> — -&gt; Running in 8dc25e5916f1<br/>bin<br/>boot<br/>dev<br/>etc<br/>home<br/>lib<br/>lib32<br/>…</span></pre><p id="a2fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这意味着:</p><ol class=""><li id="e1e9" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">在映像构建期间，每个<strong class="lb iu">运行</strong>指令的输出被打印到您的终端，</li><li id="8fbf" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">无论你用<strong class="lb iu"> RUN </strong>做了什么改变，都会保存在最终的Docker镜像中，即<code class="fe lv lw lx ly b">docker run test-image ls /foo</code>会找到<code class="fe lv lw lx ly b">/foo</code>文件。</li></ol><h2 id="d5c3" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">入口点</h2><p id="91dd" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">顾名思义，它允许您为容器执行定义一个默认的入口点。如果你愿意，这个入口点可以通过<strong class="lb iu"> CMD </strong>参数获得额外的参数。如果没有入口点，你的容器将只依靠<strong class="lb iu"> CMD </strong>，如果没有<strong class="lb iu"> CMD </strong>，那么容器将不知道运行什么。</p><p id="50e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="70b2" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> echo '<br/># This is the Dockerfile<br/>FROM ubuntu</span><span id="7bfa" class="mg mh it ly b gy nm nj l nk nl"># unset Ubuntu's default CMD<br/>CMD []<br/># End of the Dockerfile' | docker build -t test-image -</span></pre><p id="99b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查这个图像，你会发现<strong class="lb iu">入口点</strong>和<strong class="lb iu"> CMD </strong>都是<code class="fe lv lw lx ly b">null</code>:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="54aa" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$ </strong>docker image inspect test-image --format 'CMD: {{.Config.Cmd}} , ENTRYPOINT: {{.Config.Entrypoint}}'<br/>CMD: [] , ENTRYPOINT: []</span></pre><p id="b223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以如果你试着运行它，你会得到:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="3a9c" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$ </strong>docker run iii<br/>docker: Error response from daemon: No command specified.<br/>See 'docker run --help'.</span></pre><p id="f341" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们定义一下<strong class="lb iu">入口点:</strong></p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="66d0" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> echo '<br/># This is the Dockerfile<br/>FROM ubuntu</span><span id="8f71" class="mg mh it ly b gy nm nj l nk nl"># unset Ubuntu's default CMD<br/>CMD []</span><span id="74c9" class="mg mh it ly b gy nm nj l nk nl"># and set the entrypoint<br/>ENTRYPOINT ["/bin/ls"]<br/># End of the Dockerfile' | docker build -t test-image -</span></pre><p id="ab1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后你会得到:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="5a90" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$ </strong>docker run test-image<br/>bin<br/>boot<br/>dev<br/>etc<br/>home<br/>lib<br/>lib32<br/>lib64<br/>libx32<br/>media<br/>mnt<br/>opt<br/>proc<br/>root<br/>run<br/>sbin<br/>srv<br/>sys<br/>tmp<br/>usr<br/>var<br/><strong class="ly iu">$ </strong># and you can also give args to the default entrypoint<br/><strong class="ly iu">$ </strong>docker run test-image -l<br/>total 48<br/>lrwxrwxrwx   1 root root    7 Oct  6 16:47 bin -&gt; usr/bin<br/>drwxr-xr-x   2 root root 4096 Apr 15  2020 boot<br/>drwxr-xr-x   5 root root  340 Dec 22 18:17 dev<br/>drwxr-xr-x   1 root root 4096 Dec 22 18:17 etc<br/>drwxr-xr-x   2 root root 4096 Apr 15  2020 home<br/>lrwxrwxrwx   1 root root    7 Oct  6 16:47 lib -&gt; usr/lib<br/>lrwxrwxrwx   1 root root    9 Oct  6 16:47 lib32 -&gt; usr/lib32<br/>lrwxrwxrwx   1 root root    9 Oct  6 16:47 lib64 -&gt; usr/lib64<br/>lrwxrwxrwx   1 root root   10 Oct  6 16:47 libx32 -&gt; usr/libx32<br/>drwxr-xr-x   2 root root 4096 Oct  6 16:47 media<br/>drwxr-xr-x   2 root root 4096 Oct  6 16:47 mnt<br/>drwxr-xr-x   2 root root 4096 Oct  6 16:47 opt<br/>dr-xr-xr-x 172 root root    0 Dec 22 18:17 proc<br/>drwx------   2 root root 4096 Oct  6 16:58 root<br/>drwxr-xr-x   5 root root 4096 Oct  6 16:58 run<br/>lrwxrwxrwx   1 root root    8 Oct  6 16:47 sbin -&gt; usr/sbin<br/>drwxr-xr-x   2 root root 4096 Oct  6 16:47 srv<br/>dr-xr-xr-x  13 root root    0 Dec 22 18:17 sys<br/>drwxrwxrwt   2 root root 4096 Oct  6 16:58 tmp<br/>drwxr-xr-x  13 root root 4096 Oct  6 16:47 usr<br/>drwxr-xr-x  11 root root 4096 Oct  6 16:58 var</span></pre><p id="bb93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:和<code class="fe lv lw lx ly b">RUN</code>一样，<code class="fe lv lw lx ly b">ENTRYPOINT</code>可以写成<em class="ob">shell</em><strong class="lb iu"><em class="ob"/></strong>和<em class="ob"> exec </em>两种形式。</p><h2 id="5320" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">煤矿管理局</h2><p id="c0e5" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">简而言之，<code class="fe lv lw lx ly b">CMD</code> <strong class="lb iu"> </strong>让你为一个正在执行的容器提供默认值。这是什么意思？嗯，<code class="fe lv lw lx ly b">CMD</code>与<code class="fe lv lw lx ly b">ENTRYPOINT</code> <strong class="lb iu"> </strong>并排上场。事实上，许多开发人员通常会将这两者混为一谈。帮助你弄清楚这两者如何协同工作的最佳信息可以在这里找到。此表向您展示了定义这些参数的不同形式是如何组合在一起的，以及它们的最终形式是什么样的。</p><p id="93fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们这个简单的例子中，举个例子:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="a138" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> echo '<br/># This is the Dockerfile<br/>FROM ubuntu</span><span id="6ed0" class="mg mh it ly b gy nm nj l nk nl"># set the entrypoint<br/>ENTRYPOINT ["/bin/ls"]</span><span id="dad5" class="mg mh it ly b gy nm nj l nk nl"># set a default arg for ls<br/>CMD ["-l"]<br/># End of the Dockerfile' | docker build -t test-image -</span></pre><p id="3fb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所料，您将获得与上一节相同的输出，但是在启动容器时不必指定命令:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="1146" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$ </strong>docker run test-image<br/>total 48<br/>lrwxrwxrwx   1 root root    7 Oct  6 16:47 bin -&gt; usr/bin<br/>drwxr-xr-x   2 root root 4096 Apr 15  2020 boot<br/>drwxr-xr-x   5 root root  340 Dec 22 18:17 dev<br/>drwxr-xr-x   1 root root 4096 Dec 22 18:17 etc<br/>drwxr-xr-x   2 root root 4096 Apr 15  2020 home<br/>lrwxrwxrwx   1 root root    7 Oct  6 16:47 lib -&gt; usr/lib<br/>lrwxrwxrwx   1 root root    9 Oct  6 16:47 lib32 -&gt; usr/lib32<br/>lrwxrwxrwx   1 root root    9 Oct  6 16:47 lib64 -&gt; usr/lib64<br/>lrwxrwxrwx   1 root root   10 Oct  6 16:47 libx32 -&gt; usr/libx32<br/>drwxr-xr-x   2 root root 4096 Oct  6 16:47 media<br/>drwxr-xr-x   2 root root 4096 Oct  6 16:47 mnt<br/>drwxr-xr-x   2 root root 4096 Oct  6 16:47 opt<br/>dr-xr-xr-x 172 root root    0 Dec 22 18:17 proc<br/>drwx------   2 root root 4096 Oct  6 16:58 root<br/>drwxr-xr-x   5 root root 4096 Oct  6 16:58 run<br/>lrwxrwxrwx   1 root root    8 Oct  6 16:47 sbin -&gt; usr/sbin<br/>drwxr-xr-x   2 root root 4096 Oct  6 16:47 srv<br/>dr-xr-xr-x  13 root root    0 Dec 22 18:17 sys<br/>drwxrwxrwt   2 root root 4096 Oct  6 16:58 tmp<br/>drwxr-xr-x  13 root root 4096 Oct  6 16:47 usr<br/>drwxr-xr-x  11 root root 4096 Oct  6 16:58 var</span></pre><p id="d701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，如果您在启动容器时传递了一个命令，它将覆盖docker文件中的默认<strong class="lb iu"> CMD </strong>。</p><h2 id="3f94" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">标签</h2><p id="9368" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这只是元数据。将您的Docker图像标记为非常有用，这将为其最终用户提供关于该图像的附加信息。例如，假设您想要构建一个Docker映像，用户可以从中获得关于其维护者、支持电子邮件、文档页面、各自的git提交以及可能的友好消息的信息。</p><p id="8b34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该这样做:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="2785" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> echo '<br/># This is the Dockerfile<br/>FROM ubuntu</span><span id="46e5" class="mg mh it ly b gy nm nj l nk nl"># set the labels<br/>LABEL maintainer="cristovaocordeiro"<br/>LABEL "support contact"="<a class="ae ky" href="mailto:cristovaocordeiro@medium.com" rel="noopener" target="_blank">cristovaocordeiro@medium.com</a>"<br/>LABEL docs="<a class="ae ky" href="https://medium.com/@cristovaocordeiro" rel="noopener">https://medium.com/@cristovaocordeiro</a>" commit="xyz"<br/>LABEL message="I hope you enjoy this tutorial. \<br/>Make sure you subscribe for more content like this"</span><span id="3e16" class="mg mh it ly b gy nm nj l nk nl"># End of the Dockerfile' | docker build -t test-image -</span></pre><p id="5fdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，每个用户都将能够访问这些元数据，而无需运行映像，方法是:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="3073" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> docker image inspect test-image --format '{{json .Config.Labels}}' | jq<br/>{<br/>  "commit": "xyz",<br/>  "docs": "<a class="ae ky" href="https://medium.com/@cristovaocordeiro" rel="noopener">https://medium.com/@cristovaocordeiro</a>",<br/>  "maintainer": "cristovaocordeiro",<br/>  "message": "I hope you enjoy this tutorial Make sure you subscribe for more content like this",<br/>  "support contact": "<a class="ae ky" href="mailto:cristovaocordeiro@medium.com" rel="noopener" target="_blank">cristovaocordeiro@medium.com</a>"<br/>}</span></pre><h2 id="0871" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">揭露</h2><p id="3658" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这通常被误解为可以用来从容器中自动发布端口。<em class="ob">不是！尽管如此，区别还是很明显的。使用<code class="fe lv lw lx ly b">EXPOSE</code>，您可以通知Docker您的Docker映像已经标记了哪些端口用于发布。那不一样。</em></p><p id="b45a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们假设如下:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="302b" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> echo '<br/># This is the Dockerfile<br/>FROM ubuntu</span><span id="cfbb" class="mg mh it ly b gy nm nj l nk nl"># expose port<br/>EXPOSE 80</span><span id="b7ce" class="mg mh it ly b gy nm nj l nk nl"># End of the Dockerfile' | docker build -t test-image -</span></pre><p id="111d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在运行它，你会看到事实上没有任何端口被发布，除非<strong class="lb iu">，</strong>你使用<code class="fe lv lw lx ly b">docker run</code>的<code class="fe lv lw lx ly b">-P</code>选项！</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="0d15" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$ </strong>docker run -d test-image sleep 10<br/><strong class="ly iu">$ </strong>docker ps<br/>CONTAINER ID   IMAGE        COMMAND       CREATED        STATUS        PORTS     NAMES<br/>8f7af69c15dc   test-image   "sleep 10"   1 second ago   Up 1 second   <strong class="ly iu">80/tcp</strong>    pensive_goodall<br/><strong class="ly iu">$<br/>$ </strong># now publish it<br/><strong class="ly iu">$ </strong>docker run -d <strong class="ly iu">-P</strong> test-image sleep 10<br/>CONTAINER ID   IMAGE        COMMAND       CREATED         STATUS        PORTS                   NAMES<br/>2509758c86b3   test-image   "sleep 10"   2 seconds ago   Up 1 second   <strong class="ly iu">0.0.0.0:55000-&gt;80/tcp</strong>   flamboyant_einstein</span></pre><h2 id="1250" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">包封/包围（动词envelop的简写）</h2><p id="8fa4" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这个很简单。顾名思义，它允许您在Docker图像中设置环境变量。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="3138" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> echo '<br/># This is the Dockerfile<br/>FROM ubuntu</span><span id="206e" class="mg mh it ly b gy nm nj l nk nl"># set env vars<br/>ENV A=1<br/>ENV B="two"<br/>ENV C three<br/>ENV D=4 E="five"</span><span id="e10f" class="mg mh it ly b gy nm nj l nk nl"># End of the Dockerfile' | docker build -t test-image -</span></pre><p id="682d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后您会发现这些env变量是您从这个Docker映像创建的所有容器的固有部分(除非您使用<code class="fe lv lw lx ly b">env</code>选项和<code class="fe lv lw lx ly b">docker run</code>命令覆盖它们):</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="96aa" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> docker run test-image env<br/>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br/>HOSTNAME=df7db5ae7bb1<br/>A=1<br/>B=two<br/>C=three<br/>D=4<br/>E=five<br/>HOME=/root</span></pre><h2 id="59da" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">复制</h2><p id="d431" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">它允许您将文件或目录从构建环境复制到Docker映像上。</p><p id="18ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们假设在我们的工作环境中有几个文件(<code class="fe lv lw lx ly b">a.txt</code>和<code class="fe lv lw lx ly b">b.txt</code>)和一个文件夹(<code class="fe lv lw lx ly b">c</code>):</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="b8b2" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> echo '<br/># This is the Dockerfile<br/>FROM ubuntu</span><span id="9cba" class="mg mh it ly b gy nm nj l nk nl"># copy files and folder <br/>COPY a.txt /tmp/<br/>COPY --chown=1000:1001 b.txt /tmp/<br/>COPY ["c", "/tmp/c"]</span><span id="12be" class="mg mh it ly b gy nm nj l nk nl"># End of the Dockerfile' &gt; Dockerfile<br/><strong class="ly iu">$</strong> <br/><strong class="ly iu">$</strong> docker build -t test-image .</span></pre><p id="64be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:<strong class="lb iu"> </strong>使用<code class="fe lv lw lx ly b"><strong class="lb iu">COPY</strong></code> <strong class="lb iu"> </strong>或<code class="fe lv lw lx ly b">ADD</code>时，不能从<code class="fe lv lw lx ly b">stding</code>开始构建图像，因为需要构建上下文。</p><p id="098a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在这种情况下，我们可以通过以下方式仔细检查复制的文件:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="358d" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$ </strong>docker run test-image ls -Rl /tmp<br/>/tmp:<br/>total 4<br/>-rw-r--r-- 1 root root    0 Dec 23 18:52 a.txt<br/>-rw-r--r-- 1 <strong class="ly iu">1000 1001</strong>    0 Dec 23 18:52 b.txt<br/>drwxr-xr-x 2 root root 4096 Dec 23 19:06 <strong class="ly iu">c</strong></span><span id="13c3" class="mg mh it ly b gy nm nj l nk nl">/tmp/c:<br/>total 0<br/>-rw-r--r-- 1 root root 0 Dec 23 18:55 c.txt</span></pre><h2 id="7c78" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">注意缺陷障碍 (Attention Deficit Disorder)</h2><p id="2483" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">很像<code class="fe lv lw lx ly b">COPY</code>。事实上，它做得差不多，但是它也允许您从本地工作环境之外的其他来源复制文件:</p><ul class=""><li id="e6cc" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu oc nt nu nv bi translated">URL:将资源从URL直接下载到Docker映像中的目标路径</li><li id="377c" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu oc nt nu nv bi translated">tarballs:获取一个压缩的tarball，并将其自动解压缩到Docker映像中的目标目录</li></ul><p id="fc7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例(假设我们的本地环境中有一个tarball <code class="fe lv lw lx ly b">foo.tar</code>，包含上一个示例中的文件和文件夹):</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="1ed7" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> echo '<br/># This is the Dockerfile<br/>FROM ubuntu</span><span id="4e03" class="mg mh it ly b gy nm nj l nk nl"># add files from URL and tarball<br/>ADD foo.tar /tmp<br/>ADD <a class="ae ky" href="https://miro.medium.com/fit/c/262/262/1*Z22Wr8H1voxC2Ze25qwJ4Q.png" rel="noopener">https://miro.medium.com/fit/c/262/262/1*Z22Wr8H1voxC2Ze25qwJ4Q.png</a> /tmp</span><span id="0368" class="mg mh it ly b gy nm nj l nk nl"># End of the Dockerfile' &gt; Dockerfile<br/><strong class="ly iu">$</strong> <br/><strong class="ly iu">$</strong> docker build -t test-image .</span></pre><p id="a2a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后你会有:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="baab" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$ </strong>docker run test-image ls -Rl /tmp<br/>/tmp:<br/>total 16<br/>-rw------- 1 root root    6696 Jan  1  1970 1*Z22Wr8H1voxC2Ze25qwJ4Q.png<br/>-rw-r--r-- 1  501 dialout 2560 Dec 23 19:14 a.txt<br/>-rw-r--r-- 1  501 dialout    0 Dec 23 18:52 b.txt<br/>drwxr-xr-x 2  501 dialout 4096 Dec 23 19:00 c</span><span id="71a3" class="mg mh it ly b gy nm nj l nk nl">/tmp/c:<br/>total 0<br/>-rw-r--r-- 1 501 dialout 0 Dec 23 18:55 c.txt</span></pre><h2 id="f771" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">卷</h2><p id="77a2" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这让您可以告诉Docker，每当从您的Docker映像启动一个容器时，就自动创建一个挂载点。假设我希望从我的映像启动所有容器，在Docker卷中保存一个文件<code class="fe lv lw lx ly b">foo.txt</code>:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="95d7" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> echo '<br/># This is the Dockerfile<br/>FROM ubuntu</span><span id="4afb" class="mg mh it ly b gy nm nj l nk nl">RUN echo "subscribe for more content like this" &gt; /tmp/foo.txt</span><span id="8d32" class="mg mh it ly b gy nm nj l nk nl"># create a mountpoint on /tmp<br/>VOLUME /tmp</span><span id="6b5a" class="mg mh it ly b gy nm nj l nk nl"># End of the Dockerfile' &gt; Dockerfile<br/><strong class="ly iu">$</strong> <br/><strong class="ly iu">$</strong> docker build -t test-image .</span></pre><p id="7e29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在从这个映像运行容器之前，我可以仔细检查系统中是否没有卷，但是一旦我运行了容器，我将有一个新的卷(由Docker随机命名)，其中包含我的<code class="fe lv lw lx ly b">foo.txt</code>文件:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="84a1" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$ </strong>docker volume ls<br/>DRIVER    VOLUME NAME<br/><strong class="ly iu">$<br/>$ </strong>docker run test-image<strong class="ly iu"><br/>$<br/>$ </strong>docker volume ls<br/>DRIVER    VOLUME NAME<br/>local     28d64c77b5bb56b0fab699fd291ff71a776be6b5e893a3c482d962dc7894d465<strong class="ly iu"><br/>$<br/>$ </strong>docker volume inspect 28d64c77b5bb56b0fab699fd291ff71a776be6b5e893a3c482d962dc7894d465<br/>[<br/>    {<br/>        "CreatedAt": "2021-12-23T19:55:20Z",<br/>        "Driver": "local",<br/>        "Labels": null,<br/>        <strong class="ly iu">"Mountpoint": "/var/lib/docker/volumes/28d64c77b5bb56b0fab699fd291ff71a776be6b5e893a3c482d962dc7894d465/_data",</strong><br/>        "Name": "28d64c77b5bb56b0fab699fd291ff71a776be6b5e893a3c482d962dc7894d465",<br/>        "Options": null,<br/>        "Scope": "local"<br/>    }<br/>]</span><span id="7bfe" class="mg mh it ly b gy nm nj l nk nl"><strong class="ly iu">$<br/>$ </strong>ls -l /var/lib/docker/volumes/28d64c77b5bb56b0fab699fd291ff71a776be6b5e893a3c482d962dc7894d465/_data</span><span id="e622" class="mg mh it ly b gy nm nj l nk nl">total 4<br/>-rw-r--r-- 1 root root 37 Dec 23 19:38 foo.txt</span></pre><h2 id="7a7c" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">用户</h2><p id="7b01" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">不，这不会让您创建新用户。相反，这让您<strong class="lb iu">为docker文件中的所有后续指令设置</strong>用户，并在从映像启动指令时设置容器。</p><p id="7f49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="d43c" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> echo '<br/># This is the Dockerfile<br/>FROM ubuntu</span><span id="6549" class="mg mh it ly b gy nm nj l nk nl"># need to create the user first<br/>RUN adduser --disabled-password --gecos "" medium</span><span id="acc8" class="mg mh it ly b gy nm nj l nk nl"># set the user<br/>USER medium</span><span id="3d7d" class="mg mh it ly b gy nm nj l nk nl">RUN whoami</span><span id="11ce" class="mg mh it ly b gy nm nj l nk nl"># End of the Dockerfile' | docker build -t test-image -</span></pre><p id="65b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个构建的输出中，您会发现<code class="fe lv lw lx ly b">whoami</code>的结果如下:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="a988" class="mg mh it ly b gy ni nj l nk nl">...<br/>Step 4/4 : RUN whoami<br/> ---&gt; Running in b9c344af5969<br/><strong class="ly iu">medium</strong><br/>Removing intermediate container b9c344af5969<br/>...</span></pre><p id="0b8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您从它运行一个容器，您会发现相同的默认用户:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="9baf" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> docker run test-image whoami<br/>medium</span></pre><h2 id="e905" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">工作方向</h2><p id="d5d2" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这可能是docker文件中最简单的指令。它只是让您为docker文件和未来容器的所有后续指令设置工作目录。您可以在docker文件中多次使用它(非常像一个<code class="fe lv lw lx ly b">cd &lt;path&gt;</code>)，注意无论最后出现的<code class="fe lv lw lx ly b">WORKDIR</code>是什么，都将在运行的容器中生效。</p><p id="3a3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="3df6" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> echo '<br/># This is the Dockerfile<br/>FROM ubuntu</span><span id="88bd" class="mg mh it ly b gy nm nj l nk nl"># let's change the working dir a few times<br/>RUN pwd<br/>WORKDIR /my/dir<br/>RUN pwd</span><span id="1581" class="mg mh it ly b gy nm nj l nk nl">WORKDIR subdir<br/>RUN pwd</span><span id="5a19" class="mg mh it ly b gy nm nj l nk nl">WORKDIR /newdir<br/>RUN pwd</span><span id="ad9d" class="mg mh it ly b gy nm nj l nk nl"># End of the Dockerfile' | docker build -t test-image -</span></pre><p id="395c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这次构建，您会发现<code class="fe lv lw lx ly b">pwd</code>正在发生变化:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="e5b7" class="mg mh it ly b gy ni nj l nk nl">...<br/>Step 2/8 : RUN pwd<br/> ---&gt; Running in 41d16b2a91ea<br/>/<br/>Removing intermediate container 41d16b2a91ea<br/> ---&gt; b2aee049b0a5<br/>Step 3/8 : WORKDIR /my/dir<br/> ---&gt; Running in 9c7d0e17c797<br/>Removing intermediate container 9c7d0e17c797<br/> ---&gt; 34371fd7f7f7<br/>Step 4/8 : RUN pwd<br/> ---&gt; Running in 7b7ed0a84e9f<br/><strong class="ly iu">/my/dir</strong><br/>Removing intermediate container 7b7ed0a84e9f<br/> ---&gt; 306f967c5ba4<br/>Step 5/8 : WORKDIR subdir<br/> ---&gt; Running in 2a3915cb09e9<br/>Removing intermediate container 2a3915cb09e9<br/> ---&gt; 25e00401902a<br/>Step 6/8 : RUN pwd<br/> ---&gt; Running in d1e5de3c1842<br/><strong class="ly iu">/my/dir/subdir</strong><br/>Removing intermediate container d1e5de3c1842<br/> ---&gt; c35828117d72<br/>Step 7/8 : WORKDIR /newdir<br/> ---&gt; Running in e4b450689a85<br/>Removing intermediate container e4b450689a85<br/> ---&gt; f36a27bed479<br/>Step 8/8 : RUN pwd<br/> ---&gt; Running in 6e6c61b1419d<br/><strong class="ly iu">/newdir<br/></strong>Removing intermediate container 6e6c61b1419d<br/>...</span></pre><p id="41d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当运行一个容器时，您也会在<code class="fe lv lw lx ly b">/newdir</code>找到您的工作目录:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="9b1f" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> docker run test-image pwd<br/>/newdir</span></pre><h2 id="9f38" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">银</h2><p id="a0ca" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这条有用的指令允许您设置运行<code class="fe lv lw lx ly b">docker build</code>命令时Dockerfile期望您提供的编译时参数。如果您需要参数化您的构件，您可以这样做:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="e57d" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> echo '<br/># This is the Dockerfile<br/>FROM ubuntu</span><span id="4211" class="mg mh it ly b gy nm nj l nk nl">RUN echo $local_var</span><span id="e142" class="mg mh it ly b gy nm nj l nk nl"># only now this arg becomes available<br/>ARG local_var=default_local_value</span><span id="ea3e" class="mg mh it ly b gy nm nj l nk nl">RUN echo $local_var</span><span id="17c2" class="mg mh it ly b gy nm nj l nk nl"># End of the Dockerfile' &gt; Dockerfile</span></pre><p id="ef19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当构建这个图像时，我们可以随意定义<code class="fe lv lw lx ly b">local_var</code>,如果我们不这样做，它将采用默认值:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="8395" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$ </strong>docker build -t test-image .<br/>Sending build context to Docker daemon  1.336MB<br/>Step 1/4 : FROM ubuntu<br/> ---&gt; ba6acccedd29<br/>Step 2/4 : RUN echo $local_var<br/> ---&gt; Running in 6162ed110103</span><span id="bc52" class="mg mh it ly b gy nm nj l nk nl">Removing intermediate container 6162ed110103<br/> ---&gt; d0c3f0bdc3f0<br/>Step 3/4 : ARG local_var=default_local_value<br/> ---&gt; Running in c037666f9bb1<br/>Removing intermediate container c037666f9bb1<br/> ---&gt; 1d3922646297<br/>Step 4/4 : RUN echo $local_var<br/> ---&gt; Running in 3512775af26f<br/><strong class="ly iu">default_local_value</strong><br/>Removing intermediate container 3512775af26f<br/> ---&gt; b20b82d78c89<br/>Successfully built b20b82d78c89<br/>Successfully tagged test-image:latest<br/><strong class="ly iu">$ <br/>$ </strong>docker build -t test-image --build-arg local_var=FOO --no-cache .<br/>Sending build context to Docker daemon  1.336MB<br/>Step 1/4 : FROM ubuntu<br/> ---&gt; ba6acccedd29<br/>Step 2/4 : RUN echo $local_var<br/> ---&gt; Running in a389271fe6ef</span><span id="14b8" class="mg mh it ly b gy nm nj l nk nl">Removing intermediate container a389271fe6ef<br/> ---&gt; a811d17ee724<br/>Step 3/4 : ARG local_var=default_local_value<br/> ---&gt; Running in a02ee27d7862<br/>Removing intermediate container a02ee27d7862<br/> ---&gt; e430886a587a<br/>Step 4/4 : RUN echo $local_var<br/> ---&gt; Running in fb459bebe516<br/><strong class="ly iu">FOO</strong><br/>Removing intermediate container fb459bebe516<br/> ---&gt; 65f3b5a18911<br/>Successfully built 65f3b5a18911<br/>Successfully tagged test-image:latest</span></pre><h2 id="4517" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">ONBUILD</h2><p id="6450" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这种指导可能永远都不需要，这取决于你的图像是为哪些目标受众制作的。</p><p id="72a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，这允许您定义一个指令，当您的或某人使用您的映像作为不同构建的基础映像时，就执行该指令。</p><p id="984b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们假设下面的Dockerfile:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="b68c" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> echo '<br/># This is the Dockerfile<br/>FROM ubuntu</span><span id="d066" class="mg mh it ly b gy nm nj l nk nl"># for future child builds, run this<br/>ONBUILD RUN echo "this image is being built from <a class="ae ky" href="http://twitter.com/cristovaocordeiro" rel="noopener ugc nofollow" target="_blank">@cristovaocordeiro</a>'s tutorial"</span><span id="de0b" class="mg mh it ly b gy nm nj l nk nl"># End of the Dockerfile' | docker build -t test-image -</span></pre><p id="1229" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，对于这个<code class="fe lv lw lx ly b">test-image</code>成为基础的所有图像，您将得到:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="0208" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$ </strong>echo 'FROM test-image' | docker build - <br/>Sending build context to Docker daemon  2.048kB<br/>Step 1/1 : FROM test-image<br/># Executing 1 build trigger<br/> ---&gt; Running in 7ed28561ef91<br/><strong class="ly iu">this image is being built from </strong><a class="ae ky" href="http://twitter.com/cristovaocordeiro" rel="noopener ugc nofollow" target="_blank"><strong class="ly iu">@cristovaocordeiro</strong></a><strong class="ly iu">'s tutorial<br/>Removing intermediate container 7ed28561ef91</strong><br/> ---&gt; 318be0653ae4<br/>Successfully built 318be0653ae4</span></pre><h2 id="a9a7" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">停止信号</h2><p id="bc17" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">简单明了:它让您重新定义将导致容器退出的系统调用。默认情况下，所有容器都设置为<code class="fe lv lw lx ly b">SIGTERM</code>。但是您可以做以下事情来使您的容器仅在收到<code class="fe lv lw lx ly b">SIGKILL</code>时退出:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="e8ab" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> echo '<br/># This is the Dockerfile<br/>FROM ubuntu</span><span id="ff68" class="mg mh it ly b gy nm nj l nk nl"># redefine exit system call<br/>STOPSIGNAL SIGKILL</span><span id="035c" class="mg mh it ly b gy nm nj l nk nl"># End of the Dockerfile' | docker build -t test-image -</span></pre><p id="1b4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要确认:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="c4b3" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$ </strong>docker inspect test-image --format '{{.Config.StopSignal}}'<br/>SIGKILL</span></pre><h2 id="9c3b" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">健康检查</h2><p id="22d3" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">健康检查是有用的机制，通过它您可以定义自己的探测器来验证您的容器是否健康。Docker将获取这些探测器的输出，并将所述信息添加到容器的状态中。</p><p id="2e73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们相信我们的容器是健康的，当且仅当路径<code class="fe lv lw lx ly b">/tmp_custom</code>存在！此外，让我们还使我们的探测器在1s后启动，每秒运行一次(<code class="fe lv lw lx ly b">--interval</code>)，3s后超时(<code class="fe lv lw lx ly b">--timeout</code>)，如果探测器在容器生命周期的前2s失败，不认为容器不健康(<code class="fe lv lw lx ly b">--start-period</code>)，并重试探测器命令3次(<code class="fe lv lw lx ly b">--retries</code>):</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="fd82" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> echo '<br/># This is the Dockerfile<br/>FROM ubuntu</span><span id="9328" class="mg mh it ly b gy nm nj l nk nl"># container are healthy only if<br/>HEALTHCHECK --interval=1s --timeout=3s --start-period=2s --retries=3 CMD [ -d /tmp_custom ]</span><span id="531d" class="mg mh it ly b gy nm nj l nk nl"># End of the Dockerfile' | docker build -t test-image -</span></pre><p id="3bc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们运行一下，看看会发生什么:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="0ef2" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$ </strong>docker run -d test-image sleep 20<br/>588bdfb7a633a465859510d6850b6b78326d15ca8b642a768465ebc2ef37edfd<br/><strong class="ly iu">$<br/>$ </strong>docker ps # immediately after starting it<br/>CONTAINER ID   IMAGE        COMMAND      CREATED         STATUS                           PORTS     NAMES<br/>588bdfb7a633   test-image   "sleep 20"   2 seconds ago   Up 1 second (health: <strong class="ly iu">starting</strong>)             nervous_booth<br/><strong class="ly iu">$<br/>$ </strong>docker ps # a few seconds later<br/>CONTAINER ID   IMAGE        COMMAND      CREATED         STATUS                     PORTS     NAMES<br/>588bdfb7a633   test-image   "sleep 20"   5 seconds ago   Up 4 seconds (<strong class="ly iu">unhealthy</strong>)             nervous_booth</span></pre><p id="f1d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以容器是不健康的，导致<code class="fe lv lw lx ly b">tmp_custom</code>文件夹似乎不存在。检查容器将为您提供更多关于探头故障的信息:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="b917" class="mg mh it ly b gy ni nj l nk nl">docker inspect nervous_booth --format '{{json .State.Health}}' | jq<br/>{<br/>  "Status": "unhealthy",<br/>  "FailingStreak": 17,<br/>  "Log": [<br/>    {<br/>      "Start": "2021-12-23T20:49:18.8034984Z",<br/>      "End": "2021-12-23T20:49:18.9115695Z",<br/>      "ExitCode": 1,<br/>      "Output": ""<br/>    },<br/>    {<br/>      "Start": "2021-12-23T20:49:19.9204635Z",<br/>      "End": "2021-12-23T20:49:20.0230435Z",<br/>      "ExitCode": 1,<br/>      "Output": ""<br/>    },<br/>    {<br/>      "Start": "2021-12-23T20:49:21.034769Z",<br/>      "End": "2021-12-23T20:49:21.1171521Z",<br/>      "ExitCode": 1,<br/>      "Output": ""<br/>    },<br/>    {<br/>      "Start": "2021-12-23T20:49:22.1307374Z",<br/>      "End": "2021-12-23T20:49:22.2147348Z",<br/>      "ExitCode": 1,<br/>      "Output": ""<br/>    },<br/>    {<br/>      "Start": "2021-12-23T20:49:23.2238803Z",<br/>      "End": "2021-12-23T20:49:23.3248102Z",<br/>      "ExitCode": 1,<br/>      "Output": ""<br/>    }<br/>  ]<br/>}</span></pre><p id="a9cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们确保我们的容器是健康的:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="874a" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">$</strong> docker run -d test-image sh -c 'mkdir /tmp_custom &amp;&amp; sleep 20'<br/>327440b2758c40f4058f1ea86e9ee9e9874eed482d4f9b3f60ef5fc0ea2f101e<br/><strong class="ly iu">$</strong> docker ps<br/>CONTAINER ID   IMAGE        COMMAND                  CREATED         STATUS                   PORTS     NAMES<br/>327440b2758c   test-image   "sh -c 'mkdir /tmp_c…"   4 seconds ago   Up 4 seconds (<strong class="ly iu">healthy</strong>)             nervous_heisenberg</span></pre><h2 id="d9a4" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">壳</h2><p id="4915" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Linux的默认shell是<code class="fe lv lw lx ly b">/bin/sh</code>，但是您可以使用<strong class="lb iu"> SHELL来更改它。</strong>对于可以有多个shells的Windows容器来说可能更有意义(比如<code class="fe lv lw lx ly b">sh</code>、<code class="fe lv lw lx ly b">cmd</code>、<code class="fe lv lw lx ly b">powershell</code>)。例如，如果<code class="fe lv lw lx ly b">powershell</code>应该是您的默认shell，那么只需将<code class="fe lv lw lx ly b">SHELL ["powershell", "-command"]</code>添加到您的docker文件中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="375d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧啊！我认为这给了你一个来自Docker文档的总结版本，并带有一些实际的例子。你可以找到<a class="ae ky" href="https://levelup.gitconnected.com/the-whole-docker-shebang-part-1-docker-build-470f0c265702" rel="noopener ugc nofollow" target="_blank">我的另一篇文章</a>，里面有关于如何使用<code class="fe lv lw lx ly b">docker build</code>及其所有选项的详尽解释。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="02f9" class="mg mh it ly b gy ni nj l nk nl"><strong class="ly iu">Want to Connect With the Author?</strong></span><span id="8f9e" class="mg mh it ly b gy nm nj l nk nl">I hope the above article is useful for you, and serves as a good complement to my <a class="ae ky" href="https://www.udemy.com/course/docker-crash-course-learn-from-experience-for-beginners/" rel="noopener ugc nofollow" target="_blank">Docker course for beginners</a>.</span></pre></div></div>    
</body>
</html>