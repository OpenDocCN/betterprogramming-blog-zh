<html>
<head>
<title>How To Create an API-Less Full Stack App With React and Jitar</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用React和Jitar创建一个无API的全栈App</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-an-api-less-full-stack-application-with-react-and-jitar-602bcbabc66b?source=collection_archive---------7-----------------------#2022-11-22">https://betterprogramming.pub/how-to-create-an-api-less-full-stack-application-with-react-and-jitar-602bcbabc66b?source=collection_archive---------7-----------------------#2022-11-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="873b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何使用Jitar来自动化全栈应用程序中的所有客户机-服务器通信</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/32f9247a20057d1e6d3e0df7109e6201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*izDwJby-fv-mMynuQOHmkA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@prateekkatyal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">普拉蒂克·卡蒂亚尔</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="d63d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/how-i-speed-up-full-stack-development-by-not-building-apis-7f768335bec6">上一篇文章</a>中，我写了通过不构建API来加速全栈应用程序的选项，以及我如何创建了<a class="ae kv" href="https://github.com/MaskingTechnology/jitar" rel="noopener ugc nofollow" target="_blank"> Jitar </a>。</p><p id="4758" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将深入研究如何在真实的全栈应用中使用我的。为此，我们将使用<a class="ae kv" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>和Jitar创建一个简单的应用程序。我喜欢类型安全，所以我将为这个应用程序使用TypeScript。结果也可以在<a class="ae kv" href="https://github.com/petermasking/react-jitar" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="e695" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您已经阅读了本文，我假设您已经有了一些全栈经验。虽然本文使用React作为前端框架，但是也可以使用Angular、Vue等。</p><p id="583d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们开始之前，确保您的机器上安装了<a class="ae kv" href="https://nodejs.org" rel="noopener ugc nofollow" target="_blank"> Node.js </a>版本18.7或更高版本。如果您还想使用<a class="ae kv" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>，请确保您安装了版本4.4.2或更高版本。准备，预备，开始！</p><h1 id="3a6f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">步骤1:设置一个React项目</h1><p id="6baf" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了创建React应用程序，我们将使用<a class="ae kv" href="https://vitejs.dev/" rel="noopener ugc nofollow" target="_blank"> Vite </a>和react-ts模板。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="f80b" class="mu lt iq mq b be mv mw l mx my">npm create -y vite@latest react-jitar -- --template react-ts<br/>cd react-jitar<br/>npm install<br/>npm run dev</span></pre><p id="160c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在网络浏览器中打开<code class="fe mz na nb mq b"><a class="ae kv" href="http://localhost:5173/" rel="noopener ugc nofollow" target="_blank">http://localhost:5173/</a></code>时，您应该会看到Vite和React标志。</p><p id="a5f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将通过添加一个生成欢迎消息的简单函数来扩展我们的应用程序。为了稍后在应用程序中挂钩Jitar，我们需要在<code class="fe mz na nb mq b">src</code>文件夹中创建一个共享文件夹。该文件夹包含客户端和服务器之间共享的所有组件。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="69b5" class="mu lt iq mq b be mv mw l mx my">cd src<br/>mkdir shared</span></pre><p id="8d85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以添加第一个共享函数了。姑且称之为<code class="fe mz na nb mq b">sayHello</code>，并赋予其以下内容。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="bb2f" class="mu lt iq mq b be mv mw l mx my">// src/shared/sayHello.ts<br/>export async function sayHello(name: string): Promise&lt;string&gt;<br/>{<br/>    return `Hello, ${name}!`;<br/>}</span></pre><p id="ef39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，这个函数是异步的。这是一个重要的附加功能，它使得该功能可以在网络中分布。</p><p id="647d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用这个功能来欢迎我们。可以从任何React组件中直接调用该函数。我现在将使用App组件。我已经简化了本例中生成的组件，但是您可以随意制作自己的版本。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="0a77" class="mu lt iq mq b be mv mw l mx my">// src/App.tsx<br/>import './App.css'<br/>import { sayHello } from './shared/sayHello'<br/><br/>const message = await sayHello('React + Jitar')<br/><br/>function App()<br/>{<br/>    return (<br/>        &lt;div className="App"&gt;<br/>        &lt;h1&gt;{message}&lt;/h1&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}<br/><br/>export default App</span></pre><p id="b4c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保存文件后，您应该会在浏览器中看到我们的新消息。为了简化，我通过在组件外部创建消息来避免使用React钩子。从钩子上调用这个函数也可以。</p><p id="c2d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数目前在客户机上运行。接下来，我们将把它移到服务器上，而不动一行代码。</p><h1 id="17d7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">步骤2:将Jitar添加到项目中</h1><p id="f414" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了使用Jitar作为运行时，我们添加了它的Node.js服务器作为依赖项。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="add7" class="mu lt iq mq b be mv mw l mx my">npm install jitar-nodejs-server</span></pre><p id="9371" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了便于与web应用程序集成，提供了一个Vite插件。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="e7f6" class="mu lt iq mq b be mv mw l mx my">npm install --save-dev jitar-vite-plugin</span></pre><p id="539b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要启用该插件，需要将其添加到Vite配置文件中。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="7009" class="mu lt iq mq b be mv mw l mx my">// vite.config.ts<br/>import { defineConfig } from 'vite'<br/>import react from '@vitejs/plugin-react'<br/>import jitar from 'jitar-vite-plugin'<br/><br/>export default defineConfig({<br/>  plugins: [<br/>    react(),<br/>    jitar('src', 'shared', 'http://localhost:3000') // Add this<br/>  ]<br/>})</span></pre><p id="b051" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这三个参数设置了<code class="fe mz na nb mq b">root source</code>文件夹、<code class="fe mz na nb mq b">shared components</code>文件夹(相对于根文件夹)和Jitar服务器的URL。</p><p id="9e35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Vite现在已经设置好了，所以我们可以配置Jitar了。为此，我们需要两个JSON文件。首先是服务器配置。这个简单的例子不需要Jitar提供的<a class="ae kv" href="https://docs.jitar.dev/03_runtime_services" rel="noopener ugc nofollow" target="_blank">集群选项</a>，所以我们将创建一个简单的独立设置。让我们在项目根目录(在源根目录之外)创建一个新文件，文件名为<code class="fe mz na nb mq b">jitar.json</code>，内容如下:</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="17b5" class="mu lt iq mq b be mv mw l mx my">{<br/>    "url": "http://127.0.0.1:3000",<br/>    "standalone":<br/>    {<br/>        "source": "./dist",<br/>        "cache": "./cache",<br/>        "index": "index.html",<br/>        "assets": ["index.html", "main.js", "App.js", "vite.svg", "assets/**/*"]<br/>    }<br/>}</span></pre><p id="b6f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个配置告诉Jitar从<code class="fe mz na nb mq b">dist</code>文件夹中读取编译后的JavaScript，并将其缓存写入<code class="fe mz na nb mq b">cache</code>文件夹。当用网络浏览器访问时，它服务于<code class="fe mz na nb mq b">index.html</code>文件。<code class="fe mz na nb mq b">assets</code>将可从外界访问的文件列入白名单。默认情况下，其他文件将被隐藏。</p><p id="4f96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二种配置是<a class="ae kv" href="https://docs.jitar.dev/04_basic_features#segmentation" rel="noopener ugc nofollow" target="_blank">分段配置</a>。一个段定义了组成一个可部署包的组件。例如，我们只需要一个单独的段来将我们的功能放在服务器上。让我们在项目根目录下创建一个名为<code class="fe mz na nb mq b">server.segment.json</code>的新文件，内容如下。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="0aba" class="mu lt iq mq b be mv mw l mx my">{<br/>    "./shared/sayHello.js": { "sayHello": { "access": "public" } }<br/>}</span></pre><p id="7395" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">段文件的结构与JavaScript模块系统非常相似。在这种情况下，我们从<code class="fe mz na nb mq b">./shared/sayHello.js</code>导入<code class="fe mz na nb mq b">sayHello</code>。此外，我们将访问权限设置为public(默认为private)。</p><p id="5c13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，文件路径是相对于应用程序的源根目录的，它导入编译后的JavaScript文件(以。js)。</p><p id="462d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">差不多了。唯一缺少的是启动Jitar服务器的引导程序。我们需要向源根文件夹添加一个新的代码文件。看起来是这样的:</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="9e6c" class="mu lt iq mq b be mv mw l mx my">// src/jitar.ts<br/>import { startServer } from 'jitar-nodejs-server';<br/><br/>const moduleImporter = async (specifier: string) =&gt; import(specifier);<br/><br/>startServer(moduleImporter);</span></pre><p id="568b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着服务器的启动，我们需要提供一个模块导入器，它从本地应用程序上下文而不是Jitar上下文中导入节点依赖关系。虽然这背后的理论很有趣，但我现在将细节放在一边。也许将来我会写一篇关于这个以及更多Jitar内部工作方式的文章。</p><h1 id="f2c9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">步骤3:构建并运行</h1><p id="8ee9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">设置好Jitar之后，我们就可以开始第一次运行了。为此，我们需要修改<code class="fe mz na nb mq b">tsconfig.js</code>文件，将所有编译好的JavaScript输出到<code class="fe mz na nb mq b">dist</code>文件夹。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="13c5" class="mu lt iq mq b be mv mw l mx my">/* tsconfig.json */<br/>{<br/>    "compilerOptions":<br/>    {<br/>        /* other properties */<br/>        "noEmit": false, /* default true, change to false */<br/>        "outDir": "dist", /* add this property */<br/>    }<br/>}</span></pre><p id="391d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还需要修改<code class="fe mz na nb mq b">package.json</code>文件并颠倒构建脚本的顺序，以确保我们的共享组件在Vite构建过程之后可用。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="16c2" class="mu lt iq mq b be mv mw l mx my">"build": "vite build &amp;&amp; tsc",</span></pre><p id="1135" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们可以添加以下脚本来启动Jitar服务器。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="c7a7" class="mu lt iq mq b be mv mw l mx my">"jitar": "node --experimental-network-imports --experimental-fetch dist/jitar.js --config=jitar.json"</span></pre><p id="b9e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们都做好了准备。我们可以使用以下命令测试这两个脚本:</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="4704" class="mu lt iq mq b be mv mw l mx my">npm run build<br/>npm run jitar</span></pre><p id="6a3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">启动Jitar后，您应该会看到类似这样的内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/7972df5fddd01d6b8c496ae922cc4485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g38FwfhAlMgUKq0h34JL0Q.png"/></div></div></figure><p id="a3b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们的函数已经被Jitar成功注册了。这意味着它已经从客户端转移到了服务器。我们可以在<a class="ae kv" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>再次打开我们的应用程序来检查这一点。Jitar日志应该表明它已经运行了我们的函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/3a050a30befa48e4b5106d1904a1493e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7SS3eWng-DyInwC2_0MFNg.png"/></div></div></figure><p id="b8a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在检查浏览器的网络流量时(在开发者工具中)，我们还应该看到它已经向服务器发送了一个API请求。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/fd80d9740d35fac2e77069995217e1a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nw9k0zjeG_sWAGhR6Bf_iw.png"/></div></div></figure><p id="eb4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">恭喜你！您已经完成了完全自动化的API。从这里开始，应用程序可以扩展更多的功能。</p><p id="5a9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我们现在运行的是应用程序的可部署版本。也可以通过再次运行<code class="fe mz na nb mq b">npm run dev</code>在dev模式下启动Vite。请记住，Jitar需要在后台运行。否则，服务器功能将不可用。</p><h1 id="7dfe" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="4e11" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Jitar与Vite插件的结合使全栈开发人员的生活变得更加轻松，减轻了他们构建API的负担。我对端到端的类型检查和智能感知非常满意。这是其他选项不足或需要额外工具的地方(如<a class="ae kv" href="https://trpc.io/" rel="noopener ugc nofollow" target="_blank"> tRPC </a>)。</p><p id="660d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我的喜好来说，设置一个应用程序仍然需要太多的努力。为了改善这一点，定制创建者必须设置基本配置。我还没有建立一个创造者的经验，但是我会研究这个。如果你有(一些)经验，想帮忙，请告诉我！Jitar项目是开放的。</p><p id="68e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我结束之前，我想感谢您阅读这篇文章。我总是在寻找反馈。发现错误？有没有提高我写作的小窍门？你对吉塔尔有什么看法？请留言让我知道你的想法，非常感谢！</p></div></div>    
</body>
</html>