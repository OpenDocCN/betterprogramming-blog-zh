<html>
<head>
<title>How to Unit Test a GORM Application With Sqlmock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Sqlmock对GORM应用程序进行单元测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-unit-test-a-gorm-application-with-sqlmock-97ee73e36526?source=collection_archive---------1-----------------------#2020-04-01">https://betterprogramming.pub/how-to-unit-test-a-gorm-application-with-sqlmock-97ee73e36526?source=collection_archive---------1-----------------------#2020-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9d66" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用GROM和PostgreSQL的提示和技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c1ab4713ee58bfd73b89a019f39db99e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yhCbKwApwiXf1GDN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">尼古拉斯·托马斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="9cdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新于2022.07:在过去的两年里，我的观点发生了一些变化，如果你感兴趣的话，也可以看看我关于这个话题的最新<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/unit-testing-a-grom-application-with-a-real-db-server-81a1b95ad473">文章</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="74dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对DB-interactive代码进行单元测试并不容易。当涉及到像<a class="ae ky" href="https://github.com/jinzhu/gorm" rel="noopener ugc nofollow" target="_blank"> GORM </a>这样的ORM库时，就变得更加困难了。</p><p id="8e6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论上，我们可以用伟大的模仿工具<a class="ae ky" href="https://medium.com/better-programming/a-gomock-quick-start-guide-71bee4b3a6f1" rel="noopener"> GoMock </a>来模仿<code class="fe mc md me mf b">database/sql/driver</code>的所有接口(比如Conn和Driver)。然而，即使在GoMock的帮助下，我们仍然需要大量的手工工作来完成这种测试。</p><p id="648f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好消息是<a class="ae ky" href="https://github.com/DATA-DOG/go-sqlmock" rel="noopener ugc nofollow" target="_blank"> Sqlmock </a>可以解决上述问题。正如其官方网站所宣称的，这是一个“golang测试数据库交互的Sql模拟驱动程序。”</p><p id="d582" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将向您展示如何用Sqlmock对一个简单的博客应用程序进行单元测试。该应用程序由PostgreSQL支持，并使用GORM来简化O-R映射。</p><p id="0851" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用BDD测试框架<a class="ae ky" href="https://onsi.github.io/ginkgo/" rel="noopener ugc nofollow" target="_blank"> Ginkgo </a>编写测试用例，但是您可以更改为您喜欢的任何其他测试库。</p><p id="c487" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的博客应用程序将包含一个博客数据模型和一个存储库结构来处理数据库操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/ceaf1f8a840b2059dc7aa33686d5a1c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zxy2fg6IRFiRYqFj6iqomw.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9d48" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">定义GORM数据模型和存储库</h1><p id="e9ea" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">让我们首先定义博客数据模型和存储库结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2e5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe mc md me mf b">Blog.Tags</code>的类型是<code class="fe mc md me mf b">pq.StringArray</code>，代表PostgreSQL中的字符串数组。</p><p id="f235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe mc md me mf b">Repository</code>结构非常简单。它有一个字段<code class="fe mc md me mf b">*gorm.DB </code>，所有的数据库操作都依赖于这个字段。为了简洁起见，我省略了一些代码。除了<code class="fe mc md me mf b">Load</code>和<code class="fe mc md me mf b">ListAll</code>之外，<code class="fe mc md me mf b">Repository</code>结构中还声明了其他几个方法，如<code class="fe mc md me mf b">Save</code>、<code class="fe mc md me mf b">Delete</code>、<code class="fe mc md me mf b">SearchByTitle</code>等。这些方法将在本文后面解释。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0986" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">设置测试用例</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b878" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在GORM中使用Sqlmock，我们需要在<code class="fe mc md me mf b">BeforeEach</code>中做一些准备，以确保每个测试规范都可以获得一个全新的<code class="fe mc md me mf b">Repository</code>实例，然后在<code class="fe mc md me mf b">AfterEach</code>中断言期望。</p><p id="0262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mc md me mf b">BeforeEach</code>中有三个步骤来建立这个测试用例:</p><ol class=""><li id="f3e3" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">创建一个<code class="fe mc md me mf b">*sql.DB</code>的模拟实例和一个带有<code class="fe mc md me mf b">sqlmock.New()</code>的模拟控制器。</li><li id="e9f9" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">通过<code class="fe mc md me mf b">gorm.Open(“postgres”, db)</code>打开GORM(带PostgreSQL方言)。</li><li id="4317" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">创建一个新的<code class="fe mc md me mf b">Repository</code>实例。</li></ol><p id="4dc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mc md me mf b">AfterEach</code>中，我们调用<code class="fe mc md me mf b">mock.ExpectationsWereMet()</code>来确保所有的期望都得到满足。</p><p id="20e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们从最简单的场景开始写一个规范。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4509" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">测试ListAll方法</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上面的代码片段所示，<code class="fe mc md me mf b">ListAll</code>查找DB中的所有记录，并将它们映射到<code class="fe mc md me mf b">*Blog</code>的一个切片中。</p><p id="aadb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试规格是直的。我们将预期的查询设置为<code class="fe mc md me mf b">SELECT * FROM “blogs”</code>，并返回一个空的结果集。</p><p id="5ded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后运行所有测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f0bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能会惊讶于这个简单的测试用例可能会失败。但是控制台日志给了我们线索:“无法将实际的sql与预期的regexp相匹配。”</p><p id="7864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原来Sqlmock使用<code class="fe mc md me mf b">sqlmock.QueryMatcherRegex</code>作为默认的SQL匹配器。在这种情况下，方法<code class="fe mc md me mf b">sqlmock.ExpectQuery<strong class="lb iu"> </strong></code>将一个正则表达式字符串作为其参数，而不是普通的SQL字符串。</p><p id="b498" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有两个选择来解决这个问题:</p><ol class=""><li id="9618" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">用方法<code class="fe mc md me mf b">regexp.QuoteMeta</code>转义SQL字符串中的所有正则表达式元字符。所以我们可以把<code class="fe mc md me mf b">ExcectQuery</code>改成<code class="fe mc md me mf b">mock.ExpectQuery(<strong class="lb iu">regexp.QuoteMeta(<em class="nu">sqlSelectAll</em>)</strong>)...</code>。</li><li id="6add" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">更改默认的SQL匹配器。我们可以在创建模拟实例时提供一个匹配器选项:<code class="fe mc md me mf b">sqlmock.New(<strong class="lb iu">sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual)</strong>)</code>。</li></ol><p id="aa52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，正则表达式匹配器比等价匹配器更灵活(这就是为什么Sqlmock使用它作为缺省值)。</p><p id="131a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:默认情况下，Sqlmock使用正则表达式匹配SQL。</p><p id="bfef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们测试将单个DB记录加载到数据模型中的方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2b80" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">测试加载方法</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9d15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方法<code class="fe mc md me mf b">Load</code>将一个博客id作为参数，然后查找具有该id的第一条记录。</p><p id="8560" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将测试这种方法的两个场景。</p><p id="0b41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一个规范(名为“found”)中，我们构建了一个博客实例，并将其转换为一个<code class="fe mc md me mf b">sql.Row</code>。然后我们调用<code class="fe mc md me mf b">ExpectQuery</code>来定义期望。在这个规范的最后，我们断言加载的博客实例等于原始实例。</p><p id="cccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:如果你不确定GORM将产生什么SQL，你可以用<code class="fe mc md me mf b">gorm.DB</code>的<code class="fe mc md me mf b">Debug()</code>方法打开调试标志。</p><p id="8228" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个规范涵盖了“未找到”的场景。它还演示了当我们不关心SQL输入时，如何用正则表达式简化SQL匹配(我们使用<code class="fe mc md me mf b">.+</code>作为可以匹配任何内容的输入字符串)。</p><p id="c765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们所关心的是当<code class="fe mc md me mf b">Load</code>方法找不到博客时，应该返回一个<code class="fe mc md me mf b">gorm.ErrRecordNotFound</code>错误。</p><p id="72f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:使用正则表达式来简化SQL匹配。</p><p id="e76e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将通过GORM进行插入记录的单元测试——这是最棘手的部分。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f5bd" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">测试保存方法</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c2be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当数据模型有主键时，方法<code class="fe mc md me mf b">Save</code>将更新DB记录。当它没有记录时，该方法会在DB中插入一条新记录。</p><p id="00fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段显示了后一种情况。</p><p id="c818" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了一个新的blog实例，但没有设置它的主键。然后用<code class="fe mc md me mf b">mock.ExpectQuery</code>定义期望。事务在查询之前启动，在查询之后提交。</p><p id="b42d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，非查询SQL期望(例如<code class="fe mc md me mf b">Insert/Update</code>)应该由<code class="fe mc md me mf b">mock.ExpectExec</code>定义，但这是一个特例。出于某种原因，GROM对<code class="fe mc md me mf b">postgres</code>方言使用了<code class="fe mc md me mf b">QueryRow</code>而不是<code class="fe mc md me mf b">Exec</code>(更多详情请咨询<a class="ae ky" href="https://github.com/DATA-DOG/go-sqlmock/issues/118" rel="noopener ugc nofollow" target="_blank">本期</a>)。</p><p id="1591" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们用<code class="fe mc md me mf b">Expect(blog.ID).Should(BeEquivalentTo(<em class="nu">newId</em>))</code> <strong class="lb iu"> </strong>来断言<code class="fe mc md me mf b">blog.ID </code>是在<code class="fe mc md me mf b">Save</code>方法之后设置的。</p><p id="bc33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:如果您使用PostgreSQL，请使用<code class="fe mc md me mf b">mock.ExpectQuery</code>插入GORM模型。</p><p id="d8d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会建议没有必要对单元测试进行简单的<code class="fe mc md me mf b">Insert/Update</code> <em class="nu"> </em>操作。在实践中，是的，这是不必要的。这里我们想给大家展示的是，GORM可能会做一些你之前没有注意到的隐式操作。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f015" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="222f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Sqlmock是对DB-interactive代码进行单元测试的一个很好的工具，但是在使用GORM和PostgreSQL时会遇到一些问题。</p><p id="6301" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们构建了一个简单的博客应用程序，并用Sqlmock对其进行了单元测试。我相信你可以在这个例子的帮助下开始你的单元测试。</p><p id="47a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的源代码，请访问它的<a class="ae ky" href="https://github.com/dche423/dbtest" rel="noopener ugc nofollow" target="_blank">库</a>。</p><p id="c9f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干杯！</p></div></div>    
</body>
</html>