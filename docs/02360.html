<html>
<head>
<title>Why Everyone Should Learn Functional Programming Today</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么今天每个人都应该学习函数式编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-everyone-should-learn-functional-programming-today-c96a5b10d27d?source=collection_archive---------16-----------------------#2019-11-25">https://betterprogramming.pub/why-everyone-should-learn-functional-programming-today-c96a5b10d27d?source=collection_archive---------16-----------------------#2019-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="98a5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编程趋势来来去去，但函数式编程是一个基础</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ab1fd3ddd58871e1dc5ab17bae4a91e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jAIziEJZEi2s2a0upSzVkQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼尔·里卡洛斯在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7f74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编程语言的世界里，趋势来来去去。一个值得考虑的趋势是本世纪初开始的对<strong class="lb iu">函数式编程</strong>的兴趣。函数式编程是一种强调不可变数据、函数原语和状态避免的风格。</p><p id="7d34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道你在想什么。你在大学里写了一些口齿不清的东西，并且害怕它。或者，你在上一份工作中不得不管理一些糟糕的Scala代码，而你不想再处理这些。</p><p id="ba41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道，我知道。但是听我说完。</p><p id="6ec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数式编程不仅仅是一种趋势。理解它的概念和吸引力有助于理解软件工程师在2019年以及未来十年面临的问题。</p><p id="dc7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，随着数据挖掘和机器学习算法成为公众关注的问题，它有助于了解世界的现状。</p><p id="6e6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使你不使用函数式语言，函数式思维方式提供的解决方案也能帮助你解决难题，理解计算世界。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c217" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">命令式风格</h1><p id="39bd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">今天广泛使用的大多数编程语言是冯·诺依曼语言。这些语言反映了冯·诺依曼计算机架构，其中内存、存储、控制流指令和I/O是语言的一部分。程序员在内存中创建一个变量，设置它的值，删除它，并控制下一个命令是什么。</p><p id="afe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个写过程序的人都熟悉这些概念。事实上，所有最流行的语言都是冯·诺依曼家族的语言:Java、C++、Python、Ruby、Go。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ee8e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">输入功能样式</h1><p id="445b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">1978年8月，计算机科学家约翰·巴科斯在《美国计算机学会通讯》上发表了一篇文章。巴克斯指责传统的冯·诺依曼风格的语言是“肥胖和松弛的”他哀叹新一代语言的复杂性，需要大量的手册才能理解。每一代都增加了更多看似增强的特性，但由于增加了复杂性，大大降低了语言的质量。</p><p id="7671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，用这些语言编写的程序不能组合成新的程序，因为它们的组件不是以通用形式创建的。</p><p id="1195" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确实是一种令人遗憾的事态。</p><p id="c15b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">巴克斯问为什么我们不能创建结构更像数学公式的程序。在这种语言中，数据可以像在代数中一样被操作。他提出这种“函数式编程风格”会更正确、更简单、更可组合。巴克斯还强调了程序“清晰和概念有用”的重要性。</p><p id="ab67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇论文已经写了40年了，但我想我们都有同感！</p><p id="da93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像Java、Python和JavaScript这样的语言增加了旨在阐明语法的新特性，但是这些语言的总体趋势是越来越复杂。面向对象编程(OOP)至少给了我们模块化，但是继承层次导致了众所周知的设计问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="abdf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">计算模型</h1><p id="44cd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">巴克斯认为，所有这些复杂性都要归咎于冯·诺依曼计算机体系结构本身。它在20世纪40年代和50年代为我们提供了很好的服务，但到了1978年，它开始显示出它的年龄。他定义了几个概念模型来证明冯·诺依曼的普适模型的局限性。</p><h2 id="efe5" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">图灵机和自动机</h2><p id="fb70" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些是计算机科学家使用的计算机概念模型。它们满足计算的所有要求，但是对于负责设计软件程序的人来说，它们太笨重了。</p><h2 id="3b76" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">可怕的冯·诺依曼模型</h2><p id="3c44" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">巴克斯把我们今天使用的大多数传统语言所代表的冯·诺依曼模型称为“复杂、庞大、无用”。</p><p id="d04e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">巴克斯承认冯·诺依曼语言可以“相当清晰”，但他指出它们缺乏概念上的实用性。</p><p id="a2fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，我们当中有多少人斜眼盯着一千行的Python或Java代码，试图弄清楚所有这些循环和条件语句到底想干什么？对于多个参与者来说，理解高度程序化的代码可能是一场噩梦。</p><p id="9e28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">巴克斯还指出，冯·诺依曼模型是为单CPU机器设计的。一次执行一条指令。</p><h2 id="ea1d" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">功能模型</h2><p id="47fc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这里，Backus将lambda演算、Lisp语言和他自己的“函数式编程”概念归为第三类。</p><p id="61f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用这种模型编写的程序没有状态。我们没有直接设置变量，而是将值绑定到符号上。我们转换集合，而不是循环。结果是程序简洁明了，而且<strong class="lb iu">在概念上很有用</strong>。</p><p id="f289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，功能风格是<strong class="lb iu">明显的</strong>。</p><p id="675f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">的确，用函数式语言编写的程序通常很短，但是它简洁的定义比非函数式语言更容易理解。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="18f1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我为什么要在乎？</h1><p id="2b33" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">好吧，如果我们都放弃Python和Java，开始写Haskell，也许我们能写出更好的程序。嗯哼。好的。当然可以。</p><p id="cf0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是谁来做呢？为什么呢？我们如何用这些他们不懂的语言来培训刚从大学毕业的开发人员呢？更重要的是，为什么？当然，已经有很多用现有语言编写的高质量软件，正如C++的创造者比雅尼·斯特劳斯特鲁普曾经说过的:</p><blockquote class="nl nm nn"><p id="278d" class="kz la no lb b lc ld ju le lf lg jx lh np lj lk ll nq ln lo lp nr lr ls lt lu im bi translated">"世界上只有两种语言:人们抱怨的语言和没人使用的语言。"</p></blockquote><p id="6eee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了学术练习之外，我们应该关心所有这些的原因是,<strong class="lb iu">当前向“大数据”驱动的产品的发展已经导致了功能模型唯一擅长解决的计算问题。</strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d4f6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">并发</h1><p id="0a09" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如巴克斯在1978年指出的，冯·诺依曼模型实际上是面向一次执行一条指令的简单计算机的。冯·诺依曼式的程序流程将每条指令的控制权交给了程序员。</p><p id="9ba8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，没过多久我们的计算机就变得更加复杂了。现在，我们的计算机有许多中央处理器，同时执行许多指令。像Python和Java这样的流行语言并不是为了利用这一点而从头开始构建的。这些语言附加了线程API，允许程序员利用多个处理器。其他的依赖于进程分叉，本质上是把问题推到操作系统。</p><p id="75a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多线程程序很难正确编写，即使是非常有经验的程序员也会犯严重的错误。编写多线程程序是如此复杂，以至于有<a class="ae ky" href="https://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601/ref=sr_1_3?keywords=java+concurrency&amp;qid=1574700159&amp;sr=8-3" rel="noopener ugc nofollow" target="_blank">整本书致力于正确地完成它</a>。</p><p id="8a39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在20世纪40年代，拥有许多CPU的计算机很常见，我们的编程语言会是什么样子？我们是选择单独为每个线程编程，还是想出不同的概念来实现相同的目标？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="111f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">分布式系统</h1><p id="a8ee" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">10年前，大多数软件都是在用户电脑的操作系统上运行的。软件需要执行的任何操作都是使用客户的CPU、内存和本地磁盘来处理的。</p><p id="2eb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是Gmail和其他网络工具的早期成功证明了一个复杂的软件系统可以在互联网上运行。</p><p id="e079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天的商业软件不仅仅运行在客户的个人电脑上。它运行在云中，可能跨越数百台机器。软件即服务(Saas)产品现在很常见，被个人和企业使用。</p><p id="17f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着数据从客户的电脑中取出并通过网络发送到我们的云中数据中心，我们现在可以查看所有<em class="no">客户的汇总数据。这些数据可以识别数据中的趋势，例如，检测银行交易中的欺诈行为。</em></p><p id="443b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这些系统很难写。我们的程序现在不得不运行在可能有数百个CPU的机器上，而不是像冯·诺依曼模型预先假定的那样运行在具有本地内存和磁盘访问的单线程计算机上。更糟糕的是，我们现在处理的数据远远超过了我们希望在一台机器上存储的数据。我们需要研究这些数据。它不能只是被铲进一个数据仓库，然后再被查询。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="069c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">天真的解决方案</h1><p id="f539" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一种方法是继续使用我们得到的线程或进程分叉模型来编写代码，然后构建一个机器舰队来扩展它。这些机器将处理数据，并将数据推送到某个地方(数据库？)以防止它填满本地磁盘。</p><p id="5e84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你可能猜到的，这个解决方案在操作上非常复杂<em class="no">。我们必须以某种方式手动分割数据——也就是说，将我们的数据集平均分割到我们的n台处理机器上——并为所有这些机器编写胶水代码，使它们能够相互对话，并执行某种<a class="ae ky" href="https://en.wikipedia.org/wiki/Leader_election" rel="noopener ugc nofollow" target="_blank">领导人选举</a>来确定谁负责协调所有这些工作。</em></p><p id="bf9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用实际的程序员术语来说，这也意味着我们必须用代码编写、维护和版本化以下内容:</p><ul class=""><li id="333b" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">比如用Java写的复杂多线程代码。</li><li id="0007" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">一堆bash脚本，用于在云中的n台机器上部署和更新这些代码。</li><li id="9915" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">随着数据量的增加或减少，代码可以将我们的解决方案扩展到更多的机器。</li><li id="287b" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">某种调度和协调系统，使所有这些操作一起工作，并在某个地方加入它们的结果。</li></ul><p id="3243" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在想象一下调试和维护这个系统。听起来不好玩，是吧？当然，代码中产生的解决方案不会是<strong class="lb iu">明显的</strong>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a37e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">优雅的解决方案</h1><p id="d167" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">2013年，伯克利的AMPLab向开源世界捐赠了Spark项目。多年来，Spark已经成为最受欢迎的“大数据”集群编程平台之一，取代了Twitter和Google工程师构建的各种系统。</p><p id="1f26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Spark是用Scala语言编写的，Scala语言是一种运行在Java虚拟机(JVM)上的函数式编程语言。我不会深入Spark如何工作的血淋淋的细节，也不会在这里写任何代码。你可以在网上找到很多这样的例子。</p><p id="c426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我将展示Spark <strong class="lb iu">概念框架</strong>，并展示<strong class="lb iu">计算的功能模型如何对其优雅的解决方案</strong>至关重要。</p><h2 id="7299" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">什么是“程序？”</h2><p id="0afe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">问自己这个问题。在我们上面描述的假设的分布式系统中，什么是“程序？”</p><p id="6b4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是我们写的并发Java代码吗？或者是bash脚本将代码部署到我们“集群”中的各种机器上是调度算法的问题吗？</p><p id="6405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为所有这些组件放在一起包含了“程序”的一部分程序是转换数据的指令。像线程管理和管理资源这样的细节对于这个目标来说是附带的。</p><p id="edba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这么想吧。假设我们在云中有十几台机器，有4个CPU和16 GB的内存。将所有这些机器放到一个大的计算资源“集群”中。现在我们有了一台大“计算机”，它有4 * 12 = 48个CPU，16 * 12 = 192 GB内存，还有一定的磁盘存储空间。</p><p id="6f87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，假设我们用Backus描述的函数式风格编写数据转换。每个变换都像数学函数一样书写。有输入和输出。没有国家。所有数据都是不可变的，分阶段存储在每台机器的磁盘上，当不再需要时就会删除。</p><p id="1402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以有一个知道集群结构的调度程序。换句话说，它知道它有12台带有4个CPU和16 GB内存的机器。调度程序将一部分数据和我们定义的数据转换函数一起发送出去。</p><p id="4787" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，如果我们以一种纯粹的函数式风格编写我们的数据转换“程序”，那么调度程序可以同时调度许多这样的转换，其数量可以在资源有限的集群中容纳。这使我们能够以高效的方式处理数据。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c822" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">以函数方式对集群进行编程</h1><p id="84b5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我不打算将Spark作为集群计算的终极目标。也许我们将来会想出更好的东西，Spark并不适合每一个分布式系统。例如，它针对数据处理和流式传输进行了优化，而不是为实时请求提供服务。</p><p id="0022" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我想强调的是允许这种类型的系统被构建的观点的转变，即<strong class="lb iu">函数式编程风格</strong>。事实上，当我们进入“大数据”领域时，我们往往会发现大多数解决方案都依赖于计算的功能模型。</p><p id="6387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Spark提供了Scala、Java和Python API。无论您选择哪种语言，您都将使用函数式风格编写您的Spark程序。</p><p id="374d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也倾向于发现转换代码与资源管理的分离是一个主题。Apache Spark的解决方案将我们分布式系统的资源管理方面分离出来，让我们处理数据。数据转换规则清晰，要求<strong class="lb iu">没有复杂的多线程代码</strong>。</p><p id="2e59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">似乎分布式系统最终将我们从冯·诺依曼模型的限制中解放出来。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="202c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="592a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">作为Java或Python等语言的流行替代品，函数式编程语言可能正在失宠。作为简单用例(如小型web应用程序)的替代，Scala或Haskell可能有些过头了。</p><p id="f93f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是计算的功能模型还远没有消失。如果说有什么不同的话，那就是它比以往任何时候都更有优势。它隐藏在幕后，为机器学习算法、商业智能和分析引擎提供动力，为现代组织提供见解。</p><p id="a45e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">软件工程师和经理最好学习这些概念，并理解为什么在最大的技术公司的核心运行的这么多项目依赖于像Apache Spark这样的函数式项目。</p><p id="1e30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数式风格允许我们将计算资源管理的“如何”与程序的“什么”分开。它将我们从繁琐复杂的多线程API中解放出来，这些API附加在基于20世纪40年代构想的简单计算机模型的语言上。</p><p id="193c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">功能模型非常适合我们正在进入的数据丰富的世界。它是当今任何软件工程师不可或缺的工具。</p></div></div>    
</body>
</html>