<html>
<head>
<title>K8s: Network Policy Made Simple With Cilium Editor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K8s:使用Cilium编辑器简化网络策略</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/k8s-network-policy-made-simple-with-cilium-editor-a5b55781291c?source=collection_archive---------4-----------------------#2021-02-19">https://betterprogramming.pub/k8s-network-policy-made-simple-with-cilium-editor-a5b55781291c?source=collection_archive---------4-----------------------#2021-02-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7f0d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">定义复杂网络策略的直观图形工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/84e5741a1c7951c327a207e381f9c243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*io6E0RdcSdygFbfgUjorhA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安德里亚斯·威尔格尼在<a class="ae ky" href="https://unsplash.com/s/photos/hard-thing-made-simple?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="adbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="http://cilium.io" rel="noopener ugc nofollow" target="_blank">基于eBPF的网络解决方案Cilium </a>刚刚发布了<a class="ae ky" href="https://editor.cilium.io/?id=u80foQhTPt4OB9Je" rel="noopener ugc nofollow" target="_blank">一个网页编辑器</a>来帮助创建Kubernetes网络策略。在本文中，我们将演示该工具，并使用它来定义一个样本网络策略。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b237" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">纤毛和eBPF的快速介绍</h1><blockquote class="mu mv mw"><p id="4666" class="kz la mx lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated">“Cilium是一个开源项目，它是在eBPF之上设计的，旨在解决容器工作负载的网络、安全性和可见性要求。它在eBPF之上提供了一个高层次的抽象。”— <a class="ae ky" href="https://cilium.io/blog/2020/11/10/ebpf-future-of-networking/" rel="noopener ugc nofollow" target="_blank">纤毛博客</a></p></blockquote><p id="1e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Cilium具有广泛的应用领域，通常用作Kubernetes中的CNI插件，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/df136857ef9e171fd90b4e8600d0a3de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xgKipZWmzAmtWKYhHdk9mw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Kubernetes中用作CNI插件的纤毛网络解决方案。作者照片。</p></figure><p id="973c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Cilium基于eBPF(Extended Berkeley Packet Filter ),这是一项几年前合并到Linux内核中的技术，从那时起，它已经得到了令人印象深刻的发展和采用。eBPF是一种通用技术，可用于网络、跟踪、安全、分析和可观察性等领域。它允许用户将代码注入Linux内核，并由不同种类的事件触发。</p><p id="dc2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是网飞的Brendan D. Gregg对eBPF的评论:</p><blockquote class="nc"><p id="eb81" class="nd ne it bd nf ng nh ni nj nk nl lu dk translated">“超级大国终于来到了Linux。”— <a class="ae ky" href="https://www.youtube.com/watch?v=JRFNIKUROPE" rel="noopener ugc nofollow" target="_blank"> Gregg在linux.conf.au </a></p><p id="9914" class="nd ne it bd nf ng nh ni nj nk nl lu dk translated">" eBPF对Linux的作用就像JavaScript对HTML的作用一样."— <a class="ae ky" href="http://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html" rel="noopener ugc nofollow" target="_blank">格雷格的博客</a></p></blockquote><p id="31df" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">eBPF通常被视为一项革命性的技术，已经在多个Kubernetes管理的解决方案中用作网络数据层，从而确保了pods之间的通信和负载平衡。例如，在Kubernetes集群中，可以使用纤毛eBPF方法代替kube-proxy。</p><p id="c6a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解关于eBPF的一切(以及许多其他事情)，Gregg的网站是一个非常好的资源。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c600" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">关于Kubernetes网络政策</h1><p id="e7d0" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">在部署工作负载和Kubernetes时，默认情况下它们不是孤立的。例如:</p><ul class=""><li id="f23a" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">部署在不同名称空间中的pod仍然可以互相访问。</li><li id="3180" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">pod可以调用另一个名称空间上现有的服务。</li><li id="71bd" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">pod的入口和出口流量不受限制。</li></ul><p id="9bb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ok ol om on b">NetworkPolicy</code>资源的作用是控制pod内的传入和传出流量。只有在安装的CNI插件允许的情况下，才会考虑一个<code class="fe ok ol om on b">NetworkPolicy</code>。幸运的是，当时许多Kubernetes CNI插件知道如何管理<code class="fe ok ol om on b">NetworkPolicy</code>资源:</p><ul class=""><li id="d80d" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">纤毛</li><li id="ddf2" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">白棉布</li><li id="3e09" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">编织网</li></ul><p id="f73b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个<code class="fe ok ol om on b">NetworkPolicy</code>规范的例子(摘自Kubernetes官方文档):</p><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="34d0" class="os md it on b gy ot ou l ov ow">apiVersion: networking.k8s.io/v1<br/>kind: NetworkPolicy<br/>metadata:<br/>  name: test-network-policy<br/>  namespace: default<br/>spec:<br/>  podSelector:<br/>    matchLabels:<br/>      role: db<br/>  policyTypes:<br/>  - Ingress<br/>  - Egress<br/>  ingress:<br/>  - from:<br/>    - ipBlock:<br/>        cidr: 172.17.0.0/16<br/>        except:<br/>        - 172.17.1.0/24<br/>    - namespaceSelector:<br/>        matchLabels:<br/>          project: myproject<br/>    - podSelector:<br/>        matchLabels:<br/>          role: frontend<br/>    ports:<br/>    - protocol: TCP<br/>      port: 6379<br/>  egress:<br/>  - to:<br/>    - ipBlock:<br/>        cidr: 10.0.0.0/24<br/>    ports:<br/>    - protocol: TCP<br/>      port: 5978</span></pre><p id="2814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管乍一看这似乎很复杂，但理解起来并不难。让我们把它分成几个主要部分:</p><ul class=""><li id="2259" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated"><code class="fe ok ol om on b">podSelector</code>属性定义了将应用<code class="fe ok ol om on b">NetworkPolicy</code>的窗格。在这个例子中，所有带有<code class="fe ok ol om on b">roll: db</code>标签的单元都是相关的。一个<code class="fe ok ol om on b">NetworkPolicy</code>是一个命名空间资源。在本例中，它仅限于<code class="fe ok ol om on b">default</code>名称空间。</li></ul><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="50ac" class="os md it on b gy ot ou l ov ow">podSelector:<br/>  matchLabels:<br/>    role: db</span></pre><ul class=""><li id="33af" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated"><code class="fe ok ol om on b">ingress</code>属性定义了哪些实体能够到达所选的窗格。</li></ul><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="bae9" class="os md it on b gy ot ou l ov ow">ingress:<br/>  - from:<br/>    - ipBlock:<br/>        cidr: 172.17.0.0/16<br/>        except:<br/>        - 172.17.1.0/24<br/>    - namespaceSelector:<br/>        matchLabels:<br/>          project: myproject<br/>    - podSelector:<br/>        matchLabels:<br/>          role: frontend<br/>    ports:<br/>    - protocol: TCP<br/>      port: 6379</span></pre><p id="7f46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">IP属于CIDR <code class="fe ok ol om on b">172.17.0.0/16</code>的所有实体(除了<code class="fe ok ol om on b">172.17.1.0/24)</code>中的实体、命名空间<code class="fe ok ol om on b">myproject</code>中的pod或带有<code class="fe ok ol om on b">role: frontend</code>标签的pod)将只能读取端口6379上的所选pod。</p><ul class=""><li id="bedb" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated"><code class="fe ok ol om on b">egress</code>属性定义了所选pod可以启动的通信。</li></ul><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="23d2" class="os md it on b gy ot ou l ov ow">- to:<br/>    - ipBlock:<br/>        cidr: 10.0.0.0/24<br/>    ports:<br/>    - protocol: TCP<br/>      port: 5978</span></pre><p id="b755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，它们只能到达端口5978上的<code class="fe ok ol om on b">10.0.0.0/24</code>中的IP地址。</p><p id="a2c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将部署一个示例应用程序，并注意到在默认情况下对应用程序窗格的访问是完全开放的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="41bd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">运行演示应用程序</h1><p id="afc1" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">让我们考虑由MongoDB数据库和web前端组成的样本留言簿应用程序。</p><ul class=""><li id="a188" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">以下内容定义了mongo部署和服务:</li></ul><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="de68" class="os md it on b gy ot ou l ov ow">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: mongo<br/>  labels:<br/>    app: guestbook<br/>    tier: backend<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: guestbook<br/>      tier: backend<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: guestbook<br/>        tier: backend<br/>    spec:<br/>      containers:<br/>      - name: mongo<br/>        image: mongo:4.2<br/>        ports:<br/>        - containerPort: 27017<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: mongo<br/>  labels:<br/>    app: guestbook<br/>    tier: backend<br/>spec:<br/>  ports:<br/>  - port: 27017<br/>    targetPort: 27017<br/>  selector:<br/>    app: guestbook<br/>    tier: backend</span></pre><ul class=""><li id="e056" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">以下内容定义了web前端的部署和服务:</li></ul><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="f7ae" class="os md it on b gy ot ou l ov ow">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: www<br/>  labels:<br/>    app: guestbook<br/>    tier: frontend<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: guestbook<br/>      tier: frontend<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: guestbook<br/>        tier: frontend<br/>    spec:<br/>      containers:<br/>      - name: guestbook<br/>        image: paulczar/gb-frontend:v5<br/>        ports:<br/>        - containerPort: 80<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: www<br/>  labels:<br/>    app: guestbook<br/>    tier: frontend<br/>spec:<br/>  type: NodePort<br/>  ports:<br/>  - port: 80<br/>    nodePort: 31000<br/>  selector:<br/>    app: guestbook<br/>    tier: frontend</span></pre><p id="bba8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们复制了<code class="fe ok ol om on b">guestbook.yml</code>中的整个规范，创建了一个名为<code class="fe ok ol om on b">guestbook</code>的名称空间，并在该名称空间中部署应用程序:</p><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="8fb6" class="os md it on b gy ot ou l ov ow">$ kubectl create ns guestbook<br/>$ kubectl apply -f guestbook.yaml -n guestbook</span></pre><p id="d408" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，我们首先要确保所有的资源都已部署，并且pod已经启动并运行。</p><p id="f4de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mx">注意:不要在</em> <code class="fe ok ol om on b"><em class="mx">kubectl apply</em></code> <em class="mx">之后马上去喝咖啡。始终确保您的pod正在运行。只有这样，你才能得到你最喜欢的饮料。</em></p><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="c41a" class="os md it on b gy ot ou l ov ow"><strong class="on iu">$ kubectl get deploy,po,svc -n guestbook<br/></strong>NAME                    READY   UP-TO-DATE   AVAILABLE   AGE<br/>deployment.apps/mongo   1/1     1            1           15s<br/>deployment.apps/www     1/1     1            1           15s</span><span id="afc8" class="os md it on b gy ox ou l ov ow">NAME                         READY   STATUS    RESTARTS   AGE<br/>pod/mongo-567d64884f-qbbnc   1/1     Running   0          15s<br/>pod/www-6cf4495b7c-pbmfn     1/1     Running   0          15s</span><span id="2e55" class="os md it on b gy ox ou l ov ow">NAME          TYPE      CLUSTER-IP    EXTERNAL-IP PORT(S)        AGE<br/>service/mongo ClusterIP 10.245.211.49 &lt;none&gt;      27017/TCP      15s<br/>service/www   NodePort  10.245.21.238 &lt;none&gt;      80:31000/TCP   15s</span></pre><p id="ab30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe ok ol om on b">NodePort</code>服务公开了前端，因此可以从集群的任何节点通过端口31000访问应用程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/4f8de9aa3211a9b1d4f7c741da7ee9f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rln15sv0gY6AP1rdWlPMHQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">留言簿应用程序的前端公开为节点端口服务</p></figure><h2 id="6968" class="os md it bd me oz pa dn mi pb pc dp mm li pd pe mo lm pf pg mq lq ph pi ms pj bi translated">对访问数据库没有限制</h2><p id="14ff" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">上面的应用程序运行在<code class="fe ok ol om on b">guestbook</code>名称空间中，但是由于我们没有指定任何<code class="fe ok ol om on b">NetworkPolicy</code>，集群中的任何pod都可以访问底层数据库。让我们在<code class="fe ok ol om on b">default</code>名称空间的Mongo pod中运行一个shell:</p><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="a7ce" class="os md it on b gy ot ou l ov ow">$ kubectl run test -ti --image=mongo --command bash</span></pre><p id="1ff5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个pod中，我们可以使用完全限定名(<code class="fe ok ol om on b">service.namespace</code>)轻松地连接到mongo数据库:</p><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="90ae" class="os md it on b gy ot ou l ov ow">root@test:/# mongo mongodb://mongo.guestbook<br/>MongoDB shell version v4.4.3<br/>...<br/>&gt; show dbs<br/>admin      0.000GB<br/>config     0.000GB<br/>guestbook  0.000GB<br/>local      0.000GB</span></pre><p id="aa04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将使用Cilium的web编辑器创建一个<code class="fe ok ol om on b">NetworkPolicy</code>,它将数据库访问权限限制在留言簿的前端窗格。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5351" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用Cilium的编辑器构建网络策略</h1><p id="b43a" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">Cilium的编辑器让<code class="fe ok ol om on b">NetworkPolicy</code>的不同部分非常清晰:</p><ul class=""><li id="80b2" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">中心块允许您选择<code class="fe ok ol om on b">NetworkPolicy</code>应该应用的pod。</li><li id="f1a5" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">左侧的块允许您控制入口流量(哪些实体可以访问pod)。</li><li id="93d2" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">右侧的块允许您定义出口流量(pod可以访问哪些实体)。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/d16cbd9287753ee01e89bdb01654f11f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*egOz_eY2nfJzOazzHCQkvg.png"/></div></div></figure><p id="86dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">左下方的面板显示了<code class="fe ok ol om on b">NetworkPolicy</code>的规格，反映了使用顶部面板的构建模块所做的选择。</p><p id="070d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">右下角的面板提供了几个教程。主页面非常好，详细列出了定义<code class="fe ok ol om on b">NetworkPolicy</code>所需的所有建议:</p><ul class=""><li id="ac07" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">第一步。你想保护什么样的吊舱？</li><li id="57a6" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">步骤2:引入入口和出口默认<code class="fe ok ol om on b">deny</code>状态。</li><li id="d4ec" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">第三步。允许到Kubernetes DNS的流量。</li><li id="7910" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">第四步。允许同一命名空间中的流量。</li><li id="5955" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">第五步。允许来自群集外部的传入流量。</li><li id="a6a2" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">第六步。允许来自群集的传出流量。</li><li id="b526" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">第七步。允许跨命名空间流量。</li><li id="1858" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">第八步。允许基于网络的活性/就绪性探测。</li></ul><p id="ecfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用编辑器，我们将定义一个简单的<code class="fe ok ol om on b">NetworkPolicy</code>来确保应用程序的数据库只能从运行在相同名称空间中的特定pods访问。由于这个例子非常简单，我们不会使用上面列出的所有步骤。</p><h2 id="6e67" class="os md it bd me oz pa dn mi pb pc dp mm li pd pe mo lm pf pg mq lq ph pi ms pj bi translated">选择我们想要保护的pod</h2><p id="8c28" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">首先，我们需要定义<code class="fe ok ol om on b">NetworkPolicy</code>的元数据，并选择将应用<code class="fe ok ol om on b">NetworkPolicy</code>的窗格。为此，我们单击中心块并提供以下信息:</p><ul class=""><li id="b180" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">政策名称:<code class="fe ok ol om on b">db-guestbook</code></li><li id="1822" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">将在其中创建<code class="fe ok ol om on b">NetworkPolicy</code>的名称空间:<code class="fe ok ol om on b">guestbook</code></li><li id="8868" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">要选择的pod标签(<code class="fe ok ol om on b"><strong class="lb iu">app: </strong>guestbook</code>、<code class="fe ok ol om on b"><strong class="lb iu">tier:</strong> backend</code>)</li></ul><p id="a9ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，我们可以看到我们的选择被考虑在内，现在在左下方的面板中是规范的一部分:包含我们标签的<code class="fe ok ol om on b">podSelector</code>属性现在出现在<code class="fe ok ol om on b">spec</code>属性下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/5989c5d1680940e07e52efebb43624e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wIQ_cd8AK9ShnilAsIG_Rg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据库窗格的选择</p></figure><h2 id="1ccb" class="os md it bd me oz pa dn mi pb pc dp mm li pd pe mo lm pf pg mq lq ph pi ms pj bi translated">阻止所有传入和传出流量</h2><p id="76da" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">当定义一个<code class="fe ok ol om on b">NetworkPolicy</code>时，通常一个好的做法是从阻塞所有的入站和出站流量开始，然后打开真正需要的流量。中间块中的复选框允许您只需点击两次即可阻止所有流量:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/2bb381dbca1c3345b36df7b57e94421a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7JgdYtj9RL5VjmIUKMT88A.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/bf2818b53060db7df2901c0e4850c07b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hLxP-oIPRPTZ1V5HWEuwHw.png"/></div></div></figure><p id="488b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们应用当前的<code class="fe ok ol om on b">NetworkPolicy</code>，我们应该看到留言簿应用程序不再工作了。让我们检查一下！</p><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="ba13" class="os md it on b gy ot ou l ov ow">$ <strong class="on iu">cat &lt;&lt;EOF | kubectl apply -f -</strong><br/>apiVersion: networking.k8s.io/v1<br/>kind: NetworkPolicy<br/>metadata:<br/>  name: db-guestbook<br/>  namespace: guestbook<br/>spec:<br/>  podSelector:<br/>    matchLabels:<br/>      app: guestbook<br/>      tier: backend<br/>  policyTypes:<br/>    - Ingress<br/>    - Egress<br/>  ingress: []<br/>  egress: []<br/><strong class="on iu">EOF</strong></span></pre><p id="bdd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦创建了策略，我们使用留言簿前端添加一个新条目…然后我们得到一个预期的错误消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/31a9514c991affda0ef1f37a04616204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ah0Rn3LXmAUeTgktEpl9SA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">任何pod(甚至是应用程序前端的pod)都不能访问mongo数据库。</p></figure><h2 id="b368" class="os md it bd me oz pa dn mi pb pc dp mm li pd pe mo lm pf pg mq lq ph pi ms pj bi translated">定义入口流量</h2><p id="a027" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">接下来，使用左侧的构建块，我们定义允许访问pod的实体。目前，由于我们在上一步中采取的操作，所有流量都被阻止。我们现在将创建额外的规则，只允许需要的流量。该编辑器使用三个主要模块来轻松定义不同类型的规则:</p><ul class=""><li id="94cb" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">“外部集群”允许您限制可以访问pod的IP地址。</li><li id="5913" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">“在名称空间中”<strong class="lb iu"> </strong>允许您选择能够访问数据库窗格的<code class="fe ok ol om on b">guestbook</code>名称空间中的其他窗格。</li><li id="0488" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><strong class="lb iu"/>“In Cluster”允许您选择其他名称空间内的pod。</li></ul><p id="a3df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个选项，我们可以指定为传入流量打开的端口。</p><p id="786b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的示例中，我们将使用“In Namespace”块，因为我们只需要允许与DB pod相同的名称空间中的流量。我们在<code class="fe ok ol om on b">guestbook</code>名称空间中选择带有<code class="fe ok ol om on b"><strong class="lb iu">app: </strong>guestbook</code>和<code class="fe ok ol om on b"><strong class="lb iu">tier:</strong> frontend</code>标签的pod。我们还指定流量只允许在端口27017上传输(默认的MongoDB端口):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/c98e017788e75b7759b98a489893dcb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmbcjPnS6E_J4ovIWAxYhw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">入口流量的规格</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/dd85c0c117ddca30d4d09d59dacaf354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VpNXRizAibQ9ZgkaZpKuUQ.png"/></div></div></figure><h2 id="cab6" class="os md it bd me oz pa dn mi pb pc dp mm li pd pe mo lm pf pg mq lq ph pi ms pj bi translated">定义出口流量</h2><p id="a62c" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">至于出口流量，可以通过使用“外部集群”、“在名称空间中”和“在集群中”<strong class="lb iu"> </strong>块来进行细粒度的定义。在当前示例中，我们不需要来自DB pod的任何出站流量，因此当前配置很好，因为在前面的步骤中已经拒绝了出站流量。</p><p id="b3d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常情况下，pod需要与DNS服务器通信，以便解析服务名称。该编辑器通过一个专用按钮使得只允许这种传出通信变得非常简单:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/807db206064087dd93b0bcc0cb7d599b.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*qdY1hUxP0pgCJMTEWGN04w.png"/></div></figure><p id="321d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们不需要打开这个DNS流量，因为mongo pod不调用任何实体，因此不需要查询DNS。</p><h2 id="58d8" class="os md it bd me oz pa dn mi pb pc dp mm li pd pe mo lm pf pg mq lq ph pi ms pj bi translated">测试网络策略</h2><p id="ada5" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">现在让我们创建生成的<code class="fe ok ol om on b">NetworkPolicy</code>,并确保它只允许来自应用程序前端pod的流量进入DB pod。</p><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="518f" class="os md it on b gy ot ou l ov ow"><strong class="on iu">$ cat &lt;&lt;EOF | kubectl apply -f -</strong><br/>apiVersion: networking.k8s.io/v1<br/>kind: NetworkPolicy<br/>metadata:<br/>  name: db-guestbook<br/>  namespace: guestbook<br/>spec:<br/>  podSelector:<br/>    matchLabels:<br/>      app: guestbook<br/>      tier: backend<br/>  policyTypes:<br/>    - Ingress<br/>    - Egress<br/>  ingress:<br/>    - from:<br/>        - podSelector:<br/>            matchLabels:<br/>              app: guestbook<br/>              tier: frontend<br/>      ports:<br/>        - port: 27017<br/>  egress: []<br/><strong class="on iu">EOF</strong></span></pre><p id="d15d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查从一个名称空间而不是从<code class="fe ok ol om on b">guestbook</code>的pod的访问:</p><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="a02b" class="os md it on b gy ot ou l ov ow"><strong class="on iu">$ kubectl run test -ti --rm --image=mongo \<br/>  --command mongo mongodb://mongo.guestbook</strong></span><span id="b971" class="os md it on b gy ox ou l ov ow">If you don't see a command prompt, try pressing enter.<br/><strong class="on iu">Error: couldn't connect to server mongo.guestbook:27017</strong>, connection attempt failed: SocketException: Error connecting to mongo.guestbook:27017 (10.245.211.49:27017) :: caused by :: Connection timed out :<br/>connect@src/mongo/shell/mongo.js:374:17<br/>@(connect):2:6<br/>exception: connect failed<br/>exiting with code 1<br/>Session ended, resume using 'kubectl attach test -c test -i -t' command when the pod is running<br/>pod "test" deleted</span></pre><p id="0f4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不出所料，连接是不可能的。现在让我们检查来自<code class="fe ok ol om on b">guestbook</code>名称空间内的非前端pod的访问:</p><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="b7eb" class="os md it on b gy ot ou l ov ow"><strong class="on iu">$ kubectl run test -ti --rm --image=mongo \<br/>  -n guestbook \<br/>  --command mongo mongodb://mongo.guestbook</strong></span><span id="48b7" class="os md it on b gy ox ou l ov ow">If you don't see a command prompt, try pressing enter.<br/><strong class="on iu">Error: couldn't connect to server mongo.guestbook:27017</strong>, connection attempt failed: SocketException: Error connecting to mongo.guestbook:27017 (10.245.211.49:27017) :: caused by :: Connection timed out :<br/>connect@src/mongo/shell/mongo.js:374:17<br/>@(connect):2:6<br/>exception: connect failed<br/>exiting with code 1<br/>Session ended, resume using 'kubectl attach test -c test -i -t' command when the pod is running<br/>pod "test" deleted</span></pre><p id="ecc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次，连接失败是意料之中的。现在让我们检查来自<code class="fe ok ol om on b">guestbook</code>名称空间内的前端pod的访问:</p><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="f5a3" class="os md it on b gy ot ou l ov ow"><strong class="on iu">$ kubectl run test -ti --rm --image=mongo \<br/>  -n guestbook \<br/>  --labels="app=guestbook,tier=frontend" \<br/>  --command mongo mongodb://mongo.guestbook</strong></span><span id="e237" class="os md it on b gy ox ou l ov ow">If you don't see a command prompt, try pressing enter.<br/>&gt; show dbs<br/>admin      0.000GB<br/>config     0.000GB<br/>guestbook  0.000GB<br/>local      0.000GB<br/>&gt;</span></pre><p id="9b6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，连接成功，因为它是从允许访问后端pod的pod发起的。网络前端现在工作正常。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/61ec3eb30cab6c4bcc75aa64a517c843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELKmJNtb_9AmUsrXtblJ4w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">留言簿前端回到正轨</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cb38" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">外卖食品</h1><p id="166c" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated"><code class="fe ok ol om on b">NetworkPolicy</code>在Kubernetes中是一个非常重要的资源，因为它在集群中提供了工作负载隔离。乍一看，这个资源似乎很复杂，但是如果我们使用正确的工作流来定义它，它并不那么难。</p><p id="341b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Cilium的这个新编辑器确实有助于定义一个<code class="fe ok ol om on b">NetworkPolicy</code>规范，并且提供了最佳实践。如果你需要创建<code class="fe ok ol om on b">NetworkPolicy</code>或者只是想了解更多关于资源的信息，一定要仔细看看这个在线编辑器。</p></div></div>    
</body>
</html>