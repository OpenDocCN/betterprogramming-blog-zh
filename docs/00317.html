<html>
<head>
<title>These Tips Will Boost Your React Code Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这些提示将提高您的React代码性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-react-performance-tips-f6e65295fba5?source=collection_archive---------0-----------------------#2019-04-03">https://betterprogramming.pub/5-react-performance-tips-f6e65295fba5?source=collection_archive---------0-----------------------#2019-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e103" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从2500毫秒到1500毫秒的等待时间会对你的UX和转化率产生巨大的影响</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/40956b46a65ead94aa01afc8ce721d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*UVy_UmV55Qj_VAH7BGNHMw.png"/></div></figure><p id="30a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">React 很受欢迎，因为React应用程序伸缩性很好，而且使用起来很有趣。一旦你的应用程序扩展，你可能要考虑优化你的应用程序。从2500毫秒的等待时间到1500毫秒会对你的UX和转化率产生巨大的影响。</p><p id="9b26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是我在React中使用的一些性能技巧。</p></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h1 id="c357" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">React .备忘录</h1><p id="7031" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">如果您有一个无状态组件，并且您知道您的组件不需要重新呈现，那么将您的整个无状态组件包装在一个<code class="fe mh mi mj mk b">React.memo</code>函数中。举个例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="28e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">变成如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="cd99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将整个无状态组件包装在一个<code class="fe mh mi mj mk b">React.memo</code>函数中。注意有助于调试的<code class="fe mh mi mj mk b">profile.displayName</code>。<a class="ae kw" href="http://&quot;https://stackoverflow.com/a/41582557/5073961" rel="noopener ugc nofollow" target="_blank">关于component.displayName的更多信息</a></p><p id="7235" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mh mi mj mk b">React.memo</code>相当于班级版<code class="fe mh mi mj mk b">React.PureComponent</code>。</p><h1 id="a63e" class="le lf it bd lg lh mn lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx mr lz ma mb bi translated">做出反应。纯组件</h1><p id="6eed" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated"><code class="fe mh mi mj mk b">PureComponent</code>用<code class="fe mh mi mj mk b">shouldComponentUpdate</code>生命周期法比较道具和状态。这意味着如果状态和道具相同，它不会重新渲染。让我们将之前的无状态组件重构为基于类的组件。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="9b15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们确定道具和状态不会改变，我们可以不使用<code class="fe mh mi mj mk b">Component</code>，而是使用<code class="fe mh mi mj mk b">PureComponent</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ml mm l"/></div></figure></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h1 id="a726" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">ComponentDidCatch(错误，信息){}生命周期方法</h1><p id="ee92" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">组件可能会产生副作用，导致应用程序在生产中崩溃。如果你有超过1000个组件，很难跟踪所有的东西。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="25a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现代web应用程序中有如此多的活动部分，很难理解整个概念，也很难处理错误。幸运的是，React引入了一种新的生命周期方法来处理错误。</p><p id="41d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mh mi mj mk b">componentDidCatch()</code>方法的工作方式类似于JavaScript catch <code class="fe mh mi mj mk b">{}</code>块，只是针对组件。只有类组件可以是错误边界。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ml mm l"/></div></figure></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h1 id="76fa" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">React.lazy:带悬念的代码拆分</h1><blockquote class="ms mt mu"><p id="0a14" class="jq jr mv js b jt ju jv jw jx jy jz ka mw kc kd ke mx kg kh ki my kk kl km kn im bi translated">“我们为组件建立了一种通用的方法，在它们加载异步数据时暂停渲染，我们称之为悬念。您可以暂停任何状态更新，直到数据准备就绪，并且您可以向树深处的任何组件添加异步加载，而无需通过您的应用程序检查所有属性和状态并提升逻辑。在高速网络上，更新显得非常流畅和即时，没有出现和消失的旋转器的不和谐级联。在慢速网络上，您可以有意设计用户应该看到哪些加载状态，以及它们应该有多细粒度或多粗粒度，而不是根据代码的编写方式来显示微调器。该应用始终保持响应。”——丹·阿布拉莫夫。</p></blockquote><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="9b20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">点击此处阅读更多关于超越反应16 的信息。</p></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h1 id="8d7b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">做出反应。片段，以避免额外的HTML元素包装</h1><p id="cd07" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">如果您以前使用过React，您可能知道以下错误代码:</p><p id="31c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mh mi mj mk b">Parse Error: Adjacent JSX elements must be wrapped in an enclosing tag</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="eae9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">React组件只能有一个子组件。这是故意的。</p><p id="9aad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的代码会让你的应用崩溃。解决这个问题的方法是将所有东西都包装在一个元素中。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="152f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下代码的唯一问题是，我们对每个组件都有一个扩展的包装器。我们需要渲染的标记越多，我们的应用程序就越慢。</p><h2 id="3c58" class="mz lf it bd lg na nb dn lk nc nd dp lo kb ne nf ls kf ng nh lw kj ni nj ma nk bi translated">拯救碎片:</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="8767" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">瞧啊。不需要额外的标记。</p><p id="ecdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想了解更多关于React的知识，我可以看看《<a class="ae kw" href="https://amzn.to/2yr3Xpi" rel="noopener ugc nofollow" target="_blank"> <em class="mv">》这本书。</em></a></p><p id="eecf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">额外收获——这是片段的简写。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="51db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢阅读！❤</p></div></div>    
</body>
</html>