<html>
<head>
<title>Memory Card Game Tutorial written in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Swift写的存储卡游戏教程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-memory-card-game-6513f34dd25c?source=collection_archive---------0-----------------------#2019-04-07">https://betterprogramming.pub/building-a-memory-card-game-6513f34dd25c?source=collection_archive---------0-----------------------#2019-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2ae3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">协议简介</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/566a324c71b28e54da6c998eee717e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lzc8mPV1p3fdis6suPXhHA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杰夫·谢尔登在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8b5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将构建一个简单的记忆卡游戏，我觉得玩起来非常简单有趣。希望我们能在这个过程中了解一些关于类和Swift协议的知识。</p><p id="5e9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在跳到编码部分之前，我们先来看看这个游戏怎么玩。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4ed3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">记忆卡怎么玩</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/c3cbd49abc669164d1db37a5edde4b7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*yhy7IC6TfYvcSlqrbzyFHA.png"/></div></figure><p id="a857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的记忆卡游戏有一个4x4的格子。最初，所有单元格都显示出来，但它们的图像是隐藏的。当你点击一个单元格时，它会显示其背后的图像。</p><p id="22ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">玩家的任务是找到匹配的单元格。如果他们点击的下一个单元格包含相同的图像，那么它是匹配的，两个单元格仍然可见。</p><p id="03f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果下一个单元格不包含相同的图像，那么它就是未命中，两个单元格都回到隐藏状态。玩家继续，直到找到所有匹配的单元格。</p><p id="4916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直爽又好玩！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e234" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">项目结构</h1><p id="896b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了构建这个游戏的简单版本，我们需要以下组件:</p><ul class=""><li id="0d78" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">一个控制器:<code class="fe nj nk nl nm b">GameController.swift</code>。</li><li id="47cd" class="na nb it lb b lc nn lf no li np lm nq lq nr lu nf ng nh ni bi translated">一种观点:<code class="fe nj nk nl nm b">CardCell.swift</code>。</li><li id="b1c3" class="na nb it lb b lc nn lf no li np lm nq lq nr lu nf ng nh ni bi translated">两款:<code class="fe nj nk nl nm b">MemoryGame.swift</code>和<code class="fe nj nk nl nm b">Card.swift</code>。</li><li id="0202" class="na nb it lb b lc nn lf no li np lm nq lq nr lu nf ng nh ni bi translated">和<code class="fe nj nk nl nm b">Main.storyboard</code>来实现我们游戏的网格视图。</li></ul><p id="a474" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从这个游戏最简单的组成部分开始——一张牌。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="55c7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Card.swift</h1><p id="fa9f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们的卡模型将具有以下三个属性:</p><ul class=""><li id="4560" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">一个<code class="fe nj nk nl nm b">id</code>用来识别每张卡，</li><li id="a37e" class="na nb it lb b lc nn lf no li np lm nq lq nr lu nf ng nh ni bi translated">一个布尔变量<code class="fe nj nk nl nm b">shown</code>来知道卡片的状态(是显示还是隐藏)。</li><li id="15fc" class="na nb it lb b lc nn lf no li np lm nq lq nr lu nf ng nh ni bi translated">一个<code class="fe nj nk nl nm b">artworkURL</code>用于卡片图像。</li></ul><pre class="kj kk kl km gt ns nm nt nu aw nv bi"><span id="fb0b" class="nw md it nm b gy nx ny l nz oa">class <strong class="nm iu">Card</strong> {        <br/>    var id: String    <br/>    var shown: Bool = false    <br/>    var artworkURL: UIImage!<br/>}</span></pre><p id="6b49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要实现以下方法来管理我们与卡的交互:</p><ol class=""><li id="7480" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu ob ng nh ni bi translated">一种用图像初始化卡片的方法。这是将所有属性初始化为默认val的地方。对于卡的<code class="fe nj nk nl nm b">id</code>，我们通过调用<code class="fe nj nk nl nm b">NSUUIS().uuidString</code>生成一个随机id。</li></ol><pre class="kj kk kl km gt ns nm nt nu aw nv bi"><span id="76b1" class="nw md it nm b gy nx ny l nz oa"><strong class="nm iu">init</strong>(image: UIImage) {        <br/>    self.id = NSUUID().uuidString        <br/>    self.shown = false        <br/>    self.artworkURL = image    <br/>}</span></pre><p id="0cdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.一种通过比较两张卡的id来检查它们是否相等的方法。</p><pre class="kj kk kl km gt ns nm nt nu aw nv bi"><span id="9f90" class="nw md it nm b gy nx ny l nz oa">func <strong class="nm iu">equals</strong>(_ card: Card) -&gt; Bool {<br/>    return (card.id == id)    <br/>}</span></pre><p id="3ede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.一种为每张卡片创建一个副本的方法，目的是使匹配的卡片数量为偶数。这个方法将返回另一个具有相同值的<code class="fe nj nk nl nm b">Card</code>实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="f0e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.每次我们开始新游戏时随机洗牌的方法。我们将使它成为<code class="fe nj nk nl nm b">Array</code>类的一个扩展，这样我们就可以从游戏网格中的卡片数组中调用它。我们会讨论这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="4039" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们的<code class="fe nj nk nl nm b">Card</code>模型的最终实现及其属性和方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4d74" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">记忆游戏</h1><p id="0ef5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们的第二个模型是<code class="fe nj nk nl nm b">MemoryGame</code>，这里我们将定义我们游戏的4x4网格。</p><p id="2106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将具有以下属性:</p><ul class=""><li id="d1c2" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">网格上所有牌的数组:<code class="fe nj nk nl nm b">cards</code>。</li><li id="cd34" class="na nb it lb b lc nn lf no li np lm nq lq nr lu nf ng nh ni bi translated">正在显示的卡片的数组:<code class="fe nj nk nl nm b">cardsShown</code>。</li><li id="bab3" class="na nb it lb b lc nn lf no li np lm nq lq nr lu nf ng nh ni bi translated">一个bool变量:<code class="fe nj nk nl nm b">isPlaying</code>，用来跟踪游戏的状态。</li></ul><pre class="kj kk kl km gt ns nm nt nu aw nv bi"><span id="6d30" class="nw md it nm b gy nx ny l nz oa">class <strong class="nm iu">MemoryGame</strong> {        <br/>    var cards:[Card] = [Card]()    <br/>    var cardsShown:[Card] = [Card]()    <br/>    var isPlaying: Bool = false<br/>}</span></pre><p id="76c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要实现一些方法来管理我们与网格的交互。他们将会是:</p><ol class=""><li id="7d90" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu ob ng nh ni bi translated">一种方法来<strong class="lb iu">洗牌</strong>我们格子里的牌。</li></ol><pre class="kj kk kl km gt ns nm nt nu aw nv bi"><span id="bc07" class="nw md it nm b gy nx ny l nz oa">func <strong class="nm iu">shuffleCards</strong>(cards:[Card]) -&gt; [Card] {        <br/>    var randomCards = cards        <br/>    randomCards.shuffle()                </span><span id="bd4a" class="nw md it nm b gy oe ny l nz oa">    return randomCards    <br/>}</span></pre><p id="a22c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.创建新游戏的方法。这里我们需要调用我们的<strong class="lb iu"> shuffle </strong>方法来初始化我们的卡组，并将我们的<code class="fe nj nk nl nm b">isPlaying</code>变量初始化为<code class="fe nj nk nl nm b">true</code>。</p><pre class="kj kk kl km gt ns nm nt nu aw nv bi"><span id="9aea" class="nw md it nm b gy nx ny l nz oa">func <strong class="nm iu">newGame</strong>(cardsArray:[Card]) -&gt; [Card] {        <br/>    cards = <strong class="nm iu">shuffleCards</strong>(cards: cardsArray)        <br/>    isPlaying = true            </span><span id="43fa" class="nw md it nm b gy oe ny l nz oa">    return cards    <br/>}</span></pre><p id="dd9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.如果我们想要<strong class="lb iu">重新开始</strong>游戏，我们需要将我们的<code class="fe nj nk nl nm b">isPlaying</code>变量设置为<code class="fe nj nk nl nm b">false</code>，并删除我们的卡牌数组，这样我们就可以开始一个新的游戏。</p><pre class="kj kk kl km gt ns nm nt nu aw nv bi"><span id="a320" class="nw md it nm b gy nx ny l nz oa">func <strong class="nm iu">restartGame</strong>() {        <br/>    isPlaying = false                <br/>    cards.removeAll()        <br/>    cardsShown.removeAll()    <br/>}</span></pre><p id="a0ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.一种知道哪张卡被按下的方法。我们将使用这个索引来标识<code class="fe nj nk nl nm b">collectionView</code>(游戏的网格)中的每个单元格。稍后将详细介绍。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="eb26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.返回特定卡片位置的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="3a9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.<code class="fe nj nk nl nm b">unmatchedCardShown</code>方法指示选择的牌是否不匹配(当前回合中选择的第一张)。</p><pre class="kj kk kl km gt ns nm nt nu aw nv bi"><span id="aa18" class="nw md it nm b gy nx ny l nz oa">func <strong class="nm iu">unmatchedCardShown</strong>() -&gt; Bool {<br/>    return cardsShown.count % 2 != 0<br/>}</span></pre><p id="9d04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">6.<code class="fe nj nk nl nm b">unmatchedCard</code>方法读取** <code class="fe nj nk nl nm b">cardsShown</code> **数组中的最后一个元素，返回不匹配的卡片。</p><pre class="kj kk kl km gt ns nm nt nu aw nv bi"><span id="0050" class="nw md it nm b gy nx ny l nz oa">func <strong class="nm iu">unmatchedCard</strong>() -&gt; Card? {<br/>    let unmatchedCard = cardsShown.last<br/> <br/>    return unmatchedCard<br/>}</span></pre><p id="76a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">7.当玩家点击卡片时将被调用的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="db6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来有很多代码，但实际上很简单。</p><p id="a717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只是定义了游戏中需要的两个主要的类——一张卡片和一个格子。</p><p id="f421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们继续我们的故事板和控制器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="123f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">主故事板和游戏控制器</h1><p id="34f1" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们的<code class="fe nj nk nl nm b">Main.storyboard</code>会是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/cba4deb3f504e25a5e939ffa315f902e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A52oTF41TbDNMUYWFTgUjg.png"/></div></div></figure><p id="cc49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初，在控制器中，我们需要在<code class="fe nj nk nl nm b">viewDidLoad</code>中设置一个新游戏，包括为我们的网格获取图像。在我们的游戏中，这将由一个4x4 <code class="fe nj nk nl nm b">collectionView</code>组成。</p><p id="bdf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把<code class="fe nj nk nl nm b">GameController</code>设置为单视图应用程序的根视图控制器，在<code class="fe nj nk nl nm b">GameController</code>中，我们将有一个<code class="fe nj nk nl nm b">collectionView</code> <em class="og"> </em>，我们将把它称为<code class="fe nj nk nl nm b">IBOutlet</code>。</p><p id="e201" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们还将引用一个<code class="fe nj nk nl nm b">IBAction</code>按钮<code class="fe nj nk nl nm b">onStartGame()</code>，也就是你在我们标题为<code class="fe nj nk nl nm b">PLAY</code>的故事板中看到的<code class="fe nj nk nl nm b">UIButton</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4e80" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们的控制器实现中的亮点</h1><ol class=""><li id="bbbf" class="na nb it lb b lc mv lf mw li oh lm oi lq oj lu ob ng nh ni bi translated">我们首先初始化我们的两个主要对象——网格:<strong class="lb iu"> </strong> <code class="fe nj nk nl nm b">game = MemoryGame()</code>，以及我们的卡片集:<code class="fe nj nk nl nm b">cards = [Card]()</code>。</li><li id="0726" class="na nb it lb b lc nn lf no li np lm nq lq nr lu ob ng nh ni bi translated">我们在<code class="fe nj nk nl nm b">viewDidLoad</code> <strong class="lb iu">、</strong>中设置游戏的初始变量，这是我们的应用程序运行后第一个被调用的方法。</li><li id="aeed" class="na nb it lb b lc nn lf no li np lm nq lq nr lu ob ng nh ni bi translated"><code class="fe nj nk nl nm b">collectionView</code> <em class="og"> </em>最初设置为<code class="fe nj nk nl nm b">hidden</code>，因此在用户按下<code class="fe nj nk nl nm b">PLAY</code>之前，屏幕上看不到任何卡片。</li><li id="468c" class="na nb it lb b lc nn lf no li np lm nq lq nr lu ob ng nh ni bi translated">一旦用户按下<code class="fe nj nk nl nm b">PLAY</code>，就会调用<code class="fe nj nk nl nm b">onStartGame</code> <code class="fe nj nk nl nm b">IBAction</code>，我们将<code class="fe nj nk nl nm b">collectionView</code>的<em class="og"> </em> <code class="fe nj nk nl nm b">isHidden</code>属性设置为<code class="fe nj nk nl nm b">false</code>，使其可见。</li><li id="8320" class="na nb it lb b lc nn lf no li np lm nq lq nr lu ob ng nh ni bi translated">每当用户选择一个项目，就会调用<code class="fe nj nk nl nm b">collectionView</code><em class="og"/>的方法<code class="fe nj nk nl nm b">didSelectItemAt:</code>。在这个方法中，我们调用自己的<code class="fe nj nk nl nm b">didSelectCard:</code>来传递游戏的主要逻辑。</li></ol><p id="6c6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们的<code class="fe nj nk nl nm b">GameController</code>的最终实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="652b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们暂时停留在<code class="fe nj nk nl nm b">CollectionView</code>的委托方法<em class="og"> </em>或者<strong class="lb iu">协议</strong>上。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="460b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">协议</h1><p id="636e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">使用协议是Swift最基本的编程模式之一。</p><p id="bef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用协议，您可以为类、结构或枚举器定义要采用和实现的规则。这个原则允许我们编写解耦的、模块化的和可扩展的Swift代码。</p><p id="5c74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，这是我们已经为<code class="fe nj nk nl nm b">GameController</code>中的<code class="fe nj nk nl nm b">collectionView</code>实现的模式。现在我们要做我们自己的了。语法如下所示:</p><pre class="kj kk kl km gt ns nm nt nu aw nv bi"><span id="416e" class="nw md it nm b gy nx ny l nz oa">protocol <strong class="nm iu">MemoryGameProtocol </strong>{<br/>    //protocol definition goes here<strong class="nm iu"><br/></strong>}</span></pre><p id="54e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经知道协议是我们定义一个类要实现的规则或指令的地方，我们现在可以考虑我们游戏的指令应该是什么。</p><p id="fe3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们基本上需要知道4件事:</p><ol class=""><li id="c82b" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu ob ng nh ni bi translated">何时开始游戏:<code class="fe nj nk nl nm b">memoryGameDidStart</code>。</li><li id="0f60" class="na nb it lb b lc nn lf no li np lm nq lq nr lu ob ng nh ni bi translated">何时显示一张牌反面朝上:<code class="fe nj nk nl nm b">memoryGameShowCards</code>。</li><li id="94fc" class="na nb it lb b lc nn lf no li np lm nq lq nr lu ob ng nh ni bi translated">什么时候倒着出一张牌:<code class="fe nj nk nl nm b">memoryGameHideCards</code>。</li><li id="c653" class="na nb it lb b lc nn lf no li np lm nq lq nr lu ob ng nh ni bi translated">何时结束游戏:<code class="fe nj nk nl nm b">memoryGameDidEnd</code>。</li></ol><p id="5cb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们声明了我们的协议，我们需要在我们的主类中实现所有四个方法，在本例中，我们的主控制器:<code class="fe nj nk nl nm b">GameController</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="556c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak"> memoryGameDidStart </strong></h1><p id="d435" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当这个方法被触发时，意味着游戏应该开始(在我们的游戏中，这发生在玩家点击播放按钮时)。</p><p id="1dfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将简单地通过调用<code class="fe nj nk nl nm b">collectionView.reloadData()</code>来重新加载内容，现在是一组洗牌。</p><pre class="kj kk kl km gt ns nm nt nu aw nv bi"><span id="b282" class="nw md it nm b gy nx ny l nz oa">func <strong class="nm iu">memoryGameDidStart</strong>(_ game: MemoryGame) {<br/>    collectionView.reloadData()<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dfc9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">记忆游戏显示卡</h1><p id="0a57" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们从<code class="fe nj nk nl nm b">collectionView</code>的<code class="fe nj nk nl nm b">didSelectItemAt:</code>中调用这个方法。</p><p id="2b5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，它显示选定的卡片。然后，它检查我们的<code class="fe nj nk nl nm b">cardsShown</code>数组中是否存储了不匹配的牌(如果<code class="fe nj nk nl nm b">cardsShown</code>计数为奇数)。如果我们有一张不匹配的卡，那么我们将选择的卡与不匹配的卡进行比较。</p><p id="c95f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果它们相等，两张卡都被附加到<code class="fe nj nk nl nm b">cardsShown</code>上，它们仍然可见。如果它们不相等，我们从<code class="fe nj nk nl nm b">cardsShown</code>列表中移除不匹配的卡并隐藏两张卡。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="045f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">记忆卡</strong></h1><p id="01ec" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果牌不相等，这个方法被调用，所以它们返回到隐藏状态，<code class="fe nj nk nl nm b">shown = false</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6bfe" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">记忆游戏结束</strong></h1><p id="7c4c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当这个方法被调用时，意味着所有的卡片都是可见的——我们已经将所有的初始卡片移动到我们的<code class="fe nj nk nl nm b">cardsShown</code>列表中:<code class="fe nj nk nl nm b">cardsShown.count = cards.count</code>，所以游戏结束了。</p><p id="df81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们调用了<code class="fe nj nk nl nm b">endGame()</code>将<code class="fe nj nk nl nm b">isPlaying</code>变量设置为<code class="fe nj nk nl nm b">false</code>之后，这个方法会被专门调用。从这里我们显示一个警告，让用户知道游戏已经结束，我们也使用这个<code class="fe nj nk nl nm b">alertController</code>作为控制器的指示器。</p><p id="4899" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当警报解除时，<code class="fe nj nk nl nm b">viewDidDisappear</code>被调用，它重置游戏，这样用户可以再次玩游戏。</p><p id="70b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe nj nk nl nm b">GameController</code>中，这四个方法看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/6c5088c18db5e6f2a5159101918ba199.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/1*gCOrpUTweyh8RQNYOYI1eQ.gif"/></div></figure><p id="99ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个功能性的项目，所以你可以克隆它，用它来玩。</p><div class="ol om gp gr on oo"><a href="https://github.com/Xiomara7/Memory/blob/master/README.md" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">xiomara 7/内存</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">在GitHub上创建一个帐户，为内存开发做贡献。</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">github.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div></div></div>    
</body>
</html>