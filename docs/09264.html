<html>
<head>
<title>Dynamic Module Imports in JavaScript: The How And Why</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的动态模块导入:方法和原因</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dynamic-module-imports-in-javascript-the-how-and-why-9a47114119c?source=collection_archive---------4-----------------------#2021-08-04">https://betterprogramming.pub/dynamic-module-imports-in-javascript-the-how-and-why-9a47114119c?source=collection_archive---------4-----------------------#2021-08-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6e00" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不要在第一次加载时加载那些不必要的大文件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ea47ddba6883a63479dff5ad5ce5a80f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1waqdNkIs814ifxQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@winstonchen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">温斯顿陈</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="398d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想让你的代码更快更有性能，动态模块导入扮演了一个非常重要的角色。大多数时候，你不需要一次加载所有那些又重又大的文件。如果我们能在需要的时候导入这些文件，那将会非常有帮助。</p><p id="185c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动态模块导入在这里可以成为救世主。在本文中，我们将讨论什么是动态模块导入，以及它们非常有用的一些用例。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="35d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们看一下这两个文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="ffeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，我们有这两个简单的js文件:<code class="fe me mf mg mh b">user.js</code> <strong class="lb iu">、</strong>和<code class="fe me mf mg mh b">script.js</code>。</p><p id="ecdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">user.js</code>有一个名为<code class="fe me mf mg mh b">User</code>的类，它接受两个属性:<code class="fe me mf mg mh b">first</code>名和<code class="fe me mf mg mh b">last</code>名，还有一个简单的<code class="fe me mf mg mh b">printUser</code>函数，它将简单地在控制台中打印全名。</p><p id="9735" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">script.js</code> <strong class="lb iu"> </strong>有一个标准的<code class="fe me mf mg mh b">import</code>语句，从<code class="fe me mf mg mh b">user.js</code>导入<code class="fe me mf mg mh b">User</code>和<code class="fe me mf mg mh b">printUser</code>。之后我们创建了一个新用户，名字<code class="fe me mf mg mh b">first</code>为<code class="fe me mf mg mh b">Gourav</code>，名字<code class="fe me mf mg mh b">last</code>为<code class="fe me mf mg mh b">Kajal</code>，然后我们调用<code class="fe me mf mg mh b">printuser</code>函数在控制台打印用户名。非常简单。</p><p id="d21b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们大多数时候在代码中使用import语句的方式。现在，这段代码目前的工作方式是，我们的浏览器将首先下载<code class="fe me mf mg mh b">script.js</code>，然后在页面加载后立即下载<code class="fe me mf mg mh b">user.js</code> <strong class="lb iu"> </strong>。即使你使用的是像Webpack这样的捆绑器，这两个文件也会合并在一起，新文件会在页面加载时下载。无论发生什么，所有的<code class="fe me mf mg mh b">user.js</code> <strong class="lb iu"> </strong>代码和所有的<code class="fe me mf mg mh b">script.js</code>代码都会在页面加载后立即下载。</p><p id="59ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，使用动态模块导入，我们可以做的是稍后下载应用程序的一些代码，或者根本不下载代码。</p><p id="f78f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们看看如何将其转换为动态模块导入。这其实很简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="6259" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们没有使用<code class="fe me mf mg mh b">import</code>语句，而是使用了<code class="fe me mf mg mh b">import()</code>函数，它接受一个参数，即文件路径，并返回一个<code class="fe me mf mg mh b">promise</code>。所以我们使用了<code class="fe me mf mg mh b">then</code>并析构了从<code class="fe me mf mg mh b">user.js</code>返回的任何东西，然后简单地将我们的代码移到那个块中。现在，<code class="fe me mf mg mh b">user.js</code>将在我们调用该函数时被加载，而不是初始加载。</p><p id="c3cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试这一点，我将导入函数放在一个超时内，以便在页面加载后，它将等待五秒钟，然后将加载<code class="fe me mf mg mh b">user.js</code>。即使您有捆绑器，<code class="fe me mf mg mh b">user.js</code>也不会与<code class="fe me mf mg mh b">script.js</code>结合，在初始页面加载时，只会加载<code class="fe me mf mg mh b">script.js</code>，五秒钟后会加载<code class="fe me mf mg mh b">user.js</code>。</p><p id="f091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是动态模块导入的基本思想和理解。使用它，你的web应用程序将加载得更快，因为它不必下载所有不必要的代码。</p><p id="5038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们看看动态模块导入有用的一些用例。</p><h1 id="20a0" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">示例1:代码分割</h1><p id="9f8a" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">作为一名开发人员，我们试图将我们的代码分成尽可能多的包，这样我们就可以下载最少的代码。如果你需要额外的代码，你可以随时下载。这就是我们要通过动态模块导入实现的目标。</p><p id="b7c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完全理解它，让我们看一下我们的<code class="fe me mf mg mh b">script.js</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="644b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，这是一个超级简单的文件。正如我们所见，我们从<code class="fe me mf mg mh b">admin.js</code>导入了一个名为<code class="fe me mf mg mh b">setupAdminUser()</code>的函数。现在，如果用户是管理员，我们将调用这个函数。这是正常导入的样子。</p><p id="0ef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的问题是，不管用户实际上是什么类型，<code class="fe me mf mg mh b">admin.js</code>总是会被下载。但是只有当它是管理员用户时才会被执行。因此，可能对于大多数用户来说，我们只是不必要地下载这个文件，它可能包含大量的代码。这实际上是一个可以使用动态模块导入的理想地方。</p><p id="b586" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，请看下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="0a97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，不是总是下载<code class="fe me mf mg mh b">admin.js</code>，而是仅当用户是管理员时才下载。还有wallah，我们可能节省了很多带宽，我们的应用程序下载速度会更快。</p><h1 id="f13a" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">示例2:减少内存使用</h1><p id="d66c" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">加快页面加载时间是动态模块导入的一个明显的用例，但另一个用例是当您有一堆不同的文件，而您只需要其中的一个，所以您只需要下载一个。没有动态导入，就要全部下载。语言翻译文件很适合它。</p><p id="4027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">举个例子，假设我们有一个支持三种语言的多语言web应用程序:英语、法语和西班牙语。我们简单地使用导入语句来获取翻译，并有条件地使用它们，如下面的代码所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="afc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，即使我们一次有条件地使用一个翻译，我们仍然将它们全部导入，这就是为什么所有三个翻译文件都将被下载，而不管用户当前的语言环境。</p><p id="457e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，想象一下这些翻译文件非常大，你有二十个。它们都将被下载，这将导致我们的web应用程序的性能更差。</p><p id="a983" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用动态导入，只下载当前需要的文件，而不是一次性下载所有文件。我们可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="e8a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这个看起来比上一个好多了。而且实际上比前一个好用多了。这里我们只是根据用户的语言环境动态地导入翻译文件，甚至动态地创建翻译文件名。然后，一切看起来都与我们在前面的例子中已经看到的东西相似。</p><p id="c53c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们甚至使用<code class="fe me mf mg mh b">catch</code>处理了默认导入，所以如果没有找到语言环境，英语翻译将默认导入。</p><p id="e4f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方式允许我们只下载一个文件，节省了内存空间，也节省了下载速度。超级有用。</p><h1 id="d79b" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">示例3:提高代码性能</h1><p id="6413" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们要讨论的最后一个例子与前一个非常相似，但重点会有所不同。最后一个例子是关于节省时间和内存，因为我们只下载一个文件，而不是下载数百个大文件。这个用例完全是为了节省时间和内存，但前提是我们需要它。</p><p id="b22f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了完全理解这个例子，让我们假设我们有一个类似这样的文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="8f0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如我们所见，我们有一个形状数组，我们构建了一个复杂的渲染引擎，其中可能有数百个我们想要渲染的不同形状。通常，我们需要做的是为每个形状导入所有的渲染引擎，然后我们需要检查它是哪个形状，然后将其渲染出来。我们使用<code class="fe me mf mg mh b">switch</code>语句来实现这个目的。很简单，对吧？</p><p id="1d1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的问题也是下载不必要的文件。</p><p id="684d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过动态导入，我们可以确保只导入那些我们需要的文件。所以，假设你只想渲染一个<strong class="lb iu">三角形</strong>。在这种情况下，我们不必导入<strong class="lb iu">矩形</strong>文件。因此，我们可以更改代码来动态处理导入，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="e278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的好处是，如果我们从<code class="fe me mf mg mh b">shapes</code>数组中移除<strong class="lb iu">三角形</strong>，那么<strong class="lb iu">三角形. js </strong>将不会被导入。这节省了时间、内存和空间。</p><p id="5b9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，有一点非常好，那就是我们实际上也可以使用<code class="fe me mf mg mh b">async-await </code>来代替承诺。所以如果你对<code class="fe me mf mg mh b">async-await</code>更熟悉，你可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="8939" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是这篇文章的内容。我希望你今天学到了新东西。想看更多这样的文章，敬请期待！</p><p id="2b22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>