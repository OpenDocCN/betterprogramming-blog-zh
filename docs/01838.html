<html>
<head>
<title>Defining and Manipulating Classes and Objects in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中定义和操作类和对象</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/defining-and-manipulating-classes-and-objects-in-javascript-7f49c706f386?source=collection_archive---------8-----------------------#2019-10-16">https://betterprogramming.pub/defining-and-manipulating-classes-and-objects-in-javascript-7f49c706f386?source=collection_archive---------8-----------------------#2019-10-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ec7f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在基本面上刷新自己总是好的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/50966b4ffb60e58823cc2b307cba822d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vf0jrEf2HtesTVib"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mr_vero?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">欧文·史密斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9a76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，对象是允许我们将数据、函数和其他对象封装到一个我们可以访问和操作的实体中的实体。这是JavaScript程序的另一个基本构件。</p><p id="7e84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对象用于建模真实世界的数据。一只鸟就是一个例子。我们知道它有翅膀，一个头，两条腿和两个翅膀。此外，我们知道它会唧唧喳喳，吃东西，还会飞。</p><p id="d935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用对象在JavaScript中对它们建模。主体部分是对象的属性，它所做的动作是方法。</p><p id="2b4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方法是作为对象一部分的函数。属性是JavaScript中用键值对表示的任何东西。方法是特殊的属性。当一个属性有一个函数作为值时，它被称为方法。</p><p id="3cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们将一只鸟建模为一个对象，我们可以写:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="08bf" class="ma mb it lw b gy mc md l me mf">const bird = {<br/>  numWings: 2,<br/>  numLegs: 2,<br/>  numHeads: 1,<br/>  fly(){},<br/>  chirp(){},<br/>  eat(){}<br/>}</span></pre><p id="9278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">fly(){}</code>、<code class="fe mg mh mi lw b">chirp(){}</code>、<code class="fe mg mh mi lw b">eat(){}</code>为方法，其余为以数据为值的属性。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="565b" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">创建对象</h1><p id="2ac8" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在JavaScript中，我们可以用三种方式定义对象。我们可以通过使用对象构造函数方法，或者通过使用类，将它们定义为对象文字。</p><h2 id="1351" class="ma mb it bd mr nm nn dn mv no np dp mz li nq nr nb lm ns nt nd lq nu nv nf nw bi translated">对象文字</h2><p id="96a9" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">用对象文字定义对象很简单。我们只需要直接指定对象的属性和方法。例如，我们写道:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a271" class="ma mb it lw b gy mc md l me mf">const bird = {<br/>  name: 'Joe',<br/>  numWings: 2,<br/>  numLegs: 2,<br/>  numHeads: 1,<br/>  fly(){},<br/>  chirp(){},<br/>  eat(){}<br/>}</span></pre><p id="cac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将对象定义为对象文字。</p><p id="53bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想添加更多的属性，我们写:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8b81" class="ma mb it lw b gy mc md l me mf">bird.sleep = function(){};</span></pre><p id="25d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将任何东西指定为对象属性的值，因此字符串、布尔值、函数、数组和其他对象都可以设置为属性。</p><h2 id="ff0c" class="ma mb it bd mr nm nn dn mv no np dp mz li nq nr nb lm ns nt nd lq nu nv nf nw bi translated">对象构造函数</h2><p id="087d" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">同样，我们可以使用对象构造函数方法来定义一个对象。我们可以写:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f04e" class="ma mb it lw b gy mc md l me mf">let bird = new Object();<br/>bird.name = 'Joe';<br/>bird.numWings = 2;<br/>bird.numLegs = 2;<br/>bird.numHeads = 1;</span></pre><p id="bdf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种更长的定义对象的方式。它比对象文字更慢也更难阅读。</p><h2 id="fa56" class="ma mb it bd mr nm nn dn mv no np dp mz li nq nr nb lm ns nt nd lq nu nv nf nw bi translated">用类定义对象实例</h2><p id="445d" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我们也可以定义JavaScript，首先定义一个类，然后使用<code class="fe mg mh mi lw b">new</code>关键字创建一个对象，它是该类的一个实例。</p><p id="3704" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们写道:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9cb2" class="ma mb it lw b gy mc md l me mf">class Bird {<br/>  constructor(name, numWings) {<br/>    this.name = name;<br/>    this.numWings = numWings;<br/>  }</span><span id="a383" class="ma mb it lw b gy nx md l me mf">  logProperties() {<br/>    console.log(this)<br/>  }<br/>}</span><span id="31cb" class="ma mb it lw b gy nx md l me mf">const bird = new Bird('Joe', 2);<br/>bird.logProperties();</span></pre><p id="b90d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有了<code class="fe mg mh mi lw b">Bird</code>类，这是一个用<code class="fe mg mh mi lw b">name</code>和<code class="fe mg mh mi lw b">numWings</code>属性和<code class="fe mg mh mi lw b">getProperties</code>方法创建对象的模板。</p><p id="cf3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">Bird</code>类有一个<code class="fe mg mh mi lw b">constructor</code>函数，让我们传入属性值，并将其设置为被创建对象的属性。它还具有<code class="fe mg mh mi lw b">logProperties</code>功能。</p><p id="f279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">this</code>被设置为创建的对象，因为我们没有使用箭头函数作为方法。</p><p id="1c5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<code class="fe mg mh mi lw b">new</code>关键字并将数据传入<code class="fe mg mh mi lw b">constructor</code>来定义对象。一旦我们定义了对象，我们就可以调用它内部定义的方法。</p><p id="f115" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们调用了<code class="fe mg mh mi lw b">bird.logProperties</code>来记录<code class="fe mg mh mi lw b">this</code>的值，应该是<code class="fe mg mh mi lw b">{name: “Joe”, numWings: 2}</code>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="acb0" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">原型</h1><p id="c82c" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在JavaScript中，原型是允许您创建其他对象的模板。它们也可以用于JavaScript中的继承。所以，如果我们有一个<code class="fe mg mh mi lw b">Animal</code>对象定义为:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="25bb" class="ma mb it lw b gy mc md l me mf">function Animal(){<br/>  this.name = 'Joe'<br/>}</span></pre><p id="b9d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过创建一个新对象来扩展它，就像这样:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="20a3" class="ma mb it lw b gy mc md l me mf">let bird = animal.prototype;<br/>bird.fly = function() {};<br/>bird.chirp = function() {};</span></pre><p id="467b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到了<code class="fe mg mh mi lw b">fly</code>和<code class="fe mg mh mi lw b">chirp</code>方法，以及<code class="fe mg mh mi lw b">bird</code>对象中的<code class="fe mg mh mi lw b">name</code>属性。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a711" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">在对象中定义函数</h1><p id="2019" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我们可以用几种方法在对象中定义一个函数。</p><p id="9f40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以像往常一样使用<code class="fe mg mh mi lw b">function</code>关键字或箭头函数，但是我们也可以用<code class="fe mg mh mi lw b">function</code>关键字的简写来编写。例如，如果我们有一个<code class="fe mg mh mi lw b">bird</code>对象，我们想定义<code class="fe mg mh mi lw b">chirp</code>函数，我们可以写:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d3b2" class="ma mb it lw b gy mc md l me mf">const bird = {<br/> chirp: function(){<br/>   console.log('chirp', this)<br/>  }<br/>}</span></pre><p id="b4f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者使用下面的简写:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="771f" class="ma mb it lw b gy mc md l me mf">const bird = {<br/> chirp(){<br/>   console.log('chirp', this)<br/>  }<br/>}</span></pre><p id="1c49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两者相同，因为<code class="fe mg mh mi lw b">chirp</code>函数会将<code class="fe mg mh mi lw b">bird</code>对象作为<code class="fe mg mh mi lw b">this</code>的值。</p><p id="5274" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，如果使用箭头功能:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9568" class="ma mb it lw b gy mc md l me mf">const bird = {<br/> chirp: ()=&gt;{<br/>   console.log('chirp', this)<br/>  }<br/>}</span></pre><p id="cb47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">this</code>将被记录为全局<code class="fe mg mh mi lw b">window</code>对象，因为箭头函数不会改变函数所在对象的<code class="fe mg mh mi lw b">this</code>值。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="bbec" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">获取和设置对象属性</h1><p id="c961" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在定义了一个对象之后，能够获取和设置对象的属性是非常有用的。有两种方法可以获得对象的属性。一种是使用点符号，另一种是方括号符号。</p><p id="e1f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点符号允许我们获得属性名符合变量命名约定的属性。这意味着它们以字母、下划线或美元符号开头，没有空格或其他特殊字符。</p><p id="5a79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果我们有:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ede4" class="ma mb it lw b gy mc md l me mf">const bird = {<br/>  name: 'Joe',<br/>  numWings: 2,<br/>  numLegs: 2,<br/>  numHeads: 1,<br/>  fly(){},<br/>  chirp(){},<br/>  eat(){}<br/>}</span></pre><p id="6842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以通过写<code class="fe mg mh mi lw b">bird.name</code>来访问<code class="fe mg mh mi lw b">name</code>属性。</p><p id="c82e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种语法是方括号符号，它可以做与点符号相同的事情，也可以动态地访问属性。</p><p id="789b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还允许我们访问用不遵循变量名创建规则的名称定义的属性。为了使用方括号符号来获取对象属性，我们编写:<code class="fe mg mh mi lw b">bird['name']</code>。我们也可以写:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2a0e" class="ma mb it lw b gy mc md l me mf">const prop = 'name';<br/>bird[prop];</span></pre><p id="0b78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许我们通过传入变量和字符串来获取对象的属性，这对于动态修改对象和将对象用作字典非常方便，因为我们可以遍历键并修改它们和值。</p><p id="f6a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了用这两种表示法设置对象属性，我们使用赋值运算符，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="62e8" class="ma mb it lw b gy mc md l me mf">bird.name = 'Jane';</span></pre><p id="124d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，用方括号符号，我们写:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="89d2" class="ma mb it lw b gy mc md l me mf">bird['name']= 'Jane';</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="053e" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">获取对象的所有顶级属性</h1><p id="83dc" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">所有JavaScript都有以下函数来获取对象的所有顶级属性。</p><h2 id="56cf" class="ma mb it bd mr nm nn dn mv no np dp mz li nq nr nb lm ns nt nd lq nu nv nf nw bi translated">对象.键</h2><p id="cdfa" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated"><code class="fe mg mh mi lw b">Object.keys</code>获取一个对象的顶层键列表并返回一个数组。例如:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="efcd" class="ma mb it lw b gy mc md l me mf">const a = {foo: 1, bar: 2};<br/>const length = Object.keys(a).length // 2</span></pre><p id="920f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以调用keys数组上的<code class="fe mg mh mi lw b">find</code>来查找密钥，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="dd47" class="ma mb it lw b gy mc md l me mf">Object.keys(a).find(k =&gt; k == 'foo') // 'foo'</span></pre><h2 id="eee4" class="ma mb it bd mr nm nn dn mv no np dp mz li nq nr nb lm ns nt nd lq nu nv nf nw bi translated">Object.getPropertyNames</h2><p id="d404" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated"><code class="fe mg mh mi lw b">Object.getPropertyNames</code>还获取一个对象的所有顶级键的列表，并以数组的形式返回它们。例如:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2e08" class="ma mb it lw b gy mc md l me mf">const a = {foo: 1, bar: 2};<br/>const length = Object.getOwnPropertyNames(a).length // 2</span></pre><p id="859f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以调用keys数组上的<code class="fe mg mh mi lw b">find</code>来查找密钥，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="84bc" class="ma mb it lw b gy mc md l me mf">Object.getOwnPropertyNames(a).find(k =&gt; k == 'foo') // 'foo'</span></pre><h2 id="a5d0" class="ma mb it bd mr nm nn dn mv no np dp mz li nq nr nb lm ns nt nd lq nu nv nf nw bi translated">对于…在循环中</h2><p id="1012" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">还有一个特殊的循环，用于遍历对象的键。您可以执行以下操作:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="315b" class="ma mb it lw b gy mc md l me mf">const a = {foo: 1, bar: 2};<br/>let keysCount = 0;<br/>for (let key in a) {<br/>    keysCount++;<br/>}<br/>console.log(keysCount) // 2</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="5fd5" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">检查对象属性是否存在</h1><h2 id="7f3e" class="ma mb it bd mr nm nn dn mv no np dp mz li nq nr nb lm ns nt nd lq nu nv nf nw bi translated">hasOwnProperty</h2><p id="e7f0" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">您可以通过调用对象的<code class="fe mg mh mi lw b">hasOwnProperty</code>来检查对象是否有属性。例如:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3fec" class="ma mb it lw b gy mc md l me mf">const a = {foo: 1, bar: 2};<br/>a.hasOwnProperty(key); // true</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="eaf8" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">删除对象的属性</h1><p id="c038" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">JavaScript有一个<code class="fe mg mh mi lw b">delete</code>操作符来删除对象的属性。如果我们有:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7c5a" class="ma mb it lw b gy mc md l me mf">const bird = {<br/>  name: 'Joe',<br/>  numWings: 2,<br/>  numLegs: 2,<br/>  numHeads: 1,<br/>  fly(){},<br/>  chirp(){},<br/>  eat(){}<br/>}</span></pre><p id="717e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们运行<code class="fe mg mh mi lw b">delete bird.name</code>，那么<code class="fe mg mh mi lw b">bird.name</code>属性将被移除。当您记录它时，它将记录为<code class="fe mg mh mi lw b">undefined</code>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="018d" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">JavaScript继承</h1><p id="5aeb" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在JavaScript中，我们可以创建一些类，这些类的属性可以包含在子类的属性中。</p><p id="05e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以有一个包含所有子类共有的属性的高级类，并且子类可以有自己的特殊属性，这些属性不在任何其他类中。</p><p id="3d9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有一个具有公共属性和方法的<code class="fe mg mh mi lw b">Animal</code>类，比如<code class="fe mg mh mi lw b">name</code>和<code class="fe mg mh mi lw b">eat</code>方法，那么<code class="fe mg mh mi lw b">Bird</code>类可以继承<code class="fe mg mh mi lw b">Animal</code>类中的公共属性。它们不必在<code class="fe mg mh mi lw b">Bird</code>类中再次定义。</p><p id="c7b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用JavaScript编写以下代码来实现继承:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6af2" class="ma mb it lw b gy mc md l me mf">class Animal {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>  eat() {<br/>    console.log('eat');<br/>  }<br/>}</span><span id="a7e8" class="ma mb it lw b gy nx md l me mf">class Bird extends Animal {<br/>  constructor(name, numWings) {<br/>    super(name);<br/>    this.numWings = numWings;<br/>  }<br/>}</span><span id="6e39" class="ma mb it lw b gy nx md l me mf">const bird = new Bird('Joe', 2);<br/>console.log(bird.name)<br/>bird.eat();</span></pre><p id="333d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们有父类<code class="fe mg mh mi lw b">Animal</code>，它有<code class="fe mg mh mi lw b">eat</code>方法，来自<code class="fe mg mh mi lw b">Animal</code>的<code class="fe mg mh mi lw b">extends</code>的所有类都会有，所以它们不必再定义<code class="fe mg mh mi lw b">eat</code>。</p><p id="2ff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有扩展了<code class="fe mg mh mi lw b">Animal</code>类的<code class="fe mg mh mi lw b">Bird</code>类。注意，在<code class="fe mg mh mi lw b">Bird</code>类的<code class="fe mg mh mi lw b">constructor</code>中，我们有<code class="fe mg mh mi lw b">super()</code>函数调用来调用父类的构造函数，以填充父类的属性和子类的属性。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b431" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated"><code class="fe mg mh mi lw b">this</code>关键字</h1><p id="802c" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">关键字<code class="fe mg mh mi lw b">this</code>允许我们在一个对象中访问当前对象的属性，除非你使用了箭头函数。</p><p id="b8a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的例子中我们可以看到，我们可以在对象中获得子类和父类的实例的属性。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="1c0d" class="mq mb it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">复制对象</h1><p id="e7bb" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">复制对象意味着对与原始对象具有相同内容的对象进行新的对象引用。</p><p id="f0c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你把一个变量赋给另一个变量时，它经常被用来防止修改原始数据。因为如果你把一个变量赋给一个新的变量，这个新的变量和原来的对象有相同的引用。</p><p id="40f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用JavaScript克隆对象有几种方法。一些函数进行浅层复制，这意味着不是对象的所有级别都被复制，所以它们可能仍然保存对原始对象的引用。</p><p id="12f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">深层拷贝复制所有内容，这样就没有任何内容引用原始对象，消除了浅层拷贝带来的任何混乱。</p><p id="2aee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果将一个对象赋给另一个变量，它只是将引用赋给原始对象，所以两个变量都将指向原始对象。</p><p id="3e98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当其中一个变量被操作时，两个变量都将被更新。这并不总是想要的行为。为了避免这种情况，您需要将一个对象从一个变量复制到另一个变量。</p><h2 id="adfd" class="ma mb it bd mr nm nn dn mv no np dp mz li nq nr nb lm ns nt nd lq nu nv nf nw bi translated">浅拷贝</h2><p id="6571" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在JavaScript中，这很容易做到。要浅层复制一个对象，我们可以使用<code class="fe mg mh mi lw b">Objec.assign()</code>，它内置于最新版本的JavaScript中。</p><p id="05be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数执行浅层复制，这意味着它只复制一个对象的顶层，而更深层的对象仍然链接到原始对象引用。如果在原始对象中有嵌套对象，可能不希望出现这种情况。</p><p id="8592" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个如何使用<code class="fe mg mh mi lw b">Object.assign</code>的例子:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c9d7" class="ma mb it lw b gy mc md l me mf">const a = { foo: {bar: 1 }}<br/>const b = Object.assign({}, a) // get a clone of a which you can change with out modifying a itself</span></pre><p id="eb17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以像这样克隆一个阵列:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="811b" class="ma mb it lw b gy mc md l me mf">const a = [1,2,3]<br/>const b = Object.assign([], a) // get a clone of a which you can change with out modifying a itself</span></pre><h2 id="70c3" class="ma mb it bd mr nm nn dn mv no np dp mz li nq nr nb lm ns nt nd lq nu nv nf nw bi translated">深层拷贝</h2><p id="cbf1" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">要做一个没有库的对象的深层拷贝，你可以<code class="fe mg mh mi lw b">JSON.stringify</code>然后<code class="fe mg mh mi lw b">JSON.parse</code>:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bf53" class="ma mb it lw b gy mc md l me mf">const a = { foo: {bar: 1, {baz: 2}}<br/>const b = JSON.parse(JSON.strinfy(a)) // get a clone of a which you can change without modifying a itself</span></pre><p id="7329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是对对象的深层复制，这意味着对象的所有级别都被克隆，而不是引用原始对象。</p><p id="95d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">JSON.parse</code>和<code class="fe mg mh mi lw b">JSON.stringify</code>只处理普通对象，这意味着它们不能有函数和其他运行的代码。</p><p id="0d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以对浅层克隆对象使用对象析构，就像这样:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d859" class="ma mb it lw b gy mc md l me mf">const a = { foo: {bar: 1}}<br/>const b = {...a} // get a clone of a which you can change with out modifying a itself</span></pre><p id="51f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们知道如何创建对象，我们就可以轻松地存储和操作数据。我们可以通过使用对象和类创建程序来做一些不平凡的事情。</p></div></div>    
</body>
</html>