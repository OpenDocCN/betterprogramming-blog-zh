<html>
<head>
<title>How to Make Sense of Distributed Processing With Python Daemons</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何理解Python守护进程的分布式处理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-make-sense-of-distributed-processing-with-python-daemons-586ee12f7f4d?source=collection_archive---------3-----------------------#2020-01-28">https://betterprogramming.pub/how-to-make-sense-of-distributed-processing-with-python-daemons-586ee12f7f4d?source=collection_archive---------3-----------------------#2020-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="40de" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">虚拟化和扩展您的Python应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/00a386fcffbbc954f9a752ff92cf225a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJIku6eX_NbSCr0Tu7A6dw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@nesabymakers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> NESA制作</a>在<a class="ae ky" href="https://unsplash.com/s/photos/coder?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e3e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">术语“守护进程”是由麻省理工学院MAC项目的程序员创造的。它来自麦克斯韦的恶魔——一个来自思想实验的虚构存在，他不断地在后台工作，对分子进行分类。这导致Unix系统使用这个术语。</p><p id="335b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在UNIX中，守护进程是一个长期运行的后台进程，它可以执行几乎任何事情，从执行服务请求到执行Unix系统上日常活动的任何(通常是长期运行的)任意任务。与传统的应用程序不同，守护程序不在交互式用户的直接控制下运行。因为守护进程没有控制终端，所以它们在后台静默运行。术语守护进程起源于Unix，大多数操作系统都以某种形式使用守护进程。在Unix中，守护进程的名称通常以“d”结尾。一些例子包括<code class="fe lv lw lx ly b">inetd</code>、<code class="fe lv lw lx ly b">httpd</code>、<code class="fe lv lw lx ly b">nfsd</code>、<code class="fe lv lw lx ly b">sshd</code>、<code class="fe lv lw lx ly b">named</code>和<code class="fe lv lw lx ly b">lpd</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/b1769114f36d904d049a7c74d0756148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JBmoG4lJ7E236jg0q6n-HQ.png"/></div></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="68bf" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">将您的Python代码妖魔化的原因</h1><ul class=""><li id="c7fc" class="mz na it lb b lc nb lf nc li nd lm ne lq nf lu ng nh ni nj bi translated">运行一次性后台异步任务，而不使用臃肿的库，如<code class="fe lv lw lx ly b">celery</code>或异步框架。</li><li id="9725" class="mz na it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">拥有不属于主程序的长期代码执行</li><li id="5cba" class="mz na it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">引入分离的分布式计算，而不需要依赖于主应用程序生命周期的子流程。</li></ul></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="960e" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">守护进程特征</h1><p id="d5dd" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">让我们先了解一下定义，这样我们可以更好地理解守护进程创建的工作原理。UNIX系统或windows系统中的每个进程都有一个<strong class="lb iu"> PID ( </strong>进程标识号— windows有一个等效的标识号)。PID在创建时自动分配给每个进程。同样，每当我们在Unix系统中执行任何Python代码时，它都会为该程序创建一个特殊的环境及其相关的PID。让我们看看下面的一些例子:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="777e" class="nw mi it ly b gy nx ny l nz oa">$ ps -aux | less</span><span id="c964" class="nw mi it ly b gy ob ny l nz oa">$ top</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/81fed5ee7cfd0e6098a4348accbb9436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*im-Ydvy-FQR875KmRlIgCg.png"/></div></div></figure><p id="d893" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Windows中，您可以使用任务管理器查看正在运行的进程列表。选择Ctrl+Alt+Delete，然后选择<strong class="lb iu">任务管理器</strong>，打开任务管理器。在<strong class="lb iu">流程</strong>选项卡上，选择<strong class="lb iu">细节</strong>查看PID。尝试在Python终端中执行以下Python代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="5a3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到显示了一个PID，指示当前的Python会话。通过输入<code class="fe lv lw lx ly b">exit()</code>函数调用来关闭Python终端。再次运行代码，看看PID会发生什么。</p><p id="2485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个进程都有一个父进程(最初的内核级进程通常是它自己的父进程)。子进程终止时会通知父进程，父进程可以获得子进程的退出状态。</p><p id="9712" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了具有进程ID之外，每个进程属于一个<strong class="lb iu">进程组</strong>。</p><ul class=""><li id="769b" class="mz na it lb b lc ld lf lg li of lm og lq oh lu ng nh ni nj bi translated">进程组是一个或多个进程(通常与同一作业相关)的集合，这些进程可以从同一终端接收信号。</li><li id="4efc" class="mz na it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">每个流程组可以有一个<strong class="lb iu">流程组长</strong>，其流程组ID等于其流程ID。</li></ul><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="3684" class="nw mi it ly b gy nx ny l nz oa">ps -axj</span></pre><ul class=""><li id="bbeb" class="mz na it lb b lc ld lf lg li of lm og lq oh lu ng nh ni nj bi translated"><code class="fe lv lw lx ly b">-a</code>选项显示其他人拥有的进程的状态。</li><li id="b729" class="mz na it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><code class="fe lv lw lx ly b">-x</code>选项显示没有控制终端的进程。</li><li id="b6f1" class="mz na it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><code class="fe lv lw lx ly b">-j</code>选项显示作业相关信息:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/ba4c5e319cd33dd23fcde841e21cbee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oFqlXYEXHZFqIKyRP-8Q8w.png"/></div></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="1e4e" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">创建Python守护进程</h1><p id="5ffd" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">让我们看看在应用程序中执行守护进程的多种方式，以及Python中可以减轻将代码转换成守护进程负担的关键包。如果您使用的是Windows，您可以跟着做——下一节将介绍如何通过Windows计划任务服务阐明后台进程的概念。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="db91" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">先决条件</h1><p id="9f0e" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">您应该安装了Python &gt;3.6。如果你没有，你可以在这里为你的平台<a class="ae ky" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank">下载一份Python。</a></p><p id="09f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看如何手动创建一个守护进程，而不利用第三方库。唯一的先决条件是安装了<a class="ae ky" href="https://github.com/psf/requests" rel="noopener ugc nofollow" target="_blank">请求Python包</a>。</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="5d7a" class="nw mi it ly b gy nx ny l nz oa">$ mkdir daemons</span><span id="6b5e" class="nw mi it ly b gy ob ny l nz oa">$ cd daemons </span><span id="95fe" class="nw mi it ly b gy ob ny l nz oa">$ touch daemon_func.py</span><span id="56a3" class="nw mi it ly b gy ob ny l nz oa">$ pip install requests</span></pre><p id="d55f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个简单的python函数。一个虚构的新闻聚合器，它根据美国的头条新闻提取最新的头条新闻，并每隔几秒钟将它们写入一个文件。生成的文件格式如下:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="ba3f" class="nw mi it ly b gy nx ny l nz oa">pid_{pid}_my_daemon_log_{timeref}.txt</span></pre><p id="8a17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数将是说明我们如何创建Python守护进程的基础。确保您生成自己的API密钥。要获得您自己的API密钥，请在<a class="ae ky" href="https://newsapi.org" rel="noopener ugc nofollow" target="_blank">https://newsapi.org</a>上创建一个免费帐户，并将您的密钥添加到下面的代码片段中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="5fba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，为了方便和代码隔离，所有的import语句都包含在main函数中。执行上面的函数，确保一切正常。</p><p id="65e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建负责命名我们的<code class="fe lv lw lx ly b">main()</code>函数的主函数</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="f69f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Unix上派生一个守护进程需要特定的系统调用序列。</p><p id="17d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，守护进程必须从它们的控制终端和进程组中分离出来。这是通过一个叫做分叉的过程实现的。当我们用叉子叉东西的时候，它自身的副本就被创造出来了。在Unix中，我们需要两次<code class="fe lv lw lx ly b">fork</code>，从而终止每个父进程，只让原始进程的孙进程运行守护进程的代码。</p><p id="3fd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，这是通过调用<code class="fe lv lw lx ly b">os.fork()</code>函数来完成的。这允许我们将守护进程从调用终端中分离出来，这样即使在调用终端关闭之后，守护进程也可以继续运行(通常，作为一个服务器进程，不需要进一步的用户交互，例如web服务器)。在二次分叉之后添加的任何代码都将作为守护进程在后台执行。执行我们的代码会产生下面的输出。注意从父进程到分离进程的PID号:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="cc6f" class="nw mi it ly b gy nx ny l nz oa">This is the parent PID 39813<br/>Detaching from parent environment<br/>Detached Daemon PID 39815<br/>executing daemon background......</span></pre><p id="38ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<strong class="lb iu"> </strong>到<strong class="lb iu"> </strong> <code class="fe lv lw lx ly b">os.setsid()</code>创建一个新的会话。该进程成为新会话和新进程组的领导者，并与其控制终端分离。</p><p id="ac11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对<code class="fe lv lw lx ly b">os.chdir(“/”)</code> <strong class="lb iu">的调用将当前工作目录更改为根目录。</strong>从父目录继承的当前工作目录可能在一个挂载的文件系统上。由于守护程序通常在系统重新启动之前一直存在，因此如果守护程序驻留在已装载的文件系统上，则无法卸载该文件系统。</p><p id="703f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要杀死你的守护进程，打开你的终端，输入命令<code class="fe lv lw lx ly b">kill -9 {PID}</code></p><p id="1640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在mac上，你可以输入[CMD]+ [space]，搜索monitor，然后手动找到PID并强制退出该过程。如果您运行多种类型的程序，请确保终止所有运行您的守护程序代码的Python进程。</p><p id="84b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oj">有一点我想提醒你。使用Python多处理模块创建子进程并将process设置为</em> <code class="fe lv lw lx ly b"><em class="oj">daemon=True</em></code> <em class="oj">不会创建Unix分离的守护进程，如下面的示例代码所示。他们有不同的特点。此外，守护程序不是服务。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">守护程序多重处理模块</p></figure><p id="85ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当守护进程属性标志设置为<code class="fe lv lw lx ly b">true</code>时，Python多处理模块守护进程标志在后台执行一个进程。关键的区别是只要主进程在执行，守护进程<strong class="lb iu">就会继续运行。</strong>执行完毕或主程序被杀死后<strong class="lb iu">终止。很容易认为使用这个属性可以达到同样的效果。</strong></p><p id="8206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的初始代码，使用双分叉魔法，看起来足够简单，可以与您自己的Python项目集成，但是对于受过训练的人来说，它缺少了很多。</p><p id="493e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们没有适当的PID状态管理。出现异常时，无法停止或重启守护进程。没有办法知道后台守护进程的状态。没有办法知道有多少恶魔已经被调用并正在执行。无法改变只能调用一次守护进程的事实。基于<a class="ae ky" href="https://www.python.org/dev/peps/pep-3143/#correct-daemon-behaviour" rel="noopener ugc nofollow" target="_blank"> pep-3143规范</a>，当将一个程序转换成一个行为良好的Unix守护进程时，应该执行某些条件和行为。</p><p id="303f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看两个库，它们将使您的Python应用程序的后台化变得容易。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="6346" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">#1.PEP 3143标准守护进程库</h1><p id="9649" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">要开始使用标准守护进程库，您需要做的就是执行<code class="fe lv lw lx ly b">pip install</code>:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="b10c" class="nw mi it ly b gy nx ny l nz oa">$ python-daemon==2.2.4</span></pre><p id="00ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个名为<code class="fe lv lw lx ly b">daemon_cxt.py</code>的新文件。使用<code class="fe lv lw lx ly b">lib</code>所需的最少代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="d2ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">DaemonContext</code>实例代表程序的行为设置和进程上下文，当它成为一个守护进程时，它们是更多可以传递给上下文的参数。为了保持这篇文章的简单，我们不会对它们进行过多的描述。让我们回到最初的例子，用最初的<code class="fe lv lw lx ly b">newsapi</code>主函数包装它。</p><p id="b9fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将下面的代码添加到您的<code class="fe lv lw lx ly b">daemon_func.py</code>文件中</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">功能去妖魔化</p></figure><p id="8c0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个启动守护进程的新函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">启动守护程序脚本</p></figure><p id="5d09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们创建一个Python主函数，这样我们就可以调用守护进程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">守护程序主函数</p></figure><p id="b794" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试通过输入Python命令来运行该程序:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="cfc5" class="nw mi it ly b gy nx ny l nz oa">python daemon_func.py</span></pre><p id="c206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在发生了什么？就像我们的第一个例子一样，每十秒钟就会生成N个文件。记下PID——您可以用它来终止正在运行的进程。如果您想自动化这个杀死过程，您可以使用下面的代码以编程方式执行一个简单的进程杀死。您可以使用条件语句或开关来决定是使用<code class="fe lv lw lx ly b">start</code>还是<code class="fe lv lw lx ly b">kill</code>守护进程，从而将它作为参数检查的一部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="89d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想要生成多个守护进程，以便拥有某种形式的分布式并行性，那该怎么办呢？关键是要确保为每个衍生的守护进程创建一个唯一的PID文件。本质上，您可以扩大守护进程的总数，并利用您的服务器或计算机可能利用的CPU和内核的总数。</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="567e" class="nw mi it ly b gy nx ny l nz oa">&gt;&gt;&gt; import psutil<br/>&gt;&gt;&gt; psutil.cpu_count()<br/>8<br/>&gt;&gt;&gt; psutil.cpu_count(logical=False)<br/>4<br/>&gt;&gt;&gt;</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="4202" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">#2.瞌睡精灵</h1><p id="3188" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><strong class="lb iu">警告</strong>:该库仍处于维护模式。已经有一段时间了，所以在生产环境中使用它之前，我建议通读一遍代码。对于任何希望在开发者放弃的地方继续开发工作的人来说，这也足够简单。这可以作为构建您自己的Python守护进程包装器的起点。该库使用两次分叉的相同基本概念。</p><div class="ok ol gp gr om on"><a href="https://github.com/kevinconway/daemons/blob/master/daemons/daemonize/simple.py" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">kevinconway/守护程序</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">github.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div><p id="ff72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要安装sleepy daemon，您可以通过直接从git repo调用<code class="fe lv lw lx ly b">pip install</code>来确保您总是获得最新的代码:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="404f" class="nw mi it ly b gy nx ny l nz oa">$ pip install git+<a class="ae ky" href="https://github.com/kevinconway/daemons" rel="noopener ugc nofollow" target="_blank">https://github.com/kevinconway/daemons</a></span></pre><p id="8b77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个新的Python文件，并在下面添加sleepy daemon代码:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="c967" class="nw mi it ly b gy nx ny l nz oa">$ touch daemon_sleepy.py</span></pre><p id="ba24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们在这个例子中使用了<code class="fe lv lw lx ly b">sys.argv</code>，所以我们可以在脚本中传递<code class="fe lv lw lx ly b">start</code>、<code class="fe lv lw lx ly b">stop</code>和<code class="fe lv lw lx ly b">restart</code>作为参数。或者，我们也可以重写代码，以便以编程方式执行守护程序脚本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">休眠守护进程示例执行</p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="b107" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">Windows守护程序</h1><p id="3ed2" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我没有忘记Windows的人。在windows中，情况有所不同。为了复制Unix风格的创建后台任务和终止正在运行的进程的能力，我们需要利用Windows服务感谢，有一个我们可以利用的Python包，即用于Microsoft Windows的Python扩展。此库提供对大多数Win32 API函数的访问，并提供创建windows计划任务的能力。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="a8a5" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">监督者</h1><p id="3e8c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">利用<code class="fe lv lw lx ly b">Supervisor</code>作为编程妖魔化python函数的替代方法。Supervisor是一个客户机/服务器系统，它允许用户在类似UNIX的操作系统上监视和控制许多进程。它与<code class="fe lv lw lx ly b"><a class="ae ky" href="http://supervisord.org/glossary.html#term-launchd" rel="noopener ugc nofollow" target="_blank">launchd</a></code>、<code class="fe lv lw lx ly b"><a class="ae ky" href="http://supervisord.org/glossary.html#term-daemontools" rel="noopener ugc nofollow" target="_blank">daemontools</a></code>和<code class="fe lv lw lx ly b"><a class="ae ky" href="http://supervisord.org/glossary.html#term-runit" rel="noopener ugc nofollow" target="_blank">runit</a></code>等项目有一些相同的目标。</p><p id="a9d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Supervisor</code>旨在用于控制与应用程序相关的进程，并像任何其他程序一样在引导时启动。关于<code class="fe lv lw lx ly b">Supervisor</code>的一个很酷的事情是它带有一个简单的内置网络界面来帮助你管理流程。打算在监督下运行的程序不应该使自己变得不可靠。相反，它们应该在前台运行。它们不应该从启动它们的终端脱离。</p><p id="ea2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要离题太远，不要把这篇文章变成一个长达一小时的教程，请继续关注第二部分，在那里我将讨论Windows守护进程。我将深入探讨如何从我们的Python代码中以编程方式调用Windows服务，以实现与Unix系统上Python函数的后台化相同的结果，利用CPU和内核实现并行性。我们还将探索<code class="fe lv lw lx ly b">Supervisor</code>，看看它是如何工作的。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="b935" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="8dec" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们已经看到了如何用python编写自定义守护进程，以及如何以编程方式执行它们。我们已经看到了在UNIX和windows上有哪些包可以用来对Python代码进行后台化。我们已经看到了如何利用<code class="fe lv lw lx ly b">supervisor</code>作为替代手段来守护您的Python应用程序。有了这些知识，你可以设计出这样的东西:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有回调处理程序的守护程序函数</p></figure><p id="d6d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您有一些长期运行的数据科学或CPU密集型计算，您希望在后台运行—您可以设计您的代码来接受回调函数，并专注于编写自定义代码来处理守护程序结果。Daemonization逻辑将在您的库中抽象出来，让开发人员专注于他们最擅长的事情——编写代码。</p><p id="bc5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这份材料对你有所帮助，并消除你可能有的任何疑问。</p><blockquote class="pc pd pe"><p id="c248" class="kz la oj lb b lc ld ju le lf lg jx lh pf lj lk ll pg ln lo lp ph lr ls lt lu im bi translated"><strong class="lb iu">更新于2020年6月2日，第二部分如下</strong></p></blockquote><div class="ok ol gp gr om on"><a href="https://medium.com/better-programming/how-to-make-sense-of-distributed-processing-with-python-windows-services-9cfafc6fed2b" rel="noopener follow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">如何理解Python Windows服务的分布式处理</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">虚拟化和扩展您的Python应用</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">medium.com</p></div></div><div class="ow l"><div class="pi l oy oz pa ow pb ks on"/></div></div></a></div></div></div>    
</body>
</html>