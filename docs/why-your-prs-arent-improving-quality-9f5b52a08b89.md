# 为什么你的公关没有提高质量

> 原文：<https://betterprogramming.pub/why-your-prs-arent-improving-quality-9f5b52a08b89>

## 很简单:你错过了森林，错过了树

![](img/32e8aa2c2a323cb4269ed8426603e0f0.png)

[通过 Pixabay](https://pixabay.com/photos/field-trees-fall-autumn-mood-5932123/)

Git 在软件工程世界中的无处不在意味着围绕它的工具和过程已经或多或少地结合成了一些关于开发人员工作流和软件发布模式的模式。

其中包括:

*   [Git 流程](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow)
*   [GitHub 流量](https://docs.github.com/en/get-started/quickstart/github-flow)
*   [GitLab 流程](https://docs.gitlab.com/ee/topics/gitlab_flow.html)

其中每一个的核心是拉请求或 PR，许多团队试图在这一层加强代码和产品的质量。

你猜怎么着？*很少管用*。

# **修复已经损坏的东西**

显而易见，如果没有更多的严格性和纪律性，这种方法很难奏效:*在 PR 点，代码已经写好了*，所有参与者都受制于沉没成本谬误。

换句话说，在 PR 点上，团队领导或同事不太可能指出某个方法是次优的，或者应该被废弃，或者要求重大变更。不仅仅是因为沉没成本谬论，公关审查本身也可能是审查者的一个大的上下文切换。

相反，大多数 pr 最终会关注:

*   明显、孤立的逻辑错误
*   糟糕的实践和风格(但是 lint 规则可以用于此)
*   不安全的实践(同样可以使用 lint 规则、静态分析工具或类似于 [CodeQL](https://codeql.github.com/) 的工具)
*   当评审者知道这样的逻辑可能存在于系统的其他地方时，就违反了 DRY(最好通过设计评审在过程的早期解决)
*   或者——最糟糕的——只是例行公事。

这样的练习最终感觉像是一件苦差事，并且很少导致代码类型或产品质量的改进，从而在更低的缺陷率、迭代速度、更好的架构和增加的开发人员生产力方面产生影响。

通常情况下，这种练习似乎是一种仪式，见树不见林。

如果这种感觉太熟悉了，请继续读下去！

# PRs 不是代码审查

经常有一个错误的等同物，PRs 就是代码评审。事实上，您在 PR 的上下文中评审代码，PR 是 ***而不是*** 代码评审。

对于初学者来说，在更大的应用程序流程和产品、特性或业务需求的更深层次的审查之外审查代码的变更通常是没有用的。换句话说，决定如何编写代码需要了解编写代码的业务或产品环境。

但是，即使在非常基础的层面上，如果不了解周围代码的更大上下文以及数据如何流过该代码，通常也不可能了解孤立的一行 diff 是否正确、是否遗漏了边缘情况或者是否需要更多测试情况。

我认为，用更小的 PRs、PR 模板、更频繁的 PRs、草案 PRs 等等来使 PR 对评审者来说变得更容易，不会对产品和代码质量产生有意义的影响。

原因很简单:代码是密集的，许多特性和错误修复是复杂的，因此需要对逻辑流和业务需求有深刻的理解，并且对于在其他子系统——甚至是同一个子系统——上工作的同事来说，知道你的代码是否*正确、完整*和*高质量*是不可能的。

# 问题的症结

在这里，我们得到了问题的真正核心:*我们到底如何确定代码和产品质量*？

要回答这个问题，考虑一下几乎所有其他行业如何实现质量是有益的，而且几乎普遍使用两种杠杆:

*   规范
*   测试

就像问这样一个问题一样简单:输出是否符合指定的产品设计？无论是食品生产线、机器装配线、制药、建筑、缝制婚纱的女裁缝，还是软件工程，很明显只有通过规范和测试才能实现有意义的质量。

这是一个硬币的两面。没有规范，测试就没有意义。没有测试，就无法验证规格。规格决定了测试策略，测试验证了规格已经被正确实现。

> 在敏捷时代，没有人想听到这些，但是许多代码和产品质量问题的根源来自一个破碎的(或者不存在的)产品规范过程

同样，没有规范的代码审查是空洞的练习，因为如果没有设计和开发实现的业务环境(如果它是设计出来的话),几乎不可能确定实现的正确性或适用性。).如果没有规范，代码评审会关注错误的事情。

# 有意义地提高代码和产品质量

那么*我们怎样才能*有意义地提高代码和产品质量呢？我们如何进行更有意义的代码审查，而不是仅仅走过场的 PRs？

## 修正规范流程

在敏捷时代，没有人想听到这些，但是许多代码和产品质量问题的根源来自一个破碎的(或者不存在的)产品规范过程。通常，这是由于懒惰或缺乏经验的产品团队缺乏充分探索和记录特性或产品的严谨性。

这通常表现为“我们是敏捷的，所以让我们建立一个原型，我们将审查它并迭代”。通常情况下，沉没成本谬论再次出现，原型变成了出货产品。

没有足够的规格，决定最合适的架构或定义测试程序是不可能的任务，因为“边缘案例”将比比皆是。如果没有一个强有力的规范作为起点，通常就不可能确定正确的设计模式来解决手头的问题，因为问题的范围还没有完全展现给实现团队。

就我个人而言，我是 Basecamp 的 Shape Up 模型的支持者。我用过。我知道这有用。

[](https://basecamp.com/shapeup) [## 顺利发展

### 改进是为努力出货的产品开发团队准备的。如果你对自己说“为什么我们不能像…

basecamp.com](https://basecamp.com/shapeup) 

这种模型要求组织内的产品职能部门预先接受更多的责任和严格性，以完全封装工作的参数，以便工程团队可以在完整的上下文中工作。相反，它还要求工程部门仔细审查规范，并确定可行性、权衡和时间表。

拥有规范可以使代码评审更有意义，因为代码评审的目标不是在没有上下文的情况下评审代码，而是确定*实现是否满足规范*。

## 要求并审查技术设计

软件工程学科似乎可以通过了解其他行业如何管理输出质量的问题来学到很多东西，而不是在代码编写和删减后再进行审查:*审查设计*。

想象一下，在没有蓝图的情况下建造一栋房子或摩天大楼。想象一下，如果没有每个部件的 CAD 模型，造一辆特斯拉。想象一下，建造一个 SpaceX 火箭，而没有严格的设计和每个部件的规格，必须承受难以置信的力量。这似乎是不可能的。甚至园艺师会在开始挖掘和种植之前提供设计图纸进行迭代和审查。这并不是说迭代就此停止，而是说在过程的早期*迭代比在过程的后期*迭代要便宜得多。

然而，团队经常将软件视为一种假设，我们根本不关心技术设计和架构。仿佛这是为了改变迭代速度和“敏捷”的福音而做出的牺牲。

软件工程学科中的敏捷经常应用于代码*，但很少应用于设计*。在花时间修正不一致的、行为不端的代码之前，*迭代设计*不是更便宜吗？

当然，设计的严格性是特定于领域的。Fast Company 有一篇很棒的文章 [***他们写了正确的东西***](https://www.fastcompany.com/28121/they-write-right-stuff) 关于 NASA 内部的软件工程:

> 但是这个软件做了多少工作并不是它引人注目的原因。软件的出色之处在于它的工作效率。这个软件从来不死机。它永远不需要重新启动。这个软件没有错误。它是完美的，就像人类已经达到的那样完美。

当代码是一代人一次的任务的一部分时，这样的系统必须努力接近完美。

对于大多数团队来说，这显然是 ***方式*** 过于严谨，但这并不意味着“没有设计”。相反，每个团队应该思考的问题是如何使过程更有效地消除产品和技术设计的风险。

[**谷歌的设计冲刺**](https://www.gv.com/sprint/) 是一个很好的例子，展示了如何在过程早期与利益相关者一起整合快速、迭代的设计和发现，以降低过程后期的风险和成本。

一个 90 秒的介绍，一个强大的技术，以消除您的产品开发过程中的风险。

## 写出更好的代码

讽刺的是，提高代码质量的答案几乎肯定是“ ***写出更好的代码*** ”。最好的方法不是 PRs，也不是代码评审，因为*那时代码已经写好了*(这是关于代码评审和代码质量的基本逻辑缺陷)，团队会犹豫说“让我们将它重构为更干净的代码和更好的设计”(永远不会发生)，因为在那时，发布的压力太大了。其实那段代码永远不会被重写(每个产品都有那堆没人敢碰的代码)。

这不是一件容易的事，需要在招聘过程和团队结构上更加努力。这意味着核心框架位和 API 应该由更有经验的一小群人来处理，而不是免费的分工。弗雷德·布鲁克斯在他开创性的散文集《人月神话》中为此创造了一个术语:“概念完整性”。

公平地说，没有一个团队*在第一次切割时就做对了；这不是重点。关键是要以这样一种方式构建系统，其核心对于不断变化的业务需求是柔韧的和可延展的。[马丁·福勒写的“你不会需要它”或 YAGNI 似乎很合适](https://martinfowler.com/bliki/Yagni.html):*

> **Yagni 仅适用于内置于软件中支持假定功能的能力，不适用于使软件更容易修改的努力。只有在代码易于更改的情况下，yagni 才是一个可行的策略，所以在重构上花费精力并不违反 Yagni，因为重构使代码更具可塑性。**

换句话说，好的代码通常具有容易适应变化的需求的品质；*与意大利面代码*完全相反。

## 更加面向团队的开发

开发人员在一个团队中一起处理一个 bug 修复或一个特性，将会更好地掌握系统领域中业务需求和代码流的更大的上下文，因此，与引入一个对一段代码所解决的特定业务问题没有上下文理解的评审者相比，他们能够更好地为彼此提供更有意义的反馈。

将开发工作组织成小团队是一种自动将更多的目光放在每个工作单元上的方式，并且确保有多个个人理解正在实现的特性的更大的上下文。

事实上， [**这正是谷歌规定的**](https://cloud.google.com/architecture/devops/devops-tech-trunk-based-development) :

> 如果你的团队练习结对编程，那么代码已经被第二个人评审过了。

## 交互式代码评审

与其孤立地看待差异，不如进行交互式的代码评审，提交者在产品或特性的大环境中浏览代码，并讨论所做的权衡，这样可以从评审者那里得到更有意义的反馈。

由于代码在一个更大的系统或状态机的流程中进行交互，所以当查看一个差异甚至整个变更集时，决策过程中的细微差别通常是不可见的。

让一个开发人员或团队走一遍他们的技术设计决策和他们在实现过程中考虑到的挑战，可能比仅仅审查一个 PR 更有成效。PR 不是代码评审，而是更全面的代码评审过程的中心部分。

同样，谷歌的解决方案是务实的:

> 转向同步代码审查，或者至少确保开发人员优先考虑代码审查，有助于确保变更不必等待几个小时，甚至几天，就可以合并到主干中。

## 关注代码评审中的测试

除了查看实现的细节之外，审查测试策略以验证它提供了对*需求*的充分覆盖，而不是对*代码*的覆盖，这可能更重要。

再多的代码评审也不会考虑边缘情况，因为根据它们的性质，*这些是不在规范中的情况。*类似地，评估测试——无论是自动化单元测试还是自动化端到端测试——在代码评审中是否足够，需要有足够详细的功能规范来确定测试覆盖范围。

代码审查应该集中在开发人员是否已经设计并实现了适当的测试用例来说明规范。CI/CD 应该关注于确保那些测试用例被执行和通过。但是当然，这需要首先存在这样的规格说明，从那里确定这样的测试用例的*功能覆盖*(不仅仅是统计覆盖)。

最终，PR 是一个可以用来提高代码和产品质量的工具。如果它是一个团队唯一的工具，那么很容易理解为什么团队继续努力快速发布高质量、低缺陷的软件。

构建高质量的软件最终仍然需要纪律(经验会有所帮助！)从头到尾构建一个专注于明确定义规范的过程。因为只有从规范中的 ***才能得出“正确”的定义。***