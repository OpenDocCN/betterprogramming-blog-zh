<html>
<head>
<title>ExpressionChangedAfterItHasBeenCheckedError in Angular — What, Why and How To Fix It?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular中的expressionchangedafterithasbeencheckedererror—什么、为什么以及如何修复？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/expressionchangedafterithasbeencheckederror-in-angular-what-why-and-how-to-fix-it-c6bdc0b22787?source=collection_archive---------0-----------------------#2018-11-08">https://betterprogramming.pub/expressionchangedafterithasbeencheckederror-in-angular-what-why-and-how-to-fix-it-c6bdc0b22787?source=collection_archive---------0-----------------------#2018-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/349ac973036c7686095899dbd2344987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GmMtKznzJ1dS8sSzxzR3ow.png"/></div></div></figure><p id="0bcb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">ExpressionChangedAfterItHasBeenCheckedError</code> <strong class="kd iu"> </strong>毫无疑问是我在<a class="ae ld" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank">角度</a>应用中最喜欢的错误。</p><p id="4f7b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我第一次开始使用Angular时，我经常遇到这个错误。<a class="ae ld" href="https://github.com/angular/angular/issues/17572" rel="noopener ugc nofollow" target="_blank">根据GitHub </a>的说法，很多其他人也是如此。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="20a3" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">什么时候会抛出ExpressionChangedAfterItHasBeenCheckedError？</h1><p id="9e13" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">最常见的原因是:</p><ol class=""><li id="fdfa" class="mo mp it kd b ke kf ki kj km mq kq mr ku ms ky mt mu mv mw bi translated">您正在执行<code class="fe kz la lb lc b">AfterViewInit</code> <strong class="kd iu"> </strong>中的代码，这在使用<code class="fe kz la lb lc b">ViewChild</code> <strong class="kd iu">、</strong>时经常发生，因为它在<code class="fe kz la lb lc b">AfterViewInit</code> <em class="mx"> </em>被调用之前是未定义的。</li><li id="f1d7" class="mo mp it kd b ke my ki mz km na kq nb ku nc ky mt mu mv mw bi translated">您正在直接操作DOM(例如，使用<a class="ae ld" href="https://jquery.com/" rel="noopener ugc nofollow" target="_blank"> jQuery </a>)。Angular并不总能检测到这些变化并做出适当的反应。</li><li id="a449" class="mo mp it kd b ke my ki mz km na kq nb ku nc ky mt mu mv mw bi translated">当您在HTML模板中调用函数时，由于竞争条件<strong class="kd iu"> </strong>也会发生这种情况。</li></ol></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="a04c" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">ExpressionChangedAfterItHasBeenCheckedError试图警告我什么？</h1><p id="4985" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">在Angular检查后，当你的HTML中的一个表达式改变时，抛出<code class="fe kz la lb lc b">ExpressionChangedAfterItHasBeenCheckedError</code>(这是一个非常有表现力的错误)。</p><p id="8c1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此错误仅在开发模式下抛出，且有充分的理由；这通常是一个信号，表明你应该重构你的代码，因为Angular警告你，当<a class="ae ld" href="https://angular.io/api/core/enableProdMode" rel="noopener ugc nofollow" target="_blank">启用生产模式</a>时，你表达式中的这种变化将不会被察觉！</p><p id="d4ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">生产模式比开发模式更快的原因之一是Angular跳过了一些检查(例如<code class="fe kz la lb lc b">AfterViewInit</code><em class="mx"/>之后的变更检测)，即<em class="mx"> </em>在开发模式下完成。这意味着在开发模式下运行良好的代码在生产模式下将无法运行。</p><p id="adf0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是一个在开发模式下运行良好，但在生产模式下运行不佳的示例:</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7485" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一个例子:通过<code class="fe kz la lb lc b">EventEmitter</code>改变<code class="fe kz la lb lc b">ngOnInit</code>中的<code class="fe kz la lb lc b">@Input</code>属性也会导致<code class="fe kz la lb lc b">ExpressionChangedAfterItHasBeenCheckedError</code>。</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="cf85" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">如何修复expressionchangedafterithasbeencheckedererror</h1><h2 id="dd12" class="nj lm it bd ln nk nl dn lr nm nn dp lv km no np lz kq nq nr md ku ns nt mh nu bi translated">解决方案一:让Angular知道如何选择更改</h2><p id="2e4f" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">作为一种快速解决方法，经常使用<code class="fe kz la lb lc b"><a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" rel="noopener ugc nofollow" target="_blank">setTimeout</a></code> <strong class="kd iu"> </strong>或<code class="fe kz la lb lc b"><a class="ae ld" href="https://angular.io/api/core/ChangeDetectorRef" rel="noopener ugc nofollow" target="_blank">ChangeDetectorRef</a></code> <strong class="kd iu"> </strong>来使错误消失。</p><p id="a195" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">后者更好，因为用<code class="fe kz la lb lc b">ChangeDetectorRef</code>组件视图及其子视图被检查。另一方面，<code class="fe kz la lb lc b">setTimeout</code> <em class="mx"> </em>将导致Angular检查整个应用程序的更改，这种方式开销更大。</p><h2 id="86d7" class="nj lm it bd ln nk nl dn lr nm nn dp lv km no np lz kq nq nr md ku ns nt mh nu bi translated">修复二:将代码从ngAfterViewInit中移走</h2><p id="f724" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">有时候，错误甚至更容易修复——只需将您的代码移到<code class="fe kz la lb lc b"><a class="ae ld" href="https://angular.io/api/core/OnInit" rel="noopener ugc nofollow" target="_blank">OnInit</a></code> <em class="mx">。</em></p><p id="bfed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除非你不得不依赖<code class="fe kz la lb lc b">ViewChild</code> <em class="mx">、</em>或者如果一些代码应该只在Angular完全初始化一个组件的视图后运行，那么转移到<code class="fe kz la lb lc b">OnInit</code> <em class="mx"> </em>将会解决你的问题。</p><p id="9955" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是因为Angular在生产和开发模式下都会在<code class="fe kz la lb lc b">OnInit</code> <em class="mx"> </em>之后执行变更检测。</p><h2 id="3128" class="nj lm it bd ln nk nl dn lr nm nn dp lv km no np lz kq nq nr md ku ns nt mh nu bi translated">修复三:使用OnPush变更检测</h2><p id="8822" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">不喜欢角魔术和它如何检测变化？只需禁用组件中的自动变化检测，并告诉Angular自己何时应该检测变化。</p><p id="790a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b"><a class="ae ld" href="https://angular.io/api/core/ChangeDetectionStrategy" rel="noopener ugc nofollow" target="_blank">ChangeDetectionStrategy</a></code>可以在组件装饰器中指定给<code class="fe kz la lb lc b">OnPush</code>。现在，Angular只会自动检测<code class="fe kz la lb lc b"><a class="ae ld" href="https://angular.io/api/core/Input" rel="noopener ugc nofollow" target="_blank">Input</a></code> <strong class="kd iu"> </strong>的变化，剩下的就看你的了。</p><p id="d37d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然启用<code class="fe kz la lb lc b">OnPush</code> <em class="mx"> </em>策略所涉及的魔法更少，但您也可以获得更好的性能，因为Angular要做的工作更少。这对于优化大型复杂组件非常有用。</p><p id="d4c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一方面，你需要确保让Angular获得变化。最好的方法是使用<code class="fe kz la lb lc b"><a class="ae ld" href="https://angular.io/api/core/ChangeDetectorRef#markForCheck" rel="noopener ugc nofollow" target="_blank">markForCheck</a></code>。如果你没有让Angular意识到这些变化，你通常会看到UI错误或不一致(例如，一个模态没有消失)，除非Angular做另一个变化检测。</p><p id="02a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，不要在没有彻底检查你的组件之前就急于应用它。</p><h2 id="e838" class="nj lm it bd ln nk nl dn lr nm nn dp lv km no np lz kq nq nr md ku ns nt mh nu bi translated">修复四:避免@Input属性的突变</h2><p id="2a4c" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated"><code class="fe kz la lb lc b">@Input</code>理想情况下，组件本身的属性不应被修改。通过将<code class="fe kz la lb lc b">@Input</code>属性的更新留给父组件，可以避免意外的行为和副作用。除了直接更新<code class="fe kz la lb lc b">@Input</code>属性，您还可以将更新的发送给父组件，父组件将更新子组件中的<code class="fe kz la lb lc b">@Input</code>属性。</p><p id="fd58" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">顺便说一下:如果你不能避免它，那么你可以利用<a class="ae ld" href="https://angular.io/api/core/EventEmitter#constructor" rel="noopener ugc nofollow" target="_blank"> EventEmitter </a>的<code class="fe kz la lb lc b">isAsync</code>参数来自动触发变化检测(它在内部调用<code class="fe kz la lb lc b">setTimeout</code>)。</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="863d" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="a440" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">你现在应该能够理解臭名昭著的<code class="fe kz la lb lc b">ExpressionChangedAfterItHasBeenCheckedError</code> <em class="mx"> </em>发生的时间和原因了。</p><p id="fcb7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，有多种方法可以处理这个错误。只要确保你确实在解决真正的潜在问题，而不是绕过它。如果你知道如何处理这个错误的其他方法，我会很感兴趣。</p><p id="98a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更新2021: <a class="ae ld" href="https://angular.io/errors" rel="noopener ugc nofollow" target="_blank">角度文档现在包含一个常见错误列表，包括这个错误。对于一些错误，如果你更愿意从视频中学习而不是阅读，甚至还有视频。</a></p></div></div>    
</body>
</html>