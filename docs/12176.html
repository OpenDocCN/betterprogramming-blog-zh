<html>
<head>
<title>Sharing React Components With Webpack 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与Webpack 5共享React组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sharing-react-components-with-webpack-5-84c5496f3c64?source=collection_archive---------7-----------------------#2022-05-17">https://betterprogramming.pub/sharing-react-components-with-webpack-5-84c5496f3c64?source=collection_archive---------7-----------------------#2022-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="afcb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于使用Webpack 5在应用程序之间共享React组件的完整指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1a22525818d7fa116a0527977f7d4f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TmyDUPTBxtbJdV0_P8JCwQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用Webpack 5在应用程序之间共享组件很容易(图片由作者提供)</p></figure><h1 id="1a80" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="b026" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">一些文章和视频试图解释如何与Webpack 5共享组件，但以我的浅见，它们犯了一些严重的错误:它们很难理解，使用了困难的术语，并且以非常抽象的方式描述了解决方案。</p><p id="dfea" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">所以你不理解它，不能在你的应用程序之间轻松地共享组件！</p><p id="7a96" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">所以，让我们享受一下Webpack 5的模块联合带来的乐趣。像往常一样，我们将非常详细地描述事情的来龙去脉。而且很可能会有一些漂亮的截图。</p><p id="d0db" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><em class="mr">注意:下面的代码片段来自我专门为本文编写的两个小型React应用程序。你可以在GitLab上找到代码:</em></p><p id="1f63" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><a class="ae ms" href="https://gitlab.com/gvanderput/gerard-bicycle-shop/" rel="noopener ugc nofollow" target="_blank">杰拉德的自行车店</a>和<a class="ae ms" href="https://gitlab.com/gvanderput/gerard-bicycle-blog" rel="noopener ugc nofollow" target="_blank">杰拉德的博客</a>。</p><p id="b671" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">让我们继续前进！</p><h1 id="aa17" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">目标</h1><p id="b2ed" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们用React创建了一个小商店，它使用Webpack 5作为捆绑器。我们也有一个用React创建的小博客。</p><p id="3dc6" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">是的，你猜对了:它也使用Webpack 5作为捆绑器。</p><p id="c9be" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在商店内部，我们有一个React组件来呈现最新的报价。但是我们也想在博客里面渲染它！这将是我们的目标。我们想共享组件。</p><p id="94cc" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">首先，我们将仔细看看这两个应用程序。</p><h2 id="885b" class="mt kz it bd la mu mv dn le mw mx dp li lz my mz lk md na nb lm mh nc nd lo ne bi translated">商店</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/1eb75c69a494df84aac27e1433053ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*5Jlhywyfb6UJSFfFioV0iQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们别致的小网店。印象深刻吧。</p></figure><p id="e2ac" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">请欣赏这家商店。公平地说，没有发生太多的事情，但它包含了一个很好的组件。<code class="fe ng nh ni nj b">LatestOffer</code>组件。正如你所看到的，它用一些花哨的颜色渲染了一幅图像和一些文本。橙色边框内的一切(以及边框本身)都是<code class="fe ng nh ni nj b">LatestOffer</code>组件。在<code class="fe ng nh ni nj b"><a class="ae ms" href="https://gitlab.com/gvanderput/gerard-bicycle-shop/-/blob/master/src/components/BicycleShop/BicycleShop.jsx" rel="noopener ugc nofollow" target="_blank">BicycleShop.jsx</a></code>里面的第8行渲染，如下图所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7de8" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">组件本身在一个单独的文件中定义，<code class="fe ng nh ni nj b"><a class="ae ms" href="https://gitlab.com/gvanderput/gerard-bicycle-shop/-/blob/master/src/components/LatestOffer/LatestOffer.jsx" rel="noopener ugc nofollow" target="_blank">LatestOffer.jsx</a></code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="da92" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">请注意我们如何在组件中使用图像和一些样式。我们选择使用<a class="ae ms" href="https://github.com/css-modules/css-modules" rel="noopener ugc nofollow" target="_blank"> CSS模块</a>，但这是可选的。</p><p id="1bfc" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在我们有了。一家带有<code class="fe ng nh ni nj b">LatestOffer</code>成分的小店。</p><p id="9cc2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">另一个应用程序呢？</p><h2 id="1112" class="mt kz it bd la mu mv dn le mw mx dp li lz my mz lk md na nb lm mh nc nd lo ne bi translated">博客</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/c0f0558a6acf1c2b4966259e8c7245b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*N0xy91CLXYSrEgQo90CEWA.png"/></div></div></figure><p id="b0c0" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">除了商店，我们还有另一个独立的React应用程序，用于一个简单的博客。在这个博客中，在虚线环绕的区域，我们想呈现…我们商店的最新报价。正如我们之前提到的，这是我们的目标。</p><p id="12b4" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们知道有一个<code class="fe ng nh ni nj b">LatestOffer</code>组件存在，但是它是在商店知识库中定义的，而不是在我们的博客中。</p><p id="b415" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">那么，我们如何在这些应用程序之间共享组件呢？我们如何将一个组件从商店共享到博客？这就是Webpack 5的<a class="ae ms" href="https://webpack.js.org/concepts/module-federation/" rel="noopener ugc nofollow" target="_blank">模块联盟</a>发挥作用的地方。它有强大的功能，但是当你研究它的时候很难理解。</p><p id="fe17" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">所以，让我们继续前进，一步一步来。</p><h1 id="a466" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">与Webpack捆绑</h1><p id="500b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">两个应用程序(商店和博客)都有类似的捆绑代码的设置。它们都使用Webpack，并且它们的配置在很大程度上是相同的。</p><p id="ee7b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">它们在各自的<code class="fe ng nh ni nj b">webpack.config.js</code>文件中都有相同的<a class="ae ms" href="https://webpack.js.org/configuration/module/#modulerules" rel="noopener ugc nofollow" target="_blank">模块规则</a>配置，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b3c1" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这确保了样式表和JavaScript/JSX文件被正确地加载和绑定。但是这不是一个关于Webpack配置的教程，所以我们将把这些规则留到以后再说。</p><p id="810d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">相反，让我们看看如何扩展这个Webpack 5配置，在一端(商店)公开组件，在另一端(博客)消费它们。</p><h1 id="3a0d" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">模块联合:公开组件</h1><p id="c7ea" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们的目标是共享来自商店应用程序的<code class="fe ng nh ni nj b">LatestOffer</code>组件。因此，我们将首先通过添加一个<code class="fe ng nh ni nj b"><a class="ae ms" href="https://webpack.js.org/plugins/module-federation-plugin" rel="noopener ugc nofollow" target="_blank">ModuleFederationPlugin</a></code>的实例来修改商店应用程序的<code class="fe ng nh ni nj b">webpack.config.js</code>文件。所有的魔法都是这样开始的(见第11-17行):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9db9" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们将一个选项对象传递给构造函数:</p><ul class=""><li id="4deb" class="nn no it ls b lt mm lw mn lz np md nq mh nr ml ns nt nu nv bi translated"><code class="fe ng nh ni nj b">name</code>(第12行):这为当前项目定义了一个名称(记住我们现在正在编辑Shop项目的Webpack配置文件)。名字是任意的，大写也是任意的。</li><li id="88b5" class="nn no it ls b lt nw lw nx lz ny md nz mh oa ml ns nt nu nv bi translated"><code class="fe ng nh ni nj b">filename</code>(第13行):见下面一段。</li><li id="06e8" class="nn no it ls b lt nw lw nx lz ny md nz mh oa ml ns nt nu nv bi translated">(第14–16行):在这里你定义你想要公开的组件，以及它们将以哪个名字可用(稍后会详细介绍)。在这个例子中，我们通过给组件命名(<code class="fe ng nh ni nj b">./LatestOffer</code>)来公开<code class="fe ng nh ni nj b">LatestOffer</code>组件，注意关键的前导点斜线。这可以是任何名称，但我们决定使用相同的名称)，并通过将组件定义文件的路径定义为一个字符串(<code class="fe ng nh ni nj b">./src/components/LatestOffer/LatestOffer</code>)。不用说，如果我们愿意，我们可以这样公开几个组件。</li></ul><p id="0bb3" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">那么文件名呢，<code class="fe ng nh ni nj b">remoteEntry.js</code>？</p><p id="b598" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">想要使用我们公开的<code class="fe ng nh ni nj b">LatestOffer</code>组件的其他应用程序需要以某种方式获得组件定义(即组件的代码)。换句话说，他们需要能够加载该代码。</p><p id="e5a2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">假设我们的商店应用程序运行在位置<code class="fe ng nh ni nj b">localhost:8080</code>(碰巧的是，它确实运行了)。</p><p id="bc1e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">通过配置文件名<code class="fe ng nh ni nj b">remoteEntry.js</code>(也是一个任意值)，我们创建了路由<code class="fe ng nh ni nj b">localhost:8080/remoteEntry.js</code>。您可以猜测现在可以在那里找到什么——我们的<code class="fe ng nh ni nj b">LatestOffer</code>组件的代码(在一些其他样板代码中):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/0fdfa160be76dc4835e4ce4aaa64ce43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*bYKBLdCbmoo1ZsQiXDTang.png"/></div></figure><p id="414b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们现在已经公开了我们的组件。我们从我们的商店应用程序中共享它。</p><p id="2bba" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">让我们看看如何在另一边消耗它。我们如何在博客应用程序中呈现<code class="fe ng nh ni nj b">LatestOffer</code>组件。</p><h2 id="7145" class="mt kz it bd la mu mv dn le mw mx dp li lz my mz lk md na nb lm mh nc nd lo ne bi translated">模块联合:远程组件</h2><p id="1a59" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们继续，现在来看看博客应用程序的Webpack配置文件。同样，正如我们刚才对shop Webpack配置所做的那样，我们将添加一个带有一些选项的<code class="fe ng nh ni nj b">ModuleFederationPlugin</code>实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="07a1" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们传递给构造函数的选项有:</p><ul class=""><li id="3897" class="nn no it ls b lt mm lw mn lz np md nq mh nr ml ns nt nu nv bi translated"><code class="fe ng nh ni nj b">name</code>(第12行):再次显示当前项目的名称。</li><li id="70cd" class="nn no it ls b lt nw lw nx lz ny md nz mh oa ml ns nt nu nv bi translated"><code class="fe ng nh ni nj b">remotes</code>(第13–15行):基本上我们是在告诉我们的应用程序，“嘿！还有一个叫做<code class="fe ng nh ni nj b">SHOP</code>的应用程序，它正在公开组件！让我们给自己一种可能性，将它们加载到我们的项目中！”。object-key，<code class="fe ng nh ni nj b">SHOP</code>，是我们如何在本地引用外部组件(稍后会有更多相关内容)。该值是一个字符串，由at符号连接的两部分组成。第一部分是远程应用程序的名称，第二部分是包含我们正在加载的组件代码的文件(现在应该有点意义了)。</li></ul><p id="9287" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">最后，是时候在我们的博客中呈现<code class="fe ng nh ni nj b">LatestOffer</code>组件了。<br/>我们来看看。</p><h2 id="5b73" class="mt kz it bd la mu mv dn le mw mx dp li lz my mz lk md na nb lm mh nc nd lo ne bi translated">呈现远程组件</h2><p id="2270" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">看看正在渲染<code class="fe ng nh ni nj b">LatestOffer</code>组件的<code class="fe ng nh ni nj b">Blog</code>组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a6d2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">看看我们如何获得对<code class="fe ng nh ni nj b">LatestOffer</code>组件的引用(第3行)。</p><p id="7b98" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们使用所谓的动态导入。React的<code class="fe ng nh ni nj b">lazy</code>功能使我们能够做到这一点。这是一个高级主题，您可以在<a class="ae ms" href="https://reactjs.org/docs/code-splitting.html#reactlazy" rel="noopener ugc nofollow" target="_blank"> React文档</a>中了解更多信息。</p><p id="60d2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">加载(远程！)组件，我们呈现它(第10–12行)。注意，我们将组件包装在一个带有回退值的<code class="fe ng nh ni nj b">suspense</code>高阶组件(<a class="ae ms" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank"> HOC </a>)中。当我们加载远程组件时，将呈现回退值(如果它尚未加载)。一旦加载完毕，<code class="fe ng nh ni nj b">LatestOffer</code>组件就会呈现在我们的博客中！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/2acc28ad8974bf12fe0c100993cb0c8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*SrJui9Rjm9zPrAp-TqikPw.png"/></div></figure><h1 id="9302" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">最后的话</h1><p id="a9e6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在我看来，Webpack 5的模块联盟起步有点慢，这很遗憾。这篇文章证明了它的强大——相信我，我们只是触及了表面。</p><p id="8483" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">但是有些事情对模块联盟不利:</p><h2 id="8626" class="mt kz it bd la mu mv dn le mw mx dp li lz my mz lk md na nb lm mh nc nd lo ne bi translated">糟糕的命名</h2><p id="ac76" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">对于大多数开发人员来说，听到“模块联盟”这个术语并不会立即想起什么。假设Webpack插件被称为“ShareComponentsPlugin”。</p><h2 id="aa07" class="mt kz it bd la mu mv dn le mw mx dp li lz my mz lk md na nb lm mh nc nd lo ne bi translated">可怕的术语</h2><p id="46a7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">模块联合的教程中经常会涉及到微前端的概念。我确信你已经失去了至少一半的观众，因为你试图使用这样一个强大而复杂的概念。说“嘿！您想在应用程序之间共享组件吗？下面是方法！”</p><p id="5674" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">开发人员自己会发现，他们实际上可以共享一个完整的应用程序，而不是共享一个简单的表示组件(你做到了，不是吗？这里有个小秘密:可以！毕竟，完整的React应用程序只是另一个组件——有人说了<code class="fe ng nh ni nj b">App</code>吗？)</p><h2 id="b981" class="mt kz it bd la mu mv dn le mw mx dp li lz my mz lk md na nb lm mh nc nd lo ne bi translated">错误的文档</h2><p id="b775" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">甚至<a class="od oe ep" href="https://medium.com/u/9ef1379caffc?source=post_page-----84c5496f3c64--------------------------------" rel="noopener" target="_blank"> Zack Jackson </a>(大量参与维护和开发Webpack和模块联盟)自己也说在模块联盟的文档方面还有改进的空间。</p><p id="cf7a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">例如，看看GitHub上<a class="ae ms" href="https://github.com/webpack/webpack.js.org/issues/5067" rel="noopener ugc nofollow" target="_blank">这个Webpack问题</a>中的评论。</p><p id="26c9" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">但最重要的是，模块联合非常强大。天空是极限。</p><p id="f0a9" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">试试看！也许你很快就会和你的同事一起维护下一个微前端驱动的Web 4.0应用程序。</p><p id="f602" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">感谢您的宝贵时间！</p></div></div>    
</body>
</html>