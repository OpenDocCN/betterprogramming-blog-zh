<html>
<head>
<title>Enabling NFT Royalties With EIP-2981</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">启用EIP的NFT版税-2981</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/enabling-nft-royalties-with-eip-2981-1cc7cf4378a9?source=collection_archive---------10-----------------------#2022-06-29">https://betterprogramming.pub/enabling-nft-royalties-with-eip-2981-1cc7cf4378a9?source=collection_archive---------10-----------------------#2022-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ea35" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">EIP-2981引入了一种更简单的方法来启用NFT项目的版税。了解这个版税标准以及如何实施它</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4938ace3d549930157ca5ff591d33e4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uw7dWN2LY8A486mQvrOaVQ.jpeg"/></div></div></figure><p id="165c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">随着<a class="ae ln" href="https://eips.ethereum.org/EIPS/eip-721" rel="noopener ugc nofollow" target="_blank"> ERC721标准</a>的最终确定，不可替代令牌(NFT)开始受到大量关注。这些被证明是独一无二的资产存储在区块链上，并引入了一种新的方式来收集和交易艺术，音乐，个人资料图片(PFPs)等。2021年夏天，由于流行的热潮，创造和销售NFT成为一种快速积累财富的方式。</p><p id="519d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，当阅读底层规范时，您会注意到ERC721或ERC1155标准中没有获取和分割版税的功能。这些标准只处理所有权状态跟踪、批准和直接转移。</p><p id="0662" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果界面不包含任何原生版税功能，作为一个创作者，您如何能够在最初销售后很长时间内制作能够积累财富的NFT？像OpenSea这样的交易平台是如何分一杯羹的？如果你有一个更复杂的版税情况，如分割版税怎么办？</p><p id="4e63" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我们将探讨使用NFTs的版税的几个方面。我们将研究实现版税的方法，包括专有解决方案、注册和EIP-2981。我们还将研究一种分期付款的方法。最后，我们将运行一个项目，并看到版税分裂的行动。</p><p id="6f09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们开始吧！</p><h1 id="5759" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">什么是NFT版税？</h1><p id="8a70" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">就在第一批NFTs问世后几个月，市场合同就建立起来了，它允许持有者在商品上贴上价格标签，出价购买，并与他人安全交易。许多这样的市场甚至不存储用户的竞价交易；他们的配对合同收集交易的链外签名，并将它们存储在一个集中的服务器基础设施上。在区块链上拥有独一无二的东西的想法使OpenSea成为世界上最成功的市场之一，在<a class="ae ln" href="https://etherscan.io/gastracker" rel="noopener ugc nofollow" target="_blank">油老虎排行榜</a>上一直排名第一。</p><p id="3dab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那些逐渐去中心化的市场的真正成功故事是从他们每笔交易收取的费用中写出来的。例如，每只无聊的猿以100 Eth的价格交易，OpenSea就能稳定地获得2.5 Eth的巨额利润。将创作者留在他们的市场平台上的激励措施是向他们提供从二级市场销售中长期获利的选择。在NFT领域，这通常被称为“版税”。</p><h1 id="370a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">为NFT创作者赚钱:铸造费和版税</h1><p id="7218" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">当有人通过部署ERC721合约推出基本的NFT系列时，他们首先要考虑的是铸造，或者说新的令牌是如何进入生活的？</p><p id="ef77" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">令您惊讶的是，ERC721本身并没有定义任何默认的铸造规则。甚至它的官方规格也只提到过一次“薄荷”这个词。然而，几乎所有可收集的NFT合同都包含一种通过发送费用来调用的“造币”方法，这已成为常识。新铸造的代币可以在市场平台上立即交易，根据其社会市场机制，新铸造的资产可能会在几个小时内卖出大量铸造费。</p><p id="7458" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">铸造费对NFT合约的受益账户来说是有利可图的。然而，热门收藏的主要收入来源是版税，也就是当商品在其平台上交易时，市场从销售价格中分离出来的费用。既然ERC721与经济概念无关，更与NFT交易无关，那么NFT系列如何强制降低二次销售的版税呢？简单的答案？它不能。</p><p id="d95d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">重要的是要明白版税不是一个可以由收藏本身强制执行的概念。人们曾试图建立集合合约，这些合约带有自己的市场逻辑，并禁止在其受控环境之外的转让，但它们从未获得太多关注，因为市场是在主导平台上建立的。</p><p id="8ee4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于这些人来说，版税支付是一个自愿的概念，每个市场单独实施。因此，当NFT合同只是作为注册管理机构和市场单独管理版税支付时，收藏所有者如何定义他们的版税计划，以便每个市场都支持它？</p><h1 id="99d5" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">专有解决方案</h1><p id="4366" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">对于市场来说，确定收取多少版税以及将它们转移到哪里的最简单的方法是依赖于由集合实现的自己的专有接口。一个很好的例子是Rarible exchange合同，它试图支持各种外部版税接口，其中有两个Rarible定义了自己，是NFT领域的早期参与者:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="196d" class="mq lp iq mm b gy mr ms l mt mu">interface RoyaltiesV1 {<br/>    event SecondarySaleFees(uint256 tokenId, address[] recipients, uint[] bps);<br/>    function getFeeRecipients(uint256 id) external view returns (address payable[] memory);<br/>    function getFeeBps(uint256 id) external view returns (uint[] memory);<br/>}</span><span id="c216" class="mq lp iq mm b gy mv ms l mt mu">interface RoyaltiesV2 {<br/>    event RoyaltiesSet(uint256 tokenId, LibPart.Part[] royalties);<br/>    function getRaribleV2Royalties(uint256 id) external view returns (LibPart.Part[] memory);<br/>}</span></pre><p id="f3e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">NFT集合可以实现这些接口来返回版税金额和一组接收者。然后，当市场契约上的交易发生时，交易契约检查所涉及的NFT集合是否实现了这些接口中的一个，调用它，并使用它的返回值来相应地分割费用。</p><p id="c332" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，实际的销售价格不是方法接口的一部分。相反，他们以基点(bps)的形式产生版税份额，这是版税分配方案中常用的术语，通常翻译为1/10000——500的份额意味着贸易价值的5%应作为版税发送给收藏所有者。</p><h1 id="c114" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">版税注册</h1><p id="14c9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">然而，专有接口可能会导致问题。NFT契约的作者无法知道哪些接口可能会成为强制实现的，因为他们无法预测他们的令牌将在哪些市场上进行交易。更糟糕的是，如果他们在发布相关的市场合同之前启动了一个收集合同，他们通常没有简单的方法来添加各自的版税分配方案。</p><p id="4840" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决这个问题，围绕<a class="ae ln" href="https://www.manifold.xyz/" rel="noopener ugc nofollow" target="_blank"> manifold.xyz </a>的一个主要NFT市场财团同意部署一个行业范围的注册合同，收藏建设者可以使用它来独立于他们的令牌合同发出版税分割信号。版税注册的<a class="ae ln" href="https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/RoyaltyEngineV1.sol" rel="noopener ugc nofollow" target="_blank">开源代码库</a>显示它支持许多最重要的市场界面。</p><p id="5965" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，如果一个NFT收藏所有者只实现了上面提到的Rarible的版税分配方案之一，另一个不知道该接口的市场可以简单地调用通用注册中心的<code class="fe mw mx my mm b"><a class="ae ln" href="https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/RoyaltyEngineV1.sol#L107" rel="noopener ugc nofollow" target="_blank">getRoyaltyView</a></code>函数。它试图查询令牌合同上所有已知的版税接口，并将任何响应转换为通常可用的结果。</p><p id="7e07" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注册处甚至更进一步。没有在合同中加入任何版税信号方案的收藏所有者可以部署一个扩展的“覆盖”合同，并在公共注册中心注册。这种注册方法将确保只有集合所有者(由<code class="fe mw mx my mm b">owner</code>公共成员标识)可以调用它。</p><h1 id="c556" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">EIP-2981:跨市场的NFT版税信号标准</h1><p id="7ca6" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">2020年，一些雄心勃勃的个人开始定义一个通用接口，它足够灵活，可以覆盖大多数与版税相关的用例，并且易于理解和实现:EIP-2981。它只定义了NFT合同可以实施的一种方法:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="babf" class="mq lp iq mm b gy mr ms l mt mu">function royaltyInfo(uint256 _tokenId,  uint256 _salePrice) <br/>  external view <br/>  returns (address receiver, uint256 royaltyAmount);</span></pre><p id="47f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意它有意缺乏的特性:它既不关心几个政党之间的分裂，也不强加任何百分比或基点的概念。调用者很清楚他们将收到什么返回值，实现者也很清楚如何实现这一点。</p><p id="0298" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该接口也完全在链外工作，因此在替代基础设施上交易资产的市场仍然可以查询创建者费用，而不知道除了EIP-2981方法的接口签名之外的任何事情。</p><p id="14df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该接口适用于以Eth表示的销售额，以及任何其他货币。实施者只需将<code class="fe mw mx my mm b">_salePrice</code>除以他们的计算基数，然后乘以相同基数上的版税百分比。虽然实施者可以运行复杂的逻辑来根据外部因素计算动态版税，但建议尽可能少地执行此方法，因为它将在交易方之间的销售转移交易中执行，并且他们的天然气费用应该相当低。</p><p id="57bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了让您了解非平凡的EIP-2981实现可能是什么样子，这里有一个片段，您可以在1/1 NFT收藏中找到，它表明原始创作者的地址以及他们对任何与该标准兼容的市场的版税要求:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d1aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您正在使用OpenZeppelin的ERC721基础契约构建NFT契约，您可能已经注意到他们最近添加了一个包含管理方法和私有成员的<code class="fe mw mx my mm b"><a class="ae ln" href="https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#ERC721Royalty" rel="noopener ugc nofollow" target="_blank">ERC721Royalty</a></code>基础契约，以简化专用令牌版税的处理。</p><h1 id="d91b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">ERC1155印刷品的版税</h1><p id="84b3" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">市场并不是唯一让用户从版税计划中获利的应用。例如，Treum的<a class="ae ln" href="https://eulerbeats.com/" rel="noopener ugc nofollow" target="_blank"> EulerBeats </a>在他们的合同集合中使用了多令牌标准<a class="ae ln" href="https://eips.ethereum.org/EIPS/eip-1155" rel="noopener ugc nofollow" target="_blank"> ERC1155 </a>，这代表了结合了计算机生成的曲调和生成艺术作品的NFT。铸造种子令牌后，用户可以从中获得有限数量的打印，每次打印的价格会沿着令牌合同定义的绑定曲线上升。</p><p id="593b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每铸造一枚新的英格玛种子，合同会将铸造费的50%提成转给当前种子的所有者。如果接收方实现了特定于平台的<code class="fe mw mx my mm b">IEulerBeatsRoyaltyReceiver</code>接口，它甚至可以对版税支付做出反应，并在他们的种子印刷完成后执行代码。</p><h1 id="ba66" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">PaymentSplitters:向不止一个接收者发送NFT版税。</h1><p id="6db9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">EIP-2981缺乏其他方法现成解决的用例。它只能向请求方发送一个版税接收地址。因此，需要在几个接受者之间分割版税的情况必须单独实现。</p><p id="ef3f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这可能会带来几个新问题:首先，呼叫者/市场不一定必须将资金与触发交易的相同交易一起发送，而是可以在以后决定这样做，例如在从另一个帐户进行的高能效多呼叫中。第二，对地址的支付呼叫可能在汽油使用方面受到高度限制。Solidity中的任何<a class="ae ln" href="https://docs.soliditylang.org/en/v0.8.13/contracts.html?highlight=receive#receive-ether-function" rel="noopener ugc nofollow" target="_blank">默认接收方函数</a>都被强烈鼓励使用尽可能少的gas，因为发送方可能没有意识到他们正在向合同转移资金。</p><p id="e1dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最重要的考虑是，直接从契约交互中汇款会带来陷入可重入漏洞的风险；这就是为什么强烈建议支持拉取机制，允许受益人不时地提取他们的收益，而不是直接将资金推到调用合同未知的地址。</p><p id="679d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是，OpenZeppelin的基础合同又覆盖了我们。他们的<a class="ae ln" href="https://docs.openzeppelin.com/contracts/4.x/api/finance#PaymentSplitter" rel="noopener ugc nofollow" target="_blank"> PaymentSplitter </a>原语允许建立单独的分割合同，以保证资金的安全，直到他们的收款人要求他们，他们的<a class="ae ln" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/finance/PaymentSplitter.sol#L68" rel="noopener ugc nofollow" target="_blank">接收功能</a>只需要最少的汽油就可以运行。NFT集合建设者可以创建一个内嵌的支付拆分器，其中包含想要的受益人列表和他们各自的份额金额，并让他们的EIP-2981实现产生该拆分合同的地址。</p><p id="b54d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于许多用例来说，这种方法的权衡可能是可以忽略的:PaymentSplitter部署相对来说是气体密集型的，并且一旦Splitter初始化，就不可能替换收款人或股份。在<a class="ae ln" href="https://github.com/SpliceNFT/splicenft/blob/main/packages/contracts/contracts/ReplaceablePaymentSplitter.sol" rel="noopener ugc nofollow" target="_blank">创成式艺术项目拼接</a>中可以找到如何有效地替换拆分器参与者和实例化节能分包合同的示例实现。</p><h1 id="c6a0" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">用本地Mainnet Fork测试NFT版税支出</h1><p id="a4d0" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">设计与任意NFT合约交互的市场不是一项简单的任务，因为无法预测实时网络上的合约是否按照ERC界面运行。然而，使用<a class="ae ln" href="https://trufflesuite.com/blog/introducing-ganache-7/" rel="noopener ugc nofollow" target="_blank"> Ganache </a>针对这些契约测试我们的代码是有帮助的。这个强大的工具让我们可以在本地机器上创建以太坊网络的即时分支，而无需设置我们自己的区块链节点。相反，它依赖于<a class="ae ln" href="https://docs.infura.io/infura/" rel="noopener ugc nofollow" target="_blank"> Infura </a>节点来读取我们正在交互的合同和账户的当前状态。</p><p id="9741" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在开始我们的区块链实例之前，让我们克隆我们的概念证明的存储库，进入新目录，并安装任何依赖项:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="b156" class="mq lp iq mm b gy mr ms l mt mu">git clone https://github.com/elmariachi111/royalty-marketplace.git<br/>cd royalty-marketplace<br/>npm i</span></pre><p id="6906" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了了解这个NFT市场示例中发生了什么，让我们看一下<code class="fe mw mx my mm b">contracts</code>文件夹中的<code class="fe mw mx my mm b">ClosedDesert.sol</code>代码。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="e049" class="mq lp iq mm b gy mr ms l mt mu">// SPDX-License-Identifier: MIT<br/>pragma solidity ^0.8.0;</span><span id="b87f" class="mq lp iq mm b gy mv ms l mt mu">import "@openzeppelin/contracts/token/ERC721/IERC721.sol";<br/>import "@openzeppelin/contracts/utils/Address.sol";<br/>import "@openzeppelin/contracts/security/ReentrancyGuard.sol";<br/>import "@openzeppelin/contracts/token/common/ERC2981.sol";<br/>import "@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyEngineV1.sol";</span><span id="004b" class="mq lp iq mm b gy mv ms l mt mu">struct Offer {<br/>  IERC721 collection;<br/>  uint256 token_id;<br/>  uint256 priceInWei;<br/>}<br/>/**<br/> * DO NOT USE IN PRODUCTION!<br/> * a fixed reserve price marketplace<br/> */<br/>contract ClosedDesert is ReentrancyGuard {</span><span id="4e77" class="mq lp iq mm b gy mv ms l mt mu">  mapping(bytes32 =&gt; Offer) public offers;</span><span id="0f86" class="mq lp iq mm b gy mv ms l mt mu">  // https://royaltyregistry.xyz/lookup<br/>  IRoyaltyEngineV1 royaltyEngineMainnet = IRoyaltyEngineV1(0x0385603ab55642cb4Dd5De3aE9e306809991804f);</span><span id="f965" class="mq lp iq mm b gy mv ms l mt mu">  event OnSale(bytes32 offerHash, address indexed collection, uint256 token_id, address indexed owner);<br/>  event Bought(address indexed collection, uint256 token_id, address buyer, uint256 price);</span><span id="1e86" class="mq lp iq mm b gy mv ms l mt mu">  function sellNFT(IERC721 collection, uint256 token_id, uint256 priceInWei) public {<br/>    require(collection.ownerOf(token_id) == msg.sender, "must own the NFT");<br/>    require(collection.getApproved(token_id) == address(this), "must approve the marketplace to sell");</span><span id="be04" class="mq lp iq mm b gy mv ms l mt mu">    bytes32 offerHash = keccak256(abi.encodePacked(collection, token_id));<br/>    offers[offerHash] = Offer({<br/>      collection: collection,<br/>      token_id: token_id,<br/>      priceInWei: priceInWei<br/>    });<br/>    emit OnSale(offerHash, address(collection), token_id, msg.sender);<br/>  }</span><span id="a24d" class="mq lp iq mm b gy mv ms l mt mu">  function buyNft(bytes32 offerHash) public payable nonReentrant {<br/>    Offer memory offer = offers[offerHash];<br/>    require(address(offer.collection) != address(0x0), "no such offer");<br/>    require(msg.value &gt;= offer.priceInWei, "reserve price not met");</span><span id="da94" class="mq lp iq mm b gy mv ms l mt mu">    address payable owner = payable(offer.collection.ownerOf(offer.token_id));</span><span id="2b77" class="mq lp iq mm b gy mv ms l mt mu">    emit Bought(address(offer.collection), offer.token_id, msg.sender, offer.priceInWei);</span><span id="f9e5" class="mq lp iq mm b gy mv ms l mt mu">    // effect: clear offer<br/>    delete offers[offerHash];</span><span id="a1e4" class="mq lp iq mm b gy mv ms l mt mu">    (address payable[] memory recipients, uint256[] memory amounts) =<br/>      royaltyEngineMainnet.getRoyalty(address(offer.collection), offer.token_id, msg.value);</span><span id="89d4" class="mq lp iq mm b gy mv ms l mt mu">    uint256 payoutToSeller = offer.priceInWei;</span><span id="ddfd" class="mq lp iq mm b gy mv ms l mt mu">    //transfer royalties<br/>    for(uint i = 0; i &lt; recipients.length; i++) {<br/>      payoutToSeller = payoutToSeller - amounts[i];<br/>      Address.sendValue(recipients[i], amounts[i]);<br/>    }<br/>    //transfer remaining sales revenue to seller<br/>    Address.sendValue(owner, payoutToSeller);</span><span id="ff1b" class="mq lp iq mm b gy mv ms l mt mu">    //finally transfer asset<br/>    offer.collection.safeTransferFrom(owner, msg.sender, offer.token_id);<br/>  }<br/>}</span><span id="ba9c" class="mq lp iq mm b gy mv ms l mt mu">}</span></pre><p id="50f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的示例中，卖家可以在获得转让批准后，以固定的销售价格列出他们的资产。买家可以关注<code class="fe mw mx my mm b">OnSale</code>事件，并通过发布<code class="fe mw mx my mm b">buyNft</code>交易和发送想要的Eth值来做出响应。市场合同在销售交易期间检查开放的mainnet <a class="ae ln" href="https://royaltyregistry.xyz/lookup" rel="noopener ugc nofollow" target="_blank"> NFT版税注册表</a>以查看收藏所有者是否请求版税，然后相应地支付它们。如上所述，公共版税注册已经将EIP-2981兼容合同考虑在内。尽管如此，它也支持许多其他专有的分发方案。</p><p id="9f41" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们将部署我们的本地区块链实例，并使用真实用户的帐户和NFT测试我们的合同。</p><p id="cc47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了测试mainnet条件下的契约行为，我们首先需要访问一个<a class="ae ln" href="https://infura.io/product/ethereum" rel="noopener ugc nofollow" target="_blank"> Infura mainnet节点</a>，方法是请求一个项目id并在我们的机器上本地安装<a class="ae ln" href="https://github.com/trufflesuite/ganache#command-line-use" rel="noopener ugc nofollow" target="_blank">Ganache V7</a>。然后，我们可以使用我们最喜欢的NFT市场来查找收藏，并找到一个将在我们的测试中扮演卖家角色的NFT持有人帐户。卖家必须实际拥有我们将要出售的NFT。</p><p id="d90d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，找一个有足够mainnet资金(至少1 Eth)的账户来支付卖家要求的销售价格。有了这些帐户和工具，我们可以在新的终端窗口中使用以下命令启动本地Ganache mainnet实例:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="c6fb" class="mq lp iq mm b gy mr ms l mt mu">npx ganache --fork https://mainnet.infura.io/v3/&lt;infuraid&gt; --unlock &lt;0xseller-account&gt; --unlock &lt;0xbuyer-account&gt;</span></pre><p id="4c90" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">确保在上面的命令中使用您自己的Infura mainnet端点作为URL。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/aa53e65eea72cd2de187c87ab47b9146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lJriVCU9PEp37M0P.jpg"/></div></div></figure><p id="4128" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你找不到要解锁的帐户，这里有几个可以试试:</p><p id="2db3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">卖家地址:<code class="fe mw mx my mm b">0x27b4582d577d024175ed7ffb7008cc2b1ba7e1c2</code> <br/>买家地址:<code class="fe mw mx my mm b">0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045</code></p><p id="4993" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">注意:</strong>因为我们在Ganache实例中模拟以太坊主网，所以当您读到本文时，卖方可能已经不再拥有我们将要出售的NFT，或者买方可能已经没有足够的以太网来实际购买。因此，如果这些地址不起作用，您将不得不寻找符合上述标准的地址。</p><p id="7ade" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用上面的地址示例，我们的命令如下所示:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="83f1" class="mq lp iq mm b gy mr ms l mt mu">npx ganache --fork https://mainnet.infura.io/v3/&lt;infuraid&gt; --unlock 0x27b4582d577d024175ed7ffb7008cc2b1ba7e1c2 --unlock 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045</span></pre><p id="14a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，在我们最初的终端窗口中，我们将从存储库中编译和部署marketplace契约，并选择我们的本地mainnet fork提供者，这可以在<strong class="kt ir"> truffle-config.js </strong>中找到:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="58da" class="mq lp iq mm b gy mr ms l mt mu">npx truffle compile<br/>npx truffle migrate --network mainfork</span></pre><p id="c5fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们可以在mainnet条件下测试我们的版税感知市场合同，而无需支付一分钱的天然气费用。所有即将到来的交易将由本地Ganache链代表真实用户的帐户执行。</p><p id="7b9e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一下<code class="fe mw mx my mm b">testMarketplace.js</code>脚本(在<code class="fe mw mx my mm b">scripts</code>文件夹中找到),我们将使用它与我们部署的市场智能合同进行交互:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="7417" class="mq lp iq mm b gy mr ms l mt mu">const ClosedDesert = artifacts.require("ClosedDesert");<br/>const IErc721 = require("../build/contracts/IERC721.json");</span><span id="29a1" class="mq lp iq mm b gy mv ms l mt mu">//Change these constants:<br/>const collectionAddress = "0xed5af388653567af2f388e6224dc7c4b3241c544"; // Azuki<br/>const tokenId = 9183;<br/>let sellerAddress = "0x27b4582d577d024175ed7ffb7008cc2b1ba7e1c2";<br/>const buyerAddress = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045";</span><span id="6eb6" class="mq lp iq mm b gy mv ms l mt mu">module.exports = async function(callback) {<br/>  try {<br/>    const marketplace = await ClosedDesert.deployed();<br/>    const erc721 = new web3.eth.Contract(IErc721.abi, collectionAddress);<br/>    const salesPrice = web3.utils.toWei("1", "ether");</span><span id="1bab" class="mq lp iq mm b gy mv ms l mt mu">    //buyerAddress = await web3.utils.toChecksumAddress(buyerAddress);</span><span id="5b16" class="mq lp iq mm b gy mv ms l mt mu">    // marketplace needs the seller's approval to transfer their tokens<br/>    const approval = await erc721.methods.approve(marketplace.address, tokenId).send({from: sellerAddress});<br/>    const sellReceipt = await marketplace.sellNFT(collectionAddress, tokenId, salesPrice, {<br/>      from: sellerAddress<br/>    });<br/>    const { offerHash } = sellReceipt.logs[0].args;</span><span id="fe0c" class="mq lp iq mm b gy mv ms l mt mu">    const oldOwner = await erc721.methods.ownerOf(tokenId).call();<br/>    console.log(`owner of ${collectionAddress} #${tokenId}`, oldOwner);</span><span id="e65a" class="mq lp iq mm b gy mv ms l mt mu">    const oldSellerBalance = web3.utils.toBN(await web3.eth.getBalance(sellerAddress));<br/>    console.log("Seller Balance (Eth):", web3.utils.fromWei(oldSellerBalance));</span><span id="60a2" class="mq lp iq mm b gy mv ms l mt mu">    // buyer buys the item for a sales price of 1 Eth<br/>    const buyReceipt = await marketplace.buyNft(offerHash, {from: buyerAddress, value: salesPrice});<br/>    const newOwner = await erc721.methods.ownerOf(tokenId).call();<br/>    console.log(`owner of ${collectionAddress} #${tokenId}`, newOwner);</span><span id="0e1b" class="mq lp iq mm b gy mv ms l mt mu">    const newSellerBalance = web3.utils.toBN(await web3.eth.getBalance(sellerAddress));<br/>    console.log("Seller Balance (Eth):", web3.utils.fromWei(newSellerBalance));<br/>    console.log("Seller Balance Diff (Eth):", web3.utils.fromWei(newSellerBalance.sub(oldSellerBalance)));</span><span id="cd52" class="mq lp iq mm b gy mv ms l mt mu">  } catch(e) {<br/>    console.error(e)<br/>  } finally {<br/>    callback();<br/>  }<br/>}</span></pre><p id="9bc3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">注意</strong>:常量<code class="fe mw mx my mm b">collectionAddress</code>、<code class="fe mw mx my mm b">sellerAddress</code>和<code class="fe mw mx my mm b">buyerAddress</code>必须都是满足上述标准的合法mainnet地址，而<code class="fe mw mx my mm b">sellerAddress</code>和<code class="fe mw mx my mm b">buyerAddress</code>必须都在您的Ganache实例中解锁。<code class="fe mw mx my mm b">tokenId</code>常数也必须是卖家拥有的NFT的实际值<code class="fe mw mx my mm b">tokenId</code>。</p><p id="1a0b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个助手脚本中，我们将设置对我们将与之交互的合同的引用。我们决定在样本代码中获得EIP-2981兼容的<a class="ae ln" href="https://www.azuki.com/" rel="noopener ugc nofollow" target="_blank">志那都红豆集合</a>，但是它可以是任何NFT集合。我们使用以下命令运行该脚本:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="d59e" class="mq lp iq mm b gy mr ms l mt mu">npx truffle exec scripts/testMarketplace.js --network mainfork</span></pre><p id="fc5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果一切运行正常，您应该会在控制台中收到如下输出:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="6445" class="mq lp iq mm b gy mr ms l mt mu">owner of Azuki 0xed5af388653567af2f388e6224dc7c4b3241c544 #9183 0x27b4582D577d024175ed7FFB7008cC2B1ba7e1C2<br/>Seller Balance (Eth): 0.111864414925655418<br/>owner of Azuki 0xed5af388653567af2f388e6224dc7c4b3241c544 #9183 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045<br/>Seller Balance (Eth): 1.061864414925655418<br/>Seller Balance Diff (Eth): 0.95</span></pre><p id="bd3a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们浏览一下刚刚发生的步骤，以便了解它是如何工作的。首先，该脚本要求卖方在NFT售出后批准转让，这一步通常由各自的市场合同处理。然后，我们通过代表当前所有者致电<code class="fe mw mx my mm b">sellNft</code>来创建销售报价。最后，我们简单地重用sale事件中包含的offer hash，让我们的买方调用<code class="fe mw mx my mm b">buyNft</code>方法并发送请求的销售价格1 Eth。</p><p id="cf97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你比较卖家交易前后的余额时，你会注意到他们没有收到要求的1 Eth，而只有0.95。按照mainnet版税注册合同的指示，剩余资金已转移到志那都红豆的版税接收方。</p><h1 id="a6bc" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="5175" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">版税是在NFT取得成功的主要驱动力。以前，它们是专有市场的附加功能，现在已经演变成不可替代的代币经济的强制属性。他们向任何NFT收藏品建造者承诺，当他们的作品开始吸引广大观众时，他们就可以获利。他们是一个伟大的经济概念，以某种方式分配销售收入，为原始代码作者或NFT艺术家提供激励。</p><p id="79e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">ERC721不包含任何经济特征的概念；因此，NFT特许权使用费不能通过象征性合同直接强制执行。相反，市场建设者必须为令牌合约提供接口，以表明他们对交易费用的要求以及将交易费用发送到哪里。EIP-2981版税信令接口是一个简洁而强大的行业标准，可以在不给实现者增加更多复杂性的情况下实现这一点。每份新的ERC721合同都应考虑实施至少一个基本的版税信号，以便专有的市场工具能够获取并引用该信号。</p></div></div>    
</body>
</html>