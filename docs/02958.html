<html>
<head>
<title>Try These Instead of Using Immutable.js With Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">尝试这些，而不是使用Redux不可变的. js</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/try-these-instead-of-using-immutable-js-with-redux-f5bc3bd30190?source=collection_archive---------5-----------------------#2020-01-11">https://betterprogramming.pub/try-these-instead-of-using-immutable-js-with-redux-f5bc3bd30190?source=collection_archive---------5-----------------------#2020-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9b9d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">试试Immer，Redux Toolkit，无缝的，或者根本没有库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4e0dd9c0e59c248a5c5345d466a81b72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5IwI3UFT8BmTwyY9k_vcbg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@helloquence?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">在<a class="ae ky" href="https://unsplash.com/s/photos/laptop-and-paper?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的</a></p></figure><p id="e511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://medium.com/better-programming/3-reasons-to-avoid-using-immutablejs-with-redux-b0109d0123e8" rel="noopener">之前的一篇文章</a>中，我说过<a class="ae ky" href="https://immutable-js.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank"> Immutable.js </a>不应该作为Redux的“不变性助手”库，但没有推荐任何其他选项。</p><p id="9ed6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一些我比Immutable.js更喜欢使用的替代方法(排名不分先后):</p><ol class=""><li id="0d92" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/rtfeldman/seamless-immutable" rel="noopener ugc nofollow" target="_blank">无缝-不可变</a></li><li id="50f0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/immerjs/immer" rel="noopener ugc nofollow" target="_blank">沉浸</a></li><li id="cbe0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/reduxjs/redux-toolkit" rel="noopener ugc nofollow" target="_blank"> Redux工具包</a></li><li id="2546" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">根本没有图书馆</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ae8b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">重述:为什么不是Immutable.js？</h1><p id="8fd5" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">将Immutable.js与Redux一起使用的主要问题是，它的数据结构不能向后兼容普通的JavaScript语法——它们只能使用库的API来处理，API本质上是另一种语言。</p><p id="7a72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这导致库扩展到整个代码库，甚至扩展到不应该关心不变性的地方，比如哑React组件。</p><p id="d0f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这给开发人员带来了不必要的困难，他们必须不断地询问一些数据是普通的JavaScript还是由Immutable.js包装的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">试图析构一个不可变的. js对象是回答这个问题的一种方式。</p></figure><p id="54f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个更好的选择是，库的使用仅限于处理不可变数据的地方:在reducers中。</p><p id="1588" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他地方，如组件、实用函数和选择器，应该都不知道任何不变性助手库。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9b88" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">替代方案1:无缝-不可变</h1><p id="c070" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Seamless最初给人的感觉非常类似于Immutable.js:所有对象都必须由一个不可变的工厂函数包装，并且必须使用库的API来对它们进行更改。关键的区别在于<em class="np">无缝对象可以使用普通JavaScript读取。</em></p><p id="7194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑一个reducer，它看起来与无缝和不可变的几乎相同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="2a0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在如何通过Redux的<code class="fe nq nr ns nt b">mapStateToProps</code>将<code class="fe nq nr ns nt b">todos</code>传递给一个组件，以及该组件如何使用这个prop方面有所不同——无缝地，这些都可以使用普通的JavaScript来完成。</p><p id="61c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Seamless和Immutable.js的<code class="fe nq nr ns nt b">mapStateToProps</code>函数如下所示:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="0c60" class="ny mr it nt b gy nz oa l ob oc">(state) =&gt; { todos: state.todos }  // Seamless</span><span id="2286" class="ny mr it nt b gy od oa l ob oc">(state) =&gt; { todos: state.get('todos') }  // ImmutableJS</span></pre><p id="2173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在组件中使用prop看起来像这样:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="5aba" class="ny mr it nt b gy nz oa l ob oc">props.todos.a.isComplete  // Seamless</span><span id="758d" class="ny mr it nt b gy od oa l ob oc">props.todos.getIn(['a', 'isComplete']) // ImmutableJS</span></pre><p id="8aec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，与Immutable.js相比，Seamless的使用更局限于代码库中，因为无缝对象可以用普通的JavaScript读取。</p><p id="291c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像dumb React组件和基本选择器(以及它们的所有测试)这样的东西不会显示任何库的迹象。然而，改变数据只能使用无缝API来完成，因此在实用函数和更复杂的选择器中，这个库仍然是显而易见的。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9928" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">备选方案2: immer</h1><p id="2c2b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Immer的工作方式与Immutable.js和Seamless非常不同，正因为如此，它完全解决了向后兼容的问题— <em class="np">它完全是普通的JavaScript。</em></p><p id="c5bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要由于这个原因，Immer已经成为Redux中管理不变性的一个非常流行的解决方案。甚至连<a class="ae ky" href="https://redux.js.org/style-guide/style-guide/#use-immer-for-writing-immutable-updates" rel="noopener ugc nofollow" target="_blank"> Redux风格指南</a>都把它列为明显的最爱:</p><blockquote class="oe"><p id="8a38" class="of og it bd oh oi oj ok ol om on lu dk translated">“使用Immer编写不可变的更新— <strong class="ak">强烈推荐”</strong></p></blockquote><p id="52a5" class="pw-post-body-paragraph kz la it lb b lc oo ju le lf op jx lh li oq lk ll lm or lo lp lq os ls lt lu im bi translated">有点令人惊讶的是，Immutable.js仍然在npm下载排行榜上名列前茅，但我怀疑Immer很快就会领先。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/bf76a6a92ebd602cc389660ababc7309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5i-s8dXXvLcit9uhVzLAJA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.npmtrends.com/immutable-vs-immer-vs-seamless-immutable" rel="noopener ugc nofollow" target="_blank">https://www . NPM trends . com/immutable-vs-immer-vs-seamless-immutable</a></p></figure><p id="ef88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Immer允许开发人员编写变异操作，但确保这些操作只发生在临时的“草案”状态，该状态稍后会最终确定为新状态:</p><blockquote class="ou ov ow"><p id="1af3" class="kz la np lb b lc ld ju le lf lg jx lh ox lj lk ll oy ln lo lp oz lr ls lt lu im bi translated">使用Immer就像有了一个私人助理；他拿了一封信(当前状态)并给了你一份副本(草稿),让你在上面草草修改。一旦你完成了，助手会拿走你的草稿，为你产生真正的不可变的，最终的信(下一个状态)。— Immer</p></blockquote><p id="4e44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是通过Immer的<code class="fe nq nr ns nt b">produce</code>功能实现的:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="3d2e" class="ny mr it nt b gy nz oa l ob oc">produce(currentState, producer: (draftState) =&gt; void): nextState</span></pre><p id="d8e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传递当前状态，期望的更新表示为一个突变(生产者函数)，Immer将返回结果作为一个新的状态，保持当前状态不变。</p><p id="9000" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的一点是，因为Immer本身负责返回最终的草稿，所以<code class="fe nq nr ns nt b">producer</code>函数参数不应该改变草稿，也不应该试图返回某些东西——它应该只做其中一个。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/49b07065892df81a725faf9072e70194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*C0-Dr4-2TFDBpsKgPEF6aA.png"/></div></figure><p id="2ef7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个<code class="fe nq nr ns nt b">produce</code>功能的帮助，用Redux来使用Immer变得极其简单。考虑到与前面相同的reducer，使用Immer比使用Seamless和Immutable.js更好，因为:</p><ul class=""><li id="1ab4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu pb mb mc md bi translated">状态是普通的JavaScript。</li><li id="ae6b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu pb mb mc md bi translated">reducer中对这种状态的更新是使用普通JavaScript完成的。</li><li id="72cf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu pb mb mc md bi translated">从这个状态派生出来的所有道具都是普通的JavaScript。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d0c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Immer实现了我们所希望的:这个库仅限于reducers，不会扩展到代码库的其他部分，比如组件、实用函数和选择器。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="1ea7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">替代方案3: Redux工具包</h1><p id="eee0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Redux Toolkit提供了一组实用程序和函数，帮助开发人员编写包含最佳实践的一致Redux逻辑。</p><p id="6de4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个这样的实用程序是<code class="fe nq nr ns nt b">createReducer()</code>，它在幕后使用Immer，允许不可变的状态更新被写成突变。</p><p id="551e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该实用程序还允许简化reducer的结构(再见，switch语句),使reducer作为一个整体看起来有些不同，但实际的状态更新看起来与Immer相同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="b90a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，使用Redux工具包带来了与使用Immer相同的好处，只有<code class="fe nq nr ns nt b">produce</code>函数是隐藏的。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4fcb" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">选择4:根本没有图书馆</h1><p id="72e8" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">最有趣的选择，但也最容易出错。出于这个原因，这是获得对状态管理中的不变性的欣赏的一个很好的方法。</p><p id="0463" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">独立完成任务可能不会有很好的伸缩性，但是对于小型应用程序来说，它们仍然很小(小型应用程序需要Redux吗？)这是一个和其他解决方案一样好的解决方案。</p><p id="bc51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单来说；只要记住<code class="fe nq nr ns nt b">{ ...spreadEverything }</code>中的减速器即可；</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">记住扩展操作符只进行浅层复制，因此有递归。</p></figure><p id="0e0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更进一步，您可以使用<code class="fe nq nr ns nt b">Object.freeze()</code>来确保数据的不变性——试图改变一个冻结的对象将会抛出一个错误。</p><p id="638b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，冻结是一种肤浅的方法(像spread操作符一样),这意味着当状态变成嵌套状态时，冻结和解冻它变得更加复杂，必须递归地完成。</p><p id="82b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你发现自己在编写定制的<code class="fe nq nr ns nt b">deepFreeze</code>和<code class="fe nq nr ns nt b">deepUnfreeze</code>函数时，可能是时候开始使用上面的库解决方案之一了，它能更好地解决这个问题。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="dcc6" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">摘要</h1><p id="b6ba" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在Redux中，有许多库可以帮助处理不可变数据，但在我看来，那些向后兼容普通JavaScript的库是赢家，这很快就让Immutable.js打折扣了。</p><p id="576f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，Immer + Redux组合似乎是最受欢迎的，并且有很好的理由——Immer没有引入任何不能用普通JavaScript处理的东西。</p><p id="0ddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着它只限于reducers，不像Immutable.js那样扩展到代码库的Redux特定部分之外。所有这些都使得Immer易于理解和使用，易于采用，必要时甚至易于删除(但我怀疑会是这样)！</p><p id="e46f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，对于小型应用程序，您可能根本不需要库。至少在导入之前尝试一下。</p></div></div>    
</body>
</html>