# 通过示例了解 Rust 所有权模型

> 原文：<https://betterprogramming.pub/understanding-rust-ownership-model-by-example-5d586ec5e8e4>

## 了解作为 Rust 所有权体系基础的 3 条规则

![](img/4d2461217ccd58d283770a8e9d296da8.png)

Rust 所有权模型封面

在过去的几个月里，我对 Rust 编程语言很感兴趣——尤其是它的内存模型和所有权。

起初，我认为它只是另一种系统编程语言，我可以通过编写一些示例应用程序在几周内学会。但是后来我在使用它的所有权模型时遇到了许多障碍。

我花了几个星期才真正理解 RUST 编写的基本原理。现在我不能停止学习和尝试更多的东西。

在这篇文章中，我将用一个简单的例子来分享一些所有权原则。

这个例子是一个交互式产品分析框架的一部分，我试图建立这个框架来学习 Rust 并从头开始编写一个分布式系统。

要开始，请参考下面的数据结构:

在数据分析领域，事件是由键值对组成的数据结构。这些是发送到数据收集服务的数据点。事件通常可以根据人类的可读性来命名。我们将在整个教程中使用这个事件结构，并理解 Rust 的所有权规则基础。

# 没有垃圾收集器

在我们深入研究规则之前，理解 Rust 不像其他高级编程语言那样有垃圾收集器是很重要的。它也没有像 C / C++那样对大部分部件进行手动内存管理。*因此，当我们既需要性能又需要内存安全时，它是首选*。

谈到栈/堆上的内存管理，Rust 有一些简单的规则来管理对象和内存。Rust 确保我们的程序在管理内存时不会出错——前提是我们遵守某些规则。

一开始，使用这种内存模型和所有权规则似乎非常令人生畏，但是一旦我们习惯了这种操作模型，它会使我们成为更好的程序员，并提供尽可能好的性能，而不必管理低级内存。

以下是使用语言对象和变量时的规则。

# 每个变量都有一个所有者

考虑上面显示的代码块。我们初始化三个变量，即事件名称、客户端 ID 和实际的事件对象。第一条规则非常简单——每个变量都有一个所有者。这意味着上面定义的三个值归三个变量所有。这些变量只能在此函数内访问，不允许超出此函数范围的访问。当我运行这个程序时，我们看到了预期的输出，这是我们配置的事件名称。

现在让我们看看另外两条规则。

# 只允许一个所有者

在任何给定的时间点，Rust 只允许变量有一个所有者。通常，许多编程语言都有使用多个变量来引用同一个值的概念。例如，在 JAVA 中，可以写

```
String name = "Sam" ; 
String sam = name; 
System.out.println(name); 
System.out.println(sam);
```

这在 Java 中完全没问题。它打印出这两个值。

现在让我们在 Rust 中尝试一个类似的东西。

我们试图复制原始引用并将其存储在另一个变量中，以便在打印语句中使用它们。猜猜这会发生什么。

下面是我们尝试运行时的输出。

我们在这里做的只是使用另一个变量名来引用同一个事件并打印它们。但是 Rust 一点都不喜欢这样。

根据我们的第二条规则，一个值只能有一个所有者。在我们的例子中，我们最初定义的事件属于`new_event`变量。

从技术上讲，当我们试图创建一个新变量并引用原始事件时，我们打算创建两个指向相同数据的所有者。

根据第一和第二条规则，这是不允许的。为了确保始终只有一个所有者， *rust 将值移动到这个新变量*中，用`new_event_copy_ref`表示。所以，只要我们把旧变量赋给新事件变量，这个新变量就指向原始事件的内存位置。

从那时起，我们不能使用原始变量，因为它不存在。数据仍然存在，但有了新的所有者。RUST 会立即删除原始变量并清理它。

因此，当我们试图使用变量`new_event`打印原始事件名称时，我们会得到一条错误消息，明确指出`Value borrowed after move.`，所有这些检查都发生在编译期间。所以，我们保证在程序运行时，没有指向无效内存位置的引用。

现在让我们看看第三条规则。

# 超出范围的变量会被自动删除

当一个变量超出范围时，rust 会立即丢弃该变量并清理它。当我们谈到 Rust 没有垃圾收集器时，这就是没有垃圾收集器的情况。

因此，只有当变量在作用域内时，才能使用变量并引用它的内存位置。让我们举个例子来理解这一点。

我们先来理解一个‘作用域块’。(如果您来自另一种编程语言，上面的代码可能会有点不同)。

作用域是由左大括号和右大括号表示的块。`{}`。它可以嵌套在一个函数中，也可以是一个完全有自己作用域的新函数调用。在上面的例子中，我们在内部作用域中创建了一个事件。

第三条规则规定，一旦内部作用域结束，变量`new_event`及其数据将立即被删除。

根据这个逻辑和我们第二个规则的例子，我们会猜测编译器在这种情况下会报错。这次我们是对的。下面是这个程序编译时出现的错误。

```
error[E0425]: cannot find value `new_event` in this scope
  --> analytix/core/src/models.rs:49:71
   |
49 |         println!("Original event name is {} . New Event Name is {}" , new_event.name , new_event_copy_ref.name)
   |                                                                       ^^^^^^^^^ not found in this scope
```

不出所料，在作用域中没有找到这个变量。

这三条规则是 Rust 所有权系统的基础，也是理解共享状态、并发和内存管理等更复杂场景的良好起点。

内存管理的复杂性留给了语言，我们作为开发人员遵循这些规则来编写干净、高效的代码(这在开始时并不容易，但会越来越好)。

通过遵循这些规则，rust 不仅保证了开发人员的内存安全，还使他们成为更好的程序员。除此之外，它还使程序的性能提高到接近 C++的水平，而没有复杂的内存管理。

在我使用 Rust 的几个月里，我在处理这些规则时遇到了很多障碍。最终，我找到了一种真正考虑简化内存模型和代码的方法(尽管我还有很长的路要走。)我还是会说我是个生锈的新手。但是我很喜欢！

```
**Want to Connect?**Originally published at [https://shanmukhsista.com](https://shanmukhsista.com/understanding-rust-ownership-model-by-example/)
```