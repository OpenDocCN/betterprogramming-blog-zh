<html>
<head>
<title>Native or NumPy —Which Should You Choose?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Native或NumPy—您应该选择哪个？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/native-or-numpy-which-should-you-choose-d30377f2f7e9?source=collection_archive---------15-----------------------#2020-01-20">https://betterprogramming.pub/native-or-numpy-which-should-you-choose-d30377f2f7e9?source=collection_archive---------15-----------------------#2020-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a317" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">NumPy不是最佳选择的情况</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/85143d23647616812ca00b1e85e19b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJ6-SZXqS_BAAb8691MJ7Q.jpeg"/></div></div></figure><p id="f9f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于使用原生集合数据类型的初学者来说，Python非常直观。随着代码越来越高级，运行时间也越来越长。这篇文章将比较Python中的原生数组和NumPy数组的速度。</p><p id="fa23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先:如果大小保持较小，使用原生数据结构可能更容易。每当我有一个想法要在我的沙箱中测试，并且它涉及一个包含十个元素的列表时，我就使用原生数据结构。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="5b23" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">让我们准备做一些编码</h1><p id="44d5" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">为了比较NumPy和本机数组，让我们构建一些代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="6d07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这段代码创建了两个数组——一个原生python数组和一个NumPy对象。它们都包含从0到9的整数元素。我还导入了时间模块——我们稍后会讲到。</p><h2 id="faee" class="mw ly it bd lz mx my dn md mz na dp mh ld nb nc mj lh nd ne ml ll nf ng mn nh bi translated">如何求速度差</h2><p id="adf6" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">很简单。我们只需使用时间模块，找出两个时刻之间的差异:执行代码块之前的时刻和之后的时刻。我使用<code class="fe ni nj nk nl b">perf_counter_ns()</code>函数代替<code class="fe ni nj nk nl b">time()</code>,因为我想要尽可能高的精度。请注意，一秒是10亿分之一秒。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="nm nn gj gh gi no np bd b be z dk translated">这样我们可以测量持续时间。整洁！</p></figure><p id="52fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们必须在这两个时刻之间放置一些代码。测试时，我将改变数组长度和不同的数组方法，其他什么都不做。</p><p id="e700" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nq">注意:我的电脑目前使用AMD锐龙5作为CPU。根据您的CPU，您的结果可能会有所不同。</em></p><h2 id="b04f" class="mw ly it bd lz mx my dn md mz na dp mh ld nb nc mj lh nd ne ml ll nf ng mn nh bi translated">测试1:打印功能</h2><p id="59c1" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">可能每个人都使用print函数来调试或者简单地显示数组的内容。让我们看看它在各种数组大小下的表现。为了便于阅读，持续时间被转换为秒。</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="fa63" class="mw ly it nl b gy nv nw l nx ny">+------------+-------------------+------------------+<br/>| Array size | Duration (Native) | Duration (NumPy) |<br/>+------------+-------------------+------------------+<br/>|         10 |         0.0002097 |        0.0001529 |<br/>|      1 000 |         0.0096579 |        0.0134756 |<br/>|  1 000 000 |          9.481898 |       10.7749533 |<br/>+------------+-------------------+------------------+</span></pre><p id="7bcf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于较大的阵列，本机阵列似乎表现更好。否则，差异是不存在的。</p><h2 id="c76b" class="mw ly it bd lz mx my dn md mz na dp mh ld nb nc mj lh nd ne ml ll nf ng mn nh bi translated">测试2:求算术平均值</h2><p id="8a8d" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">让我们做一些计算。为了找到Python数组中的平均值，我们必须找到所有元素的总和，然后除以元素的数量。在NumPy中，我们可以用同样的方式来做<em class="nq">或</em>我们可以简单地使用<code class="fe ni nj nk nl b">mean()</code>函数。</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="1845" class="mw ly it nl b gy nv nw l nx ny">native_mean = sum(native_lst)/len(native_lst)</span><span id="34de" class="mw ly it nl b gy nz nw l nx ny">numpy_mean1 = numpy_lst.sum()/numpy_lst.size<br/>numpy_mean2 = numpy_lst.mean()</span></pre><p id="d7cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们会记录下这三次的持续时间。方法发现<code class="fe ni nj nk nl b">numpy_mean1</code>被标记为<em class="nq"> Dur。(NumPy 1) </em>”而对于<code class="fe ni nj nk nl b">numpy_mean2</code>则是“<em class="nq"> Dur。(NumPy 2) </em>”。</p><p id="f33d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于持续时间很短，下表使用纳秒作为时间单位。</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="c505" class="mw ly it nl b gy nv nw l nx ny">+------------+---------------+----------------+----------------+<br/>| Array size | Dur. (Native) | Dur. (NumPy 1) | Dur. (NumPy 2) |<br/>+------------+---------------+----------------+----------------+<br/>|         10 |          2400 |          80000 |         100600 |<br/>|      1 000 |         15000 |          61000 |          95100 |<br/>|  1 000 000 |      49311000 |         737000 |        1233100 |<br/>+------------+---------------+----------------+----------------+</span></pre><p id="96de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">哇！我们至少可以观察到三点:</p><ul class=""><li id="4bba" class="oa ob it kw b kx ky la lb ld oc lh od ll oe lp of og oh oi bi translated">随着数组大小的增加，本机方法的速度会变慢。可以说，在某个时刻，如果数组的大小增长了10倍，那么要找到所有元素的平均值就要多花10倍的时间。</li><li id="1ce5" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated">在处理小数组时，处理NumPy数组要花长得多的时间。编码时的时间损失也暴露出来了——导入NumPy和初始化NumPy数组可能需要一秒多的时间。</li><li id="a3f7" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated">第一种NumPy方法比第二种方法快。对我来说，这是不直观的:两个函数调用比一个多，我期望<code class="fe ni nj nk nl b">mean()</code>函数做同样的事情，但是更快。</li></ul></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="2aba" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">结论:什么时候应该使用NumPy？</h1><p id="90bc" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">毫无疑问，使用NumPy很有诱惑力。但是，在处理小型数组时，最好使用原生数组。可能大多数人都想知道确切的数组大小，但最好忘记那些本机数据结构，而使用NumPy，即它们执行相同功能时的数组大小。</p><p id="2148" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了估计这个大小，我进行了反复试验，并使用了本文中的第二个测试。在这个测试中，我使用了更快的NumPy方法(第一种)。</p><h2 id="598e" class="mw ly it bd lz mx my dn md mz na dp mh ld nb nc mj lh nd ne ml ll nf ng mn nh bi translated">击鼓…结果！</h2><p id="9a85" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">根据我的结果，当数组大小在4000–5000左右时会出现这种情况。</p><p id="ff2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果这篇文章中有什么引起了你的注意并且值得一提的，请在评论区发表。其他测试方法也是受欢迎的——特别是如果它们显示出小型NumPy阵列性能更好的结果。</p></div></div>    
</body>
</html>