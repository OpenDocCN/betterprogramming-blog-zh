<html>
<head>
<title>5 Swift Extensions to Generate Randoms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生成随机数的5个Swift扩展</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-swift-extensions-to-generate-randoms-87401ccc60f?source=collection_archive---------7-----------------------#2021-11-24">https://betterprogramming.pub/5-swift-extensions-to-generate-randoms-87401ccc60f?source=collection_archive---------7-----------------------#2021-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ab3b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Swift扩展生成随机数、字符等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/01f0cefa9dd19ff189a172d9cd99cc55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AP5-RpksrlNnPxJwmki_vg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚历杭德罗·加雷在<a class="ae ky" href="https://unsplash.com/s/photos/bingo-balls?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="f1a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个主要行业定期使用随机数。游戏产业和密码产业。所以我想把一系列随机数程序放在一起可能会成为一篇有趣的文章—</p><p id="1b18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我把生成随机数的代码留给你，因为你肯定已经知道了，让我们开始吧，还有更多。展示的大多数扩展都是加密安全的，苹果的<a class="ae ky" href="https://developer.apple.com/documentation/swift/systemrandomnumbergenerator" rel="noopener ugc nofollow" target="_blank">手册页</a>上有警告——警告说——加密质量可能会因平台而异。</p><h1 id="1343" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">随机字符</h1><p id="4d29" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">除了Int、Double和Bool randoms之外，我还需要一个随机字符，下面是一个扩展:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="f748" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">随机字符串</h1><p id="91d1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">众所周知，swift中的字符不是字符串，所以这里有一个例程来返回一个随机字符串[一个或多个字符，是的，这很混乱]。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="68a9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">自源随机字符串</h1><p id="070c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，也许你想提供你自己的字符串并得到一个随机选择。这里有几个扩展可以做到这一点。第一个接受一个字符串数组。第二个接受单个字符串。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="486b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是对同一件事的另一种理解——以不同的方式。如你所见，这需要一个字符串数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="f0ce" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">唯一的随机字符串</h1><p id="efc9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当然，如果上面的例程两次传递相同的字符串，那就没什么好说的了——也许这不是您想要的。这个扩展从字符串中移除每个随机出现的元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="8d85" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">整数范围内没有对等重复项</h1><p id="f894" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">回到数字，这里有一个例程返回给定范围内的整数，防止连续两次返回相同的数字。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="e6e3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">范围内唯一的整数</h1><p id="ce37" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个例程返回一个范围内唯一的整数，将每个使用过的整数添加到一个集合中，防止将同一个整数返回两次。一旦范围用尽，它将重置并重新开始。但是请注意，这是一个不确定的算法，这意味着返回一个数字所需的时间会有所不同，范围越大，变化越大。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="70df" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">范围II内的唯一整数</h1><p id="6ddc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个例程返回一个集合中的整数，用这些整数更新第二个集合。与前一个非常相似，只是这是一个确定性算法，因为它使用时间复杂度为O(n)的混洗集。范围越大，花费的时间就越长，但与前一个不同，你可以肯定时间长度将是集合大小的一个因素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，对于前面的三种方法，您不仅仅必须使用整数，您还可以扩展双精度或浮点，甚至可以使用一些字符串方法，将它们作为模板使用——具有相同的结果/限制。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="19d8" class="lv lw it bd lx ly nb ma mb mc nc me mf jz nd ka mh kc ne kd mj kf nf kg ml mm bi translated">游戏包</h1><p id="ad9d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Bon，一个好的开始——但是你知道GameKit有它自己版本的随机数生成代码例程吗？对游戏来说很好的数字，但对密码术来说不是。本示例创建一个介于0和20之间的随机数。尽管事先警告过，Apple在手册页中告诉我们，如果您需要确保每次运行时都得到随机数，则需要删除生成的初始值，请使用arc4.drop(1024)来这样做。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="0c94" class="nl lw it nh b gy nm nn l no np">let arc4 = GKARC4RandomSource()<br/>let t = arc4.nextInt(upperBound: 20)</span></pre><p id="ecc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，但是由于随机性对游戏来说是至关重要的，你可以在这里做更多的事情，调用这个例程来得到一个更随机的随机数。虽然会比上一部慢一点。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="ec92" class="nl lw it nh b gy nm nn l no np">let mersenne = GKMersenneTwisterRandomSource()<br/>mersenne.nextInt(upperBound: 20)</span></pre><p id="b3c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，有一个方法可以得到一个比前面两个更快的随机数，也就是这个。虽然有代价，但是会少一些随意性。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="e5f3" class="nl lw it nh b gy nm nn l no np">let arc4b = GKLinearCongruentialRandomSource()<br/>let u = arc4.nextInt(upperBound: 20)</span></pre><p id="d9a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">mais——还有更多。你看，如果你掷一个真正的骰子，有可能一次又一次地得到相同的值，这是伪生成器试图避免的。所以如果你想要一些更真实的东西，你可以使用分布。此处显示的随机分布确保您确信序列不太频繁。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="2a6b" class="nl lw it nh b gy nm nn l no np">let rand = GKShuffledDistribution(forDieWithSideCount: 6)<br/>let distribution = GKRandomDistribution(randomSource: rand, lowestValue: 0, highestValue: 20)</span></pre><p id="cc69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个版本中，您确保了结果是一个钟形曲线，因此您的范围内的中间值将比最高值或最低值出现得更频繁。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="6641" class="nl lw it nh b gy nm nn l no np">let rand2 = GKGaussianDistribution(forDieWithSideCount: 6)<br/>let distribution2 = GKRandomDistribution(randomSource: rand2, lowestValue: 0, highestValue: 20)</span></pre><h2 id="19b4" class="nl lw it bd lx nq nr dn mb ns nt dp mf li nu nv mh lm nw nx mj lq ny nz ml oa bi translated">随机的不是随机的</h2><p id="98b9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">还有什么比随机游戏更好的地方来结束随机游戏呢？在这段代码中，你可以看到两个种子。当您使用第一个时，它会生成相同的随机数序列，这对于测试来说非常好。当你使用第二种方法时，你会得到一个不同的随机数序列，每次都是一个随机序列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="4a6f" class="lv lw it bd lx ly nb ma mb mc nc me mf jz nd ka mh kc ne kd mj kf nf kg ml mm bi translated">安全随机数</h1><p id="b601" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后，我不得不用这段代码来结束这篇文章——我承认这段代码不是我写的，而是在这篇关于这个主题的优秀文章中找到的。你确实可以用一个随机整数作为你的密码，当然这不是你自己写的——你用CryptKit就像任何一个正常人会做的那样——</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b213" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些使我想到了本文的结尾。我希望你发现了一些有用的东西和/或确实学到了一些东西。</p></div></div>    
</body>
</html>