<html>
<head>
<title>Why You Should Stop Using ActiveModel Validations in Ruby on Rails</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该停止在Ruby on Rails中使用ActiveModel验证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-you-should-stop-using-activemodel-validations-in-ruby-on-rails-6099047776e4?source=collection_archive---------13-----------------------#2022-09-12">https://betterprogramming.pub/why-you-should-stop-using-activemodel-validations-in-ruby-on-rails-6099047776e4?source=collection_archive---------13-----------------------#2022-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2249" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于交换优势的深入指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/e60f8174810f03b6bd7d07fefd227b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*l9Dai-V8PaNvG6J4anJG6g.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图片来自imgflip</p></figure><p id="f6ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Ruby on Rails在很多方面都很棒，正如你们中的很多人所知道的，模型中的验证很酷，因为它们简单、实现快速、易于测试。</p><p id="62cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是他们也很差劲。</p><p id="142a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">注意:只有在使用PostgreSQL的情况下，本文才是可行的。如果你正在使用SQLite或MySQL，停止。</em></p><h1 id="bf7b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">它们是什么？</h1><p id="cd1f" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">验证是像<code class="fe ml mm mn mo b"><a class="ae mp" href="https://guides.rubyonrails.org/active_record_validations.html#validations-overview" rel="noopener ugc nofollow" target="_blank">validates</a></code>、<code class="fe ml mm mn mo b"><a class="ae mp" href="https://guides.rubyonrails.org/active_record_validations.html#validates-associated" rel="noopener ugc nofollow" target="_blank">validates_associated</a></code>这样的方法，它将根据一些逻辑(可以是惟一性、字符串格式或您自己的定制逻辑)检查实例，并允许或不允许它插入数据库。</p><p id="5821" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用模型验证有很多缺点。让我们一起来看看他们吧！</p><h1 id="40b9" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">它只在Rails层可行</h1><p id="95d3" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">假设您的数据库由几个团队共享。您的数据团队直接插入到您的主数据库中，或者其他系统可以不通过您的API与数据库进行交互。因此，您的验证和回调将被绕过，您的数据库中的数据可能对RDBMS(例如Postgresql)有效，但对rails应用程序无效。它会“悄悄地”瘫痪你的系统。</p><h1 id="f72a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">一旦实现了验证规则，就改变它们是不安全的</h1><p id="4e3b" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">如果开发人员添加或更改任何验证规则，可能会在新旧数据库规则之间产生差异。以前认为有效的记录现在会被认为是无效的，没有任何警告！这可能会使整个数据库失效，如果数据库进入生产环境，则需要紧急回滚。</p><p id="47f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">“好吧，我看这事可麻烦了。你建议我们做些什么来解决这个问题？”</p><p id="e988" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然是PostgreSQL的约束！</p><h1 id="bd29" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">一个基本的例子——让我们把手弄脏吧！</h1><h2 id="a262" class="mq lp iq bd lq mr ms dn lu mt mu dp ly la mv mw ma le mx my mc li mz na me nb bi translated">它们是什么？</h2><p id="b8f8" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">应用于数据库模式以插入值的“规则”(如验证)。</p><p id="e9e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一个简单的例子，看看如何将一个简单的验证规则转换成一个约束。</p><ul class=""><li id="d828" class="nc nd iq kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated">让我们建立一个快速项目来使用这段代码:</li></ul><pre class="kg kh ki kj gt nl mo nm nn aw no bi"><span id="1cbf" class="mq lp iq mo b gy np nq l nr ns">rails new constraint_example --database=postgresql</span></pre><ul class=""><li id="b5c5" class="nc nd iq kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated">光盘放入其中:</li></ul><pre class="kg kh ki kj gt nl mo nm nn aw no bi"><span id="3f93" class="mq lp iq mo b gy np nq l nr ns">cd constraint_example</span></pre><ul class=""><li id="efbe" class="nc nd iq kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated">对于这个例子，我们需要一个模型。姑且称之为<code class="fe ml mm mn mo b">User</code>(我知道，多么原创)。</li></ul><pre class="kg kh ki kj gt nl mo nm nn aw no bi"><span id="ef84" class="mq lp iq mo b gy np nq l nr ns">bin/rails generate model User email:string age:integer</span></pre><p id="1fdf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的命令应该会创建一个如下所示的迁移文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="918b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在发射<code class="fe ml mm mn mo b">bin/rails db:create db:migrate</code>。这将从迁移中创建数据库和用户表。</p><p id="dc6c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来参观一下用户模型！</p><p id="d850" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">默认情况下，它应该几乎为空:</p><pre class="kg kh ki kj gt nl mo nm nn aw no bi"><span id="2aa1" class="mq lp iq mo b gy np nq l nr ns">class User <!-- -->&lt; ApplicationRecord<br/>end</span></pre><p id="5ffb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要改变它，所以我们所有的用户都有独特的电子邮件。对于rails验证，它看起来像这样:</p><pre class="kg kh ki kj gt nl mo nm nn aw no bi"><span id="d277" class="mq lp iq mo b gy np nq l nr ns">class User <!-- -->&lt; ApplicationRecord<br/>  validates :email, uniqueness: true<br/>end</span></pre><p id="1768" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将告诉rails在创建或更新一个<code class="fe ml mm mn mo b">User</code>记录之前检查整个<code class="fe ml mm mn mo b">users</code>表中的所有电子邮件，看看它是否已经存在。</p><p id="0975" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们创造我们的第一个<code class="fe ml mm mn mo b">User</code>记录吧！</p><p id="b301" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">1.启动一个rails控制台:<code class="fe ml mm mn mo b">bin/rails c</code></p><p id="e6f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.创建一个简单的用户:<code class="fe ml mm mn mo b">User.create(email: ‘simple@example.com', age: 42)</code></p><p id="a468" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.看看rails控制台日志告诉你什么。我们应该有如下所示的日志:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="bd99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看到第二行了吗？由于我们在<code class="fe ml mm mn mo b">app/models/user.rb</code>中的验证规则，Rails将执行一个查询来检查DB中是否存在记录。</p><p id="5bf0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Rails发现没有记录被返回，所以它创建一个记录并返回新创建的实例！很好，我们可以说。</p><p id="032d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，这样一个结果的这么少的代码是令人敬畏的！那么，有什么问题呢？</p><p id="9c08" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有一个查询，每次在没有索引的列上创建或更新新用户时都会启动这个查询。如果您的数据库扩展并接受数百万条<code class="fe ml mm mn mo b">User</code>记录，这可能会导致<code class="fe ml mm mn mo b">INSERTS</code>比它们需要的慢很多，因为它们总是在没有索引的列上加上一个<code class="fe ml mm mn mo b">SELECT</code>。这是第一个问题。</p><p id="dcb0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二个问题是，只有当您试图通过rails应用程序创建/更新记录时，才会执行这个查询。如果有其他应用程序会在同一个数据库上创建数据，它们会忽略rails验证，因为它们不知道。假设我们直接从数据库中用同一封电子邮件创建第二条记录:</p><ol class=""><li id="baca" class="nc nd iq kt b ku kv kx ky la ne le nf li ng lm nv ni nj nk bi translated">访问您的数据库:<code class="fe ml mm mn mo b">psql -d constraint_example_development</code></li><li id="24be" class="nc nd iq kt b ku nw kx nx la ny le nz li oa lm nv ni nj nk bi translated">创建另一个记录:</li></ol><pre class="kg kh ki kj gt nl mo nm nn aw no bi"><span id="af1d" class="mq lp iq mo b gy np nq l nr ns">INSERT INTO users (id, email, age, created_at, updated_at) VALUES (2, '<a class="ae mp" href="mailto:simple@example.com" rel="noopener ugc nofollow" target="_blank">simple@example.com</a>', 25, '2022-09-10 11:19:20.755912', '2022-09-10 11:19:20.755912');</span></pre><p id="6590" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于是在数据库级别，Postgres绕过了Rails层，跳过了Rails验证。第二条记录已成功创建。</p><p id="f836" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.现在，回到rails控制台:<code class="fe ml mm mn mo b">bin/rails c</code></p><p id="b999" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">4.让我们更新我们的第一个用户的年龄！<code class="fe ml mm mn mo b">User.first.update!(age: 53)</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ee05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看最后一行:</p><pre class="kg kh ki kj gt nl mo nm nn aw no bi"><span id="cc75" class="mq lp iq mo b gy np nq l nr ns">/Users/yorick/.rvm/gems/ruby-2.7.4/gems/activerecord-7.0.3.1/lib/active_record/validations.rb:80:in `raise_validation_error': Validation failed: Email has already been taken (ActiveRecord::RecordInvalid)</span></pre><p id="2f30" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有一个错误告诉我们，该电子邮件是无效的，但我们没有改变它的电子邮件！</p><p id="38d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Rails不在乎。</p><p id="9031" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果只有rails拥有数据库的键，并且您从未打算通过rails之外的其他方式操作数据，那么rails验证是一种“可接受的”方式。</p><p id="eb7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们换一种方式尝试一下——使用PostgreSQL的约束和索引！</p><ol class=""><li id="5616" class="nc nd iq kt b ku kv kx ky la ne le nf li ng lm nv ni nj nk bi translated">让我们创建一个迁移:<code class="fe ml mm mn mo b">bin/rails g migration AddEmailConstraintToUsers</code></li><li id="aae6" class="nc nd iq kt b ku nw kx nx la ny le nz li oa lm nv ni nj nk bi translated">对于这样一个简单的例子，我们可以用rails的方式:</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a8f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我知道，我一直在说约束，但是为什么我们在这里用<code class="fe ml mm mn mo b">add_index</code>？创建一个<code class="fe ml mm mn mo b">unique_constraint</code>和创建一个<code class="fe ml mm mn mo b">unique_index</code>是一样的。基于<a class="ae mp" href="https://www.postgresql.org/docs/current/indexes-unique.html#:~:text=PostgreSQL%20automatically%20creates%20a%20unique,mechanism%20that%20enforces%20the%20constraint." rel="noopener ugc nofollow" target="_blank">官方PostgreSQL文档</a>:</p><blockquote class="ob oc od"><p id="4983" class="kr ks ln kt b ku kv jr kw kx ky ju kz oe lb lc ld of lf lg lh og lj lk ll lm ij bi translated">当为表定义唯一约束或主键时，PostgreSQL会自动创建唯一索引。索引覆盖了构成主键或唯一约束的列(如果合适，可以是多列索引)，并且是实施约束的机制。</p></blockquote><p id="c984" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，创建唯一约束与创建唯一索引是一样的。</p><p id="4b37" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还记得每次我们想要创建或更新记录时，Rails是如何查询的吗？Postgres现在也将自己做同样的事情，但由于有了索引，速度会更快。</p><p id="f127" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好了，现在让我们运行迁移！</p><p id="1d04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ml mm mn mo b">bin/rails db:migrate</code></p><p id="a4b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看起来我们有一个错误，如下所示:</p><pre class="kg kh ki kj gt nl mo nm nn aw no bi"><span id="6acc" class="mq lp iq mo b gy np nq l nr ns">Caused by:<br/>PG::UniqueViolation: ERROR:  could not create unique index "index_users_on_email"<br/>DETAIL:  Key (email)=(<a class="ae mp" href="mailto:simple@example.com" rel="noopener ugc nofollow" target="_blank">simple@example.com</a>) is duplicated.<br/>/Users/yorick/Work/constraint_ecample/db/migrate/20220910115344_add_email_constraint_to_users.rb:3:in `change'<br/>Tasks: TOP =&gt; db:migrate<br/>(See full trace by running task with --trace)</span></pre><p id="7aea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如文件<a class="ae mp" href="https://www.postgresql.org/docs/current/indexes-unique.html#:~:text=PostgreSQL%20automatically%20creates%20a%20unique,mechanism%20that%20enforces%20the%20constraint." rel="noopener ugc nofollow" target="_blank">所说:</a></p><blockquote class="ob oc od"><p id="a3a6" class="kr ks ln kt b ku kv jr kw kx ky ju kz oe lb lc ld of lf lg lh og lj lk ll lm ij bi translated">当索引被声明为unique时，不允许多个表行具有相同的索引值</p></blockquote><p id="556b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着我们必须在添加约束之前进行清理。当您希望将来迁移到PG约束时，这是您必须考虑的事情</p><p id="ebdc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们用下面的代码进行清理:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="36ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，使用<code class="fe ml mm mn mo b">bin/rails db:migrate</code>启动迁移。</p><p id="bd74" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们回到<code class="fe ml mm mn mo b">app/models/user.rb</code>，删除我们添加的验证:</p><pre class="kg kh ki kj gt nl mo nm nn aw no bi"><span id="3104" class="mq lp iq mo b gy np nq l nr ns">class User &lt; ApplicationRecord</span><span id="238c" class="mq lp iq mo b gy oh nq l nr ns">end</span></pre><p id="602e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们回到Rails控制台，添加以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">“创建前选择”已消失。</p></figure><p id="06a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Rails不再独立进行查询，因为它不再知道这个约束。验证记录创建的工作留给了Postgres。</p><p id="8c70" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了方便起见，让我们试着验证一下，我们不能用同一个电子邮件创建第二个用户。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">它仍然引发ActiveRecord::RecordNotUnique，因为ActiveRecord将捕获PG的PG::UniqueViolation</p></figure><p id="55c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们尝试在PostgreSQL级别创建一个副本。</p><ol class=""><li id="ea87" class="nc nd iq kt b ku kv kx ky la ne le nf li ng lm nv ni nj nk bi translated">启动psql控制台:</li></ol><pre class="kg kh ki kj gt nl mo nm nn aw no bi"><span id="a09e" class="mq lp iq mo b gy np nq l nr ns">psql -d test_app_development</span></pre><p id="9674" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.尝试创建重复记录:</p><pre class="kg kh ki kj gt nl mo nm nn aw no bi"><span id="39a9" class="mq lp iq mo b gy np nq l nr ns">INSERT INTO users (id, email, age, created_at, updated_at) VALUES (1, '<a class="ae mp" href="mailto:simple@example.com" rel="noopener ugc nofollow" target="_blank">simple@example.com</a>', 42, '2022-09-10 11:19:20.755912', '2022-09-10 11:19:20.755912');<br/>ERROR:  duplicate key value violates unique constraint "index_users_on_email"<br/>DETAIL:  Key (email)=(<a class="ae mp" href="mailto:simple@example.com" rel="noopener ugc nofollow" target="_blank">simple@example.com</a>) already exists.</span></pre><p id="7bb3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有用！您已经创建了一个简单的约束，它比Rails的验证更快、更安全！</p></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h1 id="2cc6" class="lo lp iq bd lq lr op lt lu lv oq lx ly jw or jx ma jz os ka mc kc ot kd me mf bi translated">使用PG约束的缺点——以及如何应对它们</h1><p id="5b53" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我在本文开头提到了Rails验证的缺点。现在让我们尝试对PostgreSQL约束做同样的事情。</p><h2 id="d1c2" class="mq lp iq bd lq mr ms dn lu mt mu dp ly la mv mw ma le mx my mc li mz na me nb bi translated">它混淆了数据模型的一些关键逻辑概念</h2><p id="d7da" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">要知道一个模型的约束，您必须深入到<code class="fe ml mm mn mo b">schema.rb</code>中，看看它是否有任何验证。对于大型应用程序，有一个长达一千行并且不太容易理解的<code class="fe ml mm mn mo b">schema.rb</code>文件是很正常的。</p><p id="37b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了补救这一点，我建议将令人敬畏的<code class="fe ml mm mn mo b"><a class="ae mp" href="https://github.com/ctran/annotate_models" rel="noopener ugc nofollow" target="_blank">annotate</a></code>宝石添加到您的宝石档案中的<code class="fe ml mm mn mo b">development</code>组:</p><pre class="kg kh ki kj gt nl mo nm nn aw no bi"><span id="53d6" class="mq lp iq mo b gy np nq l nr ns">group :development do</span><span id="592b" class="mq lp iq mo b gy oh nq l nr ns">...<br/>  gem 'annotate'<br/>  ...<br/>end</span></pre><p id="fd04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，跑<code class="fe ml mm mn mo b">bundle install</code>，紧随其后</p><pre class="kg kh ki kj gt nl mo nm nn aw no bi"><span id="7cae" class="mq lp iq mo b gy np nq l nr ns">bin/rails g annotate:install</span></pre><p id="a320" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后运行<code class="fe ml mm mn mo b">bundle exec annotate</code>，如下图所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">annotate有关于模型的注释，非常有用！</p></figure><p id="3e6f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ml mm mn mo b">annotate</code> gem将跟踪对表的更改，并在表模型的顶部打印一个列、索引和约束的列表。</p><h2 id="ac2c" class="mq lp iq bd lq mr ms dn lu mt mu dp ly la mv mw ma le mx my mc li mz na me nb bi translated">更改约束需要迁移</h2><p id="d4f0" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">因为它在您的数据库模式中，所以您不能再通过简单的提交来更改规则，就是这样。您必须创建一个迁移；如果某些数据不符合约束，迁移将会失败。有些人会认为这是使用PG约束的一个陷阱，但我会说这甚至更好。</p></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><p id="2d1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文以唯一约束为例，但是也可以添加其他约束，比如检查约束、非空约束等等。您可以在官方的<a class="ae mp" href="https://www.postgresql.org/docs/current/ddl-constraints.html" rel="noopener ugc nofollow" target="_blank"> PostgreSQL文档中了解更多关于约束</a>的信息。基本上所有可以用ActiveRecord验证完成的事情都可以通过PostgreSQL约束来完成！</p></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><p id="78f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">接下来的</strong>:为什么以及如何在Ruby on Rails中去掉<code class="fe ml mm mn mo b">ActiveRecord</code>回调！敬请期待😁。</p></div></div>    
</body>
</html>