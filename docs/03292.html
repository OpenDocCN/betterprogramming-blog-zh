<html>
<head>
<title>JavaScript Ellipses: The Spread and Rest Syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript省略号:Spread和Rest语法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-ellipses-the-spread-and-rest-syntax-c12df294548d?source=collection_archive---------2-----------------------#2020-02-02">https://betterprogramming.pub/javascript-ellipses-the-spread-and-rest-syntax-c12df294548d?source=collection_archive---------2-----------------------#2020-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dcf3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">现代JavaScript的实用简写</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5be25385760c85a4f632ce42cb53c252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4RCeQcyUGxCBDfD8"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@claudelrheault?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Claudel Rheault </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="ce54" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">输入Javascript省略号(…)</h1><p id="4011" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现代JavaScript允许我们使用三个点，<code class="fe mn mo mp mq b">…</code>，也称为省略号，来执行某些转换和速记方法。省略号的使用分为两类:<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank">休止语法</a>和<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">展开语法</a>。我将依次解释这些。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="b60e" class="kz la it bd lb lc my le lf lg mz li lj jz na ka ll kc nb kd ln kf nc kg lp lq bi translated">Rest语法</h1><p id="7e03" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Rest语法允许程序员检索集合中程序员没有使用过的剩余项——项的<em class="nd">rest</em>——例如对象、数组或函数参数。</p><p id="02cb" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma ng mc md me nh mg mh mi ni mk ml mm im bi translated">让我们来看几个例子。</p><h2 id="988b" class="nj la it bd lb nk nl dn lf nm nn dp lj ma no np ll me nq nr ln mi ns nt lp nu bi translated">带有对象解构的Rest语法</h2><p id="1619" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现代JavaScript允许我们解构对象。也就是说，我们可以从一个现有的对象中快速定义变量并给它们赋值。这里有一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4788" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma ng mc md me nh mg mh mi ni mk ml mm im bi translated">在这个例子中，我们首先定义一个对象。然后，使用对象解构，我们从我们的对象中取出定义变量<code class="fe mn mo mp mq b">c</code>和<code class="fe mn mo mp mq b">d</code>，并分别给它们赋值。然后可以使用变量<code class="fe mn mo mp mq b">c</code>和<code class="fe mn mo mp mq b">d</code>，正如我们在解构后的日志行中看到的。</p><p id="a403" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma ng mc md me nh mg mh mi ni mk ml mm im bi translated">使用“rest”语法，我们可以获得对象中未被显式解构的剩余项，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f6d2" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma ng mc md me nh mg mh mi ni mk ml mm im bi translated">正如你所看到的，在从<code class="fe mn mo mp mq b">obj</code>中解构<code class="fe mn mo mp mq b">c</code>和<code class="fe mn mo mp mq b">d</code>之后，我们解构了<code class="fe mn mo mp mq b">…restOfObj</code>，它被赋予了一个新对象的值，该对象具有来自<code class="fe mn mo mp mq b">obj</code>的所有键，除了那些被显式使用的键。需要注意的是，<code class="fe mn mo mp mq b">rest</code>语法必须用在一个解构的结尾，并且由前面的变量名来表示，在这个例子中是<code class="fe mn mo mp mq b">restOfObj</code>，带有一个省略号(<code class="fe mn mo mp mq b">…</code>)。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="9ae4" class="kz la it bd lb lc my le lf lg mz li lj jz na ka ll kc nb kd ln kf nc kg lp lq bi translated">带有数组解构的Rest语法</h1><p id="db10" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现代JavaScript也允许我们解构数组。这里有一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f11f" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma ng mc md me nh mg mh mi ni mk ml mm im bi translated">这里，我们首先定义一个数组，并将其赋给变量<code class="fe mn mo mp mq b">arr</code>。然后，我们解构数组，取出前三项，并将它们分配给变量<code class="fe mn mo mp mq b">firstItem</code>、<code class="fe mn mo mp mq b">secondItem</code>和<code class="fe mn mo mp mq b">thirdItem</code>。如您所见，数组的第一个值赋给了解构中定义的第一个变量，第二个值赋给了第二个变量，依此类推。</p><p id="5303" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma ng mc md me nh mg mh mi ni mk ml mm im bi translated">使用<code class="fe mn mo mp mq b">rest</code>语法，我们可以取出数组中的前几项，然后将剩余的项分配给一个新数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="2aae" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma ng mc md me nh mg mh mi ni mk ml mm im bi translated">如您所见，通过使用<code class="fe mn mo mp mq b">rest</code>语法，我们已经创建了一个名为<code class="fe mn mo mp mq b">restOfArr</code>的变量，并为其分配了一个新数组，其中包含来自<code class="fe mn mo mp mq b">arr</code>的未被显式解构的剩余项。如同<code class="fe mn mo mp mq b">rest</code>对象解构的语法一样，<code class="fe mn mo mp mq b">rest</code>数组的语法必须在解构的结尾使用。结尾由前面的变量名表示，在本例中是带省略号(<code class="fe mn mo mp mq b">…</code>)的<code class="fe mn mo mp mq b">restOfArr</code>。</p><h2 id="01a6" class="nj la it bd lb nk nl dn lf nm nn dp lj ma no np ll me nq nr ln mi ns nt lp nu bi translated">带有函数参数的Rest语法</h2><p id="b97d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">函数定义也接受定义参数的<code class="fe mn mo mp mq b">rest</code>语法，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="3fca" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma ng mc md me nh mg mh mi ni mk ml mm im bi translated">如您所见，我们已经定义了函数参数<code class="fe mn mo mp mq b">a</code>、<code class="fe mn mo mp mq b">b</code>和<code class="fe mn mo mp mq b">c</code>。接下来，我们使用一个带有参数名<code class="fe mn mo mp mq b">…restOfProvidedParameters</code>的省略号来分配剩余的参数，并将它们填充到一个数组中。由于第一、第二和第三个参数在函数定义中被显式地使用为<code class="fe mn mo mp mq b">a</code>、<code class="fe mn mo mp mq b">b</code>和<code class="fe mn mo mp mq b">c</code>，所以它们不包含在<code class="fe mn mo mp mq b">restOfProvidedParameters</code>数组中。</p><h2 id="2c5e" class="nj la it bd lb nk nl dn lf nm nn dp lj ma no np ll me nq nr ln mi ns nt lp nu bi translated">Rest语法陷阱</h2><p id="46cc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">顾名思义，<code class="fe mn mo mp mq b">rest</code>语法<em class="nd">不能</em>用于获取对象、数组或参数定义的开始元素。例如，这是不可能的:</p><pre class="kj kk kl km gt nx mq ny nz aw oa bi"><span id="1fe6" class="nj la it mq b gy ob oc l od oe">function (...firstParametersExceptTheLast, lastParameter) {</span><span id="d5b9" class="nj la it mq b gy of oc l od oe">}</span><span id="42bb" class="nj la it mq b gy of oc l od oe">// SyntaxError: Rest parameter must be last formal parameter</span></pre><p id="3cca" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma ng mc md me nh mg mh mi ni mk ml mm im bi translated">同样，it <em class="nd">也不能</em>在中间元素，就像这样:</p><pre class="kj kk kl km gt nx mq ny nz aw oa bi"><span id="0ea6" class="nj la it mq b gy ob oc l od oe">function (firstParameter, ...middleParameters, lastParameter) {</span><span id="8c3f" class="nj la it mq b gy of oc l od oe">}</span><span id="1df6" class="nj la it mq b gy of oc l od oe">// SyntaxError: Rest parameter must be last formal parameter</span></pre></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="fb8d" class="kz la it bd lb lc my le lf lg mz li lj jz na ka ll kc nb kd ln kf nc kg lp lq bi translated">扩展语法</h1><p id="4a85" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Spread语法允许集合(如对象或数组)以一种简化的方式与其他集合或函数进行交互。让我们来看看不同的组合。</p><h2 id="aa71" class="nj la it bd lb nk nl dn lf nm nn dp lj ma no np ll me nq nr ln mi ns nt lp nu bi translated">将数组语法扩展到函数调用</h2><p id="879a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这里我们定义了一个函数和一个长度为<code class="fe mn mo mp mq b">2</code>的数组。然后，我们用字符串<code class="fe mn mo mp mq b">a</code>、展开数组<code class="fe mn mo mp mq b">...arr</code>和字符串<code class="fe mn mo mp mq b">d</code>调用函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="2603" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma ng mc md me nh mg mh mi ni mk ml mm im bi translated">当<code class="fe mn mo mp mq b">fun</code>被调用时，字符串<code class="fe mn mo mp mq b">a</code>首先被提供给<code class="fe mn mo mp mq b">aParam</code>。接下来，<code class="fe mn mo mp mq b">arr</code>就展开了。数组中有两个项目，因此<code class="fe mn mo mp mq b">arr</code>、<code class="fe mn mo mp mq b">b</code>、<code class="fe mn mo mp mq b">c</code>、<code class="fe mn mo mp mq b">bParam</code>和<code class="fe mn mo mp mq b">cParam</code>将获得这些值。当扩展完成时，剩余的字符串值<code class="fe mn mo mp mq b">d</code>被提供给函数的<code class="fe mn mo mp mq b">dParam</code>。</p><h2 id="e569" class="nj la it bd lb nk nl dn lf nm nn dp lj ma no np ll me nq nr ln mi ns nt lp nu bi translated">将数组语法扩展到其他数组</h2><p id="5e11" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">扩展语法也可用于组合数组:</p><pre class="kj kk kl km gt nx mq ny nz aw oa bi"><span id="f5ff" class="nj la it mq b gy ob oc l od oe">const arr1 = [ 'b', 'c' ];<br/>const arr2 = [ 'e', 'f' ];</span><span id="f018" class="nj la it mq b gy of oc l od oe">const combinedArr = [ 'a', ...arr1, 'd', ...arr2, 'g' ];</span><span id="d9f5" class="nj la it mq b gy of oc l od oe">console.log(combinedArr); // [ 'a', 'b', 'c', 'd', 'e', 'f', 'g' ];</span></pre><p id="24d6" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma ng mc md me nh mg mh mi ni mk ml mm im bi translated">这里我们看到两个数组，<code class="fe mn mo mp mq b">arr1</code>和<code class="fe mn mo mp mq b">arr2</code>被定义。我们创建了一个新的数组<code class="fe mn mo mp mq b">combinedArr</code>，在它的创建过程中，我们在其中“传播”<code class="fe mn mo mp mq b">arr1</code>和<code class="fe mn mo mp mq b">arr2</code>。结果是新数组<code class="fe mn mo mp mq b">combinedArr</code>包含了展开数组的值。</p><h2 id="0ee0" class="nj la it bd lb nk nl dn lf nm nn dp lj ma no np ll me nq nr ln mi ns nt lp nu bi translated">将对象的语法扩展到其他对象</h2><p id="df7d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">扩展语法可用于添加和覆盖对象中的键值。规则是最后提供的键值优先。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="34e8" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma ng mc md me nh mg mh mi ni mk ml mm im bi translated">如您所见，我们已经定义了三个对象:<code class="fe mn mo mp mq b">obj1</code>、<code class="fe mn mo mp mq b">obj2</code>和<code class="fe mn mo mp mq b">obj3</code>。然后我们定义了一个新的对象，<code class="fe mn mo mp mq b">combinedObj</code>，并将之前定义的三个对象分布在其中。给定键的最后一个提供的值会覆盖以前提供的值。以下是一些解释:</p><ul class=""><li id="056e" class="og oh it lt b lu ne lx nf ma oi me oj mi ok mm ol om on oo bi translated">关键<code class="fe mn mo mp mq b">a</code>是<code class="fe mn mo mp mq b">1</code>因为虽然在<code class="fe mn mo mp mq b">combinedObj</code>中明确定义为<code class="fe mn mo mp mq b">0</code>，但是<code class="fe mn mo mp mq b">obj1</code>是在明确定义之后展开并覆盖的。</li><li id="e107" class="og oh it lt b lu op lx oq ma or me os mi ot mm ol om on oo bi translated">键<code class="fe mn mo mp mq b">d</code>是<code class="fe mn mo mp mq b">0</code>,因为虽然<code class="fe mn mo mp mq b">obj2</code>被展开并定义为<code class="fe mn mo mp mq b">2</code>,但它随后在<code class="fe mn mo mp mq b">combinedObj</code>内被明确设置为<code class="fe mn mo mp mq b">0</code>。</li><li id="965b" class="og oh it lt b lu op lx oq ma or me os mi ot mm ol om on oo bi translated">Key <code class="fe mn mo mp mq b">f</code>之所以是<code class="fe mn mo mp mq b">0</code>，是因为虽然<code class="fe mn mo mp mq b">obj1</code>、<code class="fe mn mo mp mq b">obj2</code>、<code class="fe mn mo mp mq b">obj3</code>被展开并分别定义和覆盖为<code class="fe mn mo mp mq b">1</code>、<code class="fe mn mo mp mq b">2</code>、<code class="fe mn mo mp mq b">3</code>，但最终还是从<code class="fe mn mo mp mq b">combinedObj</code>内部明确设置为<code class="fe mn mo mp mq b">0</code>。</li></ul><h2 id="ca3c" class="nj la it bd lb nk nl dn lf nm nn dp lj ma no np ll me nq nr ln mi ns nt lp nu bi translated">传播语法附加内容</h2><p id="0d0e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在JavaScript中，数组也是一个对象，因此它也可以扩展到一个对象:</p><pre class="kj kk kl km gt nx mq ny nz aw oa bi"><span id="e0db" class="nj la it mq b gy ob oc l od oe">const arr = [ 'a', 'b', 'c' ];</span><span id="c06b" class="nj la it mq b gy of oc l od oe">const obj = { ...arr };</span><span id="2075" class="nj la it mq b gy of oc l od oe">console.log(obj);<br/>// { 0: 'a', 1: 'b', 2: 'c' }</span></pre><p id="54b3" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma ng mc md me nh mg mh mi ni mk ml mm im bi translated">将一个数组扩展到另一个数组可用于制作数组的浅层副本:</p><pre class="kj kk kl km gt nx mq ny nz aw oa bi"><span id="3222" class="nj la it mq b gy ob oc l od oe">const originalArr = [ 'a', 'b', 'c' ];</span><span id="d69c" class="nj la it mq b gy of oc l od oe">const arrayShallowCopy = [ ...originalArr ];</span><span id="ef85" class="nj la it mq b gy of oc l od oe">arrayShallowCopy[1] = 'overrideShallowCopyValueOnly';</span><span id="dfde" class="nj la it mq b gy of oc l od oe">console.log(originalArr); <br/>// [ 'a', 'b', 'c' ]<br/>// (The value is unchanged)</span><span id="03bc" class="nj la it mq b gy of oc l od oe">console.log(arrayShallowCopy); <br/>// [ 'a', 'overrideShallowCopyValueOnly', 'c' ]</span></pre><h1 id="732a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">传播语法陷阱</h1><p id="a04f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Spread语法不适用于集合到数组、对象和函数的所有组合。这里有一些<em class="nd">不</em>工作:</p><ul class=""><li id="25c9" class="og oh it lt b lu ne lx nf ma oi me oj mi ok mm ol om on oo bi translated">对象不能传播到函数调用</li><li id="53d0" class="og oh it lt b lu op lx oq ma or me os mi ot mm ol om on oo bi translated">对象不能扩展到数组</li></ul></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="b469" class="kz la it bd lb lc my le lf lg mz li lj jz na ka ll kc nb kd ln kf nc kg lp lq bi translated">摘要</h1><p id="7b8c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在Javascript中，省略号(<code class="fe mn mo mp mq b">…</code>)用于两个独立的缩写——rest语法和spread语法。Rest语法将集合的剩余元素设置为一个已定义的变量。扩展语法允许集合中的元素以某种方式与其他对象、数组和函数进行交互，通常是为了提供或覆盖值。</p><p id="2f49" class="pw-post-body-paragraph lr ls it lt b lu ne ju lw lx nf jx lz ma ng mc md me nh mg mh mi ni mk ml mm im bi translated">我希望这对你有所帮助！</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="3751" class="kz la it bd lb lc my le lf lg mz li lj jz na ka ll kc nb kd ln kf nc kg lp lq bi translated">参考</h1><ul class=""><li id="3ad8" class="og oh it lt b lu lv lx ly ma ou me ov mi ow mm ol om on oo bi translated"><a class="ae ky" href="https://www.stadlersoftware.com/coding/javascript-three-dots-rest-parameters-and-spread-syntax/" rel="noopener ugc nofollow" target="_blank">https://www . stadler software . com/coding/JavaScript-three-dots-rest-parameters-and-spread-syntax/</a></li><li id="872c" class="og oh it lt b lu op lx oq ma or me os mi ot mm ol om on oo bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/Spread _ syntax</a></li></ul></div></div>    
</body>
</html>