# 为你的 iOS 应用程序编写更好的模块的 6 个原则

> 原文：<https://betterprogramming.pub/6-principles-to-write-better-modules-for-your-ios-applications-3257c26e5df2>

## 在编写你的模块和库的时候要记住什么

![](img/04f5993bf75cd02dfe67b4c8a87b1d98.png)

由[万花筒](https://unsplash.com/@kaleidico?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

我喜欢的一项任务是编写库和模块来加速我的同事。

最有收获的时刻之一发生在一个同事来感谢我，因为我正在开发的一个库帮他节省了将近一周的时间。

今天我想分享我在应用程序中实现库或模块时通常遵循的五个原则。

# 1.限制 API 表面

API 表面是模块向外部世界公开的部分。它也被称为`public`接口。

这个表面应该尽可能小。这让我们在未来的变化中更加灵活。这似乎违反直觉:如果我们公开一些函数和类型，我们怎么会不够灵活呢？

我们不知道有多少客户会使用我们的图书馆。如果我们只暴露几个元素，我们肯定知道他们正在使用它们。另一方面，我们提供的元素越多，我们对客户如何使用我们的模块的了解就越少。

此外，删除一个特性总是一个突破性的改变，因为依赖该特性的客户端将停止工作。相反，添加一个新特性永远不会中断:如果我们添加一个新特性，我们不会冒中断客户端的风险。从小处着手，我们可以更灵活地添加具有不同参数或新行为的新方法。

大型 API 表面的另一个问题是成本更高:表面需要维护。还有，表面越高，出现 bug 的概率越高。而且修复 bug 很贵。

## 推论:只提供一种执行操作的方法

有时，提供不同的方法来执行相同的操作可能很有诱惑力。典型的例子是接受特定类型并为其他类型重载的方法。

虽然用两种不同的方式提供相同的功能看起来很容易，但最好选择一种方式并坚持下去。用不同的方法执行相同的操作有很多缺点:

1.  这给客户带来了困惑。他们应该使用哪种替代方案？
2.  它可能会引入需要修复的错误。
3.  它引入了双重标准。下次我们必须实现一个特性时，我们会花时间决定如何实现它。另外，它使工作量加倍。

编写小包装器将一个域映射到另一个域通常很容易。如果客户端使用的是不同的范例，它总是可以围绕库编写一个小的包装器。

围绕库编写包装器的一个积极的副作用是，客户端的应用程序变得与我们的库分离。如果他们需要把我们的库换成另一个库(或者如果我们发布了我们库的一个新的主要版本)，这是一件好事。

# 2.尊重语义版本

[语义版本化](https://semver.org/)是业界用来注释 SDK 特定版本的标准。它基于三个数字，用点分隔:M.m.p。

1.  第一个数字— **M** —表示库的**主**版本。
2.  第二个数字—**m**—表示库的**次要**版本。
3.  第三个数字— **p** —表示库的**补丁**版本。

这些数字包含了新版本库的意义和期望。

*   补丁发布必须对我们库的客户尽可能透明。他们应该能够引入库的最新补丁，而不改变他们的代码库。补丁发布通常是错误修复和内部细节的变化，不会影响系统的行为。
*   较小的版本包括附加的变化和新特性。在这种情况下，模块的客户端应该能够将库的最新版本带入他们的代码库中，而无需更改任何一行代码。
*   主要的变化包括方法签名的变化和系统行为的重大变化。他们正在突破变革。当将库更新到主要版本时，客户希望在他们的代码库中执行一些更改。

最好尽量减少破坏性的变化。我们不希望客户不得不为我们模块的每个版本更新代码库。

最后，记住要写清楚变更日志和迁移指南，尤其是在发布主要版本的时候。这将使库的采用更加容易。

# 3.提供信息错误

假设我们需要使用库中定义的类型。此类型有一个失败的初始值设定项。你更喜欢哪种选择:失败时返回`nil`的`init`还是抛出错误告诉你失败原因的`init`？

没有什么比试图创建一个对象并收到一个`nil`值，却不知道为什么会这样更令人沮丧的了。以下示例显示了两种方法:

在这个例子中，我们可以看到失败的初始化器(它没有给出任何信息)和抛出的初始化器。从客户端的角度来看，错误提供了更多的信息和从错误中恢复的可能性，最终会要求用户进行不同的输入。

## 推论:绝不崩溃

作为推论，内部模块永远不应该故意崩溃。是的，有些情况在结构上是无法获得的，我们可能会尝试使用 bang `!`或`fatalError`来简化我们的代码。

建议避免这些解决方案，至少有两个原因:

1.  没有什么比看到你的应用崩溃，并发现这是由于第三方库发生更令人沮丧的了。
2.  它们使你的代码更难测试。不可能用`fatalError`干净地测试一个代码分支。

很难用`fatalError` s 测试函数有一个非常具体的原因。`fatalError`签名如下:

它返回一个叫做`Never`的特殊类型。这个签名告诉编译器这个函数永远不会终止。测试一个永不返回的函数的唯一方法是在一个无限循环中阻塞它的执行。每次你需要测试一个`fatalError`的时候，你的测试总会有一个挂起的线程。如果有许多致命错误，测试套件可能永远不会终止，因为它耗尽了线程来执行一些剩余的测试。

# 4.永远尊重客户的应用程序

在某些情况下，我们需要处理由客户端应用程序创建和管理的组件。对于功能模块和提供一些 UI 的库来说，尤其如此。

一个典型的例子可能是一个支付库，它提供不同的屏幕来设置支付，或者是一个 onboarding 模块，它要求用户提供一些信息。在这两种情况下，它们都可以向应用程序请求一个`NavigationController`，用于从库中推送一些`ViewController`。

我们应该始终注意这些类型，避免设置自己的委托。如果我们盲目设置它们，我们就有替换应用程序安装的那些的风险。

一个可能的解决方案是创建一个包装委托，这样可以保存原始委托并将事件转发给它。在解除或卸载 SDK 时，我们应该将委托重置为初始值。

在这个例子中，我们可以看到如何包装一个`UINavigationControllerDelegate`。

首先，我们需要几个属性来跟踪`navigationController`和`appDelegate`。这些应该是`weak`以避免引用循环。在属性中存储这些对象后，我们可以安全地更改`delegate`。

当要解散 SDK 时，必须调用`unload`方法。在该方法中，我们只是用之前保存的委托替换当前的委托。

最后，在委托的方法中，我们:

1.  检查我们是否真的必须在 SDK 中执行一些操作。
2.  如果没有，我们调用最初的`appDelegate`方法，让应用程序表现得好像 SDK 不存在一样。

# 5.始终验证输入

我们应该始终验证从应用程序接收到的输入。例如，如果我们的 SDK 需要财政代码或信用卡号，我们应该检查应用程序是否传递了有效的类型。

我最喜欢的确保这一点的方法是使用定义良好的类型，比如`CreditCardNumber`，它在`init`中包含一些验证，如果出错，抛出一个信息性错误，遵循原则三。

这不仅确保了我们在编译时使用有效的类型，还减少了一种叫做[原语困扰](https://refactoring.guru/smells/primitive-obsession)的代码味道:当我们为特定领域的实体使用原语类型时。`CreditCardNumber`就是一个很好的例子；我们可以使用正确的类型，而不是使用简单的`String`来保证信用卡的结构，如下所示:

对于这种类型，我们在初始化器中执行所有的验证步骤。如果出现问题，应用程序可以很容易地恢复，这要感谢类型抛出的明确错误。如果值是有效的，我们不必在代码库中执行任何其他验证。

这种方法还有另外两个优点:

1.  它将所有的验证推到流程的开始，允许我们快速失败并避免任何无用的计算。
2.  它防止将值用于其他目的。例如，如果我们只使用字符串，我们可能最终会使用信用卡值而不是会话 id。

# 6.编写清晰简洁的文档

编写文档可能看起来像是无意义的成本；它不会立即做任何事情，并且可能会与代码不同步。

然而，作为开发人员，当出现问题时，这是我们首先要检查的。当我们不得不使用文档不清晰的框架时，我们通常会抱怨。

良好的文档包括:

*   一个方法能做什么。
*   它的参数是什么。
*   它返回的内容。
*   它会抛出什么错误以及何时抛出。
*   任何对客户有用的具体细节:例如，它的复杂性。

# 结论

在今天的文章中，我们探讨了在代码库中开发库和特性模块时应该遵循的一些原则。总结一下:

1.  限制 API 的表面——只提供一种执行操作的方式。
2.  尊重语义版本。
3.  提供信息性错误——永不崩溃。
4.  永远尊重客户端的 app。
5.  验证输入。
6.  编写有意义的文档。

如果我们遵循这些原则，我们会交付高质量的模块，这不会让我们的客户感到惊讶。当一个 bug 出现时，一个快乐的客户也会更加宽容。

说到底，我们都是第三方库的用户。如果我们都遵循这些原则，我们就可以生活在一个代码更好、挫折更少、开发人员体验总体更好的世界里。