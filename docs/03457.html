<html>
<head>
<title>An Introduction to Database Sharding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据库分片简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-introduction-to-database-sharding-b6abde73d04f?source=collection_archive---------10-----------------------#2020-02-11">https://betterprogramming.pub/an-introduction-to-database-sharding-b6abde73d04f?source=collection_archive---------10-----------------------#2020-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bec7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">随着应用的增长扩展数据库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c9e1bb5845c070d107457bae7c73314d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*34AKJXXNjCbQ01tcP_cuKA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:<a class="ae ky" href="https://unsplash.com/@alschim?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Alexander Schimmeck</a>在<a class="ae ky" href="https://unsplash.com/s/photos/queue?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1ddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着应用程序必须处理的数据量不断增加，不可能将所有数据保存在单个节点上，因为单个服务器可能无法处理如此大的吞吐量。在这种情况下，将数据库划分为多个节点是一种有效的技术。</p><p id="fe56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们将讨论数据库分片(分区)。近年来，分片受到了很多关注。但是，许多人不熟悉这个概念。</p><p id="d518" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个博客中，我们将讨论基本概念，为什么需要它，以及实现它的方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9d06" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是分片？</h1><p id="fc3b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">分片是将来自单个数据源的数据划分到多个分区，其中每个分区的结构都是相同的。单个分区也称为碎片。碎片可以放在同一个服务器或不同的服务器上。</p><p id="6d3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解这一点，请看下图。我们有一个<em class="mz">用户</em>表，包含用户信息，如<em class="mz">姓名</em>、<em class="mz">年龄</em>和<em class="mz">国家</em>。我们将其分成两个表，<em class="mz"> users_001 </em>和<em class="mz"> users_002。</em>(在什么基础上我们可以分片一个表将在随后的段落中讨论。)</p><p id="8267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的一点是，碎片<em class="mz">不共享任何数据</em>。因此，复制需要与分片一起工作，以防止数据丢失。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/f5e65fce192bdf6af56c12faaad89b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hAePdvA7UdzIMQjC8LxxhA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2:表格的分片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c52d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么我们需要分片？</h1><p id="f94e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们用一个例子来理解这一点。假设在图1中，只有一条车道，而不是三条车道。会发生什么？交通本来会很慢，可能会堵塞。</p><p id="cde0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，在数据库中，如果我们从一个表中读取所有内容，响应时间可能会随着负载的增加而增加，数据库也可能会关闭。</p><p id="5d87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分片将流量从单个表分割到多个表，就像图1中的车道一样。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a09b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">分片是怎么做的？</h1><p id="20a2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有几种分片技术，但最流行的是:</p><ol class=""><li id="aa5c" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">基于范围的分区。</li><li id="2a3e" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">哈希分区。</li></ol><h2 id="a2c3" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated"><strong class="ak">基于范围的分区</strong></h2><p id="82a2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这种情况下，数据根据键的范围进行分片(分区)。同一范围内的数据属于同一分区。</p><p id="29df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">键的选择在这里非常重要，因为如果选择不好，那么数据将分布不均匀，也就是说，一个碎片可能包含大部分数据。</p><p id="36a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在图3中，<em class="mz">雇员</em>表的分区基于<em class="mz">年龄</em>列。年龄范围为(0-30)，(30-40)，和(&gt; 40)。因此，将有三个碎片，员工数据将根据他们的年龄进行分区。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/8b9fd8f4916f87d0c4968cee6a3779e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*_v3cboFtFLcqPLTvMk3_pw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd oc">图3: </strong>基于范围的分割</p></figure><h2 id="a3fa" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated"><strong class="ak">哈希分区</strong></h2><p id="0725" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这也被称为基于键的分区<strong class="lb iu">。</strong>在这种情况下，我们选择一个键并传递给一个哈希函数，然后得到分区，即哈希函数可以被认为是从键到分区的映射。</p><p id="4ce2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在决定散列函数时，必须确保数据均匀分布在各个碎片上。</p><p id="f8d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在图2中的分区模式中，我们的键是ID列。我们的哈希函数选取ID的最后一位数字，并相应地将数据放入分区，即以1结尾的数据放入<em class="mz"> users_001 </em>，以2结尾的数据放入<em class="mz"> users_002 </em>，依此类推。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/6449223c2cd0722be50386135704e287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BXnYY2Z-57mmPwcA_XqHdw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd oc">图4: </strong>哈希分区</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7200" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">分片是如何实现的？</h1><p id="92ca" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">从实现的角度来看，有两种方法可以做到这一点:</p><ol class=""><li id="201d" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">客户端分区。</li><li id="0d01" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">代理辅助分区。</li></ol><h2 id="ca95" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated"><strong class="ak">客户端分区</strong></h2><p id="7165" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">客户端知道数据是如何分区的，并直接选择分区来读写数据。</p><p id="9ac7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的优点是没有中间层。但是缺点是在实现之后不容易改变分区的数量，因为所有的客户端代码都需要改变。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/14c183cd62c283d14d359fcfea13cb17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAqCMHz2w9H43EK4eV8YBQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd oc">图5: </strong>客户端分区</p></figure><h2 id="c374" class="np md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated"><strong class="ak">代理辅助分区</strong></h2><p id="60fe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在代理辅助分区中，客户机向代理服务器发出请求，而不是直接调用shard。代理服务器根据分片模式将该请求转发给正确的分片。</p><p id="0238" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种技术的优点是客户端不知道任何关于分片的逻辑，并且分片和分区的数量比客户端分区更容易更改。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/d576312594b9c3983c7fc74f0f9d1a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*THXwyowlceD0PDRWFj6SIg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd oc">图6: </strong>代理辅助分区</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c5db" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="0598" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于拥有大量数据的数据库来说，分片是一个很好的解决方案。它有助于将负载从单个节点分散到多个节点。但是，它增加了应用程序的复杂性。</p><p id="9086" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，分片可能是必要的，但在添加分片之前，需要尝试其他选项，如添加缓存或迁移到更大的服务器，因为创建时间和维护成本可能超过分片的好处。</p></div></div>    
</body>
</html>