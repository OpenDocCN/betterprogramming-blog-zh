<html>
<head>
<title>Understanding TvOS Focus Guides With React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React Native了解TvOS焦点指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-tvos-focus-guides-with-react-native-22a366850825?source=collection_archive---------3-----------------------#2022-12-06">https://betterprogramming.pub/understanding-tvos-focus-guides-with-react-native-22a366850825?source=collection_archive---------3-----------------------#2022-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f25d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学会关注你的组件，即使它们彼此不一致</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dfe077079b8299922b2059922d69945d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h1WQcsu0VYcCH3yI"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">保罗·斯科鲁普斯卡斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e4ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">起初，在React本机tvOS应用程序中设置空间导航似乎相当简单。React原生文档指出，我们简单地使用可触摸混合(<code class="fe ls lt lu lv b">TouchableOpacity</code>、<code class="fe ls lt lu lv b">TouchableHighlight</code>和<code class="fe ls lt lu lv b">TouchableWithoutFeedback</code>)来使屏幕上的组件可聚焦。当您的组件在高度、大小和位置上沿着一个轴对齐时，这非常有用，但是当项目没有对齐时会发生什么呢？</p><p id="7ab2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑下面的例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/c98fe6405a90491b03b12520c0c99e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NFMNBsF1vw73slyH"/></div></div></figure><p id="cbd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当前选定的项目1.3将完全跳过第二行，并在按下时转到项目3.3，因为中间没有可聚焦的项目。对于某些应用程序来说，跳过一行是可以接受的，因为仍然可以通过按“左”然后“下”来导航到第二行，但是跳过这一行还是感觉怪怪的。</p><p id="a367" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更糟糕的是，在下面的屏幕布局中可以找到一个用户旅程中断的例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/348a9a3c2026233203039ff050b9b4a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OYBdOX7PtI3nr5Bv"/></div></div></figure><p id="1ff5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">项目1.1和1.2沿x轴居中，不会填满屏幕的整个宽度。因此，当选择2.1时，我们无法导航到第一行的按钮。当内容滚动时，这个问题变得更加严重。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/34ae09c2720f8e704bdd59c4ff44daa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RfxcqPgMF7n-9n3w"/></div></div></figure><p id="3995" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当在项目2.2上时，用户不能向上按来导航到前面的行，并且他们非常不清楚这是为什么。如果第2行只有一个可聚焦的元素，用户将无法导航到顶部的按钮。</p><h1 id="f54b" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">输入:UIFocusGuide</h1><p id="0b2f" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">苹果将<code class="fe ls lt lu lv b">FocusGuides</code>或<code class="fe ls lt lu lv b">UIFocusGuide</code>描述为代表一个不可见的、可聚焦的区域，可以将焦点移动重定向到其他视图。换句话说，它们是看不见的盒子，你把它们放在空白的地方，告诉焦点引擎该做什么。</p><p id="52e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过创建一个不可见的元素，并告诉它将焦点移动到哪里，我们可以创建一些看起来更像下图的东西。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/1d6cdacdbf154401f5abb3dbe12f932a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GcydFHFOvwo0tE-m"/></div></div></figure><p id="2e68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">聚焦导轨填充第二行上未被任何牌占据的空间，并被设置为将焦点调整到该行上的最后一张牌。每当我们沿着第三列或更远的方向上下移动并选择第二行时，焦点将自动分配给标记为2.2的组件。</p><h1 id="e53c" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">我们如何在React Native中实现这一点？</h1><p id="af4a" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">虽然文档很少，但react-native-tvos支持开箱即用的焦点指南——它们可以在您现有的react native tvOS项目中实现，而无需编写任何额外的本机代码。</p><p id="b9e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">焦点向导在react-native-tvos中导出为<code class="fe ls lt lu lv b">TVFocusGuideView</code>，并带两个重要道具<code class="fe ls lt lu lv b">style</code>和<code class="fe ls lt lu lv b">destinations</code>。<code class="fe ls lt lu lv b">style</code>对于控制焦点引导线的边界是必不可少的，例如，如果你想引导线填充行，你需要给它一个合适的<code class="fe ls lt lu lv b">width</code>或<code class="fe ls lt lu lv b">flexGrow</code>值。</p><p id="5453" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">属性是一个引用DOM中节点的数组。尽管此属性是一个数组，但只应设置数组中的第一项。数组中的项目指的是您希望focus引擎在focus guide中定位时选择的位置。</p><blockquote class="mu mv mw"><p id="c34e" class="kw kx mx ky b kz la jr lb lc ld ju le my lg lh li mz lk ll lm na lo lp lq lr ij bi translated">你不需要AndroidTV的焦点指南，我们在本文中讨论的预期逻辑已经在AndroidTV中可用。您可以保留代码，因为react-native-tvos造成的危害很小。</p></blockquote><h1 id="75d0" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">在应用程序中实现这一点</h1><blockquote class="mu mv mw"><p id="03b3" class="kw kx mx ky b kz la jr lb lc ld ju le my lg lh li mz lk ll lm na lo lp lq lr ij bi translated">建议用你自己的组件包装主要的RN组件，这样你可以改变非TVOS平台的行为。</p></blockquote><pre class="kg kh ki kj gt nb lv nc bn nd ne bi"><span id="4ba5" class="nf ly iq lv b be ng nh l ni nj">import React from 'react';<br/>import { StyleProp, TVFocusGuideView, ViewStyle } from 'react-native';<br/> <br/>import { Platform } from '~util/device';<br/> <br/>interface IProps {<br/> destinations: () =&gt; void;<br/> style?: StyleProp&lt;ViewStyle&gt;;<br/>}<br/> <br/>/**<br/>* TVFocusGuideView. Used for manually controlling the focus when focusable items do not align.<br/>* Only supported on TVOS.<br/>*/<br/>const FocusGuide: React.FC&lt;IProps&gt; = ({ destinations, style = {}, children }) =&gt; {<br/> if (!Platform.isTVOS) {<br/>   return &lt;&gt;{children}&lt;/&gt;;<br/> }<br/> <br/> return (<br/>   &lt;TVFocusGuideView destinations={destinations} style={style}&gt;<br/>     {children}<br/>   &lt;/TVFocusGuideView&gt;<br/> );<br/>};<br/> <br/>export { FocusGuide };</span></pre><p id="c121" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们遇到的一个问题是，只有当<code class="fe ls lt lu lv b">destinations</code>属性更新时，焦点向导才会收到属性更改，即使用常规的React Ref来避免重新渲染和传递，因为<code class="fe ls lt lu lv b">destinations</code>属性将意味着焦点向导不起作用。为了处理这个问题，我们可以创建一个钩子来创建对DOM节点的引用，我们将把它作为<code class="fe ls lt lu lv b">destinations</code> prop传递。</p><pre class="kg kh ki kj gt nb lv nc bn nd ne bi"><span id="6af2" class="nf ly iq lv b be ng nh l ni nj">import { useCallback, useState } from 'react';<br/> <br/>type ElementNode = any;<br/> <br/>type FocusGuideDestinationRef = {<br/> // Pass this as the focusRef of a focusable component.<br/> ref: (node: ElementNode) =&gt; void;<br/> // Pass this to the destinations prop of TVFocusGuideView.<br/> destinations: ElementNode[];<br/>};<br/> <br/>/**<br/>* Creates a reference to a dom node for a FocusGuide destinations array. Triggers a rerender when the reference is assigned<br/>* for the first time, which is necessary for passing the reference to the FocusGuide component.<br/>*/<br/>const useFocusGuideDestinationRef = (): FocusGuideDestinationRef =&gt; {<br/> const [destination, setDestination] = useState(null);<br/> const ref = useCallback((node: ElementNode) =&gt; {<br/>   if (node !== null) {<br/>     setDestination(node);<br/>   }<br/> }, []);<br/> <br/> const destinations = destination ? [destination] : [];<br/> <br/> return {<br/>   destinations,<br/>   ref,<br/> };<br/>};<br/> <br/>export { useFocusGuideDestinationRef };<br/>export type { FocusGuideDestinationRef }</span></pre><p id="d0f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用钩子，将返回的<code class="fe ls lt lu lv b">ref</code>作为ref属性传递给一个可触摸的组件，这将设置<code class="fe ls lt lu lv b">destinations</code>变量来包含对DOM的引用。返回的<code class="fe ls lt lu lv b">destinations</code>可以传递给我们的<code class="fe ls lt lu lv b">FocusGuide</code>组件。</p><p id="b67e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从这里，您可以决定<code class="fe ls lt lu lv b">FocusGuide</code>组件如何工作；通过将按钮作为子组件放置在组件中，它可以成为按钮的容器。或者您可以通过<code class="fe ls lt lu lv b">style</code>支柱设置高度和宽度，并将其用作没有子组件的自关闭组件。</p><p id="c417" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只需记住将ref传递给你的<code class="fe ls lt lu lv b">Touchable*</code>组件，将destinations传递给你的<code class="fe ls lt lu lv b">FocusGuide</code>。</p><p id="6852" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个简单的例子，当你把所有这些放在一起看起来是什么样子:</p><pre class="kg kh ki kj gt nb lv nc bn nd ne bi"><span id="2a91" class="nf ly iq lv b be ng nh l ni nj">import React from 'react';<br/>import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';<br/> <br/>import { useFocusGuideDestinationRef } from '~src/hooks/useFocusGuideDestinationRef';<br/> <br/>import { FocusGuide } from './FocusGuide';<br/> <br/>const styles = StyleSheet.create({<br/> guide: {<br/>   width: '100%',<br/>   height: 200,<br/> },<br/> button: {<br/>   width: 200,<br/>   height: 200,<br/> },<br/>});<br/> <br/>const RowWithFocusGuide: React.FC = () =&gt; {<br/> const { ref, destinations } = useFocusGuideDestinationRef();<br/> <br/> return (<br/>   &lt;View&gt;<br/>     &lt;FocusGuide destinations={destinations} style={styles.guide}&gt;<br/>       &lt;TouchableOpacity ref={ref} style={styles.button}&gt;<br/>         &lt;Text&gt;Test Button&lt;/Text&gt;<br/>       &lt;/TouchableOpacity&gt;<br/> <br/>       &lt;TouchableOpacity style={styles.button}&gt;<br/>         &lt;Text&gt;Test Button 2&lt;/Text&gt;<br/>       &lt;/TouchableOpacity&gt;<br/>     &lt;/FocusGuide&gt;<br/>   &lt;/View&gt;<br/> );<br/>};<br/> <br/>export { RowWithFocusGuide };</span></pre><p id="9e02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的生产就绪代码中，您可能会将这个解决方案与一个虚拟化列表的变体(可能是一个<code class="fe ls lt lu lv b">FlatList</code>)一起使用。为此，请记住，在选择容器时，只将ref传递给您想要关注的特定卡片。您可以根据卡的索引在您的<code class="fe ls lt lu lv b">renderItem</code>函数中完成此操作。</p><p id="470f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有兴趣了解更多关于Econify如何解决电视开发领域的问题，请通过<a class="ae kv" href="https://www.linkedin.com/in/aaronwilliamsbhx/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div></div>    
</body>
</html>