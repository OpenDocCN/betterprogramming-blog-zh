<html>
<head>
<title>Building a Hexagonal Grid With the SwiftUI Layout Protocol</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI布局协议构建六边形网格</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-hexagonal-grid-with-the-swiftui-layout-protocol-f7b0efeeacbf?source=collection_archive---------5-----------------------#2022-12-09">https://betterprogramming.pub/building-a-hexagonal-grid-with-the-swiftui-layout-protocol-f7b0efeeacbf?source=collection_archive---------5-----------------------#2022-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b9ce" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何制作一个通用的SwiftUI容器，在六边形网格中显示子视图。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/e903ce497bc372d4075c814b8f2427d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*z2FjJL8dVTl1td81tmq-0w.jpeg"/></div></figure><p id="41b9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们即将制作的组件以<a class="ae lj" href="https://github.com/ksemianov/HexGrid" rel="noopener ugc nofollow" target="_blank"> Swift包</a>的形式提供。</p><p id="f468" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">SwiftUI真的很擅长构建矩形框的层次结构。随着最近<code class="fe lk ll lm ln b">Grid</code>的加入，它变得更好了。但是，今天我们要建立一个疯狂的六边形布局。当然，这没有专用的布局类型。所以我们用<code class="fe lk ll lm ln b">Layout</code>协议来构建我们自己的！</p><h1 id="2e21" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">画一个六角形</h1><p id="35c3" class="pw-post-body-paragraph kn ko iq kp b kq mg jr ks kt mh ju kv kw mi ky kz la mj lc ld le mk lg lh li ij bi translated">让我们首先为网格单元定义一个形状。为此，我们需要实现<code class="fe lk ll lm ln b">func path(in rect: CGRect) -&gt; Path</code>来满足<code class="fe lk ll lm ln b">Shape</code>协议要求。我们基本上需要找到适合矩形的六边形的最大尺寸，计算它的顶点并在它们之间画线。这是做一个平顶六边形的完整代码。</p><pre class="kg kh ki kj gt ml ln mm bn mn mo bi"><span id="088b" class="mp lp iq ln b be mq mr l ms mt">struct Hexagon: Shape {<br/>    static let aspectRatio: CGFloat = 2 / sqrt(3)<br/><br/>    func path(in rect: CGRect) -&gt; Path {<br/>        var path = Path()<br/><br/>        let center = CGPoint(x: rect.midX, y: rect.midY)<br/>        let width = min(rect.width, rect.height * Self.aspectRatio)<br/>        let size = width / 2<br/>        let corners = (0..&lt;6)<br/>            .map {<br/>                let angle = -CGFloat.pi / 3 * CGFloat($0)<br/>                let dx = size * cos(angle)<br/>                let dy = size * sin(angle)<br/><br/>                return CGPoint(x: center.x + dx, y: center.y + dy)<br/>            }<br/><br/>        path.move(to: corners[0])<br/>        corners[1..&lt;6].forEach { point in<br/>            path.addLine(to: point)<br/>        }<br/><br/>        path.closeSubpath()<br/><br/>        return path<br/>    }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/ceff7167daeff65bdc89fbd13f31465e.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*2PhWKLuu4cJQuxTM_UFjdA.jpeg"/></div></figure><h1 id="f8de" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">协调</h1><p id="d1cb" class="pw-post-body-paragraph kn ko iq kp b kq mg jr ks kt mh ju kv kw mi ky kz la mj lc ld le mk lg lh li ij bi translated">我们需要把六边形放在某个地方。为此，我们需要一个坐标系。最容易理解的是偏置坐标系，但也可以使用其他坐标(如轴向坐标)。我们取偏移坐标的奇q变量。它基本上只是将单元格定义为成对的行和列。并且每个奇数列向下移位1/2。我们需要向布局系统提供这些坐标，这是通过创建一个符合<code class="fe lk ll lm ln b">LayoutValueKey</code>的键来完成的。</p><pre class="kg kh ki kj gt ml ln mm bn mn mo bi"><span id="6422" class="mp lp iq ln b be mq mr l ms mt">struct OffsetCoordinate: Hashable {<br/>    var row: Int<br/>    var col: Int<br/>}<br/><br/>protocol OffsetCoordinateProviding {<br/>    var offsetCoordinate: OffsetCoordinate { get }<br/>}<br/><br/>struct OffsetCoordinateLayoutValueKey: LayoutValueKey {<br/>    static let defaultValue: OffsetCoordinate? = nil<br/>}</span></pre><h1 id="a01e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">布局协议</h1><p id="5471" class="pw-post-body-paragraph kn ko iq kp b kq mg jr ks kt mh ju kv kw mi ky kz la mj lc ld le mk lg lh li ij bi translated">该协议有两个要求:</p><ul class=""><li id="e112" class="mv mw iq kp b kq kr kt ku kw mx la my le mz li na nb nc nd bi translated"><code class="fe lk ll lm ln b">sizeThatFits</code>控制视图需要多少空间</li><li id="ffc4" class="mv mw iq kp b kq ne kt nf kw ng la nh le ni li na nb nc nd bi translated"><code class="fe lk ll lm ln b">placeSubviews</code>控制子视图在可用空间内的位置</li></ul><p id="9a95" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">并且可选地:</p><ul class=""><li id="2ab7" class="mv mw iq kp b kq kr kt ku kw mx la my le mz li na nb nc nd bi translated">为了避免额外的计算</li></ul><h1 id="b093" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">贮藏</h1><p id="9a38" class="pw-post-body-paragraph kn ko iq kp b kq mg jr ks kt mh ju kv kw mi ky kz la mj lc ld le mk lg lh li ij bi translated">让我们为布局协议定义缓存数据。首先，我们需要知道网格的左上角坐标，以正确计算从边界左上角的偏移量。然后，我们需要知道单元格的完整行和列的网格有多大。</p><pre class="kg kh ki kj gt ml ln mm bn mn mo bi"><span id="0c69" class="mp lp iq ln b be mq mr l ms mt">struct CacheData {<br/>    let offsetX: Int<br/>    let offsetY: Int<br/>    let width: CGFloat<br/>    let height: CGFloat<br/>}<br/><br/>func makeCache(subviews: Subviews) -&gt; CacheData? {<br/>    let coordinates = subviews.compactMap { $0[OffsetCoordinateLayoutValueKey.self] }<br/><br/>    if coordinates.isEmpty { return nil }<br/><br/>    let offsetX = coordinates.map { $0.col }.min()!<br/>    let offsetY = coordinates.map { $0.row }.min()!<br/><br/>    let coordinatesX = coordinates.map { CGFloat($0.col) }<br/>    let minX: CGFloat = coordinatesX.min()!<br/>    let maxX: CGFloat = coordinatesX.max()!<br/>    let width = maxX - minX + 4 / 3<br/><br/>    let coordinatesY = coordinates.map { CGFloat($0.row) + 1 / 2 * CGFloat($0.col &amp; 1) }<br/>    let minY: CGFloat = coordinatesY.min()!<br/>    let maxY: CGFloat = coordinatesY.max()!<br/>    let height = maxY - minY + 1<br/><br/>    return CacheData(offsetX: offsetX, offsetY: offsetY, width: width, height: height)<br/>}</span></pre><h1 id="6cd9" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><code class="fe lk ll lm ln b">sizeThatFits</code></h1><p id="ebf0" class="pw-post-body-paragraph kn ko iq kp b kq mg jr ks kt mh ju kv kw mi ky kz la mj lc ld le mk lg lh li ij bi translated">这个很简单。我们只需要取十六进制单元格的宽度，这样它就可以放入提议中。然后根据单元宽度将其乘以网格的相应宽度和高度。</p><pre class="kg kh ki kj gt ml ln mm bn mn mo bi"><span id="c0b3" class="mp lp iq ln b be mq mr l ms mt">func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout CacheData?) -&gt; CGSize {<br/>    guard let cache else { return .zero }<br/><br/>    let size = proposal.replacingUnspecifiedDimensions()<br/>    let step = min(size.width / cache.width, size.height / cache.height / Hexagon.aspectRatio)<br/><br/>    return CGSize(width: step * cache.width, height: step * cache.height * Hexagon.aspectRatio)<br/>}</span></pre><h1 id="7bcb" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><code class="fe lk ll lm ln b">placeSubviews</code></h1><p id="c386" class="pw-post-body-paragraph kn ko iq kp b kq mg jr ks kt mh ju kv kw mi ky kz la mj lc ld le mk lg lh li ij bi translated">这里我们计算连续六边形之间的步距。然后将每个六边形以正确的尺寸放置在相应的位置。</p><pre class="kg kh ki kj gt ml ln mm bn mn mo bi"><span id="478e" class="mp lp iq ln b be mq mr l ms mt">func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout CacheData?) {<br/>    guard let cache else { return }<br/><br/>    let size = proposal.replacingUnspecifiedDimensions()<br/>    let step = min(size.width / cache.width, size.height / cache.height / Hexagon.aspectRatio)<br/>    let width = step * 4 / 3<br/>    let proposal = ProposedViewSize(width: width, height: width / Hexagon.aspectRatio)<br/>    let x = width / 2 + bounds.minX<br/>    let y = width / Hexagon.aspectRatio / 2 + bounds.minY<br/><br/>    for subview in subviews {<br/>        guard let coord = subview[OffsetCoordinateLayoutValueKey.self] else { continue }<br/><br/>        let dx: CGFloat = step * CGFloat(coord.col - cache.offsetX)<br/>        let dy: CGFloat = step * Hexagon.aspectRatio * (CGFloat(coord.row - cache.offsetY) + 1 / 2 * CGFloat(coord.col &amp; 1))<br/>        let point = CGPoint(x: x + dx, y: y + dy)<br/><br/>        subview.place(at: point, anchor: .center, proposal: proposal)<br/>    }<br/>}</span></pre><h1 id="da95" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">HexGrid</h1><p id="3cbc" class="pw-post-body-paragraph kn ko iq kp b kq mg jr ks kt mh ju kv kw mi ky kz la mj lc ld le mk lg lh li ij bi translated">此时，<code class="fe lk ll lm ln b">HexLayout</code>已经可以使用了。然而，所有子视图都应该有一个坐标的规则并没有被强制执行。所以最好做一个瘦包装器，为组件消费者提供这种编译时保证。在此过程中，我们将用六边形的形状裁剪子视图，使调用点更加清晰。</p><pre class="kg kh ki kj gt ml ln mm bn mn mo bi"><span id="9024" class="mp lp iq ln b be mq mr l ms mt">struct HexGrid&lt;Data, ID, Content&gt;: View where Data: RandomAccessCollection, Data.Element: OffsetCoordinateProviding, ID: Hashable, Content: View {<br/>    let data: Data<br/>    let id: KeyPath&lt;Data.Element, ID&gt;<br/>    let content: (Data.Element) -&gt; Content<br/><br/>    init(_ data: Data,<br/>         id: KeyPath&lt;Data.Element, ID&gt;,<br/>         @ViewBuilder content: @escaping (Data.Element) -&gt; Content) {<br/>        self.data = data<br/>        self.id = id<br/>        self.content = content<br/>    }<br/><br/>    var body: some View {<br/>        HexLayout {<br/>            ForEach(data, id: id) { element in<br/>                content(element)<br/>                    .clipShape(Hexagon())<br/>                    .layoutValue(key: OffsetCoordinateLayoutValueKey.self,<br/>                                 value: element.offsetCoordinate)<br/>            }<br/>        }<br/>    }<br/>}</span></pre><pre class="nj ml ln mm bn mn mo bi"><span id="a343" class="mp lp iq ln b be mq mr l ms mt">extension HexGrid where ID == Data.Element.ID, Data.Element: Identifiable {<br/>    init(_ data: Data,<br/>         @ViewBuilder content: @escaping (Data.Element) -&gt; Content) {<br/>        self.init(data, id: \.id, content: content)<br/>    }<br/>}</span></pre><h1 id="2c1b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">使用</h1><p id="2b45" class="pw-post-body-paragraph kn ko iq kp b kq mg jr ks kt mh ju kv kw mi ky kz la mj lc ld le mk lg lh li ij bi translated">现在，我们终于可以定义我们的数据模型，并使用ready组件来获得本文开头的图像:</p><pre class="kg kh ki kj gt ml ln mm bn mn mo bi"><span id="5092" class="mp lp iq ln b be mq mr l ms mt">struct HexCell: Identifiable, OffsetCoordinateProviding {<br/>    var id: Int { offsetCoordinate.hashValue }<br/>    var offsetCoordinate: OffsetCoordinate<br/>    var colorName: String<br/>}<br/><br/>let cells: [HexCell] = [<br/>    .init(offsetCoordinate: .init(row: 0, col: 0), colorName: "color1"),<br/>    .init(offsetCoordinate: .init(row: 0, col: 1), colorName: "color2"),<br/>    .init(offsetCoordinate: .init(row: 0, col: 2), colorName: "color3"),<br/>    .init(offsetCoordinate: .init(row: 1, col: 0), colorName: "color4"),<br/>    .init(offsetCoordinate: .init(row: 1, col: 1), colorName: "color5")<br/>]<br/><br/>HexGrid(cells) { cell in<br/>    Color(cell.colorName)<br/>}</span></pre><p id="1ca7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是你可以把图像或者任何视图放到子视图中！请注意，布局假设子视图填充六边形单元格的内容。</p><pre class="kg kh ki kj gt ml ln mm bn mn mo bi"><span id="9317" class="mp lp iq ln b be mq mr l ms mt">HexGrid(cells) { cell in<br/>    AsyncImage(url: cell.url) { image in<br/>        image.resizable().aspectRatio(contentMode: .fill)<br/>    } placeholder: {<br/>        ProgressView().frame(maxWidth: .infinity, maxHeight: .infinity)<br/>    }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/5df693ff73b9f8096f41244f165c07a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*5DFRelBbkR2sP-9FYSjlCA.jpeg"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">基于从<a class="ae lj" href="https://pixnio.com/" rel="noopener ugc nofollow" target="_blank"> PIXNIO </a>下载的公共领域照片。</p></figure><h1 id="0cf1" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">最后的想法</h1><p id="98d3" class="pw-post-body-paragraph kn ko iq kp b kq mg jr ks kt mh ju kv kw mi ky kz la mj lc ld le mk lg lh li ij bi translated">我们已经学习了如何向<code class="fe lk ll lm ln b">LayoutSubview</code>代理提供值，并构建一个有趣的非平凡的布局。</p><p id="448b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">想了解更多关于六边形网格的信息，请看这个<a class="ae lj" href="https://www.redblobgames.com/grids/hexagons/" rel="noopener ugc nofollow" target="_blank">神奇指南</a></p><p id="c5e6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在<a class="ae lj" href="https://github.com/ksemianov/HexGrid" rel="noopener ugc nofollow" target="_blank">https://github.com/ksemianov/HexGrid</a>查看完整代码</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="b316" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="nv">最初发表于</em><a class="ae lj" href="https://ksemianov.github.io/articles/hexgrid/" rel="noopener ugc nofollow" target="_blank"><em class="nv">https://ksemianov.github.io/articles/hexgrid/</em></a></p></div></div>    
</body>
</html>