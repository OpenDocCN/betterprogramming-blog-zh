<html>
<head>
<title>React Functional Components and Lodash High-Order Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应功能成分和Lodash高阶功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-functional-components-and-lodash-high-order-functions-a0bc9e2df171?source=collection_archive---------9-----------------------#2020-06-17">https://betterprogramming.pub/react-functional-components-and-lodash-high-order-functions-a0bc9e2df171?source=collection_archive---------9-----------------------#2020-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ed30" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在React功能组件中无缝使用Lodash高阶功能，如去抖和节流</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cf16ce71e95a80d8ec86e6214ddd04af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_5NBtpiYu5oouBLw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@bernardhermant?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伯纳德·赫曼特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="8388" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管现代浏览器不断增加对实用功能的支持(因此使得<a class="ae ky" href="https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore" rel="noopener ugc nofollow" target="_blank"> Lodash不如</a>有用)，但你可能仍然会发现自己处于一种出于某种原因需要/想要使用<a class="ae ky" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> Lodash </a>的情况。</p><p id="7d45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>成为最流行的前端库之一，很有可能你最终会需要结合使用两者。这似乎是一个微不足道的任务(确实如此)，但是当我们将<a class="ae ky" href="https://reactjs.org/docs/hooks-state.html#hooks-and-function-components" rel="noopener ugc nofollow" target="_blank">功能组件和钩子</a>放在一起时，可能会有一些陷阱。我希望这篇文章能帮助你避开它们。</p><p id="2650" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文适用于Lodash提供的所有高阶效用函数，但我们将重点关注<code class="fe lv lw lx ly b"><a class="ae ky" href="https://lodash.com/docs/4.17.15#debounce" rel="noopener ugc nofollow" target="_blank">debounce</a></code>和<code class="fe lv lw lx ly b"><a class="ae ky" href="https://lodash.com/docs/4.17.15#throttle" rel="noopener ugc nofollow" target="_blank">throttle</a></code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f5e6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">目录</h1><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="5aad" class="nc mh it ly b gy nd ne l nf ng">· <a class="ae ky" href="#c95f" rel="noopener ugc nofollow">TL;DR</a><br/>  ∘ <a class="ae ky" href="#9521" rel="noopener ugc nofollow">Module/file scope function</a><br/>  ∘ <a class="ae ky" href="#e148" rel="noopener ugc nofollow">Component scope function</a><br/>· <a class="ae ky" href="#bb67" rel="noopener ugc nofollow">Debounce</a><br/>· <a class="ae ky" href="#2375" rel="noopener ugc nofollow">Throttle</a><br/>· <a class="ae ky" href="#4b50" rel="noopener ugc nofollow">Conclusion</a></span></pre><h1 id="c95f" class="mg mh it bd mi mj nh ml mm mn ni mp mq jz nj ka ms kc nk kd mu kf nl kg mw mx bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="84bc" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">最重要的是避免多次定义函数。</p><h2 id="9521" class="nc mh it bd mi nr ns dn mm nt nu dp mq li nv nw ms lm nx ny mu lq nz oa mw ob bi translated">模块/文件范围函数</h2><p id="9480" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">如果函数不需要访问组件的作用域，您可以简单地在组件外部定义它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="e148" class="nc mh it bd mi nr ns dn mm nt nu dp mq li nv nw ms lm nx ny mu lq nz oa mw ob bi translated">组件范围功能</h2><p id="aa06" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们可以使用<code class="fe lv lw lx ly b">useCallback</code>来确保去抖功能只被创建一次，并且如果它需要访问组件的作用域，它将在组件的整个生命周期中被重用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bb67" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">去抖</h1><p id="0b99" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe lv lw lx ly b">debounce</code>最常见的用例是减少由用户输入触发的函数调用的数量。例如，如果您正在实现一个支持自动完成的组件，您可能不希望在每次击键时都调用后端服务，因为击键的速度很可能比应用程序处理请求的速度快。您需要一种方法来避免服务器不必要的负载，并节省用户宝贵的CPU周期。</p><p id="33b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最佳实践是<code class="fe lv lw lx ly b">debounce</code>服务调用，这意味着函数调用将一直等待，直到从上次调用函数起已经过了预定的时间量。</p><p id="1b47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在下面的代码沙箱中看到它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe od l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2375" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">喉咙</h1><p id="a681" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">throttle</code>功能最多每预定时间调用一次。一个常见的用例是减少调用处理滚动事件的回调函数的次数。例如，如果您正在实现一个支持无限滚动的组件，您将希望在用户接近页面底部时加载下一页/下一批。您很快会注意到，当用户滚动时，scroll事件将被触发多次。</p><p id="72c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这种情况，一个选择是<code class="fe lv lw lx ly b">throttle</code>事件处理函数。您可以在下面的代码沙箱中看到它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe od l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4b50" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="0c0d" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我希望你今天学到了新东西。感谢阅读。</p><p id="19d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保重，下次再见。</p></div></div>    
</body>
</html>