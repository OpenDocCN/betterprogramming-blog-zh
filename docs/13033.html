<html>
<head>
<title>A Better Version of Kickstarter Using Web3.0 — Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Web3.0的Kickstarter的更好版本——Solidity</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-better-version-of-kickstarter-using-web3-0-solidity-8bbea829d2f0?source=collection_archive---------8-----------------------#2022-07-20">https://betterprogramming.pub/a-better-version-of-kickstarter-using-web3-0-solidity-8bbea829d2f0?source=collection_archive---------8-----------------------#2022-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6f83" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为了防止Kickstarter欺诈，贡献者可以对货币决策进行投票</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b25f9e971722703ce958b440728a86b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KxaNo5iT4f7QYt44gUQdCw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">登录页面</p></figure><p id="e15b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇博客中，我将解释如何为Kickstarter制作一个原型，该原型将考虑到项目支持者的投票，以做出关于资金去向的重大决定。在这种情况下，活动经理可以创建一个请求，其中他可以提到收件人的地址和收件人的服务，人们可以投票决定是否批准该服务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lr"><img src="../Images/fa8781ca1b450065e50f5d702c4ff782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gv8HdbZnQUVIEK_UGq-kQw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">参与者查看的请求示例。</p></figure><p id="f542" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，这是一份聪明的合同。智能合同可以被定义为一个实体，它可以发送和接收货币(<em class="ls"> crypto </em>)，而不仅仅是网络上的用户。这是一段管理你的钱以及你如何引导它执行特定功能的代码——因此，是区块链上的程序！</p><p id="d1d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些程序一旦部署就不能修改，并且是最终版本。我们不要深入讨论智能合约的许多有益方面，因为有许多方面，而且时间是相对的。</p><p id="9023" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我将在这里解释智能合约。</p><ol class=""><li id="7d5a" class="lt lu iq kx b ky kz lb lc le lv li lw lm lx lq ly lz ma mb bi translated">创建市场活动的合同。</li><li id="9d0e" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq ly lz ma mb bi translated">处理活动经理如何创建请求以及其他人如何与之交互的合同。</li></ol><p id="0909" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">先说我们的编译器版本和契约函数。</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="ea55" class="mm mn iq mi b gy mo mp l mq mr">pragma solidity ^<strong class="mi ir">0.8.15</strong>;</span><span id="a429" class="mm mn iq mi b gy ms mp l mq mr">contract CampaignCreator{</span><span id="9c0a" class="mm mn iq mi b gy ms mp l mq mr">}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/83087f4da6b18d768ccd9e52325381b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VY_cqCOh9t2lB4C8aufF3A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建活动页面。</p></figure><p id="a186" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将从创建一个结构开始，它接受上面的细节。</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="2ac1" class="mm mn iq mi b gy mo mp l mq mr">struct CreateNewCampaign{<br/>    <strong class="mi ir">address </strong>addressOfNewCampaign;<br/>    <strong class="mi ir">string </strong>name;<br/>    <strong class="mi ir">uint </strong>minimumContribution;<br/>}</span></pre><ul class=""><li id="2ecb" class="lt lu iq kx b ky kz lb lc le lv li lw lm lx lq mu lz ma mb bi translated"><code class="fe mv mw mx mi b">addressOfNewCampaign</code> →要创建的活动的地址。</li><li id="c6b8" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq mu lz ma mb bi translated"><code class="fe mv mw mx mi b">name</code> →要创建的活动的标题。</li><li id="bc1a" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq mu lz ma mb bi translated"><code class="fe mv mw mx mi b">minimumContribution </code> →投票选举活动决策所需的最低捐款额。</li></ul><p id="286f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在用一个数组来存储上述结构的列表。</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="ea12" class="mm mn iq mi b gy mo mp l mq mr">CreateNewCampaign[] public deployedCampaigns;</span></pre><p id="bb5e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里，创建数组的语法如下:</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="0039" class="mm mn iq mi b gy mo mp l mq mr">data_type<!-- --> <!-- -->[]<!-- --> <!-- -->visibility<!-- --> <!-- -->name_of_the_array;</span></pre><p id="78a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，一个创建活动的函数，接受2个参数→活动的最小贡献和标题。</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="75f0" class="mm mn iq mi b gy mo mp l mq mr">function <strong class="mi ir">createCampaign</strong>(uint minimum, string memory _name) public {</span><span id="1f9d" class="mm mn iq mi b gy ms mp l mq mr">Campaign newCampaign = new Campaign(minimum, <em class="ls">msg.sender</em>);</span><span id="cb5b" class="mm mn iq mi b gy ms mp l mq mr"><strong class="mi ir">deployedCampaigns</strong>.push( <strong class="mi ir">CreateNewCampaign</strong>( address(<strong class="mi ir">newCampaign</strong>), _name, minimum) );</span><span id="581d" class="mm mn iq mi b gy ms mp l mq mr">}</span></pre><p id="caec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Line: 1 — <code class="fe mv mw mx mi b"> Campaign newCampaign = new Campaign(minimum, <em class="ls">msg.sender</em>);</code>这里，<code class="fe mv mw mx mi b"><strong class="kx ir">Campaign</strong></code>是我们稍后要编码的活动契约，<code class="fe mv mw mx mi b"><strong class="kx ir">newCampaign </strong></code>是它的实例。我们传入两个参数，即<code class="fe mv mw mx mi b">minimum</code>和<code class="fe mv mw mx mi b">msg.sender</code>，这两个参数调用活动契约的构造函数，我们稍后将在本博客中介绍。<br/> Line: 2 — <code class="fe mv mw mx mi b"><strong class="kx ir">deployedCampaigns</strong>.push( <br/><strong class="kx ir">CreateNewCampaign</strong>( address(newCampaign), _name, minimum) <br/>);</code>这里，我们只是将新创建的合同的值放入我们创建的活动列表中。</p><p id="6c26" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，在这个合同中，检索所有活动的功能。</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="8377" class="mm mn iq mi b gy mo mp l mq mr">function <strong class="mi ir">getDeployedCampaigns</strong>() public view returns ( CreateNewCampaign[] memory) {</span><span id="78de" class="mm mn iq mi b gy ms mp l mq mr">return deployedCampaigns;</span><span id="6bfa" class="mm mn iq mi b gy ms mp l mq mr">}</span></pre><h2 id="6cf7" class="mm mn iq bd my mz na dn nb nc nd dp ne le nf ng nh li ni nj nk lm nl nm nn no bi translated">让我们现在开始活动合同—</h2><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="2448" class="mm mn iq mi b gy mo mp l mq mr">contract Campaign{</span><span id="f983" class="mm mn iq mi b gy ms mp l mq mr">}</span></pre><p id="fb39" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当一个契约被调用时，首先调用的是构造函数。</p><p id="1fc9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将使用两个变量<code class="fe mv mw mx mi b">manager</code>和<code class="fe mv mw mx mi b">minimumContribution</code>来获取活动经理的值和活动的最小贡献。</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="172f" class="mm mn iq mi b gy mo mp l mq mr">address public <strong class="mi ir">manager</strong>;<br/>uint public <strong class="mi ir">minimumContribution</strong>;</span><span id="ded7" class="mm mn iq mi b gy ms mp l mq mr"><strong class="mi ir">constructor</strong>(uint minimum, address creator) {</span><span id="e9cf" class="mm mn iq mi b gy ms mp l mq mr">    manager = creator;<br/>    minimumContribution = minimum;</span><span id="b9e4" class="mm mn iq mi b gy ms mp l mq mr">}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/e60ffeb44aa8a26c4e5d04222d986edd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aZE5Oxtb1whX8ZN4hKoqng.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">访问活动合同的构造者。</p></figure><p id="1939" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，创建一个接受贡献的函数。无论谁投稿，都可以批准活动决策/请求。但在此之前，我们需要将我们的审批者存储在某个地方。</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="4193" class="mm mn iq mi b gy mo mp l mq mr">mapping(address =&gt; bool) public contributer;</span></pre><p id="d45b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个映射帮助我们检查一个特定的地址(用户)是否有贡献。我们只需要将密钥地址改为true。默认情况下，此映射中的所有值都将为假。</p><p id="8e53" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，还有一个获取贡献者计数的变量。</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="6d3f" class="mm mn iq mi b gy mo mp l mq mr">uint public <strong class="mi ir">countOfContributers</strong>;</span><span id="a487" class="mm mn iq mi b gy ms mp l mq mr">function <strong class="mi ir">contribute</strong>() public <strong class="mi ir">payable</strong>{</span><span id="5601" class="mm mn iq mi b gy ms mp l mq mr">  require( msg.value &gt; minimumContribution );<br/>  if(contributers[msg.sender] == false)<br/>  {<br/>    contributers[msg.sender] = true;<br/>    countOfContributers++;<br/>  }</span><span id="7b4b" class="mm mn iq mi b gy ms mp l mq mr">}</span></pre><p id="0912" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，该函数被标记为<code class="fe mv mw mx mi b">payable</code>，这意味着它接受付款。</p><p id="1213" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第1行— <code class="fe mv mw mx mi b"> require( msg.value &gt; minimumContribution );</code>这一行检查发送的值是否大于最小贡献值。<code class="fe mv mw mx mi b">msg.value</code>是正在发送的ETH的数量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/78f93803c1ef9fde2c0badec116506c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*XxNDzF2q4wh3QJrmSTlM8w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">上面的函数是如何调用的。</p></figure><p id="1816" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下一个if语句检查调用contribute函数的地址(用户)是否已经是contributor，如果不是，那么它写入<code class="fe mv mw mx mi b">contributers</code>映射并增加<code class="fe mv mw mx mi b">countOfContributers</code> uint。<br/>这样做是为了正确统计贡献者人数，以防有人不止一次贡献。</p><h2 id="9b07" class="mm mn iq bd my mz na dn nb nc nd dp ne le nf ng nh li ni nj nk lm nl nm nn no bi translated">现在是困难的部分，提出贡献者可以投票的请求。</h2><p id="17b8" class="pw-post-body-paragraph kv kw iq kx b ky nr jr la lb ns ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">首先，创建一个定义请求的结构。</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="c581" class="mm mn iq mi b gy mo mp l mq mr">struct Request{</span><span id="2a25" class="mm mn iq mi b gy ms mp l mq mr">   string title;<br/>   uint fundsRequired;<br/>   address receiver;<br/>   uint approvalCount;<br/>   bool complete;</span><span id="4729" class="mm mn iq mi b gy ms mp l mq mr">}</span></pre><p id="b37e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mv mw mx mi b">title </code> →请求标题<br/> <code class="fe mv mw mx mi b">fundsRequired</code> →所需资金<br/> <code class="fe mv mw mx mi b">receiver</code> →资金(ETH)的接收地址，以完成请求。<br/> <code class="fe mv mw mx mi b">approvalCount</code> →批准请求的人数。<br/> <code class="fe mv mw mx mi b">complete</code> →请求的状态，如果完成，则为真。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/b5c72eee1166afe4509c3bd5161fa737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JseibqEXj1n_i0LnOGdYlA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建请求页面</p></figure><p id="78a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在用一个数组来存储请求列表。</p><p id="23ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mv mw mx mi b">Request[] public requestsArray;</code></p><p id="8bc7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，创建请求的函数。</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="d4d5" class="mm mn iq mi b gy mo mp l mq mr">function <strong class="mi ir">createRequest </strong>( string memory _title , uint _funds , address _receiver ) public{</span><span id="6b08" class="mm mn iq mi b gy ms mp l mq mr"><strong class="mi ir">requestsArray</strong>.push( Request( _title, _funds,_receiver,0, false ) );</span><span id="38e1" class="mm mn iq mi b gy ms mp l mq mr">}</span></pre><h2 id="9995" class="mm mn iq bd my mz na dn nb nc nd dp ne le nf ng nh li ni nj nk lm nl nm nn no bi translated">注意:</h2><p id="7491" class="pw-post-body-paragraph kv kw iq kx b ky nr jr la lb ns ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">我们使用<code class="fe mv mw mx mi b">memory </code>来访问函数中作为参数的字符串，基本上内存所做的是，将被访问变量的范围限制在函数本身。</p><p id="fe77" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们批准这些请求:)</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="2740" class="mm mn iq mi b gy mo mp l mq mr">function approveRequest( uint idOfRequestToApprove ) public {</span><span id="dcbe" class="mm mn iq mi b gy ms mp l mq mr">Request storage requestToApprove = requestsArray[idOfRequestToApprove];</span><span id="b935" class="mm mn iq mi b gy ms mp l mq mr"><strong class="mi ir">require</strong>( contributers[msg.sender] == true );</span><span id="f2a9" class="mm mn iq mi b gy ms mp l mq mr"><strong class="mi ir">require</strong>( approvalsOfAllRequests[msg.sender][idOfRequestToApprove] == false );</span><span id="4ad0" class="mm mn iq mi b gy ms mp l mq mr"><strong class="mi ir">approvalsOfAllRequests</strong>[msg.sender][idOfRequestToApprove] = true;</span><span id="54b4" class="mm mn iq mi b gy ms mp l mq mr"><strong class="mi ir">requestToApprove</strong>.approvalCount++;</span><span id="5e5d" class="mm mn iq mi b gy ms mp l mq mr">}</span></pre><p id="e638" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们用一个<code class="fe mv mw mx mi b">uint </code>参数调用上面的函数— <code class="fe mv mw mx mi b">idOfRequestToApprove</code>这个参数用于访问一个特定的请求，例如:<code class="fe mv mw mx mi b">approveRequest(0)</code>将获得请求数组<code class="fe mv mw mx mi b">requestsArray</code>中的第一个请求。</p><p id="7a5a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第1行— <code class="fe mv mw mx mi b">Request storage requestToApprove = requestsArray[idOfRequestToApprove];</code>该行接受<code class="fe mv mw mx mi b">requestsArray</code>中的<code class="fe mv mw mx mi b">idOfRequestToApprove</code> ( 0，1，2，3，4，5 … a数)请求，并将其存储到<code class="fe mv mw mx mi b">requestToApprove</code>结构中。所以我们可以从<code class="fe mv mw mx mi b">requestsArray</code>访问实际的请求。→我们为此使用存储(存储→存储—通过引用分配)。</p><p id="31a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第2行— <code class="fe mv mw mx mi b"> <strong class="kx ir">require</strong>( contributers[msg.sender] == true );</code>，只是检查批准请求的地址(用户)是否是贡献者。</p><p id="c4c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第3行—这一行用于检查地址(用户)是否已经批准了请求。这是通过双重映射完成的。</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="87da" class="mm mn iq mi b gy mo mp l mq mr"><strong class="mi ir">mapping </strong>( <strong class="mi ir">address </strong>=&gt; <strong class="mi ir">mapping</strong>( uint =&gt; bool )) <strong class="mi ir">approvalsOfAllRequests</strong>;</span></pre><p id="3f96" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里我们用另一个映射来映射地址，这个映射的键是uint，值是bool，这里uint是请求ID，bool是地址是否批准了请求。假设我们想知道XYZ地址是否对第三个请求进行了投票？</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="6701" class="mm mn iq mi b gy mo mp l mq mr">return approvalsOfAllRequests[XYZ][2] == true;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/1df3f7c4779bf5ac58199a90c14a35a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ClCFeEtr8lstJtijwa8_Hw.png"/></div></div></figure><p id="aec3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第4行—该行用于防止地址(用户)再次批准同一请求。<br/>第5行——最后，我们从我们在此函数中访问的相应请求的请求结构中增加批准计数。</p><p id="2be8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后一个功能是完成一个请求。我们确实走过了漫长的道路:)</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="454e" class="mm mn iq mi b gy mo mp l mq mr">function finaliseRequest( uint idOfRequestToApprove)  public {</span><span id="2d89" class="mm mn iq mi b gy ms mp l mq mr">require(msg.sender == mananger);</span><span id="88b4" class="mm mn iq mi b gy ms mp l mq mr">Request storage requestToApprove = requestsKaArray[idOfRequestToApprove];</span><span id="0f48" class="mm mn iq mi b gy ms mp l mq mr">require(requestToApprove.approvalCount&gt;(countOfContributers/2));</span><span id="b790" class="mm mn iq mi b gy ms mp l mq mr">require( requestToApprove.complete == false );</span><span id="23ab" class="mm mn iq mi b gy ms mp l mq mr">require ( address(this).balance &gt; requestToApprove.fundsRequired );</span><span id="ac07" class="mm mn iq mi b gy ms mp l mq mr">requestToApprove.complete == true;</span><span id="d5cc" class="mm mn iq mi b gy ms mp l mq mr">payable( requestToApprove.receiver ).transfer(requestToApprove.fundsRequired);</span><span id="38cc" class="mm mn iq mi b gy ms mp l mq mr">}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/4a10916eb982585463a85f379291f127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o5w7Lf0kXboHhGBSybUTDg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最终确定请求</p></figure><p id="1773" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类似于approve函数，我们传递我们想要访问的请求的uint → ID。</p><p id="66b0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第1行— <code class="fe mv mw mx mi b">require(msg.sender == mananger);</code>检查调用最终功能的地址(用户)是否是活动经理。我们不希望别人来完成我们的请求，是吗？</p><p id="7cd3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第2行—类似于批准功能。</p><p id="52b4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第3行— <code class="fe mv mw mx mi b">require(requestToApprove.approvalCount &gt;(countOfContributers/2));</code>这是为了检查大多数<strong class="kx ir"> </strong>贡献者是否批准了请求。</p><p id="acde" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第4行— <code class="fe mv mw mx mi b"> require( requestToApprove.complete == false );</code>检查请求是否尚未完成。</p><p id="df1c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第5行— <code class="fe mv mw mx mi b"> require ( address(this).balance &gt; requestToApprove.fundsRequired );</code>这是检查合同是否有足够的余额来执行对接收方的交易。我们在<code class="fe mv mw mx mi b">address(this).balance</code>前得到合同的余额。</p><p id="194c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第6行— <code class="fe mv mw mx mi b"> payable( requestToApprove.receiver ). transfer ( requestToApprove . fundsRequired );</code>最后，我们向收款人支付资金:)</p><p id="e686" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是完整的代码:</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="3a95" class="mm mn iq mi b gy mo mp l mq mr"><a class="ae ny" href="https://gist.github.com/Khanisic/5d069575addc0716ce09d4e849027be1" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Khanisic/5d069575addc0716ce09d4e849027be1</a></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/2b21f255d9ff92e6ea5f8d9a835ba544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZOJvET11QjGbqXEafeJKg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们的活动页面</p></figure><h2 id="1ce8" class="mm mn iq bd my mz na dn nb nc nd dp ne le nf ng nh li ni nj nk lm nl nm nn no bi translated">链接</h2><ul class=""><li id="9bcb" class="lt lu iq kx b ky nr lb ns le oa li ob lm oc lq mu lz ma mb bi translated"><a class="ae ny" href="https://crowdcoin-five.vercel.app/" rel="noopener ugc nofollow" target="_blank">维尔塞尔部署的链接</a></li><li id="6467" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq mu lz ma mb bi translated"><a class="ae ny" href="https://github.com/Khanisic/Crowdcoin" rel="noopener ugc nofollow" target="_blank"> Github </a></li><li id="db74" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq mu lz ma mb bi translated"><a class="ae ny" href="https://www.figma.com/file/Tx5fzNUGJ1vB4CcsqsWfIj/Crowdcoin's-Figma?node-id=0%3A1" rel="noopener ugc nofollow" target="_blank"> Figma设计文件</a></li></ul></div></div>    
</body>
</html>