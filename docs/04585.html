<html>
<head>
<title>ES2019: A Refresher on Some Important Changes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2019:一些重要变化的回顾</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/es2019-a-refresher-on-some-important-changes-c72ea3b09823?source=collection_archive---------20-----------------------#2020-04-22">https://betterprogramming.pub/es2019-a-refresher-on-some-important-changes-c72ea3b09823?source=collection_archive---------20-----------------------#2020-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4937" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">ES10中更改或添加的内容</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/91af638e2487fc2152d6b94cb16a575d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CrQl7WgHMLs6wOuE"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@tormius?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Adrià Tormo </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="1b4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果ECMAScript过去的发布时间表为将来的发布提供了任何线索，那么。Next将于2020年6月左右发布。随着这个即将发布的版本，我认为重温一下ES10中的一些变化或添加会很好。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0b83" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">Array.flat()</h1><p id="5951" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mw mx my mz b">Array.flat()</code>是一个数组方法，当应用该方法时，返回一个嵌套数组被展平的新数组。该方法接受一个选项来指定要展平的数组的深度。如果未指定金额，则默认为1。如果指定的数量大于数组的深度，则数组会一直展平。<code class="fe mw mx my mz b">Array.flat()</code>也可以连续调用。在这里，我们可以看到<code class="fe mw mx my mz b">array.flat()</code>在使用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="10c2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">Array.flatMap()</h1><p id="b76c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mw mx my mz b">Array.flatMap()</code>做的和它听起来的一样:它获得了ES6 map方法的功能，并将其与前面提到的<code class="fe mw mx my mz b">Array.flat()</code>方法的功能相结合。实际上，<code class="fe mw mx my mz b">flatMap()</code>首先运行我们指定的map函数，然后返回一个包含指定函数输出的扁平数组。在操作中，<code class="fe mw mx my mz b">flatMap()</code>看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ef1b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">Object.fromEntries()</h1><p id="1533" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">此方法从键值对列表中创建一个对象:</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="d577" class="ng ma iq mz b gy nh ni l nj nk">let myEntries = new Map([[“name”, “zach”], [“coffee”, “yes”]]);</span><span id="f7e8" class="ng ma iq mz b gy nl ni l nj nk">console.log(Object.fromEntries(myEntries));</span><span id="d302" class="ng ma iq mz b gy nl ni l nj nk">// { name: ‘zach’, coffee: ‘yes’ }</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="24bc" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">String.trimStart()和String.trimEnd()</h1><p id="64e7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mw mx my mz b">String.trimStart()</code>和<code class="fe mw mx my mz b">String.trimEnd()</code>是新的方法，可以分别用来删除字符串开头和结尾的任何空白:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ed3a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">数组。Sort()稳定性</h1><p id="5891" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果一个数组先排序，然后再排序，如果两种排序不冲突，那么得到的数组将保留这两种排序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4eaf" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">Function.toString()</h1><p id="b70a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mw mx my mz b">.toString()</code>现在返回函数的精确文本，包括注释和空格:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="2d2a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">JSON超集</h1><p id="4b76" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这一改变允许段落分隔符(<code class="fe mw mx my mz b">(U+2029)</code>)和行分隔符(<code class="fe mw mx my mz b">(U+2028)</code>)位于字符串中。在旧版本中，它们会导致抛出语法异常。</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="056f" class="ng ma iq mz b gy nh ni l nj nk">// Not valid in before ES2019</span><span id="172e" class="ng ma iq mz b gy nl ni l nj nk">eval(‘“\u2028”’);</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f4fb" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">符号.描述()</h1><p id="176a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">返回符号对象的只读可选描述属性:</p><pre class="kg kh ki kj gt nc mz nd ne aw nf bi"><span id="a2e9" class="ng ma iq mz b gy nh ni l nj nk">let sym = “foo”</span><span id="53c3" class="ng ma iq mz b gy nl ni l nj nk">let symObject = Symbol(sym)</span><span id="8366" class="ng ma iq mz b gy nl ni l nj nk">console.log(symObject.description);</span><span id="e644" class="ng ma iq mz b gy nl ni l nj nk">//Returns ‘foo’</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3edd" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">可选Catch绑定</h1><p id="6f02" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在以前的规范中，catch子句需要向其传递一个参数。ES10改变了这一点。现在，catch子句可以选择接受参数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c82f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="3f0d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我认为看到JavaScript不断获得新特性并随着每个新版本变得更加高效是令人兴奋的。现在，在成为标准的过程的第三阶段有几个提议。你可以在GitHub 上了解最新的提议<a class="ae kv" href="https://github.com/tc39/proposals" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>