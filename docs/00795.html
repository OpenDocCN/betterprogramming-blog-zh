<html>
<head>
<title>iOS — Advanced Memory Debugging to the Masses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS —面向大众的高级内存调试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ios-advanced-memory-debugging-to-the-masses-24d25852a91c?source=collection_archive---------6-----------------------#2019-07-15">https://betterprogramming.pub/ios-advanced-memory-debugging-to-the-masses-24d25852a91c?source=collection_archive---------6-----------------------#2019-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cd85" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入挖掘虚拟内存</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/45a0c9e3ab0ef54ebaff39be39eb4ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*16XM82932ejgTr_11TS2wQ.jpeg"/></div></div></figure><h1 id="a56e" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">概观</h1><p id="abe2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在“<a class="ae mi" href="https://medium.com/better-programming/reducing-your-apps-memory-footprint-b7afcb9f3749" rel="noopener">如何降低你的应用程序的内存占用</a>”中，我解释了如何降低你的应用程序的内存。但有时，我们需要更深入地了解问题的根源。为了做到这一点，我们需要知道什么是虚拟内存，我们有什么调试工具，因此，一般提示来帮助我们完成这项任务。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="dc16" class="ku kv it bd kw kx mq kz la lb mr ld le jz ms ka lg kc mt kd li kf mu kg lk ll bi translated">什么是虚拟内存？</h1><p id="32a4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">不同的设备有不同数量的RAM，将不同的RAM系统抽象为一个统一的地址系统的技术称为虚拟内存。</p><p id="c760" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">虚拟内存并不是iOS独有的。事实上，所有现代操作系统都使用虚拟内存，这是60多年前开发的！</p><p id="9c95" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">虚拟内存地址是“虚拟的”意味着它们不必与您拥有的任何物理地址对齐。事实上，虚拟内存地址只受您的处理器架构的限制—32位处理器可以处理4GB的地址，64位处理器可以处理18eb，即19，327，352，832 GB！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="450a" class="ku kv it bd kw kx mq kz la lb mr ld le jz ms ka lg kc mt kd li kf mu kg lk ll bi translated">iPhones没有19,327,352,832 GB</h1><p id="5802" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">你不应该对此感到惊讶，但iPhones没有这么大的内存。事实上，你需要超过10亿台新的MacBook pros才能达到这个内存大小。</p><p id="a724" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">但从app的角度来看，其实并不重要。应用程序中的每个进程都获得这个虚拟内存空间，并且可以访问该空间中的每个地址。</p><p id="14b7" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">您应该考虑到每个虚拟内存空间都有相同的地址列表。一个进程中的相同地址在其他进程中是不同的物理地址，因此该进程不能访问其他进程上的内存块。</p><p id="50ad" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">每个虚拟内存空间都将一个虚拟地址映射到一个物理地址。由于没有18eb的设备，系统可能会遇到限制。与OSX不同，iOS没有后备存储，这意味着iOS不使用磁盘来保存内存数据，因此系统仅受限于其物理RAM大小。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="418c" class="ku kv it bd kw kx mq kz la lb mr ld le jz ms ka lg kc mt kd li kf mu kg lk ll bi translated">干净和脏的页面</h1><p id="915b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">虚拟内存将其空间划分为称为页面的块。页面是16KB的块，可以保存任何类型的数据。</p><p id="41cf" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">数据也可以包含在几个页面中，一个页面可以容纳多种数据。</p><p id="b31f" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">这里需要知道的最重要的一点是，页面可以被标记为脏、干净或压缩。</p><p id="89c5" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">干净内存可以从磁盘加载(“页面调出”)，包含框架、可执行代码和只读文件。</p><p id="4ca7" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">脏内存是由应用程序、堆分配、单例、全局初始化器和堆栈写入的任何内存。</p><p id="d4be" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">压缩内存包括未访问的页面，可以根据您的应用程序使用情况进行压缩或解压缩。</p><p id="74dd" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">底线—您正在使用的内存是您的脏内存+压缩内存。你可以很容易地忽略干净的记忆，因为你可以随时恢复它。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="be64" class="ku kv it bd kw kx mq kz la lb mr ld le jz ms ka lg kc mt kd li kf mu kg lk ll bi translated">调试内存的工具</h1><p id="03d1" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在我们知道了所有重要的术语，如虚拟内存、脏内存和干净内存以及分页，我们可以更好地理解我们用来调试内存问题的高级工具。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="512e" class="ku kv it bd kw kx mq kz la lb mr ld le jz ms ka lg kc mt kd li kf mu kg lk ll bi translated">虚拟机跟踪器</h1><p id="f9c3" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">虚拟机跟踪器是分配工具的一部分。</p><p id="d82e" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">若要在Instruments中描述应用程序，请在Xcode中选择“产品”-&gt;“描述文件”。或者，您可以长按“播放”按钮，然后选择“个人资料”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/4bc35099c80c995406bc80200d174b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/0*Y4rzh4pOe1VF7qVi"/></div></figure><p id="92c7" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">仪器打开后，选择“分配”,并运行profiler。</p><p id="b3e2" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">现在您将看到两个工具——一个是堆分配，另一个是VM跟踪器。虚拟内存跟踪器可以帮助您跟踪您最感兴趣的内存类型:脏内存。</p><p id="c9d6" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">大多数时候，一开始你不会在虚拟机跟踪器上看到任何数据。那是因为VM Tracker不会持续显示你的虚拟内存状态。你必须拍快照来分析你的记忆。如果您点击虚拟机跟踪器行，窗口底部会显示一个“快照”按钮。点击此按钮将允许您设置快照间隔，甚至手动拍摄快照。</p><p id="63cd" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">有了快照后，您可以看到一段时间内的脏内存状态。您还可以看到哪些对象占用了您的大部分脏内存。如果您想更深入地了解，可以使用VMMap，它非常适合高级内存调试。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2bbe" class="ku kv it bd kw kx mq kz la lb mr ld le jz ms ka lg kc mt kd li kf mu kg lk ll bi translated">命令行工具— VMMap</h1><p id="d9be" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">除了Heap和Leaks之外，VMMap是一个很棒的命令行工具，旨在调试虚拟内存环境中的内存对象。</p><p id="5247" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">为了使用它，VMMap需要您的应用程序的内存图形文件。生成一个很容易——在Xcode中，通过点击窗口底部的“调试内存图”按钮来停止应用程序运行，然后在“文件”菜单下，选择“导出内存图”。该选项将生成一个可用于VMMap的内存图文件。</p><p id="20b3" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">使用VMMap的第一步是获取虚拟内存映射的概要。</p><p id="1d00" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">在终端中写入:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="7226" class="ng kv it nc b gy nh ni l nj nk">VMMap -summary &lt;memgraph file&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/fa4289513c917027675ffc7c0f2f5576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Va23W9Gf7J83LXr4"/></div></div></figure><p id="a6f1" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated"><code class="fe nm nn no nc b"><em class="np">__TEXT</em> </code> —包含可执行代码和常量</p><p id="996d" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated"><code class="fe nm nn no nc b"><em class="np">__DATA</em></code> —嗯，数据:)</p><p id="1d28" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated"><code class="fe nm nn no nc b"><em class="np">__OBJC</em> </code> —如果您的应用程序包含目标C代码，则此区域包含目标C运行时库代码</p><p id="59e9" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated"><code class="fe nm nn no nc b">Shared Memory</code> —与其他应用程序共享的系统库，如Cocoa和OpenGL</p><p id="7e3e" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated"><code class="fe nm nn no nc b">Mapped file</code> —该区域包含经常访问的文件内容，这些内容被映射到虚拟内存，以便能够更快地访问</p><p id="a11a" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated"><code class="fe nm nn no nc b">Stack</code> —包含堆栈存储器，包括每个函数调用的参数。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f0ed" class="ku kv it bd kw kx mq kz la lb mr ld le jz ms ka lg kc mt kd li kf mu kg lk ll bi translated">脏与干净</h1><p id="8083" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们之前提到了脏内存和干净内存，但这意味着什么呢？最简单的解释是，干净内存是指，如果丢失了，你可以从代码或存储器中恢复。</p><p id="54bd" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">在VMMap summary报告中，您可以看到<code class="fe nm nn no nc b">__LINKEDIT</code>区域占用了超过100MB的虚拟内存，但却占用了0MB的脏内存，这是因为<code class="fe nm nn no nc b">__LINKEDIT</code>区域引用了保存在文件中的符号表，因此可以恢复。</p><p id="bce3" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">从结果可以看出，使用中的内存真的只是脏内存。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="66d1" class="ku kv it bd kw kx mq kz la lb mr ld le jz ms ka lg kc mt kd li kf mu kg lk ll bi translated">让我们调试内存问题</h1><p id="9122" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">那么如何利用内存命令工具呢？</p><p id="45dd" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">假设我们的应用程序内存有问题:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/5899b426cdb7ee02efe6b6c26b87adf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZBX5bhA2fLXhnkCv"/></div></div></figure><p id="b011" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">你可以看到，我们的应用程序启动后需要644MB。</p><p id="5c96" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">在我们生成一个内存图文件后，我们将使用VMMap来了解是什么类型的内存导致了这个问题。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="727f" class="ng kv it nc b gy nh ni l nj nk">VMMap -summary data.memgraph</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/eb04e7b92dd59b82fa8d0d556305ef6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b_ftqJfDV5eD98Hh"/></div></div></figure><p id="5ef2" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">我们注意到<code class="fe nm nn no nc b">MALLOC_LARGE</code>和<code class="fe nm nn no nc b">MALLOG_TINY</code>区域总共占用了589MB。如果我们想查看关于<code class="fe nm nn no nc b">MALLOC_LARGE</code>区域的更多细节，我们可以使用<code class="fe nm nn no nc b">verbose</code>标志和<code class="fe nm nn no nc b">grep</code>来查看内存块列表:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="b768" class="ng kv it nc b gy nh ni l nj nk">vmmap --verbose data.memgraph | grep "MALLOC_LARGE"</span></pre><p id="f866" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">因此，我们找到了一个有趣的块，它占用了我们大约76MB的空间。为了追踪那个对象，我们需要使用<code class="fe nm nn no nc b">Leaks</code>工具，带有<code class="fe nm nn no nc b">traceTree</code>标志和地址:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="e416" class="ng kv it nc b gy nh ni l nj nk">leaks -traceTree 0x0000000014210f00 data.memgraph</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/2c2f5cad11590c782bbf00001fd1fbd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IZjs0XtmHm5M_Ty1"/></div></div></figure><p id="d2b1" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">现在，显示的跟踪树可以告诉我们，问题出在名为<code class="fe nm nn no nc b">LoadingViewController</code>的视图控制器中的一个类名为“Note”的数组上。对我们有好处！</p><p id="ba08" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">总结一下-</p><p id="b68d" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">步骤1-将内存图导出到文件。</p><p id="19df" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">步骤2 —使用带有<code class="fe nm nn no nc b">— summary</code>标志的<code class="fe nm nn no nc b">vmmap</code>运行该文件的概述信息</p><p id="dec6" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">步骤3 —跟踪一个大的脏区域，并使用<code class="fe nm nn no nc b">— verbose</code>标志对其进行检查</p><p id="ca2b" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">步骤4-找到一个大数据块，并使用<code class="fe nm nn no nc b">Leaks</code>命令找到其来源。</p><p id="ef0a" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">这真的很棒，但是如何从一开始就防止应用程序中的脏内存变大呢？</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="113c" class="ku kv it bd kw kx mq kz la lb mr ld le jz ms ka lg kc mt kd li kf mu kg lk ll bi translated">减少脏内存</h1><p id="58bf" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了减少脏内存，我们需要记住我们在应用程序中动态创建并保留的数据是脏内存。</p><p id="d195" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">此外，请记住，如果缓存用CPU换取内存，您可以用内存换取更多的CPU工作或本地存储。</p><p id="6a52" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">减少应用程序中脏内存的技巧:</p><ul class=""><li id="fa3d" class="ns nt it lo b lp mv ls mw lv nu lz nv md nw mh nx ny nz oa bi translated">尽量使用常量而不是变量:出于安全考虑，Swift鼓励您尽可能使用<code class="fe nm nn no nc b">let</code>，但是使用<code class="fe nm nn no nc b">let</code>也可以减少您的脏内存。事实上，当country应用程序内存时，<code class="fe nm nn no nc b">let</code>对象根本不算数，因为它是代码的一部分，因此它被认为是干净的内存。</li><li id="0859" class="ns nt it lo b lp ob ls oc lv od lz oe md of mh nx ny nz oa bi translated">将大数据对象保存到本地存储，并在需要时加载它们:如果可以将数据保存到缓存文件中，并在需要时加载，就可以释放脏内存。可以把它想象成大块信息的全球存储器。</li><li id="b98c" class="ns nt it lo b lp ob ls oc lv od lz oe md of mh nx ny nz oa bi translated">在堆栈中分配变量:在堆栈中分配变量，也就是说，将它们作为方法变量进行分配，并不计入脏内存列，但是一旦方法完成了它们的运行，这些内存就被释放了。</li><li id="fe53" class="ns nt it lo b lp ob ls oc lv od lz oe md of mh nx ny nz oa bi translated">尽可能使用最小的数据类型:默认的<code class="fe nm nn no nc b">Int</code>数据类型基于CPU架构。在64位设备中，这几乎是今天所有的活动设备，默认的<code class="fe nm nn no nc b">Int</code>实际上是<code class="fe nm nn no nc b">Int64</code>。所以尽可能使用<code class="fe nm nn no nc b">Int8</code> / <code class="fe nm nn no nc b">Int16</code>。</li><li id="7824" class="ns nt it lo b lp ob ls oc lv od lz oe md of mh nx ny nz oa bi translated">使用延迟加载:只在需要的时候分配对象总是最佳实践。Swift中的延迟加载就是为了这个。如果你实现了它，有可能这些对象根本不会被分配。</li></ul><p id="2a16" class="pw-post-body-paragraph lm ln it lo b lp mv ju lr ls mw jx lu lv mx lx ly lz my mb mc md mz mf mg mh im bi translated">所有这些技巧看起来都微不足道，但是通过将它们结合起来，你可以节省大量的内存，并改善你的用户体验。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="09f0" class="ku kv it bd kw kx mq kz la lb mr ld le jz ms ka lg kc mt kd li kf mu kg lk ll bi translated">摘要</h1><p id="cca8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">你可以悄悄地忽略这篇文章，继续开发iOS应用程序，但了解这些材料可以帮助你调查与内存问题相关的问题，并在第一时间防止它们，因此，给你的应用程序带来用户体验的巨大提升。</p></div></div>    
</body>
</html>