<html>
<head>
<title>How to Build a Camera App With SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用SwiftUI构建相机App</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/effortless-swiftui-camera-d7a74abde37e?source=collection_archive---------0-----------------------#2020-10-26">https://betterprogramming.pub/effortless-swiftui-camera-d7a74abde37e?source=collection_archive---------0-----------------------#2020-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9285" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">毫不费力的SwiftUI相机教程</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/a8347edcc3e06692efb89ffdf1e0e17d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQ6PJ2f9GfIO3iuKDNZxqA.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">最终项目UI(图片来源:作者；来自Unsplash的取景器图像)</p></figure><p id="06e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我的名为轻松SwiftUI的新系列的第一篇文章。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="a9a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SwiftUI已经被证明是一个非常棒的新框架，可以快速可靠地构建和设计应用程序。尽管如此，它仍处于起步阶段，苹果需要为其他框架集成添加更多支持，就像它最近在SwiftUI 2.0中使用苹果按钮登录一样。在本教程中，我们将学习如何将<a class="ae lz" href="https://developer.apple.com/av-foundation/" rel="noopener ugc nofollow" target="_blank"> AVFoundation </a>的<code class="fe ma mb mc md b">AVCameraSession</code>与SwiftUI集成，以便我们可以为需要使用我们设备摄像头的应用程序创建可重用、可扩展的现代组件。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7e27" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">我们开始吧</h1><p id="ac3b" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">首先，让我们创建一个新项目。我把我的命名为SwiftCamera，但是你可以随意命名你的。现在让我们从相机用户界面背后的大脑开始。</p><h2 id="d5bf" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lf ng nh mq lj ni nj ms ln nk nl mu nm bi translated">照相服务</h2><p id="bcfc" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">相机服务将是负责使用所有AVFoundation类的组件，这些类需要连接到iPhone的相机并捕捉您一直等待的精彩镜头。因此，向您的项目添加一个新文件，并将其命名为<code class="fe ma mb mc md b">CameraService.swift</code>。确保它是一个类，并使其成为<code class="fe ma mb mc md b">NSObject</code>的子类。</p><p id="568a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">属性。</strong>让我们从使我们的相机服务工作的主要属性开始。我就一一列举，详细说明它们的用法。</p><p id="8a0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先让我们从用户界面将与之对话的对象开始，这些对象标有<code class="fe ma mb mc md b">Published</code> <strong class="ky ir"> <em class="nn"> </em> </strong>属性包装器。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="no np l"/></div></figure><ol class=""><li id="426d" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated"><code class="fe ma mb mc md b">flashMode</code>:告诉观察者闪光灯是开着还是关着。</li><li id="8add" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated"><code class="fe ma mb mc md b">shouldShowAlertView</code>:告诉观察者UI是否应该显示警告视图。</li><li id="1cca" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated"><code class="fe ma mb mc md b">shouldShowSpinner</code>:告诉观察者UI是否应该显示一个微调按钮，指示正在处理捕获的照片。</li><li id="9cee" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated"><code class="fe ma mb mc md b">willCapturePhoto</code>:告诉观察者照片即将被拍摄。非常适合在捕捉镜头前闪烁屏幕或播放动画。</li><li id="b54b" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated"><code class="fe ma mb mc md b">isCameraButtonDisabled</code>:不言自明。我们从设置为<code class="fe ma mb mc md b">false</code>的值开始，一旦我们成功配置了摄像机会话，我们就将该值设置为<code class="fe ma mb mc md b">true</code>。</li><li id="14fa" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated"><code class="fe ma mb mc md b">isCameraUnavailable</code>:不言自明。我们从设置为<code class="fe ma mb mc md b">false</code>的值开始，一旦我们成功配置了摄像机会话，我们就会将该值设置为<code class="fe ma mb mc md b">true</code>。</li><li id="cce0" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated"><code class="fe ma mb mc md b">photo</code>:照片输出。这种情况下的结构<code class="fe ma mb mc md b">Photo</code>非常简单。一旦照片被捕获和处理，观察者将获得一个新的值。</li></ol><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="df24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们继续处理两个公共属性和一些其他内部和私有属性，只有我们的服务会处理这些属性。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a20c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">隐私</strong>。iOS对隐私非常敏感，所以请确保在项目的<code class="fe ma mb mc md b">info.plist</code>文件中添加相机使用说明。一旦我们完成了，让我们创建我们的第一个函数，<code class="fe ma mb mc md b">checkForPermissions()</code>。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5da8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来看看这个函数。我们应该确定我们的应用程序当前的摄像头访问隐私配置。为此，AVFoundation为我们提供了一个方便的函数，返回当前状态，<code class="fe ma mb mc md b">AVCaptureDevice.authorizationStatus(.video)</code>。然后，基于返回值，我们执行不同的操作。如果状态是授权的，就这样，我们成功返回。否则，如果状态未确定，我们暂停<code class="fe ma mb mc md b">sessionQueue</code>以便暂停任何即将完成的配置，并且我们请求用户允许使用摄像机。默认情况下，我们假设用户已经拒绝访问，所以我们用我们之前创建的便捷的<code class="fe ma mb mc md b"> AlertError</code>类型显示一个警告错误，并告诉UI禁用相机视图和捕获按钮。</p><p id="627c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">会话配置。这是必不可少的。要配置我们的捕获会话，首先我们要检查我们之前是否已经配置了它。如果是这样，我们返回；否则，我们通过在捕获会话中调用<code class="fe ma mb mc md b">beginConfiguration()</code>来锁定它，开始配置，我们将会话预设设置为photo，然后开始捕获设备发现。一旦设置好捕捉设备，我们就连接我们的<code class="fe ma mb mc md b">photoCaptureOutput</code>并将其配置为<code class="fe ma mb mc md b">maxPhotoQualityPrioritization</code>设置为<code class="fe ma mb mc md b">quality</code>。一旦所有这些都完成了，我们通过在捕获会话中调用<code class="fe ma mb mc md b">commitConfiguration()</code>来提交更改。最后，让我们通过将<code class="fe ma mb mc md b">isConfigured</code>设置为<code class="fe ma mb mc md b">true</code>来存储配置状态。由于会话已成功配置，我们现在可以通过调用<code class="fe ma mb mc md b">start()</code>开始从设备捕获视频。</strong></p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ef4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">开始预览视频拍摄。</strong>正确配置捕获会话后，我们就可以开始从摄像机接收视频预览帧了。为此，我们在捕获会话中调用<code class="fe ma mb mc md b">startRunning()</code>。但是首先我们需要检查配置结果状态是什么。如果配置失败，我们创建一个<code class="fe ma mb mc md b">AlertError</code>，并通过分配给<code class="fe ma mb mc md b">shouldShowAlertView</code>属性将其发布给观察者。如果配置成功，我们应该启用快门按钮，并通过将<code class="fe ma mb mc md b">isCameraButtonDisabled</code>和<code class="fe ma mb mc md b">isCameraUnavailable</code>改为false来告诉UI相机可用。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="00e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">停止预览视频拍摄。</strong>视频捕获会话独立于声明依赖它的对象运行。这意味着，如果我们有一个带有摄像头预览的视图，并将其附加到我们的<code class="fe ma mb mc md b">CameraService</code>，然后我们关闭这个视图并取消初始化<code class="fe ma mb mc md b">CameraService</code>，摄像头捕获会话将继续运行。在iOS14上，这一点更加明显，因为我们可以在设备上看到绿点。因此，当我们退出视图或者不再需要运行这个资源时，我们需要停止捕获会话。为此，我们编写以下函数:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="fa23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的函数采用一个可选的闭包作为完成处理程序来执行，以防我们将来需要它。</p><p id="a3cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">在摄像机之间切换</strong>。做到这一点非常容易。我们只需要在当前视频设备的基础上设置一个新的视频设备。首先，我们需要禁用快门按钮，这样配置过程就不会中断。然后，基于当前的视频捕获设备，我们设置一个新的位置，可以是前部或后部，使用这个新值，初始化一个设备发现会话，从中我们将选择一个具有我们感兴趣的位置的设备。一旦我们获得了正确的设备，我们就像一开始那样配置它。配置完成后，我们提交更改并启用快门按钮。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="02bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">变焦</strong>。缩放是一个相当简单的任务:我们只需要在设备上设置缩放因子。我们将在下一个函数中获取一个带有所需缩放因子的参数，并配置视频设备。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="de94" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lf ng nh mq lj ni nj ms ln nk nl mu nm bi translated">捕捉照片</h2><p id="8ae8" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">我们终于到了。如前所述，我们的<code class="fe ma mb mc md b">photoOutput</code>对象将负责捕捉实际的照片。因此，我们需要为每次拍摄照片配置一组设置，如闪光灯、曝光等设置。在那之后，我们需要在实际的照片捕捉之前做最后一件事，那就是在我们的<code class="fe ma mb mc md b">photoOutput</code>中设置<code class="fe ma mb mc md b">AVCapturePhotoCaptureDelegate</code>。为此，我们将创建一个新类。我给我的取名<code class="fe ma mb mc md b">PhotoCaptureProcessor</code>。这个对象将负责处理由<code class="fe ma mb mc md b">AVCapturePhotoCaptureDelegate</code>协议的方法声明的照片捕获过程的各种状态。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b4e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了一个合适的对象来处理委托方法，这就是我们的<code class="fe ma mb mc md b">CameraService</code>类中实际的照片捕获函数。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="42ef" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lf ng nh mq lj ni nj ms ln nk nl mu nm bi translated">视图模型</h2><p id="0cd8" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">在进入SwiftUI的UI设计之前，我们需要一个关键的组件来使这个应用程序可组合和可重用，也就是说，要将UI与我们的<code class="fe ma mb mc md b">CameraService</code>链接起来。在本教程中，我们将使用MVVM作为我们的设计模式的选择，所以每个视图需要一个模型。对于我们的<code class="fe ma mb mc md b">CameraView</code>，我们将创建一个<code class="fe ma mb mc md b">CameraViewModel</code>。这个对象将负责使用<code class="fe ma mb mc md b">CameraService</code>，配置它并代表UI调用它的所有方法，以及进行任何需要的数据格式化。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="9175" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lf ng nh mq lj ni nj ms ln nk nl mu nm bi translated">带有SwiftUI的UI</h2><p id="1446" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">好了，我们的相机应用程序背后的大脑已经足够了。现在让我们快速为我们的应用程序创建一个漂亮的视图。这个视图足够简单，可以做以下事情:</p><p id="cd2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">A.使用捕捉按钮捕捉照片</p><p id="c73d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">B.设置拍摄的闪光模式</p><p id="2a59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">C.设置缩放因子</p><p id="5f67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">D.在前置和后置摄像头之间切换</p><p id="69a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">E.预览从摄像机捕获的视频</p><p id="b8db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">F.显示刚刚捕获的照片的小缩略图</p><p id="0ad1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧！让我们开始吧。首先，我们需要一种方法将<code class="fe ma mb mc md b">CameraService</code>捕获会话数据传递给SwiftUI中的视图。为此，我们需要创建一个符合<code class="fe ma mb mc md b">UIViewRepresentable</code>协议的特殊视图，如下所示。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="39fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">那么，这到底是怎么回事呢？</strong></p><ol class=""><li id="f452" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated">我们创建了一个UIView子类，它覆盖了UIView的层类型并将其设置为<code class="fe ma mb mc md b">AVCaptureVideoPreviewLayer</code>，然后我们创建了一个名为<code class="fe ma mb mc md b">videoPreviewLayer</code>的新get-only属性，它将UIView的层转换为<code class="fe ma mb mc md b">AVCaptureVideoPreviewLayer</code>。这样，我们可以在SwiftUI中使用这个新创建的视图<code class="fe ma mb mc md b">VideoPreviewView</code>，并使用<code class="fe ma mb mc md b">.frame()</code>视图修改器<strong class="ky ir"> </strong>设置它的框架和大小，而不需要在<code class="fe ma mb mc md b">VideoPreviewView</code> init中传递一个CGRect框架来手动修改视频预览层，就像我在社区中的其他解决方案中看到的那样。</li><li id="be19" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">我们声明了对由<code class="fe ma mb mc md b">CameraService</code>提供的<code class="fe ma mb mc md b">AVCaptureSession</code>属性的依赖，并使用该会话将其设置为<code class="fe ma mb mc md b">AVCaptureViewPreviewLayer</code>的会话，这样视频预览层就可以输出摄像机正在捕捉的内容。</li><li id="829c" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated"><code class="fe ma mb mc md b">UIViewRepresentable</code>协议提供了两种方法，<code class="fe ma mb mc md b">makeUIView()</code>和<code class="fe ma mb mc md b">updateUIView()</code>。到目前为止，我们只需要<code class="fe ma mb mc md b">makeUIView()</code>返回我们的视图。这里我们将初始化刚刚创建的<code class="fe ma mb mc md b">VideoPreviewView</code>的一个实例，并添加一些配置。</li></ol><p id="b94f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在转到SwiftUI。创建一个新的SwiftUI视图并将其命名为<code class="fe ma mb mc md b">CameraView</code>。这里我们将声明一些东西:一个快门按钮，一个闪光灯按钮，一个预览缩略图，和一个相机的预览。</p><p id="c401" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们需要在SwiftUI中构建的UI结构。这是一个简单的用户界面。如果我们知道主要组件是垂直组织的，那么我们应该使用VStack。对于底部区域，最好使用HStack来按住缩略图、快门按钮和翻转相机按钮。仅此而已。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oe"><img src="../Images/170fed74ba5a7ff0e78af4c5641d0051.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NC-E-bUSf52126xfiGDYLA.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">UI结构</p></figure><p id="e638" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在是SwiftUI代码，以及将它连接到<code class="fe ma mb mc md b">CameraViewModel</code>并根据需要调用其功能所需的所有连线。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8da6" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">结论</h1><p id="d061" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">相机应用在第一次尝试时总是有点棘手。这就是为什么我很高兴终于写了一篇相当长但完整的文章，讲述如何用SwiftUI制作一个基本的相机应用程序。</p><p id="c754" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SwiftUI是一个令人敬畏的现代框架，随着我们用它创建新的应用程序并在社区中推广它的使用，它肯定会在不久的将来被更多人采用。注意到SwiftUI迫使开发人员应用关注点分离原则也很重要，因为在本文中我们已经将<code class="fe ma mb mc md b">CameraService</code>从<code class="fe ma mb mc md b">CameraViewModel</code>和<code class="fe ma mb mc md b">CameraView</code>中分离出来，每个人都有自己的职责；这将允许我们在应用程序中构建可重用、可共享和可组合的组件。遵循这种做法不会有什么损失。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="65de" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">资源</h1><p id="a648" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">如果你想看看这个项目的全部代码，你可以在这里找到:</p><p id="517b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae lz" href="https://github.com/rorodriguez116/SwiftCamera" rel="noopener ugc nofollow" target="_blank">https://github.com/rorodriguez116/SwiftCamera</a></p><p id="ce9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还制作了一个SwiftPackage，将<code class="fe ma mb mc md b">CameraService</code>和<code class="fe ma mb mc md b">VideoPreviewView</code>与你喜欢的应用程序中的任何自定义用户界面集成在一起:</p><p id="512a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae lz" href="https://github.com/rorodriguez116/Camera-SwiftUI" rel="noopener ugc nofollow" target="_blank">https://github.com/rorodriguez116/Camera-SwiftUI</a></p></div></div>    
</body>
</html>