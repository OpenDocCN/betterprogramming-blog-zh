<html>
<head>
<title>6 Hidden Pitfalls of TypeScript You Should Know In TS 4.4.4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TS 4.4.4中您应该知道的6个隐藏的TypeScript陷阱</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-hidden-pitfalls-of-typescript-you-should-know-d7bae9cf4aa5?source=collection_archive---------4-----------------------#2021-11-22">https://betterprogramming.pub/6-hidden-pitfalls-of-typescript-you-should-know-d7bae9cf4aa5?source=collection_archive---------4-----------------------#2021-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e074" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这些陷阱将向你揭示</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/42fd1bc7472225029ca89b3a707af9c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5jYEYJXjbt0DGEDZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@exxteban?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Esteban Lopez </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1241" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">为什么介绍？这些陷阱已经浪费了足够多的时间，我们走吧！</em></p><blockquote class="lw lx ly"><p id="96fd" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">在TS版本4.4.4中经过测试和验证</p></blockquote><h1 id="92f8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.希望你永远不会看到“永远”这种类型</h1><p id="3fbb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">不要用两个不同的接口来构建一个类型。</p><p id="b8c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mz na nb nc b">&amp;</code>操作符保持安全，但不要使用<code class="fe mz na nb nc b">|</code>操作符，否则打字稿会用<code class="fe mz na nb nc b">never</code>打你。</p><p id="ea2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，检查您是否创建了来自<code class="fe mz na nb nc b">User</code>或<code class="fe mz na nb nc b">Log</code>的联合<code class="fe mz na nb nc b">UserOrLog</code>。接下来，您想用<code class="fe mz na nb nc b"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/2/keyof-types.html" rel="noopener ugc nofollow" target="_blank">keyof</a></code>操作符检查文字并集，您将得到<code class="fe mz na nb nc b">never</code>的<em class="lv"> fantastico </em>类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/893b8bbe2d072cad63d6a09f16503814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*tNyyDAU0wjzEdyw2o-iu9A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">never.ts的TypeScript编译器提示</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h2 id="6f2c" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">为什么会这样？以及如何修复。</h2><p id="c4d7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">keyof Union</code>导致never的原因是因为<code class="fe mz na nb nc b">keyof</code>总是返回一个类型的可访问键。</p><p id="3796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在联合的情况下，那将仅仅是公共键。</p><p id="a934" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于接口<code class="fe mz na nb nc b">User</code>和<code class="fe mz na nb nc b">Log</code>没有共享公共键，因此类型为<code class="fe mz na nb nc b">never</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/1e9e365d89d101701d5d716c16399ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*NgzvObncC5NnvVjmLaGNPA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正确操作时never.ts的TypeScript编译器提示</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="ae25" class="mc md it bd me mf oa mh mi mj ob ml mm jz oc ka mo kc od kd mq kf oe kg ms mt bi translated">2.你很容易被“|”虐待</h1><p id="91e3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你和我已经完全理解了<code class="fe mz na nb nc b">|</code>的意义，不是吗？</p><p id="8874" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不，如果你把它用于类型，你不会得到或的区别，相反，你会得到两种类型的混合。这就是为什么他们在打字稿总部称之为<code class="fe mz na nb nc b">union</code>的原因。</p><p id="70df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看这个例子，看看如何将命令<code class="fe mz na nb nc b">Lion | Bird</code>变成<code class="fe mz na nb nc b">Griffin</code>。<em class="lv">变量</em> <code class="fe mz na nb nc b">mixture</code> <em class="lv">可以兼得，虽然看起来不应该。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h2 id="73e6" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated"><em class="of">为什么会这样？以及如何修复。</em></h2><p id="8b9c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">联合类型的表达式<code class="fe mz na nb nc b">A | B</code>可以赋给<code class="fe mz na nb nc b">A</code>或<code class="fe mz na nb nc b">B</code>。它必须具有来自<code class="fe mz na nb nc b">A</code>或<code class="fe mz na nb nc b">B</code>(或两者)的属性。</p><p id="54bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">A &amp; B</code>的交集，A和b的必备属性。</p><p id="64e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看下图，可以看到<code class="fe mz na nb nc b">mixture</code>需要至少拥有两个接口的一个属性，而<code class="fe mz na nb nc b">mixture2</code>需要拥有所有四个属性才能成为有效的类型化变量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/68f53538f8ce2b71bd06d35a2061fb70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FCka5BBy9XojJRv3100pMQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">狮子|鸟浓缩成混合物，狮子和鸟浓缩成混合物2</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="afa2" class="mc md it bd me mf oa mh mi mj ob ml mm jz oc ka mo kc od kd mq kf oe kg ms mt bi translated">3.当一个类实现一个接口时要保持怀疑</h1><p id="3704" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">具有两种可能类型的属性的接口与类结合在一起是非常危险的。</p><p id="273f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类<code class="fe mz na nb nc b">FishClass</code>实现接口<code class="fe mz na nb nc b">Fish</code>并应用类型<code class="fe mz na nb nc b">string</code>的值<code class="fe mz na nb nc b">'Yes'</code>。现在在构造函数中，您决定附加<code class="fe mz na nb nc b">true</code>的值。尽管定义说你是被允许的，但是类预先锁定了类型。</p><p id="8131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">无路可退。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/0ca000f0e13dfc5f28cb999410e7430e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cm23yGEbVrvjCrCX7amLtw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">classAndInterface.ts的TypeScript编译器错误</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h2 id="95c7" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">为什么会这样？以及如何修复。</h2><p id="e6bc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">类成员并不是由他们打算实现或扩展的类型上下文类型化的。</p><p id="41ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">class</code>的<code class="fe mz na nb nc b">extends</code>或<code class="fe mz na nb nc b">implements</code>声明不会影响类实例的类型。相反，它只是对超类或接口执行事后类检查。所以如果你的类没有实现或者扩展你声明的，你会得到一个编译器警告。</p><p id="7568" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是对于结果类型，就好像您完全删除了extends或implements子句一样。不，没人喜欢那样。</p><p id="4df9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到成员是如何推断出来的。由于<code class="fe mz na nb nc b">alive</code>属性是用<code class="fe mz na nb nc b">"Yes"</code>的<code class="fe mz na nb nc b">string</code>值初始化的，编译器推断它属于<code class="fe mz na nb nc b">string</code>类型。后来当我把<code class="fe mz na nb nc b">true</code>赋给它时，这是一个错误，因为你不能把<code class="fe mz na nb nc b">boolean</code>赋给<code class="fe mz na nb nc b">string</code>。注意<code class="fe mz na nb nc b">string</code>可赋给<code class="fe mz na nb nc b">string | boolean</code>，所以对<code class="fe mz na nb nc b">FishClass implements Fish</code>的检查成功；您可以缩小子类型的属性。</p><p id="ac2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您必须接受这个事实，并重复该字段的联合声明来修复这种情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/fff8abff3d738e8b34729fe353e381e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*0sxGeJ5It-LCvGMXcvoYlg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">classAndInterface.ts的类型脚本解析</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="2dcc" class="mc md it bd me mf oa mh mi mj ob ml mm jz oc ka mo kc od kd mq kf oe kg ms mt bi translated">4.属性中的拼写错误是允许的</h1><p id="db1f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">输入错误可能会导致几个小时的搜索，好在TypeScript为我们检查了它，不是吗？</p><p id="018c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看下面的例子。当您使用可选属性时，TypeScript不执行sh*t。属性<code class="fe mz na nb nc b">userLvl</code>在接口<code class="fe mz na nb nc b">User</code>中不存在。</p><p id="2ada" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第8行，一切正常，编译器抛出一个错误。但是第12行让我哭了，因为它是允许的，而且完全合法——编译器没有任何抱怨。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="c0d7" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">为什么会这样？以及如何修复。</h2><p id="65dd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">问题是，根据OOP规则，派生类型应该与基本类型兼容(<code class="fe mz na nb nc b">loggedIn</code>和<code class="fe mz na nb nc b">userLevel</code>)</p><p id="754d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">超额属性检查无效的原因是为<code class="fe mz na nb nc b">map</code>执行类型检查的方式。首先，回调的返回类型是从对象文字派生而来，派生为<code class="fe mz na nb nc b">{ loggedIn: boolean, userLvl: number }</code>。</p><p id="9611" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该类型用作<code class="fe mz na nb nc b">map</code>的返回类型，因此它返回一个<code class="fe mz na nb nc b">Array&lt;{loggedIn: boolean, userLvl: number}&gt;</code>。然后这被分配给<code class="fe mz na nb nc b">User[]</code>，这是第一个规则所允许的。我没有在应该是<code class="fe mz na nb nc b">User</code>的地方分配一个对象文字。</p><p id="fff8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">得到错误的一种方法是不要让typescript推断传递给<code class="fe mz na nb nc b">map</code>的回调的结果。我们可以通过向回调添加注释来做到这一点。然后我们直接在期望<code class="fe mz na nb nc b">User</code>的位置分配一个对象文字:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/1c94c48549b52baedc25ed73578174ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kvKcYujUxux-nH5StSYMqg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">获取map-method类型检查的解决方案。</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="1df5" class="mc md it bd me mf oa mh mi mj ob ml mm jz oc ka mo kc od kd mq kf oe kg ms mt bi translated">5.在类上使用Spread运算符会导致失败</h1><p id="ac3c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通常的做法是用spread运算符组合对象。</p><p id="1195" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查作为扩展运算符失败见证的示例。函数<code class="fe mz na nb nc b">spawn</code>接受定义为<code class="fe mz na nb nc b">class</code>的类型<code class="fe mz na nb nc b">Ghost</code>。您决定通过将现有对象<code class="fe mz na nb nc b">Boo</code>扩展到<code class="fe mz na nb nc b">booSpread</code>中并将其传递给<code class="fe mz na nb nc b">spawn</code>函数来创建一个对象。这是艰难时期开始的地方。<em class="lv">缺少属性</em> <code class="fe mz na nb nc b">scare</code> <em class="lv">。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/3316c7f28e6532b26f54a8c2a5320268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SATm5xOxwHUIkG0M4J45kw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">spreadFail.ts中的TypeScript编译器错误</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h2 id="216f" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">为什么会这样？以及如何修复。</h2><p id="8ec9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在对象字面量中使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#Spread_in_object_literals" rel="noopener ugc nofollow" target="_blank"> spread操作符不会得到一个与原始对象相同类的对象。来自</a><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#Spread_in_object_literals" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="lw lx ly"><p id="c85e" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">ECMAScript 提案(ES2018)的<a class="ae ky" href="https://github.com/tc39/proposal-object-rest-spread" rel="noopener ugc nofollow" target="_blank"> Rest/Spread属性为<code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#1" rel="noopener ugc nofollow" target="_blank">object literals</a></code>增加了Spread属性。它将自己的可枚举属性从一个提供的对象复制到一个新对象上。</a></p><p id="b6ec" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">使用比<code class="fe mz na nb nc b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="noopener ugc nofollow" target="_blank">Object.assign()</a></code>更短的语法，对象的浅层克隆(不包括原型)或合并现在是可能的。</p></blockquote><p id="a4b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以你干脆“克隆”了<code class="fe mz na nb nc b">Ghost</code>。原型中包含的任何东西，比如方法，都会被忽略。如果你使用<code class="fe mz na nb nc b">Object.assign()</code>，这些方法也将被复制。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/d1460e0bb0d6013e81df0eee1cea0588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8QzcvbLF1Ph83ntS6ARxRg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">修正了使用属性扩展对象的问题。</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="046b" class="mc md it bd me mf oa mh mi mj ob ml mm jz oc ka mo kc od kd mq kf oe kg ms mt bi translated">6.定义一个接口并将所有内容映射到</h1><p id="7b95" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你定义一个接口是为了让任何人坚持使用它。</p><p id="4889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是您可以通过使用<code class="fe mz na nb nc b">Array.prototype</code>的<code class="fe mz na nb nc b">map</code>方法轻松地解决这种情况。数组<code class="fe mz na nb nc b">dobby</code>是<code class="fe mz na nb nc b">any</code>的类型，因此除了<code class="fe mz na nb nc b">Document</code>的已定义属性之外，里面什么都有。</p><p id="12b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个名为<code class="fe mz na nb nc b">myDocuments</code>的类型为<code class="fe mz na nb nc b">Document[]</code>的新数组现在应该可以阻止你将除了类型<code class="fe mz na nb nc b">Document</code>之外的任何东西赋给那个数组了——不，不，是。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/3bc763f73490e3248c4505fe8641f83a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*ltNgN44XXngzauh1MqfDQA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">myDocuments1和myDocuments2的Console.log</p></figure><p id="0c6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">看第11行，这个应该是非法的。呼叫9–1–1</em>。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h2 id="c712" class="nn md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">为什么会这样？以及如何修复。</h2><p id="5224" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你决定使用<code class="fe mz na nb nc b">any</code>作为类型，你就退出了类型检查。</p><p id="6c38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做可以让您分配随机内容数组<code class="fe mz na nb nc b">dobby</code>，并允许该值通过编译时检查。</p><p id="b6da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以很容易地将<code class="fe mz na nb nc b">any</code>更改为<code class="fe mz na nb nc b">unknown</code>来获得类型安全的副本。然后再次启用类型检查，并且不允许您将<code class="fe mz na nb nc b">dobby</code>赋值给<code class="fe mz na nb nc b">myDocuments1</code>和<code class="fe mz na nb nc b">myDocuments2</code>的类型化数组。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/5da63d0ff1a70b3792cb7bd11caa6ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kk0S2V2MLZkzmCB89MI_3A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">世界地图的分辨率. ts</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="6d1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数都在GitHub 上有很好的记录，但是经常会发现关于以前收集的bug。</p><p id="934c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">加入Medium，发现我的故事和数百万其他有用的故事:</em></p><p id="a135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://arnoldcode.medium.com/membership" rel="noopener">https://arnoldcode.medium.com/membership</a></p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt on nc oo op aw oq bi"><span id="4ef9" class="nn md it nc b gy or os l ot ou"><a class="ae ky" href="https://arnoldcodeacademy.ck.page/26-web-dev-cheat-sheets" rel="noopener ugc nofollow" target="_blank"><em class="lv">Get the 26 Cheatsheets and Study Only What You Truly Need to Land Your First Web Developer Job!</em></a></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/227a060a3bfa55f41fa795d5990e6032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Nqyiu4c6K-mCxE9e.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://arnoldcodeacademy.ck.page/26-web-dev-cheat-sheets" rel="noopener ugc nofollow" target="_blank"> Arnold Code Academy 26网站开发者备忘单</a></p></figure></div></div>    
</body>
</html>