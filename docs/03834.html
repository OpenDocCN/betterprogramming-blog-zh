<html>
<head>
<title>Swift It Yourself — Develop Your Own OCR on iOS 13 With VisionKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift It Yourself使用VisionKit在iOS 13上开发您自己的OCR</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-it-yourself-siy-develop-your-own-ocr-on-ios-13-with-visionkit-800b34c792ed?source=collection_archive---------1-----------------------#2020-03-07">https://betterprogramming.pub/swift-it-yourself-siy-develop-your-own-ocr-on-ios-13-with-visionkit-800b34c792ed?source=collection_archive---------1-----------------------#2020-03-07</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="5790" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">用Swift和苹果的眼光去阅读和解读身边的文字</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/0739854454d96b184b833a9db2716e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8k5Q7jJCfLf9g2D1tky-lQ.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@purzlbaum?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">🇨🇭·克劳迪奥·施瓦茨| @purzlbaum </a>在<a class="ae kz" href="https://unsplash.com/s/photos/scan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="154d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在iOS 11中，苹果集成了一个名为<a class="ae kz" href="https://developer.apple.com/documentation/vision/" rel="noopener ugc nofollow" target="_blank"> <em class="lw"> Vision </em> </a>的库。该库使用算法对图像和视频执行一系列任务(文本检测、条形码等)。).</p><p id="d63d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，在iOS 13中，苹果发布了一个新的库，<a class="ae kz" href="https://developer.apple.com/documentation/visionkit" rel="noopener ugc nofollow" target="_blank"> <em class="lw"> VisionKit </em> </a>，可以让你使用系统本身的文档扫描仪(使用Notes应用的同一个)。</p><p id="e706" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们来看看如何用VisionKit在iOS 13中开发自己的OCR。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="e8a6" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">项目开始</h1><p id="0845" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">为了检查我们如何扫描文档并识别其内容，我们在Xcode 11中创建了一个项目(记住VisionKit只能在iOS 13+上工作)。这个项目可以在<a class="ae kz" href="https://github.com/raulferrerdev/DocScan" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到全文。</p><p id="05d5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由于我们将使用设备的摄像头扫描文档，操作系统将向我们显示一条消息，要求我们允许使用该摄像头。如果我们不希望出现错误和应用程序被关闭，我们必须通知应用程序我们将需要摄像机。</p><p id="a993" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为此，我们在<code class="fe nb nc nd ne b">Info.plist</code>文件中添加了密钥<code class="fe nb nc nd ne b">Privacy — Camera Usage Description</code>，以及一个文本，当用户请求许可时，该文本将显示给用户。</p><p id="fdb6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">比如:<code class="fe nb nc nd ne b">To be able to scan documents you must allow the use of the camera.</code></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nf"><img src="../Images/072bbccbbc82a50387e90bb10f73dc9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kHiiSKywQ9uxZ0jQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">添加了相机使用请求密钥的Info.plist。</p></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ng"><img src="../Images/baa2fa118cfea628ee01dfcd8f952581.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/0*zNdija59qf5mCh4q.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">请求许可。</p></figure><p id="ba20" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果权限被拒绝，当我们想要扫描时，会出现以下消息:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ng"><img src="../Images/378ef81e5f331d25e16aa9db917f2442.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/0*mpQ1JE8aPHgm82WQ.png"/></div></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="b590" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">接口设计</h1><p id="77de" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">这个项目基本上由一个<code class="fe nb nc nd ne b">UIImageView</code>组件组成，其中我们将显示带有识别文本的扫描文档，一个<code class="fe nb nc nd ne b">UITextView</code>组件显示扫描仪已经识别的文本，一个<code class="fe nb nc nd ne b">UIButton</code>组件激活文档扫描。</p><p id="d344" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这个项目中，我将通过代码来完成这一切，而不使用故事板或<code class="fe nb nc nd ne b">.xib</code>文件。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nh"><img src="../Images/e31a889d647860510076a3eb99e9943d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2mbTZpBqE0dZxgzZ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">项目界面设计。</p></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="b04c" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">界面编程</h1><p id="8b1a" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">首先，我们创建了<code class="fe nb nc nd ne b">ScanButton</code>组件:</p><pre class="kk kl km kn gu ni ne nj bn nk nl bi"><span id="5c35" class="nm mf iu ne b be nn no l np nq">import UIKit<br/> <br/>class ScanButton: UIButton {<br/> <br/>    override init(frame: CGRect) {<br/>        super.init(frame: frame)<br/>        configure()<br/>    }<br/>    <br/>    <br/>    required init?(coder: NSCoder) {<br/>        fatalError("init(coder:) has not been implemented")<br/>    }<br/>    <br/>    <br/>    private func configure() {<br/>        translatesAutoresizingMaskIntoConstraints = false<br/>        setTitle("Scan document", for: .normal)<br/>        titleLabel?.font = UIFont.boldSystemFont(ofSize: 18.0)<br/>        titleLabel?.textColor = .white<br/>        layer.cornerRadius = 7.0<br/>        backgroundColor = UIColor.systemIndigo<br/>    }<br/>}</span></pre><p id="deb2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，<code class="fe nb nc nd ne b">ScanImageView</code>组件:</p><pre class="kk kl km kn gu ni ne nj bn nk nl bi"><span id="7ccc" class="nm mf iu ne b be nn no l np nq">import UIKit<br/> <br/>class ScanImageView: UIImageView {<br/> <br/>    override init(frame: CGRect) {<br/>        super.init(frame: frame)<br/>        configure()<br/>    }<br/>    <br/>    <br/>    required init?(coder: NSCoder) {<br/>        fatalError("init(coder:) has not been implemented")<br/>    }<br/>    <br/>    <br/>    private func configure() {<br/>        translatesAutoresizingMaskIntoConstraints = false<br/>        layer.cornerRadius = 7.0<br/>        layer.borderWidth = 1.0<br/>        layer.borderColor = UIColor.systemIndigo.cgColor<br/>        backgroundColor = UIColor.init(white: 1.0, alpha: 0.1)<br/>        clipsToBounds = true<br/>    }<br/>}</span></pre><p id="fe85" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，<code class="fe nb nc nd ne b">OcrTextView</code>组件:</p><pre class="kk kl km kn gu ni ne nj bn nk nl bi"><span id="dcba" class="nm mf iu ne b be nn no l np nq">import UIKit<br/> <br/>class OcrTextView: UITextView {<br/> <br/>    override init(frame: CGRect, textContainer: NSTextContainer?) {<br/>        super.init(frame: .zero, textContainer: textContainer)<br/>        <br/>        configure()<br/>    }<br/>    <br/>    <br/>    required init?(coder: NSCoder) {<br/>        fatalError("init(coder:) has not been implemented")<br/>    }<br/>    <br/>    <br/>    private func configure() {<br/>        translatesAutoresizingMaskIntoConstraints = false<br/>        layer.cornerRadius = 7.0<br/>        layer.borderWidth = 1.0<br/>        layer.borderColor = UIColor.systemTeal.cgColor<br/>        font = .systemFont(ofSize: 16.0)<br/>    }<br/>}</span></pre><p id="f562" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们从<code class="fe nb nc nd ne b">ViewController</code>中调用它们，并将它们定位在屏幕上:</p><pre class="kk kl km kn gu ni ne nj bn nk nl bi"><span id="fe08" class="nm mf iu ne b be nn no l np nq">import UIKit<br/> <br/>class ViewController: UIViewController {<br/>    <br/>    private var scanButton = ScanButton(frame: .zero)<br/>    private var scanImageView = ScanImageView(frame: .zero)<br/>    private var ocrTextView = OcrTextView(frame: .zero, textContainer: nil)<br/> <br/>    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/>        <br/>        configure()<br/>    }<br/> <br/>    <br/>    private func configure() {<br/>        view.addSubview(scanImageView)<br/>        view.addSubview(scanButton)<br/>        view.addSubview(scanButton)<br/> <br/>        let padding: CGFloat = 16<br/>        NSLayoutConstraint.activate([<br/>            scanButton.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: padding),<br/>            scanButton.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -padding),<br/>            scanButton.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -padding),<br/>            scanButton.heightAnchor.constraint(equalToConstant: 50),<br/>            <br/>            ocrTextView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: padding),<br/>            ocrTextView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -padding),<br/>            ocrTextView.bottomAnchor.constraint(equalTo: scanButton.topAnchor, constant: -padding),<br/>            ocrTextView.heightAnchor.constraint(equalToConstant: 200),<br/>            <br/>            scanImageView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: padding),<br/>            scanImageView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: padding),<br/>            scanImageView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -padding),<br/>            scanImageView.bottomAnchor.constraint(equalTo: ocrTextView.topAnchor, constant: -padding)<br/>        ])<br/>    }<br/>}</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ng"><img src="../Images/1bf36ea08c50abd8eb555781866a2972.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/0*H1cWubL-YbWtNzqW.png"/></div></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="a42b" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">扫描控制器演示—VNDocumentCameraViewController</h1><p id="8e6e" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">为了呈现允许我们扫描文档的控制器，我们必须创建并呈现一个<code class="fe nb nc nd ne b">VNDocumentCameraViewController</code>类的实例。</p><p id="f699" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在configure方法的末尾，我们添加了下面的代码，它允许我们调用<code class="fe nb nc nd ne b">scanDocument()</code>方法:</p><pre class="kk kl km kn gu ni ne nj bn nk nl bi"><span id="f24f" class="nm mf iu ne b be nn no l np nq">scanButton.addTarget(self, action: #selector(scanDocument), for: .touchUpInside)</span></pre><p id="05b1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe nb nc nd ne b">configure()</code>方法之后，我们创建了<code class="fe nb nc nd ne b">scanDocument()</code>方法:</p><pre class="kk kl km kn gu ni ne nj bn nk nl bi"><span id="5e8a" class="nm mf iu ne b be nn no l np nq">@objc private func scanDocument() {<br/>    let scanVC = VNDocumentCameraViewController()<br/>    scanVC.delegate = self<br/>    present(scanVC, animated: true)<br/>}</span></pre><p id="877a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">可以看到，<code class="fe nb nc nd ne b">@objc</code>已经加在函数前面了，因为虽然我们是用Swift编程，<code class="fe nb nc nd ne b">#selector</code>是Objective-C的一个方法。</p><p id="2273" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，<code class="fe nb nc nd ne b">VNDocumentCameraViewController</code>类提供了<code class="fe nb nc nd ne b">VNDocumentCameraViewControllerDelegate</code>协议(我们已经在<code class="fe nb nc nd ne b">scanVC.delegate = self</code>中调用过了)，所以我们可以实现它的方法。</p><p id="dc1f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们在<code class="fe nb nc nd ne b">ViewController</code>类的扩展中这样做，所以我们的代码更有条理:</p><pre class="kk kl km kn gu ni ne nj bn nk nl bi"><span id="b236" class="nm mf iu ne b be nn no l np nq">extension ViewController: VNDocumentCameraViewControllerDelegate {<br/>    func documentCameraViewController(_ controller: VNDocumentCameraViewController, didFinishWith scan: VNDocumentCameraScan) {<br/>        guard scan.pageCount &gt;= 1 else {<br/>            controller.dismiss(animated: true)<br/>            return<br/>        }<br/>        <br/>        scanImageView.image = scan.imageOfPage(at: 0)<br/>        // Here will be the code for text recognition<br/> <br/>        controller.dismiss(animated: true)<br/>    }<br/>    <br/>    func documentCameraViewController(_ controller: VNDocumentCameraViewController, didFailWithError error: Error) {<br/>        //Handle properly error<br/>        controller.dismiss(animated: true)<br/>    }<br/>    <br/>    func documentCameraViewControllerDidCancel(_ controller: VNDocumentCameraViewController) {<br/>        controller.dismiss(animated: true)<br/>    }<br/>}</span></pre><p id="f4e5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第一种方法是<code class="fe nb nc nd ne b">documentCameraViewController (_ controller: VNDocumentCameraViewController, didFinishWith scan: VNDocumentCameraScan)</code>，当我们扫描完一页或多页并保存它们时调用(<em class="lw">先保持扫描</em>，然后<em class="lw">保存</em>)。</p><p id="ff52" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nb nc nd ne b">scan</code>对象(<code class="fe nb nc nd ne b">VNDocumentCameraScan</code>)包含三个参数:</p><ul class=""><li id="db0e" class="nr ns iu lc b ld le lg lh lj nt ln nu lr nv lv nw nx ny nz bi translated"><code class="fe nb nc nd ne b">pageCount</code> —扫描的(<code class="fe nb nc nd ne b">Int</code>)页数。</li><li id="e5b4" class="nr ns iu lc b ld oa lg ob lj oc ln od lr oe lv nw nx ny nz bi translated"><code class="fe nb nc nd ne b">imageOfPage(at index: Int)</code> —指定索引中页面的图像(<code class="fe nb nc nd ne b">UIImage</code>)。</li><li id="52ea" class="nr ns iu lc b ld oa lg ob lj oc ln od lr oe lv nw nx ny nz bi translated"><code class="fe nb nc nd ne b">title</code> —扫描文件的标题(<code class="fe nb nc nd ne b">String</code>)。一旦我们确认一份或多份文件已被扫描，在移除控制器之前，我们会将扫描图像传送至<code class="fe nb nc nd ne b">scanImageView</code>组件。</li></ul><p id="09fc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第二种方法是<code class="fe nb nc nd ne b">documentCameraViewController (_ controller: VNDocumentCameraViewController, didFailWithError error: Error)</code>，在扫描文档时发生错误时调用，因此此时我们必须执行一些错误管理操作。</p><p id="e4f3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，如果错误是由于用户没有给出使用摄像机的许可，我们可以显示一条警告消息，要求激活许可。</p><p id="485d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当点击<code class="fe nb nc nd ne b">VNDocumentCameraViewController</code>控制器的<code class="fe nb nc nd ne b">Cancel</code>按钮时，调用第三个方法<code class="fe nb nc nd ne b">documentCameraViewControllerDidCancel (_ controller: VNDocumentCameraViewController)</code>。在这里，我们将只解除控制器。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="edde" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">文本识别</h1><p id="ed28" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">现在，为了识别和提取我们扫描的文档的文本，我们将使用已经集成到iOS 11中的Apple <a class="ae kz" href="https://developer.apple.com/documentation/vision" rel="noopener ugc nofollow" target="_blank"> Vision </a>框架。具体来说，我们将使用<code class="fe nb nc nd ne b"><a class="ae kz" href="https://developer.apple.com/documentation/vision/vnrecognizetextrequest" rel="noopener ugc nofollow" target="_blank">VNRecognizeTextRequest</a></code>类。</p><p id="ece0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如文档所示，这个类搜索并识别图像中的文本。</p><p id="ca71" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于这个过程，我们需要一个请求(<code class="fe nb nc nd ne b">VNRecognizeTextRequest</code>类的实例),在其中我们可以定义文本识别参数:</p><ul class=""><li id="9cb2" class="nr ns iu lc b ld le lg lh lj nt ln nu lr nv lv nw nx ny nz bi translated"><code class="fe nb nc nd ne b">customWords</code> —我们定义的一组单词，用于补充字典中的单词，并将在识别阶段使用(例如，名称、标记等)。).</li><li id="680c" class="nr ns iu lc b ld oa lg ob lj oc ln od lr oe lv nw nx ny nz bi translated"><code class="fe nb nc nd ne b">minimumTextHeight</code> —文本的最小高度(相对于图像的高度)，从该高度开始识别文本。正如苹果在其文档中指出的:</li></ul><blockquote class="of"><p id="bcd8" class="og oh iu bd oi oj ok ol om on oo lv dk translated">增加大小可以减少内存消耗并加快识别速度，但代价是忽略小于最小高度的文本。默认值是1/32，即0.03125。</p></blockquote><p id="8876" class="pw-post-body-paragraph la lb iu lc b ld op jv lf lg oq jy li lj or ll lm ln os lp lq lr ot lt lu lv in bi translated">在本项目中，我们将应用一些参数作为示例:</p><pre class="kk kl km kn gu ni ne nj bn nk nl bi"><span id="4e1e" class="nm mf iu ne b be nn no l np nq">var ocrRequest = VNRecognizeTextRequest(completionHandler: nil)<br/>ocrRequest.recognitionLevel = .accurate<br/>ocrRequest.recognitionLanguages = ["en-US", "en-GB"]<br/>ocrRequest.usesLanguageCorrection = true</span></pre><p id="802b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此时，我们创建了<code class="fe nb nc nd ne b">configureOCR()</code>函数，它将包含分析、识别和从图像中提取文本的功能:</p><pre class="kk kl km kn gu ni ne nj bn nk nl bi"><span id="3906" class="nm mf iu ne b be nn no l np nq">private func configureOCR() {<br/>    ocrRequest = VNRecognizeTextRequest { (request, error) in<br/>    guard let observations = request.results as? [VNRecognizedTextObservation] else { return }<br/>            <br/>    var ocrText = ""<br/>        for observation in observations {<br/>            guard let topCandidate = observation.topCandidates(1).first else { return }<br/>                    <br/>            ocrText += topCandidate.string + "\n"<br/>        }<br/>                <br/>        DispatchQueue.main.async {<br/>            self.ocrTextView.text = ocrText<br/>            self.scanButton.isEnabled = true<br/>        }<br/>    }<br/>        <br/>    ocrRequest.recognitionLevel = .accurate<br/>    ocrRequest.recognitionLanguages = ["en-US", "en-GB"]<br/>    ocrRequest.usesLanguageCorrection = true<br/>}</span></pre><p id="0140" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将在<code class="fe nb nc nd ne b">configure()</code>方法之后的<code class="fe nb nc nd ne b">viewDidLoad()</code>中调用这个函数。</p><p id="1942" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们在这个函数中所做的是创建一个只包含一个参数<code class="fe nb nc nd ne b">completionHandler</code>的<code class="fe nb nc nd ne b">VNRecognizeTextRequest</code>实例，每次在图像中检测到文本时都会调用这个实例。</p><p id="dbf9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此时，发生的过程是:</p><ul class=""><li id="7007" class="nr ns iu lc b ld le lg lh lj nt ln nu lr nv lv nw nx ny nz bi translated">首先，我们检查<code class="fe nb nc nd ne b">request.results</code>是否包含一个观察列表(类型为<code class="fe nb nc nd ne b">VNRecognizedTextObservation</code>)，它对应于视觉库已经检测到的行和句子。</li><li id="771d" class="nr ns iu lc b ld oa lg ob lj oc ln od lr oe lv nw nx ny nz bi translated">接下来，我们迭代这个观察列表。这些观察结果中的每一个都由一系列可能的候选文本组成，每个候选文本都有一定的可信度。我们选择第一个候选项，并将其添加到文本字符串中。</li><li id="e55b" class="nr ns iu lc b ld oa lg ob lj oc ln od lr oe lv nw nx ny nz bi translated">最后，我们在<code class="fe nb nc nd ne b">OcrTextView</code>元素中显示我们已经创建了文本所获得的原则(记住要在主线程中完成，这就是我们使用<code class="fe nb nc nd ne b">Dispatch.main.async</code>的原因)。</li></ul></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="f07f" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">图像处理</h1><p id="383a" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">最后，我们只需要处理扫描仪捕获的图像。</p><p id="00c8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于它们，我们创建一个函数，该函数将接受一个类型为<code class="fe nb nc nd ne b">UIImage</code>(捕获的图像)的参数，并将创建一个类型为<code class="fe nb nc nd ne b">VNImageRequestHandler</code>的实例，在这里我们将传递我们在开始时创建的<code class="fe nb nc nd ne b">ocrRequest</code>实例:</p><pre class="kk kl km kn gu ni ne nj bn nk nl bi"><span id="8e4b" class="nm mf iu ne b be nn no l np nq">private func processImage(_ image: UIImage) {<br/>    guard let cgImage = image.cgImage else { return }<br/> <br/>    ocrTextView.text = ""<br/>    scanButton.isEnabled = false<br/>        <br/>    let requestHandler = VNImageRequestHandler(cgImage: cgImage, options: [:])<br/>    do {<br/>        try requestHandler.perform([self.ocrRequest])<br/>    } catch let error {<br/>        print(error)<br/>    }<br/>}</span></pre><p id="b691" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如<a class="ae kz" href="https://developer.apple.com/documentation/vision/vnimagerequesthandler" rel="noopener ugc nofollow" target="_blank">文档</a>所指出的，要实例化这种类型，我们需要使用<code class="fe nb nc nd ne b">CGImage</code>而不是<code class="fe nb nc nd ne b">UIImage</code>(因为它与<a class="ae kz" href="https://developer.apple.com/documentation/coregraphics" rel="noopener ugc nofollow" target="_blank">核心图形</a>一起工作)，所以我们从传递的图像中获取参数。</p><p id="6939" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们还可以传递一个<code class="fe nb nc nd ne b">VNImageOption</code>类型的选项列表(描述图像的特定属性或者应该如何处理)，尽管在这种情况下，我们不会传递任何选项。</p><p id="150f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我们应用文本识别请求(<code class="fe nb nc nd ne b">ocrRequest</code>)。</p><p id="fc3b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该方法<code class="fe nb nc nd ne b">processImage (_ image: UIImage)</code>将在<code class="fe nb nc nd ne b">documentCameraViewController (_ controller: VNDocumentCameraViewController, didFinishWith scan: VNDocumentCameraScan)</code>方法结束时调用，并在用<code class="fe nb nc nd ne b">controller.dismiss(animated: true)</code>关闭控制器之前调用。</p><pre class="kk kl km kn gu ni ne nj bn nk nl bi"><span id="8019" class="nm mf iu ne b be nn no l np nq">func documentCameraViewController(_ controller: VNDocumentCameraViewController, didFinishWith scan: VNDocumentCameraScan) {<br/>    guard scan.pageCount &gt;= 1 else {<br/>        controller.dismiss(animated: true)<br/>        return<br/>    }<br/>        <br/>    scanImageView.image = scan.imageOfPage(at: 0)<br/>    <br/>    processImage(scan.imageOfPage(at: 0))<br/>    <br/>    controller.dismiss(animated: true)<br/>}</span></pre><h1 id="2eb1" class="me mf iu bd mg mh ou mj mk ml ov mn mo ka ow kb mq kd ox ke ms kg oy kh mu mv bi translated">扫描仪测试</h1><p id="ccb3" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">现在我们可以测试应用程序了。为此，我们打开它并捕捉图像。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oz"><img src="../Images/0831d636914fb27c144b7aa8d15dff8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*x1fBp_L2V-GPk7tHXjrhmg.gif"/></div></div></figure><p id="c87d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如你所看到的，它完美地识别了图像的文本。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="d9e8" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">结论</h1><p id="5236" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">正如我们所见，由于有了<a class="ae kz" href="https://developer.apple.com/documentation/vision/" rel="noopener ugc nofollow" target="_blank"> Vision </a>和<a class="ae kz" href="https://developer.apple.com/documentation/visionkit" rel="noopener ugc nofollow" target="_blank"> VisionKit </a>库，我们可以在手机上轻松构建自己的文档扫描仪。记住你可以在GitHub 上下载整个项目。</p></div></div>    
</body>
</html>