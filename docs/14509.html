<html>
<head>
<title>JavaScript Full-Stack Development Outlook for 2023</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2023年JavaScript全栈发展展望</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-full-stack-development-outlook-for-2023-dd1b689acd2f?source=collection_archive---------0-----------------------#2022-12-30">https://betterprogramming.pub/javascript-full-stack-development-outlook-for-2023-dd1b689acd2f?source=collection_archive---------0-----------------------#2022-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a4bd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">边缘、框架、API和其他各种东西</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c716579750e5539fa7c295d34375b912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RK2whZaSQ72_7rOSgAdlFA.png"/></div></div></figure><p id="2436" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">年末是忘记我们过去的错误并积极展望未来的好时机。因此，作为一个狂热的JS/TS全栈开发爱好者，我决定鼓起勇气，对即将到来的一年做一些预测。它们可能都很有争议，所以希望它们能引发更有意义的讨论，我渴望听到你的意见。</p><h1 id="d8a6" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">边缘部署将成为主流</h1><p id="6505" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">不管你有没有用过，你一定反复听说过2022年的《奔跑在边缘》。web开发生态系统继续痴迷于优化TTFB，并且支持在边缘上运行，对于框架构建者来说，这不仅是一件很酷的事情，现在也是必备的:</p><ul class=""><li id="b580" class="mk ml iq kt b ku kv kx ky la mm le mn li mo lm mp mq mr ms bi translated">Next.js将其“实验边缘”API路由升级到GA。它的beta版“React服务器组件”支持和新的数据加载模式是完全边缘兼容的。</li><li id="cd4e" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated">Nuxt.js 3.0完全重建了其服务器引擎，并完全支持在边缘部署上运行。</li><li id="1a81" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated">Remix正在积极推动Cloudflare workers等边缘服务上的部署。</li><li id="d22f" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated">SvelteKit 1.0，经过这么长时间的等待，终于登陆了，绝对没有错过edge支持。</li></ul><p id="422b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最简单的意义上，Edge是CDN升级，支持运行自定义代码；以便它不仅可以为客户提供静态资产，还可以为客户提供动态内容。实施边缘计算的挑战是安全、廉价且持续快速地执行代码。</p><p id="0b6f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">像CDN一样，边缘网络应该大规模部署，并在许多租户之间共享。这要求隔离的执行上下文(这样数据就不会在租户之间泄漏)占用很少的内存(这样就可以在不影响性能的情况下频繁地创建和处理上下文)。NodeJS过于臃肿，不是一个可行的解决方案。更精简的Javascript运行时，如Next.js的<a class="ae my" href="https://nextjs.org/docs/api-reference/edge-runtime" rel="noopener ugc nofollow" target="_blank"> edge运行时</a>，Cloudflare的<a class="ae my" href="https://blog.cloudflare.com/workerd-open-source-workers-runtime/" rel="noopener ugc nofollow" target="_blank"> workerd </a>，<a class="ae my" href="https://deno.com/deploy" rel="noopener ugc nofollow" target="_blank"> Deno deploy </a>，以及<a class="ae my" href="https://bun.sh/" rel="noopener ugc nofollow" target="_blank"> bun </a>，都是为了完成这个专门的工作而创建的。</p><p id="5ab5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">今天，大多数web应用程序仍然部署在传统的托管环境中。很有可能许多人会尝试部署在edge上，有些人最终会选择它。借助对开发人员更友好的框架以及它们与托管提供商的更好集成，您通常可以迁移到边缘，而无需太多代码更改，并立即享受一些好处:</p><ul class=""><li id="3509" class="mk ml iq kt b ku kv kx ky la mm le mn li mo lm mp mq mr ms bi translated">在许多情况下，SSR页面应该立即加载得更快</li><li id="1dfa" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated">边缘网络可以缓存您的数据，以减少数据存储的负载</li><li id="2679" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated">内容个性化更容易实现，因为决策可以在边缘做出</li><li id="2367" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated">你可能会用更少的成本获得更好的结果</li></ul><p id="8935" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是优势并不是银弹。其未来最大的灰色地带之一是数据获取。今天的大多数数据库仍然不是全球分布的，这种情况不太可能很快改变。如果规划不当，从边缘网络访问集中部署的数据库会降低性能。查看以下视频，了解测量测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6442" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是为什么Prisma，甚至积极开发和宣传其面向边缘的<a class="ae my" href="https://www.prisma.io/data-platform/proxy" rel="noopener ugc nofollow" target="_blank">数据代理</a>，<a class="ae my" href="https://www.prisma.io/blog/database-access-on-the-edge-8F0t1s1BqOJE#do-single-region-databases-and-the-edge-fit-together" rel="noopener ugc nofollow" target="_blank">坦诚地声称</a>:</p><blockquote class="nb nc nd"><p id="bfc4" class="kr ks ne kt b ku kv jr kw kx ky ju kz nf lb lc ld ng lf lg lh nh lj lk ll lm ij bi translated"><em class="iq">作为一个最佳实践，我们仍然建议通常尽可能靠近API服务器部署您的数据库，以最小化响应时间的延迟。</em></p></blockquote><p id="a575" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这绝对是你在走向边缘之前应该权衡的事情。正如Prisma所暗示的，缓解措施是将您的边缘网络限制在离您的数据库足够近的区域。一些框架，例如Next.js，已经支持在路由级别配置边缘区域。好吧，如果你已经在使用一个全球分布的数据存储，我没有什么要警告你的，只是送上我的祝贺。</p><h1 id="a70b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">关于数据加载模式的未解决的争论</h1><p id="084a" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">当开发人员还在整理CSR、SSR、SSG、ISR等的时候。，Next.js 13通过将React服务器组件作为其新的默认组件(尽管仍处于测试阶段)而成功登陆。</p><p id="1b4a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这为未来web应用程序的更好性能带来了相当多的兴奋，但无疑使事情变得更加混乱。然而，这个想法很酷:服务器组件呈现在服务器上，它们的代码保留在服务器上。</p><p id="651b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它可能会显著减少客户端捆绑包的大小，但同时会使网络边界比以前更加模糊。因此，你的应用程序的行为可能更难推理出来。</p><p id="960a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">查看我的另一篇文章，获得对Next.js 13的RSC的更全面的解释:</p><div class="ni nj gp gr nk nl"><a rel="noopener  ugc nofollow" target="_blank" href="/fun-with-next-js-13-server-components-fd5f886c31f3"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">探索Next.js 13服务器组件</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">Next.js 13测试版特性的快速概述</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">better编程. pub</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz kp nl"/></div></div></a></div><p id="f9ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于在全栈web应用程序中加载数据的最佳方式，一直存在无休止的争论，而且这种争论还会继续变得更加激烈，因为没有一个最佳解决方案适合所有场景:</p><ul class=""><li id="5d22" class="mk ml iq kt b ku kv kx ky la mm le mn li mo lm mp mq mr ms bi translated"><strong class="kt ir">您的后端数据读取速度是否很慢？RSC + streaming提供了一个优秀的解决方案，以细粒度异步呈现和流式传输UI。</strong></li><li id="c99e" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated">页面交互后，你应该更关心包的大小还是网络流量？<br/> 当组件重新呈现时，RSC以更多网络流量为代价减小了包的大小，因为它传输UI(虚拟DOM)而不是数据。而传统的基于路由器的数据加载，像Remix一直在做的，就不存在这样的问题。</li><li id="f319" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated"><strong class="kt ir">您更喜欢数据和组件的严格分离，还是更愿意将它们放在一起？<br/> </strong>这更多的是口味的问题。我们从大多数框架得到的最新建议是“提取”然后“渲染”(以避免渲染-提取瀑布)，但是Next.js 13(带有RSC和内置的<a class="ae my" href="https://beta.nextjs.org/docs/data-fetching/fundamentals#automatic-fetch-request-deduping" rel="noopener ugc nofollow" target="_blank">提取去重复</a>)提供了一个有趣的机会来执行“渲染时提取”。</li></ul><p id="0306" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同时，不要忘记非反应式生态系统，如Vue和Svelte，根本没有服务器组件的概念，它们的开发者做得很好。另一个有趣的事件是<a class="ae my" href="https://remix.run/blog/remixing-shopify" rel="noopener ugc nofollow" target="_blank"> Remix加入Shopify </a>。Shopify的前端框架<a class="ae my" href="https://hydrogen.shopify.dev/" rel="noopener ugc nofollow" target="_blank"> Hydroden </a>最初押注于RSC。有效收购Remix意味着它正在改变方向，至少目前是这样。这里有一个来自Vue的创造者的有趣的评论😄：</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/60024242eabfe8d151f3da4bf2dac980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WOmSAB3dyXQwJe9D.png"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated"><a class="ae my" href="https://twitter.com/youyuxi/status/1587211401453371393" rel="noopener ugc nofollow" target="_blank">https://twitter.com/youyuxi/status/1587211401453371393</a></p></figure><p id="fe3b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么你应该如何在这个混乱的世界中生存呢？我建议根据其他方面来评估自己坚持什么框架。通常，一个现代框架的数据加载机制不会让你失望。他们有不同的偏好和侧重点，但通常对大多数场景都有足够好的解决方案。我喜欢Remix用“杠杆”作为比喻的想法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/97be173892da085e24b20a08988e6bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*izG-qzteVojDqihZ.png"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated"><a class="ae my" href="https://remix.run/blog/remix-and-the-edge" rel="noopener ugc nofollow" target="_blank">https://remix.run/blog/remix-and-the-edge</a></p></figure><p id="b0b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">框架会提供所有的杠杆，但是拉是你的责任。</p><h1 id="4c13" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">API褪色</h1><p id="29dc" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">当然，我并不是说API正在消失。它们是网络的生命线，并且会变得更加重要。然而，在使用Javascript框架进行全栈开发的背景下，<strong class="kt ir">显式地</strong>设计和实现API的必要性越来越小。他们逐渐消失在框架中。</p><p id="d631" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，从技术上讲，Next.js的<code class="fe of og oh oi b">getServerSideProps</code>和<code class="fe of og oh oi b">getStaticProps</code>是API，尽管你从来没有从你的客户端代码中显式地调用它们。Remix中的<code class="fe of og oh oi b">loader</code>和<code class="fe of og oh oi b">action</code>也是如此，SvelteKit中的<code class="fe of og oh oi b">load</code>功能也是如此。网络通信，无论是时间还是格式，都被很好地封装起来，以至于你几乎意识不到它们是API。您的客户机和服务器代码自然也共享类型定义(如果您使用Typescript，是的，您应该这样做)。这些可能会解决您对SSR、SSG和部分客户端交互的所有需求。</p><p id="410b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大多数框架还允许您创建“显式”API端点来支持更灵活的客户端交互。您最初的直觉可能是，我应该用它来构建RESTful或GraphQL服务吗？但是让我们再想一想:你的代码已经在monorepo中了，客户端和服务器端代码紧密地放在一起，用同一种语言编写。那么，为什么要费心引入一个工具链，并在它们之间建立一个如此严肃的通信规范呢？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/fe321d3f14c77642257eacb6530ec631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g2zOL-051ddKJnlEkU6u3Q.png"/></div></div><p class="ob oc gj gh gi od oe bd b be z dk translated">API困境</p></figure><p id="f18d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">tRPC 给出了一个不太严谨的解决问题的奇妙方法。它充分利用了您的设置:monorepo、统一框架、公共语言(TS)，并将API构造有效地转化为编写方法并调用它们。让API以独立于框架的方式逐渐消失是另一种方法。</p><p id="54dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">牺牲是显而易见的:你的API现在与你的应用程序(甚至是一个特定的框架)紧密绑定，不容易被第三方使用。但实际上，这通常不是什么大问题。</p><p id="e791" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">随着框架的数据加载特性和tRPC等大胆想法的推动，在2023年，我们应该会看到更多的人对构建API“不那么认真”感到满意，相反，他们会更加专注于构建自己的产品。</p><h1 id="3c63" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">Web IDE的流行</h1><p id="be75" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">工具和框架的进步不仅给了我们解决问题的能力。它们也让我们在工作时有了更快的体验。值得注意的一个特殊领域是基于浏览器的ide。</p><p id="a221" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">多年来，人们一直在使用类似于<a class="ae my" href="https://jsfiddle.net/" rel="noopener ugc nofollow" target="_blank"> jsfiddle </a>的工具进行快速实验，但它仅限于处理客户端的东西。然而，成熟的web IDEs将在2022年快速成熟。例如，<a class="ae my" href="https://codesandbox.io/" rel="noopener ugc nofollow" target="_blank"> Codesandbox </a>现在通过旋转远程容器来运行服务器端工作负载，并为您模拟“本地”体验，从而为Next和Nuxt等全栈框架提供良好的支持。<a class="ae my" href="https://www.gitpod.io/" rel="noopener ugc nofollow" target="_blank"> Gitpod </a>采用了类似的技术，但在深入开发生命周期方面看起来更加雄心勃勃。<br/>其中最激动人心的是<a class="ae my" href="https://stackblitz.com/" rel="noopener ugc nofollow" target="_blank">斯塔克布里兹</a>。它迈出了勇敢的一步，用Web Assembly实现了完整的NodeJS实现(称为<a class="ae my" href="https://blog.stackblitz.com/posts/introducing-webcontainers/" rel="noopener ugc nofollow" target="_blank"> WebContainer </a>)。这样，你的后端代码就可以在你的浏览器中运行了。不需要启动远程容器，也不需要通过网络来回传输数据。这是一个真正的本地环境。这种方法听起来是解决问题并将Web IDEs转化为主流应用的唯一可行的方法。</p><p id="4383" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这仍然是一个不成熟的领域，但似乎正在快速发展。因此，我确实相信在2023年，有机会进行认真的采用，至少对于像代码审查或临时错误修复这样的任务。</p></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><p id="ea89" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">真心感谢大家陪我到年底。对世界上许多地方来说，这又是一个艰难的时期。虽然这个世界充满了你无法控制的愚蠢，但学习、编程和分享想法总是一种极好的安慰。技术的进步，尤其是OSS的发展，不同的人联合起来超越他们的个人利益，证明我们仍然是一个充满希望的物种。</p><p id="f223" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">祝大家新年快乐，前程似锦。正如亚历山大·仲马所说，人类所有的智慧可以归结为两个词:等待和希望。</p><p id="5a84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">新年快乐！</p><pre class="kg kh ki kj gt or oi os bn ot ou bi"><span id="d808" class="ov lo iq oi b be ow ox l oy oz">Want to Connect?<br/><br/>I'm the creator of <a class="ae my" href="https://zenstack.dev/?utm_campaign=medium&amp;utm_medium=organic&amp;utm_content=fullstack_outlook" rel="noopener ugc nofollow" target="_blank">ZenStack</a>, a toolkit that supercharges<br/>Prisma ORM with a powerful access control layer and<br/>unleashes its full potential for full-stack development.<br/>Our goal is to let you save time writing boilerplate code<br/>and focus on building what matters - the user experience.</span></pre></div></div>    
</body>
</html>