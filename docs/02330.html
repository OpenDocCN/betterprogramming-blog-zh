<html>
<head>
<title>The Basics of TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿的基础</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/basics-of-typescript-9fae646502e2?source=collection_archive---------13-----------------------#2019-11-22">https://betterprogramming.pub/basics-of-typescript-9fae646502e2?source=collection_archive---------13-----------------------#2019-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ea3f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么是TypeScript，为什么要尝试它？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c70b5dc931a6e60a421ffc025c78a1ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OYrHp_b84xKs_hgW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@clark_fransa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿诺·弗朗西斯卡</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="d5ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Typescript是编译成普通JavaScript的JavaScript的超集。顾名思义，typescript为我们提供了一种编写具有类型安全的JavaScript的方法，就像您使用其他强类型语言(如C#或Java)一样。</p><p id="cc39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> JavaScript是一个有效的类型脚本，类型是可选的，因此人们可以很容易地将JavaScript项目迁移到类型脚本，并逐步考虑类型安全。</em></p><p id="c94f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它为我们提供了编译时类型安全和ide中更好的智能感知。这有助于你尽早发现错误，提高工作效率。</p><p id="61b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">告别无模式对象。向自我记录的输入和输出对象问好。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0dc2" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">键入注释</h1><p id="6ab3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">所有变量、函数参数和函数返回类型都是使用typescript中的类型批注定义的，如下所示:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="bef2" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">const </strong>a: <strong class="nb iu">number </strong>= 124;<br/><strong class="nb iu">const </strong>b: <strong class="nb iu">number </strong>= 56;<br/><br/><strong class="nb iu">function </strong>sum(a: <strong class="nb iu">number</strong>, b: <strong class="nb iu">number</strong>): <strong class="nb iu">number </strong>{<br/>  <strong class="nb iu">return </strong>a + b;<br/>}</span></pre><h2 id="75d0" class="nf me it bd mf nk nl dn mj nm nn dp mn li no np mp lm nq nr mr lq ns nt mt nu bi translated">原始类型</h2><p id="b33d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">JavaScript原始类型ie <code class="fe nv nw nx nb b">number, string, boolean</code>都可以用作typescript中的内置类型。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="fefa" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">let </strong>a: <strong class="nb iu">number</strong>;<br/>a = 5;<br/>a = '5'; // error<br/><br/><strong class="nb iu">let </strong>b: <strong class="nb iu">string</strong>;<br/>b = '100';<br/>b = 100; // error<br/><br/><strong class="nb iu">let </strong>c: <strong class="nb iu">boolean</strong>;<br/>c = <strong class="nb iu">true</strong>;<br/>c = 'true'; // error</span></pre><h2 id="32c6" class="nf me it bd mf nk nl dn mj nm nn dp mn li no np mp lm nq nr mr lq ns nt mt nu bi translated">数组</h2><p id="91c2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果我们想将一个变量定义为一个数组，我们可以简单地在<code class="fe nv nw nx nb b">[]</code>后面加上任何有效的类型注释。这允许我们安全地操作数组对象，而不用担心给数组成员分配错误的类型。下面演示了这一点:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c987" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">let </strong>numArray: <strong class="nb iu">number</strong>[] = [ 24, 57, 100 ];<br/><br/>numArray[0] = 10; // ok<br/>numArray[1] = '10'; // error</span></pre><h2 id="b05c" class="nf me it bd mf nk nl dn mj nm nn dp mn li no np mp lm nq nr mr lq ns nt mt nu bi translated">接口/用户定义的类型</h2><p id="ee0f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们可以借助如下所示的<em class="lv">类型</em>或<em class="lv">接口</em>在JavaScript中定义schemas复杂对象:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="8999" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">type </strong>point = {<br/>  x: <strong class="nb iu">number</strong>;<br/>  y: <strong class="nb iu">number</strong>;<br/>}<br/><br/><strong class="nb iu">let </strong>a: point = {<br/>  x: 1,<br/>  y: 1<br/>};<br/><br/>a.x = 0;<br/>a.y = '1'; // error<br/>a.z = 2; //error</span><span id="f8c6" class="nf me it nb b gy ny nh l ni nj"><strong class="nb iu">interface </strong>point2 {<br/>  x: <strong class="nb iu">number</strong>;<br/>  y: <strong class="nb iu">number</strong>;<br/>}<br/><br/><strong class="nb iu">let </strong>b: point2 = {<br/>  x: 1,<br/>  y: 1<br/>};<br/><br/>b.x = 0;<br/>b.y = '1'; // error<br/>b.z = 2; //error</span></pre><p id="88a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型和接口都可以用来定义类型。它们都可以通过类来扩展/实现。接口和类型的详细区别可以在这里阅读<a class="ae ky" href="https://stackoverflow.com/a/52682220" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="51f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">可选属性</strong></p><p id="24f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以简单地将<code class="fe nv nw nx nb b">?</code>作为变量的后缀，我们知道这个变量是可选的，如下所述:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e9df" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">type </strong>point = {<br/>  x: <strong class="nb iu">number</strong>;<br/>  y: <strong class="nb iu">number</strong>;<br/>  z?: <strong class="nb iu">number</strong>;<br/>}<br/><br/><strong class="nb iu">let </strong>a: point = { x: 1 }; // error missing property 'y'<br/><br/><strong class="nb iu">let </strong>b: point = { x: 1, y: 1 }; // ok since z is optional</span></pre><h2 id="4d7a" class="nf me it bd mf nk nl dn mj nm nn dp mn li no np mp lm nq nr mr lq ns nt mt nu bi translated">内嵌注释</h2><p id="2efd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">不是为每个对象创建一个新的<em class="lv">类型</em>或<em class="lv">接口</em>，我们可以定义它的结构<em class="lv">内联</em>，如下所示:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0f4c" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">let </strong>student: {<br/>  age: <strong class="nb iu">number</strong>;<br/>  name: <strong class="nb iu">string</strong>,<br/>};<br/><br/>student = {<br/>  age: 15,<br/>  name: 'John doe'<br/>};<br/><br/><strong class="nb iu">function </strong>getAge(student: { age: <strong class="nb iu">number </strong>}) {<br/>  <strong class="nb iu">return </strong>student.age;<br/>}<br/><br/>console.log(getAge(student)); // 15</span></pre><h2 id="8ea9" class="nf me it bd mf nk nl dn mj nm nn dp mn li no np mp lm nq nr mr lq ns nt mt nu bi translated">特殊类型</h2><ul class=""><li id="2c22" class="nz oa it lb b lc mv lf mw li ob lm oc lq od lu oe of og oh bi translated"><code class="fe nv nw nx nb b">any</code> →我们可以将变量的类型定义为<em class="lv"> any </em>，表示任何东西都可以赋给它。应该避免使用这种方法，因为这违背了定义类型的目的。</li><li id="77e0" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe nv nw nx nb b">null</code>和<code class="fe nv nw nx nb b">undefined</code> →除非ts编译器选项中的<code class="fe nv nw nx nb b">strictNullChecks</code> <em class="lv"> </em>标志<em class="lv"> </em>为<code class="fe nv nw nx nb b">true</code>，否则我们可以将null/undefined赋给任何其他类型。</li><li id="7653" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe nv nw nx nb b">:void</code> →当函数没有返回类型时使用。</li></ul><h2 id="bcfa" class="nf me it bd mf nk nl dn mj nm nn dp mn li no np mp lm nq nr mr lq ns nt mt nu bi translated">无商标消费品</h2><p id="b805" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">一些功能/算法不依赖于对象的实际类型。例如，一个函数接受一个项目列表和一个谓词，以返回一个基于谓词的过滤列表。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="22c6" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">type </strong>student = {<br/>  name: <strong class="nb iu">string</strong>,<br/>  age: <strong class="nb iu">number<br/></strong>}<br/><br/><strong class="nb iu">const </strong>students: student[] = [<br/>  {<br/>    age: 17,<br/>    name: 'John doe'<br/>  },<br/>  {<br/>    age: 15,<br/>    name: 'Jane doe'<br/>  }<br/>];<br/><br/><strong class="nb iu">function </strong>filter&lt;T&gt;(list: T[], predicate): T[] {<br/>  <strong class="nb iu">return </strong>list.filter(predicate);<br/>}<br/><br/>console.log(filter(students, (s: student) =&gt; s.age &gt; 15));<br/>// [ { age: 17, name: 'John doe' } ]</span></pre><p id="1513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们在返回的列表中也获得了类型安全。事实上，由于JavaScript已经有了对数组的过滤功能，因此在内部typescript使用泛型来定义其结构。</p><h2 id="f948" class="nf me it bd mf nk nl dn mj nm nn dp mn li no np mp lm nq nr mr lq ns nt mt nu bi translated">联合类型</h2><p id="e56b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在某些情况下，我们希望变量是多种类型中的一种，例如一个<code class="fe nv nw nx nb b">string</code>或一个<code class="fe nv nw nx nb b">number</code>。我们可以简单地这样定义它:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c7f1" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">let </strong>a: <strong class="nb iu">number </strong>| <strong class="nb iu">string</strong>;<br/>a = 100; // ok<br/>a = '100'; // ok</span></pre><h2 id="a81a" class="nf me it bd mf nk nl dn mj nm nn dp mn li no np mp lm nq nr mr lq ns nt mt nu bi translated">交叉类型</h2><p id="1760" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在某些情况下，我们希望将两个对象的属性合并成一个新的对象。交集类型允许我们以一种类型安全的方式实现这一点，如下所示:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ddc8" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">function </strong>extend&lt;T, U&gt;(a: T, b: U): T &amp; U {<br/>  <strong class="nb iu">return </strong>{<br/>    ...a,<br/>    ...b<br/>  };<br/>}<br/><br/><strong class="nb iu">const </strong>test = extend({ name: 'John' }, { age: 25 });<br/>console.log(test);<br/>//{ name: 'John', age: 25 }</span></pre><h2 id="dc18" class="nf me it bd mf nk nl dn mj nm nn dp mn li no np mp lm nq nr mr lq ns nt mt nu bi translated">元组类型</h2><p id="fe81" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在JavaScript中，我们通常使用数组作为元组。我们可以简单地在typescript中将元组定义为<code class="fe nv nw nx nb b">:[typeOfElement1, typeOfElement2]</code>。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="74c1" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">let </strong>a: [<strong class="nb iu">string</strong>, <strong class="nb iu">number</strong>];<br/>a[0] = '100'; // ok<br/>a[1] = 100; // ok<br/><br/>a[1] = '100'; //error<br/>a[0] = 100; // error</span></pre><h2 id="d60f" class="nf me it bd mf nk nl dn mj nm nn dp mn li no np mp lm nq nr mr lq ns nt mt nu bi translated">枚举</h2><p id="d586" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">枚举是相关值的集合。JavaScript不支持将<em class="lv">枚举</em>作为数据类型。，但是typescript有。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="deba" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">enum </strong>WeekDay {<br/>  <em class="lv">monday</em>,<br/>  <em class="lv">tuesday</em>,<br/>  <em class="lv">wednesday</em>,<br/>  <em class="lv">thursday</em>,<br/>  <em class="lv">friday</em>,<br/>  <em class="lv">saturday</em>,<br/>  <em class="lv">sunday<br/></em>}<br/><br/><strong class="nb iu">function </strong>isWorkingDay(day: WeekDay): <strong class="nb iu">boolean </strong>{<br/>  <strong class="nb iu">switch </strong>(day) {<br/>    <strong class="nb iu">case </strong>WeekDay.<em class="lv">saturday</em>:<br/>    <strong class="nb iu">case </strong>WeekDay.<em class="lv">sunday</em>:<br/>      <strong class="nb iu">return false</strong>;<br/>    <strong class="nb iu">default</strong>:<br/>      <strong class="nb iu">return true</strong>;<br/>  }<br/>}<br/><br/><strong class="nb iu">const </strong>mon = WeekDay.<em class="lv">monday</em>;<br/><strong class="nb iu">const </strong>sat = WeekDay.<em class="lv">saturday</em>;<br/>console.log(isWorkingDay(mon)); // true<br/>console.log(isWorkingDay(sat)); // false<br/><br/><strong class="nb iu">enum </strong>Color {<br/>  <em class="lv">RED </em>= 'red',<br/>  <em class="lv">GREEN </em>= 'green',<br/>  <em class="lv">BLUE </em>= 'blue',<br/>}<br/><br/>// string enums can be used for comparisons<br/><strong class="nb iu">if </strong>(someStringFromDb === Color.<em class="lv">GREEN</em>) {</span><span id="5300" class="nf me it nb b gy ny nh l ni nj">}</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7a47" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">功能</h1><p id="c957" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们可以定义函数的参数和返回类型，如下所示:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5931" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">interface </strong>point {<br/>  lat: <strong class="nb iu">number</strong>,<br/>  long: <strong class="nb iu">number<br/></strong>}<br/><br/><strong class="nb iu">function </strong>getPoint(lat: <strong class="nb iu">number</strong>, long: <strong class="nb iu">number</strong>): point {<br/>  <strong class="nb iu">return </strong>{<br/>    lat: lat,<br/>    long: long<br/>  }<br/>}</span></pre><p id="c01f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使我们没有定义函数的返回类型，typescript也足够聪明，可以自己推断出返回类型。所以，下面也行得通:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="684b" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">function </strong>getPoint(lat: <strong class="nb iu">number</strong>, long: <strong class="nb iu">number</strong>) {<br/>  <strong class="nb iu">return </strong>{<br/>    lat: lat,<br/>    long: long<br/>  }<br/>}</span></pre><p id="dc71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是总是建议定义返回类型以避免类似这样的错误:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="63a6" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">function </strong>getPoint(lat: <strong class="nb iu">number</strong>, long: <strong class="nb iu">number</strong>) {<br/>  <strong class="nb iu">return </strong>{<br/>    lat: lat,<br/>    lnog: long // no error since we left it to typescript to infer the return type<br/>  }<br/>}</span></pre><h2 id="734b" class="nf me it bd mf nk nl dn mj nm nn dp mn li no np mp lm nq nr mr lq ns nt mt nu bi translated">可选参数</h2><p id="29d4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们可以将参数定义为可选的:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5bf0" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">function </strong>foo(bar: <strong class="nb iu">string</strong>, baz?: <strong class="nb iu">number</strong>) {<br/>  // baz is optional<br/>}<br/><br/>foo('str'); // ok<br/>foo('str', 1); // ok</span></pre><p id="6447" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们可以为参数设置默认值:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="a371" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">function </strong>foo(bar: <strong class="nb iu">string</strong>, baz: <strong class="nb iu">number </strong>= 1) {<br/>  console.log(bar, baz);<br/>}<br/><br/>foo('str'); // str, 1<br/>foo('str', 100); // str, 100</span></pre><h2 id="a74e" class="nf me it bd mf nk nl dn mj nm nn dp mn li no np mp lm nq nr mr lq ns nt mt nu bi translated">函数重载</h2><p id="0569" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Typescript允许我们<em class="lv">声明</em>重载。这对于文档和安全目的是有用的。但是由于JavaScript不支持函数重载，我们不得不<em class="lv">为所有重载实现</em>一个通用函数。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="bed9" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">function </strong>stringOrNumber(a: <strong class="nb iu">string</strong>): <strong class="nb iu">string</strong>;<br/><strong class="nb iu">function </strong>stringOrNumber(a: <strong class="nb iu">number</strong>): <strong class="nb iu">number</strong>;<br/><br/><strong class="nb iu">function </strong>stringOrNumber(a: <strong class="nb iu">any</strong>) {<br/>  <strong class="nb iu">if </strong>(<strong class="nb iu">typeof </strong>a === 'string') {<br/>    // typescript knows 'a' is a string in this block<br/>    // let b = a * 2; // error<br/>    <br/>    <strong class="nb iu">return </strong>a;<br/>  } <strong class="nb iu">else if </strong>(<strong class="nb iu">typeof </strong>a === 'number') {<br/>    // typescript knows 'a' is a number in this block<br/>    // let b = a.substr('') // error<br/>    <br/>    <strong class="nb iu">return </strong>a * 2;<br/>  }<br/>}<br/><br/>stringOrNumber('hello'); // hello<br/>stringOrNumber(100); // 200<br/>stringOrNumber(<strong class="nb iu">true</strong>); // error</span></pre><h2 id="6dea" class="nf me it bd mf nk nl dn mj nm nn dp mn li no np mp lm nq nr mr lq ns nt mt nu bi translated">声明函数</h2><p id="31bd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有两种方法可以让<em class="lv">声明</em>一个没有实现的函数。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4bed" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">type </strong>longHand = {<br/>  (a: <strong class="nb iu">number</strong>): <strong class="nb iu">number<br/></strong>}<br/><br/><strong class="nb iu">type </strong>shortHand = (a: <strong class="nb iu">number</strong>) =&gt; <strong class="nb iu">number</strong>;</span></pre><p id="0309" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要声明函数重载，那么速记和手写声明的唯一区别就来了。例如:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="35f8" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">type </strong>longHand = {<br/>  (a: <strong class="nb iu">number</strong>): <strong class="nb iu">number</strong>,<br/>  (a: <strong class="nb iu">string</strong>): <strong class="nb iu">string</strong>,<br/>}</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="66e0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">名称空间</h1><p id="f270" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">命名空间可用于函数的逻辑分组，如下所示:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="f326" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">namespace </strong>Logger {<br/>  <strong class="nb iu">export function </strong>info(message: <strong class="nb iu">string</strong>) {<br/>    console.log(message);<br/>  }<br/>  <br/>  <strong class="nb iu">export function </strong>error(message: <strong class="nb iu">string</strong>) {<br/>    console.error(message);<br/>  }<br/>}<br/><br/>Logger.info('info text');<br/>Logger.error('error text');</span></pre><p id="cf65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种逻辑分组也可以通过基于文件的模块来实现，建议通过命名空间来实现。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d97e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">班级</h1><p id="1dcd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">ES6类和typescript类之间的唯一区别是，typescript为类变量提供了类型安全和访问说明符。</p><p id="ddc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">访问说明符只提供编译时安全，因为编译后的JavaScript不支持它们——与类型安全相同。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ea0e" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">class </strong>Animal {<br/>  <strong class="nb iu">private readonly </strong>name: <strong class="nb iu">string</strong>;<br/>  <strong class="nb iu">protected </strong>isPet: <strong class="nb iu">boolean</strong>;<br/>  <br/>  <strong class="nb iu">constructor</strong>(name: <strong class="nb iu">string</strong>, isPet: <strong class="nb iu">boolean </strong>= <strong class="nb iu">false</strong>) {<br/>    <strong class="nb iu">this</strong>.name = name;<br/>    <strong class="nb iu">this</strong>.isPet = isPet;<br/>  }<br/>  <br/>  <strong class="nb iu">public </strong>isPetAnimal() {<br/>    <strong class="nb iu">return this</strong>.isPet;<br/>  }<br/>  <br/>  <strong class="nb iu">protected </strong>getName() {<br/>    <strong class="nb iu">return this</strong>.name;<br/>  }<br/>}<br/><br/><strong class="nb iu">class </strong>Snake <strong class="nb iu">extends </strong>Animal {<br/>  <strong class="nb iu">public </strong>getName() {<br/>    // return a.name; // error since name is private in parent class<br/>    <strong class="nb iu">return super</strong>.getName();<br/>  }<br/>}<br/><br/><strong class="nb iu">const </strong>animal = <strong class="nb iu">new </strong>Animal('tom', <strong class="nb iu">true</strong>);<br/>console.log(animal.isPetAnimal()); // true<br/>// animal.getName(); // error since its protected<br/><br/><strong class="nb iu">const </strong>snake = <strong class="nb iu">new </strong>Snake('kaa');<br/>console.log(snake.isPetAnimal()); // false<br/>console.log(snake.getName()); // kaa</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="fcd8" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="4c44" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Typescript为我们提供了一种编写具有编译时类型安全的JavaScript的方法，同时还支持JavaScript中不支持的枚举、访问说明符等结构。</p><p id="6712" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">参考文献</strong>:【https://basarat.gitbooks.io/typescript/ T2】</p></div></div>    
</body>
</html>