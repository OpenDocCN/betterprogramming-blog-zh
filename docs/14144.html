<html>
<head>
<title>Communicate Data More Effectively Using the DALL-E API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用DALL-E API更有效地交流数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/communicate-data-more-effectively-using-dall-e-api-1ffb9250944d?source=collection_archive---------6-----------------------#2022-11-10">https://betterprogramming.pub/communicate-data-more-effectively-using-dall-e-api-1ffb9250944d?source=collection_archive---------6-----------------------#2022-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8172" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用DALL-E API可视化犯罪数据集并生成逼真的人脸</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/816beadfa86d0323843e141fa0aabdd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v_jAwk9VsaL41sj15ZhU2w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用DALL-E可视化美国犯罪率</p></figure><p id="c909" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我的上一篇文章<a class="ae lr" href="https://medium.com/better-programming/using-dall-e-for-data-visualization-59df580e66ab" rel="noopener">如何使用DALL-E进行数据可视化</a>中，我探讨了文本到图像的生成如何用于数据可视化。</p><p id="57d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我从Chernoff Faces开始，这是一种可视化技术，通过将字段映射到面部特征，以人脸的形状显示多元数据。典型的，切诺夫脸是卡通线条画。</p><p id="2014" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但我很好奇DALL-E生成更逼真的人脸的能力是否有助于更有效地传达数据。</p><h1 id="16d5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">方法</h1><p id="5a00" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我决定创建一个简单的A/B测试。我首先选择了一个数据集，美国各州的犯罪率，并选择了可用字段的子集:盗窃、入室盗窃和抢劫。</p><p id="3af2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了数据集，我创建了两个可视化:</p><ul class=""><li id="8e9f" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">第一个可视化使用了由Peter Wolf使用<code class="fe my mz na nb b"><a class="ae lr" href="http://cran.r-project.org/web/packages/aplpack/index.html" rel="noopener ugc nofollow" target="_blank">APLPACK</a></code>(另一个情节包)创建的卡通式Chernoff脸。</li><li id="abba" class="mp mq iq kx b ky nc lb nd le ne li nf lm ng lq mu mv mw mx bi translated">第二种可视化使用通过Python脚本生成的文本提示使用DALL-E创建的照片级真实感人脸。</li></ul><h1 id="1c02" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">可视化#1:卡通脸</h1><p id="07d7" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">对于这个过程的这一部分，我使用R Studio和<code class="fe my mz na nb b">APLPACK</code>来生成人脸。Nathan Yau有一篇很棒的文章，记录了如何用la Chernoff的卡通面孔来可视化数据，所以我不会重复他写的内容。如果您想继续学习并创建自己的文章，请阅读这篇优秀的文章。</p><p id="b9e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是可视化#1的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/7bc9c18570df1b4070a7664f07a0a054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/1*igq90G7SSpqaTY2ooYyjMA.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">内森·尤@<a class="ae lr" href="https://flowingdata.com/" rel="noopener ugc nofollow" target="_blank">https://flowingdata.com/</a></p></figure><h1 id="5a4b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">可视化#2:照片般真实的脸</h1><p id="e988" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">为了使用DALL-E可视化数据集，我创建了一个Python脚本，它做了三件重要的事情:</p><p id="9509" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，它创建了一个映射，定义了与每个度量相关联的面部部分。在下面的要点中，你可以看到字段<code class="fe my mz na nb b">burglary</code>映射到头发长度，<code class="fe my mz na nb b">robbery</code>映射到眼睛形状，<code class="fe my mz na nb b">larceny</code>映射到嘴。</p><pre class="kg kh ki kj gt ni nb nj bn nk nl bi"><span id="f152" class="nm lt iq nb b be nn no l np nq">mapping = {<br/>    "robbery": [<br/>        "closed eyes", "relaxed eyes", "scared wide open eyes"<br/>    ],<br/>    "burglary": [<br/>        "shaved head", "short scruffy hair", "long hair"<br/>    ],<br/>    "larceny_theft": [<br/>        "closed mouth", "slightly parted lips", "wide open mouth"<br/>    ],<br/>}</span></pre><p id="f348" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其次，它使用<code class="fe my mz na nb b">Pandas</code>打开CSV文件，并使用<code class="fe my mz na nb b">pandas.qcut</code>根据映射中标签的数量将值离散化到大小相等的桶中。</p><p id="c4b2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这意味着<code class="fe my mz na nb b">qcut</code>试图将数据分成大小相等的仓(每个标签一个)。例如，<code class="fe my mz na nb b">robbery</code>有三个标签:“闭上眼睛”、“放松的眼睛”和“吓得睁大眼睛”，因此<code class="fe my mz na nb b">robbery</code>值将被“装入”这三个桶中的一个。</p><p id="ff13" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">脚本将这些离散化或“分箱”值存储为数据框中的一个新字段。看起来是这样的:</p><pre class="kg kh ki kj gt ni nb nj bn nk nl bi"><span id="4249" class="nm lt iq nb b be nn no l np nq">###<br/># For each key in the dictionary, divide up the underlying data into <br/># equal sized bins (one for each label). For more info on Panda's qcut, see:<br/># https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.qcut.html<br/><br/>df = pd.read_csv("crime.csv")<br/><br/>for key in mapping:<br/>    df["%s_attr" % key] = pd.qcut(df[key], q=len(mapping[key]), labels=mapping[key])</span></pre><p id="5de5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是数据框子集的输出示例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5cec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第三，对于数据集中的每一行，它从模板中创建提示。模板使用上一步收集的值填充其值。</p><pre class="kg kh ki kj gt ni nb nj bn nk nl bi"><span id="92fe" class="nm lt iq nb b be nn no l np nq">###<br/># For each key in the dictionary, divide up the underlying data into <br/># equal sized bins (one for each label). For more info on Panda's qcut, see:<br/># https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.qcut.html<br/><br/>df = pd.read_csv("crime.csv")<br/><br/>for key in mapping:<br/>    df["%s_attr" % key] = pd.qcut(df[key], q=len(mapping[key]), labels=mapping[key])</span></pre><p id="7a27" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将所有这些放在一起，我们就有了生成提示的最终脚本。运行它会产生以下输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ff3d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随着<a class="ae lr" href="https://openai.com/blog/dall-e-api-now-available-in-public-beta/" rel="noopener ugc nofollow" target="_blank"> DALL-E API在</a>的推出，自动生成实际图像的过程变得轻而易举。</p><pre class="kg kh ki kj gt ni nb nj bn nk nl bi"><span id="5d64" class="nm lt iq nb b be nn no l np nq"># Use this as a unique ID for each run<br/>epoch = int(time.time() * 1000)<br/><br/># For each row, generate a face using the prompt<br/>for index, row in df.iterrows():<br/>    openai.api_key = API_KEY<br/>    response = openai.Image.create(<br/>        prompt=row["prompt"],<br/>        n=1,<br/>        size="512x512"<br/>    )<br/><br/>    # OpenAI gives us back a URL<br/>    image_url = response['data'][0]['url']<br/><br/>    # Request the URL and save it locally<br/>    img_data = requests.get(image_url).content<br/>    with open('%d-%s.jpg' % (epoch, row["short_name"]), 'wb') as handler:<br/>        handler.write(img_data)</span></pre><p id="1927" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">经过一些试验，我为所有提示添加了“30岁”和“白人男性”，以尽量使基线照片正常化。我还在提示中添加了“脸部照片”，试图控制这个人的脸在图像中出现的比例。鉴于我们正在处理的数据集，面部照片也很酷。</p><p id="7c54" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后的结果…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/75b890e119eec8456e465254d40ffffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IstljHQHDt34R3WRjuX2Sw.png"/></div></div></figure><h1 id="14f6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="a7e9" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">切尔诺夫使用人脸背后的主要思想是，人类很容易识别人脸，并毫不费力地注意到人脸的微小变化。</p><p id="2cd7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可视化的全部意义在于直观地比较数量。在我非正式的N=1 A/B测试中，我问自己:生活在哪个州会更不理想？哪个州是最理想的？我似乎比在卡通中更容易注意到照片般逼真的面孔的变化。</p><p id="9898" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当选择一个州居住时，你可能想远离那些满脸恐惧、长头发的州(至少在偷窃、盗窃和抢劫方面)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/2d6c16e1ad86337fc832f8ee79d79632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*ZGR7clDdLuJYdqcrTZP-jg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">田纳西州</p></figure><p id="78c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在光谱的另一端，你可以看到由睡眼惺忪的秃子代表的州。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/e9f668e9b97822cf696862016ccd2cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*_cB9FAK9qP2D8ZVTet5Hug.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">康涅狄格州</p></figure><p id="d4da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用右场→面部特征映射，生成的照片级逼真图像以一种漫画式对等物中没有表达的方式传达情感，使某些面部突出。</p><p id="0c33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">存在一些挑战，尤其是在生成的图像中控制特征的能力有限，这使得很难在各个人脸之间画出细微的区别。</p><p id="e819" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是粗略的发现呢？我觉得可能有用。</p><p id="6034" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你怎么想呢?</p></div></div>    
</body>
</html>