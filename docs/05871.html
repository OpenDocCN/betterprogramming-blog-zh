<html>
<head>
<title>WebSockets on Demand With AWS Lambda, Serverless Framework, and Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebSockets on Demand采用AWS Lambda、无服务器框架和Go</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/websockets-on-demand-with-aws-lambda-serverless-framework-and-go-616bd7ff11c9?source=collection_archive---------2-----------------------#2020-08-13">https://betterprogramming.pub/websockets-on-demand-with-aws-lambda-serverless-framework-and-go-616bd7ff11c9?source=collection_archive---------2-----------------------#2020-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bdef" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Lambda函数和web sockets——对立面如何在云中相遇</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/177561bf67cd16721efb702d2ba7d304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-B7B9xhLuPQe9Z6aPgb9dg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="3e90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> Lambda函数</a>和<a class="ae lu" href="https://en.wikipedia.org/wiki/WebSocket" rel="noopener ugc nofollow" target="_blank"> WebSockets </a>可以看作是难以调和的概念。兰达本质上是短暂的。它们在被调用时出现，然后在完成工作后的某个时候消失。相反，WebSockets在一台服务器和许多客户机之间保持稳定、长期的连接。</p><p id="216d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> AWS APIGateway </a>提供了将这两者结合在一起的可能性，结合了Lambda按需模型的优势和WebSockets实时双向通信的能力。</p><p id="9918" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们描述了如何使用AWS API网关和Lambda函数实现WebSocket服务器。我们将使用<a class="ae lu" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务框架</a>来建立基础设施和部署解决方案，并将<a class="ae lu" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>作为编程语言。</p><p id="4502" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之所以选择无服务器，是因为它是一种将基础设施定义为代码的简单且记录良好的方法。选择Go是因为它保证了它有潜力优化Lambda成本，并提供低冷启动延迟，这是实现这种模型的一个重要特征。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5ee3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">一个简单的WebSocket服务器和客户端可以做什么</h1><p id="7e87" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">具体来说，我们将实现一个简单的WebSocket服务器。该服务器的目标是将从一个客户端收到的每条消息作为回应广播给所有连接的客户端。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/530d6bfcdaa99b354ffe03558a1f075e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aw2ZJALtZRnvF8coRCURSA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">回声广播服务器</p></figure><p id="8f2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们从图中看到的，每个客户端连接到服务器，发送消息由服务器广播到所有连接的客户端，最后，从服务器断开连接。</p><p id="98ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换句话说，客户端可以触发三种类型的事件:</p><ul class=""><li id="07a8" class="na nb it la b lb lc le lf lh nc ll nd lp ne lt nf ng nh ni bi translated"><strong class="la iu">将</strong>连接到服务器</li><li id="d58d" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated"><strong class="la iu">断开</strong>与服务器的连接</li><li id="6411" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated"><strong class="la iu">向服务器发送消息</strong></li></ul><p id="8e9f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，服务器必须对这些事件做出适当的反应。它的反应方式用Lambda函数编码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3a58" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">云中组件的设置</h1><p id="dd76" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">既然我们已经了解了客户端可以做什么以及服务器需要做什么，我们就可以开始在云中构建基础设施了。正如我们所说的，我们将使用无服务器框架来做到这一点。</p><p id="5a7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">API网关和Lambda函数的配置非常简单。我们开始将Lambda函数与要求它们管理的事件类型联系起来。这是定义这种链接的无服务yaml配置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无服务器配置yaml</p></figure><p id="1fcd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码片段中，我们定义了一个服务、一个提供者和一个当WebSocket事件到达服务器时要执行的Lambda函数。属性将一个事件链接到它的函数，这意味着当事件发生时，函数被触发。<code class="fe nq nr ns nt b">handler</code>属性指向Lambda函数将要执行的代码，在本例中是<code class="fe nq nr ns nt b">bin/handleRequest</code>，一个Go编译的可执行文件。</p><p id="c759" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，相同的功能(由<code class="fe nq nr ns nt b">bin/handleRequest</code>实现)管理<code class="fe nq nr ns nt b">connect</code>、<code class="fe nq nr ns nt b">disconnect</code>和<code class="fe nq nr ns nt b">default</code>事件。我们可以定义不同的函数来管理不同的事件，但是为了简单起见，我们选择了单一的函数，并允许一些优化形式，我们将在后面讨论。</p><p id="189c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们回到事件上。我们知道<code class="fe nq nr ns nt b">connect</code>和<code class="fe nq nr ns nt b">disconnect</code>是什么。但是什么是<code class="fe nq nr ns nt b">default</code>？</p><p id="4885" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当客户端向服务器发送消息时，消息的含义(即语义)被嵌入到其有效负载的内容中。例如，如果消息携带JSON有效负载，那么JSON可以有一个属性<code class="fe nq nr ns nt b">action</code>来标识消息应该触发的逻辑。然后，我们可以配置AWS API Gateway，用不同的Lambda函数对具有不同语义的消息做出反应。换句话说，我们可以将不同的Lambda函数附加到<code class="fe nq nr ns nt b">action</code>字段的不同值上(如果我们遵循上面的例子)。如果没有找到匹配，那么系统返回到<code class="fe nq nr ns nt b">default</code>事件和与之链接的Lambda函数。</p><p id="a147" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的例子中，我们对所有类型的事件使用相同的Lambda函数，所以没有定义<code class="fe nq nr ns nt b">custom</code>事件，只配置了<code class="fe nq nr ns nt b">$default</code>事件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c6a2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Go实现结构</h1><p id="4ae7" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">API网关WebSocket服务使用的Lambda函数的<a class="ae lu" href="https://docs.aws.amazon.com/lambda/latest/dg/golang-handler.html" rel="noopener ugc nofollow" target="_blank"> Go实现的结构也非常简单。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d67b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要在<code class="fe nq nr ns nt b">main</code>包中定义一个<code class="fe nq nr ns nt b">main</code>函数。<code class="fe nq nr ns nt b">main</code>函数简单地调用<code class="fe nq nr ns nt b">lambda.Start(handleRequest)</code>。</p><p id="d5cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为在我们的例子中，一个单一的Lambda函数管理所有类型的事件，我们需要找到识别事件类型的方法，并基于它实现一些开关逻辑。<code class="fe nq nr ns nt b">handleRequest</code>通过查询作为参数传入的事件结构的<code class="fe nq nr ns nt b">RequestContext</code>的<code class="fe nq nr ns nt b">RouteKey</code>字段，知道它正在处理哪种类型的事件，事件结构的类型为<code class="fe nq nr ns nt b">APIGatewayWebsocketProxyRequest</code>。根据事件的类型，执行适当的逻辑。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0f5d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">$connect，$disconnect和connectionIDs</h1><p id="38dc" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">WebSocket服务器能够向特定客户端发送目标消息。这意味着每个连接的客户端需要有一个唯一的<code class="fe nq nr ns nt b">connectionID</code>，并且服务器需要跟踪这样的<code class="fe nq nr ns nt b">connectionID</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/d5f05684df18efe1f39abed59a4aeba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cPsYIOxyIjPAB9tYSbNatQ.png"/></div></div></figure><p id="728a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当客户端连接到服务器时，API网关负责为每个客户端分配一个唯一的<code class="fe nq nr ns nt b">connectionID</code>。在每次调用<code class="fe nq nr ns nt b">handleRequest</code>函数时，<code class="fe nq nr ns nt b">connectionID</code>都作为参数传递。</p><p id="f7ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">WebSocket服务器需要为活动的<code class="fe nq nr ns nt b">connectionID</code>提供某种形式的存储。当接收到<code class="fe nq nr ns nt b">$connect</code>事件时，<code class="fe nq nr ns nt b">connectionID</code>将被添加到存储中。当<code class="fe nq nr ns nt b">$disconnect</code>事件发生时，<code class="fe nq nr ns nt b">connectionID</code>将从存储中删除。</p><p id="14e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑到Lambda函数的短暂特性，我们不能使用它的内部内存来存储<code class="fe nq nr ns nt b">connectionID</code> s，但是我们需要依赖一些持久的外部系统，例如数据库。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/f0774f2e380b6eab8c5995965b85300f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nYzhIJhL2QtaW7mRc4zjdA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ConnectionIDs存储</p></figure><p id="8e91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常我们会考虑使用AWS Dynamo DB，但任何永久存储机制都可以(在提供的代码中，我们实际上使用了Atlas上的<a class="ae lu" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>，只是为了给示例添加一个不寻常的位)。因此，为了保持实现的开放性，我们定义了一个接口<code class="fe nq nr ns nt b">connectionStorer</code>，来描述我们所期望的行为，并将特定实现的决策委托给一些依赖注入机制。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">connectionStorer接口</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">管理$connect和$disconnect事件</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="63ee" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">$default，动作发生的位置</h1><p id="e2be" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">实际上，在我们的例子中并没有发生什么。逻辑非常简单。收到的每条消息都会被回显给所有连接的客户端。这个简单的逻辑由<code class="fe nq nr ns nt b">$default</code>案例触发，并委托给<code class="fe nq nr ns nt b">echo</code>功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">管理$default事件</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ee62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Lambda函数的作用类似于API网关的客户端，它创建网关的一个实例，并向该实例发送回显的消息，每个活动连接发送一个消息。</p><p id="f91f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实现中还有一个小技巧。如果从客户端收到的消息代表一个整数，那么这个值被用来模拟一个使用<code class="fe nq nr ns nt b">time.Sleep</code>的长时间运行的流程。稍后我们将使用这个技巧来测试Lambda如何对来自不同客户端的并发请求做出反应。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c25d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">优化策略</h1><p id="1456" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">值得注意的是，我们使用全局变量<code class="fe nq nr ns nt b">apigateway</code>在Lambda函数的整个生命周期中存储一个网关实例。这种选择背后的原因是Lambda函数的一个实例可以服务于多个后续请求。因此，虽然Lambda函数确实可以按需实例化，但当请求到达时，该实例在一定时间内保持活动并准备好为其他请求服务也是事实(简单的经验测量表明该时间大约为10分钟)。我们可以定义全局变量来保存我们希望在后续请求处理中重用的资源，例如API网关实例。</p><p id="ca31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似地，我们在一个全局变量中保存MongoDB连接，因为创建它是一个开销很大的操作，我们希望每个Lambda函数实例化只执行一次。这就是为什么用一个单一的<code class="fe nq nr ns nt b">handleRequest</code>功能来管理所有的事件——<code class="fe nq nr ns nt b">$connect</code>、<code class="fe nq nr ns nt b">$disconnect</code>和<code class="fe nq nr ns nt b">$default</code>——在效率方面带来优势的原因。所有这些事件都需要连接到MongoDB，所有这些事件的单个处理程序意味着单个Lambda函数，因此需要为所有事件打开单个数据库连接。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4b19" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">同一个Lambda函数可以服务多少个请求</h1><p id="dd5e" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">λ函数是短暂的，但不会太短暂。Lambda函数的同一个实例化可以服务于多个请求。让我们研究几个不同的案例。</p><h2 id="f90a" class="nw md it bd me nx ny dn mi nz oa dp mm lh ob oc mo ll od oe mq lp of og ms oh bi translated">由同一个Lambda函数服务的顺序请求</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/90cefa43ca89e2548cc5546f72eb9bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*byJbAdXhcDpfvg-tKLAc9Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个Lambda函数实例服务于更多的请求</p></figure><p id="2397" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一些请求被顺序发送到同一个Lambda端点。Lambda函数速度很快，在下一个请求到来之前完成一个请求的执行。在这种情况下，我们只能期望Lambda函数的一个实例服务于所有的请求。(只需在设置全局变量时记录日志，并验证这种情况只发生一次，就可以检查这一点。)</p><h2 id="f619" class="nw md it bd me nx ny dn mi nz oa dp mm lh ob oc mo ll od oe mq lp of og ms oh bi translated">两个后续请求之间的长空闲时间</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/fa7921bb5e1b72055544aecc4b2f39e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u4Bkp7Fwsgm5MwIPry1yPA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Lambda函数空闲时间过长，已被终止</p></figure><p id="4dc0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，如果我们让Lambda函数闲置太长时间，那么Lambda函数最终会终止。当下一个请求到达时，会创建一个新的Lambda函数来执行新的请求。同样，这可以通过记录全局变量的创建来检查。</p><h2 id="02bb" class="nw md it bd me nx ny dn mi nz oa dp mm lh ob oc mo ll od oe mq lp of og ms oh bi translated">并发请求</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/bd19f2b93afca37204fdc18cdb351923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wzCYTDaeAw-7jZoCiTvLTw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">两个并发请求由两个不同的Lambda函数处理</p></figure><p id="59aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一种情况是并发请求。当下一个请求到来时，Lambda函数实例仍在处理该请求。在这种情况下，Lambda函数的另一个实例被分离出来，因为根据<a class="ae lu" href="https://docs.aws.amazon.com/lambda/latest/dg/golang-handler.html" rel="noopener ugc nofollow" target="_blank"> AWS Lambda文档</a>，“Lambda函数的单个实例永远不会同时处理多个事件”。这可以使用<code class="fe nq nr ns nt b">echo</code>功能的睡眠功能进行测试。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="f0ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">了解这些行为很重要，因为这让我们有可能实现一些优化，比如数据库连接的缓存。另一方面，当使用这种技术时，我们需要谨慎，因为许多细节没有被记录，例如，Lambda函数在被终止之前可以保持空闲的时间，并且我们不能在我们的逻辑中盲目地依赖它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b7b5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么要去？</h1><p id="f96a" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们已经看到，一个Lambda函数一次只能服务一个请求。所以我们不能使用goroutines的能力来同时处理更多的请求。管理不同请求之间的并发性是API Gateway和Lambda的工作。</p><p id="41d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管如此，如果有意义的话，我们仍然可以在单个请求的流程中利用Go并发性。在很多情况下，这是有意义的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/707493a5d922494ced27072c1b66b71d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tMJ1qtjGxaoIGFxaaFfJzA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">利用Go并发的Lambda函数</p></figure><p id="dbd4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们考虑上面的例子，其中单个请求的处理需要不同的I/O操作，例如，调用REST API、访问DB、对存储做一些事情。在这种情况下，我们可以通过并发执行所有I/O操作来充分利用Go，从而减少Lambda处理的总时间，最小化响应时间，并潜在地优化成本，因为Lambda也是由处理时间定价的。</p><p id="0473" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Go作为一种编译语言，如果我们想要高效地使用内存，也是一个很好的选择。内存是影响执行Lambda函数成本的另一个因素。</p><p id="0e19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，如果我们希望有一个低的<a class="ae lu" href="https://levelup.gitconnected.com/aws-lambda-cold-start-language-comparisons-2019-edition-%EF%B8%8F-1946d32a0244" rel="noopener ugc nofollow" target="_blank">冷启动延迟</a>，即启动一个还没有执行上下文的Lambda函数所需的时间，Go似乎也是一个不错的选择，即使这个方面的基准<a class="ae lu" href="https://mikhail.io/serverless/coldstarts/aws/" rel="noopener ugc nofollow" target="_blank">有所不同</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5cc1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建、部署和测试</h1><p id="4238" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">最后，我们需要构建、部署和测试我们的WebSocket服务器。无服务器框架模板指导我们完成这些步骤，这些步骤无论如何都是非常简单的。</p><p id="fb04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于<strong class="la iu">构建</strong>，我们需要运行以下命令:</p><p id="b57c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nq nr ns nt b">env GOOS=linux go build -ldflags="-s-w" -o ./bin/handleRequest ./handleRequest</code></p><p id="0f14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦构建完成，我们可以用下面的命令<strong class="la iu">部署</strong>:</p><p id="e71d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nq nr ns nt b">sls deploy</code></p><p id="67a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在deploy命令中，我们可以指定环境变量值，以防在实现中使用它们，例如，传递db连接字符串。</p><p id="79db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了<strong class="la iu">手动测试</strong>服务器功能，我们使用<a class="ae lu" href="https://github.com/websockets/wscat" rel="noopener ugc nofollow" target="_blank"> wscat </a>通过以下命令启动交互式命令行基本会话:</p><p id="30b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nq nr ns nt b">wscat -c wss://urlOfTheServer</code></p><p id="913b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在提示符下，我们可以键入任何消息，然后按<code class="fe nq nr ns nt b">enter</code>向服务器发送消息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b175" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="9e2b" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们已经经历了基于AWS API网关和AWS Lambda函数构建WebSocket服务器所需的步骤。我们使用了无服务器来设置云配置和部署，并对逻辑进行编程。</p><p id="7bf0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好消息是，按照无服务器的理念，这是一种相对容易的构建按需可用的WebSocket服务器的方法。</p><p id="3c97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在有了一个强大的额外工具来解决我们希望提供丰富、交互式、多对多平台的用例，而不会产生设置和管理专用服务器或集装箱解决方案所涉及的复杂性和成本。</p><p id="92b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在GitHub上找到例子的所有<a class="ae lu" href="https://github.com/EnricoPicci/lambda-websockets" rel="noopener ugc nofollow" target="_blank">代码。</a></p></div></div>    
</body>
</html>