<html>
<head>
<title>7 Tools to Help You Write Better Swift Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">帮助您编写更好的Swift代码的7个工具</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-tools-to-help-you-write-better-swift-code-5e25bc77e88d?source=collection_archive---------3-----------------------#2021-03-01">https://betterprogramming.pub/7-tools-to-help-you-write-better-swift-code-5e25bc77e88d?source=collection_archive---------3-----------------------#2021-03-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="adea" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">工具作业</h2><div class=""/><div class=""><h2 id="49ae" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用这些小工具提高你的iOS代码质量</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/0453ed321d7b90830bbf7e269d780d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aY1IezC13O2TGnPY"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@pineapple?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">菠萝供应公司</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="af70" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当团队的规模扩大时，我们自然会建立一些共同的实践来保持工作时的理智。这些实践防止了Git冲突，创建了更加同质的代码库，并帮助人们对他们同事编写的代码感到舒适。</p><p id="7eae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在某些情况下，这些实践可能很难正式和自动地实施。例如，是否使用<code class="fe me mf mg mh b">Protocol</code>或<code class="fe me mf mg mh b">ProtocolWitness</code>不能被正式强制——这更像是一种编码风格。还有很多其他情况下这是可能的。例如，当我们把一种类型<code class="fe me mf mg mh b">force cast</code>成另一种类型时，我们可以要求编译器警告我们。</p><p id="e6b4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在今天的文章中，我们将探索一些可以添加到我们的项目中来执行这些规则的工具，朝着更加一致的代码库前进。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="3072" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">雨燕</h1><p id="921e" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated"><a class="ae lh" href="https://github.com/realm/SwiftLint" rel="noopener ugc nofollow" target="_blank"> SwiftLint </a>是由<a class="ae lh" href="https://github.com/realm" rel="noopener ugc nofollow" target="_blank"> Realm </a>构建的一个工具，它执行规则来创建一个连贯的编码风格。</p><p id="1ef3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">可以用<code class="fe me mf mg mh b">brew</code>安装，也可以边开发边当<code class="fe me mf mg mh b">pod</code>用。在如何使用它方面，我们也有一些选择。我们可以:</p><ol class=""><li id="1d06" class="nm nn it lk b ll lm lo lp lr no lv np lz nq md nr ns nt nu bi translated">用<code class="fe me mf mg mh b">swiftlint</code>命令从命令行运行它。</li><li id="6223" class="nm nn it lk b ll nv lo nw lr nx lv ny lz nz md nr ns nt nu bi translated">将其附加到Git中的prehook commit中。</li><li id="496c" class="nm nn it lk b ll nv lo nw lr nx lv ny lz nz md nr ns nt nu bi translated">在Xcode中将它附加为预构建阶段，这样每次构建时它都会运行。</li></ol><p id="81d1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">步骤3可以通过在构建阶段之前在Xcode中添加以下代码片段来实现。</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="1865" class="oe mq it mh b gy of og l oh oi">if which swiftlint &gt;/dev/null; then<br/>  swiftlint<br/>else<br/>  echo "warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint"<br/>fi</span></pre><p id="6975" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们甚至可以在自动更正模式下运行该工具。它可以通过简单地在命令行中调用<code class="fe me mf mg mh b">swiftlint autocorrect</code>(或者在上面的脚本中添加<code class="fe me mf mg mh b">auocorrect</code>标志)来修复一些最简单的情况。在这种情况下，该工具将实际修改您的文件，执行一些规则。</p><p id="ce0a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所有规则都可以通过创建和编辑一个由SwiftLint读取的<code class="fe me mf mg mh b">.swiftlint.yml</code>文件来定制。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="1f90" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">快速格式</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/711c20f321fab2d376f10d4f9dc411ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*AVPY1XyY8YpxFCDP9BdtuQ.png"/></div></figure><p id="19d4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://github.com/nicklockwood/SwiftFormat" rel="noopener ugc nofollow" target="_blank"> SwiftFormat </a>(不是苹果<a class="ae lh" href="https://github.com/apple/swift-format" rel="noopener ugc nofollow" target="_blank">的那个</a>)类似SwiftLint。然而，它的目的不是强制使用一些风格规则，而是格式化代码，这样我们写的所有东西都有正确的缩进，括号在正确的位置打开和关闭，等等。</p><p id="beb2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">和SwiftLint一样，我们可以用<code class="fe me mf mg mh b">brew</code>安装它，也可以作为<code class="fe me mf mg mh b">pod</code>添加到我们的项目中。我们可以像前面的工具一样使用它:</p><ul class=""><li id="5aee" class="nm nn it lk b ll lm lo lp lr no lv np lz nq md ok ns nt nu bi translated">从命令行。</li><li id="1384" class="nm nn it lk b ll nv lo nw lr nx lv ny lz nz md ok ns nt nu bi translated">作为预构建阶段。</li><li id="eaca" class="nm nn it lk b ll nv lo nw lr nx lv ny lz nz md ok ns nt nu bi translated">作为预提交钩子。</li></ul><p id="4c7b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从命令行调用它的语法是</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="5b99" class="oe mq it mh b gy of og l oh oi">swiftformat .</span></pre><p id="3eba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">命令中的<code class="fe me mf mg mh b">.</code>是一条路径。在这个例子中，它将格式化当前路径中所有扩展名为<code class="fe me mf mg mh b">swift</code>的文件。如果我们想在某个特定的路径上运行<code class="fe me mf mg mh b">swiftformat</code>，可以指定文件路径或子文件夹。</p><p id="2c89" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意</strong> : SwiftFormat会原地改变你的文件。如果你不想改变原始文件，但你想创建第二个文件，你可以使用<code class="fe me mf mg mh b">--output</code>标志。</p><p id="61a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您想使用SwiftFormat作为预构建步骤，要在Xcode中复制和粘贴的代码片段如下:</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="71aa" class="oe mq it mh b gy of og l oh oi">if which swiftformat &gt;/dev/null; then<br/>  swiftformat .<br/>else<br/>  echo "warning: SwiftFormat not installed, download from https://github.com/nicklockwood/SwiftFormat"<br/>fi</span></pre><p id="d7c8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所有的规则都可以通过创建和编辑一个由SwiftFormat读取的<code class="fe me mf mg mh b">.swiftformat</code>文件来定制，以了解哪些规则必须被应用。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="c164" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">承诺</h1><p id="2ec9" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">不是一个真正的Swift工具，但对Git非常有帮助，<a class="ae lh" href="https://github.com/conventional-changelog/commitlint" rel="noopener ugc nofollow" target="_blank">commit list</a>对我们的提交执行<a class="ae lh" href="https://gist.github.com/joshbuchea/6f47e86d2510bce28f8e7f42ae84c716" rel="noopener ugc nofollow" target="_blank">语义提交</a>指导方针。</p><p id="5e3b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当遵循语义提交时，我们的提交消息必须遵循一些特定的规则:</p><ul class=""><li id="1ad1" class="nm nn it lk b ll lm lo lp lr no lv np lz nq md ok ns nt nu bi translated">第一部分必须是提交类型。它可能是一个新特性(使用<code class="fe me mf mg mh b">feat</code>)、一个<code class="fe me mf mg mh b">fix</code>，或者与某个配置相关(使用<code class="fe me mf mg mh b">chore</code>)。这只是几个例子，但是您可以按照您的标准对其进行配置。</li><li id="f826" class="nm nn it lk b ll nv lo nw lr nx lv ny lz nz md ok ns nt nu bi translated">然后可以在<code class="fe me mf mg mh b">()</code>之间指定一个<code class="fe me mf mg mh b">scope</code>。范围是与类型相关的任务的子类。在<a class="ae lh" href="http://bendingspoons.com" rel="noopener ugc nofollow" target="_blank">弯曲勺子</a>中，我们不怎么使用瞄准镜，但是也许你可以在你的组织中找到它们的用处。</li><li id="70f5" class="nm nn it lk b ll nv lo nw lr nx lv ny lz nz md ok ns nt nu bi translated">然后，我们有一个冒号<code class="fe me mf mg mh b">:</code></li><li id="3e78" class="nm nn it lk b ll nv lo nw lr nx lv ny lz nz md ok ns nt nu bi translated">最后，提交消息</li><li id="23b0" class="nm nn it lk b ll nv lo nw lr nx lv ny lz nz md ok ns nt nu bi translated">提交消息不能以句点结尾</li></ul><p id="8b1d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">语义提交为什么有用？因为它开启了一些有用的自动化和更好的工作流程:</p><ol class=""><li id="6028" class="nm nn it lk b ll lm lo lp lr no lv np lz nq md nr ns nt nu bi translated">它让工程师做组织良好的提交。例如，不可能将一个<code class="fe me mf mg mh b">fix</code>提交与一个<code class="fe me mf mg mh b">refactor</code>提交混合在一起。</li><li id="5def" class="nm nn it lk b ll nv lo nw lr nx lv ny lz nz md nr ns nt nu bi translated">这使得恢复中断的提交变得很容易。例如，我们可以恢复一个错误的修复，确保不删除与修复一起提交的重要特性。</li><li id="b66e" class="nm nn it lk b ll nv lo nw lr nx lv ny lz nz md nr ns nt nu bi translated">它让我们自动创建一个变更日志。</li><li id="43a3" class="nm nn it lk b ll nv lo nw lr nx lv ny lz nz md nr ns nt nu bi translated">它让我们自动处理<a class="ae lh" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本</a>。例如，如果我们要发布一个新版本的软件，其中所有的提交都是修复的，它可以作为一个<code class="fe me mf mg mh b">patch</code>发布。</li></ol><p id="8df5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:</strong>使用语义版本化，一个新的软件版本至少由格式为<code class="fe me mf mg mh b">x.y.z</code>的三个数字来标识。第一个数字代表版本的<code class="fe me mf mg mh b">major</code>部分；<code class="fe me mf mg mh b">y</code>代表<code class="fe me mf mg mh b">minor</code>，最后，<code class="fe me mf mg mh b">z</code>代表<code class="fe me mf mg mh b">patch</code>。版本的种类取决于代码相对于先前版本的变化。<br/>如果API发生了突破性的变化，那么它一定是一个<code class="fe me mf mg mh b">major</code>。<br/>如果在不破坏公共接口的情况下增加了新功能，应该是一个<code class="fe me mf mg mh b">minor</code>。<br/>不然应该是个<code class="fe me mf mg mh b">pathc</code>。</p><p id="d011" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要安装CommitLint，我们可以在shell中键入以下命令。</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="a13a" class="oe mq it mh b gy of og l oh oi">npm install --save-dev @commitlint/{config-conventional,cli}<br/>echo "module.exports = {extends: ['@commitlint/config-conventional']}" &gt; commitlint.config.js</span></pre><p id="18ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么，使用它的最好方法是在预提交钩子中。要安装它，我们可以运行以下命令。</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="f394" class="oe mq it mh b gy of og l oh oi"># Install Husky v5<br/>npm install husky --save-dev<br/># Active hooks<br/>npx husky install<br/># Add hook<br/>npx husky add .husky/commit-msg "npx --no-install commitlint --edit $1"</span></pre><p id="92ba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有了这个配置，每当我们试图向Git提交一些东西时，prehook就会运行并确保消息符合语义提交准则。</p><p id="a258" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有几种方法可以配置CommitLint的规则。例如，我们可以修改一个<code class="fe me mf mg mh b">.commitlintrc.yml</code>或一个<code class="fe me mf mg mh b">.commitlintrc.json</code>文件。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="4038" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">资源</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/4bcb6925c09037cb2f3e2743faa71673.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/1*uq1takiVFI7s6eDI0p9OTw.png"/></div></figure><p id="5daa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在每个开发人员的生活中，至少会发生一次我们不得不编写大量重复代码的情况。在Swift中，几年前尤其如此，当时这种语言还不能为<code class="fe me mf mg mh b">Codable</code>合成实现。</p><p id="d4b3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，我们可以利用资源。这是一个让我们定义一些<code class="fe me mf mg mh b">stencil</code>文件的工具，这些文件可以用作模板来自动生成一些代码。</p><p id="5d74" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">像前面的工具一样，安装Sourcery有不同的方法。</p><ol class=""><li id="f7cd" class="nm nn it lk b ll lm lo lp lr no lv np lz nq md nr ns nt nu bi translated">我们可以把它安装成一个吊舱。</li><li id="7bdd" class="nm nn it lk b ll nv lo nw lr nx lv ny lz nz md nr ns nt nu bi translated">我们可以从<code class="fe me mf mg mh b">brew</code>开始安装</li></ol><p id="e2f5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它的用法比以前的工具稍微高级一点。我强烈建议花些时间阅读自述文件中<a class="ae lh" href="https://github.com/krzysztofzablocki/Sourcery#how-to-get-started" rel="noopener ugc nofollow" target="_blank">如何开始</a>部分的教程和文章。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="2526" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">巴尔蒂克洛赫</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/02730cfd41e4a10d2d385bfeb897cd6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gJX3uSUQKHmsaEkvv7c7-g.png"/></div></div></figure><p id="a80e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当处理本地化时，我们必须在项目的特定路径中创建一个名为<code class="fe me mf mg mh b">InfoPlist.strings</code>的文件。它的父文件夹定义了这些字符串的语言。</p><p id="0ae6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，<code class="fe me mf mg mh b">path/to/Localization/en.lproj/InfoPlist.strings</code>包含英语的成对<code class="fe me mf mg mh b">&lt;key&gt;=&lt;translation&gt;;</code>字符串。<code class="fe me mf mg mh b">path/to/Localization/it.lproj/InfoPlist.strings</code>包含相同的配对，相同的键，但有意大利语翻译。</p><p id="95d1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">魔术是由苹果提供的<code class="fe me mf mg mh b">NSLocalizedString</code> API、<a class="ae lh" href="https://developer.apple.com/documentation/foundation/nslocalizedstring" rel="noopener ugc nofollow" target="_blank">实现的。这个API要求我们传递一个<code class="fe me mf mg mh b">key</code>作为参数。在运行时，操作系统将这些调用替换为与键相对应的值，这些值是用正确的语言从文件中选取的。语言取决于设备设置。</a></p><p id="43bc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您曾经使用过，您可能会遵循以下流程:</p><ol class=""><li id="4a4a" class="nm nn it lk b ll lm lo lp lr no lv np lz nq md nr ns nt nu bi translated">在需要的地方使用<code class="fe me mf mg mh b">NSLocalizedString</code>，添加一个键。</li><li id="441d" class="nm nn it lk b ll nv lo nw lr nx lv ny lz nz md nr ns nt nu bi translated">打开所有的<code class="fe me mf mg mh b">InfoPlist.string</code>并添加带有翻译的密钥</li><li id="a5a8" class="nm nn it lk b ll nv lo nw lr nx lv ny lz nz md nr ns nt nu bi translated">回到Swift文件，继续编码。</li></ol><p id="8d7b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，很难记住我们是否已经创建了<code class="fe me mf mg mh b">"Ok"</code>键，或者<code class="fe me mf mg mh b">purchase_button</code>是否应该根据使用它的屏幕有不同的副本。</p><p id="3a25" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">BartyCrouch前来救援。它稍微改变了流动:</p><ol class=""><li id="c54f" class="nm nn it lk b ll lm lo lp lr no lv np lz nq md nr ns nt nu bi translated">我们在<code class="fe me mf mg mh b">InfoPlist.string</code>文件中定义我们的<code class="fe me mf mg mh b">&lt;key&gt;=&lt;translation&gt;;</code>字符串。</li><li id="335d" class="nm nn it lk b ll nv lo nw lr nx lv ny lz nz md nr ns nt nu bi translated">我们运行<code class="fe me mf mg mh b">bartycrouch transform</code>来创建强类型属性和我们可以用来代替键的函数。</li><li id="01c7" class="nm nn it lk b ll nv lo nw lr nx lv ny lz nz md nr ns nt nu bi translated">在我们的代码中，我们使用<code class="fe me mf mg mh b">L10n</code>名称空间来访问所有生成的字符串。</li></ol><p id="16f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的代码可以像这样传递…</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="64f9" class="oe mq it mh b gy of og l oh oi">self.title = NSLocalizedString("onboarding.first-page.header-title", comment: "")</span></pre><p id="89dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">…变成这样:</p><pre class="ks kt ku kv gt oa mh ob oc aw od bi"><span id="8e34" class="oe mq it mh b gy of og l oh oi">self.title = L10n.Onboarding.FirstPage.headerTitle</span></pre><p id="01cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不仅打字更短，而且我们可以利用Xcode的自动完成功能，并且我们不能输入错误。</p><p id="5aad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">BartyCrouch可以安装<code class="fe me mf mg mh b">brew</code>。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="c296" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">SwiftGen</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/7b0c6876a0b8b4c35add10b1e5e54bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*aoE5XZlQHs3ilIAvUr57mA.png"/></div></figure><p id="d433" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与BartyCrouch类似，<a class="ae lh" href="https://github.com/SwiftGen/SwiftGen" rel="noopener ugc nofollow" target="_blank"> SwiftGen </a>适用于图像和其他资源。它甚至还适用于本地化字符串，这意味着如果您使用该工具，您可以避免使用BartyCrouch(不过，请记住，BartyCrouch还有其他功能。因此，请花些时间分析这两种工具，并选择最适合您的工具。)</p><p id="d535" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该工具的思想与BartyCrouch的类似:避免输入错误，利用我们最喜欢的语言的强类型特性。有多少次我们因为图片的名字没有大写而打错了<code class="fe me mf mg mh b">UIImage(named: "AppIcon")</code>？</p><p id="7c46" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用SwiftGen，我们可以在代码中自动生成一些扩展。然后，我们可以通过键入<code class="fe me mf mg mh b">Asset.icons.appIcon.image</code>来访问<code class="fe me mf mg mh b">appIcon</code>，并忘记实际的文件名。此外，Xcode建议如何拼写路径的所有部分！</p><p id="7236" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">SwiftGen可作为<code class="fe me mf mg mh b">pod</code>或通过<code class="fe me mf mg mh b">brew</code>安装。像许多其他工具一样，我们需要在代码中使用它之前运行它。要运行它，只需在终端中键入<code class="fe me mf mg mh b">swiftgen</code>。我们甚至可以将其添加为预构建步骤，以确保在构建项目之前所有的资源和变量都可用。</p><p id="6336" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">SwiftGen在许多不同的元素上工作。它与<code class="fe me mf mg mh b">assets</code>、<code class="fe me mf mg mh b">colors</code>、<code class="fe me mf mg mh b">fonts</code>、<code class="fe me mf mg mh b">strings</code>、<code class="fe me mf mg mh b">plist</code>以及许多其他东西一起工作。查看它的<a class="ae lh" href="https://github.com/SwiftGen/SwiftGen#asset-catalog" rel="noopener ugc nofollow" target="_blank">自述文件</a>以获得更详细的描述。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="458e" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">图伊斯特</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/b250c96ee1a352a9d609fe48ed8ff6b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xA48ofqxmePHOadihLIXcg.gif"/></div></div></figure><p id="20f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你看过我之前的<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/stop-committing-the-xcodeproj-fa83527ba156?source=your_stories_page-------------------------------------"/><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/customize-your-xcodeproject-with-tuist-6fc41fb59262?source=your_stories_page-------------------------------------">文章</a>，你就已经知道<a class="ae lh" href="https://tuist.io/" rel="noopener ugc nofollow" target="_blank">推手</a>是什么了。它有助于从Swift文件定义开始创建Xcode项目和工作空间。</p><p id="0733" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，它的作用远不止于此。它包含了<code class="fe me mf mg mh b">SwiftGen</code>，所以它自动生成上述工具处理的所有<a class="ae lh" href="https://tuist.io/docs/usage/resources/" rel="noopener ugc nofollow" target="_blank">资源</a>。另外，它概括了对包的访问，因此我们可以向子目标添加资源并轻松访问它们。</p><p id="8b77" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您甚至可以使用Tuist来配置我们上面描述的所有工具，通过使用<code class="fe me mf mg mh b">pre</code>和<code class="fe me mf mg mh b">post</code> <a class="ae lh" href="https://tuist.io/docs/usage/project-description/#target-action" rel="noopener ugc nofollow" target="_blank">目标动作</a>来配置模式，作为预构建步骤。</p><p id="8a82" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它是将所有东西粘合在一起并在您的团队中实施所有这些最佳实践的非常好的候选。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="848d" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">结论</h1><p id="b0fc" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">在今天的文章中，我们简要探讨了几个工具，它们可以帮助每个Swift团队在使用本地化字符串和资源时实施良好的代码格式并避免输入错误。</p><p id="8061" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们甚至探索了如何安装它们，以便它们可以自动运行，你可以忘记它们。</p><p id="4591" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意，我们只是触及了所有这些工具的皮毛:它们比我在本文中试图总结的要多得多，所以如果您打算使用其中的任何一个，请花时间阅读它们的文档。</p></div></div>    
</body>
</html>