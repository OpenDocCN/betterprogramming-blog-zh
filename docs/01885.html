<html>
<head>
<title>Cropping iOS Maps With PencilKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PencilKit裁剪iOS地图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cropping-ios-maps-with-pencilkit-da7f7dd7ec52?source=collection_archive---------7-----------------------#2019-10-20">https://betterprogramming.pub/cropping-ios-maps-with-pencilkit-da7f7dd7ec52?source=collection_archive---------7-----------------------#2019-10-20</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="786f" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">铅笔工具包和地图工具包出去约会</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/39f03daff11b0cabde69e1e39c4f4afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RsPIcnCmPh2Ex4229kLO4Q.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片由<a class="ae kz" href="https://pixabay.com/users/mohamed_hassan-5229782/" rel="noopener ugc nofollow" target="_blank">穆罕默德·哈桑</a>在<a class="ae kz" href="https://pixabay.com" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>拍摄</p></figure><p id="aff6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://developer.apple.com/documentation/pencilkit" rel="noopener ugc nofollow" target="_blank"> PencilKit </a>亮相WWDC 2019，最终与iOS 13一同发布。在前一篇<a class="ae kz" href="https://medium.com/better-programming/an-introduction-to-pencilkit-in-ios-4d40aa62ba5b" rel="noopener">文章</a>中已经介绍了它的基础知识，现在是时候在地图上实现和使用铅笔了。</p><p id="24b1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看看当PencilKit邀请MapKit约会时会发生什么！</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="f399" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">介绍</h1><h2 id="28c6" class="mv me iu bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated">目标</h2><ul class=""><li id="a8a9" class="nh ni iu lc b ld nj lg nk lj nl ln nm lr nn lv no np nq nr bi translated">使用PencilKit在地图上绘图；</li><li id="e09e" class="nh ni iu lc b ld ns lg nt lj nu ln nv lr nw lv no np nq nr bi translated">在动作表中显示来自绘图区域的封闭地图图像；</li><li id="ee44" class="nh ni iu lc b ld ns lg nt lj nu ln nv lr nw lv no np nq nr bi translated">将图像保存在照片库中。</li></ul><h2 id="1210" class="mv me iu bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated">快速回顾</h2><p id="4333" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nx ll lm ln ny lp lq lr nz lt lu lv in bi translated">MapKit框架用于在视图和窗口中嵌入地图。我们可以用MapKit框架做很多事情，比如添加注释和折线，标记目的地和兴趣点等。</p><p id="472e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe oa ob oc od b">MKMapView</code>用于在我们的应用程序中显示和嵌入地图。</p><p id="f3c9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">PencilKit是城里的新框架。随着iOS 13推出，它允许我们在应用程序中创建自己的涂鸦和面条。</p><p id="4296" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe oa ob oc od b">PKCanvasView</code>班级是我们的绘画竞技场。</p><h2 id="58ae" class="mv me iu bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated">最后结果</h2><p id="8910" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nx ll lm ln ny lp lq lr nz lt lu lv in bi translated">到本文结束时，我们将实现以下目标:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oe"><img src="../Images/1ae8563df57aed47f791c9978e5ca8e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/0*58ZvHXZ0_KU466Vn.gif"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">来自iOS模拟器的屏幕截图</p></figure><p id="9774" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">是时候深入研究实现了！</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="861d" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">铅笔下的地图</h1><p id="bb08" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nx ll lm ln ny lp lq lr nz lt lu lv in bi translated">首先在Xcode中启动一个新的单视图应用程序。</p><p id="3eb0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的第一步将是把我们的<code class="fe oa ob oc od b">MKMapView</code>放在<code class="fe oa ob oc od b">PKCanvasView</code>下面，这样我们就可以越过它了！</p><h2 id="505e" class="mv me iu bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated">设置MKMapView</h2><p id="0e3a" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nx ll lm ln ny lp lq lr nz lt lu lv in bi translated">很简单！你只需要在你的视图控制器中添加<code class="fe oa ob oc od b">import MapKit</code>和<code class="fe oa ob oc od b">MKMapView</code>。下面的代码不用故事板就能做到。</p><pre class="kk kl km kn gu of od og oh aw oi bi"><span id="ef79" class="mv me iu od b gz oj ok l ol om">var mapView = MKMapView(frame: CGRect(x: 0, y: 60, width: view.frame.size.width, height: view.frame.size.height - 60)) self.view.addSubview(mapView)</span></pre><h2 id="9364" class="mv me iu bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated">设置PKCanvasView</h2><pre class="kk kl km kn gu of od og oh aw oi bi"><span id="ba84" class="mv me iu od b gz oj ok l ol om">let canvasView = PKCanvasView(frame: .zero)<br/>canvasView.translatesAutoresizingMaskIntoConstraints = false<br/>canvasView.isOpaque = false<br/>view.addSubview(canvasView)<br/>        <br/>canvasView.backgroundColor = .clear<br/>        <br/>NSLayoutConstraint.activate([<br/>canvasView.topAnchor.constraint(equalTo: self.view.safeAreaLayoutGuide.topAnchor, constant: 40),<br/>canvasView.bottomAnchor.constraint(equalTo: view.bottomAnchor),<br/>canvasView.leadingAnchor.constraint(equalTo: view.leadingAnchor),<br/>canvasView.trailingAnchor.constraint(equalTo: view.trailingAnchor),<br/>])</span></pre><p id="74b7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将画布的背景颜色设置为透明，这样它下面的地图就可见了。</p><h2 id="6aff" class="mv me iu bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated">设置PKToolPicker</h2><p id="ffa8" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nx ll lm ln ny lp lq lr nz lt lu lv in bi translated">以下代码为您添加了PencilKit ToolPicker。</p><pre class="kk kl km kn gu of od og oh aw oi bi"><span id="bb58" class="mv me iu od b gz oj ok l ol om">override func viewDidAppear(_ animated: Bool) {<br/>        super.viewDidAppear(animated)</span><span id="f22f" class="mv me iu od b gz on ok l ol om">guard let window = view.window,<br/>let toolPicker = PKToolPicker.shared(for: window) else { return }</span><span id="0423" class="mv me iu od b gz on ok l ol om">toolPicker.setVisible(true, forFirstResponder: canvasView)<br/>        toolPicker.addObserver(canvasView)<br/>        canvasView.becomeFirstResponder()<br/>}</span></pre><p id="2daa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当地图在画布下面时拖动它并不是一个复杂的场景。我们所需要做的就是允许从CanvasView到下面的视图传递接触。</p><p id="4df0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，我们将保留一个切换按钮，允许交替拖动和绘图。在第一种情况下，我们传递来自CanvasView的触摸，而在第二种情况下，我们不传递！</p><p id="6a38" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们在下面的扩展中覆盖了出现在<code class="fe oa ob oc od b">PKCanvasView</code>类中的point函数:</p><pre class="kk kl km kn gu of od og oh aw oi bi"><span id="bc3e" class="mv me iu od b gz oj ok l ol om">extension PKCanvasView{<br/>    override open func point(inside point: CGPoint, with event: UIEvent?) -&gt; Bool {<br/>        return DragOrDraw.disableDrawing<br/>    }<br/>}</span><span id="b47b" class="mv me iu od b gz on ok l ol om">class DragOrDraw{<br/>    static var disableDrawing = true<br/>}</span></pre><p id="d5e7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe oa ob oc od b">disableDrawing</code>是一个布尔标志，可以从<code class="fe oa ob oc od b">NavigationBar</code>切换地图拖动和铅笔绘图，因为两者不能同时共存。</p><h2 id="3a13" class="mv me iu bd mf mw mx dn mj my mz dp mn lj na nb mp ln nc nd mr lr ne nf mt ng bi translated">设置导航栏</h2><pre class="kk kl km kn gu of od og oh aw oi bi"><span id="9173" class="mv me iu od b gz oj ok l ol om">var toggleDrawItem : UIBarButtonItem!<br/>    <br/>var disableDraw : Bool = false<br/>    <br/>func setNavigationBar() {</span><span id="eab5" class="mv me iu od b gz on ok l ol om">let previewItem = UIBarButtonItem(title: "Preview", style: .done, target: self, action: #selector(preview))<br/>        <br/>let clearItem = UIBarButtonItem(title: "Clear", style: .plain, target: self, action: #selector(clear))</span><span id="c6e7" class="mv me iu od b gz on ok l ol om">toggleDrawItem = UIBarButtonItem(title: "Drag", style: .plain, target: self, action: #selector(dragDrawToggler))</span><span id="d34a" class="mv me iu od b gz on ok l ol om">let navigationItem = UINavigationItem(title: "")<br/>navigationItem.rightBarButtonItems = [clearItem,previewItem]<br/>navigationItem.leftBarButtonItem = toggleDrawItem<br/>navigationBar = UINavigationBar(frame: .zero)<br/>navigationBar?.isTranslucent = false<br/>        <br/>navigationBar!.setItems([navigationItem], animated: false)</span><span id="ffbe" class="mv me iu od b gz on ok l ol om">navigationBar!.translatesAutoresizingMaskIntoConstraints = false<br/>view.addSubview(navigationBar!)</span><span id="131e" class="mv me iu od b gz on ok l ol om">navigationBar!.backgroundColor = .clear</span><span id="eec6" class="mv me iu od b gz on ok l ol om">NSLayoutConstraint.activate([<br/>navigationBar!.topAnchor.constraint(equalTo: self.view.safeAreaLayoutGuide.topAnchor),<br/>navigationBar!.heightAnchor.constraint(equalToConstant: 60),<br/>navigationBar!.leadingAnchor.constraint(equalTo: view.leadingAnchor),<br/>navigationBar!.trailingAnchor.constraint(equalTo: view.trailingAnchor),<br/>])</span><span id="3aad" class="mv me iu od b gz on ok l ol om">}</span></pre><p id="ba29" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">既然UI组件已经部分化了，现在是将PencilKit绘图转换为地图图像的时候了。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="e548" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">将PencilKit绘图转换为地图图像</h1><p id="c244" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nx ll lm ln ny lp lq lr nz lt lu lv in bi translated">为了从绘制的区域获取地图图像，我们需要获取绘图的边界，并裁剪包含在该矩形中的MapView:</p><pre class="kk kl km kn gu of od og oh aw oi bi"><span id="fda0" class="mv me iu od b gz oj ok l ol om"><a class="ae kz" href="http://twitter.com/objc" rel="noopener ugc nofollow" target="_blank">@objc</a> func preview() {<br/>        let bounds = canvasView.drawing.bounds<br/>        if let image = clippedImageForRect(clipRect: bounds, inView: mapView!){<br/>            showPreviewImage(image: image)<br/>        }<br/>    }</span></pre><p id="fb5e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是函数<code class="fe oa ob oc od b">clipImageForRect</code>的实现，我们将传递PencilKit边界和Map实例:</p><pre class="kk kl km kn gu of od og oh aw oi bi"><span id="cd18" class="mv me iu od b gz oj ok l ol om">func clippedImageForRect(clipRect: CGRect, inView view: UIView) -&gt; UIImage? {<br/>        UIGraphicsBeginImageContextWithOptions(clipRect.size, true, UIScreen.main.scale)<br/>        if let ctx = UIGraphicsGetCurrentContext(){<br/>            ctx.translateBy(x: -clipRect.origin.x, y: -clipRect.origin.y);<br/>            view.layer.render(in: ctx)<br/>            let img = UIGraphicsGetImageFromCurrentImageContext()<br/>            UIGraphicsEndImageContext()<br/>            return img<br/>        }</span><span id="9515" class="mv me iu od b gz on ok l ol om">        return nil<br/>}</span></pre><p id="4d3f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们有了图像，我们可以在一个<code class="fe oa ob oc od b">UIAlertController</code>中显示它，并选择将其添加到照片库中:</p><pre class="kk kl km kn gu of od og oh aw oi bi"><span id="e727" class="mv me iu od b gz oj ok l ol om">func showPreviewImage(image: UIImage)<br/>    {<br/>        let alert = UIAlertController(title: "Preview", message: "", preferredStyle: .actionSheet)<br/>        alert.addPreviewImage(image: image)</span><span id="a474" class="mv me iu od b gz on ok l ol om">alert.addAction(UIAlertAction(title: "Add To Photos", style: .default){<br/>            action in<br/>            UIImageWriteToSavedPhotosAlbum(image, self, nil, nil)<br/>        })<br/>        alert.addAction(UIAlertAction(title: "Cancel", style: .destructive, handler: nil))<br/>        <br/>        present(alert,<br/>                    animated: true,<br/>                    completion: nil)<br/>    }</span></pre><p id="bc9a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意:不要忘记在<code class="fe oa ob oc od b">info.plist</code>中设置照片库的隐私使用权限。</p><p id="366c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于iPadOS，您需要使用<code class="fe oa ob oc od b">popoverPresentationController</code>来显示动作表，如下面的代码片段所示。</p><pre class="kk kl km kn gu of od og oh aw oi bi"><span id="8cce" class="mv me iu od b gz oj ok l ol om">if let popoverPresentationController = actionSheet.popoverPresentationController {</span><span id="ce4e" class="mv me iu od b gz on ok l ol om">popoverPresentationController.sourceView = self.view</span><span id="50f5" class="mv me iu od b gz on ok l ol om">popoverPresentationController.sourceRect = CGRect(x: self.view.bounds.midX, y: self.view.bounds.midY, width: 0, height: 0)</span><span id="9839" class="mv me iu od b gz on ok l ol om">popoverPresentationController.permittedArrowDirections = []</span><span id="722e" class="mv me iu od b gz on ok l ol om">}</span></pre><p id="b386" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe oa ob oc od b">addPreviewImage</code>是我们通过使用另一个ViewController在Alert控制器的内容视图中嵌入图像的地方。</p><pre class="kk kl km kn gu of od og oh aw oi bi"><span id="6762" class="mv me iu od b gz oj ok l ol om">extension UIAlertController {<br/>    func addPreviewImage(image: UIImage) {<br/>        let vc = PreviewVC(image: image)<br/>        setValue(vc, forKey: "contentViewController")<br/>    }<br/>}</span></pre><p id="52ba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe oa ob oc od b">PreviewVC</code>的代码可以在下一节获得完整的源代码。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="db5d" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="d7b6" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nx ll lm ln ny lp lq lr nz lt lu lv in bi translated">我们用地图工具包和铅笔工具包的约会到此结束。当您需要与他人共享地图的一部分而不需要截图时，上面的示例非常方便。源代码可以在<a class="ae kz" href="https://github.com/anupamchugh/iowncode/tree/master/iOSMapAndPencilKit" rel="noopener ugc nofollow" target="_blank">这个Github库</a>中找到。</p><p id="814a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是这篇文章的总结。如果你喜欢它，这里有另一篇你可能喜欢的文章:</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu oo"><a href="https://medium.com/better-programming/pencilkit-meets-core-ml-aefe3cde6a96" rel="noopener follow" target="_blank"><div class="op ab fp"><div class="oq ab or cl cj os"><h2 class="bd iv gz z fq ot fs ft ou fv fx it bi translated">PencilKit遇上Core ML</h2><div class="ov l"><h3 class="bd b gz z fq ot fs ft ou fv fx dk translated">从图形中识别数字</h3></div><div class="ow l"><p class="bd b dl z fq ot fs ft ou fv fx dk translated">medium.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc kt oo"/></div></div></a></div></div></div>    
</body>
</html>