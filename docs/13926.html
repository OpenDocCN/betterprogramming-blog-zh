<html>
<head>
<title>What I Didn’t Say at React Alicante About Microfrontends</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于微前端，我在React Alicante上没有说的是</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-i-didnt-say-at-react-alicante-about-micro-frontends-623bd5d332f5?source=collection_archive---------0-----------------------#2022-10-15">https://betterprogramming.pub/what-i-didnt-say-at-react-alicante-about-micro-frontends-623bd5d332f5?source=collection_archive---------0-----------------------#2022-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f732" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对我所知道的关于Prisma的一切的深入探究</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3d5437f4c076dab0ce9abfd54413f2dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OFQLdAKRP6q5SOOB"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">React Alicante的作者图像</p></figure><p id="3247" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">大多数人认识我是因为我组织了<a class="ae lr" href="http://cityjsconf.org" rel="noopener ugc nofollow" target="_blank"> CityJS会议</a>或者是因为我是一名开发者或者是伦敦城市大学的讲师。一段时间以来，我一直对Prisma和它能为前端开发人员提供的东西充满热情。</p><p id="0774" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我从一些伟大的人那里听说过很多关于微前端的事情，比如Luca Mezzalira、Alex Lobera、Ruben Casas以及其他许多人。(<a class="ae lr" href="https://www.youtube.com/channel/UCSL9UjbOlc2BZ4lBg3EYrfA" rel="noopener ugc nofollow" target="_blank">一些很棒的视频在CityJS Youtube频道</a>)</p><p id="fd2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在去年夏天的假期和会议间隙，我一直在读卢卡的书《构建微前端》，在网上做了很多研究，并与我认识的从事这方面工作的人交谈。</p><p id="fbac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很长一段时间以来，我一直认为前端和后端之间的这种分离并没有真正发挥作用。微前端试图做的是减少团队之间的依赖。依赖关系可以存在于不同的部分和级别。我在演示中提到的例子是关于web部件或组件，如果您采用水平拆分，它们存在于同一页面上；如果您采用垂直拆分解决方案，它们存在于不同的路径上。</p><p id="b4b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">仍然有很多依赖，比如前端和后端之间的依赖，以及我们如何使用数据。我讨厌每次我不得不建立一个项目，并要求一个API，需要很多时间来建立。如果我们作为前端开发人员获得了这些工具，我们应该使用它们并成为全栈开发人员。</p><p id="a331" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">GraphQL、Prisma ORM或pure NodeJS等工具可以帮助我们做到这一点。问题是这些技术是否能在服务器上工作，以及我们是否需要一个也能运行服务器端功能的框架。</p><p id="722f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了模块联合SSR，我可以通过一些小技巧来实现。</p><p id="61ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我将在下面列出一些细节:</p><h1 id="81e2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Prisma客户端</h1><p id="1d82" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我在演讲中使用了Prisma，因为我相信它非常容易使用，并为前端开发人员提供了后端可以做的一切。</p><p id="6947" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要获得Prisma，只需要使用<code class="fe mp mq mr ms b">npm i prisma</code>安装Prisma即可。</p><p id="84be" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦你这样做了，你可以在你的本地环境中初始化Prisma，然后通过运行<code class="fe mp mq mr ms b">npx prisma init</code>来完成。</p><p id="be3d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将创建一个带有Prisma模式文件的Prisma文件夹。这是一个漂亮的文件。一旦你定义了数据库结构，Prisma可以为你做所有的事情。它将根据您的指示创建数据库、关系、键和所有其他后端服务。</p><p id="5501" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我的<a class="ae lr" href="https://lnug.org/talks/how-to-develop-an-emergency-website-using-prisma2-orm-nodejs-nextjs-and-deploy-it-in-heroku-and-zeit-uyAtKbDuyR0" rel="noopener ugc nofollow" target="_blank">演讲</a>中，我没有过多谈论Prisma可以做的过滤和CRUD功能。大约两年前，当我发现Prisma的新版本(版本2)时，我就这样做了。这里可以看这个<a class="ae lr" href="https://lnug.org/talks/how-to-develop-an-emergency-website-using-prisma2-orm-nodejs-nextjs-and-deploy-it-in-heroku-and-zeit-uyAtKbDuyR0" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="73d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦创建了模式，就可以运行<code class="fe mp mq mr ms b">npx prisma generate</code>。这将生成Prisma客户端。您可以在Prisma模式中指定创建客户端的位置。我认为这有助于开发人员使用mono-repos。我不得不使用它，因为我想在演示中实现它。我将在关于模块联合的下一节中解释原因。</p><h1 id="130a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">模块联盟</h1><p id="1f5b" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">对我来说，模块联合感觉就像把一个组件从一个应用程序传送到另一个应用程序。</p><p id="1fa1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我需要非常感谢Zach Jackson，因为他花了很多时间解释所有的核心概念，以及webpack如何以及为什么仍然是最强大的捆绑器。</p><p id="d4fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我在演示中使用的解决方案是利用NextJS。在每个项目中，都有一个nextjs配置文件。</p><p id="8349" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本例中的nextJS配置定义了运行在不同端口上的三个微前端。例如，这个公开了来自<code class="fe mp mq mr ms b">itemcatalogue</code>的一个组件和另一个名为<code class="fe mp mq mr ms b">exposedTitle.js</code>的组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7f88" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我选择在指定的文件夹中输出生成的客户机，因为我需要对容器做同样的事情。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="04d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mp mq mr ms b">ItemCatalogue</code>组件从我们在前面文件的模式中定义的文件夹中导入生成的Prisma客户端。<code class="fe mp mq mr ms b">getStaticProps</code>可以运行运行Prisma客户机的服务器端代码，并从数据库中检索商店。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e578" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在home应用程序，也就是容器应用程序，我们可以导入暴露的<code class="fe mp mq mr ms b">itemcatalogue</code>组件和<code class="fe mp mq mr ms b">getStaticProps</code>方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b747" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，有一个问题是Prisma客户机是在实际的微前端上生成的，而不是在容器上。因此，要做到这一点，我们需要在容器应用程序中生成客户端(在本例中，是家庭容器应用程序)。</p><p id="4048" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关于模块联合很酷的一点是，如果你想为所有的mfe共享一个Prisma客户端，那么你需要做的是在配置文件中启用共享属性。在这种情况下，我们将react作为一个库共享，它可以作为一个单体运行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3c1a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们这样做，我们就有了一个Prisma客户机和一个跨所有mfe共享的模式。</p><p id="ffd7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此解决方案的回购如下:</p><div class="mv mw gp gr mx my"><a href="https://github.com/arismarko/react-alicante-mfe" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd ir gy z fp nd fr fs ne fu fw ip bi translated">GitHub—aris Marko/React-Alicante-mfe:React Alicante演示</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">Next.js中的模块联合依赖于@module-federation/nextjs-ssr，除非您可以访问它，否则它不会工作…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">github.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm kp my"/></div></div></a></div><h1 id="306e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">莱恩斯</h1><p id="98be" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我尝试的第一个解决方案是LeanJS。它比模块联合更容易，因为设置更容易，但是它只运行基于客户端的微前端。这是一个很棒的框架，你可以把它转换成微前端。你也可以从一个整体开始，用一个标志，以后你可以转换成微前端。</p><p id="1e55" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更多信息:<a class="ae lr" href="https://leanjs.com/getting-started" rel="noopener ugc nofollow" target="_blank">https://leanjs.com/getting-started</a></p><p id="4480" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以我为例的回购是这样的:【https://github.com/arismarko/reactalicante T2】</p><p id="05a0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">点击此处观看完整演讲:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn mu l"/></div></figure></div></div>    
</body>
</html>