<html>
<head>
<title>Building a WebSocket Server in a Microservice Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在微服务架构中构建WebSocket服务器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-websocket-server-in-a-microservice-architecture-50c6c6432e2b?source=collection_archive---------0-----------------------#2022-05-04">https://betterprogramming.pub/building-a-websocket-server-in-a-microservice-architecture-50c6c6432e2b?source=collection_archive---------0-----------------------#2022-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c3cd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在微服务架构中设计用于实时通信的WebSocket服务器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5289a9283353e7df92209e481efa2d7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uOAaWQeYL17fJiNN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">泰勒·维克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="dade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">写这篇文章是为了分享我对使用WebSocket实现前端和后端实时通信的探索。近年来，微服务是许多开发人员采用的架构方法，微服务架构的关键原则之一是“单一责任原则”。</p><p id="b103" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个探索中，我们将研究如何设计和实现一个WebSocket服务器，它负责建立与前端(web应用程序)的WebSocket连接，并充当前端和后端之间实时通信的中间件(或代理)。</p><p id="19a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">注意</em> </strong> <em class="lv">:本文不会详细讨论WebSocket或发布-订阅消息传递模式是如何工作的。</em></p><div class="lw lx gp gr ly lz"><a href="https://github.com/bkjam/websocket-microservice" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">GitHub-bkjam/websocket-微服务:实时web socket微服务探索…</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">github.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn ks lz"/></div></div></a></div><h1 id="7af1" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">我的WebSocket服务器系列</h1><ul class=""><li id="4cd4" class="ng nh it lb b lc ni lf nj li nk lm nl lq nm lu nn no np nq bi translated">01:在微服务架构中构建WebSocket服务器</li><li id="13df" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">02: <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/design-considerations-for-scaling-websocket-server-horizontally-with-a-publish-subscribe-pattern-fe6de9988400">使用发布-订阅模式水平扩展WebSocket服务器的设计考虑</a></li><li id="8839" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">03: <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/implement-a-scalable-websocket-server-with-spring-boot-redis-pub-sub-and-redis-streams-b6b8cc08767f">使用Spring Boot、Redis发布/订阅和Redis流实现可伸缩的WebSocket服务器</a></li><li id="c979" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">04:待定</li></ul><h1 id="9fd0" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated"><strong class="ak">背景语境</strong></h1><p id="245c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在很多情况下，web应用程序(前端)需要客户端(浏览器)和服务器(后端)之间的实时通信。这种用例的一些例子是实时馈送、实时协作编辑、实时数据可视化、实时聊天、通知、事件更新等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/37f006dd7d3264a4610eb0c8757ced62.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*4iU-i2VD6I6ZTxs7HnMoTQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户端(前端)和单个微服务(后端)之间的WebSocket连接示例</p></figure><p id="f39f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设每个用例都有一个微服务；上面的图表将说明如何在客户端(前端)和每个单独的微服务(后端)之间建立WebSocket连接。</p><p id="29f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，这不是一个最优的设计，因为当微服务的数量增加时，将会创建更多的WebSocket连接。因此，让我们看看WebSocket服务器如何帮助解决这个问题。</p><h1 id="60cb" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">WebSocket服务器设计</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/2aa0674fd5c786d927ed15859450cc02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*xYb_K9eI3e92RaeSC_CAkA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">微服务架构中WebSocket服务器的高级示意图</p></figure><p id="3839" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的设计中，WebSocket服务器是唯一与web应用程序(前端)建立WebSocket连接的微服务。对于其他微服务，与web应用程序(前端)进行实时通信有两种主要方式:</p><ol class=""><li id="9c2d" class="ng nh it lb b lc ld lf lg li ob lm oc lq od lu oe no np nq bi translated">单向(后端到前端)<br/>——所有微服务(后端)都可以通过API向WebSocket服务器发送消息，然后消息将通过WebSocket转发给web应用(前端)。</li><li id="4275" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu oe no np nq bi translated">双向(前端和后端之间)<br/>——Web应用(前端)可以通过WebSocket向WebSocket服务器发送消息，然后消息将通过Pub/Sub转发给微服务(后端)。<br/> -微服务(后端)可以通过Pub/Sub向WebSocket服务器发送消息，然后通过WebSocket将消息转发给web应用(前端)。</li></ol><h1 id="d4ce" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">构建WebSocket服务器</h1><p id="adba" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">我们将基于上述设计，使用Spring Boot、Stomp和Redis Pub/Sub构建一个WebSocket服务器。由于我不会深入细节，你可以参考这些由<a class="ae ky" href="https://www.toptal.com/java/stomp-spring-boot-websocket" rel="noopener ugc nofollow" target="_blank">托马兹·dąbrowski</a>和<a class="ae ky" href="https://www.baeldung.com/websockets-spring" rel="noopener ugc nofollow" target="_blank">Baeldung.com</a>撰写的精彩文章，了解更多关于使用Spring Boot实现WebSocket的信息。</p><h2 id="17a0" class="of mp it bd mq og oh dn mu oi oj dp my li ok ol na lm om on nc lq oo op ne oq bi translated"><strong class="ak">步骤1:初始化Spring Boot项目</strong></h2><p id="1d84" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">前往https://start.spring.io/<a class="ae ky" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank">并初始化一个Spring Boot项目。至少，您将需要Spring Web、Redis和Websocket依赖项。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/fa1bacf76b18fbb4881984002fbbeefd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oFJ2B3obR74httOnxBH6Aw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Spring Boot项目的例子</p></figure><h2 id="8bde" class="of mp it bd mq og oh dn mu oi oj dp my li ok ol na lm om on nc lq oo op ne oq bi translated"><strong class="ak">步骤2: </strong>配置WebSocket和STOMP消息传递</h2><p id="7650" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">创建一个配置文件<code class="fe os ot ou ov b">WebsocketConfig.kt</code>，并在下面添加配置。该配置为Spring Boot应用程序启用了WebSocket功能。</p><p id="58f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意，出于演示目的，stomp端点允许所有原点，但这不应该是生产设置的配置。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">启用Spring Boot web socket(websocketconfig . kt)的配置</p></figure><h2 id="6700" class="of mp it bd mq og oh dn mu oi oj dp my li ok ol na lm om on nc lq oo op ne oq bi translated"><strong class="ak">步骤3: </strong>创建用于单向实时通信的API端点</h2><p id="326c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">API端点为微服务(后端)提供了一种向web应用(前端)发送消息的方式。由于消息只需要单向流动(后端→ WebSocket服务器→前端)，使用API将是微服务(后端→ Websocket服务器)之间很好的通信媒介。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于向WebSocket服务器发送消息的API端点</p></figure><p id="4d0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码创建了一个带有POST请求端点的REST控制器，该端点接收请求体“<code class="fe os ot ou ov b">NewMessageRequest</code>”，其中<code class="fe os ot ou ov b">topic</code>是客户端(前端)订阅的STOMP目的地，<code class="fe os ot ou ov b">message</code>是字符串格式的实际消息。这样，您现在可以通过API向WebSocket服务器发送消息，然后该消息将通过WebSocket转发到web应用程序(前端)。</p><h2 id="e4c6" class="of mp it bd mq og oh dn mu oi oj dp my li ok ol na lm om on nc lq oo op ne oq bi translated"><strong class="ak">步骤4: </strong>配置Redis发布/订阅进行双向实时通信(可选)</h2><p id="5a00" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated"><em class="lv">注意:根据您的使用情况，如果您不需要web应用程序(前端)和微服务(后端)之间的双向实时通信，您可以省略此步骤。</em></p><p id="71cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与使用发布-订阅消息传递模式相比，微服务(后端和Websocket服务器)之间通过API进行的通信对于实时通信来说不是最佳的。因此，对于双向通信，我们将利用发布-订阅消息传递模式。</p><p id="09e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多方法可以实现发布-订阅消息传递模式，但是为了演示和简单起见，我们将使用Redis发布/订阅。</p><p id="14b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，使用docker ( <code class="fe os ot ou ov b">docker run — name redis-server -p 6379:6379 -d redis</code>)在本地运行Redis服务器，并将以下配置添加到application.yml文件中，以便WebSocket服务器连接到Redis服务器。</p><pre class="kj kk kl km gt oy ov oz pa aw pb bi"><span id="8d99" class="of mp it ov b gy pc pd l pe pf"># application.yml<br/>spring.redis:<br/>    host: localhost<br/>    port: 6379</span></pre><p id="1b44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，创建一个配置文件<code class="fe os ot ou ov b">RedisConfig.kt</code>，并添加下面的配置。本质上，我们正在配置一个<code class="fe os ot ou ov b">ReactiveRedisTemplate</code>，它与Redis服务器通信，并被配置为将消息序列化和反序列化为字符串。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ReactiveRedisTemplate的配置</p></figure><p id="6d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，创建一个包含订阅和发布到Redis服务器的逻辑的<code class="fe os ot ou ov b">RedisService</code>。在下面的例子中，我们订阅了一个入站通道主题<code class="fe os ot ou ov b">GREETING_CHANNEL_INBOUND</code>，它监听来自其他微服务(后端)的传入消息，并将所有收到的消息转发到STOMP目的地<code class="fe os ot ou ov b">/topic/greetings</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="531a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，创建一个<code class="fe os ot ou ov b">Controller</code>来处理来自web应用程序(前端)的消息，这些消息被发送到带有前缀<code class="fe os ot ou ov b">/app</code>的WebSocket服务器。在下面的示例中，发送到<code class="fe os ot ou ov b">/app/greet</code>的消息将被转发(发布)到出站通道主题<code class="fe os ot ou ov b">GREETING_CHANNEL_OUTBOUND</code>，该主题随后将由正在侦听该通道的任何微服务(后端)进行处理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="2779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我们已经设置了WebSocket服务器作为中间件(或代理),它通过WebSocket与web应用程序(前端)通信，并通过Redis Pub/Sub与微服务(后端)通信。</p><h1 id="74f0" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">测试WebSocket连接</h1><p id="f93a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">使用一个由jiangxy 构建的<a class="ae ky" href="https://bkjam.github.io/websocket-debug-tool/" rel="noopener ugc nofollow" target="_blank">开源websocket客户端调试器工具作为模拟web应用程序(前端)，我们可以测试我们上面构建的WebSocket服务器。</a></p><h2 id="5666" class="of mp it bd mq og oh dn mu oi oj dp my li ok ol na lm om on nc lq oo op ne oq bi translated"><strong class="ak">测试#1:从后端向前端发送消息(通过API) </strong></h2><p id="f9be" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">启动WebSocket服务器，并使用WebSocket调试器工具通过STOMP协议连接到WebSocket服务器<code class="fe os ot ou ov b">ws://localhost:8080/stomp</code>。连接后，配置WebSocket调试器工具以订阅主题<code class="fe os ot ou ov b">/topic/toast</code>。</p><p id="731a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，使用下面的命令向WebSocket服务器发送HTTP POST请求:</p><pre class="kj kk kl km gt oy ov oz pa aw pb bi"><span id="e52d" class="of mp it ov b gy pc pd l pe pf">curl -X POST -d '{"topic": "/topic/toast", "message": "testing API endpoint" }' -H 'Content-Type: application/json' localhost:8080/api/notification</span></pre><p id="0e60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WebSocket调试器工具应该具有如下所示的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/4f3088a23b1072241501b010c10f3d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vKaGnNWu7v99S_qqx_XAuA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">WebSocket调试器工具通过API从后端发送消息的输出屏幕截图</p></figure><p id="1415" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这说明WebSocket服务器已经通过API成功接收到消息，并通过WebSocket将消息转发给web应用(前端)。</p><h2 id="48a2" class="of mp it bd mq og oh dn mu oi oj dp my li ok ol na lm om on nc lq oo op ne oq bi translated"><strong class="ak">测试#2:从后端向前端发送消息(通过发布/订阅)</strong></h2><p id="0d70" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">启动WebSocket服务器，使用WebSocket调试器工具通过STOMP协议连接到WebSocket服务器<code class="fe os ot ou ov b">ws://localhost:8080/stomp</code>。连接后，配置WebSocket调试器工具以订阅主题<code class="fe os ot ou ov b">/topic/greetings</code>(上面定义的<a class="ae ky" href="#6d66" rel="noopener ugc nofollow"/>)。</p><p id="08bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Redis CLI，通过命令<code class="fe os ot ou ov b">PUBLISH GREETING_CHANNEL_INBOUND “\"Test Message from Backend PubSub\"”</code>向频道主题<code class="fe os ot ou ov b">GREETING_CHANNEL_INBOUND</code>(上面定义的<a class="ae ky" href="#6d66" rel="noopener ugc nofollow"/>)发布消息。</p><p id="87ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意，需要额外的</em> <code class="fe os ot ou ov b"><em class="lv">\”</em></code> <em class="lv">，因为WebSocket服务器被配置为接收字符串消息</em>。WebSocket调试器工具应该会收到如下所示的消息</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/72bddf75180f7006ca54bc3fe9dc2884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tBFoqWBxGvnmY0bvK9bt5Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过Redis PubSub从后端发送消息的WebSocket调试器工具输出的屏幕截图</p></figure><p id="520d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这说明WebSocket服务器已经通过Redis Pub/Sub成功接收到消息，并通过WebSocket将消息转发给web应用(前端)。</p><h2 id="a954" class="of mp it bd mq og oh dn mu oi oj dp my li ok ol na lm om on nc lq oo op ne oq bi translated"><strong class="ak">测试3:从前端向后端发送消息(通过发布/订阅)</strong></h2><p id="9ed3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">启动WebSocket服务器，并使用WebSocket调试器工具通过STOMP协议连接到WebSocket服务器<code class="fe os ot ou ov b">ws://localhost:8080/stomp</code>。一旦连接，使用Redis CLI，使用命令<code class="fe os ot ou ov b">SUBSCRIBE GREETING_CHANNEL_OUTBOUND</code>订阅频道主题<code class="fe os ot ou ov b">GREETING_CHANNEL_OUTBOUND</code>(上面定义的<a class="ae ky" href="#531a" rel="noopener ugc nofollow"/>)。使用WebSocket调试器工具向STOMP destination <code class="fe os ot ou ov b">/app/greet</code>发送消息，您应该观察到以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/20fd88f08a49d5e7fc2180fe88bd0d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*WciXNywBV3oehoW55SSZzw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Redis CLI订阅命令的输出</p></figure><p id="a9e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这说明WebSocket服务器已经通过WebSocket成功接收到消息，并通过Redis Pub/Sub将消息转发给微服务(后端)。</p><h1 id="b6c3" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">摘要</h1><p id="8f72" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">总之，我们已经在微服务架构中运行了一个WebSocket服务器的可能设计。拥有一个WebSocket服务器非常符合微服务的“单一责任原则”，它管理所有WebSocket到web应用程序(前端)的连接，并处理web应用程序(前端)和其他微服务(后端)之间的实时通信。</p><p id="7f44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！我希望你能从这篇文章中学到一些新的东西。请继续关注下一篇文章，我们将研究如何扩展WebSocket服务器。</p><p id="05dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，请关注我获取更多内容:)。</p><p id="d0db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢你一直读到最后。快乐学习！</p></div></div>    
</body>
</html>