<html>
<head>
<title>Trace Context Propagation With OpenTelemetry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenTelemetry跟踪上下文传播</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/trace-context-propagation-with-opentelemetry-b8816f2f065e?source=collection_archive---------4-----------------------#2022-04-02">https://betterprogramming.pub/trace-context-propagation-with-opentelemetry-b8816f2f065e?source=collection_archive---------4-----------------------#2022-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="35be" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/@dmitrykolomiets/list/musings-on-tracing-3d7bd0d2093c" rel="noopener">寻踪思考</a></h2><div class=""/><div class=""><h2 id="666a" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">将AWS发行版用于OpenTelemetry的实用说明</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/52b526434149253f04f1dfbc24255ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MGmsWLwL0H6dox0p"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@polarmermaid?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安妮·尼加德</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="cb38" class="lk ll iq lg b gy lm ln l lo lp"><strong class="lg ja">Table of Contents</strong></span><span id="58fc" class="lk ll iq lg b gy lq ln l lo lp"><a class="ae le" href="#03f1" rel="noopener ugc nofollow">Summary</a><br/><a class="ae le" href="#c370" rel="noopener ugc nofollow">Trace context propagation</a><br/><a class="ae le" href="#9687" rel="noopener ugc nofollow">End to end trace</a><br/><a class="ae le" href="#e3e7" rel="noopener ugc nofollow">Dangling AWS Lambda traces</a><br/><a class="ae le" href="#762b" rel="noopener ugc nofollow">Conclusion</a><br/><a class="ae le" href="#456e" rel="noopener ugc nofollow">Resources</a></span></pre><blockquote class="lr ls lt"><p id="c95d" class="lu lv lw lx b ly lz ka ma mb mc kd md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">到目前为止，我一直在谈论OpenTelemetry和ADOT，没有讨论具体的编程语言。下面的帖子是基于ADOT Python 的<a class="ae le" href="https://aws-otel.github.io/docs/getting-started/lambda/lambda-python" rel="noopener ugc nofollow" target="_blank"> AWS托管Lambda层。我相信其他语言的结论也是一样的。</a></p></blockquote><h1 id="03f1" class="mr ll iq bd ms mt mu mv mw mx my mz na kf nb kg nc ki nd kj ne kl nf km ng nh bi translated">摘要</h1><p id="3eb4" class="pw-post-body-paragraph lu lv iq lx b ly ni ka ma mb nj kd md nk nl mg mh nm nn mk ml no np mo mp mq ij bi translated">这篇文章的目的与前一篇文章中的<a class="ae le" href="https://medium.com/@dmitrykolomiets/trace-context-propagation-in-event-driven-architectures-ba9181b1b57?source=friends_link&amp;sk=ad98d9cc52bebc6b92074d908b2eb20e" rel="noopener">完全一样——演示当AWS服务本身不支持跟踪上下文时，我们如何手动传递跟踪上下文(例如，使用AWS Kinesis流)。这一次，我们将使用OpenTelemetry，而不是AWS X-Ray来完成这项工作(不过，我们将使用X-Ray控制台来查看结果跟踪)。</a></p><h1 id="c370" class="mr ll iq bd ms mt mu mv mw mx my mz na kf nb kg nc ki nd kj ne kl nf km ng nh bi translated">跟踪上下文传播</h1><p id="5094" class="pw-post-body-paragraph lu lv iq lx b ly ni ka ma mb nj kd md nk nl mg mh nm nn mk ml no np mo mp mq ij bi translated">现在，当你了解了OpenTelemetry collectors，distributions，并能说出<a class="ae le" href="https://aws.amazon.com/otel" rel="noopener ugc nofollow" target="_blank"> ADOT </a>和<a class="ae le" href="https://azdot.gov/" rel="noopener ugc nofollow" target="_blank"> ADOT </a>之间的区别时，我们终于可以谈论实用的比特了。</p><blockquote class="lr ls lt"><p id="2f3a" class="lu lv lw lx b ly lz ka ma mb mc kd md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">如果您需要复习这些主题，请复习<a class="ae le" href="https://medium.com/@dmitrykolomiets/approaching-opentelemetry-f138b9f0a9e4?source=friends_link&amp;sk=55c40cab3e52ba1a25347a39b552666e" rel="noopener">接近打开遥测</a>。</p></blockquote><p id="1da7" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">为了演示使用OpenTelemetry的跟踪上下文传播，我将使用<a class="ae le" href="https://aws-otel.github.io/docs/getting-started/lambda/lambda-python" rel="noopener ugc nofollow" target="_blank"> ADOT Python Lambda层</a>和<a class="ae le" href="https://github.com/open-telemetry/opentelemetry-python" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry Python SDK </a>，原因如下:</p><ul class=""><li id="b64f" class="nq nr iq lx b ly lz mb mc nk ns nm nt no nu mq nv nw nx ny bi translated">在上一篇文章中，我使用Python来演示X-Ray SDK的跟踪上下文传播。我认为这将是有益的，看看如何与OpenTelemery相同的应用程序</li><li id="b2ef" class="nq nr iq lx b ly nz mb oa nk ob nm oc no od mq nv nw nx ny bi translated">Python是支持<a class="ae le" href="https://aws-otel.github.io/docs/getting-started/python-sdk/trace-auto-instr" rel="noopener ugc nofollow" target="_blank">自动检测</a>的语言之一(Java是另一种)。强调自动和手动仪器之间的区别对于理解幕后发生的事情是很重要的。</li></ul><p id="8dde" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">我们将使用之前检查过的相同应用程序架构:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/920ff35fb43724e6bbd06330c9f7c284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*4Sm4d9LckQ9sYYvaVOhsjA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">我们想用OpenTelemetry追踪的分布式架构</p></figure><h2 id="7dfc" class="lk ll iq bd ms of og dn mw oh oi dp na nk oj ok nc nm ol om ne no on oo ng iw bi translated">制片人拉姆达</h2><p id="fa5d" class="pw-post-body-paragraph lu lv iq lx b ly ni ka ma mb nj kd md nk nl mg mh nm nn mk ml no np mo mp mq ij bi translated">我们从生产者lambda开始——最简单的一个。让我先给你看看代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="op oq l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">生成器lambda实现(自动检测)</p></figure><p id="f1e3" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">这个可疑的简单实现不仅捕获lambda函数的踪迹，而且<em class="lw">检测</em>并从<code class="fe or os ot lg b">boto3</code>库中捕获踪迹，处理与ADOT收集器的交互，并将踪迹导出到AWS X射线。这是当<a class="ae le" href="https://aws-otel.github.io/docs/getting-started/python-sdk/trace-auto-instr" rel="noopener ugc nofollow" target="_blank">自动检测</a>启用时，ADOTλ层提供的服务级别！</p><p id="a8ba" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">更具体地说，您需要执行以下操作来启用自动检测:</p><ul class=""><li id="a1fb" class="nq nr iq lx b ly lz mb mc nk ns nm nt no nu mq nv nw nx ny bi translated">将<a class="ae le" href="https://aws-otel.github.io/docs/getting-started/lambda/lambda-python#add-the-arn-of-the-lambda-layer" rel="noopener ugc nofollow" target="_blank">ADOTλ层</a>添加到您的函数中——这将安装OpenTelemetry SDK、ADOT收集器、AWS特定扩展等。</li><li id="5503" class="nq nr iq lx b ly nz mb oa nk ob nm oc no od mq nv nw nx ny bi translated"><a class="ae le" href="https://aws-otel.github.io/docs/getting-started/lambda/lambda-python#enable-auto-instrumentation-for-your-lambda-function" rel="noopener ugc nofollow" target="_blank">通过添加带有<code class="fe or os ot lg b">/opt/otel-instrument</code>值的<code class="fe or os ot lg b">AWS_LAMBDA_EXEC_WRAPPER</code>变量启用自动仪表</a></li></ul><p id="d529" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">即使不了解幕后发生的一切，这看起来已经很不错了。</p><h2 id="872c" class="lk ll iq bd ms of og dn mw oh oi dp na nk oj ok nc nm ol om ne no on oo ng iw bi translated">自动化仪器——跟踪结构</h2><p id="83c7" class="pw-post-body-paragraph lu lv iq lx b ly ni ka ma mb nj kd md nk nl mg mh nm nn mk ml no np mo mp mq ij bi translated">作为健全性检查，我们可以在控制台中调用Producer函数(使用任何有效负载),并在X射线控制台中查看结果跟踪:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ou"><img src="../Images/fe633860da6443baae4b71e831344788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yp2nuye-5SCt8adv6JaA2g.png"/></div></div></figure><p id="21aa" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">让我们回顾一下捕获的X射线轨迹的结构——当我们稍后转向手动仪器时，会有一个重要的区别。</p><blockquote class="lr ls lt"><p id="b29c" class="lu lv lw lx b ly lz ka ma mb mc kd md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">x射线服务使用<a class="ae le" href="https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-segments" rel="noopener ugc nofollow" target="_blank">段</a>和<a class="ae le" href="https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-subsegments" rel="noopener ugc nofollow" target="_blank">子段</a>的概念来表示组成跟踪的工作单元之间的父/子关系。出于同样的目的，OpenTelemetry使用了一个<a class="ae le" href="https://opentelemetry.io/docs/concepts/data-sources/#traces" rel="noopener ugc nofollow" target="_blank">跨度</a>的概念——可能有父跨度和子跨度。<br/>尽管我们使用X射线控制台来查看结果轨迹，但我将在本文中使用OpenTelemetry术语。</p></blockquote><p id="9d97" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">AWS Lambda服务将前两个跨度添加到跟踪中。理解这两个跨度甚至在调用我们的生成器lambda之前<em class="lw">就被捕获并导出到X射线是很重要的。</em></p><blockquote class="lr ls lt"><p id="b81e" class="lu lv lw lx b ly lz ka ma mb mc kd md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">AWS Lambda将这两个跨度<strong class="lx ja">直接</strong>导出到X射线。在撰写本文时，无法配置AWS Lambda并指定另一个遥测后端，如Jaeger、Splunk等。<br/>暗示—如果OpenTelemetry配置了另一个遥测后端，AWS Lambda特定的跨度将<strong class="lx ja">而不是</strong>导出到那里。</p></blockquote><p id="3835" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">下一个<code class="fe or os ot lg b">producer-function</code>跨度是由OpenTelemetry捕获的跨度——这是由自动仪器启动脚本创建的跨度(还记得我们设置为<code class="fe or os ot lg b">AWS_LAMBDA_EXEC_WRAPPER</code>环境变量的<code class="fe or os ot lg b">/opt/otel-instrument</code>脚本吗？).</p><p id="d919" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">如果我们选择<code class="fe or os ot lg b">producer-function</code> span，我们将看到我们在lambda函数中手动创建的子<code class="fe or os ot lg b">producing_messages</code> span。AWS SQS和AWS Kinesis服务还有两个额外的跨度——这些是从<code class="fe or os ot lg b">boto3</code>库中捕获的。当使用自动检测时，启动脚本检测最常见的Python库，以从它们自动捕获跨度。注意<em class="lw">仪器</em>应该<a class="ae le" href="https://aws-otel.github.io/docs/getting-started/python-sdk/trace-auto-instr" rel="noopener ugc nofollow" target="_blank">安装和包装</a>带有你的lambda功能，这样才能工作。你可以在GitHub 上找到<a class="ae le" href="https://github.com/open-telemetry/opentelemetry-python-contrib/tree/main/instrumentation" rel="noopener ugc nofollow" target="_blank">受支持库的完整列表。</a></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ov"><img src="../Images/803d744655a7ff7e30cb82eb0fded430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZMBwCx95jo7-_UuVBgKCgw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">生产者函数跟踪</p></figure><p id="bb4d" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">希望您对使用自动仪器时会发生什么有更好的了解。让我们继续下一个λ。</p><h2 id="81be" class="lk ll iq bd ms of og dn mw oh oi dp na nk oj ok nc nm ol om ne no on oo ng iw bi translated">消费者SQSλ函数</h2><p id="7eef" class="pw-post-body-paragraph lu lv iq lx b ly ni ka ma mb nj kd md nk nl mg mh nm nn mk ml no np mo mp mq ij bi translated">该函数需要从SQS消息中提取跟踪上下文，并确保该函数生成的新范围“继续”消息的原始跟踪。同样，我们对这个lambda使用自动仪器。下面是实现过程:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="d6cf" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">与生产者lambda一样，我们不需要为OpenTelemetry配置太多的麻烦。我们从SQS消息中提取出<code class="fe or os ot lg b">traceId</code>和<code class="fe or os ot lg b">spanId</code>字段——这一部分与我们之前使用X射线的<a class="ae le" href="https://medium.com/@dmitrykolomiets/trace-context-propagation-in-event-driven-architectures-ba9181b1b57?source=friends_link&amp;sk=ad98d9cc52bebc6b92074d908b2eb20e" rel="noopener">跟踪传播示例相同。不过，有几件事值得一提。</a></p><p id="65da" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated"><strong class="lx ja">服务器span种类<br/> </strong>另一个有趣的细节是我们分配给<code class="fe or os ot lg b">consuming_sqs</code> span的一个特殊的<code class="fe or os ot lg b">SERVER</code> span种类。这对于在X射线服务图中将该跨度视为一个单独的节点是必要的。根据<a class="ae le" href="https://aws-otel.github.io/docs/getting-started/python-sdk/trace-manual-instr#creating-custom-spans" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="lr ls lt"><p id="3a93" class="lu lv lw lx b ly lz ka ma mb mc kd md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">请注意，只有<code class="fe or os ot lg b">Server</code>类型的跨度被转换为X射线段，所有其他跨度都被转换为X射线子段。</p></blockquote><p id="b178" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">如果您计划将OpenTelemetry轨迹导出到AWS X-Ray，请记住这个模糊的细节。如果你使用另一个遥测后端-其他<a class="ae le" href="https://opentelemetry.io/docs/instrumentation/js/api/tracing/#span-kind" rel="noopener ugc nofollow" target="_blank">跨度种类</a>可能是有用的。</p><p id="0354" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated"><strong class="lx ja">跨度链接</strong> <br/>注意，我们在创建<code class="fe or os ot lg b">consuming_sqs</code>跨度时添加了一个可选的<code class="fe or os ot lg b">links</code>参数。</p><p id="0a7e" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">这个想法很简单——每个lambda调用可能会促成<em class="lw">多个</em>跟踪，有一种方法将它们关联起来可能会很有用。在我们的例子中，我们有一个由SQS服务触发的lambda函数。以下是用一批N条消息触发该函数时所涉及的跟踪:</p><ul class=""><li id="03d7" class="nq nr iq lx b ly lz mb mc nk ns nm nt no nu mq nv nw nx ny bi translated"><strong class="lx ja">λ调用痕迹</strong>。当SQS服务触发lambda函数时，会创建一个隐式跟踪。这是“默认”跟踪，即您通常在AWS X射线控制台中看到的跟踪。默认情况下，AWS Lambda服务会发出两个跨度(我们在前面讨论自动检测跟踪结构时讨论过它们)。该跟踪还可以包括lambda冷启动或在我们开始处理SQS消息之前发生的任何事情的跨度</li><li id="aa42" class="nq nr iq lx b ly nz mb oa nk ob nm oc no od mq nv nw nx ny bi translated"><strong class="lx ja"> SQS消息追踪</strong>——<em class="lw">最多</em> N个。请记住，每个SQS消息可能属于不同的跟踪，我们希望在处理消息时“继续”原来的跟踪，而不是创建新的跟踪</li></ul><p id="329e" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">因此，当我们处理SQS消息(向消息的原始跟踪添加跨度)时，我们希望保留到Lambda调用跟踪的链接——这对于故障排除场景可能特别有用。</p><p id="41b2" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">跨度/轨迹之间的联系可能是表达因果关系的有力方式。很难在AWS X射线控制台中演示这些链接，因为X射线不支持链接(目前？).在下一篇文章中，我将展示相同的OpenTelemetry trace在不同的遥测后端(Jaeger)中的样子，并展示链接的有用性。</p><h2 id="50ed" class="lk ll iq bd ms of og dn mw oh oi dp na nk oj ok nc nm ol om ne no on oo ng iw bi translated">消费者运动学λ函数</h2><p id="6678" class="pw-post-body-paragraph lu lv iq lx b ly ni ka ma mb nj kd md nk nl mg mh nm nn mk ml no np mo mp mq ij bi translated">最后一个Kinesis消费者lambda是最棘手的一个，主要是由于<a class="ae le" href="https://github.com/aws-observability/aws-otel-lambda/issues/238" rel="noopener ugc nofollow" target="_blank">ADOT Python</a>的<a class="ae le" href="https://aws-otel.github.io/docs/getting-started/lambda/lambda-python" rel="noopener ugc nofollow" target="_blank"> AWS托管Lambda层中的问题</a>迫使我放弃自动检测(删除<code class="fe or os ot lg b">AWS_LAMBDA_EXEC_WRAPPER</code>环境变量)。这是一件好事，因为我将演示如何在没有ADOT魔法的情况下添加OpenTelemetry支持。当心，有许多东西需要吸收:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="3c5d" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">让我们一步一步地介绍OpenTelemetry初始化:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="op oq l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">初始化跟踪程序提供程序</p></figure><p id="7a62" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">我们需要做的第一件事是初始化<em class="lw">跟踪提供者</em>——这是处理跟踪收集并导出到OpenTelemetry收集器的对象。当我们初始化提供者时，我们指定一个ID生成器<a class="ae le" href="https://docs.aws.amazon.com/xray/latest/devguide/xray-api-sendingdata.html#xray-api-traceids" rel="noopener ugc nofollow" target="_blank">与X射线</a>兼容(如果不需要X射线支持，则不需要)以及我们希望附加到跨度的其他属性。对于这个例子，我们设置了一个显式的服务名，并捕获了其他特定于AWS Lambda的属性(函数ARN、名称、内存/CPU分配等)。)</p><blockquote class="lr ls lt"><p id="5b3e" class="lu lv lw lx b ly lz ka ma mb mc kd md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">跟踪器提供程序只能初始化<strong class="lx ja">一次</strong> —如果您尝试设置另一个提供程序，第二次调用将被忽略。</p></blockquote><p id="6eaa" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">让我们打开下一行:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="op oq l"/></div></figure><ul class=""><li id="ae06" class="nq nr iq lx b ly lz mb mc nk ns nm nt no nu mq nv nw nx ny bi translated"><code class="fe or os ot lg b">add_span_processor</code>—向跟踪器提供程序注册一个span <em class="lw">处理器</em>。处理器是OpenTelemetry引入的一种构造，用于在导出数据之前对数据进行预处理(例如，修改属性或样本)或帮助确保数据成功通过管道(例如，批处理/重试)。OpenTelemetry处理器的一个很好的总结可以在<a class="ae le" href="https://github.com/open-telemetry/opentelemetry-collector/tree/main/processor" rel="noopener ugc nofollow" target="_blank">收集器GitHub库</a>中找到。</li><li id="8623" class="nq nr iq lx b ly nz mb oa nk ob nm oc no od mq nv nw nx ny bi translated"><code class="fe or os ot lg b">BatchSpanProcessor</code> —批处理机接受量程并将它们放入批处理。批处理有助于更好地压缩数据，并减少传输数据所需的传出连接数</li><li id="0a8c" class="nq nr iq lx b ly nz mb oa nk ob nm oc no od mq nv nw nx ny bi translated"><code class="fe or os ot lg b">OTLPSpanExporter</code> —以<a class="ae le" href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/otlp.md" rel="noopener ugc nofollow" target="_blank">开放式遥测协议</a> (OTLP)格式导出量程。默认情况下，导出器连接到与lambda代码一起运行的本地ADOT收集器实例。ADOT收集器负责进一步转发跨度，默认情况下，收集器配置为将跨度传递给AWS X射线服务。</li></ul><p id="e7ad" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">概括一下——Tracer Provider使用<code class="fe or os ot lg b">BatchSpanProcessor</code>和<code class="fe or os ot lg b">OTLPSpanExporter</code>来管理踪迹的收集和向ADOT收集器的导出。随着自动化工具的启用，所有这些底层细节都被隐藏了，但是现在我们可以完全控制跨度的处理和导出。我将在以后的帖子中使用这种方法来演示我们如何扩展ADOT lambda层提供的功能，并添加对额外遥测后端的支持。</p><p id="0432" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">继续前进:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="92ca" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">该行启用<code class="fe or os ot lg b">boto3</code> API的仪器。对于手动插装，插装我们感兴趣的库是我们的责任。</p><p id="957e" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">最后(这是双关语)，您可能已经注意到了这段代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="40cb" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">这是必要的，以确保即使在未处理异常的情况下，所有跨度都正确导出到ADOT收集器。当使用<code class="fe or os ot lg b">BatchSpanProcessor</code>时，这一点尤其重要——记住，在将多个跨度转发给收集器之前，它会将它们批处理在一起。如果没有<code class="fe or os ot lg b">force_flush</code>调用，一些跨度可能会丢失(当然，这些将是最重要的跨度)</p><p id="4cb6" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">就是这个！现在你应该对OpenTelemetry初始化和基本配置有了一个不错的心理模型，并且理解了ADOT lambda layer提供的自动和手动仪器模式之间的区别。</p><h1 id="9687" class="mr ll iq bd ms mt mu mv mw mx my mz na kf nb kg nc ki nd kj ne kl nf km ng nh bi translated">端到端跟踪</h1><p id="65e3" class="pw-post-body-paragraph lu lv iq lx b ly ni ka ma mb nj kd md nk nl mg mh nm nn mk ml no np mo mp mq ij bi translated">在我们结束之前，我们应该运行生产者lambda函数并检查产生的端到端跟踪:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ow"><img src="../Images/dc3cd3f85b1fd68014843a58f7fec1fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*99bEI2gUiov2QxsxqTmkXA.png"/></div></div></figure><p id="307c" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">与我的<a class="ae le" href="https://medium.com/@dmitrykolomiets/trace-context-propagation-in-event-driven-architectures-ba9181b1b57?source=friends_link&amp;sk=ad98d9cc52bebc6b92074d908b2eb20e" rel="noopener">前一篇文章</a>不同，我不知道我在这个跟踪传播的例子中使用了任何“黑客”或不支持的API。根据OpenTelemetry规范，这是一个正确的实现。更好的是，我们可以通过OpenTelemetry获得端到端的X射线追踪。</p><h1 id="e3e7" class="mr ll iq bd ms mt mu mv mw mx my mz na kf nb kg nc ki nd kj ne kl nf km ng nh bi translated">悬空AWS Lambda轨迹</h1><p id="e55a" class="pw-post-body-paragraph lu lv iq lx b ly ni ka ma mb nj kd md nk nl mg mh nm nn mk ml no np mo mp mq ij bi translated">我们在上面简要介绍了AWS Lambda服务导出的跨度。当我们在X射线中查看完整的服务地图时，这些跨度清晰可见:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ox"><img src="../Images/c75c58e3d8df5fc110275015ece0d887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W4Jwm7UaOYxhF4lukCL3TQ.png"/></div></div></figure><p id="fb02" class="pw-post-body-paragraph lu lv iq lx b ly lz ka ma mb mc kd md nk mf mg mh nm mj mk ml no mn mo mp mq ij bi translated">消费者lambdas发射OpenTelemetry跨度“继续”我们的主要端到端跟踪。同时，我们仍然有AWS Lambda服务为这些函数发出的跟踪。这些迹线与主端到端迹线分离或“悬空”。由于AWS Lambda和AWS X射线服务之间的直接集成，它们在X射线控制台中是可见的。请记住，如果您要使用OpenTelemetry的不同遥测后端，这些AWS Lambda跨度将<em class="lw">而不是</em>被导出。</p><h1 id="762b" class="mr ll iq bd ms mt mu mv mw mx my mz na kf nb kg nc ki nd kj ne kl nf km ng nh bi translated">结论</h1><p id="6f02" class="pw-post-body-paragraph lu lv iq lx b ly ni ka ma mb nj kd md nk nl mg mh nm nn mk ml no np mo mp mq ij bi translated">通过展示如何将OpenTelemetry集成到事件驱动的AWS架构并获得完整的端到端跟踪，我们已经在这篇文章中涵盖了很多内容。我们仍然使用AWS X-Ray作为我们的主要遥测后端，但我们没有必要这样做——使用OpenTelemetry，我们可以将轨迹导出到另一个后端，或者同时将事件导出到多个后端。这就是我们在下一篇文章中要做的——我将向你展示如何与<a class="ae le" href="https://www.jaegertracing.io/" rel="noopener ugc nofollow" target="_blank"> Jaeger </a>集成——一个流行的开源分布式追踪后端。</p><h1 id="456e" class="mr ll iq bd ms mt mu mv mw mx my mz na kf nb kg nc ki nd kj ne kl nf km ng nh bi translated">资源</h1><ul class=""><li id="f697" class="nq nr iq lx b ly ni mb nj nk oy nm oz no pa mq nv nw nx ny bi translated">您可以在<a class="ae le" href="https://github.com/kolomiets/tracing-playground/tree/main/opentelemetry-context-propagation" rel="noopener ugc nofollow" target="_blank">Kolo miets/tracing-playground</a>GitHub资源库中找到我们上面讨论过的完整项目</li><li id="f549" class="nq nr iq lx b ly nz mb oa nk ob nm oc no od mq nv nw nx ny bi translated">为了感受一下OpenTelemetry生态系统的规模，请看一下<a class="ae le" href="https://opentelemetry.io/registry/" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry Registry </a></li></ul></div></div>    
</body>
</html>