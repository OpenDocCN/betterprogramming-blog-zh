<html>
<head>
<title>A Complete Guide to Enums in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中枚举的完全指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-complete-guide-to-enums-in-typescript-6f76da009146?source=collection_archive---------1-----------------------#2021-10-01">https://betterprogramming.pub/a-complete-guide-to-enums-in-typescript-6f76da009146?source=collection_archive---------1-----------------------#2021-10-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="137d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在反应式工作环境中对枚举的深入探讨</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1a12cf0ddcc35bd6a11025eac94b8650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qBa13IKJsst2uB7C"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@courtneybaucom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Courtney Baucom </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e5f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在计算机编程中，<a class="ae ky" href="https://en.wikipedia.org/wiki/Enumerated_type" rel="noopener ugc nofollow" target="_blank">枚举类型</a>是由一组命名值组成的数据类型，这些命名值称为该类型的元素、成员、枚举数或枚举数。在Typescript中，枚举类型使用关键字<code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/enums.html" rel="noopener ugc nofollow" target="_blank">enum</a></code>，该关键字定义了一组组织在集合中的命名常数。</p><p id="d424" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了方便起见，我们将使用React工作环境来探索枚举。示例并不局限于React，它们还可以应用于其他TypeScript工作环境。</p><h1 id="ec88" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">使用类型脚本创建React应用程序</h1><p id="56f5" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们已经使用基于JavaScript的Create React应用程序探索了许多功能和库。这次为什么要用TypeScript？</p><p id="09b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript不支持枚举，尽管<code class="fe lv lw lx ly b">enum</code>是JavaScript中的保留字。更准确地说，<a class="ae ky" href="https://github.com/rbuckton/proposal-enum" rel="noopener ugc nofollow" target="_blank">JavaScript enum</a>正处于提案阶段。</p><p id="4128" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript枚举为字符串或数字提供结构化包装。</p><p id="f65d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/upgrade-create-react-app-based-projects-to-version-4-cra-4-d7962aee11a6"> Create React App </a>:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="b9d3" class="na ma it ly b gy nb nc l nd ne">npx create-react-app react-enum --template typescript<br/>cd react-enum</span></pre><p id="6dcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行<code class="fe lv lw lx ly b">npm start</code>，基于TypeScript的Create React应用程序启动并运行。</p><h1 id="6985" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">数字和字符串枚举</h1><p id="4c7b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们用关键字<code class="fe lv lw lx ly b">enum</code>定义枚举，后跟枚举名称和枚举成员，它们是括号中的常量名称。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="9461" class="na ma it ly b gy nb nc l nd ne">enum Name {Constant1, Constant2, ...};</span></pre><p id="4e2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照惯例，枚举名和常量名都是Pascal大小写，每个复合词的第一个字母都是大写的。</p><p id="3f59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个包含四种水果的<code class="fe lv lw lx ly b">Fruit</code>枚举的例子:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="0630" class="na ma it ly b gy nb nc l nd ne">enum Fruit {<br/>  Apple,<br/>  Orange,<br/>  Peach,<br/>  Pear,<br/>}</span></pre><p id="b774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，枚举为数字枚举，即<code class="fe lv lw lx ly b">Fruit.Apple</code>为0、<code class="fe lv lw lx ly b">Fruit.Orange</code>为1、<code class="fe lv lw lx ly b">Fruit.Peach</code>为2、<code class="fe lv lw lx ly b">Fruit.Pear</code>为3。</p><p id="9d51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该数字也可以自由初始化:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="cc22" class="na ma it ly b gy nb nc l nd ne">enum Fruit {<br/>  Apple = 5,<br/>  Orange = -1,<br/>  Peach,<br/>  Pear,<br/>}</span></pre><p id="a453" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么<code class="fe lv lw lx ly b">Fruit.Apple</code>就是5，<code class="fe lv lw lx ly b">Fruit.Orange</code>就是<code class="fe lv lw lx ly b">-1</code>，<code class="fe lv lw lx ly b">Fruit.Peach</code>就是0，<code class="fe lv lw lx ly b">Fruit.Pear</code>就是1。</p><p id="2efb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好的可读性，枚举可以定义为字符串。字符串枚举必须用字符串值初始化。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="c36c" class="na ma it ly b gy nb nc l nd ne">enum Color {<br/>  Green = 'Green',<br/>  LightGreen = 'Light Green',<br/>  White = 'White',<br/>}</span></pre><p id="3a99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，<code class="fe lv lw lx ly b">Color.Green</code>就是<code class="fe lv lw lx ly b">'Green'</code>，<code class="fe lv lw lx ly b">Color.LightGreen</code>就是<code class="fe lv lw lx ly b">'Light Green'</code>，<code class="fe lv lw lx ly b">Color.White</code>就是<code class="fe lv lw lx ly b">'White'</code>。</p><p id="d036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有混合了数值和字符串值的异类枚举。</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="3f08" class="na ma it ly b gy nb nc l nd ne">enum Task {<br/>  Name = 'Todo List',<br/>  Assigned = 0,<br/>  InProgress,<br/>  Finished<br/>}</span></pre><p id="ed42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个定义，<code class="fe lv lw lx ly b">Task.Name</code>就是<code class="fe lv lw lx ly b">'Todo List'</code>，<code class="fe lv lw lx ly b">Task.Assigned</code>就是0，<code class="fe lv lw lx ly b">Task.InProgress</code>就是1，<code class="fe lv lw lx ly b">Task.Finished</code>就是2。</p><p id="1d6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用以下代码修改<code class="fe lv lw lx ly b">src/App.tsx</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e6d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第1–6行定义了<code class="fe lv lw lx ly b">Fruit</code>枚举，显示在第24–28行。enum是一个对象(第24行)，带有常量名和数值的键，<code class="fe lv lw lx ly b">{"0":"Apple","1":"Orange","2":"Peach","3":"Pear","Apple":0,"Orange":1,"Peach":2,"Pear":3}</code>。因此，我们可以使用对象映射(<code class="fe lv lw lx ly b">Fruit.Apple</code>或<code class="fe lv lw lx ly b"> Fruit.['Apple']</code>)和反向映射(<code class="fe lv lw lx ly b">Fruit[0]</code>)。</p><p id="2810" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第8–12行定义了<code class="fe lv lw lx ly b">Color</code>枚举，显示在第29–32行。它是一个对象，<code class="fe lv lw lx ly b">{"Green":"Green","LightGreen":"Light Green","White":"White"}</code>。我们可以看到字符串枚举成员没有反向映射。</p><p id="bf3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第14–19行定义了<code class="fe lv lw lx ly b">Task</code>枚举，显示在第33–37行。它是一个物体，<code class="fe lv lw lx ly b">{"0":"Assigned","1":"InProgress","2":"Finished","Name":"Todo List","Assigned":0,"InProgress":1,"Finished":2}</code>。它是一个异类枚举，只有数值成员具有反向映射。</p><p id="e730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行该应用程序，它会在浏览器上显示以下输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="28c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有bowsers直接支持TypeScript。<a class="ae ky" href="https://www.typescriptlang.org/tsconfig#target" rel="noopener ugc nofollow" target="_blank">代码可以转换成JavaScript(更确切地说是ES6)，在所有主流浏览器上运行，除了IE (ES5) </a>。枚举被转换为以下JavaScript代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="7fb4" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">常量枚举表达式</h1><p id="0fb3" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">枚举成员用常量枚举表达式初始化，这些表达式可以在编译时完全计算。以下是有效的表达式:</p><ul class=""><li id="5273" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">数值或字符串的文字枚举表达式</li></ul><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="2e88" class="na ma it ly b gy nb nc l nd ne">enum BooleanValue {<br/>  Yes = 1,<br/>  No = 0,<br/>}</span><span id="68fa" class="na ma it ly b gy nq nc l nd ne">enum Result {<br/>  Right = 'Right',<br/>  Wrong = 'Wrong',<br/>}</span></pre><ul class=""><li id="2600" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">以常量枚举表达式为操作数的<code class="fe lv lw lx ly b">+</code>、<code class="fe lv lw lx ly b">-</code>、<code class="fe lv lw lx ly b">*</code>、<code class="fe lv lw lx ly b">/</code>、<code class="fe lv lw lx ly b">&lt;&lt;</code>、<code class="fe lv lw lx ly b">&gt;&gt;</code>、<code class="fe lv lw lx ly b">&gt;&gt;&gt;</code>、<code class="fe lv lw lx ly b">&amp;</code>、<code class="fe lv lw lx ly b">|</code>、<code class="fe lv lw lx ly b">^</code>二元运算符产生的值</li></ul><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="69a5" class="na ma it ly b gy nb nc l nd ne">enum AccessCode {<br/>  None = 1 &lt;&lt; 0,<br/>  Read = 1 &lt;&lt; 1,<br/>  Write = 1 &lt;&lt; 2,<br/>}</span></pre><ul class=""><li id="733f" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">对以前定义的常量枚举成员的引用</li></ul><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="66c5" class="na ma it ly b gy nb nc l nd ne">enum AccessCode {<br/>  None = 1 &lt;&lt; 0,<br/>  Read = 1 &lt;&lt; 1,<br/>  Write = 1 &lt;&lt; 2,<br/>  ReadOrWrite = Read | Write,<br/>}</span><span id="12a1" class="na ma it ly b gy nq nc l nd ne">enum Permission {<br/>  NotAllowed = 0,<br/>  Allowed = AccessCode.ReadOrWrite,<br/>}</span></pre><ul class=""><li id="5536" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">带括号的常量枚举表达式</li></ul><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="32b4" class="na ma it ly b gy nb nc l nd ne">enum Values {<br/>  NumberValue = (2 * 3),<br/>  StringValue = ('Today' + 'Tomorrow'),<br/>}</span></pre><ul class=""><li id="ef6a" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">应用于常量枚举表达式的<code class="fe lv lw lx ly b">+</code>、<code class="fe lv lw lx ly b">-</code>、<code class="fe lv lw lx ly b">~</code>一元运算符之一</li></ul><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="ca89" class="na ma it ly b gy nb nc l nd ne">enum ThreeOps {<br/>  Plus = +1,<br/>  Minus = -1,<br/>  Tilde = ~1,<br/>}</span></pre><ul class=""><li id="34c5" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">函数调用</li></ul><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="c499" class="na ma it ly b gy nb nc l nd ne">const add3 = (value: number) =&gt; value + 3;<br/>enum ComputedValues {<br/>  V1 = add3(5),<br/>  V2 = add3(7),<br/>}</span></pre><p id="898e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将这些枚举放入<code class="fe lv lw lx ly b">src/App.tsx</code>中，看看它们是如何工作的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="408b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第1–4行定义了<code class="fe lv lw lx ly b">BooleanValue</code>枚举，显示在第43–45行。</p><p id="2274" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第6–9行定义了<code class="fe lv lw lx ly b">Result</code>枚举，显示在第46–48行。</p><p id="f036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第11–16行定义了<code class="fe lv lw lx ly b">AccessCode</code>枚举，显示在第49–53行。</p><p id="e1b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第18–21行定义了<code class="fe lv lw lx ly b">Permission</code>枚举，它显示在第54–56行。</p><p id="ce94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第23–26行定义了<code class="fe lv lw lx ly b">Values</code>枚举，它显示在第57–59行。</p><p id="75ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第28–32行定义了<code class="fe lv lw lx ly b">ThreeOps</code>枚举，显示在第60–63行。</p><p id="b175" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第34行定义了一个函数表达式<code class="fe lv lw lx ly b">add3</code>。</p><p id="e668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第35–38行定义了<code class="fe lv lw lx ly b">ComputedValues</code>枚举，显示在第64–66行。</p><p id="3a82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行该应用程序，它会在浏览器上显示以下输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">枚举被转换为以下JavaScript代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="83a5" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">枚举类型</h1><p id="b141" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">定义的枚举是TypeScript中的一种类型。此外，枚举成员也可以用作类型。</p><p id="6717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来看看下面这个<code class="fe lv lw lx ly b">src/App.tsx</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="cc82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第1–9行定义了一个枚举，<code class="fe lv lw lx ly b">Day</code>。它在第23行输出类型为<code class="fe lv lw lx ly b">object</code>。</p><p id="523f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Day</code>用作类型，在第10–13行定义常量变量。这些变量实际上有数字类型(第25–28行)。</p><p id="bdc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Day</code>用作类型，在第14行定义函数表达式。该函数在第29–32行被调用。</p><p id="d8c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第15行使用枚举成员<code class="fe lv lw lx ly b">Day.Sunday</code>来定义类型<code class="fe lv lw lx ly b">number</code>(第33行)，实际值(第34行)超出了枚举值。</p><p id="5112" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为比较，第16行和第17行不能使用defined变量来定义类型。</p><p id="e2b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行该应用程序，它会在浏览器上显示以下输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1c98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">枚举的行为类似于对象。枚举成员可以通过点符号或括号符号来引用。例如，<code class="fe lv lw lx ly b">Day.Sunday</code>和<code class="fe lv lw lx ly b">Day['Sunday']</code>可以互换使用。</p><p id="bc9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行以下<code class="fe lv lw lx ly b">src/App.tsx</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5a0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第14行显示编译错误，<code class="fe lv lw lx ly b">Element implicitly has an 'any' type because index expression is not of type 'number'.ts</code>。</p><p id="6b80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用枚举括号表示法，索引表达式必须是有效的枚举成员。如果我们使用<code class="fe lv lw lx ly b">Day[key as 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday']</code>它将会工作。其实<code class="fe lv lw lx ly b">Day[key as 'Sunday']</code>也行。</p><p id="ebbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，更好的方法是使用<code class="fe lv lw lx ly b">keyof</code>关键字。<code class="fe lv lw lx ly b">keyof typeof</code>获取将所有枚举键表示为字符串的类型，即<code class="fe lv lw lx ly b">'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday'</code>。</p><p id="a659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是通过编译的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6a75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行它，我们会在浏览器上看到对象映射和反向映射值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="a627" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何只获取枚举键？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b5cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何只获取枚举值？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e67e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何获取枚举长度？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="fa06" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">枚举对象</h1><p id="2acf" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">枚举是运行时的对象。枚举可以传递给函数。</p><p id="4804" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是改装过的<code class="fe lv lw lx ly b">src/App.tsx</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b498" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第11行是一个函数表达式，它将一个对象作为参数。它与枚举<code class="fe lv lw lx ly b">Day</code>无关，只不过它们都有键<code class="fe lv lw lx ly b">Wednesday</code>。</p><p id="9656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe lv lw lx ly b">Day</code>调用函数(第16行)。它在浏览器上产生以下输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="601e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">枚举是对象，但是生成的代码有点复杂。<code class="fe lv lw lx ly b">Day</code>枚举被转换成以下JavaScript代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从TypeScript 3.4开始，<code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions" rel="noopener ugc nofollow" target="_blank">const</a></code> <a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions" rel="noopener ugc nofollow" target="_blank">断言被引入</a>。它的语法是一个类型断言，使用<code class="fe lv lw lx ly b">as const</code>就足够了，例如<code class="fe lv lw lx ly b">123 as const</code>。当文字表达式用<code class="fe lv lw lx ly b">const</code>断言构造时，它意味着:</p><ul class=""><li id="fbed" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">表达式中的任何文本类型都不应被加宽。</li><li id="40e9" class="nh ni it lb b lc nr lf ns li nt lm nu lq nv lu nm nn no np bi translated">对象文字获取<code class="fe lv lw lx ly b">readonly</code>属性。</li><li id="5742" class="nh ni it lb b lc nr lf ns li nt lm nu lq nv lu nm nn no np bi translated">数组文字变成了<code class="fe lv lw lx ly b">readonly</code>元组。</li></ul><p id="2f2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用<code class="fe lv lw lx ly b">src/App.tsx</code>中的<code class="fe lv lw lx ly b">const</code>断言创建一个对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="71d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它没有反向映射。运行它，我们会在浏览器上看到对象映射值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5ac1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是生成的JavaScript代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="cdef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它不是枚举，但可以像枚举一样使用。生成的代码很简单，类似于原始的TypeScript代码。因此，使用<code class="fe lv lw lx ly b">const</code>断言是TypeScript枚举的一个可行替代方案。</p><h1 id="d488" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="cb14" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们已经研究了React工作环境中的类型脚本枚举。以下是总结:</p><ul class=""><li id="447b" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">有数字和字符串枚举，也有混合类型的异构枚举。</li><li id="994d" class="nh ni it lb b lc nr lf ns li nt lm nu lq nv lu nm nn no np bi translated">枚举成员使用各种常量枚举表达式。</li><li id="a764" class="nh ni it lb b lc nr lf ns li nt lm nu lq nv lu nm nn no np bi translated">枚举和枚举成员都可以用作类型。</li><li id="9f30" class="nh ni it lb b lc nr lf ns li nt lm nu lq nv lu nm nn no np bi translated">枚举是运行时的对象，枚举可以传递给函数。</li><li id="e531" class="nh ni it lb b lc nr lf ns li nt lm nu lq nv lu nm nn no np bi translated">使用const断言是TypeScript枚举的一种可行的替代方法。</li></ul><p id="7a58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。如果你有兴趣，可以看看<a class="ae ky" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener">我的其他媒体文章</a>。</p></div></div>    
</body>
</html>