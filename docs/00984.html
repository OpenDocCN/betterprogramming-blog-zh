<html>
<head>
<title>Interface Segregation Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">界面分离原理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solid-swift-by-examples-part-four-ec31bdb2872?source=collection_archive---------3-----------------------#2019-08-03">https://betterprogramming.pub/solid-swift-by-examples-part-four-ec31bdb2872?source=collection_archive---------3-----------------------#2019-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2351" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Swift实例中的坚实原则</h2><div class=""/><div class=""><h2 id="4dca" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">坚固的雨燕</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f0a8449e2e8fea07a8c33bc54b6cf0b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-r9-o73yfXoYUTnn"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">约翰·巴克利在Unsplash 上的照片</p></figure><p id="112f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是坚实的原则系列的第四部分。在之前的文章中，我们讨论了什么是可靠原理，它们试图解决什么，以及什么是SRP(I)、OCP(II)和LSP(III)。</p><p id="de5e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以在这里看到以前的原则:</p><div class="me mf gp gr mg mh"><a href="https://medium.com/@piero9212/solid-swift-by-examples-part-one-35018d53d3e6" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">坚固的雨燕</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">完整指南第一部分</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">medium.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv lb mh"/></div></div></a></div><div class="me mf gp gr mg mh"><a href="https://medium.com/@piero9212/solid-swift-by-examples-part-two-82ac3c457e4e" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">开闭原理</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">在第一部分，我们描述了什么是坚实的原则和他们试图解决什么，解释了第一…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">medium.com</p></div></div><div class="mq l"><div class="mw l ms mt mu mq mv lb mh"/></div></div></a></div><div class="me mf gp gr mg mh"><a href="https://medium.com/@piero9212/solid-swift-by-examples-part-three-675672c1ec20" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">利斯科夫替代原理</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">这是关于坚实原理的出版物的第三部分。在以前的文章中，我们讨论了什么是固体…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">medium.com</p></div></div><div class="mq l"><div class="mx l ms mt mu mq mv lb mh"/></div></div></a></div><p id="5687" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这一部分，我们将探讨以下原则:</p><p id="5261" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Robert C. Martin在为施乐公司提供咨询，帮助他们为新的打印机系统构建软件时，定义了接口分离原则。</p><p id="aa94" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">他将其定义为:</p><blockquote class="my"><p id="331d" class="mz na it bd nb nc nd ne nf ng nh md dk translated"><em class="ni">“不应该强迫客户端依赖他们不使用的接口。”</em></p></blockquote><p id="4617" class="pw-post-body-paragraph li lj it lk b ll nj kd ln lo nk kg lq lr nl lt lu lv nm lx ly lz nn mb mc md im bi translated">听起来很明显，不是吗？</p><p id="313c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">嗯，违反这个原则很容易。与<a class="ae lh" href="https://medium.com/better-programming/solid-swift-by-examples-part-one-35018d53d3e6" rel="noopener">单一责任原则</a>相似，接口分离原则的目标是通过将软件分成多个独立的部分来减少副作用和所需变更的频率。</p><p id="67e2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">ISP帮助我们避免:</p><ul class=""><li id="54bb" class="no np it lk b ll lm lo lp lr nq lv nr lz ns md nt nu nv nw bi translated">胖接口。</li><li id="065e" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated">强制类实现它们不应该实现的方法。</li><li id="3a57" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated">用很多方法污染协议。</li></ul><p id="ae85" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们开始编写示例代码:</p><p id="2dd4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我们必须制作一个餐馆列表，每个单元格都应该能够显示菜单并进行预订:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">餐馆建筑</p></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">餐馆电池</p></figure><p id="b243" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，一旦用户从<code class="fe of og oh oi b">RestaurantCell</code>点击<em class="oe">显示菜单</em>按钮，应用程序将显示一个新的<code class="fe of og oh oi b">View</code>菜单，以及同样的保留、<code class="fe of og oh oi b">markFavorite</code>和<code class="fe of og oh oi b">getDirections IBAction</code>。</p><p id="62e1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，当我们添加一个名为<code class="fe of og oh oi b">History</code>的新视图，显示用户过去的预订，而不是预订，需求定义我们必须显示菜单和<code class="fe of og oh oi b">getDirections</code>作为<code class="fe of og oh oi b">RestaurantCell</code>，但是我们必须添加一个<em class="oe">显示</em>和<em class="oe">编辑</em>到预订动作时，会发生什么呢？</p><p id="8825" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们创建了一个新的细胞类别:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">保留结构</p></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">预订单元</p></figure><p id="db44" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们正在处理预订过程，但是实现<code class="fe of og oh oi b">ReservationCellDelegate</code>的类会发生什么呢？</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">预订视图控制器</p></figure><p id="0ce4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用这种方法，从<code class="fe of og oh oi b">ReservationCellDelegate</code>实现的类被强制实现所有的函数，打破了接口分离原则。</p><p id="960f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当客户依赖于它不使用的方法时，我们就违反了一些坚实的原则。</p><p id="8338" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们使用接口隔离原理来解决这个问题。在这种情况下，可以通过组合并遵循SRP来完成:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">坚固到可以营救</p></figure><p id="c170" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们有小协议而不是大协议。这使我们的<code class="fe of og oh oi b">ViewController</code>班更好了:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">我们全新的预约VC</p></figure><p id="c9b4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">恭喜你，你已经分离了接口，所以现在我们有了彼此独立的特性。</p><p id="72cb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还有其他情况来涵盖和使用接口分离原则。这是经过一些修改后的餐厅结构:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">餐厅结构</p></figure><p id="2ad4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们之前的例子中，当用户点击<code class="fe of og oh oi b">showMenu</code>时，我们共享了这个餐馆结构，但是你注意到了吗，我们可能通过这个动作调用向其他屏幕共享了额外的未使用的信息？</p><p id="f3e2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如你所看到的，我们在像<code class="fe of og oh oi b">getDirections</code>这样的方法中分享了太多的信息，因为它只需要<code class="fe of og oh oi b">longitud</code>、<code class="fe of og oh oi b">latitud</code>和<code class="fe of og oh oi b">title</code>。这是假设请求只是显示一个简单的弹出菜单，其中包含餐馆名称和选择地图服务应用程序的列表。</p><p id="ba48" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们用我们所学的来解决它:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">我们新的餐厅结构</p></figure><p id="55ad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">利用typealias并更新我们的<code class="fe of og oh oi b">RestaurantDirectionsDelegate</code>和<code class="fe of og oh oi b">ReservationViewController.</code></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="469c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样，我们就不会向<code class="fe of og oh oi b">Directions</code> <code class="fe of og oh oi b">View</code>暴露额外的数据(比如餐馆ID和图片)。此外，它对于单元测试非常有用，让我们创建一个模拟类，实现<code class="fe of og oh oi b">RestaurantLocation</code>协议。</p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="ecb9" class="oq or it bd os ot ou ov ow ox oy oz pa ki pb kj pc kl pd km pe ko pf kp pg ph bi translated">结论</h1><p id="116b" class="pw-post-body-paragraph li lj it lk b ll pi kd ln lo pj kg lq lr pk lt lu lv pl lx ly lz pm mb mc md im bi translated">记得让你的抽象变得可重用、更小和可组合。正如您从SRP中学到的，您应该避免大的类和接口。</p><p id="647f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望你喜欢这篇文章，并发现它是有帮助的。感谢阅读。</p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="866f" class="oq or it bd os ot ou ov ow ox oy oz pa ki pb kj pc kl pd km pe ko pf kp pg ph bi translated">下一章</h1><div class="me mf gp gr mg mh"><a href="https://medium.com/@piero9212/solid-swift-by-examples-part-five-a860b86b85f5" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">从属倒置原则</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">这是关于坚实原理的出版物的最后一部分。在以前的文章中，我们讨论了什么是固体…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">medium.com</p></div></div><div class="mq l"><div class="pn l ms mt mu mq mv lb mh"/></div></div></a></div></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="ea3d" class="oq or it bd os ot ou ov ow ox oy oz pa ki pb kj pc kl pd km pe ko pf kp pg ph bi translated">参考</h1><div class="me mf gp gr mg mh"><a href="https://stackify.com/interface-segregation-principle/" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">坚实的设计原则解释:界面分离与代码示例</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">与单一责任原则相似，界面分离原则的目标是减少副作用</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">stackify.com</p></div></div><div class="mq l"><div class="po l ms mt mu mq mv lb mh"/></div></div></a></div><div class="me mf gp gr mg mh"><a href="https://medium.com/@piyush.dez/solid-principles-in-swift-e9cc84ff5aa2" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">Swift坚实的设计原则</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">SOLID代表了面向对象编程的5个原则:单一责任、开放/封闭、Liskov替换…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">medium.com</p></div></div><div class="mq l"><div class="pp l ms mt mu mq mv lb mh"/></div></div></a></div><div class="me mf gp gr mg mh"><a href="https://medium.com/the-aesthetic-programmer/ios-solid-principles-pt-4-interface-segregation-principle-a40d534b8d7f" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">iOS —固体原理第4部分—界面分离原理</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">界面分离原理认为:</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">medium.com</p></div></div><div class="mq l"><div class="pq l ms mt mu mq mv lb mh"/></div></div></a></div><div class="me mf gp gr mg mh"><a href="https://marcosantadev.com/solid-principles-applied-swift/" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">适用于Swift - Marco Santa Dev的坚实原则</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">可维护的组件。可重复使用。只是一个梦？也许不是。坚实的原则，也许是出路。固体是一个缩写…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">marcosantadev.com</p></div></div><div class="mq l"><div class="pr l ms mt mu mq mv lb mh"/></div></div></a></div><div class="me mf gp gr mg mh"><a href="https://codeburst.io/solid-design-principle-using-swift-fa67443672b8" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">使用Swift的可靠设计原则</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">坚实的原则是实现/创建有效的、可维护的、可扩展的和松散的…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">codeburst.io</p></div></div><div class="mq l"><div class="ps l ms mt mu mq mv lb mh"/></div></div></a></div><ul class=""><li id="2445" class="no np it lk b ll lm lo lp lr nq lv nr lz ns md nt nu nv nw bi translated"><a class="ae lh" href="https://web.archive.org/web/20150905081110/http://www.objectmentor.com/resources/articles/isp.pdf" rel="noopener ugc nofollow" target="_blank">https://web . archive . org/web/20150905081110/http://www . object mentor . com/resources/articles/ISP . pdf</a></li></ul></div></div>    
</body>
</html>