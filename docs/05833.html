<html>
<head>
<title>Improve MongoDB Performance Using Projection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用投影提高MongoDB性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/improve-mongodb-performance-using-projection-c08c38334269?source=collection_archive---------11-----------------------#2020-08-10">https://betterprogramming.pub/improve-mongodb-performance-using-projection-c08c38334269?source=collection_archive---------11-----------------------#2020-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="23c5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高Mongo数据库的性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e83fc20421d58e0f3a99aef379b16919.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xNUvb3ABjaziY-2J"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@greg_rosenke?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格雷格·罗森克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="598d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文记录了我关于在MongoDB中使用投影提高了多少性能的所有发现和分析。在本文的最后，我们将能够知道MongoDB查询性能是否会通过利用投影得到改善。</p><p id="86be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e784" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">问题陈述</h1><p id="9b2c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这篇文章的灵感来自于我的工作时间，当我从MongoDB检索数据时，我使用了<a class="ae ky" href="https://docs.mongodb.com/manual/reference/glossary/#term-projection" rel="noopener ugc nofollow" target="_blank">投影</a>。Projection是<em class="mz">“指定MongoDB在结果集中返回哪些字段的查询文档。”</em>根据MongoDB官方<a class="ae ky" href="https://docs.mongodb.com/manual/reference/glossary/#term-projection" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="bb3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就像在麦当劳点一个巨无霸，我们可以选择点菜，而不是全套的饮料和薯条。</p><p id="daa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我想知道—如果使用投影，查询性能会提高多少。以下是我在这项研究中想要达到的主要目标:</p><h2 id="f242" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">主要目标</h2><ul class=""><li id="061e" class="nm nn it lb b lc mu lf mv li no lm np lq nq lu nr ns nt nu bi translated">发现如果在MongoDB查询中使用投影，性能是否会提高。</li><li id="5f1f" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">发现在MongoDB查询中使用投影的最佳场景。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4dc4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">溶液分析</h1><p id="945a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了继续研究，我总是从找到我需要的东西开始。这些是我需要的东西:</p><ul class=""><li id="6c42" class="nm nn it lb b lc ld lf lg li oa lm ob lq oc lu nr ns nt nu bi translated">拥有超过500K个文档的集合，这样我就可以找出使用和不使用投影时查询时间的差异。</li><li id="5182" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">子文档架构。这是因为我怀疑带有子文档的文档会增加大量的查询时间。让我们也为实验准备这个。</li></ul><p id="90d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于数据准备的结果，请参考下面的截图。查看这篇<a class="ae ky" href="https://medium.com/@tcguy/mongodb-performance-101-how-to-generate-millions-of-data-for-performance-optimization-cf45d3556693" rel="noopener">文章</a>关于我如何为性能优化生成数百万个虚拟数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/a21953c99c01bf0f8284286fdb7e48b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYK8wFD1zZg_ItA_GFPSUg.png"/></div></div></figure><p id="3c64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个截图中，我们知道我们已经生成了50万个文档，包含以下字段:</p><ul class=""><li id="e8de" class="nm nn it lb b lc ld lf lg li oa lm ob lq oc lu nr ns nt nu bi translated"><code class="fe oe of og oh b">booking_no</code> -航班的预订号码</li><li id="3285" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe oe of og oh b">origin</code> -出发城市</li><li id="d09d" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe oe of og oh b">destination</code>——到达城市</li><li id="f15b" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe oe of og oh b">persons</code> -由<code class="fe oe of og oh b">first_name</code>、<code class="fe oe of og oh b">last_name</code>和<code class="fe oe of og oh b">dob</code>字段组成的人员数组</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2b8c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">性能实验</h1><p id="21e1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们开始任何实验之前，让我们确保设置是正确的。除了默认的<code class="fe oe of og oh b">_id</code>字段，集合中还没有创建索引。</p><p id="8725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想在这里进行的实验是:</p><ul class=""><li id="6469" class="nm nn it lb b lc ld lf lg li oa lm ob lq oc lu nr ns nt nu bi translated">实验1:如果我投影更少的字段，查询性能会提高吗？</li><li id="e955" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">实验二:如果实验一结果为否，还有哪些场景可以发现投影将如何提高查询性能？</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="218b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实验1:如果我投影更少的字段，查询性能会提高吗？</h1><p id="7679" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可惜答案是<strong class="lb iu">没有</strong>。然而，如果那些返回的字段都被索引，性能将会提高，我们将在下一节中讨论这一点。</p><p id="9480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本实验中，我们将检索目的地为“Gerlachmouth”的所有航班预订。在50万份预订中，有93份预订的目的地是“Gerlachmouth”。让我们检查一下归还这93份文件花了多长时间。</p><p id="d193" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用Mongo Shell Explain函数执行性能分析，这使我们能够发现在查询和所使用的查询策略上花费的时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/d75821575013e3183901504315aad60d.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*ZILEtJVXHlvsVaKlImVusA.png"/></div></figure><p id="2548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的截图显示了在没有投影的情况下进行检索时的结果。完成该查询需要461毫秒。虽然下面的屏幕截图显示了我们利用投影的结果，但该查询花了505毫秒才完成。</p><p id="53bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，性能并没有提高——相反，当我们使用投影时，处理查询需要更长的时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/9970ce3c81c2ba5ebd2b9828d932cfc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*1jXiJv35xCeu0cYVUtsuZQ.png"/></div></figure><p id="f01e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实验1的结论—当您在查询中实现投影时，性能并没有提高。👎👎</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="43e9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实验2:如果实验1的结果是否定的，寻找其他关于投影如何提高查询性能的场景</h1><p id="897e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">由于我的第一个假设是错误的，于是我试着做了一些研究，重新访问了MongoDB大学提供的表演<a class="ae ky" href="https://university.mongodb.com/courses/M201/about" rel="noopener ugc nofollow" target="_blank">课程</a>。该课程是免费的——如果您对学习MongoDB性能感兴趣，请查看该课程。</p><p id="bd6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现了覆盖查询。Covered Query是一个<em class="mz">“完全使用索引就可以满足的查询，不需要检查任何文档”，</em>根据MongoDB的官方<a class="ae ky" href="https://docs.mongodb.com/manual/core/query-optimization/#covered-query" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="a5c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用烹饪的比喻来理解覆盖查询。想象一下，你正在做饭，所有的食材都准备好了，放在冰箱里。基本上什么都有盖，你只要煮就行了。</p><p id="16a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们为数据库创建任何索引之前，让我们先问一个问题:我们要返回给应用程序的字段是什么？让我们给出以下场景:</p><ul class=""><li id="bc96" class="nm nn it lb b lc ld lf lg li oa lm ob lq oc lu nr ns nt nu bi translated">管理员想知道所有飞往特定目的地的航班预订情况。管理员想知道的信息是他们各自的<code class="fe oe of og oh b">booking_no</code>、<code class="fe oe of og oh b">origin</code>和<code class="fe oe of og oh b">destination</code>。</li></ul><p id="a53c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于上面的场景，让我们从创建索引开始。我们可以创建两个索引。</p><ul class=""><li id="01a1" class="nm nn it lb b lc ld lf lg li oa lm ob lq oc lu nr ns nt nu bi translated">目标—仅在目标字段上创建索引。</li><li id="7480" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">目的地、始发地和订房号——我们可以用序列<code class="fe oe of og oh b">destination</code>、<code class="fe oe of og oh b">origin</code>和<code class="fe oe of og oh b">booking_no</code>字段创建一个复合索引。</li></ul><p id="1fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于如何创建索引，请参考下面的命令。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="988c" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">无投影查询</h2><p id="d7c3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我们开始查询目的地为“Gerlachmouth”的预订。下面的屏幕截图显示了查询的执行时间。如你所见，总执行时间减少到了<strong class="lb iu"> 5ms </strong>。与没有索引的相比，它几乎快了100倍。</p><p id="7b79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能对这种性能感到满意，但这并不是优化的终点。我们可以提高查询性能，使用<strong class="lb iu">覆盖的查询</strong>比没有索引的查询<strong class="lb iu">快250倍。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/f1fcc953dc20f88135446b09bb3a9474.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*_07K8c-uv2n9X9cahQnEGQ.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ea23" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">带投影的查询(覆盖查询)</h1><p id="1fb6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用覆盖查询意味着我们正在查询被索引的字段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="8b3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用上面的命令，我们能够将查询优化到<strong class="lb iu"> 2ms </strong>，这比<strong class="lb iu">快了大约60%</strong>,而无需在索引字段上使用投影。</p><p id="595c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了改进执行时间，我们还改进了查询策略。从截图中，我们可以看到我们没有检查任何文档，这意味着索引本身已经足以满足查询。因此，这总体上提高了查询性能，因为我们不必获取文档。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/cbe8788ea9b25d40cc230db7d2e6acf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*R24vSTP-N7x_kfh2ucWr-g.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b7ad" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="3ade" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">以下是这篇文章的要点。</p><ul class=""><li id="9db0" class="nm nn it lb b lc ld lf lg li oa lm ob lq oc lu nr ns nt nu bi translated">除非使用索引可以满足所有返回的字段，否则投射较少的字段不会提高查询性能。</li><li id="0fa1" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">索引可以提高性能，但是覆盖查询可以提升查询性能。</li><li id="7d65" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">覆盖查询的执行速度比使用索引扫描的普通优化查询快60%。</li></ul><p id="462a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。下一篇文章再见。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b841" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ul class=""><li id="8735" class="nm nn it lb b lc mu lf mv li no lm np lq nq lu nr ns nt nu bi translated">查询中的项目字段— MongoDB <a class="ae ky" href="https://docs.mongodb.com/manual/tutorial/project-fields-from-query-results/" rel="noopener ugc nofollow" target="_blank">文档</a></li><li id="75d2" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">来自<a class="ae ky" href="https://dba.stackexchange.com/questions/198444/how-mongodb-projection-affects-performance" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>的详尽解释</li><li id="0566" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">解释输出— MongoDB <a class="ae ky" href="https://docs.mongodb.com/manual/reference/explain-results/#executionstats" rel="noopener ugc nofollow" target="_blank">文档</a></li></ul></div></div>    
</body>
</html>