<html>
<head>
<title>Kubernetes Pod Redundancy Strategies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes Pod冗余策略</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kubernetes-pod-redundancy-strategies-a6d9b560749a?source=collection_archive---------9-----------------------#2020-08-18">https://betterprogramming.pub/kubernetes-pod-redundancy-strategies-a6d9b560749a?source=collection_archive---------9-----------------------#2020-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5579" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">分布式系统中的故障防范策略</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c478b21d99386e2a31a397e577b12652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hbDpHkcBTCrHJ9Jw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">米歇尔·格里斯特在Unsplash<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">上拍摄的照片。</a></p></figure><p id="e366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在分布式系统中，不可避免地会出现一些故障，我们应该像正常情况一样进行规划。这个问题的一个解决方案是运行一个服务的多个实例。这样，如果一个失败，其他人可以接管。</p><p id="1f7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探索在<a class="ae ky" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a> (K8s)上实现这一点的一些不同方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="64fd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">没有人</h1><p id="3f0e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">冗余是有成本的，在决定我们需要多大的弹性时，我们应该考虑这一点。如果您的客户可以忍受少量的中断，并且不会对他们的体验产生太大影响，那么您可能不需要任何中断。</p><p id="d445" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当谈到一项服务的正常运行时间时，通常用9来表示(例如99.9%的正常运行时间)。这意味着每1000个请求中，只有一个会失败。根据经验，每增加9项服务，就要花费10倍的成本。</p><p id="53dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要您的应用程序不经常崩溃，您就可以运行一个pod，并在出现问题时依靠K8s重新调度它。这确实假设一个pod可以处理服务正在接收的负载。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1338" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">普通</h1><p id="aa8b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当您的服务开始需要更多的pod来处理负载时，您可以向外扩展。如果流量情况随时间变化(例如午餐高峰)，您应该有足够的pod来处理高峰时间的负载。这种策略只会在pod接收的流量明显减少时为您提供更多弹性。</p><p id="ce3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个pod在高峰时间出现故障，请求将分散到剩余的pod上，并有可能淹没它们。在交通流量较低的时候，剩余的吊舱可能有足够的容量来处理负载。</p><p id="4482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当谈到缩放时，您可能会听到术语<em class="mz"> in </em>、<em class="mz"> out </em>、<em class="mz"> up </em>和<em class="mz"> down </em>。通常，向上和向下扩展意味着保持相同数量的实例，但是增加服务器的CPU和/或内存。进出是引入或移除服务实例但保持资源不变的过程。这允许您进一步扩展，因为您可能会受到可以使用的最大CPU或内存的限制。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="da66" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">N + 1</h1><p id="6e4e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">和前面的<code class="fe na nb nc nd b">n</code>一样，我们需要了解需要多少个pod来处理高峰流量。这一次，我们增加了一个额外的吊舱。这为我们提供了保护，防止一个pod在高峰时间出现故障。这种恢复能力的成本是一个pod的成本，因为这是额外的，只在故障情况下需要。如果一个单元可以处理所有的流量，您应该还有一个额外的单元。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ded6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">缩放比例</h1><p id="7f51" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以让K8s为我们做这件事，而不是手动计算高峰期我们需要的吊舱数量。给定一个扩展指标，K8s可以根据当前需求扩展和缩小我们的服务。这通过在需求较低时缩减规模，在我们需要时增加规模来降低成本。扩展本身并不能让我们从pod故障中恢复过来，但确实可以应对不断增长的需求。让pods在内存和CPU方面保持较小，可以让我们更精确地扩展，并进一步削减成本。</p><p id="4731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关如何确定何时扩展服务的信息，请查看我关于K8s自动扩展的<a class="ae ky" href="https://itnext.io/performance-testing-for-kubernetes-autoscaling-ed6418cf6f70" rel="noopener ugc nofollow" target="_blank">性能测试的文章。</a></p><p id="a508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当扩展服务时，您应该包括一些扩展空间，这意味着您不应该将您的pod推到极限。您的pod需要一些时间来启动，自动缩放指标会定期计算。您的应用程序需要能够处理请求纵向扩展和实际纵向扩展之间的请求。如果你有很多吊舱，净空会缩小，因为它分散在所有吊舱。</p><p id="dffa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">水平Pod自动缩放器(HPA)用于自动缩放我们在K8s中的服务。关于如何设置的更多信息，请查看<a class="ae ky" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank">文档</a>。有关哪些指标不适合用于自动缩放的更多信息，请查看本文。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d219" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">75%缩放</h1><p id="3ec3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一旦我们实现了自动扩展，并且知道何时应该扩展我们的服务，我们就可以控制我们需要多少弹性。通过以75%的服务容量进行扩展，我们可以失去25%的pod，并且只能达到容量。我们拥有的豆荚越多，我们失去的豆荚就越多——但我们为未充分利用的豆荚付出的代价也就越多。当运行大量的pod时，您可以考虑降低弹性百分比，因为您仍然有大量的pod可能会出现故障。</p><p id="9ae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个服务的流量曲线特别尖锐，这种技术就特别有用。对于自动缩放来说，尖峰可能是一个特别麻烦的问题，因为它们可能非常短暂，以至于自动缩放器没有时间做出反应。如果您大致知道峰值有多大，您可以将它计划到服务扩展的地方。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a361" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">缩放+ N</h1><p id="c2fc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们想更精确地控制我们的冗余，我们可以扩展容量，然后引入额外的单元。这将允许<code class="fe na nb nc nd b">n</code>吊舱失败，但仍然给我们留下足够的容量。这使我们能够准确控制我们支付多少冗余吊舱。</p><p id="c948" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">K8s服务使用标签来决定pods的请求被路由到哪个pods。这允许我们部署具有不同配置的相同服务的两个副本集。一个副本集将使用水平pod自动缩放器进行缩放，而我们将配置另一个副本集，使其具有<code class="fe na nb nc nd b">n</code>pod。两个副本集将使用相同的标签标记pod，并且服务将路由到该标签。该服务将在所有单元之间平均分配流量，允许服务扩展，同时保持<code class="fe na nb nc nd b">n</code>冗余单元。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6449" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">多个集群</h1><p id="744f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">更进一步，我们可以将我们的应用程序部署到两个K8s集群上。这将允许整个集群出现故障，但仍能维持服务。负载平衡器将位于集群的前端，并在集群之间路由流量。如果您在云提供商(如AWS)上托管集群，该集群会自动跨多个可用性区域进行部署。这可以防止物理故障，如断电、自然灾害或更糟的情况，因此需要有一个好的理由来拥有多个集群。</p><p id="c444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当运行多个集群时，自动扩展变得更具挑战性，因为扩展指标通常不会在集群间共享。如果某个集群确实发生故障，仍在工作的集群将会收到来自故障集群的所有流量，而不会引起任何注意。有多种方法来处理这种负载的突然增加。您的自动伸缩可能能够足够快地做出反应来处理流量，或者您可能会在规模扩大时受到影响并降低性能。</p><p id="58a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据需要多少冗余，集群可以以主动-被动模式运行，这意味着一个集群接收所有请求。在这种设置中，服务必须从零开始纵向扩展，除非跨集群共享扩展指标。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9c33" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数量与冗余</h1><p id="9451" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你拥有的吊舱越多，一个吊舱的故障对其他吊舱的影响就越小。假设我们有10个可以服务100个rps的pod。如果我们以90rps的速度扩展，并且一个pod出现故障，剩余的pod将收到100rps，使它们达到最大值。如果我们有20个吊舱，其中一个出现故障，剩下的吊舱将只需要处理95个rps。这两种场景都假设服务接收的请求数量正好是服务应该扩展的数量。实际上，如果服务试图扩大规模，服务通常会收到稍少或稍多的流量。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7e83" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="c37c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">自动缩放是一件复杂的事情，有很多选项需要考虑。我希望您能更好地了解您可用的选项，并利用这些选项来降低您的云账单成本，同时保持服务正常运行。</p><p id="be3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>