<html>
<head>
<title>Meet Gain— the New Fastest Go TCP Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">满足增益—最新最快的TCP框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/gain-the-new-fastest-go-tcp-framework-40ec111d40e6?source=collection_archive---------1-----------------------#2022-07-07">https://betterprogramming.pub/gain-the-new-fastest-go-tcp-framework-40ec111d40e6?source=collection_archive---------1-----------------------#2022-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4c12" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看看我的开源项目</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/9db98d67dcadb17482250d8263e31270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*_VCw4aylvgS_sT0xTbIkaw.png"/></div></figure><p id="7a82" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一开始，我计划了一篇关于我的高性能TCP框架的很长的文章——the Gain，这篇文章将在框架在Github上发布的同时发表。但是当我在增益上工作的时候，我意识到我想要在文章中提到多少令人兴奋的事情。因此我决定发表一系列文章。本文是第一部分，也是引言部分。它包含了增益创作的起源，一些背景，和我的项目决策。最后，有基准测试的结果。</p><p id="728c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们从创世纪开始。开发高性能服务一直是我感兴趣的领域之一。几年前，我对公司的一个后端系统进行了大量优化。</p><p id="da92" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">长话短说，我把CPU负载降低了100多倍(！)在某些情况下，平均内存消耗超过10倍。我花了很多时间想出如何以那种方式改进我们的系统。</p><p id="f424" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">不幸的是，有一些我无法改变的技术限制(超过一个就非常讨厌)和无法偿还的技术债务。这两件事使得一些众所周知的解决方案无法实施，唯一的办法就是创建一个定制的系统。</p><p id="7652" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我在空闲时间准备了一份概念证明(因为软件开发不仅是我的工作，也是我的激情所在)，然后向公司的人展示了基准测试结果。这是一个迅速的决定。我的设计得到了批准，一两个月后，我们系统的新版本投入生产。</p><p id="d9df" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">除了获得有价值的知识和经验之外，那个项目还教会了我两件事:性能优化可能非常具有挑战性，也非常有趣。因为我喜欢挑战，并且现在有了更多的经验(不仅是高级网络应用程序编程，也包括低级网络编程)，我决定在那个项目之后的几年里验证我现在的技能。我有几个想法，但最终，赢家是开发一个TCP(和UDP)很快。Hello HTTP/3)在性能方面胜过别人的框架。</p><h1 id="92f8" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">基准</h1><p id="cf3a" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">我相信每个对高性能TCP/HTTP应用程序感兴趣的程序员都知道TechEmpower Benchmark。</p><p id="6795" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">对于那些不了解的人来说，这是对许多执行基本任务(如JSON序列化、数据库访问和服务器端模板合成)的web应用程序框架的性能比较。我知道—基准测试结果可能会在某种程度上产生误导。</p><p id="055f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现实世界中的案例可能与基准测试中测试的案例大相径庭。此外，基准测试通常测试高峰性能，这通常不是商业项目中的基本特征。它不如低CPU使用率、低内存消耗或非常低的延迟那样令人满意。<br/>这是一个个人挑战，主要目标是检查是否有机会开发出比TE基准测试更快的框架。出于本系列文章的目的和对我的框架性能的度量，我将重点放在“明文”测试类型上。这是一个简单的例子，HTTP服务器用JSON数据进行响应。这里对它的描述是<a class="ae mg" href="https://github.com/TechEmpower/FrameworkBenchmarks/wiki/Project-Information-Framework-Tests-Overview#plaintext" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="6ca9" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">竞争对手</h1><p id="b165" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">当您查看TE基准测试的最后一次运行时(<a class="ae mg" href="https://www.techempower.com/benchmarks/#section=test&amp;runid=edd8ab2e-018b-4041-92ce-03e5317d35ea&amp;hw=ph&amp;test=plaintext&amp;a=2" rel="noopener ugc nofollow" target="_blank"> <strong class="kp ir">这里是</strong> </a>)，您可以看到几个框架有几乎相同的结果。因此，为所有顶级框架运行基准测试毫无意义。因此，我选择了两个竞争者:</p><ul class=""><li id="fd47" class="mh mi iq kp b kq kr kt ku kw mj la mk le ml li mm mn mo mp bi translated">因为它是最快的。用铁锈写的。正如作者所写的，它只有一个目标:“展示单节点性能的上限，同时在生产环境中保持可用。”当您查看源代码时，可以看到作者尽可能地进行了大量优化。</li><li id="8851" class="mh mi iq kp b kq mu kt mv kw mw la mx le my li mm mn mo mp bi translated"><code class="fe mq mr ms mt b">gnet</code> <strong class="kp ir"> </strong> —用Go写的最快的TCP/UDP框架。它可以在两种模式下运行:反应器模式和复用端口模式。在第一种情况下，一个线程(接受者)负责接受连接并将它们转发给独立的线程(反应者)。在第二个例子中，没有受体。相反，所有线程都有相同的职责。它们都接受连接和读/写数据。</li></ul><h1 id="af77" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">后端</h1><p id="c4b6" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">所有这些框架都是建立在Linux epoll API之上的。我不会描述它是如何工作的。许多文章可能比我做得更好。</p><p id="dc0e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">对于本文，最重要的是要知道epoll是一个快速的解决方案，但它有一些警告——特别是在Spectre/Meltdown时期，此时系统调用不如以前便宜。因此，另一个API诞生了— <code class="fe mq mr ms mt b">io_uring</code>。对于异步I/O来说，这是一个相对较新的接口。使用用户空间和内核之间共享的环形缓冲区实现了两个队列:</p><ul class=""><li id="ac19" class="mh mi iq kp b kq kr kt ku kw mj la mk le ml li mm mn mo mp bi translated">提交队列(SQ)，</li><li id="0ab6" class="mh mi iq kp b kq mu kt mv kw mw la mx le my li mm mn mo mp bi translated">完成队列(CQ)。</li></ul><p id="b0b3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">应用程序用一个或多个SQ条目填充第一个。然后内核消耗所有的请求，并创建完成事件，如果它们中的任何一个完成的话。完成事件总是与特定的SQE相关联，但是可能以任何顺序到达。如果您想了解更多关于io uring的信息，有许多很好的资源:</p><ul class=""><li id="dd78" class="mh mi iq kp b kq kr kt ku kw mj la mk le ml li mm mn mo mp bi translated"><a class="ae mg" href="https://unixism.net/loti/what_is_io_uring.html" rel="noopener ugc nofollow" target="_blank">UNIX ism——月神之王</a></li><li id="1ec4" class="mh mi iq kp b kq mu kt mv kw mw la mx le my li mm mn mo mp bi translated"><a class="ae mg" href="https://kernel.dk/io_uring.pdf" rel="noopener ugc nofollow" target="_blank">高效io和IO期间</a></li><li id="2bf4" class="mh mi iq kp b kq mu kt mv kw mw la mx le my li mm mn mo mp bi translated"><a class="ae mg" href="https://blogs.oracle.com/linux/post/an-introduction-to-the-io-uring-asynchronous-io-framework" rel="noopener ugc nofollow" target="_blank">异步I/O框架介绍</a></li></ul><h1 id="ab86" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">程序设计语言</h1><p id="412b" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">从一开始我就考虑了两种编程语言:Go和Rust。两者都是现代的，非常快的语言，两者也各有利弊。生锈一般比较快。它的性能与C++的性能相当。有趣的是，它保证了内存安全。</p><p id="272b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有一个特性叫做所有权。所有权是一组编译器规则。如果违反了以下任何规则，程序将无法编译:</p><ol class=""><li id="b527" class="mh mi iq kp b kq kr kt ku kw mj la mk le ml li mz mn mo mp bi translated">Rust中的每个值都有一个称为其所有者的变量。</li><li id="4f78" class="mh mi iq kp b kq mu kt mv kw mw la mx le my li mz mn mo mp bi translated">一次只能有一个所有者。</li><li id="3fb3" class="mh mi iq kp b kq mu kt mv kw mw la mx le my li mz mn mo mp bi translated">当所有者超出范围时，该值将被丢弃。</li></ol><p id="8d22" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Golang使用了一个更流行的解决方案来达到同样的目的——垃圾收集器。因为GC在运行时工作，所以对程序性能有影响。许多技术可以帮助减少GC的开销，但是释放内存仍然比Rust慢。这两种语言还有另一个显著的区别。Rust几乎可以毫无痛苦地绑定到本地库。从Rust调用C代码也没有固有的开销。为什么重要？因为io_uring的主要实现是用c写的，它叫做<code class="fe mq mr ms mt b">liburing</code>，由《io_uring architecture》作者Jens Axboe维护。另一方面，Golang有一个名为CGO的特性。不幸的是，这个解决方案没有预期的快，从Go调用C代码很慢。</p><p id="f9cd" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">所以，语言的选择似乎很简单。不一定。看起来使用Rust和提到的<code class="fe mq mr ms mt b">liburing</code>库是最好的选择，但是在这个特殊的例子中，主要的目标是从Linux和io_uring中榨取尽可能多的东西。为此，您需要对自己选择的编程语言有深入的了解，并对内核端IO机制有透彻的理解。我对围棋的经验比Rust多得多，所以在这方面，围棋是更好的选择。上面提到的用C写的io uring API呢？CGO通不过测试，所以解决方案可能是……用GO写一个类似的API。Go用户有一个低级的sys/unix包，其中包含调用syscalls的函数，还有一个不安全的包，其中允许手动分配内存。我仔细看了一遍liburing代码，自信这两个包足够了。由于这不是一个商业项目，没有必要节省工时，我可以走更长的路。在Go中编写库帮助我理解了如何更好地运行，现在回想起来，我认为这是正确的决定。</p><h1 id="45cc" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">基准环境</h1><p id="55db" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">硬件:</p><ul class=""><li id="7bc6" class="mh mi iq kp b kq kr kt ku kw mj la mk le ml li mm mn mo mp bi translated">服务器:AWS m6i.xlarge实例，4个vCPU，16 GB RAM</li><li id="3dc3" class="mh mi iq kp b kq mu kt mv kw mw la mx le my li mm mn mo mp bi translated">客户机:AWS m6i . 2x大型实例，8个vCPU，32 GB RAM，与服务器位于集群放置组中的同一可用性区域</li></ul><p id="b843" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">软件:</p><ul class=""><li id="abf2" class="mh mi iq kp b kq kr kt ku kw mj la mk le ml li mm mn mo mp bi translated">Ubuntu 22.04</li><li id="457f" class="mh mi iq kp b kq mu kt mv kw mw la mx le my li mm mn mo mp bi translated">内核:5 . 15 . 0–1004-AWS</li><li id="34a9" class="mh mi iq kp b kq mu kt mv kw mw la mx le my li mm mn mo mp bi translated">去1.18</li></ul><p id="4ab2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">配置:</p><ul class=""><li id="5f68" class="mh mi iq kp b kq kr kt ku kw mj la mk le ml li mm mn mo mp bi translated">512个连接</li><li id="fd25" class="mh mi iq kp b kq mu kt mv kw mw la mx le my li mm mn mo mp bi translated">8个线程，每个vCPU一个</li><li id="ea9a" class="mh mi iq kp b kq mu kt mv kw mw la mx le my li mm mn mo mp bi translated">5秒钟热身，然后进行三次测试，每次10秒钟</li></ul><h1 id="e5d5" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">基准测试结果</h1><p id="d049" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">我已经为每个框架运行了三次基准测试。每次运行的结果总是非常相似。下面你可以看到最好的。</p><h2 id="e19a" class="na lk iq bd ll nb nc dn lp nd ne dp lt kw nf ng lv la nh ni lx le nj nk lz nl bi translated"><strong class="ak"> Gnet </strong></h2><pre class="kg kh ki kj gt nm mt nn no aw np bi"><span id="97e5" class="na lk iq mt b gy nq nr l ns nt">ubuntu@ip-xx-xx-xx-xx:<strong class="mt ir">~</strong>$  wrk -t8 -c512 -d10s http://3.68.71.17:8080/plaintext  <br/>Running 10s test @ http://3.68.71.17:8080/plaintext  <br/> 8 threads and 512 connections  <br/> Thread Stats   Avg      Stdev     Max   +/- Stdev  <br/>   Latency     1.45ms  544.73us  23.69ms   90.78%  <br/>   Req/Sec    44.76k     3.50k   94.66k    97.64%  <br/> 3579707 requests in 10.10s, 440.39MB read  <br/>Requests/sec: 354443.98  <br/>Transfer/sec:     43.61MB</span></pre><h2 id="9135" class="na lk iq bd ll nb nc dn lp nd ne dp lt kw nf ng lv la nh ni lx le nj nk lz nl bi translated"><strong class="ak"> FaF </strong></h2><pre class="kg kh ki kj gt nm mt nn no aw np bi"><span id="8926" class="na lk iq mt b gy nq nr l ns nt">ubuntu@ip-xx-xx-xx-xx:<strong class="mt ir">~</strong>$ wrk -t8 -c512 -d10s http://3.68.71.17:8089/plaintext  <br/>Running 10s test @ http://3.68.71.17:8089/plaintext  <br/> 8 threads and 512 connections  <br/> Thread Stats   Avg      Stdev     Max   +/- Stdev  <br/>   Latency     1.30ms    0.91ms  72.42ms   94.50%  <br/>   Req/Sec    50.14k     5.43k  167.49k    98.63%  <br/> 4005379 requests in 10.10s, 481.30MB read  <br/>Requests/sec: 396598.02  <br/>Transfer/sec:     47.66MB</span></pre><h2 id="75c0" class="na lk iq bd ll nb nc dn lp nd ne dp lt kw nf ng lv la nh ni lx le nj nk lz nl bi translated"><strong class="ak">增益</strong></h2><pre class="kg kh ki kj gt nm mt nn no aw np bi"><span id="c898" class="na lk iq mt b gy nq nr l ns nt">ubuntu@ip-xx-xx-xx-xx:<strong class="mt ir">~</strong>$ wrk -t8 -c512 -d10s http://3.68.71.17:8765/plaintext  <br/>Running 10s test @ http://3.68.71.17:8765/plaintext  <br/> 8 threads and 512 connections  <br/> Thread Stats   Avg      Stdev     Max   +/- Stdev  <br/>   Latency     1.08ms  253.02us  33.56ms   96.90%  <br/>   Req/Sec    58.16k     3.12k  138.32k    97.88%  <br/> 4634736 requests in 10.10s, 570.18MB read  <br/>Requests/sec: 458908.65  <br/>Transfer/sec:     56.46MB</span></pre><p id="0890" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下面的条形图比较了每个框架每秒的请求数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/fdf92596230e4496bf86ef53ef445a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*WQ7E9F6EffKhvqIBgrqUfg.png"/></div></figure><p id="4b8e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如您所见，这一收益甚至超过了TE基准测试中最快的服务器。其结果比gnet好近30%，比FaF好近16%。也许它并不突出，但我们谈论的是一个基于io _ uring的框架，在不久的将来，它应该会更快，Gain应该会从中受益。我非常感谢Jenx Axboe和所有的贡献者。他们已经做了很好的工作，并且一直在努力改进iouring。因为我在增益上的工作仍在进行中，并且有一些事情我会改进，它还不可用，但会很快发布。</p><p id="490b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">此外，还发布了具有一些令人兴奋的特性的新Linux内核(尤其是在版本5.18和5.19中)和一个新的liburing版本(2.2)。所以在发布之前，我还想检查这些新内核的性能，并实现(可能)新的操作系统特性。在下一篇文章中，我将描述Gain架构，并解释性能优化，敬请关注！</p><p id="1784" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">编辑:<br/>Gain的Alpha版本在GitHub上发布。</p><div class="nv nw gp gr nx ny"><a href="https://github.com/pawelgaczynski/gain" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">GitHub-pawelgaczynski/Gain:Gain是一个高性能的网络框架</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">Gain是一个完全用Go编写的高性能网络框架。它使用io——一种新的异步I/O API…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kl ny"/></div></div></a></div></div></div>    
</body>
</html>