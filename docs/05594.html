<html>
<head>
<title>Abstract Classes and Metaclasses in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的抽象类和元类</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/abstract-classes-and-metaclasses-in-python-9236ccfbf88b?source=collection_archive---------6-----------------------#2020-07-21">https://betterprogramming.pub/abstract-classes-and-metaclasses-in-python-9236ccfbf88b?source=collection_archive---------6-----------------------#2020-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b6c1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python来扩展Python</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6cfd2628e593291dd4b438c1009a29cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YEZUPJ_GzrhEv7l-.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://pixabay.com/users/piro4d-2707530/" rel="noopener ugc nofollow" target="_blank"> PIRO4D </a>在<a class="ae ky" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄的照片。</p></figure><p id="850f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">抽象类(或接口)是面向对象设计的重要组成部分。虽然Python不是纯粹的OOP语言，但它在抽象和元类方面提供了非常健壮的解决方案。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="90c7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">抽象类</h1><p id="0556" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">简而言之，抽象类是不能实例化的类。这是因为抽象类没有指定特性的实现。相反，您只需指定方法签名和属性类型(有时)，并且每个子类都必须提供自己的实现。请注意，仍然有可能为<em class="mz">提供一些</em>实现。例如，抽象类可以实现默认的构造函数。</p><p id="84ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在设计复杂系统以限制重复和加强一致性时，抽象非常有用。例如，你可能有一个<code class="fe na nb nc nd b">Renderer</code>抽象类，它实现了<code class="fe na nb nc nd b">3DRenderer</code>、<code class="fe na nb nc nd b">2DRenderer</code>和<code class="fe na nb nc nd b">HapticRenderer</code>。然后，负责生成渲染数据的代码不需要知道特定的渲染器。它只是把他们都称为<code class="fe na nb nc nd b">Renderer</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="695b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">ABC模块</h1><p id="b9d6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Python中，抽象是通过内置库中的<code class="fe na nb nc nd b">abc</code>模块实现的。这是如何使用它的最简单的例子:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="b7b4" class="ni md it nd b gy nj nk l nl nm">from abc import ABC class AbstractRenderer(ABC): <br/>    pass</span></pre><p id="58f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">abc</code>模块公开了<code class="fe na nb nc nd b">ABC</code>类，代表<code class="fe na nb nc nd b">A</code>抽象<code class="fe na nb nc nd b">B</code>类<code class="fe na nb nc nd b">C</code>类。因此，任何直接继承<code class="fe na nb nc nd b">ABC</code>类的类都是抽象的。但是如果没有抽象方法，它就没有多大用处:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="9e90" class="ni md it nd b gy nj nk l nl nm">from abc import ABC, abstractmethod </span><span id="09ca" class="ni md it nd b gy nn nk l nl nm">class AbstractRenderer(ABC): <br/>    @abstractmethod def render(self, data): <br/>        raise NotImplementedError()</span></pre><p id="20ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们定义了<code class="fe na nb nc nd b">render</code>抽象方法，因此有了<code class="fe na nb nc nd b">@abstractmethod</code>装饰器。在它的身体里，我们升起<code class="fe na nb nc nd b">NotImplementedError</code>作为安全预防措施。从理论上讲，应该连调用这个方法都不可能。如果您尝试实例化<code class="fe na nb nc nd b">AbstractRenderer</code>，您将得到一个错误:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="297d" class="ni md it nd b gy nj nk l nl nm">&gt;&gt;&gt; renderer = AbstractRenderer() <br/>&gt;&gt;&gt; Traceback (most recent call last): <br/>File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: <br/>Can't instantiate abstract class AbstractRenderer with abstract methods render</span></pre><p id="c281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除非在一个抽象类中有每个<code class="fe na nb nc nd b">abstractmethod</code>的具体实现，否则你将无法实例化它。下面是如何实现它:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="4a21" class="ni md it nd b gy nj nk l nl nm">class 3DRenderer(AbstractRenderer): <br/>    def render(self, data): <br/>        some_library.draw_3d_stuff(data) </span><span id="8442" class="ni md it nd b gy nn nk l nl nm">renderer = 3DRenderer() <br/>renderer.render(some_data)</span></pre><p id="bd13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了方法，还可以指定抽象属性(注意<code class="fe na nb nc nd b">property</code>不是<code class="fe na nb nc nd b">abc</code>的一部分):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2777" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们定义了<code class="fe na nb nc nd b">engine</code>抽象属性。第一个函数(用<code class="fe na nb nc nd b">@property</code>装饰)是getter，用<code class="fe na nb nc nd b">@engine.setter</code>装饰的是setter。稍后，您必须同时实现这两个功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0a67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仔细看看这里实现的getter和setter。请注意，setter将引擎字符串改为大写。这是一个使用<code class="fe na nb nc nd b">property</code>覆盖默认Python行为以及使用<code class="fe na nb nc nd b">abc</code>的例子。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2946" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">元类</h1><p id="b4ff" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如您刚才看到的，Python的抽象类实现与您在其他流行语言中看到的不同。这是因为抽象不是语言语法的一部分。相反，它被实现为一个库。接下来的逻辑问题是“你能自己做类似的事情吗，纯粹用Python？”答案是肯定的。</p><p id="5e95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在转到元类之前，您需要先了解一些关于类的东西。你可能认为类是对象创建的蓝图，你可能是对的。但是在Python中，类本身就是<em class="mz">对象</em>。例如，当运行以下代码时:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="df93" class="ni md it nd b gy nj nk l nl nm">class YouExpectedMeToBeAClass: <br/>    pass</span></pre><p id="e25a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python将<em class="mz">实例化</em>一个<code class="fe na nb nc nd b">YouExpectedMeToBeAClass</code>类，并将这个“对象”存储在内存中。稍后，当您在创建对象时引用该类时，Python将使用该“对象”但是Python如何实例化一个类呢？当然是通过使用元类。</p><p id="87c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">元类是类的类。元类为类的创建提供了蓝图。默认情况下，每个类都有一个元类(称为<code class="fe na nb nc nd b">type</code>)。要创建自定义元类，您必须继承<code class="fe na nb nc nd b">type</code>:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="a2d0" class="ni md it nd b gy nj nk l nl nm">class CustomMeta(type): <br/>    pass </span><span id="b462" class="ni md it nd b gy nn nk l nl nm">class SomeClass(metaclass=CustomMeta): <br/>    pass</span></pre><p id="b097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mz">注:</em> <code class="fe na nb nc nd b"><em class="mz">type</em></code> <em class="mz">的父类是</em> <code class="fe na nb nc nd b"><em class="mz">type</em></code> <em class="mz">本身。这是Python内部的一个hack，用纯Python不可能实现替代的</em> <code class="fe na nb nc nd b"><em class="mz">type</em></code> <em class="mz">。</em></p><p id="d60c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">CustomMeta</code>本身什么也不做。让我们添加更多的特性来展示元类的威力。让我们让<code class="fe na nb nc nd b">CustomMeta</code>检查是否每个子类都有一个<code class="fe na nb nc nd b">render</code>属性(就像<code class="fe na nb nc nd b">AbstractRenderer</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0e00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您试图运行这段代码(甚至没有实例化任何东西！)，它会抛出一个错误。我先解释一下<code class="fe na nb nc nd b">__new__</code>是什么。这是类的构造函数，就像对象的<code class="fe na nb nc nd b">__init__</code>。它在定义<code class="fe na nb nc nd b">SomeClass</code>的时候被调用，从这个函数返回的任何东西都成为这个类。这些参数是:元类(<code class="fe na nb nc nd b">cls</code>)、新类的名称(<code class="fe na nb nc nd b">clsname</code>)、父类(<code class="fe na nb nc nd b">bases</code>)和属性(<code class="fe na nb nc nd b">attrs</code>)。在函数体中，我们枚举属性并检查<code class="fe na nb nc nd b">render</code>是否是其中之一。如果不是，则引发一个异常。要运行这段代码，将这段代码添加到<code class="fe na nb nc nd b">SomeClass</code>:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="9da3" class="ni md it nd b gy nj nk l nl nm">def render(self): pass</span></pre><p id="3277" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常简单的例子，说明了<code class="fe na nb nc nd b">abc</code>模块在幕后做了什么。如果你有兴趣了解更多，可以在GitHub 上的<a class="ae ky" href="https://github.com/python/cpython/blob/master/Lib/abc.py" rel="noopener ugc nofollow" target="_blank">获得</a><a class="ae ky" href="https://github.com/python/cpython/blob/master/Lib/abc.py" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c68c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结束语</h1><p id="64d4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">感谢您的阅读。我希望你喜欢我的文章。如果你在评论中有元类的用例，请告诉我！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e42a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="dbb5" class="nq nr it lb b lc mu lf mv li ns lm nt lq nu lu nv nw nx ny bi translated"><a class="ae ky" href="https://docs.python.org/3/library/abc.html" rel="noopener ugc nofollow" target="_blank"> abc文档</a></li><li id="bafd" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae ky" href="https://docs.python.org/3/reference/datamodel.html" rel="noopener ugc nofollow" target="_blank"> Python数据模型</a></li></ul></div></div>    
</body>
</html>