<html>
<head>
<title>Exploring an Object-Oriented Jenkins Pipeline for Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索面向对象的Jenkins管道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-an-object-oriented-jenkins-pipeline-for-terraform-182130111ddf?source=collection_archive---------8-----------------------#2022-09-26">https://betterprogramming.pub/exploring-an-object-oriented-jenkins-pipeline-for-terraform-182130111ddf?source=collection_archive---------8-----------------------#2022-09-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2cd1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Jenkins多级Terraform CD流水线中一种改进CI/CD粒度的新型体系结构设计</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b8d085cbdeea9352c7651dc7938be508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6oCwkTfcypnKW9nzVsptcg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.toptal.com/devops/terraform-jenkins-continuous-deployment" rel="noopener ugc nofollow" target="_blank">来自TopTal的图像</a></p></figure><p id="a6d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，当我们执行<code class="fe ls lt lu lv b">terraform plan</code>、<code class="fe ls lt lu lv b">terraform destroy</code>或<code class="fe ls lt lu lv b">terraform apply</code>时，我们将这些动作应用于我们的目标文件中的所有资源，通常是<code class="fe ls lt lu lv b">main.tf</code>(您可以为文件使用任何名称，但这个名称只是作为惯例使用)。</p><p id="3a3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在CI/CD时代，当我们拥有从数据、应用程序代码到基础设施代码的所有管道时，通常很难达到这种粒度。通常，至少在Terraform中，为了实现这三个不同的动作，我们有三个不同的流水线来执行<code class="fe ls lt lu lv b">terraform plan</code> : <code class="fe ls lt lu lv b">terraform apply</code>和<code class="fe ls lt lu lv b">terraform destroy</code>。当我们选择某个动作(假设是<code class="fe ls lt lu lv b">terraform plan</code>)时，这个动作会在管道内的所有阶段和所有资源上执行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/01fbe56ece63bbaba88fa758d77c3c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*NhmoJyRrqTuF5pTiAU9qOA.png"/></div></figure><p id="8e7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是当我们观察所有这些管道时，有一个共性可以被抽象出来以创建一个共性，在这个共性上动态的本质可以被继承。正如我们创建一个类，使用不同的对象和不同的属性值可以建立，是否有可能创建一个类似的基类(读管道),当实例化时可以创建不同的管道对象？</p><blockquote class="lx"><p id="c4c9" class="ly lz iq bd ma mb mc md me mf mg lr dk translated">###一个管道创建所有这些内容# # #</p></blockquote><h1 id="6966" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">模块化基础设施</h1><p id="49e0" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">为了构建这个基于类的管道，我们首先需要创建一个terraform脚本。开发的这个脚本应该是松散耦合的，本质上应该是模块化的。为此，我们创建了这个模块化脚本，它有三个模块，分别名为“网络”、“计算”和“通知”每个模块创建的组件如下:</p><ol class=""><li id="7129" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">网络:1个VPC和1个子网</li><li id="a4a0" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">计算:1个IAM角色，1个Lambda，1个EC2 t2.micro实例</li><li id="c1b4" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">通知:1个SNS主题和1个电子邮件订阅</li></ol><p id="9237" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">文件结构如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/e8a053d6814718278d4707a039dee928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*5iOy0OMEhYjvBlzrDDjZtA.png"/></div></figure><p id="6654" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">准备好之后，让我们在Jenkins文件中创建一个声明式的groovy脚本。</p><h1 id="8e93" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw nt jx mt jz nu ka mv kc nv kd mx my bi translated">基于类的Jenkins管道</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/b48e761e74e05e5d7c500a4ec0b41520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G0ebsNMTjI7FE-9jIQ-CQQ.png"/></div></div></figure><p id="bf6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了创建这种基于类的架构风格，以便在操作和资源级别灵活地创建管道对象，我们将利用Jenkins中一个名为“参数”的特性。这个特性帮助我们使用一个基类Jenkins管道创建多个对象。在本例中，让我们创建三个操作，即:</p><ul class=""><li id="3eee" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nx nk nl nm bi translated"><code class="fe ls lt lu lv b">terraform plan</code>:这创建并打印出我们将要在各自的提供者(可以是AWS、Kubernetes、GCP、Azure等)中创建的资源的计划。)</li><li id="6141" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nx nk nl nm bi translated"><code class="fe ls lt lu lv b">terraform apply</code>:这个命令在各自的提供者中创建资源，并创建一个状态文件，保存资源的当前状态。</li><li id="02b6" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nx nk nl nm bi translated"><code class="fe ls lt lu lv b">terraform destroy</code>:这将删除状态文件中列出的所有资源。</li></ul><p id="d4f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些操作在三个模块/资源上执行，即“网络”、“计算”和“通知”</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="58cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述参数为最终用户创建了一个UI，如下所示，这将帮助最终用户动态创建基本管道的对象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/f6eab9adae85265fa6a93bfa5f094705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*FIymz0EXRQpAJ-DBXNjbCA.png"/></div></figure><p id="331a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据所选择的行动和必须完成这些行动的资源，Jenkins将根据您的要求创建一个动态管道。在下图中，我们看到我们已经在#24中为网络和计算资源应用了terraform，并在#25中为网络和通知运行了<code class="fe ls lt lu lv b">terraform apply</code>。为了清理基础设施，我们在第26次运行中运行了<code class="fe ls lt lu lv b">terraform destroy</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/eefc8b786b50b985b5a2b52210690c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ozczWzf9I7WBcZYiE8UQ_g.png"/></div></div></figure><p id="83dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前实施的方法比持续部署更符合持续交付原则。</p><p id="ee22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于Jenkins文件和Terraform代码，请参考此<a class="ae kv" href="https://github.com/krishnaduttPanchagnula/Multifunctional-terraform-Jenkins-pipeline" rel="noopener ugc nofollow" target="_blank">链接</a>。</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt oj lv ok ol aw om bi"><span id="2e6f" class="on mi iq lv b gy oo op l oq or"><strong class="lv ir">Want to Connect?</strong></span><span id="63bf" class="on mi iq lv b gy os op l oq or">Feel free to reach out to my <a class="ae kv" href="https://www.linkedin.com/in/krishnadutt/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a> for interesting content and productive discussions.</span></pre></div></div>    
</body>
</html>