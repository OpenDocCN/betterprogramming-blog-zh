<html>
<head>
<title>Kubernetes For Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者的Kubernetes</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kubernetes-for-beginners-b3042e01ccff?source=collection_archive---------4-----------------------#2020-03-24">https://betterprogramming.pub/kubernetes-for-beginners-b3042e01ccff?source=collection_archive---------4-----------------------#2020-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d0c0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Kubernetes，面向更普通的观众</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/497918cff4a2492db34edceee467469b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ICfb_U811Cv88Jlo"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约瑟夫·巴里恩托斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e8fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>已经有一段时间了。正是这种领先的平台改变了我们今天看待信息技术的方式。该项目由一群谷歌开发人员发起，作为编排容器的一种方式，他们将容器开源给了云原生计算基金会。今天，它是最流行的系统之一，也是运行容器的事实上的标准。</p><p id="d980" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有各种各样的原因。我们将深入了解Kubernetes最初是什么，为什么它如此受欢迎，以及它用简单明了的语言解决了什么问题。要阅读本文，您不需要任何Kubernetes或容器方面的经验。我将逐一理清这些概念。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fcb1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是Kubernetes？</h1><p id="822c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们查看<a class="ae ky" href="https://en.wikipedia.org/wiki/Kubernetes" rel="noopener ugc nofollow" target="_blank">维基百科的定义</a>，我们会看到“Kubernetes是一个开源的容器编排系统，用于自动化应用程序的部署、扩展和管理。”</p><p id="21cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里主要有两个词:<em class="mz">容器</em>和<em class="mz">编排</em>。我们需要了解每一个是什么来理解Kubernetes。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="60b6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是容器？</h1><p id="e295" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Kubernetes 表示，“<strong class="lb iu">容器</strong>是一种技术，用于打包应用程序的(已编译)代码以及它在运行时需要的依赖关系。您运行的每个<strong class="lb iu">容器</strong>都是可重复的；包含依赖项的标准化意味着无论你在哪里运行它，你都会得到相同的行为。”</p><p id="42ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个定义对初学者来说可能听起来有点过了。让我解释一下。</p><p id="1723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们需要在服务器上运行一堆应用程序，比如web应用程序、数据库、消息传递层等。，这将导致以下情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/ec754cbed1910d82600f6e502ee0e20d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*pZX1m5jE1r9Ue5jNmDyLHQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">服务器上的应用程序堆栈</p></figure><p id="0caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个运行操作系统(OS)的硬件基础设施，库和应用程序依赖项安装在OS上。不同的应用程序共享相同的库和依赖项来运行。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7da8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">地狱矩阵</h1><p id="93f0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您研究上一节中描述的设计，肯定会有多个问题。如果您猜对了，例如，与数据库服务器相比，web服务器可能需要不同版本的库，而一个版本的依赖关系可能与一个应用程序兼容，但与另一个不兼容。如果我们需要升级其中一个依赖项，我们需要确保不会影响另一个可能不支持它的应用程序。这种场景被称为地狱矩阵，对开发者和管理员来说都是一场噩梦。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aae7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">它在我的机器上工作</h1><p id="e962" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">任何在技术领域工作过的人在职业生涯中都至少遇到过一次这个短语。“它在我的机器上工作”是开发人员和测试人员之间的典型对话，其中开发人员说应用程序在他们的机器上工作得非常好。尽管如此，它在测试环境中并不工作，在测试环境中工作得非常好的东西在生产环境中可能就不一样了。原因？地狱矩阵。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f6a6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">解决方法</h1><p id="9225" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在容器出现之前，组织已经通过使用虚拟机解决了这个问题。虚拟机是对计算机系统的模拟。虚拟机基于计算机架构，并使用名为<em class="mz">管理程序</em>的软件提供物理计算机的功能。市场上一些受欢迎的虚拟机管理程序是VMWare和Oracle Virtual Box。典型的基于虚拟机的堆栈如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/3ded02bc6e468c86119f1396fb6805c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z2fC5Tb6q3BpjoX3FyYc-g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">虚拟机上的应用程序堆栈</p></figure><p id="3eaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，一切顺利。我们已经解决了依赖问题，现在我们已经脱离了地狱矩阵。这种架构是开创性的，持续了二十多年，今天仍在使用。然而，这引入了另一个问题。现在，我们不再在一台机器上运行单个操作系统，而是在一台物理设备上运行多个客户操作系统。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bf58" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">虚拟机时代的问题</h1><p id="5439" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们试图解决运行时、库和依赖性问题，但是我们在它们之间引入了一个重量级的来宾操作系统层，这有它的缺点。虚拟机很重，启动速度较慢，并且需要额外的依赖来维护来宾操作系统和主机操作系统。管理员现在需要管理多台服务器，而不是众多的依赖项。</p><p id="63e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们需要为来宾操作系统分配最低数量的资源，组织会向虚拟机过度调配资源，以满足虚拟机的峰值利用率，而不是正常使用。即使架构正确，虚拟机内的资源共享也不是最佳的。虚拟机浪费了大量资源，因为大量已分配的资源仍未得到利用。为一个应用程序配备专用的虚拟机会导致可移植性问题，运营团队很快就会发现自己在试图将服务器当成宠物。运行在服务器上的应用程序是必不可少的，如果它们由于某种原因失败了，从头开始重新构建它们是一个问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a94e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">介绍容器</h1><p id="23aa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">容器通过将服务器视为服务器来平衡这个问题。我们不再有单独的虚拟机用于web服务器、数据库和消息传递。相反，我们为它们准备了不同的容器。迷茫？见下图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/8ea60c6e1d12857071b2877fd89472fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WzVlSOk77g2vlo0cB9jH6w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">容器上的应用程序堆栈</p></figure><p id="8d0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在已经摆脱了对客户操作系统的依赖，容器现在在同一个操作系统中作为独立的进程运行。容器利用容器运行时。一些流行的容器运行时是<a class="ae ky" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>、<a class="ae ky" href="https://www.rocker-project.org/" rel="noopener ugc nofollow" target="_blank"> Rocket </a>和<a class="ae ky" href="https://containerd.io/" rel="noopener ugc nofollow" target="_blank"> containerd </a>。其中最流行的，或多或少是容器运行时技术中事实上的标准，是Docker。</p><p id="865f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容器运行时提供了一个抽象层，允许应用程序自包含，并且所有应用程序和依赖项相互独立。</p><p id="4edb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容器解决了很多问题。</p><p id="fb5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">容器是可移植的</strong>——因为容器将运行时和应用程序依赖打包在一起，所以它们是可移植的。容器不关心它在哪里运行，在所有环境中的行为都是一样的。</p><p id="1f54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">容器更高效</strong> —因为容器不包含客户操作系统，所以启动速度极快。虽然启动一个虚拟机需要几分钟，但启动一个新容器只需几秒钟。</p><p id="5bb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">容器是可扩展的</strong> —这并不是说虚拟机不可扩展，而是因为容器启动速度快且占用空间少，所以构建新容器比构建新虚拟机要容易得多。您可以让多个容器在一个操作系统中独立地扩展和缩减，并共享资源，这比虚拟机浪费更少。</p><p id="4763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">容器是轻量级的</strong> —因为容器不包含沉重的客户操作系统，所以容器具有非常轻的足迹。您不需要将set资源分配给容器，它可以使用底层OS资源，类似于应用程序。与虚拟机相比，它们需要更少的计算资源来运行。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="99ce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">管理容器</h1><p id="84d2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在一个服务器中运行多个容器的想法听起来很诱人，但是它们也有自己的问题。你如何称集装箱？当容器不健康时，您如何确保容器运行并修复？如果您突然看到一个峰值，并希望自动扩大容器，会发生什么情况？如果您看到流量下降，并希望将容器缩小到最佳水平，该怎么办？容器适用于微服务架构，如果您正在使用它，您将如何确保容器能够相互通信？如果您达到了资源限制，并且想要在另一个VM中调度您的容器，该怎么办？</p><p id="fde7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些问题的答案是像Kubernetes这样的容器编排平台。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0bd0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用Kubernetes介绍容器编排</h1><p id="c56a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用Kubernetes的想法很简单。您有一个由Kubernetes管理的服务器集群，Kubernetes负责编排服务器中的容器。您将服务器视为服务器，并在称为容器的自包含单元中运行应用程序。</p><p id="1fe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为容器可以在任何服务器上运行，所以只要客户端可以访问它，容器在哪个服务器上运行并不重要。如果您需要扩展您的集群，您可以向群集中添加或删除节点，而不必担心应用程序体系结构、分区、角色等问题。你在Kubernetes级别处理所有这些。</p><p id="fb8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes使用一个简单的概念来管理容器。有控制和协调容器工作负载的主节点(控制平面),以及容器运行的工作节点。Kubernetes在pod中运行容器，这构成了Kubernetes中的基本构件。</p><p id="6644" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes主要提供以下内容:</p><ol class=""><li id="1519" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated"><strong class="lb iu">与底层容器运行时</strong>通信——Kubernetes不是容器平台，而是容器编排平台。它的kubelet组件作为服务在每个节点上运行，负责与底层容器平台对话以管理容器。例如，当您使用<code class="fe nl nm nn no b">kubectl</code>创建一个pod，并且您的底层容器平台是Docker时，kubelet向所选worker节点中的Docker运行时发出一个Docker run命令。</li><li id="0cf7" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated"><strong class="lb iu">存储预期配置的状态</strong> —当您使用<code class="fe nl nm nn no b">kubectl </code> create/apply命令应用Kubernetes配置时，Kubernetes会将其作为预期配置存储在其<code class="fe nl nm nn no b">etcd</code>数据存储中。</li><li id="143c" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated"><strong class="lb iu">根据预期配置维护状态</strong> — Kubernetes通过查看<code class="fe nl nm nn no b">etcd</code>数据存储中的配置，不断尝试维护集群的预期状态。</li><li id="2ff1" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated"><strong class="lb iu">提供基于抽象软件的网络编排层</strong>—Kubernetes提供的pod网络确保容器可以在某种覆盖或桥接网络上相互通信。这个网络在容器运行时内被管理(例如，使用Docker桥接网络),或者通过内部或外部网络被管理。当一个pod与另一个pod对话时，Kubernetes会修改路由表，以确保连接到位。</li><li id="c9e0" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated"><strong class="lb iu">提供内置的服务发现</strong> — Kubernetes提供开箱即用的容器服务发现。您不需要外部应用程序来管理它。Kubernetes在DNS上公开您的pod，该DNS将服务名称映射到任何可用的Pod IP，因此提供服务发现和多个Pod副本之间的负载平衡。正是因为这种服务发现，豆荚才是短暂的。服务还可以通过在节点内创建监听器，以及通过请求云提供商提供指向您的pod的负载平衡器，将您的pod暴露给内部和外部客户端。</li><li id="e8a4" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated"><strong class="lb iu">健康检查配置</strong> — Kubernetes确保集群中运行的容器工作负载处于预期的健康状态，如果没有，它会销毁并重新创建容器。</li><li id="e680" class="nc nd it lb b lc np lf nq li nr lm ns lq nt lu nh ni nj nk bi translated"><strong class="lb iu">请求云提供商提供对象</strong> —如果你在像GCP或Azure这样的云提供商内运行Kubernetes，它可以使用云API来动态供应资源，如负载平衡器和存储。这样，您就有了一个单一的控制平面来管理在容器中运行应用程序所需的一切。</li></ol><p id="c797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是Kubernetes集群的高级架构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/f0114f4c520aeab8c205cbdef5628aa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cT56FWaY0s0V4Yh04OezEg.png"/></div></div></figure><p id="a7af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您不再需要担心您的应用程序的状态，而是依靠Kubernetes来确保您的应用程序继续运行并保持健康。开发人员只需要关注应用程序代码，他们不需要担心底层的基础设施，因为容器在所有环境中都是一样的。Kubernetes使管理员的工作变得更加容易:它提供了大量的特性，这使得管理Kubernetes集群更加有效和高效。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a723" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">进一步阅读</h1><p id="0463" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">感谢您通读。我希望你喜欢这篇文章。如果您有兴趣进一步了解，请查看“<a class="ae ky" href="https://medium.com/better-programming/demystifying-kubernetes-objects-understanding-the-what-why-and-how-18b42c9ca9c2" rel="noopener">揭开Kubernetes对象的神秘面纱</a>”</p></div></div>    
</body>
</html>