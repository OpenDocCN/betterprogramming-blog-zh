<html>
<head>
<title>Improve Your React Application Performance by Reducing the Number of API Calls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过减少API调用的数量来提高React应用程序的性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/request-batching-in-react-b8fd0656b28b?source=collection_archive---------13-----------------------#2022-03-28">https://betterprogramming.pub/request-batching-in-react-b8fd0656b28b?source=collection_archive---------13-----------------------#2022-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="446f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在React中请求批处理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1a25c3942fe7cd2af6298f0e98986990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B7X43kTWeCcNztU6"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@farber?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔纳森·法伯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近在开发一个React应用程序，它需要调用一个API来检查用户是否有权限在应用程序中执行不同的操作。组件将通过调用这个API来检查不同的权限，如果用户缺少所需的权限，则由它们来呈现错误或替代状态。</p><p id="7583" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我注意到这种方法会导致快速连续地进行许多调用(尽管针对不同的权限)，我想通过减少调用这个API的次数来改善这种情况。然后，我开始考虑如何实现一种机制来消除查询的抖动，在等待期结束时(比如说10ms ),它会折叠所有的查询，进行一次批处理调用，并在组件不知道的情况下返回响应。</p><p id="aa00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">API已经支持批处理版本(获取许可列表),所以这只是前端工作。</p><p id="b91f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几年前，我开发了一个使用<a class="ae ky" href="https://github.com/Netflix/Hystrix" rel="noopener ugc nofollow" target="_blank"> Hystrix </a>的API，它是一个Java库，提供了很多东西，包括<a class="ae ky" href="https://github.com/Netflix/Hystrix/wiki/How-it-Works#request-collapsing" rel="noopener ugc nofollow" target="_blank">请求折叠</a>，所以我继续寻找一个Javascript的等价物，如果可能的话，我真的不想重新发明轮子。</p><p id="0672" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我找到了！是<a class="ae ky" href="https://github.com/graphql/dataloader" rel="noopener ugc nofollow" target="_blank">数据加载器</a>:</p><blockquote class="lv lw lx"><p id="adbb" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">一个通用实用程序，作为应用程序数据提取层的一部分，为各种后端提供一致的API，并通过批处理和缓存减少对这些后端的请求。</p></blockquote><h1 id="3e6a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">目录</h1><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="2f4f" class="mz md it mv b gy na nb l nc nd">· <a class="ae ky" href="#6c50" rel="noopener ugc nofollow">Dataloader usage</a><br/>· <a class="ae ky" href="#eca2" rel="noopener ugc nofollow">React-query integration</a></span></pre><h1 id="6c50" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据加载器用法</h1><p id="fc0c" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">基本上，你定义你的<code class="fe nj nk nl mv b">Dataloader</code>:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="9d1f" class="mz md it mv b gy na nb l nc nd">const fetcher = async (requests) =&gt; {<br/> // this function takes an array of collapsed requests makes a batch call and return an array of responses<br/>};</span><span id="ef99" class="mz md it mv b gy nm nb l nc nd">const loader = new Dataloader(fetcher);</span></pre><p id="4f44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后使用其基于promise的API加载一个(或多个)项目:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="847e" class="mz md it mv b gy na nb l nc nd">const data = await loader.load(request);</span></pre><p id="5eff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，单个执行帧中出现的单个请求将被折叠。但是，这是可配置的，可以很容易地更改为折叠某个时间窗口内发生的所有请求。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="e097" class="mz md it mv b gy na nb l nc nd">const loader = new DataLoader(fetcher, {<br/>  batchScheduleFn: callback =&gt; setTimeout(callback, 100)<br/>})</span></pre><p id="7844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，可以通过使用<code class="fe nj nk nl mv b">maxBatchSize</code>选项来限制折叠在一起的请求的数量。</p><h1 id="eca2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">反应-查询集成</h1><p id="3922" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">该应用程序还使用了<a class="ae ky" href="https://react-query.tanstack.com/" rel="noopener ugc nofollow" target="_blank"> react-query </a>来管理API调用，因此挑战在于集成这两者。幸运的是他们在一起玩得很好，正如你在这个<a class="ae ky" href="https://codesandbox.io/s/react-query-dataloader-lgosp" rel="noopener ugc nofollow" target="_blank">演示</a>中看到的。</p><p id="5a17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有需要做的就是使用加载器作为react-query获取函数:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="d69e" class="mz md it mv b gy na nb l nc nd">const { data } = useQuery(<br/>    getKey(request),<br/>    () =&gt; loader.load(request)<br/>  );</span></pre><p id="747b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！加载器将完成所有压缩调用的繁重工作，使其对消费者完全透明。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="8800" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望你今天学到了新东西。保重，下次再见。</p></div></div>    
</body>
</html>