<html>
<head>
<title>6 New JavaScript Features Shipping With ES2022</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2022附带6项新的JavaScript功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-new-features-shipping-with-es2022-d595e332561e?source=collection_archive---------9-----------------------#2022-07-05">https://betterprogramming.pub/7-new-features-shipping-with-es2022-d595e332561e?source=collection_archive---------9-----------------------#2022-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="690c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个顶级await，<code class="fe ki kj kk kl b">.at()</code>方法在所有内置的可索引上，等等</h2></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/99f406be50b1e0f5f90c7815ce340217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3B1h7n1zt7R1k4vV"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://unsplash.com/@ventiviews?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">通风视图</a>对<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">防溅罩</a>的拍照</p></figure><p id="4d17" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你可能知道，从2015年ES6开始，Ecma International的TC39每年都会发布ECMAScript的新版本。ECMAScript 2022是ECMAScript语言规范的第13版。</p><p id="2962" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这个新的迭代有它自己的一批新特性——让我们来回顾一下！</p><h1 id="6d23" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">1.顶级等待</h1><p id="60b0" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated">顶层<code class="fe ki kj kk kl b">await</code>使模块能够充当大型异步函数。</p><p id="f148" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">有了顶级的<code class="fe ki kj kk kl b">await</code>，ECMAScript模块(ESM)可以<code class="fe ki kj kk kl b">await</code>资源，导致其他模块<code class="fe ki kj kk kl b">import</code>它们，在它们开始评估自己的身体之前等待。</p><pre class="kn ko kp kq gt mw kl mx my aw mz bi"><span id="3bf0" class="na ma it kl b gy nb nc l nd ne">// say this is my-apple.js<br/>await Promise.resolve('<!-- -->🦥<!-- -->') <em class="nf">// '</em>🦥<em class="nf">'</em></span></pre><h2 id="2428" class="na ma it bd mb ng nh dn mf ni nj dp mj lm nk nl ml lq nm nn mn lu no np mp nq bi translated">用例</h2><p id="c7a0" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated">什么时候让一个模块等待异步操作加载才有意义？</p><p id="c5d8" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf iu">动态依赖路径</strong></p><pre class="kn ko kp kq gt mw kl mx my aw mz bi"><span id="005f" class="na ma it kl b gy nb nc l nd ne">const strings = await import(`/i18n/${navigator.language}`);</span></pre><p id="9493" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这允许模块使用运行时值来确定依赖性。这对于开发/生产分割、国际化、环境分割等非常有用。</p><p id="55f0" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf iu">资源初始化</strong></p><pre class="kn ko kp kq gt mw kl mx my aw mz bi"><span id="bd13" class="na ma it kl b gy nb nc l nd ne">const connection = await dbConnector();</span></pre><p id="79d7" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这允许模块表示资源，也允许在模块永远无法使用的情况下产生错误。</p><p id="8a36" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf iu">依赖倒退</strong></p><pre class="kn ko kp kq gt mw kl mx my aw mz bi"><span id="b467" class="na ma it kl b gy nb nc l nd ne">let jQuery;<br/>try {<br/>  jQuery = await import('https://cdn-a.com/jQuery');<br/>} catch {<br/>  jQuery = await import('https://cdn-b.com/jQuery');<br/>}</span></pre><h1 id="be02" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">2.<code class="fe ki kj kk kl b">.at()</code>对所有内置可索引的方法</h1><p id="4797" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated">目前，要从可索引对象的末尾访问一个值，通常的做法是编写<code class="fe ki kj kk kl b">arr[arr.length - n]</code>。</p><p id="1651" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这需要命名indexable两次，此外，为<code class="fe ki kj kk kl b">.length</code>增加了七个字符，并且对匿名值有敌意。</p><p id="2709" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">此外，您不能使用这种技术来获取函数返回值的最后一项，除非您首先将它存储在一个临时变量中。让我们看看我们能用<code class="fe ki kj kk kl b">.at()</code>做些什么:</p><pre class="kn ko kp kq gt mw kl mx my aw mz bi"><span id="2b2c" class="na ma it kl b gy nb nc l nd ne">const users = ['<!-- -->👷‍♀️', '🧟‍♂️', '👶', '🧝', '🙋‍♂️'<!-- -->];</span><span id="4686" class="na ma it kl b gy nr nc l nd ne">// Until today<br/>users[users.length - 1]; // '🙋‍♂️'<br/>users[1]; // '🧟‍♂️'<br/>users[1000]; // <em class="nf">undefined</em></span><span id="4219" class="na ma it kl b gy nr nc l nd ne">// With the .at() method;<br/>users.at(-1); // '🙋‍♂️'<br/>users.at(1); // '🧟‍♂️'<br/>users.at(1000); // <em class="nf">undefined<br/></em>["🍍", "🍏"].at(0); // "🍍"</span></pre><h1 id="27e9" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">3.更易访问的<code class="fe ki kj kk kl b">hasOwnProperty: </code> Object.hasOwn</h1><p id="5b2a" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated">如果你不直接拥有一个对象中定义的每个属性，你不能100%确定调用<code class="fe ki kj kk kl b">.hasOwnProperty()</code>就是调用内置方法。让我们看看这个例子:</p><pre class="kn ko kp kq gt mw kl mx my aw mz bi"><span id="8e9d" class="na ma it kl b gy nb nc l nd ne">let object = {<br/>  hasOwnProperty() {<br/>    throw new Error("gotcha!")<br/>  }<br/>}</span><span id="46d4" class="na ma it kl b gy nr nc l nd ne">object.hasOwnProperty("foo")<br/>// Uncaught Error: gotcha!</span></pre><p id="aae9" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe ki kj kk kl b">Object.hasOwn</code>具有与<code class="fe ki kj kk kl b">.hasOwnProperty()</code>完全相同的行为，并且实现方式如下:</p><pre class="kn ko kp kq gt mw kl mx my aw mz bi"><span id="bb31" class="na ma it kl b gy nb nc l nd ne">let object = { foo: false }<br/>Object.hasOwn(object, "foo") // true</span><span id="fc22" class="na ma it kl b gy nr nc l nd ne">let object2 = Object.create({ foo: true })<br/>Object.hasOwn(object2, "foo") // false</span><span id="8856" class="na ma it kl b gy nr nc l nd ne">let object3 = Object.create(null)<br/>Object.hasOwn(object3, "foo") // false</span></pre><h2 id="b526" class="na ma it bd mb ng nh dn mf ni nj dp mj lm nk nl ml lq nm nn mn lu no np mp nq bi translated">很高兴知道</h2><p id="c5a9" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated">ESLint有一个<a class="ae lc" href="https://eslint.org/docs/rules/no-prototype-builtins" rel="noopener ugc nofollow" target="_blank">内置规则</a>，禁止使用类似<code class="fe ki kj kk kl b">hasOwnProperty</code>的原型内置。</p><h1 id="098b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">4.正则表达式匹配索引</h1><p id="282f" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated">ECMAScript <code class="fe ki kj kk kl b">RegExp</code>匹配索引提供了捕获的子字符串相对于输入字符串开头的起始和结束索引的附加信息。</p><p id="5abb" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们来看看它的实际应用:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="78f0" class="na ma it bd mb ng nh dn mf ni nj dp mj lm nk nl ml lq nm nn mn lu no np mp nq bi translated">很高兴知道</h2><p id="9c8d" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated">出于性能原因，只有指定了<code class="fe ki kj kk kl b">d</code>标志，<code class="fe ki kj kk kl b">indices</code>才会被添加到结果中。</p><h1 id="15f5" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">5.错误原因</h1><p id="55dd" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated">为了帮助进行意外行为诊断，需要用上下文信息(如错误消息和错误实例属性)来补充错误，以解释当时发生了什么。</p><p id="1b37" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果错误是从深层的内部方法中抛出的，那么在没有适当的异常设计模式的情况下，抛出的错误可能不会直接有效地处理。</p><p id="0386" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在，<code class="fe ki kj kk kl b">Error()</code>接受了一个额外的选项参数:<code class="fe ki kj kk kl b">cause</code>属性。<code class="fe ki kj kk kl b">cause</code>然后将作为一个属性分配给错误实例。这意味着可以链接错误，而无需在条件中包装错误的不必要和过于繁琐的手续:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="b1bd" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">6.针对私人领域的人体工程学品牌检查</h1><p id="bc2f" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated">这个新特性提出了一种检查对象是否有给定私有字段的简洁方法。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="6af8" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="f314" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated">今年到此为止！很好的完成了这篇文章的结尾！</p><p id="9ea1" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">作为一名开发人员，跟上语言的发展是你成长的关键！</p><p id="721f" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这些特性中哪一个最让你兴奋？</p><p id="600f" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">感谢阅读！</p></div></div>    
</body>
</html>