<html>
<head>
<title>8 Best Practices for Future-Proofing Your TypeScript Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让您的TypeScript代码经得起未来考验的8个最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/8-best-practices-for-future-proofing-your-typescript-code-2600fb7d8063?source=collection_archive---------0-----------------------#2019-11-18">https://betterprogramming.pub/8-best-practices-for-future-proofing-your-typescript-code-2600fb7d8063?source=collection_archive---------0-----------------------#2019-11-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aabd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">确保您的类型脚本代码经得起时间的考验</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ae4f6a2bf7f98b3a82e9105d7999fdbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T-MkxhRDcCtIAjm5ANRYIQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@joeel56?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">妮可·沃尔夫</a>在<a class="ae ky" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="01a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您是使用JavaScript构建库、前端还是后端应用程序，切换到<a class="ae ky" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>这一小小的努力已经是为您的代码提供未来保障的一大步。</p><p id="9c3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不同意，我建议您至少在一些经常调用的代码上尝试一下，并通过错误报告工具比较未捕获的异常前后的情况。</p><p id="480b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您向代码库中添加类型时，您可能会注意到由于逻辑错误、对潜在可空变量的未经检查的访问、有太多问题(输入/输出参数)的函数等导致的死代码，这将立即有助于减少代码中的问题数量。</p><p id="f0b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它将使重构您的代码更加容易，有助于未来的开发并减少技术债务——因为现在，IDE(例如<a class="ae ky" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank">VS</a>Code)知道您的代码使用什么类型，它可以帮助重命名、拆分、移动代码，以及显示未使用的函数。</p><p id="b291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有几个低成本的技巧可以实现，这将极大地帮助您使您的代码更加经得起未来考验，尤其是如果您计划在团队中处理您的代码，或者如果您的代码不仅仅是一个原型。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="22b7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.打开严格检查</h1><p id="a7b8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">默认情况下，TypeScript不使用它的<code class="fe mz na nb nc b">strict</code>模式。如果您还不想完全提交给TypeScript(例如，只将您的JavaScript文件的一部分迁移到它)，这可能很好，但这也意味着许多常见的JavaScript错误不会被TypeScript捕获。</p><p id="efa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发生这种情况是因为TypeScript不希望您为所有内容添加类型定义(而是将参数和变量标记为<code class="fe mz na nb nc b">any</code>，并允许您将<code class="fe mz na nb nc b">null</code>或<code class="fe mz na nb nc b">undefined</code>赋给任何类型，以及其他一些规则(查看<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" rel="noopener ugc nofollow" target="_blank">文档</a>)。</p><p id="4191" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需打开项目的<code class="fe mz na nb nc b">tsconfig.json</code>中的<code class="fe mz na nb nc b">strict</code>标志，就可以大大提高代码的稳定性。必须显式地键入所有内容将会改进代码的文档，允许您更容易地推理代码的期望。</p><p id="3ea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将有助于TypeScript编译器帮助您，因为它可以指出由于缺少空检查或参数/变量的其他潜在值而导致的潜在异常。</p><p id="6080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多不使用TypeScript，或者不为任何事情添加类型的开发人员倾向于认为他们不需要冗长的类型，因为他们的代码已经足够好了。</p><p id="1f19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，至少要考虑帮团队中的其他开发人员一个忙，让他们有可能使用IDE的更多自动化重构功能，而不是浪费时间在繁重的工作上。</p><p id="cb32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尤其是因为您仍然可以配置TypeScript来发出JavaScript代码，而不会被项目中缺少的类型所阻止，并将缺少的类型视为技术债务，随着时间的推移将会消除。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f5d8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.用巴别塔代替tsc</h1><p id="d723" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">从版本7开始，<a class="ae ky" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>增加了对TypeScript的支持，这意味着你不再需要使用TypeScript编译器<code class="fe mz na nb nc b">tsc</code>来构建你的项目，而是可以使用Babel，它只是简单地从所有的TypeScript文件中剥离你的类型，然后以JavaScript的形式发出结果。</p><p id="9902" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不仅比<code class="fe mz na nb nc b">tsc</code>快得多，尤其是在更大的项目中，而且允许您在您的项目中使用整个巴别塔生态系统。</p><p id="3e63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于后端项目，这意味着您可以简化笨重的文件查看脚本，只需使用<a class="ae ky" href="https://babeljs.io/docs/en/babel-node" rel="noopener ugc nofollow" target="_blank">巴别塔节点</a>来查看更改:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c862" class="nh md it nc b gy ni nj l nk nl">nodemon — inspect=0.0.0.0:9229 — exec babel-node — extensions ‘.ts,.tsx’ src/index.ts</span></pre><p id="eef6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于项目，例如在使用<a class="ae ky" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>或其他非TypeScript特性时，这意味着您可以通过Babel轻松添加它们，并且您的TypeScript构建管道不会中断或需要更改:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4380" class="nh md it nc b gy ni nj l nk nl">{<br/>  "plugins": ["import-graphql"]<br/>}</span></pre><p id="ef07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，对于使用用TypeScript构建的命令行工具的项目，您将不再需要在运行之前先构建<a class="ae ky" href="https://github.com/TypeStrong/ts-node" rel="noopener ugc nofollow" target="_blank"> ts-node </a>或步骤，而是直接通过babel-node运行您的CLI。</p><p id="5e23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">负面影响很小。Babel的TypeScript实现不支持TypeScript的const enums(这听起来比实际情况更严重)，如果你真的想对所有文件进行检查，你仍然需要在commit/CI管道中使用<code class="fe mz na nb nc b">tsc</code>,因为Babel不解释TypeScript。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2c55" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.锁定您的版本</h1><p id="d0a8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您还没有，开始将您的版本固定在您的<code class="fe mz na nb nc b">package.json</code>中。即使您有一个锁文件，也要把您的<code class="fe mz na nb nc b">package.json</code>看作是您的项目所依赖的人类可读的事实。</p><p id="7e76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于TypeScript项目尤其如此。尽管一些JavaScript项目更新了它们的依赖项的补丁版本，但是只有在那时你才会注意到这个包的维护者并没有真正遵循<a class="ae ky" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank"> SemVer </a>或者引入了一个bug，所有的TypeScript开发人员，在某个时候，都会因为更新了他们的<code class="fe mz na nb nc b">@types</code>类型定义的补丁版本，然后注意到许多新的TypeScript错误而遭受损失。</p><p id="4c7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这通常是由于第三方依赖关系的许多第三方类型随着时间的推移而演变，有时会以不可预见的方式变得更加严格。</p><p id="3e93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，仅允许参数上下文的<a class="ae ky" href="https://koajs.com/" rel="noopener ugc nofollow" target="_blank"> Koa </a>定义或仅允许在上下文上使用用户对象的Express定义，因为这些键在它们的接口上被设置为<code class="fe mz na nb nc b">any</code>，在几十个路由中突然失败，因为已经添加了正确的类型。</p><p id="28c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管TypeScript及其生态系统已经成熟，并将继续成熟，但由于越来越多的开源库直接采用TypeScript，升级<code class="fe mz na nb nc b">@types</code>仍然是一个痛苦。</p><p id="e9b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于TypeScript来说更是如此，就像您希望已经完成的其他依赖项升级一样，考虑使用诸如<a class="ae ky" href="http://Greenkeeper.io" rel="noopener ugc nofollow" target="_blank"> Greenkeeper.io </a>(或者<a class="ae ky" href="https://github.com/renovatebot/renovate" rel="noopener ugc nofollow" target="_blank">renewal</a>，或者您的CI提供的任何东西)之类的工具来自动升级一个单独分支中的单个依赖项，使您的项目更容易更新。</p><p id="a32b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">永远不要考虑在周五晚上更新这个小小的<code class="fe mz na nb nc b">@types/</code>包的补丁版本。糟糕的周末就是这样开始的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ebe2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.不透明类型FTW</h1><p id="3c6d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在您的许多项目中，您将最终使用许多字符串类型的参数，而很少使用其他类型的参数，这使得TypeScript很难在您分配错误的变量时警告您:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9f45" class="nh md it nc b gy ni nj l nk nl">const trackLogin = (currentDate: string, sessionId: string) =&gt; { someCode(); };<br/>const sessionUuid: string = currentSession.getUuid();<br/>const currentDate: string = (new Date()).toISOString();<br/>trackLogin(sessionUuid, currentDate);</span></pre><p id="1ddc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以很容易地防止这种情况，同时也使得将来重构代码更加容易。只需定义和使用所谓的不透明类型，它可以是项目所需的粒度:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1158" class="nh md it nc b gy ni nj l nk nl">type Opaque&lt;K, T&gt; = T &amp; { __TYPE__: K };<br/>type Uuid = Opaque&lt;"Uuid", string&gt;;<br/>type DateISOString = Opaque&lt;"DateISOString", string&gt;;</span></pre><p id="3263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实用函数<code class="fe mz na nb nc b">Opaque&lt;K, T&gt;</code>简单地定义了一个新类型，除了变量值之外，它还存储一个(唯一的)键，比如<code class="fe mz na nb nc b">Uuid</code>或<code class="fe mz na nb nc b">DateISOString</code>。</p><p id="4897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就允许TypeScript区分不同的类型，即使所有类型仍然存储普通字符串并且不改变编译器的输出。</p><p id="98ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着您现在可以添加尽可能多的具有唯一名称的字符串类型，它们仍将作为字符串值传递，但在顶部添加了类型验证:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c05e" class="nh md it nc b gy ni nj l nk nl">const trackLogin = (currentDate: DateISOString, sessionId: Uuid) =&gt; { someCode(); }<br/>const sessionUuid = currentSession.getUuid() as Uuid;<br/>const currentDate = new Date().toISOString() as DateISOString;</span><span id="d398" class="nh md it nc b gy nm nj l nk nl">trackLogin(sessionUuid, currentDate);<br/>// Your IDE / TypeScript will now understand this function call and show an error</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e70f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.使用实用程序类型</h1><p id="7b38" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">除了不透明类型之外，还要学习和使用其他实用程序类型——它们会让你的代码更容易理解。</p><p id="de5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript已经内置了一些实用程序类型，例如<code class="fe mz na nb nc b">Partial&lt;T&gt;</code>，它使得<code class="fe mz na nb nc b">T</code>的所有属性都是可选的，或者<code class="fe mz na nb nc b">Readonly&lt;T&gt;</code>，它使得<code class="fe mz na nb nc b">T</code>是只读的。(还有其他第三方实用程序类型的<a class="ae ky" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>包可用。)</p><p id="4f6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您开始使用它们时，您很快就会注意到，您的代码中冗余/重复的TypeScript类型会更少，定义更窄的类型会更多。</p><p id="4ebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果你是一个React开发人员，对于一个<a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a> reducer，你可以简单地将一个reducer的输入状态定义为<code class="fe mz na nb nc b">Readonly&lt;T&gt;</code>，以便更容易地查看你是否无意中覆盖了它，而不必添加另一个只读状态类型。</p><p id="d8d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，它们不仅有助于减少类型重复；它们还可以帮助你不要导出太多的接口，保持代码清晰。</p><p id="f8cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">坚持React示例，您可能想要为React组件属性或动作创建者返回值定义导出的接口。</p><p id="ec50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果您认为接口是样板文件，并且您的代码实际上是关于React组件的，那么您可以简单地使用<code class="fe mz na nb nc b">React.ComponentProps&lt;T&gt;</code>以一种直接的方式获得组件的属性(这适用于基于类和基于函数的组件)，或者使用<code class="fe mz na nb nc b">ReturnType&lt;T&gt;</code>获得动作创建者的类型。</p><p id="b2fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便提一下，如果从代码领域的角度来看有意义，那么只尝试将接口或类型分解成更小的嵌套接口/类型。一旦它们被积极地分开，就很难看到结构，尤其是在使用代码完成时。</p><p id="6f9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，将一个接口放在一起并通过方括号引用它要容易得多，例如，<code class="fe mz na nb nc b">IUser["parents"]</code>可以是引用一个存储另外两个<code class="fe mz na nb nc b">Users</code>的<code class="fe mz na nb nc b">parents</code>值对象的简单方式，而不是引入一个一次性的<code class="fe mz na nb nc b">IParents</code>，后者可能在一周后变得过于模糊。</p><p id="23c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，拥有尽可能多的接口并不是一种竞争，总是要考虑接口或类型在您的产品领域中意味着什么，并在必要时复制，但不要在您的IDE需要它时复制。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b436" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.使用更漂亮的</h1><p id="cf66" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在任何多人工作的代码库中，或者同一个人长时间工作的代码库中，编码风格都是不一致的。</p><p id="9288" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使你同意古老的“制表符对空格”之争，有些人可能对多行函数调用的缩进方式不同，而有些人编写JSON对象的方式不同，等等。</p><p id="3b9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不仅会导致浪费时间讨论哪种风格更好，或者哪种风格与过于模糊或过于复杂的公司风格指南相匹配；而且还会在合并请求中导致无用的差异，使查看实际更改的代码变得更加困难。</p><p id="0470" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以简单地使用<a class="ae ky" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank">更漂亮的</a>来格式化你的代码。它非常固执己见并且(幸运的是！)没有提供很多浪费时间的配置选项，它可以完美地处理许多文件格式，例如HTML以及JSON、CSS和TypeScript。</p><p id="e034" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以设置你的IDE(比如VS代码)在你保存文件时自动使用它，这实际上是更漂亮的最大好处——你将不再在缩进、行长度等方面花费宝贵的编码时间。相反，你可以不停地打字，漂亮会变魔术。</p><p id="e296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我强烈建议你使用现成的更漂亮的，不要试图改变它。你根本不需要修改你的编码风格，因为Prettier会自动格式化你的代码。</p><p id="e05e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能需要做的就是调整你阅读代码的方式。坦率地说，这只需做一次，比通读一个函数并看到三个不同的人的五种不同的编码风格要容易得多。</p><p id="65cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">*我允许的一个配置更改是使用ES5风格的尾随逗号:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1fe9" class="nh md it nc b gy ni nj l nk nl">{<br/>  "trailingComma": "es5"<br/>}</span></pre><p id="aeb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您在对象末尾添加新元素时，这将减少合并请求中的差异，从而减少合并冲突。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ffc5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.使用对象作为函数的有效负载</h1><p id="3417" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于某些函数，只传入一个对象而不是单独的输入变量可能非常有益，这将极大地简化以后对函数签名的更改。</p><p id="2bb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传统上，应用该规则的函数是Redux动作创建者:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6d9d" class="nh md it nc b gy ni nj l nk nl">const sendMail = (type: string, subject: string, body: string, to: string, attachment?: File) =&gt; {<br/>  return {<br/>    payload: {<br/>      attachment, body, subject, to<br/>    },<br/>    type,<br/>  };<br/>};</span></pre><p id="fe25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对比:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6d6d" class="nh md it nc b gy ni nj l nk nl">const sendMail = (type: string, payload: { subject: string, body: string, to: string, attachment?: File }) =&gt; {<br/>  return {<br/>    payload,<br/>    type,<br/>  };<br/>};</span></pre><p id="0915" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您现在必须添加一个新参数时，例如我们示例中的电子邮件收件人的<code class="fe mz na nb nc b">userId</code>，在第一种表达函数的方式中，您必须更改函数签名，并随之更改所有被调用的React组件/分派函数。</p><p id="daf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你只是传递一个对象，不仅在动作创建器中表达返回对象更容易，而且你也不必担心输入参数的顺序，还有一个可选的参数。</p><p id="52f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也适用于Express应用程序或类似层中的控制器方法，在这种情况下，您可能最终会稍微更改您的域代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7860" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">8.使用ESLint和SonarJS</h1><p id="8135" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">就像漂亮对于你的编码格式是多么重要一样，每个项目都应该使用<a class="ae ky" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>作为他们的编码标准，还有ESLint插件<a class="ae ky" href="https://www.sonarsource.com/products/codeanalyzers/sonarjs.html" rel="noopener ugc nofollow" target="_blank"> SonarJS </a>。</p><p id="ee8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(<a class="ae ky" href="https://palantir.github.io/tslint/" rel="noopener ugc nofollow" target="_blank"> TSLint </a>正被弃用，取而代之的是<a class="ae ky" href="https://github.com/typescript-eslint/typescript-eslint" rel="noopener ugc nofollow" target="_blank">typescript-eslint</a>；TSLint插件SonarTS已经被采用，现在是SonarJS的一部分。</p><p id="aa0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在推荐的设置中，ESLint有许多规则可以提高你的代码质量，帮助你避免常见的错误。</p><p id="bde1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使对于高级程序员来说，提醒他们getter没有返回值，或者变量在当前作用域中没有声明也是有帮助的；我们都会犯错。</p><p id="a447" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了ESLint的特性之外，SonarJS还为您的代码添加了一些复杂性检查，这有助于您先编写代码，然后将您的方法分成更小的部分</p><p id="617b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在重构或向现有功能添加新需求时也是一个很大的帮助，并且不会意外地导致过于复杂的功能。</p></div></div>    
</body>
</html>