<html>
<head>
<title>Beginning Python Programming — Part 9</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python编程入门—第9部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/beginning-python-programming-part-8-45cad890e6b?source=collection_archive---------8-----------------------#2019-06-04">https://betterprogramming.pub/beginning-python-programming-part-8-45cad890e6b?source=collection_archive---------8-----------------------#2019-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0187" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于Python中的错误处理，您需要知道的一切</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9eb3478c38ff37db87ff3df360d88480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ae55KFpfSHWiWL6c"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丘特尔斯纳普</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="148e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一篇文章中，我们讨论了格式化、列表理解和lambdas。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/@broebling/beginning-python-programming-part-8-966f1189c1fe" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Python编程入门—第8部分</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">在上一篇文章中，我们深入挖掘了类，发现了它们是如何被创建和销毁的。我们还看了我们如何…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="6b36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些灵活性，我们也使代码变得复杂。当您有一个复杂的代码库时，您肯定会遇到错误，这就是错误处理发挥作用的地方。</p><p id="f4ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，错误处理是<strong class="lb iu"> <em class="mn">而不是</em> </strong>测试！印刷的声明也不是这样。那么到底什么是错误处理呢？</p><h1 id="68bb" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">错误处理</h1><p id="5b7c" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">简而言之，错误处理就是添加足够的逻辑，这样你的程序就可以处理那些原本会停止运行的情况。</p><p id="fdba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误来自可能引发错误的函数。当错误出现时，它会从函数中返回，即使该函数应该返回一个字符串值。如果不被捕获，它将导致您的程序崩溃。所以让我们开始吧，这样我们可以有效地处理这些问题。</p><p id="c7a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看几个容易发现错误的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2b86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们试图从<code class="fe nn no np nq b">my_dict</code>访问<code class="fe nn no np nq b">address</code>键。不出所料，那个键不存在，我们在控制台中收到一个<code class="fe nn no np nq b">KeyError</code>。</p><p id="5b4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，我们试图访问<code class="fe nn no np nq b">my_list</code>中同样不存在的第10个元素。对于这个场景，我们接收到一个<code class="fe nn no np nq b">IndexError</code>。</p><p id="8a48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe nn no np nq b">try...except</code>来解决这个问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6c56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我稍微改变了顺序，但是它实际上做了和以前一样的事情，只是我在前面的try/except块中圈出了失败的代码。</p><p id="62f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过编写<code class="fe nn no np nq b">try:</code>来为Python解释器准备可能失败的代码。在<code class="fe nn no np nq b">try</code>主体内部，Python会在运行每一行时检查错误。如果出现错误，它会跳出<code class="fe nn no np nq b">try</code>主体，执行写在<code class="fe nn no np nq b">except:</code>内部的代码。</p><p id="468e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的程序不再崩溃，但它打印“哎呦！”还有“又呜呜了！”到控制台。这很好，因为以前我们的程序一遇到第一个失败的<code class="fe nn no np nq b">print</code>语句就会退出，现在我们的程序继续运行。如果我们在最后一个try/except语句下面编写更多的代码，这些代码也会运行。</p><p id="290b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不打算就此打住，因为虽然代码有效，但它不是好的代码。</p><p id="b3b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用正确的方式重写这个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="66ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们在<code class="fe nn no np nq b">except</code>后面添加我们期望从失败代码中收到的错误类型。所有语言中大多数错误的酷之处在于，它们往往会告诉你发生了哪个错误，然后告诉你发生的原因。</p><p id="98ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以通过捕获错误以显示给用户或记录到控制台来改进这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7c51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们正在获取有关所发生错误的有用信息。通过适当的日志格式(后面的文章)，我们可以包含失败的行号，或者如果数字10存储在变量中，甚至可以提供更多的信息。</p><p id="7859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在需要<code class="fe nn no np nq b">my_dict</code>从<code class="fe nn no np nq b">my_list</code>返回一个值的场景中，我们可以将它们封装在同一个<code class="fe nn no np nq b">try</code>块中，如果一个失败，那么我们停止处理剩余的<code class="fe nn no np nq b">try</code>体，执行<code class="fe nn no np nq b">except</code>体并继续。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="8365" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这无法检索字典值，所以它甚至没有尝试检索列表值。它下降到我们最后的<code class="fe nn no np nq b">print</code>语句，程序结束。</p><blockquote class="nr ns nt"><p id="c85f" class="kz la mn lb b lc ld ju le lf lg jx lh nu lj lk ll nv ln lo lp nw lr ls lt lu im bi translated">这在与网络相关的呼叫的情况下是有帮助的，在这种情况下，用户可能没有互联网接入。因为我们通常有更多的代码依赖于这个网络访问，我们可以跳过它，节省一些处理时间。这只是一个例子，一个更现实的解决网络故障的方法是“提前退出”正在执行网络调用的函数，也就是说，调用一失败就从该函数返回。</p></blockquote><p id="10ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，在打印错误时，必须将其转换为字符串。因为print会自动为您调用任何类中的<code class="fe nn no np nq b">__str__(self)</code>，所以我们只需要在将错误附加到字符串时这样做。我们也可以用f弦来代替它，它也能为我们做到这一点。</p><p id="c98f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一件事我应该添加，以确保这是失败证明。这是一个全球性的例外条款。</p><p id="9743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的异常都来自于<code class="fe nn no np nq b">BaseException</code>和<code class="fe nn no np nq b">Exception</code>类。这两者之间的区别很简单。</p><ul class=""><li id="c9a0" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated"><code class="fe nn no np nq b">BaseException</code>是所有异常的子类，包括<code class="fe nn no np nq b">Exception</code></li><li id="da78" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><code class="fe nn no np nq b">Exception</code>是所有非退出异常的子类。根据<a class="ae ky" href="https://docs.python.org/3.7/library/exceptions.html#Exception" rel="noopener ugc nofollow" target="_blank"> python文档</a>:“所有用户定义的异常也应该从这个类派生。”</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="fd83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我只是加了另一个<code class="fe nn no np nq b">BaseException</code>的例外。这样，如果出现我们没有预料到的情况，我们肯定会处理它，并收到一条消息，提示我们哪里出错了。</p><p id="8296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还对<code class="fe nn no np nq b">IndexError</code>异常做了另一个修改，如果数字超出范围，我们打印列表中的最后一项。虽然这并不简单，但我们更可能想要列表中的最后一项，而不是第一项，后者总是在索引0处；因此，这是一个足够好的解决方案。把这看作是对<em class="mn">启发式编程、</em>或者更简单地说最佳猜测逻辑<em class="mn">的一次尝试。</em></p><p id="0374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是异常的真正目的，我们不只是想显示它们，我们想对它们采取行动，我们需要对错误做些什么，让它对用户有意义。用户不关心列表中有多少元素；他们知道，如果他们想要最后一个，他们将从列表中要求一个高值，并希望它有效。</p><p id="1ead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们可以用类似下面的内容替换<code class="fe nn no np nq b">KeyError</code>异常:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4bc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到这有多有用了吗？让你的错误有意义。</p><h2 id="eb1a" class="ol mp it bd mq om on dn mu oo op dp my li oq or na lm os ot nc lq ou ov ne ow bi translated">其他</h2><p id="e6da" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">有时我们可能想做一些事情，除非一切顺利。我们可以将<code class="fe nn no np nq b">else</code>添加到我们的<code class="fe nn no np nq b">try/except</code>中，只有当我们没有任何问题时，它才会执行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="48cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们试图以只读方式打开一个名为<code class="fe nn no np nq b">my_file.txt</code>的文件，用<code class="fe nn no np nq b">'r'</code>表示。如果成功，我们读取文件内容，并在将文件内容打印到控制台之前将其存储在<code class="fe nn no np nq b">contents</code>中。</p><p id="8e1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果文件不存在于我们运行的程序所在的位置，我们将点击<code class="fe nn no np nq b">FileNotFoundError</code>。如果发生这种情况，我们告诉用户发生了什么，然后继续。</p><p id="8559" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这种情况没有发生，我们手上就有一个打开的文件，我们需要确保我们关闭了该文件以移除任何锁定，以便其他程序可以在以后使用该文件。这就是<code class="fe nn no np nq b">else</code>的用武之地。如果成功，将执行else子句，并关闭文件。</p><p id="6cbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是工作代码，所以如果你想在你的工作目录中创建一个名为“my_file.txt”的新文件，这是可行的，并且文件会在完成后关闭。</p><p id="67af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mn">在Python中，通过垃圾回收或者当你的程序退出时，文件自动为你关闭；但是，最好是显式关闭您打开的任何文件。有一种更好的方法来处理文件IO，但是我们将在以后的文章中讨论这一点。</em></p><h2 id="f374" class="ol mp it bd mq om on dn mu oo op dp my li oq or na lm os ot nc lq ou ov ne ow bi translated">最后</h2><p id="260a" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">不，这还不是文章的结尾，但是<code class="fe nn no np nq b">else</code>还有一个兄弟姐妹叫做<code class="fe nn no np nq b">finally</code>。这两者之间的区别很容易理解。</p><ul class=""><li id="afc1" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated"><code class="fe nn no np nq b">else</code>是try语句成功时只调用<strong class="lb iu">的</strong>吗？</li><li id="c189" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><code class="fe nn no np nq b">finally</code>是不是<strong class="lb iu">无论如何都要叫</strong>。</li></ul><p id="9e64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您的需要，它们可以单独使用，也可以一起使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="76d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果成功，我们将看到以下输出:</p><pre class="kj kk kl km gt ox nq oy oz aw pa bi"><span id="6dda" class="ol mp it nq b gy pb pc l pd pe">file opened!<br/>Hello, World!<br/>file closed<br/>done</span></pre><p id="249f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果找不到文件:</p><pre class="kj kk kl km gt ox nq oy oz aw pa bi"><span id="442c" class="ol mp it nq b gy pb pc l pd pe">File not found!<br/>done</span></pre><p id="18da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始写你的<code class="fe nn no np nq b">try/except</code>块的一个很好的方法是从把所有的东西彼此分开开始。找出哪些类型的错误可能来自错误引发函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/b63c8aee968f833925b2111d56941b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B-qzw1RcHERcC_Jf"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">彼得·赫尔希在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="73d1" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">创建自定义错误</h1><p id="619f" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">有时，我们的程序非常专业，以至于我们需要自己的错误，我们可以从函数中返回，这些函数提供了告诉用户哪里出错的特异性。我们有两个选择，要么采用Python已经存在的错误，要么创建我们自己的错误。</p><p id="e152" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先来看看从Python中采用。</p><p id="8a19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个例子，我们将接受一个字符串参数，但是我们希望它只包含空格。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="cd2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两个示例中，第一个<code class="fe nn no np nq b">data</code>值是正确的，我们看到控制台中显示的值为10。</p><p id="2a44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二个例子中，我们有标签(<code class="fe nn no np nq b">\t</code>)。我们的函数做的第一件事是检查数据是否包含制表符。如果是，它将引发<code class="fe nn no np nq b">TabError</code>。错误本身与<code class="fe nn no np nq b">data</code>字符串断开；它不关心内容。这只是一个错误，如果事情没有按计划进行，你可以用它在你的程序中提供一个有意义的停止。如果您尝试打印<code class="fe nn no np nq b">TabError</code>的字符串值，您将返回<code class="fe nn no np nq b">None</code>。</p><p id="6629" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想包含更适合当前情况的错误消息，您可以将函数改为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="196d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将允许您像上面那样使用<code class="fe nn no np nq b">TabError as error</code>,并将其显示为错误消息。这是首选的，这样，你只需要担心返回你的错误信息，而不是每次调用这个函数都创建一个错误信息。</p><p id="3830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，如果您需要在错误消息中包含逻辑，您可以调整一条或两条消息来满足您的需要。</p></div><div class="ab cl pg ph hx pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="im in io ip iq"><p id="bcb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要比这更特殊的东西，您可以随时创建自己的错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="35b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们创建了一个名为<code class="fe nn no np nq b">BadData</code>的异常，它是<code class="fe nn no np nq b">Exception</code>的子类，这是我们应该在所有错误中使用的。我添加了一个<em class="mn">文档串</em>，当我们看到<code class="fe nn no np nq b">BadData</code>的自动文档时，它可以帮助我们理解它的用途。然后我们<code class="fe nn no np nq b">pass</code>因为我们不需要再做什么了。</p><p id="87f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们运行我们的程序，如果我们有一个包含级别的文件，那么我们继续处理内容。如果没有，那么我们抛出异常并在下面捕获它。因为我们的异常是一个类，所以我们可以在任何需要的地方使用它。</p><p id="667b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它很简单，并为您提供了许多功能来处理系统可能无法理解的错误。如果您找不到适合您需求的异常，并且没有更好的方法不使用<code class="fe nn no np nq b">try/except</code>重构您的代码来处理那个错误，那么总是创建自定义异常。</p><h2 id="6664" class="ol mp it bd mq om on dn mu oo op dp my li oq or na lm os ot nc lq ou ov ne ow bi translated">再加注</h2><p id="20f0" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">有时，您可能会调用一个函数堆栈深处的异常，并需要它返回到顶部。在这种情况下，您可以使用<code class="fe nn no np nq b">raise</code>通过堆栈继续引发相同的异常，直到您准备好处理它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d144" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我只是使用了一个<code class="fe nn no np nq b">NotImplementedError</code>,因为我们还没有完成这个函数。<code class="fe nn no np nq b">some_other_func</code>使用<code class="fe nn no np nq b">try/except</code>块调用<code class="fe nn no np nq b">make_error</code>。如果我们收到一个<code class="fe nn no np nq b">NotImplementedError</code>，我们再次引发它，这样我们就可以在我们的主体中处理它，在那里我们打印“未实现”虽然这是一个简单的例子，但它让您很好地了解了它是如何工作的。</p><h1 id="f998" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">摘要</h1><p id="4b56" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">今天，我们学习了错误是如何发生的，以及如果出现错误，我们如何处理它们。我们学习了几种在不太理想的条件下保持程序运行的技术，以及正确的错误处理和糟糕的错误处理之间的区别。如果您已经下载了PyCharm，您可以输入<code class="fe nn no np nq b">raise</code>，然后输入<code class="fe nn no np nq b">ctrl</code> + <code class="fe nn no np nq b">space</code>来查看一些您可以使用的异常。如果你有足够的勇气参与其他地方的模块，你甚至可以看到他们为你创建的关于他们项目的不同的异常。</p><h2 id="f786" class="ol mp it bd mq om on dn mu oo op dp my li oq or na lm os ot nc lq ou ov ne ow bi translated">推荐阅读</h2><p id="da53" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">Python教程的第8章</p><div class="lv lw gp gr lx ly"><a href="https://docs.python.org/3/tutorial/errors.html" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">8.错误和异常-Python 3 . 7 . 3文档</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">即使语句或表达式在语法上是正确的，当试图执行…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">docs.python.org</p></div></div></div></a></div><h1 id="eb37" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">下一步是什么</h1><p id="0b81" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">接下来是代码结构和可读性。现在是我们学习如何在PEP 8标准下正确构建代码的时候了。我们可能还会涉及PEP 257中定义的docstring约定。</p><p id="9469" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你打算写好的Python程序，你需要理解那些PEP标准，并至少遵守它们。</p><p id="a1c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在那之前，看看你是否能处理一些项目中可能出现的令人讨厌的错误。这样你就可以把任何你想要的数据扔进你的应用程序，它会智能地回应你的疑虑。</p></div></div>    
</body>
</html>