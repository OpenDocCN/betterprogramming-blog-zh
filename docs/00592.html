<html>
<head>
<title>Build a Modern, Customized File Uploading User Interface in React with Plain CSS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中用普通CSS构建一个现代化的、定制的文件上传用户界面</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-modern-customized-file-uploading-user-interface-in-react-with-plain-css-8a78bc92963a?source=collection_archive---------1-----------------------#2019-06-16">https://betterprogramming.pub/build-a-modern-customized-file-uploading-user-interface-in-react-with-plain-css-8a78bc92963a?source=collection_archive---------1-----------------------#2019-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f061" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">现在是让React做大事的时候了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/4f5022936a003af750e6dd9323cb6978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*1diMeBUG8zQxTN3Ey5tLzQ.jpeg"/></div></figure><p id="e151" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">围绕文件输入组件构建用户界面是一项非常方便的学习技能，因为你可以从90年代的外观转向更现代的外观，以补充依赖于它的网页——特别是当我们不能像普通HTML元素一样设计它的时候。当用户使用你的技术时，他们不仅仅是<em class="ln">在使用它——他们很可能也在评判你的应用和技术。</em></p><p id="5644" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">事情是这样的:我们可以很容易地向他们显示一个文件输入，让他们使用默认的HTML元素选择文件，让他们提交文件，然后收工。但是<em class="ln">在</em>之间发生了什么？当事情发生时，用户喜欢看到什么？一个什么都不告诉他们的界面，还是一个告诉他们<em class="ln">一切</em>的界面？</p><p id="95e5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">用户的互联网断了怎么办？如果服务器没有任何响应怎么办？如果14个文件中的第8个对他们来说很大呢？如果用户等待上传过程完成10分钟，并想看看已经完成了多少，该怎么办？或者哪些文件已经上传了？</p><p id="7efb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在之前的教程中(如果你搜索我的帖子就能找到)，我介绍了构建这个API的逻辑<em class="ln">和</em>。那篇文章的目的是教授逻辑。您可以就此打住，围绕它构建自己的定制用户界面。或者您可以自己构建逻辑部分，并阅读这篇文章，了解如何为任何文件上传组件实现UX。创建这些帖子有两个不同的原因，但完全兼容。我将在这篇文章中提供逻辑，这样我们就可以专注于用户界面。决定权在你！</p><p id="19f4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当我编写用户界面时，它变得越来越长，我在考虑是否应该减少组件的数量，展示一个基本的UX版本。然而，由于现在很多文章都没有深入到一个主题，所以我想借此机会更深入地研究一下实现，并找点乐子。</p><p id="9afe" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我本来想用我最喜欢的CSS库<em class="ln"> styled-components </em>来制作这个教程，但是，为了演示如何在没有额外工具的情况下构建一个复杂的用户界面，我决定不这么做。这些工具只是一种便利。你只需要学习一点点<em class="ln"> CSS </em>，<em class="ln">而不是</em>工具。</p><p id="e5c8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后但同样重要的是，这是我们将在这篇文章中构建的预览:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/96990c10c568e489c256e7fde85aac6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/0*mcmAw8TyDG3ttv9_.gif"/></div></figure><p id="ee4e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">事不宜迟，我们开始吧！</p><p id="b616" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在本教程中，我们将使用<a class="ae lm" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>快速生成一个React项目。</p><p id="c030" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">继续使用下面的命令创建一个项目。对于本教程，我将调用我们的项目<em class="ln"> upload-app: </em></p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="e6bf" class="lu lv it lq b gy lw lx l ly lz">npx create-react-app upload-app</span></pre><p id="e19b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">完成后，进入它的目录:</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="47eb" class="lu lv it lq b gy lw lx l ly lz">cd upload-app</span></pre><p id="6a89" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我承诺只提供文件上传实现的逻辑，所以我们可以立即开始构建用户界面。所以这里有一个我们将要使用的定制钩子，叫做<code class="fe ma mb mc lq b">useApp.js</code>:</p><blockquote class="md me mf"><p id="4fbe" class="kq kr ln ks b kt ku ju kv kw kx jx ky mg la lb lc mh le lf lg mi li lj lk ll im bi translated"><em class="it"> src/useApp.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><h2 id="e98f" class="lu lv it bd ml mm mn dn mo mp mq dp mr kz ms mt mu ld mv mw mx lh my mz na nb bi translated">说明</h2><p id="f2bd" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">这里有一个这里发生的事情的快速总结。</p><p id="8e17" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当用户选择文件时，调用<code class="fe ma mb mc lq b">onChange</code>处理程序。<code class="fe ma mb mc lq b">e</code>参数包含我们想要的文件，可以通过<code class="fe ma mb mc lq b">e.target.files</code>访问。这些将是在界面中一个接一个呈现的文件。然而，这个<code class="fe ma mb mc lq b">files</code>对象不是一个数组——它实际上是一个<code class="fe ma mb mc lq b"><a class="ae lm" href="https://developer.mozilla.org/en-US/docs/Web/API/FileList" rel="noopener ugc nofollow" target="_blank">FileList</a></code>。这是一个问题，因为我们不能简单地映射它，否则会出错。所以我们将它转换为一个数组，并将其附加到state.files，允许UI在UI中逐行呈现它们。当用户提交表单时，会调用<code class="fe ma mb mc lq b">onSubmit</code>处理程序。它分派一个动作，该动作向一个或多个<code class="fe ma mb mc lq b">useEffects</code>发送信号，表示该开始了。有几个<code class="fe ma mb mc lq b">useEffects</code>，每个都被分配了不同的任务和条件。一个用于<em class="ln">开始流程</em>，一个用于<em class="ln">继续流程</em>，一个用于<em class="ln">结束流程</em>。</p><p id="b233" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们接下来要做的是打开<code class="fe ma mb mc lq b">App.js</code>文件，用以下代码替换默认代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7379" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是我们的起始CSS文件:<code class="fe ma mb mc lq b">src/styles.css</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="6a5c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果您运行该应用程序，它将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/3b752f00f89ff4e2b707a25f94c4bebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/0*BLFJcCYFicBPQ7CF.gif"/></div></figure><p id="5096" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是非常基本的。真的没有关于这些图片的信息，用户界面看起来像90年代的网页。</p><p id="8389" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当您单击“提交”时，您可以签入控制台消息，以确保它们被逐一处理:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/88171cfecf24016eb7db6cd7f57ef4b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/0*5qQ-Uat2oG-O8FCZ.jpg"/></div></figure><p id="1cde" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一旦完成，你可以继续应用程序的流程，比如将用户重定向到成功页面，或者以模态显示狗的图片。</p><p id="04ba" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">问题是用户不知道发生了什么——他们可能等了10分钟，页面仍然保持不变。</p><p id="9dfd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所以我们要稍微改变一下。我们希望我们的用户从实例化的时刻到上传过程的结束，对<em class="ln">正在发生的一切都是最新的。</em></p><p id="27b5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="ln">让我们自定义</em> <em class="ln">文件输入</em>这样看起来更好。我们希望我们的用户认为我们是独一无二的和最好的，所以我们必须超越！</p><p id="170b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">目前，我们的文件输入如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/26967f0961735cf9869068249b4a5bbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/0*KCytf1azho6Cq2Wh.jpg"/></div></figure><p id="0980" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，我们不希望用户点击退出按钮后再也不回来，所以我们必须进一步设计。有几种方法可以自定义文件输入。</p><p id="c102" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们接下来要制作的这个文件输入组件实际上并不是真正的输入元素，但是它会通过允许用户点击它时打开文件浏览器来伪装成输入元素。</p><p id="5a41" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">创建一个名为<code class="fe ma mb mc lq b">FileUploader.js</code>的文件，并将以下代码放入其中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="ee2f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe ma mb mc lq b">real</code> <em class="ln"> </em>文件输入的是这里的<code class="fe ma mb mc lq b">root div element</code>的孩子。<code class="fe ma mb mc lq b">triggerInput</code>是一个功能，允许我们接入附加到<code class="fe ma mb mc lq b">file input</code>元素的<code class="fe ma mb mc lq b">inputRef</code> ref。我们很快就会看到这一点。</p><p id="6184" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，如果我们呈现这个组件并传入一个<code class="fe ma mb mc lq b">children</code>，那么<code class="fe ma mb mc lq b">hiddenInputStyle</code>将被应用到实际的文件输入中，这样它将强制显示我们的定制组件，而不是UI。<em class="ln">这就是我们如何覆盖界面</em>中的默认文件输入。</p><p id="a689" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在我们的钩子内部，我们定义了<em class="ln">触发输入</em>处理程序</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="a230" class="lu lv it lq b gy lw lx l ly lz">const triggerInput = (e) =&gt; {<br/>  e.persist()<br/>  inputRef.current.click()<br/>}</span></pre><p id="6bc8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后返回它，这样调用者就可以访问它:<code class="fe ma mb mc lq b">src/useApp.js</code></p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="8281" class="lu lv it lq b gy lw lx l ly lz">return {<br/>  ...state,<br/>  onSubmit,<br/>  onChange,<br/>  triggerInput,<br/>}</span></pre><p id="c197" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">太好了！现在我们要制作一个组件，它将把自己伪装成真正的文件输入。它可以是任何东西，但对于本教程来说，它将是用户的一个迷你“<em class="ln">屏幕</em>”——引导他们上传文件，并通过使用图形和文本更新将它们带到下一个屏幕。由于我们是在<code class="fe ma mb mc lq b">FileUploader</code>的渲染方法中渲染<code class="fe ma mb mc lq b">children</code>，我们可以将这个屏幕渲染为 <code class="fe ma mb mc lq b">FileUploader</code>的<em class="ln">子屏幕。我们希望整个屏幕能够在我们需要的时候打开文件浏览器。</em></p><p id="b8e7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">该<em class="ln">屏幕</em>将显示带背景的文本。我将通过在<code class="fe ma mb mc lq b">src</code>目录中创建一个名为<code class="fe ma mb mc lq b">images</code>的文件夹来使用一个图像作为背景。我将把整个教程中使用的图像放在这里，这样我们就可以从中导入图像。</p><p id="b03c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">制作另一个名为<code class="fe ma mb mc lq b">FileUploaderScreen.js</code>的文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="a26e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">以下是我为组件使用的样式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="039c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因为我们被允许将导入的图像作为字符串传递给<em class="ln"> backgroundImage </em> style属性，所以我将它用作背景图像的值。</p><p id="bf76" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们提到过，我们希望这个屏幕在单击时打开一个文件浏览器，所以我们必须在FileUploader中渲染这个。</p><p id="c9d3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在让我们把这个<em class="ln">文件上传器</em>和<em class="ln">文件上传器屏幕</em>放到我们的<code class="fe ma mb mc lq b">App.js</code>文件中:</p><blockquote class="md me mf"><p id="1b8e" class="kq kr ln ks b kt ku ju kv kw kx jx ky mg la lb lc mh le lf lg mi li lj lk ll im bi translated"><em class="it"> src/App.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="63a9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，当您点击<em class="ln">文件上传屏幕</em>时，您应该能够选择文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/1b4a2f570f105090be92280248539979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/0*YBNCu9tEcmnokL3f.gif"/></div></figure><p id="063f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们在用户选择文件时将背景图像切换到不同的图像。</p><p id="0170" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们如何做到这一点？</p><p id="4c7b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这就是我们必须使用之前在自定义钩子中定义的状态属性的地方:</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="a629" class="lu lv it lq b gy lw lx l ly lz">const initialState = {<br/>  files: [],<br/>  pending: [],<br/>  next: null,<br/>  uploading: false,<br/>  uploaded: {},<br/>  status: IDLE,<br/>}</span></pre><p id="64e2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你回头看看我们的useEffects和reducer，你会发现我们是根据正在发生的事情来进行useEffects调度操作的:</p><blockquote class="md me mf"><p id="7583" class="kq kr ln ks b kt ku ju kv kw kx jx ky mg la lb lc mh le lf lg mi li lj lk ll im bi translated"><em class="it"> src/useApp.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><blockquote class="md me mf"><p id="8ec6" class="kq kr ln ks b kt ku ju kv kw kx jx ky mg la lb lc mh le lf lg mi li lj lk ll im bi translated"><em class="it"> src/useApp.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="f8ae" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">此外，如果您回头看一下<em class="ln"> onChange </em>处理程序，您会看到这些动作类型中的一个被分派:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="87cc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因为我们知道调度<em class="ln">‘load’</em>会将<em class="ln">状态.状态</em>更新为<em class="ln">‘LOADED’</em>，所以每当<em class="ln">状态.状态</em>更新为<em class="ln">加载</em>时，我们可以在<em class="ln">文件上传器屏幕</em>中使用它来改变图像。</p><p id="a6ba" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所以我们要做的是使用一个switch case根据<em class="ln"> state.status </em>的值将<em class="ln"> src </em>分配给<em class="ln"> backgroundImage </em> style属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="f775" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们还可以定义一些其他图像，用于其他状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7253" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">用户每做一件事，图像都会不一样。这样我们就不会让用户感到厌烦，所以他们总是很忙。尽你所能让他们留在你的网站上，而不是弹开。当然保持G级就行了:)。</p><p id="91f9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">无论如何，如果你现在试图选择文件，屏幕将不会更新。这是因为我们需要将<em class="ln">状态</em> prop传递给<em class="ln"> FileUploaderScreen </em>:</p><blockquote class="md me mf"><p id="8d91" class="kq kr ln ks b kt ku ju kv kw kx jx ky mg la lb lc mh le lf lg mi li lj lk ll im bi translated"><em class="it"> src/App.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/8eb8334601ffd8176756299e9aa74d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/0*zzkALEoIk5Rj2plb.gif"/></div></figure><p id="c0c3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我不知道你怎么想，但我真的认为接下来需要解决那些丑陋、不成比例的缩略图。这已经不是90年代了，我们有反击！</p><p id="f5d4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所以我们要做的是缩小它们以适合<em class="ln">文件行</em>组件(行列表)。在每一行中，缩略图的宽度尺寸为50px，高度尺寸为50px。这将确保我们在右边有足够的空间，以干净和专业的方式向用户显示文件名和文件大小。</p><p id="6740" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">创建一个名为<code class="fe ma mb mc lq b">FileRow.js</code>的新文件，并将其添加到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="e38e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我使用的样式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="5630" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">事情是这样的:</p><ol class=""><li id="9807" class="nk nl it ks b kt ku kw kx kz nm ld nn lh no ll np nq nr ns bi translated">我们定义了一个<em class="ln"> FileRow </em>组件，它将接收必要的道具来呈现其子组件。<em class="ln">文件</em>、<em class="ln"> src </em>、<em class="ln"> id </em>和<em class="ln">索引</em>来自于我们的<code class="fe ma mb mc lq b">useApp</code>自定义钩子内<em class="ln"> onChange </em>处理程序设置的state.files数组。</li><li id="ab28" class="nk nl it ks b kt nt kw nu kz nv ld nw lh nx ll np nq nr ns bi translated"><em class="ln">I Uploading</em>在这里的目的是在上传文件时呈现一个“上传…”文本和一个加载微调器。</li><li id="80d9" class="nk nl it ks b kt nt kw nu kz nv ld nw lh nx ll np nq nr ns bi translated"><em class="ln"> isUploaded </em>的目的是当行的文件对象处于<em class="ln">状态时，对行进行着色。uploaded </em> —通过id映射。(如果你想知道的话，这就是我们上传<em class="ln">州信息</em>的原因)</li><li id="e8ee" class="nk nl it ks b kt nt kw nu kz nv ld nw lh nx ll np nq nr ns bi translated">由于我们不希望每次更新状态时都呈现每一行，所以我们必须用一个<a class="ae lm" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank"> <em class="ln"> React.memo </em> </a>来包装它，以便记忆这些属性，这样它们只有在<em class="ln">索引</em>、<em class="ln">正在加载</em>或<em class="ln">正在加载</em>发生变化时才会更新。当这些文件正在上传时，这些道具将<em class="ln">永远不会</em>改变，除非发生了重要的事情，所以应用这些条件是安全的。</li><li id="7145" class="nk nl it ks b kt nt kw nu kz nv ld nw lh nx ll np nq nr ns bi translated">getReadableSizeFromBytes 被提供，以便我们呈现人类可读的文件大小。否则，用户将会读到类似于<em class="ln"> 83271328 </em>的数字。</li><li id="a001" class="nk nl it ks b kt nt kw nu kz nv ld nw lh nx ll np nq nr ns bi translated"><em class="ln">旋转器</em>为装载旋转器。</li></ol><p id="30e2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">出于本教程的目的，我使用了<a class="ae lm" href="https://github.com/tsuyoshiwada/react-md-spinner" rel="noopener ugc nofollow" target="_blank">反应-md-spinner </a>。此外，我使用了<a class="ae lm" href="https://github.com/JedWatson/classnames" rel="noopener ugc nofollow" target="_blank"> classnames </a>包来组合/有条件地呈现类名，以便进行条件样式化，从而更加易于控制。</p><p id="62c1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">注意:如果您决定继续使用react-md-spinner/classnames并得到这个错误:</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="3293" class="lu lv it lq b gy lw lx l ly lz">Cannot find module babel-preset-react-app/node_modules/@babel/runtime</span></pre><p id="1f38" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">那么你可能需要安装<code class="fe ma mb mc lq b">@babel/runtime.</code></p><blockquote class="md me mf"><p id="7268" class="kq kr ln ks b kt ku ju kv kw kx jx ky mg la lb lc mh le lf lg mi li lj lk ll im bi translated"><em class="it"> src/Spinner.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="9a35" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我使用的样式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="4554" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="ln">现在</em>如果你尝试选择文件，界面看起来比以前流畅很多:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/c5d3458ab661a76c7a388a336d05d0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/0*TB56Sjm_Fs_RQbP8.gif"/></div></figure><p id="d2e4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">接下来我们需要做的是让屏幕显示文本更新，这样用户就不会对正在发生的事情感到困惑。否则，<em class="ln">文件上传屏幕</em>是没有用的，因为它现在只是旋转图像。</p><p id="28b7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里的技巧是使用强大的<em class="ln"> state.status </em>属性，就像我们处理图像旋转一样。</p><p id="db7a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">知道了这一点，我们可以让它在每次状态更新时呈现定制组件。</p><p id="1138" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">转到<code class="fe ma mb mc lq b">FileUploaderScreen.js</code>文件，通过有条件地渲染“<em class="ln"> init/idle </em>”组件开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/aa1e84e8ed70821dd865aca41f1a37ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/0*IPRbVF-k_ZVDYECg.jpg"/></div></figure><p id="3fc6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">似乎我们现在的形象有点光明。因此，我们将定义几个类样式来根据渲染的图像更新亮度:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><blockquote class="md me mf"><p id="40c5" class="kq kr ln ks b kt ku ju kv kw kx jx ky mg la lb lc mh le lf lg mi li lj lk ll im bi translated"><em class="it">src/file uploaders screen . js</em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="edcd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在应该更容易看出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/0a144eab5eb980c611e8c88ee725a9f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/0*skIrTE41nUontcKa.jpg"/></div></figure><p id="13a3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用与我们之前处理<em class="ln"> Init </em>组件相同的概念，我们可以用相同的方式实现其余的组件:</p><blockquote class="md me mf"><p id="362b" class="kq kr ln ks b kt ku ju kv kw kx jx ky mg la lb lc mh le lf lg mi li lj lk ll im bi translated"><em class="it">src/file uploader screen . js</em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="4c9c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">以下是他们使用的所有风格:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="0d24" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当<em class="ln"> state.status' </em>值为'<em class="ln"> LOADED </em>'时，呈现<em class="ln"> Loaded </em>组件。奇怪的是,“上传更多”按钮被我们一开始创建的<em class="ln">文件上传器</em>所包装。"那在那里做什么呢？"你可能会问。</p><p id="a397" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在文件上传屏幕通过初始步骤后，我们不再希望整个组件触发文件浏览器。我很快会再讲一遍。</p><p id="9cca" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="ln">未决</em>组件用于显示上传正在进行中<em class="ln"/>，以便他们<em class="ln">在等待时知道</em>有事情发生。这部分对我们用户来说非常重要！</p><p id="c7c7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">上传过程完成后，立即显示<em class="ln">成功</em>组件。</p><p id="645e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，当上传出错时，显示<em class="ln">错误</em>组件。这是为了帮助用户理解当前的情况，而不是让他们自己去发现。</p><p id="7766" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们要做的下一件事是更新<code class="fe ma mb mc lq b">App.js</code>:</p><blockquote class="md me mf"><p id="4aca" class="kq kr ln ks b kt ku ju kv kw kx jx ky mg la lb lc mh le lf lg mi li lj lk ll im bi translated"><em class="it"> src/App.js </em></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="c58c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们给我们的<em class="ln"> useApp </em>钩子添加了一个新函数<em class="ln"> getFileUploaderProps </em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="1718" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们将这一部分提取到一个单独的函数中的原因是，在最初的<em class="ln">文件上传器屏幕</em>中，我们将<em class="ln"> triggerInput </em>和<em class="ln"> onChange </em>处理程序直接应用于<em class="ln">文件上传器</em>中的根组件。在第一个屏幕改变后，我们不希望整个文件上传器屏幕组件再触发文件浏览器(因为我们<em class="ln">在<em class="ln">第二个</em>屏幕上</em>提供了一个<em class="ln">上传更多的</em>按钮)。</p><p id="a30f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这就是为什么我们在<em class="ln">应用</em>组件中有这个:</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="bcc1" class="lu lv it lq b gy lw lx l ly lz">const initialFileUploaderProps = getFileUploaderProps({<br/>  triggerInput: status === 'IDLE' ? triggerInput : undefined,<br/>  onChange: status === 'IDLE' ? onChange : undefined,<br/>})</span></pre><p id="e44e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">并使用它将其参数传播给<em class="ln">文件上传者</em>:</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="5e1c" class="lu lv it lq b gy lw lx l ly lz">&lt;FileUploader {...initialFileUploaderProps}&gt;<br/>  &lt;FileUploaderScreen<br/>    triggerInput={triggerInput}<br/>    getFileUploaderProps={getFileUploaderProps}<br/>    files={files}<br/>    pending={pending}<br/>    status={status}<br/>  /&gt;<br/>&lt;/FileUploader&gt;</span></pre><p id="eaf4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，<em class="ln"> FileUploader </em>将像平常一样传入所有4个参数，但对于其余屏幕，将具有来自<em class="ln"> props.triggerInput </em>和<em class="ln"> props.onChange </em>的<em class="ln">未定义的</em>值。在react中，<em class="ln"> onClick </em>处理程序<em class="ln">在<em class="ln">未定义</em>时</em>不会触发。这将禁用点击处理程序，因此我们可以将<em class="ln">上传更多</em>按钮指定为选择文件的新处理程序。</p><p id="e3e0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是这个应用现在的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/85a66e53dda5558ee093e8aa514fccfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/0*oi1h_8Vbs66Hxvto.gif"/></div></figure><p id="c914" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">到目前为止一切顺利。但是看起来好像文件行列表中的加载微调器在上传文件时笨拙地把东西推到了一边。</p><p id="4a7f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您是否注意到在<em class="ln">微调器</em>组件上应用了一个<em class="ln">柔性中心</em>属性？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="08d5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">是的，我们错过了CSS。所以让我们把它直接放入CSS文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/b513435c0a4ff956e305b618ab1addc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/1*yNj7ncpL2EsY4O_b2OtRkw.gif"/></div></figure></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="4072" class="oh lv it bd ml oi oj ok mo ol om on mr jz oo ka mu kc op kd mx kf oq kg na or bi translated">结论</h1><p id="ed4a" class="pw-post-body-paragraph kq kr it ks b kt nc ju kv kw nd jx ky kz ne lb lc ld nf lf lg lh ng lj lk ll im bi translated">本教程到此结束！如果你想看到奖励(绿色箭头指向<em class="ln">下一页</em>按钮)，你可以在GitHub <a class="ae lm" href="https://github.com/jsmanifest/upload-app" rel="noopener ugc nofollow" target="_blank">这里</a>看到源代码中的实现。</p><p id="379c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我为在本教程快结束时的匆忙道歉。我不确定它是否变得太长或者太无聊:)让我知道这个教程对你来说怎么样！</p><p id="a325" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">感谢您的阅读，我希望您能期待更多来自我的优质帖子！</p></div></div>    
</body>
</html>