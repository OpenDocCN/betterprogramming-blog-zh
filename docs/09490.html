<html>
<head>
<title>Exploring Polymorphism in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Python中的多态性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-polymorphism-in-python-f12b167c5e9f?source=collection_archive---------5-----------------------#2021-08-31">https://betterprogramming.pub/exploring-polymorphism-in-python-f12b167c5e9f?source=collection_archive---------5-----------------------#2021-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c826" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何应用多态性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ba5670ab42169dcf938821b9f132942d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hfSsRmjyzAXiyjST"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迈克尔·泽兹奇在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="19f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多态在编程中是一个非常著名和有趣的话题。作为一个词，它意味着以几种不同的形式出现。在程序设计中，它可以被定义为具有相同名称但不同功能的函数或函数的组合。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="8919" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多态性可以大致分为两种类型:</p><h1 id="1b26" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">内置多态函数</strong></h1><p id="b9c1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些是可以以不同方式使用的内置运算符或函数。在下面的代码片段中，我们可以看到加法运算符如何用于将两个整数相加，连接两个字符串，以及添加两个列表。类似地，我们可以看到如何使用内置函数<code class="fe mz na nb nc b"> len()</code>来检测字符串和列表的长度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内置多态函数的示例</p></figure><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="9576" class="nj md it nc b gy nk nl l nm nn">Output<br/>Poly Morphism<br/>11<br/>['Poly', 2, '3', '4', 5, 'Morphism']<br/>12<br/>6</span></pre><h1 id="ad8f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">用户自定义多态函数</strong></h1><p id="14f5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">顾名思义，这些是由用户定义或编写来执行不同功能的函数。在下面的代码片段中，我们可以使用multiply函数将两个数字、三个数字或四个数字相乘。我们可以根据自己的需要修改这个函数，因此它可以以多种方式为我们服务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用户定义函数的示例</p></figure><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="552e" class="nj md it nc b gy nk nl l nm nn">Output<br/>6<br/>24<br/>120</span></pre><h1 id="5fbd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何使用多态性？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/d8b60fbb3b0f2f0f90412cc09fd18e74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*qYoWTcncdmYIx8GNQLVS8w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多态性的各种用途</p></figure><h2 id="b3a8" class="nj md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated"><strong class="ak">运算符重载</strong></h2><p id="4bfc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这种类型的重载中，我们可以以各种方式使用运算符，而不仅仅是它的预定义含义，比如乘法运算符可以用于将两个整数相乘或扩展一个字符串。让我们来看一个运算符重载的实际实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运算符重载示例</p></figure><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="871d" class="nj md it nc b gy nk nl l nm nn">Total Cost: 550</span></pre><p id="357d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们试图使用<code class="fe mz na nb nc b">Books</code>类来存储图书的MRP，然后找到总成本，而<code class="fe mz na nb nc b">__add__</code>函数帮助我们实现了这个目标。如果我们不包含<code class="fe mz na nb nc b">__add__</code>函数，我们将会得到一个错误，我们将不能添加两个对象。因此，根据这里的<code class="fe mz na nb nc b">__add__</code>函数的功能，操作符重载将帮助我们添加两个或更多的对象。</p><h2 id="1184" class="nj md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated"><strong class="ak">方法重载</strong></h2><p id="c63c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">方法重载的简单含义是一个包含多个同名但参数不同的方法的类。现在，Python出现了一个问题。Python默认不支持方法重载，但是有几种不同的方法可以实现它。让我们借助一个例子来理解它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">方法重载的例子</p></figure><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="fc60" class="nj md it nc b gy nk nl l nm nn">No Food Item Booked<br/>Lunch Booked<br/>Lunch &amp; Dinner Booked</span></pre><p id="51f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们可以看到一个类<code class="fe mz na nb nc b">Book_Food</code>，其中有一个<code class="fe mz na nb nc b">book</code>函数，它的参数为<code class="fe mz na nb nc b">None</code>，每当我们传递参数时，它都会根据这些参数进行操作，因此它可以表现为单参数、双参数和无参数函数。我们可以在这里添加几种类型的逻辑，使它根据我们的需要以不同的方式运行。</p><h2 id="a9be" class="nj md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated"><strong class="ak">方法覆盖</strong></h2><p id="7efd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Python中，我们可以重新实现一个方法，并根据需要在子类中改变它的功能。我们可以从父类继承子类中的方法，这些方法有相同的名称，可能有相同的参数，但功能不同。这个过程被称为<code class="fe mz na nb nc b">Method Overriding</code>，在我们的父类方法的功能不适合子类的情况下非常有用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">方法重写的示例</p></figure><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="b4d4" class="nj md it nc b gy nk nl l nm nn">19.0<br/>19.0<br/>50</span></pre><h2 id="f9f4" class="nj md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated"><strong class="ak">鸭子打字</strong></h2><p id="cbd3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">它来自下面的引用:</p><blockquote class="oa ob oc"><p id="ad48" class="kz la od lb b lc ld ju le lf lg jx lh oe lj lk ll of ln lo lp og lr ls lt lu im bi translated">"如果它看起来像鸭子，叫起来也像鸭子，那它就是鸭子."</p></blockquote><p id="2a9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着定义方法的类并不重要，重要的是它定义的方法。在这个功能中，我们根本不检查类型，而是检查方法及其定义。我们可以用一个类似于方法覆盖的例子来理解它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鸭子打字的例子</p></figure><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="e78f" class="nj md it nc b gy nk nl l nm nn">19.0<br/>50<br/>19.0</span></pre><p id="6b0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们可以看到我们在每个类中都调用了相同的方法名，但是它们的功能是不同的，这就是我们所关注的。</p><p id="19a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>