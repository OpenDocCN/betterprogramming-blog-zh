<html>
<head>
<title>How to Use Property Decorators to Prevent API Break Changes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用属性装饰器来防止API中断更改</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-property-decorators-to-prevent-api-break-changes-ed0e8c8b4949?source=collection_archive---------6-----------------------#2020-10-02">https://betterprogramming.pub/how-to-use-property-decorators-to-prevent-api-break-changes-ed0e8c8b4949?source=collection_archive---------6-----------------------#2020-10-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f1c9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让您的API保持一致</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/506be0d0b41bd8d142843045666219e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-OjyKmsu2F_cyWzd"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@acharki95?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿齐兹·阿查基</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="1d24" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="6c16" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一些Python程序员为其他人开发包和框架。在这种情况下，他们的代码包括其他开发人员可以使用的公共API。当我们设计软件包时，并不总是能够预见到技术世界发展过程中可能出现的所有潜在问题——我们也不能预见到每一个相关的业务需求。通常，我们必须不断更新我们的软件包，这是当你看到你可能使用的不同版本的软件包时。</p><p id="df90" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于Python的开源特性，大多数Python程序，包括许多包本身，都依赖于其他Python包。可能发生的一个常见情况是，某一天您的代码工作正常，但在您更新了程序的一些依赖项后，第二天它就停止工作了。当然，这也是为什么人们使用Docker这样的容器来解决这些依赖相关的问题。但是从包开发人员的角度来看，我们应该不惜一切代价努力防止API-break更改。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="f285" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">属性</h1><p id="3562" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">作为一种面向对象的编程语言，Python主要通过创建各种对象来实现其功能。正如其他OOP语言一样，Python对象的一个特性是拥有适用的属性。</p><p id="6844" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">假设我们正在构建一个客户端管理程序。数据模型用于管理每个客户端的信息。为此，在程序的初始版本中，我们有以下代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户端类别V0</p></figure><p id="86d5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如您所见，我们有<code class="fe ng nh ni nj b">Client</code>类，每个实例都有<code class="fe ng nh ni nj b">first_name</code>、<code class="fe ng nh ni nj b">last_name</code>、<code class="fe ng nh ni nj b">middle_initial</code>和<code class="fe ng nh ni nj b">initials</code>属性。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="95c1" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">问题是</h1><p id="5b7e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu">在我们继续之前，先做一个简短的声明:</strong>这个问题可以通过首先采用适当的设计来避免。此处的插图主要用于演示目的。</p><p id="f44a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">假设我们的程序很受欢迎，很多公司都用我们的程序。然而，一个新的功能需求出现了——一些公司希望能够改变客户的姓氏，因为在美国，女性结婚后改变姓氏并不罕见。</p><p id="44e8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">随着某人姓氏的改变，他们的姓名首字母也随之改变。然而，在创建客户端实例时，我们已经硬编码了某人的姓名首字母。为了解决这个问题，我们实际上可以将获取<code class="fe ng nh ni nj b">initials</code>作为一个函数，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户类别V1</p></figure><p id="cbc1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，这种实现会给其他一些公司带来问题，因为<code class="fe ng nh ni nj b">initials</code>属性是实例对象的属性，作为<code class="fe ng nh ni nj b">client.initials</code>被访问。经过这次修改，我们将不得不通过调用函数<code class="fe ng nh ni nj b">client.initials()</code>来获取某人的姓名首字母。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">突破API的变化</p></figure><p id="5656" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如上所示，本质上，我们引入了一个break变更(即，一个API变更使得现有代码停止工作)。没有程序员喜欢看到他们的代码因为依赖包的改变而停止工作。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="00b7" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">房地产装修工</h1><p id="97e6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了防止这种API中断变化，我们可以利用<code class="fe ng nh ni nj b">property</code>装饰器。在我们解释它是什么之前，让我们看看下面代码片段中的<code class="fe ng nh ni nj b">Client</code>类的更新版本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户类别V2</p></figure><p id="b5ab" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要使用<code class="fe ng nh ni nj b">property</code>装饰器，我们只需将<code class="fe ng nh ni nj b">@property</code>放在我们在<code class="fe ng nh ni nj b">Client</code>类的<code class="fe ng nh ni nj b">V1</code>中声明的函数<code class="fe ng nh ni nj b">initials()</code>之上。有了这个<code class="fe ng nh ni nj b">property</code>装饰器，它允许我们使用点符号而不是调用函数来访问属性，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">物业装饰</p></figure><p id="98ad" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">代码向您展示了我们可以使用相同的点符号来访问<code class="fe ng nh ni nj b">initials</code>属性(或<code class="fe ng nh ni nj b">Client</code>类<code class="fe ng nh ni nj b">V2</code>的属性)。本质上，我们通过实现属性装饰器来防止API中断更改。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="20ce" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">属性装饰器的其他好处</h1><p id="071d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">前一节向您展示了我们如何使用<code class="fe ng nh ni nj b">property</code> decorator通过允许我们使用点符号访问属性来保持API的一致性，就像访问属性一样。然而，<code class="fe ng nh ni nj b">property</code>装饰器有额外的好处。</p><ul class=""><li id="0046" class="nk nl it lt b lu mn lx mo ma nm me nn mi no mm np nq nr ns bi translated">它允许我们更好地控制如何为特定属性设置值——或者某些内容是否可以设置。对于常规属性，我们不能直接控制当前的代码。例如，对于<code class="fe ng nh ni nj b">initials</code>的情况，我们不希望它被手动设置。使用<code class="fe ng nh ni nj b">property</code>装饰器，如果我们没有为<code class="fe ng nh ni nj b">property</code>实现setter，它是不可设置的，如下所示。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">设定器控制</p></figure><ul class=""><li id="5f9e" class="nk nl it lt b lu mn lx mo ma nm me nn mi no mm np nq nr ns bi translated">因为在引擎盖下，属性是作为函数实现的，这给了我们在函数内添加额外操作的可能性。例如，假设我们希望在有人试图访问首字母时得到通知(尽管我认为这在现实中并不重要)。这个功能可以通过<code class="fe ng nh ni nj b">property</code>装饰器实现，如下所示。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据监控</p></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="aba8" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">结论</h1><p id="459c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们主要回顾了如何使用<code class="fe ng nh ni nj b">property</code>装饰器来防止可能的API中断更改。此外，我们还谈到了在你的项目中使用<code class="fe ng nh ni nj b">property</code>装饰者的其他好处。</p><p id="32ae" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">感谢你阅读这篇文章。</p></div></div>    
</body>
</html>