<html>
<head>
<title>Beginning Python Programming — Part 16</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python编程入门—第16部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/beginning-python-programming-part-16-5703d8f0fad3?source=collection_archive---------15-----------------------#2019-07-15">https://betterprogramming.pub/beginning-python-programming-part-16-5703d8f0fad3?source=collection_archive---------15-----------------------#2019-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="56e2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们来谈谈测试驱动开发</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a123b2188298822fe2e854e193a7c04e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mPjWjj6RkWX7QzH9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@michalp24?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米哈尔·皮查多</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="245e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一篇文章中，我们介绍了多处理，完成异步。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/beginning-python-programming-part-15-ae96dd8b9c95" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Python编程入门—第15部分</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">多重处理简介</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="9247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将涵盖任何编程语言最关键的方面。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="b950" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">测试</h1><p id="71ac" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">测试代码最流行的两个模块是<code class="fe nr ns nt nu b">unittest</code>和<code class="fe nr ns nt nu b">PyTest</code>。我选择在本文中讨论<code class="fe nr ns nt nu b">unittest</code>,因为它是Python附带的。</p><p id="b3bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nr ns nt nu b">unittest</code>是Python提供的一个框架，允许您创建关于代码的断言。如果断言为真，测试通过。</p><p id="9b57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始测试之前，我们应该了解一些关于测试代码的事情，其中一些是社区中分歧很大的。</p><p id="21c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种不同形式的测试:</p><ul class=""><li id="52d2" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated"><strong class="lb iu">单元测试</strong>——覆盖你的代码的各个部分的测试(这就是本文的内容)</li><li id="0c82" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><strong class="lb iu">可靠性测试(冒烟测试)</strong> —确保您的整个程序能够经受住时间的考验或者不会崩溃的测试。(冒烟测试这个名字来源于一个古老的诀窍，如果你打开一个东西，它没有开始冒烟，它应该会工作。)</li><li id="77c1" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><strong class="lb iu">质量保证测试</strong> —由QA团队执行的测试(如果有)。QA工程师被训练成你代码的混沌猴子。(致质量保证工程师:我充满爱心地说这句话。)</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><ul class=""><li id="aacf" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated"><strong class="lb iu">用户验收测试</strong> —你的代码交给一个测试你的代码的试验小组。试点小组越大，你得到的结果就越多。(例如，早期接入游戏)</li></ul><p id="f3bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些测试可以按任何顺序进行，但这是典型的使用顺序。</p><ul class=""><li id="2155" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated"><strong class="lb iu">代码覆盖率</strong> —测试覆盖的代码的百分比。</li><li id="5dc8" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><strong class="lb iu">覆盖率</strong>——定义测试数量与代码行数量的比率。</li></ul><p id="6807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道这些是敏感的话题，所以我要理性地讨论它。</p><p id="0589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拥有100%的代码覆盖率总是很好的，但至少你应该关注你的应用程序的业务逻辑，这是你的程序被创建来做的代码的主要部分。在大多数情况下，一个好的最低限度应该是30%的覆盖率，尽管你可以通过一些设计良好的测试轻松达到80%的覆盖率。一个设计良好的测试应该覆盖代码的大范围工作流，比如检查web服务器应用程序的响应以确保它是正确的。您可以将路由、业务逻辑甚至数据库逻辑都包含在一个测试中。</p><p id="a0a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">覆盖率通常是一些开发人员的吹嘘点。有的会说“我有1:1的比例”(一行代码一个测试)。这可能意味着大量浪费的生产周期。在中大型项目中，更好的目标是1:10甚至1:20。这在浪费生产力和测试准确性之间提供了一个中间地带。</p><ul class=""><li id="d307" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">测试驱动开发(TDD)——TDD是一种先对比<em class="oj">代码，然后编写测试</em>的方法。TDD首先编写一个测试，然后编写最少的代码来通过测试。</li></ul><p id="cded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TDD和覆盖率通常是齐头并进的；如果你曾经听到一个开发人员谈论他们的测试比率，他们可能正在使用TDD。TDD不是一件坏事，但是如果你不小心的话，它会很快引起维护上的麻烦。</p><p id="ee6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">举个例子吧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om ol l"/></div></figure><p id="e00b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要<code class="fe nr ns nt nu b">import unittest</code>将模块拉进来进行测试。接下来，我们有一个基本的<code class="fe nr ns nt nu b">add</code>函数，它将两个数相加。</p><p id="9f83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们创建一个名为<code class="fe nr ns nt nu b">TestAddFunction</code>的类，它继承自<code class="fe nr ns nt nu b">unittest.TestCase</code>，将包含我们为上面的add函数创建的每个测试。在真实的场景中，您的类将包含与工作流功能相关的所有测试。如果工作流是从一个文件中检索名称，您将测试打开一个文件，读取文件，解析名称，并确保从文件中检索的名称的值和数量是正确的。</p><p id="7972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建的第一个测试是<code class="fe nr ns nt nu b">test_add_numbers</code>。它唯一的职责是测试我们的add函数是否返回了正确的结果。首先，我们调用函数并将结果存储在一个变量中。最后，我们使用<br/> <code class="fe nr ns nt nu b">self.assertEqual(result, 4, "Whoops")</code>来检查我们函数的结果确实是4。由于我们继承了<code class="fe nr ns nt nu b">unittest.TestCase</code>，我们收到了相当多的断言来帮助我们测试代码。</p><p id="b2c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nr ns nt nu b">assertEqual</code>需要三个参数。前两个是我们想要比较的值，第三个是我们想要在测试失败时打印到控制台的消息。在这个基本的例子中，测试失败的原因是显而易见的，但是有时您可能有不止一个断言，这有助于确定哪个断言失败了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om ol l"/></div></figure><p id="f026" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了运行测试，您可以使用以下命令:</p><pre class="kj kk kl km gt on nu oo op aw oq bi"><span id="2bb2" class="or mv it nu b gy os ot l ou ov">cd /path/to/project<br/>python -m unittest</span></pre><p id="16cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在项目目录中创建了一个虚拟环境，那么您需要在最后指定一个文件名:</p><pre class="kj kk kl km gt on nu oo op aw oq bi"><span id="2af9" class="or mv it nu b gy os ot l ou ov">python -m unittest tests.py</span></pre><p id="0582" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在PyCharm中，您需要<a class="ae ky" href="https://www.jetbrains.com/help/pycharm/2019.1/creating-run-debug-configuration-for-tests.html" rel="noopener ugc nofollow" target="_blank">为测试</a>添加一个运行配置。</p><h2 id="e9bb" class="or mv it bd mw ow ox dn na oy oz dp ne li pa pb ng lm pc pd ni lq pe pf nk pg bi translated">安装和拆卸</h2><p id="93bd" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">有时你需要在测试前后执行工作。<code class="fe nr ns nt nu b">setUp</code>和<code class="fe nr ns nt nu b">tearDown</code>允许您配置您的测试环境，因此您不需要在生产系统中测试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om ol l"/></div></figure><p id="d7a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是一个简单的测试，确保文件不是空的。这里我们使用<code class="fe nr ns nt nu b">self.assertTrue(len(contents), "Empty file")</code>进行测试。<code class="fe nr ns nt nu b">assertTrue</code>需要一个布尔表达式。空弦、<code class="fe nr ns nt nu b">None</code>和<code class="fe nr ns nt nu b">0</code>也等同于<code class="fe nr ns nt nu b">False</code>结果。</p><p id="d650" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们主要关注的是<code class="fe nr ns nt nu b">setUp</code>和<code class="fe nr ns nt nu b">tearDown</code>。<code class="fe nr ns nt nu b">setUp</code>在我们的类创建时被调用。把这个当做测试类的<code class="fe nr ns nt nu b">def __init__(self):</code>。在这里，我们用它来创建一个包含单词“Hello”的新文件。随着测试的继续，它将调用<code class="fe nr ns nt nu b">test_file_read</code>，后者将调用函数<code class="fe nr ns nt nu b">read_file</code>并将响应存储到<code class="fe nr ns nt nu b">contents</code>中。然后我们检查以确保<code class="fe nr ns nt nu b">contents</code>不仅仅是一个空字符串；如果是，我们打印“空文件”</p><p id="37d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最后的检查是断言文件的内容等于“Hello”这看起来像是重复的测试，但是通过首先检查内容的长度，我们可以确信文件至少是存在的。最后的测试是确保文件的内容和我们预期的一样。</p><p id="b6db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们为这个类运行所有的测试时，<code class="fe nr ns nt nu b">tearDown</code>被调用。这是我们执行任何必要清理的地方。在这个场景中，我们在项目目录中创建了一个名为<code class="fe nr ns nt nu b">testfile</code>的文件，我们需要删除它。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="1d5d" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">新闻报道</h1><p id="58bd" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">关于测试还有很多内容要介绍，但是我会把它留给你在下面的推荐阅读中。我想谈谈覆盖率，因为这是你写完测试后知道的方法。如果没有覆盖率，你需要遵循这样的格言“编写测试，直到对失败的恐惧变成对编写测试的厌倦。”</p><p id="cdea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过使用<code class="fe nr ns nt nu b">pip install coverage</code>或者使用Pycharm中的捆绑包来安装覆盖。(设置&gt;构建、执行、部署&gt;覆盖率&gt;使用捆绑的覆盖率. py)</p><p id="3e42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用以下命令从命令行运行并检查测试覆盖率:</p><pre class="kj kk kl km gt on nu oo op aw oq bi"><span id="64dc" class="or mv it nu b gy os ot l ou ov">cd /path/to/project<br/>python -m coverage run<br/>python -m coverage report</span></pre><p id="c979" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将打印类似如下的输出:</p><pre class="kj kk kl km gt on nu oo op aw oq bi"><span id="3516" class="or mv it nu b gy os ot l ou ov">Name      Stmts   Miss  Cover<br/>-----------------------------<br/>tests.py     13      0   100%</span></pre><p id="7572" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nr ns nt nu b">Name</code>是包含测试的文件，<code class="fe nr ns nt nu b">Stmts</code>是在文件中发现的语句数量，<code class="fe nr ns nt nu b">Miss</code>是覆盖率遗漏的测试数量，<code class="fe nr ns nt nu b">Cover</code>是被测试覆盖的代码百分比。</p><p id="e143" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要查看选项列表，请使用<code class="fe nr ns nt nu b">python -m coverage help</code>。</p><p id="cfd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在PyCharm中，选择Run &gt; Run tests with coverage。测试覆盖了绿色阴影线。您还将在右侧栏中看到每个文件的统计数据(默认布局)。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f639" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">测试驱动开发(TDD)</h1><p id="b52d" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">TDD是一种测试代码的方法。这个想法是你写一个失败的测试，然后写足够的代码让测试通过。描述这一点的最直接方式是遵循以下步骤:</p><ol class=""><li id="befc" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu ph ob oc od bi translated">添加测试</li><li id="dcfd" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu ph ob oc od bi translated">运行测试。如果通过，请执行第一步。</li><li id="a1af" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu ph ob oc od bi translated">做出改变。</li><li id="3a20" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu ph ob oc od bi translated">运行测试。如果通过，请执行第一步。如果失败，请执行第三步。</li></ol><p id="2e3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们之前的例子中，我们编写了一个函数，然后我们编写了将一次性调用该函数的测试。在TDD中，我们编写测试并运行它，完全知道测试会失败，因为逻辑不存在。然后我们会编写足够的代码来通过测试。如果它仍然失败，我们回过头来检查我们的逻辑，找出失败的原因并做出修正。如果它过去了，我们继续前进。</p><p id="9eca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这只是一个方法论，所以我不会在这里涉及，但是如果你想了解更多，我会在建议阅读中提供一个链接。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f140" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">摘要</h1><p id="21a8" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们学习了如何在Python中进行一些基本的测试，并使用代码覆盖率来计算我们的代码有多少被测试覆盖，并且对TDD进行了简单的介绍。</p><p id="9ca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我过去很难写测试，因为我写的大多数程序都很简单。我不得不改变我的想法。我开始认为我写的每个程序每天都能赚100万美元，直到它失败。为了防止它失败，我需要编写测试来确保它可以在没有维护的情况下运行几十年。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5c8c" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">推荐阅读</h1><h2 id="fa07" class="or mv it bd mw ow ox dn na oy oz dp ne li pa pb ng lm pc pd ni lq pe pf nk pg bi translated">测试断言的完整列表</h2><div class="lv lw gp gr lx ly"><a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.debug" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">单元测试—单元测试框架— Python 3.7.4文档</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">编辑描述</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">docs.python.org</p></div></div></div></a></div><h2 id="d847" class="or mv it bd mw ow ox dn na oy oz dp ne li pa pb ng lm pc pd ni lq pe pf nk pg bi translated">新闻报道</h2><div class="lv lw gp gr lx ly"><a href="https://coverage.readthedocs.io/en/v4.5.x/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Coverage.py — Coverage.py 4.5.3文档</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">Coverage.py是一个测量Python程序代码覆盖率的工具。它监控你的程序，记录下…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">coverage.readthedocs.io</p></div></div></div></a></div><h2 id="2dc3" class="or mv it bd mw ow ox dn na oy oz dp ne li pa pb ng lm pc pd ni lq pe pf nk pg bi translated">测试驱动开发</h2><div class="lv lw gp gr lx ly"><a href="http://www.agiledata.org/essays/tdd.html" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">测试驱动开发(TDD)简介</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">编辑描述</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">www.agiledata.org</p></div></div><div class="mh l"><div class="pi l mj mk ml mh mm ks ly"/></div></div></a></div><h2 id="d861" class="or mv it bd mw ow ox dn na oy oz dp ne li pa pb ng lm pc pd ni lq pe pf nk pg bi translated">PyTest</h2><div class="lv lw gp gr lx ly"><a href="https://docs.pytest.org/en/latest/#" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">pytest:帮助你编写更好的程序——pytest文档</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">该框架使编写小型测试变得容易，同时还可以扩展以支持应用程序和软件的复杂功能测试。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">docs.pytest.org</p></div></div></div></a></div></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="712d" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">下一步是什么？</h1><p id="1e65" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在本系列的最后一篇文章中，我将提供一些我在开发工作流中使用的技巧。虽然它对我有用，但对初学者来说是一个很好的起点，但不一定对每个人都有用。</p><p id="89db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熟能生巧；在GitHub上阅读其他开发者的代码也是如此。我强烈建议您出去看看其他一些Python项目，并向其他人学习。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/beginning-python-programming-part-17-2d7f4f85efd9" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Python编程入门—第17部分</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">总结工作场所优化</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="pj l mj mk ml mh mm ks ly"/></div></div></a></div></div></div>    
</body>
</html>