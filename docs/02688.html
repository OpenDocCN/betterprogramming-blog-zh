<html>
<head>
<title>Algorithms: Breadth-First Search vs. Depth-First Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法:广度优先搜索与深度优先搜索</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/algorithms-searching-through-a-tree-33610e4577bd?source=collection_archive---------6-----------------------#2019-12-17">https://betterprogramming.pub/algorithms-searching-through-a-tree-33610e4577bd?source=collection_archive---------6-----------------------#2019-12-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="caa6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在树中搜索的不同方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bb003460b5e4d3384bc35039a9c9b646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQgguiM1LRLfM6woK6QTFw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卢克·理查森在<a class="ae ky" href="https://unsplash.com/s/photos/tree?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="c79e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是关于遍历或搜索树形数据结构的。树是一种非线性数据结构。它不像数组或链表那样线性存储数据，而是分层存储(图1)。</p><p id="4fd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将讨论两种流行的搜索算法:广度优先搜索(BFS)和深度优先搜索(DFS)及其应用。我们也将看到哪一个表现更好，什么时候。这是为新的或重温这个主题的读者准备的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/71b47cff4892d3fb295e9efc56a1c00a.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*nzi-kKnzjtNSnFMM7IeKqw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:一棵树的图画</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e572" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">1.深度优先搜索</h1><p id="67a4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">DFS是一种遍历树的搜索算法。搜索是通过访问一个节点，然后在访问其兄弟节点之前访问所有子节点来完成的(具有相同父节点的节点被称为<em class="na">兄弟节点</em>)。</p><p id="7054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过一个例子来理解这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/2c7e34974915d26ec1b94f0799068980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*Pc1N9BbgP1Q0aRBqwV7pSA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2:深度优先搜索</p></figure><p id="02b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以使用一个栈来实现[一个<em class="na">栈</em>是一个用于存储对象的数据结构，其中对象是根据后进先出(LIFO)原则插入和移除的]:</p><p id="2971" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.从根节点开始。标记它访问过。<br/> 2。将其左侧子节点和右侧子节点推送到堆栈中。<br/> 3。从堆栈中弹出一个节点，并将其标记为已访问。将其左侧子节点和右侧子节点推送到堆栈中。<br/> 4。对每个未访问的节点重复步骤3。</p><h2 id="b917" class="nc me it bd mf nd ne dn mj nf ng dp mn li nh ni mp lm nj nk mr lq nl nm mt nn bi translated"><strong class="ak">时间复杂度</strong></h2><p id="8a4f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">时间复杂度为<em class="na"> O(V+E) </em>，其中<em class="na"> V </em>为顶点数，<em class="na"> E </em>为边数。</p><h2 id="7422" class="nc me it bd mf nd ne dn mj nf ng dp mn li nh ni mp lm nj nk mr lq nl nm mt nn bi translated"><strong class="ak">空间复杂度</strong></h2><p id="6326" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">空间复杂度为<em class="na"> O(h) </em>，其中<em class="na"> h </em>为树的最大高度。</p><h2 id="5bc1" class="nc me it bd mf nd ne dn mj nf ng dp mn li nh ni mp lm nj nk mr lq nl nm mt nn bi translated"><strong class="ak">应用</strong></h2><ol class=""><li id="a04d" class="no np it lb b lc mv lf mw li nq lm nr lq ns lu nt nu nv nw bi translated">DFS用于查找两个节点之间的路径。</li><li id="45cc" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">它可以用来进行拓扑排序，这可以用来根据给定的依赖关系来调度作业。</li><li id="c8b4" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">它还可以用来寻找谜题的答案，例如，找到一条走出迷宫的路径，该路径存储在堆栈中。</li></ol></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b790" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">2.广度优先搜索</h1><p id="5b57" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">就像DFS一样，BFS也是一种搜索算法——但有一点不同。首先访问同一级别的节点(然后是下面级别的节点)。一个<em class="na">级</em>是根节点和节点+ 1之间的连接数。</p><p id="d5aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一个例子来形象化这一点。我们将使用用于DFS的同一棵树来理解它们的区别。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/20ab446f523479793f4acdaccf39eae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*fZRBcprgWB7i-lG3eWU-9Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3:广度优先搜索</p></figure><p id="a6b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以使用一个队列来实现[一个<em class="na">队列</em>是一个用于存储对象的数据结构，其中对象是根据先进先出(FIFO)原则插入和移除的]:</p><p id="1c84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.从根节点开始。标记它访问过。<br/> 2。将其左子节点和右子节点推入队列。<br/> 3。从队列中弹出一个节点，并将其标记为已访问。将其左子节点和右子节点推入队列。<br/> 4。重复步骤3，直到队列为空。</p><h2 id="ca8d" class="nc me it bd mf nd ne dn mj nf ng dp mn li nh ni mp lm nj nk mr lq nl nm mt nn bi translated"><strong class="ak">时间复杂度</strong></h2><p id="7d6e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">时间复杂度同DFS— <em class="na"> O(V+E) </em>，其中<em class="na"> V </em>为顶点数，<em class="na"> E </em>为边数。</p><h2 id="2e90" class="nc me it bd mf nd ne dn mj nf ng dp mn li nh ni mp lm nj nk mr lq nl nm mt nn bi translated"><strong class="ak">空间复杂度</strong></h2><p id="90e3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">空间复杂度为<em class="na"> O(l) </em>，其中<em class="na"> l </em>为单级节点的最大数量。</p><h2 id="9da6" class="nc me it bd mf nd ne dn mj nf ng dp mn li nh ni mp lm nj nk mr lq nl nm mt nn bi translated"><strong class="ak">应用</strong></h2><ol class=""><li id="dfd1" class="no np it lb b lc mv lf mw li nq lm nr lq ns lu nt nu nv nw bi translated">BFS用于查找两个节点之间的最短路径。</li><li id="e6eb" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">它被用来在GPS系统中寻找邻近的位置。</li><li id="c4d1" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">它还被用于查找像BitTorrent这样的对等网络中的所有相邻节点。</li></ol></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e39d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">BFS和DFS，你该选哪个？</h1><p id="0c07" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">两种算法的时间复杂度是一样的。但是在空间复杂性的情况下，如果最大高度小于单个级别中的最大节点数，那么DFS将比BFS更优化空间，反之亦然。</p><p id="1fa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果问题涉及到寻找最近邻居或最短路径，BFS表现得更好——就像在DFS的情况下，叶子节点首先被访问。</p><p id="7901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在解决难题或拓扑排序的情况下(即，在到达叶节点时需要评估结果的情况)，DFS表现得更好。</p></div></div>    
</body>
</html>