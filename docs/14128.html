<html>
<head>
<title>A Passwordless Authentication Architecture Based on a One-Time Code Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于一次性代码方法的无密码认证体系结构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-passwordless-authentication-architecture-based-on-a-one-time-code-approach-2ef30d0f25d8?source=collection_archive---------1-----------------------#2022-11-09">https://betterprogramming.pub/a-passwordless-authentication-architecture-based-on-a-one-time-code-approach-2ef30d0f25d8?source=collection_archive---------1-----------------------#2022-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e57e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">thunder OTP——一种由轻量级云原生微服务使用Kotlin实现的架构方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/eb50f510c207e11ad3e2afba124321a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*06-BNE2zzWOfESIuYJRRqA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com/es/s/fotos/password-security?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">与</a>之间</p></figure><p id="61c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无密码身份验证越来越受欢迎，主要原因是当今密码缺乏安全性，因为密码被重复使用和窃取的频率越来越高。第二个原因是密码必须越来越复杂，这降低了用户体验。</p><p id="e801" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安全性和用户体验是任何数字公司的重中之重，通常是直接冲突的。因此，人们对无密码认证感兴趣，因为它承诺同时提供更高的安全性和更好的用户体验。</p><p id="3b47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将解释用于实现无密码解决方案的体系结构方法，该解决方案可以用作独立的身份验证机制或更复杂的MFA解决方案的一部分。我将强调使用Redis集群应用的水平扩展模型和GraalVM的原生映像方法来实现轻量级和高效的服务层。</p><div class="ls lt gp gr lu lv"><a href="https://github.com/sergio11/passwordless_authentication_architecture" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">GitHub—Sergio 11/passless _ authentic ation _ Architecture:thunder OTP—架构方法…</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">无密码认证将是在线认证的未来！无密码身份验证越来越流行…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">github.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div><h1 id="a85c" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">什么是无密码认证？</h1><p id="4692" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">无密码身份验证是一种不使用密码来验证用户身份的方法。相反，passwords使用更安全的替代方案，如所有权因素(一次性密码OTP，注册智能手机)或生物特征(指纹，视网膜扫描)。</p><p id="19be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">密码已经很久不安全了。它们很难记住，也容易放错地方。他们也是网络罪犯的头号目标。以至于81%的入侵都与弱密码或被盗密码有关。</p><p id="ee0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">明确区分用于提供无密码身份验证的不同方法非常重要。有些更安全，有些提供更好的用户体验。这种架构是使用一次性代码(OTPs)解决方案实现的。它们以多因素身份认证过程而闻名，但一次性密码或代码也可用作独立的身份认证方法。</p><h1 id="7255" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">无密码身份验证有哪些类型？</h1><p id="544b" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">无密码认证可以通过多种方式实现。以下是一些例子:</p><ul class=""><li id="b818" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">生物识别:身体特征，如指纹或视网膜扫描，以及行为特征，如打字和触摸屏动态，用于唯一地识别一个人。</li><li id="de07" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">拥有因素:通过用户拥有或携带的东西进行身份验证。例如，智能手机验证器应用程序生成的代码、通过短信或硬件令牌接收的OTP。</li><li id="51a2" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">神奇链接:用户输入他们的电子邮件地址，系统给他们发送一封电子邮件。该电子邮件包含一个链接，单击该链接即可授予用户访问权限。</li></ul><h1 id="46c8" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">OTP在无密码身份验证中是如何工作的？</h1><p id="1f63" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">一次性密码(或OTP)是与参考相关联的数字代码。这些代码被发送给用户，所以只有服务器和用户知道这个代码。当用户在平台中输入代码时，他们被授予访问权限并通过身份验证。</p><p id="bca4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些代码将通过短信、推送通知或电子邮件发送到用户的手机。</p><p id="baeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，一次性代码总是链接到一个唯一的引用，所以不存在不同的使用超越代码的任何机会。OTP也有时间限制，这限制了代码的时间有效性。</p><h1 id="a7e5" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">MFA与无密码身份验证</h1><p id="d1ea" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">这种架构方法可以用作独立的无密码身份验证服务，用更合适的身份验证因素取代常规密码。另一方面，它也可以用作多因素身份认证系统的一部分和验证用户身份的另一个身份认证因素。</p><p id="0f9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，MFA系统可能使用指纹扫描作为主要身份验证因素，使用SMS OTPs作为次要身份验证因素。</p><p id="55fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">人们有时会混淆无密码和MFA，或者将两者互换使用。这是因为许多传统的基于密码的登录系统已经开始使用无密码技术作为他们的第二身份验证因素。</p><h1 id="3633" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">无密码身份验证的优势</h1><p id="b1ab" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">无密码身份验证提供了各种功能和业务优势。具体来说，它有助于:</p><ul class=""><li id="6bd9" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">改善用户体验-消除密码和密码疲劳，并提供对所有应用程序和服务的统一访问。</li><li id="c27a" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">增强安全性—通过消除危险的密码管理技术并减少凭据盗窃和假冒</li><li id="10a2" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">简化IT操作—不再需要发布、保护、轮换、重置和管理密码。</li></ul><h1 id="25ed" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">建筑的主要技术</h1><p id="4b99" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">在深入了解该项目的工作原理之前，我想向大家简要回顾一下该架构中应用的技术:</p><h2 id="7378" class="nv ml iq bd mm nw nx dn mq ny nz dp mu lf oa ob mw lj oc od my ln oe of na og bi translated">Redis集群</h2><p id="d9af" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">Redis是一个开源的内存数据结构存储，它构建缓存和键值NoSQL数据库。Redis集群是Redis的特殊版本，有助于提高Redis数据库的可伸缩性和可用性。更具体地说，它是Redis的一个分布式实现，可以跨多个Redis节点自动分片(即分区)数据。</p><p id="344e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Redis集群有助于提高Redis数据库的可伸缩性、可用性和容错能力，超越Redis的基本版本。Redis集群的功能包括:</p><ul class=""><li id="6886" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">可伸缩性:Redis集群最多可以扩展到1，000个节点。</li><li id="0dea" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">可用性:Redis集群要继续运行，有两个条件——大多数主节点必须是可到达的，并且任何不可到达的主节点必须有一个备份辅助节点。这是一项慷慨的政策，有助于提高Redis数据库的可用性。</li><li id="7f8c" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">写安全:Redis集群试图以写安全的方式运行。它将尝试保留连接到群集中大多数主节点的任何客户端的写入。</li></ul><h1 id="9366" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">HAProxy</h1><p id="9b4f" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">HAProxy(高可用性代理)是一个TCP/HTTP负载平衡器和代理服务器，允许web服务器将传入的请求分布到多个端点。这在过多的并发连接使单个服务器的能力饱和的情况下非常有用。客户端将连接到HAProxy实例，而不是连接到处理所有请求的单个服务器，ha proxy实例将使用反向代理根据负载平衡算法将请求转发到一个可用的端点。</p><h1 id="aa58" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">Ktor框架</h1><p id="4867" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">Ktor是一个异步框架，用于创建微服务、web应用等。从头开始用科特林语写的。</p><h1 id="6a6a" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">GraalVM高性能JDK分发版</h1><p id="ad21" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">GraalVM是基于<a class="ae kv" href="https://en.wikipedia.org/wiki/HotSpot_(virtual_machine)" rel="noopener ugc nofollow" target="_blank"> HotSpot </a> / <a class="ae kv" href="https://en.wikipedia.org/wiki/OpenJDK" rel="noopener ugc nofollow" target="_blank"> OpenJDK </a>的Java VM和JDK，用Java实现。它支持额外的编程语言和执行模式，如提前编译Java应用程序以实现快速启动和低内存占用。</p><h1 id="b40f" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">网络服务器</h1><p id="5ed1" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">Netty是一个NIO客户机服务器框架，它能够快速、轻松地开发网络应用程序，如协议服务器和客户机。它极大地简化了网络编程，如TCP和UDP套接字服务器。</p><h1 id="86b9" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">Twilio SMS API</h1><p id="13d4" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">Twilio的可编程SMS API可帮助您为应用程序添加强大的消息传递功能。</p><p id="7a1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这个REST API，您可以发送和接收SMS消息，跟踪已发送消息的传递，安排以后发送SMS消息，以及检索和修改消息历史。</p><h1 id="5980" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">Firebase云消息传递</h1><p id="5e38" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">Firebase Cloud Messaging (FCM)是一个跨平台的消息传递解决方案，可以让您可靠地免费发送消息。</p><h1 id="be24" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">发送网格</h1><p id="f47b" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">SendGrid是一个基于云的SMTP提供商，它允许您在不维护电子邮件服务器的情况下发送电子邮件。SendGrid管理所有技术细节，从扩展基础设施到ISP拓展和信誉监控，再到白名单服务和实时分析。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/73f43f57c837587aeb4af9c1d1d3402a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gktZZpgI5tDdT_RtRV8geg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">新鲜的照片在<a class="ae kv" href="https://unsplash.com/es/s/fotos/contrase%C3%B1a?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">前</a></p></figure><h1 id="49d0" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">架构概述</h1><p id="65c2" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">在这一节中，我想更详细地介绍一下架构的运作，不过，首先，了解一下我在提出这一设计时所考虑的主要目标会很有意思:</p><ul class=""><li id="42b3" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">更快的启动时间:构建提前编译的微服务，无需预热即可在数毫秒内启动并提供最高性能。</li><li id="9e46" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">低资源使用:构建提前编译的微服务，只使用JVM所需资源的一小部分，这意味着它们的运行成本更低，并且提高了利用率。</li><li id="6fba" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">小型容器映像:尝试在轻量级容器映像中压缩本机可执行文件，以实现更安全、更快速、更高效的部署。</li><li id="3978" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">最小化漏洞:通过从应用程序和库中移除所有未使用的类、方法和字段，尝试使用本机映像来减少攻击面，同时通过将Java字节码转换为本机代码来增加逆向工程的难度。</li><li id="8607" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">使用基于RAM存储器的通用且高效的存储系统，并有可能将数据保存在辅助存储器中以便从故障中恢复，提供了高可用性和可扩展性。</li><li id="86e9" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">实施集中式配置存储库。微服务将下载存储配置的最新版本。</li><li id="6d4e" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">包括基于循环算法的负载平衡器，以最小化响应时间、提高服务性能并避免饱和。</li></ul><p id="af08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到上述所有因素，架构设计如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/bc1de1505a17f74858043033d7702b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uiYTzJ4CYScOvPQF8wy6JQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">无密码建筑</p></figure><p id="6011" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该架构可以用作独立的身份验证服务，也可以作为更复杂的MFA解决方案的一部分。客户端将请求一次性代码或密码来验证其身份。他们将指明希望接收令牌的交付服务(电子邮件、SMS和推送通知是当前可用的选项)。</p><p id="55ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">系统将应用与指定交付服务相关的规则来生成OTP令牌。生成的令牌将保留在Redis群集中，其TTL与服务类型相关联，并将向客户端返回唯一的操作标识符，该标识符可用于后续的验证操作—取消或重新发送。</p><p id="c013" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">系统最多允许三次重新提交操作标识符。如果客户端在验证时提供了不正确的OTP，它将被删除，并且必须请求新的OTP。该系统执行各种检查以防止滥用该服务。</p><p id="9ee8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上图所示，在该架构中，我们可以突出几个不同的部分:</p><h1 id="513b" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">高性能TCP/HTTP负载平衡器</h1><p id="c32e" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">负载平衡可确保我们的服务在流量高峰期间的可用性、正常运行时间和性能。负载平衡旨在实现最佳的资源使用，最大限度地提高服务稳定性，并防止单个组件过载。它将一个服务必须完成的工作量分配给两个或多个服务，允许在相同的时间内完成更多的工作。</p><p id="12df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面我们将向您展示HAProxy是如何使用循环法在这种架构方法中实现的。不过，首先让我们回顾一下HAProxy提供的循环算法。</p><p id="e88d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">循环算法是最常用的实现方法。它根据服务的权重轮流使用负载均衡器后面的每个服务。这也可能是最平滑和最公平的算法，因为服务器的处理时间保持平均分配。作为一种动态算法，循环调度允许随时调整服务器权重。</p><p id="d2d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">负载均衡器的配置是通过<code class="fe oi oj ok ol b">haproxy.cfg</code>文件完成的，在这里我们可以突出显示两个不同的部分:后端和前端。</p><p id="3bfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">后端是一组接收转发请求的服务。后端是在HAProxy配置的后端部分定义的。在其最基本的形式中，后端可以定义为:</p><ul class=""><li id="be22" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">使用哪种负载平衡算法</li><li id="ab66" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">服务器和端口列表</li></ul><p id="afc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">后端可以包含一个或多个服务器。一般来说，通过将负载分散到多个服务器上，向后端添加更多的服务器会增加潜在的负载能力。如果您的一些后端服务器变得不可用，也可以提高可靠性。</p><pre class="kg kh ki kj gt om ol on oo aw op bi"><span id="45fa" class="nv ml iq ol b gy oq or l os ot">backend otp_services<br/>  mode http<br/>  option forwardfor<br/>  balance roundrobin<br/>  server otp_service_1 otp_service_1:8080 check<br/>  server otp_service_2 otp_service_2:8080 check<br/>  server otp_service_3 otp_service_3:8080 check<br/>  server otp_service_4 otp_service_4:8080 check<br/>  server otp_service_5 otp_service_5:8080 check<br/>  server otp_service_6 otp_service_6:8080 check</span></pre><p id="5775" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oi oj ok ol b">balance roundrobin</code>行指定了负载均衡算法</p><p id="66b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oi oj ok ol b">mode http</code>指定将使用第7层代理</p><p id="202a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe oi oj ok ol b">server</code>指令末尾的<code class="fe oi oj ok ol b">check</code>选项指定应该在那些后端服务器上执行健康检查。</p><p id="513e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前端定义了请求应该如何转发到后端。前端在HAProxy配置的<code class="fe oi oj ok ol b">frontend</code>部分定义。它们的定义由以下部分组成:</p><ul class=""><li id="b299" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">一组IP地址和端口(如<code class="fe oi oj ok ol b">10.1.1.7:80</code>、<code class="fe oi oj ok ol b"> *:443</code>等)。)</li><li id="187c" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">美国学术团体委员会</li><li id="698c" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><code class="fe oi oj ok ol b">use_backend</code>规则，根据匹配的ACL条件定义使用哪个后端，和/或<code class="fe oi oj ok ol b">default_backend</code>规则处理所有其他情况</li></ul><pre class="kg kh ki kj gt om ol on oo aw op bi"><span id="dcac" class="nv ml iq ol b gy oq or l os ot">frontend balancer<br/>  bind 0.0.0.0:9090<br/>  mode http<br/>  default_backend otp_services</span></pre><p id="9374" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">HAProxy使用健康检查来确定后端服务器是否可以处理请求。这避免了在服务器变得不可用时从后端手动删除服务器。默认的运行状况检查是尝试建立到服务器的TCP连接。</p><p id="c8cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果服务器运行状况检查失败，无法为请求提供服务，它将在后端被自动禁用，流量将不会转发给它，直到它再次运行状况良好。如果后端中的所有服务器都出现故障，服务将变得不可用，直到这些后端服务器中至少有一个恢复正常。</p><p id="8117" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在下面查看完整的配置文件:</p><pre class="kg kh ki kj gt om ol on oo aw op bi"><span id="82d8" class="nv ml iq ol b gy oq or l os ot">global<br/>  stats socket /var/run/api.sock user haproxy group haproxy mode 660 level admin expose-fd listeners<br/>  log stdout format raw local0 info</span><span id="cbe4" class="nv ml iq ol b gy ou or l os ot">defaults<br/>  mode http<br/>  timeout client 10s<br/>  timeout connect 5s<br/>  timeout server 10s<br/>  timeout http-request 10s<br/>  log global</span><span id="8dee" class="nv ml iq ol b gy ou or l os ot">frontend stats<br/>  bind *:8404<br/>  stats enable<br/>  stats uri /<br/>  stats refresh 10s</span><span id="26c9" class="nv ml iq ol b gy ou or l os ot">frontend balancer<br/>  bind 0.0.0.0:9090<br/>  mode http<br/>  default_backend otp_services</span><span id="a3f7" class="nv ml iq ol b gy ou or l os ot">backend otp_services<br/>  mode http<br/>  option forwardfor<br/>  balance roundrobin<br/>  server otp_service_1 otp_service_1:8080 check<br/>  server otp_service_2 otp_service_2:8080 check<br/>  server otp_service_3 otp_service_3:8080 check<br/>  server otp_service_4 otp_service_4:8080 check<br/>  server otp_service_5 otp_service_5:8080 check<br/>  server otp_service_6 otp_service_6:8080 check</span></pre><p id="6c1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过访问<code class="fe oi oj ok ol b">/haproxy?status</code>来查看服务器状态和正常运行时间的图形表示，如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/b232b1e8e297d42024c1d96dd6c1dee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wFBbJvz4vII5TSXP0uYYvw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">HAProxy负载平衡统计</p></figure><h1 id="b9de" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">由GraalVM原生映像支持的轻量级云原生微服务</h1><p id="7aa2" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">作为使用微服务开发的分布式系统，新的现代应用程序正在为云而构建。事件驱动、异步和反应式设计应该快速有效地扩展。由于编译器的工作方式，HotSpot JVM和JIT编译器并不是支持这种用例并开发云原生解决方案的理想环境。它需要大量的内存和CPU。</p><p id="4aca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让客户充分利用云的按使用付费模式的潜力，构建占用空间更小的应用程序非常重要，这样他们就不会消耗太多的RAM和CPU。占用空间小意味着运行此类应用程序的资源更少，因此成本更低，这是许多组织的一个重要指标。</p><p id="14de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了占用空间更小之外，应用程序启动以快速处理传入请求也很重要。否则，应用程序启动时会丢失大量流量。</p><p id="162f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由Java HotSpot VM实现的微服务保证了只有频繁执行的特定代码段才会被编译成机器代码，因此应用程序的性能主要取决于这些代码段的执行速度。这些关键部分被称为应用程序的热点；因此得名Java HotSpot VM。</p><p id="8f49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当JVM解释字节码时，JIT分析执行并动态地将频繁执行的字节码编译成机器码。这防止了JVM不得不一遍又一遍地解释相同的字节码。</p><p id="24c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Graal VM实现提供了更好的JIT编译器实现，并做了进一步的优化。Graal编译器还提供了提前(AOT) Graal AOT编译选项，以构建可以与嵌入式虚拟机一起独立运行的本机映像。</p><p id="6e7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用GraalVM原生映像技术，我们可以提前将服务编译成本生代码，从而使生成的二进制文件不依赖于JVM来执行。这个可执行文件可以作为一个独立的应用程序放在一个容器中，启动速度非常非常快。</p><p id="f634" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在下图中看到的，多阶段docker构建用于生成轻量级的基于发行版的映像，该映像将只执行由GraalVM本机映像生成的服务二进制文件。</p><pre class="kg kh ki kj gt om ol on oo aw op bi"><span id="7f60" class="nv ml iq ol b gy oq or l os ot"># ---- Building phase ----<br/>FROM ghcr.io/graalvm/native-image:22.2.0 AS builder<br/>RUN mkdir -p /tmp/export/lib64 \<br/>    &amp;&amp; cp /usr/lib64/libstdc++.so.6.0.25 /tmp/export/lib64/libstdc++.so.6 \<br/>    &amp;&amp; cp /usr/lib64/libz.so.1 /tmp/export/lib64/libz.so.1<br/>COPY --chown=gradle:gradle .. /home/gradle/src<br/>WORKDIR /home/gradle/src<br/>RUN ./gradlew clean nativeCompile --no-daemon --debug</span><span id="fe48" class="nv ml iq ol b gy ou or l os ot"># ---- Release ----<br/>FROM gcr.io/distroless/base AS release<br/>COPY --from=builder /tmp/export/lib64 /lib64<br/>COPY --from=builder /home/gradle/src/build/native/nativeCompile/otp_graalvm_service app<br/>ENV LD_LIBRARY_PATH /lib64<br/>EXPOSE 8080<br/>ENTRYPOINT ["/app"]</span></pre><p id="a980" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有必要考虑本机映像试图通过检测所有这些调用静态分析来解析目标元素(如用户方法、类……)。然而，这种分析无法检测到运行时所需的所有元素。因此，我们必须使用手动配置来指定它们。</p><p id="c765" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使准备这些配置文件更加容易和方便，GraalVM提供了一个代理，它跟踪常规Java VM上执行的动态特性的所有使用情况。我在开发阶段通过这个命令使用了它:</p><pre class="kg kh ki kj gt om ol on oo aw op bi"><span id="02fe" class="nv ml iq ol b gy oq or l os ot">java -agentlib:native-image-agent=config-merge-dir=./config -jar otp_service.jar</span></pre><p id="e088" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在执行过程中，代理与Java VM交互，拦截所有查询类、方法、字段、资源或请求代理访问的调用。然后，代理在指定的输出目录中生成文件<code class="fe oi oj ok ol b">jni-config.json</code>、<code class="fe oi oj ok ol b">reflect-config.json</code>、<code class="fe oi oj ok ol b">proxy-config.json</code>和<code class="fe oi oj ok ol b">resource-config.json</code>。生成的文件是JSON格式的独立配置文件，其中包含所有截获的动态访问。</p><p id="418a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可能需要使用不同的输入多次运行目标应用程序，以触发单独的执行路径，从而更好地覆盖动态访问。代理通过<code class="fe oi oj ok ol b">config-merge-dir</code>选项支持这一点，该选项将拦截的访问添加到一组现有的配置文件中</p><p id="dab1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为为了更好地覆盖动态访问，需要用不同的输入多次运行目标应用程序来触发单独的执行路径。代理通过config-merge-dir选项支持这一点，该选项将拦截的访问添加到现有的一组配置文件中，正如我在上面的命令中使用的那样。</p><p id="ac90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些文件需要在原生Gradle映像构建时通过<code class="fe oi oj ok ol b">ReflectionConfigurationFile</code>和<code class="fe oi oj ok ol b">ResourceConfigurationFiles</code>选项提供。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="7eae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，与使用基于热点的图像消耗130M内存相比，我们的轻量级服务仅消耗约20M内存，正如您在下面的容器统计图像中所看到的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/a6d4bfd34191e843ba050198fc897f47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4bNRye_57xb7Kqt_H6xbGw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">本机微服务统计</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/85ea8baf660ebb6227f14c7a559b5c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E58qeTs5Hirl3y0lwrmrGA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">热点微服务统计</p></figure><h1 id="d22b" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">基于Ktor框架的异步服务</h1><p id="c9b3" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">Ktor是一个为Kotlin编写和设计的异步web框架，它利用协程，允许您编写异步代码，而无需自己管理任何线程。</p><p id="18dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一些关于Ktor的背景信息。它得到了Jetbrains的支持，他们也是Kotlin本身的创造者。有谁比从事语言工作的人更适合制作Kotlin web框架呢？</p><p id="2a8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在选择Ktor作为其他框架的首选方案时，我考虑了几个因素，其中一些总结如下:</p><p id="06f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">依赖注入由Koin </strong></p><p id="6504" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Ktor被认为是一个微框架，因此它缺少一些功能和实用程序，而这些功能和实用程序是我们在Spring Framework等更复杂的框架中可以找到的。其中一个没有IoC容器。尽管如此，我们可以集成非常简单的外部库，如Kodein或Koin。在这种情况下，我们选择了koin，智能Kotlin依赖注入库</p><p id="7b08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Koin中定义模块依赖关系非常简单，下面是Jedis客户端声明的摘录，它允许我们与Redis集群通信:</p><pre class="kg kh ki kj gt om ol on oo aw op bi"><span id="704b" class="nv ml iq ol b gy oq or l os ot"><em class="pa">val </em>redisModule = module {<br/>    single {<br/>        JedisCluster(hashSetOf(*get&lt;RedisClusterConfig&gt;().nodes.map {<br/>            HostAndPort(it.host, it.port) }.toTypedArray()) )<br/>    }<br/>}</span></pre><h2 id="5d2f" class="nv ml iq bd mm nw nx dn mq ny nz dp mu lf oa ob mw lj oc od my ln oe of na og bi translated">插件架构</h2><p id="73ec" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">Ktor允许您通过连接新的插件来扩展其功能，这些插件允许我们在处理信息时拥有更多功能，或者支持其他响应格式。</p><p id="4e53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像<code class="fe oi oj ok ol b">ktor-server-request-validation</code>这样的插件已经被用来验证请求中接收到的数据，插件<code class="fe oi oj ok ol b">ktor-server-status-pages-jvm</code>用来充分管理请求处理过程中产生的内部错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h1 id="f3d4" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">易于部署</h1><p id="3492" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">Ktor服务器应用程序可以作为一个独立的包轻松交付，我们只需要首先创建一个服务器。服务器配置可以包括不同的设置:服务器引擎(如Netty、Jetty等。)、各种特定于引擎的选项、主机和端口值等等。</p><p id="34a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oi oj ok ol b">embeddedServer</code>函数是一种在代码中配置服务器参数并快速运行应用程序的简单方法。</p><pre class="kg kh ki kj gt om ol on oo aw op bi"><span id="05fe" class="nv ml iq ol b gy oq or l os ot">fun main() {<br/>    embeddedServer(Netty, port = 8080, host = "0.0.0.0") <strong class="ol ir">{<br/>        </strong>configureKoin()<br/>        configureAdministration()<br/>        configureSerialization()<br/>        configureValidation()<br/>        configureMonitoring()<br/>        configureAuthentication()<br/>        configureRouting()<br/>    <strong class="ol ir">}</strong>.start(wait = true)<br/>}</span></pre><h1 id="03a0" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">易于扩展并覆盖广泛的需求</h1><p id="c0ef" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">Ktor是一个具有扩展可能性的微框架，可以添加额外的功能，这些功能是我们无法用属于框架生态系统的插件覆盖的。</p><p id="6750" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个额外的<code class="fe oi oj ok ol b">AuthenticationProvider</code>来验证使用平台服务的客户端是非常容易的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h1 id="d1d3" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">Redis集群实现可扩展性和高可用性</h1><p id="ba8e" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">Redis集群是一个内置的Redis特性，提供自动分片、复制和高可用性。它能够在多个节点之间自动分割我们的OTPs数据集，并在一部分节点出现故障或无法与集群的其余部分通信时继续运行。</p><p id="8c95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的redis集群将由八个Redis节点组成，其中四个节点将充当主节点，另外四个将充当辅助节点。借助Redis Insight工具，我们可以探索我们架构的配置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/247178d66f10cf21670f40260e44d063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U3YE4vccqGsoQJbfTwwwfA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Redis集群配置概述</p></figure><p id="c39d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用该功能，我已经能够实现以下目标:</p><ul class=""><li id="f79b" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">高性能和线性可扩展性</li><li id="e31b" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">可接受的书写安全度</li><li id="517c" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">它能够在大多数主节点是可到达的并且对于每个不再可到达的主节点至少有一个可到达的辅助节点的分区中存活</li></ul><p id="c4dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于配置中的每个节点，我们将创建一个<code class="fe oi oj ok ol b">redis.conf</code>文件，启用集群模式的配置，此外还有其他必要的配置。</p><pre class="kg kh ki kj gt om ol on oo aw op bi"><span id="5175" class="nv ml iq ol b gy oq or l os ot">port 6379<br/>cluster-enabled yes<br/>cluster-config-file nodes.conf<br/>cluster-node-timeout 5000<br/>cluster-announce-ip 192.168.1.39<br/>cluster-announce-port 6379<br/>cluster-announce-bus-port 16379<br/>appendonly yes<br/>loadmodule /usr/lib/redis/modules/rejson.so</span></pre><p id="4a8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要启用集群模式，需要将<code class="fe oi oj ok ol b">cluster-enabled</code>指令设置为<code class="fe oi oj ok ol b">yes</code>。每个实例还包含存储该节点配置的文件路径，默认情况下是<code class="fe oi oj ok ol b">nodes.conf</code>。</p><p id="2634" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有Redis节点都将基于rejson模块提供的<code class="fe oi oj ok ol b">redislabs/rejson</code>映像，以原生json格式存储和操作内容。在配置文件中，有必要使用<code class="fe oi oj ok ol b">loadmodule</code>指令显式加载该模块。</p><p id="639d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，还需要配置Redis TCP端口和集群总线端口，以允许集群配置内部和外部的通信。</p><pre class="kg kh ki kj gt om ol on oo aw op bi"><span id="deb5" class="nv ml iq ol b gy oq or l os ot"># Redis Node 1<br/>  redis-node-1:<br/>      image: 'redislabs/rejson:latest'<br/>      container_name: redis-node-1<br/>      command: redis-server /usr/local/etc/redis/redis.conf<br/>      volumes:<br/>        - ./data:/var/lib/redis<br/>        - ./conf/node_1/redis.conf:/usr/local/etc/redis/redis.conf<br/>      ports:<br/>        - 6379:6379<br/>        - 16379:16379<br/>      networks:<br/>        redis_cluster_network:<br/>          ipv4_address: 192.168.0.30</span></pre><p id="7f17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个Redis集群节点需要两个开放的TCP连接:一个Redis TCP端口用于服务客户端，例如<code class="fe oi oj ok ol b">6379</code>，另一个端口称为集群总线端口。默认情况下，通过将<code class="fe oi oj ok ol b">10000</code>添加到数据端口来设置集群总线端口(例如<code class="fe oi oj ok ol b">16379</code>)。然而，您可以在<code class="fe oi oj ok ol b">cluster-port</code>配置中覆盖它。</p><p id="1466" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">集群总线是一种使用二进制协议的节点到节点通信通道，由于带宽和处理时间都很少，因此更适合在节点之间交换信息。节点使用集群总线进行故障检测、配置更新、故障转移授权等。客户端不应该尝试与集群总线端口通信，而应该使用Redis命令端口。</p><p id="38a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了方便Redis集群部署，我实现了一个Ruby Rake任务，来统一启动和运行Docker Compose部署以及使用Redis CLI创建集群的过程。</p><pre class="kg kh ki kj gt om ol on oo aw op bi"><span id="bc8d" class="nv ml iq ol b gy oq or l os ot">desc "Start and configure Cluster Containers"<br/>  task :start =&gt; [ :check_docker_task, :login, :check_deployment_file ] do <br/>   puts "Start Cluster Containers"<br/>   puts `docker-compose -f ./redis_cluster/docker-compose.yml up -d`<br/>   puts `docker run -it --rm --network=redis_cluster_redis_cluster_network redislabs/rejson:latest redis-cli --cluster create 192.168.0.30:6379 192.168.0.35:6380 192.168.0.40:6381 192.168.0.45:6382 192.168.0.50:6383 192.168.0.55:6384 192.168.0.60:6385 192.168.0.65:6386 --cluster-replicas 1 --cluster-yes`<br/>  end</span></pre><p id="d35c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里使用的命令是create，因为我们想要创建一个新的集群。选项<code class="fe oi oj ok ol b">--cluster-replicas 1</code>意味着我们希望为每个创建的主服务器创建一个副本。</p><p id="a47e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其他参数是我想用来创建新集群的实例的地址列表。</p><p id="7a41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oi oj ok ol b">redis-cli</code>将提出一个配置。键入yes接受建议的配置。集群将被配置和加入，这意味着实例将被引导以相互通信。最后，如果一切顺利，您将看到如下消息:</p><pre class="kg kh ki kj gt om ol on oo aw op bi"><span id="b4d8" class="nv ml iq ol b gy oq or l os ot">[OK] All 16384 slots covered</span></pre><p id="d8e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着至少有一个主实例服务于16384个可用插槽中的每一个。</p><p id="d25d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过RedisInsight的实时视图，我们可以检查与每个键相关联的信息，甚至可以对其进行操作。下图显示了链接到操作码<code class="fe oi oj ok ol b">2dc15cf8–1761–48c9-b15d-cd348460a218</code>的生成的OTP模型的JSON表示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/dd4e300313e42c177b81101038c64ce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wMvVCh5qes16lg0kq6NNzg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">生成的OTP模型的JSON表示</p></figure><p id="2915" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其他本地redis数据结构也用于实现访问控制列表。下图显示了<code class="fe oi oj ok ol b">authorized_clients</code>键的内容，它包含被授权使用服务的客户端的标识符。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/2b8109cc9be9c759e60a91c4149ba440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nwob0OxZ8TVVz3lonYtvBg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">授权客户</p></figure><h1 id="e72d" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">OTP交付服务</h1><p id="a797" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">我们已经到达了架构的最后一点，在这一点上，我想详细说明用于安全有效地交付OTP的服务。每个服务都有不同的配置，通过电子邮件发送的动态口令比通过短信发送的动态口令更复杂，持续时间更长，生成器在这方面很灵活，所有这些方面都可以在下面的<code class="fe oi oj ok ol b">application.yml</code>文件中进行调整:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="d67e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还可以定制在每个发送者中发送的消息。在每个发送者中，有必要配置服务密钥，以便能够与相应的第三方API进行通信。</p><p id="6770" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">发送方的选择是在生成OTP令牌时做出的。生成端点调用支持字段<code class="fe oi oj ok ol b">type</code>和<code class="fe oi oj ok ol b">destination</code>。</p><p id="af39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想通过“properties”属性定制文本消息，也可以传递一组属性。</p><pre class="kg kh ki kj gt om ol on oo aw op bi"><span id="5f46" class="nv ml iq ol b gy oq or l os ot">curl --location --request POST 'http://localhost:9090/otp/v1/generate' \</span><span id="6c4e" class="nv ml iq ol b gy ou or l os ot">--header 'ClientId: /0GiNd8HKN3PKjOedxi9g3+7oz14gLLLg4fIRGHHSTc=' \</span><span id="2d61" class="nv ml iq ol b gy ou or l os ot">--header 'Content-Type: application/json' \</span><span id="26df" class="nv ml iq ol b gy ou or l os ot">--data-raw '{<br/>"type": "SMS",<br/>"destination": "+34677112233", <br/>"properties": {}<br/>}'</span></pre><p id="78a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们试图生成一个OTP令牌，它将通过SMS发送到目的地。有必要考虑使用<code class="fe oi oj ok ol b">ClientId</code>报头，它允许我们将自己标识为使用服务的授权客户。</p><p id="e691" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前面的请求将激活OTP SMS Sender的执行，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">OTP手机短信发送器</p></figure><p id="2d2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该发送方将使用Twilio库发送带有定制文本消息的SMS，以及我们之前生成的OTP代码。如果在发送过程中出现错误，我们将报告一个<code class="fe oi oj ok ol b">OTPSenderFailedException</code>异常，该异常将丢弃OTP代码并中止该过程。</p><p id="e199" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想要使用电子邮件服务来传递OTP代码，方法将是类似的，简单地说，我们必须将发送者的类型配置为“mail ”,并在目的地中指明电子邮件地址。</p><pre class="kg kh ki kj gt om ol on oo aw op bi"><span id="c9a1" class="nv ml iq ol b gy oq or l os ot">curl --location --request POST 'http://localhost:9090/otp/v1/generate' \</span><span id="1c5c" class="nv ml iq ol b gy ou or l os ot">--header 'ClientId: /0GiNd8HKN3PKjOedxi9g3+7oz14gLLLg4fIRGHHSTc=' \</span><span id="22a8" class="nv ml iq ol b gy ou or l os ot">--header 'Content-Type: application/json' \</span><span id="bd2f" class="nv ml iq ol b gy ou or l os ot">--data-raw '{<br/>"type": "MAIL",<br/>"destination": "testmail@yopmail.com",<br/>"properties": {}<br/>}'</span></pre><p id="b003" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们将激活OTP邮件发送程序的执行，该程序将使用SendGrid库构建电子邮件并将其发送到指定的目的地。在构建电子邮件的过程中，它将指示代表消息内容的所需模板，这些模板可以使用SendGrid提供的WYSWYG工具来制作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">OTP邮件发送者</p></figure><h1 id="d9c1" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">二手技术</h1><ul class=""><li id="5786" class="nh ni iq ky b kz nc lc nd lf pe lj pf ln pg lr nm nn no np bi translated">Redis集群架构(启用rejson模块)</li><li id="db30" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">HAProxy负载平衡器</li><li id="32ab" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">Ktor框架</li><li id="2294" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">网络服务器</li><li id="5fd7" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">GraalVM高性能JDK分发版</li><li id="06e0" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">Twilio Java助手库</li><li id="a51f" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">Sendgrid Java助手库</li><li id="12f1" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">Firebase云消息传递</li><li id="543d" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">Jedis(一个redis Java客户端，为性能和易用性而设计)</li><li id="d70d" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">Hoplite(一个无样板的Kotlin配置库，用于将配置文件作为数据类加载)</li></ul><p id="f51f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是了。我真的很喜欢开发和记录这个小项目。谢谢你阅读它。我希望这是第一次。</p><p id="2446" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您对完整的代码感兴趣，这里是公共存储库的链接:</p><div class="ls lt gp gr lu lv"><a href="https://github.com/sergio11/passwordless_authentication_architecture" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">GitHub—Sergio 11/passless _ authentic ation _ Architecture:thunder OTP—架构方法…</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">无密码认证将是在线认证的未来！无密码身份验证越来越流行…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">github.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div></div></div>    
</body>
</html>