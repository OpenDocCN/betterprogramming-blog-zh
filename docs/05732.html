<html>
<head>
<title>How to Implement Custom Token-Based Authentication in Spring Boot and Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Spring Boot和科特林实现自定义的基于令牌的身份验证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-custom-token-based-authentication-in-spring-boot-and-kotlin-5b59b55c1de2?source=collection_archive---------0-----------------------#2020-08-01">https://betterprogramming.pub/how-to-implement-custom-token-based-authentication-in-spring-boot-and-kotlin-5b59b55c1de2?source=collection_archive---------0-----------------------#2020-08-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="45c3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建更安全的Spring Boot应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3015e34b2d0455c5c12fdc7b9ef82cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qbE9Ft5XiAD0745R"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@seanlimm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">肖恩·林</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="a741" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当构建<a class="ae ky" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a> REST web服务时，我们必须<a class="ae ky" href="https://medium.com/technology-hits/why-devsecops-is-one-the-biggest-tech-trends-in-2021-b8d8c56e38fc" rel="noopener">处理安全性</a>。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/technology-hits/why-devsecops-is-one-the-biggest-tech-trends-in-2021-b8d8c56e38fc" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">为什么DevSecOps是2021年最大的技术趋势之一</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">安全性是IT企业成功的关键</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="34bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现我们的安全目标，比如授权和认证，使用像<a class="ae ky" href="https://spring.io/projects/spring-security" rel="noopener ugc nofollow" target="_blank"> Spring Security </a>这样专门设计的框架可能是最好的解决方案。</p><blockquote class="mn mo mp"><p id="6c31" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">“Spring Security是一个专注于为Java应用程序提供认证和授权的框架。像所有Spring项目一样，Spring Security的真正强大之处在于它可以很容易地扩展以满足定制需求。”–<a class="ae ky" href="https://spring.io/projects/spring-security" rel="noopener ugc nofollow" target="_blank">弹簧安全</a></p></blockquote><p id="1787" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有时实现一个特定的认证逻辑来保持应用程序的简单是必要的。</p><p id="9055" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将要展示的系统将允许我们选择是否保护一个API。此外，我们假设每个有效的认证令牌标识一个特定的用户。令牌位于特定的头或cookie中，由认证逻辑用来提取用户，该用户的数据将被自动传递给受保护的API的函数体。</p><p id="2c7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何在Spring Boot和科特林实现定制的基于令牌的认证。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="1d59" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">1.定义自定义注释</h1><p id="a328" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">为了选择API是否应该受到身份验证系统的保护，我们将使用一个自定义的注释。该注释将用于标记类型为<code class="fe ny nz oa ob b">User</code>的参数，以定义API是否受保护。由令牌标识的特定用户的实例被自动检索，并且可以在API函数体内使用。</p><p id="39de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何定义一个定制的<code class="fe ny nz oa ob b">Auth</code>注释:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="43c7" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">2.定义验证逻辑</h1><p id="dd80" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">认证逻辑应该放在一个特定的组件中，我们准备称之为<code class="fe ny nz oa ob b">AuthTokenHandler</code> <em class="mq">。</em>该类的目的是验证令牌是否有效，并提取其相关用户。这可以通过多种方式实现。我们将展示两种不同的验证方法。</p><p id="1c04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用自定义DAO:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="9099" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用外部API:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="5929" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两种情况下，当令牌丢失或无效时，会抛出一个自定义的<code class="fe ny nz oa ob b">AuthenticationException</code>。在这种情况下，受保护的API应该响应“401未授权”</p><blockquote class="mn mo mp"><p id="0f01" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">“HTTP 401未经授权的客户端错误状态响应代码表示请求尚未应用，因为它缺少目标资源的有效身份验证凭据。”— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401#" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="600c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，标记有<code class="fe ny nz oa ob b"><a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html" rel="noopener ugc nofollow" target="_blank">@ControllerAdvice</a></code>的类可以如下使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="a81d" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">3.正在检索令牌</h1><p id="24fa" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">当定制的<code class="fe ny nz oa ob b">Auth</code>注释被识别时，为了允许Spring Boot自动在头或cookies中寻找令牌，必须定义一个实现<code class="fe ny nz oa ob b"><a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/method/support/HandlerMethodArgumentResolver.html" rel="noopener ugc nofollow" target="_blank">HandlerMethodArgumentResolver</a></code>的<code class="fe ny nz oa ob b">AuthTokenWebResolver</code>。</p><p id="2e96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设身份验证令牌可以放在名为<code class="fe ny nz oa ob b">authToken</code>的头或cookie中。检索逻辑可以如下实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="9c22" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">4.配置Spring Boot</h1><p id="a11f" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">现在，我们必须为配置定义一个定制类。这样，Spring Boot将能够按照设计使用定制的<code class="fe ny nz oa ob b">Auth</code>注释。</p><p id="6b69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了一切正常，我们需要将之前定义的<code class="fe ny nz oa ob b">AuthTokenWebResolver</code>添加到默认的参数解析器中。这可以通过利用<code class="fe ny nz oa ob b"><a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.html" rel="noopener ugc nofollow" target="_blank">WebMvcConfigurationSupport</a></code>类来实现。</p><blockquote class="mn mo mp"><p id="3ccf" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">“[WebMvcConfigurationSupport]通常通过将<code class="fe ny nz oa ob b">@EnableWebMvc</code>添加到应用程序<code class="fe ny nz oa ob b">@Configuration</code>类来导入。另一个更高级的选择是直接从这个类扩展，并根据需要覆盖方法，记住将<code class="fe ny nz oa ob b">@Configuration</code>添加到子类中，将<code class="fe ny nz oa ob b">@Bean</code>添加到被覆盖的<code class="fe ny nz oa ob b">@Bean</code>方法中— <a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.html" rel="noopener ugc nofollow" target="_blank"> Spring的官方文档</a></p></blockquote><p id="91f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将定义一个扩展了<code class="fe ny nz oa ob b">WebMvcConfigurationSupport</code>的<code class="fe ny nz oa ob b">@Configuration</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="980f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用<code class="fe ny nz oa ob b">WebMvcConfigurationSupport</code>，<em class="mq"> </em>时，不要忘记我们必须处理CORS配置。否则，我们的API可能无法像预期的那样到达。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="b75b" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">5.把所有的放在一起</h1><p id="0a51" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">现在，是时候看看如何使用<code class="fe ny nz oa ob b">Auth</code>注释来使API只与经过身份验证的用户一起工作了。这可以通过向所选的控制器API函数添加一个标有<code class="fe ny nz oa ob b">Auth</code>注释的<code class="fe ny nz oa ob b">User</code>类型参数来轻松实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">受基于自定义令牌的身份验证保护的API</p></figure><p id="1d86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，定义缺乏保护的API也是可能的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不受基于自定义令牌的身份验证保护的API</p></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="cca8" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">奖金</h1><p id="ee4e" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">使用非常相似的方法，您可以实现基本的访问认证，如这里的<a class="ae ky" href="https://levelup.gitconnected.com/how-to-implement-basic-access-authentication-in-spring-boot-eaded2e33d19" rel="noopener ugc nofollow" target="_blank">所述</a>。</p><div class="lv lw gp gr lx ly"><a href="https://levelup.gitconnected.com/how-to-implement-basic-access-authentication-in-spring-boot-eaded2e33d19" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">如何在Spring Boot实现基本接入认证</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">让您的Spring Boot API更加安全</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mh l"><div class="oe l mj mk ml mh mm ks ly"/></div></div></a></div></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="af07" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">结论</h1><p id="5142" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">就这些了，伙计们！我希望这有助于您在Spring Boot和科特林定义自定义的基于令牌的身份验证。</p><p id="6f60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何意见或建议，请告诉我。</p></div></div>    
</body>
</html>