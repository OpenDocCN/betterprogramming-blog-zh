<html>
<head>
<title>May I See the SwiftUI Menu, Please?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我可以看看SwiftUI菜单吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/may-i-see-the-swiftui-menu-please-b9d40246c2f5?source=collection_archive---------11-----------------------#2020-01-14">https://betterprogramming.pub/may-i-see-the-swiftui-menu-please-b9d40246c2f5?source=collection_archive---------11-----------------------#2020-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5d1c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在SwiftUI中实现菜单导航</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d70c9976c4d181390f80cb5ee83ef281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*jTztl06EqtQjFvR_1j933Q.jpeg"/></div></figure></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="0a35" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">介绍</h1><p id="3729" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">移动应用程序开发中最常见的导航模式之一是菜单导航。</p><p id="d669" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">虽然这种模式在亚马逊或Gmail等许多应用程序中广泛使用，但苹果从未提供内置的方式来实现这种导航。</p><p id="c8a0" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">回到“旧时代”，当用UIKit设计应用程序时，<a class="ae mq" href="https://github.com/John-Lluch/SWRevealViewController" rel="noopener ugc nofollow" target="_blank"> SWRevealViewController </a>实现这种模式就派上了用场。在本教程中，我们将看到如何使用SwiftUI轻松实现相同的效果。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="5049" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">我们的目标</h1><p id="4993" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">我们的目标是实现一个可重用的菜单，它将从左向右滑动，并显示一个可点击的项目列表。列表中的每一行和显示的内容都可以是任意的<code class="fe mr ms mt mu b">View</code>，这意味着菜单必须支持通用类型。</p><p id="ca08" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">你可以在我的<a class="ae mq" href="https://github.com/fermoya/CustomNavigations" rel="noopener ugc nofollow" target="_blank">回购</a>里找到最终实现。在本教程结束时，您应该会看到这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/57eb9a27d72e81c3db1642ec4cae6cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*l46SamEnILlK93jfzRfY5w.gif"/></div></figure></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="4a9f" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">MenuView</h1><p id="06a5" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">在SwiftUI中实现定制视图时，将所有视图写在同一个文件中可能很有诱惑力。</p><p id="0e4f" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">然而，这阻止了视图的重用，并使我们的代码难以阅读。还记得UIKit里的<em class="mw"/><em class="mw"/>海量<code class="fe mr ms mt mu b">ViewController</code>吗？大型<code class="fe mr ms mt mu b">View</code>怎么样？</p><p id="2a9f" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">创建一个新文件，并将其命名为<code class="fe mr ms mt mu b">MenuView</code>。让我们将该结构定义为:</p><pre class="kj kk kl km gt mx mu my mz aw na bi"><span id="35e6" class="nb ky it mu b gy nc nd l ne nf">struct MenuView&lt;Item, Row, Content&gt;: View where Item: Identifiable &amp; Equatable, Row: View, Content: View {</span><span id="bbab" class="nb ky it mu b gy ng nd l ne nf">    // Content here</span><span id="ab52" class="nb ky it mu b gy ng nd l ne nf">}</span></pre><p id="bf3b" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated"><code class="fe mr ms mt mu b">MenuView</code>定义了三种通用类型:<code class="fe mr ms mt mu b">Item</code>、<code class="fe mr ms mt mu b">Row</code>和<code class="fe mr ms mt mu b">Content</code>。让我们来看看这些是什么:</p><ul class=""><li id="7d0f" class="nh ni it lr b ls ml lv mm ly nj mc nk mg nl mk nm nn no np bi translated"><code class="fe mr ms mt mu b">Item</code>是填充一个<code class="fe mr ms mt mu b">Row</code>的数据模型。</li><li id="fdbd" class="nh ni it lr b ls nq lv nr ly ns mc nt mg nu mk nm nn no np bi translated"><code class="fe mr ms mt mu b">Row</code>是为菜单中的特定项目显示的视图。</li><li id="e8b6" class="nh ni it lr b ls nq lv nr ly ns mc nt mg nu mk nm nn no np bi translated"><code class="fe mr ms mt mu b">Content</code>是屏幕上显示的所选菜单索引的视图。</li></ul><p id="e2e0" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">对于那些已经熟悉SwiftUI的人来说，<code class="fe mr ms mt mu b">Item</code>和<code class="fe mr ms mt mu b">Row</code>听起来可能与<code class="fe mr ms mt mu b">List</code>非常相似。</p><p id="f420" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated"><code class="fe mr ms mt mu b">List</code>接受一个<code class="fe mr ms mt mu b">Identifiable</code>项目集合和一个工厂块，为每个项目生成一个<code class="fe mr ms mt mu b">View</code>。在我们的例子中，<code class="fe mr ms mt mu b">MenuView</code>将采用两个工厂块来构建列表的行和所选行的内容。</p><p id="3797" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated"><code class="fe mr ms mt mu b">MenuView</code>只是一个内置的<code class="fe mr ms mt mu b">List</code>叠加在一个动态内容页面上。</p><h2 id="3553" class="nb ky it bd kz nv nw dn ld nx ny dp lh ly nz oa lj mc ob oc ll mg od oe ln of bi translated">菜单视图依赖项</h2><p id="3ff6" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">要创建一个<code class="fe mr ms mt mu b">MenuView</code>，我们需要传递填充行的项目列表以及两个工厂块，以动态注入行和部分的视图。</p><p id="39ff" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">为此，我们可以利用<code class="fe mr ms mt mu b">@ViewBuilder</code>属性包装器。这将允许我们以一种更“快捷”的方式编写代码，也就是说，以一种更具描述性的方式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="cd31" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">看看这些论点:</p><ul class=""><li id="300d" class="nh ni it lr b ls ml lv mm ly nj mc nk mg nl mk nm nn no np bi translated"><code class="fe mr ms mt mu b">indexSelected</code>代表当前选中的行。</li><li id="ee62" class="nh ni it lr b ls nq lv nr ly ns mc nt mg nu mk nm nn no np bi translated"><code class="fe mr ms mt mu b">menuItems</code>保存元素列表，这些元素将对列表的每一行进行建模。从结构定义中记住它们符合<code class="fe mr ms mt mu b">Identifiable</code>和<code class="fe mr ms mt mu b">Equatable</code>。</li><li id="386b" class="nh ni it lr b ls nq lv nr ly ns mc nt mg nu mk nm nn no np bi translated"><code class="fe mr ms mt mu b">menuItemRow</code>是一个<code class="fe mr ms mt mu b">ViewBuilder</code>。这个工厂方法将有助于动态构建列表的每一行。</li><li id="54fa" class="nh ni it lr b ls nq lv nr ly ns mc nt mg nu mk nm nn no np bi translated"><code class="fe mr ms mt mu b">menuItemContent</code>是另一个工厂方法，将用于创建所选部分的内容。</li></ul><p id="91ab" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">至此，我们已经具备了开始实现<code class="fe mr ms mt mu b">MenuView</code>所需的一切。我们开始工作吧。</p><h2 id="ce95" class="nb ky it bd kz nv nw dn ld nx ny dp lh ly nz oa lj mc ob oc ll mg od oe ln of bi translated">履行</h2><p id="a58f" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">如前所述，<code class="fe mr ms mt mu b">MenuView</code>将包含两个视图:</p><ul class=""><li id="63f1" class="nh ni it lr b ls ml lv mm ly nj mc nk mg nl mk nm nn no np bi translated"><code class="fe mr ms mt mu b">revealList</code>，物品清单。</li><li id="f472" class="nh ni it lr b ls nq lv nr ly ns mc nt mg nu mk nm nn no np bi translated"><code class="fe mr ms mt mu b">contentView</code>，查看所选章节或页面。</li></ul><p id="02b9" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">它们都将被堆叠在彼此之上。<code class="fe mr ms mt mu b">MenuView</code>会保持一个状态，知道<code class="fe mr ms mt mu b">revealList</code>是否可见；</p><pre class="kj kk kl km gt mx mu my mz aw na bi"><span id="2ea3" class="nb ky it mu b gy nc nd l ne nf">@State private var isMenuRevealed: Bool = true</span></pre><p id="9bee" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">扩展<code class="fe mr ms mt mu b">MenuView</code>并声明<code class="fe mr ms mt mu b">revealList</code>和<code class="fe mr ms mt mu b">contentView</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="8852" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">请注意，我们使用工厂块来构建每一行以及所选行的内容。点击时，每一行都会改变<code class="fe mr ms mt mu b">indexSelected</code>并隐藏菜单。</p><p id="90c9" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">我们将使用<code class="fe mr ms mt mu b">ZStack</code>将<code class="fe mr ms mt mu b">revealList</code>堆叠在<code class="fe mr ms mt mu b">contentView</code>之上。</p><p id="e315" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">然而，<code class="fe mr ms mt mu b">revealList</code>将需要一个偏移量，该偏移量将根据<code class="fe mr ms mt mu b">isMenuRevealed</code>而变化。如果是真的，它会覆盖整个屏幕。如果为假，它将滑出屏幕。</p><p id="fe02" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">定义一个助手方法来确定<code class="fe mr ms mt mu b">revealList</code>偏移量:</p><pre class="kj kk kl km gt mx mu my mz aw na bi"><span id="9924" class="nb ky it mu b gy nc nd l ne nf">private func revealListOffset(_ proxy: GeometryProxy) -&gt; CGPoint {<br/>    CGPoint(x: self.isMenuRevealed ? -proxy.size.width : 0, y: 0)<br/>}</span></pre><p id="8583" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">最后，将<code class="fe mr ms mt mu b">body</code>定义为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="16c3" class="nb ky it bd kz nv nw dn ld nx ny dp lh ly nz oa lj mc ob oc ll mg od oe ln of bi translated">显示菜单</h2><p id="f001" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">目前，菜单定义了一个状态<code class="fe mr ms mt mu b">isMenuRevealed</code>来管理<code class="fe mr ms mt mu b">revealList</code>的偏移。当任何一行被点击时，它被切换到false，但是我们如何显示菜单呢？</p><p id="ba1b" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">此外，我们应该考虑到，当某些事件发生时，任何其他视图也可能想要触发菜单。例如，当点击导航条按钮时。</p><p id="037b" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">我们来改变一下<code class="fe mr ms mt mu b">isMenuRevealed</code>的定义。它将不再是一种状态，而是一种约束:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="d6fc" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">这意味着<code class="fe mr ms mt mu b">isMenuRevealed</code>是双向的，意味着它可以被包含它的视图修改，也可以从它的视图层次结构中的其他视图修改。</p><p id="2fea" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">此时，菜单可以从另一个包含<code class="fe mr ms mt mu b">MenuView</code>的视图中切换。</p><p id="7e7c" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">如果我们添加一个“内置”的方式，通过一个手势来做同样的事情，会怎么样？让我们添加一个拖动手势，以便在用户滑动内容时显示或隐藏菜单。首先，创建一个状态来保存手势偏移值:</p><pre class="kj kk kl km gt mx mu my mz aw na bi"><span id="2e62" class="nb ky it mu b gy nc nd l ne nf">@State private var draggingOffset: CGFloat = 0</span></pre><p id="2624" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">然后，在<code class="fe mr ms mt mu b">ZStack</code>上加上<code class="fe mr ms mt mu b">DragGesture</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="e285" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">以及如果轻击<code class="fe mr ms mt mu b">contentView</code>则关闭菜单的<code class="fe mr ms mt mu b">TapGesture</code>:</p><pre class="kj kk kl km gt mx mu my mz aw na bi"><span id="e910" class="nb ky it mu b gy nc nd l ne nf">self.contentView<br/>    .onTapGesture (perform: {<br/>        withAnimation {<br/>            self.isMenuRevealed = true<br/>        }<br/>    })</span></pre><p id="e8dc" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">不要忘记使用<code class="fe mr ms mt mu b">withAnimation</code>来制作状态变化的动画。</p><p id="a72e" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">注意，我们已经为依赖于<code class="fe mr ms mt mu b">isMenuRevealed</code>的<code class="fe mr ms mt mu b">draggingOffset</code>设置了一个阈值。如果菜单是打开的，我们不想一直向右滑动，不是吗？</p><p id="bc25" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">最后，修改方法<code class="fe mr ms mt mu b">revealListOffset</code>,使其考虑这个偏移量:</p><pre class="kj kk kl km gt mx mu my mz aw na bi"><span id="904e" class="nb ky it mu b gy nc nd l ne nf">let hiddenOffset = -proxy.size.width + draggingOffset<br/>return CGPoint(x: self.isMenuRevealed ? hiddenOffset : hiddenOffset + proxy.width, y: 0)</span></pre><h2 id="8fd4" class="nb ky it bd kz nv nw dn ld nx ny dp lh ly nz oa lj mc ob oc ll mg od oe ln of bi translated">显示比率</h2><p id="febc" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">到目前为止，<code class="fe mr ms mt mu b">revealList</code>占据了太多的空间(实际上是整个屏幕)。当揭露出来的时候，它背后的东西并不明显:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/4f98d009099cc58a0430cb1656e670b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*BL4EJlLUBcKzkbIPoYbMqA.gif"/></div></figure><p id="1084" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">定义一个显示比率将是有用的，以便我们可以选择重叠比率。让我们给我们的初始化程序添加一个新变量<code class="fe mr ms mt mu b">revealRatio</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="78bb" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">现在，修改<code class="fe mr ms mt mu b">revealListOffset</code>并创建一个名为<code class="fe mr ms mt mu b">revealListSize</code>的新函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="e5ef" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">最后，回到主体，使用新创建的函数。用<code class="fe mr ms mt mu b">self.revealListSize(proxy).width</code>替换<code class="fe mr ms mt mu b">proxy.size.width</code>。您的视图体现在应该看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="be8b" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated"><code class="fe mr ms mt mu b">MenuView</code>现已准备上线。我们可以试一试吗？</p><h2 id="00b4" class="nb ky it bd kz nv nw dn ld nx ny dp lh ly nz oa lj mc ob oc ll mg od oe ln of bi translated">用例</h2><p id="d25f" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">让我们将它付诸实践，看看实现一个菜单有多容易。创建一个新文件，并在其主体中声明一个<code class="fe mr ms mt mu b">MenuView</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="b464" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">很简单，不是吗？通过模块化我们的视图，我们已经设法写出了更整洁的代码，现在我们可以重用。</p><p id="a8c4" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">此外，很容易扩展新的功能。选择分隔缝边缘或在不同的分隔缝模式之间进行选择怎么样？</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="9024" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">从这里去哪里</h1><p id="b4eb" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">查看我的<a class="ae mq" href="https://github.com/fermoya/CustomNavigations" rel="noopener ugc nofollow" target="_blank">回购</a>的全部代码。</p></div></div>    
</body>
</html>