<html>
<head>
<title>Parameter Injection for Android ViewModels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android视图模型的参数注入</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/parameter-injection-for-android-viewmodels-b9e9e3448051?source=collection_archive---------10-----------------------#2022-08-24">https://betterprogramming.pub/parameter-injection-for-android-viewmodels-b9e9e3448051?source=collection_archive---------10-----------------------#2022-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d8b9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用SaveStateHandler和Hilt处理Android视图模型中的参数注入</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cb06336ad056eab1f56a65219f092369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LkMe52b3_HNhbGx3"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">约书亚·雷德科普在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="fbbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将依赖项注入到我们的视图模型中已经是很好的实践了。它保持了实现的灵活性和易测试性。</p><p id="9095" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是提供给屏幕或片段的参数呢？例如，分割参数或组成导航参数。通常使用类似于<code class="fe ls lt lu lv b">init</code>的方法从视图接收参数并设置<code class="fe ls lt lu lv b">ViewModel</code>。这给我们需要注意的<code class="fe ls lt lu lv b">ViewModel</code>增加了额外的步骤。因此，在构造函数中获取依赖项和参数会更好。</p><h1 id="258a" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">设置</h1><p id="3d88" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">对于这个例子，让我们保持简单，主要关注处理参数。</p><p id="a60a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们创建了一个有两个屏幕的应用程序:</p><ol class=""><li id="854a" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">屏幕1只是一个按钮。点击它会得到一个随机数，并导航到屏幕2，将随机数作为参数传递。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/9d510878e534886e7f1270bf231cee1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/0*ADzQ2dTTGM6shbbV.png"/></div></figure><ol class=""><li id="3c89" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">屏幕2接收随机数，创建一个<code class="fe ls lt lu lv b">View</code>状态，并简单地将结果显示为文本。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/8d675e591d5636b8f56853783abab128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WoTG5NRuUXg-095s.png"/></div></div></figure><p id="c310" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">屏幕是用Jetpack Compose创建的，该示例也使用Composes NavHost导航，但是相同的<code class="fe ls lt lu lv b">ViewModel</code>代码适用于活动和片段。唯一的区别是允许用作参数的类型。在下面的设置中，组合导航只允许我们将参数作为导航路径字符串的一部分进行传递。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a55a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所看到的，我们的第二个屏幕有route <code class="fe ls lt lu lv b"> details/{randomNumber}</code>声明参数<code class="fe ls lt lu lv b">randomNumber</code>。</p><h1 id="ced2" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">处理保存的状态</h1><p id="1db7" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">现在来谈一个重要的问题。我们如何在导航后的第二个屏幕上检索ViewModel中的参数？</p><p id="247c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">SavedStateHandle</code>类包含了我们需要的信息，它可以直接注入到<code class="fe ls lt lu lv b">ViewModel</code>的构造函数中。</p><pre class="kg kh ki kj gt ng lv nh ni aw nj bi"><span id="6d03" class="nk lx iq lv b gy nl nm l nn no">class DetailsFlowViewModel(<br/>    savedStateHandle: SavedStateHandle<br/>) : ViewModel() {<br/>    ...<br/>}</span></pre><p id="5e4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论有没有像Hilt这样的依赖注入框架的帮助，这都是可能的。</p><p id="27ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">SavedStateHandle</code>为我们提供了两种获取参数的方法。</p><pre class="kg kh ki kj gt ng lv nh ni aw nj bi"><span id="6433" class="nk lx iq lv b gy nl nm l nn no">operator fun &lt;T&gt; get(key: String): T?</span><span id="e86e" class="nk lx iq lv b gy np nm l nn no">fun &lt;T&gt; getStateFlow(key: String, initialValue: T): StateFlow&lt;T&gt;</span></pre><p id="4e51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据我们想要达到的目标，我们可以使用任何一种方法。在我们的例子中，我们希望提供一个从<code class="fe ls lt lu lv b">ViewModel</code>到<code class="fe ls lt lu lv b">UI</code>的<code class="fe ls lt lu lv b">View</code>状态流。所以，还是用<code class="fe ls lt lu lv b">getStateFlow</code>吧。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><blockquote class="nq nr ns"><p id="d50f" class="kw kx nt ky b kz la jr lb lc ld ju le nu lg lh li nv lk ll lm nw lo lp lq lr ij bi translated"><em class="iq">重要提示:因为我们使用的是组合导航，所以在将参数转换为实际的Int类型之前，我们必须首先将参数作为字符串进行检索。有了片段参数，就有可能直接获得一个Int类型的参数。</em></p></blockquote><h1 id="7ec1" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">更进一步</h1><p id="7784" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们已经可以直接向<code class="fe ls lt lu lv b">ViewModel</code>的构造函数提供我们的参数。但是仍然有一个缺点:<code class="fe ls lt lu lv b">ViewModel</code>构造函数没有告诉我们它到底想要什么，但是，例如，在测试中，我们需要知道在将类型<code class="fe ls lt lu lv b">String</code>的<code class="fe ls lt lu lv b">randomNumber</code>传递给构造函数之前，将它设置为<code class="fe ls lt lu lv b">SavedStateHandle</code>。听起来这需要很多关于实现细节的知识。</p><p id="5ba3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果构造函数只是告诉我们:我想要Int类型的参数<code class="fe ls lt lu lv b">randomNumber</code>，不是更好吗？</p><p id="6c11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以借助像Hilt这样的依赖注入框架来实现这一点。</p><blockquote class="nq nr ns"><p id="5c86" class="kw kx nt ky b kz la jr lb lc ld ju le nu lg lh li nv lk ll lm nw lo lp lq lr ij bi translated"><em class="iq">长话短说，我不打算在这篇文章中详细介绍刀柄的基本用法。如果你想了解Hilt，你可以去它的</em> <a class="ae kv" href="https://developer.android.com/training/dependency-injection/hilt-android" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Android开发者教程</em> </a> <em class="iq">。</em></p></blockquote><p id="bb99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们创建一个<code class="fe ls lt lu lv b">Qualifier</code>注释，允许我们标识我们的参数。</p><pre class="kg kh ki kj gt ng lv nh ni aw nj bi"><span id="4506" class="nk lx iq lv b gy nl nm l nn no">@Qualifier<br/>@Retention(AnnotationRetention.BINARY)<br/>annotation class RandomNumber</span></pre><p id="17ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用<code class="fe ls lt lu lv b">Qualifier</code> <code class="fe ls lt lu lv b">RandomNumber</code>我们可以创建一个小的刀柄模块，在<code class="fe ls lt lu lv b">ViewModel</code>范围内提供我们的参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="8c60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在<code class="fe ls lt lu lv b">ViewModelComponent</code>中安装模块，使参数在它被注入的<code class="fe ls lt lu lv b">ViewModel</code>的生命周期内可用。实际的<code class="fe ls lt lu lv b">provideRandomNumber</code>方法是我们之前在<code class="fe ls lt lu lv b">ViewModel</code>中的代码，有一点不同。我们不使用<code class="fe ls lt lu lv b">Flow</code>而是直接获取值。</p><p id="c214" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了模块，我们的<code class="fe ls lt lu lv b">ViewModel</code>就变得简单了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="bb2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用<code class="fe ls lt lu lv b">Qualifier</code>请求我们想要的参数，并简单地使用它来创建我们的<code class="fe ls lt lu lv b">View</code>状态。</p><h1 id="bd25" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="6696" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">如本文所示，使用参数注入确实比注入<code class="fe ls lt lu lv b">SavedStateHandle</code>或创建init方法需要更多的代码，但它更好地分离了我们应用程序的不同方面，允许更可读和可测试的代码。</p><p id="0891" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b">SavedStateHandle</code>、<code class="fe ls lt lu lv b">Hilt</code>和<code class="fe ls lt lu lv b">Activity</code>的不同变体的完整示例可以在<a class="ae kv" href="https://github.com/a-frank/viewmodel-parameters" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="3f8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想知道，同样的概念可以用Koin来实现。</p><p id="6091" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一集见。</p></div></div>    
</body>
</html>