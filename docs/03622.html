<html>
<head>
<title>Android: What is LiveEvent LiveData?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android:什么是LiveEvent LiveData？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-liveevent-livedata-7270a64736b3?source=collection_archive---------2-----------------------#2020-02-23">https://betterprogramming.pub/what-is-liveevent-livedata-7270a64736b3?source=collection_archive---------2-----------------------#2020-02-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="992f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用LiveEvent解决向单个观察者发射的问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c8f5780b78c9a6c07b06ed1251dee310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7QxHX7NDOrvcBc8B"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="429b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LiveData是一个可观察的数据持有者类。与常规的可观察对象不同，LiveData具有生命周期意识，这意味着它尊重其他应用程序组件的生命周期，如活动、片段或服务。这种意识确保了LiveData只更新处于<strong class="lb iu">活动</strong>生命周期状态的应用组件观察者。</p><p id="712d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要理解LiveData，我们首先需要理解观察者模式。它是一种软件设计模式，其中一个对象(称为主体)维护其依赖者(称为观察者)的列表，并自动通知它们任何状态变化，通常通过调用它们的方法之一。</p><p id="d1c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不了解LiveData或其工作原理，请在进一步了解之前浏览<a class="ae ky" href="https://medium.com/better-programming/everything-to-should-understand-about-livedata-507dd83adea7" rel="noopener">这篇文章</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0d9d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用例</h1><p id="c51a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">观察LiveData的常见用例是显示小吃店或执行一些自定义操作，如显示对话框、导航等。例如，让我们考虑一个简单的应用程序，其中有两个活动，每个活动都有自己的视图模型。观察到动态数据值后，第一个活动导航到第二个活动。但问题是，当用户在第二个活动中按下back按钮时，或者当用户从后台状态恢复第一个活动时，动态数据值会被重新提交到第一个活动，第一个活动会再次导航到第二个活动。结果，用户将永远无法回到第一个活动。</p><p id="4396" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是问题所在:我们如何创建LiveData来发出单个事件并只通知单个观察者，即使有许多观察者订阅它？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2bdf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">解决办法</h1><p id="ac36" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有一个名为<code class="fe mz na nb nc b">LiveEvent</code>的包装类可以解决这种情况。它是一个只发送一次更新的LiveData。它是<code class="fe mz na nb nc b">MediatorLiveData</code> <strong class="lb iu"> </strong>的扩展，在多个观察者同时观察时更新单个观察者很方便。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8921" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一个例子来更好地理解它</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a9d1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">例子</h1><p id="e445" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">例如，让我们考虑一个简单的电视节目应用程序，其中有一个包含两个片段的活动。<code class="fe mz na nb nc b">FragmentShowsList</code>显示节目列表，点击<code class="fe mz na nb nc b">FragmentShowsList</code>中的节目，我们将导航至<code class="fe mz na nb nc b">FragmentShowDetails</code>，显示节目详情。但是，如果在两个片段中有一个共同的按钮动作(例如<code class="fe mz na nb nc b">SUBSCRIBE</code> ) <strong class="lb iu"> </strong>)会怎么样呢？在点击按钮时，我们点击订阅API并使用LiveData发布结果。当收到结果时，在两个片段中观察到相同的LiveData实例，我们需要在<code class="fe mz na nb nc b">FragmentShowsList</code>的情况下显示成功对话框，在<code class="fe mz na nb nc b">FragmentShowDetails</code>的情况下显示toast消息。</p><p id="6b23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是当我们观察单个ViewModel实例时，问题出现了。如果<code class="fe mz na nb nc b">FragmentShowsList</code>在顶部，它接收结果并显示对话框。但是稍后如果我们导航到<code class="fe mz na nb nc b">FragmentShowDetails</code>，它将显示toast消息，而无需点击按钮，因为它正在观察包含值的LiveData。</p><p id="a463" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的活动将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1c01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的XML如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="03c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们创建<code class="fe mz na nb nc b">fragment_shows_list</code> <strong class="lb iu"> </strong>布局文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8461" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们创建<code class="fe mz na nb nc b">FragmentShowsList</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="36a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们创建<code class="fe mz na nb nc b">FragmentShowDetails</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0f48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和<code class="fe mz na nb nc b">fragment_shows_details</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9000" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们运行并检查输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/c649f91b28ceee18697f6d767258c0f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/1*tJ2kEpM7MONzZCRL5PsF3g.gif"/></div></figure><h2 id="f8b2" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">要观察的事物</h2><ol class=""><li id="ac9b" class="ns nt it lb b lc mu lf mv li nu lm nv lq nw lu nx ny nz oa bi translated">我点击了<code class="fe mz na nb nc b">FragmentShowList</code>上的订阅按钮。在结果中，它显示了预期的成功对话框确认。</li><li id="8faa" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">当我点击导航按钮时，它导航到了<code class="fe mz na nb nc b">FragmentShowDetails</code>，但意外地显示了一条不期望或不需要的toast消息。</li><li id="0de7" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">当我点击<code class="fe mz na nb nc b">FragmentShowDetails</code>上的BackPress时，它被替换为<code class="fe mz na nb nc b">FragmentShowList</code>，但显示了一个不需要的成功对话框或一个重复的例子。</li></ol><p id="f946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在活动内部的两个不同片段之间进行通信，我们通常使用活动的共享视图模型来消除带有接口的样板代码。但是，如果没有正确处理，像上面这样的场景会导致意想不到的行为出现。</p><p id="73a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们将<code class="fe mz na nb nc b">LiveEvent</code>类添加到我们的代码中，在ViewModel中更改两行代码，看看神奇之处:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/d37d8fc60862dcf135f6aa38c4f02a4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/1*A7L-Wt2Cf7VriOSaIanAbQ.gif"/></div></figure><p id="7a1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">活动或片段的代码没有任何变化——只是对视图模型中的两行代码进行了简单的修改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b912" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">了解底层魔法</strong></h1><p id="4af4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">上面神奇的原因是<code class="fe mz na nb nc b">MediatorLiveData</code> <strong class="lb iu">。</strong> It <strong class="lb iu"> </strong>可以定义为一个LiveData子类，它可以观察其他LiveData对象并对来自它们的OnChanged事件做出反应。在这个<code class="fe mz na nb nc b">LiveEvent</code>类中，我们用一个<code class="fe mz na nb nc b">ObserverWrapper</code> <strong class="lb iu"> </strong>类<strong class="lb iu"> </strong>来包装观察者，在这个类中已经编写了实际的逻辑。有一个布尔值来判断是否至少观察到一次变化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0fda" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="b938" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">目前就这些。那么，谁在LiveData上遇到过类似的问题呢？请评论。我希望你已经找到了一个好的解决方法。</p><p id="a5e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请让我知道你的建议。</p><p id="0489" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>