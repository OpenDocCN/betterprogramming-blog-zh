<html>
<head>
<title>Learn How to Hash Data in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解如何在Flutter中散列数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-how-to-encrypt-data-in-flutter-c999b4fc7340?source=collection_archive---------5-----------------------#2021-10-06">https://betterprogramming.pub/learn-how-to-encrypt-data-in-flutter-c999b4fc7340?source=collection_archive---------5-----------------------#2021-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dc2c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Flutter中使用加密算法来散列数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0ff55b69fe9369ee4398a591cf3f0951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hFPnwlAmM4npLNm2gN7VhQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@swimstaralex?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Alexander Sinn </a>在<a class="ae ky" href="https://unsplash.com/s/photos/data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="dc84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们将致力于让我们的移动应用更加安全可靠。例如，我们可以通过加密敏感的用户数据来实现这一点。我将向您展示这是如何与Flutter一起工作的。</p><p id="9e7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将仔细研究加密散列算法，看看如何在Flutter中使用算法<code class="fe lv lw lx ly b">SHA-1</code>、<code class="fe lv lw lx ly b">SHA-224</code>、<code class="fe lv lw lx ly b">SHA-256</code>、<code class="fe lv lw lx ly b">SHA-384</code>、<code class="fe lv lw lx ly b">SHA-512</code>、<code class="fe lv lw lx ly b">SHA-512/224</code>、<code class="fe lv lw lx ly b">SHA-512/256</code>、<code class="fe lv lw lx ly b">MD5</code>、<code class="fe lv lw lx ly b">HMAC</code>(即HMAC-MD5、HMAC-SHA1、HMAC-SHA256)来散列数据。</p><p id="7a22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将创建一个应用程序，它接收文本，如果需要，还接收密码，并使用前面提到的不同算法将其转换为哈希值。</p><p id="9693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我将向您展示如何使用<code class="fe lv lw lx ly b">TextEditingController</code>在运行时更改哈希值，并且只需单击一下就可以复制哈希值本身。</p><p id="eb32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是这款应用的运行情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Luciano Jung在Youtube上的视频</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="c51f" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">介绍</h1><p id="27f7" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">为了使用一些常见的散列函数加密数据，我们将实现<code class="fe lv lw lx ly b"><a class="ae ky" href="https://pub.dev/packages/crypto" rel="noopener ugc nofollow" target="_blank">crypto</a></code>包，它包含空安全。这支持Android和iOS应用程序以及web和桌面应用程序。</p><p id="323c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">加密产生的散列结果并不意味着被再次解密——或者根本不被解密。它们用于散列重要数据，如密码，以便以后可以检查，但不是以纯文本形式存储。当通过比较两个数据集的哈希值来比较这两个数据集时，也可以应用它们。</p><p id="40ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将通过一步一步的指导来实现上面显示的结果。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="16b7" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">准备</h1><p id="0b71" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">先说代码准备。要实现下面的项目，你需要将<code class="fe lv lw lx ly b">crypto</code>包集成到你的Flutter代码库中。</p><p id="49c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在命令行中运行以下命令:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="e396" class="nj mj it ly b gy nk nl l nm nn"><strong class="ly iu">$ </strong>flutter pub add crypto</span></pre><p id="111e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将向您的包的<code class="fe lv lw lx ly b">pubspec.yaml</code>添加一行(并运行一个隐式的<code class="fe lv lw lx ly b">flutter pub get</code>):</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="d675" class="nj mj it ly b gy nk nl l nm nn">dependencies:<br/>  crypto: ^latest_version</span></pre><p id="8f21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在您的Dart代码中，您可以使用以下import语句来使用该包:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="7951" class="nj mj it ly b gy nk nl l nm nn">import 'package:crypto/crypto.dart';</span></pre></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="1c6e" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">履行</h1><p id="9355" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">让我们从散列数据集的基础知识开始。我们需要一个数据集，比如一个字符串<code class="fe lv lw lx ly b">“some text”</code>。我们将使用Dart内部库<code class="fe lv lw lx ly b">dart:convert</code>将其转换成一个<code class="fe lv lw lx ly b">utf8</code>字符串。然后我们可以使用<code class="fe lv lw lx ly b">crypto</code>包中的散列函数来加密它。</p><p id="ec64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我使用了<code class="fe lv lw lx ly b">sha1</code>算法的convert函数来生成哈希值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no ma l"/></div></figure><p id="bc2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你使用<code class="fe lv lw lx ly b">hmac</code>它几乎和以前一样简单。您所需要的只是一个额外的<code class="fe lv lw lx ly b">utf8</code>格式的键，并创建一个<code class="fe lv lw lx ly b">hmac</code>对象，我们将哈希算法传递给它。在这种情况下，<code class="fe lv lw lx ly b">sha1</code>和<code class="fe lv lw lx ly b">key</code>。其余的代码看起来几乎相同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no ma l"/></div></figure><p id="16c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了重新创建上面视频中显示的应用程序，我创建了一个新的有状态小部件。下面是它的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no ma l"/></div></figure><p id="fc35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的片段中发生了很多事情。以下是它们的简要概述:</p><ul class=""><li id="7de1" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">小部件声明了一个<code class="fe lv lw lx ly b">TextEditingController</code>，它获得一个默认文本。</li><li id="a29e" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">调用状态的<code class="fe lv lw lx ly b">build</code>方法来创建实际的小部件。我使用了一个<code class="fe lv lw lx ly b">Center</code>小部件作为根对象，它得到一个<code class="fe lv lw lx ly b">Column</code>作为它的子对象。</li><li id="9bdb" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">在<code class="fe lv lw lx ly b">child</code>中，指定了一个<code class="fe lv lw lx ly b">TextField</code>和一个<code class="fe lv lw lx ly b">Card</code>小部件。<code class="fe lv lw lx ly b">TextField</code>应该包含我们要加密的文本，因此得到了<code class="fe lv lw lx ly b">TextEditingController</code>。</li><li id="6e5a" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">对于<code class="fe lv lw lx ly b">onChanged</code>方法，需要调用<code class="fe lv lw lx ly b">setState</code>方法，这样文本的编辑才能正常工作。<code class="fe lv lw lx ly b">Card</code>小部件得到一个填充间隔符和一个<code class="fe lv lw lx ly b">ListTile</code>，其中包含一个<code class="fe lv lw lx ly b">title</code>(使用的算法)、一个<code class="fe lv lw lx ly b">subtitle</code>(散列值)和一个<code class="fe lv lw lx ly b">trailing</code>图标。该图标将在以后用于复制文本。</li><li id="fbd6" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">_hashValue</code>函数获取将用于加密的算法。我们将在下面使用相同的函数来复制各自的值。因为我们想要创建一个散列值的列表，所以散列值不存储在变量中。</li></ul><p id="315e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了通过一次点击复制散列值，我们已经在尾随图标的<code class="fe lv lw lx ly b">onPressed</code>属性中设置了<code class="fe lv lw lx ly b">onCopyPressed</code>方法——该方法获取算法。相应的功能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no ma l"/></div></figure><p id="f171" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们调用了<code class="fe lv lw lx ly b">Clipboard</code>对象的<code class="fe lv lw lx ly b">setData</code>方法，并将哈希值传递给它。</p><p id="e068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了向用户确认复制成功，我们设置了一个<code class="fe lv lw lx ly b">SnackBar</code>,显示复制到剪贴板的哈希值。使用<code class="fe lv lw lx ly b">ScaffoldMessenger</code>我们可以显示小吃店。</p><p id="9b80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了能够迭代<code class="fe lv lw lx ly b">crypto</code>包中所有可用的散列函数，并为每个函数显示一个单独的<code class="fe lv lw lx ly b">Card</code>小部件，我们使用下面的代码部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no ma l"/></div></figure><p id="0d1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的第一步中，我创建了一个<code class="fe lv lw lx ly b">_algorithmMap</code>来迭代所有函数。</p><p id="9195" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随后，我对这张地图进行迭代，将文本设置为标题，并使用算法对其进行加密。因此，对于地图中的每个条目，都会创建一个单独的卡片小部件，它具有单独的属性。</p><p id="c531" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">散列函数本身不需要改变，因为它已经获得了值。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="05dc" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">限制</h1><p id="05bc" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">为了展示这个小项目的局限性，我想介绍几件事:</p><ol class=""><li id="1681" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu od nv nw nx bi translated">本项目中使用的<code class="fe lv lw lx ly b">crypto</code>包没有经过任何安全专业人员的审查和评估。在生产系统中使用算法的风险由您自己承担。系统的安全性应该由专业人员或通过扩展测试来确保。</li><li id="ec70" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu od nv nw nx bi translated">项目中使用的<code class="fe lv lw lx ly b">crypto</code>包目前只支持提到的<code class="fe lv lw lx ly b">sha</code>、<code class="fe lv lw lx ly b">md5</code>和<code class="fe lv lw lx ly b">hmac</code>算法。因此，不提供其他哈希算法，如<code class="fe lv lw lx ly b">BLAKE</code>或<code class="fe lv lw lx ly b">RIPEMD</code>。此外，正如已经提到的，这个包不是为了加密和解密，而只是为了散列值。</li></ol></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><p id="1ae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的源代码可以在我的<a class="ae ky" href="https://github.com/lucianojung/flutter_package_examples/blob/master/lib/packages/crypto/crypto_main.dart" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中找到，附带的应用程序可以在<a class="ae ky" href="https://flutter-package-examples.netlify.app/#/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。感谢阅读。</p></div></div>    
</body>
</html>