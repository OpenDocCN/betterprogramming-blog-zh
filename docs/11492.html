<html>
<head>
<title>Provisioning Postgres From Docker to Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Docker向Kubernetes提供Postgres</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/provisioning-postgres-from-docker-to-kubernetes-48b812d4b67a?source=collection_archive---------11-----------------------#2022-03-24">https://betterprogramming.pub/provisioning-postgres-from-docker-to-kubernetes-48b812d4b67a?source=collection_archive---------11-----------------------#2022-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4003" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Kubernetes吊舱中部署Postgres</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/05d5e52df7f3f4d5f51dae5d808e7007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OXoEIaTJMt_qwyKH.png"/></div></div></figure><p id="2bd7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我们将看到如何使用Docker 创建一个<a class="ae lq" href="https://arctype.com/postgres/install/docker-mac-postgres" rel="noopener ugc nofollow" target="_blank"> Postgres容器，并在不丢失数据的情况下重启Postgres容器。在本文的最后，我们将在Kubernetes pods中部署Postgres，并使用ConfigMaps和StatefulSets进行定制部署。</a></p><h1 id="dd32" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">为什么要使用容器化的数据库？</h1><p id="5c9d" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">与简单地将数据库安装在服务器上相比，为数据库创建容器似乎会增加不必要的开销。然而，它允许用户将容器的所有优点带到他们的数据库中。</p><h2 id="ee6f" class="mo ls it bd lt mp mq dn lx mr ms dp mb ld mt mu md lh mv mw mf ll mx my mh mz bi translated"><strong class="ak">将数据和数据库分开</strong></h2><p id="9a37" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">容器化允许用户分离数据库应用程序和数据。因此，它提高了容错能力，使用户能够在应用程序出现故障时启动新的容器，而不会影响底层数据。此外，容器化还允许用户相对容易地扩展和增加数据库的可用性。</p><h2 id="4348" class="mo ls it bd lt mp mq dn lx mr ms dp mb ld mt mu md lh mv mw mf ll mx my mh mz bi translated"><strong class="ak">便携性</strong></h2><p id="648a" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">容器的可移植性有助于用户将数据库部署和迁移到任何受支持的容器化环境中，而无需更改任何基础设施或配置。它们还使用户能够对数据库应用程序进行配置更改，而对生产环境中的底层数据影响很小甚至没有影响。此外，这些容器可以提高资源利用率，降低总体成本，因为<a class="ae lq" href="https://www.atlassian.com/continuous-delivery/microservices/containers-vs-vms#:~:text=The%20key%20differentiator%20between%20containers,above%20the%20operating%20system%20level." rel="noopener ugc nofollow" target="_blank">与虚拟机</a>等其他解决方案相比，它们本质上是轻量级的。</p><h1 id="5a2d" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建容器化的数据库</h1><p id="6255" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">首先，我们需要一个图像作为容器的基础。虽然我们可以从头开始创建一个映像，但在大多数情况下这是不必要的，因为像Postgres这样的常用软件提供了官方容器映像，并带有定制容器的选项。因此，我们将使用Docker hub 中的<a class="ae lq" href="https://hub.docker.com/_/postgres" rel="noopener ugc nofollow" target="_blank">官方Postgres映像来创建这个数据库容器。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl na"><img src="../Images/55afd5c0358887754d227809e1f16d0e.png" data-original-src="https://miro.medium.com/v2/0*WQT6Hm0jQ4JmaG6D"/></div></figure><p id="23e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来呢。创建容器配置的时间。这可以通过docker-compose文件轻松完成<a class="ae lq" href="https://docs.docker.com/get-started/08_using_compose/#:~:text=Docker%20Compose%20is%20a%20tool,or%20tear%20it%20all%20down." rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="f605" class="mo ls it nc b gy ng nh l ni nj">version: '3.1'<br/>services:<br/>	postgres-db:<br/>		container_name: postgres-db<br/>		image: postgres:latest<br/>		restart: always<br/>		environment:<br/>			POSTGRES_USER: testadmin<br/>			POSTGRES_PASSWORD: test123<br/>			POSTGRES_DB: testdb<br/>			PGDATA: /var/lib/postgresql/data/pgdata<br/>		volumes:<br/>			- postgres-db-data:/var/lib/postgresql/data<br/>		ports:<br/>			- 5432:5432<br/>volumes:<br/>	postgres-db-data:<br/>		name: postgres-db-data</span></pre><p id="3d07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的配置中，我们创建了一个docker卷来存储Postgres数据。由于该卷可重复使用，因此即使容器被移除，您也可以恢复底层数据。对于Postgres容器，我们使用最新的Postgres映像和环境变量来设置容器中的用户、密码、数据库和数据位置。在卷部分，我们将内部容器数据位置映射到我们的卷，并公开端口5432。</p><p id="6048" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦创建了文件，我们就可以运行<code class="fe nk nl nm nc b">docker-compose up</code>命令来启动容器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl na"><img src="../Images/dbea0dbd3741e68b546eb5d726278bbf.png" data-original-src="https://miro.medium.com/v2/0*_EWWOoXNRCNEIrJk"/></div></figure><p id="227c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们可以运行<code class="fe nk nl nm nc b">docker ps</code>命令来查看容器是否成功运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl na"><img src="../Images/6740c6eea5183d4c59900e06e9307486.png" data-original-src="https://miro.medium.com/v2/0*r87f1wl-IalYYq_P"/></div></figure><p id="2af5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样。我们成功地创建了一个集装箱化的Postgres数据库。有用吗？我们可以通过一个SQL客户端连接到数据库来验证这一点。因此，让我们使用<a class="ae lq" href="https://arctype.com/" rel="noopener ugc nofollow" target="_blank"> Arctype SQL客户端</a>来初始化一个测试连接。首先，提供数据库连接的详细信息。在这个实例中，我们将使用Docker主机的IP、端口和创建容器时提供的凭证。然后，正如您在下图中看到的，我们可以成功地初始化到数据库的连接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl na"><img src="../Images/45d29d43f12942a7f48e4737c8a9cd79.png" data-original-src="https://miro.medium.com/v2/0*jtpuL3NY5XytxrZ8"/></div></figure><h1 id="19e8" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建可重复的配置</h1><p id="97f1" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">如前所述，容器允许用户将数据库数据从应用程序中分离出来，并实现可重复的配置。例如，假设您在数据库软件中遇到了一个错误。在传统安装中，这可能会导致灾难性的后果，因为数据和应用程序是绑定在一起的。甚至回滚也是不可能的，因为它们会导致数据丢失。但是，容器化允许您删除出错的容器，启动新的实例，并立即访问数据。</p><p id="b9ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们在实践中看看这个场景。首先，让我们<a class="ae lq" href="https://docs.arctype.com/managing-tables/view-table-schema#view-and-edit-full-table-schema" rel="noopener ugc nofollow" target="_blank">创建一个名为<code class="fe nk nl nm nc b">test_data_table</code>的表</a>，并使用Arctype客户端向其中插入一些记录。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl na"><img src="../Images/fd2617f968241d1912f6715af039d1d4.png" data-original-src="https://miro.medium.com/v2/0*RYQWu9dEktNgmQnG"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl na"><img src="../Images/38aa5388a9d1637ed0fadb8e2bb3745d.png" data-original-src="https://miro.medium.com/v2/0*f-hetLUMRYDcHeFT"/></div></figure><p id="adc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们在数据库中有了一些数据。让我们使用docker-compose down命令删除容器，这将从docker环境中删除容器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl na"><img src="../Images/43de1fefe472e27d46848c9d2a6213a4.png" data-original-src="https://miro.medium.com/v2/0*WCKbmAU_WpKth8vt"/></div></figure><p id="0030" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="nn">注意— </em> </strong> <em class="nn">删除容器时，SQL客户端会显示一个错误，说连接被拒绝。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl na"><img src="../Images/b84cc15dabd0456e5e536c114824346f.png" data-original-src="https://miro.medium.com/v2/0*0ohYQFSOHQRLS-8v"/></div></figure><p id="a3d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们对合成文件做一点小小的修改，以更改容器的名称。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="4fd0" class="mo ls it nc b gy ng nh l ni nj">version: '3.1'<br/>services:<br/>	postgres-db:<br/>		# New Container<br/>		container_name: postgres-db-new<br/>		image: postgres:latest<br/>		restart: always<br/>		environment:<br/>			POSTGRES_USER: testadmin<br/>			POSTGRES_PASSWORD: test123<br/>			POSTGRES_DB: testdb<br/>			PGDATA: /var/lib/postgresql/data/pgdata<br/>		volumes:<br/>		- postgres-db-data:/var/lib/postgresql/data<br/>		ports:<br/>		- 5432:5432<br/>volumes:<br/>	postgres-db-data:<br/>		name: postgres-db-data</span></pre><p id="bafe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，再次旋转容器，并使用<code class="fe nk nl nm nc b">docker ps</code>命令验证它是否正在运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl na"><img src="../Images/c12cb6a298208ce06a57263f31eea312.png" data-original-src="https://miro.medium.com/v2/0*z3q4PeetsrFjGB-5"/></div></figure><p id="5b9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">刷新Arctype客户端中的表以重新建立连接。然后运行一个简单的SELECT命令来查询<code class="fe nk nl nm nc b">test_data_table</code>中的数据，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl na"><img src="../Images/5c7c30d9a8768de079c0a1d3ac0d206c.png" data-original-src="https://miro.medium.com/v2/0*eSeNXW-EuGUgq5jy"/></div></figure><p id="eaaa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，即使容器被移除，我们也可以重新创建容器并访问数据。</p><h1 id="a869" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">使用Kubernetes管理容器</h1><p id="ead5" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">对于本地开发环境，甚至是在生产环境中运行一些容器，Docker都是一个很好的选择。然而，由于大多数生产环境由许多容器组成，快速管理它们变得不可行。这就是像Kubernetes这样的编排平台发挥作用的地方，它提供了一个完整的功能丰富的容器编排平台来大规模管理容器。</p><p id="998a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Kubernetes中部署Postgres容器的最佳方式是使用StatefulSet。It <a class="ae lq" href="https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/" rel="noopener ugc nofollow" target="_blank">使用户能够供应有状态的应用</a>，并配置持久存储、唯一网络标识符、自动滚动更新、有序部署和扩展。所有这些特性都是促进像数据库这样的有状态应用程序所必需的。本节将介绍如何在K8s集群中部署Postgres容器。</p><h1 id="e817" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建和部署Postgres Pod</h1><p id="d765" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">对于这个部署，我们将创建一个<code class="fe nk nl nm nc b">configmap</code>来存储我们的环境变量、一个在集群外部公开数据库的服务以及Postgres Pod的StatefulSet。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="a11a" class="mo ls it nc b gy ng nh l ni nj"># PostgreSQL StatefulSet ConfigMap<br/>apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>	name: postgres-db-config<br/>	labels:<br/>		app: postgresql-db<br/>data:<br/>	POSTGRES_PASSWORD: test123<br/>	PGDATA: /data/pgdata<br/>---<br/># PostgreSQL StatefulSet Service<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>	name: postgres-db-lb<br/>spec:<br/>	selector:<br/>		app: postgresql-db<br/>	type: LoadBalancer<br/>	ports:<br/>	- port: 5432<br/>	targetPort: 5432<br/>---<br/># PostgreSQL StatefulSet<br/>apiVersion: apps/v1<br/>kind: StatefulSet<br/>metadata:<br/>	name: postgresql-db<br/>spec:<br/>	serviceName: postgresql-db-service<br/>	selector:<br/>		matchLabels:<br/>			app: postgresql-db<br/>	replicas: 2<br/>	template:<br/>		metadata:<br/>			labels:<br/>				app: postgresql-db<br/>		spec:<br/>			# Official Postgres Container<br/>			containers:<br/>			- name: postgresql-db<br/>			image: postgres:10.4<br/>			imagePullPolicy: IfNotPresent<br/>			ports:<br/>			- containerPort: 5432<br/>			# Resource Limits<br/>			resources:<br/>				requests:<br/>					memory: "265Mi"<br/>					cpu: "250m"<br/>				limits:<br/>					memory: "512Mi"<br/>					cpu: "500m"<br/>			# Data Volume<br/>			volumeMounts:<br/>			- name: postgresql-db-disk<br/>			mountPath: /data<br/>			# Point to ConfigMap<br/>			env:<br/>			- configMapRef:<br/>			name: postgres-db-config<br/># Volume Claim<br/>volumeClaimTemplates:<br/>	- metadata:<br/>		name: postgresql-db-disk<br/>	spec:<br/>		accessModes: ["ReadWriteOnce"]<br/>		resources:<br/>			requests:<br/>				storage: 25Gi</span></pre><p id="d6d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上述配置可以总结为以下几点:</p><ul class=""><li id="deaa" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp nt nu nv nw bi translated"><strong class="kw iu">ConfigMap—postgres-d b-config:</strong>这个config map定义了Postgres容器所需的所有环境变量。</li><li id="b29f" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated"><strong class="kw iu">服务— postgres-db-lb: </strong>负载平衡器类型的服务被定义为使用端口5432在容器外部公开pod</li><li id="0a3a" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated"><strong class="kw iu">stateful set—PostgreSQL-db:</strong>stateful set使用Postgres容器映像配置了两个副本，其中的数据被装载到永久卷上。为容器和卷配置了额外的资源限制。</li></ul><p id="60bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建此配置后，我们可以使用以下命令应用它并验证StatefulSet。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="f486" class="mo ls it nc b gy ng nh l ni nj">kubectl apply -f .\postgres-statefulset.yaml<br/>kubectl get all<br/>kubectl get pvc</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl na"><img src="../Images/9266a049ea9743c42e8f19ae31caddf5.png" data-original-src="https://miro.medium.com/v2/0*B7zlS8MptkUepn5Z"/></div></figure><p id="1ad1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样！您已经成功地在Kubernetes上配置了Postgres数据库。</p><h1 id="294f" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">访问数据库</h1><p id="9959" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">既然我们现在有了正在运行的pod，让我们访问数据库。因为我们已经设置了一个服务，所以我们可以使用该服务的外部IP来访问数据库。使用<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/arctype.com"> Arctype客户端</a>提供服务器详细信息，如默认用户和数据库(Postgres)并测试连接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl na"><img src="../Images/db1f61dccca1daa8d606104f11d089c0.png" data-original-src="https://miro.medium.com/v2/0*OLLlKLKqX7CVRc-H"/></div></figure><p id="3f06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与docker示例一样，让我们创建一个名为<code class="fe nk nl nm nc b">test_data_table</code>的表并添加一些记录。这里，我们将删除整个StatefulSet。如果我们已经正确地配置了一切，数据将在pod被删除时保留。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl na"><img src="../Images/69bd6e8bf4812d59060c311a254ae1d5.png" data-original-src="https://miro.medium.com/v2/0*jAahrBe4RPhXXnYQ"/></div></figure><p id="c477" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们重置StatefulSet并尝试访问数据库。由于这是一个新的部署，您将看到一个与服务相关联的新外部IP。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl na"><img src="../Images/2e613718892a029fe0c21e31ca327a57.png" data-original-src="https://miro.medium.com/v2/0*cR1LdD4oS85lbSul"/></div></figure><p id="c982" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Arctype SQL客户端上修改连接字符串并尝试连接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl na"><img src="../Images/ced8dfbfa053364721c2d637f48d97c7.png" data-original-src="https://miro.medium.com/v2/0*0Hhg4-OEGCiHhpgZ"/></div></figure><p id="2a6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后您将看到我们之前创建的表。您将能够通过运行SELECT命令来显示表中的所有数据，该命令表示无论窗格的状态如何，数据都是可用的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl na"><img src="../Images/b3d1df3ab6012b9d3ce1ccccfae28e12.png" data-original-src="https://miro.medium.com/v2/0*oSl69VUNuXst4jXA"/></div></figure><h1 id="0383" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">使用数据库窗格时的最佳实践</h1><p id="8612" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在Kubernetes中部署数据库时，有一些最佳实践可以遵循，以获得最佳的可靠性和性能。</p><ol class=""><li id="b32e" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp oc nu nv nw bi translated">使用<a class="ae lq" href="https://phoenixnap.com/kb/kubernetes-secrets" rel="noopener ugc nofollow" target="_blank"> Kubernetes Secrets存储密码等敏感信息</a>。尽管为了简单起见，我们在配置中以明文形式存储了用户密码，但是任何敏感信息都应该秘密存储在生产环境中，并在需要时引用。</li><li id="d3c5" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated">对CPU、RAM和存储实施<a class="ae lq" href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits" rel="noopener ugc nofollow" target="_blank">资源限制</a>。这有助于管理集群中的资源，并确保pod不会过度消耗资源。</li><li id="2c42" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated">始终为您的卷配置备份。即使可以重新创建pod，如果底层数据卷损坏，整个数据库也将变得不可用。</li><li id="924f" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated">实施网络策略和RBAC，以控制入口和可以修改这些资源的用户，从而实现最佳性能和安全性。</li><li id="8ce5" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated">使用单独的名称空间将数据库与普通应用程序隔离开来，并通过服务管理连接。</li></ol><h1 id="dccd" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="cf94" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">创建容器化数据库允许用户利用容器化的所有好处，并将它们应用到数据库中。</p><p id="9c05" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种容器化适用于任何数据库，从像<a class="ae lq" href="https://arctype.com/mysql/connect/client-mysql" rel="noopener ugc nofollow" target="_blank"> MySQL </a>和<a class="ae lq" href="https://arctype.com/postgres/connect/client-postgres" rel="noopener ugc nofollow" target="_blank"> Postgres </a>这样的市场领导者到为云原生应用从头设计的新竞争者。</p><p id="b455" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，<a class="ae lq" href="https://dev.to/aws-heroes/yugabytedb-on-amazon-eks-3206" rel="noopener ugc nofollow" target="_blank">yugabytdb是一个新的数据库，可以在任何Kubernetes环境下运行，比如亚马逊EKS </a>。管理容器化的数据库使用户能够利用传统数据库部署所需的一小部分资源来实现容错、高可用性和可伸缩的数据库架构。</p></div></div>    
</body>
</html>