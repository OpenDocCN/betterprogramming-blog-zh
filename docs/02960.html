<html>
<head>
<title>How to Limit Resources for Docker Swarm Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何限制Docker群服务的资源</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/limit-resources-for-swarm-services-249dcebed833?source=collection_archive---------7-----------------------#2020-01-11">https://betterprogramming.pub/limit-resources-for-swarm-services-249dcebed833?source=collection_archive---------7-----------------------#2020-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5a97" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">开始控制Docker服务和容器的资源消耗</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/39f172bf994a9884406f2bf58d8c5b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IiNt6-cR9pQH-nKis1IZYQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@henning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亨宁·维茨勒</a>在<a class="ae ky" href="https://unsplash.com/s/photos/limit?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1ef7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Linux系统上，OOM killer(内存不足)将杀死任何试图消耗资源(如RAM)超过主机可用资源或分配给进程的资源的进程。</p><p id="f8f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种行为可能会对正在运行的服务产生非常危险的影响，不仅是在生产环境中，而且对于试运行和测试环境也是如此，原因很简单，因为这意味着服务将由于需要更多资源而停止运行。</p><p id="79c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种行为的另一个缺点是，如果允许某个服务消耗主机上的所有资源，则存在影响同一主机上运行的其他服务的风险。</p><p id="8001" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">OMM killer进程正在监视Linux系统上运行的所有进程或服务，包括Docker守护进程和容器。</p><p id="9f46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过定义Docker守护进程和服务的资源约束，可以降低一个服务或进程消耗所有节点资源并影响同一主机上其他服务的风险。</p><p id="bf6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个想法，Docker守护进程和Docker容器都将有自己的限制。OMM killer会遵守这些限制，当进程超出限制时，它会终止进程。</p><p id="95b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然根据官方<a class="ae ky" href="https://docs.docker.com/config/containers/resource_constraints/#limit-a-containers-access-to-memory" rel="noopener ugc nofollow" target="_blank">文档</a>也有可能限制Docker运行时的资源，但在这篇文章中，我将重点关注在单个Docker群服务上设置资源限制。</p><p id="c291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker Compose提供了两种方法来约束和限制为每个单独的群服务和容器分配的资源。下面是对这些方法的简要描述。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e82d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">预订</strong></h1><p id="bf31" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">该方法将在创建期间为Docker任务保留分配的资源量。这意味着，如果您有一台16gb RAM的主机，并且您为每个服务任务分配了1GB，那么您在该主机上最多只能运行16个任务。</p><p id="f496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您尝试将该主机上的服务部署或扩展到16个以上的任务，所有新任务都将被拒绝，并且不会创建新的容器，因为主机上没有可用的资源。即使16个正在运行的容器只消耗5 GB，情况也是如此。</p><p id="5efd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种行为背后的原因是Docker将在预定的时间为每个任务保留1 GB的RAM，主机上的任何其他进程都不能使用它。</p><p id="663f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预留的限制值应该尽可能小，以保证服务能够在预定的主机上按预期启动和运行。</p><p id="e941" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，预留值不应阻塞主机上不需要的资源，也不应影响Docker Swarm集群上其他服务的调度。</p><p id="d46c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，对于平均消耗500 MB的服务，不建议将预留值设置为5 GB。在这种情况下，很明显，我们将主机资源锁定在特定的服务上是在浪费资源。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f4da" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">极限</strong></h1><p id="854a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这种方法在单个基础上设置Docker服务的上限。</p><p id="cfbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为所有服务设置此限制将保证没有服务或容器会超出其自身的资源限制，消耗主机上的大部分资源，从而影响其他服务的性能。</p><p id="8226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据Docker Compose <a class="ae ky" href="https://docs.docker.com/compose/compose-file/" rel="noopener ugc nofollow" target="_blank">引用</a>，可以通过以下方式为各个服务设置<code class="fe mz na nb nc b">cpu</code>和<code class="fe mz na nb nc b">memory</code>资源约束:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="410e" class="nh md it nc b gy ni nj l nk nl">version: "3.7"<br/>services:<br/>  redis:<br/>    image: redis:alpine<br/>    deploy:<br/>      resources:<br/>        limits:<br/>          cpus: '0.50'<br/>          memory: 50M<br/>        reservations:<br/>          cpus: '0.25'<br/>          memory: 20M</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8ee3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">结论</strong></h1><p id="84a3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">从资源的角度来看，为群服务设置资源限制有助于将群服务彼此隔离。因此，没有任何服务能够支配主机服务器上的所有资源。</p></div></div>    
</body>
</html>