<html>
<head>
<title>Introduction to Nameko: A Python Framework for Building Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nameko简介:构建微服务的Python框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-microservices-with-nameko-c2ddd203130b?source=collection_archive---------2-----------------------#2022-01-09">https://betterprogramming.pub/building-microservices-with-nameko-c2ddd203130b?source=collection_archive---------2-----------------------#2022-01-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bb5f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用Nameko的能力构建可扩展的健壮微服务系统</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/222d57908a66bc624a47ba27c06dfe76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cPn0vrJ1dFx07S-h7dBR4Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:<a class="ae kv" href="https://unsplash.com/@epan5" rel="noopener ugc nofollow" target="_blank">克日什托夫·尼沃尔尼</a></p></figure><p id="f0cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将了解Nameko及其作为微服务框架的功能。</p><h1 id="9ebe" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Nameko是什么？</h1><p id="be4e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Nameko是一个遵循微服务架构设计的框架，用于在Python中构建轻量级、高度可伸缩和容错的服务。</p><p id="825e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它内置了对以下方面的支持:</p><ul class=""><li id="f443" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">AMQP上空的RPC</li><li id="b3df" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">AMQP上的异步事件(发布-订阅)</li></ul><h1 id="1e11" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么是奈美子？</h1><p id="d24d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://nameko.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> Nameko </a>使您能够构建一个服务，该服务可以响应RPC消息，调度特定动作的事件，并侦听来自其他服务的事件。它还可以为不会说AMQP语的客户提供HTTP接口。</p><p id="6821" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建一个基本的Nameko服务并试验它的功能。</p><h1 id="607a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">设置基本环境</h1><p id="5933" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，你需要安装的<a class="ae kv" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"> Docker。我们将使用Python 3，所以请确保您也安装了它。为了运行Nameko，我们需要RabbitMQ。它将负责我们Nameko服务之间的通信。</a></p><h2 id="ec47" class="nd lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">安装</h2><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="9cf5" class="nd lt iq nq b gy nu nv l nw nx">$ pip install nameko<!-- --> </span></pre><h2 id="c4fa" class="nd lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">启动RabbitMQ容器</h2><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="ebbb" class="nd lt iq nq b gy nu nv l nw nx">$ docker run -p 5672:5672 — hostname nameko-rabbitmq rabbitmq:3</span></pre><h1 id="bd7e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Nameko的Hello World</h1><p id="a6d4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Nameko服务只是一个Python类。该类将逻辑封装在其方法中，并将任何依赖项声明为属性。</p><p id="7514" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">继续创建一个名为<code class="fe ny nz oa nq b">Service.py</code>的文件，其内容如下:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="4c33" class="nd lt iq nq b gy nu nv l nw nx">from nameko.rpc import rpc<br/><br/>class Service:<br/>    name = "service"<br/><br/>    @rpc<br/>    def receive_event(self, event):<br/>        return f"Event Received: {event}"</span></pre><p id="67b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们运行我们的例子。如果RabbitMQ正在运行，只需运行:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="8e9e" class="nd lt iq nq b gy nu nv l nw nx">$ nameko run Service</span></pre><p id="321e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Nameko实现了自动服务发现，这意味着当通过AMQP调用RPC方法时，Nameko将尝试自己找到相应的RabbitMQ服务。</p><p id="f023" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要测试我们的服务，请在另一个终端中运行以下命令:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="e287" class="nd lt iq nq b gy nu nv l nw nx">&gt;&gt;&gt; n.rpc.service.receive_event(event={‘message’: ‘Hello World!!’})</span></pre><p id="c34f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当调用RPC入口点时，会创建一个Nameko worker。worker只是服务类的一个无状态实例，这使得它本质上是线程安全的。默认情况下，服务的最大工作线程数设置为10。</p><p id="c1eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://nameko.readthedocs.io/en/stable/key_concepts.html/#workers" rel="noopener ugc nofollow" target="_blank">点击此处阅读更多关于Nameko工人的信息</a>。</p><p id="020f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果最大工作线程数设置为1，那么一次只会执行一个Nameko工作线程，也就是说，它将表现为一个常规队列。</p><h1 id="617c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">如何在两个Nameko服务之间进行通信</h1><p id="5f43" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了从一个Nameko服务到另一个服务进行通信，反之亦然，Nameko提供了一个<code class="fe ny nz oa nq b">RpcProxy</code>构造。你可以这样使用它:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="426d" class="nd lt iq nq b gy nu nv l nw nx">from nameko.rpc import rpc, RpcProxy<br/><br/>class SenderService:<br/>    name = "sender_service"<br/>    receiver_service_proxy = RpcProxy("receiver_service")<br/><br/>    @rpc<br/>    def send_event(self, event):<br/>        return self.receiver_service_proxy.receive_event({'message': 'Hello World!!'})<br/><br/>class ReceiverService:<br/>    name = "receiver_service"<br/><br/>    @rpc<br/>    def receive_event(self, event):<br/>        return f"Event Received: {event}"</span></pre><h1 id="26cc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">名片和非名片服务之间的通信</h1><p id="ffa1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有些情况下，我们需要从不是Nameko服务的地方调用Nameko服务，比如API服务或cron作业。你可以这样做:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="4e3a" class="nd lt iq nq b gy nu nv l nw nx">from nameko.standalone.rpc import ClusterRpcProxy<br/><br/>AMQP_URI = "pyamqp://user:paswword@hostname"<br/><br/>config = {<br/>    'AMQP_URI': AMQP_URI<br/>}<br/><br/>with ClusterRpcProxy(config) as cluster_rpc:<br/>    cluster_rpc.service.receive_event({'message': 'Hello World!!'})</span></pre><h1 id="84e0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">并发</h1><p id="5e33" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Nameko构建在<code class="fe ny nz oa nq b"><a class="ae kv" href="http://eventlet.net/" rel="noopener ugc nofollow" target="_blank">eventlet</a></code>库之上，通过<code class="fe ny nz oa nq b">greenthreads</code>提供并发性。</p><p id="0164" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">绿色线程与操作系统线程不同，它们相互协作让步，而不是由操作系统抢先调度。当服务的I/O负载较重时，这种行为被证明是有利的。</p><p id="bd33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个绿色线程只有在忙于执行I/O时才会让出控制权，这给了另一个绿色线程执行的机会，从而允许服务使用共享数据结构，而无需使用锁和其他同步机制。</p><p id="4dbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过修改上面的代码在实践中试验Nameko并发性:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="22f9" class="nd lt iq nq b gy nu nv l nw nx">from time import sleep<br/>from nameko.rpc import rpc<br/><br/>class Service:<br/>    name = "service"<br/><br/>    @rpc<br/>    def receive_event(self, event):<br/>        sleep(5)<br/>        return f"Event Received: {event}"</span></pre><p id="02c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在使用时间模块中的<code class="fe ny nz oa nq b">sleep</code>，这是一个阻塞调用。然而，当使用<code class="fe ny nz oa nq b">nameko run</code>运行我们的服务时，nameko会自动为非阻塞调用(如<code class="fe ny nz oa nq b">sleep(5)</code>)打上阻塞补丁，即使其异步。</p><p id="bd8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对我们服务的单个RPC调用的响应时间将是5秒。现在，如果我们一次对同一个RPC发出10个调用，那么得到所有10个调用的响应需要多长时间？</p><p id="8030" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在nameko shell中运行以下代码:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="f6cb" class="nd lt iq nq b gy nu nv l nw nx">def time_concurrent_invocations():<br/>    start_time = time.perf_counter()<br/>    responses = []<br/>    num_concurrent_calls = 10<br/>    for i in range(num_concurrent_calls):<br/>        response = n.rpc.service.receive_event({'message': f'Worker {i+1}'})<br/>        responses.append(response)<br/><br/>    for response in responses:<br/>        print(response.result)<br/><br/>    end_time = time.perf_counter()<br/><br/>    print(f'Total Time: {round(end_time-start_time, 3)}')<br/><br/>time_concurrent_invocations()</span></pre><p id="5c4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个例子只运行了大约五秒钟。每个工人将被阻塞等待睡眠调用结束，但这并不阻止另一个工人开始，在行动中隐含让步。</p><p id="0b36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您更改上面代码片段中的<code class="fe ny nz oa nq b">num_concurrent_calls = 20</code>，执行将在10秒内完成。</p><h1 id="b807" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">异步发布-订阅</h1><p id="b8e0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们假设，我们现在必须执行一个异步任务，比如在云上发送通知或上传文件:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="0c3a" class="nd lt iq nq b gy nu nv l nw nx">from nameko.events import EventDispatcher, event_handler<br/>from nameko.rpc import rpc<br/><br/>class MessageService:<br/><br/>    name = "message_service"<br/><br/>    dispatch = EventDispatcher()<br/><br/><br/>    def time_consuming_function(self, payload):<br/>        self.dispatch("heavy_payload_event", payload)<br/><br/>    @rpc<br/>    def receive_message(self, event):<br/><br/>        if event['payload']:<br/>            self.time_consuming_function(event['payload'])<br/><br/>        print(f'Message Received: {event['message']}')<br/><br/><br/><br/>class TimeConsumingService:<br/>    name = "time_consuming_service"<br/><br/>    @event_handler("message_service", "heavy_payload_event")<br/>    def time_consuming_event_handler(self, payload):<br/>        pass</span></pre><p id="d0fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当<code class="fe ny nz oa nq b">receive_message</code>处理一个带有有效负载的事件时，它调用<code class="fe ny nz oa nq b">time_consuming_function</code>，后者通过在一个单独的绿色线程中调用<code class="fe ny nz oa nq b">time_consuming_event_handler</code>来利用<code class="fe ny nz oa nq b">EventDispatcher</code>以异步方式处理有效负载。这里的调用方线程不等待事件处理程序返回响应，从而允许调用方线程更快地完成执行并接受进一步的请求。</p><h1 id="b070" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">可攀登的</h1><p id="63be" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们一直只使用一台服务器，运行一个RabbitMQ实例。在生产环境中，您可能希望任意增加运行调用过多的服务的节点数量。</p><p id="073a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了模拟服务伸缩，让我们从并发部分重新审视我们的服务。使用<code class="fe ny nz oa nq b">nameko run Service</code>打开另一个终端，像以前一样运行服务。这将启动另一个服务实例，有可能运行十个以上的工作线程。现在，尝试使用<code class="fe ny nz oa nq b">num_concurrent_calls = 20</code>再次运行该代码片段。现在应该再花五秒钟来运行。当有多个服务实例运行时，Nameko将在可用的实例中循环调用RPC请求。</p><p id="2fa8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，您可以配置这些服务，使它们可以在完全不同的机器上运行，并独立地扩展它们。您所需要做的就是将这些服务指向同一个RabbitMQ代理。</p><p id="a270" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用代理URI创建一个配置文件:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="0d33" class="nd lt iq nq b gy nu nv l nw nx"># config.yaml<br/>AMQP_URI: amqp://&lt;rabbitmq-ip&gt;:5672/</span></pre><p id="b59a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用以下命令在不同的计算机上运行这些服务:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="8f20" class="nd lt iq nq b gy nu nv l nw nx">$ nameko run &lt;nameko_service&gt; --config config.yaml</span></pre><h1 id="1021" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">容错的</h1><p id="997f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Nameko具有高度的健壮性和容错能力，因此，即使服务群集中的一个或多个节点出现故障，它也能继续正常运行，直到至少有一个健康的节点保持运行。</p><p id="47a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尝试运行服务的3个实例，并使用<code class="fe ny nz oa nq b">num_concurrent_calls = 50</code>执行测试片段。一旦执行了测试片段，就终止一两个<code class="fe ny nz oa nq b">Service</code>实例。丢失的消息将被重新路由到健康节点，从而避免消息丢失。</p><p id="166b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种行为是由于在worker执行成功完成后消息被<em class="ob">确认</em>的事实，如果在交付后但在确认前连接丢失，RabbitMQ将回收并重新交付消息。</p><h1 id="0a77" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">如果RabbitMQ服务器死亡，队列中还有消息，会发生什么情况？</h1><p id="bd4e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Nameko为RPC over AMQP创建的队列默认设置了<code class="fe ny nz oa nq b">delivery_mode=PERSISTENT</code>。这告诉RabbitMQ将消息保存到磁盘。</p><p id="d0a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，当RabbitMQ已经接受了一个消息，但还没有保存它时，有一个短的时间窗口，这意味着持久性保证不是很强。</p><p id="b933" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，Nameko默认使用<a class="ae kv" href="https://www.rabbitmq.com/confirms.html" rel="noopener ugc nofollow" target="_blank"> publisher确认</a>。确认会造成性能损失，但可以保证消息不会丢失。</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><h1 id="5a45" class="ls lt iq bd lu lv oj lx ly lz ok mb mc jw ol jx me jz om ka mg kc on kd mi mj bi translated">结论</h1><p id="a254" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Nameko旨在帮助您使用微服务构建系统，并从单个服务的单个实例扩展到包含许多不同服务的多个实例的集群。</p><p id="8d39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解更多关于Nameko的信息，请查看<a class="ae kv" href="https://nameko.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> Nameko文档</a>并加入<a class="ae kv" href="https://discourse.nameko.io/" rel="noopener ugc nofollow" target="_blank"> Nameko讨论</a>。</p></div></div>    
</body>
</html>