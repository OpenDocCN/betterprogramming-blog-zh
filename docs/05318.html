<html>
<head>
<title>Refactoring Reducers and States for a Better Store</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重构归约器和状态以获得更好的存储</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/refactoring-reducers-states-for-a-better-store-cdb355632fbf?source=collection_archive---------10-----------------------#2020-06-29">https://betterprogramming.pub/refactoring-reducers-states-for-a-better-store-cdb355632fbf?source=collection_archive---------10-----------------------#2020-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="01be" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">改进NGRX项目的综合指南(第1部分)</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/722b5998fedf8962844fde7c0e2c15be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2o9aW-W5YVTn6NhNek_dnw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="fc41" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">文档很棒，但有时你并不真正了解如何参与一项新技术，或者你甚至看不到使用它的真正优势。每当我开始一个新项目或在NGRX中检查任何项目时，有一件事让我感到困惑，那就是如何初始化存储和状态。</p><p id="9d76" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将介绍一些可以在管理其reducers的基本项目(已经在NGRX中完成)中完成的改进。我们将了解关于<a class="ae lr" href="https://ngrx.io/guide/schematics/reducer" rel="noopener ugc nofollow" target="_blank"> NGRX减速器</a>的文献的最新进展。最后，您将看到我们如何模块化我们的项目，获得抽象某些特性的好处。</p><p id="3516" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用例是别人用Angular和NGRX superpower构建的一个简单的待办事项列表(非常感谢构建它的人)。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="fa6b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">使用案例</h1><p id="b158" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">这里我们的起点是一个基本的NGRX项目，有三个动作:添加<code class="fe mw mx my mz b">Todo</code>，删除<code class="fe mw mx my mz b">Todo</code>，切换<code class="fe mw mx my mz b">Todo</code>来标记任务是否完成。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/df9a192bdc3013e8d7b9ea600d48c31d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*biycTT20p4ICrYzHPo-pYw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">花点时间熟悉一下代码，并对待办事项列表做一点小小的改动。</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="cd5d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">介绍</h1><p id="e9d7" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">尽管我们的待办事项列表工作得很好，但我们可以看到快速而简单的性能改进是使其更具可伸缩性和模块化的下一个合理步骤。</p><p id="1814" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从这里开始，让我们开始工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/b08cf796f652f81d0046bb22359c903c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fc5MnkAdyXwl8npP8878Fg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae lr" href="https://github.com/ackuser/ngrx-custom-reducers-todo-list/tree/feature/startPoint" rel="noopener ugc nofollow" target="_blank">https://github . com/ack user/ngrx-custom-reducers-todo-list/tree/feature/start point</a></p></figure><p id="a0de" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此时回购:<a class="ae lr" href="https://stackblitz.com/edit/ngrx-custom-reducers-todo-list" rel="noopener ugc nofollow" target="_blank"> StackBlitz </a>或<a class="ae lr" href="https://github.com/ackuser/ngrx-custom-reducers-todo-list/tree/feature/startPoint" rel="noopener ugc nofollow" target="_blank">GitHub</a>on branch feature/start point。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0d89" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">关键概念</strong></h1><p id="7c41" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">减速器是商店应用程序的基础。由于应用程序存储维护状态，reducers是在调度动作时操纵和输出新状态表示的主力。每一个缩减器都应该专注于一个特定的部分，或者状态的一部分，类似于数据库中的一个表。</p><h2 id="d3bf" class="ne ma iq bd mb nf ng dn mf nh ni dp mj le nj nk ml li nl nm mn lm nn no mp np bi translated">定义状态形状:<code class="fe mw mx my mz b">reducer.ts</code></h2><pre class="kg kh ki kj gt nq mz nr ns aw nt bi"><span id="6c1c" class="ne ma iq mz b gy nu nv l nw nx">export interface State {<br/>   todoList: Array&lt;Todo&gt;<br/>}</span></pre><h2 id="0bb6" class="ne ma iq bd mb nf ng dn mf nh ni dp mj le nj nk ml li nl nm mn lm nn no mp np bi translated">设定初始状态:<code class="fe mw mx my mz b">reducer.ts</code></h2><pre class="kg kh ki kj gt nq mz nr ns aw nt bi"><span id="b76a" class="ne ma iq mz b gy nu nv l nw nx">export const initialState: State = {<br/>   todoList: []<br/>};</span></pre><p id="00fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很简单。但是，拥有一个坚实的结构让我们能够解决我们的应用程序，使它更容易理解和扩展。</p><h2 id="a719" class="ne ma iq bd mb nf ng dn mf nh ni dp mj le nj nk ml li nl nm mn lm nn no mp np bi translated">注册根状态:<code class="fe mw mx my mz b">app.module.ts</code></h2><pre class="kg kh ki kj gt nq mz nr ns aw nt bi"><span id="d259" class="ne ma iq mz b gy nu nv l nw nx">StoreModule.forRoot({todosSliceState: todoReducer}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/322ca7d6814988e517537bf11e3686e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*Du3ox5Ahf5OMK9-4mfgvuw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">某一时刻的状态快照</p></figure><p id="1384" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好吧，但我不太喜欢物体内部的物体。而现在的问题是，我还得把这种东西写进我的组件里:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/12eb74ac5962d761f0c449ca2bafa568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*Fy6je5_szSSx3idKsbmPfA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用程序组件</p></figure><p id="9ad1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只要你的应用程序不断增长，整个州就会被分成不同的部分，所以选择器可以拯救你:</p><p id="ab90" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mw mx my mz b"><strong class="kx ir">selectors.ts</strong></code></p><pre class="kg kh ki kj gt nq mz nr ns aw nt bi"><span id="59e1" class="ne ma iq mz b gy nu nv l nw nx">export interface AppState {<br/>    todosSliceState: TodosState;<br/>}</span><span id="717e" class="ne ma iq mz b gy oa nv l nw nx">export const selectTodosSliceState = (state: AppState) =&gt; state.todosSliceState;</span><span id="d03f" class="ne ma iq mz b gy oa nv l nw nx">export const selectTodos = createSelector(<br/>selectTodosSliceState,<br/>(state: TodosState) =&gt; state.todos<br/>);</span></pre><p id="3475" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基本上，我们对状态做了一个抽象，说:“我们想要得到我们的<code class="fe mw mx my mz b">todos</code>的切片。一旦我们有了，那么请通过选择器使它们可用。”</p><p id="c329" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这极大地美化了我们在大型应用中的控制器，同时也将它们与Observables的所有功能共享。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/3823930a343ef53e82ed3a3686af9d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJClv07JRYwxpOKfgjMUiw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用程序组件</p></figure><p id="ded9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让它在生产模式下编译(ng &lt; 9.x).</p><p id="0e8f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Reducers probably look like  【T2】 :</p><pre class="kg kh ki kj gt nq mz nr ns aw nt bi"><span id="8903" class="ne ma iq mz b gy nu nv l nw nx">export const _todoReducer = createReducer(<br/>initialState,<br/>                       ...</span></pre><p id="4a3d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">And you will get this in Angular versions lower than 9:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/2784252c16197d561c71e8d20f0dc1bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*DWSiPfsyvE_5HW_2NvnoXg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Error during compile the project</p></figure><p id="b538" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">The approach to get rid of this error and make your project AOT-compilable would be to <a class="ae lr" href="https://ngrx.io/guide/store/reducers#creating-the-reducer-function" rel="noopener ugc nofollow" target="_blank">像这样包装你的reducer函数调用</a>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/270cec5c35b27365be2f0ba26d59aa1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWmtXx3Iv0ERSjkGNYvbqA.png"/></div></div></figure><p id="17ce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此时的回购:分支特征/形状状态上的<a class="ae lr" href="https://stackblitz.com/edit/ngrx-custom-reducers-todo-list" rel="noopener ugc nofollow" target="_blank"> StackBlitz </a>或<a class="ae lr" href="https://github.com/ackuser/ngrx-custom-reducers-todo-list/tree/feature/shapeState" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b7e4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">使其成为一个模块(重构)</strong></h1><p id="0c52" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">我们不会做一个只有一个功能的NGRX应用程序，因为在这样的情况下，它甚至不配用Angular做这个应用程序。这是一个基本的例子，对吗？</p><p id="3c2f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以还是那句话，只要你的app成长了，你就会把你app的这部分/特性开发成<a class="ae lr" href="https://ngrx.io/guide/store/reducers#register-feature-state" rel="noopener ugc nofollow" target="_blank">模块特性</a>。</p><p id="29de" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们将待办事项列表块模块化:</p><ol class=""><li id="9453" class="oe of iq kx b ky kz lb lc le og li oh lm oi lq oj ok ol om bi translated">从根中移除<code class="fe mw mx my mz b">todo</code>状态。我们把它放在新的模块中。</li></ol><p id="4692" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mw mx my mz b">app.module.ts</code>(《前传》):</p><pre class="kg kh ki kj gt nq mz nr ns aw nt bi"><span id="28f7" class="ne ma iq mz b gy nu nv l nw nx">StoreModule.forRoot({todosSliceState: todoReducer}<br/>                              ...</span></pre><p id="dab8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">变成了<code class="fe mw mx my mz b">app.module.ts</code>(“现在”):</p><pre class="kg kh ki kj gt nq mz nr ns aw nt bi"><span id="164e" class="ne ma iq mz b gy nu nv l nw nx">StoreModule.forRoot({}<br/>                             ...</span></pre><p id="96e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.抽象特征键。</p><p id="ab11" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mw mx my mz b">reducer.ts</code></p><pre class="kg kh ki kj gt nq mz nr ns aw nt bi"><span id="1aa8" class="ne ma iq mz b gy nu nv l nw nx">export const featureKey = 'todosSliceState';</span></pre><p id="271d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:注册特性状态和调用<code class="fe mw mx my mz b"><a class="ae lr" href="https://ngrx.io/api/store/createFeatureSelector" rel="noopener ugc nofollow" target="_blank">createFeatureSelector</a></code>时，建议抽象一个特性键字符串，防止硬编码字符串。</p><p id="155b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.<a class="ae lr" href="https://ngrx.io/guide/store/reducers#register-feature-state" rel="noopener ugc nofollow" target="_blank">创建一个新模块</a>。</p><p id="7655" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mw mx my mz b">todo.module.ts</code></p><pre class="kg kh ki kj gt nq mz nr ns aw nt bi"><span id="6f50" class="ne ma iq mz b gy nu nv l nw nx">import * as fromTodos from './reducer';</span><span id="f6e4" class="ne ma iq mz b gy oa nv l nw nx">@NgModule({</span><span id="899a" class="ne ma iq mz b gy oa nv l nw nx">imports: [<br/>...<br/>StoreModule.forFeature(fromTodos.featureKey, fromTodos.todoReducer)<br/>...<br/>]})</span></pre><p id="53d9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">总而言之，这是塑造我们国家的另一种方式。唯一的区别是我们是通过一个模块来完成的，因此加载这个新模块是至关重要的——别忘了！</p><pre class="kg kh ki kj gt nq mz nr ns aw nt bi"><span id="5b4c" class="ne ma iq mz b gy nu nv l nw nx">@NgModule({</span><span id="0a38" class="ne ma iq mz b gy oa nv l nw nx">imports: [<br/>...<br/>TodoModule,<br/>...</span></pre><p id="de39" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:我急切地加载<code class="fe mw mx my mz b">Todo</code>模块<em class="on"/>，但是你也可以懒洋洋地加载<em class="on"/>。您的特性状态是急切加载还是延迟加载取决于您的应用程序的需求。</p><p id="9536" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">4.<a class="ae lr" href="https://ngrx.io/guide/store/selectors" rel="noopener ugc nofollow" target="_blank">选择器</a></p><p id="8d8a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们改变<code class="fe mw mx my mz b">selector.ts</code>(“之前”)</p><pre class="kg kh ki kj gt nq mz nr ns aw nt bi"><span id="9e8c" class="ne ma iq mz b gy nu nv l nw nx"><em class="on">export const selectTodosSliceState = (state: AppState) =&gt; state.todosSliceState;</em></span><span id="12dd" class="ne ma iq mz b gy oa nv l nw nx">export const selectTodos = createSelector(selectTodosSliceState,(state: TodosState) =&gt; state.todos);</span><span id="c3b3" class="ne ma iq mz b gy oa nv l nw nx">...</span></pre><p id="7775" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">到<code class="fe mw mx my mz b">selector.ts</code>(“现在”)。</p><pre class="kg kh ki kj gt nq mz nr ns aw nt bi"><span id="9726" class="ne ma iq mz b gy nu nv l nw nx">export const selectTodosSliceState = createFeatureSelector&lt;AppState, TodosState&gt;(featureKey);</span><span id="aa4b" class="ne ma iq mz b gy oa nv l nw nx">export const selectTodos = createSelector(selectTodosSliceState,(state: TodosState) =&gt; state.todos);</span><span id="1df2" class="ne ma iq mz b gy oa nv l nw nx">                            ...</span></pre><p id="2a12" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就这么简单。(有一些区别，我可能会在其他文章中解释。)</p><p id="7de4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我还做了一些与NGRX无关的事情。其中，我创建了组件，使它们变得聪明和愚蠢。如果我还没有说服你，看看他们。它们可能对你构建一个模块更有意义。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/2263c086bef77e427ef47cb604716c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N5WD4cHmRuOxo0uIBjv57Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">主要组件的快照</p></figure><p id="be07" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此时回购:分支特征/模块上的<a class="ae lr" href="https://stackblitz.com/edit/ngrx-custom-reducers-todo-list" rel="noopener ugc nofollow" target="_blank"> StackBlitz </a>或<a class="ae lr" href="https://github.com/ackuser/ngrx-custom-reducers-todo-list/tree/feature/module" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7d4b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="d417" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">我从NGRX中已经完成的一个例子开始这篇文章，因为我认为专注于提供快速扩展应用程序的工具比从头开始一个NGRX项目更有趣(非常无聊)。</p><p id="cbbd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望它能对任何开始向NGRX介绍自己的人有用。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="01ca" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">后续步骤</h1><p id="6867" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">我们将讨论NGRX的其他主题，比如reducers、selectors、<code class="fe mw mx my mz b">metaReducers</code>、facades中的依赖注入，也许还有这个框架的其他部分，比如<code class="fe mw mx my mz b">ngrx/entity</code>或<code class="fe mw mx my mz b">ngrx/data</code>。</p><p id="4a43" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你读完了，谢谢。</p></div></div>    
</body>
</html>