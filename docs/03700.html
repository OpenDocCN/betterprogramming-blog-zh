<html>
<head>
<title>Special CSS Just for Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">仅用于组件的特殊CSS</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/2020-010-special-css-just-for-components-d5fc36c83744?source=collection_archive---------12-----------------------#2020-02-27">https://betterprogramming.pub/2020-010-special-css-just-for-components-d5fc36c83744?source=collection_archive---------12-----------------------#2020-02-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="200a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何创建标准、健壮的组件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/744eda5a9217b0566875e9c7a14d23e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JHziIluNUs3rBIv6zlY5kw.png"/></div></div></figure><p id="3a91" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从历史上看，HTML组件的设计很脆弱，灵活性很小。不应该是这样的。现在有一种标准的方式让消费者能够定制组件。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="a4ca" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">为Web组件输入CSS</h1><p id="18aa" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">web组件的两个方面似乎是相互对立的:隔离和定制。开发者如何保持内部CSS规则与外界隔离？消费者如何设计组件来实现他们想要的品牌？</p><p id="606b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种冲突可以通过针对web组件设计的特殊CSS特性来解决。</p><p id="ec5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们定义隔离和定制的目标。</p><p id="15ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mu">隔离</em>是组件的影子DOM创建的防火墙。在隔离的情况下，应用于网站的CSS规则只影响从文档的根到自定义元素的元素，而不会进一步影响。另一方面，在组件中声明的CSS规则只影响从它的分离阴影根开始的元素。</p><p id="4f61" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是好事。它允许组件开发者和组件消费者独立地声明规则，而不用担心他们的决定会被意外地覆盖。</p><p id="045b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mu">定制</em>另一方面，是消费者定制组件外观的能力。消费者可以使用CSS修饰设计良好的组件，而无需分叉代码。</p><p id="d5b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">CSS工作组几年来一直在试验解决这一明显冲突的方法。他们采用的解决方案现在可以在浏览器中使用。</p><p id="4504" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是目前可以使用的产品:</p><ul class=""><li id="748e" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">CSS自定义属性，用于将值传递给组件</li><li id="48db" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><code class="fe nj nk nl nm b">:host</code>选择器，用于自引用组件定位</li><li id="d2e3" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><code class="fe nj nk nl nm b">:host()</code>伪类选择器，用于选择组件的实例</li><li id="08d2" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated"><code class="fe nj nk nl nm b">::slotted()</code>伪元素选择器，用于定位用户插入组件的元素</li></ul><p id="4cae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的一切都是基于标准的，由万维网联盟(W3C)采用，并且独立于任何专有框架，如React、Vue或Angular。它经得起未来的考验。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="5c64" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">CSS自定义属性</h1><p id="820d" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">CSS自定义属性被用来解决许多不同的问题。它们已经存在了一段时间，大多数CSS作者都很熟悉。</p><p id="0dee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回顾一下，自定义属性通常在文档的根级别声明，并在选择器中使用，如下例所示:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="48a1" class="nr ly it nm b gy ns nt l nu nv">:root {<br/>    --color: #DDD;<br/>    --background: #333;<br/>}<br/>p {<br/>    color: var(--color);<br/>    background-color: var(--background);<br/>}</span></pre><p id="1ed3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里使用的<code class="fe nj nk nl nm b">:root</code>伪类选择器可能有些人不熟悉。它与<code class="fe nj nk nl nm b">html</code>选择器同义，但具有更高的特异性。哪一个都可以。</p><p id="be9f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">自定义属性不必在根处声明。它们也可以在元素上声明。例如，我们可以通过这样做来本地化名为<code class="fe nj nk nl nm b">rwt-shadowbox</code>的自定义元素中使用的变量的范围:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="0857" class="nr ly it nm b gy ns nt l nu nv">rwt-shadowbox {<br/>    --color: #DDD;<br/>    --background: #333;<br/>    --alt-color: #EEE;<br/>    --alt-background: #222;<br/>}</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="952e" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">组件内部的自定义属性</h1><p id="38be" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">现在让我们离开文档的CSS，看看组件的内部CSS。</p><p id="e153" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每当需要向外界公开一个特性时，可以将组件的内部样式表设计成使用定制的属性名。这些名称既可以在文档的样式表中声明(如前所示)，也可以在组件本身内部声明。</p><p id="273b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，组件的内部样式表可能被设计成使用这些名称，就像这样:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="e7b8" class="nr ly it nm b gy ns nt l nu nv">header {<br/>    color: var(--color);<br/>    background: var(--background);<br/>}<br/>footer {<br/>    color: var(--alt-color);<br/>    background: var(--alt-background);<br/>}</span></pre><p id="b1df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与固定值(如<code class="fe nj nk nl nm b">#DDD</code>和<code class="fe nj nk nl nm b">#333</code>)不同，像这样的自定义属性<em class="mu"> </em>穿透了影子DOM防火墙。这是组件创建者让消费者控制其样式的主要方式。</p><p id="e11a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您没有从本文中学到任何东西，请记住:CSS自定义属性——由用户在文档的样式表中定义——穿透了影子DOM防火墙。</p><p id="59e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">自定义属性本身是一个好的开始，但是我们可以用<code class="fe nj nk nl nm b">:host</code>选择器使我们的组件更加灵活。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="8638" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">:主机选择器</h1><p id="8501" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">好的组件设计会将关于尺寸、位置和装饰的最终决定留给消费者。正如刚才演示的那样，这可以通过使用变量来实现。然而，组件不应该强迫消费者提供这些。组件创建者应该始终提供合理的默认值。</p><p id="2055" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，通过在一个<code class="fe nj nk nl nm b">:host</code>选择器中声明默认变量值，在组件内部指定它们。这个特殊的选择器相当于影子DOM的文档DOM的<code class="fe nj nk nl nm b">:root</code>选择器。</p><p id="9a72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再次考虑名为<code class="fe nj nk nl nm b">rwt-shadowbox</code>的示例组件。这是一个考虑到定制而设计的对话框。创建者有目的地使用组件大小和位置的变量，以使消费者在使用时具有灵活性。</p><p id="37c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了实现这一点，创建者在组件的<code class="fe nj nk nl nm b">:host</code>选择器中声明变量，并在<code class="fe nj nk nl nm b">#shadowbox</code>选择器中使用它们，如下所示:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="1ae8" class="nr ly it nm b gy ns nt l nu nv">:host {<br/>    --width: 70vw;<br/>    --height: 50vh;<br/>    --bottom: 1rem;<br/>    --left: 1rem;<br/>}<br/>#shadowbox {<br/>    width: var(--width);<br/>    height: var(--height);<br/>    bottom: var(--bottom);<br/>    left: var(--left);<br/>}</span></pre><p id="8ab8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果创建者没有为<code class="fe nj nk nl nm b">:host</code>中的变量声明默认值，消费者将被迫为四个变量中的每一个提供值。</p><p id="5f39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">CSS <code class="fe nj nk nl nm b">var()</code>语法也为这些情况提供了后备值，作为一种安全网。后备值被指定为<code class="fe nj nk nl nm b">var()</code>的第二个参数，如下所示:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="ff88" class="nr ly it nm b gy ns nt l nu nv">#shadowbox {<br/>    width: var(--width, 70vw);<br/>    height: var(--height, 50vh);<br/>    bottom: var(--bottom, 1rem);<br/>    left: var(--left, 1rem);<br/>}</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="181e" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">选择组件实例</h1><p id="8b0e" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">有时，一种成分被有意设计成具有多种风味。例如，一个组件可能同时具有一组暗模式和一组亮模式的颜色默认值。在这种情况下，创建者可能希望通过让用户指定一个类名而不是一系列颜色变量来简化用户的工作。</p><p id="bcb0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建者可以用<code class="fe nj nk nl nm b">:host()</code>伪类选择器来做这件事。这可能是这样的:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="88cc" class="nr ly it nm b gy ns nt l nu nv">:host(.darkmode) {<br/>    --color: #DDD;<br/>    --background: #333;<br/>}<br/>:host(.brightmode) {<br/>    --color: #222;<br/>    --background: #EEE;<br/>}</span></pre><p id="e093" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">选择使用黑暗模式主题的使用者会将组件放入文档中，如下所示:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="2a28" class="nr ly it nm b gy ns nt l nu nv">&lt;body&gt;<br/>    &lt;h1&gt;Dark mode&lt;/h1&gt;<br/>    &lt;rwt-shadowbox class='darkmode'&gt;&lt;/rwt-shadowbox&gt;<br/>&lt;/body&gt;</span></pre><p id="5d28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当一个文档中有多个组件实例时，这种技术也可以用来定位组件的特定实例。也许，对于成员有一个对话框，对于非成员有一个稍微不同的变体。用于定位标识为<code class="fe nj nk nl nm b">non-member</code>的消费者实例的组件的CSS将是:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="636b" class="nr ly it nm b gy ns nt l nu nv">:host(#non-member) {<br/>    --color: #DDD;<br/>    --background: #333;<br/>}</span></pre><p id="38e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以非成员角色使用组件的使用者会将文档指定为:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="abb8" class="nr ly it nm b gy ns nt l nu nv">&lt;body&gt;<br/>    &lt;h1&gt;Non member&lt;/h1&gt;<br/>    &lt;rwt-shadowbox id='non-member'&gt;&lt;/rwt-shadowbox&gt;<br/>&lt;/body&gt;</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="a81b" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">选择开槽元素</h1><p id="e83b" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">有时组件被有目的地设计成允许消费者插入元素。我在这里详细讨论了这个<a class="ae nw" href="https://medium.com/better-programming/2020-008-add-flexibility-to-web-components-with-slots-c07ce2620952" rel="noopener">。</a></p><p id="094c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">考虑消费者对三个开槽元件的这种使用:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="e227" class="nr ly it nm b gy ns nt l nu nv">&lt;body&gt;<br/>    &lt;rwt-shadowbox&gt;<br/>        &lt;h1 slot='inner' id='caption'&gt;Slotted Header&lt;/h2&gt;<br/>        &lt;p slot='inner' class='first-para'&gt;First paragraph...&lt;/p&gt;<br/>        &lt;p slot='inner'&gt;Next paragraph...&lt;/p&gt;<br/>    &lt;/rwt-shadowbox&gt;<br/>&lt;/body&gt;</span></pre><p id="5c29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以使用<code class="fe nj nk nl nm b">::slotted()</code>伪元素定位开槽元素。它有一个参数，是一个选择器，比如标记名、标识符或类名。</p><p id="143e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该示例中组件的内部样式可能如下所示:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="95bb" class="nr ly it nm b gy ns nt l nu nv">::slotted(#caption) {<br/>    font-size: 2rem;<br/>}<br/>::slotted(p) {<br/>    text-indent: 0;<br/>}<br/>::slotted(.first-para) {<br/>    text-indent: 1rem;<br/>}</span></pre><p id="e1e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，组件创建者以三种方式使用了<code class="fe nj nk nl nm b">::slotted()</code>伪元素:用标识符定位标题，用<code class="fe nj nk nl nm b">&lt;p&gt;</code>标记定位所有段落，用类名定位第一个段落。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="1b9f" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">摘要</h1><p id="8c83" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">所有这些都很难理解，所以我开源了几个定制组件，您可以在这里更详细地研究这个主题<a class="ae nw" href="https://hub.readwritetools.com/components.blue?utm_term=CSSforWebComponents" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="d12a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总之，组件创建者有四种技术可以为消费者提供他们渴望的灵活性:</p><ul class=""><li id="e40e" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">使用CSS自定义属性向使用者公开各个设置</li><li id="c1c8" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">使用组件内部的<code class="fe nj nk nl nm b">:host</code>选择器，就像在文档中使用<code class="fe nj nk nl nm b">:root</code>选择器一样</li><li id="0c58" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">使用<code class="fe nj nk nl nm b">:host()</code>伪类选择器让消费者能够定位内部组件类</li><li id="6883" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">使用<code class="fe nj nk nl nm b">::slotted()</code>伪元素选择器对消费者插入的任意元素进行样式化</li></ul><p id="66c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过适当的预先考虑，组件设计可以享受隔离的安全好处，同时提供定制的灵活性好处，使事情不那么脆弱，更有用。</p></div></div>    
</body>
</html>