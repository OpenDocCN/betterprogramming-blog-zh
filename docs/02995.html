<html>
<head>
<title>How to Design a Basic Logging System in Your Go Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在你的Go应用中设计一个基本的日志系统</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-and-designing-logging-system-in-go-application-c85a28bb8526?source=collection_archive---------4-----------------------#2020-01-14">https://betterprogramming.pub/understanding-and-designing-logging-system-in-go-application-c85a28bb8526?source=collection_archive---------4-----------------------#2020-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b861" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更好的日志记录，更好的调试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/18a34e8c69f1940da83b986db9721029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VQ6MJzjOKDZWQl6ArR1SUg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@firmbee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">威廉·艾文</a>在<a class="ae ky" href="https://unsplash.com/s/photos/design?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="5507" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">简介</strong></h1><p id="df0b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">由于Go的可组合性、可伸缩性和并发性，以及其他非常有趣的特性，许多公司都将赌注压在了它身上。</p><p id="7776" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">简单的web服务和微服务应用程序需要一个经过深思熟虑的日志记录策略来帮助我们理解用户行为、定位错误并监控应用程序的性能。</p><p id="02c4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本文中，我们将探索跟踪、度量和日志记录。尤其是日志记录，将会得到最大的关注。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="aac7" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">跟踪/监控/记录</h1><h2 id="c28e" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated"><strong class="ak">什么是追踪？</strong></h2><p id="c234" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">与日志记录相比，跟踪覆盖了更广泛、更连续的应用程序视图。实现跟踪的主要原因是为了能够监督应用程序的流程和进出应用程序的数据进展。因此，跟踪扮演的角色比日志记录更脏。</p><p id="2618" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">跟踪代表单个用户在整个应用程序中的旅程。这使得工程师能够识别瓶颈，并专注于改善和优化应用程序的性能。</p><p id="0e4b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">运行时/跟踪为程序提供了为Go执行跟踪器生成跟踪的工具。当问题确实发生时，跟踪允许您查看您是如何到达那里的:哪个函数、函数的持续时间、传递的参数以及用户可以到达函数的多深。在理想的Go应用程序中，每个函数都支持跟踪。尽管Stackdriver(可以通过OpenCensus Go包使用)等云技术可以帮助在您的应用程序中检测追踪过程，但由此产生的数据量可能会太多而无法排序。</p><p id="a4d5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">示例</strong>:以下代码记录了执行跟踪中的四个区域，以跟踪卡布奇诺制作操作中连续步骤的持续时间(来自<code class="fe nr ns nt nu b">trace</code>官方包):</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="6ec3" class="ne la it nu b gy nz oa l ob oc">trace.WithRegion(ctx, “makeCappuccino”, func() {</span><span id="98b5" class="ne la it nu b gy od oa l ob oc">      // orderID allows to identify a specific order</span><span id="273f" class="ne la it nu b gy od oa l ob oc">      // among many cappuccino order region records.</span><span id="5a90" class="ne la it nu b gy od oa l ob oc">      trace.Log(ctx, “orderID”, orderID)</span><span id="77b6" class="ne la it nu b gy od oa l ob oc">      trace.WithRegion(ctx, “steamMilk”, steamMilk)</span><span id="ce62" class="ne la it nu b gy od oa l ob oc">      trace.WithRegion(ctx, “extractCoffee”, extractCoffee)</span><span id="d392" class="ne la it nu b gy od oa l ob oc">      trace.WithRegion(ctx, “mixMilkCoffee”, mixMilkCoffee)</span><span id="1ca5" class="ne la it nu b gy od oa l ob oc">})</span></pre><h2 id="bc6e" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated"><strong class="ak">什么是监控？</strong></h2><p id="8fd1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">术语<em class="nq">监控</em>可用于跟踪、记录或其他一些活动。然而，监视要具体得多:它检测应用程序，然后收集、汇总和分析指标，以便更好地理解应用程序的行为。</p><p id="463f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这种类型的监控主要是诊断性的——例如，当系统没有正常工作时，向开发人员发出警报。在理想情况下，成本不是问题，您可以检测和监控您的所有服务。在Go应用程序中实现监控的一个极好的工具是OpenTracing(请查看它们)。</p><h2 id="e44d" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated"><strong class="ak">什么是日志记录？</strong></h2><p id="343f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><em class="nq">日志</em>以一种战略性的集中格式为我们提供错误报告跟踪和相关数据。</p><p id="2197" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">可以为不同模式的小型和大型应用程序实现日志记录。日志文件服务器被认为是在应用程序中获取离散事件的第一站。离散事件可以是应用程序中的失败、错误或状态转换，可以指示事件的主要原因。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="1e4f" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">在Go应用程序中实现日志记录的工具</h1><h2 id="f525" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated"><strong class="ak">内置的‘日志’库</strong>:</h2><p id="be4e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">可以使用Golang内置的<a class="ae ky" href="https://golang.org/pkg/log/" rel="noopener ugc nofollow" target="_blank">日志库</a>，命名为<code class="fe nr ns nt nu b">log</code>。这个包附带了一个默认的记录器，它可以编写一个标准错误并添加一个时间戳，而不需要进行配置。就我个人而言，当我需要从代码中获得快速反馈，而不必担心生成丰富的结构化日志时，我发现这个包对本地开发更有用。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="e0b4" class="ne la it nu b gy nz oa l ob oc">package main</span><span id="2cee" class="ne la it nu b gy od oa l ob oc">import (“log” “errors” “fmt”)</span><span id="3408" class="ne la it nu b gy od oa l ob oc"><br/>func add(f int64, s int64) (int64, error) {<br/>    if f &lt; 0 &amp;&amp; s &lt; 0 {<br/>         return 0, errors.New(“cannot add signed numbers”)<br/>    }</span><span id="2a45" class="ne la it nu b gy od oa l ob oc">    return f * s, nil<br/>}<br/></span><span id="8740" class="ne la it nu b gy od oa l ob oc">func main() {<br/>    var first, second int64<br/>    first, second = 10, 20</span><span id="2a66" class="ne la it nu b gy od oa l ob oc">    //first, second = -10, -20<br/>    <br/>    result, err := add(first, second)<br/>    <br/>    if err != nil{<br/>       log.Print(err)<br/>    }</span><span id="b46b" class="ne la it nu b gy od oa l ob oc">    fmt.Println(result)<br/>}</span></pre><h2 id="c3b4" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated"><strong class="ak">浩浩荡荡</strong><a class="ae ky" href="https://github.com/sirupsen/logrus" rel="noopener ugc nofollow" target="_blank"><strong class="ak">Logrus</strong></a><strong class="ak">包</strong>:</h2><p id="a4cf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您可以将Logrus用于格式化日志。这是一个强烈推荐的包，因为它是为JSON等合适格式的结构化日志设计的。由于许多语言都支持JSON格式，这使得机器可以轻松解析Golang日志。下面的代码片段为我们提供了一个示例和预期结果:</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="f729" class="ne la it nu b gy nz oa l ob oc">package main</span><span id="4538" class="ne la it nu b gy od oa l ob oc">import (log “github.com/sirupsen/logrus”)</span><span id="d38e" class="ne la it nu b gy od oa l ob oc">func main() {</span><span id="3143" class="ne la it nu b gy od oa l ob oc">      log.SetFormatter(&amp;log.JSONFormatter{})</span><span id="cafc" class="ne la it nu b gy od oa l ob oc">      coreFields := log.Fields{ “gopher_lagos”: “staging-1”, “meetup”: “foo-app”, “session”: “1ce3f6v”, }</span><span id="f097" class="ne la it nu b gy od oa l ob oc">    log.WithFields(coreFields).WithFields(log.Fields{“product_type”: “ticket”, “quantity”: 3, “price”:100.0}).Info(“This is for Gophers Lagos Meetup”)</span><span id="9abb" class="ne la it nu b gy od oa l ob oc">}</span></pre><p id="9ba2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面的代码片段会导致如下结果:</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="c6df" class="ne la it nu b gy nz oa l ob oc"><em class="nq">{“gopher_lagos”:”staging-1",”level”:”info”,”meetup”:”foo-app”,”msg”:”This is for Gophers Lagos Meetup”,”number”:3,”price”:100,”product_type”:”ticket”,”session”:”1ce3f6v”,”time”:”2009–11–10T23:00:00Z”}</em></span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="b7d8" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated"><strong class="ak">设计和存储Golang日志的最佳实践(Datadog，2019年):</strong></h1><h2 id="0366" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">避免为日志记录声明“goroutines”</h2><p id="2986" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">避免创建自己的<code class="fe nr ns nt nu b">goroutine</code>来处理写日志有两个原因。首先，它会导致并发问题，因为日志记录器的副本会试图访问同一个<code class="fe nr ns nt nu b">io.Writer</code>。第二，日志库通常自己启动<code class="fe nr ns nt nu b">goroutine</code>，在内部管理任何并发问题，启动自己的<code class="fe nr ns nt nu b">goroutine</code>只会造成干扰。</p><h2 id="2e4a" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">将您的日志写入文件</h2><p id="e926" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当您从应用程序中收集日志时，建议您直接将它们写入本地文件(而不是直接写入远程文件)。您需要确保您的日志在本地始终可用，并且不会在网络中丢失。</p><h2 id="c694" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated"><strong class="ak">实现标准日志接口</strong></h2><p id="beec" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在一个开发人员/工程师团队中，很可能会看到成员使用不同的属性名称来描述同一件事情。这可能会导致日志中不可解决的不一致，并使应该构成同一画面一部分的日志之间的关联变得非常激烈。例如，当以不同的方式处理上传时，两个开发人员可能会记录相同的错误—缺少客户端名称。实现标准日志接口是避免这种灾难的唯一方法。</p><p id="edc7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们看一个实际的例子。下面的结构定义了我们希望记录的对象/事件。当然，我们可以向列表中添加更多事件:</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="d339" class="ne la it nu b gy nz oa l ob oc">type LogEvent struct {<br/>    id int<br/>    message string<br/>}</span></pre><p id="1118" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这些变量将我们的日志消息存储为新事件:</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="0c8f" class="ne la it nu b gy nz oa l ob oc">var (<br/>     invalidArgMessage = LogEvent{1, “Invalid arg: %s”}</span><span id="c2ee" class="ne la it nu b gy od oa l ob oc">     invalidArgValueMessage = LogEvent{2, “Invalid value for argument: %s: %v”}</span><span id="f565" class="ne la it nu b gy od oa l ob oc">     missingArgMessage = LogEvent{3, “Missing arg: %s”}<br/>)</span></pre><p id="7f5d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">标准错误消息和init():</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="b21e" class="ne la it nu b gy nz oa l ob oc">// Standard “InvalidArg error messagefunc (m *MainLogger) InvalidArg(argumentName string){<br/>    m.Errorf(invalidArgMessage.message, argumentName)<br/>}</span><span id="b544" class="ne la it nu b gy od oa l ob oc">// Standard “InvalidArgValue error message<br/>func (m *MainLogger) InvalidArgValue(argumentName string, argumentValue string){<br/>    m.Errorf(invalidArgValueMessage.message, argumentName, argumentValue)<br/>}</span><span id="ce30" class="ne la it nu b gy od oa l ob oc">// “Standard “MissingArg error message”<br/>func (m *MainLogger) MissingArg(argumentName string){<br/>    m.Errorf(missingArgMessage.message, argumentName)<br/>}</span><span id="d6ef" class="ne la it nu b gy od oa l ob oc">// MainLogger enforces specific log message formats (we are using logrus, but you are free to use other libraries)</span><span id="d65e" class="ne la it nu b gy od oa l ob oc">type MainLogger struct {<br/>   *logrus.Logger<br/>}</span><span id="9ed0" class="ne la it nu b gy od oa l ob oc">func init() {<br/>    // Log as JSON instead of the default ASCII formatter.<br/>    logrus.SetFormatter(&amp;logrus.JSONFormatter{})<br/>}</span></pre><p id="8d20" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">创建一个构造器/初始化器来返回我们的<code class="fe nr ns nt nu b">MainLogger</code>结构:</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="8c75" class="ne la it nu b gy nz oa l ob oc">func NewLogger() *MainLogger {<br/>     f, err := os.OpenFile(“logrus.log”,      os.O_APPEND|os.O_CREATE|os.O_RDWR, 0666)</span><span id="04f6" class="ne la it nu b gy od oa l ob oc">     if err != nil {<br/>         fmt.Printf(“error opening file: %v”, err)<br/>     }</span><span id="4e9b" class="ne la it nu b gy od oa l ob oc">     var baseLogger = logrus.New()</span><span id="742c" class="ne la it nu b gy od oa l ob oc">     var standardLogger = &amp;MainLogger{baseLogger}</span><span id="d16d" class="ne la it nu b gy od oa l ob oc">     standardLogger.Formatter = &amp;logrus.JSONFormatter{}</span><span id="075d" class="ne la it nu b gy od oa l ob oc">     mw := io.MultiWriter(os.Stdout, f)</span><span id="71b9" class="ne la it nu b gy od oa l ob oc">     standardLogger.SetOutput(mw) return standardLogger<br/>}</span></pre><p id="3618" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们已经完成了基本标准接口的设计，可以开始调用Go文件中的方法了，如下所示:</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="9097" class="ne la it nu b gy nz oa l ob oc">var standardLogger = logger.NewLogger()</span><span id="4874" class="ne la it nu b gy od oa l ob oc">// call method when an argument is missing<br/>standardLogger.MissingArg(“imgModel.ImageData”)</span><span id="fa87" class="ne la it nu b gy od oa l ob oc">// call method when an invalid argument is supplied<br/>standardLogger.InvalidArg(“imgModel.ImageData”)</span></pre><h2 id="11e5" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated"><strong class="ak"> 4。集中Golang日志</strong></h2><p id="b893" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一些Go应用程序部署在一个主机集群上。</p><p id="a422" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当您需要检查/调查这些主机中的日志时，您将被迫SSH到其中的每一个主机。这无论如何都没有效率！</p><p id="a7e8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一个可扩展且高效的解决方案是将日志从本地文件传递到一个中央平台，然后您可以根据需要处理这些日志。</p><p id="57eb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有许多方法可以实现这一点；一种方法是使用<a class="ae ky" href="https://golang.org/pkg/log/syslog/" rel="noopener ugc nofollow" target="_blank"> Golang syslog包</a>将日志从整个基础设施转发到一个syslog服务器。另一种方法是使用日志管理解决方案。例如，Datadog和OpenTracing可以跟踪您的日志文件，并将日志转发到中央平台进行处理和分析。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="f6b0" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">摘要</h1><p id="3f7e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们学习了跟踪、监控和日志记录以及它们的各种用法。此外，我们深入探讨了日志记录，讨论了标准和第三方日志记录库。然后，我们研究了在Go应用程序中实现日志记录的最佳实践，并提供了代码示例。</p><p id="6498" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我真的希望你喜欢读这篇文章，就像我喜欢写它一样。整个代码库可以在<a class="ae ky" href="https://github.com/D-sense/logger-api-demo/blob/master/log/logger.go" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="f57e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们继续前进！</p></div></div>    
</body>
</html>