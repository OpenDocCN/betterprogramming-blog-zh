<html>
<head>
<title>Fixing Problems of Jetpack Compose Navigation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">修正了Jetpack组合导航的问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/realize-jetpack-compose-navigation-2889401f52b?source=collection_archive---------2-----------------------#2022-07-08">https://betterprogramming.pub/realize-jetpack-compose-navigation-2889401f52b?source=collection_archive---------2-----------------------#2022-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0018" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Jetpack Compose中导航的常见陷阱以及我们如何处理它们</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d7fdc332fae602c1196afc26874feb75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6hoJKWeGJxWgN0fwF3dh5w.jpeg"/></div></div></figure><p id="7454" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们团队已经在<a class="ae ln" href="https://play.google.com/store/apps/details?id=com.afterglow.client&amp;hl=en&amp;gl=US" rel="noopener ugc nofollow" target="_blank">余辉</a> app中使用Compose六个月了。在这篇文章中，我想分享我们所面临的困难，并提出我们所找到的解决方案。</p><h1 id="9155" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">Jetpack合成中的导航库</h1><p id="34a2" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我找到了3个最流行的导航解决方案:<a class="ae ln" href="https://developer.android.com/jetpack/compose/navigation" rel="noopener ugc nofollow" target="_blank"> Jetpack Compose Navigation </a>、<a class="ae ln" href="https://github.com/adrielcafe/voyager" rel="noopener ugc nofollow" target="_blank"> Voyager </a>、<a class="ae ln" href="https://github.com/arkivanov/Decompose" rel="noopener ugc nofollow" target="_blank"> Decompose </a>。</p><p id="4548" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我不会在这里详细比较每个解决方案。而且，没有一个是最好的，唯一正确的。我宁愿告诉你哪个库更适合你的项目。</p><ul class=""><li id="91fd" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">voyager——一个非常方便简单的库。伟大的<strong class="kt ir">小</strong>和<strong class="kt ir">宠物项目</strong>。它也适合于你准备承担以下风险的更严重的项目:<em class="mu">没有对iOS导航的支持，库支持弱，有应用崩溃的问题</em>。</li><li id="07be" class="ml mm iq kt b ku mv kx mw la mx le my li mz lm mq mr ms mt bi translated">分解——是唯一一个提供成熟的<strong class="kt ir">多平台导航</strong>的流行库。一个好的<strong class="kt ir">稳定解决方案</strong>，有作者的<strong class="kt ir">优秀支持。如果你已经使用了Arkadii Ivanov 的</strong><a class="ae ln" href="https://github.com/arkivanov/MVIKotlin" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">MVIKotlin</strong></a><strong class="kt ir">库</strong>，那么它将很好地融入你的项目。但是很多人<em class="mu">注意到，一开始</em>很难理解库的用法。如果您承诺在您的项目中使用该库，请准备好花几个工作日来实现它。如果你有一个很大的团队，你还必须编写简化的导航文档，并准备LiveTemplates来去掉大量的模板代码。</li><li id="1319" class="ml mm iq kt b ku mv kx mw la mx le my li mz lm mq mr ms mt bi translated">Jetpack Compose Navigation — <strong class="kt ir">大多数项目的可靠库</strong>。如果上面描述的解决方案不适合你，请随意使用谷歌的导航库。我对这个库非常怀疑，知道XML世界中Jetpack导航的问题。然而，这个图书馆被证明是非常好的。不存在关键问题。很容易在任何项目中实现它，并实现任何级别的导航复杂性。Jetpack导航不会阻止编写KMM应用程序的能力，因为导航本身发生在框架级(视图层)。</li></ul><p id="ae1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们选择了Jetpack Navigation，因为它最适合我们的项目，并且风险最小。我注意到Voyager也可以适用于许多项目，但作为一家初创公司，我们不敢带一个库，它有许多潜在的问题，在<a class="ae ln" href="https://github.com/adrielcafe/voyager/issues" rel="noopener ugc nofollow" target="_blank"> GitHub问题</a>中有描述</p><h1 id="cf40" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">动画片</h1><p id="6f4a" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在将Jetpack导航嵌入到应用程序中之后，您会发现您将无法配置开箱即用的动画。</p><p id="3317" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">谷歌的Jetpack导航中的动画还处于实验阶段。对于这样的实验，Google在Compose下有一个单独的扩展集合，叫做伴奏者。</p><p id="a923" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<a class="ae ln" href="https://google.github.io/accompanist/navigation-animation/" rel="noopener ugc nofollow" target="_blank">伴奏导航动画</a>的帮助下，你可以在10分钟内设置好作曲风格下的任何屏幕间转换动画。</p><h1 id="166d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">在淡入淡出动画中消除闪烁的屏幕</h1><p id="6449" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">如果活动窗口的背景不同于合成屏幕的背景，那么在添加过渡动画后，您会注意到屏幕在过渡期间似乎在闪烁。这是因为Compose不会将一个屏幕覆盖在另一个屏幕上，就像在活动之间导航或在Android片段之间导航时执行“添加”事务一样。Compose先播放破坏屏幕的动画，之后马上播放创建新屏幕的动画。如果您添加了淡入淡出动画，那么在过渡中间的某个地方，您会注意到活动窗口的背景，它不同于合成屏幕的背景。</p><p id="9dfb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">修复这种闪烁很简单:从编写屏幕中移除背景，并将其添加为活动窗口的背景。如果您在每个屏幕上使用自己的背景，那么在用户切换到的屏幕的合成动画结束时，将背景设置为当前屏幕的活动窗口。</p><p id="7fab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从<em class="mu">活动</em>中，您可以通过以下方式更改<em class="mu">活动窗口</em>背景:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="fee0" class="nh lp iq nd b gy ni nj l nk nl"><em class="mu">window</em>.setBackgroundDrawable(BitmapDrawable)</span></pre><p id="34f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以从撰写更改<em class="mu">活动窗口</em>的背景:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="64ae" class="nh lp iq nd b gy ni nj l nk nl"><em class="mu">val activity = LocalContext.current as Activity<br/>LaunchedEffect(activity) {<br/>    activity.window</em>.setBackgroundDrawable(BitmapDrawable)<br/>}</span></pre><h2 id="8b8e" class="nh lp iq bd lq nm nn dn lu no np dp ly la nq nr ma le ns nt mc li nu nv me nw bi translated">多活动中的内存泄漏</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/258c6bc05e532f7214d2ecba533c02d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0IEFmJIQZpBFArQ0"/></div></div></figure><p id="67ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2018年，<a class="na nb ep" href="https://medium.com/u/dbdc1597ce6b?source=post_page-----2889401f52b--------------------------------" rel="noopener" target="_blank"> Konstantin Tskhovrebov </a>写了一篇知名的<a class="ae ln" href="https://habr.com/ru/company/redmadrobot/blog/426617/" rel="noopener ugc nofollow" target="_blank">文章</a>关于使用单一活动方法的便利性。许多程序员对此持否定态度，仍然没有转换到这种方法，没有看到它的优势。</p><p id="c1a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我喜欢使用单个活动，但是对于余辉导航，我们决定在独立模块中的多个活动之间导航。我们假设活动间导航方法是健壮的，并且已经在数千个项目中测试过。</p><p id="902e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不会有什么不好的事情发生(我们是这么想的，直到我们把LeakCanary连接到这个项目上)！结果是，当活动配置被重新创建时，整个合成图正在泄漏。对活动的引用由重组器(composer的内部关键实体之一)持有。</p><p id="675c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们向Android社区寻求答案，但没有收到任何解决方案。后来，我们发现了一条<a class="ae ln" href="https://twitter.com/Piwai/status/1522693187877281794?t=izeD4-TvpX9LApsJh1L-4Q&amp;s=19" rel="noopener ugc nofollow" target="_blank">有趣的推文</a>，其中我们不是唯一指责Compose内存泄漏的人。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/c32d2afe0af2fad3edc1be5cb6b0b3e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ls-ACzHU_zjLiSuPNmmaZg.png"/></div></div></figure><p id="f83b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过实验，我们发现当应用程序中同时存在多个活动时，Compose中会出现内存泄漏问题。我们完全切换到单活动方法，并且永远忘记了内存泄漏。</p><p id="9bd2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">顺便说一下，在使用Compose的片段之间导航时，内存泄漏也是可能的。但是，在这种情况下，可以通过在ComposeView中更改从内存中清除合成的策略来修复内存泄漏:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="8bad" class="nh lp iq nd b gy ni nj l nk nl">setViewCompositionStrategy(<br/>    DisposeOnLifecycleDestroyed(viewLifecycleOwner)<br/>)</span></pre><h2 id="9082" class="nh lp iq bd lq nm nn dn lu no np dp ly la nq nr ma le ns nt mc li nu nv me nw bi translated">在有限的屏幕流内共享视图模型</h2><p id="8678" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">假设我们在某种通用的应用程序导航中嵌入了导航。在这个导航中，我们有几个屏幕应该有一个通用的<code class="fe nz oa ob nd b">SharedViewModel</code>。StackOverflow上也有几个类似的问题，但是最后我们都没有找到真正合适的答案。StackOverflow的答案不适合我们的原因是:</p><ul class=""><li id="a012" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">ViewModel不观察组合函数的生命周期，并且在必要时不会被清除</li><li id="ae1f" class="ml mm iq kt b ku mv kx mw la mx le my li mz lm mq mr ms mt bi translated">将无法在嵌套导航中嵌入<code class="fe nz oa ob nd b">SharedViewModel</code>。例如，您不能创建像FlowScreen这样的合成函数，并在其中放置嵌套导航。Jetpack导航不允许你这么做。</li><li id="de00" class="ml mm iq kt b ku mv kx mw la mx le my li mz lm mq mr ms mt bi translated">很难从一个组合函数中获得<code class="fe nz oa ob nd b">SharedViewModel</code>的实例。访问ViewModel需要编写大量非显而易见的代码。</li></ul><p id="ef71" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们以不同的方式解决了这个问题。我们在导航之外创建了一个<code class="fe nz oa ob nd b">SharedViewModelHolder</code>,它保存了一个到ViewModel的链接。</p><p id="10eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">添加了扩展函数来创建一个新的视图模型并获取一个现有的视图模型。结果，我们得到了一个非常简单且可重用的代码来使用<code class="fe nz oa ob nd b">SharedViewModel</code>。此外，我们没有将自己嵌入到Compose行为中，Compose行为在Compose函数的框架内为我们正确地处理了ViewModel生命周期。同时，导航图清楚地显示了ViewModel将在哪里被创建和销毁。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="oe of gj gh gi og oh bd b be z dk translated">嵌套导航图</p></figure><p id="3082" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">GitHub Gist:<a class="ae ln" href="https://gist.github.com/VitalyPeryatin/c0ec7841b8c5f0098dc3aa64532beb33" rel="noopener ugc nofollow" target="_blank">sharedviewmodelholder . kt</a></p><h2 id="edea" class="nh lp iq bd lq nm nn dn lu no np dp ly la nq nr ma le ns nt mc li nu nv me nw bi translated">打开筛链</h2><p id="9536" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">通常在应用程序中，你必须为一些事件打开一个屏幕链。例如，当您点击一个通知时，您需要打开以下屏幕链:主屏幕、聊天列表和消息来自的特定聊天的屏幕。在组合导航中没有单独机制允许单个事务打开屏幕链，因此我们将使用单独的事务打开每个屏幕。</p><p id="3091" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请记住，单个活动在撰写中是受欢迎的。这种方法在这里也会给我们很大帮助。我们有<code class="fe nz oa ob nd b">AppActivity</code>——这个应用程序的主要和唯一的活动。它有一个到<code class="fe nz oa ob nd b">AppViewModel</code>的链接，里面有一个通道(来自Kotlin Coroutines ),有一个要打开的屏幕列表。<code class="fe nz oa ob nd b">AppActivity</code>订阅该频道，并在收到新的屏幕列表(链)时，通过<code class="fe nz oa ob nd b">navigate()</code>方法循环切换到每个屏幕。如果有人需要打开一个新的屏幕链，那么你需要切换到的新屏幕(路线)列表通过<code class="fe nz oa ob nd b">Intent</code>传送到<code class="fe nz oa ob nd b">AppActivity</code>。</p></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><p id="cf04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将展示代码中的关键点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="984f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">GitHub要诀:<a class="ae ln" href="https://gist.github.com/VitalyPeryatin/5cdb138d01b4ad11442307099e9202a5" rel="noopener ugc nofollow" target="_blank">开屏链代码片段</a></p><p id="adfa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Jetpack导航推荐<a class="ae ln" href="https://developer.android.com/jetpack/compose/navigation#nav-with-args" rel="noopener ugc nofollow" target="_blank">通过路线传递参数</a>。这是一种非常优雅的数据传输方式。<em class="mu">路线</em>显示用户传递到下一个屏幕的内容。很容易记录。在进程死亡后，在引擎盖下合成恢复参数。</p><p id="c079" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是有一个问题:不能在Compose导航中传递复杂的对象。一方面，引用数据类型不能被持久化，因此它们在进程死亡后仍然存在(除非它们已经被预先序列化)。</p><p id="5597" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一方面，Android开发者已经习惯于使用<code class="fe nz oa ob nd b">Serializable</code>和<code class="fe nz oa ob nd b">Parcelable</code>类型在屏幕之间传递复杂的数据。然而，即使是这些也不能在Compose中传递。</p><p id="3183" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有对<code class="fe nz oa ob nd b">NavType.ParcelableType</code>的支持，但事实上，如果不自定义序列化成字符串，通过它传输数据是不可能的。这个问题在StackOverflow上被问了很多次:<a class="ae ln" href="https://stackoverflow.com/questions/65610003/pass-parcelable-argument-with-compose-navigation" rel="noopener ugc nofollow" target="_blank">这里</a>，这里<a class="ae ln" href="https://stackoverflow.com/questions/69059149/how-pass-parcelable-argument-with-new-version-of-compose-navigation" rel="noopener ugc nofollow" target="_blank">这里</a>。但是撰写导航的创造者仍然<a class="ae ln" href="https://developer.android.com/guide/navigation/navigation-pass-data#supported_argument_types" rel="noopener ugc nofollow" target="_blank">自信</a>在屏幕之间传输复杂的数据是不可能的。</p><blockquote class="op oq or"><p id="818d" class="kr ks mu kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated">注意:通过参数传递复杂的数据结构被认为是一种反模式。每个目的地应该负责根据最少的必要信息(如项目id)加载UI数据。这简化了流程再造，避免了潜在的数据不一致。</p></blockquote><p id="e5c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但我不这么认为，我完全赞同<a class="ae ln" href="https://t.me/android_declarative/44297" rel="noopener ugc nofollow" target="_blank">的立场</a> <a class="na nb ep" href="https://medium.com/u/ca9741bc2980?source=post_page-----2889401f52b--------------------------------" rel="noopener" target="_blank">阿尔卡季·伊万诺夫</a>:</p><blockquote class="op oq or"><p id="a440" class="kr ks mu kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated">…，<primitive id="" as="" string="" or="" number="">并不总是足够的，Parcelable非常有用。例如，对于用户的屏幕，除了其标识符之外，可能还需要关于打开该屏幕的上下文的信息。如果这是我个人资料中的朋友，或者是搜索屏幕中的用户，或者是其他地方的用户。可能需要以不同的方式显示它们。查询的关键字可以是一组参数。在这种情况下，通常使用不同的组合来创建一个密封类可能是有意义的。而且是的，如果设计改变了，那么改变这个类就足够了，所有使用的地方都会停止编译。但是如果标识符类型变成了字符串而不是数字，那么在运行时一切都会崩溃。如果你知道怎么做，有了深度链接，一切都很好。</primitive></p></blockquote></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><p id="e024" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">顺便说一下，我们将准确地保存<code class="fe nz oa ob nd b">Parcelable</code>，而不是<code class="fe nz oa ob nd b">Serializable</code>或任何其他引用数据类型，因为<code class="fe nz oa ob nd b">Parcelable</code>是在Android中序列化数据的最佳方式:它易于创建，并且可以快速序列化为一种相当紧凑的形式。</p><p id="7f24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">互联网上有很多在屏幕间转移<code class="fe nz oa ob nd b">Parcelable</code>的方法，但它们都归结为三种:</p><p id="24b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">1)在先前的后堆栈中保持可打包:</p><p id="64df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在当前屏幕上…</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="c34b" class="nh lp iq nd b gy ni nj l nk nl">navController.currentBackStackEntry?.arguments = Bundle().apply {<br/>    putParcelable("article", article)<br/>}<br/>navController.navigate("article")</span></pre><p id="89c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下一个屏幕上…</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="7cef" class="nh lp iq nd b gy ni nj l nk nl">val article = navController.previousBackStackEntry?.arguments<br/>    ?.getParcelable&lt;Article&gt;("article")</span></pre><blockquote class="op oq or"><p id="e0c9" class="kr ks mu kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated">缺点:当通过popBackStack()关闭上一个屏幕时，下一个屏幕的数据将会丢失</p></blockquote><p id="1d48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2)通过束传递数据，忽略屏幕路由:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="e6c6" class="nh lp iq nd b gy ni nj l nk nl">fun NavController.navigate(<br/>    route: String,<br/>    args: Bundle,<br/>    navOptions: NavOptions? = null,<br/>    navigatorExtras: Navigator.Extras? = null<br/>) {<br/>    val routeLink = NavDeepLinkRequest<br/>        .Builder<br/>        .fromUri(NavDestination.createRoute(route).toUri())<br/>        .build()</span><span id="ca5d" class="nh lp iq nd b gy ov nj l nk nl">    val deepLinkMatch = graph.matchDeepLink(routeLink)<br/>    if (deepLinkMatch != null) {<br/>        val destination = deepLinkMatch.destination<br/>        val id = destination.id<br/>        navigate(id, args, navOptions, navigatorExtras)<br/>    } else {<br/>        navigate(route, navOptions, navigatorExtras)<br/>    }<br/>}</span></pre><blockquote class="op oq or"><p id="9429" class="kr ks mu kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated">缺点:<br/> 1。不可能像在Compose中习惯的那样继续通过路由传输简单的数据(日志导航会有困难)。<br/> 2。这种方式是不可靠的，因为我们使用的方法仅用于导航库的内部目的。它们可以随时关闭。</p></blockquote><p id="f217" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3)从外部或内部将数据序列化为route内部的字符串NavType:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="9bcd" class="nh lp iq nd b gy ni nj l nk nl">class AssetParamType : NavType&lt;Device&gt;(isNullableAllowed = false) {</span><span id="08a2" class="nh lp iq nd b gy ov nj l nk nl">override fun get(bundle: Bundle, key: String): Device? {<br/>        return bundle.getParcelable(key)<br/>    }</span><span id="0885" class="nh lp iq nd b gy ov nj l nk nl">    override fun parseValue(value: String): Device {<br/>        return Gson().fromJson(value, Device::class.java)<br/>    }</span><span id="0768" class="nh lp iq nd b gy ov nj l nk nl">    override fun put(bundle: Bundle, key: String, value: Device) {<br/>        bundle.putParcelable(key, value)<br/>    }<br/>}</span></pre><blockquote class="op oq or"><p id="fade" class="kr ks mu kt b ku kv jr kw kx ky ju kz os lb lc ld ot lf lg lh ou lj lk ll lm ij bi translated">缺点:<br/> 1。我不得不写很多额外的代码<br/> 2。序列化和反序列化需要大量时间，并且会明显影响肉眼合成的渲染速度</p></blockquote></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><p id="9da9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在研究了上面描述的所有方法后，我们意识到没有一个适合我们，并决定提出我们自己的解决方案，它既快速有效，又不违背图书馆的原则。</p><p id="1705" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们不去探究实现导航包装器的细节，那么原理是基于在<code class="fe nz oa ob nd b">HashMap&lt;String, Parcelable&gt;</code>类型的<code class="fe nz oa ob nd b">parcelableArguments</code>中存储数据。</p><p id="81e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当在下一个屏幕上接收数据时，我们必须将<code class="fe nz oa ob nd b"><em class="mu">parcelableArguments</em></code>包装在<code class="fe nz oa ob nd b">rememberSaveable{}</code>中，这样<em class="mu">可打包的</em>参数可以在进程死亡后继续存在。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="c18f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以点击GitHub Gist下面的链接，了解更多关于我们的方法。在那里，我试图列出最重要的代码片段来解决传递可打包对象的问题。</p><p id="396d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">GitHub Gist: <a class="ae ln" href="https://gist.github.com/VitalyPeryatin/e31385e59f4670a3977d009f0d712c7f" rel="noopener ugc nofollow" target="_blank">传递parcelable参数</a></p><h1 id="257b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="bee6" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们已经讨论了在Compose中实现导航时可能遇到的主要问题。我们找到了任何人都可以轻松集成到他们的项目中的解决方案。我们希望现在您使用Compose会少受些苦，多些乐趣！</p><p id="791c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们一起让这篇文章对我们大家更有用。写出你将如何解决文章中描述的问题。我希望得到您的反馈！</p></div></div>    
</body>
</html>