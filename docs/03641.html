<html>
<head>
<title>How to Write Recursion in 3 Steps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用3个步骤编写递归</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-recursion-in-3-steps-9d512189a94e?source=collection_archive---------15-----------------------#2020-02-24">https://betterprogramming.pub/how-to-write-recursion-in-3-steps-9d512189a94e?source=collection_archive---------15-----------------------#2020-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7bda" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中的分步示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9c782d46a24af0ee03521f3ca2daf285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DkqKp4GCtf_FHrSX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@eddietsy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Eddie Tsy </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="e4f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归函数反复调用自己，直到满足某个暂停条件。</p><p id="45d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这太可怕了。一个函数调用它自己是非常危险的，因为它相对来说不太直观，如果我们不小心对待它，可能会遇到一些运行时错误。我以前觉得这很吓人，但是我可以制定一个三步方法，让你有足够的信心编写自己的无错误递归函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="127c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">例子</h1><p id="cb43" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们以一个阶乘函数为例。我将使用Python来演示它，但是同样的逻辑也适用于其他语言。</p><h2 id="852c" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">1.递归情况——流程</h2><p id="022f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我们需要确定递归情况，这就是如何使用阶乘函数定义阶乘函数。我们知道一个事实:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="4af9" class="mz md it nm b gy nq nr l ns nt">n! = n × (n-1) × (n-2) × ... × 3 × 2 × 1</span></pre><p id="f0e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以用递归方式重写，其中阶乘函数应用于左侧和右侧:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="920b" class="mz md it nm b gy nq nr l ns nt">n! = n × (n-1)!</span></pre><p id="dcc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以用Python来表达:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="ece9" class="mz md it nm b gy nq nr l ns nt">def factorial(n):<br/>    return n * factorial(n-1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/a0bc9ed47391aeecc9635bf55985a083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7JC45g7-jZiPvhc2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@tine999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tine ivani</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f4c8" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">2.基本情况—停止标准</h2><p id="f144" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">但是上面的代码有一个bug。考虑一下<code class="fe nv nw nx nm b">factorial(2)</code>，它调用<code class="fe nv nw nx nm b">factorial(1)</code>，它调用<code class="fe nv nw nx nm b">factorial(0)</code>等等。函数不停地调用自己，这是有问题的。因此，我们需要递归函数的一个基本情况，在这个情况下它停止调用自己。</p><p id="43c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">0和1的阶乘定义为<code class="fe nv nw nx nm b">0! = 1! = 1</code>。这些是我们的基本案例，我们可以将它们硬编码到我们的函数中。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="7ea0" class="mz md it nm b gy nq nr l ns nt">def factorial(n):<br/>    if n in [0,1]:<br/>        return 1<br/>    else:<br/>        return n * factorial(n-1)</span></pre><p id="e6ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归函数在遇到<code class="fe nv nw nx nm b">factorial(1)</code>时停止调用自己。所以调用<code class="fe nv nw nx nm b">factorial(2)</code>返回<code class="fe nv nw nx nm b">2 * factorial(1)</code>，T6返回<code class="fe nv nw nx nm b">2 * 1 = 2</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="2245" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">3.非故意案例—限制</h2><p id="77a7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">编写递归函数时，要考虑的最重要的事情是确保函数为每个可能的参数<code class="fe nv nw nx nm b">n</code>停止。我们确定我们的函数不会永远运行下去吗？</p><p id="924b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx nm b">factorial(-1)</code>怎么样？那<code class="fe nv nw nx nm b">factorial(1.5)</code>呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/f89d77612726b2c2ca2ececec7af3b05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h2s7RJ0x5OwpF_H4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@emmapaillex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Emma Paillex </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="7abe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有<code class="fe nv nw nx nm b">n = 0</code>和<code class="fe nv nw nx nm b">n = 1</code>的基本情况，我们的递归情况用一个参数<code class="fe nv nw nx nm b">n-1</code>调用函数本身。这意味着，只有当<code class="fe nv nw nx nm b">factorial(n)</code>以非负整数<code class="fe nv nw nx nm b">n</code>开始时，函数才会到达基本情况。</p><p id="5dd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<code class="fe nv nw nx nm b">factorial(-1)</code>调用<code class="fe nv nw nx nm b">factorial(-2)</code>，T6调用<code class="fe nv nw nx nm b">factorial(-3)</code>，我们永远无法到达基本案例。非整数<code class="fe nv nw nx nm b">n</code>也一样。</p><p id="9c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们防止这种情况发生。虽然有许多不同的方法来实现这一点，但我们将使用Python中的一个简单断言方法，如果<code class="fe nv nw nx nm b">n</code>不是非负整数，该方法将抛出一个错误。换句话说，我们强制参数<code class="fe nv nw nx nm b">n</code>为非负整数<code class="fe nv nw nx nm b">n &gt;= 0 and int(n) == n</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9799" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">另一个例子</h1><p id="2374" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">另一个非常常见的例子是斐波那契数的计算。它由以下递归和基本情况定义:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="f357" class="mz md it nm b gy nq nr l ns nt"># recursive case<br/>fibo(n) = fibo(n-1) + fibo(n-2)</span><span id="422d" class="mz md it nm b gy ob nr l ns nt"># base cases<br/>fibo(0) = 0<br/>fibo(1) = 1</span></pre><p id="18ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，由于<code class="fe nv nw nx nm b">fibo(n)</code>同时调用了<code class="fe nv nw nx nm b">fibo(n-1)</code>和<code class="fe nv nw nx nm b">fibo(n-2)</code>，因此这两种基本情况都需要在函数中进行编码，以避免运行时错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="181d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，约束<code class="fe nv nw nx nm b">n</code>以避免无意中使用递归函数。简单。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/f3b317f7aa70a6cf71e4cb66983d7454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*19GxcfpQ0LE7i48Q"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@austindistel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Austin Distel </a>拍摄的照片。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="58cf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">警告</h1><p id="8479" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用递归可以使你的代码简洁优雅，因为一个复杂的计算被分解成许多简单的子问题。但是，递归可能计算量很大，并且需要大量内存。</p><p id="a702" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，递归斐波那契数函数是一种非常低效的计算方法。想想<code class="fe nv nw nx nm b">fibo(5)</code>:它调用<code class="fe nv nw nx nm b">fibo(3)</code>和<code class="fe nv nw nx nm b">fibo(4)</code>。前者称为<code class="fe nv nw nx nm b">fibo(1)</code>和<code class="fe nv nw nx nm b">fibo(2)</code>，后者称为<code class="fe nv nw nx nm b">fibo(2)</code>和<code class="fe nv nw nx nm b">fibo(3)</code>。注意<code class="fe nv nw nx nm b">fibo(2)</code>和<code class="fe nv nw nx nm b">fibo(3)</code>不必要运行多次。</p><p id="c911" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于更大的<code class="fe nv nw nx nm b">n</code>，这个问题变得更加严重。下面可以找到一种更有效的方法来计算斐波纳契数。显而易见，递归更加优雅(尽管有时可读性较差)和紧凑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9576" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">外卖食品</h1><ul class=""><li id="f5f3" class="od oe it lb b lc mu lf mv li of lm og lq oh lu oi oj ok ol bi translated">递归的情况是函数的流程。</li><li id="ef0b" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">基本情况是停止流程的停止<strong class="lb iu"> </strong>标准。</li><li id="d4fc" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">无意的情况可能会导致运行时错误，应该通过限制参数的范围来处理。</li><li id="37d6" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">当心递归函数的内存消耗。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/35ade2f2824842ebb11f92b9644a4319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gjPs_95BGTI8g7Od"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@priscilladupreez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">普里西拉·杜·普里兹</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="45eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！如果您对提高Python技能感兴趣，以下文章可能会有所帮助:</p><div class="or os gp gr ot ou"><a href="https://medium.com/better-programming/stop-abusing-args-and-kwargs-in-python-560ce6645e14" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">停止在Python中滥用*args和**kwargs</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">他们会回来缠着你</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">medium.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div><div class="or os gp gr ot ou"><a href="https://towardsdatascience.com/4-hidden-python-features-that-beginners-should-know-ec9de65ff9f8" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">初学者应该知道的4个隐藏的Python特性</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">如何轻松增强您的Python代码</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pj l pf pg ph pd pi ks ou"/></div></div></a></div><div class="or os gp gr ot ou"><a href="https://towardsdatascience.com/5-python-features-i-wish-i-had-known-earlier-bc16e4a13bf4" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">我希望我能早点知道的5个Python特性</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">超越lambda、map和filter的Python技巧</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pk l pf pg ph pd pi ks ou"/></div></div></a></div></div></div>    
</body>
</html>