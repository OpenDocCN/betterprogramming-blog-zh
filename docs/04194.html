<html>
<head>
<title>Drawing in a UIView</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在UIView中绘图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/drawing-in-an-uiview-4bc754483242?source=collection_archive---------4-----------------------#2020-03-29">https://betterprogramming.pub/drawing-in-an-uiview-4bc754483242?source=collection_archive---------4-----------------------#2020-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b84a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何用手指绘画并导出图像</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ba98c9fbb0a21bb0fd0e78f6f390416d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eCdrF1i5jsm4B9m9X3STKQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1445053" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/ponce_photography-2473530/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1445053" rel="noopener ugc nofollow" target="_blank"> Aline Ponce </a>拍摄</p></figure><p id="b646" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇短文中，我们将探索如何在我们的应用程序中添加一个视图，用户可以用手指在其中绘图。</p><p id="f8e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个绘图是非常容易的。首先，我们将看到如何获得触摸和跟踪运动的位置。下一步是在<code class="fe lv lw lx ly b">CGContext</code>中连接这些点，得到我们的图。最后，我们将看到如何将创建的绘图重置并导出为<code class="fe lv lw lx ly b">UIImage</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="be94" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">获取触摸位置</strong></h1><p id="6c1b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们从跟踪视图内部的触摸开始。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6d0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —首先，我们创建一个可重用的<code class="fe lv lw lx ly b">UIView</code>子类来包装绘图功能。在这个类中，我们有一个包含<code class="fe lv lw lx ly b">CGPoint</code>的数组。外部数组表示线，其中每条线由多个点组成。</p><p id="533d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code> —由于这个类是<code class="fe lv lw lx ly b">UIView</code>的子类，我们可以覆盖方法<code class="fe lv lw lx ly b">touchesBegan(_:with:)</code>和<code class="fe lv lw lx ly b">touchesMoved(_:with:)</code>，这允许我们获得触摸的位置。这些方法可以访问一组触摸，从中我们可以获得第一个触摸点，并将其转换到该视图的坐标系中。</p><p id="10a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 3</code> —现在我们有了自己的观点，我们需要将它添加到<code class="fe lv lw lx ly b">lineArray</code>。因为<code class="fe lv lw lx ly b">touchesBegan</code>标志着一个新行的开始，我们首先向它添加一个空数组<code class="fe lv lw lx ly b">CGPoint</code>。接下来，我们将第一个点添加到这条新线上。</p><p id="8ec6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 4</code> —以下所有点将在<code class="fe lv lw lx ly b">touchesMoved</code>中被跟踪。就像之前一样，我们访问当前点并将其添加到数组中。最后，通过调用<code class="fe lv lw lx ly b">setNeedsDisplay()</code>，我们触发了视图的重绘。</p><p id="5a28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在下一个方法中看到如何画出我们的点。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4fbe" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">划清界限</h1><p id="22b8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">下一步是画出我们的观点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f002" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —为了绘制点，我们需要覆盖方法<code class="fe lv lw lx ly b">draw(_:)</code>。在这里，我们通过调用<code class="fe lv lw lx ly b">UIGraphicsGetCurrentContext()</code>来访问当前的<code class="fe lv lw lx ly b">CGContext</code>。这样的上下文定义了一个绘图目的地，并保存了一个参数来呈现给定的点，比如颜色和线宽。</p><p id="86ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该上下文将被传递给另一个方法，该方法将进行实际的绘制。一旦我们看到如何将图形导出到<code class="fe lv lw lx ly b">UIImage</code>，我们为什么使用单独的方法就清楚了。</p><p id="2ca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code> —在<code class="fe lv lw lx ly b">draw(inContext:)</code>中，我们从配置给定的上下文开始。我们将它的线宽设置为5，颜色设置为黑色，通过将线帽设置为<code class="fe lv lw lx ly b">.round</code>来使线的两端变圆。当然，你可以使用任何你喜欢的配置！</p><p id="aa8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 3</code> —接下来，我们开始实际绘制上下文。为了做到这一点，我们迭代了线的数组。</p><p id="fa2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 4</code> —对于每一行，我们获取第一个点，并通过调用<code class="fe lv lw lx ly b">context.move(to:)</code>将这个点设置为我们的起点。</p><p id="b38a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 5</code> —现在我们用<code class="fe lv lw lx ly b">context.addLine(to:)</code>给后面的每个点加一条线，用<code class="fe lv lw lx ly b">context.strokePath()</code>画线。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2f52" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">重置和导出图形</h1><p id="5da4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最后，让我们看看如何清除绘图或将其导出为图像。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 1</code> —删除图纸就像重置我们的<code class="fe lv lw lx ly b">lineArray</code>并调用<code class="fe lv lw lx ly b">setNeedsDisplay</code>一样简单。这将触发我们的点的一个新的渲染，但是因为没有更多的了，视图将是空的。</p><p id="a1e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 2</code> —要导出我们的绘图，首先，我们需要创建一个与视图本身大小相同的新<code class="fe lv lw lx ly b">UIGraphicsBeginImageContext</code>。这也将把当前上下文设置为新创建的上下文，我们通过调用<code class="fe lv lw lx ly b">UIGraphicsGetCurrentContext</code>来访问它。</p><p id="a297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以重用我们的<code class="fe lv lw lx ly b">draw(inContext:)</code>方法，但是这一次，我们传入新创建的图像上下文。</p><p id="04a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">// 4</code> —最后，我们通过调用<code class="fe lv lw lx ly b">UIGraphicsGetImageFromCurrentImageContext()</code>获得图像，这将使用我们的绘图创建一个<code class="fe lv lw lx ly b">UIImage</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b6eb" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">后续步骤</h1><p id="42a6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我们已经有了一个基本的视图，您可以继续通过添加颜色或使线条可配置来扩展它。</p><p id="32b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个由罗恩·克利弗在<a class="ae ky" href="https://www.raywenderlich.com" rel="noopener ugc nofollow" target="_blank">raywenderlich.com</a>做的<a class="ae ky" href="https://www.raywenderlich.com/5895-uikit-drawing-tutorial-how-to-make-a-simple-drawing-app" rel="noopener ugc nofollow" target="_blank">很棒的教程</a>，他不仅增加了这些功能，还展示了使用多个<code class="fe lv lw lx ly b">UIImageViews</code>的另一种绘图方式。</p><div class="nf ng gp gr nh ni"><a href="https://www.raywenderlich.com/5895-uikit-drawing-tutorial-how-to-make-a-simple-drawing-app" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd iu gy z fp nn fr fs no fu fw is bi translated">UIKit画图教程:如何制作简单的画图App</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">了解如何使用UIKit绘图API在Swift中创建简单的绘图应用程序。版本Swift 4.2，iOS 12，Xcode 10更新…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">www.raywenderlich.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw ks ni"/></div></div></a></div></div></div>    
</body>
</html>