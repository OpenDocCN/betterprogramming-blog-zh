<html>
<head>
<title>Using the Destructuring Assignment Syntax in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中使用析构赋值语法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-the-destructuring-assignment-syntax-in-javascript-8ca8af6a0397?source=collection_archive---------4-----------------------#2019-10-26">https://betterprogramming.pub/using-the-destructuring-assignment-syntax-in-javascript-8ca8af6a0397?source=collection_archive---------4-----------------------#2019-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="053b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">清理代码库的语法糖</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d7d023e859c1d6c3cc42f756b6542848.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BaGGc-O9YmbdN4as"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@tracycodes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tracy Adams </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">析构赋值语法是2015版JavaScript中引入的JavaScript语法功能，它允许我们将数组的值列表或对象的键值对解包到单个变量中。</p><p id="bdf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于从数组或对象中检索条目并将它们设置为单个变量的值非常方便。这非常方便，因为另一种方法是从索引中获取一个数组条目，然后将它们设置为数组的变量值。</p><p id="c2a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于对象，我们从键中获取值，并将它们设置为变量值。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="81e5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数组析构</h1><p id="2d30" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以在代码中轻松使用析构赋值语法。对于数组，我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="41b7" class="ne md it na b gy nf ng l nh ni">const [a,b] = [1,2];</span></pre><p id="47d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们得到1作为<code class="fe nj nk nl na b">a</code>的值，2作为<code class="fe nj nk nl na b">b</code>的值，因为析构语法将数组的条目解包到单独的变量中。</p><p id="9003" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，数组中项的数量不一定等于变量的数量。例如，我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9332" class="ne md it na b gy nf ng l nh ni">const [a,b] = [1,2,3]</span></pre><p id="b22f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么<code class="fe nj nk nl na b">a</code>仍然是1，<code class="fe nj nk nl na b">b</code>仍然是2，因为语法只设置了变量，这些变量按照数组中数字出现的顺序排列。因此，1被设置为<code class="fe nj nk nl na b">a</code>，2被设置为<code class="fe nj nk nl na b">b</code>，3被忽略。</p><p id="03b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用rest操作符来获取没有被设置为变量的剩余变量。例如，我们可以有:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0251" class="ne md it na b gy nf ng l nh ni">const [a,b,...rest] = [1,2,3,4,5,6]</span></pre><p id="1c4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，<code class="fe nj nk nl na b">rest</code>将是<code class="fe nj nk nl na b">[3,4,5,6]</code>，而我们将<code class="fe nj nk nl na b">a</code>设置为1，将<code class="fe nj nk nl na b">b</code>设置为2。这让我们可以将剩余的数组条目放入一个变量中，而不用将它们都设置为自己的变量。</p><p id="f7e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以对对象使用析构赋值语法。例如，我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1ab7" class="ne md it na b gy nf ng l nh ni">const {a,b} = {a:1, b:2};</span></pre><p id="edc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，<code class="fe nj nk nl na b">a</code>被设置为1，<code class="fe nj nk nl na b">b</code>被设置为2，因为在给变量赋值时，键与变量的名称相匹配。</p><p id="7a49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们将<code class="fe nj nk nl na b">a</code>作为键，1作为相应的值，所以当键名与变量名匹配时，变量<code class="fe nj nk nl na b">a</code>被设置为1。<code class="fe nj nk nl na b">b</code>也是如此。我们有一个名为<code class="fe nj nk nl na b">b</code>的值为2的键，因为我们有一个名为<code class="fe nj nk nl na b">b</code>的变量，我们可以将<code class="fe nj nk nl na b">b</code>设置为2。</p><p id="1123" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在用析构赋值语法给变量赋值之前声明变量。例如，我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5d8e" class="ne md it na b gy nf ng l nh ni">let a, b;<br/>([a, b] = [1, 2]);</span></pre><p id="243a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将<code class="fe nj nk nl na b">a</code>设置为1，将<code class="fe nj nk nl na b">b</code>设置为2，因为声明的<code class="fe nj nk nl na b">a</code>和<code class="fe nj nk nl na b">b</code>与被赋值的相同。</p><p id="a755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要变量名相同，JavaScript解释器就足够聪明来完成赋值，不管它们是否事先声明。</p><p id="ffe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要行上的括号，这样赋值将被解释为一行，而不是中间有等号的单个块，因为同一行上的两个块不是有效的语法。</p><p id="ed45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有当变量声明发生在析构赋值之前时，才需要这样做。</p><p id="f045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以为析构赋值设置默认值。例如:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="218b" class="ne md it na b gy nf ng l nh ni">let a,b;<br/>([a=1,b=2] = [0])</span></pre><p id="c79e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是有效的语法。在上面的代码中，我们得到<code class="fe nj nk nl na b">a</code>是0，因为我们给它赋值了0。<code class="fe nj nk nl na b">b</code>是2，因为我们没有给它赋值。</p><p id="b0c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">析构赋值语法也可以用于交换变量，所以我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7367" class="ne md it na b gy nf ng l nh ni">let a = 1;<br/>let b = 2;<br/>([a,b] = [b,a])</span></pre><p id="dad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上述代码的最后一行之后，<code class="fe nj nk nl na b">b</code>将变为1，<code class="fe nj nk nl na b">a</code>将变为2。我们不再需要给临时变量赋值来交换它们，也不需要通过加减来给变量赋值。</p><p id="6096" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">析构赋值语法也适用于将函数的返回值赋给变量。</p><p id="49b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果一个函数返回一个数组或对象，我们可以用析构赋值语法把它们赋给变量。例如，如果我们有:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c25f" class="ne md it na b gy nf ng l nh ni">const fn = () =&gt;[1,2]</span></pre><p id="091a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="cb19" class="ne md it na b gy nf ng l nh ni">const [a,b] = fn();</span></pre><p id="fe4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用析构语法将1作为<code class="fe nj nk nl na b">a</code>获取，将2作为<code class="fe nj nk nl na b">b</code>获取，因为使用该语法将返回的数组赋给了变量。</p><p id="8ca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，对于对象，我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0062" class="ne md it na b gy nf ng l nh ni">const fn = () =&gt; {a:1, b:2}<br/>const {a,b} = fn();</span></pre><p id="96e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过跳过析构赋值中间的变量名来忽略中间的变量。例如，我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="61cc" class="ne md it na b gy nf ng l nh ni">const fn = () =&gt; [1,2,3];<br/>let [a,,b] = fn();</span></pre><p id="7884" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到值为1的<code class="fe nj nk nl na b">a</code>和值为3的<code class="fe nj nk nl na b">b</code>，跳过中间值。</p><p id="b69a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是要知道，如果我们使用带有析构赋值语法的rest操作符，我们不能在左边有尾随逗号，因此:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="454d" class="ne md it na b gy nf ng l nh ni">let [a, ...b,] = [1, 2, 3];</span></pre><p id="fd83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">会产生一个<code class="fe nj nk nl na b">SyntaxError</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9070" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">对象析构</h1><p id="a1a7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们也可以对对象使用析构赋值语法。例如，我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="68f7" class="ne md it na b gy nf ng l nh ni">const {a,b} = {a:1, b:2};</span></pre><p id="0196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，<code class="fe nj nk nl na b">a</code>被设置为1，<code class="fe nj nk nl na b">b</code>被设置为2，因为在给变量赋值时，键与变量的名称相匹配。</p><p id="d5f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们有<code class="fe nj nk nl na b">a</code>作为键，1作为相应的值，变量<code class="fe nj nk nl na b">a</code>被设置为1，因为键名与变量名匹配。<code class="fe nj nk nl na b">b</code>也是一样。我们有一个名为<code class="fe nj nk nl na b">b</code>的值为2的键，因为我们有一个名为<code class="fe nj nk nl na b">b</code>的变量，我们可以将<code class="fe nj nk nl na b">b</code>设置为2。</p><p id="aba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以将它分配给不同的变量名，这样我们就不必将键值条目设置为不同的变量名。我们只需在左侧对象的值部分添加我们想要的变量的名称，这就是我们想要为其赋值的变量，如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c279" class="ne md it na b gy nf ng l nh ni">const {a: foo, b: bar} = {a:1, b:2};</span></pre><p id="513d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们将键<code class="fe nj nk nl na b">a</code>的值赋给了<code class="fe nj nk nl na b">foo</code>，将键<code class="fe nj nk nl na b">b</code>的值赋给了变量<code class="fe nj nk nl na b">bar</code>。我们仍然需要<code class="fe nj nk nl na b">a</code>和<code class="fe nj nk nl na b">b</code>作为左边的键，这样它们就可以与右边的相同键名相匹配，用于析构赋值。</p><p id="3756" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<code class="fe nj nk nl na b">a</code>和<code class="fe nj nk nl na b">b</code>实际上并没有被定义为变量。它只是用来匹配右边的键-值对，以便它们可以被设置为变量<code class="fe nj nk nl na b">foo</code>和<code class="fe nj nk nl na b">bar</code>。</p><p id="38fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对象的析构赋值也可以有默认值。例如，我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0397" class="ne md it na b gy nf ng l nh ni">let {a = 1, b = 2} = {a: 3};</span></pre><p id="a0cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将<code class="fe nj nk nl na b">a</code>设置为3，将<code class="fe nj nk nl na b">b</code>设置为2，这是默认值，因为我们没有一个右侧带有名为<code class="fe nj nk nl na b">b</code>的键的键-值对。</p><p id="3633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用析构语法将值赋给与原始对象的键不同名称的变量，也可以提供默认值。所以，我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bdf9" class="ne md it na b gy nf ng l nh ni">const {a: foo=3, b: bar=4} = {a:1};</span></pre><p id="5a0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，<code class="fe nj nk nl na b">foo</code>将会是1，<code class="fe nj nk nl na b">bar</code>将会是4，因为我们为左边的条指定了默认值，但是用析构赋值将<code class="fe nj nk nl na b">foo</code>指定为1。</p><p id="03bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">析构赋值也适用于嵌套对象。例如，如果我们有以下对象:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="cf24" class="ne md it na b gy nf ng l nh ni">let user = {<br/>  id: 42,<br/>  userName: 'dsmith',<br/>  name: {<br/>    firstName: 'Dave',<br/>    lastName: 'Smith'<br/>  }<br/>};</span></pre><p id="b04a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="acad" class="ne md it na b gy nf ng l nh ni">let <!-- -->{<!-- -->userName<!-- -->, <!-- -->name<!-- -->: { firstName }} = <!-- -->user;</span></pre><p id="22a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe nj nk nl na b">displayName</code>设置为<code class="fe nj nk nl na b">'dsmith'</code>，将<code class="fe nj nk nl na b">firstName</code>设置为<code class="fe nj nk nl na b">'Dave'</code>。对整个对象进行查找，因此，如果左对象的结构与右对象的结构相同，并且键存在，那么析构赋值语法将起作用。</p><p id="d75e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用语法将值解包到单个变量中，同时将对象作为参数传入。</p><p id="edaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了做到这一点，我们把我们想要赋值的东西，也就是析构赋值表达式左边的东西，作为函数的参数。</p><p id="118a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果我们想把<code class="fe nj nk nl na b">user</code>作为变量分解成它的各个部分，我们可以写一个像下面这样的函数:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="61a2" class="ne md it na b gy nf ng l nh ni">const who = (<!-- -->{<!-- -->userName<!-- -->, <!-- -->name<!-- -->: { firstName }}) =&gt; `${<!-- -->userName<!-- -->}'s first name is ${firstName}<!-- -->;</span><span id="25a2" class="ne md it na b gy nm ng l nh ni">who(user)</span></pre><p id="b1ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们得到了<code class="fe nj nk nl na b">userName</code>和<code class="fe nj nk nl na b">firstName</code>，它们将被分别设置为<code class="fe nj nk nl na b">'dsmith'</code>和<code class="fe nj nk nl na b">'Dave'</code>，因为我们将析构赋值语法应用于<code class="fe nj nk nl na b">who</code>函数的参数，该函数是我们之前定义的<code class="fe nj nk nl na b">user</code>对象。</p><p id="a11c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们可以像在参数中析构一样设置默认参数，就像我们对正则赋值表达式所做的那样。所以，我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="006a" class="ne md it na b gy nf ng l nh ni">const who = (<!-- -->{<!-- -->userName = 'djones'<!-- -->, <!-- -->name<!-- -->: { firstName }}) =&gt; `${<!-- -->userName<!-- -->}'s first name is ${firstName}<!-- -->`</span></pre><p id="199c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将<code class="fe nj nk nl na b">user</code>设置为:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="05b8" class="ne md it na b gy nf ng l nh ni">let user = {<br/>  id: 42,<br/>  name: {<br/>    firstName: 'Dave',<br/>    lastName: 'Smith'<br/>  }<br/>};</span></pre><p id="5af9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后当我们调用<code class="fe nj nk nl na b">who(user)</code>时，我们得到<code class="fe nj nk nl na b">'djones's first name is Dave'</code>，因为我们将<code class="fe nj nk nl na b">'djones'</code>设置为<code class="fe nj nk nl na b">userName</code>的默认值。</p><p id="4196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们遍历可迭代对象时，我们可以使用析构赋值语法。例如，我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bd63" class="ne md it na b gy nf ng l nh ni">const people = [{<br/>    firstName: 'Dave',<br/>    lastName: 'Smith'<br/>  },<br/>  {<br/>    firstName: 'Jane',<br/>    lastName: 'Smith'<br/>  },<br/>  {<br/>    firstName: 'Don',<br/>    lastName: 'Smith'<br/>  },<br/>]</span><span id="e8e9" class="ne md it na b gy nm ng l nh ni">for (let {<br/>    firstName,<br/>    lastName<br/>  } of people) {<br/>  console.log(firstName, lastName);<br/>}</span></pre><p id="62ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e580" class="ne md it na b gy nf ng l nh ni">Dave Smith<br/>Jane Smith<br/>Don Smith</span></pre><p id="4bb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记录，因为析构语法在<code class="fe nj nk nl na b">for...of</code>循环中起作用，因为<code class="fe nj nk nl na b">let</code>之后的变量是数组的入口。</p><p id="f3ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算对象属性也可以在析构赋值表达式的左侧。所以，我们可以有这样的东西:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d94e" class="ne md it na b gy nf ng l nh ni">let key = 'a';<br/>let {[key]: bar} = {a: 1};</span></pre><p id="b6a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会将<code class="fe nj nk nl na b">bar</code>设置为1，因为<code class="fe nj nk nl na b">[key]</code>被设置为<code class="fe nj nk nl na b">a</code>，然后JavaScript解释器可以匹配两边的键，并对变量<code class="fe nj nk nl na b">bar</code>进行析构赋值。</p><p id="ebd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也意味着左侧的键不必是有效的属性或变量名。但是，左侧冒号后的变量名必须是有效的属性或变量名。</p><p id="2b55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="52dd" class="ne md it na b gy nf ng l nh ni">const obj = { 'abc 123': 1};<br/>const { 'abc 123': abc123 } = obj;<br/><br/>console.log(abc123); // <!-- -->1</span></pre><p id="bf9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要两边的键名相同，我们就可以用字符串中的任意一个键对变量进行析构赋值。</p><p id="cc71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一件要注意的事情是，析构赋值足够聪明，可以在原型链的同一层上查找键，所以如果我们有:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4514" class="ne md it na b gy nf ng l nh ni">var obj = {a: 1};<br/>obj.__proto__.b = 2;<br/>const {a, b} = obj;</span></pre><p id="690e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当JavaScript解释器在原型继承链中寻找<code class="fe nj nk nl na b">b</code>并设置键<code class="fe nj nk nl na b">b</code>给出的值时，我们仍然将<code class="fe nj nk nl na b">a</code>设置为1，将<code class="fe nj nk nl na b">b</code>设置为2。</p><p id="a385" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，析构赋值是一个非常强大的语法。编写代码将数组条目赋给变量或将对象值赋给它们自己的变量可以节省大量时间。</p><p id="db83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还让我们不用临时变量就能交换变量，使代码更简单，更容易理解。它还通过继承工作，因此属性不必在对象本身中，即使属性在它的原型中也可以工作。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="36cb" class="ne md it na b gy nf ng l nh ni">const fn = () =&gt; {a:1, b:2}<br/>const {a,b} = fn();</span></pre></div></div>    
</body>
</html>