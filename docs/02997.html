<html>
<head>
<title>Using Higher-Order Components With useContext and useReducer for a Redux-Like Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对类似Redux的模式使用带有useContext和useReducer的高阶组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-higher-order-component-with-usecontext-and-usereducer-for-a-redux-like-pattern-8fb6ba0e5aba?source=collection_archive---------6-----------------------#2020-01-14">https://betterprogramming.pub/using-higher-order-component-with-usecontext-and-usereducer-for-a-redux-like-pattern-8fb6ba0e5aba?source=collection_archive---------6-----------------------#2020-01-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b0f5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在React组件中维护干净且可重用的代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dae2a845069ffd68d496a67513e9d054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1iypsouAGB6jABtPW-JyA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯多夫·高尔在<a class="ae kv" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="944b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不是<code class="fe ls lt lu lv b">useContext</code>或者<code class="fe ls lt lu lv b">useReducer</code>或者更高阶的元件教程，我就不详细解释了。</p><p id="8c49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个同事告诉我<code class="fe ls lt lu lv b">useContext</code>和<code class="fe ls lt lu lv b">useReducer</code>有多好。他们带来了拥有一个状态管理系统而不需要外部包的所有好处。</p><p id="cd2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我花了一些时间来尝试它们，并对无法保持无国籍状态感到不快。</p><p id="83fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">直接使用<code class="fe ls lt lu lv b">useContext</code>的缺点包括:</p><ol class=""><li id="5c6a" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">改变我们编写组件的方式。</li><li id="ee3c" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">可以访问比组件所用更多的信息。</li><li id="0b31" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">无法在上下文之外重用表示组件。</li></ol><p id="1fea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在尝试了<code class="fe ls lt lu lv b">useContext</code>和HOC之后，我设法用它们创建了无状态组件。</p><p id="9c62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了提高本文的可读性，我将所有代码放在一个文件中。我强烈建议您为每个组件创建单独的文件。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="adc1" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">不使用上下文的计数器组件</h1><p id="b1c1" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">让我们看看一种不用<code class="fe ls lt lu lv b">useContext</code>编写计数器组件的方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e72c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有一个存储状态的容器<code class="fe ls lt lu lv b">Counter</code>，我们可以创建一堆其他的无状态组件，比如<code class="fe ls lt lu lv b">Display</code>、<code class="fe ls lt lu lv b">IncrementButton</code>、<code class="fe ls lt lu lv b">DecrementButton</code>来帮助我们显示<code class="fe ls lt lu lv b">Counter</code>的计数值。</p><p id="5d30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们有一个非常嵌套的组件，需要多层次的适当传递时，挑战就来了。</p><p id="fc89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，在<code class="fe ls lt lu lv b">Counter</code>和<code class="fe ls lt lu lv b">IncrementButton</code>之间，如果有五个其他嵌套组件，我们将不得不把状态值从<code class="fe ls lt lu lv b">Counter</code>一直传递到<code class="fe ls lt lu lv b">IncrementButton</code>。</p><p id="b959" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您有许多组件需要跨多个级别传递状态时，这就变得很烦人。通过使用<code class="fe ls lt lu lv b">useContext</code>，我们将能够在不传递任何道具的情况下访问状态。</p><p id="0431" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码使用<code class="fe ls lt lu lv b">useContext</code>代替。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="428c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不再需要将状态传递给单独的组件。<code class="fe ls lt lu lv b">Display</code>、<code class="fe ls lt lu lv b">IncrementButton</code>、<code class="fe ls lt lu lv b">DecrementButton</code>分别不从母公司取<code class="fe ls lt lu lv b">count</code>、<code class="fe ls lt lu lv b">increment</code>、<code class="fe ls lt lu lv b">decrement</code>。</p><p id="ff12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，它们不再是独立的组件。它们需要在它们的祖先组件链中有一个提供者。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="9070" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">useState和useReducer</h1><p id="24b4" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">一种常见的模式是将<code class="fe ls lt lu lv b">useState</code>与<code class="fe ls lt lu lv b">useReducer</code>一起使用。当我们需要管理许多状态时，这很方便。我们目前只有一个状态<code class="fe ls lt lu lv b">count</code>，但是一旦我们有了几个状态，事情就会变得混乱。</p><p id="1798" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下代码利用了<code class="fe ls lt lu lv b">useContext</code>和<code class="fe ls lt lu lv b">useReducer</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7dc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">useReducer</code>取一个减速器及其初始状态。我们创建一个接受当前状态和动作的缩减器。更新后的<code class="fe ls lt lu lv b">state</code>和<code class="fe ls lt lu lv b">dispatch</code>功能由减速器返回给我们。</p><p id="9aa5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">动作创建者<code class="fe ls lt lu lv b">incrementAction</code>和<code class="fe ls lt lu lv b">decrementAction</code>返回一个动作(一个带有类型和可选负载的对象)。然后，<code class="fe ls lt lu lv b">dispatch</code>函数通过调度我们创建的动作来更新状态。</p><p id="81a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您熟悉Redux，那么这个模式对您来说会很熟悉。</p><p id="cf8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加动作和缩减器有助于组织预期的状态。这些操作帮助我们跟踪我们拥有的功能。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="cbab" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">独立的无状态组件</h1><p id="49dc" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">应用<code class="fe ls lt lu lv b">useState</code>和<code class="fe ls lt lu lv b">useReducer</code>后，我们创建了一个状态管理系统。现在我们将尝试把<code class="fe ls lt lu lv b">Display</code>、<code class="fe ls lt lu lv b">IncrementButton</code>和<code class="fe ls lt lu lv b">DecrementButton</code>组件改回独立的无状态组件。</p><p id="6691" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用一个高阶组件(HOC)来注入状态和调度函数作为道具。</p><p id="3b24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们单独看一下特设委员会。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d6fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有两种方法可以检索上下文的值。</p><p id="c320" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一种方式是使用<code class="fe ls lt lu lv b">useContext</code>如前所见:<code class="fe ls lt lu lv b">const {state, dispatch} = useContext(CounterContext)</code>。</p><p id="c42c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二种方式是利用上下文的消费者，比如<code class="fe ls lt lu lv b">CounterContext.Consumer</code>。<code class="fe ls lt lu lv b">Consumer</code>需要返回组件的函数。</p><p id="9247" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们把值<code class="fe ls lt lu lv b">state</code>和<code class="fe ls lt lu lv b">dispatch</code>析构出来，和所有的道具一起传入组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ff3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用特设，我们不再需要使用<code class="fe ls lt lu lv b">Display</code>中的<code class="fe ls lt lu lv b">useContext</code>。<code class="fe ls lt lu lv b">Display</code>组件现在接受一个<code class="fe ls lt lu lv b">state</code>作为道具。</p><p id="4cc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们需要用<code class="fe ls lt lu lv b">withCounter</code>包装我们的无状态组件，这个HOC为无状态组件提供了<code class="fe ls lt lu lv b">state</code>和<code class="fe ls lt lu lv b">dispatch</code>。</p><p id="5c9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是这一部分的代码</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="dbd8" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">从显示中删除状态</h1><p id="d397" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">在上一节中，我们传入了作为道具的<code class="fe ls lt lu lv b">state</code>和<code class="fe ls lt lu lv b">dispatch</code>。然而，<code class="fe ls lt lu lv b">Display</code>组件只需要<code class="fe ls lt lu lv b">count</code>而不是整个<code class="fe ls lt lu lv b">state</code>对象。</p><p id="bf51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本节中，我们将从<code class="fe ls lt lu lv b">Display</code>中移除<code class="fe ls lt lu lv b">state</code>，仅传入<code class="fe ls lt lu lv b">count</code>。我们可以通过扩展我们的HOC来加入一个<code class="fe ls lt lu lv b">mapStateToProps</code>和<code class="fe ls lt lu lv b">mapDispatchToProps</code>来做到这一点。</p><p id="2879" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新<code class="fe ls lt lu lv b">withCounter</code> HOC以接收<code class="fe ls lt lu lv b">mapStateToProps</code>和<code class="fe ls lt lu lv b">mapDispatchToProps</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f5bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们修改<code class="fe ls lt lu lv b">withCounter</code>以包含<code class="fe ls lt lu lv b">mapStateToProps</code>和<code class="fe ls lt lu lv b">mapDispatchToProps</code>。</p><p id="d6d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">mapStateToProps</code>应提取出<code class="fe ls lt lu lv b">Display</code>所需的状态。组件必须明确地告诉它所需要的状态是什么，这些状态将作为道具传递给组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7b77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">IncrementButton</code>组件中，为了映射分派函数，我们可以创建一个<code class="fe ls lt lu lv b">mapDispatchToProps</code>函数来将分派函数映射到道具。在<code class="fe ls lt lu lv b">DecrementButton</code>组件中，代码是类似的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1d50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在已经成功地使用<code class="fe ls lt lu lv b">useContext</code>、<code class="fe ls lt lu lv b">useReducer</code>和HOC创建了一个类似Redux的模式，它不需要我们修改如何编写我们的无状态组件。</p><p id="d85d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">特别感谢<a class="nq nr ep" href="https://medium.com/u/7c7e484eedea?source=post_page-----8fb6ba0e5aba--------------------------------" rel="noopener" target="_blank">梅布尔·李</a>作为一名出色的编辑。</p><p id="3ada" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="a28d" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">密码</h1><p id="ec1e" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">下面是放在一个文件中的完整代码。强烈建议将组件、操作和上下文分离到不同的文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure></div></div>    
</body>
</html>