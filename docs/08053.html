<html>
<head>
<title>How To Crack the Top 25 Golang Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何破解25大Golang面试问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-crack-the-top-25-golang-interview-questions-a94396d6c808?source=collection_archive---------3-----------------------#2021-03-19">https://betterprogramming.pub/how-to-crack-the-top-25-golang-interview-questions-a94396d6c808?source=collection_archive---------3-----------------------#2021-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a224" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过掌握这些问题赢得下一次编码面试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aacb3a84747bd3db44863a188d35809a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7XM4m2xt_Lkdvj9EemjbOg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="d360" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>编程语言，或Golang，是一种开源编程语言，类似于C，但针对快速编译、无缝并发和开发人员易用性进行了优化。</p><p id="60ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种语言是由谷歌创造和采用的，但近年来随着对并发、网络化程序需求的增加，这种语言在其他公司也越来越流行。</p><p id="07f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无论你是在准备谷歌的工作面试，还是只想继续做一名前沿开发者，Go都是你的正确选择。今天，我们将通过25个最重要的围棋问答来帮助你练习你的围棋技巧。</p><p id="e3de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">这是我们今天要讲的内容:</strong></p><ul class=""><li id="9987" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">关于Golang基础知识的问题</li><li id="126a" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">中级Golang问题</li><li id="7e27" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">Golang中的编码挑战</li><li id="8d40" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">Golang并发问题</li><li id="e1f8" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">你学习的下一步</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8004" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">关于Golang基础知识的问题</h1><h2 id="5f37" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">1.与其他语言相比，使用Go有什么好处？</h2><ul class=""><li id="d1e7" class="lv lw it la b lb nu le nv lh nw ll nx lp ny lt ma mb mc md bi translated">与其他以学术实验开始的语言不同，Go代码是务实设计的。每一个特性和语法决策都是为了让程序员的生活更轻松。</li><li id="1a20" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">Golang针对并发性进行了优化，并且在大规模下运行良好。</li><li id="ca59" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">由于单一的标准代码格式，Golang通常被认为比其他语言更具可读性。</li><li id="0827" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">自动垃圾收集明显比在Java或Python中更有效，因为它与程序并行执行。</li></ul><h2 id="90e0" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">2.什么是字符串文字？</h2><p id="76b1" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">一个<em class="oc">字符串文字</em>是通过连接字符形成的字符串常量。字符串文字的两种形式是原始字符串文字和解释字符串文字。</p><p id="3dee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">原始字符串文字写在反斜杠(<code class="fe od oe of og b">foo</code>)内，并用未解释的UTF-8字符填充。解释的字符串文字就是我们通常认为的字符串，写在双引号内，包含除换行符和未结束的双引号之外的任何字符。</p><h2 id="b168" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">3.Golang使用什么数据类型？</h2><p id="6275" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">Golang使用以下类型:</p><ul class=""><li id="a91f" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">方法</li><li id="b808" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">布尔代数学体系的</li><li id="c0ae" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">数字的</li><li id="143a" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">线</li><li id="c4d9" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">排列</li><li id="a310" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">薄片</li><li id="a235" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">结构体</li><li id="df53" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">指针</li><li id="917f" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">功能</li><li id="ed69" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">连接</li><li id="2147" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">地图</li><li id="2c43" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">频道</li></ul><h2 id="d42d" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">4.Go程序中的包是什么？</h2><p id="f8b0" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated"><em class="oc">包</em> ( <code class="fe od oe of og b">pkg</code>)是包含Go源文件或其他包的Go工作区中的目录。源文件中的每个函数、变量和类型都存储在链接包中。每个Go源文件都属于一个包，该包在文件的顶部使用:</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="389b" class="ni mr it og b gy ol om l on oo">package &lt;packagename&gt;</span></pre><p id="3d37" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用以下方法导入和导出包以重用导出的函数或类型:</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="75ee" class="ni mr it og b gy ol om l on oo">import &lt;packagename&gt;</span></pre><p id="c012" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Golang的标准包是<code class="fe od oe of og b">fmt</code>，其中包含类似<code class="fe od oe of og b">Println()</code>的格式化和打印功能。</p><h2 id="df8e" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">5.Go支持什么形式的类型转换？将整数转换为浮点数</h2><p id="1513" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">Go支持显式类型转换，以满足其严格的类型要求。</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="c4f8" class="ni mr it og b gy ol om l on oo">i := 55      //int</span><span id="dca5" class="ni mr it og b gy op om l on oo">j := 67.8    //float64</span><span id="33d3" class="ni mr it og b gy op om l on oo">sum := i + int(j) //j is converted to int</span></pre><h2 id="36af" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">6.什么是goroutine？你怎么阻止它？</h2><p id="1297" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">一个<em class="oc"> goroutine </em>是一个函数或方法，它使用一个特殊的goroutine线程与任何其他goroutine并行执行。Goroutine线程比标准线程更轻量级，大多数Golang程序同时使用数千个go routine。</p><p id="7009" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要创建一个goroutine，在函数声明之前添加关键字<code class="fe od oe of og b">go</code>。</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="0b83" class="ni mr it og b gy ol om l on oo">go f(x, y, z)</span></pre><p id="eff7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以通过向goroutine发送信号通道来停止它。Goroutines只有在被告知检查时才能响应信号，所以你需要在逻辑位置包括检查，比如在你的<code class="fe od oe of og b">for</code>循环的顶部。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="f8b3" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">7.如何在运行时检查变量类型？</h2><p id="f67b" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">类型开关是在运行时检查变量类型的最佳方式。类型开关通过类型而不是值来计算变量。每个开关至少包含一个作为条件语句的<code class="fe od oe of og b">case</code>和一个<code class="fe od oe of og b">default</code>案例，如果没有一个案例为真，则执行该案例。</p><p id="de21" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，您可以创建一个类型开关来检查接口值<code class="fe od oe of og b">i</code>是否包含类型<code class="fe od oe of og b">int</code>或<code class="fe od oe of og b">string</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="532b" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">8.你如何连接字符串？</h2><p id="bff2" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">连接字符串最简单的方法是使用连接操作符(<code class="fe od oe of og b">+</code>)，它允许您像添加数值一样添加字符串。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="09eb" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">中级Golang问题</h1><h2 id="03a6" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">9.解释用Golang测试的步骤</h2><p id="0c33" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">Golang支持使用定制测试套件对包进行自动化测试。</p><p id="f62d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要创建一个新的套件，创建一个以<code class="fe od oe of og b">_test.go</code>结尾并包含一个<code class="fe od oe of og b">TestXxx</code>函数的文件，其中<code class="fe od oe of og b">Xxx</code>被替换为您正在测试的特性的名称。例如，测试登录能力的函数将被称为<code class="fe od oe of og b">TestLogin</code>。</p><p id="974f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，将测试套件文件放在与您想要测试的文件相同的包中。测试文件在常规执行时会被跳过，但当您输入<code class="fe od oe of og b">go test</code>命令时会运行。</p><h2 id="6642" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">10.什么是函数闭包？</h2><p id="0474" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated"><em class="oc">函数闭包</em>是从函数体外部引用变量的函数值。该函数可以访问引用的变量并为其赋值。</p><p id="e24e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:<code class="fe od oe of og b">adder()</code>返回一个闭包，这个闭包绑定到它自己引用的<code class="fe od oe of og b">sum</code>变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="5fe8" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">11.我们如何用Golang执行继承？</h2><p id="22b9" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">这是一个有点技巧的问题:Golang中没有继承，因为它不支持类。</p><p id="b777" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，您可以使用composition模仿继承行为，使用现有的struct对象定义新对象的开始行为。一旦创建了新对象，功能就可以扩展到原始结构之外。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="30ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe od oe of og b">Animal</code>结构包含<code class="fe od oe of og b">Eat()</code>、<code class="fe od oe of og b">Sleep()</code>和<code class="fe od oe of og b">Run()</code>函数。通过简单地在<code class="fe od oe of og b">Dog</code>的实现顶部列出结构，这些函数被嵌入到子结构<code class="fe od oe of og b">Dog</code>中。</p><h2 id="66a2" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">12.解释Go接口。它们是什么，它们是如何工作的？</h2><p id="20df" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">接口是Go中的一种特殊类型，它定义了一组方法签名，但不提供实现。类型<code class="fe od oe of og b">interface</code>的值可以保存实现这些方法的任何值。</p><p id="d3f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接口本质上充当方法的占位符，这些方法基于使用它们的对象而具有多个实现。</p><p id="595d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，您可以实现一个<code class="fe od oe of og b">geometry</code>接口，该接口定义所有使用该接口的形状必须有一个<code class="fe od oe of og b">area()</code>和<code class="fe od oe of og b">perim()</code>的实现。</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="99c4" class="ni mr it og b gy ol om l on oo">type geometry interface {<br/>    area() float64<br/>    perim() float64<br/>}</span></pre><h2 id="d4d6" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">13.Golang中的左值和右值是什么？</h2><p id="13e0" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">左值</p><ul class=""><li id="bc3d" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">指的是一个内存位置</li><li id="016e" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">表示变量标识符</li><li id="96ea" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">易变的</li><li id="557c" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">可能出现在<code class="fe od oe of og b">=</code>操作器的左侧或右侧</li></ul><p id="c2ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，在语句<code class="fe od oe of og b">x =20</code>中，<code class="fe od oe of og b">x</code>是左值，<code class="fe od oe of og b">20</code>是右值。</p><p id="52c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">右值</strong></p><ul class=""><li id="7ae4" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">表示存储在内存中的数据值</li><li id="8921" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">表示一个常数值</li><li id="edbe" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">总是出现在<code class="fe od oe of og b">=</code>操作员的右侧。</li></ul><p id="75aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，语句<code class="fe od oe of og b">10 = 20</code>无效，因为<code class="fe od oe of og b">=</code>运算符左侧有一个右值(<code class="fe od oe of og b">10</code>)。</p><h2 id="4417" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">14.Go中的循环构造是什么？</h2><p id="b5dd" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">Go只有一个循环结构:<code class="fe od oe of og b">for</code>循环。<code class="fe od oe of og b">for</code>循环由分号分隔的三个部分组成:</p><ul class=""><li id="5b63" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">在循环开始前执行的<code class="fe od oe of og b">Init</code>语句。它通常是一个只在<code class="fe od oe of og b">for</code>循环范围内可见的变量声明。</li><li id="3b4a" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">条件表达式，在每次迭代之前作为布尔值进行计算，以确定循环是否应该继续。</li><li id="756a" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">在每次迭代结束时执行的<code class="fe od oe of og b">post</code>语句。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/b728a4d0a553ac62d8ff364ba86e95bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/0*rfpeK-EC7CWHI5EQ.PNG"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="1991" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">15.你能从一个函数中返回多个值吗？</h2><p id="6629" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">是的。Go函数可以返回多个值，每个值在<code class="fe od oe of og b">return</code>语句中用逗号分隔。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="00a3" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">Golang的编码挑战</h1><h2 id="fd20" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">16.实现堆栈(LIFO)</h2><p id="1d33" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">实现具有弹出、附加和打印顶部功能的堆栈结构。</p><p id="64fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案</strong></p><p id="e8b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用slice对象实现堆栈。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="d8d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们使用内置的<code class="fe od oe of og b">append()</code>函数来实现追加行为。然后我们用<code class="fe od oe of og b">len(stack)-1</code>选择栈顶并打印。</p><p id="f33e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于pop，我们将堆栈的新长度设置为打印的上限值的位置，<code class="fe od oe of og b">len(stack)-1</code>。</p><h2 id="841d" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">17.打印切片字符或字符串的所有排列</h2><p id="9e9a" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">实现<code class="fe od oe of og b">perm()</code>函数，该函数接受一个切片或字符串，并打印所有可能的字符组合。</p><p id="ec50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="49d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用<code class="fe od oe of og b">rune</code>类型来处理切片和字符串。符文是Unicode码点，因此可以同等地解析字符串和切片。</p><h2 id="be09" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">18.交换两个变量的值，不使用临时变量</h2><p id="728e" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">实现<code class="fe od oe of og b">swap()</code>，它交换两个变量的值，而不使用第三个变量。</p><p id="4e99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="ea47" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然这在其他语言中可能很复杂，但Go让它变得很容易。</p><p id="faca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以简单地包含语句<code class="fe od oe of og b">b, a = a, b</code>，变量引用什么数据，而不涉及任何一个值。</p><h2 id="190e" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">19.实现最小和最大行为</h2><p id="8312" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">实现<code class="fe od oe of og b">Min(x, y int)</code>和<code class="fe od oe of og b">Max(x, y int)</code>函数，它们接受两个整数并分别返回较小或较大的值。</p><p id="d66f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案</strong></p><p id="deb4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，Go只支持使用<code class="fe od oe of og b">math.min</code>和<code class="fe od oe of og b">math.max</code>的浮点数的最小值和最大值。您必须创建自己的实现来使它适用于整数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="e21e" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">20.反转切片的顺序</h2><p id="bcac" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">实现函数<code class="fe od oe of og b">reverse</code>,该函数获取一个整数切片并在不使用临时切片的情况下就地反转该切片。</p><p id="0fad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="618a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的<code class="fe od oe of og b">for</code>循环交换切片中每个元素的值。值将从左向右滑动。最终，所有元素都会被反转。</p><h2 id="dd07" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">21.检查切片是否为空的最简单方法是什么？</h2><p id="0d4e" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">创建一个检查切片是否为空的程序。找到最简单的解决方案。</p><p id="cd54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案</strong></p><p id="88fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">检查切片是否为空的最简单方法是使用内置的<code class="fe od oe of og b">len()</code>函数，该函数返回切片的长度。如果<code class="fe od oe of og b">len(slice) == 0</code>，那么你知道切片是空的。</p><p id="d6c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="44ff" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">22.格式化字符串，但不打印</h2><p id="483b" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">找到用变量格式化字符串而不打印值的最简单的方法。</p><p id="25cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案</strong></p><p id="1266" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最简单的不打印格式化的方法是使用<code class="fe od oe of og b">fmt.Sprintf()</code>，它返回一个字符串而不打印它。</p><p id="552b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="9136" class="ni mr it og b gy ol om l on oo">package main</span><span id="c3fe" class="ni mr it og b gy op om l on oo">import "fmt"</span><span id="3113" class="ni mr it og b gy op om l on oo">func main() {<br/>  s := fmt.Sprintf("Size: %d MB.", 85)<br/>  fmt.Println(s)<br/>}</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8740" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">Golang并发问题</h1><h2 id="7977" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">23.解释Golang中并发和并行的区别</h2><p id="7297" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated"><em class="oc">并发</em>是指你的程序可以同时处理多个任务，而<em class="oc">并行</em>是指你的程序可以使用多个处理器同时执行多个任务。</p><p id="bc9f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换句话说，并发性是程序的一个属性，它允许您同时进行多个任务，但不一定同时执行。并行性是同时执行两个或更多任务的运行时属性。</p><p id="ba16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，并行性可以成为实现并发性的一种手段，但它只是众多可用手段中的一种。</p><p id="a419" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Golang中并发的关键工具是<em class="oc"> goroutines </em>和<em class="oc">通道</em>。go routine是并发的轻量级线程，而通道允许go routine在执行过程中相互通信。</p><h2 id="1917" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">24.合并排序</h2><p id="111e" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">使用goroutines和channels实现并发合并排序解决方案。</p><p id="e694" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用这种顺序合并排序实现作为起点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="5278" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="10cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，在归并排序中，我们不断递归地将数组划分为<code class="fe od oe of og b">right</code>侧和<code class="fe od oe of og b">left</code>侧，并在从<strong class="la iu">行30 </strong>到<strong class="la iu">行34 </strong>的两侧调用<code class="fe od oe of og b">MergeSort</code>函数。</p><p id="efdf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们必须确保在从两个递归调用中获得返回值后执行<code class="fe od oe of og b">Merge(left,right)</code>，也就是说，在<code class="fe od oe of og b">Merge(left,right)</code>可执行之前，必须更新<code class="fe od oe of og b">left</code>和<code class="fe od oe of og b">right</code>。因此，我们在<strong class="la iu">行26 </strong>上引入一个<code class="fe od oe of og b">bool</code>类型的通道，并在<code class="fe od oe of og b">left = MergeSort(data[:mid])</code>执行后立即发送<code class="fe od oe of og b">true</code>(<strong class="la iu">行32 </strong>)。</p><p id="eb96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe od oe of og b">&lt;-done</code>操作在语句<code class="fe od oe of og b">Merge(left,right)</code>之前阻塞<strong class="la iu">行35 </strong>上的代码，以便在我们的goroutine完成之前不会继续。在goroutine完成并且我们在<code class="fe od oe of og b">done</code>通道上接收到<code class="fe od oe of og b">true</code>之后，代码前进到<strong class="la iu">行36 </strong>上的<code class="fe od oe of og b">Merge(left,right)</code>语句。</p><h2 id="0b96" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">25.平方和</h2><p id="93db" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">实现<code class="fe od oe of og b">SumOfSquares</code>函数，该函数接受一个整数<code class="fe od oe of og b">c</code>，并返回1和<code class="fe od oe of og b">c</code>之间的所有平方和。您需要使用<code class="fe od oe of og b">select</code>语句、goroutines和通道。</p><p id="9db0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，输入<code class="fe od oe of og b">5</code>将返回<code class="fe od oe of og b">55</code>，因为$1^2 + 2^2 + 3^2 + 4^2 + 5^2 = 55美元</p><p id="19eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用以下代码作为起点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="896e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解决方案</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="64c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看看我们的<code class="fe od oe of og b">SumOfSquares</code>函数。首先，在<strong class="la iu">第4行</strong>上，我们声明一个变量<code class="fe od oe of og b">y</code>，然后跳转到<code class="fe od oe of og b">For-Select</code>循环。在我们的select语句中有两种情况:</p><ul class=""><li id="a27b" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><code class="fe od oe of og b">case c &lt;- (y*y)</code>:这是通过通道<code class="fe od oe of og b">c</code>发送<code class="fe od oe of og b">y</code>的平方，在主例程创建的goroutine中接收。</li><li id="5f93" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><code class="fe od oe of og b">case &lt;-quit</code>:这是为了接收从函数返回的主例程的消息。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8009" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">你学习的下一步</h1><p id="af64" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">练习题做得很好！围棋是一门新兴的语言，像这样的动手练习是快速学会的关键。为了更好地准备面试，你需要:</p><ul class=""><li id="fc04" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">制定详细的学习计划</li><li id="7008" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">在白板上练习围棋问题</li><li id="cf04" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">学习如何大声表达你的思维过程</li><li id="1306" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">准备行为面试</li></ul><p id="717b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oc">快乐学习！</em></p></div></div>    
</body>
</html>