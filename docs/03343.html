<html>
<head>
<title>A Short Guide to CSS Positioning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CSS定位的简短指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-short-guide-to-css-positioning-a481c3556d60?source=collection_archive---------16-----------------------#2020-02-04">https://betterprogramming.pub/a-short-guide-to-css-positioning-a481c3556d60?source=collection_archive---------16-----------------------#2020-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1365" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">固定、相对、绝对等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7656c5374344e88ecc879d929be75de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hxEEL1pyvQwhjWrz"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@grakozy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格雷格·拉科齐</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="42ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我一直做web前端开发，用CSS用的挺多的。我以为我对CSS的基本知识了如指掌。但是在我内心深处，我知道我对CSS的了解并不能涵盖一切。还有很多东西我不知道。所以我决定踏上探索CSS世界的旅程，这是第一章。</p><p id="3489" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将解释CSS <code class="fe lv lw lx ly b">position</code>特性，你们可能都已经知道了，但是我将尝试提出一些你们以前可能没有听说过的东西。</p><h2 id="3aa0" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">阅读前</h2><p id="cea0" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在阅读了CSS规范之后，我试图用我的研究中的一些例子来组织这些。</p><p id="a3e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，最好是阅读官方文档来获得更准确的信息。此外，可能会有错误的信息或遗漏的信息，如果您能纠正我，我将不胜感激。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="e93d" class="ne ma it bd mb nf ng nh me ni nj nk mh jz nl ka mk kc nm kd mn kf nn kg mq no bi translated">什么是包容块？</h1><p id="8c5e" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在CSS中，有一个概念叫做包含块 (CB)的<em class="np">，在开始使用CSS <code class="fe lv lw lx ly b">position</code>之前，你应该知道这个概念。</em></p><p id="0966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包含块是您创建的DOM元素的抽象区域。当需要计算<code class="fe lv lw lx ly b">width</code>、<code class="fe lv lw lx ly b">height</code>、<code class="fe lv lw lx ly b">top</code>、<code class="fe lv lw lx ly b">left</code>时，由后代元素使用。CB是其后代元素的标准。换句话说，CB通常被称为父元素——从技术上来说，这是不对的，但是许多文档认为CB等同于父元素，以便于解释。</p><p id="7fd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个DOM元素在创建时都会创建它的CB。CB和制造它的东西一模一样。区别在于CB实际上并不用于在浏览器上绘制DOM元素，因为它们是抽象的概念。他们所做的是帮助后代元素决定他们的<code class="fe lv lw lx ly b">width</code>或<code class="fe lv lw lx ly b">height</code>应该是什么，或者他们的<code class="fe lv lw lx ly b">top</code>和<code class="fe lv lw lx ly b">left</code>应该是什么。</p><p id="13a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">元素和CBs之间的关系如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/e2b732004a6753c070bbd04599410576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qDYKrbqj6ZH6y0Y3bXc1lw.png"/></div></div></figure><p id="d2f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<code class="fe lv lw lx ly b">position</code>属性的类型，CB可能有所不同。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="9dc9" class="lz ma it ly b gy nv nw l nx ny">div {  <br/>  position: fixed;<br/>}</span><span id="84b0" class="lz ma it ly b gy nz nw l nx ny">p { <br/>  position: absolute; <br/>}</span><span id="5a48" class="lz ma it ly b gy nz nw l nx ny">h1 {   <br/>  position: relative; <br/>}</span><span id="df58" class="lz ma it ly b gy nz nw l nx ny">section { <br/>  position: sticky; <br/>}</span></pre><ul class=""><li id="fd7f" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated"><code class="fe lv lw lx ly b">div</code> — <code class="fe lv lw lx ly b">fixed</code>始终指视口</li><li id="aca3" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe lv lw lx ly b">p</code> — <code class="fe lv lw lx ly b">absolute</code>，指<code class="fe lv lw lx ly b">position</code>不是<code class="fe lv lw lx ly b">static</code>的最近的父元素CB。如果它们都不满足条件，则使用视口。</li><li id="7290" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe lv lw lx ly b">h1</code> — <code class="fe lv lw lx ly b">relative</code>并遵循正常的DOM流程。有趣的是，<code class="fe lv lw lx ly b">relative</code>元素使用左上角的坐标(0，0)作为CB的坐标。我将在这篇文章的后面更详细地解释这一点。</li><li id="2888" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe lv lw lx ly b">section</code> — <code class="fe lv lw lx ly b">sticky</code>指<code class="fe lv lw lx ly b">nearest</code>父元素的CB，其中<code class="fe lv lw lx ly b">overflow</code>设置为<code class="fe lv lw lx ly b">scroll</code>或<code class="fe lv lw lx ly b">auto</code>。如果它们都不满足条件，则使用视口。在这篇文章的后面，我会对此进行更深入的解释。</li></ul></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="d8e6" class="ne ma it bd mb nf ng nh me ni nj nk mh jz nl ka mk kc nm kd mn kf nn kg mq no bi translated">绝对位置</h1><p id="2098" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">absolute</code>元素不包含在普通的DOM流中。它从不关心其他元素的位置或大小。</p><p id="8134" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">absolute</code>元素的位置可以根据它所引用的元素而变化。基本上，<code class="fe lv lw lx ly b">absolute</code>元素指的是<code class="fe lv lw lx ly b">position</code>属性不是<code class="fe lv lw lx ly b">static</code>的最近的父元素的CB。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="cc9d" class="lz ma it ly b gy nv nw l nx ny">&lt;div id="outer"&gt;   <br/>  Outer   <br/>  &lt;div id="inner"&gt;<br/>     Inner<br/>     &lt;p id="p1"&gt;<br/>       Position Absolute<br/>     &lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="0ff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一棵像这样的DOM树。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/7bff3eab92665ca58f3c7a00a70d3417.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/0*Bo8e5-1-B5B2ZitJ"/></div></figure><p id="8327" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">inner</code>元素的位置现在是<code class="fe lv lw lx ly b">static</code>，这是没有设置<code class="fe lv lw lx ly b">position</code>属性时的默认值。因此，<code class="fe lv lw lx ly b">p1</code>指的是<code class="fe lv lw lx ly b">outer</code>的CB。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/3e30ff3baada11e16e2c957aae40a087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/0*3W7hYrfY54NglSE9"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如果所有元素位置都是静态的，则绝对位置指的是视口</p></figure><p id="4834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在<code class="fe lv lw lx ly b">outer</code>的位置是<code class="fe lv lw lx ly b">static</code>，这是默认值。如果没有父元素被设置为非<code class="fe lv lw lx ly b">static</code>的值，那么<code class="fe lv lw lx ly b">absolute</code>元素，在本例中为<code class="fe lv lw lx ly b">p1</code>，引用视口。</p><p id="4900" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但有一件事我应该澄清一下。值为<code class="fe lv lw lx ly b">absolute</code>的元素不在正常的DOM流中。不过，看起来它还在流行。实际上，<code class="fe lv lw lx ly b">p1</code>元件的位置如下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/0a84e87701edf655d47d6267939e3b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/0*Rc61sm7C6_tpwDu2"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">默认字体大小为16px</p></figure><p id="34bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你首先能看到的是<code class="fe lv lw lx ly b">p1</code>的<code class="fe lv lw lx ly b">margin</code>。此时<code class="fe lv lw lx ly b">p1</code>的<code class="fe lv lw lx ly b">margin</code>值为1 <code class="fe lv lw lx ly b">em</code>，换算成16px。默认情况下，<code class="fe lv lw lx ly b">em</code>受父元素的<code class="fe lv lw lx ly b">font-size</code>值的影响，该值可以继承给子元素。Chrome中默认的<code class="fe lv lw lx ly b">font-size</code>是16px，也就是说<code class="fe lv lw lx ly b">p1</code>的父元素的<code class="fe lv lw lx ly b">font-size</code>也是16px，因为我没有碰过。所以<code class="fe lv lw lx ly b">p1</code>的<code class="fe lv lw lx ly b">margin</code>大小也将是<code class="fe lv lw lx ly b">16px * 1em = 16px</code>。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="6f69" class="lz ma it ly b gy nv nw l nx ny">#inner {<br/>  font-size: 10px;<br/>}</span></pre><p id="411b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我把<code class="fe lv lw lx ly b">inner</code>的<code class="fe lv lw lx ly b">font-size</code>改成10px会怎么样，因为<code class="fe lv lw lx ly b">inner</code>是<code class="fe lv lw lx ly b">p1</code>的父节点？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/b94cd90909643202894f45dc6eab9a28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/0*39jQ6GvLpWHlmZki"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">现在字体大小改为10px</p></figure><p id="df72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后<code class="fe lv lw lx ly b">p1</code>的<code class="fe lv lw lx ly b">margin</code>也被重新计算为10px。</p><p id="92e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且，我也没有给<code class="fe lv lw lx ly b">p1</code>的<code class="fe lv lw lx ly b">top</code>属性赋予任何值，但是为什么它会从最顶端的元素偏移一些像素呢？从表面上看，它大约是文本“外部”和“内部”高度的总和嗯，没错。</p><p id="8f12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CSS规范对<code class="fe lv lw lx ly b">top</code>属性的描述如下:</p><blockquote class="ou ov ow"><p id="8246" class="kz la np lb b lc ld ju le lf lg jx lh ox lj lk ll oy ln lo lp oz lr ls lt lu im bi translated">“‘顶’和‘底’是‘自动’，而‘高度’不是‘自动’，那么将‘顶’设置为静态位置。”</p></blockquote><p id="325a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，这意味着即使<code class="fe lv lw lx ly b">p1</code>是一个<code class="fe lv lw lx ly b">absolute</code>定位的元素，它也像一个<code class="fe lv lw lx ly b">relative</code>定位的元素一样工作——除非它的<code class="fe lv lw lx ly b">top</code>或<code class="fe lv lw lx ly b">left</code>被设置。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="1ed3" class="lz ma it ly b gy nv nw l nx ny">#p1 {<br/>  top: 0;<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/2245e8d1bd6ac817347f1341a83a0ce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/0*I1pjnSLrYPTiZYdb"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在top被设置为0后，绝对元素最终粘在了top上</p></figure><p id="7352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给了<code class="fe lv lw lx ly b">p1</code>一个<code class="fe lv lw lx ly b">top</code>的值后，终于，上了CB的顶。</p><h2 id="923c" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">快速测验</h2><p id="fe09" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lv lw lx ly b">p1</code>仍不在左起0处。这是为什么呢？(提示:<code class="fe lv lw lx ly b">p1</code>的<code class="fe lv lw lx ly b">left</code>还是<code class="fe lv lw lx ly b">auto</code>。)</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="f1e8" class="ne ma it bd mb nf ng nh me ni nj nk mh jz nl ka mk kc nm kd mn kf nn kg mq no bi translated">位置固定</h1><p id="6205" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lv lw lx ly b">fixed</code>元素与<code class="fe lv lw lx ly b">absolute</code>元素非常相似，除了一个巨大的区别——它们总是将视口称为CB。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="eb3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，<code class="fe lv lw lx ly b">outer</code>从顶部偏移50px，并且<code class="fe lv lw lx ly b">left</code>和<code class="fe lv lw lx ly b">top</code>被设置为<code class="fe lv lw lx ly b">position: fixed</code>的<code class="fe lv lw lx ly b">0</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/0a166fd3aca72facafcfa0db9b69d174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/0*OjD5oW2x-wpKQZGJ"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">固定元素总是查看视口的CB</p></figure><p id="7d13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到<code class="fe lv lw lx ly b">p1</code>贴在视窗的顶部。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="1dd5" class="ne ma it bd mb nf ng nh me ni nj nk mh jz nl ka mk kc nm kd mn kf nn kg mq no bi translated">相对位置</h1><p id="40dd" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lv lw lx ly b">relative</code>元素遵循正常的DOM流。它们总是参考父元素的CB来确定大小和位置(<code class="fe lv lw lx ly b">top</code>、<code class="fe lv lw lx ly b">left</code>等)。).但是，它们引用自己的CB位置，该位置包含在父元素的DOM流中，作为开始位置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/cf3ae56d3a7e7dd1d7e06ede27420178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/0*_Ft5Yd_SkZzcr2jd"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">相对元素总是查看父元素的CB</p></figure><p id="7717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">relative</code>和<code class="fe lv lw lx ly b">absolute</code>元素有相同的共同特征——它们可以与其他元素重叠。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="1514" class="lz ma it ly b gy nv nw l nx ny">#p1 {   <br/>  top: 50%; <br/>}</span></pre><p id="1fc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">p1</code>这里的top是50%。由于<code class="fe lv lw lx ly b">p1</code>引用父元素的CB，因此<code class="fe lv lw lx ly b">top</code>值将是父元素高度的50%。但是它没有从父元素CB的顶部偏移。是从它的CB上面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/efc1264796bcb3c00e462111c22da9dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*5llYVBP7JyhKOQrt"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">相对元素与父元素重叠</p></figure><p id="84b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">relative</code>和<code class="fe lv lw lx ly b">absolute</code>是有区别的。<code class="fe lv lw lx ly b">absolute</code>元素无论如何都应该在浏览器上呈现，除非它们的<code class="fe lv lw lx ly b">display</code>被设置为<code class="fe lv lw lx ly b">none </code> —例如，<code class="fe lv lw lx ly b">relative</code>元素根据其父元素的<code class="fe lv lw lx ly b">overflow</code>属性决定是否在浏览器上显示。</p><p id="9956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个我再深入解释一下。一旦创建了DOM元素，该元素就执行两项任务。第一项工作是为它的后代元素建立看起来完全相同的CB，这些后代元素将在以后需要时引用它的CB。另一个任务是确定必要时要参考的CB。</p><p id="feec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这类似于JavaScript的<code class="fe lv lw lx ly b">prototype</code>。当一个子元素在它所引用的CB之外时，浏览器通过查看子元素所引用CB的元素的<code class="fe lv lw lx ly b">overflow</code>属性来决定是否显示该子元素。如果<code class="fe lv lw lx ly b">overflow</code>属性被设置为<code class="fe lv lw lx ly b">scroll</code>或<code class="fe lv lw lx ly b">auto</code>，浏览器必须使子元素可见。</p><p id="9d33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更简单的解释是:如果CB所引用的元素的<code class="fe lv lw lx ly b">overflow</code>属性是<code class="fe lv lw lx ly b">scroll</code>或<code class="fe lv lw lx ly b">auto</code>，那么子元素将被显示。</p><p id="a5ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这是不是真的。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="a52f" class="lz ma it ly b gy nv nw l nx ny">#inner {   <br/>  overflow: scroll; <br/>}</span><span id="26fb" class="lz ma it ly b gy nz nw l nx ny">#p1 {   <br/>  top: 200%; <br/>}</span></pre><p id="d9e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">inner</code>有<code class="fe lv lw lx ly b">overflow: scroll</code><code class="fe lv lw lx ly b">p1</code>离顶挺远的，一开始看不到。但是如果你向下滚动，浏览器允许你看到它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/bb7c31181bcbb8211289b8683f0fd7e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/0*NtoTtVvLTeLRpf-g"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无论如何，必须显示相关元素</p></figure><p id="4315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，如果<code class="fe lv lw lx ly b">inner</code>的<code class="fe lv lw lx ly b">overflow</code>是<code class="fe lv lw lx ly b">hidden</code>就不会显示。如果<code class="fe lv lw lx ly b">overflow</code>没有设置，默认为<code class="fe lv lw lx ly b">visible</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/62ce6319d9d83719ffd1bf75c3324294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/0*9MJXel7WgLVntClw"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">当父元素的溢出属性可见时，相对元素将像这样显示</p></figure><h1 id="8efc" class="ne ma it bd mb nf pf nh me ni pg nk mh jz ph ka mk kc pi kd mn kf pj kg mq no bi translated">位置粘性</h1><p id="c13e" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lv lw lx ly b">sticky</code>很有用，但也很奇怪。CSS规范将其描述为类似于<code class="fe lv lw lx ly b">relative</code>。<code class="fe lv lw lx ly b">sticky</code>像<code class="fe lv lw lx ly b">relative</code>一样工作，直到元素位于某个阈值点。<em class="np">某个阈值点，在此上下文中的</em>是指决定元素位置的值，如<code class="fe lv lw lx ly b">top</code>或<code class="fe lv lw lx ly b">left</code>。但是谁的<code class="fe lv lw lx ly b">top</code>和<code class="fe lv lw lx ly b">left</code>？</p><p id="f6f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">sticky</code>元素是指<code class="fe lv lw lx ly b">overflow</code>设置为<code class="fe lv lw lx ly b">scroll</code>的最近的父元素的CB。如果它们都不满足条件，则一个<code class="fe lv lw lx ly b">sticky</code>元素引用视口。</p><p id="d354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果<code class="fe lv lw lx ly b">top</code>是50px，那么<code class="fe lv lw lx ly b">sticky</code>元素就像<code class="fe lv lw lx ly b">relative</code>元素一样工作，直到它从CB的顶部偏移50px。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/d8462dc48b333dcd169179ab63510600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*REUlsSuzVZ5E9CJT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。粘的</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/f5d6cd4af17d693e817bb52ff3af28b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sdEQDNZtpwvVKQw3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图二。粘的</p></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="ef83" class="ne ma it bd mb nf ng nh me ni nj nk mh jz nl ka mk kc nm kd mn kf nn kg mq no bi translated">其他有用信息</h1><p id="9dbb" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">如果同时设置了<code class="fe lv lw lx ly b">left</code>和<code class="fe lv lw lx ly b">right</code>，则<code class="fe lv lw lx ly b">left</code>获胜。如果同时设置了<code class="fe lv lw lx ly b">top</code>和<code class="fe lv lw lx ly b">bottom</code>，则<code class="fe lv lw lx ly b">top</code>获胜。</p><p id="5cb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果父元素的<code class="fe lv lw lx ly b">direction</code>属性设置为<code class="fe lv lw lx ly b">rtl</code>，从右到左，上面的优先级将相反。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="9c24" class="lz ma it ly b gy nv nw l nx ny">div {   <br/>  position: absolute;<br/>  top: 0; <br/>  bottom: 0;  <br/>  left: 0;  <br/>  right: 0; <br/>}</span></pre><p id="62be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的CSS表达式其实如下。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="1b47" class="lz ma it ly b gy nv nw l nx ny">div {   <br/>  position: absolute;<br/>  top: 0; <br/>  left: 0;  <br/>}</span></pre></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="70f3" class="ne ma it bd mb nf ng nh me ni nj nk mh jz nl ka mk kc nm kd mn kf nn kg mq no bi translated">结论</h1><p id="5c0a" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我试图组织CSS规范描述CSS的位置，给出一些例子以便更好地理解。即使我知道如何使用它们，我也不知道它们为什么这样或那样工作。所以这项研究对我来说很有意义。</p><p id="ccdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一下，<code class="fe lv lw lx ly b">position: sticky</code>比其他特性更晚被添加到规范中。所以目前没有很多浏览器支持这个功能。这个有一个聚合填充。希望以后有机会可以说说。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="b07a" class="ne ma it bd mb nf ng nh me ni nj nk mh jz nl ka mk kc nm kd mn kf nn kg mq no bi translated">资源</h1><ul class=""><li id="b884" class="oa ob it lb b lc ms lf mt li pm lm pn lq po lu of og oh oi bi translated"><a class="ae ky" href="https://www.w3.org/TR/CSS2/visudet.html#containing-block-details" rel="noopener ugc nofollow" target="_blank">“包含块”的定义— CSS模型2 </a></li><li id="f7bc" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><a class="ae ky" href="https://www.w3.org/TR/CSS21/visudet.html#propdef-height" rel="noopener ugc nofollow" target="_blank">内容高度:“高度”属性— CSS模型2 </a></li><li id="2b5c" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block" rel="noopener ugc nofollow" target="_blank">布局和包含块— MDN </a></li><li id="ee0c" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><a class="ae ky" href="http://www.littlewebhut.com/css/info_nonreplaced_replaced/" rel="noopener ugc nofollow" target="_blank"> CSS非替换和替换元素— LittleWebHut </a></li><li id="f2b5" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><a class="ae ky" href="https://caniuse.com/#feat=css-sticky" rel="noopener ugc nofollow" target="_blank">职位:粘性浏览器支持—我可以使用</a></li></ul></div></div>    
</body>
</html>