<html>
<head>
<title>Encapsulation, Access Controls, and Frameworks in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的封装、访问控制和框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/encapsulation-access-controls-and-frameworks-in-swift-6b5ddf8ce717?source=collection_archive---------7-----------------------#2020-07-27">https://betterprogramming.pub/encapsulation-access-controls-and-frameworks-in-swift-6b5ddf8ce717?source=collection_archive---------7-----------------------#2020-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cc32" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用访问控制的实用指南，包括框架的创建</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/917e9a2c5696d5ab7a2c78626255d91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h4TLlisFk7XvtREAsS7C7Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯托夫·高尔在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就论文而言，我必须承认这有点长，大约有2000多字。在前半部分，我将介绍三种基本的访问类型:私有、文件私有和内部。在第二部分，我将介绍如何创建一个具有公共和开放访问类型的框架。两个部分都有标签，可以独立阅读。</p><p id="e68f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说一些背景。早在20世纪70年代，瑞士苏黎世联邦理工学院的信息学教授，一个叫<a class="ae ky" href="https://en.wikipedia.org/wiki/Niklaus_Wirth" rel="noopener ugc nofollow" target="_blank">尼古拉斯·沃斯</a>的人，创造并出版了当时革命性的教学语言。一种他称为帕斯卡的语言。这是一种基于他的书<a class="ae ky" href="https://en.wikipedia.org/wiki/Algorithms_%2B_Data_Structures_%3D_Programs" rel="noopener ugc nofollow" target="_blank"> <em class="lv">算法+数据结构=程序</em> </a> <em class="lv">的语言。</em></p><p id="36f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是最早引入封装概念的高级计算机语言之一。这是一个我们今天都认为理所当然的概念。它的基本思想是，需要创建一个范围，在这个范围内可以限制对代码中元素的访问。私有和公共变量和方法的概念。</p><p id="f327" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，Pascal作为一种语言被设计得如此之好，以至于苹果决定用它来编写Mac OS。苹果操作系统，也就是命运多舛的丽莎和麦金塔电脑运行的操作系统。在其他人都还在使用c的时候，这是一个勇敢的决定。</p><p id="a423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与此同时，C本身也在经历着转变。十年前，随着Objective C语言的发展，Pascal语言问世，这种语言又一次采用了封装的思想和概念。巧合的是，史蒂夫·乔布斯的新团队在NextStep OS项目中再次使用了这种语言。给我们目标c的公司。</p><p id="69ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如他们所说，剩下的就是历史了。乔布斯于1997年回到苹果，带来了新的操作系统和新的语言，Objective C。正如你所知，Objective C是Swift的前身，众所周知，它于2014年问世。</p><p id="2bd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，Swift继续建立在Pascal的遗产之上，并且在该语言中有五个封装级别:私有、文件私有、内部、公共和开放。访问级别可以应用于变量、类、结构、枚举、函数、方法，甚至SwiftUI的新包装器构建。相对于源文件、定义所述代码的实体和/或模块的访问级别。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e5a3" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">私有、文件私有和内部</h1><p id="8c0a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">好了，历史足够了，让我们编码吧。我们将使用两个项目来说明这些访问级别是如何工作的。我们从最严格的，私有的开始。使用SwiftUI作为接口创建一个新项目，并向其中添加一个cocoa touch类文件，将其命名为Person.class，并添加您在此处看到的代码。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="7d1c" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">class</strong> Person {<br/>  <strong class="nb iu">var</strong> id: <strong class="nb iu">String</strong> = "SecretID"<br/>}</span></pre><p id="e532" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">访问该对象的SwiftUI接口需要如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4fb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的默认访问级别是内部。内部意味着可以在定义它们的整个模块中访问。默认情况下，您在Xcode项目中创建的所有内容都具有内部访问权限。<strong class="lb iu"> </strong>在SwiftUI实现中命名了Person类之后，它可以访问其中的所有变量。现在让我们试着把事情锁定一点。更改person类中的<code class="fe nm nn no nb b">id</code>使其成为私有的。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="31aa" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">private</strong> <strong class="nb iu">var</strong> id: <strong class="nb iu">String</strong> = "SecretID"</span></pre><p id="40ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将立即在ContentView.swift SwiftUI代码中得到一个错误，警告您类变量不再可访问。我们把它弄坏了，怎么修。</p><p id="af7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们假设我们不想改变<code class="fe nm nn no nb b">id</code>，我们只想读取它。我们可以通过在类中定义一个方法来修复这个错误，我们可以用这个方法来返回id。将<code class="fe nm nn no nb b">Person ID</code>类修改成如下所示的代码。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="2445" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">class</strong> Person {<br/>  <strong class="nb iu">private</strong> <strong class="nb iu">var</strong> id: <strong class="nb iu">String</strong> = "SecretID"<br/>  <strong class="nb iu">func</strong> displayid() -&gt; <strong class="nb iu">String</strong> {<br/>    <strong class="nb iu">return</strong> id<br/>  }<br/>}</span></pre><p id="92f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于函数<code class="fe nm nn no nb b">displayed()</code>将被分配内部权限，我们可以在SwiftUI代码中调用该函数。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="6942" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">struct</strong> ContentView: <strong class="nb iu">View</strong> {<br/>  @<strong class="nb iu">State</strong> <strong class="nb iu">var</strong> person = Person()<br/>  <strong class="nb iu">var</strong> <strong class="nb iu">body</strong>: <strong class="nb iu">some</strong> <strong class="nb iu">View</strong> {<br/>    Text("\(person.displayid())")<br/>  }<br/>}</span></pre><p id="0e1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">展望未来，想象我们需要能够改变<code class="fe nm nn no nb b">secret ID</code>。为此，我们可以创建一个新的类(尽管与<code class="fe nm nn no nb b">Person.class</code>在同一个文件中)，向其中添加一个函数，如下所示。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="2642" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">class</strong> Management {<br/>  <strong class="nb iu">static</strong> <strong class="nb iu">func</strong> updateID(for person:Person, with newID:<strong class="nb iu">String</strong> ) {   <br/>    person.id = newID<br/>  }<br/>}</span></pre><p id="da33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，您的新管理类最初也不会访问<code class="fe nm nn no nb b">person.id</code>，因为它是一个不同的类，很像SwiftUI struct。您将得到与之前相同的错误。</p><p id="f1b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，同时保留一些安全性，我们可以将Person类中的变量<code class="fe nm nn no nb b">id</code>的访问级别改为<code class="fe nm nn no nb b">fileprivate</code>。因为您在Person类所在的同一个文件中定义了管理类，所以它将获得访问权；而不开放对<code class="fe nm nn no nb b">ContentView.swift</code>文件中SwiftUI实现的访问。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="7ea1" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">fileprivate</strong> <strong class="nb iu">var</strong> id: String = "SecretID"</span></pre><p id="078b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过更改代码的<code class="fe nm nn no nb b">ContentView.swift</code>来测试新的实现，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4c9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将在最初显示<code class="fe nm nn no nb b">secret ID</code>消息三秒后更新您将在屏幕上看到的<code class="fe nm nn no nb b">ID</code>。注意，我在这里需要<code class="fe nm nn no nb b">dnr</code>变量，因为没有它SwiftUI不会知道它需要再次重新运行主体。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ca34" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">框架、公共和开放</h1><p id="774d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在，为了说明封装的最后两个级别，我们将切换项目。返回桌面，创建一个新项目。称之为BuyersPortal我打算再次使用SwiftUI作为接口。</p><p id="0973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<code class="fe nm nn no nb b">ContentView.swift</code>并将这些结构和类添加到其中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5fa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里定义的是一个产品记录和一个将使用它的类。现在更新<code class="fe nm nn no nb b">ContentView.swift</code>来访问您的新结构/类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9034" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你准备跑的时候；去吧。它将显示值为零的<code class="fe nm nn no nb b">newCustomer</code>。点击文本，它会进入你刚刚定义的方法，价格会改变。<code class="fe nm nn no nb b">Product</code>和<code class="fe nm nn no nb b">Purchases</code>类的默认权限是内部的，所有内容都在同一个文件中，这一切都将完美地工作。</p><p id="c744" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在想象你正在和你的同事Stewart一起远程工作。你的工作是定义<code class="fe nm nn no nb b">Product</code>和<code class="fe nm nn no nb b">Purchases</code>对象，而他的工作是将它们付诸行动。现在，您可以编写您在这里看到的代码，并发布源代码，但这不是很实际，也许您想保留对它的更多控制。</p><p id="7085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是框架、公共和开放访问控制发挥作用的地方。您将<code class="fe nm nn no nb b">Product</code>和<code class="fe nm nn no nb b">Purchases</code>对象嵌入到一个具有公共/开放权限的框架中。一个你交给Stewart的框架，确信他能够使用它，但不会滥用它。</p><p id="c4ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要构建一个框架，请返回Xcode并启动一个新项目。就叫<code class="fe nm nn no nb b">Engine</code>吧，不过等等，不要选通常的单页app，这次选个框架。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/579a1ebf4dd0986f65b2f3e53ce0b7ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LLTygysr-ZznMdMfl7QiuA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图。</p></figure><p id="c79e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个项目将会出现，它看起来相当光秃秃的，里面只有几个文件。向其中添加一个新的swift源代码文件，复制并粘贴我上面概述的代码，在您的新框架项目中定义<code class="fe nm nn no nb b">Product</code>和<code class="fe nm nn no nb b">Purchase</code>对象&amp;方法。</p><p id="5235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译一下，检查一下没有打错字，没有错误。关闭项目，现在仔细遵循这些步骤。</p><ul class=""><li id="7412" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">回到<code class="fe nm nn no nb b">BuyersPortal</code>项目，就是你刚刚剪切并粘贴了你的结构和类的那个项目，并注释掉所有内容。</li><li id="13c7" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">打开包含<code class="fe nm nn no nb b">Engine</code>项目的文件夹(其中包含结构和类),然后将其中的<code class="fe nm nn no nb b">xcodeproj</code>拖动到<code class="fe nm nn no nb b">BuyersPortal</code>。</li></ul><p id="5243" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no nb b">BuyersPortal</code>项目的文件检查器现在应该是这样的。<code class="fe nm nn no nb b">Engine</code>项目在<code class="fe nm nn no nb b">BuyersPortal</code>项目内。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/1d9b933e62c5411e0d7b6bcd9d3c9bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bm3qT8xKyNJTT-3a-vesrw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图。</p></figure><p id="5da5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格地说，我们不需要在这里包含整个<code class="fe nm nn no nb b">Engine</code>项目，我们可以只包含框架。但是在这种情况下包含整个项目更有意义，因为在我们将框架交付给Stewart之前，我们将更改其中的代码以获得正确的权限。</p><p id="2ff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，编译一切，以确保我们没有设法破坏我们的桌面。好了，我们准备慢慢地重建<code class="fe nm nn no nb b">BuyersPortal</code>中的<code class="fe nm nn no nb b">ContentView.swif</code> t。从定义<code class="fe nm nn no nb b">Purchases</code>的那行开始。行不通；你会得到一个错误“找不到…”</p><p id="91fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是swift的许可问题，而是告诉你它不知道你在说什么。这仍然是一个Xcode问题。</p><p id="a47f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要再做一步来将我们的<code class="fe nm nn no nb b">Engine</code>项目集成到<code class="fe nm nn no nb b">BuyersPortal</code>中。回到项目并展开<code class="fe nm nn no nb b">Engine</code>项目，在products下找到您想要的<code class="fe nm nn no nb b">Engine.framework</code>。</p><p id="58f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在选择<code class="fe nm nn no nb b">BuyersPortal</code>项目，向下滚动到框架、库和嵌入内容区域。您需要将刚刚找到的<code class="fe nm nn no nb b">Engine.framework</code>拖到此部分。如果正确的话，项目框架、库和嵌入内容应该是这样的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/969feb880044ddce740ff9a5e0326daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-76EJQrIwmDzBsv9ToAl9A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图。</p></figure><p id="c0e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要犯拖到<code class="fe nm nn no nb b">Engine</code>项目的框架、库和嵌入式代码部分的错误，那是行不通的！</p><p id="5cc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">链接之后，确保现在在<code class="fe nm nn no nb b">ContentView.swift</code>文件中也包含了一个导入语句。<code class="fe nm nn no nb b">BuyersPortal</code>中的<code class="fe nm nn no nb b">ContentView.swift</code>即。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="cd21" class="nf me it nb b gy ng nh l ni nj">import Engine</span></pre><p id="1d1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在取消对初始行的注释，以定义您的第一个<code class="fe nm nn no nb b">Purchases</code>对象。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="b509" class="nf me it nb b gy ng nh l ni nj">@State var newCustomer = Purchases()</span></pre><p id="8452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没用的，但是别担心，我们就快到了。现在您需要修复Swift权限。</p><p id="0da6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，<code class="fe nm nn no nb b">Engine</code>类中的所有权限都被设置为默认权限，即内部权限。将<code class="fe nm nn no nb b">Purchases</code>类的权限更改为public，然后重试。错误信息会改变，它会抱怨初始化器不是公共的。给你的<code class="fe nm nn no nb b">Purchases</code>类添加一个初始化器，然后重新编译。这次会成功的。我们正在取得进展。</p><p id="cc1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">取消对<code class="fe nm nn no nb b">Text</code>对象的<code class="fe nm nn no nb b">onTapGesture</code>注释，它将再次抱怨对<code class="fe nm nn no nb b">Purchases</code>类中的<code class="fe nm nn no nb b">Product</code>结构和<code class="fe nm nn no nb b">products</code>变量的访问权限，以及对<code class="fe nm nn no nb b">calculatePrice</code>方法的访问权限。让它们在你的<code class="fe nm nn no nb b">Engine</code>类中全部公开。您在<code class="fe nm nn no nb b">Engine</code>产品中的代码应该看起来像这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4932" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译并运行。点击<code class="fe nm nn no nb b">newCustomer</code>字段，它将运行<code class="fe nm nn no nb b">calculate price</code>方法并报告新的价格。好了，你有它，公众访问。</p><p id="bd5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了最后一种类型的访问控制，即开放访问控制，我们已经讨论过了。现在想象一下Stewart想要在这里继承我们的<code class="fe nm nn no nb b">Purchases</code>类。例如，他可能想要一个折扣班。一个直接从我们的<code class="fe nm nn no nb b">Purchases</code>类继承其值和方法的类。</p><p id="8a4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编辑<code class="fe nm nn no nb b">BuyersPortal</code>项目并向其中添加一个新文件，即<code class="fe nm nn no nb b">DiscountPurchases.swift</code>。在<code class="fe nm nn no nb b">DiscountPurchases.swift</code>文件中添加以下代码。斯图尔特想为55岁以上的购买者提供折扣。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c8d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要明确的是，这还不行。我们需要再次调整我们的<code class="fe nm nn no nb b">Engine</code>类的权限。</p><p id="2daf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果他按原样尝试，它将返回另一个访问控制错误。这不是我们想要的，也不是他需要的。将代码更改为如下所示。你需要使<code class="fe nm nn no nb b">purchases</code>类成为一个开放的类。也改变函数<code class="fe nm nn no nb b">calculatePrice</code>的公共访问，因为他也需要访问这个函数。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4d55" class="nf me it nb b gy ng nh l ni nj">open class Purchases {</span></pre><p id="d269" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在再次回到<code class="fe nm nn no nb b">DiscountPurchases</code>类并添加这段代码。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="6b99" class="nf me it nb b gy ng nh l ni nj">override func calculatePrice() -&gt; Double {<br/>  super.calculatePrice() * (1 - discountPercentage / 100)<br/>}</span></pre><p id="44a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在一切都可以编译了。您所需要做的就是在SwiftUI字段中添加一些代码，将它们组合在一起。要测试您将要发布的新框架，请使用下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5f08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我走到了最后。我们已经讨论了这两个项目中所有主要的访问类型。然而，在我离开之前，我想给你指出一个视频的方向，这篇文章的大部分内容都是基于这个视频。你猜对了，我的同事斯图尔特制作了一个视频。这是一个很好的资源，涵盖了您在这里可以找到的相同内容，并提供了更多的细节。你可以在这里找到视频<a class="ae ky" href="https://www.youtube.com/watch?time_continue=9&amp;v=V7B3ZmvV_Us&amp;feature=emb_logo" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>