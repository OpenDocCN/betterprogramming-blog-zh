<html>
<head>
<title>How To Detect Unique Arrays in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中检测唯一数组</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/detecting-unique-arrays-in-javascript-e4e9a7a87542?source=collection_archive---------0-----------------------#2019-12-25">https://betterprogramming.pub/detecting-unique-arrays-in-javascript-e4e9a7a87542?source=collection_archive---------0-----------------------#2019-12-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dd4c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">集合、多种类型的循环等等</h2></div><p id="cb3e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当JavaScript数组包含原始值(字符串、数字、未定义、null、布尔值和符号)时，可能会出现这样的情况，您希望检测数组是否包含任何重复的元素。</p><p id="c200" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，您可能希望确定数组中的元素是否是唯一的。有几种方法可以实现这一点。</p><p id="381f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们仔细看看我们的选择。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="a1bd" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">方法1。嵌套循环</h1><p id="4e49" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在这种方法中，我们将遍历数组，从第一个元素开始，对于每个元素，我们将该元素与所有其他元素进行比较，以查看是否存在匹配。</p><p id="108f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实现这一点，我们将使用两个相互嵌套的<code class="fe mf mg mh mi b">for loops</code>。</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="6cf7" class="mr lj iq mi b gy ms mt l mu mv">function isUnique(arr) {<br/>  const len = arr.length;<br/>  for (let i = 0; i &lt; len; i++) {<br/>    for (let j = 0; j &lt; len; j++) {<br/>      // if the elements match, this wouldn't be a unique array<br/>      if (i !== j &amp;&amp; arr[i] === arr[j]) {<br/>        return false;<br/>      }<br/>    }<br/>  }<br/>  return true;<br/>}</span></pre><p id="c539" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管这种方法对于小型和半小型数据集非常有效，但随着输入数据集的增长，它会变得越来越慢。这种方法的缓慢是因为嵌套循环。</p><p id="2940" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一个有一百万个数字的数据集。在这个数据集中，在最坏的情况下，我们的重复元素可能是数组中的最后一个元素，因此，我们需要将一百万个数字与一百万个数字进行比较(一百万*一百万)，这非常慢。</p><ul class=""><li id="2052" class="mw mx iq kh b ki kj kl km ko my ks mz kw na la nb nc nd ne bi translated"><a class="ae nf" href="https://jsfiddle.net/farskid/bquo7k8x/12/" rel="noopener ugc nofollow" target="_blank">代号</a></li></ul></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="f90c" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">方法2。具有缓存值的单循环</h1><p id="aed2" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在这种方法中，我们不是将每个元素与其他元素进行比较，而是跟踪我们访问的元素，这些元素与重复的元素不匹配。</p><p id="0e2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，我们缓存我们遍历的内容，并查找下一个元素来检查我们是否已经访问过这样的元素。</p><p id="21a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于这个被访问的引用，我们只需要将数组中的每个元素与这个引用进行比较，因此，我们只需要遍历这个数组一次。</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="ad6d" class="mr lj iq mi b gy ms mt l mu mv">function isUnique(arr) {<br/>  const seenValues = {}<br/><br/>  for (let i = 0; i &lt; arr.length; i++) {<br/>    // we already saw this element in the array<br/>    if (seenValues[arr[i]]) {<br/>      return false;<br/>    } else {<br/>      seenValues[arr[i]] = true<br/>    }<br/>  }<br/><br/>  return true;<br/>}</span></pre><p id="21b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在最坏的情况下，数据集中有一百万个数字，我们复制的元素将是最后一个元素，但是在这种方法中，我们只比较一百万次。这种方法比方法1快得多。</p><ul class=""><li id="2254" class="mw mx iq kh b ki kj kl km ko my ks mz kw na la nb nc nd ne bi translated"><a class="ae nf" href="https://jsfiddle.net/farskid/zky1mdug/18/" rel="noopener ugc nofollow" target="_blank">代码</a></li></ul></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="c9fd" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">方法三。使用ES6 S <code class="fe mf mg mh mi b">et</code></h1><p id="b160" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">当ES6出现的时候，我们被介绍了一种新的JavaScript数据结构，叫做<code class="fe mf mg mh mi b">Set</code>。</p><p id="59d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">集合是定义上唯一的元素的集合，这意味着，如果您试图将重复的元素插入到集合中，它不会有任何效果。</p><p id="410a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于根据定义<code class="fe mf mg mh mi b">Set</code> s是唯一元素的集合，所以有一种技术可以将数组转换成集合，这反过来又会产生数组中唯一的项目集合，现在存储在集合中。</p><p id="e180" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，一个相反的操作将被用来把那个<code class="fe mf mg mh mi b">Set</code>转换回一个数组。在某种意义上，你可以说<code class="fe mf mg mh mi b">Set</code>被用作中间数据结构来从数组中移除重复的元素。</p><p id="dc1d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mf mg mh mi b">Array -&gt; Set -&gt; Array</code></p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="bd26" class="mr lj iq mi b gy ms mt l mu mv">// convert an array to a set and convert back<br/>function getUniqueArray(arr) {<br/>  return [...new Set(arr)]<br/>}<br/><br/>function isUnique(arr) {<br/>  return getUniqueArray(arr).length === arr.length<br/>}</span></pre><p id="4f14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种方法中，如果唯一数组(从<code class="fe mf mg mh mi b">Set</code>转换回来)中的元素数量与输入数组长度相同，这意味着该数组已经包含唯一值，并且没有从其中删除重复值来改变长度。</p><p id="346a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:如果你只是想检查唯一性，你不需要将一个<code class="fe mf mg mh mi b">Set</code>转换回一个数组。您可以通过勾选<code class="fe mf mg mh mi b">Set.prototype.size</code>来完全跳过这部分操作。</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="8310" class="mr lj iq mi b gy ms mt l mu mv">// convert an array to a set<br/>function arrayToSet(arr) {<br/>  return new Set(arr)<br/>}<br/><br/>function isUnique(arr) {<br/>  return arrayToSet(arr).size === arr.length<br/>}</span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="295d" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">性能比较</h1><p id="edf1" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">只要数据集相对较小，交替使用这三种方法都可以。对于较大的数据集，您需要关注这些方法的性能，以及它们在有限的时间内可以执行多少操作。</p><p id="35c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这三者之间性能比较的简短答案是:</p><p id="436b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mf mg mh mi b">Approach 2 &gt; Approach 3 &gt; Approach 1</code>。</p><p id="94c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方法2(使用带有缓存值的单循环)比其他方法快得多。在方法3 ( <code class="fe mf mg mh mi b">Set</code>)和方法1(嵌套循环)之间，方法3也快得多。</p><p id="78cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更好地理解这些性能比较，请看一下基准测试:</p><div class="ng nh gp gr ni nj"><a href="https://esbench.com/bench/5e0273c1170166009e5470f7" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">ESBench</h2><div class="nq l"><p class="bd b dl z fp no fr fs np fu fw dk translated">esbench.com三种方法的基准</p></div></div></div></a></div></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="5190" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">好奇者请注意</h1><ul class=""><li id="e2ad" class="mw mx iq kh b ki ma kl mb ko nr ks ns kw nt la nb nc nd ne bi translated">方法1(使用嵌套循环)具有二次复杂度，这意味着它将导致O(n2)时间复杂度。</li><li id="8f54" class="mw mx iq kh b ki nu kl nv ko nw ks nx kw ny la nb nc nd ne bi translated">方法2(使用单个循环和缓存值)是线性复杂度，这意味着它将导致O(n)时间复杂度。</li><li id="d490" class="mw mx iq kh b ki nu kl nv ko nw ks nx kw ny la nb nc nd ne bi translated">对于方法3，我没有强烈的意见，因为我并不完全了解如何在JavaScript引擎中实现<code class="fe mf mg mh mi b">Set</code>。</li></ul></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="c927" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">给不耐烦的人的结论</h1><p id="dc86" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">不要为你没有的问题预先优化。只有当你有一个大的数据集带来表面的缓慢时，性能优化才有意义。</p><p id="f3e1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于相对较小的数据集，您采用哪种方法并不重要，因为所有方法都足够快。对于较大的数据集，总是倾向于使用方法2，因为基准测试表明它明显更快。</p><figure class="mj mk ml mm gt oa gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi nz"><img src="../Images/1c1a7122f990cbdb014e51a14b63ba37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i6hudSinohkEHBiL.png"/></div></div></figure></div></div>    
</body>
</html>