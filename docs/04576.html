<html>
<head>
<title>Testing in Python: Dependency Injection vs. Mocking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的测试:依赖注入与模仿</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/testing-in-python-dependency-injection-vs-mocking-5e542783cb20?source=collection_archive---------11-----------------------#2020-04-22">https://betterprogramming.pub/testing-in-python-dependency-injection-vs-mocking-5e542783cb20?source=collection_archive---------11-----------------------#2020-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f49b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">什么时候应该使用依赖注入？什么时候应该使用嘲讽？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e9e477f7f61c8215181831e8831466c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*45-3UO529G5czUB7"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@helloquence?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">hello queue</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="2a97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢Python的一点是它的测试工具。当您需要模拟与外部依赖项的交互时，您可以选择:</p><ul class=""><li id="8804" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">使用依赖注入用测试double替换依赖。</li><li id="7fad" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用Python的<code class="fe mg mh mi mj b"><a class="ae kv" href="https://mock.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">mock</a></code>库劫持实际的函数调用。</li><li id="b38c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">用模拟响应对一个假服务器进行测试。</li></ul><p id="e03c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了所有这些可用的测试策略，可能不清楚使用哪种策略。在本文中，我将讨论什么时候选择模拟而不是依赖注入是有意义的，反之亦然。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="08c8" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">代码</h1><p id="c070" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">让我们看一些代码来说明模仿和依赖注入之间的区别。假设我正在测试调用<code class="fe mg mh mi mj b">Inventory</code>服务的代码。<code class="fe mg mh mi mj b">Inventory</code>服务跟踪用户持有的物品。这是我们用来与<code class="fe mg mh mi mj b">Inventory</code>服务交互的客户端:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="01d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试中的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="064f" class="nq ms iq bd mt nr ns dn mx nt nu dp nb lf nv nw nd lj nx ny nf ln nz oa nh ob bi translated">使用模拟方法的有效测试</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c153" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这不是关于如何使用<code class="fe mg mh mi mj b">mock</code>库的教程，但是我将遍历代码来建立上下文:</p><ul class=""><li id="ed0a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">我们不想调用<code class="fe mg mh mi mj b">Inventory</code>服务，所以我们修补了<code class="fe mg mh mi mj b">get_items</code>和<code class="fe mg mh mi mj b">add_item</code>函数。</li><li id="ec00" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们已经将对<code class="fe mg mh mi mj b">Inventory</code>服务的调用的返回值设置为我们期望它返回的值。</li></ul><h2 id="a228" class="nq ms iq bd mt nr ns dn mx nt nu dp nb lf nv nw nd lj nx ny nf ln nz oa nh ob bi translated">使用依赖注入的有效测试</h2><p id="9021" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">在使用依赖注入之前，我们需要建立一个生产/测试环境，以及一种选择在每个环境中运行的代码的方法。让我们改变我们的客户:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="01e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oc">免责声明:这段代码足以说明概念。生产代码库需要更复杂的设置。</em></p><p id="ce82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们定义了两个具体的类。如果我们不在<code class="fe mg mh mi mj b">prod</code>环境中，我们将使用在内存中保存数据的<code class="fe mg mh mi mj b">InventoryMock</code>类。不再需要使用<code class="fe mg mh mi mj b">mock</code>库。我们的新测试看起来像:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="d8c6" class="mr ms iq bd mt mu od mw mx my oe na nb jw of jx nd jz og ka nf kc oh kd nh ni bi translated">我应该用什么？</h1><p id="4b42" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">这两种策略都使我们能够在不调用<code class="fe mg mh mi mj b">Inventory</code>服务的情况下测试代码。在选择最合适的策略时，我会考虑以下几点:</p><h2 id="aefa" class="nq ms iq bd mt nr ns dn mx nt nu dp nb lf nv nw nd lj nx ny nf ln nz oa nh ob bi translated">范围/成本</h2><p id="46fa" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">根据代码的状态，一种策略会比另一种更便宜。如果您需要模拟一些用例，修补函数可能比创建模拟类更容易/更快。如果您的代码库已经有了支持依赖注入的基础设施和工具，那么编写一个简单的模拟类可能比打补丁更简单。</p><p id="cb8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还应该考虑您采用的方法的未来后果。如果你所模仿的交互会发生变化，那么考虑选择修改最快的方法。</p><h2 id="2168" class="nq ms iq bd mt nr ns dn mx nt nu dp nb lf nv nw nd lj nx ny nf ln nz oa nh ob bi translated">规模经济</h2><p id="cd72" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">依赖注入是扩展嘲讽方法的一种方式。如果许多用例依赖于您想要模仿的交互，那么投资依赖注入是有意义的。容易进行依赖注入的系统:</p><ul class=""><li id="4cb7" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">认证/授权服务。</li><li id="5bb1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">负责分布式跟踪和跟踪指标的日志记录解决方案。</li><li id="a717" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">常用的基础设施，如缓存和消息代理。</li></ul><p id="a305" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些系统通常在整个代码库中使用:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/992c87fd835ccb80d9d8c7aeb694fddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KzAMP5D4iSNP-QM9kiq2hQ.png"/></div></div></figure><p id="24d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是依赖注入的闪光点——必须修补每个交互将是一件痛苦的事情。如果所讨论的系统跨多个存储库使用，那么您可以更进一步，将依赖注入类正式化为客户端库。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="750f" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">结束语</h1><p id="eb56" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">依赖注入和模仿都是值得称赞的测试外部依赖的方法。依赖注入需要更多的工作来设置，但是它非常适合高频率的使用。模仿/修补方法快速/简单，但是随着依赖使用的增加/变化，它开始变成技术债务。还有几件事要记住:</p><ul class=""><li id="750c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">一致性:如果代码使用依赖注入(或补丁)来模拟交互，那么没有理由偏离，除非有重大优势。</li><li id="9a38" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">能力:如果工程师精通Python的<code class="fe mg mh mi mj b">mock</code>库，但没有使用面向对象风格的依赖注入的经验(反之亦然)，迁移到依赖注入的数量上的好处可能不会超过质量上的伤害。</li></ul></div></div>    
</body>
</html>