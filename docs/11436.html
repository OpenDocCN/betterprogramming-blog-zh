<html>
<head>
<title>How to Sort a 20G File in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Rust中对20G文件进行排序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-sort-a-20g-file-in-rust-12abfffbd92b?source=collection_archive---------2-----------------------#2022-03-20">https://betterprogramming.pub/how-to-sort-a-20g-file-in-rust-12abfffbd92b?source=collection_archive---------2-----------------------#2022-03-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ed1b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">并且知道如何处理文件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/63397820e3b0a9b13700a6fefb298ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fttqmqpq6DKNX7nJlAGgPw.png"/></div></div></figure><p id="3402" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如何对与内存不匹配的文件进行排序的问题已经有了一个标准的解决方案，叫做“外部排序”。</p><p id="a5f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个故事是关于如何用Rust实现这样一个外部排序算法的一些细节。</p><p id="fa1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管已经有一些现成的解决这个问题的方法，但是从实现的角度来看，这是非常有趣的，因为它涉及到标准文件处理中的许多重要概念。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="f0b3" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">该算法</h1><p id="7218" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">让我们快速回顾一下外部排序是如何工作的。标准排序算法的实现需要将目标列表保存在内存中。</p><p id="3cc2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果可用内存不够大，我们首先将列表分成更小的部分来读取，以适合内存。通过使用某种排序算法对每个部分进行排序，并随后将其写入专用于该部分的文件。这给我们留下了许多文件，每个文件都包含一个排序列表，并且每个文件都可以放在内存中。</p><p id="8015" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们将一个可读的流放到每个文件中，并总是选择最小的元素写入一个“大”的结果文件。如果您不熟悉这种合并策略，稍后您将很容易从代码中理解细节。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="c14e" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">产生测试数据</h1><p id="b3f0" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">为了有一个大约20G大小的大文件，我们将逻辑回归的第一个<code class="fe mu mv mw mx b">n</code>迭代写在其混乱区域内:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="b6fe" class="nc ly it mx b gy nd ne l nf ng">x_n+1 = r * x_n * (1 - x_n )</span></pre><p id="4429" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这非常适合，因为它会产生大量不重复的数据。</p><p id="c9fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该序列的<code class="fe mu mv mw mx b"><a class="ae nh" href="https://applied-math-coding.medium.com/an-introduction-into-rust-part-11-iterators-1985d077aa0a" rel="noopener">Iterator</a></code>是这样实现的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="cb77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Rust中，人们可以通过简单的操作在文件中创建一个可写的流，</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="6a68" class="nc ly it mx b gy nd ne l nf ng">use std::fs::{remove_file, File};</span><span id="e449" class="nc ly it mx b gy nk ne l nf ng">let mut file = <strong class="mx iu">File::create</strong>("filename").unwrap();</span></pre><p id="d679" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们可以开始一行一行地写，</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="65da" class="nc ly it mx b gy nd ne l nf ng">let mut logistic = Logistic(0.35);</span><span id="70d3" class="nc ly it mx b gy nk ne l nf ng">...</span><span id="b25c" class="nc ly it mx b gy nk ne l nf ng"><strong class="mx iu">writeln!</strong>(file, "{}", logistic.next().unwrap());</span></pre><p id="d98a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种方法适用于少量的数据，但是在我们的例子中，这可能需要很长时间。逐行写入文件是一种非常低效的I/O操作。</p><p id="d28a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于这个原因，我们首先在内存中缓冲尽可能多的写操作，当这个缓冲溢出时，它在一个I/O操作中被写入文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0d36" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个想法是用一个<code class="fe mu mv mw mx b">BufWriter::with_capacity</code>包裹<code class="fe mu mv mw mx b">File</code>。在这里，我们可以指定在实际写入文件之前应该缓冲多少字节。</p><p id="9a28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用这种缓冲时调用<code class="fe mu mv mw mx b">file.flush().unwrap()</code>也很重要。这确保了在缓冲区被丢弃之前，所有数据都从缓冲区写入文件。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="687f" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">外部排序</h1><p id="fe84" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">该算法的核心方法如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d5c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们从生成的大文件中读取适合内存的部分。为了打开文件以获得可读的流，</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="e99d" class="nc ly it mx b gy nd ne l nf ng">let file = File::open('filename').unwrap();</span></pre><p id="dee6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是同样，逐行读取会导致非常低效的I/O操作。因此，我们再次使用缓冲技巧，但这次正好相反:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="e634" class="nc ly it mx b gy nd ne l nf ng">let file = <strong class="mx iu">BufReader::with_capacity</strong>(<br/>  10_000_000, File::open(filename).unwrap()<br/>);</span></pre><p id="22c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将文件逐行缓冲读取到一个向量中。我们这样做，直到使用了一定量的内存<code class="fe mu mv mw mx b">max_mem_use</code>，然后通过调用<code class="fe mu mv mw mx b">sort_and_write_to_file</code>对列表的这一部分进行排序。为了方便起见，这个方法还将排序后的部分写入一个临时文件。</p><p id="7c5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里使用的排序只是Rust在<code class="fe mu mv mw mx b">Vec</code>上的标准排序方法(当时是一种类似合并排序的算法):</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="1ddb" class="nc ly it mx b gy nd ne l nf ng">v.<strong class="mx iu">sort_by</strong>(|a, b| a.<strong class="mx iu">partial_cmp</strong>(b).unwrap());</span></pre><p id="ba13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要使用<code class="fe mu mv mw mx b">partial_cmp</code>，因为在<code class="fe mu mv mw mx b">f64</code>类型的数据上只实现了<code class="fe mu mv mw mx b">PartialOrd</code>特征(而不是<code class="fe mu mv mw mx b">Ord</code>)。</p><p id="c8e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">依然有趣的是方法<code class="fe mu mv mw mx b">merge</code>。这里，缓冲的可读流被放到每个临时数据文件中，然后它们被逐行读取(缓冲)并相互比较。最小值被写入(缓冲)到结果文件中。我们只读取给定流中的下一行，以防其值是最低的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="96df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">active_readers</code>是一个向量，保存所有缓冲的可读流到所有临时数据文件上的<code class="fe mu mv mw mx b">Line</code>-迭代器(<code class="fe mu mv mw mx b">tmp_file_names</code>)。然后创建一个名为<code class="fe mu mv mw mx b">value</code>的向量，它最初保存每个临时文件的第一行。我们反复搜索<code class="fe mu mv mw mx b">values</code>中的最小值，并将后者写入结果文件:<code class="fe mu mv mw mx b">writeln!(file, “{}”, min_val);</code></p><p id="e310" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，我们用对应的临时文件的下一行替换对应的索引<code class="fe mu mv mw mx b">values</code>，如果它还没有到达e of。</p><p id="e0b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样，我们确保在一个“大”的结果文件中产生一个升序排序的列表。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="c0df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了方便起见，让我粘贴我用来生成和排序一个近20G文件的全部代码。为了在您的系统上运行，您可能需要调整系统内存中的全局变量<code class="fe mu mv mw mx b">BUFFER_CAPACITY</code>和<code class="fe mu mv mw mx b">MAX_MEM_USE</code>。但是请注意，根据这些设置，这可能会产生大量临时文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="8ff9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读！</p></div></div>    
</body>
</html>