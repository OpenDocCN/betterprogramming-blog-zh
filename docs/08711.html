<html>
<head>
<title>A Deep Dive Into Method Dispatches in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解Swift中的方法调度</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-deep-dive-into-method-dispatches-in-swift-65a8e408a7d0?source=collection_archive---------3-----------------------#2021-06-03">https://betterprogramming.pub/a-deep-dive-into-method-dispatches-in-swift-65a8e408a7d0?source=collection_archive---------3-----------------------#2021-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dbbe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">静态、垂直表和消息调度</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7af0c1ff7494b073288404505f43b80a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fim_xlWpQjSBxhNp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@ourselp?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Philippe Oursel </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="873f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想知道Swift中的方法调用是如何工作的吗？看起来很简单，你定义了方法，在运行时，方法调用神奇地工作了，即使有很多事情要处理，比如继承导致的重写方法，方法调用优化等等。</p><p id="b99f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇短文中，我们将了解Swift中可用的不同类型的方法分派。在讨论分派时，我们还将讨论编译器和运行时为了实际处理方法调用而进行的一些优化。</p><p id="9a68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们开始吧。</p><h1 id="6630" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是方法调度？</h1><p id="7920" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">方法分派是在编程语言中管理函数调用的过程。</p><p id="4235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着解释一下当你调用一个方法时会发生什么。编译器如何知道方法在哪里？当你有多个子类时，编译器如何知道调用哪个方法？毫不奇怪，所有这些都在编译时和运行时得到了解决。</p><p id="b8b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对类类型或值类型中定义的每个方法的调用可以通过三种方式解决:</p><ol class=""><li id="0bfe" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">静态调度</li><li id="3484" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">虚拟表调度</li><li id="3c3a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">信息发送</li></ol></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="b035" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">1.静态调度</h1><p id="cff4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果一个方法不能被重写，则该方法是静态调度的。</p><p id="f219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种类型的方法调度是所有调度中最简单和最快的。其速度之所以如此之快，是因为给定函数不能被覆盖，这意味着该方法只有一个实现会在运行时存储在内存中的某个位置。运行时可以直接跳转到那个内存地址并执行它(不像您将看到的其他调度)。</p><p id="9db2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您始终可以使用以下关键字指定使用静态分派的方法:</p><ul class=""><li id="c525" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu ns my mz na bi translated"><code class="fe nt nu nv nw b">static</code></li><li id="8ad9" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ns my mz na bi translated"><code class="fe nt nu nv nw b">final</code></li></ul><p id="aff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，这也是在值类型中声明的函数的默认调度方法，因为根据定义，值类型不能被重写。</p><h1 id="7cce" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.虚拟表调度</h1><p id="c295" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是Swift中用于参考类型的默认分派方法。</p><p id="9cfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种方法中，在编译时创建一个查找表，指定需要在运行时调用的方法的实际实现。在运行时，这个查找表作为一个地址数组保存在内存中实现所在的实际位置。</p><p id="39b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种分派成为引用类型的默认分派方法的原因是，类需要支持继承。V表通过生成对重写方法和非重写方法的正确调用来帮助继承类。</p><p id="eecf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果您有一个类似下面的设置，运行时会计算出何时需要调用<code class="fe nt nu nv nw b">ChildClass</code>类而不是<code class="fe nt nu nv nw b">SuperClass</code>类中的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="d2c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个问题显然是运行时如何确定调用哪个方法？</p><p id="2b24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事情是这样的，类的方法实现存储在一个名为<em class="nz">调度表</em>的数组中(也称为<code class="fe nt nu nv nw b">vtable</code>或<code class="fe nt nu nv nw b">witness</code>表，稍后会详细介绍)。</p><p id="279a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个类，即<code class="fe nt nu nv nw b">ChildClass</code>和<code class="fe nt nu nv nw b">SuperClass</code>，都有自己的表，这些表包含指向实际方法实现的指针。</p><p id="f392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">V表是在编译时在<a class="ae ky" href="https://github.com/apple/swift/blob/main/docs/SIL.rst#vtables" rel="noopener ugc nofollow" target="_blank"> SIL </a> (Swift中间语言)生成期间计算的，需要调用的实际方法实现是在运行时计算出来的。基本上，您可以将V-Table视为一个表查找，它为实际的函数实现分配一个惟一的标识符。在为子类生成的表中也提供了每个超类实现，因此本质上只有一个额外的操作需要在运行时执行，即在运行时从V表中计算出当调用该方法时需要调用该方法的哪个实现。</p><p id="403b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面先睹为快，看看SIL生成的V-Table看起来像上面的代码片段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4395" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面生成的代码中可以看到，<code class="fe nt nu nv nw b">ChildClass</code>和<code class="fe nt nu nv nw b">SuperClass</code>在它们的V表中都声明了所有可用的方法。</p><p id="f6c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还要注意，对于两个类的<code class="fe nt nu nv nw b">nonOverriddenMethod</code>,方法标识符(类似于出现在每行末尾的<code class="fe nt nu nv nw b">@$SilGen10SuperClass…</code>的字符串)是相同的(因为<code class="fe nt nu nv nw b">ChildClass</code>没有覆盖它),但是对于<code class="fe nt nu nv nw b">overrideMethod</code>声明是不同的(因为它们有不同的实现)。</p><p id="79c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想进一步了解实际调用是如何发生的，您可以使用以下命令生成SIL:</p><pre class="kj kk kl km gt oa nw ob oc aw od bi"><span id="fdac" class="oe lw it nw b gy of og l oh oi">swiftc -emit-silgen -O &lt;swift-file-name&gt;.swift</span></pre><p id="afa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将发现更多关于SIL生成的代码在调用站点实际使用的信息。</p><h1 id="62b9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.信息发送</h1><p id="cba0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是一个有趣的方法，尽管它可能会导致一些性能下降，所以了解何时使用它很重要！在前面的部分中，我们看到了如何使用V-Table分派来推迟决定需要在运行时调用方法的哪个实现，但是我们还有另一个问题。为了理解这个问题，我们需要追溯历史。</p><h2 id="d2d8" class="oe lw it bd lx oj ok dn mb ol om dp mf li on oo mh lm op oq mj lq or os ml ot bi translated">很久很久以前…</h2><p id="8fc9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Objective-C是一种非常依赖于运行时的语言。我这样说是什么意思？</p><p id="c7d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着Objective-C为我们提供了在运行时执行大量代码检查和更改代码实现的能力。</p><p id="9f98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种语言通常将其许多任务推迟到运行时，这样可以加快编译速度。</p><p id="8897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在运行时支持许多功能，例如:</p><ul class=""><li id="d1c7" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu ns my mz na bi translated">使用一个名为<code class="fe nt nu nv nw b">isMemberOfClass</code>的函数检查一个实例是否属于一个特定类型的类。或者如果您想检查它是否属于继承层次中的某个特定类，您可以使用<code class="fe nt nu nv nw b">isKindOfClass</code>。</li><li id="fc7b" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ns my mz na bi translated">使用一个叫做<code class="fe nt nu nv nw b">respondsToSelector</code>的函数检查一个类是否能响应一个特定的方法</li><li id="24a0" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ns my mz na bi translated">使用所谓的<em class="nz">方法重组</em>在运行时动态改变方法实现</li><li id="bc25" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ns my mz na bi translated">使用<code class="fe nt nu nv nw b">class_addMethod</code>在运行时添加方法实现</li></ul><p id="c4f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有很多。所有这些都要归功于一个名为Objective-C运行时库的库，它嵌入在<code class="fe nt nu nv nw b">NSObject</code>使用的Objective-C中。鉴于Objective-C中的几乎每个类都必须从这个类继承，这些功能几乎在任何地方都可用。</p><p id="8fa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们知道了Objective-C是一种非常灵活的运行时语言，你可以改变方法实现，添加方法实现等等。，都是在运行时。这可能会对V表分派的方式造成问题，因为V表是在编译时生成的。编译时生成的V-Table可能不代表需要调用的方法的正确实现，因为它可能已经被重新整理过，或者可能已经在运行时添加了新方法。</p><p id="4ba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">消息分派是对上述问题的解决方案，其中在运行时维护不同的表。在实际调用过程中，运行时在这个表上进行查找，以找出进行调用的实际方法地址。</p><p id="54ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用动态分派的方法不包括在编译时生成的V表中，因为由于Objective-C的运行时功能，这些方法在运行时可能会被替换。</p><p id="6be1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于所有需要动态调度的成员，这是Objective-C中的默认调度方法。</p><h2 id="4b34" class="oe lw it bd lx oj ok dn mb ol om dp mf li on oo mh lm op oq mj lq or os ml ot bi translated"><code class="fe nt nu nv nw b">dynamic</code>和<code class="fe nt nu nv nw b">@objc</code></h2><p id="77f6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这一节从更深的意义上探讨SIL生成的代码。这里提供的唯一理论如下:<code class="fe nt nu nv nw b">dynamic</code>关键字在Swift中用于为需要它的方法启用动态分派(例如，在方法切换或KVO相关代码中),而<code class="fe nt nu nv nw b">@objc</code>用于将该方法公开给Objective-C</p><p id="58de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Swift 3之前，所有动态成员都自动暴露给Objective-C，但从Swift 4开始，您必须在需要暴露给动态调度的方法前面明确提到<code class="fe nt nu nv nw b">dynamic</code>和<code class="fe nt nu nv nw b">@objc</code>。</p><p id="156c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Swift中，需要用作<code class="fe nt nu nv nw b">selector</code>对象的方法必须用<code class="fe nt nu nv nw b">@objc</code>来声明，因为这些方法仍然需要向Objective-C公开。这里使用的目标动作机制仍然是用Objective-C编写的</p><p id="72cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，当您向代码中创建的<code class="fe nt nu nv nw b">UIBarButton</code>添加通知观察器或方法时(使用<a class="ae ky" href="https://www.notion.so/Target-Action-Selector-239ebc1b81004f1c8a11d60478f77718" rel="noopener ugc nofollow" target="_blank">目标动作</a>机制，等等)。)这些方法使用Obj-C的运行时功能来调用这些方法。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="2053" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从现在开始，这将是对SIL生成的代码的一个小小的探索，而且不会很好看。让我们以一个简单的类为例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="832a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此类生成的垂直表如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="34f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">V表不包含对<code class="fe nt nu nv nw b">dynamicMethod</code>的声明，因为它附加了<code class="fe nt nu nv nw b">dynamic</code>关键字。</p><p id="02f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SIL还为每种方法生成两个版本。一个是Objective-C(第10行和第33行)，一个是Swift中的实际实现(第2行和第24行)。Objective-C公开的方法反过来调用Swift实现本身，这是当您向Objective-C公开一个方法时发生的运行时开销。</p><p id="d81f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是SIL生成的函数实现代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4ad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在呼叫站点，SIL看起来如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您看过去第23行，在那里生成了对<code class="fe nt nu nv nw b">dynamicMethod</code>的调用，您可以看到一个名为<code class="fe nt nu nv nw b">foreign</code>的新关键字，它在调用<code class="fe nt nu nv nw b">objcMethod</code>的第18行没有出现。该关键字表示现在方法实现调用不再由Swift V-Table处理，而是由其他系统处理。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="038d" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">结论</h1><p id="130b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">总而言之，我希望您从这篇文章中学到的是三种类型的派遣以及与它们相关的权衡。</p><p id="4329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果阅读本文的目的只是为面试做准备或只是为了理解理论，那么进入SIL可能是没有必要的，尽管SIL生成的代码可以进行完全不同的技术内省，最好通过在您的系统上实际生成该代码来完成。</p><h1 id="6d05" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">有用的链接</h1><p id="d057" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这里是我在学习方法分派时浏览的一些链接。</p><ul class=""><li id="c5b7" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu ns my mz na bi translated"><a class="ae ky" href="https://www.rightpoint.com/rplabs/switch-method-dispatch-table" rel="noopener ugc nofollow" target="_blank">Method Dispatches in Swift—right point</a>(这可能有点过时，但这里的理论仍然有效。)</li><li id="a116" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ns my mz na bi translated"><a class="ae ky" href="https://swiftunboxed.com/interop/objc-dynamic/" rel="noopener ugc nofollow" target="_blank"> @objc和动态SIL演练— Swift拆箱</a></li><li id="6ab4" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ns my mz na bi translated"><a class="ae ky" href="https://developer.apple.com/swift/blog/?id=27" rel="noopener ugc nofollow" target="_blank">减少动态调度——苹果Swift博客</a></li></ul></div></div>    
</body>
</html>