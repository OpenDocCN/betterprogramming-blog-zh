<html>
<head>
<title>Mastering Angular Structural Directives</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握角度结构指令</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mastering-in-angular-structural-directives-b089186136ef?source=collection_archive---------2-----------------------#2022-01-03">https://betterprogramming.pub/mastering-in-angular-structural-directives-b089186136ef?source=collection_archive---------2-----------------------#2022-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="796f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建3个不同的结构指令来掌握这个想法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4f88bbd42f8257ec7aace1c10f851780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NhramL70X7CJZgYnUWJ-xA.png"/></div></div></figure><p id="4abd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们开始学习Angular时，我们知道有两种类型的指令:属性指令和结构指令。这里我们将只关注<em class="ln">结构指令</em>。嗯，结构指令允许我们修改元素的DOM树，而不仅仅是元素本身(就像属性指令一样)。这包括能够删除一个元素并用其他元素替换它，创建其他元素，等等。</p><p id="de7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你已经知道的，我们需要在代码中区分<em class="ln">结构</em>指令和<em class="ln">属性</em>指令:当我们应用<em class="ln">结构</em>指令时，它应该以<code class="fe lo lp lq lr b">*</code> : <code class="fe lo lp lq lr b">*ngFor</code>，<code class="fe lo lp lq lr b">*ngIf</code>开始。实际上，当我第一次读到这个的时候，这种区分似乎有点奇怪，甚至有点麻烦。让我们试着找出，为什么我们需要把这个<code class="fe lo lp lq lr b">*</code>放在结构指令中，它是有意义的。</p><p id="a2ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过这篇文章，我们将实现三个不同的结构指令，帮助你掌握它的主要思想。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ce4e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">什么是ng-template？</strong></h1><p id="8271" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">在我们进一步讨论之前，我们需要达成共识，理解什么是<code class="fe lo lp lq lr b">ng-template</code>。让我们用这个元素开发一个简单的组件，看看Angular实际呈现的是什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/02e168cefda2a2ef1c78fcec00826708.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l6LM11_TA8gbBqAVNrMyVw.png"/></div></div></figure><p id="0b9b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你可以在组件模板中看到的，我们在<code class="fe lo lp lq lr b">ng-template</code>中定义了<code class="fe lo lp lq lr b">span</code>元素。但是我们在浏览器中看不到这个<code class="fe lo lp lq lr b">span</code>。看起来很没用，不是吗？稍微等等，当然有用，有目的的退出。</p><h1 id="66cb" class="lz ma iq bd mb mc mx me mf mg my mi mj jw mz jx ml jz na ka mn kc nb kd mp mq bi translated"><strong class="ak">什么是ng-container？</strong></h1><p id="dafe" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">同样，让我们通过一个组件创建来发现它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/6964a7c705b76c19312cb1c52f8715d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lrQ8NRlvyX-gvaBWXRnSw.png"/></div></div></figure><p id="09bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们看到了放入<code class="fe lo lp lq lr b">ng-container</code>的内容，但是容器本身是不可见的。如果您熟悉React，您可能会认出与<code class="fe lo lp lq lr b">React.Fragment</code>或其简写方式<code class="fe lo lp lq lr b">&lt;&gt;&lt;/&gt;</code>类似的行为</p><h1 id="2af4" class="lz ma iq bd mb mc mx me mf mg my mi mj jw mz jx ml jz na ka mn kc nb kd mp mq bi translated">将ng容器和ng模板绑定在一起</h1><p id="1226" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">实际上，我们可以要求Angular显式地呈现我们放在<code class="fe lo lp lq lr b">ng-template</code> <strong class="kt ir">中的内容</strong>。为此，我们需要完成以下步骤:</p><ul class=""><li id="87de" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm ni nj nk nl bi translated"><strong class="kt ir">第一步</strong>:获取组件中<code class="fe lo lp lq lr b">ng-template</code>的引用；</li><li id="1a83" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated"><strong class="kt ir">步骤2 </strong>:获取一个容器(任何DOM元素)的引用，我们希望在这个容器中呈现<code class="fe lo lp lq lr b">ng-template</code>的内容</li><li id="db5d" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated"><strong class="kt ir">步骤3 </strong>:以编程方式呈现容器中的内容。</li></ul><h2 id="34c9" class="nr ma iq bd mb ns nt dn mf nu nv dp mj la nw nx ml le ny nz mn li oa ob mp oc bi translated">第一步:</h2><p id="c5c5" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">让我们首先定义一个对<code class="fe lo lp lq lr b">ng-template</code>元素的模板引用，并在组件中访问它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/1980bbdad6fd642468c1e63a52ab96fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HwEh00CMwXxMnAHPAL7f_w.png"/></div></div></figure><p id="2cc1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们为<code class="fe lo lp lq lr b">ng-template</code>元素定义了一个模板引用<code class="fe lo lp lq lr b">#template</code>，并使用<code class="fe lo lp lq lr b">ViewChild</code>装饰器来访问它。请注意，我们在这里要求得到<code class="fe lo lp lq lr b">TemplateRef</code>(你也可以用这个来要求:<code class="fe lo lp lq lr b">@Input('template', { read: TemplateRef }) template: TemplateRef&lt;any&gt;</code>)。</p><h2 id="506f" class="nr ma iq bd mb ns nt dn mf nu nv dp mj la nw nx ml le ny nz mn li oa ob mp oc bi translated">第二步:</h2><p id="bda3" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">让我们在模板中定义一个容器，我们希望在其中呈现预定义的模板，并在组件中访问它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/b1ba0e98d079df4b4084f9ac8bbd32a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oEthRXulEqa4IzksE5WozA.png"/></div></div></figure><p id="a023" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">几乎与我们在上一步中所做的一样:定义了一个对<code class="fe lo lp lq lr b">ng-container</code>元素的模板引用<code class="fe lo lp lq lr b">#container</code>，并使用<code class="fe lo lp lq lr b">ViewChild</code> decorator访问它，但是在这种情况下，我们希望将它读为<code class="fe lo lp lq lr b">ViewContainerRef</code>。请注意，对于容器，我们可以使用任何DOM元素，不仅仅是<code class="fe lo lp lq lr b">ng-container</code>，但是它保持了我们布局的整洁，因为Angular没有在布局中留下任何来自<code class="fe lo lp lq lr b">ng-container</code>的脚。</p><h2 id="4a56" class="nr ma iq bd mb ns nt dn mf nu nv dp mj la nw nx ml le ny nz mn li oa ob mp oc bi translated">第三步:</h2><p id="9e6d" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated"><code class="fe lo lp lq lr b">container</code>和<code class="fe lo lp lq lr b">template</code>将只在<code class="fe lo lp lq lr b">ngAfterViewInit</code>生命周期中可用，我们需要在容器中呈现一个模板:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/0e296573542df950b47cffd120aabd51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ioeumvOod6sgSXIc7H5vaQ.png"/></div></div></figure><p id="249d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们刚刚从给定的模板创建了一个视图，并将其插入到容器中。这种情况下的最终结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/cd0eaba5c241723083f6b284ccea50e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8yp_tOlVrqBrrdimwoQ9_A.png"/></div></div></figure><h1 id="8769" class="lz ma iq bd mb mc mx me mf mg my mi mj jw mz jx ml jz na ka mn kc nb kd mp mq bi translated"><strong class="ak">结构指令</strong></h1><p id="1058" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">你可能会问，为什么我不先解释结构指令，而是从<code class="fe lo lp lq lr b">ng-template</code>和<code class="fe lo lp lq lr b">ng-container</code>开始。但是需要解释为什么我们把<code class="fe lo lp lq lr b">*</code>放在这些指令之前。答案是Angular一看到<code class="fe lo lp lq lr b">*</code>它就以不同的方式对待我们的模板，并创建一些额外的元素:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/18cd74ef021d605edaf1a9564536153e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OKHxgSUGq2Wc0jjavE7esw.png"/></div></div></figure><p id="489a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Angular将我们的模板包装在<code class="fe lo lp lq lr b">ng-template</code>元素(1)中。这意味着如果没有对<code class="fe lo lp lq lr b">ngFor</code>指令的任何实现，我们将什么也看不到。此外，Angular还创建了一个占位符空间，称为<em class="ln">嵌入式视图</em>，其中的指令可以决定在这个空视图容器(2)中插入什么，例如，像我们上面所做的那样，在特定的时间插入<code class="fe lo lp lq lr b">ng-template</code>的内容。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e4b6" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">示例1:自定义ngIf指令。</h1><p id="6270" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">让我们想象Angular没有像<code class="fe lo lp lq lr b">ngIf</code>那样的内置指令，我们需要开发自己的名称为<code class="fe lo lp lq lr b">customIf</code>的指令。</p><p id="1eab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们使用Angular CLI创建它:</p><pre class="kg kh ki kj gt oi lr oj ok aw ol bi"><span id="ae89" class="nr ma iq lr b gy om on l oo op">ng g d directives/custom-if</span></pre><p id="5fcf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe lo lp lq lr b">directives</code>文件夹下创建<code class="fe lo lp lq lr b">custom-if.directive.ts</code>文件，并自动在<code class="fe lo lp lq lr b">AppModule</code>中声明；</p><pre class="kg kh ki kj gt oi lr oj ok aw ol bi"><span id="17a9" class="nr ma iq lr b gy om on l oo op">@Directive({<br/>   selector: '[appCustomIf]'<br/>})<br/>export class CustomIfDirective {<br/>   constructor() { }<br/>}</span></pre><p id="4916" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于Angular在幕后做了一些工作——用<code class="fe lo lp lq lr b">ng-template</code>包装我们的模板并创建一个占位符，我们可以在那里放置任何内容，我们可以要求Angular在构造函数中提供对这些元素的访问:</p><pre class="kg kh ki kj gt oi lr oj ok aw ol bi"><span id="1837" class="nr ma iq lr b gy om on l oo op">@Directive({<br/>   selector: '[appCustomIf]'<br/>})<br/>export class CustomIfDirective {<br/>   constructor(<br/>      private template: TemplateRef&lt;any&gt;,    <br/>      private container: ViewContainerRef) { }<br/>}</span></pre><ul class=""><li id="f055" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm ni nj nk nl bi translated"><code class="fe lo lp lq lr b">TemplateRef</code> —引用包含在<code class="fe lo lp lq lr b">ng-template</code>中的内容</li><li id="426d" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated"><code class="fe lo lp lq lr b">ViewContainerRef</code> <strong class="kt ir"> — </strong>对占位符的引用，我们可以在其中放置任何内容</li></ul><p id="ad64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的指令中，我们还需要获取@Input，并基于它来确定我们是否需要在指令容器中呈现模板:</p><pre class="kg kh ki kj gt oi lr oj ok aw ol bi"><span id="3c76" class="nr ma iq lr b gy om on l oo op">@Directive({<br/>   selector: '[appCustomIf]'<br/>})<br/>export class CustomIfDirective {<br/>   @Input() appCustomIf!: boolean;</span><span id="0fb3" class="nr ma iq lr b gy oq on l oo op">   constructor(<br/>      private template: TemplateRef&lt;any&gt;,    <br/>      private container: ViewContainerRef) { }<br/>}</span></pre><p id="5040" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果<code class="fe lo lp lq lr b">@Input</code>为真，最后一步是在<code class="fe lo lp lq lr b">ngOnInit</code>方法的容器中呈现模板:</p><pre class="kg kh ki kj gt oi lr oj ok aw ol bi"><span id="abd4" class="nr ma iq lr b gy om on l oo op">@Directive({<br/>   selector: '[appCustomIf]'<br/>})<br/>export class CustomIfDirective implements OnInit {<br/>   @Input() appCustomIf!: boolean;</span><span id="798c" class="nr ma iq lr b gy oq on l oo op">   constructor(<br/>      private template: TemplateRef&lt;any&gt;,    <br/>      private container: ViewContainerRef) { }</span><span id="d759" class="nr ma iq lr b gy oq on l oo op">   ngOnInit() {<br/>      if (this.appCustomIf) {    <br/>           this.container.createEmbeddedView(this.templateRef);<br/>       }<br/>    }<br/>}</span></pre><p id="90eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">恭喜你！你已经实现了第一个结构指令。但是我相信更有趣的事情是实现自定义的<code class="fe lo lp lq lr b">ngFor</code>指令。让我们试着去做。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4fe5" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">示例2:自定义ngFor指令。</strong></h1><p id="79d5" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">让我们记住<code class="fe lo lp lq lr b">ngFor</code>是如何使用的:</p><pre class="kg kh ki kj gt oi lr oj ok aw ol bi"><span id="8bf0" class="nr ma iq lr b gy om on l oo op">&lt;ul&gt;<br/>   &lt;li *ngFor="let value of values; let index"&gt;<br/>     {{index}} {{value}}<br/>   &lt;/li&gt;<br/>&lt;/ul&gt;<br/></span></pre><p id="a3c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这看起来有点奇怪，因为我们知道我们可能绑定到只产生一个值的JS表达式。但是使用的这个会产生多个值<code class="fe lo lp lq lr b">let value of values</code>。第一个混淆可能来自于我们试图将关键字<code class="fe lo lp lq lr b">of</code>与我们与<code class="fe lo lp lq lr b">for...of</code>一起使用的JS关键字<code class="fe lo lp lq lr b">of</code>进行映射，但是它与这个关键字没有任何共同之处。Angular使用它自己的DSL语言，我们可以使用任何我们想要的单词来代替<code class="fe lo lp lq lr b">of</code>。我们按顺序走吧。</p><p id="2954" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，你在指令<code class="fe lo lp lq lr b">ngFor</code>右边看到的表达式叫做<em class="ln"> microsyntax </em>。让我们试着解释一下它的结构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/73c446e9f799315cc82b203db0410d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ym4Hy1bQm5V_D2Nz624k7g.png"/></div></div></figure><p id="6665" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，context可以被设置为任何我们想要用来在目标容器中呈现模板的东西，但是当然，在这种情况下，它应该在沿着<code class="fe lo lp lq lr b">values</code>的迭代期间被设置为一个元素。记住，我们通常将模板的类型定义为<code class="fe lo lp lq lr b">TemplateRef&lt;any&gt;</code>，这个<code class="fe lo lp lq lr b">any</code>是我们模板的上下文类型。</p><p id="2b97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里更有趣的部分是，我们应该使用哪个名称来访问<code class="fe lo lp lq lr b">values</code>中的值？这张图表应该有助于您:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/33fb6679dd6ad74c07dd9d9ae2de2ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c1HFAwkaZ1FXGA21bNR0ug.png"/></div></div></figure><p id="c832" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该名称由两部分组成:</p><ul class=""><li id="59fd" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm ni nj nk nl bi translated">第一部分是指令的名称(在我们的例子中是<code class="fe lo lp lq lr b">ngFor</code>)；</li><li id="e3be" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated">第二部分是在<code class="fe lo lp lq lr b">value</code>之前的单词的名字(在我们的例子中是<code class="fe lo lp lq lr b">of</code></li></ul><p id="3039" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我之前说过的，你可以使用任何单词代替<code class="fe lo lp lq lr b">of</code>，例如<code class="fe lo lp lq lr b">iterate</code>，并且通过<code class="fe lo lp lq lr b">@Input('ngForIterate')</code>访问值，它也被称为<em class="ln">绑定键</em>。</p><p id="fcbb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望到目前为止一切顺利。让我们开始执行我们的<code class="fe lo lp lq lr b">customFor</code>指令。像往常一样，让我们使用Angular CLI为指令创建脚手架:</p><pre class="kg kh ki kj gt oi lr oj ok aw ol bi"><span id="1882" class="nr ma iq lr b gy om on l oo op">ng g d directives/customFor</span></pre><p id="b640" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它在<code class="fe lo lp lq lr b">directives</code>文件夹中创建文件<code class="fe lo lp lq lr b">customFor.directive.ts</code>文件，内容如下:</p><pre class="kg kh ki kj gt oi lr oj ok aw ol bi"><span id="8b49" class="nr ma iq lr b gy om on l oo op">@Directive({<br/>   selector: '[appCustomFor]'<br/>})<br/>export class CustomForDirective {<br/>   constructor() { }<br/>}</span></pre><p id="7d6b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好吧，为了让事情变得更有趣，让我们为developing指令定义我们的microsyntax:</p><pre class="kg kh ki kj gt oi lr oj ok aw ol bi"><span id="f2ff" class="nr ma iq lr b gy om on l oo op">&lt;ul *appCustomFor="let value iterate values; let index"&gt;<br/>   &lt;li&gt;{{index}} {{value}}&lt;/li&gt;<br/>&lt;ul&gt;</span></pre><p id="c7f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以用下面的装饰器访问<code class="fe lo lp lq lr b">values</code>:</p><pre class="kg kh ki kj gt oi lr oj ok aw ol bi"><span id="a261" class="nr ma iq lr b gy om on l oo op">@Input('appCustomForIterate') items: any[]</span></pre><p id="faee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们在容器中呈现模板时，我们使用了以下API:</p><pre class="kg kh ki kj gt oi lr oj ok aw ol bi"><span id="af38" class="nr ma iq lr b gy om on l oo op">this.containerRef.createEmbeddedView(this.templateRef)</span></pre><p id="10ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">方法<code class="fe lo lp lq lr b">createEmbeddedView</code>接受第二个参数，它是模板的上下文:</p><pre class="kg kh ki kj gt oi lr oj ok aw ol bi"><span id="b3b3" class="nr ma iq lr b gy om on l oo op">this.containerRef.createEmbeddedView(this.templateRef, {<br/>   '$implicit': '' // any value which we want<br/>   index: 0 // any value which we want<br/>})</span></pre><p id="6e34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意<code class="fe lo lp lq lr b">$implicit</code>键——在我们的例子中，它在表达式中操纵<code class="fe lo lp lq lr b">value</code>的值。让我们来看看如何实施该指令:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="d9ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，我故意把内置指令<code class="fe lo lp lq lr b">ngFor</code>中使用的<code class="fe lo lp lq lr b">of</code>键改成了<code class="fe lo lp lq lr b">iterate</code>，所以我们可以这样使用这个指令:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ot ou l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="04a4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">示例3:带有结构指令的自定义轮播</h1><p id="b86e" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">让我们为生产实现一个更实际的例子。让我们假设我们需要实现Carousel。我们需要向指令传递一个转盘的图像列表，自定义指令需要显示一个当前图像，可以前进/后退。它的用法看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="a7e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们像往常一样从使用Angular CLI创建指令开始，并在构造函数中注入<code class="fe lo lp lq lr b">TemplateRef</code>和<code class="fe lo lp lq lr b">ViewContainerRef</code>。此外，我们需要访问<code class="fe lo lp lq lr b">images</code>变量中的值，这可以通过键绑定<code class="fe lo lp lq lr b">@Input('appCarouselOf')</code>来实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="ea45" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到目前为止，一切都应该是熟悉的。好吧，让我们实现一个负责在容器中呈现模板的方法。在实现之前，注意根据这个指令<code class="fe lo lp lq lr b">let image of images; let ctr = ctr</code>的用法，我们需要在模板上下文中传递2个变量:</p><ul class=""><li id="c044" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm ni nj nk nl bi translated"><code class="fe lo lp lq lr b">$implicit</code>保持当前轮播图像；</li><li id="f230" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated"><code class="fe lo lp lq lr b">ctr</code> —负责图像旋转的控制器</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="1da0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们实现两个方法，这两个方法在vis控制器中可用:<code class="fe lo lp lq lr b">next</code>和<code class="fe lo lp lq lr b">prev</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="fe45" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就是这样。下面是完整的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="eda3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">希望你喜欢这篇文章。</p></div></div>    
</body>
</html>