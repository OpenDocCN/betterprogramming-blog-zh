<html>
<head>
<title>TypeScript’s Record Type Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释了TypeScript的记录类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typescripts-record-type-explained-691372b1a449?source=collection_archive---------1-----------------------#2021-06-18">https://betterprogramming.pub/typescripts-record-type-explained-691372b1a449?source=collection_archive---------1-----------------------#2021-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b8e6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您想知道的关于记录实用程序类型的所有信息</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/170c66fa4406495fa1d4d88f18082758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*bdsUHbM2L34QcDz32SFsXQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">杰里米·毕晓普在<a class="ae ku" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="4c31" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">Record</code>是TypeScript实用程序类型之一，从版本2.1开始就可以使用。</p><p id="d01b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">不得不承认，第一次看官方定义的时候有点迷茫:</p><blockquote class="lv lw lx"><p id="4c65" class="kv kw ly kx b ky kz ju la lb lc jx ld lz lf lg lh ma lj lk ll mb ln lo lp lq im bi translated">"<code class="fe lr ls lt lu b"><strong class="kx iu">Record&lt;Keys,Type&gt;</strong></code></p><p id="88ae" class="kv kw ly kx b ky kz ju la lb lc jx ld lz lf lg lh ma lj lk ll mb ln lo lp lq im bi translated">构造一个对象类型，其属性键为<code class="fe lr ls lt lu b">Keys</code>，属性值为<code class="fe lr ls lt lu b">Type</code>。该实用工具可用于将一种类型的属性映射到另一种类型。”— <a class="ae ku" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank">打字稿的文档</a></p></blockquote><p id="abf2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">从表面上看，<code class="fe lr ls lt lu b">Record</code>类型创建了一个对象类型，它具有类型<code class="fe lr ls lt lu b">Keys</code>的属性和类型<code class="fe lr ls lt lu b">Type</code>的相应值。但是类似的特性可以通过使用索引签名来实现，那么我们为什么要使用<code class="fe lr ls lt lu b">Record</code>类型呢？是什么让它与众不同或者有用？</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="553d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">记录类型与索引签名</h1><p id="1d55" class="pw-post-body-paragraph kv kw it kx b ky nb ju la lb nc jx ld le nd lg lh li ne lk ll lm nf lo lp lq im bi translated">在TypeScript中，我们把用方括号访问对象属性的方式称为<em class="ly">索引签名</em>。它广泛用于具有未知字符串键和特定值类型的对象类型。这里有一个例子:</p><pre class="kj kk kl km gt ng lu nh ni aw nj bi"><span id="f4dd" class="nk mk it lu b gy nl nm l nn no">type studentScore= { [name: string]: number };</span></pre><p id="81bc" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">上面的索引签名示例也可以用<code class="fe lr ls lt lu b">Record</code>类型来表示:</p><pre class="kj kk kl km gt ng lu nh ni aw nj bi"><span id="a2cc" class="nk mk it lu b gy nl nm l nn no">type studentScore = Record&lt;string, number&gt;;</span></pre><p id="c957" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于这个用例，从类型断言的角度来看，这两个类型声明是等效的。但是从语法的角度来看，<code class="fe lr ls lt lu b">index signature</code>更好。在索引签名方法中，<code class="fe lr ls lt lu b">name</code>键更清楚地表达了意图，另一个优点是它显示在VisualCode IntelliSense中。</p><p id="1e23" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">那我们为什么要用<code class="fe lr ls lt lu b">Record</code>型呢？</p><h2 id="cfe4" class="nk mk it bd ml np nq dn mp nr ns dp mt le nt nu mv li nv nw mx lm nx ny mz nz bi translated">记录类型为什么有用？</h2><p id="fb72" class="pw-post-body-paragraph kv kw it kx b ky nb ju la lb nc jx ld le nd lg lh li ne lk ll lm nf lo lp lq im bi translated"><code class="fe lr ls lt lu b">Record</code>类型的好处是<strong class="kx iu">简洁</strong>。当我们想要限制一个对象的属性时，它特别有用。例如，我们可以使用字符串文字的联合来指定<code class="fe lr ls lt lu b">Record </code>类型允许的键，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi oa"><img src="../Images/c5aea5b1a4dbc8ae504303067206ab2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7LB7CK4k-ssUrOkyMMXdCQ.png"/></div></div></figure><p id="bc30" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这个例子中，我们定义了一个带有联合类型约束的类型。如果我们试图访问一个不在<code class="fe lr ls lt lu b">roles</code>联合类型中的属性，VS代码编译器会不高兴。当我们维护复杂类型时，编译时检查非常有用，因为编译器会防止这类错误发生。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi of"><img src="../Images/08c122b4611a1f9f3dcb13c5532e171d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uI2COsqHhbjksip9j8JADA.png"/></div></div></figure><p id="aa89" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">另一个有用的特性是键也可以是枚举。在下面的例子中，我们使用<code class="fe lr ls lt lu b">staffTypes</code>枚举作为<code class="fe lr ls lt lu b">Record</code>类型的受限键，因此可读性更好。请注意，只有在TypeScript 2.9之后才支持枚举。因此，在2.9版本之前，密钥的类型被限制为<code class="fe lr ls lt lu b">string </code>类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/d41af80b9b9d42b25ca485f2c4abb02f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*z7tzFyX5CRF9m_hy9P6Jpw.png"/></div></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="b66e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">将记录类型与keyof运算符相结合</h1><p id="b909" class="pw-post-body-paragraph kv kw it kx b ky nb ju la lb nc jx ld le nd lg lh li ne lk ll lm nf lo lp lq im bi translated"><code class="fe lr ls lt lu b">keyof </code>运算符是一个类型运算符，可以将对象键提取为一个union类型。通过使用<code class="fe lr ls lt lu b">keyof</code> <strong class="kx iu"> </strong>从现有类型中获取所有属性，并将其与一个字符串值相结合，我们可以像下面这样做:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/dcd1ed692235fd9f3fba092959c28ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*uEJNjd5OfX3wao0LSjEZTg.png"/></div></figure><p id="ac4f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当您希望保留现有类型的属性，但将值类型转换为其他类型时，这很方便。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="ec11" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">高级用法示例</h1><p id="694c" class="pw-post-body-paragraph kv kw it kx b ky nb ju la lb nc jx ld le nd lg lh li ne lk ll lm nf lo lp lq im bi translated">一个<code class="fe lr ls lt lu b">Record</code>类型可以与其他实用程序类型一起用于更高级的用例。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="385a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">通过<code class="fe lr ls lt lu b">Record</code>、<code class="fe lr ls lt lu b">Partial</code>和<code class="fe lr ls lt lu b">Intersection</code>类型的协同工作，这段代码创建了一个强类型的<code class="fe lr ls lt lu b">benefits</code>对象，在键和值类型之间建立了一个关联。强类型对象使得在编译时捕获错误成为可能。它还使IDE能够在键入时标记错误，并为IntelliSense提供自动完成功能。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="4b8d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">摘要</h1><p id="c897" class="pw-post-body-paragraph kv kw it kx b ky nb ju la lb nc jx ld le nd lg lh li ne lk ll lm nf lo lp lq im bi translated"><code class="fe lr ls lt lu b">Record</code>是一个方便简洁的实用类型，可以让你的代码更加健壮。在处理动态数据结构时，这尤其有用。类型的目标与其他精彩的类型脚本特性相同:<a class="ae ku" href="https://levelup.gitconnected.com/achieve-type-safety-with-typescript-magic-fef5ff939c98" rel="noopener ugc nofollow" target="_blank">更好的类型安全性</a>。</p><p id="b83e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果你喜欢这篇文章，你可能也喜欢阅读<a class="ae ku" href="https://sunnysun-5694.medium.com/typescript-infer-keyword-explained-76f4a7208cb0" rel="noopener">另一篇关于推断关键词</a>的文章。</p><p id="bc45" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="ly">如果您还不是Medium、</em> <a class="ae ku" href="https://sunnysun-5694.medium.com/membership" rel="noopener"> <strong class="kx iu"> <em class="ly">的付费会员，您可以通过访问此链接</em> </strong> </a> <em class="ly">进行注册。你可以无限制地阅读媒体上的所有报道。我会收你一部分会员费作为介绍费。</em></p></div></div>    
</body>
</html>