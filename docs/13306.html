<html>
<head>
<title>Pointers in Python? Wait… Is It Possible?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的指针？等等……可能吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pointers-in-python-wait-is-it-possible-9e19da644e41?source=collection_archive---------1-----------------------#2022-08-16">https://betterprogramming.pub/pointers-in-python-wait-is-it-possible-9e19da644e41?source=collection_archive---------1-----------------------#2022-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="566e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Python代码中直接使用指针的力量</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9c5c7f62ebcb8a19fa8119c97f810c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VYR2K8zojr_zDECrPCoDPQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@pakata?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pakata Goh </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ca9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">指针在低级编程语言中非常强大。<br/> Python被认为是一种高级编程语言，但可以用或桥扩展到低级语言，即C和C++。</p><p id="dd82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近发布的一个包允许我们在Python代码中直接使用指针的力量。</p><h1 id="a687" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">指针是什么？</h1><p id="8e8c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">指针被定义为<code class="fe mp mq mr ms b">data-types</code>，其值是计算机内存中的物理地址。</p><p id="345f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，让我们看看下面的C代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8708" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个非常简单的例子中，我们声明了一个名为<code class="fe mp mq mr ms b">i</code>的整数，并给它赋值<code class="fe mp mq mr ms b">1</code>，然后我们声明了一个指向名为<code class="fe mp mq mr ms b">i_ptr</code>的整数的指针，并给它赋值该整数的物理地址<code class="fe mp mq mr ms b">i</code>。</p><p id="8c99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们打印出<code class="fe mp mq mr ms b">i</code>的值、<code class="fe mp mq mr ms b">i_ptr</code>的值(是存储<code class="fe mp mq mr ms b">i</code>的地址)，然后是<code class="fe mp mq mr ms b">i_ptr</code>指向的地址中存储的值。</p><p id="7e6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们运行这段代码，结果可能是这样的:</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="4931" class="mz lt iq ms b gy na nb l nc nd">i=1</span><span id="ad49" class="mz lt iq ms b gy ne nb l nc nd">i_ptr=0061FEC8</span><span id="3b93" class="mz lt iq ms b gy ne nb l nc nd">*i_ptr=1</span></pre><h1 id="c565" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么是指针？</h1><p id="5211" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">通过使用指针，我们可以使用值的地址而不是值本身。</p><p id="ee49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这在很多情况下都很有用。</p><p id="c68c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，当<code class="fe mp mq mr ms b">sorting</code>一个数组时，我们经常需要交换项目。交换值的代价很高，因为我们需要将整个数据结构从一个地址转移到另一个地址。</p><p id="1e76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，交换指针更加资源友好。</p><p id="f0af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">指针还允许动态分配内存。</p><p id="e423" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在C语言中，这是通过使用<code class="fe mp mq mr ms b">malloc</code>函数来完成的，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="34b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们为十个整数动态分配了空间。</p><p id="7923" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个整数的长度是4个字节，所以总的来说，这个内存空间是40个字节长。<br/>我们用1到10的数字填充每个插槽，然后打印每个插槽当时的地址和值。</p><p id="9173" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个可能的输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="32c6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">指针简介. py</h1><p id="03fd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://pypi.org/project/pointers.py/" rel="noopener ugc nofollow" target="_blank"> pointers.py </a>提供了一个很好的抽象，可以在我们的Python代码中使用指针，而不用显式地使用<code class="fe mp mq mr ms b">c-types</code>或c扩展。</p><p id="8669" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们用下面的命令从pip安装<code class="fe mp mq mr ms b">pointers.py</code>:</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="b848" class="mz lt iq ms b gy na nb l nc nd">pip install pointers.py</span></pre><p id="853d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们写一个简单的程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="18ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们有一个值为“hello world”的字符串，我们创建了一个名为<code class="fe mp mq mr ms b">ptr</code>的指针来获取字符串的地址。</p><p id="9441" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们打印指针和它所指向的值。</p><p id="9c89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们运行这段代码，我们会得到以下结果:</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="26d6" class="mz lt iq ms b gy na nb l nc nd">0x26638d28430<br/>hello world</span></pre><p id="2605" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们可以直接访问存储“hello world”的地址。</p><p id="3992" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，我们可以使用以下语法从值中提取指针:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="51e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以直接改变这个字符串的值了！</p><p id="b5ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住，Python中的字符串是不可变的，这意味着我们不能改变字符串的值。相反，我们只能创建一个新字符串。</p><p id="2ac0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了指针，我们可以绕过这个限制，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="717a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们运行这个，我们会得到以下结果:</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="bac1" class="mz lt iq ms b gy na nb l nc nd">0x1ee67fabe30<br/>hello world  <br/>0x1ee67f38430<br/>hi world</span></pre><p id="2d56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">勘误表更新(2022年8月20日)</strong>:</p><p id="2cde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我注意到这两个地址不一样，这是真的。<br/>然而，如果我们看看下面的代码片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6126" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，<code class="fe mp mq mr ms b">ptr</code>和<code class="fe mp mq mr ms b">ptr2</code>引用包含字符串“hello world”的同一个对象。<br/>如果没有指针，一旦一个字符串的值改变，它将被赋给一个新的python内存结构，另一个保持不变。</p><p id="9e84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在我们更改了<code class="fe mp mq mr ms b">ptr</code>中的值后，我们看到<code class="fe mp mq mr ms b">ptr2</code>的值也发生了变化:</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="68a8" class="mz lt iq ms b gy na nb l nc nd">0x1c4bbd58530<br/>hello world    <br/>0x1c4bbd58530  <br/>hello world    <br/>===============<br/>0x1c4bbe17870  <br/>hi world       <br/>0x1c4bbd58530  <br/>hi world</span></pre><p id="e889" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么不变的作为确实变异了，好吗？不好？丑？你将是裁判:)</p><p id="a944" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谢谢你的评论！</p><p id="4c41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">勘误表结束</strong></p><p id="9746" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们如何使用<code class="fe mp mq mr ms b">pointers.py</code>动态分配和释放内存:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="09e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个代码片段中，我们分配了1个整数(28字节)大小的内存，并将数字1压入这个分配的内存中。</p><p id="6087" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们打印地址和值，然后我们释放内存。</p><p id="be9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个可能的输出:</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="3f62" class="mz lt iq ms b gy na nb l nc nd">0x1c21a612470<br/>1</span></pre><p id="3ceb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们做一些奇怪的事情:)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8024" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该预料到这段代码中的断言错误，对吗？<br/>嗯……不！</p><p id="7eed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这段代码中，我们没有得到任何异常。</p><p id="68ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们在地址1中插入了值2，所以我们完全把事情弄糟了。</p><p id="dca7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以记住，指针给你巨大的力量，但是伴随着巨大的力量而来的是巨大的责任！</p><h1 id="f5ff" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最后一点</h1><p id="8636" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我个人比较喜欢低级编程，所以我的观点可能会有偏差。但是我相信这是对你的Pythonic工具带的一个很好的补充。</p><p id="f939" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它可以轻松地在Python和它的C环境之间架起桥梁，并帮助处理可能需要直接内存访问的更复杂的任务。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="8c5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="no">感谢您的阅读！</em></p><p id="1214" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="no">敬请期待更多。</em></p></div></div>    
</body>
</html>