<html>
<head>
<title>Framer Motion Tutorials: Make More Advanced Animations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">帧运动教程:制作更高级的动画</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/framer-motion-tutorials-make-more-advanced-animations-4344b686ea0a?source=collection_archive---------4-----------------------#2020-01-08">https://betterprogramming.pub/framer-motion-tutorials-make-more-advanced-animations-4344b686ea0a?source=collection_archive---------4-----------------------#2020-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="764f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://medium.com/@kateshokurova" rel="noopener"> <em class="kp">由</em> </a> <a class="ae ko" href="https://shakuro.com/blog/author/julia-shikanova" rel="noopener ugc nofollow" target="_blank">朱丽娅</a> <a class="ae ko" href="https://medium.com/@kateshokurova" rel="noopener"> <em class="kp">，开发者</em> </a> <a class="ae ko" href="https://shakuro.com/" rel="noopener ugc nofollow" target="_blank"> <em class="kp">三郎</em> </a></p><h2 id="a419" class="kq kr it bd ks kt ku dn kv kw kx dp ky kb kz la lb kf lc ld le kj lf lg lh li bi translated">向React应用程序添加动画</h2><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/74795702a624f364d8681df3717a69f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYrG5rg8rk2K_CuQ0rOw1g.jpeg"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">m代表安德鲁·庞斯的动作</p></figure><p id="3cfa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Framer Motion是一个相对较新且受欢迎的开源React动画库，旨在创建生产就绪的动画。帧运动是姿势的动画库的下一步。它拥有一个低级的声明式API，可以在任何平台上使用，既可以用于网络，也可以用于移动应用。它的另一个被软件开发者看重的优势是，它也可以作为一个单独的包在React应用程序中使用。</p><p id="368b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Framer的文档提供了足够的<a class="ae ko" href="https://www.framer.com/api/motion/" rel="noopener ugc nofollow" target="_blank">教程</a>关于如何做最简单的手势和动作。然而，如果你在处理更复杂的案件，网上这方面的信息太少了。所以钻研最简单的例子没有意义，可以根据文档来做。网上也有关于这个主题的文章(尽管不是很多)。让我们来修补更复杂的帧动画。</p><p id="4f27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你曾经想知道如何制作这种或那种黄油般光滑的效果，例如，在<a class="ae ko" href="https://dribbble.com/global-design-survey-2019" rel="noopener ugc nofollow" target="_blank">Dribbble Global Design Survey 2019 page</a>上，那么请继续阅读并学习这篇成帧器运动教程！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="dd53" class="mg kr it bd ks mh mi mj kv mk ml mm ky mn mo mp lb mq mr ms le mt mu mv lh mw bi translated">何时使用帧运动，为什么</h1><p id="d29f" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">Framer Motion能够为Framer X中的动画提供动力，Framer X是一种原型工具，这使得移交极其方便。大多数设计师都遇到过这样的情况，他们花了很长时间来完善设计的每个细节，结果却在开发过程中丢失了。Framer Motion允许您在原型制作和生产中使用相同的动画库。这样你就不需要担心你的反应动画和你想要的不一样。</p><p id="3430" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至于使用动画作为工具的最佳方式，主要是保持它有意义并且与主题相关。你可以在这篇文章中掌握主要思想和十几个有用的技巧，现在，让我们直接进入React动画教程。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="92f6" class="mg kr it bd ks mh mi mj kv mk ml mm ky mn mo mp lb mq mr ms le mt mu mv lh mw bi translated">成帧器运动教程</h1><p id="ef97" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">帧运动对于动画来说是很棒的。让我们试着做一些！如果此时您正处于JavaScript之旅的起点，那么您最好先从简单的东西开始。</p><p id="498f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个成帧器运动教程由1-3个组件和一个道具列表组成(大多数是可选的和/或有默认值)。所有的例子都是交互式的，所以刷新和点击，拖动，翻转。</p><h2 id="949d" class="kq kr it bd ks kt ku dn kv kw kx dp ky kb kz la lb kf lc ld le kj lf lg lh li bi translated"><a class="ae ko" href="https://codesandbox.io/s/framer-motion-parallax-box-ekqoe" rel="noopener ugc nofollow" target="_blank">视差框教程</a></h2><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="03dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ParallaxBox组件动画通过滚动来设置，模仿视差效果。滚动<code class="fe ne nf ng nh b">triggers</code>组件，根据<code class="fe ne nf ng nh b">yOffset</code>属性中指定的值(px，&gt; 0，默认= 100)向上/向下移动(取决于滚动方向)。</p><p id="3e59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ne nf ng nh b">MotionValues</code>用于跟踪一个动画值的状态和速度。</p><p id="dd4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常自动计算的<code class="fe ne nf ng nh b">MotionValues</code>在大多数情况下绰绰有余。但是对于更高级的，你可以<a class="ae ko" href="https://www.framer.com/api/motion/motionvalue/" rel="noopener ugc nofollow" target="_blank">手动创建</a>然后注入到组件中。我们会这么做的。</p><p id="a860" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为<code class="fe ne nf ng nh b">ParallaxBox</code>组件制作动画，使用<code class="fe ne nf ng nh b">MotionValues</code>的链，通过<code class="fe ne nf ng nh b">useTransform</code> <em class="kp">钩子</em> ( <code class="fe ne nf ng nh b">useTransform</code> <em class="kp">)传递给<code class="fe ne nf ng nh b">ParallaxBox</code><em class="kp"/>；</em>父，从，到，选项)。</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="dd22" class="kq kr it nh b gy nm nn l no np">const y = useTransform(<br/>  scrollY,<br/>  yRange, <br/>  [0, -yOffset], <br/>  easing<br/>);</span></pre><p id="6625" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ne nf ng nh b">useTransform</code>创建一个<code class="fe ne nf ng nh b">MotionValue</code>，通过将另一个<code class="fe ne nf ng nh b">MotionValue</code>的输出从一个数值范围<a class="ae ko" href="https://www.framer.com/api/motion/motionvalue/#usetransform" rel="noopener ugc nofollow" target="_blank">映射到另一个</a>来转换它。</p><p id="e8b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个参数parent:要转换其输出的<code class="fe ne nf ng nh b">MotionValue</code>。</p><p id="2e5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用另一个钩子作为它的值:</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="c813" class="kq kr it nh b gy nm nn l no np">const { scrollY } = useViewportScroll();</span></pre><p id="63a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ne nf ng nh b">useViewportScroll(): ScrollMotionValues</code> —提供当视口滚动时更新的<code class="fe ne nf ng nh b">MotionValues</code>。<code class="fe ne nf ng nh b"><a class="ae ko" href="https://www.framer.com/api/motion/motionvalue/#useviewportscroll" rel="noopener ugc nofollow" target="_blank">scrollY</a></code> —以像素为单位的垂直滚动距离。</p><p id="9e23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输入值-from:number[]-一系列线性数字(全部递增或递减)。</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="dfde" class="kq kr it nh b gy nm nn l no np">const yRange = [transformInitialValue, transformFinalValue];</span></pre><p id="4deb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ne nf ng nh b">yRange</code>接受由<code class="fe ne nf ng nh b">transformInitialValue</code>——元素的初始位置和<code class="fe ne nf ng nh b"><em class="kp">transformFinalValue </em></code>——它在动画结尾的位置组成的数组。</p><p id="bff8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出值-to:<em class="kp">T[]</em>-一系列数字、颜色或字符串。必须和<code class="fe ne nf ng nh b">inputRange</code>一样长。</p><p id="afdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在该示例中，输出值采用一个数组:</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="82da" class="kq kr it nh b gy nm nn l no np">[0, -yOffset]</span></pre><p id="28fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中0 —初始位置，<code class="fe ne nf ng nh b">–yOffset</code> —元素偏移(该值为负值，因为组件相对于其初始位置向上移动)。</p><p id="b706" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ne nf ng nh b">useTransform</code>取的最后一个值，<code class="fe ne nf ng nh b">options</code> <em class="kp">，</em>可以取几个值，但是在这个例子中，对我们最有意义的是ease: <code class="fe ne nf ng nh b">EasingFunction []</code>。</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="3670" class="kq kr it nh b gy nm nn l no np">easing = [0.42, 0, 0.58, 1],</span></pre><p id="1c05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://easings.net/en" rel="noopener ugc nofollow" target="_blank">缓动功能</a>是让你控制动画速度的算法，让它们产生想要的效果，如弹跳、减速等。</p><p id="34bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也就是说，在现实生活中，事物不会以线性方式突然开始和停止运动。动量和其他物理方面发挥了作用。例如，当你打球时，你要记住它不是匀速运动，而是弹跳。汽车转弯时减速等。缓动功能有助于使效果看起来更自然、更逼真。</p><p id="559f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">缓动可以采用四个数字的数组[n，n，n，n]作为三次贝塞尔函数，也可以内置命名函数，如<code class="fe ne nf ng nh b">linear</code>、<code class="fe ne nf ng nh b">easeInOut</code>、<a class="ae ko" href="https://www.framer.com/api/motion/types/#tween.ease" rel="noopener ugc nofollow" target="_blank">等</a>。</p><p id="a9b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在剩下的就是将<code class="fe ne nf ng nh b"><em class="kp">y</em></code>值传递给组件:</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="bb9e" class="kq kr it nh b gy nm nn l no np">return (<br/>   &lt;MotionBox ref={ref} initial={{ y: 0 }} style={{ y, opacity }}&gt;<br/>     {children}<br/>   &lt;/MotionBox&gt;<br/> );</span></pre><p id="40a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">任务完成了。现在组件将在滚动时平滑上移，模仿视差效果。</p><p id="9415" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还可以将道具传递到组件中:</p><ul class=""><li id="9001" class="nq nr it js b jt ju jx jy kb ns kf nt kj nu kn nv nw nx ny bi translated"><code class="fe ne nf ng nh b">yOffset</code> —偏移值</li><li id="faa3" class="nq nr it js b jt nz jx oa kb ob kf oc kj od kn nv nw nx ny bi translated"><code class="fe ne nf ng nh b">easing</code> —动画类型</li><li id="5d76" class="nq nr it js b jt nz jx oa kb ob kf oc kj od kn nv nw nx ny bi translated"><code class="fe ne nf ng nh b">triggerPoint </code> —一个介于0和1之间的值，根据该元素在页面上的位置确定其动画开始的时间，其中0表示页面的顶部，1表示页面的底部。</li><li id="e653" class="nq nr it js b jt nz jx oa kb ob kf oc kj od kn nv nw nx ny bi translated"><code class="fe ne nf ng nh b">fadeOut</code> <em class="kp"> </em>是一个布尔值，决定元素的淡出是否会影响其不透明度级别。</li></ul><p id="6584" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有列出的属性都是可选的，并且已经在组件中指定了默认值。</p><p id="e3fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很简单，不是吗？</p><h2 id="07f2" class="kq kr it bd ks kt ku dn kv kw kx dp ky kb kz la lb kf lc ld le kj lf lg lh li bi translated"><a class="ae ko" href="https://codesandbox.io/s/framer-motion-intersection-observer-scale-qmtyb" rel="noopener ugc nofollow" target="_blank">路口观测器|比例箱教程</a></h2><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="aa25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个教程比上一个简单多了。唯一的困难是使用第三方库的钩子<a class="ae ko" href="https://github.com/streamich/react-use" rel="noopener ugc nofollow" target="_blank">React——使用</a> — <code class="fe ne nf ng nh b">useIntersection</code> — <a class="ae ko" href="https://github.com/streamich/react-use/blob/master/docs/useIntersection.md" rel="noopener ugc nofollow" target="_blank"> React传感器钩子</a>来跟踪目标元素的交集的变化。</p><p id="8df4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个钩子的帮助下，我们可以创建<code class="fe ne nf ng nh b">IntersectionObserver</code>组件，当运动组件出现在它的作用域中并开始动画时，它会进行感知。</p><p id="a7c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个组件可以用<code class="fe ne nf ng nh b">default = false</code>进行布尔道具重置，负责当元素再次出现在视口时是否触发动画。</p><p id="2fcc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以用<code class="fe ne nf ng nh b">IntersectionObserver</code>组件包装一个或多个运动组件:</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="6dbe" class="kq kr it nh b gy nm nn l no np">&lt;IntersectionObserver&gt;<br/>  &lt;ScaleBox /&gt;<br/>&lt;/IntersectionObserver&gt;</span></pre><p id="ebbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并将<code class="fe ne nf ng nh b">inView</code>值从<code class="fe ne nf ng nh b">IntersectionObserver</code>组件的上下文传递给运动组件:</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="cac3" class="kq kr it nh b gy nm nn l no np">const { inView } = useContext(IntersectionContext);</span></pre><p id="681d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们继续讨论运动组件— <code class="fe ne nf ng nh b">ScaleBox</code> <em class="kp">。</em></p><p id="dd61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">比例值允许您减小或增大元素的大小。也就是说，当<code class="fe ne nf ng nh b">ScaleBox</code>落入浏览器窗口的可视部分时，<em class="kp"> </em> <code class="fe ne nf ng nh b">IntersectionObserver</code> <em class="kp"> </em>将inView上下文的值改为<code class="fe ne nf ng nh b">true</code>，这将触发动画:</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="083c" class="kq kr it nh b gy nm nn l no np">animate={inView ? "show" : "hidden"}</span></pre><p id="7b50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ne nf ng nh b">ScaleBox</code>可以在<code class="fe ne nf ng nh b">IntersectionObserver</code>组件之外使用，但是动画会在页面加载后开始，并且不管它是否在可见区域都会被处理。通常，这不是我们希望运动组件采取的方式，这就是我们需要<code class="fe ne nf ng nh b">IntersectionObserver</code>的原因。</p><p id="40bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了描述<code class="fe ne nf ng nh b">ScaleBox</code>动画，我们使用<code class="fe ne nf ng nh b">variants</code>，预定义的目标对象集:</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="5c8c" class="kq kr it nh b gy nm nn l no np">const variants = {<br/>   hidden: {<br/>     scale: 0,<br/>     opacity: 0,<br/>     transition<br/>   },<br/>   show: {<br/>     scale: 1,<br/>     opacity: 1,<br/>     transition<br/>   }<br/> };</span></pre><p id="ccec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ne nf ng nh b">variants</code>对象包含键-值对，其中键(标签)是动画属性的名称(在我们的例子中，是<code class="fe ne nf ng nh b">hidden</code>和<code class="fe ne nf ng nh b">show</code>，尽管名称可以是任何东西；主要是让他们有意义)。</p><p id="bae7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">唯一剩下的事情就是将<code class="fe ne nf ng nh b">variants</code>对象传递给<code class="fe ne nf ng nh b">variants</code> <em class="kp">属性</em>:</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="8dec" class="kq kr it nh b gy nm nn l no np">return (<br/>   &lt;MotionBox<br/>     initial="hidden"<br/>     animate={inView ? "show" : "hidden"}<br/>     exit="hidden"<br/>     variants={variants}<br/>   &gt;<br/>     {children}<br/>   &lt;/MotionBox&gt;<br/> );</span></pre><p id="1fed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">变体可以设置由其标签指示的动画目标(例如，initial="hidden ")。</p><p id="8748" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更详细地考虑一下<code class="fe ne nf ng nh b">transition</code>属性也是值得的，用它可以设置动画执行参数，比如<code class="fe ne nf ng nh b">duration</code>(s)<code class="fe ne nf ng nh b">delay</code>(s)<code class="fe ne nf ng nh b"><a class="ae ko" href="https://www.framer.com/api/motion/types/#tween.ease" rel="noopener ugc nofollow" target="_blank">ease</a></code>。</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="c1b2" class="kq kr it nh b gy nm nn l no np">const transition = {<br/>  duration: 0.4,<br/>  delay: 0.2,<br/>  ease: "easeInOut"<br/> };</span></pre><p id="c719" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有其他参数可以传递给<code class="fe ne nf ng nh b">transition</code>，比如<code class="fe ne nf ng nh b">loop</code>，动画的迭代次数(接受一个数字或者<code class="fe ne nf ng nh b">infinity</code>)。</p><p id="c56b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果，我们得到了两个组件。第一个，<code class="fe ne nf ng nh b">Intersection Observer</code> <em class="kp"> </em>检测屏幕上运动元素的存在。第二个，<code class="fe ne nf ng nh b">ScaleBox</code>，<em class="kp">，</em>改变元素的大小。这两个组件都很简单。一起使用它们允许当内容在用户的视窗中显示时，动画显示页面上出现的内容。</p><h2 id="211f" class="kq kr it bd ks kt ku dn kv kw kx dp ky kb kz la lb kf lc ld le kj lf lg lh li bi translated"><a class="ae ko" href="https://codesandbox.io/s/framer-motion-stagger-fade-in-up-9gky2" rel="noopener ugc nofollow" target="_blank">淡入淡出框|错开教程</a></h2><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="208f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ne nf ng nh b">FadeInOutBox</code> —动画显示元素外观、其从底部到顶部的移动(<code class="fe ne nf ng nh b">yOffset</code>)及其不透明度的组件。</p><p id="c087" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与<code class="fe ne nf ng nh b">ScaleBox</code>一样，该组件使用<code class="fe ne nf ng nh b">variants</code>:</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="c256" class="kq kr it nh b gy nm nn l no np">const variants = {<br/>   hidden: { <br/>y: yOffset, <br/>opacity: 0, <br/>transition <br/>   },<br/>   show: {<br/>     y: 0,<br/>     opacity: 1,<br/>     transition   <br/>   }<br/> };</span></pre><p id="bd8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只有在这种情况下，<code class="fe ne nf ng nh b"><em class="kp">y</em></code>属性(沿y轴变换元素的位置)才是动画，而不是缩放。</p><p id="78bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本例的第二个组件是<code class="fe ne nf ng nh b">StaggerWrap</code>以一定的延迟(<code class="fe ne nf ng nh b">staggerChildren</code>)连续动画显示嵌套的运动组件。</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="7ea1" class="kq kr it nh b gy nm nn l no np">const variants = {<br/>   hidden: { opacity: 0 },<br/>   show: {<br/>     opacity: 1,<br/>     transition: {<br/>       when: "beforeChildren",<br/>       staggerChildren: 0.5<br/>     }<br/>   }<br/> };</span></pre><p id="79c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当属性有助于详细描述父对象与其子对象之间的关联时(默认为false)。如果父动画必须在子动画之前执行，也可以取<code class="fe ne nf ng nh b">beforeChildren</code>值，反之则取<code class="fe ne nf ng nh b">afterChildren</code>值。</p><p id="4c8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，动画参数被传送到父组件，即<code class="fe ne nf ng nh b">StaggerWrap</code>组件本身:</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="2670" class="kq kr it nh b gy nm nn l no np">return (<br/>   &lt;<strong class="nh iu">StaggerContext.Provider</strong> value={{ stagger: true }}&gt;<br/>     &lt;<strong class="nh iu">MotionBox</strong><br/>       initial="hidden"<br/>       animate="show"<br/>       exit="hidden"<br/>       variants={variants}<br/>     &gt;<br/>       {children}<br/>     &lt;/<strong class="nh iu">MotionBox</strong>&gt;<br/>   &lt;/<strong class="nh iu">StaggerContext.Provider</strong>&gt;<br/> );<br/>};</span></pre><p id="b5d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">剩下的唯一一件事就是将<code class="fe ne nf ng nh b">variants</code>对象传递到子元素的道具选项中:</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="7c7a" class="kq kr it nh b gy nm nn l no np">return stagger ? (<br/>   &lt;<strong class="nh iu">MotionBox</strong> variants={variants}&gt;<br/>     {children}<br/>   &lt;/<strong class="nh iu">MotionBox</strong>&gt;<br/> ) : [...]</span></pre><p id="fd26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将<code class="fe ne nf ng nh b">StaggerWrap</code>和<code class="fe ne nf ng nh b">FadeInUpBox</code>一起使用，你可以通过移动<code class="fe ne nf ng nh b">y</code> ( <code class="fe ne nf ng nh b">yOffset</code>)和不透明度的改变来连续动画显示多个元素的外观。</p><h2 id="ede3" class="kq kr it bd ks kt ku dn kv kw kx dp ky kb kz la lb kf lc ld le kj lf lg lh li bi translated"><a class="ae ko" href="https://codesandbox.io/s/framer-motion-animatepresence-react-router-dom-9dhyn?file=/src/App.js:2205-2220" rel="noopener ugc nofollow" target="_blank">动画演示|路由教程</a></h2><p id="c72d" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">使用Framer-motion的组件<a class="ae ko" href="https://www.framer.com/api/motion/animate-presence/" rel="noopener ugc nofollow" target="_blank"> <em class="kp"> AnimatePresence </em> </a>和<a class="ae ko" href="https://reactrouter.com/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank"> <em class="kp"> React-Router </em> </a>，我们可以在页面之间设置漂亮无缝的过渡，以提升您的项目的外观✨</p><p id="188c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Framer-motion已经有了一个带有路由的<a class="ae ko" href="https://codesandbox.io/s/framer-motion-x-react-router-n7qhp?file=/src/Gallery.jsx" rel="noopener ugc nofollow" target="_blank">演示，但是它有点不均衡，并且在文档中没有解释可能很难理解。所以我们决定用我们自己的小演示和教程来解决这个问题。</a></p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="c7e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基本上，这个演示由主博客页面(<em class="kp"> Blog </em>组件)和博客文章列表(<em class="kp"> PostPreview </em>)以及单独的文章页面(<em class="kp"> Post </em>)组成。您可以通过点击<em class="kp">了解更多信息</em>链接导航到帖子，并通过点击<em class="kp">返回主页</em>链接返回。在页面间导航会触发<em class="kp"> AnimatePresence </em>内组件的进入和退出动画。</p><p id="e070" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们需要设置路由，如果你不熟悉这个主题，请查阅文档:<a class="ae ko" href="https://reactrouter.com/web/guides/quick-start/1st-example-basic-routing" rel="noopener ugc nofollow" target="_blank">基本路由(react-router-dom) </a>。</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="510a" class="kq kr it nh b gy nm nn l no np">&lt;Router&gt;</span><span id="2e65" class="kq kr it nh b gy oe nn l no np">&lt;Route</span><span id="187f" class="kq kr it nh b gy oe nn l no np">render={({ location }) =&gt; (</span><span id="8704" class="kq kr it nh b gy oe nn l no np">&lt;AnimatePresence exitBeforeEnter initial={false}&gt;</span><span id="593e" class="kq kr it nh b gy oe nn l no np">&lt;Switch location={location} key={location.pathname}&gt;</span><span id="6a9f" class="kq kr it nh b gy oe nn l no np">&lt;Route exact path=”/” component={Blog} /&gt;</span><span id="2bcc" class="kq kr it nh b gy oe nn l no np">&lt;Route exact path=”/post/:id” component={Post} /&gt;</span><span id="4f3d" class="kq kr it nh b gy oe nn l no np">&lt;/Switch&gt;</span><span id="eb56" class="kq kr it nh b gy oe nn l no np">&lt;/AnimatePresence&gt;</span><span id="d83e" class="kq kr it nh b gy oe nn l no np">)}</span><span id="f4ef" class="kq kr it nh b gy oe nn l no np">/&gt;</span><span id="9e83" class="kq kr it nh b gy oe nn l no np">&lt;/Router&gt;</span></pre><p id="5be9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简而言之，<em class="kp">路由器</em>的工作原理是这样的:根据<em class="kp">的位置，</em>值<em class="kp">开关</em>渲染匹配当前位置的第一个子<em class="kp">路由</em>。如果它的主页位置是“/”，如果它是一篇文章，它就是“/post/:id”(“/post/0”，“/post/1”，等等)。</p><p id="2803" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了在<em class="kp">路由器</em>中实际渲染一个组件，我们需要将它作为道具传递给<em class="kp">路由器</em>:</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="62d3" class="kq kr it nh b gy nm nn l no np">&lt;Route {...} component={Component} /&gt;</span></pre><p id="711b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者像这样用它包装一个组件:</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="d2c6" class="kq kr it nh b gy nm nn l no np">&lt;Route {...} &gt;&lt;Component /&gt;&lt;/Route&gt;</span></pre><p id="f0f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我们需要用Framer-motion的<em class="kp"> AnimatePresence </em>包装<em class="kp">开关</em>，以启用动画，即使我们的组件已从React树中删除。</p><p id="2d19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们仔细看看我们需要传递给<em class="kp"> AnimatePresence </em>的道具:</p><ul class=""><li id="283e" class="nq nr it js b jt ju jx jy kb ns kf nt kj nu kn nv nw nx ny bi translated"><em class="kp"> exitBeforeEnter </em>确保组件一次只渲染一个，因此退出组件将在进入组件渲染之前完成其退出动画；</li><li id="d669" class="nq nr it js b jt nz jx oa kb ob kf oc kj od kn nv nw nx ny bi translated"><em class="kp"> initial={false} </em>在组件第一次呈现时(即页面第一次加载时)禁用初始动画。</li></ul><p id="edad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步是创建我们的组件。我们从<em class="kp">博客</em>开始:</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="ce69" class="kq kr it nh b gy nm nn l no np">const blogVariants = {</span><span id="7a43" class="kq kr it nh b gy oe nn l no np">enter: { transition: { staggerChildren: 0.1 } },</span><span id="0b11" class="kq kr it nh b gy oe nn l no np">exit: { transition: { staggerChildren: 0.1 } }</span><span id="0d10" class="kq kr it nh b gy oe nn l no np">}</span><span id="307e" class="kq kr it nh b gy oe nn l no np">const Blog = () =&gt; (</span><span id="f5ad" class="kq kr it nh b gy oe nn l no np">&lt;motion.div</span><span id="0d64" class="kq kr it nh b gy oe nn l no np">initial="initial"</span><span id="ee87" class="kq kr it nh b gy oe nn l no np">animate="enter"</span><span id="8ca1" class="kq kr it nh b gy oe nn l no np">exit="exit"</span><span id="e50a" class="kq kr it nh b gy oe nn l no np">variants={blogVariants}</span><span id="7d2a" class="kq kr it nh b gy oe nn l no np">&gt;</span><span id="0f8b" class="kq kr it nh b gy oe nn l no np">{content.map((post) =&gt; (</span><span id="5388" class="kq kr it nh b gy oe nn l no np">&lt;PostPreview key={post.id} {...post} /&gt;</span><span id="ebd3" class="kq kr it nh b gy oe nn l no np">))}</span><span id="488d" class="kq kr it nh b gy oe nn l no np">&lt;/motion.div&gt;</span><span id="064a" class="kq kr it nh b gy oe nn l no np">);</span></pre><p id="35ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kp"> staggerChildren </em>帮助我们创建<a class="ae ko" href="https://www.framer.com/api/motion/animation/#orchestration" rel="noopener ugc nofollow" target="_blank">交错编排的动画</a>(这意味着列表中的每个下一个项目都比前一个项目有0.1的延迟)，但是如果您不需要的话，可以删除<em class="kp">variants = { blog variants }</em>。</p><p id="f671" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们看看我们在<em class="kp">博客</em>中映射的<em class="kp">后查看</em>组件。我们用<em class="kp"> motion.div </em>包装内容，并传递带有动画值的变量。</p><p id="d1c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我们需要添加<em class="kp">链接</em>来导航到我们的帖子页面，让我们将获取路由路径的<em class="kp">传递给</em>属性，确保添加我们帖子的<em class="kp"> id </em> (to={/post/${id}})以确保路由正常工作。</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="c11b" class="kq kr it nh b gy nm nn l no np">const transition = { duration: 0.5, ease: "easeInOut" };</span><span id="0439" class="kq kr it nh b gy oe nn l no np">const postPreviewVariants = {</span><span id="6dff" class="kq kr it nh b gy oe nn l no np">initial: { x: "100%", opacity: 0 },</span><span id="7820" class="kq kr it nh b gy oe nn l no np">enter: { x: 0, opacity: 1, transition },</span><span id="c1e3" class="kq kr it nh b gy oe nn l no np">exit: { x: "-100%", opacity: 0, transition }</span><span id="6582" class="kq kr it nh b gy oe nn l no np">};</span><span id="27ea" class="kq kr it nh b gy oe nn l no np">const PostPreview = ({ id, {...} }) =&gt; (</span><span id="27be" class="kq kr it nh b gy oe nn l no np">&lt;motion.div variants={postPreviewVariants}&gt;</span><span id="b64c" class="kq kr it nh b gy oe nn l no np">{...}</span><span id="7a81" class="kq kr it nh b gy oe nn l no np">&lt;Link to={`/post/${id}`}&gt;Learn more&lt;/Link&gt;</span><span id="d86b" class="kq kr it nh b gy oe nn l no np">&lt;/motion.div&gt;</span><span id="cc79" class="kq kr it nh b gy oe nn l no np">);</span></pre><p id="d7a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后但同样重要的是——后组件:</p><pre class="lk ll lm ln gt ni nh nj nk aw nl bi"><span id="4039" class="kq kr it nh b gy nm nn l no np">const transition = { duration: 0.5, ease: "easeInOut" };</span><span id="70e0" class="kq kr it nh b gy oe nn l no np">const postVariants = {</span><span id="be68" class="kq kr it nh b gy oe nn l no np">initial: { y: 100, opacity: 0 },</span><span id="aec3" class="kq kr it nh b gy oe nn l no np">enter: { y: 0, opacity: 1, transition },</span><span id="fe1e" class="kq kr it nh b gy oe nn l no np">exit: { y: -100, opacity: 0, transition }</span><span id="4eea" class="kq kr it nh b gy oe nn l no np">};</span><span id="06f2" class="kq kr it nh b gy oe nn l no np">const Post = ({ match }) =&gt; {</span><span id="ea41" class="kq kr it nh b gy oe nn l no np">const id = Number(match.params.id);</span><span id="1da7" class="kq kr it nh b gy oe nn l no np">const { title, ... } = content[id];</span><span id="4dba" class="kq kr it nh b gy oe nn l no np">return (</span><span id="ff16" class="kq kr it nh b gy oe nn l no np">&lt;motion.div</span><span id="fd9f" class="kq kr it nh b gy oe nn l no np">initial="exit"</span><span id="b800" class="kq kr it nh b gy oe nn l no np">animate="enter"</span><span id="f813" class="kq kr it nh b gy oe nn l no np">exit="exit"</span><span id="336e" class="kq kr it nh b gy oe nn l no np">variants={postVariants}</span><span id="80ea" class="kq kr it nh b gy oe nn l no np">&gt;</span><span id="b2ac" class="kq kr it nh b gy oe nn l no np">&lt;Link to="/"&gt;Back to Home page&lt;/Link&gt;</span><span id="b4a4" class="kq kr it nh b gy oe nn l no np">{...}</span><span id="991a" class="kq kr it nh b gy oe nn l no np">&lt;/motion.div&gt;</span><span id="84f0" class="kq kr it nh b gy oe nn l no np">);</span><span id="e81b" class="kq kr it nh b gy oe nn l no np">};</span></pre><p id="d532" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个<a class="ae ko" href="https://reactrouter.com/web/api/match" rel="noopener ugc nofollow" target="_blank">匹配</a>对象包含关于我们的路由路径如何匹配URL的信息。使用<em class="kp"> match </em>，我们可以访问许多有用的属性，但是唯一与我们的情况相关的是post<em class="kp">id(match . params . id)</em>，我们需要它来访问当前帖子的内容。</p><p id="a994" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还定义我们的动画(<em class="kp">后置变量</em>)并将其传递给<em class="kp"> motion.div. </em>的变量</p><p id="b690" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一步是添加<em class="kp">链接</em>，以便能够导航回主页。</p><p id="8f7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仅此而已！现在，每当我们在页面之间导航时，退出动画就会被触发，使这个过程变得流畅。</p><h2 id="73cf" class="kq kr it bd ks kt ku dn kv kw kx dp ky kb kz la lb kf lc ld le kj lf lg lh li bi translated"><a class="ae ko" href="https://codesandbox.io/s/framer-motion-drag-slider-3mggu" rel="noopener ugc nofollow" target="_blank">拖动滑块</a></h2><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a05e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该组件使用<code class="fe ne nf ng nh b">useMotionValue</code>钩子将<code class="fe ne nf ng nh b">x</code>的值(即滑块翻转)更改为拖动手势(drag = "x ")。</p><p id="b3b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用我们已经知道的<em class="kp"/><code class="fe ne nf ng nh b">IntersectionObserver</code><em class="kp"/><code class="fe ne nf ng nh b">FadeInOutBox</code>和<code class="fe ne nf ng nh b">ScaleBox</code>组件，可以将<code class="fe ne nf ng nh b">scale</code> <em class="kp"> \ </em> <code class="fe ne nf ng nh b">fadeIn</code>值传递给<code class="fe ne nf ng nh b">slideApperance</code>道具，为幻灯片的外观添加动画。</p><p id="db71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个滑块远非完美:滑块包装器上的<code class="fe ne nf ng nh b">overflow-x: hidden</code> <em class="kp"> </em>使得它不可能实现鼠标滚轮运动上的滚动。</p><p id="0ebb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，由于某种未知的原因，它经常在最后一张幻灯片上被重置到原始位置。</p><h2 id="02fe" class="kq kr it bd ks kt ku dn kv kw kx dp ky kb kz la lb kf lc ld le kj lf lg lh li bi translated"><a class="ae ko" href="https://codesandbox.io/s/framer-motion-slider-os3kr" rel="noopener ugc nofollow" target="_blank">运动滑块</a></h2><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2bfe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个滑块，不仅可以拖动，也可以控制(箭头和项目符号)。</p><p id="5f3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了在卸载时制作幻灯片状态的动画，我们需要使用<code class="fe ne nf ng nh b">AnimationPresence</code> <em class="kp"> </em>组件并通过<code class="fe ne nf ng nh b">exitBeforeEnter</code> prop在下一个组件渲染之前正确完成其退出动画。</p><p id="ec19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这不是一个完美的例子。特别是子弹动画只在一个方向上起作用，并且使用了<a class="ae ko" href="https://popmotion.io/popcorn/" rel="noopener ugc nofollow" target="_blank">第三方库</a>。</p><h2 id="b5f6" class="kq kr it bd ks kt ku dn kv kw kx dp ky kb kz la lb kf lc ld le kj lf lg lh li bi translated"><a class="ae ko" href="https://codesandbox.io/s/framer-motion-progress-circle-sqy8i" rel="noopener ugc nofollow" target="_blank">进度条</a>和<a class="ae ko" href="https://codesandbox.io/s/framer-motion-progress-bar-beu3h" rel="noopener ugc nofollow" target="_blank">进度条</a></h2><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0312" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些只是在<a class="ae ko" href="https://dribbble.com/global-design-survey-2019" rel="noopener ugc nofollow" target="_blank"> Dribbble的全球设计调查页面</a>上摆弄一些动画，并试图做出类似的东西。</p><p id="048c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一些显示统计信息的组件最好与<code class="fe ne nf ng nh b">IntersectionObserver</code>结合使用。</p><h2 id="56c8" class="kq kr it bd ks kt ku dn kv kw kx dp ky kb kz la lb kf lc ld le kj lf lg lh li bi translated"><a class="ae ko" href="https://codesandbox.io/s/framer-motion-fade-in-up-scale-k1crp" rel="noopener ugc nofollow" target="_blank">渐强框|比例框</a></h2><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="19af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对Dribbble的又一次尝试。</p><p id="ec42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个例子中已经有熟悉的<code class="fe ne nf ng nh b">StaggerWrap</code>组件，用于动画文本的<code class="fe ne nf ng nh b">FadeInUpBox</code>，以及用于动画图像的<code class="fe ne nf ng nh b">ScaleBox</code>。总的来说，动画相当简单，但看起来令人印象深刻，很有趣。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="76ae" class="mg kr it bd ks mh mi mj kv mk ml mm ky mn mo mp lb mq mr ms le mt mu mv lh mw bi translated">总结</h1><p id="5908" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">总的来说，Framer Motion是一个多功能、灵活、现代的React动画库。Motion是一个灵活的工具，对于非常平滑和简单的React动画以及更高级的序列都非常有用。所有这些都使用尽可能少的代码。它的主要问题是其功能的重要部分要么在文档中描述得很差而且很不完整，要么根本没有描述。正因为如此，你可能会花时间去学习，而不是去实现它们。</p><p id="eef1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很高兴如果这个帧运动教程能帮助你弄清楚如何建立自己的运动组件与惊人的动画，并使你的工作至少轻松一点。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="dad2" class="mg kr it bd ks mh mi mj kv mk ml mm ky mn mo mp lb mq mr ms le mt mu mv lh mw bi translated"><strong class="ak">code sandbox中的所有示例</strong></h1><p id="b42b" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated"><a class="ae ko" href="https://codesandbox.io/s/framer-motion-parallax-box-ekqoe" rel="noopener ugc nofollow" target="_blank">视差框</a> <br/> <a class="ae ko" href="https://codesandbox.io/s/framer-motion-intersection-observer-scale-qmtyb" rel="noopener ugc nofollow" target="_blank">交点观察者|比例框</a> <br/> <a class="ae ko" href="https://codesandbox.io/s/framer-motion-stagger-fade-in-up-9gky2" rel="noopener ugc nofollow" target="_blank">淡入框|错开</a> <br/> <a class="ae ko" href="https://codesandbox.io/s/framer-motion-animatepresence-react-router-dom-9dhyn?file=/src/App.js:2205-2220" rel="noopener ugc nofollow" target="_blank">动画效果|路由</a> <br/> <a class="ae ko" href="https://codesandbox.io/s/framer-motion-drag-slider-3mggu" rel="noopener ugc nofollow" target="_blank">拖动滑块</a> <br/> <a class="ae ko" href="https://codesandbox.io/s/framer-motion-slider-os3kr" rel="noopener ugc nofollow" target="_blank">运动滑块</a> <br/> <a class="ae ko" href="https://codesandbox.io/s/framer-motion-progress-circle-sqy8i" rel="noopener ugc nofollow" target="_blank">进度条</a> <br/> <a class="ae ko" href="https://codesandbox.io/s/framer-motion-progress-bar-beu3h" rel="noopener ugc nofollow" target="_blank">进度条</a> <br/> <a class="ae ko" href="https://codesandbox.io/s/framer-motion-fade-in-up-scale-k1crp" rel="noopener ugc nofollow" target="_blank">淡入框|比例框</a></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="b12e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kp">本成帧器运动教程最初发布于2020年1月，2020年12月进行了更新，以使其更加相关和全面。</em></p></div></div>    
</body>
</html>