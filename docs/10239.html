<html>
<head>
<title>Getting Started with Cassandra NoSQl Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Cassandra NoSQl数据库入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-cassandra-nosql-database-4eefb5d57906?source=collection_archive---------12-----------------------#2021-12-15">https://betterprogramming.pub/getting-started-with-cassandra-nosql-database-4eefb5d57906?source=collection_archive---------12-----------------------#2021-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c6b3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Cassandra架构和内部解释</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e828cea38ec3a9d9ac4a938941980810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vLGAzOMpryBjnaP6T8m_QA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@yogidan2012?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丹尼尔·利维斯·佩鲁西</a>在<a class="ae ky" href="https://unsplash.com/s/photos/infinity?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="542a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自从NoSql数据库出现以来，由于内置的水平分区、模式的灵活性以及为其存储的大量数据计算指标/智能元数据的能力，它们一直非常受欢迎。因此，它不是在所有情况下都适用的灵丹妙药；NoSql数据库上的连接可能更难，数据之间的关系可能不是隐式的，读取时间可能更慢，并且没有ACID属性。</p><p id="c6e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大致有5种不同类型的NoSql数据库:</p><ul class=""><li id="3f75" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">键值存储(Key Value Store):可以认为是一个巨大的分布式哈希表。一些流行的例子包括<a class="ae ky" href="https://en.wikipedia.org/wiki/Redis" rel="noopener ugc nofollow" target="_blank"> Redis </a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Couchbase_Server" rel="noopener ugc nofollow" target="_blank"> Couchbase </a>。</li><li id="7c8f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">文档存储</strong>:用于存储和检索类似文档的结构，如JSON、XML等。<code class="fe mj mk ml mm b">Document Store</code>是<code class="fe mj mk ml mm b">Key-Value</code> store的子类，区别在于数据对于键值存储中的数据库来说是不透明的，而文档存储使用文档的底层结构来生成元数据并进一步优化。MongoDB 是一个流行的例子。</li><li id="9143" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">图形</strong>:图形数据库可以看作是在那些文档之间增加了一层关系的文档数据库。</li><li id="b544" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">列式数据库</strong>:多列存储数据的数据库。它类似于二维键值存储。最受欢迎的例子之一是卡珊德拉。</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="1451" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Cassandra由脸书开发并开源，目前正被网飞、苹果、Spotify等公司大量使用。像Cassandra这样的列数据库的优点是，每一列都存储在磁盘上的一个单独的文件中，所以如果只查询某些列，只需要读取它们，而不用用不属于查询的列来解析整行。此外，可以压缩列中的重复顺序数据以提高存储效率。</p><h1 id="13d4" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">卡桑德拉的特征</h1><ul class=""><li id="f74b" class="lv lw it lb b lc nm lf nn li no lm np lq nq lu ma mb mc md bi translated">分布式、非关系型数据存储。</li><li id="3149" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">水平可扩展(低数据密度)。</li><li id="b334" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">设计用于访问模式(i/o操作的类似SQL的数据查询)。</li><li id="6d38" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">无缝数据复制。</li><li id="2988" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">P2P无主模式。避免任何单点故障。</li><li id="89aa" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最终一致的系统。</li></ul><h1 id="a18a" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">Cassandra数据模型</h1><p id="0da2" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">存储在Cassandra中的最小形式的数据可以想象为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/2e6d861e62245754c2f577d80d5ec0a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KqBdVScOnDAMdiMqazjAJw.jpeg"/></div></div></figure><ol class=""><li id="2ca9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nv mb mc md bi translated">列:名称和数据类型</li><li id="fc41" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nv mb mc md bi translated">列族:具有主键的列的列表(可以是其中一列，也可以是组合键)。它有一些属性:</li></ol><ul class=""><li id="e6a2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">key_cached</code>:保存密钥在存储器中的位置。</li><li id="02cb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">row_cahed</code>:在内存中保存整行。</li><li id="d696" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">pre_load_row_cache</code>:预加载行缓存的选项</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/21467955293aad3bf89b7ad8a1ba2d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*joY4k42Qt_VRhOrfEXarEg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">色谱柱系列可视化—作者图片</p></figure><p id="c470" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.超级列族:它是行的列族的子集。它可以用于绑定经常使用的行，但是:</p><ul class=""><li id="8798" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">Cassandra不索引超级列家族中的列。</li><li id="6f28" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">可能会发生内存不足的错误。</li></ul><p id="1edd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.一个柱族或一组柱族成为一个键空间。</p><p id="38b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">密钥空间是Cassandra数据存储中最外面的地方，我们在这里定义复制和副本放置策略。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/c55e8d13b9a5a890589bc8be563498ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vEyiV4kiNr8AtZ3AKmueVA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡珊德拉vs关系数据库—作者图片</p></figure><h2 id="a41b" class="ny mv it bd mw nz oa dn na ob oc dp ne li od oe ng lm of og ni lq oh oi nk oj bi translated">卡珊德拉钥匙</h2><p id="6711" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">主键由两部分组成:</p><ol class=""><li id="7bd9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nv mb mc md bi translated"><strong class="lb iu">分区键</strong>:决定我们的数据放在哪个节点上的键；</li></ol><ul class=""><li id="a446" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用散列函数对分区键进行散列，由此形成的令牌决定数据将位于哪个节点(具有令牌范围)。</li><li id="bee2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">具有相同主键的行将位于相同的节点上，因此在查询时，指定整个分区键是至关重要的。</li></ul><p id="3c72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<strong class="lb iu">聚类键</strong>:数据在具有相同分区键的节点中排序的顺序。因此，范围查询在这里是可能的。</p><p id="cd9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:对于使用任何其他列(而不是主键)的查询，我们需要将它作为二级索引。它通过SS表附加二级索引(SASI)来实现。</p><h2 id="9338" class="ny mv it bd mw nz oa dn na ob oc dp ne li od oe ng lm of og ni lq oh oi nk oj bi translated">查询优先建模</h2><p id="e516" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">由于没有连接，我们需要创建所有的关系表和查询时需要的表。因此，我们需要考虑将在ER上执行的所有查询，然后相应地制作表。</p><h2 id="41bb" class="ny mv it bd mw nz oa dn na ob oc dp ne li od oe ng lm of og ni lq oh oi nk oj bi translated">物化视图</h2><p id="2c0d" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">因为对于每个表，我们需要太多的其他表来执行所有的查询。因此，在更新操作的情况下，我们需要更新多个表，逻辑需要由应用程序自己编写，加上Cassandra是一个NoSQL数据库，不能保证类似ACID的属性。Cassandra用物化视图(MV)解决了这个问题:</p><ol class=""><li id="8dde" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nv mb mc md bi translated">使用MV，我们可以创建从基表到MV的一对一映射。</li><li id="404a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nv mb mc md bi translated">基表上的任何更新都将传播到Mat。卡桑德拉的观点。</li><li id="0cd4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nv mb mc md bi translated">基表的主键必须出现在Mat的主键中。尽管分区和聚集键可以改变。此外，除了主键之外，您最多可以在mat视图的主键中多选择一列。</li></ol><h2 id="6444" class="ny mv it bd mw nz oa dn na ob oc dp ne li od oe ng lm of og ni lq oh oi nk oj bi translated"><strong class="ak">节点和令牌</strong></h2><ul class=""><li id="276c" class="lv lw it lb b lc nm lf nn li no lm np lq nq lu ma mb mc md bi translated">Cassandra集群中的节点被虚拟地放置在一个令牌范围从-2⁶到2⁶ -1的环上。</li><li id="c2d1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当单个节点添加到节点配置为256个令牌的空群集中时。该环被分成256个令牌范围，并且这些范围被给予单个节点。</li><li id="009d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当另一个节点具有256个令牌配置时，第一个节点中的令牌范围被一分为二，并且一半的范围以随机的统一顺序给予第二个节点，依此类推。</li><li id="065f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">因为我们自己进行令牌分配，所以我们进入了从一个节点到另一个节点的下游任务的业务，这对于数据的整个分割是没有效率的。因此，为了获得更高的吞吐量，我们使用vnodes将工作平均分配给所有其他节点。</li></ul><h2 id="1e1e" class="ny mv it bd mw nz oa dn na ob oc dp ne li od oe ng lm of og ni lq oh oi nk oj bi translated">分身术</h2><p id="a3c4" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">在复制属性方面，我们有<em class="ok">复制因子</em>，即我们需要多少份数据副本，以及<em class="ok">复制放置策略</em>，即如何定位和放置每个副本。在一个简单的复制放置策略- &gt;中，副本被放置在环上的下一个虚拟节点上。</p><h2 id="89af" class="ny mv it bd mw nz oa dn na ob oc dp ne li od oe ng lm of og ni lq oh oi nk oj bi translated">一致性</h2><blockquote class="ol"><p id="7973" class="om on it bd oo op oq or os ot ou lu dk translated"><strong class="ak"> <em class="ov"> R + W &gt; N </em> </strong></p></blockquote><ul class=""><li id="99f4" class="lv lw it lb b lc ow lf ox li oy lm oz lq pa lu ma mb mc md bi translated">每个节点都充当协调器节点。</li><li id="96eb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一旦读/写进入任何节点(协调程序),它查看所有节点共有的环形结构，并找到具有相同分区键的节点及其副本。</li><li id="42e9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">然后，它对所有N个副本进行读/写操作，并根据配置(全部、一个、仲裁)将答案返回给协调器，然后返回给应用程序。</li><li id="e8a3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在多个DC的情况下，当请求到达一个节点(协调程序)时，它会在另一个DC中找到一个远程协调程序，并将请求转发到那里。跨DC的一致性配置也可以调整到本地仲裁或每个仲裁</li></ul><h2 id="e173" class="ny mv it bd mw nz oa dn na ob oc dp ne li od oe ng lm of og ni lq oh oi nk oj bi translated">八卦协议</h2><ul class=""><li id="82bb" class="lv lw it lb b lc nm lf nn li no lm np lq nq lu ma mb mc md bi translated">让所有节点互相交谈以使所有节点拥有所有元数据是低效的。</li><li id="af0f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">这种流行病般的算法会看到每个节点随机选择另一个节点并交换它们的数据。然后，每个节点将谈论它们的状态和它们知道的节点的状态。每个节点需要几分钟来了解所有其他节点。</li></ul><h2 id="0f13" class="ny mv it bd mw nz oa dn na ob oc dp ne li od oe ng lm of og ni lq oh oi nk oj bi translated">写路径内部</h2><ol class=""><li id="3aa8" class="lv lw it lb b lc nm lf nn li no lm np lq nq lu nv mb mc md bi translated">书面请求来自协调器节点。</li><li id="d7fe" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nv mb mc md bi translated">然后，它被同时写入提交日志(在磁盘中，日志结构的合并树，每个节点一个)和mem表(在RAM中，每个表一个)。两个操作一完成，ACK就被发回。</li><li id="2cc8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nv mb mc md bi translated">一旦mem表满了，它就被刷新到不可变的SS表中(在磁盘中)。</li><li id="a8e8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nv mb mc md bi translated">在<code class="fe mj mk ml mm b">DELETE</code>操作的情况下，逻辑删除被写入mem表，然后被刷新到SS表。</li></ol><h2 id="5ccf" class="ny mv it bd mw nz oa dn na ob oc dp ne li od oe ng lm of og ni lq oh oi nk oj bi translated">读取路径内部</h2><ol class=""><li id="58db" class="lv lw it lb b lc nm lf nn li no lm np lq nq lu nv mb mc md bi translated">作为第一步，我们检查mem表，它有最新的数据，所以如果请求的行在那里，我们就返回它们。</li><li id="2481" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nv mb mc md bi translated">然后我们尝试解析多个SS表。</li><li id="6967" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nv mb mc md bi translated">读通磁盘是昂贵的。</li><li id="c032" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nv mb mc md bi translated">为了对此进行优化，我们在每个SS表上设置了布隆过滤器和密钥缓存。</li><li id="1dd4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nv mb mc md bi translated">因此，首先它将检查布隆过滤器，以确定所请求的密钥是否存在。如果没有，它将移动到下一个SS表。如果存在，它将检查键缓存，如果存在(键缓存由数据存在的偏移量组成)，它将查看该偏移量并返回数据，如果不存在，它将扫描SS表，该表将按分区键排序，更新键缓存中的偏移量并返回数据。</li></ol><h2 id="5e0f" class="ny mv it bd mw nz oa dn na ob oc dp ne li od oe ng lm of og ni lq oh oi nk oj bi translated">压紧</h2><p id="6acc" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">由于会有多个SS表，Cassandra不时会压缩SS表并删除带有墓碑的值。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="2fc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我结束了对卡珊德拉NoSQL数据库的基本了解。感谢阅读。</p></div></div>    
</body>
</html>