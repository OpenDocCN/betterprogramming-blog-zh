<html>
<head>
<title>How to Migrate From Docker Compose to Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从Docker Compose迁移到Kubernetes</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-migrate-from-docker-compose-to-kubernetes-b57eb229beb2?source=collection_archive---------2-----------------------#2020-05-28">https://betterprogramming.pub/how-to-migrate-from-docker-compose-to-kubernetes-b57eb229beb2?source=collection_archive---------2-----------------------#2020-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8593" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将您的服务从docker-compose文件移动到Kubernetes资源并部署它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f9ce4b90cbcf7221487dce637fe2d25d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lMlyD1JAF3i5JeGN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安德鲁·鲁伊斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="80c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker Compose是一个很棒的工具，可以用来在开发环境中管理Docker容器的创建和部署。但是，它并不是将容器部署到生产环境中的最佳选择，因为它缺少生产部署所需的许多功能，例如构建容器集群以支持容器的高可用性和支持零停机部署。</p><p id="b92c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，Marathon、Nomad、Docker Swarm和Kubernetes等容器编排器是为管理生产环境中的容器部署而构建的。这些系统旨在处理:</p><ul class=""><li id="31c6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">大量运行在容器中的微服务。</li><li id="a81b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用群集和服务复制以高可用性模式托管服务。</li><li id="8786" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">服务的自动恢复、服务发现、资源管理以及许多其他功能。</li></ul><p id="a869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您希望托管高度可用和可靠的服务并避免服务停机，则必须选择其中一种工具来管理生产环境。</p><p id="6974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将逐步描述从Docker Compose到Kubernetes的迁移过程。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4eb0" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">Docker撰写文件</h1><p id="9181" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">下面的要点包含三种服务(MySQL、Rails后端和Nginx反向代理服务)的定义，只需使用下面的命令就可以部署这三种服务:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="7f0c" class="ns mr it no b gy nt nu l nv nw">$&gt; docker-compose up -d</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4b16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用上面的组合文件，并尝试将已定义的服务迁移到Kubernetes对象，并将它们部署在Kubernetes集群中。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a5f1" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">Kubernetes概述</h1><p id="d4d9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><a class="ae ky" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>是世界上许多个人和公司广泛使用的著名容器编排器之一。它最初是由谷歌开发的，目前是一个由CNCF管理的开源项目。</p><p id="c351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes支持与管理容器生命周期相关的各种特性，并且还受到一个庞大社区的支持，该社区包括个人以及大型公司，如IBM、Google、Microsoft和Red Hat。</p><p id="6ef7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与Docker Compose不同，Kubernetes更加灵活和复杂(同时)。例如，Kubernetes提供了几个对象、资源和解决方案来处理容器部署，而Compose只提供服务定义(如上面的文件所示)。此外，它们之间的术语也不同。例如，<code class="fe nz oa ob no b">service</code>对于这些工具来说意味着完全不同的东西。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="1eee" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">库伯内特资源公司</h1><p id="0465" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如上所述，Kubernetes提供了广泛的资源列表。可以使用下面的命令查看这些资源的完整列表:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="b736" class="ns mr it no b gy nt nu l nv nw">$&gt;  kubectl api-resources</span></pre><p id="321f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据需要部署的堆栈，可以消耗和创建这些资源。下面列出了大多数情况下所需的基本资源，并对每种资源进行了简要描述:</p><ul class=""><li id="a89a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nz oa ob no b">PersistenntVolume</code> —集群中的一个调配存储(例如，可以是AWS上的本地或远程存储)。</li><li id="3bb1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nz oa ob no b">PersistenntVolumeClaim</code> —用户或服务对<code class="fe nz oa ob no b">PersistentVolume</code>的请求。</li><li id="24d2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nz oa ob no b">Pod</code> — Kubernetes不支持直接创建容器，Kubernetes中的基本执行对象是Pod，它可能包含一个或多个容器。</li><li id="e3c2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nz oa ob no b">ReplicaSet</code> —负责维护给定应用程序副本的稳定状态的资源。</li><li id="5aee" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nz oa ob no b">Deployment</code> —管理容器部署周期事件，如滚动更新、撤消更改、暂停和恢复更改。</li><li id="7786" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nz oa ob no b">Service</code> —负责实现部署的应用程序之间的通信。</li><li id="c43b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nz oa ob no b">Ingress</code> —向外部世界公开内部服务。</li></ul><p id="30e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些资源的定义包括四个主要部分，如下所示:</p><ul class=""><li id="1edc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">apiVersion —资源的API版本。</li><li id="ed52" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">种类—资源的类型。</li><li id="37b3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">元数据—应附加到资源的元数据，如标签和名称。</li><li id="0184" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">规范—定义已定义资源的规范和配置。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b6f0" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">部署MySQL</h1><p id="0df9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">为了能够将MySQL应用程序部署到Kubernetes，我们需要创建以下Kubernetes资源:</p><ul class=""><li id="c5b6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nz oa ob no b">PersistentVolume</code>:由于MySQL服务需要在磁盘上保存数据，我们需要使用与Compose相同的卷。否则，数据将存储在容器中，一旦容器被重新创建，数据将会丢失。下面的YAML文件定义了1Gi容量的<code class="fe nz oa ob no b">hostPath</code>和<code class="fe nz oa ob no b">PersistentVolume</code>资源。将在主机上创建数据卷。不建议将数据直接存储在主机上，尤其是如果将pod配置为在集群上的不同节点上进行调度。在这种情况下，应使用其他<a class="ae ky" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes" rel="noopener ugc nofollow" target="_blank">卷插件</a>。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><ul class=""><li id="dab5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nz oa ob no b">PersistentVolumeClaim</code>:创造一个<code class="fe nz oa ob no b">PersistentVolume</code>不足以能够使用它。还需要请求使用创建的卷，这个请求可以使用<code class="fe nz oa ob no b">PersistentVolumeClaim</code>来完成。根据下面的文件，我们请求使用500毫升的<code class="fe nz oa ob no b">PersistentVolume</code>容量。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><ul class=""><li id="c9aa" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nz oa ob no b">Deployment</code>:<code class="fe nz oa ob no b">Deployment</code>资源将负责创建应用程序的<code class="fe nz oa ob no b">Replicaset</code>，应用程序的容器将由创建的<code class="fe nz oa ob no b">ReplicaSet</code>对象管理。<code class="fe nz oa ob no b">Deployment</code>资源的定义应包含以下部分:</li></ul><ol class=""><li id="cc73" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu oc mb mc md bi translated">副本:应该从应用程序创建的副本数量。</li><li id="0708" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oc mb mc md bi translated">选择器:用于选择由部署管理的单元的条件。如下面的代码片段所示，部署将管理所有带有标签<code class="fe nz oa ob no b">app=mysqldb-pod</code>的pod。</li><li id="3316" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oc mb mc md bi translated">模板:<strong class="lb iu"> </strong>将用于创建和管理窗格的窗格模板。如下所示，该模板包括pod标签、容器规格、附件等。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><ul class=""><li id="f028" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nz oa ob no b">Service</code>:需要<code class="fe nz oa ob no b">Service</code>资源才能与MySQL pods通信。可以直接在其IP上访问服务单元，但在复制的情况下，更容易拥有一个服务IP来平衡服务单元之间的负载。服务资源的规范必须包括以下部分:</li></ul><ol class=""><li id="c754" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu oc mb mc md bi translated">类型:服务的类型。Kubernetes支持几种<a class="ae ky" href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types" rel="noopener ugc nofollow" target="_blank">服务类型</a>来管理内部和外部通信。外部服务不应访问MySQL服务。因此，我们将使用一个<code class="fe nz oa ob no b">ClusterIP</code>类型。该服务将在集群级别公开，并且可以由集群中的任何pod访问。</li><li id="8aff" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oc mb mc md bi translated">选择器:<strong class="lb iu"> </strong>选择服务管理的pod的条件。</li><li id="50ce" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oc mb mc md bi translated">端口:定义服务端和容器端端口的端口映射。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b5c7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">部署后端应用</strong></h1><p id="887f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">部署Rails应用程序可以用与MySQL应用程序相同的方式完成，除了我们不需要<code class="fe nz oa ob no b">PersistentVolume</code>资源，因为它不持久存储任何数据。下面是部署Rails应用程序所需的资源:</p><ul class=""><li id="e242" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nz oa ob no b">Deployment</code>:<code class="fe nz oa ob no b">Deployment</code>对象将定义后端应用程序容器模板，并传递将应用程序连接到MySQL数据库所需的环境变量。注意，我们使用上面定义的MySQL服务名从后端应用程序连接到数据库。Kubernetes中的服务发现服务将负责把这个名称翻译成服务IP。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><ul class=""><li id="0bee" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">服务:可以使用<code class="fe nz oa ob no b">NodePort</code>或<code class="fe nz oa ob no b">Loadbalancer</code>服务在主机上直接公开Rails服务(例如，在端口80上)。但是，使用这种方法，不可能在同一个端口上使用其他服务，并且很难用这种方法管理大量服务。因此，建议使用<code class="fe nz oa ob no b">ClusterIP</code>管理服务，使用<code class="fe nz oa ob no b">Ingress</code>控制器管理外部通信。下面是Rails服务定义文件:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f8bb" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">部署入口控制器</h1><p id="86b4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">构建一个<code class="fe nz oa ob no b">Ingress</code>控制器并向外界公开内部服务包括以下步骤:</p><ul class=""><li id="7242" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">创建默认的后端服务:当请求的URL不能映射到任何已定义的服务时，<code class="fe nz oa ob no b">Ingress</code>控制器将使用默认的后端服务。默认的后端服务可以是任何服务，只要它在根路由上响应404错误，在<code class="fe nz oa ob no b">healthz</code>端点上响应200错误。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><ul class=""><li id="1f9c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nz oa ob no b">Ingress</code>控制器是负责处理传入请求并将请求代理到各自服务的应用程序。如下面的代码片段所示，<code class="fe nz oa ob no b">Ingress</code>控制器被配置为使用上面定义的服务作为默认的后端服务:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><ul class=""><li id="0af6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nz oa ob no b">Ingress</code>服务:使用<code class="fe nz oa ob no b">LoadBalancer</code>服务在主机上暴露<code class="fe nz oa ob no b">Ingress</code>控制器是很重要的(也可以使用<code class="fe nz oa ob no b">NodePort</code>来完成)。下面的服务定义公开了端口80和443上的<code class="fe nz oa ob no b">Ingress</code>控制器:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><ul class=""><li id="ea7f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nz oa ob no b">Ingress</code>规则:这个资源是配置<code class="fe nz oa ob no b">Ingress</code>控制器所需要的信息，以便将请求代理给Rails应用程序。从下面的<code class="fe nz oa ob no b">Ingress</code>定义中，我们可以看到主机<code class="fe nz oa ob no b">rails.lvh.me</code>的请求将被重定向到端口8080上的Rails服务:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b58b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以使用以下命令之一将上面创建的资源部署到Kubernetes集群:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="2070" class="ns mr it no b gy nt nu l nv nw">$&gt;  kubectl apply -f ${filename}<br/>$&gt;  kubectl create -f ${filename}</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="983f" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="899b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">部署到Kubernetes集群比使用Docker Compose部署更复杂。然而，由于其灵活性、可靠性和特性，Kubernetes是将容器部署到生产环境中最常用的编排工具之一。</p><p id="ae86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文中展示的部署的完整实现可以在GitHub 上找到<a class="ae ky" href="https://github.com/wshihadeh/migratetoK8s" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>