<html>
<head>
<title>How To Implement JSON Web Token (JWT) in Java Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Java Spring Boot中实现JSON Web Token (JWT)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-json-web-token-jwt-in-java-spring-boot-943084ad1592?source=collection_archive---------7-----------------------#2022-08-04">https://betterprogramming.pub/how-to-implement-json-web-token-jwt-in-java-spring-boot-943084ad1592?source=collection_archive---------7-----------------------#2022-08-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4c01" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这一有用功能的简要指南</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/f9d43d06db26763e97c56c1fdfd26b7a.png" data-original-src="https://miro.medium.com/v2/0*l2iewA5vBhS7YFso"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来自Pixabay</p></figure><p id="5725" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JSON Web Token或JWT作为一种服务间安全通信的方式而闻名。JWT有两种形式:JWS和JWE。他们之间的区别是，JWS的有效载荷没有加密，而JWE是。</p><p id="3675" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文将探讨Java Spring Boot中JWT的实现。如果你想更多地了解JWT本身，你可以在这里访问我的另一篇文章<a class="ae lq" href="https://codecurated.com/blog/introduction-to-jwt-jws-jwe-jwa-jwk/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="7ace" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文中的代码托管在以下GitHub存储库中:<a class="ae lq" href="https://github.com/brilianfird/jwt-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/brilianfird/jwt-demo</a>。</p><h1 id="49dd" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">图书馆</h1><p id="67a8" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">对于本文，我们将使用<code class="fe mo mp mq mr b">jose4j</code>库。<code class="fe mo mp mq mr b">jose4j</code>是Java中流行的JWT库之一，具有完整的特性。如果你想看看其他的库(不管是不是针对Java的)，jwt.io 整理了一个列表。</p><pre class="ki kj kk kl gt ms mr mt mu aw mv bi"><span id="37c0" class="mw ls it mr b gy mx my l mz na">&lt;dependency&gt;  <br/>    &lt;groupId&gt;org.bitbucket.b_c&lt;/groupId&gt;  <br/>    &lt;artifactId&gt;jose4j&lt;/artifactId&gt;  <br/>    &lt;version&gt;0.7.12&lt;/version&gt;  <br/>&lt;/dependency&gt;</span></pre><h1 id="408d" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">用Java实现JWS</h1><p id="b024" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">JSON网络签名(JWS)由三部分组成:</p><ul class=""><li id="6690" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">何塞·海德</li><li id="b14d" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">有效载荷</li><li id="c3d7" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">签名</li></ul><p id="0587" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看一个何塞标题的例子:</p><pre class="ki kj kk kl gt ms mr mt mu aw mv bi"><span id="7311" class="mw ls it mr b gy mx my l mz na">{<br/>	alg:"HS264"<br/>}</span></pre><p id="c21b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JOSE header存储了关于如何处理JWS的元数据。<br/> <code class="fe mo mp mq mr b">alg</code>存储关于JWT使用的签名算法的信息。</p><p id="8861" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们检查有效载荷:</p><pre class="ki kj kk kl gt ms mr mt mu aw mv bi"><span id="8f6c" class="mw ls it mr b gy mx my l mz na">{<br/>  "sub": "1234567890",<br/>  "name": "Brilian Firdaus",<br/>  "iat": 1651422365<br/>}</span></pre><p id="8225" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JSON payload存储我们想要传输给客户机的数据。它还储存了一些JWT声称的信息，我们可以核实。</p><p id="75b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上例中，我们有三个注册为JWT索赔的字段。</p><ul class=""><li id="1101" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated"><code class="fe mo mp mq mr b">sub</code>表示用户的唯一id</li><li id="5ec1" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe mo mp mq mr b">name</code>表示用户的姓名</li><li id="0956" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe mo mp mq mr b">iat</code>表示我在一个纪元中创造JWT的时候</li></ul><p id="d90a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后一部分是签名，这是使JWS安全的部分。通常，JWS的签名将以字节的形式出现。让我们看一个Base64编码签名的例子:</p><pre class="ki kj kk kl gt ms mr mt mu aw mv bi"><span id="1710" class="mw ls it mr b gy mx my l mz na">qsg3HKPxM96PeeXl-sMrao00yOh1T0yQfZa-BsrtjHI</span></pre><p id="0e3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果我们看到上面的三个部分，您可能会想知道如何将这三个部分无缝地传递给消费者。答案是紧凑序列化。使用紧凑序列化，我们可以轻松地与消费者共享JWS，因为JWS将成为一个长字符串。</p><pre class="ki kj kk kl gt ms mr mt mu aw mv bi"><span id="a832" class="mw ls it mr b gy mx my l mz na">Base64.encode(JOSE Header) + "." + Base64.encode(Payload) + "." + Base64.encode(signature)</span></pre><p id="b894" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果将是:</p><pre class="ki kj kk kl gt ms mr mt mu aw mv bi"><span id="0ee4" class="mw ls it mr b gy mx my l mz na">eyJhbGciOiJIUzI1NiIsImtpZCI6IjIwMjItMDUtMDEifQ.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkJyaWxpYW4gRmlyZGF1cyIsImlhdCI6MTY1MTQyMjM2NX0.qsg3HKPxM96PeeXl-sMrao00yOh1T0yQfZa-BsrtjHI</span></pre><p id="5cd7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在JWT规范中，紧凑序列化部分也是强制性的。因此，要将JWS视为JWT，我们必须进行紧凑的序列化。</p><h1 id="694d" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">无保护的</h1><p id="aebd" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们将探索的第一种JWS是没有保护的JWS。人们很少使用这种类型的JWS(基本上只是一个普通的JSON)，但是让我们先来研究一下，以了解实现的基础。</p><p id="decf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从创建标题开始。与之前使用<code class="fe mo mp mq mr b">HS256</code>算法的例子不同，现在我们不使用任何算法。</p><h1 id="cb50" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated"><strong class="ak">生产无保护的JWS </strong></h1><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ea7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看我们在代码中做了什么:</p><ul class=""><li id="c06f" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">我们设置了一堆索赔(<code class="fe mo mp mq mr b">sub</code>、<code class="fe mo mp mq mr b">iat</code>、<code class="fe mo mp mq mr b">exp</code>、<code class="fe mo mp mq mr b">iss</code>、<code class="fe mo mp mq mr b">name</code>、<code class="fe mo mp mq mr b">email</code>、<code class="fe mo mp mq mr b">email_verified</code>)</li><li id="39a6" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">我们将签名算法设置为<code class="fe mo mp mq mr b">NONE</code>并将算法约束设置为<code class="fe mo mp mq mr b">NO_CONSTRAINT</code>，因为<code class="fe mo mp mq mr b">jose4j</code>会因为算法缺乏安全性而抛出异常</li><li id="fde0" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">我们将JWS打包在紧凑序列化中，这将产生一个包含JWS的字符串。结果是一个JWT编译的字符串。</li></ul><p id="c34d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看调用<code class="fe mo mp mq mr b">jws.getCompactSerialization()</code>会得到什么输出:</p><pre class="ki kj kk kl gt ms mr mt mu aw mv bi"><span id="ca25" class="mw ls it mr b gy mx my l mz na">eyJhbGciOiJub25lIn0.eyJzdWIiOiI3NTYwNzU1ZS1mNDVkLTRlYmItYTA5OC1iODk3MWMwMmViZWYiLCJpYXQiOjE2NTI1NTYyNjYsImV4cCI6MTY1MzE2MTA2NiwiaXNzIjoiaHR0cHM6Ly9jb2RlY3VyYXRlZC5jb20iLCJuYW1lIjoiQnJpbGlhbiBGaXJkYXVzIiwiZW1haWwiOiJicmlsaWFuZmlyZEBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZX0.</span></pre><p id="8509" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们尝试解码它，我们将得到带有我们之前设置的字段的JWS:</p><pre class="ki kj kk kl gt ms mr mt mu aw mv bi"><span id="5dfb" class="mw ls it mr b gy mx my l mz na">{<br/>  "header": {<br/>    "alg": "none"<br/>  },<br/>  "payload": {<br/>    "sub": "7560755e-f45d-4ebb-a098-b8971c02ebef",<br/>    "iat": 1652556266,<br/>    "exp": 1653161066,<br/>    "iss": "https://codecurated.com",<br/>    "name": "Brilian Firdaus",<br/>    "email": "brilianfird@gmail.com",<br/>    "email_verified": true<br/>  }<br/>}</span></pre><p id="c0c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经成功地用Java的<code class="fe mo mp mq mr b">jose4j</code>库创建了一个JWT！现在，让我们继续JWT消费过程。</p><p id="525e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了使用JWT，我们可以使用<code class="fe mo mp mq mr b">jose4j</code>库中的<code class="fe mo mp mq mr b">JwtConsumer</code>类。让我们看一个例子:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="461c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过使用<code class="fe mo mp mq mr b">JwtConsumer</code>，我们可以很容易地制定关于在处理传入的JWT时验证什么的规则。它还提供了一种简单的方法，通过分别使用<code class="fe mo mp mq mr b">.getJoseObjects()</code>和<code class="fe mo mp mq mr b">getJwtClaims()</code>来获得JWS对象和声明。</p><p id="6f7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然我们知道了如何在没有签名算法的情况下生产和消费JWT，那么理解有签名算法的情况就容易多了。不同之处在于，我们需要设置算法并创建密钥来生成/验证JWT。</p><h1 id="700a" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">HMAC·SHA-256</h1><p id="ddc5" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">HMAC SHA-256( <code class="fe mo mp mq mr b">HS256</code>)是一个带有对称密钥的MAC函数。我们将需要为它的密钥生成至少32个字节，并将其提供给<code class="fe mo mp mq mr b">jose4j</code>库中的<code class="fe mo mp mq mr b">HmacKey</code>类，以确保安全性。</p><p id="8682" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用Java中的<code class="fe mo mp mq mr b">SecureRandom</code>库来确保密钥的随机性。</p><pre class="ki kj kk kl gt ms mr mt mu aw mv bi"><span id="5b40" class="mw ls it mr b gy mx my l mz na">byte[] key = new byte[32];  <br/>  <br/>SecureRandom secureRandom = new SecureRandom();  <br/>secureRandom.nextBytes(key);<br/><br/>HmacKey hmacKey = new HmacKey(key);</span></pre><p id="9ee9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">密钥应被视为凭证。因此，它应该存储在一个安全的环境中。作为建议，可以将其存储为环境变量或者存储在[Vault]中(https://www.vaultproject.io/)。</p><p id="b5c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看如何创建和消费与<code class="fe mo mp mq mr b">HS256</code>签约的JWT:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b552" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与创建没有签名算法的JWS相比，代码没有太大区别。我们首先使用<code class="fe mo mp mq mr b">SecureRandom</code>和<code class="fe mo mp mq mr b">HmacKey</code>类制作密钥。因为<code class="fe mo mp mq mr b">HS256</code>使用对称密钥，所以我们只需要一个密钥来签名和验证JWT。</p><p id="f979" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还通过使用<code class="fe mo mp mq mr b">jws.setAlgorithmheaderValue(AlgorithmIdentifiers.HMAC_SHA256</code>和带有<code class="fe mo mp mq mr b">jws.setKey(hmacKey)</code>的密钥将算法头值设置为<code class="fe mo mp mq mr b">HS256</code>。</p><p id="1ecb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在JWT消费者中，我们只需要通过使用<code class="fe mo mp mq mr b">jwtConsumer</code>对象上的<code class="fe mo mp mq mr b">.setVerificationKey(hmacKey)</code>来设置HMAC密钥<code class="fe mo mp mq mr b">jose4j</code>将通过解析其JOSE报头来自动确定JWS中使用的算法。</p><h1 id="4759" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">ES256</h1><p id="287d" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">与只需要一个密钥的<code class="fe mo mp mq mr b">HS256</code>不同，我们需要为<code class="fe mo mp mq mr b">ES256</code>算法生成两个密钥:私钥和公钥。</p><p id="a609" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用私钥来创建和验证JWT，而我们只能使用公钥来验证JWT。由于这些特点，私钥通常作为凭证存储，而公钥可以作为JWK公开托管，因此JWT的消费者可以查询主机并自己获得密钥。</p><p id="7003" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mo mp mq mr b">jose4j</code>库提供了一个简单的API来生成私有和公共密钥作为JWK。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="51cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们知道了如何用<code class="fe mo mp mq mr b">ES256</code>算法生成创建JWT的密钥，这与用<code class="fe mo mp mq mr b">HS256</code>算法创建JWT几乎是一样的。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0ba9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">唯一不同的是:</p><ul class=""><li id="5984" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">我们将算法头设为<code class="fe mo mp mq mr b">ECDSA_USING_P256_CURVE_AND_SHA256</code></li><li id="ff4e" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">我们在创建JWT时使用私钥</li><li id="8b3f" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">我们使用公钥来验证JWT</li></ul><h1 id="363d" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">主持JWK</h1><p id="1c43" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们可以使用<code class="fe mo mp mq mr b">JsonWebKeySet</code>类轻松创建JSON Web Key Set。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="034b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还需要更改密钥解析器的一些属性:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a81f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们托管了JSON Web密钥集，所以我们需要查询主机。<code class="fe mo mp mq mr b">jose4j</code>也通过使用<code class="fe mo mp mq mr b">HttpsJwksVerificationKeyResolver</code>提供了一种简单的方法。</p><h1 id="7013" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">用Java实现JWE</h1><p id="2fb1" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">与JWS不同，JSON Web Encryption是一种JWT，它被加密，所以除了有私钥的人之外，没有人能看到它的内容。首先，让我们看一个例子:</p><pre class="ki kj kk kl gt ms mr mt mu aw mv bi"><span id="b20a" class="mw ls it mr b gy mx my l mz na">eyJhbGciOiJFQ0RILUVTK0EyNTZLVyIsImVuYyI6IkExMjhDQkMtSFMyNTYiLCJlcGsiOnsia3R5IjoiRUMiLCJ4IjoiMEdxMEFuWUk1RVFxOUVZYjB4dmxjTGxKanV6ckxhSjhUYUdHYzk5MU9sayIsInkiOiJya1Q2cjlqUWhjRU1xaGtubHJ6S0hVemFKMlhWakFpWGpIWGZYZU9aY0hRIiwiY3J2IjoiUC0yNTYifX0.DUrC7Y_ejpt1n9c8wXetwU65sxkEYxG6RBsCUdokVODJBtwypL9VjQ.ydZx-UDWDN7jbGeESXvPHg.6ksHUeeGgGj0txFNXmsSQUCnAv52tJuGR5vgrX54vnLkryPFv2ATdLwYXZz3mAjeDes4s9otz4-Fzg1IBZ4qsfCVa6_3CVdkb8BTU4OvQx23SFEgtj8zh-8ZrqZbpKIT.p-E09mQIleNCCmwX3YL-uQ</span></pre><p id="4e71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JWE的结构是:</p><pre class="ki kj kk kl gt ms mr mt mu aw mv bi"><span id="1b26" class="mw ls it mr b gy mx my l mz na">BASE64URL(UTF8(JWE Protected Header)) || ’.’ ||<br/>BASE64URL(JWE Encrypted Key) || ’.’ ||<br/>BASE64URL(JWE Initialization Vector) || ’.’ ||<br/>BASE64URL(JWE Ciphertext) || ’.’ ||<br/>BASE64URL(JWE Authentication Tag)</span></pre><p id="24ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">而如果我们解密JWE，我们会得到如下的说法:</p><pre class="ki kj kk kl gt ms mr mt mu aw mv bi"><span id="fc08" class="mw ls it mr b gy mx my l mz na">{<br/>	"iss":"https://codecurated.com",<br/>	"exp":1654274573,<br/>	"iat":1654256573,<br/>	"sub":"12345"<br/>}</span></pre><p id="209b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们看看如何创建JWE:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="864f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与JWS相比，创造和消费JWE的主要区别在于:</p><ul class=""><li id="e8ff" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">我们使用公钥作为加密密钥，使用私钥作为解密密钥</li><li id="d068" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">我们在JWE没有签名，所以消费者需要跳过签名要求</li></ul><h1 id="fa2e" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="9dd1" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在本文中，我们已经学会了使用<code class="fe mo mp mq mr b">jose4j</code>在Java中创建JWS和JWE。</p><p id="aa50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望这篇文章对你有用。如果你想了解更多关于JWT的概念，你可以访问<a class="ae lq" href="https://codecurated.com/blog/introduction-to-jwt-jws-jwe-jwa-jwk/" rel="noopener ugc nofollow" target="_blank">我的另一篇文章。</a></p></div></div>    
</body>
</html>