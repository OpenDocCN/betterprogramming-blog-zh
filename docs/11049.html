<html>
<head>
<title>Understanding TypeScript Errors for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者理解打字稿错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-typescript-errors-for-beginners-65d15f3e3561?source=collection_archive---------7-----------------------#2022-02-14">https://betterprogramming.pub/understanding-typescript-errors-for-beginners-65d15f3e3561?source=collection_archive---------7-----------------------#2022-02-14</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="5db7" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">如何减轻编译错误的认知负担，让您开始觉得使用TypeScript很有效率</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/15b2e356d86297fd4c6854cc97b3e82f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bjZyvdxyjr6xcykQMuaqxA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者插画的矢量艺术</p></figure><p id="6370" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">最近，我在Twitter上看到了一些关于TypeScript的激烈辩论，这恰好与我让一些新开发人员加入一个基于TypeScript的项目不谋而合。</p><p id="d9be" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这一切都始于詹姆斯·龙(James Long)的一条推文，他是一名有着15年经验的开发人员，他质疑它在非常具体的情况下是否有用。我过去加入的开发人员对TypeScript也有类似的看法。他们断言这是不值得的，学习曲线太长，并且会降低项目新开发人员的生产力。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lv lw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">James Long的推文——我仍然不相信探索架构是值得的</p></figure><p id="053d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我想回应这条推文，并提供我的观点，但已经有这么多的回应，我不想堆积。如此多的人热情地为TypeScript辩护，以至于龙先生最终发出了一些其他的推文，包括下面的。我感觉很糟糕——社区应该欢迎和接受新的想法，而不是排斥一个基本的想法，以至于产生抵触情绪。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="lv lw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">詹姆斯·朗的推特——永远不要发关于TypeScript的推特</p></figure><p id="603a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我相信Long先生遇到的只是一些关于TypeScript的额外认知开销，当定期使用TypeScript时，这些开销会随着时间的推移而减少。即使在重新架构或者不断重构的时候，如果你已经习惯了的话，在编写剩余代码的过程中，改变类型仍然只占很小一部分时间。</p><p id="b57f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">不仅如此，有时候重构真的有助于确保你不会错过任何东西。</p><p id="7dd6" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">但是，我想我应该写一篇文章来帮助TypeScript初学者最小化解码一些更隐晦的TypeScript错误的认知开销，以便他们可以更快地提高工作效率，而不是堆积在tweet响应上。因为，归根结底，这场争论是关于生产率，而不是类型安全。下面是我看到的新TypeScript开发人员遇到的一些妨碍他们工作效率的更常见的问题。</p><h1 id="73ce" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">“不可分配”错误并不总是指分配运算符- TS(2322)</h1><p id="5715" class="pw-post-body-paragraph kz la iu lb b lc mp jv le lf mq jy lh li mr lk ll lm ms lo lp lq mt ls lt lu in bi translated">当我第一次开始使用TypeScript时，我最大的挫折之一是一些错误消息的不确定性。来自像Scala和Rust这样的强类型语言——其中的错误消息往往会告诉你到底哪里出了问题，以及如何修复它(在Rust的情况下，它还会为你点一份披萨，给你按摩一下脖子🤣)—我觉得TypeScript中的错误信息有时会让我陷入徒劳无功的境地。</p><p id="cb22" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">最让我沮丧的错误消息是<code class="fe mu mv mw mx b">not assignable ts(2322) </code>错误。清单1提供了这样一个错误消息的例子。我会对整个项目进行解析，试图找到我试图将一个“字符串”赋给一个“数字”的地方(使用示例中的类型)，结果却发现“这个文件中根本没有赋值操作符！”</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="my lw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">清单1 —引用TypeScript函数的返回类型的错误消息</p></figure><p id="6830" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我最终意识到，有时<code class="fe mu mv mw mx b">ts(2322)</code>只是说一个函数不能返回你在返回语句中提供的类型。在这个例子中，当我实际上将函数定义为需要返回一个<code class="fe mu mv mw mx b">number</code>时，我试图返回一个<code class="fe mu mv mw mx b">string</code>。</p><p id="74e4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在其他语言中，编译器会明确地告诉我，我正试图从一个函数返回错误的类型。但是在TypeScript中(它更像是一个静态类型分析器，而不是一个成熟的强类型语言),它反而说我试图给<em class="mz">分配</em>错误的类型。</p><p id="a532" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">下面的表达式(实际上有一个赋值操作符)会抛出同样的错误消息:<code class="fe mu mv mw mx b">const exampleNumber: number = 'ab'</code>。所以你可以明白为什么这让我如此困惑。也就是说，一旦我意识到这种情况正在发生，我就开始在遇到<code class="fe mu mv mw mx b">ts(2322)</code>时检查这个场景。</p><p id="8d7a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">现在，这个错误信息是我的第二天性。理解TypeScript就是重复，看到一个错误模式，然后一遍又一遍地解决它。</p><h1 id="88a6" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">找不到模块TS的声明文件(7016)</h1><p id="b2dd" class="pw-post-body-paragraph kz la iu lb b lc mp jv le lf mq jy lh li mr lk ll lm ms lo lp lq mt ls lt lu in bi translated">新的TypeScript开发人员在基于TypeScript的项目中遇到的一个非常常见的问题是“找不到模块的声明文件…”错误。这个错误只是告诉您，您从npm导入的模块没有任何关联的类型，这意味着它是用JavaScript开发的，或者npm没有附带任何类型文件。</p><p id="e327" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">幸运的是，正如您在清单2中看到的，错误消息非常有用。它告诉你要解决这个问题，安装来自<code class="fe mu mv mw mx b">@types</code>“确定类型”模块的类型。“明确类型化”是npm上的一个开源名称空间，贡献者可以在其中为他们喜欢的项目发布类型文件，这些项目没有开箱即用的类型。你可以去<a class="ae na" href="https://definitelytyped.org/" rel="noopener ugc nofollow" target="_blank">明确键入的</a>网站<a class="ae na" href="https://www.typescriptlang.org/dt/search?search=" rel="noopener ugc nofollow" target="_blank">搜索你的包</a>看看是否存在。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="my lw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">清单TypeScript中ts(7016)错误消息的示例</p></figure><p id="4e23" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果您的包不存在于明确类型上，您可以通过在类型声明文件中声明一个同名的模块来退出对该特定模块的类型检查。清单3显示了这样一个声明的例子。正如您所看到的，如果您在项目的根目录下添加一个<code class="fe mu mv mw mx b">declarations.d.ts</code>文件，并确保有一个针对抛出错误的模块的声明，<code class="fe mu mv mw mx b">ts(7016)</code>应该会消失。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="my lw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">清单3 —示例类型声明文件。</p></figure><h1 id="869c" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">无商标消费品</h1><p id="48e2" class="pw-post-body-paragraph kz la iu lb b lc mp jv le lf mq jy lh li mr lk ll lm ms lo lp lq mt ls lt lu in bi translated">我经常看到刚接触TypeScript的开发人员擅长在他们不理解的代码中复制模式，但最终会在出现问题时询问他们。泛型就是这样一种模式。问题最终出现了，“这些尖括号实际上是什么意思？”</p><p id="6fa5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">那些尖括号指的是泛型类型，你必须理解泛型，才能读懂类型错误。一个<a class="ae na" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a>是由TypeScript提供的一个工具，它允许开发者创建一个可重用的API，下游开发者实际上可以向API提供他们自己的类型来影响它的行为。泛型的<a class="ae na" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank"> TypeScript文档实际上非常好，所以我建议阅读一下以了解更多信息。</a></p><h1 id="729b" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">处理未定义的错误</h1><p id="8711" class="pw-post-body-paragraph kz la iu lb b lc mp jv le lf mq jy lh li mr lk ll lm ms lo lp lq mt ls lt lu in bi translated">TypeScript初学者的另一个常见错误是认为因为没有编译时错误，所以也就没有运行时错误。例如，我见过工程师从HTTP请求的响应中提供预期的类型，TypeScript编译器在整个应用程序中以这种方式处理响应，因此没有编译时错误。</p><p id="7e0d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">但是，一旦应用程序运行并且从服务器返回一个对象，整个应用程序就会崩溃，出现白屏死机(在React应用程序没有错误边界的情况下),并且控制台中会出现一条错误消息:</p><blockquote class="nb"><p id="fb85" class="nc nd iu bd ne nf ng nh ni nj nk lu dk translated"><code class="fe mu mv mw mx b">undefined</code>的<code class="fe mu mv mw mx b">id’</code>无法读取属性。"</p></blockquote><p id="b556" class="pw-post-body-paragraph kz la iu lb b lc nl jv le lf nm jy lh li nn lk ll lm no lo lp lq np ls lt lu in bi translated">房地产<code class="fe mu mv mw mx b">id</code>只是这个特定信息中的一个例子。但重要的是，您要理解来自应用程序外部的数据并不一定是您所说的那种类型。因此，任何时候你使用<code class="fe mu mv mw mx b">as</code>关键字或者在API中使用泛型来转换类型，都有可能转换值，你需要明白那里有运行时错误的机会。</p><p id="cf3b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">处理这种特殊错误的常见方法是使用可选的链接和nullish合并操作符。清单4提供了这些操作符的一个例子。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="my lw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">清单4 —可选链接和无效合并的示例</p></figure><p id="818c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如您所见，可选链接中提供的问号防止我们得到<code class="fe mu mv mw mx b">Cannot read property 'type' of undefined</code>错误。如果表达式的左边为空或未定义，双问号(nullish合并)允许我们默认为另一个值。</p><p id="1239" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">之所以有必要这样做，是因为第1行中提供给API的<code class="fe mu mv mw mx b">&lt;Character&gt;</code>泛型将响应转换为<code class="fe mu mv mw mx b">Character</code>类型，它假设在<code class="fe mu mv mw mx b">Character</code>接口中定义的所有属性都可用。</p><h1 id="2c9e" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">属性“X”在类型“Y”上不存在— TS(2339)</h1><p id="1a08" class="pw-post-body-paragraph kz la iu lb b lc mp jv le lf mq jy lh li mr lk ll lm ms lo lp lq mt ls lt lu in bi translated">我见过许多初学者在知道他们试图使用的类型上存在一个属性时，对这个错误感到沮丧。通常，他们会遇到比他们试图使用的类型更不具体或抽象的类型，这意味着他们试图访问的属性类型是函数允许他们使用的类型的扩展。</p><p id="d0e7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">另一种可能的情况是，他们需要使用的类型实际上是联合类型，因此类型系统将只允许他们使用那些联合类型共有的属性(否则无法保证他们想要使用的类型将是可用的)。清单5提供了一个扩展类型和联合类型的例子。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="my lw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">清单5 —如何使用类型保护来处理类型扩展和联合类型。</p></figure><p id="dd20" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在本例中，属性<code class="fe mu mv mw mx b">gender</code>仅在类型<code class="fe mu mv mw mx b">Character</code>上可用，在类型<code class="fe mu mv mw mx b">Noun</code>或类型<code class="fe mu mv mw mx b">Setting</code>上不可用。因此，试图从函数内部访问<code class="fe mu mv mw mx b">gender</code>将会抛出一个<code class="fe mu mv mw mx b">ts(2339)</code> TypeScript错误。</p><p id="0463" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在清单5的第一个例子中，<code class="fe mu mv mw mx b">Noun</code>类型与<code class="fe mu mv mw mx b">Character</code>和<code class="fe mu mv mw mx b">Setting</code>都有共同的属性，但是由于函数需要一个<code class="fe mu mv mw mx b">Noun</code>(<code class="fe mu mv mw mx b">Character</code>和<code class="fe mu mv mw mx b">Setting</code>都扩展了它，因此可以作为有效类型传递给这个函数)，所以它只能访问共同的属性。</p><p id="115f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在示例2中也是如此，其中提供了联合类型<code class="fe mu mv mw mx b">Character</code>和<code class="fe mu mv mw mx b">Setting</code>。如果我们想访问一个只存在于<code class="fe mu mv mw mx b">Character</code>上的属性，那么我们必须让类型系统知道<code class="fe mu mv mw mx b">noun</code>参数是否是一个<code class="fe mu mv mw mx b">Character</code>。</p><p id="35ec" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在这一点上，我看到许多开发人员感到沮丧，并求助于将函数体中的<code class="fe mu mv mw mx b">noun</code>转换为<code class="fe mu mv mw mx b">any</code>类型或<code class="fe mu mv mw mx b">Character</code>。<em class="mz">但是请忍住投</em>的冲动！</p><p id="b651" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">相反，使用类型保护来检查属性<code class="fe mu mv mw mx b">gender</code>是否存在。如果是的话，那么类型系统可以安全地假设<code class="fe mu mv mw mx b">noun</code>是其后的<code class="fe mu mv mw mx b">Character</code>。</p><p id="5f58" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">清单5中的<code class="fe mu mv mw mx b">models.ts</code>文件的第16行提供了一个<a class="ae na" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html" rel="noopener ugc nofollow" target="_blank">类型保护</a>的例子。编写类型保护的关键是类型保护函数的返回类型中的关键字<code class="fe mu mv mw mx b">is</code>。通过声明输入参数<code class="fe mu mv mw mx b">is</code>是返回类型中的某个类型，类型守卫需要做的就是返回一个布尔值来验证该声明，类型系统会处理剩下的事情。</p><h1 id="3c6a" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">滚动到错误消息的底部</h1><p id="d68f" class="pw-post-body-paragraph kz la iu lb b lc mp jv le lf mq jy lh li mr lk ll lm ms lo lp lq mt ls lt lu in bi translated">我倾向于给第一次使用TypeScript的新开发人员的最大提示是滚动到错误消息的底部。通常错误信息中有很多干扰，很难理解到底是什么问题。清单6提供了一个嵌套错误消息的例子。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="my lw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">清单TypeScript中的嵌套错误消息</p></figure><p id="e33f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">所有的泛型和嵌套状态都与这个特定的错误相关联，很难理解真正的问题是什么。对于新的TypeScript开发人员来说，这个错误消息变得令人不知所措——好像编译器在对他们吼叫。有太多事情不对劲了！</p><p id="d05b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">然而，这实际上只是说一个<code class="fe mu mv mw mx b">string</code>不能被赋值给一个类型<code class="fe mu mv mw mx b">Partial&lt;Character&gt;</code>，并且所有的信息都在错误消息的最后一行。</p><p id="3bee" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这到底是怎么回事？为什么错误信息这么大？</p><p id="ab76" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">TypeScript正在遍历可能存在类型冲突的树，直到在根处找到确切的问题。在阅读时尝试扫描整个树有时会很有用，但大多数时候最好滚动到错误消息的底部，从问题的基础开始。</p><p id="b26f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">即使找到了问题的根源，有时它也可能被您在项目中使用的不同库或框架插入的泛型类型所隐藏。</p><p id="e9dc" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在这个例子中，<code class="fe mu mv mw mx b">ActionCreatorWithPayload&lt;&gt;</code>包装了实际的错误，并且来自Redux Toolkit。如果您没有在错误消息中明确定义泛型，那么可以安全地假设类型的这一部分没有任何问题，而是它所包装的东西(在本例中是<code class="fe mu mv mw mx b">Partial&lt;Character&gt;</code>)。</p><h1 id="a8c8" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">结论</h1><p id="6e5c" class="pw-post-body-paragraph kz la iu lb b lc mp jv le lf mq jy lh li mr lk ll lm ms lo lp lq mt ls lt lu in bi translated">希望这些提示能帮助你开始觉得使用TypeScript更有效率。重复是关键。您遇到的TypeScript错误越多，并且知道如何解决它们，下次解决这些相同的错误就越容易。</p><p id="4e94" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">你将开始学习模式，很快认知开销将会很低，以至于TypeScript在运行时错误中为你节省的时间将远远超过心理开销。</p><p id="93bf" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我最大的建议是不要放弃使用<code class="fe mu mv mw mx b">any</code>类型或<code class="fe mu mv mw mx b">@ts-ignore</code>注释来退出类型检查。你做得越多，而不是真正理解问题是什么，学习TypeScript就越难。</p><p id="90d0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">此外，让你的生活更简单，不要使用长而复杂的内联类型。使用接口、枚举和类型别名。您的代码将更容易阅读，您的类型将更容易在整个项目中引用。</p><p id="8c4b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果你遇到了其他常见的类型错误，或者需要帮助，请在评论中提出来，我会尽我所能给予回复。</p><p id="f6b9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">祝你好运！</p></div></div>    
</body>
</html>