<html>
<head>
<title>Angular: DI, Services, and Injectors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度:DI、服务和喷射器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-di-services-and-injectors-1f777e883e18?source=collection_archive---------13-----------------------#2022-05-30">https://betterprogramming.pub/angular-di-services-and-injectors-1f777e883e18?source=collection_archive---------13-----------------------#2022-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="635e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">依赖注入如何与服务一起工作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0945bd18143a19185b2e004df88703aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZNrfKOZi7qB6ZjDK5QYy0A.jpeg"/></div></div></figure><p id="84b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们谈谈Angular中的依赖注入系统，稍微讨论一下注入器，并决定实现服务提供者的方法。</p><p id="0c36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Angular文档很好地描述了喷射器的系统，但是为了完整的理解，有必要对此给予更详细的关注。</p><p id="e59c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，应该注意服务是如何加载的:在加载应用程序时立即加载还是在使用时加载？</p><p id="9b8c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">再来看角楼<em class="ln">迪</em>的方案。有几个级别的注入器，每个新模块/组件/指令都有自己的注入器级别。在Angular的<em class="ln">版本</em> <em class="ln"> 14 </em>中，在路线中增加了新的注射等级。</p><p id="c5ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该系统类似于一个树形结构，如果用图形表示，会得到以下视图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lo"><img src="../Images/4cf9ddb465d6919bd2346fc86f90d784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LfOv1onNbWCTq2MjTrcrlQ.png"/></div></div></figure><p id="90f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对注射器的搜索从孩子到父母等等，直到<code class="fe lp lq lr ls b">NullInjector</code>。</p><p id="23dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果<em class="ln">依赖注入</em>中没有关于注入服务的条目，那么您会得到一个相当常见的错误:</p><pre class="kg kh ki kj gt lt ls lu lv aw lw bi"><span id="ed4e" class="lx ly iq ls b gy lz ma l mb mc">NullInjectorError: No provider for YourService!</span></pre><p id="95f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您所想，可以通过在应用程序或所需模块中声明服务来修复这个错误。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="87a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Angular文档推荐使用单例服务，这通常是正确的方法，并在<code class="fe lp lq lr ls b">root</code>中提供它们。像这样:</p><pre class="kg kh ki kj gt lt ls lu lv aw lw bi"><span id="73e2" class="lx ly iq ls b gy lz ma l mb mc">@Injectable({ providedIn: 'root' })</span></pre><p id="6998" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是什么意思，<code class="fe lp lq lr ls b">'root'</code>从何而来？当应用程序启动时，这个<code class="fe lp lq lr ls b">'root'</code>级别的注入器被创建，它由我们在<code class="fe lp lq lr ls b">bootstrapModule</code>方法中加载的上下文决定。该模块或组件(从<em class="ln">版本14 </em>开始，这可以通过<em class="ln">独立</em>实现)将是树的<code class="fe lp lq lr ls b">'root'</code>级。另外，在上面的方案中可以看到，还有父母<code class="fe lp lq lr ls b">'platform'</code>和<code class="fe lp lq lr ls b">NullInjector</code> <em class="ln"> DI </em>等级。</p><p id="f0db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，通过声明<code class="fe lp lq lr ls b">providedIn: 'root'</code>，我们向<em class="ln"> DI </em>系统表明对服务的当前实例的引用位于<code class="fe lp lq lr ls b">'root'</code>。理解这一点很重要，这就是如何组合<em class="ln">依赖注入</em>树的。</p><p id="1fa6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们看看声明服务的可能选项。</p><p id="7e4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一个变体是在服务本身的<code class="fe lp lq lr ls b">@Injectable</code>装饰器中用属性声明的:</p><pre class="kg kh ki kj gt lt ls lu lv aw lw bi"><span id="6465" class="lx ly iq ls b gy lz ma l mb mc">providedIn?: Type&lt;any&gt; | ‘root’ | ‘platform’ | ‘any’ | null;</span></pre><p id="a0b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Angular文档详细说明了<code class="fe lp lq lr ls b">providedIn</code>属性参数的效果:</p><ul class=""><li id="d5cc" class="mk ml iq kt b ku kv kx ky la mm le mn li mo lm mp mq mr ms bi translated"><code class="fe lp lq lr ls b">Type&lt;any&gt;</code>:将注射剂与<code class="fe lp lq lr ls b">@NgModule</code>或其他<code class="fe lp lq lr ls b">InjectorType</code>关联。我们可以声明一个模块，在这个模块中，服务将被实例化并注入DI，例如:<code class="fe lp lq lr ls b">@Injectable({ providedIn: YourModule })</code>。</li><li id="b291" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated"><code class="fe lp lq lr ls b">null</code>(此处相当于<code class="fe lp lq lr ls b">undefined</code>):自动不提供任何范围的注射剂。我们必须在<code class="fe lp lq lr ls b">Providers</code>属性中将服务添加到提供者列表中。</li></ul><p id="f4b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lp lq lr ls b">InjectorType</code>:</p><ul class=""><li id="5819" class="mk ml iq kt b ku kv kx ky la mm le mn li mo lm mp mq mr ms bi translated"><code class="fe lp lq lr ls b">'root'</code>:大多数app中的应用级注入器。</li><li id="2ccc" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated"><code class="fe lp lq lr ls b">'platform'</code>:页面上所有应用共享的特殊单例平台注入器。</li><li id="4563" class="mk ml iq kt b ku mt kx mu la mv le mw li mx lm mp mq mr ms bi translated"><code class="fe lp lq lr ls b">'any'</code>:在每个延迟加载的模块中提供一个唯一的实例，而所有急切加载的模块共享一个实例。</li></ul><p id="42ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二个变体是第一个变体之后的服务声明，具有空属性<code class="fe lp lq lr ls b">providedIn</code> : <code class="fe lp lq lr ls b">@Injectable()</code>，其为<code class="fe lp lq lr ls b">undefined</code>，与此类似:</p><pre class="kg kh ki kj gt lt ls lu lv aw lw bi"><span id="20e0" class="lx ly iq ls b gy lz ma l mb mc">@Injectable({ providedIn: null })</span></pre><p id="3f69" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，您需要在指令/组件/模块的<code class="fe lp lq lr ls b">Providers</code>属性中声明一个服务，这个服务的一个实例将在这个<em class="ln"> DI </em>级别创建。</p><p id="b6af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">需要注意的是，即使服务是在第一个变体中创建的，在<code class="fe lp lq lr ls b">Providers</code>中声明这个服务也会导致这个服务的一个新实例的创建以及在DI树中对它的引用。因此，在不同层次的<em class="ln"> DI </em>树中，可能会出现相同服务的不同实例。</p><p id="b75b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，在角度<em class="ln">版本14 </em>中，您可以在<code class="fe lp lq lr ls b"> Routes</code>中使用带有属性<code class="fe lp lq lr ls b">Providers</code>的额外DI电平。</p><p id="71d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有一个视图示例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lo"><img src="../Images/f2235a1eeb40b625c640d209ca7e1554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*51QEFguuVIkaTMwIA5svfQ.png"/></div></div></figure><p id="0b56" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在关于加载<code class="fe lp lq lr ls b">@Injectable()</code>类代码，不管声明方法如何，它们都被下载到客户端，但是第一个模块类块直接使用可注入类(至少在构造函数中声明)。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="5992" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">谢谢，今天的<code class="fe lp lq lr ls b">@Injectable()</code>就到这里。</p></div></div>    
</body>
</html>