<html>
<head>
<title>How to Test Node.js Apps That Interact With External APIs Using Nock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何测试使用Nock与外部API交互的Node.js应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/testing-nodejs-apps-that-interact-with-external-apis-with-nock-97e1957e4130?source=collection_archive---------3-----------------------#2020-03-01">https://betterprogramming.pub/testing-nodejs-apps-that-interact-with-external-apis-with-nock-97e1957e4130?source=collection_archive---------3-----------------------#2020-03-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3c8d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Nock模仿你的API请求</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/16bb5ac500c79df815a0543b541ac3f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8XmkL_BsdWjKuo8b"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@helloquence?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">hello queue</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="b39b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天的网络应用很少单独存在。它们经常通过HTTP请求向外部API发出请求。</p><p id="ed1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，测试这些类型的代码并不太难，因为我们可以模拟HTTP响应。这意味着我们的测试不必在我们的测试中提出请求，这对于编写可重复和独立的测试是至关重要的。</p><p id="de57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究如何测试一个与外部API交互的Express应用程序。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0f4d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建简单的应用程序</h1><p id="a251" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我们创建将要测试的应用程序。该应用程序将从查克·诺里斯笑话应用程序接口<a class="ae ky" href="http://www.icndb.com/api/" rel="noopener ugc nofollow" target="_blank">获得一个随机笑话。</a></p><p id="f3d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们创建一个空项目文件夹并运行:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e336" class="ne md it na b gy nf ng l nh ni">npm init -y</span></pre><p id="ef6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用默认答案创建一个空的<code class="fe nj nk nl na b">package.json</code>文件。</p><p id="8a04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们分别安装Express和Node-Fetch来创建应用程序和从API获取数据。</p><p id="0558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们运行:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5557" class="ne md it na b gy nf ng l nh ni">npm i express node-fetch</span></pre><p id="f9c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装软件包。</p><p id="db1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们创建<code class="fe nj nk nl na b">app.js</code>并添加:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5a9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让应用程序理解这个笑话并将其作为回应返回。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8eb5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">添加测试</h1><p id="c8e6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了添加测试，我们使用Jest test runner运行测试并检查结果，使用Nock模拟我们在<code class="fe nj nk nl na b">app.js</code>中发出的请求的响应，使用Supertest运行Express应用程序并获得我们可以检查的响应。</p><p id="f207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们运行:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="df0c" class="ne md it na b gy nf ng l nh ni">npm i nock supertest jest</span></pre><p id="fa51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们为测试代码创建<code class="fe nj nk nl na b">app.test.js</code>，然后添加:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="abaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在文件里。</p><p id="7cd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码从包含我们来自<code class="fe nj nk nl na b">app.js</code>的应用和我们用于构建测试的库开始。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c855" class="ne md it na b gy nf ng l nh ni">const app = require('./app');<br/>const nock = require('nock');<br/>const request = require('supertest');</span></pre><p id="4ba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的第一行从<code class="fe nj nk nl na b">app.js</code>导入Express app实例。然后另外两行分别导入Nock和Supertest库。</p><p id="1d3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们通过从Jest调用<code class="fe nj nk nl na b">test</code>来添加测试框架，并传入描述和<code class="fe nj nk nl na b">async</code>函数，因为我们将使用Supertest的promise版本。</p><p id="c2de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后使用Nock，我们模拟如下响应:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ae0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，模拟请求是一个GET请求，这与我们在<code class="fe nj nk nl na b">app.js</code>中的请求相同。此外，网址是一样的，我们有。</p><p id="af3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不同之处在于，我们在测试中使用<code class="fe nj nk nl na b">mockResponse</code>对象返回200响应。</p><p id="d827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，实际的API返回什么并不重要。Nock将拦截请求，并总是返回<code class="fe nj nk nl na b">mockResponse</code>的内容，作为在<code class="fe nj nk nl na b">app.js</code>中路由请求的响应体。</p><p id="0bea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们只需调用带有Supertest的路由，如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="eb9b" class="ne md it na b gy nf ng l nh ni">const res = await request(app).get('/');</span></pre><p id="c70e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe nj nk nl na b">app.js</code>中的路线，然后检查如下响应:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="dc53" class="ne md it na b gy nf ng l nh ni">expect(res.status).toBe(200);<br/>expect(res.body).toEqual(mockResponse);</span></pre><p id="0cc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">toEqual</code>方法检查深度相等，因此我们可以传入整个对象进行检查。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/80bc17a524af7706360965f8e6db0268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WX8nABUAwEFoUoDh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@mroz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Filip Mroz </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="de99" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">运行测试</h1><p id="466a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在要运行我们的测试，我们必须添加:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="fa83" class="ne md it na b gy nf ng l nh ni">"test": "jest --forceExit"</span></pre><p id="f948" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到<code class="fe nj nk nl na b">package.json</code>的<code class="fe nj nk nl na b">scripts</code>段。</p><p id="4a12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要<code class="fe nj nk nl na b">--forceExit</code>选项，这样一旦测试运行，测试就会退出。这是一个有待解决的问题。</p><p id="9768" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以通过运行以下命令来运行测试:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a085" class="ne md it na b gy nf ng l nh ni">npm test</span></pre><p id="2869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们应该得到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8ca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论我们运行多少次测试，我们都会得到相同的结果，因为我们嘲笑了API的响应。</p><p id="574e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">真正的API在我们每次向它发出请求时都返回不同的东西，所以我们不能在测试中使用它。</p><p id="ecc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使我们可以，它也会慢得多，而且API可能并不总是可用的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="124b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="a177" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用Nock，我们可以在应用程序中轻松模拟外部API请求的响应。然后，我们可以专注于运行我们的应用程序代码并检查结果。</p><p id="2586" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了运行快速并产生可重复结果的测试，它不依赖于测试之外的任何东西。</p></div></div>    
</body>
</html>