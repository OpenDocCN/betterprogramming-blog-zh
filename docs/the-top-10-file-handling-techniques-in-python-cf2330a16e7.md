# Python 中的 10 大文件处理技术

> 原文：<https://betterprogramming.pub/the-top-10-file-handling-techniques-in-python-cf2330a16e7>

## 使处理文件更容易

![](img/f603b637446b708475e40c41e0675ba2.png)

照片由 [PolaroMagnet](https://unsplash.com/@polaromagnet?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

无论你在做什么项目，你都有可能不得不在你的电脑或服务器上处理文件。毕竟，文件是存储相关的、通常有组织的信息的最常见的容器。然而，我发现许多人，有时包括我自己，不得不搜索一些与文件处理相关的特定操作。因此，在本文中，我想回顾一下 Python 中最有用的十种技术。

# 1.显示当前目录

当我们想知道我们当前的工作目录是什么时，我们可以简单地使用 *os* 模块的`getcwd()`函数，如下图所示。

显示当前工作目录

上面的代码也向您展示了我们可以使用`pathlib`模块来获取当前的工作目录。请注意，`pathlib`模块成为处理文件相关操作的首选方式，您将在本文中看到它的更多用法。然而，如果您正在使用旧版本的 Python ( < 3.4)，您可能必须坚持使用`os`模块。

# 2.创建一个新目录

要制作目录，可以使用`mkdir()`功能。这个函数将在指定的路径下创建一个目录。如果只使用目录名，文件夹将在当前目录下创建。

制作目录

但是，如果您想创建一个超过一级的新目录(即，另一个文件夹中的一个文件夹)，您需要使用`makedirs()`功能。下面是一个简单的例子。

制作目录

如果您正在使用 Python 的最新版本(≥ 3.4)，可以考虑利用`pathlib`模块来创建新目录。具体来说，它不仅可以创建子目录，还可以根据请求处理路径中任何缺失的目录。请参见下面的示例。

使用 pathlib 创建目录。

需要注意的一点是，如果您尝试多次运行上面的一些代码，您可能会遇到问题——您不能创建一个已经存在的新目录。值得注意的是，`exist_ok`参数可以通过将其设置为`True`来处理这个问题，如上所示。默认情况下，`False`值将阻止我们创建目录，如果它存在的话。

目录存在时出错

# 3.删除目录和文件

当我们完成对一些文件或文件夹的操作时，我们可能希望删除它们以保持计算机资源的有序。为此，我们可以使用 *os* 模块中的`remove()`函数删除一个文件。如果你想删除一个文件夹，我们应该使用`rmdir()`功能。如果你试图用`remove()`功能删除一个目录，你会遇到错误。它们的用法如下所示。

删除目录和文件

如果您坚持使用 *pathlib* 模块的可用功能，删除文件可以使用`unlink()`方法，而删除目录可以使用`rmdir()`方法。请注意，这两个方法都是一个`Path`对象的实例方法。

# 4.获取文件列表

当我们为分析工作或机器学习项目进行数据处理时，我们需要获得特定目录中的文件列表。通常，文件名都有匹配的模式。假设我们想找出所有。目录中的 txt 文件。下面是我们如何使用带有路径对象的`glob()`方法来做到这一点。请注意，这个`glob()`方法创建了一个生成器，它允许我们进行迭代。下面的代码向您展示了出于演示目的，我们从生成器创建了一个文件路径列表。

特定模式的文件

或者，直接使用 *glob* 模块也很方便，如下所示，它通过创建您可以使用的文件名列表来实现类似的功能。请注意，`Path.glob()`创建路径。在大多数情况下，比如文件读写，两者都可以。

带有 glob 的特定模式的文件

# 5.移动和复制文件

一个常规的文件管理任务是移动和复制文件。在 Python 中，这些工作可以非常容易地完成。要移动一个文件，您只需通过用目标目录替换旧目录来重命名该文件。假设我们需要移动所有的。txt 文件到另一个文件夹。下面的代码向您展示了我们如何使用 *pathlib* 模块来实现这一点。

移动文件

要复制文件，我们可以利用 *shutil* 模块中可用的功能，这是标准库中另一个用于文件操作的有用模块。具体来说，我们可以通过将源文件和目标文件指定为字符串来使用模块中的`copy()`函数。下面是一个简单的例子。当然，您可以结合使用`copy()`函数和`glob()`函数来处理一堆具有相同模式的文件。

复制文件

# 6.检查目录/文件

实际上，在我上面展示的例子中，你已经见过很多次了。我一直使用`exists()`方法来检查特定路径是否存在。当它这样做时，它返回`True`；如果没有，它返回`False`。值得注意的是，该函数在 *os* 和 *pathlib* 模块中都可用，尽管它们具有不同的函数签名。它们各自的用法如下所示。

使用 exists()的示例。

我们还可以在 *pathlib* 模块中检查一个路径是一个目录还是一个具有随时可以调用的函数的文件。考虑下面的例子。

检查路径的类型(目录还是文件)

# 7.获取文件信息

当我们处理文件时，我们需要在很多情况下提取文件名。有了`Path`对象，就很容易了。其实我以前用过。您可以简单地检索文件`Path`对象的`name`属性。如果您只对知道不带扩展名的名称感兴趣，您可以检索`stem`属性。下面的代码片段向您展示了这样的用法。

检索文件名

出于特殊原因，您需要获得正在处理的文件的扩展名。在大多数情况下，您可以利用 file `Path`对象的`suffix`属性，如下所示。

检索文件扩展名

如果你想获得更多关于文件的信息，比如文件大小和修改时间，你可以使用`stat()`方法，如果你熟悉 *os* 模块，它就像`os.stat()`一样工作。下面是一些简单的例子。

检索元信息

# 8.读取文件

我们做的最重要的文件操作之一当然是从文件中读取数据。毕竟，文件中的内容可能是最初创建该文件的唯一原因。要读取文件，最常规的方法是使用内置的`open()`函数创建一个文件对象。默认情况下，该函数将以读取模式打开文件，并将文件中的数据视为文本。让我们看一个例子。

读取文件

上面的代码向您展示了读取文件内容的最常见的方法。如果你知道你的文件没有太多的数据，你可以简单地用`read()`方法一次全部读取。然而，当文件非常大时，您应该考虑使用允许您逐行处理数据的生成器。具体来说，file 对象通过逐行呈现数据来充当生成器，这通过消除我们使用`read()`方法时加载所有数据的需要来节省内存。如果想了解更多关于生成器的知识，可以参考[这篇文章](https://medium.com/swlh/generators-in-python-5-things-to-know-c76a1f60427a)，里面讲述了文件读取中生成器的使用。

如前所述，默认的开放模型将文件内容视为文本。但是，如果您正在处理二进制文件，您应该显式地指定它。例如，不要用`‘r’`，你应该用`‘rb’`。这个要求也适用于编写文件，下面将会讨论。另一个需要处理的棘手部分是文件的编码。在大多数情况下，`open()`函数会帮助我们处理编码，我们处理的大多数文件应该是“utf-8”编码的。如果你正在处理使用其他编码的文件，你应该设置`encoding`参数。

# 9.写文件

要将数据写入文件，我们仍然可以通过以写模式(`‘w’`)或追加(`‘a’`)模式打开文件来创建文件对象。在前面的模式中，数据将通过截断旧信息写入文件。相比之下，追加模式将允许我们在现有数据的末尾写入数据。让我们在下面的代码片段中看看两者是如何工作的。

写文件

在上面的代码中，我向您展示了我们可以在 write 和 append 模式下写入数据。我不知道你是否注意到了，但是我每次打开文件的时候都使用了带语句的*。原因是 with 语句为我们处理文件创建了一个上下文，当我们完成文件操作时，它将帮助我们关闭 file 对象。这很重要，因为如果我们不及时关闭打开的文件对象，它可能会被破坏。你可以在我最近的文章中了解更多关于上下文管理的内容。*

# 10.压缩和解压缩文件

当我们处理大量文件时，您可能希望压缩文件以便长期存储或临时传输。相关功能在 *zipfile* 模块中提供。为了压缩文件，您将使用模块中的`ZipFile()`函数创建一个 zip 文件对象，类似于我们对`open()`函数所做的，两者都涉及到创建一个由上下文管理器管理的文件对象(还记得使用带有语句的*吗？).让我们看看下面的代码作为一个简单的例子。*

Zip 文件

您可能会从其他地方获得一个 zip 文件，并且您需要解压缩这些文件。为了简单起见，让我们假设我们将文件解压到当前目录。请注意，由于 zip 文件中包含的文件在当前目录中具有相同的名称，这些文件将被覆盖而不会发出警告。因此，您应该考虑将 zip 文件的内容提取到一个文件夹中，而不必担心会被覆盖。

解压缩文件

# 结论

在本教程中，我们回顾了 Python 中十个最有用的文件操作技巧。正如您所知，所有这些操作只需要几行代码，因此非常容易操作。如果您不熟悉这些操作，我希望这篇文章可以作为您的文件处理相关工作的快速参考。

感谢你阅读这篇文章。