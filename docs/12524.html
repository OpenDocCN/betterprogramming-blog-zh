<html>
<head>
<title>Here Are the MySQL Development Specifications My Team Is Using</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以下是我的团队正在使用的MySQL开发规范</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/here-are-the-mysql-development-specifications-my-team-is-using-b7537469d0f1?source=collection_archive---------12-----------------------#2022-06-10">https://betterprogramming.pub/here-are-the-mysql-development-specifications-my-team-is-using-b7537469d0f1?source=collection_archive---------12-----------------------#2022-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a95c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">来提升我们的结构设计！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a935e2cee36d253b22eea948a5def258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LM36si3-cybIFHt6"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Arnel Hasanovic 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="736f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据库对象命名约定</h1><h2 id="88ad" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.1数据库对象</em></h2><p id="f615" class="pw-post-body-paragraph mh mi it mj b mk ml ju mm mn mo jx mp lw mq mr ms lz mt mu mv mc mw mx my mz im bi translated">数据库对象是数据库的组成部分，常见的有:表、索引、视图、图表、默认值、规则、触发器、存储过程、用户等。</p><p id="63f8" class="pw-post-body-paragraph mh mi it mj b mk na ju mm mn nb jx mp lw nc mr ms lz nd mu mv mc ne mx my mz im bi translated">命名约定是指数据库对象的命名约定，如<code class="fe nf ng nh ni b">SCHEMA</code>、<code class="fe nf ng nh ni b">TABLE</code>、<code class="fe nf ng nh ni b">INDEX</code>、<code class="fe nf ng nh ni b">CONSTRAINTS</code>等。</p><h2 id="1953" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.2数据库对象全局命名约定</em></h2><ul class=""><li id="7617" class="nj nk it mj b mk ml mn mo lw nl lz nm mc nn mz no np nq nr bi translated">用有意义的英文单词命名，单词之间用下划线隔开。</li><li id="07ab" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">名称只能使用英文字母、数字下划线，并且以英文字母开头。</li><li id="9670" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">避免使用备份、调用、组等MySQL保留字。</li><li id="bc75" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">所有数据库对象都使用小写字母。事实上，可以在MySQL中设置区分大小写。为了确保一致性，我们在这里将所有小写表示标准化。</li></ul><h2 id="194b" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.3数据库命名约定</em></h2><ul class=""><li id="861a" class="nj nk it mj b mk ml mn mo lw nl lz nm mc nn mz no np nq nr bi translated">数据库名称应尽可能不超过30个字符。</li><li id="fb18" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">数据库命名一般是项目名称+代表库含义的缩写，比如IM项目的工作流数据库，可以是<code class="fe nf ng nh ni b">im_flow</code>。</li><li id="0ed3" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">创建数据库时，必须添加默认字符集和归类子句。默认字符集是UTF8 (dumbo已经迁移到使用utf8mb4)。</li><li id="221c" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">名称应该是小写的。</li></ul><h2 id="262a" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.4表格命名约定</em></h2><ul class=""><li id="7e88" class="nj nk it mj b mk ml mn mo lw nl lz nm mc nn mz no np nq nr bi translated">常规表的表名以t_开头，t代表表的含义。命名规则为t + module(含module含义的缩写)+ table(含table含义的缩写)，如用户模块的教育信息表:<code class="fe nf ng nh ni b">t_user_eduinfo</code>。</li><li id="9944" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">临时表(RD、QA或DBA用于临时数据处理的表)，命名规则:temp前缀+ module + table + date后缀:<code class="fe nf ng nh ni b">temp_user_eduinfo_20220101</code>。</li><li id="c676" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">备份表(用于保存和归档历史数据或灾难恢复的数据)命名规则，bak前缀+模块+表+日期后缀:<code class="fe nf ng nh ni b">bak_user_eduinfo_20220101</code>。</li><li id="1b25" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">同一模块的表尽量使用相同的前缀，表名尽量表达意思。</li><li id="4d77" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">由下划线分隔的多个单词<code class="fe nf ng nh ni b">_</code>。</li><li id="c170" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">常规表的表名尽量不要超过30个字符。<code class="fe nf ng nh ni b">temp</code>表和<code class="fe nf ng nh ni b">bak</code>表要尽量短，名字要小写。</li></ul><h2 id="860d" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.5字段命名约定</em></h2><ul class=""><li id="c31a" class="nj nk it mj b mk ml mn mo lw nl lz nm mc nn mz no np nq nr bi translated">字段名要求有代表其实际意义的英文单词或缩写，单词之间用下划线<code class="fe nf ng nh ni b">_</code>连接，如<code class="fe nf ng nh ni b">service_ip</code>、<code class="fe nf ng nh ni b">service_port</code>。</li><li id="9bc0" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">表之间含义相同的字段必须有相同的名称。比如<code class="fe nf ng nh ni b">A</code>表和<code class="fe nf ng nh ni b">B</code>表有一个创建时间，应该统一为create_time，不一致会很混乱。</li><li id="4e19" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">由下划线分隔的多个单词<code class="fe nf ng nh ni b">_</code>。</li><li id="7885" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">字段名尽量不要超过30个字符，名称要小写。</li></ul><h2 id="6f23" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.6索引命名约定</em></h2><ul class=""><li id="aa95" class="nj nk it mj b mk ml mn mo lw nl lz nm mc nn mz no np nq nr bi translated">使用<code class="fe nf ng nh ni b">uni</code> +字段名:<code class="fe nf ng nh ni b">create unique index uni_uid on t_user_basic(uid)</code>来命名唯一索引。</li><li id="e8d5" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">非唯一索引使用<code class="fe nf ng nh ni b">idx</code> +字段名:<code class="fe nf ng nh ni b">create index_idx_uname_mobile on t_user_basic(uname,mobile)</code>命名。</li><li id="5866" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">多个单词用下划线分隔<code class="fe nf ng nh ni b">_</code>。</li><li id="673a" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">索引名称应尽可能不超过50个字符。名称应该是小写的。索引字段的组合不能太多，否则不利于查询效率的提高。</li><li id="4f93" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">对于由多个单词组成的列名，尽可能取代表含义的缩写，如<code class="fe nf ng nh ni b">test_contact</code>表的<code class="fe nf ng nh ni b">member_id</code>和<code class="fe nf ng nh ni b">friend_id</code>上的组合索引:<code class="fe nf ng nh ni b">idx_mid_fid</code>。</li><li id="c027" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">了解组合索引的最左前缀原则，避免重复索引构造。如果<code class="fe nf ng nh ni b">(a,b,c)</code>成立，就相当于<code class="fe nf ng nh ni b">(a), (a,b), (a,b,c)</code>成立。</li></ul><h2 id="b3f6" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.7视图命名约定</em></h2><ul class=""><li id="1563" class="nj nk it mj b mk ml mn mo lw nl lz nm mc nn mz no np nq nr bi translated">视图名称以<code class="fe nf ng nh ni b">v</code>开头，表示视图，完整的结构是<code class="fe nf ng nh ni b">v</code>的缩写+视图内容含义。</li><li id="81d2" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">如果视图仅来自单个表，则为<code class="fe nf ng nh ni b">v</code>+表名。如果视图关联多个表，用v+下划线<code class="fe nf ng nh ni b">_</code>连接多个表名，视图名尽量不要超过30个字符。缩写用于30个以上的字符。</li><li id="ac64" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">如果没有特殊需要，严禁开发人员创建视图。</li><li id="772c" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">名称应该是小写的。</li></ul><h2 id="a55d" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.8存储过程命名约定</em></h2><ul class=""><li id="3d07" class="nj nk it mj b mk ml mn mo lw nl lz nm mc nn mz no np nq nr bi translated">存储过程的名称以<code class="fe nf ng nh ni b">sp</code>开头，表示存储过程(存储过程)。之后多个单词用下划线<code class="fe nf ng nh ni b">_</code>连接。存储过程的名称应该反映其功能。存储过程名称应尽可能不超过30个字符。</li><li id="5c76" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">存储过程中的输入参数以<code class="fe nf ng nh ni b">i_</code>开头，输出参数以<code class="fe nf ng nh ni b">o_</code>开头。</li><li id="5bc6" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">名称应该是小写的。</li></ul><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="19cd" class="lr la it ni b gy ob oc l od oe">create procedure sp_multi_param(in i_id bigint,in i_name varchar(32),out o_memo varchar(100))</span></pre><h2 id="2b89" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.9函数命名约定</em></h2><ul class=""><li id="d492" class="nj nk it mj b mk ml mn mo lw nl lz nm mc nn mz no np nq nr bi translated">函数名以<code class="fe nf ng nh ni b">func</code>开头，表示函数。之后多个单词用一个下划线<code class="fe nf ng nh ni b">_</code>连接，函数名要体现其功能。函数名尽量不要超过30个字符。</li><li id="a8ca" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">名称应该是小写的。</li></ul><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="8b07" class="lr la it ni b gy ob oc l od oe">create function func_format_date(ctime datetime)</span></pre><h2 id="9fa7" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.10触发器命名约定</em></h2><ul class=""><li id="8f7d" class="nj nk it mj b mk ml mn mo lw nl lz nm mc nn mz no np nq nr bi translated">触发器以<code class="fe nf ng nh ni b">trig</code>开头，表示一个触发器。</li><li id="5f89" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">基本部分描述由触发器添加的表。触发器名称应尽可能不超过30个字符。</li><li id="d425" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">后缀(<code class="fe nf ng nh ni b">_i</code>、<code class="fe nf ng nh ni b">_u</code>、<code class="fe nf ng nh ni b">_d</code>)表示触发条件的触发方式(插入、更新或删除)。</li><li id="30c7" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">名称应该是小写的。</li></ul><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="7a3f" class="lr la it ni b gy ob oc l od oe">DROP TRIGGER IF EXISTS trig_attach_log_d;</span><span id="6e38" class="lr la it ni b gy of oc l od oe">CREATE TRIGGER trig_attach_log_d AFTER DELETE ON t_dept FOR EACH ROW;</span></pre><h2 id="fe08" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.11约束命名约定</em></h2><ul class=""><li id="f324" class="nj nk it mj b mk ml mn mo lw nl lz nm mc nn mz no np nq nr bi translated">唯一约束:uk_tablename_field name。<code class="fe nf ng nh ni b">uk</code>是唯一键的缩写。例如，为一个部门的部门名添加一个唯一约束，以确保没有重名，如下:<code class="fe nf ng nh ni b">alter table t_dept add constraint un_name unique(name)</code>。</li><li id="f149" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">外键约束:fk_table name，后跟外键所在的表名和对应的主表名(不包括<code class="fe nf ng nh ni b">t_</code>)。子表名和父表名由下划线<code class="fe nf ng nh ni b">_</code>分隔。如下:<code class="fe nf ng nh ni b">alter table t_user add constraint fk_user_dept foreign key(depno) references t_dept(id)</code>。</li><li id="f924" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">非空约束:如无特殊需要，建议所有字段默认为非空，不同数据类型必须给出默认值。</li><li id="37ae" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">出于性能考虑，如果没有特殊需要，建议不要使用外键。引用完整性由代码控制。这也是我们的惯例，从程序角度进行完整性控制，但如果不注意，也会产生脏数据。</li><li id="6796" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">名称应该是小写的。</li></ul><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="422a" class="lr la it ni b gy ob oc l od oe">`id` int(11) NOT NULL,<br/>`name` varchar(30) DEFAULT '',<br/>`deptId` int(11) DEFAULT 0,<br/>`salary` float DEFAULT NULL,</span></pre><h2 id="2401" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.12用户命名惯例</em></h2><ul class=""><li id="6840" class="nj nk it mj b mk ml mn mo lw nl lz nm mc nn mz no np nq nr bi translated">生产中使用的用户命名格式是code_application。</li><li id="300c" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">只读用户的命名规则是read_application。</li></ul></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h1 id="ff0b" class="kz la it bd lb lc on le lf lg oo li lj jz op ka ll kc oq kd ln kf or kg lp lq bi translated">数据库对象设计规范</h1><h2 id="1f8a" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.1如何选择存储引擎</em></h2><p id="e853" class="pw-post-body-paragraph mh mi it mj b mk ml ju mm mn mo jx mp lw mq mr ms lz mt mu mv mc mw mx my mz im bi translated">如果没有特殊要求，必须使用InnoDB存储引擎。</p><p id="406d" class="pw-post-body-paragraph mh mi it mj b mk na ju mm mn nb jx mp lw nc mr ms lz nd mu mv mc ne mx my mz im bi translated">当前默认引擎可以用<code class="fe nf ng nh ni b">show variables like 'default_storage_engine</code>查看。主要有MyISAM和InnoDB，从5.5版本开始默认使用InnoDB引擎。</p><p id="fa75" class="pw-post-body-paragraph mh mi it mj b mk na ju mm mn nb jx mp lw nc mr ms lz nd mu mv mc ne mx my mz im bi translated">基本区别在于:MyISAM类型不支持高级处理，比如事务处理，而InnoDB类型支持。</p><p id="c3d6" class="pw-post-body-paragraph mh mi it mj b mk na ju mm mn nb jx mp lw nc mr ms lz nd mu mv mc ne mx my mz im bi translated">MyISAM类型表强调性能，它比InnoDB类型执行得更快，但不提供事务支持，而InnoDB提供事务支持和高级数据库特性，如外键。</p><h2 id="6641" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.2字符集的选择</em></h2><p id="dd1f" class="pw-post-body-paragraph mh mi it mj b mk ml ju mm mn mo jx mp lw mq mr ms lz mt mu mv mc mw mx my mz im bi translated">除非另有规定，否则必须使用utf8或utf8mb4。</p><p id="ccbb" class="pw-post-body-paragraph mh mi it mj b mk na ju mm mn nb jx mp lw nc mr ms lz nd mu mv mc ne mx my mz im bi translated">在中国，选择支持中文和各种语言的utf8格式是最好的方式。MySQL在5.5之后增加了utf8mb4编码。mb4表示大部分字节4，它是专门为与四字节unicode兼容而设计的。</p><p id="f927" class="pw-post-body-paragraph mh mi it mj b mk na ju mm mn nb jx mp lw nc mr ms lz nd mu mv mc ne mx my mz im bi translated">所以，utf8mb4是utf8的超集，除了将编码改为utf8mb4之外，不需要其他转换。当然，为了节省空间，通常使用utf8就足够了。</p><p id="9e92" class="pw-post-body-paragraph mh mi it mj b mk na ju mm mn nb jx mp lw nc mr ms lz nd mu mv mc ne mx my mz im bi translated">您可以使用以下脚本来查看数据库的编码格式。</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="5a77" class="lr la it ni b gy ob oc l od oe">SHOW VARIABLES WHERE Variable_name LIKE 'character_set_%' OR Variable_name LIKE 'collation%';</span><span id="b625" class="lr la it ni b gy of oc l od oe">-- or</span><span id="d302" class="lr la it ni b gy of oc l od oe">SHOW VARIABLES Like '%char%';</span></pre><h2 id="ae63" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.3表格设计规范</em></h2><ul class=""><li id="16b7" class="nj nk it mj b mk ml mn mo lw nl lz nm mc nn mz no np nq nr bi translated">应尽可能减少不同应用对应的数据库表之间的关联，不允许外键在表之间关联，以确保组件对应的表之间的独立性，并为重构系统或表结构提供可能性。当前的行业实践通常通过过程来控制引用完整性。</li><li id="fc9a" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">从表格设计的角度来看，数据库设计不应该是针对整个系统进行的而是应该按照系统架构中的组件进行划分，数据库设计应该按照每个组件所处理的业务进行。</li><li id="62a6" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">该表必须有主键。主键的优点是唯一标识、有效引用、高效检索，所以一般情况下尽量有主键字段。</li><li id="db63" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">一个字段只有一个含义。</li><li id="d800" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">该表不应有重复的列。</li><li id="e47d" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">复杂数据类型(数组、自定义等)的使用。)是禁止的。JSON类型的使用取决于具体情况。</li><li id="b37d" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">需要连接的字段(连接键)的数据类型必须绝对一致，以避免隐式转换。例如，关联字段都是Int类型。</li><li id="3551" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">设计至少要满足第三范式，尽量减少数据冗余。一些特殊场景允许非规范化设计，但是冗余字段的设计需要在项目评审期间进行解释。</li><li id="251c" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">文本字段存储为大量文本，必须放在单独的表中，并通过PK与主表关联。如果没有特殊需要，禁止使用文本和BLOB字段。</li><li id="635e" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">需要定期删除(或转移)过期数据的表可以通过子表来解决。我们的做法是将操作频率较低的历史数据按照2/8规则迁移到历史表中，并按照时间或Id制作切割点。</li><li id="5da4" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">单个表格的字段数量不要太多，建议最多不超过50个。过宽的表对性能也有很大的影响。</li><li id="a9a7" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">当MySQL处理大型表时，性能开始显著下降。因此，建议单个表的物理大小限制在16GB以内，表中的数据行数控制在2000W以内。</li><li id="ba06" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">行业内的规则是，超过2000W后，性能开始显著下降。不过这个值是有弹性的，你可以根据实际情况来判断。比如阿里的标准是500W，百度的确实是2000W。事实上，无论表格是否宽，单行数据所占的空间都起着作用。</li><li id="d13c" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">如果数据量或数据增长很大程度上在前期规划，那么在设计评审中就要加入表拆分策略，会有专门的文章来分析数据拆分方法:垂直拆分(垂直拆分和垂直子表)、水平拆分(子库子表和内部子表)。</li><li id="36bb" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">没有特殊要求，严禁使用分区表。</li></ul><h2 id="38eb" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.4现场设计规范</em></h2><ul class=""><li id="3076" class="nj nk it mj b mk ml mn mo lw nl lz nm mc nn mz no np nq nr bi translated"><code class="fe nf ng nh ni b">INT</code>:如无特殊需要，使用<code class="fe nf ng nh ni b">UNSIGNED INT</code>存储整数。整数字段后的数字表示显示长度。例如，<code class="fe nf ng nh ni b">id int(11) NOT NULL</code></li><li id="6200" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated"><code class="fe nf ng nh ni b">DATETIME</code>:所有需要精确到时间(时、分、秒)的字段都使用<code class="fe nf ng nh ni b">DATETIME</code>而不是<code class="fe nf ng nh ni b">TIMESTAMP</code>类型。</li><li id="41e4" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">对于<code class="fe nf ng nh ni b">TIMESTAMP</code>，它将当前时区的写入时间转换为UTC(通用标准时间)进行存储。查询时，将其转换为客户端的当前时区并返回。而对于<code class="fe nf ng nh ni b">DATETIME</code>，不做任何改动，输入输出基本保持原样。</li><li id="a676" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">另外，<code class="fe nf ng nh ni b">DATETIME</code>储存的范围也比较大:</li><li id="f2c6" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">时间戳可以存储的时间范围是:<code class="fe nf ng nh ni b">1970–01–01 00:00:01.000000’ to ‘2038–01–19 03:14:07.999999</code>。</li><li id="2fe7" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated"><code class="fe nf ng nh ni b">DateTime</code>可以存储的时间范围是:<code class="fe nf ng nh ni b">1000–01–01 00:00:00.000000’ to ‘9999–12–31 23:59:59.999999</code>。</li><li id="6b05" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">但在特殊情况下，<code class="fe nf ng nh ni b">TIMESTAMP</code>更适合跨时区的业务。</li><li id="b83e" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated"><code class="fe nf ng nh ni b">VARCHAR</code>:所有的动态长度字符串都使用<code class="fe nf ng nh ni b">VARCHAR</code>类型，类似于status等有限类别的字段，也使用能清楚表示实际意义的字符串，不应该用<code class="fe nf ng nh ni b">INT; VARCHAR( N)</code>等数字代替</li><li id="eeb0" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated"><code class="fe nf ng nh ni b">N</code>代表字符数，不是字节数。例如<code class="fe nf ng nh ni b">VARCHAR(255)</code>最多可以存储255个字符(字符包括英文字母、汉字、特殊字符等。).但是<code class="fe nf ng nh ni b">N</code>要尽量小，因为一个MySQL表中所有<code class="fe nf ng nh ni b">VARCHAR</code>字段的最大长度是65535字节，存储的字符数由选择的字符集决定。</li><li id="27a5" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">如果UTF8存储一个最多三个字节的字符，那么<code class="fe nf ng nh ni b">varchar</code>在存储长度占三个字节的字符时，不应该超过21845个字符。同时，在进行排序、创建临时表等内存操作时，会使用<code class="fe nf ng nh ni b">N</code>的长度来申请内存。(如无特殊需要，原则上单个varchar类型字段不允许超过255个字符)</li><li id="2baf" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated"><code class="fe nf ng nh ni b">TEXT</code>:只有当字符数可能超过20000时，才能使用<code class="fe nf ng nh ni b">TEXT</code>类型存储字符数据，因为所有MySQL数据库都会使用UTF8字符集。</li><li id="54d7" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">所有使用<code class="fe nf ng nh ni b">TEXT</code>类型的字段都必须从原表中拆分出来，用原表的主键组成另一个表进行存储，与大文本字段隔离的目的是。如无特殊需要，请勿使用<code class="fe nf ng nh ni b">MEDIUMTEXT</code>、<code class="fe nf ng nh ni b">TEXT</code>或<code class="fe nf ng nh ni b">LONGTEXT</code>类型</li><li id="6dd7" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">精确的浮点数据存储需要<code class="fe nf ng nh ni b">DECIMAL</code>，严禁使用<code class="fe nf ng nh ni b">FLOAT</code>和<code class="fe nf ng nh ni b">DOUBLE</code>。</li><li id="b1aa" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">如果没有特殊需要，尽量不要使用BLOB类型</li><li id="1473" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">如果没有特殊需要，建议对字段使用<code class="fe nf ng nh ni b">NOT NULL</code>属性，可以用默认值代替<code class="fe nf ng nh ni b">NULL</code></li><li id="6545" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">自动递增字段的类型必须是整数，并且必须是<code class="fe nf ng nh ni b">UNSIGNED</code>。推荐类型为<code class="fe nf ng nh ni b">INT</code>或<code class="fe nf ng nh ni b">BIGINT</code>，自动递增字段必须是主键或主键的一部分。</li></ul><h2 id="a15c" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.5指标设计规范</em></h2><ul class=""><li id="3866" class="nj nk it mj b mk ml mn mo lw nl lz nm mc nn mz no np nq nr bi translated">指数歧视。</li><li id="1ca2" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">必须在具有高索引选择性(区分)的列上创建索引。选择性计算为<code class="fe nf ng nh ni b">selectivity = count(distinct c_name)/count(*)</code>；如果判别结果小于0.2，不建议使用该列在顶部创建索引，否则，很可能会降低SQL的执行速度。</li><li id="63f6" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">遵循最左边的前缀。</li><li id="70ed" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">为了确定需要形成复合索引的多个字段，建议在设计时将具有高选择性的字段放在第一位。使用时，复合索引的第一个字段必须在where条件中，并且需要根据最左边的前缀规则进行匹配。</li><li id="7886" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">外键是被禁止的，完整性可以在程序级别被约束。</li><li id="d89d" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">如果需要为文本类型字段创建索引，必须使用前缀索引。</li><li id="49f2" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">单个表中的索引数量理论上应控制在5个以内。经常会有大批量的插入和更新操作表，应该尽量少建立索引。理论上，索引建立的原则是多读少写。</li><li id="45ee" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">需要在索引后添加<code class="fe nf ng nh ni b">ORDER BY</code>、<code class="fe nf ng nh ni b">GROUP BY</code>和<code class="fe nf ng nh ni b">DISTINCT</code>字段，形成覆盖索引。</li><li id="e07e" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">正确理解和计算指标字段的区分度。文中有计算规则。区分度高的索引可以快速定位数据。如果区分度太低，指数就不能得到有效利用。可能需要扫描大量数据页，而不使用它。索引没有区别。</li><li id="0c0c" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">正确理解和计算前缀索引的字段长度。文中有判断规则。合适的长度必须确保高度的区分度和最合适的索引存储容量。只有达到最优状态，才能保证有效率的指标。</li><li id="678f" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">对于关节索引注意最左边的匹配原则:必须按照从左到右的顺序进行匹配。MySQL会一直向右匹配索引，直到遇到范围查询(<code class="fe nf ng nh ni b">&gt;</code>、<code class="fe nf ng nh ni b">&lt;</code>、<code class="fe nf ng nh ni b">between</code>、<code class="fe nf ng nh ni b">like</code>)，然后停止匹配。</li><li id="3852" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">比如<code class="fe nf ng nh ni b">depno=1</code>和<code class="fe nf ng nh ni b">empname&gt;"</code>和<code class="fe nf ng nh ni b">job=1</code>。如果(depno，empname，job)订单的索引已建立，则作业将不会使用该索引。</li><li id="cdfc" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">按需获取策略。查询记录时，不要一出现就使用<code class="fe nf ng nh ni b">*</code>，只取需要的数据。如果可能，尽量只使用索引覆盖，这样可以减少表返回操作，提高效率。</li><li id="f723" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">正确判断是否使用联合索引(上面关于联合索引使用的章节描述了判断规则)，还可以进一步分析索引下推(IPC)，减少返回表的操作，提高效率。</li><li id="b17f" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">避免索引失效的原则:禁止在索引字段上使用函数和运算符，这会使索引失效。这其实就是保证指标对应的字段“干净”的需要。</li><li id="7837" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">避免不必要的类型转换。当使用数值比较字符串字段时，索引将无效。</li><li id="55d3" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">模糊查询“%value%”将使索引无效，并将其转换为全表扫描，因为无法确定扫描的范围，但“value%”可以有效地使用索引。</li><li id="fa1f" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">索引覆盖排序字段，可以减少排序步骤，提高查询效率</li><li id="ca0c" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">尽可能扩展索引，除非必要，否则不要创建索引。比如表中已经有一个an的索引，现在需要增加一个<code class="fe nf ng nh ni b">(a, b)</code>的索引，那么只需要修改原来的索引就可以了。</li></ul><p id="c9a8" class="pw-post-body-paragraph mh mi it mj b mk na ju mm mn nb jx mp lw nc mr ms lz nd mu mv mc ne mx my mz im bi translated">例如:比如一个品牌表，建立的索引如下，主键索引，唯一索引。</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="cccd" class="lr la it ni b gy ob oc l od oe">PRIMARY KEY (`id`), UNIQUE KEY `uni_brand_define` (`app_id`,`define_id`)</span></pre><p id="7cdd" class="pw-post-body-paragraph mh mi it mj b mk na ju mm mn nb jx mp lw nc mr ms lz nd mu mv mc ne mx my mz im bi translated">当你同事的业务代码中的检索语句如下时，你应该马上得到警告，即没有覆盖索引，也没有遵循最左前缀原则:</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="b3ee" class="lr la it ni b gy ob oc l od oe">select brand_id,brand_name from ds_brand_system where status = ? and define_id = ? and app_id = ?</span></pre><p id="6b1c" class="pw-post-body-paragraph mh mi it mj b mk na ju mm mn nb jx mp lw nc mr ms lz nd mu mv mc ne mx my mz im bi translated">建议更改为:</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="e240" class="lr la it ni b gy ob oc l od oe">select brand_id, brand_name from ds_brand_system where app_id = ? and define_id = ? and status = ?</span></pre><h2 id="47d7" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.6受限设计规范</em></h2><ul class=""><li id="0057" class="nj nk it mj b mk ml mn mo lw nl lz nm mc nn mz no np nq nr bi translated">PK应该是有序的和无意义的，由开发人员定制，尽可能短，并在一个自动递增的序列。</li><li id="9c41" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">如果表中除PK外还有唯一约束，可以在数据库中创建前缀为<code class="fe nf ng nh ni b">uk_</code>的唯一约束索引。</li><li id="4b1d" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">不允许更新PK字段。</li><li id="0f5e" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">禁止创建由程序控制的外键约束。</li><li id="e582" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">如果没有特殊需要，所有字段都必须添加一个非空约束，即不能为空。</li><li id="c6ed" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">如果没有特殊需要，所有字段都必须有默认值。</li></ul><h1 id="3e69" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">SQL使用规范</h1><h2 id="4cef" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.1选择检索的规范性</em></h2><ul class=""><li id="a3b3" class="nj nk it mj b mk ml mn mo lw nl lz nm mc nn mz no np nq nr bi translated">尽量避免使用<code class="fe nf ng nh ni b">select *</code>。在join中使用<code class="fe nf ng nh ni b">select *</code>，语句可能会导致只需要访问索引就能完成的查询需要返回表中取数据。</li><li id="74c3" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">一个是检索大量不必要的数据，对于宽表来说是灾难；</li><li id="52e2" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">严禁在没有任何条件的情况下使用<code class="fe nf ng nh ni b">select * from t_name</code>。道理是一样的，会变成全表全场扫描。</li><li id="0794" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">MySQL中的文本类型字段存储:(a .)不与其他普通字段一起存储，因为读取效率低，而且还会影响其他轻量级字段的访问效率。(b .)如果不需要文本型字段，使用<code class="fe nf ng nh ni b">select *</code>，执行会消耗大量IO，效率很低。</li><li id="ecf9" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">可以使用相关函数来检索字段，但应尽量避免使用<code class="fe nf ng nh ni b">now(), rand(), sysdate()</code>等结果不确定的函数。严禁在Where条件中的筛选条件字段上使用任何函数，包括数据类型转换函数。大量的计算和转换会导致效率低下，这在索引中也有描述。</li><li id="930e" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">所有分页查询语句都需要有排序条件，否则，很容易造成混乱。</li><li id="e108" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">将<code class="fe nf ng nh ni b">or</code>换成<code class="fe nf ng nh ni b">in() / union()</code>，效率会更好，注意ins数量少于300</li><li id="40eb" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">严禁使用<code class="fe nf ng nh ni b">%</code>前缀进行模糊前缀查询:如:<code class="fe nf ng nh ni b">select a,b,c from t_name where a like '%name';</code>，可以使用<code class="fe nf ng nh ni b">%</code>模糊后缀查询如<code class="fe nf ng nh ni b">select a, b from t_name where a like 'name%';</code>。</li><li id="85c5" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">避免使用子查询，可以将子查询优化为<code class="fe nf ng nh ni b">join</code>操作。</li></ul><p id="aa9b" class="pw-post-body-paragraph mh mi it mj b mk na ju mm mn nb jx mp lw nc mr ms lz nd mu mv mc ne mx my mz im bi translated">通常情况下，当子查询在子句中，并且子查询是简单SQL(不包括<code class="fe nf ng nh ni b">union, group by, order by, limit</code>的子句)时，子查询可以转换为关联查询进行优化。</p><p id="f024" class="pw-post-body-paragraph mh mi it mj b mk na ju mm mn nb jx mp lw nc mr ms lz nd mu mv mc ne mx my mz im bi translated">子查询性能不佳的原因:</p><ul class=""><li id="ca2e" class="nj nk it mj b mk na mn nb lw os lz ot mc ou mz no np nq nr bi translated">子查询的结果集不能使用索引。通常，子查询的结果集将存储在临时表中。内存临时表和磁盘临时表都没有索引，所以查询性能会受到一定程度的影响。</li><li id="8951" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">尤其是对于返回大结果集的子查询，对查询性能的影响更大。</li><li id="8789" class="nj nk it mj b mk ns mn nt lw nu lz nv mc nw mz no np nq nr bi translated">由于子查询将生成大量临时表，并且没有索引，因此它将消耗太多的CPU和IO资源，从而导致大量缓慢的查询。</li></ul><h2 id="ae49" class="lr la it bd lb ls lt dn lf lu lv dp lj lw lx ly ll lz ma mb ln mc md me lp mf bi translated"><em class="mg"> 1.2规范操作</em></h2><p id="6f5a" class="pw-post-body-paragraph mh mi it mj b mk ml ju mm mn mo jx mp lw mq mr ms lz mt mu mv mc mw mx my mz im bi translated">禁止使用没有字段列表的INSERT语句。</p><p id="459f" class="pw-post-body-paragraph mh mi it mj b mk na ju mm mn nb jx mp lw nc mr ms lz nd mu mv mc ne mx my mz im bi translated">例如:<code class="fe nf ng nh ni b">insert into values ('a', 'b', 'c');</code>应使用<code class="fe nf ng nh ni b">insert into t_name(c1, c2, c3) values ('a', 'b', 'c');</code>。</p><p id="5a1b" class="pw-post-body-paragraph mh mi it mj b mk na ju mm mn nb jx mp lw nc mr ms lz nd mu mv mc ne mx my mz im bi translated">大容量写操作(更新、删除、插入)需要多个批处理操作。</p><p id="4916" class="pw-post-body-paragraph mh mi it mj b mk na ju mm mn nb jx mp lw nc mr ms lz nd mu mv mc ne mx my mz im bi translated">大批量操作可能会导致严重的主-次延迟，尤其是在主-次模式下，大批量操作可能会导致严重的主-次延迟，因为次映像需要从主映像的bin-log中读取日志以进行数据同步。</p><p id="218a" class="pw-post-body-paragraph mh mi it mj b mk na ju mm mn nb jx mp lw nc mr ms lz nd mu mv mc ne mx my mz im bi translated">当bin日志采用行格式时，会生成大量日志。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><p id="c5fb" class="pw-post-body-paragraph mh mi it mj b mk na ju mm mn nb jx mp lw nc mr ms lz nd mu mv mc ne mx my mz im bi translated"><em class="ov">感谢您阅读本文。</em></p><p id="bd4d" class="pw-post-body-paragraph mh mi it mj b mk na ju mm mn nb jx mp lw nc mr ms lz nd mu mv mc ne mx my mz im bi translated"><em class="ov">继续关注更多信息。</em></p></div></div>    
</body>
</html>